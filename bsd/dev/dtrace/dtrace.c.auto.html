<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>dtrace.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">dtrace.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or <a href="http://www.opensolaris.org/os/licensing.">http://www.opensolaris.org/os/licensing.</a>
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets &quot;[]&quot; replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */</span>

<span class="enscript-comment">/*
 * Portions Copyright (c) 2013, Joyent, Inc. All rights reserved.
 * Portions Copyright (c) 2013 by Delphix. All rights reserved.
 */</span>

<span class="enscript-comment">/*
 * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */</span>

<span class="enscript-comment">/* #pragma ident	&quot;@(#)dtrace.c	1.65	08/07/02 SMI&quot; */</span>

<span class="enscript-comment">/*
 * DTrace - Dynamic Tracing for Solaris
 *
 * This is the implementation of the Solaris Dynamic Tracing framework
 * (DTrace).  The user-visible interface to DTrace is described at length in
 * the &quot;Solaris Dynamic Tracing Guide&quot;.  The interfaces between the libdtrace
 * library, the in-kernel DTrace framework, and the DTrace providers are
 * described in the block comments in the &lt;sys/dtrace.h&gt; header file.  The
 * internal architecture of DTrace is described in the block comments in the
 * &lt;sys/dtrace_impl.h&gt; header file.  The comments contained within the DTrace
 * implementation very much assume mastery of all of these sources; if one has
 * an unanswered question about the implementation, one should consult them
 * first.
 *
 * The functions here are ordered roughly as follows:
 *
 *   - Probe context functions
 *   - Probe hashing functions
 *   - Non-probe context utility functions
 *   - Matching functions
 *   - Provider-to-Framework API functions
 *   - Probe management functions
 *   - DIF object functions
 *   - Format functions
 *   - Predicate functions
 *   - ECB functions
 *   - Buffer functions
 *   - Enabling functions
 *   - DOF functions
 *   - Anonymous enabling functions
 *   - Consumer state functions
 *   - Helper functions
 *   - Hook functions
 *   - Driver cookbook functions
 *
 * Each group of functions begins with a block comment labelled the &quot;DTrace
 * [Group] Functions&quot;, allowing one to find each block by searching forward
 * on capital-f functions.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace_impl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/devfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/exception_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ast.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_data.h&gt;</span>
<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">pmap_find_phys</span>(<span class="enscript-type">void</span> *, uint64_t);
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">pmap_valid_page</span>(uint32_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">OSKextRegisterKextsWithDTrace</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> kmod_info_t g_kernel_kmod_info;

<span class="enscript-comment">/* Solaris proc_t is the struct. Darwin's proc_t is a pointer to it. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">proc_t</span> struct proc <span class="enscript-comment">/* Steer clear of the Darwin typedef for proc_t */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">t_predcache</span> t_dtrace_predcache <span class="enscript-comment">/* Cosmetic. Helps readability of thread.h */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_suspend</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_resume</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">helper_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">fasttrap_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_lazy_dofs_duplicate</span>(proc_t *, proc_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_lazy_dofs_destroy</span>(proc_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_postinit</span>(<span class="enscript-type">void</span>);

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;../../../osfmk/chud/chud_dtrace.h&quot;</span>

<span class="enscript-type">extern</span> kern_return_t chudxnu_dtrace_callback
	(uint64_t selector, uint64_t *args, uint32_t count);

<span class="enscript-comment">/* Import this function to retrieve the physical memory. */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kernel_sysctlbyname</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">void</span> *oldp,
	size_t *oldlenp, <span class="enscript-type">void</span> *newp, size_t newlen);

<span class="enscript-comment">/*
 * DTrace Tunable Variables
 *
 * The following variables may be dynamically tuned by using sysctl(8), the
 * variables being stored in the kern.dtrace namespace.  For example:
 * 	sysctl kern.dtrace.dof_maxsize = 1048575 	# 1M
 *
 * In general, the only variables that one should be tuning this way are those
 * that affect system-wide DTrace behavior, and for which the default behavior
 * is undesirable.  Most of these variables are tunable on a per-consumer
 * basis using DTrace options, and need not be tuned on a system-wide basis.
 * When tuning these variables, avoid pathological values; while some attempt
 * is made to verify the integrity of these variables, they are not considered
 * part of the supported interface to DTrace, and they are therefore not
 * checked comprehensively.
 */</span>
uint64_t	dtrace_buffer_memory_maxsize = 0;		<span class="enscript-comment">/* initialized in dtrace_init */</span>
uint64_t	dtrace_buffer_memory_inuse = 0;
<span class="enscript-type">int</span>		dtrace_destructive_disallow = 0;
dtrace_optval_t	dtrace_nonroot_maxsize = (16 * 1024 * 1024);
size_t		dtrace_difo_maxsize = (256 * 1024);
dtrace_optval_t	dtrace_dof_maxsize = (384 * 1024);
size_t		dtrace_global_maxsize = (16 * 1024);
size_t		dtrace_actions_max = (16 * 1024);
size_t		dtrace_retain_max = 1024;
dtrace_optval_t	dtrace_helper_actions_max = 32;
dtrace_optval_t	dtrace_helper_providers_max = 64;
dtrace_optval_t	dtrace_dstate_defsize = (1 * 1024 * 1024);
size_t		dtrace_strsize_default = 256;
dtrace_optval_t	dtrace_cleanrate_default = 990099000;		<span class="enscript-comment">/* 1.1 hz */</span>
dtrace_optval_t	dtrace_cleanrate_min = 20000000;			<span class="enscript-comment">/* 50 hz */</span>
dtrace_optval_t	dtrace_cleanrate_max = (uint64_t)60 * NANOSEC;	<span class="enscript-comment">/* 1/minute */</span>
dtrace_optval_t	dtrace_aggrate_default = NANOSEC;		<span class="enscript-comment">/* 1 hz */</span>
dtrace_optval_t	dtrace_statusrate_default = NANOSEC;		<span class="enscript-comment">/* 1 hz */</span>
dtrace_optval_t dtrace_statusrate_max = (hrtime_t)10 * NANOSEC;	 <span class="enscript-comment">/* 6/minute */</span>
dtrace_optval_t	dtrace_switchrate_default = NANOSEC;		<span class="enscript-comment">/* 1 hz */</span>
dtrace_optval_t	dtrace_nspec_default = 1;
dtrace_optval_t	dtrace_specsize_default = 32 * 1024;
dtrace_optval_t dtrace_stackframes_default = 20;
dtrace_optval_t dtrace_ustackframes_default = 20;
dtrace_optval_t dtrace_jstackframes_default = 50;
dtrace_optval_t dtrace_jstackstrsize_default = 512;
<span class="enscript-type">int</span>		dtrace_msgdsize_max = 128;
hrtime_t	dtrace_chill_max = 500 * (NANOSEC / MILLISEC);	<span class="enscript-comment">/* 500 ms */</span>
hrtime_t	dtrace_chill_interval = NANOSEC;		<span class="enscript-comment">/* 1000 ms */</span>
<span class="enscript-type">int</span>		dtrace_devdepth_max = 32;
<span class="enscript-type">int</span>		dtrace_err_verbose;
<span class="enscript-type">int</span>		dtrace_provide_private_probes = 0;
hrtime_t	dtrace_deadman_interval = NANOSEC;
hrtime_t	dtrace_deadman_timeout = (hrtime_t)10 * NANOSEC;
hrtime_t	dtrace_deadman_user = (hrtime_t)30 * NANOSEC;

<span class="enscript-comment">/*
 * DTrace External Variables
 *
 * As dtrace(7D) is a kernel module, any DTrace variables are obviously
 * available to DTrace consumers via the backtick (`) syntax.  One of these,
 * dtrace_zero, is made deliberately so:  it is provided as a source of
 * well-known, zero-filled memory.  While this variable is not documented,
 * it is used by some translators as an implementation detail.
 */</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span>	dtrace_zero[256] = { 0 };	<span class="enscript-comment">/* zero-filled memory */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	dtrace_max_cpus = 0;		<span class="enscript-comment">/* number of enabled cpus */</span>
<span class="enscript-comment">/*
 * DTrace Internal Variables
 */</span>
<span class="enscript-type">static</span> dev_info_t	*dtrace_devi;		<span class="enscript-comment">/* device info */</span>
<span class="enscript-type">static</span> vmem_t		*dtrace_arena;		<span class="enscript-comment">/* probe ID arena */</span>
<span class="enscript-type">static</span> vmem_t		*dtrace_minor;		<span class="enscript-comment">/* minor number arena */</span>
<span class="enscript-type">static</span> taskq_t		*dtrace_taskq;		<span class="enscript-comment">/* task queue */</span>
<span class="enscript-type">static</span> dtrace_probe_t	**dtrace_probes;	<span class="enscript-comment">/* array of all probes */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		dtrace_nprobes;		<span class="enscript-comment">/* number of probes */</span>
<span class="enscript-type">static</span> dtrace_provider_t *dtrace_provider;	<span class="enscript-comment">/* provider list */</span>
<span class="enscript-type">static</span> dtrace_meta_t	*dtrace_meta_pid;	<span class="enscript-comment">/* user-land meta provider */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		dtrace_opens;		<span class="enscript-comment">/* number of opens */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		dtrace_helpers;		<span class="enscript-comment">/* number of helpers */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>		*dtrace_softstate;	<span class="enscript-comment">/* softstate pointer */</span>
<span class="enscript-type">static</span> dtrace_hash_t	*dtrace_bymod;		<span class="enscript-comment">/* probes hashed by module */</span>
<span class="enscript-type">static</span> dtrace_hash_t	*dtrace_byfunc;		<span class="enscript-comment">/* probes hashed by function */</span>
<span class="enscript-type">static</span> dtrace_hash_t	*dtrace_byname;		<span class="enscript-comment">/* probes hashed by name */</span>
<span class="enscript-type">static</span> dtrace_toxrange_t *dtrace_toxrange;	<span class="enscript-comment">/* toxic range array */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		dtrace_toxranges;	<span class="enscript-comment">/* number of toxic ranges */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		dtrace_toxranges_max;	<span class="enscript-comment">/* size of toxic range array */</span>
<span class="enscript-type">static</span> dtrace_anon_t	dtrace_anon;		<span class="enscript-comment">/* anonymous enabling */</span>
<span class="enscript-type">static</span> kmem_cache_t	*dtrace_state_cache;	<span class="enscript-comment">/* cache for dynamic state */</span>
<span class="enscript-type">static</span> uint64_t		dtrace_vtime_references; <span class="enscript-comment">/* number of vtimestamp refs */</span>
<span class="enscript-type">static</span> kthread_t	*dtrace_panicked;	<span class="enscript-comment">/* panicking thread */</span>
<span class="enscript-type">static</span> dtrace_ecb_t	*dtrace_ecb_create_cache; <span class="enscript-comment">/* cached created ECB */</span>
<span class="enscript-type">static</span> dtrace_genid_t	dtrace_probegen;	<span class="enscript-comment">/* current probe generation */</span>
<span class="enscript-type">static</span> dtrace_helpers_t *dtrace_deferred_pid;	<span class="enscript-comment">/* deferred helper list */</span>
<span class="enscript-type">static</span> dtrace_enabling_t *dtrace_retained;	<span class="enscript-comment">/* list of retained enablings */</span>
<span class="enscript-type">static</span> dtrace_genid_t   dtrace_retained_gen;    <span class="enscript-comment">/* current retained enab gen */</span>
<span class="enscript-type">static</span> dtrace_dynvar_t	dtrace_dynhash_sink;	<span class="enscript-comment">/* end of dynamic hash chains */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>		dtrace_dof_mode;	<span class="enscript-comment">/* See dtrace_impl.h for a description of Darwin's dof modes. */</span>

			<span class="enscript-comment">/*
			 * This does't quite fit as an internal variable, as it must be accessed in
			 * fbt_provide and sdt_provide. Its clearly not a dtrace tunable variable either...
			 */</span>
<span class="enscript-type">int</span>			dtrace_kernel_symbol_mode;	<span class="enscript-comment">/* See dtrace_impl.h for a description of Darwin's kernel symbol modes. */</span>


<span class="enscript-comment">/*
 * To save memory, some common memory allocations are given a
 * unique zone. For example, dtrace_probe_t is 72 bytes in size,
 * which means it would fall into the kalloc.128 bucket. With
 * 20k elements allocated, the space saved is substantial.
 */</span>

<span class="enscript-type">struct</span> zone *dtrace_probe_t_zone;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_module_unloaded</span>(<span class="enscript-type">struct</span> kmod_info *kmod);

<span class="enscript-comment">/*
 * DTrace Locking
 * DTrace is protected by three (relatively coarse-grained) locks:
 *
 * (1) dtrace_lock is required to manipulate essentially any DTrace state,
 *     including enabling state, probes, ECBs, consumer state, helper state,
 *     etc.  Importantly, dtrace_lock is _not_ required when in probe context;
 *     probe context is lock-free -- synchronization is handled via the
 *     dtrace_sync() cross call mechanism.
 *
 * (2) dtrace_provider_lock is required when manipulating provider state, or
 *     when provider state must be held constant.
 *
 * (3) dtrace_meta_lock is required when manipulating meta provider state, or
 *     when meta provider state must be held constant.
 *
 * The lock ordering between these three locks is dtrace_meta_lock before
 * dtrace_provider_lock before dtrace_lock.  (In particular, there are
 * several places where dtrace_provider_lock is held by the framework as it
 * calls into the providers -- which then call back into the framework,
 * grabbing dtrace_lock.)
 *
 * There are two other locks in the mix:  mod_lock and cpu_lock.  With respect
 * to dtrace_provider_lock and dtrace_lock, cpu_lock continues its historical
 * role as a coarse-grained lock; it is acquired before both of these locks.
 * With respect to dtrace_meta_lock, its behavior is stranger:  cpu_lock must
 * be acquired _between_ dtrace_meta_lock and any other DTrace locks.
 * mod_lock is similar with respect to dtrace_provider_lock in that it must be
 * acquired _between_ dtrace_provider_lock and dtrace_lock.
 */</span>


<span class="enscript-comment">/*
 * APPLE NOTE:
 *
 * For porting purposes, all kmutex_t vars have been changed
 * to lck_mtx_t, which require explicit initialization.
 *
 * kmutex_t becomes lck_mtx_t
 * mutex_enter() becomes lck_mtx_lock()
 * mutex_exit() becomes lck_mtx_unlock()
 *
 * Lock asserts are changed like this:
 *
 * ASSERT(MUTEX_HELD(&amp;cpu_lock));
 *	becomes:
 * lck_mtx_assert(&amp;cpu_lock, LCK_MTX_ASSERT_OWNED);
 *
 */</span>
<span class="enscript-type">static</span> lck_mtx_t	dtrace_lock;		<span class="enscript-comment">/* probe state lock */</span>
<span class="enscript-type">static</span> lck_mtx_t	dtrace_provider_lock;	<span class="enscript-comment">/* provider state lock */</span>
<span class="enscript-type">static</span> lck_mtx_t	dtrace_meta_lock;	<span class="enscript-comment">/* meta-provider state lock */</span>
<span class="enscript-type">static</span> lck_rw_t		dtrace_dof_mode_lock;	<span class="enscript-comment">/* dof mode lock */</span>

<span class="enscript-comment">/*
 * DTrace Provider Variables
 *
 * These are the variables relating to DTrace as a provider (that is, the
 * provider of the BEGIN, END, and ERROR probes).
 */</span>
<span class="enscript-type">static</span> dtrace_pattr_t	dtrace_provider_attr = {
{ DTRACE_STABILITY_STABLE, DTRACE_STABILITY_STABLE, DTRACE_CLASS_COMMON },
{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
{ DTRACE_STABILITY_STABLE, DTRACE_STABILITY_STABLE, DTRACE_CLASS_COMMON },
{ DTRACE_STABILITY_STABLE, DTRACE_STABILITY_STABLE, DTRACE_CLASS_COMMON },
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_nullop</span>(<span class="enscript-type">void</span>)
{}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_enable_nullop</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> dtrace_pops_t	dtrace_provider_ops = {
	(<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *, <span class="enscript-type">const</span> dtrace_probedesc_t *))dtrace_nullop,
	(<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *, <span class="enscript-type">struct</span> modctl *))dtrace_nullop,
	(<span class="enscript-type">int</span> (*)(<span class="enscript-type">void</span> *, dtrace_id_t, <span class="enscript-type">void</span> *))dtrace_enable_nullop,
	(<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *, dtrace_id_t, <span class="enscript-type">void</span> *))dtrace_nullop,
	(<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *, dtrace_id_t, <span class="enscript-type">void</span> *))dtrace_nullop,
	(<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *, dtrace_id_t, <span class="enscript-type">void</span> *))dtrace_nullop,
	NULL,
	NULL,
	NULL,
	(<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *, dtrace_id_t, <span class="enscript-type">void</span> *))dtrace_nullop
};

<span class="enscript-type">static</span> dtrace_id_t	dtrace_probeid_begin;	<span class="enscript-comment">/* special BEGIN probe */</span>
<span class="enscript-type">static</span> dtrace_id_t	dtrace_probeid_end;	<span class="enscript-comment">/* special END probe */</span>
dtrace_id_t		dtrace_probeid_error;	<span class="enscript-comment">/* special ERROR probe */</span>

<span class="enscript-comment">/*
 * DTrace Helper Tracing Variables
 */</span>
uint32_t dtrace_helptrace_next = 0;
uint32_t dtrace_helptrace_nlocals;
<span class="enscript-type">char</span>	*dtrace_helptrace_buffer;
size_t	dtrace_helptrace_bufsize = 512 * 1024;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">int</span>	dtrace_helptrace_enabled = 1;
#<span class="enscript-reference">else</span>
<span class="enscript-type">int</span>	dtrace_helptrace_enabled = 0;
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*
 * DTrace Error Hashing
 *
 * On DEBUG kernels, DTrace will track the errors that has seen in a hash
 * table.  This is very useful for checking coverage of tests that are
 * expected to induce DIF or DOF processing errors, and may be useful for
 * debugging problems in the DIF code generator or in DOF generation .  The
 * error hash may be examined with the ::dtrace_errhash MDB dcmd.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> dtrace_errhash_t	dtrace_errhash[DTRACE_ERRHASHSZ];
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *dtrace_errlast;
<span class="enscript-type">static</span> kthread_t *dtrace_errthread;
<span class="enscript-type">static</span> lck_mtx_t dtrace_errlock;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * DTrace Macros and Constants
 *
 * These are various macros that are useful in various spots in the
 * implementation, along with a few random constants that have no meaning
 * outside of the implementation.  There is no real structure to this cpp
 * mishmash -- but is there ever?
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACE_HASHSTR</span>(hash, probe)	\
	dtrace_hash_str(*((<span class="enscript-type">char</span> **)((uintptr_t)(probe) + (hash)-&gt;dth_stroffs)))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACE_HASHNEXT</span>(hash, probe)	\
	(dtrace_probe_t **)((uintptr_t)(probe) + (hash)-&gt;dth_nextoffs)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACE_HASHPREV</span>(hash, probe)	\
	(dtrace_probe_t **)((uintptr_t)(probe) + (hash)-&gt;dth_prevoffs)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACE_HASHEQ</span>(hash, lhs, rhs)	\
	(strcmp(*((<span class="enscript-type">char</span> **)((uintptr_t)(lhs) + (hash)-&gt;dth_stroffs)), \
	    *((<span class="enscript-type">char</span> **)((uintptr_t)(rhs) + (hash)-&gt;dth_stroffs))) == 0)

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_AGGHASHSIZE_SLEW</span>		17

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_V4MAPPED_OFFSET</span>		(sizeof (uint32_t) * 3)

<span class="enscript-comment">/*
 * The key for a thread-local variable consists of the lower 61 bits of the
 * current_thread(), plus the 3 bits of the highest active interrupt above LOCK_LEVEL.
 * We add DIF_VARIABLE_MAX to t_did to assure that the thread key is never
 * equal to a variable identifier.  This is necessary (but not sufficient) to
 * assure that global associative arrays never collide with thread-local
 * variables.  To guarantee that they cannot collide, we must also define the
 * order for keying dynamic variables.  That order is:
 *
 *   [ key0 ] ... [ keyn ] [ variable-key ] [ tls-key ]
 *
 * Because the variable-key and the tls-key are in orthogonal spaces, there is
 * no way for a global variable key signature to match a thread-local key
 * signature.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-comment">/* FIXME: two function calls!! */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACE_TLS_THRKEY</span>(where) { \
	uint_t intr = ml_at_interrupt_context(); <span class="enscript-comment">/* Note: just one measly bit */</span> \
	uint64_t thr = (uintptr_t)current_thread(); \
	ASSERT(intr &lt; (1 &lt;&lt; 3)); \
	(where) = ((thr + DIF_VARIABLE_MAX) &amp; \
	    (((uint64_t)1 &lt;&lt; 61) - 1)) | ((uint64_t)intr &lt;&lt; 61); \
}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unknown</span> <span class="enscript-variable-name">architecture</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DT_BSWAP_8</span>(x)	((x) &amp; 0xff)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DT_BSWAP_16</span>(x)	((DT_BSWAP_8(x) &lt;&lt; 8) | DT_BSWAP_8((x) &gt;&gt; 8))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DT_BSWAP_32</span>(x)	((DT_BSWAP_16(x) &lt;&lt; 16) | DT_BSWAP_16((x) &gt;&gt; 16))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DT_BSWAP_64</span>(x)	((DT_BSWAP_32(x) &lt;&lt; 32) | DT_BSWAP_32((x) &gt;&gt; 32))

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DT_MASK_LO</span> 0x00000000FFFFFFFFULL

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACE_STORE</span>(type, tomax, offset, what) \
	*((type *)((uintptr_t)(tomax) + (uintptr_t)offset)) = (type)(what);


#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACE_ALIGNCHECK</span>(addr, size, flags)				\
	<span class="enscript-keyword">if</span> (addr &amp; (MIN(size,4) - 1)) {					\
		*flags |= CPU_DTRACE_BADALIGN;				\
		cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_illval = addr;	\
		<span class="enscript-keyword">return</span> (0);						\
	}

<span class="enscript-comment">/*
 * Test whether a range of memory starting at testaddr of size testsz falls
 * within the range of memory described by addr, sz.  We take care to avoid
 * problems with overflow and underflow of the unsigned quantities, and
 * disallow all negative sizes.  Ranges of size 0 are allowed.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACE_INRANGE</span>(testaddr, testsz, baseaddr, basesz) \
	((testaddr) - (baseaddr) &lt; (basesz) &amp;&amp; \
	(testaddr) + (testsz) - (baseaddr) &lt;= (basesz) &amp;&amp; \
	(testaddr) + (testsz) &gt;= (testaddr))

<span class="enscript-comment">/*
 * Test whether alloc_sz bytes will fit in the scratch region.  We isolate
 * alloc_sz on the righthand side of the comparison in order to avoid overflow
 * or underflow in the comparison with it.  This is simpler than the INRANGE
 * check above, because we know that the dtms_scratch_ptr is valid in the
 * range.  Allocations of size zero are allowed.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACE_INSCRATCH</span>(mstate, alloc_sz) \
	((mstate)-&gt;dtms_scratch_base + (mstate)-&gt;dtms_scratch_size - \
	(mstate)-&gt;dtms_scratch_ptr &gt;= (alloc_sz))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">RECOVER_LABEL</span>(bits) dtraceLoadRecover##bits:

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACE_LOADFUNC</span>(bits)						\
<span class="enscript-comment">/*CSTYLED*/</span>								\
uint##bits##_t dtrace_load##bits(uintptr_t addr);			\
									\
uint##bits##_t								\
dtrace_load##bits(uintptr_t addr)					\
{									\
	size_t size = bits / NBBY;					\
	<span class="enscript-comment">/*CSTYLED*/</span>							\
	uint##bits##_t rval = 0;					\
	<span class="enscript-type">int</span> i;								\
	<span class="enscript-type">volatile</span> uint16_t *flags = (<span class="enscript-type">volatile</span> uint16_t *)		\
	    &amp;cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags;			\
									\
	DTRACE_ALIGNCHECK(addr, size, flags);				\
									\
	<span class="enscript-keyword">for</span> (i = 0; i &lt; dtrace_toxranges; i++) {			\
		<span class="enscript-keyword">if</span> (addr &gt;= dtrace_toxrange[i].dtt_limit)		\
			<span class="enscript-keyword">continue</span>;					\
									\
		<span class="enscript-keyword">if</span> (addr + size &lt;= dtrace_toxrange[i].dtt_base)		\
			<span class="enscript-keyword">continue</span>;					\
									\
		<span class="enscript-comment">/*							\
		 * This address falls within a toxic region; return 0.	\
		 */</span>							\
		*flags |= CPU_DTRACE_BADADDR;				\
		cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_illval = addr;	\
		<span class="enscript-keyword">return</span> (0);						\
	}								\
									\
	{								\
	<span class="enscript-type">volatile</span> vm_offset_t recover = (vm_offset_t)&amp;&amp;dtraceLoadRecover##bits;		\
	*flags |= CPU_DTRACE_NOFAULT;					\
	recover = dtrace_set_thread_recover(current_thread(), recover);	\
	<span class="enscript-comment">/*CSTYLED*/</span>							\
	<span class="enscript-comment">/*                                                              \
	* PR6394061 - avoid device memory that is unpredictably		\
	* mapped and unmapped                                   	\
	*/</span>								\
        <span class="enscript-keyword">if</span> (pmap_valid_page(pmap_find_phys(kernel_pmap, addr)))		\
	    rval = *((<span class="enscript-type">volatile</span> uint##bits##_t *)addr);			\
	RECOVER_LABEL(bits);						\
	(<span class="enscript-type">void</span>)dtrace_set_thread_recover(current_thread(), recover);	\
	*flags &amp;= ~CPU_DTRACE_NOFAULT;					\
	}								\
									\
	<span class="enscript-keyword">return</span> (rval);							\
}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* all other architectures */</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unknown</span> <span class="enscript-variable-name">Architecture</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">dtrace_loadptr</span>	dtrace_load64
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">dtrace_loadptr</span>	dtrace_load32
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_DYNHASH_FREE</span>	0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_DYNHASH_SINK</span>	1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_DYNHASH_VALID</span>	2

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_MATCH_FAIL</span>       -1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MATCH_NEXT</span>	0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_MATCH_DONE</span>	1
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACE_ANCHORED</span>(probe)	((probe)-&gt;dtpr_func[0] != <span class="enscript-string">'\0'</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DTRACE_STATE_ALIGN</span>	64

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACE_FLAGS2FLT</span>(flags)						\
	(((flags) &amp; CPU_DTRACE_BADADDR) ? DTRACEFLT_BADADDR :		\
	((flags) &amp; CPU_DTRACE_ILLOP) ? DTRACEFLT_ILLOP :		\
	((flags) &amp; CPU_DTRACE_DIVZERO) ? DTRACEFLT_DIVZERO :		\
	((flags) &amp; CPU_DTRACE_KPRIV) ? DTRACEFLT_KPRIV :		\
	((flags) &amp; CPU_DTRACE_UPRIV) ? DTRACEFLT_UPRIV :		\
	((flags) &amp; CPU_DTRACE_TUPOFLOW) ?  DTRACEFLT_TUPOFLOW :		\
	((flags) &amp; CPU_DTRACE_BADALIGN) ?  DTRACEFLT_BADALIGN :		\
	((flags) &amp; CPU_DTRACE_NOSCRATCH) ?  DTRACEFLT_NOSCRATCH :	\
	((flags) &amp; CPU_DTRACE_BADSTACK) ?  DTRACEFLT_BADSTACK :		\
	DTRACEFLT_UNKNOWN)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACEACT_ISSTRING</span>(act)						\
	((act)-&gt;dta_kind == DTRACEACT_DIFEXPR &amp;&amp;			\
	(act)-&gt;dta_difo-&gt;dtdo_rtype.dtdt_kind == DIF_TYPE_STRING)


<span class="enscript-type">static</span> size_t <span class="enscript-function-name">dtrace_strlen</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, size_t);
<span class="enscript-type">static</span> dtrace_probe_t *<span class="enscript-function-name">dtrace_probe_lookup_id</span>(dtrace_id_t id);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_enabling_provide</span>(dtrace_provider_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_enabling_match</span>(dtrace_enabling_t *, <span class="enscript-type">int</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_enabling_matchall</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> dtrace_state_t *<span class="enscript-function-name">dtrace_anon_grab</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> uint64_t <span class="enscript-function-name">dtrace_helper</span>(<span class="enscript-type">int</span>, dtrace_mstate_t *,
    dtrace_state_t *, uint64_t, uint64_t);
<span class="enscript-type">static</span> dtrace_helpers_t *<span class="enscript-function-name">dtrace_helpers_create</span>(proc_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_buffer_drop</span>(dtrace_buffer_t *);
<span class="enscript-type">static</span> intptr_t <span class="enscript-function-name">dtrace_buffer_reserve</span>(dtrace_buffer_t *, size_t, size_t,
    dtrace_state_t *, dtrace_mstate_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_state_option</span>(dtrace_state_t *, dtrace_optid_t,
    dtrace_optval_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dtrace_ecb_create_enable</span>(dtrace_probe_t *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_helper_provider_destroy</span>(dtrace_helper_provider_t *);


<span class="enscript-comment">/*
 * DTrace sysctl handlers
 *
 * These declarations and functions are used for a deeper DTrace configuration.
 * Most of them are not per-consumer basis and may impact the other DTrace
 * consumers.  Correctness may not be supported for all the variables, so you
 * should be careful about what values you are using.
 */</span>

<span class="enscript-function-name">SYSCTL_DECL</span>(_kern_dtrace);
<span class="enscript-function-name">SYSCTL_NODE</span>(_kern, OID_AUTO, dtrace, CTLFLAG_RW | CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;dtrace&quot;</span>); 

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_dtrace_err_verbose SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> changed, error;
	<span class="enscript-type">int</span> value = *(<span class="enscript-type">int</span> *) arg1;

	error = sysctl_io_number(req, value, <span class="enscript-keyword">sizeof</span>(value), &amp;value, &amp;changed);
	<span class="enscript-keyword">if</span> (error || !changed)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (value != 0 &amp;&amp; value != 1)
		<span class="enscript-keyword">return</span> (ERANGE);

	lck_mtx_lock(&amp;dtrace_lock);
		dtrace_err_verbose = value;
	lck_mtx_unlock(&amp;dtrace_lock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * kern.dtrace.err_verbose
 *
 * Set DTrace verbosity when an error occured (0 = disabled, 1 = enabld).
 * Errors are reported when a DIFO or a DOF has been rejected by the kernel.
 */</span>
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_dtrace, OID_AUTO, err_verbose,
	CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;dtrace_err_verbose, 0,
	sysctl_dtrace_err_verbose, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;dtrace error verbose&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_dtrace_buffer_memory_maxsize SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg2</span>, <span class="enscript-variable-name">req</span>)
	<span class="enscript-type">int</span> changed, error;
	uint64_t value = *(uint64_t *) arg1;

	error = sysctl_io_number(req, value, <span class="enscript-keyword">sizeof</span>(value), &amp;value, &amp;changed);
	<span class="enscript-keyword">if</span> (error || !changed)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (value &lt;= dtrace_buffer_memory_inuse)
		<span class="enscript-keyword">return</span> (ERANGE);

	lck_mtx_lock(&amp;dtrace_lock);
		dtrace_buffer_memory_maxsize = value;	
	lck_mtx_unlock(&amp;dtrace_lock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * kern.dtrace.buffer_memory_maxsize
 *
 * Set DTrace maximal size in bytes used by all the consumers' state buffers.  By default
 * the limit is PHYS_MEM / 3 for *all* consumers.  Attempting to set a null, a negative value
 * or a value &lt;= to dtrace_buffer_memory_inuse will result in a failure.
 */</span>
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_dtrace, OID_AUTO, buffer_memory_maxsize,
	CTLTYPE_QUAD | CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;dtrace_buffer_memory_maxsize, 0,
	sysctl_dtrace_buffer_memory_maxsize, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;dtrace state buffer memory maxsize&quot;</span>);

<span class="enscript-comment">/*
 * kern.dtrace.buffer_memory_inuse
 *
 * Current state buffer memory used, in bytes, by all the DTrace consumers.
 * This value is read-only.
 */</span>
<span class="enscript-function-name">SYSCTL_QUAD</span>(_kern_dtrace, OID_AUTO, buffer_memory_inuse, CTLFLAG_RD | CTLFLAG_LOCKED,
	&amp;dtrace_buffer_memory_inuse, <span class="enscript-string">&quot;dtrace state buffer memory in-use&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_dtrace_difo_maxsize SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg2</span>, <span class="enscript-variable-name">req</span>)
	<span class="enscript-type">int</span> changed, error;
	size_t value = *(size_t*) arg1;

	error = sysctl_io_number(req, value, <span class="enscript-keyword">sizeof</span>(value), &amp;value, &amp;changed);
	<span class="enscript-keyword">if</span> (error || !changed)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (value &lt;= 0)
		<span class="enscript-keyword">return</span> (ERANGE);

	lck_mtx_lock(&amp;dtrace_lock);
		dtrace_difo_maxsize = value;
	lck_mtx_unlock(&amp;dtrace_lock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * kern.dtrace.difo_maxsize
 *
 * Set the DIFO max size in bytes, check the definition of dtrace_difo_maxsize
 * to get the default value.  Attempting to set a null or negative size will
 * result in a failure.
 */</span>
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_dtrace, OID_AUTO, difo_maxsize,
	CTLTYPE_QUAD | CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;dtrace_difo_maxsize, 0,
	sysctl_dtrace_difo_maxsize, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;dtrace difo maxsize&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_dtrace_dof_maxsize SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg2</span>, <span class="enscript-variable-name">req</span>)
	<span class="enscript-type">int</span> changed, error;
	dtrace_optval_t value = *(dtrace_optval_t *) arg1;

	error = sysctl_io_number(req, value, <span class="enscript-keyword">sizeof</span>(value), &amp;value, &amp;changed);
	<span class="enscript-keyword">if</span> (error || !changed)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (value &lt;= 0)
		<span class="enscript-keyword">return</span> (ERANGE);

	lck_mtx_lock(&amp;dtrace_lock);
		dtrace_dof_maxsize = value;
	lck_mtx_unlock(&amp;dtrace_lock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * kern.dtrace.dof_maxsize
 *
 * Set the DOF max size in bytes, check the definition of dtrace_dof_maxsize to
 * get the default value.  Attempting to set a null or negative size will result
 * in a failure.
 */</span>
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_dtrace, OID_AUTO, dof_maxsize,
	CTLTYPE_QUAD | CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;dtrace_dof_maxsize, 0,
	sysctl_dtrace_dof_maxsize, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;dtrace dof maxsize&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_dtrace_global_maxsize SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg2</span>, <span class="enscript-variable-name">req</span>)
	<span class="enscript-type">int</span> changed, error;
	dtrace_optval_t value = *(dtrace_optval_t*) arg1;

	error = sysctl_io_number(req, value, <span class="enscript-keyword">sizeof</span>(value), &amp;value, &amp;changed);
	<span class="enscript-keyword">if</span> (error || !changed)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (value &lt;= 0)
		<span class="enscript-keyword">return</span> (ERANGE);

	lck_mtx_lock(&amp;dtrace_lock);
		dtrace_global_maxsize = value;
	lck_mtx_unlock(&amp;dtrace_lock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * kern.dtrace.global_maxsize
 *
 * Set the global variable max size in bytes, check the definition of
 * dtrace_global_maxsize to get the default value.  Attempting to set a null or
 * negative size will result in a failure.
 */</span>
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_dtrace, OID_AUTO, global_maxsize,
	CTLTYPE_QUAD | CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;dtrace_global_maxsize, 0,
	sysctl_dtrace_global_maxsize, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;dtrace global maxsize&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_dtrace_provide_private_probes SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> value = *(<span class="enscript-type">int</span> *) arg1;

	error = sysctl_io_number(req, value, <span class="enscript-keyword">sizeof</span>(value), &amp;value, NULL);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (value != 0 &amp;&amp; value != 1)
		<span class="enscript-keyword">return</span> (ERANGE);

	lck_mtx_lock(&amp;dtrace_lock);
		dtrace_provide_private_probes = value;
	lck_mtx_unlock(&amp;dtrace_lock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * kern.dtrace.provide_private_probes
 *
 * Set whether the providers must provide the private probes.  This is
 * mainly used by the FBT provider to request probes for the private/static
 * symbols.
 */</span>
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_dtrace, OID_AUTO, provide_private_probes,
	CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;dtrace_provide_private_probes, 0,
	sysctl_dtrace_provide_private_probes, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;provider must provide the private probes&quot;</span>);

<span class="enscript-comment">/*
 * DTrace Probe Context Functions
 *
 * These functions are called from probe context.  Because probe context is
 * any context in which C may be called, arbitrarily locks may be held,
 * interrupts may be disabled, we may be in arbitrary dispatched state, etc.
 * As a result, functions called from probe context may only call other DTrace
 * support functions -- they may not interact at all with the system at large.
 * (Note that the ASSERT macro is made probe-context safe by redefining it in
 * terms of dtrace_assfail(), a probe-context safe function.) If arbitrary
 * loads are to be performed from probe context, they _must_ be in terms of
 * the safe dtrace_load*() variants.
 *
 * Some functions in this block are not actually called from probe context;
 * for these functions, there will be a comment above the function reading
 * &quot;Note:  not called from probe context.&quot;
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_assfail</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *a, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *f, <span class="enscript-type">int</span> l)
{
	panic(<span class="enscript-string">&quot;dtrace: assertion failed: %s, file: %s, line: %d&quot;</span>, a, f, l);

	<span class="enscript-comment">/*
	 * We just need something here that even the most clever compiler
	 * cannot optimize away.
	 */</span>
	<span class="enscript-keyword">return</span> (a[(uintptr_t)f]);
}

<span class="enscript-comment">/*
 * Atomically increment a specified error counter from probe context.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_error</span>(uint32_t *counter)
{
	<span class="enscript-comment">/*
	 * Most counters stored to in probe context are per-CPU counters.
	 * However, there are some error conditions that are sufficiently
	 * arcane that they don't merit per-CPU storage.  If these counters
	 * are incremented concurrently on different CPUs, scalability will be
	 * adversely affected -- but we don't expect them to be white-hot in a
	 * correctly constructed enabling...
	 */</span>
	uint32_t oval, nval;

	<span class="enscript-keyword">do</span> {
		oval = *counter;

		<span class="enscript-keyword">if</span> ((nval = oval + 1) == 0) {
			<span class="enscript-comment">/*
			 * If the counter would wrap, set it to 1 -- assuring
			 * that the counter is never zero when we have seen
			 * errors.  (The counter must be 32-bits because we
			 * aren't guaranteed a 64-bit compare&amp;swap operation.)
			 * To save this code both the infamy of being fingered
			 * by a priggish news story and the indignity of being
			 * the target of a neo-puritan witch trial, we're
			 * carefully avoiding any colorful description of the
			 * likelihood of this condition -- but suffice it to
			 * say that it is only slightly more likely than the
			 * overflow of predicate cache IDs, as discussed in
			 * dtrace_predicate_create().
			 */</span>
			nval = 1;
		}
	} <span class="enscript-keyword">while</span> (dtrace_cas32(counter, oval, nval) != oval);
}

<span class="enscript-comment">/*
 * Use the DTRACE_LOADFUNC macro to define functions for each of loading a
 * uint8_t, a uint16_t, a uint32_t and a uint64_t.
 */</span>
<span class="enscript-function-name">DTRACE_LOADFUNC</span>(8)
<span class="enscript-function-name">DTRACE_LOADFUNC</span>(16)
<span class="enscript-function-name">DTRACE_LOADFUNC</span>(32)
<span class="enscript-function-name">DTRACE_LOADFUNC</span>(64)

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_inscratch</span>(uintptr_t dest, size_t size, dtrace_mstate_t *mstate)
{
	<span class="enscript-keyword">if</span> (dest &lt; mstate-&gt;dtms_scratch_base)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (dest + size &lt; dest)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (dest + size &gt; mstate-&gt;dtms_scratch_ptr)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_canstore_statvar</span>(uint64_t addr, size_t sz,
    dtrace_statvar_t **svars, <span class="enscript-type">int</span> nsvars)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; nsvars; i++) {
		dtrace_statvar_t *svar = svars[i];

		<span class="enscript-keyword">if</span> (svar == NULL || svar-&gt;dtsv_size == 0)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (DTRACE_INRANGE(addr, sz, svar-&gt;dtsv_data, svar-&gt;dtsv_size))
			<span class="enscript-keyword">return</span> (1);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Check to see if the address is within a memory region to which a store may
 * be issued.  This includes the DTrace scratch areas, and any DTrace variable
 * region.  The caller of dtrace_canstore() is responsible for performing any
 * alignment checks that are needed before stores are actually executed.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_canstore</span>(uint64_t addr, size_t sz, dtrace_mstate_t *mstate,
    dtrace_vstate_t *vstate)
{
	<span class="enscript-comment">/*
	 * First, check to see if the address is in scratch space...
	 */</span>
	<span class="enscript-keyword">if</span> (DTRACE_INRANGE(addr, sz, mstate-&gt;dtms_scratch_base,
	    mstate-&gt;dtms_scratch_size))
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-comment">/*
	 * Now check to see if it's a dynamic variable.  This check will pick
	 * up both thread-local variables and any global dynamically-allocated
	 * variables.
	 */</span>
	<span class="enscript-keyword">if</span> (DTRACE_INRANGE(addr, sz, (uintptr_t)vstate-&gt;dtvs_dynvars.dtds_base,
	    vstate-&gt;dtvs_dynvars.dtds_size)) {
		dtrace_dstate_t *dstate = &amp;vstate-&gt;dtvs_dynvars;
		uintptr_t base = (uintptr_t)dstate-&gt;dtds_base +
		    (dstate-&gt;dtds_hashsize * <span class="enscript-keyword">sizeof</span> (dtrace_dynhash_t));
		uintptr_t chunkoffs;

		<span class="enscript-comment">/*
		 * Before we assume that we can store here, we need to make
		 * sure that it isn't in our metadata -- storing to our
		 * dynamic variable metadata would corrupt our state.  For
		 * the range to not include any dynamic variable metadata,
		 * it must:
		 *
		 *	(1) Start above the hash table that is at the base of
		 *	the dynamic variable space
		 *
		 *	(2) Have a starting chunk offset that is beyond the
		 *	dtrace_dynvar_t that is at the base of every chunk
		 *
		 *	(3) Not span a chunk boundary
		 *
		 */</span>
		<span class="enscript-keyword">if</span> (addr &lt; base)
			<span class="enscript-keyword">return</span> (0);

		chunkoffs = (addr - base) % dstate-&gt;dtds_chunksize;

		<span class="enscript-keyword">if</span> (chunkoffs &lt; <span class="enscript-keyword">sizeof</span> (dtrace_dynvar_t))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">if</span> (chunkoffs + sz &gt; dstate-&gt;dtds_chunksize)
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">return</span> (1);
	}

	<span class="enscript-comment">/*
	 * Finally, check the static local and global variables.  These checks
	 * take the longest, so we perform them last.
	 */</span>
	<span class="enscript-keyword">if</span> (dtrace_canstore_statvar(addr, sz,
	    vstate-&gt;dtvs_locals, vstate-&gt;dtvs_nlocals))
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">if</span> (dtrace_canstore_statvar(addr, sz,
	    vstate-&gt;dtvs_globals, vstate-&gt;dtvs_nglobals))
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Convenience routine to check to see if the address is within a memory
 * region in which a load may be issued given the user's privilege level;
 * if not, it sets the appropriate error flags and loads 'addr' into the
 * illegal value slot.
 *
 * DTrace subroutines (DIF_SUBR_*) should use this helper to implement
 * appropriate memory access protection.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_canload</span>(uint64_t addr, size_t sz, dtrace_mstate_t *mstate,
    dtrace_vstate_t *vstate)
{
	<span class="enscript-type">volatile</span> uint64_t *illval = &amp;cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_illval;

	<span class="enscript-comment">/*
	 * If we hold the privilege to read from kernel memory, then
	 * everything is readable.
	 */</span>
	<span class="enscript-keyword">if</span> ((mstate-&gt;dtms_access &amp; DTRACE_ACCESS_KERNEL) != 0)
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-comment">/*
	 * You can obviously read that which you can store.
	 */</span>
	<span class="enscript-keyword">if</span> (dtrace_canstore(addr, sz, mstate, vstate))
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-comment">/*
	 * We're allowed to read from our own string table.
	 */</span>
	<span class="enscript-keyword">if</span> (DTRACE_INRANGE(addr, sz, (uintptr_t)mstate-&gt;dtms_difo-&gt;dtdo_strtab,
	    mstate-&gt;dtms_difo-&gt;dtdo_strlen))
		<span class="enscript-keyword">return</span> (1);

	DTRACE_CPUFLAG_SET(CPU_DTRACE_KPRIV);
	*illval = addr;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Convenience routine to check to see if a given string is within a memory
 * region in which a load may be issued given the user's privilege level;
 * this exists so that we don't need to issue unnecessary dtrace_strlen()
 * calls in the event that the user has all privileges.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_strcanload</span>(uint64_t addr, size_t sz, dtrace_mstate_t *mstate,
    dtrace_vstate_t *vstate)
{
	size_t strsz;

	<span class="enscript-comment">/*
	 * If we hold the privilege to read from kernel memory, then
	 * everything is readable.
	 */</span>
	<span class="enscript-keyword">if</span> ((mstate-&gt;dtms_access &amp; DTRACE_ACCESS_KERNEL) != 0)
		<span class="enscript-keyword">return</span> (1);

	strsz = 1 + dtrace_strlen((<span class="enscript-type">char</span> *)(uintptr_t)addr, sz);
	<span class="enscript-keyword">if</span> (dtrace_canload(addr, strsz, mstate, vstate))
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Convenience routine to check to see if a given variable is within a memory
 * region in which a load may be issued given the user's privilege level.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_vcanload</span>(<span class="enscript-type">void</span> *src, dtrace_diftype_t *type, dtrace_mstate_t *mstate,
    dtrace_vstate_t *vstate)
{
	size_t sz;
	ASSERT(type-&gt;dtdt_flags &amp; DIF_TF_BYREF);

	<span class="enscript-comment">/*
	 * If we hold the privilege to read from kernel memory, then
	 * everything is readable.
	 */</span>
	<span class="enscript-keyword">if</span> ((mstate-&gt;dtms_access &amp; DTRACE_ACCESS_KERNEL) != 0)
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">if</span> (type-&gt;dtdt_kind == DIF_TYPE_STRING)
		sz = dtrace_strlen(src,
		    vstate-&gt;dtvs_state-&gt;dts_options[DTRACEOPT_STRSIZE]) + 1;
	<span class="enscript-keyword">else</span>
		sz = type-&gt;dtdt_size;

	<span class="enscript-keyword">return</span> (dtrace_canload((uintptr_t)src, sz, mstate, vstate));
}

<span class="enscript-comment">/*
 * Compare two strings using safe loads.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_strncmp</span>(<span class="enscript-type">char</span> *s1, <span class="enscript-type">char</span> *s2, size_t limit)
{
	uint8_t c1, c2;
	<span class="enscript-type">volatile</span> uint16_t *flags;

	<span class="enscript-keyword">if</span> (s1 == s2 || limit == 0)
		<span class="enscript-keyword">return</span> (0);

	flags = (<span class="enscript-type">volatile</span> uint16_t *)&amp;cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags;

	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> (s1 == NULL) {
			c1 = <span class="enscript-string">'\0'</span>;
		} <span class="enscript-keyword">else</span> {
			c1 = dtrace_load8((uintptr_t)s1++);
		}

		<span class="enscript-keyword">if</span> (s2 == NULL) {
			c2 = <span class="enscript-string">'\0'</span>;
		} <span class="enscript-keyword">else</span> {
			c2 = dtrace_load8((uintptr_t)s2++);
		}

		<span class="enscript-keyword">if</span> (c1 != c2)
			<span class="enscript-keyword">return</span> (c1 - c2);
	} <span class="enscript-keyword">while</span> (--limit &amp;&amp; c1 != <span class="enscript-string">'\0'</span> &amp;&amp; !(*flags &amp; CPU_DTRACE_FAULT));

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Compute strlen(s) for a string using safe memory accesses.  The additional
 * len parameter is used to specify a maximum length to ensure completion.
 */</span>
<span class="enscript-type">static</span> size_t
<span class="enscript-function-name">dtrace_strlen</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s, size_t lim)
{
	uint_t len;

	<span class="enscript-keyword">for</span> (len = 0; len != lim; len++) {
		<span class="enscript-keyword">if</span> (dtrace_load8((uintptr_t)s++) == <span class="enscript-string">'\0'</span>)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (len);
}

<span class="enscript-comment">/*
 * Check if an address falls within a toxic region.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_istoxic</span>(uintptr_t kaddr, size_t size)
{
	uintptr_t taddr, tsize;
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; dtrace_toxranges; i++) {
		taddr = dtrace_toxrange[i].dtt_base;
		tsize = dtrace_toxrange[i].dtt_limit - taddr;

		<span class="enscript-keyword">if</span> (kaddr - taddr &lt; tsize) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
			cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_illval = kaddr;
			<span class="enscript-keyword">return</span> (1);
		}

		<span class="enscript-keyword">if</span> (taddr - kaddr &lt; size) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
			cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_illval = taddr;
			<span class="enscript-keyword">return</span> (1);
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Copy src to dst using safe memory accesses.  The src is assumed to be unsafe
 * memory specified by the DIF program.  The dst is assumed to be safe memory
 * that we can store to directly because it is managed by DTrace.  As with
 * standard bcopy, overlapping copies are handled properly.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_bcopy</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *src, <span class="enscript-type">void</span> *dst, size_t len)
{
	<span class="enscript-keyword">if</span> (len != 0) {
		uint8_t *s1 = dst;
		<span class="enscript-type">const</span> uint8_t *s2 = src;

		<span class="enscript-keyword">if</span> (s1 &lt;= s2) {
			<span class="enscript-keyword">do</span> {
				*s1++ = dtrace_load8((uintptr_t)s2++);
			} <span class="enscript-keyword">while</span> (--len != 0);
		} <span class="enscript-keyword">else</span> {
			s2 += len;
			s1 += len;

			<span class="enscript-keyword">do</span> {
				*--s1 = dtrace_load8((uintptr_t)--s2);
			} <span class="enscript-keyword">while</span> (--len != 0);
		}
	}
}

<span class="enscript-comment">/*
 * Copy src to dst using safe memory accesses, up to either the specified
 * length, or the point that a nul byte is encountered.  The src is assumed to
 * be unsafe memory specified by the DIF program.  The dst is assumed to be
 * safe memory that we can store to directly because it is managed by DTrace.
 * Unlike dtrace_bcopy(), overlapping regions are not handled.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_strcpy</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *src, <span class="enscript-type">void</span> *dst, size_t len)
{
	<span class="enscript-keyword">if</span> (len != 0) {
		uint8_t *s1 = dst, c;
		<span class="enscript-type">const</span> uint8_t *s2 = src;

		<span class="enscript-keyword">do</span> {
			*s1++ = c = dtrace_load8((uintptr_t)s2++);
		} <span class="enscript-keyword">while</span> (--len != 0 &amp;&amp; c != <span class="enscript-string">'\0'</span>);
	}
}

<span class="enscript-comment">/*
 * Copy src to dst, deriving the size and type from the specified (BYREF)
 * variable type.  The src is assumed to be unsafe memory specified by the DIF
 * program.  The dst is assumed to be DTrace variable memory that is of the
 * specified type; we assume that we can store to directly.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_vcopy</span>(<span class="enscript-type">void</span> *src, <span class="enscript-type">void</span> *dst, dtrace_diftype_t *type)
{
	ASSERT(type-&gt;dtdt_flags &amp; DIF_TF_BYREF);

	<span class="enscript-keyword">if</span> (type-&gt;dtdt_kind == DIF_TYPE_STRING) {
		dtrace_strcpy(src, dst, type-&gt;dtdt_size);
	} <span class="enscript-keyword">else</span> {
		dtrace_bcopy(src, dst, type-&gt;dtdt_size);
}
}

<span class="enscript-comment">/*
 * Compare s1 to s2 using safe memory accesses.  The s1 data is assumed to be
 * unsafe memory specified by the DIF program.  The s2 data is assumed to be
 * safe memory that we can access directly because it is managed by DTrace.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_bcmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *s1, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *s2, size_t len)
{
	<span class="enscript-type">volatile</span> uint16_t *flags;

	flags = (<span class="enscript-type">volatile</span> uint16_t *)&amp;cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags;

	<span class="enscript-keyword">if</span> (s1 == s2)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (s1 == NULL || s2 == NULL)
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">if</span> (s1 != s2 &amp;&amp; len != 0) {
		<span class="enscript-type">const</span> uint8_t *ps1 = s1;
		<span class="enscript-type">const</span> uint8_t *ps2 = s2;

		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> (dtrace_load8((uintptr_t)ps1++) != *ps2++)
				<span class="enscript-keyword">return</span> (1);
		} <span class="enscript-keyword">while</span> (--len != 0 &amp;&amp; !(*flags &amp; CPU_DTRACE_FAULT));
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Zero the specified region using a simple byte-by-byte loop.  Note that this
 * is for safe DTrace-managed memory only.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_bzero</span>(<span class="enscript-type">void</span> *dst, size_t len)
{
	uchar_t *cp;

	<span class="enscript-keyword">for</span> (cp = dst; len != 0; len--)
		*cp++ = 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_add_128</span>(uint64_t *addend1, uint64_t *addend2, uint64_t *sum)
{
	uint64_t result[2];

	result[0] = addend1[0] + addend2[0];
	result[1] = addend1[1] + addend2[1] +
	    (result[0] &lt; addend1[0] || result[0] &lt; addend2[0] ? 1 : 0);

	sum[0] = result[0];
	sum[1] = result[1];
}

<span class="enscript-comment">/*
 * Shift the 128-bit value in a by b. If b is positive, shift left.
 * If b is negative, shift right.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_shift_128</span>(uint64_t *a, <span class="enscript-type">int</span> b)
{
	uint64_t mask;

	<span class="enscript-keyword">if</span> (b == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (b &lt; 0) {
		b = -b;
		<span class="enscript-keyword">if</span> (b &gt;= 64) {
			a[0] = a[1] &gt;&gt; (b - 64);
			a[1] = 0;
		} <span class="enscript-keyword">else</span> {
			a[0] &gt;&gt;= b;
			mask = 1LL &lt;&lt; (64 - b);
			mask -= 1;
			a[0] |= ((a[1] &amp; mask) &lt;&lt; (64 - b));
			a[1] &gt;&gt;= b;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (b &gt;= 64) {
			a[1] = a[0] &lt;&lt; (b - 64);
			a[0] = 0;
		} <span class="enscript-keyword">else</span> {
			a[1] &lt;&lt;= b;
			mask = a[0] &gt;&gt; (64 - b);
			a[1] |= mask;
			a[0] &lt;&lt;= b;
		}
	}
}

<span class="enscript-comment">/*
 * The basic idea is to break the 2 64-bit values into 4 32-bit values,
 * use native multiplication on those, and then re-combine into the
 * resulting 128-bit value.
 *
 * (hi1 &lt;&lt; 32 + lo1) * (hi2 &lt;&lt; 32 + lo2) =
 *     hi1 * hi2 &lt;&lt; 64 +
 *     hi1 * lo2 &lt;&lt; 32 +
 *     hi2 * lo1 &lt;&lt; 32 +
 *     lo1 * lo2
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_multiply_128</span>(uint64_t factor1, uint64_t factor2, uint64_t *product)
{
	uint64_t hi1, hi2, lo1, lo2;
	uint64_t tmp[2];

	hi1 = factor1 &gt;&gt; 32;
	hi2 = factor2 &gt;&gt; 32;

	lo1 = factor1 &amp; DT_MASK_LO;
	lo2 = factor2 &amp; DT_MASK_LO;

	product[0] = lo1 * lo2;
	product[1] = hi1 * hi2;

	tmp[0] = hi1 * lo2;
	tmp[1] = 0;
	dtrace_shift_128(tmp, 32);
	dtrace_add_128(product, tmp, product);

	tmp[0] = hi2 * lo1;
	tmp[1] = 0;
	dtrace_shift_128(tmp, 32);
	dtrace_add_128(product, tmp, product);
}

<span class="enscript-comment">/*
 * This privilege check should be used by actions and subroutines to
 * verify that the user credentials of the process that enabled the
 * invoking ECB match the target credentials
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_priv_proc_common_user</span>(dtrace_state_t *state)
{
	cred_t *cr, *s_cr = state-&gt;dts_cred.dcr_cred;

	<span class="enscript-comment">/*
	 * We should always have a non-NULL state cred here, since if cred
	 * is null (anonymous tracing), we fast-path bypass this routine.
	 */</span>
	ASSERT(s_cr != NULL);

	<span class="enscript-keyword">if</span> ((cr = dtrace_CRED()) != NULL &amp;&amp;
	    posix_cred_get(s_cr)-&gt;cr_uid == posix_cred_get(cr)-&gt;cr_uid &amp;&amp;
	    posix_cred_get(s_cr)-&gt;cr_uid == posix_cred_get(cr)-&gt;cr_ruid &amp;&amp;
	    posix_cred_get(s_cr)-&gt;cr_uid == posix_cred_get(cr)-&gt;cr_suid &amp;&amp;
	    posix_cred_get(s_cr)-&gt;cr_gid == posix_cred_get(cr)-&gt;cr_gid &amp;&amp;
	    posix_cred_get(s_cr)-&gt;cr_gid == posix_cred_get(cr)-&gt;cr_rgid &amp;&amp;
	    posix_cred_get(s_cr)-&gt;cr_gid == posix_cred_get(cr)-&gt;cr_sgid)
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * This privilege check should be used by actions and subroutines to
 * verify that the zone of the process that enabled the invoking ECB
 * matches the target credentials
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_priv_proc_common_zone</span>(dtrace_state_t *state)
{
	cred_t *cr, *s_cr = state-&gt;dts_cred.dcr_cred;
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cr</span>, <span class="enscript-variable-name">s_cr</span>, <span class="enscript-variable-name">state</span>) <span class="enscript-comment">/* __APPLE__ */</span>

	<span class="enscript-comment">/*
	 * We should always have a non-NULL state cred here, since if cred
	 * is null (anonymous tracing), we fast-path bypass this routine.
	 */</span>
	ASSERT(s_cr != NULL);

	<span class="enscript-keyword">return</span> 1; <span class="enscript-comment">/* APPLE NOTE: Darwin doesn't do zones. */</span>
}

<span class="enscript-comment">/*
 * This privilege check should be used by actions and subroutines to
 * verify that the process has not setuid or changed credentials.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_priv_proc_common_nocd</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> 1; <span class="enscript-comment">/* Darwin omits &quot;No Core Dump&quot; flag. */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_priv_proc_destructive</span>(dtrace_state_t *state)
{
	<span class="enscript-type">int</span> action = state-&gt;dts_cred.dcr_action;

	<span class="enscript-keyword">if</span> (ISSET(current_proc()-&gt;p_lflag, P_LNOATTACH))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (dtrace_is_restricted() &amp;&amp; !dtrace_can_attach_to_proc(current_proc()))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (((action &amp; DTRACE_CRA_PROC_DESTRUCTIVE_ALLZONE) == 0) &amp;&amp;
	    dtrace_priv_proc_common_zone(state) == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (((action &amp; DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER) == 0) &amp;&amp;
	    dtrace_priv_proc_common_user(state) == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (((action &amp; DTRACE_CRA_PROC_DESTRUCTIVE_CREDCHG) == 0) &amp;&amp;
	    dtrace_priv_proc_common_nocd() == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">return</span> (1);

<span class="enscript-reference">bad</span>:
	cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags |= CPU_DTRACE_UPRIV;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_priv_proc_control</span>(dtrace_state_t *state)
{
	<span class="enscript-keyword">if</span> (ISSET(current_proc()-&gt;p_lflag, P_LNOATTACH))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (dtrace_is_restricted() &amp;&amp; !dtrace_can_attach_to_proc(current_proc()))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (state-&gt;dts_cred.dcr_action &amp; DTRACE_CRA_PROC_CONTROL)
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">if</span> (dtrace_priv_proc_common_zone(state) &amp;&amp;
	    dtrace_priv_proc_common_user(state) &amp;&amp;
	    dtrace_priv_proc_common_nocd())
		<span class="enscript-keyword">return</span> (1);

<span class="enscript-reference">bad</span>:
	cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags |= CPU_DTRACE_UPRIV;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_priv_proc</span>(dtrace_state_t *state)
{
	<span class="enscript-keyword">if</span> (ISSET(current_proc()-&gt;p_lflag, P_LNOATTACH))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (dtrace_is_restricted() &amp;&amp; !dtrace_is_running_apple_internal() &amp;&amp; !dtrace_can_attach_to_proc(current_proc()))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (state-&gt;dts_cred.dcr_action &amp; DTRACE_CRA_PROC)
		<span class="enscript-keyword">return</span> (1);

<span class="enscript-reference">bad</span>:
	cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags |= CPU_DTRACE_UPRIV;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * The P_LNOATTACH check is an Apple specific check.
 * We need a version of dtrace_priv_proc() that omits
 * that check for PID and EXECNAME accesses
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_priv_proc_relaxed</span>(dtrace_state_t *state)
{

	<span class="enscript-keyword">if</span> (state-&gt;dts_cred.dcr_action &amp; DTRACE_CRA_PROC)
		<span class="enscript-keyword">return</span> (1);

	cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags |= CPU_DTRACE_UPRIV;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_priv_kernel</span>(dtrace_state_t *state)
{
	<span class="enscript-keyword">if</span> (dtrace_is_restricted() &amp;&amp; !dtrace_is_running_apple_internal())
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (state-&gt;dts_cred.dcr_action &amp; DTRACE_CRA_KERNEL)
		<span class="enscript-keyword">return</span> (1);

<span class="enscript-reference">bad</span>:
	cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags |= CPU_DTRACE_KPRIV;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_priv_kernel_destructive</span>(dtrace_state_t *state)
{
	<span class="enscript-keyword">if</span> (dtrace_is_restricted())
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (state-&gt;dts_cred.dcr_action &amp; DTRACE_CRA_KERNEL_DESTRUCTIVE)
		<span class="enscript-keyword">return</span> (1);

<span class="enscript-reference">bad</span>:
	cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags |= CPU_DTRACE_KPRIV;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Note:  not called from probe context.  This function is called
 * asynchronously (and at a regular interval) from outside of probe context to
 * clean the dirty dynamic variable lists on all CPUs.  Dynamic variable
 * cleaning is explained in detail in &lt;sys/dtrace_impl.h&gt;.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_dynvar_clean</span>(dtrace_dstate_t *dstate)
{
	dtrace_dynvar_t *dirty;
	dtrace_dstate_percpu_t *dcpu;
	<span class="enscript-type">int</span> i, work = 0;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)NCPU; i++) {
		dcpu = &amp;dstate-&gt;dtds_percpu[i];

		ASSERT(dcpu-&gt;dtdsc_rinsing == NULL);

		<span class="enscript-comment">/*
		 * If the dirty list is NULL, there is no dirty work to do.
		 */</span>
		<span class="enscript-keyword">if</span> (dcpu-&gt;dtdsc_dirty == NULL)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * If the clean list is non-NULL, then we're not going to do
		 * any work for this CPU -- it means that there has not been
		 * a dtrace_dynvar() allocation on this CPU (or from this CPU)
		 * since the last time we cleaned house.
		 */</span>
		<span class="enscript-keyword">if</span> (dcpu-&gt;dtdsc_clean != NULL)
			<span class="enscript-keyword">continue</span>;

		work = 1;

		<span class="enscript-comment">/*
		 * Atomically move the dirty list aside.
		 */</span>
		<span class="enscript-keyword">do</span> {
			dirty = dcpu-&gt;dtdsc_dirty;

			<span class="enscript-comment">/*
			 * Before we zap the dirty list, set the rinsing list.
			 * (This allows for a potential assertion in
			 * dtrace_dynvar():  if a free dynamic variable appears
			 * on a hash chain, either the dirty list or the
			 * rinsing list for some CPU must be non-NULL.)
			 */</span>
			dcpu-&gt;dtdsc_rinsing = dirty;
			dtrace_membar_producer();
		} <span class="enscript-keyword">while</span> (dtrace_casptr(&amp;dcpu-&gt;dtdsc_dirty,
		    dirty, NULL) != dirty);
	}

	<span class="enscript-keyword">if</span> (!work) {
		<span class="enscript-comment">/*
		 * We have no work to do; we can simply return.
		 */</span>
		<span class="enscript-keyword">return</span>;
	}

	dtrace_sync();

	<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)NCPU; i++) {
		dcpu = &amp;dstate-&gt;dtds_percpu[i];

		<span class="enscript-keyword">if</span> (dcpu-&gt;dtdsc_rinsing == NULL)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * We are now guaranteed that no hash chain contains a pointer
		 * into this dirty list; we can make it clean.
		 */</span>
		ASSERT(dcpu-&gt;dtdsc_clean == NULL);
		dcpu-&gt;dtdsc_clean = dcpu-&gt;dtdsc_rinsing;
		dcpu-&gt;dtdsc_rinsing = NULL;
	}

	<span class="enscript-comment">/*
	 * Before we actually set the state to be DTRACE_DSTATE_CLEAN, make
	 * sure that all CPUs have seen all of the dtdsc_clean pointers.
	 * This prevents a race whereby a CPU incorrectly decides that
	 * the state should be something other than DTRACE_DSTATE_CLEAN
	 * after dtrace_dynvar_clean() has completed.
	 */</span>
	dtrace_sync();

	dstate-&gt;dtds_state = DTRACE_DSTATE_CLEAN;
}

<span class="enscript-comment">/*
 * Depending on the value of the op parameter, this function looks-up,
 * allocates or deallocates an arbitrarily-keyed dynamic variable.  If an
 * allocation is requested, this function will return a pointer to a
 * dtrace_dynvar_t corresponding to the allocated variable -- or NULL if no
 * variable can be allocated.  If NULL is returned, the appropriate counter
 * will be incremented.
 */</span>
<span class="enscript-type">static</span> dtrace_dynvar_t *
<span class="enscript-function-name">dtrace_dynvar</span>(dtrace_dstate_t *dstate, uint_t nkeys,
    dtrace_key_t *key, size_t dsize, dtrace_dynvar_op_t op,
    dtrace_mstate_t *mstate, dtrace_vstate_t *vstate)
{
	uint64_t hashval = DTRACE_DYNHASH_VALID;
	dtrace_dynhash_t *hash = dstate-&gt;dtds_hash;
	dtrace_dynvar_t *free, *new_free, *next, *dvar, *start, *prev = NULL;
	processorid_t me = CPU-&gt;cpu_id, cpu = me;
	dtrace_dstate_percpu_t *dcpu = &amp;dstate-&gt;dtds_percpu[me];
	size_t bucket, ksize;
	size_t chunksize = dstate-&gt;dtds_chunksize;
	uintptr_t kdata, lock, nstate;
	uint_t i;

	ASSERT(nkeys != 0);

	<span class="enscript-comment">/*
	 * Hash the key.  As with aggregations, we use Jenkins' &quot;One-at-a-time&quot;
	 * algorithm.  For the by-value portions, we perform the algorithm in
	 * 16-bit chunks (as opposed to 8-bit chunks).  This speeds things up a
	 * bit, and seems to have only a minute effect on distribution.  For
	 * the by-reference data, we perform &quot;One-at-a-time&quot; iterating (safely)
	 * over each referenced byte.  It's painful to do this, but it's much
	 * better than pathological hash distribution.  The efficacy of the
	 * hashing algorithm (and a comparison with other algorithms) may be
	 * found by running the ::dtrace_dynstat MDB dcmd.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; nkeys; i++) {
		<span class="enscript-keyword">if</span> (key[i].dttk_size == 0) {
			uint64_t val = key[i].dttk_value;

			hashval += (val &gt;&gt; 48) &amp; 0xffff;
			hashval += (hashval &lt;&lt; 10);
			hashval ^= (hashval &gt;&gt; 6);

			hashval += (val &gt;&gt; 32) &amp; 0xffff;
			hashval += (hashval &lt;&lt; 10);
			hashval ^= (hashval &gt;&gt; 6);

			hashval += (val &gt;&gt; 16) &amp; 0xffff;
			hashval += (hashval &lt;&lt; 10);
			hashval ^= (hashval &gt;&gt; 6);

			hashval += val &amp; 0xffff;
			hashval += (hashval &lt;&lt; 10);
			hashval ^= (hashval &gt;&gt; 6);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * This is incredibly painful, but it beats the hell
			 * out of the alternative.
			 */</span>
			uint64_t j, size = key[i].dttk_size;
			uintptr_t base = (uintptr_t)key[i].dttk_value;

			<span class="enscript-keyword">if</span> (!dtrace_canload(base, size, mstate, vstate))
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">for</span> (j = 0; j &lt; size; j++) {
				hashval += dtrace_load8(base + j);
				hashval += (hashval &lt;&lt; 10);
				hashval ^= (hashval &gt;&gt; 6);
			}
		}
	}

	<span class="enscript-keyword">if</span> (DTRACE_CPUFLAG_ISSET(CPU_DTRACE_FAULT))
		<span class="enscript-keyword">return</span> (NULL);

	hashval += (hashval &lt;&lt; 3);
	hashval ^= (hashval &gt;&gt; 11);
	hashval += (hashval &lt;&lt; 15);

	<span class="enscript-comment">/*
	 * There is a remote chance (ideally, 1 in 2^31) that our hashval
	 * comes out to be one of our two sentinel hash values.  If this
	 * actually happens, we set the hashval to be a value known to be a
	 * non-sentinel value.
	 */</span>
	<span class="enscript-keyword">if</span> (hashval == DTRACE_DYNHASH_FREE || hashval == DTRACE_DYNHASH_SINK)
		hashval = DTRACE_DYNHASH_VALID;

	<span class="enscript-comment">/*
	 * Yes, it's painful to do a divide here.  If the cycle count becomes
	 * important here, tricks can be pulled to reduce it.  (However, it's
	 * critical that hash collisions be kept to an absolute minimum;
	 * they're much more painful than a divide.)  It's better to have a
	 * solution that generates few collisions and still keeps things
	 * relatively simple.
	 */</span>
	bucket = hashval % dstate-&gt;dtds_hashsize;

	<span class="enscript-keyword">if</span> (op == DTRACE_DYNVAR_DEALLOC) {
		<span class="enscript-type">volatile</span> uintptr_t *lockp = &amp;hash[bucket].dtdh_lock;

		<span class="enscript-keyword">for</span> (;;) {
			<span class="enscript-keyword">while</span> ((lock = *lockp) &amp; 1)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (dtrace_casptr((<span class="enscript-type">void</span> *)(uintptr_t)lockp,
			    (<span class="enscript-type">void</span> *)lock, (<span class="enscript-type">void</span> *)(lock + 1)) == (<span class="enscript-type">void</span> *)lock)
				<span class="enscript-keyword">break</span>;
		}

		dtrace_membar_producer();
	}

<span class="enscript-reference">top</span>:
	prev = NULL;
	lock = hash[bucket].dtdh_lock;

	dtrace_membar_consumer();

	start = hash[bucket].dtdh_chain;
	ASSERT(start != NULL &amp;&amp; (start-&gt;dtdv_hashval == DTRACE_DYNHASH_SINK ||
	    start-&gt;dtdv_hashval != DTRACE_DYNHASH_FREE ||
	    op != DTRACE_DYNVAR_DEALLOC));

	<span class="enscript-keyword">for</span> (dvar = start; dvar != NULL; dvar = dvar-&gt;dtdv_next) {
		dtrace_tuple_t *dtuple = &amp;dvar-&gt;dtdv_tuple;
		dtrace_key_t *dkey = &amp;dtuple-&gt;dtt_key[0];

		<span class="enscript-keyword">if</span> (dvar-&gt;dtdv_hashval != hashval) {
			<span class="enscript-keyword">if</span> (dvar-&gt;dtdv_hashval == DTRACE_DYNHASH_SINK) {
				<span class="enscript-comment">/*
				 * We've reached the sink, and therefore the
				 * end of the hash chain; we can kick out of
				 * the loop knowing that we have seen a valid
				 * snapshot of state.
				 */</span>
				ASSERT(dvar-&gt;dtdv_next == NULL);
				ASSERT(dvar == &amp;dtrace_dynhash_sink);
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (dvar-&gt;dtdv_hashval == DTRACE_DYNHASH_FREE) {
				<span class="enscript-comment">/*
				 * We've gone off the rails:  somewhere along
				 * the line, one of the members of this hash
				 * chain was deleted.  Note that we could also
				 * detect this by simply letting this loop run
				 * to completion, as we would eventually hit
				 * the end of the dirty list.  However, we
				 * want to avoid running the length of the
				 * dirty list unnecessarily (it might be quite
				 * long), so we catch this as early as
				 * possible by detecting the hash marker.  In
				 * this case, we simply set dvar to NULL and
				 * break; the conditional after the loop will
				 * send us back to top.
				 */</span>
				dvar = NULL;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
		}

		<span class="enscript-keyword">if</span> (dtuple-&gt;dtt_nkeys != nkeys)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;

		<span class="enscript-keyword">for</span> (i = 0; i &lt; nkeys; i++, dkey++) {
			<span class="enscript-keyword">if</span> (dkey-&gt;dttk_size != key[i].dttk_size)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>; <span class="enscript-comment">/* size or type mismatch */</span>

			<span class="enscript-keyword">if</span> (dkey-&gt;dttk_size != 0) {
				<span class="enscript-keyword">if</span> (dtrace_bcmp(
				    (<span class="enscript-type">void</span> *)(uintptr_t)key[i].dttk_value,
				    (<span class="enscript-type">void</span> *)(uintptr_t)dkey-&gt;dttk_value,
				    dkey-&gt;dttk_size))
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (dkey-&gt;dttk_value != key[i].dttk_value)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
			}
		}

		<span class="enscript-keyword">if</span> (op != DTRACE_DYNVAR_DEALLOC)
			<span class="enscript-keyword">return</span> (dvar);

		ASSERT(dvar-&gt;dtdv_next == NULL ||
		    dvar-&gt;dtdv_next-&gt;dtdv_hashval != DTRACE_DYNHASH_FREE);

		<span class="enscript-keyword">if</span> (prev != NULL) {
			ASSERT(hash[bucket].dtdh_chain != dvar);
			ASSERT(start != dvar);
			ASSERT(prev-&gt;dtdv_next == dvar);
			prev-&gt;dtdv_next = dvar-&gt;dtdv_next;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (dtrace_casptr(&amp;hash[bucket].dtdh_chain,
			    start, dvar-&gt;dtdv_next) != start) {
				<span class="enscript-comment">/*
				 * We have failed to atomically swing the
				 * hash table head pointer, presumably because
				 * of a conflicting allocation on another CPU.
				 * We need to reread the hash chain and try
				 * again.
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">top</span>;
			}
		}

		dtrace_membar_producer();

		<span class="enscript-comment">/*
		 * Now set the hash value to indicate that it's free.
		 */</span>
		ASSERT(hash[bucket].dtdh_chain != dvar);
		dvar-&gt;dtdv_hashval = DTRACE_DYNHASH_FREE;

		dtrace_membar_producer();

		<span class="enscript-comment">/*
		 * Set the next pointer to point at the dirty list, and
		 * atomically swing the dirty pointer to the newly freed dvar.
		 */</span>
		<span class="enscript-keyword">do</span> {
			next = dcpu-&gt;dtdsc_dirty;
			dvar-&gt;dtdv_next = next;
		} <span class="enscript-keyword">while</span> (dtrace_casptr(&amp;dcpu-&gt;dtdsc_dirty, next, dvar) != next);

		<span class="enscript-comment">/*
		 * Finally, unlock this hash bucket.
		 */</span>
		ASSERT(hash[bucket].dtdh_lock == lock);
		ASSERT(lock &amp; 1);
		hash[bucket].dtdh_lock++;

		<span class="enscript-keyword">return</span> (NULL);
<span class="enscript-reference">next</span>:
		prev = dvar;
		<span class="enscript-keyword">continue</span>;
	}

	<span class="enscript-keyword">if</span> (dvar == NULL) {
		<span class="enscript-comment">/*
		 * If dvar is NULL, it is because we went off the rails:
		 * one of the elements that we traversed in the hash chain
		 * was deleted while we were traversing it.  In this case,
		 * we assert that we aren't doing a dealloc (deallocs lock
		 * the hash bucket to prevent themselves from racing with
		 * one another), and retry the hash chain traversal.
		 */</span>
		ASSERT(op != DTRACE_DYNVAR_DEALLOC);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">top</span>;
	}

	<span class="enscript-keyword">if</span> (op != DTRACE_DYNVAR_ALLOC) {
		<span class="enscript-comment">/*
		 * If we are not to allocate a new variable, we want to
		 * return NULL now.  Before we return, check that the value
		 * of the lock word hasn't changed.  If it has, we may have
		 * seen an inconsistent snapshot.
		 */</span>
		<span class="enscript-keyword">if</span> (op == DTRACE_DYNVAR_NOALLOC) {
			<span class="enscript-keyword">if</span> (hash[bucket].dtdh_lock != lock)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">top</span>;
		} <span class="enscript-keyword">else</span> {
			ASSERT(op == DTRACE_DYNVAR_DEALLOC);
			ASSERT(hash[bucket].dtdh_lock == lock);
			ASSERT(lock &amp; 1);
			hash[bucket].dtdh_lock++;
		}

		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-comment">/*
	 * We need to allocate a new dynamic variable.  The size we need is the
	 * size of dtrace_dynvar plus the size of nkeys dtrace_key_t's plus the
	 * size of any auxiliary key data (rounded up to 8-byte alignment) plus
	 * the size of any referred-to data (dsize).  We then round the final
	 * size up to the chunksize for allocation.
	 */</span>
	<span class="enscript-keyword">for</span> (ksize = 0, i = 0; i &lt; nkeys; i++)
		ksize += P2ROUNDUP(key[i].dttk_size, <span class="enscript-keyword">sizeof</span> (uint64_t));

	<span class="enscript-comment">/*
	 * This should be pretty much impossible, but could happen if, say,
	 * strange DIF specified the tuple.  Ideally, this should be an
	 * assertion and not an error condition -- but that requires that the
	 * chunksize calculation in dtrace_difo_chunksize() be absolutely
	 * bullet-proof.  (That is, it must not be able to be fooled by
	 * malicious DIF.)  Given the lack of backwards branches in DIF,
	 * solving this would presumably not amount to solving the Halting
	 * Problem -- but it still seems awfully hard.
	 */</span>
	<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span> (dtrace_dynvar_t) + <span class="enscript-keyword">sizeof</span> (dtrace_key_t) * (nkeys - 1) +
	    ksize + dsize &gt; chunksize) {
		dcpu-&gt;dtdsc_drops++;
		<span class="enscript-keyword">return</span> (NULL);
	}

	nstate = DTRACE_DSTATE_EMPTY;

	<span class="enscript-keyword">do</span> {
<span class="enscript-reference">retry</span>:
		free = dcpu-&gt;dtdsc_free;

		<span class="enscript-keyword">if</span> (free == NULL) {
			dtrace_dynvar_t *clean = dcpu-&gt;dtdsc_clean;
			<span class="enscript-type">void</span> *rval;

			<span class="enscript-keyword">if</span> (clean == NULL) {
				<span class="enscript-comment">/*
				 * We're out of dynamic variable space on
				 * this CPU.  Unless we have tried all CPUs,
				 * we'll try to allocate from a different
				 * CPU.
				 */</span>
				<span class="enscript-keyword">switch</span> (dstate-&gt;dtds_state) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACE_DSTATE_CLEAN</span>: {
					<span class="enscript-type">void</span> *sp = &amp;dstate-&gt;dtds_state;

					<span class="enscript-keyword">if</span> (++cpu &gt;= (<span class="enscript-type">int</span>)NCPU)
						cpu = 0;

					<span class="enscript-keyword">if</span> (dcpu-&gt;dtdsc_dirty != NULL &amp;&amp;
					    nstate == DTRACE_DSTATE_EMPTY)
						nstate = DTRACE_DSTATE_DIRTY;

					<span class="enscript-keyword">if</span> (dcpu-&gt;dtdsc_rinsing != NULL)
						nstate = DTRACE_DSTATE_RINSING;

					dcpu = &amp;dstate-&gt;dtds_percpu[cpu];

					<span class="enscript-keyword">if</span> (cpu != me)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;

					(<span class="enscript-type">void</span>) dtrace_cas32(sp,
					    DTRACE_DSTATE_CLEAN, nstate);

					<span class="enscript-comment">/*
					 * To increment the correct bean
					 * counter, take another lap.
					 */</span>
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
				}

				<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACE_DSTATE_DIRTY</span>:
					dcpu-&gt;dtdsc_dirty_drops++;
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACE_DSTATE_RINSING</span>:
					dcpu-&gt;dtdsc_rinsing_drops++;
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACE_DSTATE_EMPTY</span>:
					dcpu-&gt;dtdsc_drops++;
					<span class="enscript-keyword">break</span>;
				}

				DTRACE_CPUFLAG_SET(CPU_DTRACE_DROP);
				<span class="enscript-keyword">return</span> (NULL);
			}

			<span class="enscript-comment">/*
			 * The clean list appears to be non-empty.  We want to
			 * move the clean list to the free list; we start by
			 * moving the clean pointer aside.
			 */</span>
			<span class="enscript-keyword">if</span> (dtrace_casptr(&amp;dcpu-&gt;dtdsc_clean,
			    clean, NULL) != clean) {
				<span class="enscript-comment">/*
				 * We are in one of two situations:
				 *
				 *  (a)	The clean list was switched to the
				 *	free list by another CPU.
				 *
				 *  (b)	The clean list was added to by the
				 *	cleansing cyclic.
				 *
				 * In either of these situations, we can
				 * just reattempt the free list allocation.
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
			}

			ASSERT(clean-&gt;dtdv_hashval == DTRACE_DYNHASH_FREE);

			<span class="enscript-comment">/*
			 * Now we'll move the clean list to the free list.
			 * It's impossible for this to fail:  the only way
			 * the free list can be updated is through this
			 * code path, and only one CPU can own the clean list.
			 * Thus, it would only be possible for this to fail if
			 * this code were racing with dtrace_dynvar_clean().
			 * (That is, if dtrace_dynvar_clean() updated the clean
			 * list, and we ended up racing to update the free
			 * list.)  This race is prevented by the dtrace_sync()
			 * in dtrace_dynvar_clean() -- which flushes the
			 * owners of the clean lists out before resetting
			 * the clean lists.
			 */</span>
			rval = dtrace_casptr(&amp;dcpu-&gt;dtdsc_free, NULL, clean);
			ASSERT(rval == NULL);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}

		dvar = free;
		new_free = dvar-&gt;dtdv_next;
	} <span class="enscript-keyword">while</span> (dtrace_casptr(&amp;dcpu-&gt;dtdsc_free, free, new_free) != free);

	<span class="enscript-comment">/*
	 * We have now allocated a new chunk.  We copy the tuple keys into the
	 * tuple array and copy any referenced key data into the data space
	 * following the tuple array.  As we do this, we relocate dttk_value
	 * in the final tuple to point to the key data address in the chunk.
	 */</span>
	kdata = (uintptr_t)&amp;dvar-&gt;dtdv_tuple.dtt_key[nkeys];
	dvar-&gt;dtdv_data = (<span class="enscript-type">void</span> *)(kdata + ksize);
	dvar-&gt;dtdv_tuple.dtt_nkeys = nkeys;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; nkeys; i++) {
		dtrace_key_t *dkey = &amp;dvar-&gt;dtdv_tuple.dtt_key[i];
		size_t kesize = key[i].dttk_size;

		<span class="enscript-keyword">if</span> (kesize != 0) {
			dtrace_bcopy(
			    (<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)(uintptr_t)key[i].dttk_value,
			    (<span class="enscript-type">void</span> *)kdata, kesize);
			dkey-&gt;dttk_value = kdata;
			kdata += P2ROUNDUP(kesize, <span class="enscript-keyword">sizeof</span> (uint64_t));
		} <span class="enscript-keyword">else</span> {
			dkey-&gt;dttk_value = key[i].dttk_value;
		}

		dkey-&gt;dttk_size = kesize;
	}

	ASSERT(dvar-&gt;dtdv_hashval == DTRACE_DYNHASH_FREE);
	dvar-&gt;dtdv_hashval = hashval;
	dvar-&gt;dtdv_next = start;

	<span class="enscript-keyword">if</span> (dtrace_casptr(&amp;hash[bucket].dtdh_chain, start, dvar) == start)
		<span class="enscript-keyword">return</span> (dvar);

	<span class="enscript-comment">/*
	 * The cas has failed.  Either another CPU is adding an element to
	 * this hash chain, or another CPU is deleting an element from this
	 * hash chain.  The simplest way to deal with both of these cases
	 * (though not necessarily the most efficient) is to free our
	 * allocated block and tail-call ourselves.  Note that the free is
	 * to the dirty list and _not_ to the free list.  This is to prevent
	 * races with allocators, above.
	 */</span>
	dvar-&gt;dtdv_hashval = DTRACE_DYNHASH_FREE;

	dtrace_membar_producer();

	<span class="enscript-keyword">do</span> {
		free = dcpu-&gt;dtdsc_dirty;
		dvar-&gt;dtdv_next = free;
	} <span class="enscript-keyword">while</span> (dtrace_casptr(&amp;dcpu-&gt;dtdsc_dirty, free, dvar) != free);

	<span class="enscript-keyword">return</span> (dtrace_dynvar(dstate, nkeys, key, dsize, op, mstate, vstate));
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_aggregate_min</span>(uint64_t *oval, uint64_t nval, uint64_t arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	<span class="enscript-keyword">if</span> ((int64_t)nval &lt; (int64_t)*oval)
		*oval = nval;
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_aggregate_max</span>(uint64_t *oval, uint64_t nval, uint64_t arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	<span class="enscript-keyword">if</span> ((int64_t)nval &gt; (int64_t)*oval)
		*oval = nval;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_aggregate_quantize</span>(uint64_t *quanta, uint64_t nval, uint64_t incr)
{
	<span class="enscript-type">int</span> i, zero = DTRACE_QUANTIZE_ZEROBUCKET;
	int64_t val = (int64_t)nval;

	<span class="enscript-keyword">if</span> (val &lt; 0) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; zero; i++) {
			<span class="enscript-keyword">if</span> (val &lt;= DTRACE_QUANTIZE_BUCKETVAL(i)) {
				quanta[i] += incr;
				<span class="enscript-keyword">return</span>;
			}
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">for</span> (i = zero + 1; i &lt; DTRACE_QUANTIZE_NBUCKETS; i++) {
			<span class="enscript-keyword">if</span> (val &lt; DTRACE_QUANTIZE_BUCKETVAL(i)) {
				quanta[i - 1] += incr;
				<span class="enscript-keyword">return</span>;
			}
		}

		quanta[DTRACE_QUANTIZE_NBUCKETS - 1] += incr;
		<span class="enscript-keyword">return</span>;
	}

	ASSERT(0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_aggregate_lquantize</span>(uint64_t *lquanta, uint64_t nval, uint64_t incr)
{
	uint64_t arg = *lquanta++;
	int32_t base = DTRACE_LQUANTIZE_BASE(arg);
	uint16_t step = DTRACE_LQUANTIZE_STEP(arg);
	uint16_t levels = DTRACE_LQUANTIZE_LEVELS(arg);
	int32_t val = (int32_t)nval, level;

	ASSERT(step != 0);
	ASSERT(levels != 0);

	<span class="enscript-keyword">if</span> (val &lt; base) {
		<span class="enscript-comment">/*
		 * This is an underflow.
		 */</span>
		lquanta[0] += incr;
		<span class="enscript-keyword">return</span>;
	}

	level = (val - base) / step;

	<span class="enscript-keyword">if</span> (level &lt; levels) {
		lquanta[level + 1] += incr;
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * This is an overflow.
	 */</span>
	lquanta[levels + 1] += incr;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_aggregate_llquantize_bucket</span>(int16_t factor, int16_t low, int16_t high,
                                   int16_t nsteps, int64_t value)
{
	int64_t this = 1, last, next;
	<span class="enscript-type">int</span> base = 1, order;

	<span class="enscript-keyword">for</span> (order = 0; order &lt; low; ++order)
		this *= factor;

	<span class="enscript-comment">/*
	 * If our value is less than our factor taken to the power of the
	 * low order of magnitude, it goes into the zeroth bucket.
	 */</span>
	<span class="enscript-keyword">if</span> (value &lt; this)
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">else</span>
		last = this;

	<span class="enscript-keyword">for</span> (this *= factor; order &lt;= high; ++order) {
		<span class="enscript-type">int</span> nbuckets = this &gt; nsteps ? nsteps : this;

		<span class="enscript-comment">/*
		 * We should not generally get log/linear quantizations
		 * with a high magnitude that allows 64-bits to
		 * overflow, but we nonetheless protect against this
		 * by explicitly checking for overflow, and clamping
		 * our value accordingly.
		 */</span>
		next = this * factor;
		<span class="enscript-keyword">if</span> (next &lt; this) {
			value = this - 1;
		}

		<span class="enscript-comment">/*
		 * If our value lies within this order of magnitude,
		 * determine its position by taking the offset within
		 * the order of magnitude, dividing by the bucket
		 * width, and adding to our (accumulated) base.
		 */</span>
		<span class="enscript-keyword">if</span> (value &lt; this) {
			<span class="enscript-keyword">return</span> (base + (value - last) / (this / nbuckets));
		}

		base += nbuckets - (nbuckets / factor);
		last = this;
		this = next;
	}

	<span class="enscript-comment">/*
	 * Our value is greater than or equal to our factor taken to the
	 * power of one plus the high magnitude -- return the top bucket.
	 */</span>
	<span class="enscript-keyword">return</span> base;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_aggregate_llquantize</span>(uint64_t *llquanta, uint64_t nval, uint64_t incr)
{
	uint64_t arg    = *llquanta++;
	uint16_t factor = DTRACE_LLQUANTIZE_FACTOR(arg);
	uint16_t low    = DTRACE_LLQUANTIZE_LOW(arg);
	uint16_t high   = DTRACE_LLQUANTIZE_HIGH(arg);
	uint16_t nsteps = DTRACE_LLQUANTIZE_NSTEP(arg);

	llquanta[dtrace_aggregate_llquantize_bucket(factor, low, high, nsteps, nval)] += incr;
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_aggregate_avg</span>(uint64_t *data, uint64_t nval, uint64_t arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	data[0]++;
	data[1] += nval;
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_aggregate_stddev</span>(uint64_t *data, uint64_t nval, uint64_t arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	int64_t snval = (int64_t)nval;
	uint64_t tmp[2];

	data[0]++;
	data[1] += nval;

	<span class="enscript-comment">/*
	 * What we want to say here is:
	 *
	 * data[2] += nval * nval;
	 *
	 * But given that nval is 64-bit, we could easily overflow, so
	 * we do this as 128-bit arithmetic.
	 */</span>
	<span class="enscript-keyword">if</span> (snval &lt; 0)
		snval = -snval;

	dtrace_multiply_128((uint64_t)snval, (uint64_t)snval, tmp);
	dtrace_add_128(data + 2, tmp, data + 2);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_aggregate_count</span>(uint64_t *oval, uint64_t nval, uint64_t arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">nval</span>, <span class="enscript-variable-name">arg</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	*oval = *oval + 1;
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_aggregate_sum</span>(uint64_t *oval, uint64_t nval, uint64_t arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	*oval += nval;
}

<span class="enscript-comment">/*
 * Aggregate given the tuple in the principal data buffer, and the aggregating
 * action denoted by the specified dtrace_aggregation_t.  The aggregation
 * buffer is specified as the buf parameter.  This routine does not return
 * failure; if there is no space in the aggregation buffer, the data will be
 * dropped, and a corresponding counter incremented.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_aggregate</span>(dtrace_aggregation_t *agg, dtrace_buffer_t *dbuf,
    intptr_t offset, dtrace_buffer_t *buf, uint64_t expr, uint64_t arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>)
	dtrace_recdesc_t *rec = &amp;agg-&gt;dtag_action.dta_rec;
	uint32_t i, ndx, size, fsize;
	uint32_t align = <span class="enscript-keyword">sizeof</span> (uint64_t) - 1;
	dtrace_aggbuffer_t *agb;
	dtrace_aggkey_t *key;
	uint32_t hashval = 0, limit, isstr;
	caddr_t tomax, data, kdata;
	dtrace_actkind_t action;
	dtrace_action_t *act;
	uintptr_t offs;

	<span class="enscript-keyword">if</span> (buf == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (!agg-&gt;dtag_hasarg) {
		<span class="enscript-comment">/*
		 * Currently, only quantize() and lquantize() take additional
		 * arguments, and they have the same semantics:  an increment
		 * value that defaults to 1 when not present.  If additional
		 * aggregating actions take arguments, the setting of the
		 * default argument value will presumably have to become more
		 * sophisticated...
		 */</span>
		arg = 1;
	}

	action = agg-&gt;dtag_action.dta_kind - DTRACEACT_AGGREGATION;
	size = rec-&gt;dtrd_offset - agg-&gt;dtag_base;
	fsize = size + rec-&gt;dtrd_size;

	ASSERT(dbuf-&gt;dtb_tomax != NULL);
	data = dbuf-&gt;dtb_tomax + offset + agg-&gt;dtag_base;

	<span class="enscript-keyword">if</span> ((tomax = buf-&gt;dtb_tomax) == NULL) {
		dtrace_buffer_drop(buf);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * The metastructure is always at the bottom of the buffer.
	 */</span>
	agb = (dtrace_aggbuffer_t *)(tomax + buf-&gt;dtb_size -
	    <span class="enscript-keyword">sizeof</span> (dtrace_aggbuffer_t));

	<span class="enscript-keyword">if</span> (buf-&gt;dtb_offset == 0) {
		<span class="enscript-comment">/*
		 * We just kludge up approximately 1/8th of the size to be
		 * buckets.  If this guess ends up being routinely
		 * off-the-mark, we may need to dynamically readjust this
		 * based on past performance.
		 */</span>
		uintptr_t hashsize = (buf-&gt;dtb_size &gt;&gt; 3) / <span class="enscript-keyword">sizeof</span> (uintptr_t);

		<span class="enscript-keyword">if</span> ((uintptr_t)agb - hashsize * <span class="enscript-keyword">sizeof</span> (dtrace_aggkey_t *) &lt;
		    (uintptr_t)tomax || hashsize == 0) {
			<span class="enscript-comment">/*
			 * We've been given a ludicrously small buffer;
			 * increment our drop count and leave.
			 */</span>
			dtrace_buffer_drop(buf);
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-comment">/*
		 * And now, a pathetic attempt to try to get a an odd (or
		 * perchance, a prime) hash size for better hash distribution.
		 */</span>
		<span class="enscript-keyword">if</span> (hashsize &gt; (DTRACE_AGGHASHSIZE_SLEW &lt;&lt; 3))
			hashsize -= DTRACE_AGGHASHSIZE_SLEW;

		agb-&gt;dtagb_hashsize = hashsize;
		agb-&gt;dtagb_hash = (dtrace_aggkey_t **)((uintptr_t)agb -
		    agb-&gt;dtagb_hashsize * <span class="enscript-keyword">sizeof</span> (dtrace_aggkey_t *));
		agb-&gt;dtagb_free = (uintptr_t)agb-&gt;dtagb_hash;

		<span class="enscript-keyword">for</span> (i = 0; i &lt; agb-&gt;dtagb_hashsize; i++)
			agb-&gt;dtagb_hash[i] = NULL;
	}

	ASSERT(agg-&gt;dtag_first != NULL);
	ASSERT(agg-&gt;dtag_first-&gt;dta_intuple);

	<span class="enscript-comment">/*
	 * Calculate the hash value based on the key.  Note that we _don't_
	 * include the aggid in the hashing (but we will store it as part of
	 * the key).  The hashing algorithm is Bob Jenkins' &quot;One-at-a-time&quot;
	 * algorithm: a simple, quick algorithm that has no known funnels, and
	 * gets good distribution in practice.  The efficacy of the hashing
	 * algorithm (and a comparison with other algorithms) may be found by
	 * running the ::dtrace_aggstat MDB dcmd.
	 */</span>
	<span class="enscript-keyword">for</span> (act = agg-&gt;dtag_first; act-&gt;dta_intuple; act = act-&gt;dta_next) {
		i = act-&gt;dta_rec.dtrd_offset - agg-&gt;dtag_base;
		limit = i + act-&gt;dta_rec.dtrd_size;
		ASSERT(limit &lt;= size);
		isstr = DTRACEACT_ISSTRING(act);

		<span class="enscript-keyword">for</span> (; i &lt; limit; i++) {
			hashval += data[i];
			hashval += (hashval &lt;&lt; 10);
			hashval ^= (hashval &gt;&gt; 6);

			<span class="enscript-keyword">if</span> (isstr &amp;&amp; data[i] == <span class="enscript-string">'\0'</span>)
				<span class="enscript-keyword">break</span>;
		}
	}

	hashval += (hashval &lt;&lt; 3);
	hashval ^= (hashval &gt;&gt; 11);
	hashval += (hashval &lt;&lt; 15);

	<span class="enscript-comment">/*
	 * Yes, the divide here is expensive -- but it's generally the least
	 * of the performance issues given the amount of data that we iterate
	 * over to compute hash values, compare data, etc.
	 */</span>
	ndx = hashval % agb-&gt;dtagb_hashsize;

	<span class="enscript-keyword">for</span> (key = agb-&gt;dtagb_hash[ndx]; key != NULL; key = key-&gt;dtak_next) {
		ASSERT((caddr_t)key &gt;= tomax);
		ASSERT((caddr_t)key &lt; tomax + buf-&gt;dtb_size);

		<span class="enscript-keyword">if</span> (hashval != key-&gt;dtak_hashval || key-&gt;dtak_size != size)
			<span class="enscript-keyword">continue</span>;

		kdata = key-&gt;dtak_data;
		ASSERT(kdata &gt;= tomax &amp;&amp; kdata &lt; tomax + buf-&gt;dtb_size);

		<span class="enscript-keyword">for</span> (act = agg-&gt;dtag_first; act-&gt;dta_intuple;
		    act = act-&gt;dta_next) {
			i = act-&gt;dta_rec.dtrd_offset - agg-&gt;dtag_base;
			limit = i + act-&gt;dta_rec.dtrd_size;
			ASSERT(limit &lt;= size);
			isstr = DTRACEACT_ISSTRING(act);

			<span class="enscript-keyword">for</span> (; i &lt; limit; i++) {
				<span class="enscript-keyword">if</span> (kdata[i] != data[i])
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;

				<span class="enscript-keyword">if</span> (isstr &amp;&amp; data[i] == <span class="enscript-string">'\0'</span>)
					<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> (action != key-&gt;dtak_action) {
			<span class="enscript-comment">/*
			 * We are aggregating on the same value in the same
			 * aggregation with two different aggregating actions.
			 * (This should have been picked up in the compiler,
			 * so we may be dealing with errant or devious DIF.)
			 * This is an error condition; we indicate as much,
			 * and return.
			 */</span>
			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-comment">/*
		 * This is a hit:  we need to apply the aggregator to
		 * the value at this key.
		 */</span>
		agg-&gt;dtag_aggregate((uint64_t *)(kdata + size), expr, arg);
		<span class="enscript-keyword">return</span>;
<span class="enscript-reference">next</span>:
		<span class="enscript-keyword">continue</span>;
	}

	<span class="enscript-comment">/*
	 * We didn't find it.  We need to allocate some zero-filled space,
	 * link it into the hash table appropriately, and apply the aggregator
	 * to the (zero-filled) value.
	 */</span>
	offs = buf-&gt;dtb_offset;
	<span class="enscript-keyword">while</span> (offs &amp; (align - 1))
		offs += <span class="enscript-keyword">sizeof</span> (uint32_t);

	<span class="enscript-comment">/*
	 * If we don't have enough room to both allocate a new key _and_
	 * its associated data, increment the drop count and return.
	 */</span>
	<span class="enscript-keyword">if</span> ((uintptr_t)tomax + offs + fsize &gt;
	    agb-&gt;dtagb_free - <span class="enscript-keyword">sizeof</span> (dtrace_aggkey_t)) {
		dtrace_buffer_drop(buf);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*CONSTCOND*/</span>
	ASSERT(!(<span class="enscript-keyword">sizeof</span> (dtrace_aggkey_t) &amp; (<span class="enscript-keyword">sizeof</span> (uintptr_t) - 1)));
	key = (dtrace_aggkey_t *)(agb-&gt;dtagb_free - <span class="enscript-keyword">sizeof</span> (dtrace_aggkey_t));
	agb-&gt;dtagb_free -= <span class="enscript-keyword">sizeof</span> (dtrace_aggkey_t);

	key-&gt;dtak_data = kdata = tomax + offs;
	buf-&gt;dtb_offset = offs + fsize;

	<span class="enscript-comment">/*
	 * Now copy the data across.
	 */</span>
	*((dtrace_aggid_t *)kdata) = agg-&gt;dtag_id;

	<span class="enscript-keyword">for</span> (i = <span class="enscript-keyword">sizeof</span> (dtrace_aggid_t); i &lt; size; i++)
		kdata[i] = data[i];

	<span class="enscript-comment">/*
	 * Because strings are not zeroed out by default, we need to iterate
	 * looking for actions that store strings, and we need to explicitly
	 * pad these strings out with zeroes.
	 */</span>
	<span class="enscript-keyword">for</span> (act = agg-&gt;dtag_first; act-&gt;dta_intuple; act = act-&gt;dta_next) {
		<span class="enscript-type">int</span> nul;

		<span class="enscript-keyword">if</span> (!DTRACEACT_ISSTRING(act))
			<span class="enscript-keyword">continue</span>;

		i = act-&gt;dta_rec.dtrd_offset - agg-&gt;dtag_base;
		limit = i + act-&gt;dta_rec.dtrd_size;
		ASSERT(limit &lt;= size);

		<span class="enscript-keyword">for</span> (nul = 0; i &lt; limit; i++) {
			<span class="enscript-keyword">if</span> (nul) {
				kdata[i] = <span class="enscript-string">'\0'</span>;
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">if</span> (data[i] != <span class="enscript-string">'\0'</span>)
				<span class="enscript-keyword">continue</span>;

			nul = 1;
		}
	}

	<span class="enscript-keyword">for</span> (i = size; i &lt; fsize; i++)
		kdata[i] = 0;

	key-&gt;dtak_hashval = hashval;
	key-&gt;dtak_size = size;
	key-&gt;dtak_action = action;
	key-&gt;dtak_next = agb-&gt;dtagb_hash[ndx];
	agb-&gt;dtagb_hash[ndx] = key;

	<span class="enscript-comment">/*
	 * Finally, apply the aggregator.
	 */</span>
	*((uint64_t *)(key-&gt;dtak_data + size)) = agg-&gt;dtag_initial;
	agg-&gt;dtag_aggregate((uint64_t *)(key-&gt;dtak_data + size), expr, arg);
}

<span class="enscript-comment">/*
 * Given consumer state, this routine finds a speculation in the INACTIVE
 * state and transitions it into the ACTIVE state.  If there is no speculation
 * in the INACTIVE state, 0 is returned.  In this case, no error counter is
 * incremented -- it is up to the caller to take appropriate action.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_speculation</span>(dtrace_state_t *state)
{
	<span class="enscript-type">int</span> i = 0;
	dtrace_speculation_state_t current;
	uint32_t *stat = &amp;state-&gt;dts_speculations_unavail, count;

	<span class="enscript-keyword">while</span> (i &lt; state-&gt;dts_nspeculations) {
		dtrace_speculation_t *spec = &amp;state-&gt;dts_speculations[i];

		current = spec-&gt;dtsp_state;

		<span class="enscript-keyword">if</span> (current != DTRACESPEC_INACTIVE) {
			<span class="enscript-keyword">if</span> (current == DTRACESPEC_COMMITTINGMANY ||
			    current == DTRACESPEC_COMMITTING ||
			    current == DTRACESPEC_DISCARDING)
				stat = &amp;state-&gt;dts_speculations_busy;
			i++;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (dtrace_cas32((uint32_t *)&amp;spec-&gt;dtsp_state,
		    current, DTRACESPEC_ACTIVE) == current)
			<span class="enscript-keyword">return</span> (i + 1);
	}

	<span class="enscript-comment">/*
	 * We couldn't find a speculation.  If we found as much as a single
	 * busy speculation buffer, we'll attribute this failure as &quot;busy&quot;
	 * instead of &quot;unavail&quot;.
	 */</span>
	<span class="enscript-keyword">do</span> {
		count = *stat;
	} <span class="enscript-keyword">while</span> (dtrace_cas32(stat, count, count + 1) != count);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * This routine commits an active speculation.  If the specified speculation
 * is not in a valid state to perform a commit(), this routine will silently do
 * nothing.  The state of the specified speculation is transitioned according
 * to the state transition diagram outlined in &lt;sys/dtrace_impl.h&gt;
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_speculation_commit</span>(dtrace_state_t *state, processorid_t cpu,
    dtrace_specid_t which)
{
	dtrace_speculation_t *spec;
	dtrace_buffer_t *src, *dest;
	uintptr_t daddr, saddr, dlimit, slimit;
	dtrace_speculation_state_t current,  new = DTRACESPEC_INACTIVE;
	intptr_t offs;
	uint64_t timestamp;

	<span class="enscript-keyword">if</span> (which == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (which &gt; (dtrace_specid_t)state-&gt;dts_nspeculations) {
		cpu_core[cpu].cpuc_dtrace_flags |= CPU_DTRACE_ILLOP;
		<span class="enscript-keyword">return</span>;
	}
	
	spec = &amp;state-&gt;dts_speculations[which - 1];
	src = &amp;spec-&gt;dtsp_buffer[cpu];
	dest = &amp;state-&gt;dts_buffer[cpu];

	<span class="enscript-keyword">do</span> {
		current = spec-&gt;dtsp_state;

		<span class="enscript-keyword">if</span> (current == DTRACESPEC_COMMITTINGMANY)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">switch</span> (current) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_INACTIVE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_DISCARDING</span>:
			<span class="enscript-keyword">return</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_COMMITTING</span>:
			<span class="enscript-comment">/*
			 * This is only possible if we are (a) commit()'ing
			 * without having done a prior speculate() on this CPU
			 * and (b) racing with another commit() on a different
			 * CPU.  There's nothing to do -- we just assert that
			 * our offset is 0.
			 */</span>
			ASSERT(src-&gt;dtb_offset == 0);
			<span class="enscript-keyword">return</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_ACTIVE</span>:
			new = DTRACESPEC_COMMITTING;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_ACTIVEONE</span>:
			<span class="enscript-comment">/*
			 * This speculation is active on one CPU.  If our
			 * buffer offset is non-zero, we know that the one CPU
			 * must be us.  Otherwise, we are committing on a
			 * different CPU from the speculate(), and we must
			 * rely on being asynchronously cleaned.
			 */</span>
			<span class="enscript-keyword">if</span> (src-&gt;dtb_offset != 0) {
				new = DTRACESPEC_COMMITTING;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/*FALLTHROUGH*/</span>

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_ACTIVEMANY</span>:
			new = DTRACESPEC_COMMITTINGMANY;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			ASSERT(0);
		}
	} <span class="enscript-keyword">while</span> (dtrace_cas32((uint32_t *)&amp;spec-&gt;dtsp_state,
	    current, new) != current);

	<span class="enscript-comment">/*
	 * We have set the state to indicate that we are committing this
	 * speculation.  Now reserve the necessary space in the destination
	 * buffer.
	 */</span>
	<span class="enscript-keyword">if</span> ((offs = dtrace_buffer_reserve(dest, src-&gt;dtb_offset,
	    <span class="enscript-keyword">sizeof</span> (uint64_t), state, NULL)) &lt; 0) {
		dtrace_buffer_drop(dest);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * We have sufficient space to copy the speculative buffer into the
	 * primary buffer.  First, modify the speculative buffer, filling
	 * in the timestamp of all entries with the current time.  The data
	 * must have the commit() time rather than the time it was traced,
	 * so that all entries in the primary buffer are in timestamp order.
	 */</span>
	timestamp = dtrace_gethrtime();
	saddr = (uintptr_t)src-&gt;dtb_tomax;
	slimit = saddr + src-&gt;dtb_offset;
	<span class="enscript-keyword">while</span> (saddr &lt; slimit) {
		size_t size;
		dtrace_rechdr_t *dtrh = (dtrace_rechdr_t *)saddr;

		<span class="enscript-keyword">if</span> (dtrh-&gt;dtrh_epid == DTRACE_EPIDNONE) {
			saddr += <span class="enscript-keyword">sizeof</span> (dtrace_epid_t);
			<span class="enscript-keyword">continue</span>;
		}

		ASSERT(dtrh-&gt;dtrh_epid &lt;= ((dtrace_epid_t) state-&gt;dts_necbs));
		size = state-&gt;dts_ecbs[dtrh-&gt;dtrh_epid - 1]-&gt;dte_size;

		ASSERT(saddr + size &lt;= slimit);
		ASSERT(size &gt;= <span class="enscript-keyword">sizeof</span>(dtrace_rechdr_t));
		ASSERT(DTRACE_RECORD_LOAD_TIMESTAMP(dtrh) == UINT64_MAX);

		DTRACE_RECORD_STORE_TIMESTAMP(dtrh, timestamp);

		saddr += size;
	}

	<span class="enscript-comment">/*
	 * Copy the buffer across.  (Note that this is a
	 * highly subobtimal bcopy(); in the unlikely event that this becomes
	 * a serious performance issue, a high-performance DTrace-specific
	 * bcopy() should obviously be invented.)
	 */</span>
	daddr = (uintptr_t)dest-&gt;dtb_tomax + offs;
	dlimit = daddr + src-&gt;dtb_offset;
	saddr = (uintptr_t)src-&gt;dtb_tomax;

	<span class="enscript-comment">/*
	 * First, the aligned portion.
	 */</span>
	<span class="enscript-keyword">while</span> (dlimit - daddr &gt;= <span class="enscript-keyword">sizeof</span> (uint64_t)) {
		*((uint64_t *)daddr) = *((uint64_t *)saddr);

		daddr += <span class="enscript-keyword">sizeof</span> (uint64_t);
		saddr += <span class="enscript-keyword">sizeof</span> (uint64_t);
	}

	<span class="enscript-comment">/*
	 * Now any left-over bit...
	 */</span>
	<span class="enscript-keyword">while</span> (dlimit - daddr)
		*((uint8_t *)daddr++) = *((uint8_t *)saddr++);

	<span class="enscript-comment">/*
	 * Finally, commit the reserved space in the destination buffer.
	 */</span>
	dest-&gt;dtb_offset = offs + src-&gt;dtb_offset;

<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/*
	 * If we're lucky enough to be the only active CPU on this speculation
	 * buffer, we can just set the state back to DTRACESPEC_INACTIVE.
	 */</span>
	<span class="enscript-keyword">if</span> (current == DTRACESPEC_ACTIVE ||
	    (current == DTRACESPEC_ACTIVEONE &amp;&amp; new == DTRACESPEC_COMMITTING)) {
		uint32_t rval = dtrace_cas32((uint32_t *)&amp;spec-&gt;dtsp_state,
		    DTRACESPEC_COMMITTING, DTRACESPEC_INACTIVE);
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">rval</span>) <span class="enscript-comment">/* __APPLE__ */</span>

		ASSERT(rval == DTRACESPEC_COMMITTING);
	}

	src-&gt;dtb_offset = 0;
	src-&gt;dtb_xamot_drops += src-&gt;dtb_drops;
	src-&gt;dtb_drops = 0;
}

<span class="enscript-comment">/*
 * This routine discards an active speculation.  If the specified speculation
 * is not in a valid state to perform a discard(), this routine will silently
 * do nothing.  The state of the specified speculation is transitioned
 * according to the state transition diagram outlined in &lt;sys/dtrace_impl.h&gt;
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_speculation_discard</span>(dtrace_state_t *state, processorid_t cpu,
    dtrace_specid_t which)
{
	dtrace_speculation_t *spec;
	dtrace_speculation_state_t current, new = DTRACESPEC_INACTIVE;
	dtrace_buffer_t *buf;

	<span class="enscript-keyword">if</span> (which == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (which &gt; (dtrace_specid_t)state-&gt;dts_nspeculations) {
		cpu_core[cpu].cpuc_dtrace_flags |= CPU_DTRACE_ILLOP;
		<span class="enscript-keyword">return</span>;
	}

	spec = &amp;state-&gt;dts_speculations[which - 1];
	buf = &amp;spec-&gt;dtsp_buffer[cpu];

	<span class="enscript-keyword">do</span> {
		current = spec-&gt;dtsp_state;

		<span class="enscript-keyword">switch</span> (current) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_INACTIVE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_COMMITTINGMANY</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_COMMITTING</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_DISCARDING</span>:
			<span class="enscript-keyword">return</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_ACTIVE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_ACTIVEMANY</span>:
			new = DTRACESPEC_DISCARDING;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_ACTIVEONE</span>:
			<span class="enscript-keyword">if</span> (buf-&gt;dtb_offset != 0) {
				new = DTRACESPEC_INACTIVE;
			} <span class="enscript-keyword">else</span> {
				new = DTRACESPEC_DISCARDING;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			ASSERT(0);
		}
	} <span class="enscript-keyword">while</span> (dtrace_cas32((uint32_t *)&amp;spec-&gt;dtsp_state,
	    current, new) != current);

	buf-&gt;dtb_offset = 0;
	buf-&gt;dtb_drops = 0;
}

<span class="enscript-comment">/*
 * Note:  not called from probe context.  This function is called
 * asynchronously from cross call context to clean any speculations that are
 * in the COMMITTINGMANY or DISCARDING states.  These speculations may not be
 * transitioned back to the INACTIVE state until all CPUs have cleaned the
 * speculation.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_speculation_clean_here</span>(dtrace_state_t *state)
{
	dtrace_icookie_t cookie;
	processorid_t cpu = CPU-&gt;cpu_id;
	dtrace_buffer_t *dest = &amp;state-&gt;dts_buffer[cpu];
	dtrace_specid_t i;

	cookie = dtrace_interrupt_disable();

	<span class="enscript-keyword">if</span> (dest-&gt;dtb_tomax == NULL) {
		dtrace_interrupt_enable(cookie);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">for</span> (i = 0; i &lt; (dtrace_specid_t)state-&gt;dts_nspeculations; i++) {
		dtrace_speculation_t *spec = &amp;state-&gt;dts_speculations[i];
		dtrace_buffer_t *src = &amp;spec-&gt;dtsp_buffer[cpu];

		<span class="enscript-keyword">if</span> (src-&gt;dtb_tomax == NULL)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (spec-&gt;dtsp_state == DTRACESPEC_DISCARDING) {
			src-&gt;dtb_offset = 0;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (spec-&gt;dtsp_state != DTRACESPEC_COMMITTINGMANY)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (src-&gt;dtb_offset == 0)
			<span class="enscript-keyword">continue</span>;

		dtrace_speculation_commit(state, cpu, i + 1);
	}

	dtrace_interrupt_enable(cookie);
}

<span class="enscript-comment">/*
 * Note:  not called from probe context.  This function is called
 * asynchronously (and at a regular interval) to clean any speculations that
 * are in the COMMITTINGMANY or DISCARDING states.  If it discovers that there
 * is work to be done, it cross calls all CPUs to perform that work;
 * COMMITMANY and DISCARDING speculations may not be transitioned back to the
 * INACTIVE state until they have been cleaned by all CPUs.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_speculation_clean</span>(dtrace_state_t *state)
{
	<span class="enscript-type">int</span> work = 0;
	uint32_t rv;
	dtrace_specid_t i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; (dtrace_specid_t)state-&gt;dts_nspeculations; i++) {
		dtrace_speculation_t *spec = &amp;state-&gt;dts_speculations[i];

		ASSERT(!spec-&gt;dtsp_cleaning);

		<span class="enscript-keyword">if</span> (spec-&gt;dtsp_state != DTRACESPEC_DISCARDING &amp;&amp;
		    spec-&gt;dtsp_state != DTRACESPEC_COMMITTINGMANY)
			<span class="enscript-keyword">continue</span>;

		work++;
		spec-&gt;dtsp_cleaning = 1;
	}

	<span class="enscript-keyword">if</span> (!work)
		<span class="enscript-keyword">return</span>;

	dtrace_xcall(DTRACE_CPUALL,
	    (dtrace_xcall_t)dtrace_speculation_clean_here, state);

	<span class="enscript-comment">/*
	 * We now know that all CPUs have committed or discarded their
	 * speculation buffers, as appropriate.  We can now set the state
	 * to inactive.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; (dtrace_specid_t)state-&gt;dts_nspeculations; i++) {
		dtrace_speculation_t *spec = &amp;state-&gt;dts_speculations[i];
		dtrace_speculation_state_t current, new;

		<span class="enscript-keyword">if</span> (!spec-&gt;dtsp_cleaning)
			<span class="enscript-keyword">continue</span>;

		current = spec-&gt;dtsp_state;
		ASSERT(current == DTRACESPEC_DISCARDING ||
		    current == DTRACESPEC_COMMITTINGMANY);

		new = DTRACESPEC_INACTIVE;

		rv = dtrace_cas32((uint32_t *)&amp;spec-&gt;dtsp_state, current, new);
		ASSERT(rv == current);
		spec-&gt;dtsp_cleaning = 0;
	}
}

<span class="enscript-comment">/*
 * Called as part of a speculate() to get the speculative buffer associated
 * with a given speculation.  Returns NULL if the specified speculation is not
 * in an ACTIVE state.  If the speculation is in the ACTIVEONE state -- and
 * the active CPU is not the specified CPU -- the speculation will be
 * atomically transitioned into the ACTIVEMANY state.
 */</span>
<span class="enscript-type">static</span> dtrace_buffer_t *
<span class="enscript-function-name">dtrace_speculation_buffer</span>(dtrace_state_t *state, processorid_t cpuid,
    dtrace_specid_t which)
{
	dtrace_speculation_t *spec;
	dtrace_speculation_state_t current, new = DTRACESPEC_INACTIVE;
	dtrace_buffer_t *buf;

	<span class="enscript-keyword">if</span> (which == 0)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">if</span> (which &gt; (dtrace_specid_t)state-&gt;dts_nspeculations) {
		cpu_core[cpuid].cpuc_dtrace_flags |= CPU_DTRACE_ILLOP;
		<span class="enscript-keyword">return</span> (NULL);
	}

	spec = &amp;state-&gt;dts_speculations[which - 1];
	buf = &amp;spec-&gt;dtsp_buffer[cpuid];

	<span class="enscript-keyword">do</span> {
		current = spec-&gt;dtsp_state;

		<span class="enscript-keyword">switch</span> (current) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_INACTIVE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_COMMITTINGMANY</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_DISCARDING</span>:
			<span class="enscript-keyword">return</span> (NULL);

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_COMMITTING</span>:
			ASSERT(buf-&gt;dtb_offset == 0);
			<span class="enscript-keyword">return</span> (NULL);

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_ACTIVEONE</span>:
			<span class="enscript-comment">/*
			 * This speculation is currently active on one CPU.
			 * Check the offset in the buffer; if it's non-zero,
			 * that CPU must be us (and we leave the state alone).
			 * If it's zero, assume that we're starting on a new
			 * CPU -- and change the state to indicate that the
			 * speculation is active on more than one CPU.
			 */</span>
			<span class="enscript-keyword">if</span> (buf-&gt;dtb_offset != 0)
				<span class="enscript-keyword">return</span> (buf);

			new = DTRACESPEC_ACTIVEMANY;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_ACTIVEMANY</span>:
			<span class="enscript-keyword">return</span> (buf);

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACESPEC_ACTIVE</span>:
			new = DTRACESPEC_ACTIVEONE;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			ASSERT(0);
		}
	} <span class="enscript-keyword">while</span> (dtrace_cas32((uint32_t *)&amp;spec-&gt;dtsp_state,
	    current, new) != current);

	ASSERT(new == DTRACESPEC_ACTIVEONE || new == DTRACESPEC_ACTIVEMANY);
	<span class="enscript-keyword">return</span> (buf);
}

<span class="enscript-comment">/*
 * Return a string.  In the event that the user lacks the privilege to access
 * arbitrary kernel memory, we copy the string out to scratch memory so that we
 * don't fail access checking.
 *
 * dtrace_dif_variable() uses this routine as a helper for various
 * builtin values such as 'execname' and 'probefunc.'
 */</span>
<span class="enscript-type">static</span>
uintptr_t
<span class="enscript-function-name">dtrace_dif_varstr</span>(uintptr_t addr, dtrace_state_t *state,
    dtrace_mstate_t *mstate)
{
	uint64_t size = state-&gt;dts_options[DTRACEOPT_STRSIZE];
	uintptr_t ret;
	size_t strsz;

	<span class="enscript-comment">/*
	 * The easy case: this probe is allowed to read all of memory, so
	 * we can just return this as a vanilla pointer.
	 */</span>
	<span class="enscript-keyword">if</span> ((mstate-&gt;dtms_access &amp; DTRACE_ACCESS_KERNEL) != 0)
		<span class="enscript-keyword">return</span> (addr);

	<span class="enscript-comment">/*
	 * This is the tougher case: we copy the string in question from
	 * kernel memory into scratch memory and return it that way: this
	 * ensures that we won't trip up when access checking tests the
	 * BYREF return value.
	 */</span>
	strsz = dtrace_strlen((<span class="enscript-type">char</span> *)addr, size) + 1;

	<span class="enscript-keyword">if</span> (mstate-&gt;dtms_scratch_ptr + strsz &gt;
	    mstate-&gt;dtms_scratch_base + mstate-&gt;dtms_scratch_size) {
		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
		<span class="enscript-keyword">return</span> (0);
	}

	dtrace_strcpy((<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)addr, (<span class="enscript-type">void</span> *)mstate-&gt;dtms_scratch_ptr,
	    strsz);
	ret = mstate-&gt;dtms_scratch_ptr;
	mstate-&gt;dtms_scratch_ptr += strsz;
	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-comment">/*
 * This function implements the DIF emulator's variable lookups.  The emulator
 * passes a reserved variable identifier and optional built-in array index.
 */</span>
<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">dtrace_dif_variable</span>(dtrace_mstate_t *mstate, dtrace_state_t *state, uint64_t v,
    uint64_t ndx)
{
	<span class="enscript-comment">/*
	 * If we're accessing one of the uncached arguments, we'll turn this
	 * into a reference in the args array.
	 */</span>
	<span class="enscript-keyword">if</span> (v &gt;= DIF_VAR_ARG0 &amp;&amp; v &lt;= DIF_VAR_ARG9) {
		ndx = v - DIF_VAR_ARG0;
		v = DIF_VAR_ARGS;
	}

	<span class="enscript-keyword">switch</span> (v) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_ARGS</span>:
		ASSERT(mstate-&gt;dtms_present &amp; DTRACE_MSTATE_ARGS);
		<span class="enscript-keyword">if</span> (ndx &gt;= <span class="enscript-keyword">sizeof</span> (mstate-&gt;dtms_arg) /
		    <span class="enscript-keyword">sizeof</span> (mstate-&gt;dtms_arg[0])) {
			<span class="enscript-comment">/*
			 * APPLE NOTE: Account for introduction of __dtrace_probe()
			 */</span>
			<span class="enscript-type">int</span> aframes = mstate-&gt;dtms_probe-&gt;dtpr_aframes + 3;
			dtrace_provider_t *pv;
			uint64_t val;

			pv = mstate-&gt;dtms_probe-&gt;dtpr_provider;
			<span class="enscript-keyword">if</span> (pv-&gt;dtpv_pops.dtps_getargval != NULL)
				val = pv-&gt;dtpv_pops.dtps_getargval(pv-&gt;dtpv_arg,
				    mstate-&gt;dtms_probe-&gt;dtpr_id,
				    mstate-&gt;dtms_probe-&gt;dtpr_arg, ndx, aframes);
			<span class="enscript-comment">/* Special case access of arg5 as passed to dtrace_probe_error() (which see.) */</span>
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mstate-&gt;dtms_probe-&gt;dtpr_id == dtrace_probeid_error &amp;&amp; ndx == 5) {
			        <span class="enscript-keyword">return</span> ((dtrace_state_t *)(uintptr_t)(mstate-&gt;dtms_arg[0]))-&gt;dts_arg_error_illval;
			}

			<span class="enscript-keyword">else</span>
				val = dtrace_getarg(ndx, aframes);

			<span class="enscript-comment">/*
			 * This is regrettably required to keep the compiler
			 * from tail-optimizing the call to dtrace_getarg().
			 * The condition always evaluates to true, but the
			 * compiler has no way of figuring that out a priori.
			 * (None of this would be necessary if the compiler
			 * could be relied upon to _always_ tail-optimize
			 * the call to dtrace_getarg() -- but it can't.)
			 */</span>
			<span class="enscript-keyword">if</span> (mstate-&gt;dtms_probe != NULL)
				<span class="enscript-keyword">return</span> (val);

			ASSERT(0);
		}

		<span class="enscript-keyword">return</span> (mstate-&gt;dtms_arg[ndx]);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_UREGS</span>: {
		thread_t thread;

		<span class="enscript-keyword">if</span> (!dtrace_priv_proc(state))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">if</span> ((thread = current_thread()) == NULL) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
			cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_illval = 0;
			<span class="enscript-keyword">return</span> (0);
		}

		<span class="enscript-keyword">return</span> (dtrace_getreg(find_user_regs(thread), ndx));
	}


	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_CURTHREAD</span>:
		<span class="enscript-keyword">if</span> (!dtrace_priv_kernel(state))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">return</span> ((uint64_t)(uintptr_t)current_thread());

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_TIMESTAMP</span>:
		<span class="enscript-keyword">if</span> (!(mstate-&gt;dtms_present &amp; DTRACE_MSTATE_TIMESTAMP)) {
			mstate-&gt;dtms_timestamp = dtrace_gethrtime();
			mstate-&gt;dtms_present |= DTRACE_MSTATE_TIMESTAMP;
		}
		<span class="enscript-keyword">return</span> (mstate-&gt;dtms_timestamp);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_VTIMESTAMP</span>:
		ASSERT(dtrace_vtime_references != 0);
		<span class="enscript-keyword">return</span> (dtrace_get_thread_vtime(current_thread()));

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_WALLTIMESTAMP</span>:
		<span class="enscript-keyword">if</span> (!(mstate-&gt;dtms_present &amp; DTRACE_MSTATE_WALLTIMESTAMP)) {
			mstate-&gt;dtms_walltimestamp = dtrace_gethrestime();
			mstate-&gt;dtms_present |= DTRACE_MSTATE_WALLTIMESTAMP;
		}
		<span class="enscript-keyword">return</span> (mstate-&gt;dtms_walltimestamp);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_MACHTIMESTAMP</span>:
		<span class="enscript-keyword">if</span> (!(mstate-&gt;dtms_present &amp; DTRACE_MSTATE_MACHTIMESTAMP)) {
			mstate-&gt;dtms_machtimestamp = mach_absolute_time();
			mstate-&gt;dtms_present |= DTRACE_MSTATE_MACHTIMESTAMP;
		}
		<span class="enscript-keyword">return</span> (mstate-&gt;dtms_machtimestamp);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_CPU</span>:
		<span class="enscript-keyword">return</span> ((uint64_t) dtrace_get_thread_last_cpu_id(current_thread()));

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_IPL</span>:
		<span class="enscript-keyword">if</span> (!dtrace_priv_kernel(state))
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-keyword">if</span> (!(mstate-&gt;dtms_present &amp; DTRACE_MSTATE_IPL)) {
			mstate-&gt;dtms_ipl = dtrace_getipl();
			mstate-&gt;dtms_present |= DTRACE_MSTATE_IPL;
		}
		<span class="enscript-keyword">return</span> (mstate-&gt;dtms_ipl);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_EPID</span>:
		ASSERT(mstate-&gt;dtms_present &amp; DTRACE_MSTATE_EPID);
		<span class="enscript-keyword">return</span> (mstate-&gt;dtms_epid);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_ID</span>:
		ASSERT(mstate-&gt;dtms_present &amp; DTRACE_MSTATE_PROBE);
		<span class="enscript-keyword">return</span> (mstate-&gt;dtms_probe-&gt;dtpr_id);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_STACKDEPTH</span>:
		<span class="enscript-keyword">if</span> (!dtrace_priv_kernel(state))
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-keyword">if</span> (!(mstate-&gt;dtms_present &amp; DTRACE_MSTATE_STACKDEPTH)) {
			<span class="enscript-comment">/*
			 * APPLE NOTE: Account for introduction of __dtrace_probe()
			 */</span>
			<span class="enscript-type">int</span> aframes = mstate-&gt;dtms_probe-&gt;dtpr_aframes + 3;

			mstate-&gt;dtms_stackdepth = dtrace_getstackdepth(aframes);
			mstate-&gt;dtms_present |= DTRACE_MSTATE_STACKDEPTH;
		}
		<span class="enscript-keyword">return</span> (mstate-&gt;dtms_stackdepth);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_USTACKDEPTH</span>:
		<span class="enscript-keyword">if</span> (!dtrace_priv_proc(state))
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-keyword">if</span> (!(mstate-&gt;dtms_present &amp; DTRACE_MSTATE_USTACKDEPTH)) {
			<span class="enscript-comment">/*
			 * See comment in DIF_VAR_PID.
			 */</span>
			<span class="enscript-keyword">if</span> (DTRACE_ANCHORED(mstate-&gt;dtms_probe) &amp;&amp;
			    CPU_ON_INTR(CPU)) {
				mstate-&gt;dtms_ustackdepth = 0;
			} <span class="enscript-keyword">else</span> {
				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
				mstate-&gt;dtms_ustackdepth =
				    dtrace_getustackdepth();
				DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
			}
			mstate-&gt;dtms_present |= DTRACE_MSTATE_USTACKDEPTH;
		}
		<span class="enscript-keyword">return</span> (mstate-&gt;dtms_ustackdepth);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_CALLER</span>:
		<span class="enscript-keyword">if</span> (!dtrace_priv_kernel(state))
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-keyword">if</span> (!(mstate-&gt;dtms_present &amp; DTRACE_MSTATE_CALLER)) {
			<span class="enscript-comment">/*
			 * APPLE NOTE: Account for introduction of __dtrace_probe()
			 */</span>
			<span class="enscript-type">int</span> aframes = mstate-&gt;dtms_probe-&gt;dtpr_aframes + 3;

			<span class="enscript-keyword">if</span> (!DTRACE_ANCHORED(mstate-&gt;dtms_probe)) {
				<span class="enscript-comment">/*
				 * If this is an unanchored probe, we are
				 * required to go through the slow path:
				 * dtrace_caller() only guarantees correct
				 * results for anchored probes.
				 */</span>
				pc_t caller[2];

				dtrace_getpcstack(caller, 2, aframes,
				    (uint32_t *)(uintptr_t)mstate-&gt;dtms_arg[0]);
				mstate-&gt;dtms_caller = caller[1];
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((mstate-&gt;dtms_caller =
				dtrace_caller(aframes)) == (uintptr_t)-1) {
				<span class="enscript-comment">/*
				 * We have failed to do this the quick way;
				 * we must resort to the slower approach of
				 * calling dtrace_getpcstack().
				 */</span>
				pc_t caller;

				dtrace_getpcstack(&amp;caller, 1, aframes, NULL);
				mstate-&gt;dtms_caller = caller;
			}

			mstate-&gt;dtms_present |= DTRACE_MSTATE_CALLER;
		}
		<span class="enscript-keyword">return</span> (mstate-&gt;dtms_caller);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_UCALLER</span>:
		<span class="enscript-keyword">if</span> (!dtrace_priv_proc(state))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">if</span> (!(mstate-&gt;dtms_present &amp; DTRACE_MSTATE_UCALLER)) {
			uint64_t ustack[3];

			<span class="enscript-comment">/*
			 * dtrace_getupcstack() fills in the first uint64_t
			 * with the current PID.  The second uint64_t will
			 * be the program counter at user-level.  The third
			 * uint64_t will contain the caller, which is what
			 * we're after.
			 */</span>
			ustack[2] = 0;
			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
			dtrace_getupcstack(ustack, 3);
			DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
			mstate-&gt;dtms_ucaller = ustack[2];
			mstate-&gt;dtms_present |= DTRACE_MSTATE_UCALLER;
		}

		<span class="enscript-keyword">return</span> (mstate-&gt;dtms_ucaller);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_PROBEPROV</span>:
		ASSERT(mstate-&gt;dtms_present &amp; DTRACE_MSTATE_PROBE);
		<span class="enscript-keyword">return</span> (dtrace_dif_varstr(
		    (uintptr_t)mstate-&gt;dtms_probe-&gt;dtpr_provider-&gt;dtpv_name,
		    state, mstate));

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_PROBEMOD</span>:
		ASSERT(mstate-&gt;dtms_present &amp; DTRACE_MSTATE_PROBE);
		<span class="enscript-keyword">return</span> (dtrace_dif_varstr(
		    (uintptr_t)mstate-&gt;dtms_probe-&gt;dtpr_mod,
		    state, mstate));

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_PROBEFUNC</span>:
		ASSERT(mstate-&gt;dtms_present &amp; DTRACE_MSTATE_PROBE);
		<span class="enscript-keyword">return</span> (dtrace_dif_varstr(
		    (uintptr_t)mstate-&gt;dtms_probe-&gt;dtpr_func,
		    state, mstate));

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_PROBENAME</span>:
		ASSERT(mstate-&gt;dtms_present &amp; DTRACE_MSTATE_PROBE);
		<span class="enscript-keyword">return</span> (dtrace_dif_varstr(
		    (uintptr_t)mstate-&gt;dtms_probe-&gt;dtpr_name,
		    state, mstate));

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_PID</span>:
		<span class="enscript-keyword">if</span> (!dtrace_priv_proc_relaxed(state))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-comment">/*
		 * Note that we are assuming that an unanchored probe is
		 * always due to a high-level interrupt.  (And we're assuming
		 * that there is only a single high level interrupt.)
		 */</span>
		<span class="enscript-keyword">if</span> (DTRACE_ANCHORED(mstate-&gt;dtms_probe) &amp;&amp; CPU_ON_INTR(CPU))
			<span class="enscript-comment">/* Anchored probe that fires while on an interrupt accrues to process 0 */</span>
			<span class="enscript-keyword">return</span> 0; 

		<span class="enscript-keyword">return</span> ((uint64_t)dtrace_proc_selfpid());

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_PPID</span>:
		<span class="enscript-keyword">if</span> (!dtrace_priv_proc_relaxed(state))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-comment">/*
		 * See comment in DIF_VAR_PID.
		 */</span>
		<span class="enscript-keyword">if</span> (DTRACE_ANCHORED(mstate-&gt;dtms_probe) &amp;&amp; CPU_ON_INTR(CPU))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">return</span> ((uint64_t)dtrace_proc_selfppid());

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_TID</span>:
		<span class="enscript-comment">/* We do not need to check for null current_thread() */</span>
		<span class="enscript-keyword">return</span> thread_tid(current_thread()); <span class="enscript-comment">/* globally unique */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_PTHREAD_SELF</span>:
		<span class="enscript-keyword">if</span> (!dtrace_priv_proc(state))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-comment">/* Not currently supported, but we should be able to delta the dispatchqaddr and dispatchqoffset to get pthread_self */</span>
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_DISPATCHQADDR</span>:
		<span class="enscript-keyword">if</span> (!dtrace_priv_proc(state))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-comment">/* We do not need to check for null current_thread() */</span>
		<span class="enscript-keyword">return</span> thread_dispatchqaddr(current_thread());

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_EXECNAME</span>:
	{
		<span class="enscript-type">char</span> *xname = (<span class="enscript-type">char</span> *)mstate-&gt;dtms_scratch_ptr;
		size_t scratch_size = MAXCOMLEN+1;
		
		<span class="enscript-comment">/* The scratch allocation's lifetime is that of the clause. */</span>
		<span class="enscript-keyword">if</span> (!DTRACE_INSCRATCH(mstate, scratch_size)) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
			<span class="enscript-keyword">return</span> 0;
		}
			
		<span class="enscript-keyword">if</span> (!dtrace_priv_proc_relaxed(state))
			<span class="enscript-keyword">return</span> (0);

		mstate-&gt;dtms_scratch_ptr += scratch_size;
		proc_selfname( xname, scratch_size );

		<span class="enscript-keyword">return</span> ((uint64_t)(uintptr_t)xname);
	}


	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_ZONENAME</span>:
        {
                <span class="enscript-comment">/* scratch_size is equal to length('global') + 1 for the null-terminator. */</span>
                <span class="enscript-type">char</span> *zname = (<span class="enscript-type">char</span> *)mstate-&gt;dtms_scratch_ptr;
                size_t scratch_size = 6 + 1;

		<span class="enscript-keyword">if</span> (!dtrace_priv_proc(state))
			<span class="enscript-keyword">return</span> (0);

                <span class="enscript-comment">/* The scratch allocation's lifetime is that of the clause. */</span>
                <span class="enscript-keyword">if</span> (!DTRACE_INSCRATCH(mstate, scratch_size)) {
                        DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
                        <span class="enscript-keyword">return</span> 0;
                }

                mstate-&gt;dtms_scratch_ptr += scratch_size;

                <span class="enscript-comment">/* The kernel does not provide zonename, it will always return 'global'. */</span>
                strlcpy(zname, <span class="enscript-string">&quot;global&quot;</span>, scratch_size);

                <span class="enscript-keyword">return</span> ((uint64_t)(uintptr_t)zname);
        }

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_UID</span>:
		<span class="enscript-keyword">if</span> (!dtrace_priv_proc_relaxed(state))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-comment">/*
		 * See comment in DIF_VAR_PID.
		 */</span>
		<span class="enscript-keyword">if</span> (DTRACE_ANCHORED(mstate-&gt;dtms_probe) &amp;&amp; CPU_ON_INTR(CPU))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">return</span> ((uint64_t) dtrace_proc_selfruid());

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_GID</span>:
		<span class="enscript-keyword">if</span> (!dtrace_priv_proc(state))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-comment">/*
		 * See comment in DIF_VAR_PID.
		 */</span>
		<span class="enscript-keyword">if</span> (DTRACE_ANCHORED(mstate-&gt;dtms_probe) &amp;&amp; CPU_ON_INTR(CPU))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">if</span> (dtrace_CRED() != NULL)
			<span class="enscript-comment">/* Credential does not require lazy initialization. */</span>
			<span class="enscript-keyword">return</span> ((uint64_t)kauth_getgid());
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* proc_lock would be taken under kauth_cred_proc_ref() in kauth_cred_get(). */</span>
			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
			<span class="enscript-keyword">return</span> -1ULL;
		}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_ERRNO</span>: {
		uthread_t uthread = (uthread_t)get_bsdthread_info(current_thread());
		<span class="enscript-keyword">if</span> (!dtrace_priv_proc(state))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-comment">/*
		 * See comment in DIF_VAR_PID.
		 */</span>
		<span class="enscript-keyword">if</span> (DTRACE_ANCHORED(mstate-&gt;dtms_probe) &amp;&amp; CPU_ON_INTR(CPU))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">if</span> (uthread)
			<span class="enscript-keyword">return</span> (uint64_t)uthread-&gt;t_dtrace_errno;
		<span class="enscript-keyword">else</span> {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
			<span class="enscript-keyword">return</span> -1ULL;
		}
	}

	<span class="enscript-reference">default</span>:
		DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
		<span class="enscript-keyword">return</span> (0);
	}
}

<span class="enscript-comment">/*
 * Emulate the execution of DTrace ID subroutines invoked by the call opcode.
 * Notice that we don't bother validating the proper number of arguments or
 * their types in the tuple stack.  This isn't needed because all argument
 * interpretation is safe because of our load safety -- the worst that can
 * happen is that a bogus program can obtain bogus results.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_dif_subr</span>(uint_t subr, uint_t rd, uint64_t *regs,
    dtrace_key_t *tupregs, <span class="enscript-type">int</span> nargs,
    dtrace_mstate_t *mstate, dtrace_state_t *state)
{
	<span class="enscript-type">volatile</span> uint16_t *flags = &amp;cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags;
	<span class="enscript-type">volatile</span> uint64_t *illval = &amp;cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_illval;
	dtrace_vstate_t *vstate = &amp;state-&gt;dts_vstate;

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
	<span class="enscript-type">union</span> {
		mutex_impl_t mi;
		uint64_t mx;
	} m;

	<span class="enscript-type">union</span> {
		krwlock_t ri;
		uintptr_t rw;
	} r;
#<span class="enscript-reference">else</span>
<span class="enscript-comment">/* FIXME: awaits lock/mutex work */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

	<span class="enscript-keyword">switch</span> (subr) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_RAND</span>:
		regs[rd] = (dtrace_gethrtime() * 2416 + 374441) % 1771875;
		<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_MUTEX_OWNED</span>:
		<span class="enscript-keyword">if</span> (!dtrace_canload(tupregs[0].dttk_value, <span class="enscript-keyword">sizeof</span> (kmutex_t),
		    mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		m.mx = dtrace_load64(tupregs[0].dttk_value);
		<span class="enscript-keyword">if</span> (MUTEX_TYPE_ADAPTIVE(&amp;m.mi))
			regs[rd] = MUTEX_OWNER(&amp;m.mi) != MUTEX_NO_OWNER;
		<span class="enscript-keyword">else</span>
			regs[rd] = LOCK_HELD(&amp;m.mi.m_spin.m_spinlock);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_MUTEX_OWNER</span>:
		<span class="enscript-keyword">if</span> (!dtrace_canload(tupregs[0].dttk_value, <span class="enscript-keyword">sizeof</span> (kmutex_t),
		    mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		m.mx = dtrace_load64(tupregs[0].dttk_value);
		<span class="enscript-keyword">if</span> (MUTEX_TYPE_ADAPTIVE(&amp;m.mi) &amp;&amp;
		    MUTEX_OWNER(&amp;m.mi) != MUTEX_NO_OWNER)
			regs[rd] = (uintptr_t)MUTEX_OWNER(&amp;m.mi);
		<span class="enscript-keyword">else</span>
			regs[rd] = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_MUTEX_TYPE_ADAPTIVE</span>:
		<span class="enscript-keyword">if</span> (!dtrace_canload(tupregs[0].dttk_value, <span class="enscript-keyword">sizeof</span> (kmutex_t),
		    mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		m.mx = dtrace_load64(tupregs[0].dttk_value);
		regs[rd] = MUTEX_TYPE_ADAPTIVE(&amp;m.mi);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_MUTEX_TYPE_SPIN</span>:
		<span class="enscript-keyword">if</span> (!dtrace_canload(tupregs[0].dttk_value, <span class="enscript-keyword">sizeof</span> (kmutex_t),
		    mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		m.mx = dtrace_load64(tupregs[0].dttk_value);
		regs[rd] = MUTEX_TYPE_SPIN(&amp;m.mi);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_RW_READ_HELD</span>: {
		uintptr_t tmp;

		<span class="enscript-keyword">if</span> (!dtrace_canload(tupregs[0].dttk_value, <span class="enscript-keyword">sizeof</span> (uintptr_t),
		    mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		r.rw = dtrace_loadptr(tupregs[0].dttk_value);
		regs[rd] = _RW_READ_HELD(&amp;r.ri, tmp);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_RW_WRITE_HELD</span>:
		<span class="enscript-keyword">if</span> (!dtrace_canload(tupregs[0].dttk_value, <span class="enscript-keyword">sizeof</span> (krwlock_t),
		    mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		r.rw = dtrace_loadptr(tupregs[0].dttk_value);
		regs[rd] = _RW_WRITE_HELD(&amp;r.ri);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_RW_ISWRITER</span>:
		<span class="enscript-keyword">if</span> (!dtrace_canload(tupregs[0].dttk_value, <span class="enscript-keyword">sizeof</span> (krwlock_t),
		    mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		r.rw = dtrace_loadptr(tupregs[0].dttk_value);
		regs[rd] = _RW_ISWRITER(&amp;r.ri);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">else</span>
<span class="enscript-comment">/* FIXME: awaits lock/mutex work */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_BCOPY</span>: {
		<span class="enscript-comment">/*
		 * We need to be sure that the destination is in the scratch
		 * region -- no other region is allowed.
		 */</span>
		uintptr_t src = tupregs[0].dttk_value;
		uintptr_t dest = tupregs[1].dttk_value;
		size_t size = tupregs[2].dttk_value;

		<span class="enscript-keyword">if</span> (!dtrace_inscratch(dest, size, mstate)) {
			*flags |= CPU_DTRACE_BADADDR;
			*illval = regs[rd];
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (!dtrace_canload(src, size, mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		dtrace_bcopy((<span class="enscript-type">void</span> *)src, (<span class="enscript-type">void</span> *)dest, size);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_ALLOCA</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_COPYIN</span>: {
		uintptr_t dest = P2ROUNDUP(mstate-&gt;dtms_scratch_ptr, 8);
		uint64_t size =
		    tupregs[subr == DIF_SUBR_ALLOCA ? 0 : 1].dttk_value;
		size_t scratch_size = (dest - mstate-&gt;dtms_scratch_ptr) + size;

		<span class="enscript-comment">/*
		 * This action doesn't require any credential checks since
		 * probes will not activate in user contexts to which the
		 * enabling user does not have permissions.
		 */</span>

		<span class="enscript-comment">/*
		 * Rounding up the user allocation size could have overflowed
		 * a large, bogus allocation (like -1ULL) to 0.
		 */</span>
		<span class="enscript-keyword">if</span> (scratch_size &lt; size ||
		    !DTRACE_INSCRATCH(mstate, scratch_size)) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (subr == DIF_SUBR_COPYIN) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
			<span class="enscript-keyword">if</span> (dtrace_priv_proc(state))
				dtrace_copyin(tupregs[0].dttk_value, dest, size, flags);
			DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
		}

		mstate-&gt;dtms_scratch_ptr += scratch_size;
		regs[rd] = dest;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_COPYINTO</span>: {
		uint64_t size = tupregs[1].dttk_value;
		uintptr_t dest = tupregs[2].dttk_value;

		<span class="enscript-comment">/*
		 * This action doesn't require any credential checks since
		 * probes will not activate in user contexts to which the
		 * enabling user does not have permissions.
		 */</span>
		<span class="enscript-keyword">if</span> (!dtrace_inscratch(dest, size, mstate)) {
			*flags |= CPU_DTRACE_BADADDR;
			*illval = regs[rd];
			<span class="enscript-keyword">break</span>;
		}

		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
		<span class="enscript-keyword">if</span> (dtrace_priv_proc(state))
			dtrace_copyin(tupregs[0].dttk_value, dest, size, flags);
		DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_COPYINSTR</span>: {
		uintptr_t dest = mstate-&gt;dtms_scratch_ptr;
		uint64_t size = state-&gt;dts_options[DTRACEOPT_STRSIZE];

		<span class="enscript-keyword">if</span> (nargs &gt; 1 &amp;&amp; tupregs[1].dttk_value &lt; size)
			size = tupregs[1].dttk_value + 1;

		<span class="enscript-comment">/*
		 * This action doesn't require any credential checks since
		 * probes will not activate in user contexts to which the
		 * enabling user does not have permissions.
		 */</span>
		<span class="enscript-keyword">if</span> (!DTRACE_INSCRATCH(mstate, size)) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
		<span class="enscript-keyword">if</span> (dtrace_priv_proc(state))
			dtrace_copyinstr(tupregs[0].dttk_value, dest, size, flags);
		DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);

		((<span class="enscript-type">char</span> *)dest)[size - 1] = <span class="enscript-string">'\0'</span>;
		mstate-&gt;dtms_scratch_ptr += size;
		regs[rd] = dest;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_MSGSIZE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_MSGDSIZE</span>: {
		<span class="enscript-comment">/* Darwin does not implement SysV streams messages */</span>
		DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
		regs[rd] = 0;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_PROGENYOF</span>: {
		pid_t pid = tupregs[0].dttk_value;
		<span class="enscript-type">struct</span> proc *p = current_proc();
		<span class="enscript-type">int</span> rval = 0, lim = nprocs;

		<span class="enscript-keyword">while</span>(p &amp;&amp; (lim-- &gt; 0)) {
			pid_t ppid;

			ppid = (pid_t)dtrace_load32((uintptr_t)&amp;(p-&gt;p_pid));
			<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_FAULT)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (ppid == pid) {
				rval = 1;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (ppid == 0)
				<span class="enscript-keyword">break</span>; <span class="enscript-comment">/* Can't climb process tree any further. */</span>

			p = (<span class="enscript-type">struct</span> proc *)dtrace_loadptr((uintptr_t)&amp;(p-&gt;p_pptr));
			<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_FAULT)
				<span class="enscript-keyword">break</span>;
		}

		regs[rd] = rval;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_SPECULATION</span>:
		regs[rd] = dtrace_speculation(state);
		<span class="enscript-keyword">break</span>;


	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_COPYOUT</span>: {
		uintptr_t kaddr = tupregs[0].dttk_value;
		user_addr_t uaddr = tupregs[1].dttk_value;
		uint64_t size = tupregs[2].dttk_value;

		<span class="enscript-keyword">if</span> (!dtrace_destructive_disallow &amp;&amp;
		    dtrace_priv_proc_control(state) &amp;&amp;
		    !dtrace_istoxic(kaddr, size)) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
			dtrace_copyout(kaddr, uaddr, size, flags);
			DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_COPYOUTSTR</span>: {
		uintptr_t kaddr = tupregs[0].dttk_value;
		user_addr_t uaddr = tupregs[1].dttk_value;
		uint64_t size = tupregs[2].dttk_value;

		<span class="enscript-keyword">if</span> (!dtrace_destructive_disallow &amp;&amp;
		    dtrace_priv_proc_control(state) &amp;&amp;
		    !dtrace_istoxic(kaddr, size)) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
			dtrace_copyoutstr(kaddr, uaddr, size, flags);
			DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_STRLEN</span>: {
		size_t sz;
		uintptr_t addr = (uintptr_t)tupregs[0].dttk_value;
		sz = dtrace_strlen((<span class="enscript-type">char</span> *)addr,
		    state-&gt;dts_options[DTRACEOPT_STRSIZE]);

		<span class="enscript-keyword">if</span> (!dtrace_canload(addr, sz + 1, mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		regs[rd] = sz;

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_STRCHR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_STRRCHR</span>: {
		<span class="enscript-comment">/*
		 * We're going to iterate over the string looking for the
		 * specified character.  We will iterate until we have reached
		 * the string length or we have found the character.  If this
		 * is DIF_SUBR_STRRCHR, we will look for the last occurrence
		 * of the specified character instead of the first.
		 */</span>
		uintptr_t saddr = tupregs[0].dttk_value;
		uintptr_t addr = tupregs[0].dttk_value;
		uintptr_t limit = addr + state-&gt;dts_options[DTRACEOPT_STRSIZE];
		<span class="enscript-type">char</span> c, target = (<span class="enscript-type">char</span>)tupregs[1].dttk_value;

		<span class="enscript-keyword">for</span> (regs[rd] = 0; addr &lt; limit; addr++) {
			<span class="enscript-keyword">if</span> ((c = dtrace_load8(addr)) == target) {
				regs[rd] = addr;

				<span class="enscript-keyword">if</span> (subr == DIF_SUBR_STRCHR)
					<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\0'</span>)
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (!dtrace_canload(saddr, addr - saddr, mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_STRSTR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_INDEX</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_RINDEX</span>: {
		<span class="enscript-comment">/*
		 * We're going to iterate over the string looking for the
		 * specified string.  We will iterate until we have reached
		 * the string length or we have found the string.  (Yes, this
		 * is done in the most naive way possible -- but considering
		 * that the string we're searching for is likely to be
		 * relatively short, the complexity of Rabin-Karp or similar
		 * hardly seems merited.)
		 */</span>
		<span class="enscript-type">char</span> *addr = (<span class="enscript-type">char</span> *)(uintptr_t)tupregs[0].dttk_value;
		<span class="enscript-type">char</span> *substr = (<span class="enscript-type">char</span> *)(uintptr_t)tupregs[1].dttk_value;
		uint64_t size = state-&gt;dts_options[DTRACEOPT_STRSIZE];
		size_t len = dtrace_strlen(addr, size);
		size_t sublen = dtrace_strlen(substr, size);
		<span class="enscript-type">char</span> *limit = addr + len, *orig = addr;
		<span class="enscript-type">int</span> notfound = subr == DIF_SUBR_STRSTR ? 0 : -1;
		<span class="enscript-type">int</span> inc = 1;

		regs[rd] = notfound;

		<span class="enscript-keyword">if</span> (!dtrace_canload((uintptr_t)addr, len + 1, mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (!dtrace_canload((uintptr_t)substr, sublen + 1, mstate,
		    vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * strstr() and index()/rindex() have similar semantics if
		 * both strings are the empty string: strstr() returns a
		 * pointer to the (empty) string, and index() and rindex()
		 * both return index 0 (regardless of any position argument).
		 */</span>
		<span class="enscript-keyword">if</span> (sublen == 0 &amp;&amp; len == 0) {
			<span class="enscript-keyword">if</span> (subr == DIF_SUBR_STRSTR)
				regs[rd] = (uintptr_t)addr;
			<span class="enscript-keyword">else</span>
				regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (subr != DIF_SUBR_STRSTR) {
			<span class="enscript-keyword">if</span> (subr == DIF_SUBR_RINDEX) {
				limit = orig - 1;
				addr += len;
				inc = -1;
			}

			<span class="enscript-comment">/*
			 * Both index() and rindex() take an optional position
			 * argument that denotes the starting position.
			 */</span>
			<span class="enscript-keyword">if</span> (nargs == 3) {
				int64_t pos = (int64_t)tupregs[2].dttk_value;

				<span class="enscript-comment">/*
				 * If the position argument to index() is
				 * negative, Perl implicitly clamps it at
				 * zero.  This semantic is a little surprising
				 * given the special meaning of negative
				 * positions to similar Perl functions like
				 * substr(), but it appears to reflect a
				 * notion that index() can start from a
				 * negative index and increment its way up to
				 * the string.  Given this notion, Perl's
				 * rindex() is at least self-consistent in
				 * that it implicitly clamps positions greater
				 * than the string length to be the string
				 * length.  Where Perl completely loses
				 * coherence, however, is when the specified
				 * substring is the empty string (&quot;&quot;).  In
				 * this case, even if the position is
				 * negative, rindex() returns 0 -- and even if
				 * the position is greater than the length,
				 * index() returns the string length.  These
				 * semantics violate the notion that index()
				 * should never return a value less than the
				 * specified position and that rindex() should
				 * never return a value greater than the
				 * specified position.  (One assumes that
				 * these semantics are artifacts of Perl's
				 * implementation and not the results of
				 * deliberate design -- it beggars belief that
				 * even Larry Wall could desire such oddness.)
				 * While in the abstract one would wish for
				 * consistent position semantics across
				 * substr(), index() and rindex() -- or at the
				 * very least self-consistent position
				 * semantics for index() and rindex() -- we
				 * instead opt to keep with the extant Perl
				 * semantics, in all their broken glory.  (Do
				 * we have more desire to maintain Perl's
				 * semantics than Perl does?  Probably.)
				 */</span>
				<span class="enscript-keyword">if</span> (subr == DIF_SUBR_RINDEX) {
					<span class="enscript-keyword">if</span> (pos &lt; 0) {
						<span class="enscript-keyword">if</span> (sublen == 0)
							regs[rd] = 0;
						<span class="enscript-keyword">break</span>;
					}

					<span class="enscript-keyword">if</span> ((size_t)pos &gt; len)
						pos = len;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (pos &lt; 0)
						pos = 0;

					<span class="enscript-keyword">if</span> ((size_t)pos &gt;= len) {
						<span class="enscript-keyword">if</span> (sublen == 0)
							regs[rd] = len;
						<span class="enscript-keyword">break</span>;
					}
				}

				addr = orig + pos;
			}
		}

		<span class="enscript-keyword">for</span> (regs[rd] = notfound; addr != limit; addr += inc) {
			<span class="enscript-keyword">if</span> (dtrace_strncmp(addr, substr, sublen) == 0) {
				<span class="enscript-keyword">if</span> (subr != DIF_SUBR_STRSTR) {
					<span class="enscript-comment">/*
					 * As D index() and rindex() are
					 * modeled on Perl (and not on awk),
					 * we return a zero-based (and not a
					 * one-based) index.  (For you Perl
					 * weenies: no, we're not going to add
					 * $[ -- and shouldn't you be at a con
					 * or something?)
					 */</span>
					regs[rd] = (uintptr_t)(addr - orig);
					<span class="enscript-keyword">break</span>;
				}

				ASSERT(subr == DIF_SUBR_STRSTR);
				regs[rd] = (uintptr_t)addr;
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_STRTOK</span>: {
		uintptr_t addr = tupregs[0].dttk_value;
		uintptr_t tokaddr = tupregs[1].dttk_value;
		uint64_t size = state-&gt;dts_options[DTRACEOPT_STRSIZE];
		uintptr_t limit, toklimit = tokaddr + size;
		<span class="enscript-type">char</span> *dest = (<span class="enscript-type">char</span> *)mstate-&gt;dtms_scratch_ptr;
		uint8_t c=<span class="enscript-string">'\0'</span>, tokmap[32];	 <span class="enscript-comment">/* 256 / 8 */</span>
		uint64_t i = 0;

		<span class="enscript-comment">/*
		 * Check both the token buffer and (later) the input buffer,
		 * since both could be non-scratch addresses.
		 */</span>
		<span class="enscript-keyword">if</span> (!dtrace_strcanload(tokaddr, size, mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (!DTRACE_INSCRATCH(mstate, size)) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (addr == 0) {
			<span class="enscript-comment">/*
			 * If the address specified is NULL, we use our saved
			 * strtok pointer from the mstate.  Note that this
			 * means that the saved strtok pointer is _only_
			 * valid within multiple enablings of the same probe --
			 * it behaves like an implicit clause-local variable.
			 */</span>
			addr = mstate-&gt;dtms_strtok;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * If the user-specified address is non-NULL we must
			 * access check it.  This is the only time we have
			 * a chance to do so, since this address may reside
			 * in the string table of this clause-- future calls
			 * (when we fetch addr from mstate-&gt;dtms_strtok)
			 * would fail this access check.
			 */</span>
			<span class="enscript-keyword">if</span> (!dtrace_strcanload(addr, size, mstate, vstate)) {
				regs[rd] = 0;
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-comment">/*
		 * First, zero the token map, and then process the token
		 * string -- setting a bit in the map for every character
		 * found in the token string.
		 */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (tokmap); i++)
			tokmap[i] = 0;

		<span class="enscript-keyword">for</span> (; tokaddr &lt; toklimit; tokaddr++) {
			<span class="enscript-keyword">if</span> ((c = dtrace_load8(tokaddr)) == <span class="enscript-string">'\0'</span>)
				<span class="enscript-keyword">break</span>;

			ASSERT((c &gt;&gt; 3) &lt; <span class="enscript-keyword">sizeof</span> (tokmap));
			tokmap[c &gt;&gt; 3] |= (1 &lt;&lt; (c &amp; 0x7));
		}

		<span class="enscript-keyword">for</span> (limit = addr + size; addr &lt; limit; addr++) {
			<span class="enscript-comment">/*
			 * We're looking for a character that is _not_ contained
			 * in the token string.
			 */</span>
			<span class="enscript-keyword">if</span> ((c = dtrace_load8(addr)) == <span class="enscript-string">'\0'</span>)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (!(tokmap[c &gt;&gt; 3] &amp; (1 &lt;&lt; (c &amp; 0x7))))
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\0'</span>) {
			<span class="enscript-comment">/*
			 * We reached the end of the string without finding
			 * any character that was not in the token string.
			 * We return NULL in this case, and we set the saved
			 * address to NULL as well.
			 */</span>
			regs[rd] = 0;
			mstate-&gt;dtms_strtok = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * From here on, we're copying into the destination string.
		 */</span>
		<span class="enscript-keyword">for</span> (i = 0; addr &lt; limit &amp;&amp; i &lt; size - 1; addr++) {
			<span class="enscript-keyword">if</span> ((c = dtrace_load8(addr)) == <span class="enscript-string">'\0'</span>)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (tokmap[c &gt;&gt; 3] &amp; (1 &lt;&lt; (c &amp; 0x7)))
				<span class="enscript-keyword">break</span>;

			ASSERT(i &lt; size);
			dest[i++] = c;
		}

		ASSERT(i &lt; size);
		dest[i] = <span class="enscript-string">'\0'</span>;
		regs[rd] = (uintptr_t)dest;
		mstate-&gt;dtms_scratch_ptr += size;
		mstate-&gt;dtms_strtok = addr;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_SUBSTR</span>: {
		uintptr_t s = tupregs[0].dttk_value;
		uint64_t size = state-&gt;dts_options[DTRACEOPT_STRSIZE];
		<span class="enscript-type">char</span> *d = (<span class="enscript-type">char</span> *)mstate-&gt;dtms_scratch_ptr;
		int64_t index = (int64_t)tupregs[1].dttk_value;
		int64_t remaining = (int64_t)tupregs[2].dttk_value;
		size_t len = dtrace_strlen((<span class="enscript-type">char</span> *)s, size);
		int64_t i = 0;

		<span class="enscript-keyword">if</span> (!dtrace_canload(s, len + 1, mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (!DTRACE_INSCRATCH(mstate, size)) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (nargs &lt;= 2)
			remaining = (int64_t)size;

		<span class="enscript-keyword">if</span> (index &lt; 0) {
			index += len;

			<span class="enscript-keyword">if</span> (index &lt; 0 &amp;&amp; index + remaining &gt; 0) {
				remaining += index;
				index = 0;
			}
		}

		<span class="enscript-keyword">if</span> ((size_t)index &gt;= len || index &lt; 0) {
			remaining = 0;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (remaining &lt; 0) {
			remaining += len - index;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((uint64_t)index + (uint64_t)remaining &gt; size) {
			remaining = size - index;
		}

		<span class="enscript-keyword">for</span> (i = 0; i &lt; remaining; i++) {
			<span class="enscript-keyword">if</span> ((d[i] = dtrace_load8(s + index + i)) == <span class="enscript-string">'\0'</span>)
				<span class="enscript-keyword">break</span>;
			}

		d[i] = <span class="enscript-string">'\0'</span>;

		mstate-&gt;dtms_scratch_ptr += size;
		regs[rd] = (uintptr_t)d;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_GETMAJOR</span>:
		regs[rd] = (uintptr_t)major( (dev_t)tupregs[0].dttk_value );
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_GETMINOR</span>:
		regs[rd] = (uintptr_t)minor( (dev_t)tupregs[0].dttk_value );
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_DDI_PATHNAME</span>: {
		<span class="enscript-comment">/* APPLE NOTE: currently unsupported on Darwin */</span>
		DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
		regs[rd] = 0;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_STRJOIN</span>: {
		<span class="enscript-type">char</span> *d = (<span class="enscript-type">char</span> *)mstate-&gt;dtms_scratch_ptr;
		uint64_t size = state-&gt;dts_options[DTRACEOPT_STRSIZE];
		uintptr_t s1 = tupregs[0].dttk_value;
		uintptr_t s2 = tupregs[1].dttk_value;
		uint64_t i = 0;

		<span class="enscript-keyword">if</span> (!dtrace_strcanload(s1, size, mstate, vstate) ||
		    !dtrace_strcanload(s2, size, mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (!DTRACE_INSCRATCH(mstate, size)) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">for</span> (;;) {
			<span class="enscript-keyword">if</span> (i &gt;= size) {
				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
				regs[rd] = 0;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> ((d[i++] = dtrace_load8(s1++)) == <span class="enscript-string">'\0'</span>) {
				i--;
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">for</span> (;;) {
			<span class="enscript-keyword">if</span> (i &gt;= size) {
				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
				regs[rd] = 0;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> ((d[i++] = dtrace_load8(s2++)) == <span class="enscript-string">'\0'</span>)
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (i &lt; size) {
			mstate-&gt;dtms_scratch_ptr += i;
			regs[rd] = (uintptr_t)d;
		}

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_LLTOSTR</span>: {
		int64_t i = (int64_t)tupregs[0].dttk_value;
		int64_t val = i &lt; 0 ? i * -1 : i;
		uint64_t size = 22;	<span class="enscript-comment">/* enough room for 2^64 in decimal */</span>
		<span class="enscript-type">char</span> *end = (<span class="enscript-type">char</span> *)mstate-&gt;dtms_scratch_ptr + size - 1;

		<span class="enscript-keyword">if</span> (!DTRACE_INSCRATCH(mstate, size)) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">for</span> (*end-- = <span class="enscript-string">'\0'</span>; val; val /= 10)
			*end-- = <span class="enscript-string">'0'</span> + (val % 10);

		<span class="enscript-keyword">if</span> (i == 0)
			*end-- = <span class="enscript-string">'0'</span>;

		<span class="enscript-keyword">if</span> (i &lt; 0)
			*end-- = <span class="enscript-string">'-'</span>;

		regs[rd] = (uintptr_t)end + 1;
		mstate-&gt;dtms_scratch_ptr += size;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_HTONS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_NTOHS</span>:
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_BIG_ENDIAN</span>
		regs[rd] = (uint16_t)tupregs[0].dttk_value;
#<span class="enscript-reference">else</span>
		regs[rd] = DT_BSWAP_16((uint16_t)tupregs[0].dttk_value);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">break</span>;


	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_HTONL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_NTOHL</span>:
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_BIG_ENDIAN</span>
		regs[rd] = (uint32_t)tupregs[0].dttk_value;
#<span class="enscript-reference">else</span>
		regs[rd] = DT_BSWAP_32((uint32_t)tupregs[0].dttk_value);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">break</span>;


	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_HTONLL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_NTOHLL</span>:
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_BIG_ENDIAN</span>
		regs[rd] = (uint64_t)tupregs[0].dttk_value;
#<span class="enscript-reference">else</span>
		regs[rd] = DT_BSWAP_64((uint64_t)tupregs[0].dttk_value);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">break</span>;


	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_DIRNAME</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_BASENAME</span>: {
		<span class="enscript-type">char</span> *dest = (<span class="enscript-type">char</span> *)mstate-&gt;dtms_scratch_ptr;
		uint64_t size = state-&gt;dts_options[DTRACEOPT_STRSIZE];
		uintptr_t src = tupregs[0].dttk_value;
		<span class="enscript-type">int</span> i, j, len = dtrace_strlen((<span class="enscript-type">char</span> *)src, size);
		<span class="enscript-type">int</span> lastbase = -1, firstbase = -1, lastdir = -1;
		<span class="enscript-type">int</span> start, end;

		<span class="enscript-keyword">if</span> (!dtrace_canload(src, len + 1, mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (!DTRACE_INSCRATCH(mstate, size)) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * The basename and dirname for a zero-length string is
		 * defined to be &quot;.&quot;
		 */</span>
		<span class="enscript-keyword">if</span> (len == 0) {
			len = 1;
			src = (uintptr_t)<span class="enscript-string">&quot;.&quot;</span>;
		}

		<span class="enscript-comment">/*
		 * Start from the back of the string, moving back toward the
		 * front until we see a character that isn't a slash.  That
		 * character is the last character in the basename.
		 */</span>
		<span class="enscript-keyword">for</span> (i = len - 1; i &gt;= 0; i--) {
			<span class="enscript-keyword">if</span> (dtrace_load8(src + i) != <span class="enscript-string">'/'</span>)
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (i &gt;= 0)
			lastbase = i;

		<span class="enscript-comment">/*
		 * Starting from the last character in the basename, move
		 * towards the front until we find a slash.  The character
		 * that we processed immediately before that is the first
		 * character in the basename.
		 */</span>
		<span class="enscript-keyword">for</span> (; i &gt;= 0; i--) {
			<span class="enscript-keyword">if</span> (dtrace_load8(src + i) == <span class="enscript-string">'/'</span>)
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (i &gt;= 0)
			firstbase = i + 1;

		<span class="enscript-comment">/*
		 * Now keep going until we find a non-slash character.  That
		 * character is the last character in the dirname.
		 */</span>
		<span class="enscript-keyword">for</span> (; i &gt;= 0; i--) {
			<span class="enscript-keyword">if</span> (dtrace_load8(src + i) != <span class="enscript-string">'/'</span>)
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (i &gt;= 0)
			lastdir = i;

		ASSERT(!(lastbase == -1 &amp;&amp; firstbase != -1));
		ASSERT(!(firstbase == -1 &amp;&amp; lastdir != -1));

		<span class="enscript-keyword">if</span> (lastbase == -1) {
			<span class="enscript-comment">/*
			 * We didn't find a non-slash character.  We know that
			 * the length is non-zero, so the whole string must be
			 * slashes.  In either the dirname or the basename
			 * case, we return '/'.
			 */</span>
			ASSERT(firstbase == -1);
			firstbase = lastbase = lastdir = 0;
		}

		<span class="enscript-keyword">if</span> (firstbase == -1) {
			<span class="enscript-comment">/*
			 * The entire string consists only of a basename
			 * component.  If we're looking for dirname, we need
			 * to change our string to be just &quot;.&quot;; if we're
			 * looking for a basename, we'll just set the first
			 * character of the basename to be 0.
			 */</span>
			<span class="enscript-keyword">if</span> (subr == DIF_SUBR_DIRNAME) {
				ASSERT(lastdir == -1);
				src = (uintptr_t)<span class="enscript-string">&quot;.&quot;</span>;
				lastdir = 0;
			} <span class="enscript-keyword">else</span> {
				firstbase = 0;
			}
		}

		<span class="enscript-keyword">if</span> (subr == DIF_SUBR_DIRNAME) {
			<span class="enscript-keyword">if</span> (lastdir == -1) {
				<span class="enscript-comment">/*
				 * We know that we have a slash in the name --
				 * or lastdir would be set to 0, above.  And
				 * because lastdir is -1, we know that this
				 * slash must be the first character.  (That
				 * is, the full string must be of the form
				 * &quot;/basename&quot;.)  In this case, the last
				 * character of the directory name is 0.
				 */</span>
				lastdir = 0;
			}

			start = 0;
			end = lastdir;
		} <span class="enscript-keyword">else</span> {
			ASSERT(subr == DIF_SUBR_BASENAME);
			ASSERT(firstbase != -1 &amp;&amp; lastbase != -1);
			start = firstbase;
			end = lastbase;
		}

		<span class="enscript-keyword">for</span> (i = start, j = 0; i &lt;= end &amp;&amp; (uint64_t)j &lt; size - 1; i++, j++)
			dest[j] = dtrace_load8(src + i);

		dest[j] = <span class="enscript-string">'\0'</span>;
		regs[rd] = (uintptr_t)dest;
		mstate-&gt;dtms_scratch_ptr += size;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_CLEANPATH</span>: {
		<span class="enscript-type">char</span> *dest = (<span class="enscript-type">char</span> *)mstate-&gt;dtms_scratch_ptr, c;
		uint64_t size = state-&gt;dts_options[DTRACEOPT_STRSIZE];
		uintptr_t src = tupregs[0].dttk_value;
		<span class="enscript-type">int</span> i = 0, j = 0;

		<span class="enscript-keyword">if</span> (!dtrace_strcanload(src, size, mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (!DTRACE_INSCRATCH(mstate, size)) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * Move forward, loading each character.
		 */</span>
		<span class="enscript-keyword">do</span> {
			c = dtrace_load8(src + i++);
<span class="enscript-reference">next</span>:
			<span class="enscript-keyword">if</span> ((uint64_t)(j + 5) &gt;= size)	<span class="enscript-comment">/* 5 = strlen(&quot;/..c\0&quot;) */</span>
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (c != <span class="enscript-string">'/'</span>) {
				dest[j++] = c;
				<span class="enscript-keyword">continue</span>;
			}

			c = dtrace_load8(src + i++);

			<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'/'</span>) {
				<span class="enscript-comment">/*
				 * We have two slashes -- we can just advance
				 * to the next character.
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
			}

			<span class="enscript-keyword">if</span> (c != <span class="enscript-string">'.'</span>) {
				<span class="enscript-comment">/*
				 * This is not &quot;.&quot; and it's not &quot;..&quot; -- we can
				 * just store the &quot;/&quot; and this character and
				 * drive on.
				 */</span>
				dest[j++] = <span class="enscript-string">'/'</span>;
				dest[j++] = c;
				<span class="enscript-keyword">continue</span>;
			}

			c = dtrace_load8(src + i++);

			<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'/'</span>) {
				<span class="enscript-comment">/*
				 * This is a &quot;/./&quot; component.  We're not going
				 * to store anything in the destination buffer;
				 * we're just going to go to the next component.
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
			}

			<span class="enscript-keyword">if</span> (c != <span class="enscript-string">'.'</span>) {
				<span class="enscript-comment">/*
				 * This is not &quot;..&quot; -- we can just store the
				 * &quot;/.&quot; and this character and continue
				 * processing.
				 */</span>
				dest[j++] = <span class="enscript-string">'/'</span>;
				dest[j++] = <span class="enscript-string">'.'</span>;
				dest[j++] = c;
				<span class="enscript-keyword">continue</span>;
			}

			c = dtrace_load8(src + i++);

			<span class="enscript-keyword">if</span> (c != <span class="enscript-string">'/'</span> &amp;&amp; c != <span class="enscript-string">'\0'</span>) {
				<span class="enscript-comment">/*
				 * This is not &quot;..&quot; -- it's &quot;..[mumble]&quot;.
				 * We'll store the &quot;/..&quot; and this character
				 * and continue processing.
				 */</span>
				dest[j++] = <span class="enscript-string">'/'</span>;
				dest[j++] = <span class="enscript-string">'.'</span>;
				dest[j++] = <span class="enscript-string">'.'</span>;
				dest[j++] = c;
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/*
			 * This is &quot;/../&quot; or &quot;/..\0&quot;.  We need to back up
			 * our destination pointer until we find a &quot;/&quot;.
			 */</span>
			i--;
			<span class="enscript-keyword">while</span> (j != 0 &amp;&amp; dest[--j] != <span class="enscript-string">'/'</span>)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\0'</span>)
				dest[++j] = <span class="enscript-string">'/'</span>;
		} <span class="enscript-keyword">while</span> (c != <span class="enscript-string">'\0'</span>);

		dest[j] = <span class="enscript-string">'\0'</span>;
		regs[rd] = (uintptr_t)dest;
		mstate-&gt;dtms_scratch_ptr += size;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_INET_NTOA</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_INET_NTOA6</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_INET_NTOP</span>: {
		size_t size;
		<span class="enscript-type">int</span> af, argi, i;
		<span class="enscript-type">char</span> *base, *end;

		<span class="enscript-keyword">if</span> (subr == DIF_SUBR_INET_NTOP) {
			af = (<span class="enscript-type">int</span>)tupregs[0].dttk_value;
			argi = 1;
		} <span class="enscript-keyword">else</span> {
			af = subr == DIF_SUBR_INET_NTOA ? AF_INET: AF_INET6;
			argi = 0;
		}

		<span class="enscript-keyword">if</span> (af == AF_INET) {
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
			ipaddr_t ip4;
#<span class="enscript-reference">else</span>
			uint32_t ip4;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>
			uint8_t *ptr8, val;

			<span class="enscript-comment">/*
			 * Safely load the IPv4 address.
			 */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)			
			ip4 = dtrace_load32(tupregs[argi].dttk_value);
#<span class="enscript-reference">else</span>
			dtrace_bcopy(
			    (<span class="enscript-type">void</span> *)(uintptr_t)tupregs[argi].dttk_value,
			    (<span class="enscript-type">void</span> *)(uintptr_t)&amp;ip4, <span class="enscript-keyword">sizeof</span> (ip4));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>			
			<span class="enscript-comment">/*
			 * Check an IPv4 string will fit in scratch.
			 */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
			size = INET_ADDRSTRLEN;
#<span class="enscript-reference">else</span>
			size = MAX_IPv4_STR_LEN;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>
			<span class="enscript-keyword">if</span> (!DTRACE_INSCRATCH(mstate, size)) {
				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
				regs[rd] = 0;
				<span class="enscript-keyword">break</span>;
			}
			base = (<span class="enscript-type">char</span> *)mstate-&gt;dtms_scratch_ptr;
			end = (<span class="enscript-type">char</span> *)mstate-&gt;dtms_scratch_ptr + size - 1;

			<span class="enscript-comment">/*
			 * Stringify as a dotted decimal quad.
			 */</span>
			*end-- = <span class="enscript-string">'\0'</span>;
			ptr8 = (uint8_t *)&amp;ip4;
			<span class="enscript-keyword">for</span> (i = 3; i &gt;= 0; i--) {
				val = ptr8[i];

				<span class="enscript-keyword">if</span> (val == 0) {
					*end-- = <span class="enscript-string">'0'</span>;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">for</span> (; val; val /= 10) {
						*end-- = <span class="enscript-string">'0'</span> + (val % 10);
					}
				}

				<span class="enscript-keyword">if</span> (i &gt; 0)
					*end-- = <span class="enscript-string">'.'</span>;
			}
			ASSERT(end + 1 &gt;= base);

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (af == AF_INET6) {
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_S6_un</span> __u6_addr
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_S6_u8</span> __u6_addr8
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>
			<span class="enscript-type">struct</span> in6_addr ip6;
			<span class="enscript-type">int</span> firstzero, tryzero, numzero, v6end;
			uint16_t val;
			<span class="enscript-type">const</span> <span class="enscript-type">char</span> digits[] = <span class="enscript-string">&quot;0123456789abcdef&quot;</span>;

			<span class="enscript-comment">/*
			 * Stringify using RFC 1884 convention 2 - 16 bit
			 * hexadecimal values with a zero-run compression.
			 * Lower case hexadecimal digits are used.
			 * 	eg, fe80::214:4fff:fe0b:76c8.
			 * The IPv4 embedded form is returned for inet_ntop,
			 * just the IPv4 string is returned for inet_ntoa6.
			 */</span>

			<span class="enscript-comment">/*
			 * Safely load the IPv6 address.
			 */</span>
			dtrace_bcopy(
			    (<span class="enscript-type">void</span> *)(uintptr_t)tupregs[argi].dttk_value,
			    (<span class="enscript-type">void</span> *)(uintptr_t)&amp;ip6, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr));

			<span class="enscript-comment">/*
			 * Check an IPv6 string will fit in scratch.
			 */</span>
			size = INET6_ADDRSTRLEN;
			<span class="enscript-keyword">if</span> (!DTRACE_INSCRATCH(mstate, size)) {
				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
				regs[rd] = 0;
				<span class="enscript-keyword">break</span>;
			}
			base = (<span class="enscript-type">char</span> *)mstate-&gt;dtms_scratch_ptr;
			end = (<span class="enscript-type">char</span> *)mstate-&gt;dtms_scratch_ptr + size - 1;
			*end-- = <span class="enscript-string">'\0'</span>;

			<span class="enscript-comment">/*
			 * Find the longest run of 16 bit zero values
			 * for the single allowed zero compression - &quot;::&quot;.
			 */</span>
			firstzero = -1;
			tryzero = -1;
			numzero = 1;
			<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr); i++) {
				<span class="enscript-keyword">if</span> (ip6._S6_un._S6_u8[i] == 0 &amp;&amp;
				    tryzero == -1 &amp;&amp; i % 2 == 0) {
					tryzero = i;
					<span class="enscript-keyword">continue</span>;
				}

				<span class="enscript-keyword">if</span> (tryzero != -1 &amp;&amp;
				    (ip6._S6_un._S6_u8[i] != 0 ||
				    i == <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr) - 1)) {

					<span class="enscript-keyword">if</span> (i - tryzero &lt;= numzero) {
						tryzero = -1;
						<span class="enscript-keyword">continue</span>;
					}

					firstzero = tryzero;
					numzero = i - i % 2 - tryzero;
					tryzero = -1;

					<span class="enscript-keyword">if</span> (ip6._S6_un._S6_u8[i] == 0 &amp;&amp;
					    i == <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr) - 1)
						numzero += 2;
				}
			}
			ASSERT(firstzero + numzero &lt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr));

			<span class="enscript-comment">/*
			 * Check for an IPv4 embedded address.
			 */</span>
			v6end = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr) - 2;
			<span class="enscript-keyword">if</span> (IN6_IS_ADDR_V4MAPPED(&amp;ip6) ||
			    IN6_IS_ADDR_V4COMPAT(&amp;ip6)) {
				<span class="enscript-keyword">for</span> (i = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr) - 1;
				     i &gt;= (<span class="enscript-type">int</span>)DTRACE_V4MAPPED_OFFSET; i--) {
					ASSERT(end &gt;= base);

					val = ip6._S6_un._S6_u8[i];

					<span class="enscript-keyword">if</span> (val == 0) {
						*end-- = <span class="enscript-string">'0'</span>;
					} <span class="enscript-keyword">else</span> {
						<span class="enscript-keyword">for</span> (; val; val /= 10) {
							*end-- = <span class="enscript-string">'0'</span> + val % 10;
						}
					}

					<span class="enscript-keyword">if</span> (i &gt; (<span class="enscript-type">int</span>)DTRACE_V4MAPPED_OFFSET)
						*end-- = <span class="enscript-string">'.'</span>;
				}

				<span class="enscript-keyword">if</span> (subr == DIF_SUBR_INET_NTOA6)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">inetout</span>;

				<span class="enscript-comment">/*
				 * Set v6end to skip the IPv4 address that
				 * we have already stringified.
				 */</span>
				v6end = 10;
			}

			<span class="enscript-comment">/*
			 * Build the IPv6 string by working through the
			 * address in reverse.
			 */</span>
			<span class="enscript-keyword">for</span> (i = v6end; i &gt;= 0; i -= 2) {
				ASSERT(end &gt;= base);

				<span class="enscript-keyword">if</span> (i == firstzero + numzero - 2) {
					*end-- = <span class="enscript-string">':'</span>;
					*end-- = <span class="enscript-string">':'</span>;
					i -= numzero - 2;
					<span class="enscript-keyword">continue</span>;
				}

				<span class="enscript-keyword">if</span> (i &lt; 14 &amp;&amp; i != firstzero - 2)
					*end-- = <span class="enscript-string">':'</span>;

				val = (ip6._S6_un._S6_u8[i] &lt;&lt; 8) +
				    ip6._S6_un._S6_u8[i + 1];

				<span class="enscript-keyword">if</span> (val == 0) {
					*end-- = <span class="enscript-string">'0'</span>;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">for</span> (; val; val /= 16) {
						*end-- = digits[val % 16];
					}
				}
			}
			ASSERT(end + 1 &gt;= base);

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">_S6_un</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">_S6_u8</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * The user didn't use AH_INET or AH_INET6.
			 */</span>
			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

<span class="enscript-reference">inetout</span>:	regs[rd] = (uintptr_t)end + 1;
		mstate-&gt;dtms_scratch_ptr += size;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_TOUPPER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_TOLOWER</span>: {
		uintptr_t src = tupregs[0].dttk_value;
		<span class="enscript-type">char</span> *dest = (<span class="enscript-type">char</span> *)mstate-&gt;dtms_scratch_ptr;
		<span class="enscript-type">char</span> lower, upper, base, c;
		uint64_t size = state-&gt;dts_options[DTRACEOPT_STRSIZE];
		size_t len = dtrace_strlen((<span class="enscript-type">char</span>*) src, size);
		size_t i = 0;

		lower = (subr == DIF_SUBR_TOUPPER) ? <span class="enscript-string">'a'</span> : <span class="enscript-string">'A'</span>;
		upper = (subr == DIF_SUBR_TOUPPER) ? <span class="enscript-string">'z'</span> : <span class="enscript-string">'Z'</span>;
		base  = (subr == DIF_SUBR_TOUPPER) ? <span class="enscript-string">'A'</span> : <span class="enscript-string">'a'</span>;

		<span class="enscript-keyword">if</span> (!dtrace_canload(src, len + 1, mstate, vstate)) {
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (!DTRACE_INSCRATCH(mstate, size)) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">for</span> (i = 0; i &lt; size - 1; ++i) {
			<span class="enscript-keyword">if</span> ((c = dtrace_load8(src + i)) == <span class="enscript-string">'\0'</span>)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (c &gt;= lower &amp;&amp; c &lt;= upper)
				c = base + (c - lower);
			dest[i] = c;
		}

		ASSERT(i &lt; size);

		dest[i] = <span class="enscript-string">'\0'</span>;
		regs[rd] = (uintptr_t) dest;
		mstate-&gt;dtms_scratch_ptr += size;

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_VM_KERNEL_ADDRPERM</span>: {
		<span class="enscript-keyword">if</span> (!dtrace_priv_kernel(state)) {
			regs[rd] = 0;
		} <span class="enscript-keyword">else</span> {
			regs[rd] = VM_KERNEL_ADDRPERM((vm_offset_t) tupregs[0].dttk_value);
		}

		<span class="enscript-keyword">break</span>;
	}
<span class="enscript-comment">/*
 * APPLE NOTE:
 * CoreProfile callback ('core_profile (uint64_t, [uint64_t], [uint64_t] ...)')
 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_SUBR_COREPROFILE</span>: {
		uint64_t selector = tupregs[0].dttk_value;
		uint64_t args[DIF_DTR_NREGS-1] = {0ULL};
		uint32_t ii;
		uint32_t count = (uint32_t)nargs;

		<span class="enscript-keyword">if</span> (count &lt; 1) {
		    regs[rd] = KERN_FAILURE;
		    <span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-keyword">if</span>(count &gt; DIF_DTR_NREGS)
		    count = DIF_DTR_NREGS;

		<span class="enscript-comment">/* copy in any variadic argument list, bounded by DIF_DTR_NREGS */</span>
		<span class="enscript-keyword">for</span>(ii = 0; ii &lt; count-1; ii++) {
			args[ii] = tupregs[ii+1].dttk_value;
		}

		kern_return_t ret = 
			chudxnu_dtrace_callback(selector, args, count-1);
		<span class="enscript-keyword">if</span>(KERN_SUCCESS != ret) {
			<span class="enscript-comment">/* error */</span>
		}

		regs[rd] = ret;
		<span class="enscript-keyword">break</span>;
	}
	}
}

<span class="enscript-comment">/*
 * Emulate the execution of DTrace IR instructions specified by the given
 * DIF object.  This function is deliberately void of assertions as all of
 * the necessary checks are handled by a call to dtrace_difo_validate().
 */</span>
<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">dtrace_dif_emulate</span>(dtrace_difo_t *difo, dtrace_mstate_t *mstate,
    dtrace_vstate_t *vstate, dtrace_state_t *state)
{
	<span class="enscript-type">const</span> dif_instr_t *text = difo-&gt;dtdo_buf;
	<span class="enscript-type">const</span> uint_t textlen = difo-&gt;dtdo_len;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *strtab = difo-&gt;dtdo_strtab;
	<span class="enscript-type">const</span> uint64_t *inttab = difo-&gt;dtdo_inttab;

	uint64_t rval = 0;
	dtrace_statvar_t *svar;
	dtrace_dstate_t *dstate = &amp;vstate-&gt;dtvs_dynvars;
	dtrace_difv_t *v;
	<span class="enscript-type">volatile</span> uint16_t *flags = &amp;cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags;
	<span class="enscript-type">volatile</span> uint64_t *illval = &amp;cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_illval;

	dtrace_key_t tupregs[DIF_DTR_NREGS + 2]; <span class="enscript-comment">/* +2 for thread and id */</span>
	uint64_t regs[DIF_DIR_NREGS];
	uint64_t *tmp;

	uint8_t cc_n = 0, cc_z = 0, cc_v = 0, cc_c = 0;
	int64_t cc_r;
	uint_t pc = 0, id, opc = 0;
	uint8_t ttop = 0;
	dif_instr_t instr;
	uint_t r1, r2, rd;

	<span class="enscript-comment">/*
	 * We stash the current DIF object into the machine state: we need it
	 * for subsequent access checking.
	 */</span>
	mstate-&gt;dtms_difo = difo;

	regs[DIF_REG_R0] = 0; 		<span class="enscript-comment">/* %r0 is fixed at zero */</span>

	<span class="enscript-keyword">while</span> (pc &lt; textlen &amp;&amp; !(*flags &amp; CPU_DTRACE_FAULT)) {
		opc = pc;

		instr = text[pc++];
		r1 = DIF_INSTR_R1(instr);
		r2 = DIF_INSTR_R2(instr);
		rd = DIF_INSTR_RD(instr);

		<span class="enscript-keyword">switch</span> (DIF_INSTR_OP(instr)) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_OR</span>:
			regs[rd] = regs[r1] | regs[r2];
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_XOR</span>:
			regs[rd] = regs[r1] ^ regs[r2];
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_AND</span>:
			regs[rd] = regs[r1] &amp; regs[r2];
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SLL</span>:
			regs[rd] = regs[r1] &lt;&lt; regs[r2];
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SRL</span>:
			regs[rd] = regs[r1] &gt;&gt; regs[r2];
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SUB</span>:
			regs[rd] = regs[r1] - regs[r2];
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ADD</span>:
			regs[rd] = regs[r1] + regs[r2];
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_MUL</span>:
			regs[rd] = regs[r1] * regs[r2];
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SDIV</span>:
			<span class="enscript-keyword">if</span> (regs[r2] == 0) {
				regs[rd] = 0;
				*flags |= CPU_DTRACE_DIVZERO;
			} <span class="enscript-keyword">else</span> {
				regs[rd] = (int64_t)regs[r1] /
				    (int64_t)regs[r2];
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_UDIV</span>:
			<span class="enscript-keyword">if</span> (regs[r2] == 0) {
				regs[rd] = 0;
				*flags |= CPU_DTRACE_DIVZERO;
			} <span class="enscript-keyword">else</span> {
				regs[rd] = regs[r1] / regs[r2];
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SREM</span>:
			<span class="enscript-keyword">if</span> (regs[r2] == 0) {
				regs[rd] = 0;
				*flags |= CPU_DTRACE_DIVZERO;
			} <span class="enscript-keyword">else</span> {
				regs[rd] = (int64_t)regs[r1] %
				    (int64_t)regs[r2];
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_UREM</span>:
			<span class="enscript-keyword">if</span> (regs[r2] == 0) {
				regs[rd] = 0;
				*flags |= CPU_DTRACE_DIVZERO;
			} <span class="enscript-keyword">else</span> {
				regs[rd] = regs[r1] % regs[r2];
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_NOT</span>:
			regs[rd] = ~regs[r1];
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_MOV</span>:
			regs[rd] = regs[r1];
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_CMP</span>:
			cc_r = regs[r1] - regs[r2];
			cc_n = cc_r &lt; 0;
			cc_z = cc_r == 0;
			cc_v = 0;
			cc_c = regs[r1] &lt; regs[r2];
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_TST</span>:
			cc_n = cc_v = cc_c = 0;
			cc_z = regs[r1] == 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BA</span>:
			pc = DIF_INSTR_LABEL(instr);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BE</span>:
			<span class="enscript-keyword">if</span> (cc_z)
				pc = DIF_INSTR_LABEL(instr);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BNE</span>:
			<span class="enscript-keyword">if</span> (cc_z == 0)
				pc = DIF_INSTR_LABEL(instr);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BG</span>:
			<span class="enscript-keyword">if</span> ((cc_z | (cc_n ^ cc_v)) == 0)
				pc = DIF_INSTR_LABEL(instr);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BGU</span>:
			<span class="enscript-keyword">if</span> ((cc_c | cc_z) == 0)
				pc = DIF_INSTR_LABEL(instr);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BGE</span>:
			<span class="enscript-keyword">if</span> ((cc_n ^ cc_v) == 0)
				pc = DIF_INSTR_LABEL(instr);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BGEU</span>:
			<span class="enscript-keyword">if</span> (cc_c == 0)
				pc = DIF_INSTR_LABEL(instr);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BL</span>:
			<span class="enscript-keyword">if</span> (cc_n ^ cc_v)
				pc = DIF_INSTR_LABEL(instr);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BLU</span>:
			<span class="enscript-keyword">if</span> (cc_c)
				pc = DIF_INSTR_LABEL(instr);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BLE</span>:
			<span class="enscript-keyword">if</span> (cc_z | (cc_n ^ cc_v))
				pc = DIF_INSTR_LABEL(instr);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BLEU</span>:
			<span class="enscript-keyword">if</span> (cc_c | cc_z)
				pc = DIF_INSTR_LABEL(instr);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDSB</span>:
			<span class="enscript-keyword">if</span> (!dtrace_canstore(regs[r1], 1, mstate, vstate)) {
				*flags |= CPU_DTRACE_KPRIV;
				*illval = regs[r1];
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/*FALLTHROUGH*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDSB</span>:
			regs[rd] = (int8_t)dtrace_load8(regs[r1]);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDSH</span>:
			<span class="enscript-keyword">if</span> (!dtrace_canstore(regs[r1], 2, mstate, vstate)) {
				*flags |= CPU_DTRACE_KPRIV;
				*illval = regs[r1];
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/*FALLTHROUGH*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDSH</span>:
			regs[rd] = (int16_t)dtrace_load16(regs[r1]);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDSW</span>:
			<span class="enscript-keyword">if</span> (!dtrace_canstore(regs[r1], 4, mstate, vstate)) {
				*flags |= CPU_DTRACE_KPRIV;
				*illval = regs[r1];
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/*FALLTHROUGH*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDSW</span>:
			regs[rd] = (int32_t)dtrace_load32(regs[r1]);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDUB</span>:
			<span class="enscript-keyword">if</span> (!dtrace_canstore(regs[r1], 1, mstate, vstate)) {
				*flags |= CPU_DTRACE_KPRIV;
				*illval = regs[r1];
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/*FALLTHROUGH*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDUB</span>:
			regs[rd] = dtrace_load8(regs[r1]);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDUH</span>:
			<span class="enscript-keyword">if</span> (!dtrace_canstore(regs[r1], 2, mstate, vstate)) {
				*flags |= CPU_DTRACE_KPRIV;
				*illval = regs[r1];
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/*FALLTHROUGH*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDUH</span>:
			regs[rd] = dtrace_load16(regs[r1]);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDUW</span>:
			<span class="enscript-keyword">if</span> (!dtrace_canstore(regs[r1], 4, mstate, vstate)) {
				*flags |= CPU_DTRACE_KPRIV;
				*illval = regs[r1];
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/*FALLTHROUGH*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDUW</span>:
			regs[rd] = dtrace_load32(regs[r1]);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDX</span>:
			<span class="enscript-keyword">if</span> (!dtrace_canstore(regs[r1], 8, mstate, vstate)) {
				*flags |= CPU_DTRACE_KPRIV;
				*illval = regs[r1];
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/*FALLTHROUGH*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDX</span>:
			regs[rd] = dtrace_load64(regs[r1]);
			<span class="enscript-keyword">break</span>;
<span class="enscript-comment">/*
 * Darwin 32-bit kernel may fetch from 64-bit user.
 * Do not cast regs to uintptr_t
 * DIF_OP_ULDSB,DIF_OP_ULDSH, DIF_OP_ULDSW, DIF_OP_ULDUB
 * DIF_OP_ULDUH, DIF_OP_ULDUW, DIF_OP_ULDX
 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDSB</span>:
			regs[rd] = (int8_t)
			    dtrace_fuword8(regs[r1]);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDSH</span>:
			regs[rd] = (int16_t)
			    dtrace_fuword16(regs[r1]);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDSW</span>:
			regs[rd] = (int32_t)
			    dtrace_fuword32(regs[r1]);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDUB</span>:
			regs[rd] =
			    dtrace_fuword8(regs[r1]);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDUH</span>:
			regs[rd] =
			    dtrace_fuword16(regs[r1]);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDUW</span>:
			regs[rd] =
			    dtrace_fuword32(regs[r1]);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDX</span>:
			regs[rd] =
			    dtrace_fuword64(regs[r1]);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RET</span>:
			rval = regs[rd];
			pc = textlen;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_NOP</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SETX</span>:
			regs[rd] = inttab[DIF_INSTR_INTEGER(instr)];
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SETS</span>:
			regs[rd] = (uint64_t)(uintptr_t)
			    (strtab + DIF_INSTR_STRING(instr));
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SCMP</span>: {
			size_t sz = state-&gt;dts_options[DTRACEOPT_STRSIZE];
			uintptr_t s1 = regs[r1];
			uintptr_t s2 = regs[r2];

			<span class="enscript-keyword">if</span> (s1 != 0 &amp;&amp;
			    !dtrace_strcanload(s1, sz, mstate, vstate))
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (s2 != 0 &amp;&amp;
			    !dtrace_strcanload(s2, sz, mstate, vstate))
				<span class="enscript-keyword">break</span>;

			cc_r = dtrace_strncmp((<span class="enscript-type">char</span> *)s1, (<span class="enscript-type">char</span> *)s2, sz);

			cc_n = cc_r &lt; 0;
			cc_z = cc_r == 0;
			cc_v = cc_c = 0;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDGA</span>:
			regs[rd] = dtrace_dif_variable(mstate, state,
			    r1, regs[r2]);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDGS</span>:
			id = DIF_INSTR_VAR(instr);

			<span class="enscript-keyword">if</span> (id &gt;= DIF_VAR_OTHER_UBASE) {
				uintptr_t a;

				id -= DIF_VAR_OTHER_UBASE;
				svar = vstate-&gt;dtvs_globals[id];
				ASSERT(svar != NULL);
				v = &amp;svar-&gt;dtsv_var;

				<span class="enscript-keyword">if</span> (!(v-&gt;dtdv_type.dtdt_flags &amp; DIF_TF_BYREF)) {
					regs[rd] = svar-&gt;dtsv_data;
					<span class="enscript-keyword">break</span>;
				}

				a = (uintptr_t)svar-&gt;dtsv_data;

				<span class="enscript-keyword">if</span> (*(uint8_t *)a == UINT8_MAX) {
					<span class="enscript-comment">/*
					 * If the 0th byte is set to UINT8_MAX
					 * then this is to be treated as a
					 * reference to a NULL variable.
					 */</span>
					regs[rd] = 0;
				} <span class="enscript-keyword">else</span> {
					regs[rd] = a + <span class="enscript-keyword">sizeof</span> (uint64_t);
				}

				<span class="enscript-keyword">break</span>;
			}

			regs[rd] = dtrace_dif_variable(mstate, state, id, 0);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STGS</span>:
			id = DIF_INSTR_VAR(instr);

			ASSERT(id &gt;= DIF_VAR_OTHER_UBASE);
			id -= DIF_VAR_OTHER_UBASE;

			svar = vstate-&gt;dtvs_globals[id];
			ASSERT(svar != NULL);
			v = &amp;svar-&gt;dtsv_var;

			<span class="enscript-keyword">if</span> (v-&gt;dtdv_type.dtdt_flags &amp; DIF_TF_BYREF) {
				uintptr_t a = (uintptr_t)svar-&gt;dtsv_data;

				ASSERT(a != 0);
				ASSERT(svar-&gt;dtsv_size != 0);

				<span class="enscript-keyword">if</span> (regs[rd] == 0) {
					*(uint8_t *)a = UINT8_MAX;
					<span class="enscript-keyword">break</span>;
				} <span class="enscript-keyword">else</span> {
					*(uint8_t *)a = 0;
					a += <span class="enscript-keyword">sizeof</span> (uint64_t);
				}
				<span class="enscript-keyword">if</span> (!dtrace_vcanload(
				    (<span class="enscript-type">void</span> *)(uintptr_t)regs[rd], &amp;v-&gt;dtdv_type,
				    mstate, vstate))
					<span class="enscript-keyword">break</span>;

				dtrace_vcopy((<span class="enscript-type">void</span> *)(uintptr_t)regs[rd],
				    (<span class="enscript-type">void</span> *)a, &amp;v-&gt;dtdv_type);
				<span class="enscript-keyword">break</span>;
			}

			svar-&gt;dtsv_data = regs[rd];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDTA</span>:
			<span class="enscript-comment">/*
			 * There are no DTrace built-in thread-local arrays at
			 * present.  This opcode is saved for future work.
			 */</span>
			*flags |= CPU_DTRACE_ILLOP;
			regs[rd] = 0;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDLS</span>:
			id = DIF_INSTR_VAR(instr);

			<span class="enscript-keyword">if</span> (id &lt; DIF_VAR_OTHER_UBASE) {
				<span class="enscript-comment">/*
				 * For now, this has no meaning.
				 */</span>
				regs[rd] = 0;
				<span class="enscript-keyword">break</span>;
			}

			id -= DIF_VAR_OTHER_UBASE;

			ASSERT(id &lt; (uint_t)vstate-&gt;dtvs_nlocals);
			ASSERT(vstate-&gt;dtvs_locals != NULL);
			svar = vstate-&gt;dtvs_locals[id];
			ASSERT(svar != NULL);
			v = &amp;svar-&gt;dtsv_var;

			<span class="enscript-keyword">if</span> (v-&gt;dtdv_type.dtdt_flags &amp; DIF_TF_BYREF) {
				uintptr_t a = (uintptr_t)svar-&gt;dtsv_data;
				size_t sz = v-&gt;dtdv_type.dtdt_size;

				sz += <span class="enscript-keyword">sizeof</span> (uint64_t);
				ASSERT(svar-&gt;dtsv_size == (<span class="enscript-type">int</span>)NCPU * sz);
				a += CPU-&gt;cpu_id * sz;

				<span class="enscript-keyword">if</span> (*(uint8_t *)a == UINT8_MAX) {
					<span class="enscript-comment">/*
					 * If the 0th byte is set to UINT8_MAX
					 * then this is to be treated as a
					 * reference to a NULL variable.
					 */</span>
					regs[rd] = 0;
				} <span class="enscript-keyword">else</span> {
					regs[rd] = a + <span class="enscript-keyword">sizeof</span> (uint64_t);
				}

				<span class="enscript-keyword">break</span>;
			}

			ASSERT(svar-&gt;dtsv_size == (<span class="enscript-type">int</span>)NCPU * <span class="enscript-keyword">sizeof</span> (uint64_t));
			tmp = (uint64_t *)(uintptr_t)svar-&gt;dtsv_data;
			regs[rd] = tmp[CPU-&gt;cpu_id];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STLS</span>:
			id = DIF_INSTR_VAR(instr);

			ASSERT(id &gt;= DIF_VAR_OTHER_UBASE);
			id -= DIF_VAR_OTHER_UBASE;
			ASSERT(id &lt; (uint_t)vstate-&gt;dtvs_nlocals);
			ASSERT(vstate-&gt;dtvs_locals != NULL);
			svar = vstate-&gt;dtvs_locals[id];
			ASSERT(svar != NULL);
			v = &amp;svar-&gt;dtsv_var;

			<span class="enscript-keyword">if</span> (v-&gt;dtdv_type.dtdt_flags &amp; DIF_TF_BYREF) {
				uintptr_t a = (uintptr_t)svar-&gt;dtsv_data;
				size_t sz = v-&gt;dtdv_type.dtdt_size;

				sz += <span class="enscript-keyword">sizeof</span> (uint64_t);
				ASSERT(svar-&gt;dtsv_size == (<span class="enscript-type">int</span>)NCPU * sz);
				a += CPU-&gt;cpu_id * sz;

				<span class="enscript-keyword">if</span> (regs[rd] == 0) {
					*(uint8_t *)a = UINT8_MAX;
					<span class="enscript-keyword">break</span>;
				} <span class="enscript-keyword">else</span> {
					*(uint8_t *)a = 0;
					a += <span class="enscript-keyword">sizeof</span> (uint64_t);
				}

				<span class="enscript-keyword">if</span> (!dtrace_vcanload(
				    (<span class="enscript-type">void</span> *)(uintptr_t)regs[rd], &amp;v-&gt;dtdv_type,
				    mstate, vstate))
					<span class="enscript-keyword">break</span>;

				dtrace_vcopy((<span class="enscript-type">void</span> *)(uintptr_t)regs[rd],
				    (<span class="enscript-type">void</span> *)a, &amp;v-&gt;dtdv_type);
				<span class="enscript-keyword">break</span>;
			}

			ASSERT(svar-&gt;dtsv_size == (<span class="enscript-type">int</span>)NCPU * <span class="enscript-keyword">sizeof</span> (uint64_t));
			tmp = (uint64_t *)(uintptr_t)svar-&gt;dtsv_data;
			tmp[CPU-&gt;cpu_id] = regs[rd];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDTS</span>: {
			dtrace_dynvar_t *dvar;
			dtrace_key_t *key;

			id = DIF_INSTR_VAR(instr);
			ASSERT(id &gt;= DIF_VAR_OTHER_UBASE);
			id -= DIF_VAR_OTHER_UBASE;
			v = &amp;vstate-&gt;dtvs_tlocals[id];

			key = &amp;tupregs[DIF_DTR_NREGS];
			key[0].dttk_value = (uint64_t)id;
			key[0].dttk_size = 0;
			DTRACE_TLS_THRKEY(key[1].dttk_value);
			key[1].dttk_size = 0;

			dvar = dtrace_dynvar(dstate, 2, key,
			    <span class="enscript-keyword">sizeof</span> (uint64_t), DTRACE_DYNVAR_NOALLOC,
			    mstate, vstate);

			<span class="enscript-keyword">if</span> (dvar == NULL) {
				regs[rd] = 0;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (v-&gt;dtdv_type.dtdt_flags &amp; DIF_TF_BYREF) {
				regs[rd] = (uint64_t)(uintptr_t)dvar-&gt;dtdv_data;
			} <span class="enscript-keyword">else</span> {
				regs[rd] = *((uint64_t *)dvar-&gt;dtdv_data);
			}

			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STTS</span>: {
			dtrace_dynvar_t *dvar;
			dtrace_key_t *key;

			id = DIF_INSTR_VAR(instr);
			ASSERT(id &gt;= DIF_VAR_OTHER_UBASE);
			id -= DIF_VAR_OTHER_UBASE;

			key = &amp;tupregs[DIF_DTR_NREGS];
			key[0].dttk_value = (uint64_t)id;
			key[0].dttk_size = 0;
			DTRACE_TLS_THRKEY(key[1].dttk_value);
			key[1].dttk_size = 0;
			v = &amp;vstate-&gt;dtvs_tlocals[id];

			dvar = dtrace_dynvar(dstate, 2, key,
			    v-&gt;dtdv_type.dtdt_size &gt; <span class="enscript-keyword">sizeof</span> (uint64_t) ?
			    v-&gt;dtdv_type.dtdt_size : <span class="enscript-keyword">sizeof</span> (uint64_t),
			    regs[rd] ? DTRACE_DYNVAR_ALLOC :
			    DTRACE_DYNVAR_DEALLOC, mstate, vstate);

			<span class="enscript-comment">/*
			 * Given that we're storing to thread-local data,
			 * we need to flush our predicate cache.
			 */</span>
			dtrace_set_thread_predcache(current_thread(), 0);

			<span class="enscript-keyword">if</span> (dvar == NULL)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (v-&gt;dtdv_type.dtdt_flags &amp; DIF_TF_BYREF) {
				<span class="enscript-keyword">if</span> (!dtrace_vcanload(
				    (<span class="enscript-type">void</span> *)(uintptr_t)regs[rd],
				    &amp;v-&gt;dtdv_type, mstate, vstate))
					<span class="enscript-keyword">break</span>;

				dtrace_vcopy((<span class="enscript-type">void</span> *)(uintptr_t)regs[rd],
				    dvar-&gt;dtdv_data, &amp;v-&gt;dtdv_type);
			} <span class="enscript-keyword">else</span> {
				*((uint64_t *)dvar-&gt;dtdv_data) = regs[rd];
			}

			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SRA</span>:
			regs[rd] = (int64_t)regs[r1] &gt;&gt; regs[r2];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_CALL</span>:
			dtrace_dif_subr(DIF_INSTR_SUBR(instr), rd,
			    regs, tupregs, ttop, mstate, state);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_PUSHTR</span>:
			<span class="enscript-keyword">if</span> (ttop == DIF_DTR_NREGS) {
				*flags |= CPU_DTRACE_TUPOFLOW;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (r1 == DIF_TYPE_STRING) {
				<span class="enscript-comment">/*
				 * If this is a string type and the size is 0,
				 * we'll use the system-wide default string
				 * size.  Note that we are _not_ looking at
				 * the value of the DTRACEOPT_STRSIZE option;
				 * had this been set, we would expect to have
				 * a non-zero size value in the &quot;pushtr&quot;.
				 */</span>
				tupregs[ttop].dttk_size =
				    dtrace_strlen((<span class="enscript-type">char</span> *)(uintptr_t)regs[rd],
				    regs[r2] ? regs[r2] :
				    dtrace_strsize_default) + 1;
			} <span class="enscript-keyword">else</span> {
				tupregs[ttop].dttk_size = regs[r2];
			}

			tupregs[ttop++].dttk_value = regs[rd];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_PUSHTV</span>:
			<span class="enscript-keyword">if</span> (ttop == DIF_DTR_NREGS) {
				*flags |= CPU_DTRACE_TUPOFLOW;
				<span class="enscript-keyword">break</span>;
			}

			tupregs[ttop].dttk_value = regs[rd];
			tupregs[ttop++].dttk_size = 0;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_POPTS</span>:
			<span class="enscript-keyword">if</span> (ttop != 0)
				ttop--;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_FLUSHTS</span>:
			ttop = 0;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDGAA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDTAA</span>: {
			dtrace_dynvar_t *dvar;
			dtrace_key_t *key = tupregs;
			uint_t nkeys = ttop;

			id = DIF_INSTR_VAR(instr);
			ASSERT(id &gt;= DIF_VAR_OTHER_UBASE);
			id -= DIF_VAR_OTHER_UBASE;

			key[nkeys].dttk_value = (uint64_t)id;
			key[nkeys++].dttk_size = 0;

			<span class="enscript-keyword">if</span> (DIF_INSTR_OP(instr) == DIF_OP_LDTAA) {
				DTRACE_TLS_THRKEY(key[nkeys].dttk_value);
				key[nkeys++].dttk_size = 0;
				v = &amp;vstate-&gt;dtvs_tlocals[id];
			} <span class="enscript-keyword">else</span> {
				v = &amp;vstate-&gt;dtvs_globals[id]-&gt;dtsv_var;
			}

			dvar = dtrace_dynvar(dstate, nkeys, key,
			    v-&gt;dtdv_type.dtdt_size &gt; <span class="enscript-keyword">sizeof</span> (uint64_t) ?
			    v-&gt;dtdv_type.dtdt_size : <span class="enscript-keyword">sizeof</span> (uint64_t),
			    DTRACE_DYNVAR_NOALLOC, mstate, vstate);

			<span class="enscript-keyword">if</span> (dvar == NULL) {
				regs[rd] = 0;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (v-&gt;dtdv_type.dtdt_flags &amp; DIF_TF_BYREF) {
				regs[rd] = (uint64_t)(uintptr_t)dvar-&gt;dtdv_data;
			} <span class="enscript-keyword">else</span> {
				regs[rd] = *((uint64_t *)dvar-&gt;dtdv_data);
			}

			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STGAA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STTAA</span>: {
			dtrace_dynvar_t *dvar;
			dtrace_key_t *key = tupregs;
			uint_t nkeys = ttop;

			id = DIF_INSTR_VAR(instr);
			ASSERT(id &gt;= DIF_VAR_OTHER_UBASE);
			id -= DIF_VAR_OTHER_UBASE;

			key[nkeys].dttk_value = (uint64_t)id;
			key[nkeys++].dttk_size = 0;

			<span class="enscript-keyword">if</span> (DIF_INSTR_OP(instr) == DIF_OP_STTAA) {
				DTRACE_TLS_THRKEY(key[nkeys].dttk_value);
				key[nkeys++].dttk_size = 0;
				v = &amp;vstate-&gt;dtvs_tlocals[id];
			} <span class="enscript-keyword">else</span> {
				v = &amp;vstate-&gt;dtvs_globals[id]-&gt;dtsv_var;
			}

			dvar = dtrace_dynvar(dstate, nkeys, key,
			    v-&gt;dtdv_type.dtdt_size &gt; <span class="enscript-keyword">sizeof</span> (uint64_t) ?
			    v-&gt;dtdv_type.dtdt_size : <span class="enscript-keyword">sizeof</span> (uint64_t),
			    regs[rd] ? DTRACE_DYNVAR_ALLOC :
			    DTRACE_DYNVAR_DEALLOC, mstate, vstate);

			<span class="enscript-keyword">if</span> (dvar == NULL)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (v-&gt;dtdv_type.dtdt_flags &amp; DIF_TF_BYREF) {
				<span class="enscript-keyword">if</span> (!dtrace_vcanload(
				    (<span class="enscript-type">void</span> *)(uintptr_t)regs[rd], &amp;v-&gt;dtdv_type,
				    mstate, vstate))
					<span class="enscript-keyword">break</span>;

				dtrace_vcopy((<span class="enscript-type">void</span> *)(uintptr_t)regs[rd],
				    dvar-&gt;dtdv_data, &amp;v-&gt;dtdv_type);
			} <span class="enscript-keyword">else</span> {
				*((uint64_t *)dvar-&gt;dtdv_data) = regs[rd];
			}

			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ALLOCS</span>: {
			uintptr_t ptr = P2ROUNDUP(mstate-&gt;dtms_scratch_ptr, 8);
			size_t size = ptr - mstate-&gt;dtms_scratch_ptr + regs[r1];

			<span class="enscript-comment">/*
			 * Rounding up the user allocation size could have
			 * overflowed large, bogus allocations (like -1ULL) to
			 * 0.
			 */</span>
			<span class="enscript-keyword">if</span> (size &lt; regs[r1] ||
			    !DTRACE_INSCRATCH(mstate, size)) {
				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
				regs[rd] = 0;
				<span class="enscript-keyword">break</span>;
			}

			dtrace_bzero((<span class="enscript-type">void</span> *) mstate-&gt;dtms_scratch_ptr, size);
				mstate-&gt;dtms_scratch_ptr += size;
				regs[rd] = ptr;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_COPYS</span>:
			<span class="enscript-keyword">if</span> (!dtrace_canstore(regs[rd], regs[r2],
			    mstate, vstate)) {
				*flags |= CPU_DTRACE_BADADDR;
				*illval = regs[rd];
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (!dtrace_canload(regs[r1], regs[r2], mstate, vstate))
				<span class="enscript-keyword">break</span>;

			dtrace_bcopy((<span class="enscript-type">void</span> *)(uintptr_t)regs[r1],
			    (<span class="enscript-type">void</span> *)(uintptr_t)regs[rd], (size_t)regs[r2]);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STB</span>:
			<span class="enscript-keyword">if</span> (!dtrace_canstore(regs[rd], 1, mstate, vstate)) {
				*flags |= CPU_DTRACE_BADADDR;
				*illval = regs[rd];
				<span class="enscript-keyword">break</span>;
			}
			*((uint8_t *)(uintptr_t)regs[rd]) = (uint8_t)regs[r1];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STH</span>:
			<span class="enscript-keyword">if</span> (!dtrace_canstore(regs[rd], 2, mstate, vstate)) {
				*flags |= CPU_DTRACE_BADADDR;
				*illval = regs[rd];
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (regs[rd] &amp; 1) {
				*flags |= CPU_DTRACE_BADALIGN;
				*illval = regs[rd];
				<span class="enscript-keyword">break</span>;
			}
			*((uint16_t *)(uintptr_t)regs[rd]) = (uint16_t)regs[r1];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STW</span>:
			<span class="enscript-keyword">if</span> (!dtrace_canstore(regs[rd], 4, mstate, vstate)) {
				*flags |= CPU_DTRACE_BADADDR;
				*illval = regs[rd];
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (regs[rd] &amp; 3) {
				*flags |= CPU_DTRACE_BADALIGN;
				*illval = regs[rd];
				<span class="enscript-keyword">break</span>;
			}
			*((uint32_t *)(uintptr_t)regs[rd]) = (uint32_t)regs[r1];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STX</span>:
			<span class="enscript-keyword">if</span> (!dtrace_canstore(regs[rd], 8, mstate, vstate)) {
				*flags |= CPU_DTRACE_BADADDR;
				*illval = regs[rd];
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/*
			* Darwin kmem_zalloc() called from
			* dtrace_difo_init() is 4-byte aligned.
			*/</span>
			<span class="enscript-keyword">if</span> (regs[rd] &amp; 3) {
				*flags |= CPU_DTRACE_BADALIGN;
				*illval = regs[rd];
				<span class="enscript-keyword">break</span>;
			}
			*((uint64_t *)(uintptr_t)regs[rd]) = regs[r1];
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (!(*flags &amp; CPU_DTRACE_FAULT))
		<span class="enscript-keyword">return</span> (rval);

	mstate-&gt;dtms_fltoffs = opc * <span class="enscript-keyword">sizeof</span> (dif_instr_t);
	mstate-&gt;dtms_present |= DTRACE_MSTATE_FLTOFFS;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_action_breakpoint</span>(dtrace_ecb_t *ecb)
{
	dtrace_probe_t *probe = ecb-&gt;dte_probe;
	dtrace_provider_t *prov = probe-&gt;dtpr_provider;
	<span class="enscript-type">char</span> c[DTRACE_FULLNAMELEN + 80], *str;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg = <span class="enscript-string">&quot;dtrace: breakpoint action at probe &quot;</span>;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *ecbmsg = <span class="enscript-string">&quot; (ecb &quot;</span>;
	uintptr_t mask = (0xf &lt;&lt; (<span class="enscript-keyword">sizeof</span> (uintptr_t) * NBBY / 4));
	uintptr_t val = (uintptr_t)ecb;
	<span class="enscript-type">int</span> shift = (<span class="enscript-keyword">sizeof</span> (uintptr_t) * NBBY) - 4, i = 0;

	<span class="enscript-keyword">if</span> (dtrace_destructive_disallow)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * It's impossible to be taking action on the NULL probe.
	 */</span>
	ASSERT(probe != NULL);

	<span class="enscript-comment">/*
	 * This is a poor man's (destitute man's?) sprintf():  we want to
	 * print the provider name, module name, function name and name of
	 * the probe, along with the hex address of the ECB with the breakpoint
	 * action -- all of which we must place in the character buffer by
	 * hand.
	 */</span>
	<span class="enscript-keyword">while</span> (*msg != <span class="enscript-string">'\0'</span>)
		c[i++] = *msg++;

	<span class="enscript-keyword">for</span> (str = prov-&gt;dtpv_name; *str != <span class="enscript-string">'\0'</span>; str++)
		c[i++] = *str;
	c[i++] = <span class="enscript-string">':'</span>;

	<span class="enscript-keyword">for</span> (str = probe-&gt;dtpr_mod; *str != <span class="enscript-string">'\0'</span>; str++)
		c[i++] = *str;
	c[i++] = <span class="enscript-string">':'</span>;

	<span class="enscript-keyword">for</span> (str = probe-&gt;dtpr_func; *str != <span class="enscript-string">'\0'</span>; str++)
		c[i++] = *str;
	c[i++] = <span class="enscript-string">':'</span>;

	<span class="enscript-keyword">for</span> (str = probe-&gt;dtpr_name; *str != <span class="enscript-string">'\0'</span>; str++)
		c[i++] = *str;

	<span class="enscript-keyword">while</span> (*ecbmsg != <span class="enscript-string">'\0'</span>)
		c[i++] = *ecbmsg++;

	<span class="enscript-keyword">while</span> (shift &gt;= 0) {
		mask = (uintptr_t)0xf &lt;&lt; shift;

		<span class="enscript-keyword">if</span> (val &gt;= ((uintptr_t)1 &lt;&lt; shift))
			c[i++] = <span class="enscript-string">&quot;0123456789abcdef&quot;</span>[(val &amp; mask) &gt;&gt; shift];
		shift -= 4;
	}

	c[i++] = <span class="enscript-string">')'</span>;
	c[i] = <span class="enscript-string">'\0'</span>;

	debug_enter(c);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_action_panic</span>(dtrace_ecb_t *ecb)
{
	dtrace_probe_t *probe = ecb-&gt;dte_probe;

	<span class="enscript-comment">/*
	 * It's impossible to be taking action on the NULL probe.
	 */</span>
	ASSERT(probe != NULL);

	<span class="enscript-keyword">if</span> (dtrace_destructive_disallow)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (dtrace_panicked != NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (dtrace_casptr(&amp;dtrace_panicked, NULL, current_thread()) != NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * We won the right to panic.  (We want to be sure that only one
	 * thread calls panic() from dtrace_probe(), and that panic() is
	 * called exactly once.)
	 */</span>
	panic(<span class="enscript-string">&quot;dtrace: panic action at probe %s:%s:%s:%s (ecb %p)&quot;</span>,
	    probe-&gt;dtpr_provider-&gt;dtpv_name, probe-&gt;dtpr_mod,
	    probe-&gt;dtpr_func, probe-&gt;dtpr_name, (<span class="enscript-type">void</span> *)ecb);

	<span class="enscript-comment">/*
	 * APPLE NOTE: this was for an old Mac OS X debug feature
	 * allowing a return from panic().  Revisit someday.
	 */</span>
	dtrace_panicked = NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_action_raise</span>(uint64_t sig)
{
	<span class="enscript-keyword">if</span> (dtrace_destructive_disallow)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (sig &gt;= NSIG) {
		DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * raise() has a queue depth of 1 -- we ignore all subsequent
	 * invocations of the raise() action.
	 */</span>

	uthread_t uthread = (uthread_t)get_bsdthread_info(current_thread());

	<span class="enscript-keyword">if</span> (uthread &amp;&amp; uthread-&gt;t_dtrace_sig == 0) {
		uthread-&gt;t_dtrace_sig = sig;
		act_set_astbsd(current_thread());
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_action_stop</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (dtrace_destructive_disallow)
		<span class="enscript-keyword">return</span>;

        uthread_t uthread = (uthread_t)get_bsdthread_info(current_thread());
	<span class="enscript-keyword">if</span> (uthread) {
		<span class="enscript-comment">/*
		 * The currently running process will be set to task_suspend
		 * when it next leaves the kernel.
		*/</span>
		uthread-&gt;t_dtrace_stop = 1;
		act_set_astbsd(current_thread());
	}
}


<span class="enscript-comment">/*
 * APPLE NOTE: pidresume works in conjunction with the dtrace stop action.
 * Both activate only when the currently running process next leaves the
 * kernel.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_action_pidresume</span>(uint64_t pid)
{
	<span class="enscript-keyword">if</span> (dtrace_destructive_disallow)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (kauth_cred_issuser(kauth_cred_get()) == 0) {
		DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);		
		<span class="enscript-keyword">return</span>;
	}
        uthread_t uthread = (uthread_t)get_bsdthread_info(current_thread());

	<span class="enscript-comment">/*
	 * When the currently running process leaves the kernel, it attempts to
	 * task_resume the process (denoted by pid), if that pid appears to have
	 * been stopped by dtrace_action_stop().
	 * The currently running process has a pidresume() queue depth of 1 --
	 * subsequent invocations of the pidresume() action are ignored.
	 */</span>	

	<span class="enscript-keyword">if</span> (pid != 0 &amp;&amp; uthread &amp;&amp; uthread-&gt;t_dtrace_resumepid == 0) {
		uthread-&gt;t_dtrace_resumepid = pid;
		act_set_astbsd(current_thread());
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_action_chill</span>(dtrace_mstate_t *mstate, hrtime_t val)
{
	hrtime_t now;
	<span class="enscript-type">volatile</span> uint16_t *flags;
	dtrace_cpu_t *cpu = CPU;

	<span class="enscript-keyword">if</span> (dtrace_destructive_disallow)
		<span class="enscript-keyword">return</span>;

	flags = (<span class="enscript-type">volatile</span> uint16_t *)&amp;cpu_core[cpu-&gt;cpu_id].cpuc_dtrace_flags;

	now = dtrace_gethrtime();

	<span class="enscript-keyword">if</span> (now - cpu-&gt;cpu_dtrace_chillmark &gt; dtrace_chill_interval) {
		<span class="enscript-comment">/*
		 * We need to advance the mark to the current time.
		 */</span>
		cpu-&gt;cpu_dtrace_chillmark = now;
		cpu-&gt;cpu_dtrace_chilled = 0;
	}

	<span class="enscript-comment">/*
	 * Now check to see if the requested chill time would take us over
	 * the maximum amount of time allowed in the chill interval.  (Or
	 * worse, if the calculation itself induces overflow.)
	 */</span>
	<span class="enscript-keyword">if</span> (cpu-&gt;cpu_dtrace_chilled + val &gt; dtrace_chill_max ||
	    cpu-&gt;cpu_dtrace_chilled + val &lt; cpu-&gt;cpu_dtrace_chilled) {
		*flags |= CPU_DTRACE_ILLOP;
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">while</span> (dtrace_gethrtime() - now &lt; val)
		<span class="enscript-keyword">continue</span>;

	<span class="enscript-comment">/*
	 * Normally, we assure that the value of the variable &quot;timestamp&quot; does
	 * not change within an ECB.  The presence of chill() represents an
	 * exception to this rule, however.
	 */</span>
	mstate-&gt;dtms_present &amp;= ~DTRACE_MSTATE_TIMESTAMP;
	cpu-&gt;cpu_dtrace_chilled += val;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_action_ustack</span>(dtrace_mstate_t *mstate, dtrace_state_t *state,
    uint64_t *buf, uint64_t arg)
{
	<span class="enscript-type">int</span> nframes = DTRACE_USTACK_NFRAMES(arg);
	<span class="enscript-type">int</span> strsize = DTRACE_USTACK_STRSIZE(arg);
	uint64_t *pcs = &amp;buf[1], *fps;
	<span class="enscript-type">char</span> *str = (<span class="enscript-type">char</span> *)&amp;pcs[nframes];
	<span class="enscript-type">int</span> size, offs = 0, i, j;
	uintptr_t old = mstate-&gt;dtms_scratch_ptr, saved;
	uint16_t *flags = &amp;cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags;
	<span class="enscript-type">char</span> *sym;

	<span class="enscript-comment">/*
	 * Should be taking a faster path if string space has not been
	 * allocated.
	 */</span>
	ASSERT(strsize != 0);

	<span class="enscript-comment">/*
	 * We will first allocate some temporary space for the frame pointers.
	 */</span>
	fps = (uint64_t *)P2ROUNDUP(mstate-&gt;dtms_scratch_ptr, 8);
	size = (uintptr_t)fps - mstate-&gt;dtms_scratch_ptr +
	    (nframes * <span class="enscript-keyword">sizeof</span> (uint64_t));

	<span class="enscript-keyword">if</span> (!DTRACE_INSCRATCH(mstate, (uintptr_t)size)) {
		<span class="enscript-comment">/*
		 * Not enough room for our frame pointers -- need to indicate
		 * that we ran out of scratch space.
		 */</span>
		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
		<span class="enscript-keyword">return</span>;
	}

	mstate-&gt;dtms_scratch_ptr += size;
	saved = mstate-&gt;dtms_scratch_ptr;

	<span class="enscript-comment">/*
	 * Now get a stack with both program counters and frame pointers.
	 */</span>
	DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
	dtrace_getufpstack(buf, fps, nframes + 1);
	DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);

	<span class="enscript-comment">/*
	 * If that faulted, we're cooked.
	 */</span>
	<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_FAULT)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * Now we want to walk up the stack, calling the USTACK helper.  For
	 * each iteration, we restore the scratch pointer.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; nframes; i++) {
		mstate-&gt;dtms_scratch_ptr = saved;

		<span class="enscript-keyword">if</span> (offs &gt;= strsize)
			<span class="enscript-keyword">break</span>;

		sym = (<span class="enscript-type">char</span> *)(uintptr_t)dtrace_helper(
		    DTRACE_HELPER_ACTION_USTACK,
		    mstate, state, pcs[i], fps[i]);

		<span class="enscript-comment">/*
		 * If we faulted while running the helper, we're going to
		 * clear the fault and null out the corresponding string.
		 */</span>
		<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_FAULT) {
			*flags &amp;= ~CPU_DTRACE_FAULT;
			str[offs++] = <span class="enscript-string">'\0'</span>;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (sym == NULL) {
			str[offs++] = <span class="enscript-string">'\0'</span>;
			<span class="enscript-keyword">continue</span>;
		}

		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);

		<span class="enscript-comment">/*
		 * Now copy in the string that the helper returned to us.
		 */</span>
		<span class="enscript-keyword">for</span> (j = 0; offs + j &lt; strsize; j++) {
			<span class="enscript-keyword">if</span> ((str[offs + j] = sym[j]) == <span class="enscript-string">'\0'</span>)
				<span class="enscript-keyword">break</span>;
		}

		DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);

		offs += j + 1;
	}

	<span class="enscript-keyword">if</span> (offs &gt;= strsize) {
		<span class="enscript-comment">/*
		 * If we didn't have room for all of the strings, we don't
		 * abort processing -- this needn't be a fatal error -- but we
		 * still want to increment a counter (dts_stkstroverflows) to
		 * allow this condition to be warned about.  (If this is from
		 * a jstack() action, it is easily tuned via jstackstrsize.)
		 */</span>
		dtrace_error(&amp;state-&gt;dts_stkstroverflows);
	}

	<span class="enscript-keyword">while</span> (offs &lt; strsize)
		str[offs++] = <span class="enscript-string">'\0'</span>;

<span class="enscript-reference">out</span>:
	mstate-&gt;dtms_scratch_ptr = old;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_store_by_ref</span>(dtrace_difo_t *dp, caddr_t tomax, size_t size,
    size_t *valoffsp, uint64_t *valp, uint64_t end, <span class="enscript-type">int</span> intuple, <span class="enscript-type">int</span> dtkind)
{
	<span class="enscript-type">volatile</span> uint16_t *flags;
	uint64_t val = *valp;
	size_t valoffs = *valoffsp;

	flags = (<span class="enscript-type">volatile</span> uint16_t *)&amp;cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags;
	ASSERT(dtkind == DIF_TF_BYREF || dtkind == DIF_TF_BYUREF);

	<span class="enscript-comment">/*
	 * If this is a string, we're going to only load until we find the zero
	 * byte -- after which we'll store zero bytes.
	 */</span>
	<span class="enscript-keyword">if</span> (dp-&gt;dtdo_rtype.dtdt_kind == DIF_TYPE_STRING) {
		<span class="enscript-type">char</span> c = <span class="enscript-string">'\0'</span> + 1;
		size_t s;

		<span class="enscript-keyword">for</span> (s = 0; s &lt; size; s++) {
			<span class="enscript-keyword">if</span> (c != <span class="enscript-string">'\0'</span> &amp;&amp; dtkind == DIF_TF_BYREF) {
				c = dtrace_load8(val++);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (c != <span class="enscript-string">'\0'</span> &amp;&amp; dtkind == DIF_TF_BYUREF) {
				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
				c = dtrace_fuword8((user_addr_t)(uintptr_t)val++);
				DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
				<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_FAULT)
					<span class="enscript-keyword">break</span>;
			}

			DTRACE_STORE(uint8_t, tomax, valoffs++, c);

			<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\0'</span> &amp;&amp; intuple)
				<span class="enscript-keyword">break</span>;
		}
	} <span class="enscript-keyword">else</span> {
		uint8_t c;
		<span class="enscript-keyword">while</span> (valoffs &lt; end) {
			<span class="enscript-keyword">if</span> (dtkind == DIF_TF_BYREF) {
				c = dtrace_load8(val++);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dtkind == DIF_TF_BYUREF) {
				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
				c = dtrace_fuword8((user_addr_t)(uintptr_t)val++);
				DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
				<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_FAULT)
					<span class="enscript-keyword">break</span>;
			}

			DTRACE_STORE(uint8_t, tomax,
			    valoffs++, c);
		}
	}

	*valp = val;
	*valoffsp = valoffs;
}

<span class="enscript-comment">/*
 * If you're looking for the epicenter of DTrace, you just found it.  This
 * is the function called by the provider to fire a probe -- from which all
 * subsequent probe-context DTrace activity emanates.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">__dtrace_probe</span>(dtrace_id_t id, uint64_t arg0, uint64_t arg1,
    uint64_t arg2, uint64_t arg3, uint64_t arg4)
{
	processorid_t cpuid;
	dtrace_icookie_t cookie;
	dtrace_probe_t *probe;
	dtrace_mstate_t mstate;
	dtrace_ecb_t *ecb;
	dtrace_action_t *act;
	intptr_t offs;
	size_t size;
	<span class="enscript-type">int</span> vtime, onintr;
	<span class="enscript-type">volatile</span> uint16_t *flags;
	hrtime_t now;

	cookie = dtrace_interrupt_disable();
	probe = dtrace_probes[id - 1];
	cpuid = CPU-&gt;cpu_id;
	onintr = CPU_ON_INTR(CPU);

	<span class="enscript-keyword">if</span> (!onintr &amp;&amp; probe-&gt;dtpr_predcache != DTRACE_CACHEIDNONE &amp;&amp;
	    probe-&gt;dtpr_predcache == dtrace_get_thread_predcache(current_thread())) {
		<span class="enscript-comment">/*
		 * We have hit in the predicate cache; we know that
		 * this predicate would evaluate to be false.
		 */</span>
		dtrace_interrupt_enable(cookie);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (panic_quiesce) {
		<span class="enscript-comment">/*
		 * We don't trace anything if we're panicking.
		 */</span>
		dtrace_interrupt_enable(cookie);
		<span class="enscript-keyword">return</span>;
	}

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
	now = dtrace_gethrtime();
	vtime = dtrace_vtime_references != 0;

	<span class="enscript-keyword">if</span> (vtime &amp;&amp; curthread-&gt;t_dtrace_start)
		curthread-&gt;t_dtrace_vtime += now - curthread-&gt;t_dtrace_start;
#<span class="enscript-reference">else</span>
	<span class="enscript-comment">/*
	 * APPLE NOTE:  The time spent entering DTrace and arriving
	 * to this point, is attributed to the current thread.
	 * Instead it should accrue to DTrace.  FIXME
	 */</span>
	vtime = dtrace_vtime_references != 0;

	<span class="enscript-keyword">if</span> (vtime)
	{
		int64_t dtrace_accum_time, recent_vtime;
		thread_t thread = current_thread();

		dtrace_accum_time = dtrace_get_thread_tracing(thread); <span class="enscript-comment">/* Time spent inside DTrace so far (nanoseconds) */</span>

		<span class="enscript-keyword">if</span> (dtrace_accum_time &gt;= 0) {
			recent_vtime = dtrace_abs_to_nano(dtrace_calc_thread_recent_vtime(thread)); <span class="enscript-comment">/* up to the moment thread vtime */</span>

			recent_vtime = recent_vtime - dtrace_accum_time; <span class="enscript-comment">/* Time without DTrace contribution */</span>
		
			dtrace_set_thread_vtime(thread, recent_vtime);
		}
	}

	now = dtrace_gethrtime(); <span class="enscript-comment">/* must not precede dtrace_calc_thread_recent_vtime() call! */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

	<span class="enscript-comment">/*
	 * APPLE NOTE: A provider may call dtrace_probe_error() in lieu of
	 * dtrace_probe() in some circumstances.   See, e.g. fasttrap_isa.c.
	 * However the provider has no access to ECB context, so passes
	 * 0 through &quot;arg0&quot; and the probe_id of the overridden probe as arg1.
	 * Detect that here and cons up a viable state (from the probe_id).
	 */</span>
	<span class="enscript-keyword">if</span> (dtrace_probeid_error == id &amp;&amp; 0 == arg0) {
		dtrace_id_t ftp_id = (dtrace_id_t)arg1;
		dtrace_probe_t *ftp_probe = dtrace_probes[ftp_id - 1];
		dtrace_ecb_t *ftp_ecb = ftp_probe-&gt;dtpr_ecb;

		<span class="enscript-keyword">if</span> (NULL != ftp_ecb) {
			dtrace_state_t *ftp_state = ftp_ecb-&gt;dte_state;

			arg0 = (uint64_t)(uintptr_t)ftp_state;
			arg1 = ftp_ecb-&gt;dte_epid;
			<span class="enscript-comment">/*
			 * args[2-4] established by caller.
			 */</span>
			ftp_state-&gt;dts_arg_error_illval = -1; <span class="enscript-comment">/* arg5 */</span>
		}
	}

	mstate.dtms_difo = NULL;
	mstate.dtms_probe = probe;
	mstate.dtms_strtok = 0;
	mstate.dtms_arg[0] = arg0;
	mstate.dtms_arg[1] = arg1;
	mstate.dtms_arg[2] = arg2;
	mstate.dtms_arg[3] = arg3;
	mstate.dtms_arg[4] = arg4;

	flags = (<span class="enscript-type">volatile</span> uint16_t *)&amp;cpu_core[cpuid].cpuc_dtrace_flags;

	<span class="enscript-keyword">for</span> (ecb = probe-&gt;dtpr_ecb; ecb != NULL; ecb = ecb-&gt;dte_next) {
		dtrace_predicate_t *pred = ecb-&gt;dte_predicate;
		dtrace_state_t *state = ecb-&gt;dte_state;
		dtrace_buffer_t *buf = &amp;state-&gt;dts_buffer[cpuid];
		dtrace_buffer_t *aggbuf = &amp;state-&gt;dts_aggbuffer[cpuid];
		dtrace_vstate_t *vstate = &amp;state-&gt;dts_vstate;
		dtrace_provider_t *prov = probe-&gt;dtpr_provider;
		uint64_t tracememsize = 0;
		<span class="enscript-type">int</span> committed = 0;
		caddr_t tomax;

		<span class="enscript-comment">/*
		 * A little subtlety with the following (seemingly innocuous)
		 * declaration of the automatic 'val':  by looking at the
		 * code, you might think that it could be declared in the
		 * action processing loop, below.  (That is, it's only used in
		 * the action processing loop.)  However, it must be declared
		 * out of that scope because in the case of DIF expression
		 * arguments to aggregating actions, one iteration of the
		 * action loop will use the last iteration's value.
		 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">lint</span>
		uint64_t val = 0;
#<span class="enscript-reference">else</span>
		uint64_t val = 0;
#<span class="enscript-reference">endif</span>

		mstate.dtms_present = DTRACE_MSTATE_ARGS | DTRACE_MSTATE_PROBE;
		*flags &amp;= ~CPU_DTRACE_ERROR;

		<span class="enscript-keyword">if</span> (prov == dtrace_provider) {
			<span class="enscript-comment">/*
			 * If dtrace itself is the provider of this probe,
			 * we're only going to continue processing the ECB if
			 * arg0 (the dtrace_state_t) is equal to the ECB's
			 * creating state.  (This prevents disjoint consumers
			 * from seeing one another's metaprobes.)
			 */</span>
			<span class="enscript-keyword">if</span> (arg0 != (uint64_t)(uintptr_t)state)
				<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (state-&gt;dts_activity != DTRACE_ACTIVITY_ACTIVE) {
			<span class="enscript-comment">/*
			 * We're not currently active.  If our provider isn't
			 * the dtrace pseudo provider, we're not interested.
			 */</span>
			<span class="enscript-keyword">if</span> (prov != dtrace_provider)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-comment">/*
			 * Now we must further check if we are in the BEGIN
			 * probe.  If we are, we will only continue processing
			 * if we're still in WARMUP -- if one BEGIN enabling
			 * has invoked the exit() action, we don't want to
			 * evaluate subsequent BEGIN enablings.
			 */</span>
			<span class="enscript-keyword">if</span> (probe-&gt;dtpr_id == dtrace_probeid_begin &amp;&amp;
			    state-&gt;dts_activity != DTRACE_ACTIVITY_WARMUP) {
				ASSERT(state-&gt;dts_activity ==
				    DTRACE_ACTIVITY_DRAINING);
				<span class="enscript-keyword">continue</span>;
			}
		}

		<span class="enscript-keyword">if</span> (ecb-&gt;dte_cond) {
			<span class="enscript-comment">/*
			 * If the dte_cond bits indicate that this
			 * consumer is only allowed to see user-mode firings
			 * of this probe, call the provider's dtps_usermode()
			 * entry point to check that the probe was fired
			 * while in a user context. Skip this ECB if that's
			 * not the case.
			 */</span>
			<span class="enscript-keyword">if</span> ((ecb-&gt;dte_cond &amp; DTRACE_COND_USERMODE) &amp;&amp;
			    prov-&gt;dtpv_pops.dtps_usermode(prov-&gt;dtpv_arg,
			    probe-&gt;dtpr_id, probe-&gt;dtpr_arg) == 0)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-comment">/*
			 * This is more subtle than it looks. We have to be
			 * absolutely certain that CRED() isn't going to
			 * change out from under us so it's only legit to
			 * examine that structure if we're in constrained
			 * situations. Currently, the only times we'll this
			 * check is if a non-super-user has enabled the
			 * profile or syscall providers -- providers that
			 * allow visibility of all processes. For the
			 * profile case, the check above will ensure that
			 * we're examining a user context.
			 */</span>
			<span class="enscript-keyword">if</span> (ecb-&gt;dte_cond &amp; DTRACE_COND_OWNER) {
				cred_t *cr;
				cred_t *s_cr =
				    ecb-&gt;dte_state-&gt;dts_cred.dcr_cred;
				proc_t *proc;
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">proc</span>) <span class="enscript-comment">/* __APPLE__ */</span>

				ASSERT(s_cr != NULL);

			<span class="enscript-comment">/*
			 * XXX this is hackish, but so is setting a variable
			 * XXX in a McCarthy OR...
			 */</span>
				<span class="enscript-keyword">if</span> ((cr = dtrace_CRED()) == NULL ||
				    posix_cred_get(s_cr)-&gt;cr_uid != posix_cred_get(cr)-&gt;cr_uid ||
				    posix_cred_get(s_cr)-&gt;cr_uid != posix_cred_get(cr)-&gt;cr_ruid ||
				    posix_cred_get(s_cr)-&gt;cr_uid != posix_cred_get(cr)-&gt;cr_suid ||
				    posix_cred_get(s_cr)-&gt;cr_gid != posix_cred_get(cr)-&gt;cr_gid ||
				    posix_cred_get(s_cr)-&gt;cr_gid != posix_cred_get(cr)-&gt;cr_rgid ||
				    posix_cred_get(s_cr)-&gt;cr_gid != posix_cred_get(cr)-&gt;cr_sgid ||
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
				    (proc = ttoproc(curthread)) == NULL ||
				    (proc-&gt;p_flag &amp; SNOCD))
#<span class="enscript-reference">else</span>
					1) <span class="enscript-comment">/* APPLE NOTE: Darwin omits &quot;No Core Dump&quot; flag */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>
					<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">if</span> (ecb-&gt;dte_cond &amp; DTRACE_COND_ZONEOWNER) {
				cred_t *cr;
				cred_t *s_cr =
				    ecb-&gt;dte_state-&gt;dts_cred.dcr_cred;
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cr</span>, <span class="enscript-variable-name">s_cr</span>) <span class="enscript-comment">/* __APPLE__ */</span>

				ASSERT(s_cr != NULL);

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
				<span class="enscript-keyword">if</span> ((cr = CRED()) == NULL ||
				    s_cr-&gt;cr_zone-&gt;zone_id !=
				    cr-&gt;cr_zone-&gt;zone_id)
					<span class="enscript-keyword">continue</span>;
#<span class="enscript-reference">else</span>
				<span class="enscript-comment">/* APPLE NOTE: Darwin doesn't do zones. */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>
			}
		}

		<span class="enscript-keyword">if</span> (now - state-&gt;dts_alive &gt; dtrace_deadman_timeout) {
			<span class="enscript-comment">/*
			 * We seem to be dead.  Unless we (a) have kernel
			 * destructive permissions (b) have expicitly enabled
			 * destructive actions and (c) destructive actions have
			 * not been disabled, we're going to transition into
			 * the KILLED state, from which no further processing
			 * on this state will be performed.
			 */</span>
			<span class="enscript-keyword">if</span> (!dtrace_priv_kernel_destructive(state) ||
			    !state-&gt;dts_cred.dcr_destructive ||
			    dtrace_destructive_disallow) {
				<span class="enscript-type">void</span> *activity = &amp;state-&gt;dts_activity;
				dtrace_activity_t current;

				<span class="enscript-keyword">do</span> {
					current = state-&gt;dts_activity;
				} <span class="enscript-keyword">while</span> (dtrace_cas32(activity, current,
				    DTRACE_ACTIVITY_KILLED) != current);

				<span class="enscript-keyword">continue</span>;
			}
		}

		<span class="enscript-keyword">if</span> ((offs = dtrace_buffer_reserve(buf, ecb-&gt;dte_needed,
		    ecb-&gt;dte_alignment, state, &amp;mstate)) &lt; 0)
			<span class="enscript-keyword">continue</span>;

		tomax = buf-&gt;dtb_tomax;
		ASSERT(tomax != NULL);

		<span class="enscript-comment">/*
		 * Build and store the record header corresponding to the ECB.
		 */</span>
		<span class="enscript-keyword">if</span> (ecb-&gt;dte_size != 0) {
			dtrace_rechdr_t dtrh;

			<span class="enscript-keyword">if</span> (!(mstate.dtms_present &amp; DTRACE_MSTATE_TIMESTAMP)) {
				mstate.dtms_timestamp = dtrace_gethrtime();
				mstate.dtms_present |= DTRACE_MSTATE_TIMESTAMP;
			}

			ASSERT(ecb-&gt;dte_size &gt;= <span class="enscript-keyword">sizeof</span>(dtrace_rechdr_t));

			dtrh.dtrh_epid = ecb-&gt;dte_epid;
			DTRACE_RECORD_STORE_TIMESTAMP(&amp;dtrh, mstate.dtms_timestamp);
			DTRACE_STORE(dtrace_rechdr_t, tomax, offs, dtrh);
		}

		mstate.dtms_epid = ecb-&gt;dte_epid;
		mstate.dtms_present |= DTRACE_MSTATE_EPID;

		<span class="enscript-keyword">if</span> (state-&gt;dts_cred.dcr_visible &amp; DTRACE_CRV_KERNEL)
			mstate.dtms_access = DTRACE_ACCESS_KERNEL;
		<span class="enscript-keyword">else</span>
			mstate.dtms_access = 0;

		<span class="enscript-keyword">if</span> (pred != NULL) {
			dtrace_difo_t *dp = pred-&gt;dtp_difo;
			<span class="enscript-type">int</span> rval;

			rval = dtrace_dif_emulate(dp, &amp;mstate, vstate, state);

			<span class="enscript-keyword">if</span> (!(*flags &amp; CPU_DTRACE_ERROR) &amp;&amp; !rval) {
				dtrace_cacheid_t cid = probe-&gt;dtpr_predcache;

				<span class="enscript-keyword">if</span> (cid != DTRACE_CACHEIDNONE &amp;&amp; !onintr) {
					<span class="enscript-comment">/*
					 * Update the predicate cache...
					 */</span>
					ASSERT(cid == pred-&gt;dtp_cacheid);

					dtrace_set_thread_predcache(current_thread(), cid);
				}

				<span class="enscript-keyword">continue</span>;
			}
		}

		<span class="enscript-keyword">for</span> (act = ecb-&gt;dte_action; !(*flags &amp; CPU_DTRACE_ERROR) &amp;&amp;
		    act != NULL; act = act-&gt;dta_next) {
			size_t valoffs;
			dtrace_difo_t *dp;
			dtrace_recdesc_t *rec = &amp;act-&gt;dta_rec;

			size = rec-&gt;dtrd_size;
			valoffs = offs + rec-&gt;dtrd_offset;

			<span class="enscript-keyword">if</span> (DTRACEACT_ISAGG(act-&gt;dta_kind)) {
				uint64_t v = 0xbad;
				dtrace_aggregation_t *agg;

				agg = (dtrace_aggregation_t *)act;

				<span class="enscript-keyword">if</span> ((dp = act-&gt;dta_difo) != NULL)
					v = dtrace_dif_emulate(dp,
					    &amp;mstate, vstate, state);

				<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_ERROR)
					<span class="enscript-keyword">continue</span>;

				<span class="enscript-comment">/*
				 * Note that we always pass the expression
				 * value from the previous iteration of the
				 * action loop.  This value will only be used
				 * if there is an expression argument to the
				 * aggregating action, denoted by the
				 * dtag_hasarg field.
				 */</span>
				dtrace_aggregate(agg, buf,
				    offs, aggbuf, v, val);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">switch</span> (act-&gt;dta_kind) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_STOP</span>:
				<span class="enscript-keyword">if</span> (dtrace_priv_proc_destructive(state))
					dtrace_action_stop();
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_BREAKPOINT</span>:
				<span class="enscript-keyword">if</span> (dtrace_priv_kernel_destructive(state))
					dtrace_action_breakpoint(ecb);
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_PANIC</span>:
				<span class="enscript-keyword">if</span> (dtrace_priv_kernel_destructive(state))
					dtrace_action_panic(ecb);
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_STACK</span>:
				<span class="enscript-keyword">if</span> (!dtrace_priv_kernel(state))
					<span class="enscript-keyword">continue</span>;

				dtrace_getpcstack((pc_t *)(tomax + valoffs),
				    size / <span class="enscript-keyword">sizeof</span> (pc_t), probe-&gt;dtpr_aframes,
				    DTRACE_ANCHORED(probe) ? NULL :
				  (uint32_t *)(uintptr_t)arg0);
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_JSTACK</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_USTACK</span>:
				<span class="enscript-keyword">if</span> (!dtrace_priv_proc(state))
					<span class="enscript-keyword">continue</span>;

				<span class="enscript-comment">/*
				 * See comment in DIF_VAR_PID.
				 */</span>
				<span class="enscript-keyword">if</span> (DTRACE_ANCHORED(mstate.dtms_probe) &amp;&amp;
				    CPU_ON_INTR(CPU)) {
					<span class="enscript-type">int</span> depth = DTRACE_USTACK_NFRAMES(
					    rec-&gt;dtrd_arg) + 1;

					dtrace_bzero((<span class="enscript-type">void</span> *)(tomax + valoffs),
					    DTRACE_USTACK_STRSIZE(rec-&gt;dtrd_arg)
					    + depth * <span class="enscript-keyword">sizeof</span> (uint64_t));

					<span class="enscript-keyword">continue</span>;
				}

				<span class="enscript-keyword">if</span> (DTRACE_USTACK_STRSIZE(rec-&gt;dtrd_arg) != 0 &amp;&amp;
				    curproc-&gt;p_dtrace_helpers != NULL) {
					<span class="enscript-comment">/*
					 * This is the slow path -- we have
					 * allocated string space, and we're
					 * getting the stack of a process that
					 * has helpers.  Call into a separate
					 * routine to perform this processing.
					 */</span>
					dtrace_action_ustack(&amp;mstate, state,
					    (uint64_t *)(tomax + valoffs),
					    rec-&gt;dtrd_arg);
					<span class="enscript-keyword">continue</span>;
				}

				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
				dtrace_getupcstack((uint64_t *)
				    (tomax + valoffs),
				    DTRACE_USTACK_NFRAMES(rec-&gt;dtrd_arg) + 1);
				DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
			}

			dp = act-&gt;dta_difo;
			ASSERT(dp != NULL);

			val = dtrace_dif_emulate(dp, &amp;mstate, vstate, state);

			<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_ERROR)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">switch</span> (act-&gt;dta_kind) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_SPECULATE</span>: {
				dtrace_rechdr_t *dtrh = NULL;

				ASSERT(buf == &amp;state-&gt;dts_buffer[cpuid]);
				buf = dtrace_speculation_buffer(state,
				    cpuid, val);

				<span class="enscript-keyword">if</span> (buf == NULL) {
					*flags |= CPU_DTRACE_DROP;
					<span class="enscript-keyword">continue</span>;
				}

				offs = dtrace_buffer_reserve(buf,
				    ecb-&gt;dte_needed, ecb-&gt;dte_alignment,
				    state, NULL);

				<span class="enscript-keyword">if</span> (offs &lt; 0) {
					*flags |= CPU_DTRACE_DROP;
					<span class="enscript-keyword">continue</span>;
				}

				tomax = buf-&gt;dtb_tomax;
				ASSERT(tomax != NULL);

				<span class="enscript-keyword">if</span> (ecb-&gt;dte_size != 0)
					<span class="enscript-keyword">continue</span>;

				ASSERT(ecb-&gt;dte_size &gt;= <span class="enscript-keyword">sizeof</span>(dtrace_rechdr_t));
				dtrh = ((<span class="enscript-type">void</span> *)(tomax + offs));
				dtrh-&gt;dtrh_epid = ecb-&gt;dte_epid;

				<span class="enscript-comment">/*
				 * When the speculation is committed, all of
				 * the records in the speculative buffer will
				 * have their timestamps set to the commit
				 * time.  Until then, it is set to a sentinel
				 * value, for debugability.
				 */</span>
				DTRACE_RECORD_STORE_TIMESTAMP(dtrh, UINT64_MAX);

 				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_CHILL</span>:
				<span class="enscript-keyword">if</span> (dtrace_priv_kernel_destructive(state))
					dtrace_action_chill(&amp;mstate, val);
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_RAISE</span>:
				<span class="enscript-keyword">if</span> (dtrace_priv_proc_destructive(state))
					dtrace_action_raise(val);
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_PIDRESUME</span>:   <span class="enscript-comment">/* __APPLE__ */</span>
				<span class="enscript-keyword">if</span> (dtrace_priv_proc_destructive(state))
					dtrace_action_pidresume(val);
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_COMMIT</span>:
				ASSERT(!committed);

				<span class="enscript-comment">/*
				 * We need to commit our buffer state.
				 */</span>
				<span class="enscript-keyword">if</span> (ecb-&gt;dte_size)
					buf-&gt;dtb_offset = offs + ecb-&gt;dte_size;
				buf = &amp;state-&gt;dts_buffer[cpuid];
				dtrace_speculation_commit(state, cpuid, val);
				committed = 1;
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_DISCARD</span>:
				dtrace_speculation_discard(state, cpuid, val);
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_DIFEXPR</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_LIBACT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_PRINTF</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_PRINTA</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_SYSTEM</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_FREOPEN</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_APPLEBINARY</span>:   <span class="enscript-comment">/* __APPLE__ */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_TRACEMEM</span>:
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_TRACEMEM_DYNSIZE</span>:
				tracememsize = val;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_SYM</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_MOD</span>:
				<span class="enscript-keyword">if</span> (!dtrace_priv_kernel(state))
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_USYM</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_UMOD</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_UADDR</span>: {
				<span class="enscript-keyword">if</span> (!dtrace_priv_proc(state))
					<span class="enscript-keyword">continue</span>;

				DTRACE_STORE(uint64_t, tomax,
				    valoffs, (uint64_t)dtrace_proc_selfpid());
				DTRACE_STORE(uint64_t, tomax,
				    valoffs + <span class="enscript-keyword">sizeof</span> (uint64_t), val);

				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_EXIT</span>: {
				<span class="enscript-comment">/*
				 * For the exit action, we are going to attempt
				 * to atomically set our activity to be
				 * draining.  If this fails (either because
				 * another CPU has beat us to the exit action,
				 * or because our current activity is something
				 * other than ACTIVE or WARMUP), we will
				 * continue.  This assures that the exit action
				 * can be successfully recorded at most once
				 * when we're in the ACTIVE state.  If we're
				 * encountering the exit() action while in
				 * COOLDOWN, however, we want to honor the new
				 * status code.  (We know that we're the only
				 * thread in COOLDOWN, so there is no race.)
				 */</span>
				<span class="enscript-type">void</span> *activity = &amp;state-&gt;dts_activity;
				dtrace_activity_t current = state-&gt;dts_activity;

				<span class="enscript-keyword">if</span> (current == DTRACE_ACTIVITY_COOLDOWN)
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">if</span> (current != DTRACE_ACTIVITY_WARMUP)
					current = DTRACE_ACTIVITY_ACTIVE;

				<span class="enscript-keyword">if</span> (dtrace_cas32(activity, current,
				    DTRACE_ACTIVITY_DRAINING) != current) {
					*flags |= CPU_DTRACE_DROP;
					<span class="enscript-keyword">continue</span>;
				}

				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-reference">default</span>:
				ASSERT(0);
			}

			<span class="enscript-keyword">if</span> (dp-&gt;dtdo_rtype.dtdt_flags &amp; (DIF_TF_BYREF | DIF_TF_BYUREF)) {
				uintptr_t end = valoffs + size;

				<span class="enscript-keyword">if</span> (tracememsize != 0 &amp;&amp;
                                    valoffs + tracememsize &lt; end)
				{
                                        end = valoffs + tracememsize;
                                        tracememsize = 0;
                                }

				<span class="enscript-keyword">if</span> (dp-&gt;dtdo_rtype.dtdt_flags &amp; DIF_TF_BYREF &amp;&amp;
				    !dtrace_vcanload((<span class="enscript-type">void</span> *)(uintptr_t)val,
				                     &amp;dp-&gt;dtdo_rtype, &amp;mstate, vstate))
				{
					<span class="enscript-keyword">continue</span>;
				}

				dtrace_store_by_ref(dp, tomax, size, &amp;valoffs,
				    &amp;val, end, act-&gt;dta_intuple,
				    dp-&gt;dtdo_rtype.dtdt_flags &amp; DIF_TF_BYREF ?
				    <span class="enscript-reference">DIF_TF_BYREF</span>: DIF_TF_BYUREF);

				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">switch</span> (size) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">sizeof</span> (uint8_t):
				DTRACE_STORE(uint8_t, tomax, valoffs, val);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">sizeof</span> (uint16_t):
				DTRACE_STORE(uint16_t, tomax, valoffs, val);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">sizeof</span> (uint32_t):
				DTRACE_STORE(uint32_t, tomax, valoffs, val);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">sizeof</span> (uint64_t):
				DTRACE_STORE(uint64_t, tomax, valoffs, val);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-comment">/*
				 * Any other size should have been returned by
				 * reference, not by value.
				 */</span>
				ASSERT(0);
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_DROP)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_FAULT) {
			<span class="enscript-type">int</span> ndx;
			dtrace_action_t *err;

			buf-&gt;dtb_errors++;

			<span class="enscript-keyword">if</span> (probe-&gt;dtpr_id == dtrace_probeid_error) {
				<span class="enscript-comment">/*
				 * There's nothing we can do -- we had an
				 * error on the error probe.  We bump an
				 * error counter to at least indicate that
				 * this condition happened.
				 */</span>
				dtrace_error(&amp;state-&gt;dts_dblerrors);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">if</span> (vtime) {
				<span class="enscript-comment">/*
				 * Before recursing on dtrace_probe(), we
				 * need to explicitly clear out our start
				 * time to prevent it from being accumulated
				 * into t_dtrace_vtime.
				 */</span>

				<span class="enscript-comment">/*				   
				 * Darwin sets the sign bit on t_dtrace_tracing
				 * to suspend accumulation to it.
				 */</span>
				dtrace_set_thread_tracing(current_thread(), 
				    (1ULL&lt;&lt;63) | dtrace_get_thread_tracing(current_thread()));

			}

			<span class="enscript-comment">/*
			 * Iterate over the actions to figure out which action
			 * we were processing when we experienced the error.
			 * Note that act points _past_ the faulting action; if
			 * act is ecb-&gt;dte_action, the fault was in the
			 * predicate, if it's ecb-&gt;dte_action-&gt;dta_next it's
			 * in action #1, and so on.
			 */</span>
			<span class="enscript-keyword">for</span> (err = ecb-&gt;dte_action, ndx = 0;
			    err != act; err = err-&gt;dta_next, ndx++)
				<span class="enscript-keyword">continue</span>;

			dtrace_probe_error(state, ecb-&gt;dte_epid, ndx,
			    (mstate.dtms_present &amp; DTRACE_MSTATE_FLTOFFS) ?
			    mstate.dtms_fltoffs : -1, DTRACE_FLAGS2FLT(*flags),
			    cpu_core[cpuid].cpuc_dtrace_illval);

			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (!committed)
			buf-&gt;dtb_offset = offs + ecb-&gt;dte_size;
	}

	<span class="enscript-comment">/* FIXME: On Darwin the time spent leaving DTrace from this point to the rti is attributed
	   to the current thread. Instead it should accrue to DTrace. */</span>
	<span class="enscript-keyword">if</span> (vtime) {
		thread_t thread = current_thread();
		int64_t t = dtrace_get_thread_tracing(thread);
		
		<span class="enscript-keyword">if</span> (t &gt;= 0) { 
			<span class="enscript-comment">/* Usual case, accumulate time spent here into t_dtrace_tracing */</span>
			dtrace_set_thread_tracing(thread, t + (dtrace_gethrtime() - now));
		} <span class="enscript-keyword">else</span> { 
			<span class="enscript-comment">/* Return from error recursion. No accumulation, just clear the sign bit on t_dtrace_tracing. */</span>
			dtrace_set_thread_tracing(thread, (~(1ULL&lt;&lt;63)) &amp; t); 
		}
	}

	dtrace_interrupt_enable(cookie);
}

<span class="enscript-comment">/*
 * APPLE NOTE:  Don't allow a thread to re-enter dtrace_probe().
 * This could occur if a probe is encountered on some function in the
 * transitive closure of the call to dtrace_probe().
 * Solaris has some strong guarantees that this won't happen.
 * The Darwin implementation is not so mature as to make those guarantees.
 * Hence, the introduction of __dtrace_probe() on xnu.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_probe</span>(dtrace_id_t id, uint64_t arg0, uint64_t arg1,
    uint64_t arg2, uint64_t arg3, uint64_t arg4)
{
	thread_t thread = current_thread();
	disable_preemption();
	<span class="enscript-keyword">if</span> (id == dtrace_probeid_error) {
		__dtrace_probe(id, arg0, arg1, arg2, arg3, arg4);
		dtrace_getipl(); <span class="enscript-comment">/* Defeat tail-call optimization of __dtrace_probe() */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!dtrace_get_thread_reentering(thread)) {
		dtrace_set_thread_reentering(thread, TRUE);
		__dtrace_probe(id, arg0, arg1, arg2, arg3, arg4);
		dtrace_set_thread_reentering(thread, FALSE);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">else</span> __dtrace_probe(dtrace_probeid_error, 0, id, 1, -1, DTRACEFLT_UNKNOWN);
#<span class="enscript-reference">endif</span>
	enable_preemption();
}

<span class="enscript-comment">/*
 * DTrace Probe Hashing Functions
 *
 * The functions in this section (and indeed, the functions in remaining
 * sections) are not _called_ from probe context.  (Any exceptions to this are
 * marked with a &quot;Note:&quot;.)  Rather, they are called from elsewhere in the
 * DTrace framework to look-up probes in, add probes to and remove probes from
 * the DTrace probe hashes.  (Each probe is hashed by each element of the
 * probe tuple -- allowing for fast lookups, regardless of what was
 * specified.)
 */</span>
<span class="enscript-type">static</span> uint_t
<span class="enscript-function-name">dtrace_hash_str</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *p)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> g;
	uint_t hval = 0;

	<span class="enscript-keyword">while</span> (*p) {
		hval = (hval &lt;&lt; 4) + *p++;
		<span class="enscript-keyword">if</span> ((g = (hval &amp; 0xf0000000)) != 0)
			hval ^= g &gt;&gt; 24;
		hval &amp;= ~g;
	}
	<span class="enscript-keyword">return</span> (hval);
}

<span class="enscript-type">static</span> dtrace_hash_t *
<span class="enscript-function-name">dtrace_hash_create</span>(uintptr_t stroffs, uintptr_t nextoffs, uintptr_t prevoffs)
{
	dtrace_hash_t *hash = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_hash_t), KM_SLEEP);

	hash-&gt;dth_stroffs = stroffs;
	hash-&gt;dth_nextoffs = nextoffs;
	hash-&gt;dth_prevoffs = prevoffs;

	hash-&gt;dth_size = 1;
	hash-&gt;dth_mask = hash-&gt;dth_size - 1;

	hash-&gt;dth_tab = kmem_zalloc(hash-&gt;dth_size *
	    <span class="enscript-keyword">sizeof</span> (dtrace_hashbucket_t *), KM_SLEEP);

	<span class="enscript-keyword">return</span> (hash);
}

<span class="enscript-comment">/*
 * APPLE NOTE: dtrace_hash_destroy is not used.
 * It is called by dtrace_detach which is not
 * currently implemented.  Revisit someday.
 */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_hash_destroy</span>(dtrace_hash_t *hash)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; hash-&gt;dth_size; i++)
		ASSERT(hash-&gt;dth_tab[i] == NULL);
#<span class="enscript-reference">endif</span>

	kmem_free(hash-&gt;dth_tab,
	    hash-&gt;dth_size * <span class="enscript-keyword">sizeof</span> (dtrace_hashbucket_t *));
	kmem_free(hash, <span class="enscript-keyword">sizeof</span> (dtrace_hash_t));
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_hash_resize</span>(dtrace_hash_t *hash)
{
	<span class="enscript-type">int</span> size = hash-&gt;dth_size, i, ndx;
	<span class="enscript-type">int</span> new_size = hash-&gt;dth_size &lt;&lt; 1;
	<span class="enscript-type">int</span> new_mask = new_size - 1;
	dtrace_hashbucket_t **new_tab, *bucket, *next;

	ASSERT((new_size &amp; new_mask) == 0);

	new_tab = kmem_zalloc(new_size * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *), KM_SLEEP);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; size; i++) {
		<span class="enscript-keyword">for</span> (bucket = hash-&gt;dth_tab[i]; bucket != NULL; bucket = next) {
			dtrace_probe_t *probe = bucket-&gt;dthb_chain;

			ASSERT(probe != NULL);
			ndx = DTRACE_HASHSTR(hash, probe) &amp; new_mask;

			next = bucket-&gt;dthb_next;
			bucket-&gt;dthb_next = new_tab[ndx];
			new_tab[ndx] = bucket;
		}
	}

	kmem_free(hash-&gt;dth_tab, hash-&gt;dth_size * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *));
	hash-&gt;dth_tab = new_tab;
	hash-&gt;dth_size = new_size;
	hash-&gt;dth_mask = new_mask;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_hash_add</span>(dtrace_hash_t *hash, dtrace_probe_t *new)
{
	<span class="enscript-type">int</span> hashval = DTRACE_HASHSTR(hash, new);
	<span class="enscript-type">int</span> ndx = hashval &amp; hash-&gt;dth_mask;
	dtrace_hashbucket_t *bucket = hash-&gt;dth_tab[ndx];
	dtrace_probe_t **nextp, **prevp;

	<span class="enscript-keyword">for</span> (; bucket != NULL; bucket = bucket-&gt;dthb_next) {
		<span class="enscript-keyword">if</span> (DTRACE_HASHEQ(hash, bucket-&gt;dthb_chain, new))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">add</span>;
	}

	<span class="enscript-keyword">if</span> ((hash-&gt;dth_nbuckets &gt;&gt; 1) &gt; hash-&gt;dth_size) {
		dtrace_hash_resize(hash);
		dtrace_hash_add(hash, new);
		<span class="enscript-keyword">return</span>;
	}

	bucket = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_hashbucket_t), KM_SLEEP);
	bucket-&gt;dthb_next = hash-&gt;dth_tab[ndx];
	hash-&gt;dth_tab[ndx] = bucket;
	hash-&gt;dth_nbuckets++;

<span class="enscript-reference">add</span>:
	nextp = DTRACE_HASHNEXT(hash, new);
	ASSERT(*nextp == NULL &amp;&amp; *(DTRACE_HASHPREV(hash, new)) == NULL);
	*nextp = bucket-&gt;dthb_chain;

	<span class="enscript-keyword">if</span> (bucket-&gt;dthb_chain != NULL) {
		prevp = DTRACE_HASHPREV(hash, bucket-&gt;dthb_chain);
		ASSERT(*prevp == NULL);
		*prevp = new;
	}

	bucket-&gt;dthb_chain = new;
	bucket-&gt;dthb_len++;
}

<span class="enscript-type">static</span> dtrace_probe_t *
<span class="enscript-function-name">dtrace_hash_lookup</span>(dtrace_hash_t *hash, dtrace_probe_t *template)
{
	<span class="enscript-type">int</span> hashval = DTRACE_HASHSTR(hash, template);
	<span class="enscript-type">int</span> ndx = hashval &amp; hash-&gt;dth_mask;
	dtrace_hashbucket_t *bucket = hash-&gt;dth_tab[ndx];

	<span class="enscript-keyword">for</span> (; bucket != NULL; bucket = bucket-&gt;dthb_next) {
		<span class="enscript-keyword">if</span> (DTRACE_HASHEQ(hash, bucket-&gt;dthb_chain, template))
			<span class="enscript-keyword">return</span> (bucket-&gt;dthb_chain);
	}

	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_hash_collisions</span>(dtrace_hash_t *hash, dtrace_probe_t *template)
{
	<span class="enscript-type">int</span> hashval = DTRACE_HASHSTR(hash, template);
	<span class="enscript-type">int</span> ndx = hashval &amp; hash-&gt;dth_mask;
	dtrace_hashbucket_t *bucket = hash-&gt;dth_tab[ndx];

	<span class="enscript-keyword">for</span> (; bucket != NULL; bucket = bucket-&gt;dthb_next) {
		<span class="enscript-keyword">if</span> (DTRACE_HASHEQ(hash, bucket-&gt;dthb_chain, template))
			<span class="enscript-keyword">return</span> (bucket-&gt;dthb_len);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_hash_remove</span>(dtrace_hash_t *hash, dtrace_probe_t *probe)
{
	<span class="enscript-type">int</span> ndx = DTRACE_HASHSTR(hash, probe) &amp; hash-&gt;dth_mask;
	dtrace_hashbucket_t *bucket = hash-&gt;dth_tab[ndx];

	dtrace_probe_t **prevp = DTRACE_HASHPREV(hash, probe);
	dtrace_probe_t **nextp = DTRACE_HASHNEXT(hash, probe);

	<span class="enscript-comment">/*
	 * Find the bucket that we're removing this probe from.
	 */</span>
	<span class="enscript-keyword">for</span> (; bucket != NULL; bucket = bucket-&gt;dthb_next) {
		<span class="enscript-keyword">if</span> (DTRACE_HASHEQ(hash, bucket-&gt;dthb_chain, probe))
			<span class="enscript-keyword">break</span>;
	}

	ASSERT(bucket != NULL);

	<span class="enscript-keyword">if</span> (*prevp == NULL) {
		<span class="enscript-keyword">if</span> (*nextp == NULL) {
			<span class="enscript-comment">/*
			 * The removed probe was the only probe on this
			 * bucket; we need to remove the bucket.
			 */</span>
			dtrace_hashbucket_t *b = hash-&gt;dth_tab[ndx];

			ASSERT(bucket-&gt;dthb_chain == probe);
			ASSERT(b != NULL);

			<span class="enscript-keyword">if</span> (b == bucket) {
				hash-&gt;dth_tab[ndx] = bucket-&gt;dthb_next;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">while</span> (b-&gt;dthb_next != bucket)
					b = b-&gt;dthb_next;
				b-&gt;dthb_next = bucket-&gt;dthb_next;
			}

			ASSERT(hash-&gt;dth_nbuckets &gt; 0);
			hash-&gt;dth_nbuckets--;
			kmem_free(bucket, <span class="enscript-keyword">sizeof</span> (dtrace_hashbucket_t));
			<span class="enscript-keyword">return</span>;
		}

		bucket-&gt;dthb_chain = *nextp;
	} <span class="enscript-keyword">else</span> {
		*(DTRACE_HASHNEXT(hash, *prevp)) = *nextp;
	}

	<span class="enscript-keyword">if</span> (*nextp != NULL)
		*(DTRACE_HASHPREV(hash, *nextp)) = *prevp;
}

<span class="enscript-comment">/*
 * DTrace Utility Functions
 *
 * These are random utility functions that are _not_ called from probe context.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_badattr</span>(<span class="enscript-type">const</span> dtrace_attribute_t *a)
{
	<span class="enscript-keyword">return</span> (a-&gt;dtat_name &gt; DTRACE_STABILITY_MAX ||
	    a-&gt;dtat_data &gt; DTRACE_STABILITY_MAX ||
	    a-&gt;dtat_class &gt; DTRACE_CLASS_MAX);
}

<span class="enscript-comment">/*
 * Return a duplicate copy of a string.  If the specified string is NULL,
 * this function returns a zero-length string.
 * APPLE NOTE: Darwin employs size bounded string operation.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">dtrace_strdup</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *str)
{
	size_t bufsize = (str != NULL ? strlen(str) : 0) + 1;
	<span class="enscript-type">char</span> *new = kmem_zalloc(bufsize, KM_SLEEP);

	<span class="enscript-keyword">if</span> (str != NULL)
		(<span class="enscript-type">void</span>) strlcpy(new, str, bufsize);

	<span class="enscript-keyword">return</span> (new);
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DTRACE_ISALPHA</span>(c)	\
	(((c) &gt;= <span class="enscript-string">'a'</span> &amp;&amp; (c) &lt;= <span class="enscript-string">'z'</span>) || ((c) &gt;= <span class="enscript-string">'A'</span> &amp;&amp; (c) &lt;= <span class="enscript-string">'Z'</span>))

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_badname</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s)
{
	<span class="enscript-type">char</span> c;

	<span class="enscript-keyword">if</span> (s == NULL || (c = *s++) == <span class="enscript-string">'\0'</span>)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (!DTRACE_ISALPHA(c) &amp;&amp; c != <span class="enscript-string">'-'</span> &amp;&amp; c != <span class="enscript-string">'_'</span> &amp;&amp; c != <span class="enscript-string">'.'</span>)
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-keyword">while</span> ((c = *s++) != <span class="enscript-string">'\0'</span>) {
		<span class="enscript-keyword">if</span> (!DTRACE_ISALPHA(c) &amp;&amp; (c &lt; <span class="enscript-string">'0'</span> || c &gt; <span class="enscript-string">'9'</span>) &amp;&amp;
		    c != <span class="enscript-string">'-'</span> &amp;&amp; c != <span class="enscript-string">'_'</span> &amp;&amp; c != <span class="enscript-string">'.'</span> &amp;&amp; c != <span class="enscript-string">'`'</span>)
			<span class="enscript-keyword">return</span> (1);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_cred2priv</span>(cred_t *cr, uint32_t *privp, uid_t *uidp, zoneid_t *zoneidp)
{
	uint32_t priv;

	<span class="enscript-keyword">if</span> (cr == NULL || PRIV_POLICY_ONLY(cr, PRIV_ALL, B_FALSE)) {
		<span class="enscript-comment">/*
		 * For DTRACE_PRIV_ALL, the uid and zoneid don't matter.
		 */</span>
		priv = DTRACE_PRIV_ALL;
	} <span class="enscript-keyword">else</span> {
		*uidp = crgetuid(cr);
		*zoneidp = crgetzoneid(cr);

		priv = 0;
		<span class="enscript-keyword">if</span> (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_KERNEL, B_FALSE))
			priv |= DTRACE_PRIV_KERNEL | DTRACE_PRIV_USER;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_USER, B_FALSE))
			priv |= DTRACE_PRIV_USER;
		<span class="enscript-keyword">if</span> (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_PROC, B_FALSE))
			priv |= DTRACE_PRIV_PROC;
		<span class="enscript-keyword">if</span> (PRIV_POLICY_ONLY(cr, PRIV_PROC_OWNER, B_FALSE))
			priv |= DTRACE_PRIV_OWNER;
		<span class="enscript-keyword">if</span> (PRIV_POLICY_ONLY(cr, PRIV_PROC_ZONE, B_FALSE))
			priv |= DTRACE_PRIV_ZONEOWNER;
	}

	*privp = priv;
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DTRACE_ERRDEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_errdebug</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *str)
{
	<span class="enscript-type">int</span> hval = dtrace_hash_str(str) % DTRACE_ERRHASHSZ;
	<span class="enscript-type">int</span> occupied = 0;

	lck_mtx_lock(&amp;dtrace_errlock);
	dtrace_errlast = str;
	dtrace_errthread = (kthread_t *)current_thread();

	<span class="enscript-keyword">while</span> (occupied++ &lt; DTRACE_ERRHASHSZ) {
		<span class="enscript-keyword">if</span> (dtrace_errhash[hval].dter_msg == str) {
			dtrace_errhash[hval].dter_count++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-keyword">if</span> (dtrace_errhash[hval].dter_msg != NULL) {
			hval = (hval + 1) % DTRACE_ERRHASHSZ;
			<span class="enscript-keyword">continue</span>;
		}

		dtrace_errhash[hval].dter_msg = str;
		dtrace_errhash[hval].dter_count = 1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	panic(<span class="enscript-string">&quot;dtrace: undersized error hash&quot;</span>);
<span class="enscript-reference">out</span>:
	lck_mtx_unlock(&amp;dtrace_errlock);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * DTrace Matching Functions
 *
 * These functions are used to match groups of probes, given some elements of
 * a probe tuple, or some globbed expressions for elements of a probe tuple.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_match_priv</span>(<span class="enscript-type">const</span> dtrace_probe_t *prp, uint32_t priv, uid_t uid,
    zoneid_t zoneid)
{
	<span class="enscript-keyword">if</span> (priv != DTRACE_PRIV_ALL) {
		uint32_t ppriv = prp-&gt;dtpr_provider-&gt;dtpv_priv.dtpp_flags;
		uint32_t match = priv &amp; ppriv;

		<span class="enscript-comment">/*
		 * No PRIV_DTRACE_* privileges...
		 */</span>
		<span class="enscript-keyword">if</span> ((priv &amp; (DTRACE_PRIV_PROC | DTRACE_PRIV_USER |
		    DTRACE_PRIV_KERNEL)) == 0)
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-comment">/*
		 * No matching bits, but there were bits to match...
		 */</span>
		<span class="enscript-keyword">if</span> (match == 0 &amp;&amp; ppriv != 0)
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-comment">/*
		 * Need to have permissions to the process, but don't...
		 */</span>
		<span class="enscript-keyword">if</span> (((ppriv &amp; ~match) &amp; DTRACE_PRIV_OWNER) != 0 &amp;&amp;
		    uid != prp-&gt;dtpr_provider-&gt;dtpv_priv.dtpp_uid) {
			<span class="enscript-keyword">return</span> (0);
		}

		<span class="enscript-comment">/*
		 * Need to be in the same zone unless we possess the
		 * privilege to examine all zones.
		 */</span>
		<span class="enscript-keyword">if</span> (((ppriv &amp; ~match) &amp; DTRACE_PRIV_ZONEOWNER) != 0 &amp;&amp;
		    zoneid != prp-&gt;dtpr_provider-&gt;dtpv_priv.dtpp_zoneid) {
			<span class="enscript-keyword">return</span> (0);
		}
	}

	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * dtrace_match_probe compares a dtrace_probe_t to a pre-compiled key, which
 * consists of input pattern strings and an ops-vector to evaluate them.
 * This function returns &gt;0 for match, 0 for no match, and &lt;0 for error.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_match_probe</span>(<span class="enscript-type">const</span> dtrace_probe_t *prp, <span class="enscript-type">const</span> dtrace_probekey_t *pkp,
    uint32_t priv, uid_t uid, zoneid_t zoneid)
{
	dtrace_provider_t *pvp = prp-&gt;dtpr_provider;
	<span class="enscript-type">int</span> rv;

	<span class="enscript-keyword">if</span> (pvp-&gt;dtpv_defunct)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> ((rv = pkp-&gt;dtpk_pmatch(pvp-&gt;dtpv_name, pkp-&gt;dtpk_prov, 0)) &lt;= 0)
		<span class="enscript-keyword">return</span> (rv);

	<span class="enscript-keyword">if</span> ((rv = pkp-&gt;dtpk_mmatch(prp-&gt;dtpr_mod, pkp-&gt;dtpk_mod, 0)) &lt;= 0)
		<span class="enscript-keyword">return</span> (rv);

	<span class="enscript-keyword">if</span> ((rv = pkp-&gt;dtpk_fmatch(prp-&gt;dtpr_func, pkp-&gt;dtpk_func, 0)) &lt;= 0)
		<span class="enscript-keyword">return</span> (rv);

	<span class="enscript-keyword">if</span> ((rv = pkp-&gt;dtpk_nmatch(prp-&gt;dtpr_name, pkp-&gt;dtpk_name, 0)) &lt;= 0)
		<span class="enscript-keyword">return</span> (rv);

	<span class="enscript-keyword">if</span> (dtrace_match_priv(prp, priv, uid, zoneid) == 0)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">return</span> (rv);
}

<span class="enscript-comment">/*
 * dtrace_match_glob() is a safe kernel implementation of the gmatch(3GEN)
 * interface for matching a glob pattern 'p' to an input string 's'.  Unlike
 * libc's version, the kernel version only applies to 8-bit ASCII strings.
 * In addition, all of the recursion cases except for '*' matching have been
 * unwound.  For '*', we still implement recursive evaluation, but a depth
 * counter is maintained and matching is aborted if we recurse too deep.
 * The function returns 0 if no match, &gt;0 if match, and &lt;0 if recursion error.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_match_glob</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *p, <span class="enscript-type">int</span> depth)
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *olds;
	<span class="enscript-type">char</span> s1, c;
	<span class="enscript-type">int</span> gs;

	<span class="enscript-keyword">if</span> (depth &gt; DTRACE_PROBEKEY_MAXDEPTH)
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-keyword">if</span> (s == NULL)
		s = <span class="enscript-string">&quot;&quot;</span>; <span class="enscript-comment">/* treat NULL as empty string */</span>

<span class="enscript-reference">top</span>:
	olds = s;
	s1 = *s++;

	<span class="enscript-keyword">if</span> (p == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> ((c = *p++) == <span class="enscript-string">'\0'</span>)
		<span class="enscript-keyword">return</span> (s1 == <span class="enscript-string">'\0'</span>);

	<span class="enscript-keyword">switch</span> (c) {
	<span class="enscript-keyword">case</span> <span class="enscript-string">'['</span>: {
		<span class="enscript-type">int</span> ok = 0, notflag = 0;
		<span class="enscript-type">char</span> lc = <span class="enscript-string">'\0'</span>;

		<span class="enscript-keyword">if</span> (s1 == <span class="enscript-string">'\0'</span>)
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">if</span> (*p == <span class="enscript-string">'!'</span>) {
			notflag = 1;
			p++;
		}

		<span class="enscript-keyword">if</span> ((c = *p++) == <span class="enscript-string">'\0'</span>)
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'-'</span> &amp;&amp; lc != <span class="enscript-string">'\0'</span> &amp;&amp; *p != <span class="enscript-string">']'</span>) {
				<span class="enscript-keyword">if</span> ((c = *p++) == <span class="enscript-string">'\0'</span>)
					<span class="enscript-keyword">return</span> (0);
				<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\\'</span> &amp;&amp; (c = *p++) == <span class="enscript-string">'\0'</span>)
					<span class="enscript-keyword">return</span> (0);

				<span class="enscript-keyword">if</span> (notflag) {
					<span class="enscript-keyword">if</span> (s1 &lt; lc || s1 &gt; c)
						ok++;
					<span class="enscript-keyword">else</span>
						<span class="enscript-keyword">return</span> (0);
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lc &lt;= s1 &amp;&amp; s1 &lt;= c)
					ok++;

			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\\'</span> &amp;&amp; (c = *p++) == <span class="enscript-string">'\0'</span>)
				<span class="enscript-keyword">return</span> (0);

			lc = c; <span class="enscript-comment">/* save left-hand 'c' for next iteration */</span>

			<span class="enscript-keyword">if</span> (notflag) {
				<span class="enscript-keyword">if</span> (s1 != c)
					ok++;
				<span class="enscript-keyword">else</span>
					<span class="enscript-keyword">return</span> (0);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (s1 == c)
				ok++;

			<span class="enscript-keyword">if</span> ((c = *p++) == <span class="enscript-string">'\0'</span>)
				<span class="enscript-keyword">return</span> (0);

		} <span class="enscript-keyword">while</span> (c != <span class="enscript-string">']'</span>);

		<span class="enscript-keyword">if</span> (ok)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">top</span>;

		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-string">'\\'</span>:
		<span class="enscript-keyword">if</span> ((c = *p++) == <span class="enscript-string">'\0'</span>)
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-comment">/*FALLTHRU*/</span>

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">if</span> (c != s1)
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-comment">/*FALLTHRU*/</span>

	<span class="enscript-keyword">case</span> <span class="enscript-string">'?'</span>:
		<span class="enscript-keyword">if</span> (s1 != <span class="enscript-string">'\0'</span>)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">top</span>;
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">case</span> <span class="enscript-string">'*'</span>:
		<span class="enscript-keyword">while</span> (*p == <span class="enscript-string">'*'</span>)
			p++; <span class="enscript-comment">/* consecutive *'s are identical to a single one */</span>

		<span class="enscript-keyword">if</span> (*p == <span class="enscript-string">'\0'</span>)
			<span class="enscript-keyword">return</span> (1);

		<span class="enscript-keyword">for</span> (s = olds; *s != <span class="enscript-string">'\0'</span>; s++) {
			<span class="enscript-keyword">if</span> ((gs = dtrace_match_glob(s, p, depth + 1)) != 0)
				<span class="enscript-keyword">return</span> (gs);
		}

		<span class="enscript-keyword">return</span> (0);
	}
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_match_string</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *p, <span class="enscript-type">int</span> depth)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">depth</span>) <span class="enscript-comment">/* __APPLE__ */</span>

	<span class="enscript-comment">/* APPLE NOTE: Darwin employs size bounded string operation. */</span>
	<span class="enscript-keyword">return</span> (s != NULL &amp;&amp; strncmp(s, p, strlen(s) + 1) == 0);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_match_nul</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *p, <span class="enscript-type">int</span> depth)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">s</span>, <span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">depth</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	<span class="enscript-keyword">return</span> (1); <span class="enscript-comment">/* always match the empty pattern */</span>
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_match_nonzero</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *p, <span class="enscript-type">int</span> depth)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">depth</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	<span class="enscript-keyword">return</span> (s != NULL &amp;&amp; s[0] != <span class="enscript-string">'\0'</span>);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_match</span>(<span class="enscript-type">const</span> dtrace_probekey_t *pkp, uint32_t priv, uid_t uid,
    zoneid_t zoneid, <span class="enscript-type">int</span> (*matched)(dtrace_probe_t *, <span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *arg)
{
	dtrace_probe_t template, *probe;
	dtrace_hash_t *hash = NULL;
	<span class="enscript-type">int</span> len, rc, best = INT_MAX, nmatched = 0;
	dtrace_id_t i;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/*
	 * If the probe ID is specified in the key, just lookup by ID and
	 * invoke the match callback once if a matching probe is found.
	 */</span>
	<span class="enscript-keyword">if</span> (pkp-&gt;dtpk_id != DTRACE_IDNONE) {
		<span class="enscript-keyword">if</span> ((probe = dtrace_probe_lookup_id(pkp-&gt;dtpk_id)) != NULL &amp;&amp;
		    dtrace_match_probe(probe, pkp, priv, uid, zoneid) &gt; 0) {
		        <span class="enscript-keyword">if</span> ((*matched)(probe, arg) == DTRACE_MATCH_FAIL)
                               <span class="enscript-keyword">return</span> (DTRACE_MATCH_FAIL);
			nmatched++;
		}
		<span class="enscript-keyword">return</span> (nmatched);
	}

	template.dtpr_mod =  (<span class="enscript-type">char</span> *)(uintptr_t)pkp-&gt;dtpk_mod;
	template.dtpr_func = (<span class="enscript-type">char</span> *)(uintptr_t)pkp-&gt;dtpk_func;
	template.dtpr_name = (<span class="enscript-type">char</span> *)(uintptr_t)pkp-&gt;dtpk_name;

	<span class="enscript-comment">/*
	 * We want to find the most distinct of the module name, function
	 * name, and name.  So for each one that is not a glob pattern or
	 * empty string, we perform a lookup in the corresponding hash and
	 * use the hash table with the fewest collisions to do our search.
	 */</span>
	<span class="enscript-keyword">if</span> (pkp-&gt;dtpk_mmatch == &amp;dtrace_match_string &amp;&amp;
	    (len = dtrace_hash_collisions(dtrace_bymod, &amp;template)) &lt; best) {
		best = len;
		hash = dtrace_bymod;
	}

	<span class="enscript-keyword">if</span> (pkp-&gt;dtpk_fmatch == &amp;dtrace_match_string &amp;&amp;
	    (len = dtrace_hash_collisions(dtrace_byfunc, &amp;template)) &lt; best) {
		best = len;
		hash = dtrace_byfunc;
	}

	<span class="enscript-keyword">if</span> (pkp-&gt;dtpk_nmatch == &amp;dtrace_match_string &amp;&amp;
	    (len = dtrace_hash_collisions(dtrace_byname, &amp;template)) &lt; best) {
		best = len;
		hash = dtrace_byname;
	}

	<span class="enscript-comment">/*
	 * If we did not select a hash table, iterate over every probe and
	 * invoke our callback for each one that matches our input probe key.
	 */</span>
	<span class="enscript-keyword">if</span> (hash == NULL) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; (dtrace_id_t)dtrace_nprobes; i++) {
			<span class="enscript-keyword">if</span> ((probe = dtrace_probes[i]) == NULL ||
			    dtrace_match_probe(probe, pkp, priv, uid,
			    zoneid) &lt;= 0)
				<span class="enscript-keyword">continue</span>;

			nmatched++;

                       <span class="enscript-keyword">if</span> ((rc = (*matched)(probe, arg)) != DTRACE_MATCH_NEXT) {
			       <span class="enscript-keyword">if</span> (rc == DTRACE_MATCH_FAIL)
                                       <span class="enscript-keyword">return</span> (DTRACE_MATCH_FAIL);
			       <span class="enscript-keyword">break</span>;
                       }
		}

		<span class="enscript-keyword">return</span> (nmatched);
	}

	<span class="enscript-comment">/*
	 * If we selected a hash table, iterate over each probe of the same key
	 * name and invoke the callback for every probe that matches the other
	 * attributes of our input probe key.
	 */</span>
	<span class="enscript-keyword">for</span> (probe = dtrace_hash_lookup(hash, &amp;template); probe != NULL;
	    probe = *(DTRACE_HASHNEXT(hash, probe))) {

		<span class="enscript-keyword">if</span> (dtrace_match_probe(probe, pkp, priv, uid, zoneid) &lt;= 0)
			<span class="enscript-keyword">continue</span>;

		nmatched++;

		<span class="enscript-keyword">if</span> ((rc = (*matched)(probe, arg)) != DTRACE_MATCH_NEXT) {
		    <span class="enscript-keyword">if</span> (rc == DTRACE_MATCH_FAIL)
			<span class="enscript-keyword">return</span> (DTRACE_MATCH_FAIL);
		    <span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">return</span> (nmatched);
}

<span class="enscript-comment">/*
 * Return the function pointer dtrace_probecmp() should use to compare the
 * specified pattern with a string.  For NULL or empty patterns, we select
 * dtrace_match_nul().  For glob pattern strings, we use dtrace_match_glob().
 * For non-empty non-glob strings, we use dtrace_match_string().
 */</span>
<span class="enscript-type">static</span> dtrace_probekey_f *
<span class="enscript-function-name">dtrace_probekey_func</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *p)
{
	<span class="enscript-type">char</span> c;

	<span class="enscript-keyword">if</span> (p == NULL || *p == <span class="enscript-string">'\0'</span>)
		<span class="enscript-keyword">return</span> (&amp;dtrace_match_nul);

	<span class="enscript-keyword">while</span> ((c = *p++) != <span class="enscript-string">'\0'</span>) {
		<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'['</span> || c == <span class="enscript-string">'?'</span> || c == <span class="enscript-string">'*'</span> || c == <span class="enscript-string">'\\'</span>)
			<span class="enscript-keyword">return</span> (&amp;dtrace_match_glob);
	}

	<span class="enscript-keyword">return</span> (&amp;dtrace_match_string);
}

<span class="enscript-comment">/*
 * Build a probe comparison key for use with dtrace_match_probe() from the
 * given probe description.  By convention, a null key only matches anchored
 * probes: if each field is the empty string, reset dtpk_fmatch to
 * dtrace_match_nonzero().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_probekey</span>(<span class="enscript-type">const</span> dtrace_probedesc_t *pdp, dtrace_probekey_t *pkp)
{
	pkp-&gt;dtpk_prov = pdp-&gt;dtpd_provider;
	pkp-&gt;dtpk_pmatch = dtrace_probekey_func(pdp-&gt;dtpd_provider);

	pkp-&gt;dtpk_mod = pdp-&gt;dtpd_mod;
	pkp-&gt;dtpk_mmatch = dtrace_probekey_func(pdp-&gt;dtpd_mod);

	pkp-&gt;dtpk_func = pdp-&gt;dtpd_func;
	pkp-&gt;dtpk_fmatch = dtrace_probekey_func(pdp-&gt;dtpd_func);

	pkp-&gt;dtpk_name = pdp-&gt;dtpd_name;
	pkp-&gt;dtpk_nmatch = dtrace_probekey_func(pdp-&gt;dtpd_name);

	pkp-&gt;dtpk_id = pdp-&gt;dtpd_id;

	<span class="enscript-keyword">if</span> (pkp-&gt;dtpk_id == DTRACE_IDNONE &amp;&amp;
	    pkp-&gt;dtpk_pmatch == &amp;dtrace_match_nul &amp;&amp;
	    pkp-&gt;dtpk_mmatch == &amp;dtrace_match_nul &amp;&amp;
	    pkp-&gt;dtpk_fmatch == &amp;dtrace_match_nul &amp;&amp;
	    pkp-&gt;dtpk_nmatch == &amp;dtrace_match_nul)
		pkp-&gt;dtpk_fmatch = &amp;dtrace_match_nonzero;
}

<span class="enscript-comment">/*
 * DTrace Provider-to-Framework API Functions
 *
 * These functions implement much of the Provider-to-Framework API, as
 * described in &lt;sys/dtrace.h&gt;.  The parts of the API not in this section are
 * the functions in the API for probe management (found below), and
 * dtrace_probe() itself (found above).
 */</span>

<span class="enscript-comment">/*
 * Register the calling provider with the DTrace framework.  This should
 * generally be called by DTrace providers in their attach(9E) entry point.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_register</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">const</span> dtrace_pattr_t *pap, uint32_t priv,
    cred_t *cr, <span class="enscript-type">const</span> dtrace_pops_t *pops, <span class="enscript-type">void</span> *arg, dtrace_provider_id_t *idp)
{
	dtrace_provider_t *provider;

	<span class="enscript-keyword">if</span> (name == NULL || pap == NULL || pops == NULL || idp == NULL) {
		cmn_err(CE_WARN, <span class="enscript-string">&quot;failed to register provider '%s': invalid &quot;</span>
		    <span class="enscript-string">&quot;arguments&quot;</span>, name ? name : <span class="enscript-string">&quot;&lt;NULL&gt;&quot;</span>);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (name[0] == <span class="enscript-string">'\0'</span> || dtrace_badname(name)) {
		cmn_err(CE_WARN, <span class="enscript-string">&quot;failed to register provider '%s': invalid &quot;</span>
		    <span class="enscript-string">&quot;provider name&quot;</span>, name);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> ((pops-&gt;dtps_provide == NULL &amp;&amp; pops-&gt;dtps_provide_module == NULL) ||
	    pops-&gt;dtps_enable == NULL || pops-&gt;dtps_disable == NULL ||
	    pops-&gt;dtps_destroy == NULL ||
	    ((pops-&gt;dtps_resume == NULL) != (pops-&gt;dtps_suspend == NULL))) {
		cmn_err(CE_WARN, <span class="enscript-string">&quot;failed to register provider '%s': invalid &quot;</span>
		    <span class="enscript-string">&quot;provider ops&quot;</span>, name);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (dtrace_badattr(&amp;pap-&gt;dtpa_provider) ||
	    dtrace_badattr(&amp;pap-&gt;dtpa_mod) ||
	    dtrace_badattr(&amp;pap-&gt;dtpa_func) ||
	    dtrace_badattr(&amp;pap-&gt;dtpa_name) ||
	    dtrace_badattr(&amp;pap-&gt;dtpa_args)) {
		cmn_err(CE_WARN, <span class="enscript-string">&quot;failed to register provider '%s': invalid &quot;</span>
		    <span class="enscript-string">&quot;provider attributes&quot;</span>, name);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (priv &amp; ~DTRACE_PRIV_ALL) {
		cmn_err(CE_WARN, <span class="enscript-string">&quot;failed to register provider '%s': invalid &quot;</span>
		    <span class="enscript-string">&quot;privilege attributes&quot;</span>, name);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> ((priv &amp; DTRACE_PRIV_KERNEL) &amp;&amp;
	    (priv &amp; (DTRACE_PRIV_USER | DTRACE_PRIV_OWNER)) &amp;&amp;
	    pops-&gt;dtps_usermode == NULL) {
		cmn_err(CE_WARN, <span class="enscript-string">&quot;failed to register provider '%s': need &quot;</span>
		    <span class="enscript-string">&quot;dtps_usermode() op for given privilege attributes&quot;</span>, name);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	provider = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_provider_t), KM_SLEEP);

	<span class="enscript-comment">/* APPLE NOTE: Darwin employs size bounded string operation. */</span>
	{
	size_t bufsize = strlen(name) + 1;
	provider-&gt;dtpv_name = kmem_alloc(bufsize, KM_SLEEP);
	(<span class="enscript-type">void</span>) strlcpy(provider-&gt;dtpv_name, name, bufsize);
	}

	provider-&gt;dtpv_attr = *pap;
	provider-&gt;dtpv_priv.dtpp_flags = priv;
	<span class="enscript-keyword">if</span> (cr != NULL) {
		provider-&gt;dtpv_priv.dtpp_uid = crgetuid(cr);
		provider-&gt;dtpv_priv.dtpp_zoneid = crgetzoneid(cr);
	}
	provider-&gt;dtpv_pops = *pops;

	<span class="enscript-keyword">if</span> (pops-&gt;dtps_provide == NULL) {
		ASSERT(pops-&gt;dtps_provide_module != NULL);
		provider-&gt;dtpv_pops.dtps_provide =
		    (<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *, <span class="enscript-type">const</span> dtrace_probedesc_t *))dtrace_nullop;
	}

	<span class="enscript-keyword">if</span> (pops-&gt;dtps_provide_module == NULL) {
		ASSERT(pops-&gt;dtps_provide != NULL);
		provider-&gt;dtpv_pops.dtps_provide_module =
		    (<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *, <span class="enscript-type">struct</span> modctl *))dtrace_nullop;
	}

	<span class="enscript-keyword">if</span> (pops-&gt;dtps_suspend == NULL) {
		ASSERT(pops-&gt;dtps_resume == NULL);
		provider-&gt;dtpv_pops.dtps_suspend =
		    (<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *, dtrace_id_t, <span class="enscript-type">void</span> *))dtrace_nullop;
		provider-&gt;dtpv_pops.dtps_resume =
		    (<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *, dtrace_id_t, <span class="enscript-type">void</span> *))dtrace_nullop;
	}

	provider-&gt;dtpv_arg = arg;
	*idp = (dtrace_provider_id_t)provider;

	<span class="enscript-keyword">if</span> (pops == &amp;dtrace_provider_ops) {
		lck_mtx_assert(&amp;dtrace_provider_lock, LCK_MTX_ASSERT_OWNED);
		lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
		ASSERT(dtrace_anon.dta_enabling == NULL);

		<span class="enscript-comment">/*
		 * We make sure that the DTrace provider is at the head of
		 * the provider chain.
		 */</span>
		provider-&gt;dtpv_next = dtrace_provider;
		dtrace_provider = provider;
		<span class="enscript-keyword">return</span> (0);
	}

	lck_mtx_lock(&amp;dtrace_provider_lock);
	lck_mtx_lock(&amp;dtrace_lock);

	<span class="enscript-comment">/*
	 * If there is at least one provider registered, we'll add this
	 * provider after the first provider.
	 */</span>
	<span class="enscript-keyword">if</span> (dtrace_provider != NULL) {
		provider-&gt;dtpv_next = dtrace_provider-&gt;dtpv_next;
		dtrace_provider-&gt;dtpv_next = provider;
	} <span class="enscript-keyword">else</span> {
		dtrace_provider = provider;
	}

	<span class="enscript-keyword">if</span> (dtrace_retained != NULL) {
		dtrace_enabling_provide(provider);

		<span class="enscript-comment">/*
		 * Now we need to call dtrace_enabling_matchall() -- which
		 * will acquire cpu_lock and dtrace_lock.  We therefore need
		 * to drop all of our locks before calling into it...
		 */</span>
		lck_mtx_unlock(&amp;dtrace_lock);
		lck_mtx_unlock(&amp;dtrace_provider_lock);
		dtrace_enabling_matchall();

		<span class="enscript-keyword">return</span> (0);
	}

	lck_mtx_unlock(&amp;dtrace_lock);
	lck_mtx_unlock(&amp;dtrace_provider_lock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Unregister the specified provider from the DTrace framework.  This should
 * generally be called by DTrace providers in their detach(9E) entry point.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_unregister</span>(dtrace_provider_id_t id)
{
	dtrace_provider_t *old = (dtrace_provider_t *)id;
	dtrace_provider_t *prev = NULL;
	<span class="enscript-type">int</span> i, self = 0;
	dtrace_probe_t *probe, *first = NULL;

	<span class="enscript-keyword">if</span> (old-&gt;dtpv_pops.dtps_enable ==
	    (<span class="enscript-type">int</span> (*)(<span class="enscript-type">void</span> *, dtrace_id_t, <span class="enscript-type">void</span> *))dtrace_enable_nullop) {
		<span class="enscript-comment">/*
		 * If DTrace itself is the provider, we're called with locks
		 * already held.
		 */</span>
		ASSERT(old == dtrace_provider);
		ASSERT(dtrace_devi != NULL);
		lck_mtx_assert(&amp;dtrace_provider_lock, LCK_MTX_ASSERT_OWNED);
		lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
		self = 1;

		<span class="enscript-keyword">if</span> (dtrace_provider-&gt;dtpv_next != NULL) {
			<span class="enscript-comment">/*
			 * There's another provider here; return failure.
			 */</span>
			<span class="enscript-keyword">return</span> (EBUSY);
		}
	} <span class="enscript-keyword">else</span> {
		lck_mtx_lock(&amp;dtrace_provider_lock);
		lck_mtx_lock(&amp;mod_lock);
		lck_mtx_lock(&amp;dtrace_lock);
	}

	<span class="enscript-comment">/*
	 * If anyone has /dev/dtrace open, or if there are anonymous enabled
	 * probes, we refuse to let providers slither away, unless this
	 * provider has already been explicitly invalidated.
	 */</span>
	<span class="enscript-keyword">if</span> (!old-&gt;dtpv_defunct &amp;&amp;
	    (dtrace_opens || (dtrace_anon.dta_state != NULL &amp;&amp;
	    dtrace_anon.dta_state-&gt;dts_necbs &gt; 0))) {
		<span class="enscript-keyword">if</span> (!self) {
			lck_mtx_unlock(&amp;dtrace_lock);
			lck_mtx_unlock(&amp;mod_lock);
			lck_mtx_unlock(&amp;dtrace_provider_lock);
		}
		<span class="enscript-keyword">return</span> (EBUSY);
	}

	<span class="enscript-comment">/*
	 * Attempt to destroy the probes associated with this provider.
	 */</span>
	<span class="enscript-keyword">if</span> (old-&gt;dtpv_ecb_count!=0) {
		<span class="enscript-comment">/*
		 * We have at least one ECB; we can't remove this provider.
		 */</span>
		<span class="enscript-keyword">if</span> (!self) {
			lck_mtx_unlock(&amp;dtrace_lock);
			lck_mtx_unlock(&amp;mod_lock);
			lck_mtx_unlock(&amp;dtrace_provider_lock);
		}
		<span class="enscript-keyword">return</span> (EBUSY);
	}

	<span class="enscript-comment">/*
	 * All of the probes for this provider are disabled; we can safely
	 * remove all of them from their hash chains and from the probe array.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; dtrace_nprobes &amp;&amp; old-&gt;dtpv_probe_count!=0; i++) {
		<span class="enscript-keyword">if</span> ((probe = dtrace_probes[i]) == NULL)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (probe-&gt;dtpr_provider != old)
			<span class="enscript-keyword">continue</span>;

		dtrace_probes[i] = NULL;
		old-&gt;dtpv_probe_count--;

		dtrace_hash_remove(dtrace_bymod, probe);
		dtrace_hash_remove(dtrace_byfunc, probe);
		dtrace_hash_remove(dtrace_byname, probe);

		<span class="enscript-keyword">if</span> (first == NULL) {
			first = probe;
			probe-&gt;dtpr_nextmod = NULL;
		} <span class="enscript-keyword">else</span> {
			probe-&gt;dtpr_nextmod = first;
			first = probe;
		}
	}

	<span class="enscript-comment">/*
	 * The provider's probes have been removed from the hash chains and
	 * from the probe array.  Now issue a dtrace_sync() to be sure that
	 * everyone has cleared out from any probe array processing.
	 */</span>
	dtrace_sync();

	<span class="enscript-keyword">for</span> (probe = first; probe != NULL; probe = first) {
		first = probe-&gt;dtpr_nextmod;

		old-&gt;dtpv_pops.dtps_destroy(old-&gt;dtpv_arg, probe-&gt;dtpr_id,
		    probe-&gt;dtpr_arg);
		kmem_free(probe-&gt;dtpr_mod, strlen(probe-&gt;dtpr_mod) + 1);
		kmem_free(probe-&gt;dtpr_func, strlen(probe-&gt;dtpr_func) + 1);
		kmem_free(probe-&gt;dtpr_name, strlen(probe-&gt;dtpr_name) + 1);
		vmem_free(dtrace_arena, (<span class="enscript-type">void</span> *)(uintptr_t)(probe-&gt;dtpr_id), 1);
		zfree(dtrace_probe_t_zone, probe);
	}

	<span class="enscript-keyword">if</span> ((prev = dtrace_provider) == old) {
		ASSERT(self || dtrace_devi == NULL);
		ASSERT(old-&gt;dtpv_next == NULL || dtrace_devi == NULL);
		dtrace_provider = old-&gt;dtpv_next;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">while</span> (prev != NULL &amp;&amp; prev-&gt;dtpv_next != old)
			prev = prev-&gt;dtpv_next;

		<span class="enscript-keyword">if</span> (prev == NULL) {
			panic(<span class="enscript-string">&quot;attempt to unregister non-existent &quot;</span>
			    <span class="enscript-string">&quot;dtrace provider %p\n&quot;</span>, (<span class="enscript-type">void</span> *)id);
		}

		prev-&gt;dtpv_next = old-&gt;dtpv_next;
	}

	<span class="enscript-keyword">if</span> (!self) {
		lck_mtx_unlock(&amp;dtrace_lock);
		lck_mtx_unlock(&amp;mod_lock);
		lck_mtx_unlock(&amp;dtrace_provider_lock);
	}

	kmem_free(old-&gt;dtpv_name, strlen(old-&gt;dtpv_name) + 1);
	kmem_free(old, <span class="enscript-keyword">sizeof</span> (dtrace_provider_t));

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Invalidate the specified provider.  All subsequent probe lookups for the
 * specified provider will fail, but its probes will not be removed.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_invalidate</span>(dtrace_provider_id_t id)
{
	dtrace_provider_t *pvp = (dtrace_provider_t *)id;

	ASSERT(pvp-&gt;dtpv_pops.dtps_enable !=
	    (<span class="enscript-type">int</span> (*)(<span class="enscript-type">void</span> *, dtrace_id_t, <span class="enscript-type">void</span> *))dtrace_enable_nullop);

	lck_mtx_lock(&amp;dtrace_provider_lock);
	lck_mtx_lock(&amp;dtrace_lock);

	pvp-&gt;dtpv_defunct = 1;

	lck_mtx_unlock(&amp;dtrace_lock);
	lck_mtx_unlock(&amp;dtrace_provider_lock);
}

<span class="enscript-comment">/*
 * Indicate whether or not DTrace has attached.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_attached</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 * dtrace_provider will be non-NULL iff the DTrace driver has
	 * attached.  (It's non-NULL because DTrace is always itself a
	 * provider.)
	 */</span>
	<span class="enscript-keyword">return</span> (dtrace_provider != NULL);
}

<span class="enscript-comment">/*
 * Remove all the unenabled probes for the given provider.  This function is
 * not unlike dtrace_unregister(), except that it doesn't remove the provider
 * -- just as many of its associated probes as it can.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_condense</span>(dtrace_provider_id_t id)
{
	dtrace_provider_t *prov = (dtrace_provider_t *)id;
	<span class="enscript-type">int</span> i;
	dtrace_probe_t *probe;

	<span class="enscript-comment">/*
	 * Make sure this isn't the dtrace provider itself.
	 */</span>
	ASSERT(prov-&gt;dtpv_pops.dtps_enable !=
	  (<span class="enscript-type">int</span> (*)(<span class="enscript-type">void</span> *, dtrace_id_t, <span class="enscript-type">void</span> *))dtrace_enable_nullop);

	lck_mtx_lock(&amp;dtrace_provider_lock);
	lck_mtx_lock(&amp;dtrace_lock);

	<span class="enscript-comment">/*
	 * Attempt to destroy the probes associated with this provider.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; dtrace_nprobes; i++) {
		<span class="enscript-keyword">if</span> ((probe = dtrace_probes[i]) == NULL)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (probe-&gt;dtpr_provider != prov)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (probe-&gt;dtpr_ecb != NULL)
			<span class="enscript-keyword">continue</span>;

		dtrace_probes[i] = NULL;
		prov-&gt;dtpv_probe_count--;

		dtrace_hash_remove(dtrace_bymod, probe);
		dtrace_hash_remove(dtrace_byfunc, probe);
		dtrace_hash_remove(dtrace_byname, probe);

		prov-&gt;dtpv_pops.dtps_destroy(prov-&gt;dtpv_arg, i + 1,
		    probe-&gt;dtpr_arg);
		kmem_free(probe-&gt;dtpr_mod, strlen(probe-&gt;dtpr_mod) + 1);
		kmem_free(probe-&gt;dtpr_func, strlen(probe-&gt;dtpr_func) + 1);
		kmem_free(probe-&gt;dtpr_name, strlen(probe-&gt;dtpr_name) + 1);
		zfree(dtrace_probe_t_zone, probe);
		vmem_free(dtrace_arena, (<span class="enscript-type">void</span> *)((uintptr_t)i + 1), 1);
	}

	lck_mtx_unlock(&amp;dtrace_lock);
	lck_mtx_unlock(&amp;dtrace_provider_lock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * DTrace Probe Management Functions
 *
 * The functions in this section perform the DTrace probe management,
 * including functions to create probes, look-up probes, and call into the
 * providers to request that probes be provided.  Some of these functions are
 * in the Provider-to-Framework API; these functions can be identified by the
 * fact that they are not declared &quot;static&quot;.
 */</span>

<span class="enscript-comment">/*
 * Create a probe with the specified module name, function name, and name.
 */</span>
dtrace_id_t
<span class="enscript-function-name">dtrace_probe_create</span>(dtrace_provider_id_t prov, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *mod,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *func, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> aframes, <span class="enscript-type">void</span> *arg)
{
	dtrace_probe_t *probe, **probes;
	dtrace_provider_t *provider = (dtrace_provider_t *)prov;
	dtrace_id_t id;

	<span class="enscript-keyword">if</span> (provider == dtrace_provider) {
		lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	} <span class="enscript-keyword">else</span> {
		lck_mtx_lock(&amp;dtrace_lock);
	}

	id = (dtrace_id_t)(uintptr_t)vmem_alloc(dtrace_arena, 1,
	    VM_BESTFIT | VM_SLEEP);

	probe = zalloc(dtrace_probe_t_zone);
	bzero(probe, <span class="enscript-keyword">sizeof</span> (dtrace_probe_t));

	probe-&gt;dtpr_id = id;
	probe-&gt;dtpr_gen = dtrace_probegen++;
	probe-&gt;dtpr_mod = dtrace_strdup(mod);
	probe-&gt;dtpr_func = dtrace_strdup(func);
	probe-&gt;dtpr_name = dtrace_strdup(name);
	probe-&gt;dtpr_arg = arg;
	probe-&gt;dtpr_aframes = aframes;
	probe-&gt;dtpr_provider = provider;

	dtrace_hash_add(dtrace_bymod, probe);
	dtrace_hash_add(dtrace_byfunc, probe);
	dtrace_hash_add(dtrace_byname, probe);

	<span class="enscript-keyword">if</span> (id - 1 &gt;= (dtrace_id_t)dtrace_nprobes) {
		size_t osize = dtrace_nprobes * <span class="enscript-keyword">sizeof</span> (dtrace_probe_t *);
		size_t nsize = osize &lt;&lt; 1;

		<span class="enscript-keyword">if</span> (nsize == 0) {
			ASSERT(osize == 0);
			ASSERT(dtrace_probes == NULL);
			nsize = <span class="enscript-keyword">sizeof</span> (dtrace_probe_t *);
		}

		probes = kmem_zalloc(nsize, KM_SLEEP);

		<span class="enscript-keyword">if</span> (dtrace_probes == NULL) {
			ASSERT(osize == 0);
			dtrace_probes = probes;
			dtrace_nprobes = 1;
		} <span class="enscript-keyword">else</span> {
			dtrace_probe_t **oprobes = dtrace_probes;

			bcopy(oprobes, probes, osize);
			dtrace_membar_producer();
			dtrace_probes = probes;

			dtrace_sync();

			<span class="enscript-comment">/*
			 * All CPUs are now seeing the new probes array; we can
			 * safely free the old array.
			 */</span>
			kmem_free(oprobes, osize);
			dtrace_nprobes &lt;&lt;= 1;
		}

		ASSERT(id - 1 &lt; (dtrace_id_t)dtrace_nprobes);
	}

	ASSERT(dtrace_probes[id - 1] == NULL);
	dtrace_probes[id - 1] = probe;
	provider-&gt;dtpv_probe_count++;	

	<span class="enscript-keyword">if</span> (provider != dtrace_provider)
		lck_mtx_unlock(&amp;dtrace_lock);

	<span class="enscript-keyword">return</span> (id);
}

<span class="enscript-type">static</span> dtrace_probe_t *
<span class="enscript-function-name">dtrace_probe_lookup_id</span>(dtrace_id_t id)
{
	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (id == 0 || id &gt; (dtrace_id_t)dtrace_nprobes)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">return</span> (dtrace_probes[id - 1]);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_probe_lookup_match</span>(dtrace_probe_t *probe, <span class="enscript-type">void</span> *arg)
{
	*((dtrace_id_t *)arg) = probe-&gt;dtpr_id;

	<span class="enscript-keyword">return</span> (DTRACE_MATCH_DONE);
}

<span class="enscript-comment">/*
 * Look up a probe based on provider and one or more of module name, function
 * name and probe name.
 */</span>
dtrace_id_t
<span class="enscript-function-name">dtrace_probe_lookup</span>(dtrace_provider_id_t prid, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *mod,
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *func, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name)
{
	dtrace_probekey_t pkey;
	dtrace_id_t id;
	<span class="enscript-type">int</span> match;

	pkey.dtpk_prov = ((dtrace_provider_t *)prid)-&gt;dtpv_name;
	pkey.dtpk_pmatch = &amp;dtrace_match_string;
	pkey.dtpk_mod = mod;
	pkey.dtpk_mmatch = mod ? &amp;dtrace_match_string : &amp;dtrace_match_nul;
	pkey.dtpk_func = func;
	pkey.dtpk_fmatch = func ? &amp;dtrace_match_string : &amp;dtrace_match_nul;
	pkey.dtpk_name = name;
	pkey.dtpk_nmatch = name ? &amp;dtrace_match_string : &amp;dtrace_match_nul;
	pkey.dtpk_id = DTRACE_IDNONE;

	lck_mtx_lock(&amp;dtrace_lock);
	match = dtrace_match(&amp;pkey, DTRACE_PRIV_ALL, 0, 0,
	    dtrace_probe_lookup_match, &amp;id);
	lck_mtx_unlock(&amp;dtrace_lock);

	ASSERT(match == 1 || match == 0);
	<span class="enscript-keyword">return</span> (match ? id : 0);
}

<span class="enscript-comment">/*
 * Returns the probe argument associated with the specified probe.
 */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">dtrace_probe_arg</span>(dtrace_provider_id_t id, dtrace_id_t pid)
{
	dtrace_probe_t *probe;
	<span class="enscript-type">void</span> *rval = NULL;

	lck_mtx_lock(&amp;dtrace_lock);

	<span class="enscript-keyword">if</span> ((probe = dtrace_probe_lookup_id(pid)) != NULL &amp;&amp;
	    probe-&gt;dtpr_provider == (dtrace_provider_t *)id)
		rval = probe-&gt;dtpr_arg;

	lck_mtx_unlock(&amp;dtrace_lock);

	<span class="enscript-keyword">return</span> (rval);
}

<span class="enscript-comment">/*
 * Copy a probe into a probe description.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_probe_description</span>(<span class="enscript-type">const</span> dtrace_probe_t *prp, dtrace_probedesc_t *pdp)
{
	bzero(pdp, <span class="enscript-keyword">sizeof</span> (dtrace_probedesc_t));
	pdp-&gt;dtpd_id = prp-&gt;dtpr_id;

	<span class="enscript-comment">/* APPLE NOTE: Darwin employs size bounded string operation. */</span>
	(<span class="enscript-type">void</span>) strlcpy(pdp-&gt;dtpd_provider,
	    prp-&gt;dtpr_provider-&gt;dtpv_name, DTRACE_PROVNAMELEN);

	(<span class="enscript-type">void</span>) strlcpy(pdp-&gt;dtpd_mod, prp-&gt;dtpr_mod, DTRACE_MODNAMELEN);
	(<span class="enscript-type">void</span>) strlcpy(pdp-&gt;dtpd_func, prp-&gt;dtpr_func, DTRACE_FUNCNAMELEN);
	(<span class="enscript-type">void</span>) strlcpy(pdp-&gt;dtpd_name, prp-&gt;dtpr_name, DTRACE_NAMELEN);
}

<span class="enscript-comment">/*
 * Called to indicate that a probe -- or probes -- should be provided by a
 * specfied provider.  If the specified description is NULL, the provider will
 * be told to provide all of its probes.  (This is done whenever a new
 * consumer comes along, or whenever a retained enabling is to be matched.) If
 * the specified description is non-NULL, the provider is given the
 * opportunity to dynamically provide the specified probe, allowing providers
 * to support the creation of probes on-the-fly.  (So-called _autocreated_
 * probes.)  If the provider is NULL, the operations will be applied to all
 * providers; if the provider is non-NULL the operations will only be applied
 * to the specified provider.  The dtrace_provider_lock must be held, and the
 * dtrace_lock must _not_ be held -- the provider's dtps_provide() operation
 * will need to grab the dtrace_lock when it reenters the framework through
 * dtrace_probe_lookup(), dtrace_probe_create(), etc.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_probe_provide</span>(dtrace_probedesc_t *desc, dtrace_provider_t *prv)
{
	<span class="enscript-type">struct</span> modctl *ctl;
	<span class="enscript-type">int</span> all = 0;

	lck_mtx_assert(&amp;dtrace_provider_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (prv == NULL) {
		all = 1;
		prv = dtrace_provider;
	}
		 
	<span class="enscript-keyword">do</span> {
		<span class="enscript-comment">/*
		 * First, call the blanket provide operation.
		 */</span>
		prv-&gt;dtpv_pops.dtps_provide(prv-&gt;dtpv_arg, desc);
		
		<span class="enscript-comment">/*
		 * Now call the per-module provide operation.  We will grab
		 * mod_lock to prevent the list from being modified.  Note
		 * that this also prevents the mod_busy bits from changing.
		 * (mod_busy can only be changed with mod_lock held.)
		 */</span>
		lck_mtx_lock(&amp;mod_lock);
		
		ctl = dtrace_modctl_list;
		<span class="enscript-keyword">while</span> (ctl) {
			prv-&gt;dtpv_pops.dtps_provide_module(prv-&gt;dtpv_arg, ctl);
			ctl = ctl-&gt;mod_next;
		}
		
		lck_mtx_unlock(&amp;mod_lock);
	} <span class="enscript-keyword">while</span> (all &amp;&amp; (prv = prv-&gt;dtpv_next) != NULL);
}

<span class="enscript-comment">/*
 * Iterate over each probe, and call the Framework-to-Provider API function
 * denoted by offs.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_probe_foreach</span>(uintptr_t offs)
{
	dtrace_provider_t *prov;
	<span class="enscript-type">void</span> (*func)(<span class="enscript-type">void</span> *, dtrace_id_t, <span class="enscript-type">void</span> *);
	dtrace_probe_t *probe;
	dtrace_icookie_t cookie;
	<span class="enscript-type">int</span> i;

	<span class="enscript-comment">/*
	 * We disable interrupts to walk through the probe array.  This is
	 * safe -- the dtrace_sync() in dtrace_unregister() assures that we
	 * won't see stale data.
	 */</span>
	cookie = dtrace_interrupt_disable();

	<span class="enscript-keyword">for</span> (i = 0; i &lt; dtrace_nprobes; i++) {
		<span class="enscript-keyword">if</span> ((probe = dtrace_probes[i]) == NULL)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (probe-&gt;dtpr_ecb == NULL) {
			<span class="enscript-comment">/*
			 * This probe isn't enabled -- don't call the function.
			 */</span>
			<span class="enscript-keyword">continue</span>;
		}

		prov = probe-&gt;dtpr_provider;
		func = *((<span class="enscript-type">void</span>(**)(<span class="enscript-type">void</span> *, dtrace_id_t, <span class="enscript-type">void</span> *))
		    ((uintptr_t)&amp;prov-&gt;dtpv_pops + offs));

		func(prov-&gt;dtpv_arg, i + 1, probe-&gt;dtpr_arg);
	}

	dtrace_interrupt_enable(cookie);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_probe_enable</span>(<span class="enscript-type">const</span> dtrace_probedesc_t *desc, dtrace_enabling_t *enab)
{
	dtrace_probekey_t pkey;
	uint32_t priv;
	uid_t uid;
	zoneid_t zoneid;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	dtrace_ecb_create_cache = NULL;

	<span class="enscript-keyword">if</span> (desc == NULL) {
		<span class="enscript-comment">/*
		 * If we're passed a NULL description, we're being asked to
		 * create an ECB with a NULL probe.
		 */</span>
		(<span class="enscript-type">void</span>) dtrace_ecb_create_enable(NULL, enab);
		<span class="enscript-keyword">return</span> (0);
	}

	dtrace_probekey(desc, &amp;pkey);
	dtrace_cred2priv(enab-&gt;dten_vstate-&gt;dtvs_state-&gt;dts_cred.dcr_cred,
	    &amp;priv, &amp;uid, &amp;zoneid);

	<span class="enscript-keyword">return</span> (dtrace_match(&amp;pkey, priv, uid, zoneid, dtrace_ecb_create_enable,
	    enab));
}

<span class="enscript-comment">/*
 * DTrace Helper Provider Functions
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_dofattr2attr</span>(dtrace_attribute_t *attr, <span class="enscript-type">const</span> dof_attr_t dofattr)
{
	attr-&gt;dtat_name = DOF_ATTR_NAME(dofattr);
	attr-&gt;dtat_data = DOF_ATTR_DATA(dofattr);
	attr-&gt;dtat_class = DOF_ATTR_CLASS(dofattr);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_dofprov2hprov</span>(dtrace_helper_provdesc_t *hprov,
    <span class="enscript-type">const</span> dof_provider_t *dofprov, <span class="enscript-type">char</span> *strtab)
{
	hprov-&gt;dthpv_provname = strtab + dofprov-&gt;dofpv_name;
	dtrace_dofattr2attr(&amp;hprov-&gt;dthpv_pattr.dtpa_provider,
	    dofprov-&gt;dofpv_provattr);
	dtrace_dofattr2attr(&amp;hprov-&gt;dthpv_pattr.dtpa_mod,
	    dofprov-&gt;dofpv_modattr);
	dtrace_dofattr2attr(&amp;hprov-&gt;dthpv_pattr.dtpa_func,
	    dofprov-&gt;dofpv_funcattr);
	dtrace_dofattr2attr(&amp;hprov-&gt;dthpv_pattr.dtpa_name,
	    dofprov-&gt;dofpv_nameattr);
	dtrace_dofattr2attr(&amp;hprov-&gt;dthpv_pattr.dtpa_args,
	    dofprov-&gt;dofpv_argsattr);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_helper_provide_one</span>(dof_helper_t *dhp, dof_sec_t *sec, pid_t pid)
{
	uintptr_t daddr = (uintptr_t)dhp-&gt;dofhp_dof;
	dof_hdr_t *dof = (dof_hdr_t *)daddr;
	dof_sec_t *str_sec, *prb_sec, *arg_sec, *off_sec, *enoff_sec;
	dof_provider_t *provider;
	dof_probe_t *probe;
	uint32_t *off, *enoff;
	uint8_t *arg;
	<span class="enscript-type">char</span> *strtab;
	uint_t i, nprobes;
	dtrace_helper_provdesc_t dhpv;
	dtrace_helper_probedesc_t dhpb;
	dtrace_meta_t *meta = dtrace_meta_pid;
	dtrace_mops_t *mops = &amp;meta-&gt;dtm_mops;
	<span class="enscript-type">void</span> *parg;

	provider = (dof_provider_t *)(uintptr_t)(daddr + sec-&gt;dofs_offset);
	str_sec = (dof_sec_t *)(uintptr_t)(daddr + dof-&gt;dofh_secoff +
	    provider-&gt;dofpv_strtab * dof-&gt;dofh_secsize);
	prb_sec = (dof_sec_t *)(uintptr_t)(daddr + dof-&gt;dofh_secoff +
	    provider-&gt;dofpv_probes * dof-&gt;dofh_secsize);
	arg_sec = (dof_sec_t *)(uintptr_t)(daddr + dof-&gt;dofh_secoff +
	    provider-&gt;dofpv_prargs * dof-&gt;dofh_secsize);
	off_sec = (dof_sec_t *)(uintptr_t)(daddr + dof-&gt;dofh_secoff +
	    provider-&gt;dofpv_proffs * dof-&gt;dofh_secsize);

	strtab = (<span class="enscript-type">char</span> *)(uintptr_t)(daddr + str_sec-&gt;dofs_offset);
	off = (uint32_t *)(uintptr_t)(daddr + off_sec-&gt;dofs_offset);
	arg = (uint8_t *)(uintptr_t)(daddr + arg_sec-&gt;dofs_offset);
	enoff = NULL;

	<span class="enscript-comment">/*
	 * See dtrace_helper_provider_validate().
	 */</span>
	<span class="enscript-keyword">if</span> (dof-&gt;dofh_ident[DOF_ID_VERSION] != DOF_VERSION_1 &amp;&amp;
	    provider-&gt;dofpv_prenoffs != DOF_SECT_NONE) {
		enoff_sec = (dof_sec_t *)(uintptr_t)(daddr + dof-&gt;dofh_secoff +
		    provider-&gt;dofpv_prenoffs * dof-&gt;dofh_secsize);
		enoff = (uint32_t *)(uintptr_t)(daddr + enoff_sec-&gt;dofs_offset);
	}

	nprobes = prb_sec-&gt;dofs_size / prb_sec-&gt;dofs_entsize;

	<span class="enscript-comment">/*
	 * Create the provider.
	 */</span>
	dtrace_dofprov2hprov(&amp;dhpv, provider, strtab);

	<span class="enscript-keyword">if</span> ((parg = mops-&gt;dtms_provide_pid(meta-&gt;dtm_arg, &amp;dhpv, pid)) == NULL)
		<span class="enscript-keyword">return</span>;

	meta-&gt;dtm_count++;

	<span class="enscript-comment">/*
	 * Create the probes.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; nprobes; i++) {
		probe = (dof_probe_t *)(uintptr_t)(daddr +
		    prb_sec-&gt;dofs_offset + i * prb_sec-&gt;dofs_entsize);

		dhpb.dthpb_mod = dhp-&gt;dofhp_mod;
		dhpb.dthpb_func = strtab + probe-&gt;dofpr_func;
		dhpb.dthpb_name = strtab + probe-&gt;dofpr_name;
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
		dhpb.dthpb_base = probe-&gt;dofpr_addr;
#<span class="enscript-reference">else</span>
		dhpb.dthpb_base = dhp-&gt;dofhp_addr; <span class="enscript-comment">/* FIXME: James, why? */</span>
#<span class="enscript-reference">endif</span>
		dhpb.dthpb_offs = (int32_t *)(off + probe-&gt;dofpr_offidx);
		dhpb.dthpb_noffs = probe-&gt;dofpr_noffs;
		<span class="enscript-keyword">if</span> (enoff != NULL) {
			dhpb.dthpb_enoffs = (int32_t *)(enoff + probe-&gt;dofpr_enoffidx);
			dhpb.dthpb_nenoffs = probe-&gt;dofpr_nenoffs;
		} <span class="enscript-keyword">else</span> {
			dhpb.dthpb_enoffs = NULL;
			dhpb.dthpb_nenoffs = 0;
		}
		dhpb.dthpb_args = arg + probe-&gt;dofpr_argidx;
		dhpb.dthpb_nargc = probe-&gt;dofpr_nargc;
		dhpb.dthpb_xargc = probe-&gt;dofpr_xargc;
		dhpb.dthpb_ntypes = strtab + probe-&gt;dofpr_nargv;
		dhpb.dthpb_xtypes = strtab + probe-&gt;dofpr_xargv;

		mops-&gt;dtms_create_probe(meta-&gt;dtm_arg, parg, &amp;dhpb);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_helper_provide</span>(dof_helper_t *dhp, pid_t pid)
{
	uintptr_t daddr = (uintptr_t)dhp-&gt;dofhp_dof;
	dof_hdr_t *dof = (dof_hdr_t *)daddr;
	uint32_t i;

	lck_mtx_assert(&amp;dtrace_meta_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; dof-&gt;dofh_secnum; i++) {
		dof_sec_t *sec = (dof_sec_t *)(uintptr_t)(daddr +
		    dof-&gt;dofh_secoff + i * dof-&gt;dofh_secsize);

		<span class="enscript-keyword">if</span> (sec-&gt;dofs_type != DOF_SECT_PROVIDER)
			<span class="enscript-keyword">continue</span>;

		dtrace_helper_provide_one(dhp, sec, pid);
	}

	<span class="enscript-comment">/*
	 * We may have just created probes, so we must now rematch against
	 * any retained enablings.  Note that this call will acquire both
	 * cpu_lock and dtrace_lock; the fact that we are holding
	 * dtrace_meta_lock now is what defines the ordering with respect to
	 * these three locks.
	 */</span>
	dtrace_enabling_matchall();
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_helper_provider_remove_one</span>(dof_helper_t *dhp, dof_sec_t *sec, pid_t pid)
{
	uintptr_t daddr = (uintptr_t)dhp-&gt;dofhp_dof;
	dof_hdr_t *dof = (dof_hdr_t *)daddr;
	dof_sec_t *str_sec;
	dof_provider_t *provider;
	<span class="enscript-type">char</span> *strtab;
	dtrace_helper_provdesc_t dhpv;
	dtrace_meta_t *meta = dtrace_meta_pid;
	dtrace_mops_t *mops = &amp;meta-&gt;dtm_mops;

	provider = (dof_provider_t *)(uintptr_t)(daddr + sec-&gt;dofs_offset);
	str_sec = (dof_sec_t *)(uintptr_t)(daddr + dof-&gt;dofh_secoff +
	    provider-&gt;dofpv_strtab * dof-&gt;dofh_secsize);

	strtab = (<span class="enscript-type">char</span> *)(uintptr_t)(daddr + str_sec-&gt;dofs_offset);

	<span class="enscript-comment">/*
	 * Create the provider.
	 */</span>
	dtrace_dofprov2hprov(&amp;dhpv, provider, strtab);

	mops-&gt;dtms_remove_pid(meta-&gt;dtm_arg, &amp;dhpv, pid);

	meta-&gt;dtm_count--;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_helper_provider_remove</span>(dof_helper_t *dhp, pid_t pid)
{
	uintptr_t daddr = (uintptr_t)dhp-&gt;dofhp_dof;
	dof_hdr_t *dof = (dof_hdr_t *)daddr;
	uint32_t i;

	lck_mtx_assert(&amp;dtrace_meta_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; dof-&gt;dofh_secnum; i++) {
		dof_sec_t *sec = (dof_sec_t *)(uintptr_t)(daddr +
		    dof-&gt;dofh_secoff + i * dof-&gt;dofh_secsize);

		<span class="enscript-keyword">if</span> (sec-&gt;dofs_type != DOF_SECT_PROVIDER)
			<span class="enscript-keyword">continue</span>;

		dtrace_helper_provider_remove_one(dhp, sec, pid);
	}
}

<span class="enscript-comment">/*
 * DTrace Meta Provider-to-Framework API Functions
 *
 * These functions implement the Meta Provider-to-Framework API, as described
 * in &lt;sys/dtrace.h&gt;.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_meta_register</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">const</span> dtrace_mops_t *mops, <span class="enscript-type">void</span> *arg,
    dtrace_meta_provider_id_t *idp)
{
	dtrace_meta_t *meta;
	dtrace_helpers_t *help, *next;
	uint_t i;

	*idp = DTRACE_METAPROVNONE;

	<span class="enscript-comment">/*
	 * We strictly don't need the name, but we hold onto it for
	 * debuggability. All hail error queues!
	 */</span>
	<span class="enscript-keyword">if</span> (name == NULL) {
		cmn_err(CE_WARN, <span class="enscript-string">&quot;failed to register meta-provider: &quot;</span>
		    <span class="enscript-string">&quot;invalid name&quot;</span>);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (mops == NULL ||
	    mops-&gt;dtms_create_probe == NULL ||
	    mops-&gt;dtms_provide_pid == NULL ||
	    mops-&gt;dtms_remove_pid == NULL) {
		cmn_err(CE_WARN, <span class="enscript-string">&quot;failed to register meta-register %s: &quot;</span>
		    <span class="enscript-string">&quot;invalid ops&quot;</span>, name);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	meta = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_meta_t), KM_SLEEP);
	meta-&gt;dtm_mops = *mops;

	<span class="enscript-comment">/* APPLE NOTE: Darwin employs size bounded string operation. */</span>
	{
	size_t bufsize = strlen(name) + 1;
	meta-&gt;dtm_name = kmem_alloc(bufsize, KM_SLEEP);
	(<span class="enscript-type">void</span>) strlcpy(meta-&gt;dtm_name, name, bufsize);
	}

	meta-&gt;dtm_arg = arg;

	lck_mtx_lock(&amp;dtrace_meta_lock);
	lck_mtx_lock(&amp;dtrace_lock);

	<span class="enscript-keyword">if</span> (dtrace_meta_pid != NULL) {
		lck_mtx_unlock(&amp;dtrace_lock);
		lck_mtx_unlock(&amp;dtrace_meta_lock);
		cmn_err(CE_WARN, <span class="enscript-string">&quot;failed to register meta-register %s: &quot;</span>
		    <span class="enscript-string">&quot;user-land meta-provider exists&quot;</span>, name);
		kmem_free(meta-&gt;dtm_name, strlen(meta-&gt;dtm_name) + 1);
		kmem_free(meta, <span class="enscript-keyword">sizeof</span> (dtrace_meta_t));
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	dtrace_meta_pid = meta;
	*idp = (dtrace_meta_provider_id_t)meta;

	<span class="enscript-comment">/*
	 * If there are providers and probes ready to go, pass them
	 * off to the new meta provider now.
	 */</span>

	help = dtrace_deferred_pid;
	dtrace_deferred_pid = NULL;

	lck_mtx_unlock(&amp;dtrace_lock);

	<span class="enscript-keyword">while</span> (help != NULL) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; help-&gt;dthps_nprovs; i++) {
			dtrace_helper_provide(&amp;help-&gt;dthps_provs[i]-&gt;dthp_prov,
			    help-&gt;dthps_pid);
		}

		next = help-&gt;dthps_next;
		help-&gt;dthps_next = NULL;
		help-&gt;dthps_prev = NULL;
		help-&gt;dthps_deferred = 0;
		help = next;
	}

	lck_mtx_unlock(&amp;dtrace_meta_lock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_meta_unregister</span>(dtrace_meta_provider_id_t id)
{
	dtrace_meta_t **pp, *old = (dtrace_meta_t *)id;

	lck_mtx_lock(&amp;dtrace_meta_lock);
	lck_mtx_lock(&amp;dtrace_lock);

	<span class="enscript-keyword">if</span> (old == dtrace_meta_pid) {
		pp = &amp;dtrace_meta_pid;
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;attempt to unregister non-existent &quot;</span>
		    <span class="enscript-string">&quot;dtrace meta-provider %p\n&quot;</span>, (<span class="enscript-type">void</span> *)old);
	}

	<span class="enscript-keyword">if</span> (old-&gt;dtm_count != 0) {
		lck_mtx_unlock(&amp;dtrace_lock);
		lck_mtx_unlock(&amp;dtrace_meta_lock);
		<span class="enscript-keyword">return</span> (EBUSY);
	}

	*pp = NULL;

	lck_mtx_unlock(&amp;dtrace_lock);
	lck_mtx_unlock(&amp;dtrace_meta_lock);

	kmem_free(old-&gt;dtm_name, strlen(old-&gt;dtm_name) + 1);
	kmem_free(old, <span class="enscript-keyword">sizeof</span> (dtrace_meta_t));

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * DTrace DIF Object Functions
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_difo_err</span>(uint_t pc, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *format, ...)
{
	<span class="enscript-keyword">if</span> (dtrace_err_verbose) {
		va_list alist;

		(<span class="enscript-type">void</span>) uprintf(<span class="enscript-string">&quot;dtrace DIF object error: [%u]: &quot;</span>, pc);
		va_start(alist, format);
		(<span class="enscript-type">void</span>) vuprintf(format, alist);
		va_end(alist);
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DTRACE_ERRDEBUG</span>
	dtrace_errdebug(format);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * Validate a DTrace DIF object by checking the IR instructions.  The following
 * rules are currently enforced by dtrace_difo_validate():
 *
 * 1. Each instruction must have a valid opcode
 * 2. Each register, string, variable, or subroutine reference must be valid
 * 3. No instruction can modify register %r0 (must be zero)
 * 4. All instruction reserved bits must be set to zero
 * 5. The last instruction must be a &quot;ret&quot; instruction
 * 6. All branch targets must reference a valid instruction _after_ the branch
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_difo_validate</span>(dtrace_difo_t *dp, dtrace_vstate_t *vstate, uint_t nregs,
    cred_t *cr)
{
	<span class="enscript-type">int</span> err = 0;
	uint_t i;

	<span class="enscript-type">int</span> (*efunc)(uint_t pc, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, ...) = dtrace_difo_err;
	<span class="enscript-type">int</span> kcheckload;
	uint_t pc;

	kcheckload = cr == NULL ||
	    (vstate-&gt;dtvs_state-&gt;dts_cred.dcr_visible &amp; DTRACE_CRV_KERNEL) == 0;

	dp-&gt;dtdo_destructive = 0;

	<span class="enscript-keyword">for</span> (pc = 0; pc &lt; dp-&gt;dtdo_len &amp;&amp; err == 0; pc++) {
		dif_instr_t instr = dp-&gt;dtdo_buf[pc];

		uint_t r1 = DIF_INSTR_R1(instr);
		uint_t r2 = DIF_INSTR_R2(instr);
		uint_t rd = DIF_INSTR_RD(instr);
		uint_t rs = DIF_INSTR_RS(instr);
		uint_t label = DIF_INSTR_LABEL(instr);
		uint_t v = DIF_INSTR_VAR(instr);
		uint_t subr = DIF_INSTR_SUBR(instr);
		uint_t type = DIF_INSTR_TYPE(instr);
		uint_t op = DIF_INSTR_OP(instr);

		<span class="enscript-keyword">switch</span> (op) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_OR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_XOR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_AND</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SLL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SRL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SRA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SUB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ADD</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_MUL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SDIV</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_UDIV</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SREM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_UREM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_COPYS</span>:
			<span class="enscript-keyword">if</span> (r1 &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, r1);
			<span class="enscript-keyword">if</span> (r2 &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, r2);
			<span class="enscript-keyword">if</span> (rd &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, rd);
			<span class="enscript-keyword">if</span> (rd == 0)
				err += efunc(pc, <span class="enscript-string">&quot;cannot write to %r0\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_NOT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_MOV</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ALLOCS</span>:
			<span class="enscript-keyword">if</span> (r1 &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, r1);
			<span class="enscript-keyword">if</span> (r2 != 0)
				err += efunc(pc, <span class="enscript-string">&quot;non-zero reserved bits\n&quot;</span>);
			<span class="enscript-keyword">if</span> (rd &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, rd);
			<span class="enscript-keyword">if</span> (rd == 0)
				err += efunc(pc, <span class="enscript-string">&quot;cannot write to %r0\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDSB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDSH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDSW</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDUB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDUH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDUW</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDX</span>:
			<span class="enscript-keyword">if</span> (r1 &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, r1);
			<span class="enscript-keyword">if</span> (r2 != 0)
				err += efunc(pc, <span class="enscript-string">&quot;non-zero reserved bits\n&quot;</span>);
			<span class="enscript-keyword">if</span> (rd &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, rd);
			<span class="enscript-keyword">if</span> (rd == 0)
				err += efunc(pc, <span class="enscript-string">&quot;cannot write to %r0\n&quot;</span>);
			<span class="enscript-keyword">if</span> (kcheckload)
				dp-&gt;dtdo_buf[pc] = DIF_INSTR_LOAD(op +
				    DIF_OP_RLDSB - DIF_OP_LDSB, r1, rd);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDSB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDSH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDSW</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDUB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDUH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDUW</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDX</span>:
			<span class="enscript-keyword">if</span> (r1 &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, r1);
			<span class="enscript-keyword">if</span> (r2 != 0)
				err += efunc(pc, <span class="enscript-string">&quot;non-zero reserved bits\n&quot;</span>);
			<span class="enscript-keyword">if</span> (rd &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, rd);
			<span class="enscript-keyword">if</span> (rd == 0)
				err += efunc(pc, <span class="enscript-string">&quot;cannot write to %r0\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDSB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDSH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDSW</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDUB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDUH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDUW</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDX</span>:
			<span class="enscript-keyword">if</span> (r1 &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, r1);
			<span class="enscript-keyword">if</span> (r2 != 0)
				err += efunc(pc, <span class="enscript-string">&quot;non-zero reserved bits\n&quot;</span>);
			<span class="enscript-keyword">if</span> (rd &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, rd);
			<span class="enscript-keyword">if</span> (rd == 0)
				err += efunc(pc, <span class="enscript-string">&quot;cannot write to %r0\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STW</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STX</span>:
			<span class="enscript-keyword">if</span> (r1 &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, r1);
			<span class="enscript-keyword">if</span> (r2 != 0)
				err += efunc(pc, <span class="enscript-string">&quot;non-zero reserved bits\n&quot;</span>);
			<span class="enscript-keyword">if</span> (rd &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, rd);
			<span class="enscript-keyword">if</span> (rd == 0)
				err += efunc(pc, <span class="enscript-string">&quot;cannot write to 0 address\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_CMP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SCMP</span>:
			<span class="enscript-keyword">if</span> (r1 &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, r1);
			<span class="enscript-keyword">if</span> (r2 &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, r2);
			<span class="enscript-keyword">if</span> (rd != 0)
				err += efunc(pc, <span class="enscript-string">&quot;non-zero reserved bits\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_TST</span>:
			<span class="enscript-keyword">if</span> (r1 &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, r1);
			<span class="enscript-keyword">if</span> (r2 != 0 || rd != 0)
				err += efunc(pc, <span class="enscript-string">&quot;non-zero reserved bits\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BNE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BG</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BGU</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BGE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BGEU</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BLU</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BLE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BLEU</span>:
			<span class="enscript-keyword">if</span> (label &gt;= dp-&gt;dtdo_len) {
				err += efunc(pc, <span class="enscript-string">&quot;invalid branch target %u\n&quot;</span>,
				    label);
			}
			<span class="enscript-keyword">if</span> (label &lt;= pc) {
				err += efunc(pc, <span class="enscript-string">&quot;backward branch to %u\n&quot;</span>,
				    label);
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RET</span>:
			<span class="enscript-keyword">if</span> (r1 != 0 || r2 != 0)
				err += efunc(pc, <span class="enscript-string">&quot;non-zero reserved bits\n&quot;</span>);
			<span class="enscript-keyword">if</span> (rd &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, rd);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_NOP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_POPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_FLUSHTS</span>:
			<span class="enscript-keyword">if</span> (r1 != 0 || r2 != 0 || rd != 0)
				err += efunc(pc, <span class="enscript-string">&quot;non-zero reserved bits\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SETX</span>:
			<span class="enscript-keyword">if</span> (DIF_INSTR_INTEGER(instr) &gt;= dp-&gt;dtdo_intlen) {
				err += efunc(pc, <span class="enscript-string">&quot;invalid integer ref %u\n&quot;</span>,
				    DIF_INSTR_INTEGER(instr));
			}
			<span class="enscript-keyword">if</span> (rd &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, rd);
			<span class="enscript-keyword">if</span> (rd == 0)
				err += efunc(pc, <span class="enscript-string">&quot;cannot write to %r0\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SETS</span>:
			<span class="enscript-keyword">if</span> (DIF_INSTR_STRING(instr) &gt;= dp-&gt;dtdo_strlen) {
				err += efunc(pc, <span class="enscript-string">&quot;invalid string ref %u\n&quot;</span>,
				    DIF_INSTR_STRING(instr));
			}
			<span class="enscript-keyword">if</span> (rd &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, rd);
			<span class="enscript-keyword">if</span> (rd == 0)
				err += efunc(pc, <span class="enscript-string">&quot;cannot write to %r0\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDGA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDTA</span>:
			<span class="enscript-keyword">if</span> (r1 &gt; DIF_VAR_ARRAY_MAX)
				err += efunc(pc, <span class="enscript-string">&quot;invalid array %u\n&quot;</span>, r1);
			<span class="enscript-keyword">if</span> (r2 &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, r2);
			<span class="enscript-keyword">if</span> (rd &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, rd);
			<span class="enscript-keyword">if</span> (rd == 0)
				err += efunc(pc, <span class="enscript-string">&quot;cannot write to %r0\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDGS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDLS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDGAA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDTAA</span>:
			<span class="enscript-keyword">if</span> (v &lt; DIF_VAR_OTHER_MIN || v &gt; DIF_VAR_OTHER_MAX)
				err += efunc(pc, <span class="enscript-string">&quot;invalid variable %u\n&quot;</span>, v);
			<span class="enscript-keyword">if</span> (rd &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, rd);
			<span class="enscript-keyword">if</span> (rd == 0)
				err += efunc(pc, <span class="enscript-string">&quot;cannot write to %r0\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STGS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STLS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STGAA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STTAA</span>:
			<span class="enscript-keyword">if</span> (v &lt; DIF_VAR_OTHER_UBASE || v &gt; DIF_VAR_OTHER_MAX)
				err += efunc(pc, <span class="enscript-string">&quot;invalid variable %u\n&quot;</span>, v);
			<span class="enscript-keyword">if</span> (rs &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, rd);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_CALL</span>:
			<span class="enscript-keyword">if</span> (subr &gt; DIF_SUBR_MAX)
				err += efunc(pc, <span class="enscript-string">&quot;invalid subr %u\n&quot;</span>, subr);
			<span class="enscript-keyword">if</span> (rd &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, rd);
			<span class="enscript-keyword">if</span> (rd == 0)
				err += efunc(pc, <span class="enscript-string">&quot;cannot write to %r0\n&quot;</span>);

			<span class="enscript-keyword">if</span> (subr == DIF_SUBR_COPYOUT ||
			    subr == DIF_SUBR_COPYOUTSTR) {
				dp-&gt;dtdo_destructive = 1;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_PUSHTR</span>:
			<span class="enscript-keyword">if</span> (type != DIF_TYPE_STRING &amp;&amp; type != DIF_TYPE_CTF)
				err += efunc(pc, <span class="enscript-string">&quot;invalid ref type %u\n&quot;</span>, type);
			<span class="enscript-keyword">if</span> (r2 &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, r2);
			<span class="enscript-keyword">if</span> (rs &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, rs);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_PUSHTV</span>:
			<span class="enscript-keyword">if</span> (type != DIF_TYPE_CTF)
				err += efunc(pc, <span class="enscript-string">&quot;invalid val type %u\n&quot;</span>, type);
			<span class="enscript-keyword">if</span> (r2 &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, r2);
			<span class="enscript-keyword">if</span> (rs &gt;= nregs)
				err += efunc(pc, <span class="enscript-string">&quot;invalid register %u\n&quot;</span>, rs);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			err += efunc(pc, <span class="enscript-string">&quot;invalid opcode %u\n&quot;</span>,
			    DIF_INSTR_OP(instr));
		}
	}

	<span class="enscript-keyword">if</span> (dp-&gt;dtdo_len != 0 &amp;&amp;
	    DIF_INSTR_OP(dp-&gt;dtdo_buf[dp-&gt;dtdo_len - 1]) != DIF_OP_RET) {
		err += efunc(dp-&gt;dtdo_len - 1,
		    <span class="enscript-string">&quot;expected 'ret' as last DIF instruction\n&quot;</span>);
	}

	<span class="enscript-keyword">if</span> (!(dp-&gt;dtdo_rtype.dtdt_flags &amp; (DIF_TF_BYREF | DIF_TF_BYUREF))) {
		<span class="enscript-comment">/*
		 * If we're not returning by reference, the size must be either
		 * 0 or the size of one of the base types.
		 */</span>
		<span class="enscript-keyword">switch</span> (dp-&gt;dtdo_rtype.dtdt_size) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">sizeof</span> (uint8_t):
		<span class="enscript-keyword">case</span> <span class="enscript-reference">sizeof</span> (uint16_t):
		<span class="enscript-keyword">case</span> <span class="enscript-reference">sizeof</span> (uint32_t):
		<span class="enscript-keyword">case</span> <span class="enscript-reference">sizeof</span> (uint64_t):
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			err += efunc(dp-&gt;dtdo_len - 1, <span class="enscript-string">&quot;bad return size\n&quot;</span>);
		}
	}

	<span class="enscript-keyword">for</span> (i = 0; i &lt; dp-&gt;dtdo_varlen &amp;&amp; err == 0; i++) {
		dtrace_difv_t *v = &amp;dp-&gt;dtdo_vartab[i], *existing = NULL;
		dtrace_diftype_t *vt, *et;
		uint_t id;
		<span class="enscript-type">int</span> ndx;

		<span class="enscript-keyword">if</span> (v-&gt;dtdv_scope != DIFV_SCOPE_GLOBAL &amp;&amp;
		    v-&gt;dtdv_scope != DIFV_SCOPE_THREAD &amp;&amp;
		    v-&gt;dtdv_scope != DIFV_SCOPE_LOCAL) {
			err += efunc(i, <span class="enscript-string">&quot;unrecognized variable scope %d\n&quot;</span>,
			    v-&gt;dtdv_scope);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (v-&gt;dtdv_kind != DIFV_KIND_ARRAY &amp;&amp;
		    v-&gt;dtdv_kind != DIFV_KIND_SCALAR) {
			err += efunc(i, <span class="enscript-string">&quot;unrecognized variable type %d\n&quot;</span>,
			    v-&gt;dtdv_kind);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> ((id = v-&gt;dtdv_id) &gt; DIF_VARIABLE_MAX) {
			err += efunc(i, <span class="enscript-string">&quot;%d exceeds variable id limit\n&quot;</span>, id);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (id &lt; DIF_VAR_OTHER_UBASE)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * For user-defined variables, we need to check that this
		 * definition is identical to any previous definition that we
		 * encountered.
		 */</span>
		ndx = id - DIF_VAR_OTHER_UBASE;

		<span class="enscript-keyword">switch</span> (v-&gt;dtdv_scope) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIFV_SCOPE_GLOBAL</span>:
			<span class="enscript-keyword">if</span> (ndx &lt; vstate-&gt;dtvs_nglobals) {
				dtrace_statvar_t *svar;

				<span class="enscript-keyword">if</span> ((svar = vstate-&gt;dtvs_globals[ndx]) != NULL)
					existing = &amp;svar-&gt;dtsv_var;
			}

			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIFV_SCOPE_THREAD</span>:
			<span class="enscript-keyword">if</span> (ndx &lt; vstate-&gt;dtvs_ntlocals)
				existing = &amp;vstate-&gt;dtvs_tlocals[ndx];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIFV_SCOPE_LOCAL</span>:
			<span class="enscript-keyword">if</span> (ndx &lt; vstate-&gt;dtvs_nlocals) {
				dtrace_statvar_t *svar;

				<span class="enscript-keyword">if</span> ((svar = vstate-&gt;dtvs_locals[ndx]) != NULL)
					existing = &amp;svar-&gt;dtsv_var;
			}

			<span class="enscript-keyword">break</span>;
		}

		vt = &amp;v-&gt;dtdv_type;

		<span class="enscript-keyword">if</span> (vt-&gt;dtdt_flags &amp; DIF_TF_BYREF) {
			<span class="enscript-keyword">if</span> (vt-&gt;dtdt_size == 0) {
				err += efunc(i, <span class="enscript-string">&quot;zero-sized variable\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (v-&gt;dtdv_scope == DIFV_SCOPE_GLOBAL &amp;&amp;
			    vt-&gt;dtdt_size &gt; dtrace_global_maxsize) {
				err += efunc(i, <span class="enscript-string">&quot;oversized by-ref global\n&quot;</span>);
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> (existing == NULL || existing-&gt;dtdv_id == 0)
			<span class="enscript-keyword">continue</span>;

		ASSERT(existing-&gt;dtdv_id == v-&gt;dtdv_id);
		ASSERT(existing-&gt;dtdv_scope == v-&gt;dtdv_scope);

		<span class="enscript-keyword">if</span> (existing-&gt;dtdv_kind != v-&gt;dtdv_kind)
			err += efunc(i, <span class="enscript-string">&quot;%d changed variable kind\n&quot;</span>, id);

		et = &amp;existing-&gt;dtdv_type;

		<span class="enscript-keyword">if</span> (vt-&gt;dtdt_flags != et-&gt;dtdt_flags) {
			err += efunc(i, <span class="enscript-string">&quot;%d changed variable type flags\n&quot;</span>, id);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (vt-&gt;dtdt_size != 0 &amp;&amp; vt-&gt;dtdt_size != et-&gt;dtdt_size) {
			err += efunc(i, <span class="enscript-string">&quot;%d changed variable type size\n&quot;</span>, id);
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-comment">/*
 * Validate a DTrace DIF object that it is to be used as a helper.  Helpers
 * are much more constrained than normal DIFOs.  Specifically, they may
 * not:
 *
 * 1. Make calls to subroutines other than copyin(), copyinstr() or
 *    miscellaneous string routines
 * 2. Access DTrace variables other than the args[] array, and the
 *    curthread, pid, ppid, tid, execname, zonename, uid and gid variables.
 * 3. Have thread-local variables.
 * 4. Have dynamic variables.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_difo_validate_helper</span>(dtrace_difo_t *dp)
{
	<span class="enscript-type">int</span> (*efunc)(uint_t pc, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, ...) = dtrace_difo_err;
	<span class="enscript-type">int</span> err = 0;
	uint_t pc;

	<span class="enscript-keyword">for</span> (pc = 0; pc &lt; dp-&gt;dtdo_len; pc++) {
		dif_instr_t instr = dp-&gt;dtdo_buf[pc];

		uint_t v = DIF_INSTR_VAR(instr);
		uint_t subr = DIF_INSTR_SUBR(instr);
		uint_t op = DIF_INSTR_OP(instr);

		<span class="enscript-keyword">switch</span> (op) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_OR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_XOR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_AND</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SLL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SRL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SRA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SUB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ADD</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_MUL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SDIV</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_UDIV</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SREM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_UREM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_COPYS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_NOT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_MOV</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDSB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDSH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDSW</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDUB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDUH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDUW</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RLDX</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDSB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDSH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDSW</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDUB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDUH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDUW</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ULDX</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STW</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STX</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_ALLOCS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_CMP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SCMP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_TST</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BNE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BG</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BGU</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BGE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BGEU</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BLU</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BLE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_BLEU</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_RET</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_NOP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_POPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_FLUSHTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SETX</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SETS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDGA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDLS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STGS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STLS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_PUSHTR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_PUSHTV</span>:
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDGS</span>:
			<span class="enscript-keyword">if</span> (v &gt;= DIF_VAR_OTHER_UBASE)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (v &gt;= DIF_VAR_ARG0 &amp;&amp; v &lt;= DIF_VAR_ARG9)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (v == DIF_VAR_CURTHREAD || v == DIF_VAR_PID ||
			    v == DIF_VAR_PPID || v == DIF_VAR_TID ||
			    v == DIF_VAR_EXECNAME || v == DIF_VAR_ZONENAME ||
			    v == DIF_VAR_UID || v == DIF_VAR_GID)
				<span class="enscript-keyword">break</span>;

			err += efunc(pc, <span class="enscript-string">&quot;illegal variable %u\n&quot;</span>, v);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDTA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDGAA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_LDTAA</span>:
			err += efunc(pc, <span class="enscript-string">&quot;illegal dynamic variable load\n&quot;</span>);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STGAA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STTAA</span>:
			err += efunc(pc, <span class="enscript-string">&quot;illegal dynamic variable store\n&quot;</span>);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_CALL</span>:
			<span class="enscript-keyword">if</span> (subr == DIF_SUBR_ALLOCA ||
			    subr == DIF_SUBR_BCOPY ||
			    subr == DIF_SUBR_COPYIN ||
			    subr == DIF_SUBR_COPYINTO ||
			    subr == DIF_SUBR_COPYINSTR ||
			    subr == DIF_SUBR_INDEX ||
			    subr == DIF_SUBR_INET_NTOA ||
			    subr == DIF_SUBR_INET_NTOA6 ||
			    subr == DIF_SUBR_INET_NTOP ||
			    subr == DIF_SUBR_LLTOSTR ||
			    subr == DIF_SUBR_RINDEX ||
			    subr == DIF_SUBR_STRCHR ||
			    subr == DIF_SUBR_STRJOIN ||
			    subr == DIF_SUBR_STRRCHR ||
			    subr == DIF_SUBR_STRSTR ||
			    subr == DIF_SUBR_COREPROFILE ||
			    subr == DIF_SUBR_HTONS ||
			    subr == DIF_SUBR_HTONL ||
			    subr == DIF_SUBR_HTONLL ||
			    subr == DIF_SUBR_NTOHS ||
			    subr == DIF_SUBR_NTOHL ||
			    subr == DIF_SUBR_NTOHLL)
				<span class="enscript-keyword">break</span>;

			err += efunc(pc, <span class="enscript-string">&quot;invalid subr %u\n&quot;</span>, subr);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			err += efunc(pc, <span class="enscript-string">&quot;invalid opcode %u\n&quot;</span>,
			    DIF_INSTR_OP(instr));
		}
	}

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-comment">/*
 * Returns 1 if the expression in the DIF object can be cached on a per-thread
 * basis; 0 if not.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_difo_cacheable</span>(dtrace_difo_t *dp)
{
	uint_t i;

	<span class="enscript-keyword">if</span> (dp == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; dp-&gt;dtdo_varlen; i++) {
		dtrace_difv_t *v = &amp;dp-&gt;dtdo_vartab[i];

		<span class="enscript-keyword">if</span> (v-&gt;dtdv_scope != DIFV_SCOPE_GLOBAL)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">switch</span> (v-&gt;dtdv_id) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_CURTHREAD</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_PID</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_TID</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_EXECNAME</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_VAR_ZONENAME</span>:
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (0);
		}
	}

	<span class="enscript-comment">/*
	 * This DIF object may be cacheable.  Now we need to look for any
	 * array loading instructions, any memory loading instructions, or
	 * any stores to thread-local variables.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; dp-&gt;dtdo_len; i++) {
		uint_t op = DIF_INSTR_OP(dp-&gt;dtdo_buf[i]);

		<span class="enscript-keyword">if</span> ((op &gt;= DIF_OP_LDSB &amp;&amp; op &lt;= DIF_OP_LDX) ||
		    (op &gt;= DIF_OP_ULDSB &amp;&amp; op &lt;= DIF_OP_ULDX) ||
		    (op &gt;= DIF_OP_RLDSB &amp;&amp; op &lt;= DIF_OP_RLDX) ||
		    op == DIF_OP_LDGA || op == DIF_OP_STTS)
			<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_difo_hold</span>(dtrace_difo_t *dp)
{
	uint_t i;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	dp-&gt;dtdo_refcnt++;
	ASSERT(dp-&gt;dtdo_refcnt != 0);

	<span class="enscript-comment">/*
	 * We need to check this DIF object for references to the variable
	 * DIF_VAR_VTIMESTAMP.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; dp-&gt;dtdo_varlen; i++) {
		dtrace_difv_t *v = &amp;dp-&gt;dtdo_vartab[i];

		<span class="enscript-keyword">if</span> (v-&gt;dtdv_id != DIF_VAR_VTIMESTAMP)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (dtrace_vtime_references++ == 0)
			dtrace_vtime_enable();
	}
}

<span class="enscript-comment">/*
 * This routine calculates the dynamic variable chunksize for a given DIF
 * object.  The calculation is not fool-proof, and can probably be tricked by
 * malicious DIF -- but it works for all compiler-generated DIF.  Because this
 * calculation is likely imperfect, dtrace_dynvar() is able to gracefully fail
 * if a dynamic variable size exceeds the chunksize.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_difo_chunksize</span>(dtrace_difo_t *dp, dtrace_vstate_t *vstate)
{
	uint64_t sval = 0;
	dtrace_key_t tupregs[DIF_DTR_NREGS + 2]; <span class="enscript-comment">/* +2 for thread and id */</span>
	<span class="enscript-type">const</span> dif_instr_t *text = dp-&gt;dtdo_buf;
	uint_t pc, srd = 0;
	uint_t ttop = 0;
	size_t size, ksize;
	uint_t id, i;

	<span class="enscript-keyword">for</span> (pc = 0; pc &lt; dp-&gt;dtdo_len; pc++) {
		dif_instr_t instr = text[pc];
		uint_t op = DIF_INSTR_OP(instr);
		uint_t rd = DIF_INSTR_RD(instr);
		uint_t r1 = DIF_INSTR_R1(instr);
		uint_t nkeys = 0;
		uchar_t scope;

		dtrace_key_t *key = tupregs;

		<span class="enscript-keyword">switch</span> (op) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_SETX</span>:
			sval = dp-&gt;dtdo_inttab[DIF_INSTR_INTEGER(instr)];
			srd = rd;
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STTS</span>:
			key = &amp;tupregs[DIF_DTR_NREGS];
			key[0].dttk_size = 0;
			key[1].dttk_size = 0;
			nkeys = 2;
			scope = DIFV_SCOPE_THREAD;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STGAA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_STTAA</span>:
			nkeys = ttop;

			<span class="enscript-keyword">if</span> (DIF_INSTR_OP(instr) == DIF_OP_STTAA)
				key[nkeys++].dttk_size = 0;

			key[nkeys++].dttk_size = 0;

			<span class="enscript-keyword">if</span> (op == DIF_OP_STTAA) {
				scope = DIFV_SCOPE_THREAD;
			} <span class="enscript-keyword">else</span> {
				scope = DIFV_SCOPE_GLOBAL;
			}

			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_PUSHTR</span>:
			<span class="enscript-keyword">if</span> (ttop == DIF_DTR_NREGS)
				<span class="enscript-keyword">return</span>;

			<span class="enscript-keyword">if</span> ((srd == 0 || sval == 0) &amp;&amp; r1 == DIF_TYPE_STRING) {
				<span class="enscript-comment">/*
				 * If the register for the size of the &quot;pushtr&quot;
				 * is %r0 (or the value is 0) and the type is
				 * a string, we'll use the system-wide default
				 * string size.
				 */</span>
				tupregs[ttop++].dttk_size =
				    dtrace_strsize_default;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (srd == 0)
					<span class="enscript-keyword">return</span>;

				tupregs[ttop++].dttk_size = sval;
			}

			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_PUSHTV</span>:
			<span class="enscript-keyword">if</span> (ttop == DIF_DTR_NREGS)
				<span class="enscript-keyword">return</span>;

			tupregs[ttop++].dttk_size = 0;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_FLUSHTS</span>:
			ttop = 0;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIF_OP_POPTS</span>:
			<span class="enscript-keyword">if</span> (ttop != 0)
				ttop--;
			<span class="enscript-keyword">break</span>;
		}

		sval = 0;
		srd = 0;

		<span class="enscript-keyword">if</span> (nkeys == 0)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * We have a dynamic variable allocation; calculate its size.
		 */</span>
		<span class="enscript-keyword">for</span> (ksize = 0, i = 0; i &lt; nkeys; i++)
			ksize += P2ROUNDUP(key[i].dttk_size, <span class="enscript-keyword">sizeof</span> (uint64_t));

		size = <span class="enscript-keyword">sizeof</span> (dtrace_dynvar_t);
		size += <span class="enscript-keyword">sizeof</span> (dtrace_key_t) * (nkeys - 1);
		size += ksize;

		<span class="enscript-comment">/*
		 * Now we need to determine the size of the stored data.
		 */</span>
		id = DIF_INSTR_VAR(instr);

		<span class="enscript-keyword">for</span> (i = 0; i &lt; dp-&gt;dtdo_varlen; i++) {
			dtrace_difv_t *v = &amp;dp-&gt;dtdo_vartab[i];

			<span class="enscript-keyword">if</span> (v-&gt;dtdv_id == id &amp;&amp; v-&gt;dtdv_scope == scope) {
				size += v-&gt;dtdv_type.dtdt_size;
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> (i == dp-&gt;dtdo_varlen)
			<span class="enscript-keyword">return</span>;

		<span class="enscript-comment">/*
		 * We have the size.  If this is larger than the chunk size
		 * for our dynamic variable state, reset the chunk size.
		 */</span>
		size = P2ROUNDUP(size, <span class="enscript-keyword">sizeof</span> (uint64_t));

		<span class="enscript-keyword">if</span> (size &gt; vstate-&gt;dtvs_dynvars.dtds_chunksize)
			vstate-&gt;dtvs_dynvars.dtds_chunksize = size;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_difo_init</span>(dtrace_difo_t *dp, dtrace_vstate_t *vstate)
{
	<span class="enscript-type">int</span> oldsvars, osz, nsz, otlocals, ntlocals;
	uint_t i, id;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	ASSERT(dp-&gt;dtdo_buf != NULL &amp;&amp; dp-&gt;dtdo_len != 0);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; dp-&gt;dtdo_varlen; i++) {
		dtrace_difv_t *v = &amp;dp-&gt;dtdo_vartab[i];
		dtrace_statvar_t *svar;
		dtrace_statvar_t ***svarp = NULL;
		size_t dsize = 0;
		uint8_t scope = v-&gt;dtdv_scope;
		<span class="enscript-type">int</span> *np = (<span class="enscript-type">int</span> *)NULL;

		<span class="enscript-keyword">if</span> ((id = v-&gt;dtdv_id) &lt; DIF_VAR_OTHER_UBASE)
			<span class="enscript-keyword">continue</span>;

		id -= DIF_VAR_OTHER_UBASE;

		<span class="enscript-keyword">switch</span> (scope) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIFV_SCOPE_THREAD</span>:
			<span class="enscript-keyword">while</span> (id &gt;= (uint_t)(otlocals = vstate-&gt;dtvs_ntlocals)) {
				dtrace_difv_t *tlocals;

				<span class="enscript-keyword">if</span> ((ntlocals = (otlocals &lt;&lt; 1)) == 0)
					ntlocals = 1;

				osz = otlocals * <span class="enscript-keyword">sizeof</span> (dtrace_difv_t);
				nsz = ntlocals * <span class="enscript-keyword">sizeof</span> (dtrace_difv_t);

				tlocals = kmem_zalloc(nsz, KM_SLEEP);

				<span class="enscript-keyword">if</span> (osz != 0) {
					bcopy(vstate-&gt;dtvs_tlocals,
					    tlocals, osz);
					kmem_free(vstate-&gt;dtvs_tlocals, osz);
				}

				vstate-&gt;dtvs_tlocals = tlocals;
				vstate-&gt;dtvs_ntlocals = ntlocals;
			}

			vstate-&gt;dtvs_tlocals[id] = *v;
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIFV_SCOPE_LOCAL</span>:
			np = &amp;vstate-&gt;dtvs_nlocals;
			svarp = &amp;vstate-&gt;dtvs_locals;

			<span class="enscript-keyword">if</span> (v-&gt;dtdv_type.dtdt_flags &amp; DIF_TF_BYREF)
				dsize = (<span class="enscript-type">int</span>)NCPU * (v-&gt;dtdv_type.dtdt_size +
				    <span class="enscript-keyword">sizeof</span> (uint64_t));
			<span class="enscript-keyword">else</span>
				dsize = (<span class="enscript-type">int</span>)NCPU * <span class="enscript-keyword">sizeof</span> (uint64_t);

			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIFV_SCOPE_GLOBAL</span>:
			np = &amp;vstate-&gt;dtvs_nglobals;
			svarp = &amp;vstate-&gt;dtvs_globals;

			<span class="enscript-keyword">if</span> (v-&gt;dtdv_type.dtdt_flags &amp; DIF_TF_BYREF)
				dsize = v-&gt;dtdv_type.dtdt_size +
				    <span class="enscript-keyword">sizeof</span> (uint64_t);

			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			ASSERT(0);
		}

		<span class="enscript-keyword">while</span> (id &gt;= (uint_t)(oldsvars = *np)) {
			dtrace_statvar_t **statics;
			<span class="enscript-type">int</span> newsvars, oldsize, newsize;

			<span class="enscript-keyword">if</span> ((newsvars = (oldsvars &lt;&lt; 1)) == 0)
				newsvars = 1;

			oldsize = oldsvars * <span class="enscript-keyword">sizeof</span> (dtrace_statvar_t *);
			newsize = newsvars * <span class="enscript-keyword">sizeof</span> (dtrace_statvar_t *);

			statics = kmem_zalloc(newsize, KM_SLEEP);

			<span class="enscript-keyword">if</span> (oldsize != 0) {
				bcopy(*svarp, statics, oldsize);
				kmem_free(*svarp, oldsize);
			}

			*svarp = statics;
			*np = newsvars;
		}

		<span class="enscript-keyword">if</span> ((svar = (*svarp)[id]) == NULL) {
			svar = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_statvar_t), KM_SLEEP);
			svar-&gt;dtsv_var = *v;

			<span class="enscript-keyword">if</span> ((svar-&gt;dtsv_size = dsize) != 0) {
				svar-&gt;dtsv_data = (uint64_t)(uintptr_t)
				    kmem_zalloc(dsize, KM_SLEEP);
			}

			(*svarp)[id] = svar;
		}

		svar-&gt;dtsv_refcnt++;
	}

	dtrace_difo_chunksize(dp, vstate);
	dtrace_difo_hold(dp);
}

<span class="enscript-type">static</span> dtrace_difo_t *
<span class="enscript-function-name">dtrace_difo_duplicate</span>(dtrace_difo_t *dp, dtrace_vstate_t *vstate)
{
	dtrace_difo_t *new;
	size_t sz;

	ASSERT(dp-&gt;dtdo_buf != NULL);
	ASSERT(dp-&gt;dtdo_refcnt != 0);

	new = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_difo_t), KM_SLEEP);

	ASSERT(dp-&gt;dtdo_buf != NULL);
	sz = dp-&gt;dtdo_len * <span class="enscript-keyword">sizeof</span> (dif_instr_t);
	new-&gt;dtdo_buf = kmem_alloc(sz, KM_SLEEP);
	bcopy(dp-&gt;dtdo_buf, new-&gt;dtdo_buf, sz);
	new-&gt;dtdo_len = dp-&gt;dtdo_len;

	<span class="enscript-keyword">if</span> (dp-&gt;dtdo_strtab != NULL) {
		ASSERT(dp-&gt;dtdo_strlen != 0);
		new-&gt;dtdo_strtab = kmem_alloc(dp-&gt;dtdo_strlen, KM_SLEEP);
		bcopy(dp-&gt;dtdo_strtab, new-&gt;dtdo_strtab, dp-&gt;dtdo_strlen);
		new-&gt;dtdo_strlen = dp-&gt;dtdo_strlen;
	}

	<span class="enscript-keyword">if</span> (dp-&gt;dtdo_inttab != NULL) {
		ASSERT(dp-&gt;dtdo_intlen != 0);
		sz = dp-&gt;dtdo_intlen * <span class="enscript-keyword">sizeof</span> (uint64_t);
		new-&gt;dtdo_inttab = kmem_alloc(sz, KM_SLEEP);
		bcopy(dp-&gt;dtdo_inttab, new-&gt;dtdo_inttab, sz);
		new-&gt;dtdo_intlen = dp-&gt;dtdo_intlen;
	}

	<span class="enscript-keyword">if</span> (dp-&gt;dtdo_vartab != NULL) {
		ASSERT(dp-&gt;dtdo_varlen != 0);
		sz = dp-&gt;dtdo_varlen * <span class="enscript-keyword">sizeof</span> (dtrace_difv_t);
		new-&gt;dtdo_vartab = kmem_alloc(sz, KM_SLEEP);
		bcopy(dp-&gt;dtdo_vartab, new-&gt;dtdo_vartab, sz);
		new-&gt;dtdo_varlen = dp-&gt;dtdo_varlen;
	}

	dtrace_difo_init(new, vstate);
	<span class="enscript-keyword">return</span> (new);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_difo_destroy</span>(dtrace_difo_t *dp, dtrace_vstate_t *vstate)
{
	uint_t i;

	ASSERT(dp-&gt;dtdo_refcnt == 0);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; dp-&gt;dtdo_varlen; i++) {
		dtrace_difv_t *v = &amp;dp-&gt;dtdo_vartab[i];
		dtrace_statvar_t *svar;
		dtrace_statvar_t **svarp = NULL;
		uint_t id;
		uint8_t scope = v-&gt;dtdv_scope;
		<span class="enscript-type">int</span> *np = NULL;

		<span class="enscript-keyword">switch</span> (scope) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIFV_SCOPE_THREAD</span>:
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIFV_SCOPE_LOCAL</span>:
			np = &amp;vstate-&gt;dtvs_nlocals;
			svarp = vstate-&gt;dtvs_locals;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DIFV_SCOPE_GLOBAL</span>:
			np = &amp;vstate-&gt;dtvs_nglobals;
			svarp = vstate-&gt;dtvs_globals;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			ASSERT(0);
		}

		<span class="enscript-keyword">if</span> ((id = v-&gt;dtdv_id) &lt; DIF_VAR_OTHER_UBASE)
			<span class="enscript-keyword">continue</span>;

		id -= DIF_VAR_OTHER_UBASE;
		
		ASSERT(id &lt; (uint_t)*np);

		svar = svarp[id];
		ASSERT(svar != NULL);
		ASSERT(svar-&gt;dtsv_refcnt &gt; 0);

		<span class="enscript-keyword">if</span> (--svar-&gt;dtsv_refcnt &gt; 0)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (svar-&gt;dtsv_size != 0) {
			ASSERT(svar-&gt;dtsv_data != 0);
			kmem_free((<span class="enscript-type">void</span> *)(uintptr_t)svar-&gt;dtsv_data,
			    svar-&gt;dtsv_size);
		}

		kmem_free(svar, <span class="enscript-keyword">sizeof</span> (dtrace_statvar_t));
		svarp[id] = NULL;
	}

	kmem_free(dp-&gt;dtdo_buf, dp-&gt;dtdo_len * <span class="enscript-keyword">sizeof</span> (dif_instr_t));
	kmem_free(dp-&gt;dtdo_inttab, dp-&gt;dtdo_intlen * <span class="enscript-keyword">sizeof</span> (uint64_t));
	kmem_free(dp-&gt;dtdo_strtab, dp-&gt;dtdo_strlen);
	kmem_free(dp-&gt;dtdo_vartab, dp-&gt;dtdo_varlen * <span class="enscript-keyword">sizeof</span> (dtrace_difv_t));

	kmem_free(dp, <span class="enscript-keyword">sizeof</span> (dtrace_difo_t));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_difo_release</span>(dtrace_difo_t *dp, dtrace_vstate_t *vstate)
{
	uint_t i;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	ASSERT(dp-&gt;dtdo_refcnt != 0);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; dp-&gt;dtdo_varlen; i++) {
		dtrace_difv_t *v = &amp;dp-&gt;dtdo_vartab[i];

		<span class="enscript-keyword">if</span> (v-&gt;dtdv_id != DIF_VAR_VTIMESTAMP)
			<span class="enscript-keyword">continue</span>;

		ASSERT(dtrace_vtime_references &gt; 0);
		<span class="enscript-keyword">if</span> (--dtrace_vtime_references == 0)
			dtrace_vtime_disable();
	}

	<span class="enscript-keyword">if</span> (--dp-&gt;dtdo_refcnt == 0)
		dtrace_difo_destroy(dp, vstate);
}

<span class="enscript-comment">/*
 * DTrace Format Functions
 */</span>
<span class="enscript-type">static</span> uint16_t
<span class="enscript-function-name">dtrace_format_add</span>(dtrace_state_t *state, <span class="enscript-type">char</span> *str)
{
	<span class="enscript-type">char</span> *fmt, **new;
	uint16_t ndx, len = strlen(str) + 1;

	fmt = kmem_zalloc(len, KM_SLEEP);
	bcopy(str, fmt, len);

	<span class="enscript-keyword">for</span> (ndx = 0; ndx &lt; state-&gt;dts_nformats; ndx++) {
		<span class="enscript-keyword">if</span> (state-&gt;dts_formats[ndx] == NULL) {
			state-&gt;dts_formats[ndx] = fmt;
			<span class="enscript-keyword">return</span> (ndx + 1);
		}
	}

	<span class="enscript-keyword">if</span> (state-&gt;dts_nformats == USHRT_MAX) {
		<span class="enscript-comment">/*
		 * This is only likely if a denial-of-service attack is being
		 * attempted.  As such, it's okay to fail silently here.
		 */</span>
		kmem_free(fmt, len);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * For simplicity, we always resize the formats array to be exactly the
	 * number of formats.
	 */</span>
	ndx = state-&gt;dts_nformats++;
	new = kmem_alloc((ndx + 1) * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">char</span> *), KM_SLEEP);

	<span class="enscript-keyword">if</span> (state-&gt;dts_formats != NULL) {
		ASSERT(ndx != 0);
		bcopy(state-&gt;dts_formats, new, ndx * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">char</span> *));
		kmem_free(state-&gt;dts_formats, ndx * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">char</span> *));
	}

	state-&gt;dts_formats = new;
	state-&gt;dts_formats[ndx] = fmt;

	<span class="enscript-keyword">return</span> (ndx + 1);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_format_remove</span>(dtrace_state_t *state, uint16_t format)
{
	<span class="enscript-type">char</span> *fmt;

	ASSERT(state-&gt;dts_formats != NULL);
	ASSERT(format &lt;= state-&gt;dts_nformats);
	ASSERT(state-&gt;dts_formats[format - 1] != NULL);

	fmt = state-&gt;dts_formats[format - 1];
	kmem_free(fmt, strlen(fmt) + 1);
	state-&gt;dts_formats[format - 1] = NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_format_destroy</span>(dtrace_state_t *state)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (state-&gt;dts_nformats == 0) {
		ASSERT(state-&gt;dts_formats == NULL);
		<span class="enscript-keyword">return</span>;
	}

	ASSERT(state-&gt;dts_formats != NULL);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; state-&gt;dts_nformats; i++) {
		<span class="enscript-type">char</span> *fmt = state-&gt;dts_formats[i];

		<span class="enscript-keyword">if</span> (fmt == NULL)
			<span class="enscript-keyword">continue</span>;

		kmem_free(fmt, strlen(fmt) + 1);
	}

	kmem_free(state-&gt;dts_formats, state-&gt;dts_nformats * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">char</span> *));
	state-&gt;dts_nformats = 0;
	state-&gt;dts_formats = NULL;
}

<span class="enscript-comment">/*
 * DTrace Predicate Functions
 */</span>
<span class="enscript-type">static</span> dtrace_predicate_t *
<span class="enscript-function-name">dtrace_predicate_create</span>(dtrace_difo_t *dp)
{
	dtrace_predicate_t *pred;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	ASSERT(dp-&gt;dtdo_refcnt != 0);

	pred = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_predicate_t), KM_SLEEP);
	pred-&gt;dtp_difo = dp;
	pred-&gt;dtp_refcnt = 1;

	<span class="enscript-keyword">if</span> (!dtrace_difo_cacheable(dp))
		<span class="enscript-keyword">return</span> (pred);

	<span class="enscript-keyword">if</span> (dtrace_predcache_id == DTRACE_CACHEIDNONE) {
		<span class="enscript-comment">/*
		 * This is only theoretically possible -- we have had 2^32
		 * cacheable predicates on this machine.  We cannot allow any
		 * more predicates to become cacheable:  as unlikely as it is,
		 * there may be a thread caching a (now stale) predicate cache
		 * ID. (N.B.: the temptation is being successfully resisted to
		 * have this cmn_err() &quot;Holy shit -- we executed this code!&quot;)
		 */</span>
		<span class="enscript-keyword">return</span> (pred);
	}

	pred-&gt;dtp_cacheid = dtrace_predcache_id++;

	<span class="enscript-keyword">return</span> (pred);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_predicate_hold</span>(dtrace_predicate_t *pred)
{
	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	ASSERT(pred-&gt;dtp_difo != NULL &amp;&amp; pred-&gt;dtp_difo-&gt;dtdo_refcnt != 0);
	ASSERT(pred-&gt;dtp_refcnt &gt; 0);

	pred-&gt;dtp_refcnt++;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_predicate_release</span>(dtrace_predicate_t *pred, dtrace_vstate_t *vstate)
{
	dtrace_difo_t *dp = pred-&gt;dtp_difo;
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dp</span>) <span class="enscript-comment">/* __APPLE__ */</span>

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	ASSERT(dp != NULL &amp;&amp; dp-&gt;dtdo_refcnt != 0);
	ASSERT(pred-&gt;dtp_refcnt &gt; 0);

	<span class="enscript-keyword">if</span> (--pred-&gt;dtp_refcnt == 0) {
		dtrace_difo_release(pred-&gt;dtp_difo, vstate);
		kmem_free(pred, <span class="enscript-keyword">sizeof</span> (dtrace_predicate_t));
	}
}

<span class="enscript-comment">/*
 * DTrace Action Description Functions
 */</span>
<span class="enscript-type">static</span> dtrace_actdesc_t *
<span class="enscript-function-name">dtrace_actdesc_create</span>(dtrace_actkind_t kind, uint32_t ntuple,
    uint64_t uarg, uint64_t arg)
{
	dtrace_actdesc_t *act;

	ASSERT(!DTRACEACT_ISPRINTFLIKE(kind) || (arg != 0 &amp;&amp;
	    arg &gt;= KERNELBASE) || (arg == 0 &amp;&amp; kind == DTRACEACT_PRINTA));

	act = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_actdesc_t), KM_SLEEP);
	act-&gt;dtad_kind = kind;
	act-&gt;dtad_ntuple = ntuple;
	act-&gt;dtad_uarg = uarg;
	act-&gt;dtad_arg = arg;
	act-&gt;dtad_refcnt = 1;

	<span class="enscript-keyword">return</span> (act);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_actdesc_hold</span>(dtrace_actdesc_t *act)
{
	ASSERT(act-&gt;dtad_refcnt &gt;= 1);
	act-&gt;dtad_refcnt++;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_actdesc_release</span>(dtrace_actdesc_t *act, dtrace_vstate_t *vstate)
{
	dtrace_actkind_t kind = act-&gt;dtad_kind;
	dtrace_difo_t *dp;

	ASSERT(act-&gt;dtad_refcnt &gt;= 1);

	<span class="enscript-keyword">if</span> (--act-&gt;dtad_refcnt != 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ((dp = act-&gt;dtad_difo) != NULL)
		dtrace_difo_release(dp, vstate);

	<span class="enscript-keyword">if</span> (DTRACEACT_ISPRINTFLIKE(kind)) {
		<span class="enscript-type">char</span> *str = (<span class="enscript-type">char</span> *)(uintptr_t)act-&gt;dtad_arg;

		ASSERT((str != NULL &amp;&amp; (uintptr_t)str &gt;= KERNELBASE) ||
		    (str == NULL &amp;&amp; act-&gt;dtad_kind == DTRACEACT_PRINTA));

		<span class="enscript-keyword">if</span> (str != NULL)
			kmem_free(str, strlen(str) + 1);
	}

	kmem_free(act, <span class="enscript-keyword">sizeof</span> (dtrace_actdesc_t));
}

<span class="enscript-comment">/*
 * DTrace ECB Functions
 */</span>
<span class="enscript-type">static</span> dtrace_ecb_t *
<span class="enscript-function-name">dtrace_ecb_add</span>(dtrace_state_t *state, dtrace_probe_t *probe)
{
	dtrace_ecb_t *ecb;
	dtrace_epid_t epid;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	ecb = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_ecb_t), KM_SLEEP);
	ecb-&gt;dte_predicate = NULL;
	ecb-&gt;dte_probe = probe;

	<span class="enscript-comment">/*
	 * The default size is the size of the default action: recording
	 * the header.
	 */</span>
	ecb-&gt;dte_size = ecb-&gt;dte_needed = <span class="enscript-keyword">sizeof</span> (dtrace_rechdr_t);
	ecb-&gt;dte_alignment = <span class="enscript-keyword">sizeof</span> (dtrace_epid_t);

	epid = state-&gt;dts_epid++;

	<span class="enscript-keyword">if</span> (epid - 1 &gt;= (dtrace_epid_t)state-&gt;dts_necbs) {
		dtrace_ecb_t **oecbs = state-&gt;dts_ecbs, **ecbs;
		<span class="enscript-type">int</span> necbs = state-&gt;dts_necbs &lt;&lt; 1;

		ASSERT(epid == (dtrace_epid_t)state-&gt;dts_necbs + 1);

		<span class="enscript-keyword">if</span> (necbs == 0) {
			ASSERT(oecbs == NULL);
			necbs = 1;
		}

		ecbs = kmem_zalloc(necbs * <span class="enscript-keyword">sizeof</span> (*ecbs), KM_SLEEP);

		<span class="enscript-keyword">if</span> (oecbs != NULL)
			bcopy(oecbs, ecbs, state-&gt;dts_necbs * <span class="enscript-keyword">sizeof</span> (*ecbs));

		dtrace_membar_producer();
		state-&gt;dts_ecbs = ecbs;

		<span class="enscript-keyword">if</span> (oecbs != NULL) {
			<span class="enscript-comment">/*
			 * If this state is active, we must dtrace_sync()
			 * before we can free the old dts_ecbs array:  we're
			 * coming in hot, and there may be active ring
			 * buffer processing (which indexes into the dts_ecbs
			 * array) on another CPU.
			 */</span>
			<span class="enscript-keyword">if</span> (state-&gt;dts_activity != DTRACE_ACTIVITY_INACTIVE)
				dtrace_sync();

			kmem_free(oecbs, state-&gt;dts_necbs * <span class="enscript-keyword">sizeof</span> (*ecbs));
		}

		dtrace_membar_producer();
		state-&gt;dts_necbs = necbs;
	}

	ecb-&gt;dte_state = state;

	ASSERT(state-&gt;dts_ecbs[epid - 1] == NULL);
	dtrace_membar_producer();
	state-&gt;dts_ecbs[(ecb-&gt;dte_epid = epid) - 1] = ecb;

	<span class="enscript-keyword">return</span> (ecb);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_ecb_enable</span>(dtrace_ecb_t *ecb)
{
	dtrace_probe_t *probe = ecb-&gt;dte_probe;

	lck_mtx_assert(&amp;cpu_lock, LCK_MTX_ASSERT_OWNED);
	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	ASSERT(ecb-&gt;dte_next == NULL);

	<span class="enscript-keyword">if</span> (probe == NULL) {
		<span class="enscript-comment">/*
		 * This is the NULL probe -- there's nothing to do.
		 */</span>
	    <span class="enscript-keyword">return</span>(0);
	}

	probe-&gt;dtpr_provider-&gt;dtpv_ecb_count++;
	<span class="enscript-keyword">if</span> (probe-&gt;dtpr_ecb == NULL) {
		dtrace_provider_t *prov = probe-&gt;dtpr_provider;

		<span class="enscript-comment">/*
		 * We're the first ECB on this probe.
		 */</span>
		probe-&gt;dtpr_ecb = probe-&gt;dtpr_ecb_last = ecb;

		<span class="enscript-keyword">if</span> (ecb-&gt;dte_predicate != NULL)
			probe-&gt;dtpr_predcache = ecb-&gt;dte_predicate-&gt;dtp_cacheid;

		<span class="enscript-keyword">return</span> (prov-&gt;dtpv_pops.dtps_enable(prov-&gt;dtpv_arg,
                    probe-&gt;dtpr_id, probe-&gt;dtpr_arg));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * This probe is already active.  Swing the last pointer to
		 * point to the new ECB, and issue a dtrace_sync() to assure
		 * that all CPUs have seen the change.
		 */</span>
		ASSERT(probe-&gt;dtpr_ecb_last != NULL);
		probe-&gt;dtpr_ecb_last-&gt;dte_next = ecb;
		probe-&gt;dtpr_ecb_last = ecb;
		probe-&gt;dtpr_predcache = 0;

		dtrace_sync();
		<span class="enscript-keyword">return</span>(0);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_ecb_resize</span>(dtrace_ecb_t *ecb)
{
	dtrace_action_t *act;
	uint32_t curneeded = UINT32_MAX;
	uint32_t aggbase = UINT32_MAX;

	<span class="enscript-comment">/*
	 * If we record anything, we always record the dtrace_rechdr_t.  (And
	 * we always record it first.)
	 */</span>
	ecb-&gt;dte_size = <span class="enscript-keyword">sizeof</span> (dtrace_rechdr_t);
	ecb-&gt;dte_alignment = <span class="enscript-keyword">sizeof</span> (dtrace_epid_t);

	<span class="enscript-keyword">for</span> (act = ecb-&gt;dte_action; act != NULL; act = act-&gt;dta_next) {
		dtrace_recdesc_t *rec = &amp;act-&gt;dta_rec;
		ASSERT(rec-&gt;dtrd_size &gt; 0 || rec-&gt;dtrd_alignment == 1);

		ecb-&gt;dte_alignment = MAX(ecb-&gt;dte_alignment, rec-&gt;dtrd_alignment);

		<span class="enscript-keyword">if</span> (DTRACEACT_ISAGG(act-&gt;dta_kind)) {
			dtrace_aggregation_t *agg = (dtrace_aggregation_t *)act;

			ASSERT(rec-&gt;dtrd_size != 0);
			ASSERT(agg-&gt;dtag_first != NULL);
			ASSERT(act-&gt;dta_prev-&gt;dta_intuple);
			ASSERT(aggbase != UINT32_MAX);
			ASSERT(curneeded != UINT32_MAX);

			agg-&gt;dtag_base = aggbase;

			curneeded = P2ROUNDUP(curneeded, rec-&gt;dtrd_alignment);
			rec-&gt;dtrd_offset = curneeded;
			curneeded += rec-&gt;dtrd_size;
			ecb-&gt;dte_needed = MAX(ecb-&gt;dte_needed, curneeded);

			aggbase = UINT32_MAX;
			curneeded = UINT32_MAX;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (act-&gt;dta_intuple) {
			<span class="enscript-keyword">if</span> (curneeded == UINT32_MAX) {
				<span class="enscript-comment">/*
				 * This is the first record in a tuple.  Align
				 * curneeded to be at offset 4 in an 8-byte
				 * aligned block.
				 */</span>
				ASSERT(act-&gt;dta_prev == NULL || !act-&gt;dta_prev-&gt;dta_intuple);
				ASSERT(aggbase == UINT32_MAX);

				curneeded = P2PHASEUP(ecb-&gt;dte_size,
				    <span class="enscript-keyword">sizeof</span> (uint64_t), <span class="enscript-keyword">sizeof</span> (dtrace_aggid_t));

				aggbase = curneeded - <span class="enscript-keyword">sizeof</span> (dtrace_aggid_t);
				ASSERT(IS_P2ALIGNED(aggbase,
				    <span class="enscript-keyword">sizeof</span> (uint64_t)));
			}

			curneeded = P2ROUNDUP(curneeded, rec-&gt;dtrd_alignment);
			rec-&gt;dtrd_offset = curneeded;
			curneeded += rec-&gt;dtrd_size;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* tuples must be followed by an aggregation */</span>
			ASSERT(act-&gt;dta_prev == NULL || !act-&gt;dta_prev-&gt;dta_intuple);
			ecb-&gt;dte_size = P2ROUNDUP(ecb-&gt;dte_size, rec-&gt;dtrd_alignment);
			rec-&gt;dtrd_offset = ecb-&gt;dte_size;
			ecb-&gt;dte_size += rec-&gt;dtrd_size;
			ecb-&gt;dte_needed = MAX(ecb-&gt;dte_needed, ecb-&gt;dte_size);
		}
	}

	<span class="enscript-keyword">if</span> ((act = ecb-&gt;dte_action) != NULL &amp;&amp;
	    !(act-&gt;dta_kind == DTRACEACT_SPECULATE &amp;&amp; act-&gt;dta_next == NULL) &amp;&amp;
	    ecb-&gt;dte_size == <span class="enscript-keyword">sizeof</span> (dtrace_rechdr_t)) {
		<span class="enscript-comment">/*
		 * If the size is still sizeof (dtrace_rechdr_t), then all
		 * actions store no data; set the size to 0.
		 */</span>
		ecb-&gt;dte_size = 0;
	}

	ecb-&gt;dte_size = P2ROUNDUP(ecb-&gt;dte_size, <span class="enscript-keyword">sizeof</span> (dtrace_epid_t));
	ecb-&gt;dte_needed = P2ROUNDUP(ecb-&gt;dte_needed, (<span class="enscript-keyword">sizeof</span> (dtrace_epid_t)));
	ecb-&gt;dte_state-&gt;dts_needed = MAX(ecb-&gt;dte_state-&gt;dts_needed, ecb-&gt;dte_needed);
}

<span class="enscript-type">static</span> dtrace_action_t *
<span class="enscript-function-name">dtrace_ecb_aggregation_create</span>(dtrace_ecb_t *ecb, dtrace_actdesc_t *desc)
{
	dtrace_aggregation_t *agg;
	size_t size = <span class="enscript-keyword">sizeof</span> (uint64_t);
	<span class="enscript-type">int</span> ntuple = desc-&gt;dtad_ntuple;
	dtrace_action_t *act;
	dtrace_recdesc_t *frec;
	dtrace_aggid_t aggid;
	dtrace_state_t *state = ecb-&gt;dte_state;

	agg = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_aggregation_t), KM_SLEEP);
	agg-&gt;dtag_ecb = ecb;

	ASSERT(DTRACEACT_ISAGG(desc-&gt;dtad_kind));

	<span class="enscript-keyword">switch</span> (desc-&gt;dtad_kind) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEAGG_MIN</span>:
		agg-&gt;dtag_initial = INT64_MAX;
		agg-&gt;dtag_aggregate = dtrace_aggregate_min;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEAGG_MAX</span>:
		agg-&gt;dtag_initial = INT64_MIN;
		agg-&gt;dtag_aggregate = dtrace_aggregate_max;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEAGG_COUNT</span>:
		agg-&gt;dtag_aggregate = dtrace_aggregate_count;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEAGG_QUANTIZE</span>:
		agg-&gt;dtag_aggregate = dtrace_aggregate_quantize;
		size = (((<span class="enscript-keyword">sizeof</span> (uint64_t) * NBBY) - 1) * 2 + 1) *
		    <span class="enscript-keyword">sizeof</span> (uint64_t);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEAGG_LQUANTIZE</span>: {
		uint16_t step = DTRACE_LQUANTIZE_STEP(desc-&gt;dtad_arg);
		uint16_t levels = DTRACE_LQUANTIZE_LEVELS(desc-&gt;dtad_arg);

		agg-&gt;dtag_initial = desc-&gt;dtad_arg;
		agg-&gt;dtag_aggregate = dtrace_aggregate_lquantize;

		<span class="enscript-keyword">if</span> (step == 0 || levels == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

		size = levels * <span class="enscript-keyword">sizeof</span> (uint64_t) + 3 * <span class="enscript-keyword">sizeof</span> (uint64_t);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEAGG_LLQUANTIZE</span>: {
		uint16_t factor = DTRACE_LLQUANTIZE_FACTOR(desc-&gt;dtad_arg);
		uint16_t low    = DTRACE_LLQUANTIZE_LOW(desc-&gt;dtad_arg);
		uint16_t high   = DTRACE_LLQUANTIZE_HIGH(desc-&gt;dtad_arg);
		uint16_t nsteps = DTRACE_LLQUANTIZE_NSTEP(desc-&gt;dtad_arg);
		int64_t v;

		agg-&gt;dtag_initial = desc-&gt;dtad_arg;
		agg-&gt;dtag_aggregate = dtrace_aggregate_llquantize;

		<span class="enscript-keyword">if</span> (factor &lt; 2 || low &gt;= high || nsteps &lt; factor)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

		<span class="enscript-comment">/*
		 * Now check that the number of steps evenly divides a power
		 * of the factor.  (This assures both integer bucket size and
		 * linearity within each magnitude.)
		 */</span>
		<span class="enscript-keyword">for</span> (v = factor; v &lt; nsteps; v *= factor)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> ((v % nsteps) || (nsteps % factor))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

 		size = (dtrace_aggregate_llquantize_bucket(factor, low, high, nsteps, INT64_MAX) + 2) * <span class="enscript-keyword">sizeof</span> (uint64_t);
		<span class="enscript-keyword">break</span>;
  }

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEAGG_AVG</span>:
		agg-&gt;dtag_aggregate = dtrace_aggregate_avg;
		size = <span class="enscript-keyword">sizeof</span> (uint64_t) * 2;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEAGG_STDDEV</span>:
		agg-&gt;dtag_aggregate = dtrace_aggregate_stddev;
		size = <span class="enscript-keyword">sizeof</span> (uint64_t) * 4;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEAGG_SUM</span>:
		agg-&gt;dtag_aggregate = dtrace_aggregate_sum;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
	}

	agg-&gt;dtag_action.dta_rec.dtrd_size = size;

	<span class="enscript-keyword">if</span> (ntuple == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

	<span class="enscript-comment">/*
	 * We must make sure that we have enough actions for the n-tuple.
	 */</span>
	<span class="enscript-keyword">for</span> (act = ecb-&gt;dte_action_last; act != NULL; act = act-&gt;dta_prev) {
		<span class="enscript-keyword">if</span> (DTRACEACT_ISAGG(act-&gt;dta_kind))
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (--ntuple == 0) {
			<span class="enscript-comment">/*
			 * This is the action with which our n-tuple begins.
			 */</span>
			agg-&gt;dtag_first = act;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">success</span>;
		}
	}

	<span class="enscript-comment">/*
	 * This n-tuple is short by ntuple elements.  Return failure.
	 */</span>
	ASSERT(ntuple != 0);
<span class="enscript-reference">err</span>:
	kmem_free(agg, <span class="enscript-keyword">sizeof</span> (dtrace_aggregation_t));
	<span class="enscript-keyword">return</span> (NULL);

<span class="enscript-reference">success</span>:
	<span class="enscript-comment">/*
	 * If the last action in the tuple has a size of zero, it's actually
	 * an expression argument for the aggregating action.
	 */</span>
	ASSERT(ecb-&gt;dte_action_last != NULL);
	act = ecb-&gt;dte_action_last;

	<span class="enscript-keyword">if</span> (act-&gt;dta_kind == DTRACEACT_DIFEXPR) {
		ASSERT(act-&gt;dta_difo != NULL);

		<span class="enscript-keyword">if</span> (act-&gt;dta_difo-&gt;dtdo_rtype.dtdt_size == 0)
			agg-&gt;dtag_hasarg = 1;
	}

	<span class="enscript-comment">/*
	 * We need to allocate an id for this aggregation.
	 */</span>
	aggid = (dtrace_aggid_t)(uintptr_t)vmem_alloc(state-&gt;dts_aggid_arena, 1,
	    VM_BESTFIT | VM_SLEEP);

	<span class="enscript-keyword">if</span> (aggid - 1 &gt;= (dtrace_aggid_t)state-&gt;dts_naggregations) {
		dtrace_aggregation_t **oaggs = state-&gt;dts_aggregations;
		dtrace_aggregation_t **aggs;
		<span class="enscript-type">int</span> naggs = state-&gt;dts_naggregations &lt;&lt; 1;
		<span class="enscript-type">int</span> onaggs = state-&gt;dts_naggregations;

		ASSERT(aggid == (dtrace_aggid_t)state-&gt;dts_naggregations + 1);

		<span class="enscript-keyword">if</span> (naggs == 0) {
			ASSERT(oaggs == NULL);
			naggs = 1;
		}

		aggs = kmem_zalloc(naggs * <span class="enscript-keyword">sizeof</span> (*aggs), KM_SLEEP);

		<span class="enscript-keyword">if</span> (oaggs != NULL) {
			bcopy(oaggs, aggs, onaggs * <span class="enscript-keyword">sizeof</span> (*aggs));
			kmem_free(oaggs, onaggs * <span class="enscript-keyword">sizeof</span> (*aggs));
		}

		state-&gt;dts_aggregations = aggs;
		state-&gt;dts_naggregations = naggs;
	}

	ASSERT(state-&gt;dts_aggregations[aggid - 1] == NULL);
	state-&gt;dts_aggregations[(agg-&gt;dtag_id = aggid) - 1] = agg;

	frec = &amp;agg-&gt;dtag_first-&gt;dta_rec;
	<span class="enscript-keyword">if</span> (frec-&gt;dtrd_alignment &lt; <span class="enscript-keyword">sizeof</span> (dtrace_aggid_t))
		frec-&gt;dtrd_alignment = <span class="enscript-keyword">sizeof</span> (dtrace_aggid_t);

	<span class="enscript-keyword">for</span> (act = agg-&gt;dtag_first; act != NULL; act = act-&gt;dta_next) {
		ASSERT(!act-&gt;dta_intuple);
		act-&gt;dta_intuple = 1;
	}

	<span class="enscript-keyword">return</span> (&amp;agg-&gt;dtag_action);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_ecb_aggregation_destroy</span>(dtrace_ecb_t *ecb, dtrace_action_t *act)
{
	dtrace_aggregation_t *agg = (dtrace_aggregation_t *)act;
	dtrace_state_t *state = ecb-&gt;dte_state;
	dtrace_aggid_t aggid = agg-&gt;dtag_id;

	ASSERT(DTRACEACT_ISAGG(act-&gt;dta_kind));
	vmem_free(state-&gt;dts_aggid_arena, (<span class="enscript-type">void</span> *)(uintptr_t)aggid, 1);

	ASSERT(state-&gt;dts_aggregations[aggid - 1] == agg);
	state-&gt;dts_aggregations[aggid - 1] = NULL;

	kmem_free(agg, <span class="enscript-keyword">sizeof</span> (dtrace_aggregation_t));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_ecb_action_add</span>(dtrace_ecb_t *ecb, dtrace_actdesc_t *desc)
{
	dtrace_action_t *action, *last;
	dtrace_difo_t *dp = desc-&gt;dtad_difo;
	uint32_t size = 0, align = <span class="enscript-keyword">sizeof</span> (uint8_t), mask;
	uint16_t format = 0;
	dtrace_recdesc_t *rec;
	dtrace_state_t *state = ecb-&gt;dte_state;
	dtrace_optval_t *opt = state-&gt;dts_options;
	dtrace_optval_t nframes=0, strsize;
	uint64_t arg = desc-&gt;dtad_arg;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	ASSERT(ecb-&gt;dte_action == NULL || ecb-&gt;dte_action-&gt;dta_refcnt == 1);

	<span class="enscript-keyword">if</span> (DTRACEACT_ISAGG(desc-&gt;dtad_kind)) {
		<span class="enscript-comment">/*
		 * If this is an aggregating action, there must be neither
		 * a speculate nor a commit on the action chain.
		 */</span>
		dtrace_action_t *act;

		<span class="enscript-keyword">for</span> (act = ecb-&gt;dte_action; act != NULL; act = act-&gt;dta_next) {
			<span class="enscript-keyword">if</span> (act-&gt;dta_kind == DTRACEACT_COMMIT)
				<span class="enscript-keyword">return</span> (EINVAL);

			<span class="enscript-keyword">if</span> (act-&gt;dta_kind == DTRACEACT_SPECULATE)
				<span class="enscript-keyword">return</span> (EINVAL);
		}

		action = dtrace_ecb_aggregation_create(ecb, desc);

		<span class="enscript-keyword">if</span> (action == NULL)
			<span class="enscript-keyword">return</span> (EINVAL);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (DTRACEACT_ISDESTRUCTIVE(desc-&gt;dtad_kind) ||
		    (desc-&gt;dtad_kind == DTRACEACT_DIFEXPR &amp;&amp;
		    dp != NULL &amp;&amp; dp-&gt;dtdo_destructive)) {
			state-&gt;dts_destructive = 1;
		}

		<span class="enscript-keyword">switch</span> (desc-&gt;dtad_kind) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_PRINTF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_PRINTA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_SYSTEM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_FREOPEN</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_DIFEXPR</span>:
			<span class="enscript-comment">/*
			 * We know that our arg is a string -- turn it into a
			 * format.
			 */</span>
			<span class="enscript-keyword">if</span> (arg == 0) {
				ASSERT(desc-&gt;dtad_kind == DTRACEACT_PRINTA ||
				       desc-&gt;dtad_kind == DTRACEACT_DIFEXPR);
				format = 0;
			} <span class="enscript-keyword">else</span> {
				ASSERT(arg != 0);
				ASSERT(arg &gt; KERNELBASE);
				format = dtrace_format_add(state,
				    (<span class="enscript-type">char</span> *)(uintptr_t)arg);
			}

			<span class="enscript-comment">/*FALLTHROUGH*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_LIBACT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_TRACEMEM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_TRACEMEM_DYNSIZE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_APPLEBINARY</span>:	<span class="enscript-comment">/* __APPLE__ */</span>
			<span class="enscript-keyword">if</span> (dp == NULL)
				<span class="enscript-keyword">return</span> (EINVAL);

			<span class="enscript-keyword">if</span> ((size = dp-&gt;dtdo_rtype.dtdt_size) != 0)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (dp-&gt;dtdo_rtype.dtdt_kind == DIF_TYPE_STRING) {
				<span class="enscript-keyword">if</span> (!(dp-&gt;dtdo_rtype.dtdt_flags &amp; DIF_TF_BYREF))
					<span class="enscript-keyword">return</span> (EINVAL);

				size = opt[DTRACEOPT_STRSIZE];
			}

			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_STACK</span>:
			<span class="enscript-keyword">if</span> ((nframes = arg) == 0) {
				nframes = opt[DTRACEOPT_STACKFRAMES];
				ASSERT(nframes &gt; 0);
				arg = nframes;
			}

			size = nframes * <span class="enscript-keyword">sizeof</span> (pc_t);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_JSTACK</span>:
			<span class="enscript-keyword">if</span> ((strsize = DTRACE_USTACK_STRSIZE(arg)) == 0)
				strsize = opt[DTRACEOPT_JSTACKSTRSIZE];

			<span class="enscript-keyword">if</span> ((nframes = DTRACE_USTACK_NFRAMES(arg)) == 0)
				nframes = opt[DTRACEOPT_JSTACKFRAMES];

			arg = DTRACE_USTACK_ARG(nframes, strsize);

			<span class="enscript-comment">/*FALLTHROUGH*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_USTACK</span>:
			<span class="enscript-keyword">if</span> (desc-&gt;dtad_kind != DTRACEACT_JSTACK &amp;&amp;
			    (nframes = DTRACE_USTACK_NFRAMES(arg)) == 0) {
				strsize = DTRACE_USTACK_STRSIZE(arg);
				nframes = opt[DTRACEOPT_USTACKFRAMES];
				ASSERT(nframes &gt; 0);
				arg = DTRACE_USTACK_ARG(nframes, strsize);
			}

			<span class="enscript-comment">/*
			 * Save a slot for the pid.
			 */</span>
			size = (nframes + 1) * <span class="enscript-keyword">sizeof</span> (uint64_t);
			size += DTRACE_USTACK_STRSIZE(arg);
			size = P2ROUNDUP(size, (uint32_t)(<span class="enscript-keyword">sizeof</span> (uintptr_t)));

			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_SYM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_MOD</span>:
			<span class="enscript-keyword">if</span> (dp == NULL || ((size = dp-&gt;dtdo_rtype.dtdt_size) !=
			    <span class="enscript-keyword">sizeof</span> (uint64_t)) ||
			    (dp-&gt;dtdo_rtype.dtdt_flags &amp; DIF_TF_BYREF))
				<span class="enscript-keyword">return</span> (EINVAL);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_USYM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_UMOD</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_UADDR</span>:
			<span class="enscript-keyword">if</span> (dp == NULL ||
			    (dp-&gt;dtdo_rtype.dtdt_size != <span class="enscript-keyword">sizeof</span> (uint64_t)) ||
			    (dp-&gt;dtdo_rtype.dtdt_flags &amp; DIF_TF_BYREF))
				<span class="enscript-keyword">return</span> (EINVAL);

			<span class="enscript-comment">/*
			 * We have a slot for the pid, plus a slot for the
			 * argument.  To keep things simple (aligned with
			 * bitness-neutral sizing), we store each as a 64-bit
			 * quantity.
			 */</span>
			size = 2 * <span class="enscript-keyword">sizeof</span> (uint64_t);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_STOP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_BREAKPOINT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_PANIC</span>:
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_CHILL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_DISCARD</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_RAISE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_PIDRESUME</span>:	<span class="enscript-comment">/* __APPLE__ */</span>
			<span class="enscript-keyword">if</span> (dp == NULL)
				<span class="enscript-keyword">return</span> (EINVAL);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_EXIT</span>:
			<span class="enscript-keyword">if</span> (dp == NULL ||
			    (size = dp-&gt;dtdo_rtype.dtdt_size) != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>) ||
			    (dp-&gt;dtdo_rtype.dtdt_flags &amp; DIF_TF_BYREF))
				<span class="enscript-keyword">return</span> (EINVAL);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_SPECULATE</span>:
			<span class="enscript-keyword">if</span> (ecb-&gt;dte_size &gt; <span class="enscript-keyword">sizeof</span> (dtrace_rechdr_t))
				<span class="enscript-keyword">return</span> (EINVAL);

			<span class="enscript-keyword">if</span> (dp == NULL)
				<span class="enscript-keyword">return</span> (EINVAL);

			state-&gt;dts_speculates = 1;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEACT_COMMIT</span>: {
			dtrace_action_t *act = ecb-&gt;dte_action;

			<span class="enscript-keyword">for</span> (; act != NULL; act = act-&gt;dta_next) {
				<span class="enscript-keyword">if</span> (act-&gt;dta_kind == DTRACEACT_COMMIT)
					<span class="enscript-keyword">return</span> (EINVAL);
			}

			<span class="enscript-keyword">if</span> (dp == NULL)
				<span class="enscript-keyword">return</span> (EINVAL);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		<span class="enscript-keyword">if</span> (size != 0 || desc-&gt;dtad_kind == DTRACEACT_SPECULATE) {
			<span class="enscript-comment">/*
			 * If this is a data-storing action or a speculate,
			 * we must be sure that there isn't a commit on the
			 * action chain.
			 */</span>
			dtrace_action_t *act = ecb-&gt;dte_action;

			<span class="enscript-keyword">for</span> (; act != NULL; act = act-&gt;dta_next) {
				<span class="enscript-keyword">if</span> (act-&gt;dta_kind == DTRACEACT_COMMIT)
					<span class="enscript-keyword">return</span> (EINVAL);
			}
		}

		action = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_action_t), KM_SLEEP);
		action-&gt;dta_rec.dtrd_size = size;
	}

	action-&gt;dta_refcnt = 1;
	rec = &amp;action-&gt;dta_rec;
	size = rec-&gt;dtrd_size;

	<span class="enscript-keyword">for</span> (mask = <span class="enscript-keyword">sizeof</span> (uint64_t) - 1; size != 0 &amp;&amp; mask &gt; 0; mask &gt;&gt;= 1) {
		<span class="enscript-keyword">if</span> (!(size &amp; mask)) {
			align = mask + 1;
			<span class="enscript-keyword">break</span>;
		}
	}

	action-&gt;dta_kind = desc-&gt;dtad_kind;

	<span class="enscript-keyword">if</span> ((action-&gt;dta_difo = dp) != NULL)
		dtrace_difo_hold(dp);

	rec-&gt;dtrd_action = action-&gt;dta_kind;
	rec-&gt;dtrd_arg = arg;
	rec-&gt;dtrd_uarg = desc-&gt;dtad_uarg;
	rec-&gt;dtrd_alignment = (uint16_t)align;
	rec-&gt;dtrd_format = format;

	<span class="enscript-keyword">if</span> ((last = ecb-&gt;dte_action_last) != NULL) {
		ASSERT(ecb-&gt;dte_action != NULL);
		action-&gt;dta_prev = last;
		last-&gt;dta_next = action;
	} <span class="enscript-keyword">else</span> {
		ASSERT(ecb-&gt;dte_action == NULL);
		ecb-&gt;dte_action = action;
	}

	ecb-&gt;dte_action_last = action;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_ecb_action_remove</span>(dtrace_ecb_t *ecb)
{
	dtrace_action_t *act = ecb-&gt;dte_action, *next;
	dtrace_vstate_t *vstate = &amp;ecb-&gt;dte_state-&gt;dts_vstate;
	dtrace_difo_t *dp;
	uint16_t format;

	<span class="enscript-keyword">if</span> (act != NULL &amp;&amp; act-&gt;dta_refcnt &gt; 1) {
		ASSERT(act-&gt;dta_next == NULL || act-&gt;dta_next-&gt;dta_refcnt == 1);
		act-&gt;dta_refcnt--;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">for</span> (; act != NULL; act = next) {
			next = act-&gt;dta_next;
			ASSERT(next != NULL || act == ecb-&gt;dte_action_last);
			ASSERT(act-&gt;dta_refcnt == 1);

			<span class="enscript-keyword">if</span> ((format = act-&gt;dta_rec.dtrd_format) != 0)
				dtrace_format_remove(ecb-&gt;dte_state, format);

			<span class="enscript-keyword">if</span> ((dp = act-&gt;dta_difo) != NULL)
				dtrace_difo_release(dp, vstate);

			<span class="enscript-keyword">if</span> (DTRACEACT_ISAGG(act-&gt;dta_kind)) {
				dtrace_ecb_aggregation_destroy(ecb, act);
			} <span class="enscript-keyword">else</span> {
				kmem_free(act, <span class="enscript-keyword">sizeof</span> (dtrace_action_t));
			}
		}
	}

	ecb-&gt;dte_action = NULL;
	ecb-&gt;dte_action_last = NULL;
	ecb-&gt;dte_size = 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_ecb_disable</span>(dtrace_ecb_t *ecb)
{
	<span class="enscript-comment">/*
	 * We disable the ECB by removing it from its probe.
	 */</span>
	dtrace_ecb_t *pecb, *prev = NULL;
	dtrace_probe_t *probe = ecb-&gt;dte_probe;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (probe == NULL) {
		<span class="enscript-comment">/*
		 * This is the NULL probe; there is nothing to disable.
		 */</span>
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">for</span> (pecb = probe-&gt;dtpr_ecb; pecb != NULL; pecb = pecb-&gt;dte_next) {
		<span class="enscript-keyword">if</span> (pecb == ecb)
			<span class="enscript-keyword">break</span>;
		prev = pecb;
	}

	ASSERT(pecb != NULL);

	<span class="enscript-keyword">if</span> (prev == NULL) {
		probe-&gt;dtpr_ecb = ecb-&gt;dte_next;
	} <span class="enscript-keyword">else</span> {
		prev-&gt;dte_next = ecb-&gt;dte_next;
	}

	<span class="enscript-keyword">if</span> (ecb == probe-&gt;dtpr_ecb_last) {
		ASSERT(ecb-&gt;dte_next == NULL);
		probe-&gt;dtpr_ecb_last = prev;
	}

	probe-&gt;dtpr_provider-&gt;dtpv_ecb_count--;
	<span class="enscript-comment">/*
	 * The ECB has been disconnected from the probe; now sync to assure
	 * that all CPUs have seen the change before returning.
	 */</span>
	dtrace_sync();

	<span class="enscript-keyword">if</span> (probe-&gt;dtpr_ecb == NULL) {
		<span class="enscript-comment">/*
		 * That was the last ECB on the probe; clear the predicate
		 * cache ID for the probe, disable it and sync one more time
		 * to assure that we'll never hit it again.
		 */</span>
		dtrace_provider_t *prov = probe-&gt;dtpr_provider;

		ASSERT(ecb-&gt;dte_next == NULL);
		ASSERT(probe-&gt;dtpr_ecb_last == NULL);
		probe-&gt;dtpr_predcache = DTRACE_CACHEIDNONE;
		prov-&gt;dtpv_pops.dtps_disable(prov-&gt;dtpv_arg,
		    probe-&gt;dtpr_id, probe-&gt;dtpr_arg);
		dtrace_sync();
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * There is at least one ECB remaining on the probe.  If there
		 * is _exactly_ one, set the probe's predicate cache ID to be
		 * the predicate cache ID of the remaining ECB.
		 */</span>
		ASSERT(probe-&gt;dtpr_ecb_last != NULL);
		ASSERT(probe-&gt;dtpr_predcache == DTRACE_CACHEIDNONE);

		<span class="enscript-keyword">if</span> (probe-&gt;dtpr_ecb == probe-&gt;dtpr_ecb_last) {
			dtrace_predicate_t *p = probe-&gt;dtpr_ecb-&gt;dte_predicate;

			ASSERT(probe-&gt;dtpr_ecb-&gt;dte_next == NULL);

			<span class="enscript-keyword">if</span> (p != NULL)
				probe-&gt;dtpr_predcache = p-&gt;dtp_cacheid;
		}

		ecb-&gt;dte_next = NULL;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_ecb_destroy</span>(dtrace_ecb_t *ecb)
{
	dtrace_state_t *state = ecb-&gt;dte_state;
	dtrace_vstate_t *vstate = &amp;state-&gt;dts_vstate;
	dtrace_predicate_t *pred;
	dtrace_epid_t epid = ecb-&gt;dte_epid;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	ASSERT(ecb-&gt;dte_next == NULL);
	ASSERT(ecb-&gt;dte_probe == NULL || ecb-&gt;dte_probe-&gt;dtpr_ecb != ecb);

	<span class="enscript-keyword">if</span> ((pred = ecb-&gt;dte_predicate) != NULL)
		dtrace_predicate_release(pred, vstate);

	dtrace_ecb_action_remove(ecb);

	ASSERT(state-&gt;dts_ecbs[epid - 1] == ecb);
	state-&gt;dts_ecbs[epid - 1] = NULL;

	kmem_free(ecb, <span class="enscript-keyword">sizeof</span> (dtrace_ecb_t));
}

<span class="enscript-type">static</span> dtrace_ecb_t *
<span class="enscript-function-name">dtrace_ecb_create</span>(dtrace_state_t *state, dtrace_probe_t *probe,
    dtrace_enabling_t *enab)
{
	dtrace_ecb_t *ecb;
	dtrace_predicate_t *pred;
	dtrace_actdesc_t *act;
	dtrace_provider_t *prov;
	dtrace_ecbdesc_t *desc = enab-&gt;dten_current;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	ASSERT(state != NULL);

	ecb = dtrace_ecb_add(state, probe);
	ecb-&gt;dte_uarg = desc-&gt;dted_uarg;

	<span class="enscript-keyword">if</span> ((pred = desc-&gt;dted_pred.dtpdd_predicate) != NULL) {
		dtrace_predicate_hold(pred);
		ecb-&gt;dte_predicate = pred;
	}

	<span class="enscript-keyword">if</span> (probe != NULL) {
		<span class="enscript-comment">/*
		 * If the provider shows more leg than the consumer is old
		 * enough to see, we need to enable the appropriate implicit
		 * predicate bits to prevent the ecb from activating at
		 * revealing times.
		 *
		 * Providers specifying DTRACE_PRIV_USER at register time
		 * are stating that they need the /proc-style privilege
		 * model to be enforced, and this is what DTRACE_COND_OWNER
		 * and DTRACE_COND_ZONEOWNER will then do at probe time.
		 */</span>
		prov = probe-&gt;dtpr_provider;
		<span class="enscript-keyword">if</span> (!(state-&gt;dts_cred.dcr_visible &amp; DTRACE_CRV_ALLPROC) &amp;&amp;
		    (prov-&gt;dtpv_priv.dtpp_flags &amp; DTRACE_PRIV_USER))
			ecb-&gt;dte_cond |= DTRACE_COND_OWNER;

		<span class="enscript-keyword">if</span> (!(state-&gt;dts_cred.dcr_visible &amp; DTRACE_CRV_ALLZONE) &amp;&amp;
		    (prov-&gt;dtpv_priv.dtpp_flags &amp; DTRACE_PRIV_USER))
			ecb-&gt;dte_cond |= DTRACE_COND_ZONEOWNER;

		<span class="enscript-comment">/*
		 * If the provider shows us kernel innards and the user
		 * is lacking sufficient privilege, enable the
		 * DTRACE_COND_USERMODE implicit predicate.
		 */</span>
		<span class="enscript-keyword">if</span> (!(state-&gt;dts_cred.dcr_visible &amp; DTRACE_CRV_KERNEL) &amp;&amp;
		    (prov-&gt;dtpv_priv.dtpp_flags &amp; DTRACE_PRIV_KERNEL))
			ecb-&gt;dte_cond |= DTRACE_COND_USERMODE;
	}

	<span class="enscript-keyword">if</span> (dtrace_ecb_create_cache != NULL) {
		<span class="enscript-comment">/*
		 * If we have a cached ecb, we'll use its action list instead
		 * of creating our own (saving both time and space).
		 */</span>
		dtrace_ecb_t *cached = dtrace_ecb_create_cache;
		dtrace_action_t *act_if = cached-&gt;dte_action;

		<span class="enscript-keyword">if</span> (act_if != NULL) {
			ASSERT(act_if-&gt;dta_refcnt &gt; 0);
			act_if-&gt;dta_refcnt++;
			ecb-&gt;dte_action = act_if;
			ecb-&gt;dte_action_last = cached-&gt;dte_action_last;
			ecb-&gt;dte_needed = cached-&gt;dte_needed;
			ecb-&gt;dte_size = cached-&gt;dte_size;
			ecb-&gt;dte_alignment = cached-&gt;dte_alignment;
		}

		<span class="enscript-keyword">return</span> (ecb);
	}

	<span class="enscript-keyword">for</span> (act = desc-&gt;dted_action; act != NULL; act = act-&gt;dtad_next) {
		<span class="enscript-keyword">if</span> ((enab-&gt;dten_error = dtrace_ecb_action_add(ecb, act)) != 0) {
			dtrace_ecb_destroy(ecb);
			<span class="enscript-keyword">return</span> (NULL);
		}
	}

	dtrace_ecb_resize(ecb);

	<span class="enscript-keyword">return</span> (dtrace_ecb_create_cache = ecb);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_ecb_create_enable</span>(dtrace_probe_t *probe, <span class="enscript-type">void</span> *arg)
{
	dtrace_ecb_t *ecb;
	dtrace_enabling_t *enab = arg;
	dtrace_state_t *state = enab-&gt;dten_vstate-&gt;dtvs_state;

	ASSERT(state != NULL);

	<span class="enscript-keyword">if</span> (probe != NULL &amp;&amp; probe-&gt;dtpr_gen &lt; enab-&gt;dten_probegen) {
		<span class="enscript-comment">/*
		 * This probe was created in a generation for which this
		 * enabling has previously created ECBs; we don't want to
		 * enable it again, so just kick out.
		 */</span>
		<span class="enscript-keyword">return</span> (DTRACE_MATCH_NEXT);
	}

	<span class="enscript-keyword">if</span> ((ecb = dtrace_ecb_create(state, probe, enab)) == NULL)
		<span class="enscript-keyword">return</span> (DTRACE_MATCH_DONE);

	<span class="enscript-keyword">if</span> (dtrace_ecb_enable(ecb) &lt; 0)
               <span class="enscript-keyword">return</span> (DTRACE_MATCH_FAIL);
	
	<span class="enscript-keyword">return</span> (DTRACE_MATCH_NEXT);
}

<span class="enscript-type">static</span> dtrace_ecb_t *
<span class="enscript-function-name">dtrace_epid2ecb</span>(dtrace_state_t *state, dtrace_epid_t id)
{
	dtrace_ecb_t *ecb;
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ecb</span>) <span class="enscript-comment">/* __APPLE__ */</span>

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (id == 0 || id &gt; (dtrace_epid_t)state-&gt;dts_necbs)
		<span class="enscript-keyword">return</span> (NULL);

	ASSERT(state-&gt;dts_necbs &gt; 0 &amp;&amp; state-&gt;dts_ecbs != NULL);
	ASSERT((ecb = state-&gt;dts_ecbs[id - 1]) == NULL || ecb-&gt;dte_epid == id);

	<span class="enscript-keyword">return</span> (state-&gt;dts_ecbs[id - 1]);
}

<span class="enscript-type">static</span> dtrace_aggregation_t *
<span class="enscript-function-name">dtrace_aggid2agg</span>(dtrace_state_t *state, dtrace_aggid_t id)
{
	dtrace_aggregation_t *agg;
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">agg</span>) <span class="enscript-comment">/* __APPLE__ */</span>

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (id == 0 || id &gt; (dtrace_aggid_t)state-&gt;dts_naggregations)
		<span class="enscript-keyword">return</span> (NULL);

	ASSERT(state-&gt;dts_naggregations &gt; 0 &amp;&amp; state-&gt;dts_aggregations != NULL);
	ASSERT((agg = state-&gt;dts_aggregations[id - 1]) == NULL ||
	    agg-&gt;dtag_id == id);

	<span class="enscript-keyword">return</span> (state-&gt;dts_aggregations[id - 1]);
}

<span class="enscript-comment">/*
 * DTrace Buffer Functions
 *
 * The following functions manipulate DTrace buffers.  Most of these functions
 * are called in the context of establishing or processing consumer state;
 * exceptions are explicitly noted.
 */</span>

<span class="enscript-comment">/*
 * Note:  called from cross call context.  This function switches the two
 * buffers on a given CPU.  The atomicity of this operation is assured by
 * disabling interrupts while the actual switch takes place; the disabling of
 * interrupts serializes the execution with any execution of dtrace_probe() on
 * the same CPU.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_buffer_switch</span>(dtrace_buffer_t *buf)
{
	caddr_t tomax = buf-&gt;dtb_tomax;
	caddr_t xamot = buf-&gt;dtb_xamot;
	dtrace_icookie_t cookie;
	hrtime_t now;

	ASSERT(!(buf-&gt;dtb_flags &amp; DTRACEBUF_NOSWITCH));
	ASSERT(!(buf-&gt;dtb_flags &amp; DTRACEBUF_RING));

	cookie = dtrace_interrupt_disable();
	now = dtrace_gethrtime();
	buf-&gt;dtb_tomax = xamot;
	buf-&gt;dtb_xamot = tomax;
	buf-&gt;dtb_xamot_drops = buf-&gt;dtb_drops;
	buf-&gt;dtb_xamot_offset = buf-&gt;dtb_offset;
	buf-&gt;dtb_xamot_errors = buf-&gt;dtb_errors;
	buf-&gt;dtb_xamot_flags = buf-&gt;dtb_flags;
	buf-&gt;dtb_offset = 0;
	buf-&gt;dtb_drops = 0;
	buf-&gt;dtb_errors = 0;
	buf-&gt;dtb_flags &amp;= ~(DTRACEBUF_ERROR | DTRACEBUF_DROPPED);
	buf-&gt;dtb_interval = now - buf-&gt;dtb_switched;
	buf-&gt;dtb_switched = now;
	dtrace_interrupt_enable(cookie);
}

<span class="enscript-comment">/*
 * Note:  called from cross call context.  This function activates a buffer
 * on a CPU.  As with dtrace_buffer_switch(), the atomicity of the operation
 * is guaranteed by the disabling of interrupts.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_buffer_activate</span>(dtrace_state_t *state)
{
	dtrace_buffer_t *buf;
	dtrace_icookie_t cookie = dtrace_interrupt_disable();

	buf = &amp;state-&gt;dts_buffer[CPU-&gt;cpu_id];

	<span class="enscript-keyword">if</span> (buf-&gt;dtb_tomax != NULL) {
		<span class="enscript-comment">/*
		 * We might like to assert that the buffer is marked inactive,
		 * but this isn't necessarily true:  the buffer for the CPU
		 * that processes the BEGIN probe has its buffer activated
		 * manually.  In this case, we take the (harmless) action
		 * re-clearing the bit INACTIVE bit.
		 */</span>
		buf-&gt;dtb_flags &amp;= ~DTRACEBUF_INACTIVE;
	}

	dtrace_interrupt_enable(cookie);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_buffer_canalloc</span>(size_t size)
{
	<span class="enscript-keyword">if</span> (size &gt; (UINT64_MAX - dtrace_buffer_memory_inuse))
		<span class="enscript-keyword">return</span> (B_FALSE);
	<span class="enscript-keyword">if</span> ((size + dtrace_buffer_memory_inuse) &gt; dtrace_buffer_memory_maxsize)
		<span class="enscript-keyword">return</span> (B_FALSE);

	<span class="enscript-keyword">return</span> (B_TRUE);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_buffer_alloc</span>(dtrace_buffer_t *bufs, size_t size, <span class="enscript-type">int</span> flags,
    processorid_t cpu)
{
	dtrace_cpu_t *cp;
	dtrace_buffer_t *buf;
	size_t size_before_alloc = dtrace_buffer_memory_inuse;

	lck_mtx_assert(&amp;cpu_lock, LCK_MTX_ASSERT_OWNED);
	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (size &gt; (size_t)dtrace_nonroot_maxsize &amp;&amp;
	    !PRIV_POLICY_CHOICE(CRED(), PRIV_ALL, B_FALSE))
		<span class="enscript-keyword">return</span> (EFBIG);

	cp = cpu_list;

	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> (cpu != DTRACE_CPUALL &amp;&amp; cpu != cp-&gt;cpu_id)
			<span class="enscript-keyword">continue</span>;

		buf = &amp;bufs[cp-&gt;cpu_id];

		<span class="enscript-comment">/*
		 * If there is already a buffer allocated for this CPU, it
		 * is only possible that this is a DR event.  In this case,
		 * the buffer size must match our specified size.
		 */</span>
		<span class="enscript-keyword">if</span> (buf-&gt;dtb_tomax != NULL) {
			ASSERT(buf-&gt;dtb_size == size);
			<span class="enscript-keyword">continue</span>;
		}

		ASSERT(buf-&gt;dtb_xamot == NULL);

		<span class="enscript-comment">/* DTrace, please do not eat all the memory. */</span>
		<span class="enscript-keyword">if</span> (dtrace_buffer_canalloc(size) == B_FALSE)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
		<span class="enscript-keyword">if</span> ((buf-&gt;dtb_tomax = kmem_zalloc(size, KM_NOSLEEP)) == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
		dtrace_buffer_memory_inuse += size;

		buf-&gt;dtb_size = size;
		buf-&gt;dtb_flags = flags;
		buf-&gt;dtb_offset = 0;
		buf-&gt;dtb_drops = 0;

		<span class="enscript-keyword">if</span> (flags &amp; DTRACEBUF_NOSWITCH)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/* DTrace, please do not eat all the memory. */</span>
		<span class="enscript-keyword">if</span> (dtrace_buffer_canalloc(size) == B_FALSE)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
		<span class="enscript-keyword">if</span> ((buf-&gt;dtb_xamot = kmem_zalloc(size, KM_NOSLEEP)) == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
		dtrace_buffer_memory_inuse += size;
	} <span class="enscript-keyword">while</span> ((cp = cp-&gt;cpu_next) != cpu_list);

	ASSERT(dtrace_buffer_memory_inuse &lt;= dtrace_buffer_memory_maxsize);

	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">err</span>:
	cp = cpu_list;

	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> (cpu != DTRACE_CPUALL &amp;&amp; cpu != cp-&gt;cpu_id)
			<span class="enscript-keyword">continue</span>;

		buf = &amp;bufs[cp-&gt;cpu_id];

		<span class="enscript-keyword">if</span> (buf-&gt;dtb_xamot != NULL) {
			ASSERT(buf-&gt;dtb_tomax != NULL);
			ASSERT(buf-&gt;dtb_size == size);
			kmem_free(buf-&gt;dtb_xamot, size);
		}

		<span class="enscript-keyword">if</span> (buf-&gt;dtb_tomax != NULL) {
			ASSERT(buf-&gt;dtb_size == size);
			kmem_free(buf-&gt;dtb_tomax, size);
		}

		buf-&gt;dtb_tomax = NULL;
		buf-&gt;dtb_xamot = NULL;
		buf-&gt;dtb_size = 0;
	} <span class="enscript-keyword">while</span> ((cp = cp-&gt;cpu_next) != cpu_list);

	<span class="enscript-comment">/* Restore the size saved before allocating memory */</span>
	dtrace_buffer_memory_inuse = size_before_alloc;

	<span class="enscript-keyword">return</span> (ENOMEM);
}

<span class="enscript-comment">/*
 * Note:  called from probe context.  This function just increments the drop
 * count on a buffer.  It has been made a function to allow for the
 * possibility of understanding the source of mysterious drop counts.  (A
 * problem for which one may be particularly disappointed that DTrace cannot
 * be used to understand DTrace.)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_buffer_drop</span>(dtrace_buffer_t *buf)
{
	buf-&gt;dtb_drops++;
}

<span class="enscript-comment">/*
 * Note:  called from probe context.  This function is called to reserve space
 * in a buffer.  If mstate is non-NULL, sets the scratch base and size in the
 * mstate.  Returns the new offset in the buffer, or a negative value if an
 * error has occurred.
 */</span>
<span class="enscript-type">static</span> intptr_t
<span class="enscript-function-name">dtrace_buffer_reserve</span>(dtrace_buffer_t *buf, size_t needed, size_t align,
    dtrace_state_t *state, dtrace_mstate_t *mstate)
{
	intptr_t offs = buf-&gt;dtb_offset, soffs;
	intptr_t woffs;
	caddr_t tomax;
	size_t total_off;

	<span class="enscript-keyword">if</span> (buf-&gt;dtb_flags &amp; DTRACEBUF_INACTIVE)
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-keyword">if</span> ((tomax = buf-&gt;dtb_tomax) == NULL) {
		dtrace_buffer_drop(buf);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (!(buf-&gt;dtb_flags &amp; (DTRACEBUF_RING | DTRACEBUF_FILL))) {
		<span class="enscript-keyword">while</span> (offs &amp; (align - 1)) {
			<span class="enscript-comment">/*
			 * Assert that our alignment is off by a number which
			 * is itself sizeof (uint32_t) aligned.
			 */</span>
			ASSERT(!((align - (offs &amp; (align - 1))) &amp;
			    (<span class="enscript-keyword">sizeof</span> (uint32_t) - 1)));
			DTRACE_STORE(uint32_t, tomax, offs, DTRACE_EPIDNONE);
			offs += <span class="enscript-keyword">sizeof</span> (uint32_t);
		}

		<span class="enscript-keyword">if</span> ((uint64_t)(soffs = offs + needed) &gt; buf-&gt;dtb_size) {
			dtrace_buffer_drop(buf);
			<span class="enscript-keyword">return</span> (-1);
		}

		<span class="enscript-keyword">if</span> (mstate == NULL)
			<span class="enscript-keyword">return</span> (offs);

		mstate-&gt;dtms_scratch_base = (uintptr_t)tomax + soffs;
		mstate-&gt;dtms_scratch_size = buf-&gt;dtb_size - soffs;
		mstate-&gt;dtms_scratch_ptr = mstate-&gt;dtms_scratch_base;

		<span class="enscript-keyword">return</span> (offs);
	}

	<span class="enscript-keyword">if</span> (buf-&gt;dtb_flags &amp; DTRACEBUF_FILL) {
		<span class="enscript-keyword">if</span> (state-&gt;dts_activity != DTRACE_ACTIVITY_COOLDOWN &amp;&amp;
		    (buf-&gt;dtb_flags &amp; DTRACEBUF_FULL))
			<span class="enscript-keyword">return</span> (-1);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	total_off = needed + (offs &amp; (align - 1));

	<span class="enscript-comment">/*
	 * For a ring buffer, life is quite a bit more complicated.  Before
	 * we can store any padding, we need to adjust our wrapping offset.
	 * (If we've never before wrapped or we're not about to, no adjustment
	 * is required.)
	 */</span>
	<span class="enscript-keyword">if</span> ((buf-&gt;dtb_flags &amp; DTRACEBUF_WRAPPED) ||
	    offs + total_off &gt; buf-&gt;dtb_size) {
		woffs = buf-&gt;dtb_xamot_offset;

		<span class="enscript-keyword">if</span> (offs + total_off &gt; buf-&gt;dtb_size) {
			<span class="enscript-comment">/*
			 * We can't fit in the end of the buffer.  First, a
			 * sanity check that we can fit in the buffer at all.
			 */</span>
			<span class="enscript-keyword">if</span> (total_off &gt; buf-&gt;dtb_size) {
				dtrace_buffer_drop(buf);
				<span class="enscript-keyword">return</span> (-1);
			}

			<span class="enscript-comment">/*
			 * We're going to be storing at the top of the buffer,
			 * so now we need to deal with the wrapped offset.  We
			 * only reset our wrapped offset to 0 if it is
			 * currently greater than the current offset.  If it
			 * is less than the current offset, it is because a
			 * previous allocation induced a wrap -- but the
			 * allocation didn't subsequently take the space due
			 * to an error or false predicate evaluation.  In this
			 * case, we'll just leave the wrapped offset alone: if
			 * the wrapped offset hasn't been advanced far enough
			 * for this allocation, it will be adjusted in the
			 * lower loop.
			 */</span>
			<span class="enscript-keyword">if</span> (buf-&gt;dtb_flags &amp; DTRACEBUF_WRAPPED) {
				<span class="enscript-keyword">if</span> (woffs &gt;= offs)
					woffs = 0;
			} <span class="enscript-keyword">else</span> {
				woffs = 0;
			}

			<span class="enscript-comment">/*
			 * Now we know that we're going to be storing to the
			 * top of the buffer and that there is room for us
			 * there.  We need to clear the buffer from the current
			 * offset to the end (there may be old gunk there).
			 */</span>
			<span class="enscript-keyword">while</span> ((uint64_t)offs &lt; buf-&gt;dtb_size)
				tomax[offs++] = 0;

			<span class="enscript-comment">/*
			 * We need to set our offset to zero.  And because we
			 * are wrapping, we need to set the bit indicating as
			 * much.  We can also adjust our needed space back
			 * down to the space required by the ECB -- we know
			 * that the top of the buffer is aligned.
			 */</span>
			offs = 0;
			total_off = needed;
			buf-&gt;dtb_flags |= DTRACEBUF_WRAPPED;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * There is room for us in the buffer, so we simply
			 * need to check the wrapped offset.
			 */</span>
			<span class="enscript-keyword">if</span> (woffs &lt; offs) {
				<span class="enscript-comment">/*
				 * The wrapped offset is less than the offset.
				 * This can happen if we allocated buffer space
				 * that induced a wrap, but then we didn't
				 * subsequently take the space due to an error
				 * or false predicate evaluation.  This is
				 * okay; we know that _this_ allocation isn't
				 * going to induce a wrap.  We still can't
				 * reset the wrapped offset to be zero,
				 * however: the space may have been trashed in
				 * the previous failed probe attempt.  But at
				 * least the wrapped offset doesn't need to
				 * be adjusted at all...
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}

		<span class="enscript-keyword">while</span> (offs + total_off &gt; (size_t)woffs) {
			dtrace_epid_t epid = *(uint32_t *)(tomax + woffs);
			size_t size;

			<span class="enscript-keyword">if</span> (epid == DTRACE_EPIDNONE) {
				size = <span class="enscript-keyword">sizeof</span> (uint32_t);
			} <span class="enscript-keyword">else</span> {
				ASSERT(epid &lt;= (dtrace_epid_t)state-&gt;dts_necbs);
				ASSERT(state-&gt;dts_ecbs[epid - 1] != NULL);

				size = state-&gt;dts_ecbs[epid - 1]-&gt;dte_size;
			}

			ASSERT(woffs + size &lt;= buf-&gt;dtb_size);
			ASSERT(size != 0);

			<span class="enscript-keyword">if</span> (woffs + size == buf-&gt;dtb_size) {
				<span class="enscript-comment">/*
				 * We've reached the end of the buffer; we want
				 * to set the wrapped offset to 0 and break
				 * out.  However, if the offs is 0, then we're
				 * in a strange edge-condition:  the amount of
				 * space that we want to reserve plus the size
				 * of the record that we're overwriting is
				 * greater than the size of the buffer.  This
				 * is problematic because if we reserve the
				 * space but subsequently don't consume it (due
				 * to a failed predicate or error) the wrapped
				 * offset will be 0 -- yet the EPID at offset 0
				 * will not be committed.  This situation is
				 * relatively easy to deal with:  if we're in
				 * this case, the buffer is indistinguishable
				 * from one that hasn't wrapped; we need only
				 * finish the job by clearing the wrapped bit,
				 * explicitly setting the offset to be 0, and
				 * zero'ing out the old data in the buffer.
				 */</span>
				<span class="enscript-keyword">if</span> (offs == 0) {
					buf-&gt;dtb_flags &amp;= ~DTRACEBUF_WRAPPED;
					buf-&gt;dtb_offset = 0;
					woffs = total_off;

					<span class="enscript-keyword">while</span> ((uint64_t)woffs &lt; buf-&gt;dtb_size)
						tomax[woffs++] = 0;
				}

				woffs = 0;
				<span class="enscript-keyword">break</span>;
			}

			woffs += size;
		}

		<span class="enscript-comment">/*
		 * We have a wrapped offset.  It may be that the wrapped offset
		 * has become zero -- that's okay.
		 */</span>
		buf-&gt;dtb_xamot_offset = woffs;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/*
	 * Now we can plow the buffer with any necessary padding.
	 */</span>
	<span class="enscript-keyword">while</span> (offs &amp; (align - 1)) {
		<span class="enscript-comment">/*
		 * Assert that our alignment is off by a number which
		 * is itself sizeof (uint32_t) aligned.
		 */</span>
		ASSERT(!((align - (offs &amp; (align - 1))) &amp;
		    (<span class="enscript-keyword">sizeof</span> (uint32_t) - 1)));
		DTRACE_STORE(uint32_t, tomax, offs, DTRACE_EPIDNONE);
		offs += <span class="enscript-keyword">sizeof</span> (uint32_t);
	}

	<span class="enscript-keyword">if</span> (buf-&gt;dtb_flags &amp; DTRACEBUF_FILL) {
		<span class="enscript-keyword">if</span> (offs + needed &gt; buf-&gt;dtb_size - state-&gt;dts_reserve) {
			buf-&gt;dtb_flags |= DTRACEBUF_FULL;
			<span class="enscript-keyword">return</span> (-1);
		}
	}

	<span class="enscript-keyword">if</span> (mstate == NULL)
		<span class="enscript-keyword">return</span> (offs);

	<span class="enscript-comment">/*
	 * For ring buffers and fill buffers, the scratch space is always
	 * the inactive buffer.
	 */</span>
	mstate-&gt;dtms_scratch_base = (uintptr_t)buf-&gt;dtb_xamot;
	mstate-&gt;dtms_scratch_size = buf-&gt;dtb_size;
	mstate-&gt;dtms_scratch_ptr = mstate-&gt;dtms_scratch_base;

	<span class="enscript-keyword">return</span> (offs);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_buffer_polish</span>(dtrace_buffer_t *buf)
{
	ASSERT(buf-&gt;dtb_flags &amp; DTRACEBUF_RING);
	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (!(buf-&gt;dtb_flags &amp; DTRACEBUF_WRAPPED))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * We need to polish the ring buffer.  There are three cases:
	 *
	 * - The first (and presumably most common) is that there is no gap
	 *   between the buffer offset and the wrapped offset.  In this case,
	 *   there is nothing in the buffer that isn't valid data; we can
	 *   mark the buffer as polished and return.
	 *
	 * - The second (less common than the first but still more common
	 *   than the third) is that there is a gap between the buffer offset
	 *   and the wrapped offset, and the wrapped offset is larger than the
	 *   buffer offset.  This can happen because of an alignment issue, or
	 *   can happen because of a call to dtrace_buffer_reserve() that
	 *   didn't subsequently consume the buffer space.  In this case,
	 *   we need to zero the data from the buffer offset to the wrapped
	 *   offset.
	 *
	 * - The third (and least common) is that there is a gap between the
	 *   buffer offset and the wrapped offset, but the wrapped offset is
	 *   _less_ than the buffer offset.  This can only happen because a
	 *   call to dtrace_buffer_reserve() induced a wrap, but the space
	 *   was not subsequently consumed.  In this case, we need to zero the
	 *   space from the offset to the end of the buffer _and_ from the
	 *   top of the buffer to the wrapped offset.
	 */</span>
	<span class="enscript-keyword">if</span> (buf-&gt;dtb_offset &lt; buf-&gt;dtb_xamot_offset) {
		bzero(buf-&gt;dtb_tomax + buf-&gt;dtb_offset,
		    buf-&gt;dtb_xamot_offset - buf-&gt;dtb_offset);
	}

	<span class="enscript-keyword">if</span> (buf-&gt;dtb_offset &gt; buf-&gt;dtb_xamot_offset) {
		bzero(buf-&gt;dtb_tomax + buf-&gt;dtb_offset,
		    buf-&gt;dtb_size - buf-&gt;dtb_offset);
		bzero(buf-&gt;dtb_tomax, buf-&gt;dtb_xamot_offset);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_buffer_free</span>(dtrace_buffer_t *bufs)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)NCPU; i++) {
		dtrace_buffer_t *buf = &amp;bufs[i];

		<span class="enscript-keyword">if</span> (buf-&gt;dtb_tomax == NULL) {
			ASSERT(buf-&gt;dtb_xamot == NULL);
			ASSERT(buf-&gt;dtb_size == 0);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (buf-&gt;dtb_xamot != NULL) {
			ASSERT(!(buf-&gt;dtb_flags &amp; DTRACEBUF_NOSWITCH));
			kmem_free(buf-&gt;dtb_xamot, buf-&gt;dtb_size);

			ASSERT(dtrace_buffer_memory_inuse &gt;= buf-&gt;dtb_size);
			dtrace_buffer_memory_inuse -= buf-&gt;dtb_size;
		}

		kmem_free(buf-&gt;dtb_tomax, buf-&gt;dtb_size);
		ASSERT(dtrace_buffer_memory_inuse &gt;= buf-&gt;dtb_size);
		dtrace_buffer_memory_inuse -= buf-&gt;dtb_size;

		buf-&gt;dtb_size = 0;
		buf-&gt;dtb_tomax = NULL;
		buf-&gt;dtb_xamot = NULL;
	}
}

<span class="enscript-comment">/*
 * DTrace Enabling Functions
 */</span>
<span class="enscript-type">static</span> dtrace_enabling_t *
<span class="enscript-function-name">dtrace_enabling_create</span>(dtrace_vstate_t *vstate)
{
	dtrace_enabling_t *enab;

	enab = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_enabling_t), KM_SLEEP);
	enab-&gt;dten_vstate = vstate;

	<span class="enscript-keyword">return</span> (enab);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_enabling_add</span>(dtrace_enabling_t *enab, dtrace_ecbdesc_t *ecb)
{
	dtrace_ecbdesc_t **ndesc;
	size_t osize, nsize;

	<span class="enscript-comment">/*
	 * We can't add to enablings after we've enabled them, or after we've
	 * retained them.
	 */</span>
	ASSERT(enab-&gt;dten_probegen == 0);
	ASSERT(enab-&gt;dten_next == NULL &amp;&amp; enab-&gt;dten_prev == NULL);

	<span class="enscript-comment">/* APPLE NOTE: this protects against gcc 4.0 botch on x86 */</span>
	<span class="enscript-keyword">if</span> (ecb == NULL) <span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (enab-&gt;dten_ndesc &lt; enab-&gt;dten_maxdesc) {
		enab-&gt;dten_desc[enab-&gt;dten_ndesc++] = ecb;
		<span class="enscript-keyword">return</span>;
	}

	osize = enab-&gt;dten_maxdesc * <span class="enscript-keyword">sizeof</span> (dtrace_enabling_t *);

	<span class="enscript-keyword">if</span> (enab-&gt;dten_maxdesc == 0) {
		enab-&gt;dten_maxdesc = 1;
	} <span class="enscript-keyword">else</span> {
		enab-&gt;dten_maxdesc &lt;&lt;= 1;
	}

	ASSERT(enab-&gt;dten_ndesc &lt; enab-&gt;dten_maxdesc);

	nsize = enab-&gt;dten_maxdesc * <span class="enscript-keyword">sizeof</span> (dtrace_enabling_t *);
	ndesc = kmem_zalloc(nsize, KM_SLEEP);
	bcopy(enab-&gt;dten_desc, ndesc, osize);
	kmem_free(enab-&gt;dten_desc, osize);

	enab-&gt;dten_desc = ndesc;
	enab-&gt;dten_desc[enab-&gt;dten_ndesc++] = ecb;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_enabling_addlike</span>(dtrace_enabling_t *enab, dtrace_ecbdesc_t *ecb,
    dtrace_probedesc_t *pd)
{
	dtrace_ecbdesc_t *new;
	dtrace_predicate_t *pred;
	dtrace_actdesc_t *act;

	<span class="enscript-comment">/*
	 * We're going to create a new ECB description that matches the
	 * specified ECB in every way, but has the specified probe description.
	 */</span>
	new = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_ecbdesc_t), KM_SLEEP);

	<span class="enscript-keyword">if</span> ((pred = ecb-&gt;dted_pred.dtpdd_predicate) != NULL)
		dtrace_predicate_hold(pred);

	<span class="enscript-keyword">for</span> (act = ecb-&gt;dted_action; act != NULL; act = act-&gt;dtad_next)
		dtrace_actdesc_hold(act);

	new-&gt;dted_action = ecb-&gt;dted_action;
	new-&gt;dted_pred = ecb-&gt;dted_pred;
	new-&gt;dted_probe = *pd;
	new-&gt;dted_uarg = ecb-&gt;dted_uarg;

	dtrace_enabling_add(enab, new);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_enabling_dump</span>(dtrace_enabling_t *enab)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; enab-&gt;dten_ndesc; i++) {
		dtrace_probedesc_t *desc = &amp;enab-&gt;dten_desc[i]-&gt;dted_probe;

		cmn_err(CE_NOTE, <span class="enscript-string">&quot;enabling probe %d (%s:%s:%s:%s)&quot;</span>, i,
		    desc-&gt;dtpd_provider, desc-&gt;dtpd_mod,
		    desc-&gt;dtpd_func, desc-&gt;dtpd_name);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_enabling_destroy</span>(dtrace_enabling_t *enab)
{
	<span class="enscript-type">int</span> i;
	dtrace_ecbdesc_t *ep;
	dtrace_vstate_t *vstate = enab-&gt;dten_vstate;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; enab-&gt;dten_ndesc; i++) {
		dtrace_actdesc_t *act, *next;
		dtrace_predicate_t *pred;

		ep = enab-&gt;dten_desc[i];

		<span class="enscript-keyword">if</span> ((pred = ep-&gt;dted_pred.dtpdd_predicate) != NULL)
			dtrace_predicate_release(pred, vstate);

		<span class="enscript-keyword">for</span> (act = ep-&gt;dted_action; act != NULL; act = next) {
			next = act-&gt;dtad_next;
			dtrace_actdesc_release(act, vstate);
		}

		kmem_free(ep, <span class="enscript-keyword">sizeof</span> (dtrace_ecbdesc_t));
	}

	kmem_free(enab-&gt;dten_desc,
	    enab-&gt;dten_maxdesc * <span class="enscript-keyword">sizeof</span> (dtrace_enabling_t *));

	<span class="enscript-comment">/*
	 * If this was a retained enabling, decrement the dts_nretained count
	 * and take it off of the dtrace_retained list.
	 */</span>
	<span class="enscript-keyword">if</span> (enab-&gt;dten_prev != NULL || enab-&gt;dten_next != NULL ||
	    dtrace_retained == enab) {
		ASSERT(enab-&gt;dten_vstate-&gt;dtvs_state != NULL);
		ASSERT(enab-&gt;dten_vstate-&gt;dtvs_state-&gt;dts_nretained &gt; 0);
		enab-&gt;dten_vstate-&gt;dtvs_state-&gt;dts_nretained--;
                dtrace_retained_gen++;
	}

	<span class="enscript-keyword">if</span> (enab-&gt;dten_prev == NULL) {
		<span class="enscript-keyword">if</span> (dtrace_retained == enab) {
			dtrace_retained = enab-&gt;dten_next;

			<span class="enscript-keyword">if</span> (dtrace_retained != NULL)
				dtrace_retained-&gt;dten_prev = NULL;
		}
	} <span class="enscript-keyword">else</span> {
		ASSERT(enab != dtrace_retained);
		ASSERT(dtrace_retained != NULL);
		enab-&gt;dten_prev-&gt;dten_next = enab-&gt;dten_next;
	}

	<span class="enscript-keyword">if</span> (enab-&gt;dten_next != NULL) {
		ASSERT(dtrace_retained != NULL);
		enab-&gt;dten_next-&gt;dten_prev = enab-&gt;dten_prev;
	}

	kmem_free(enab, <span class="enscript-keyword">sizeof</span> (dtrace_enabling_t));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_enabling_retain</span>(dtrace_enabling_t *enab)
{
	dtrace_state_t *state;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	ASSERT(enab-&gt;dten_next == NULL &amp;&amp; enab-&gt;dten_prev == NULL);
	ASSERT(enab-&gt;dten_vstate != NULL);

	state = enab-&gt;dten_vstate-&gt;dtvs_state;
	ASSERT(state != NULL);

	<span class="enscript-comment">/*
	 * We only allow each state to retain dtrace_retain_max enablings.
	 */</span>
	<span class="enscript-keyword">if</span> (state-&gt;dts_nretained &gt;= dtrace_retain_max)
		<span class="enscript-keyword">return</span> (ENOSPC);

	state-&gt;dts_nretained++;
        dtrace_retained_gen++;

	<span class="enscript-keyword">if</span> (dtrace_retained == NULL) {
		dtrace_retained = enab;
		<span class="enscript-keyword">return</span> (0);
	}

	enab-&gt;dten_next = dtrace_retained;
	dtrace_retained-&gt;dten_prev = enab;
	dtrace_retained = enab;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_enabling_replicate</span>(dtrace_state_t *state, dtrace_probedesc_t *match,
    dtrace_probedesc_t *create)
{
	dtrace_enabling_t *new, *enab;
	<span class="enscript-type">int</span> found = 0, err = ENOENT;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	ASSERT(strlen(match-&gt;dtpd_provider) &lt; DTRACE_PROVNAMELEN);
	ASSERT(strlen(match-&gt;dtpd_mod) &lt; DTRACE_MODNAMELEN);
	ASSERT(strlen(match-&gt;dtpd_func) &lt; DTRACE_FUNCNAMELEN);
	ASSERT(strlen(match-&gt;dtpd_name) &lt; DTRACE_NAMELEN);

	new = dtrace_enabling_create(&amp;state-&gt;dts_vstate);

	<span class="enscript-comment">/*
	 * Iterate over all retained enablings, looking for enablings that
	 * match the specified state.
	 */</span>
	<span class="enscript-keyword">for</span> (enab = dtrace_retained; enab != NULL; enab = enab-&gt;dten_next) {
		<span class="enscript-type">int</span> i;

		<span class="enscript-comment">/*
		 * dtvs_state can only be NULL for helper enablings -- and
		 * helper enablings can't be retained.
		 */</span>
		ASSERT(enab-&gt;dten_vstate-&gt;dtvs_state != NULL);

		<span class="enscript-keyword">if</span> (enab-&gt;dten_vstate-&gt;dtvs_state != state)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * Now iterate over each probe description; we're looking for
		 * an exact match to the specified probe description.
		 */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; enab-&gt;dten_ndesc; i++) {
			dtrace_ecbdesc_t *ep = enab-&gt;dten_desc[i];
			dtrace_probedesc_t *pd = &amp;ep-&gt;dted_probe;

			<span class="enscript-comment">/* APPLE NOTE: Darwin employs size bounded string operation. */</span>
			<span class="enscript-keyword">if</span> (strncmp(pd-&gt;dtpd_provider, match-&gt;dtpd_provider, DTRACE_PROVNAMELEN))
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (strncmp(pd-&gt;dtpd_mod, match-&gt;dtpd_mod, DTRACE_MODNAMELEN))
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (strncmp(pd-&gt;dtpd_func, match-&gt;dtpd_func, DTRACE_FUNCNAMELEN))
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (strncmp(pd-&gt;dtpd_name, match-&gt;dtpd_name, DTRACE_NAMELEN))
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-comment">/*
			 * We have a winning probe!  Add it to our growing
			 * enabling.
			 */</span>
			found = 1;
			dtrace_enabling_addlike(new, ep, create);
		}
	}

	<span class="enscript-keyword">if</span> (!found || (err = dtrace_enabling_retain(new)) != 0) {
		dtrace_enabling_destroy(new);
		<span class="enscript-keyword">return</span> (err);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_enabling_retract</span>(dtrace_state_t *state)
{
	dtrace_enabling_t *enab, *next;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/*
	 * Iterate over all retained enablings, destroy the enablings retained
	 * for the specified state.
	 */</span>
	<span class="enscript-keyword">for</span> (enab = dtrace_retained; enab != NULL; enab = next) {
		next = enab-&gt;dten_next;

		<span class="enscript-comment">/*
		 * dtvs_state can only be NULL for helper enablings -- and
		 * helper enablings can't be retained.
		 */</span>
		ASSERT(enab-&gt;dten_vstate-&gt;dtvs_state != NULL);

		<span class="enscript-keyword">if</span> (enab-&gt;dten_vstate-&gt;dtvs_state == state) {
			ASSERT(state-&gt;dts_nretained &gt; 0);
			dtrace_enabling_destroy(enab);
		}
	}

	ASSERT(state-&gt;dts_nretained == 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_enabling_match</span>(dtrace_enabling_t *enab, <span class="enscript-type">int</span> *nmatched)
{
	<span class="enscript-type">int</span> i = 0;
	<span class="enscript-type">int</span> total_matched = 0, matched = 0;

	lck_mtx_assert(&amp;cpu_lock, LCK_MTX_ASSERT_OWNED);
	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; enab-&gt;dten_ndesc; i++) {
		dtrace_ecbdesc_t *ep = enab-&gt;dten_desc[i];

		enab-&gt;dten_current = ep;
		enab-&gt;dten_error = 0;

		<span class="enscript-comment">/*
		 * If a provider failed to enable a probe then get out and
		 * let the consumer know we failed.
		 */</span>
		<span class="enscript-keyword">if</span> ((matched = dtrace_probe_enable(&amp;ep-&gt;dted_probe, enab)) &lt; 0)
			<span class="enscript-keyword">return</span> (EBUSY);

		total_matched += matched;

		<span class="enscript-keyword">if</span> (enab-&gt;dten_error != 0) {
			<span class="enscript-comment">/*
			 * If we get an error half-way through enabling the
			 * probes, we kick out -- perhaps with some number of
			 * them enabled.  Leaving enabled probes enabled may
			 * be slightly confusing for user-level, but we expect
			 * that no one will attempt to actually drive on in
			 * the face of such errors.  If this is an anonymous
			 * enabling (indicated with a NULL nmatched pointer),
			 * we cmn_err() a message.  We aren't expecting to
			 * get such an error -- such as it can exist at all,
			 * it would be a result of corrupted DOF in the driver
			 * properties.
			 */</span>
			<span class="enscript-keyword">if</span> (nmatched == NULL) {
				cmn_err(CE_WARN, <span class="enscript-string">&quot;dtrace_enabling_match() &quot;</span>
				    <span class="enscript-string">&quot;error on %p: %d&quot;</span>, (<span class="enscript-type">void</span> *)ep,
				    enab-&gt;dten_error);
			}

			<span class="enscript-keyword">return</span> (enab-&gt;dten_error);
		}
	}

	enab-&gt;dten_probegen = dtrace_probegen;
	<span class="enscript-keyword">if</span> (nmatched != NULL)
		*nmatched = total_matched;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_enabling_matchall</span>(<span class="enscript-type">void</span>)
{
	dtrace_enabling_t *enab;

	lck_mtx_lock(&amp;cpu_lock);
	lck_mtx_lock(&amp;dtrace_lock);

	<span class="enscript-comment">/*
	 * Iterate over all retained enablings to see if any probes match
	 * against them.  We only perform this operation on enablings for which
	 * we have sufficient permissions by virtue of being in the global zone
	 * or in the same zone as the DTrace client.  Because we can be called
	 * after dtrace_detach() has been called, we cannot assert that there
	 * are retained enablings.  We can safely load from dtrace_retained,
	 * however:  the taskq_destroy() at the end of dtrace_detach() will
	 * block pending our completion.
	 */</span>

	<span class="enscript-comment">/*
	 * Darwin doesn't do zones.
	 * Behave as if always in &quot;global&quot; zone.&quot;
	 */</span>
	<span class="enscript-keyword">for</span> (enab = dtrace_retained; enab != NULL; enab = enab-&gt;dten_next) {
		(<span class="enscript-type">void</span>) dtrace_enabling_match(enab, NULL);
	}

	lck_mtx_unlock(&amp;dtrace_lock);
	lck_mtx_unlock(&amp;cpu_lock);
}

<span class="enscript-comment">/*
 * If an enabling is to be enabled without having matched probes (that is, if
 * dtrace_state_go() is to be called on the underlying dtrace_state_t), the
 * enabling must be _primed_ by creating an ECB for every ECB description.
 * This must be done to assure that we know the number of speculations, the
 * number of aggregations, the minimum buffer size needed, etc. before we
 * transition out of DTRACE_ACTIVITY_INACTIVE.  To do this without actually
 * enabling any probes, we create ECBs for every ECB decription, but with a
 * NULL probe -- which is exactly what this function does.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_enabling_prime</span>(dtrace_state_t *state)
{
	dtrace_enabling_t *enab;
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span> (enab = dtrace_retained; enab != NULL; enab = enab-&gt;dten_next) {
		ASSERT(enab-&gt;dten_vstate-&gt;dtvs_state != NULL);

		<span class="enscript-keyword">if</span> (enab-&gt;dten_vstate-&gt;dtvs_state != state)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * We don't want to prime an enabling more than once, lest
		 * we allow a malicious user to induce resource exhaustion.
		 * (The ECBs that result from priming an enabling aren't
		 * leaked -- but they also aren't deallocated until the
		 * consumer state is destroyed.)
		 */</span>
		<span class="enscript-keyword">if</span> (enab-&gt;dten_primed)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">for</span> (i = 0; i &lt; enab-&gt;dten_ndesc; i++) {
			enab-&gt;dten_current = enab-&gt;dten_desc[i];
			(<span class="enscript-type">void</span>) dtrace_probe_enable(NULL, enab);
		}

		enab-&gt;dten_primed = 1;
	}
}

<span class="enscript-comment">/*
 * Called to indicate that probes should be provided due to retained
 * enablings.  This is implemented in terms of dtrace_probe_provide(), but it
 * must take an initial lap through the enabling calling the dtps_provide()
 * entry point explicitly to allow for autocreated probes.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_enabling_provide</span>(dtrace_provider_t *prv)
{
	<span class="enscript-type">int</span> i, all = 0;
	dtrace_probedesc_t desc;
        dtrace_genid_t gen;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	lck_mtx_assert(&amp;dtrace_provider_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (prv == NULL) {
		all = 1;
		prv = dtrace_provider;
	}

	<span class="enscript-keyword">do</span> {
		dtrace_enabling_t *enab;
		<span class="enscript-type">void</span> *parg = prv-&gt;dtpv_arg;

<span class="enscript-reference">retry</span>:
		gen = dtrace_retained_gen;
		<span class="enscript-keyword">for</span> (enab = dtrace_retained; enab != NULL;
		    enab = enab-&gt;dten_next) {
			<span class="enscript-keyword">for</span> (i = 0; i &lt; enab-&gt;dten_ndesc; i++) {
				desc = enab-&gt;dten_desc[i]-&gt;dted_probe;
				lck_mtx_unlock(&amp;dtrace_lock);
				prv-&gt;dtpv_pops.dtps_provide(parg, &amp;desc);
				lck_mtx_lock(&amp;dtrace_lock);
				<span class="enscript-comment">/*
				 * Process the retained enablings again if
				 * they have changed while we weren't holding
				 * dtrace_lock.
				 */</span>
				<span class="enscript-keyword">if</span> (gen != dtrace_retained_gen)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
			}
		}
	} <span class="enscript-keyword">while</span> (all &amp;&amp; (prv = prv-&gt;dtpv_next) != NULL);

	lck_mtx_unlock(&amp;dtrace_lock);
	dtrace_probe_provide(NULL, all ? NULL : prv);
	lck_mtx_lock(&amp;dtrace_lock);
}

<span class="enscript-comment">/*
 * DTrace DOF Functions
 */</span>
<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_dof_error</span>(dof_hdr_t *dof, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *str)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dof</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	<span class="enscript-keyword">if</span> (dtrace_err_verbose)
		cmn_err(CE_WARN, <span class="enscript-string">&quot;failed to process DOF: %s&quot;</span>, str);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DTRACE_ERRDEBUG</span>
	dtrace_errdebug(str);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 * Create DOF out of a currently enabled state.  Right now, we only create
 * DOF containing the run-time options -- but this could be expanded to create
 * complete DOF representing the enabled state.
 */</span>
<span class="enscript-type">static</span> dof_hdr_t *
<span class="enscript-function-name">dtrace_dof_create</span>(dtrace_state_t *state)
{
	dof_hdr_t *dof;
	dof_sec_t *sec;
	dof_optdesc_t *opt;
	<span class="enscript-type">int</span> i, len = <span class="enscript-keyword">sizeof</span> (dof_hdr_t) +
	    roundup(<span class="enscript-keyword">sizeof</span> (dof_sec_t), <span class="enscript-keyword">sizeof</span> (uint64_t)) +
	    <span class="enscript-keyword">sizeof</span> (dof_optdesc_t) * DTRACEOPT_MAX;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	dof = dt_kmem_zalloc_aligned(len, 8, KM_SLEEP);
	dof-&gt;dofh_ident[DOF_ID_MAG0] = DOF_MAG_MAG0;
	dof-&gt;dofh_ident[DOF_ID_MAG1] = DOF_MAG_MAG1;
	dof-&gt;dofh_ident[DOF_ID_MAG2] = DOF_MAG_MAG2;
	dof-&gt;dofh_ident[DOF_ID_MAG3] = DOF_MAG_MAG3;

	dof-&gt;dofh_ident[DOF_ID_MODEL] = DOF_MODEL_NATIVE;
	dof-&gt;dofh_ident[DOF_ID_ENCODING] = DOF_ENCODE_NATIVE;
	dof-&gt;dofh_ident[DOF_ID_VERSION] = DOF_VERSION;
	dof-&gt;dofh_ident[DOF_ID_DIFVERS] = DIF_VERSION;
	dof-&gt;dofh_ident[DOF_ID_DIFIREG] = DIF_DIR_NREGS;
	dof-&gt;dofh_ident[DOF_ID_DIFTREG] = DIF_DTR_NREGS;

	dof-&gt;dofh_flags = 0;
	dof-&gt;dofh_hdrsize = <span class="enscript-keyword">sizeof</span> (dof_hdr_t);
	dof-&gt;dofh_secsize = <span class="enscript-keyword">sizeof</span> (dof_sec_t);
	dof-&gt;dofh_secnum = 1;	<span class="enscript-comment">/* only DOF_SECT_OPTDESC */</span>
	dof-&gt;dofh_secoff = <span class="enscript-keyword">sizeof</span> (dof_hdr_t);
	dof-&gt;dofh_loadsz = len;
	dof-&gt;dofh_filesz = len;
	dof-&gt;dofh_pad = 0;

	<span class="enscript-comment">/*
	 * Fill in the option section header...
	 */</span>
	sec = (dof_sec_t *)((uintptr_t)dof + <span class="enscript-keyword">sizeof</span> (dof_hdr_t));
	sec-&gt;dofs_type = DOF_SECT_OPTDESC;
	sec-&gt;dofs_align = <span class="enscript-keyword">sizeof</span> (uint64_t);
	sec-&gt;dofs_flags = DOF_SECF_LOAD;
	sec-&gt;dofs_entsize = <span class="enscript-keyword">sizeof</span> (dof_optdesc_t);

	opt = (dof_optdesc_t *)((uintptr_t)sec +
	    roundup(<span class="enscript-keyword">sizeof</span> (dof_sec_t), <span class="enscript-keyword">sizeof</span> (uint64_t)));

	sec-&gt;dofs_offset = (uintptr_t)opt - (uintptr_t)dof;
	sec-&gt;dofs_size = <span class="enscript-keyword">sizeof</span> (dof_optdesc_t) * DTRACEOPT_MAX;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; DTRACEOPT_MAX; i++) {
		opt[i].dofo_option = i;
		opt[i].dofo_strtab = DOF_SECIDX_NONE;
		opt[i].dofo_value = state-&gt;dts_options[i];
	}

	<span class="enscript-keyword">return</span> (dof);
}

<span class="enscript-type">static</span> dof_hdr_t *
<span class="enscript-function-name">dtrace_dof_copyin</span>(user_addr_t uarg, <span class="enscript-type">int</span> *errp)
{
	dof_hdr_t hdr, *dof;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_NOTOWNED);

	<span class="enscript-comment">/*
	 * First, we're going to copyin() the sizeof (dof_hdr_t).
	 */</span>
	<span class="enscript-keyword">if</span> (copyin(uarg, &amp;hdr, <span class="enscript-keyword">sizeof</span> (hdr)) != 0) {
		dtrace_dof_error(NULL, <span class="enscript-string">&quot;failed to copyin DOF header&quot;</span>);
		*errp = EFAULT;
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-comment">/*
	 * Now we'll allocate the entire DOF and copy it in -- provided
	 * that the length isn't outrageous.
	 */</span>
	<span class="enscript-keyword">if</span> (hdr.dofh_loadsz &gt;= (uint64_t)dtrace_dof_maxsize) {
		dtrace_dof_error(&amp;hdr, <span class="enscript-string">&quot;load size exceeds maximum&quot;</span>);
		*errp = E2BIG;
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (hdr.dofh_loadsz &lt; <span class="enscript-keyword">sizeof</span> (hdr)) {
		dtrace_dof_error(&amp;hdr, <span class="enscript-string">&quot;invalid load size&quot;</span>);
		*errp = EINVAL;
		<span class="enscript-keyword">return</span> (NULL);
	}

	dof = dt_kmem_alloc_aligned(hdr.dofh_loadsz, 8, KM_SLEEP);

        <span class="enscript-keyword">if</span> (copyin(uarg, dof, hdr.dofh_loadsz) != 0  ||
	  dof-&gt;dofh_loadsz != hdr.dofh_loadsz) {
	    dt_kmem_free_aligned(dof, hdr.dofh_loadsz);
	    *errp = EFAULT;
	    <span class="enscript-keyword">return</span> (NULL);
	}	    

	<span class="enscript-keyword">return</span> (dof);
}

<span class="enscript-type">static</span> dof_hdr_t *
<span class="enscript-function-name">dtrace_dof_copyin_from_proc</span>(proc_t* p, user_addr_t uarg, <span class="enscript-type">int</span> *errp)
{
	dof_hdr_t hdr, *dof;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_NOTOWNED);

	<span class="enscript-comment">/*
	 * First, we're going to copyin() the sizeof (dof_hdr_t).
	 */</span>
	<span class="enscript-keyword">if</span> (uread(p, &amp;hdr, <span class="enscript-keyword">sizeof</span>(hdr), uarg) != KERN_SUCCESS) {
		dtrace_dof_error(NULL, <span class="enscript-string">&quot;failed to copyin DOF header&quot;</span>);
		*errp = EFAULT;
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-comment">/*
	 * Now we'll allocate the entire DOF and copy it in -- provided
	 * that the length isn't outrageous.
	 */</span>
	<span class="enscript-keyword">if</span> (hdr.dofh_loadsz &gt;= (uint64_t)dtrace_dof_maxsize) {
		dtrace_dof_error(&amp;hdr, <span class="enscript-string">&quot;load size exceeds maximum&quot;</span>);
		*errp = E2BIG;
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (hdr.dofh_loadsz &lt; <span class="enscript-keyword">sizeof</span> (hdr)) {
		dtrace_dof_error(&amp;hdr, <span class="enscript-string">&quot;invalid load size&quot;</span>);
		*errp = EINVAL;
		<span class="enscript-keyword">return</span> (NULL);
	}

	dof = dt_kmem_alloc_aligned(hdr.dofh_loadsz, 8, KM_SLEEP);

	<span class="enscript-keyword">if</span> (uread(p, dof, hdr.dofh_loadsz, uarg) != KERN_SUCCESS) {
		dt_kmem_free_aligned(dof, hdr.dofh_loadsz);
		*errp = EFAULT;
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">return</span> (dof);
}

<span class="enscript-type">static</span> dof_hdr_t *
<span class="enscript-function-name">dtrace_dof_property</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name)
{
	uchar_t *buf;
	uint64_t loadsz;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len, i;
	dof_hdr_t *dof;

	<span class="enscript-comment">/*
	 * Unfortunately, array of values in .conf files are always (and
	 * only) interpreted to be integer arrays.  We must read our DOF
	 * as an integer array, and then squeeze it into a byte array.
	 */</span>
	<span class="enscript-keyword">if</span> (ddi_prop_lookup_int_array(DDI_DEV_T_ANY, dtrace_devi, 0,
	    name, (<span class="enscript-type">int</span> **)&amp;buf, &amp;len) != DDI_PROP_SUCCESS)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; len; i++)
		buf[i] = (uchar_t)(((<span class="enscript-type">int</span> *)buf)[i]);

	<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span> (dof_hdr_t)) {
		ddi_prop_free(buf);
		dtrace_dof_error(NULL, <span class="enscript-string">&quot;truncated header&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (len &lt; (loadsz = ((dof_hdr_t *)buf)-&gt;dofh_loadsz)) {
		ddi_prop_free(buf);
		dtrace_dof_error(NULL, <span class="enscript-string">&quot;truncated DOF&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (loadsz &gt;= (uint64_t)dtrace_dof_maxsize) {
		ddi_prop_free(buf);
		dtrace_dof_error(NULL, <span class="enscript-string">&quot;oversized DOF&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	dof = dt_kmem_alloc_aligned(loadsz, 8, KM_SLEEP);
	bcopy(buf, dof, loadsz);
	ddi_prop_free(buf);

	<span class="enscript-keyword">return</span> (dof);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_dof_destroy</span>(dof_hdr_t *dof)
{
	dt_kmem_free_aligned(dof, dof-&gt;dofh_loadsz);
}

<span class="enscript-comment">/*
 * Return the dof_sec_t pointer corresponding to a given section index.  If the
 * index is not valid, dtrace_dof_error() is called and NULL is returned.  If
 * a type other than DOF_SECT_NONE is specified, the header is checked against
 * this type and NULL is returned if the types do not match.
 */</span>
<span class="enscript-type">static</span> dof_sec_t *
<span class="enscript-function-name">dtrace_dof_sect</span>(dof_hdr_t *dof, uint32_t type, dof_secidx_t i)
{
	dof_sec_t *sec = (dof_sec_t *)(uintptr_t)
	    ((uintptr_t)dof + dof-&gt;dofh_secoff + i * dof-&gt;dofh_secsize);

	<span class="enscript-keyword">if</span> (i &gt;= dof-&gt;dofh_secnum) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;referenced section index is invalid&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (!(sec-&gt;dofs_flags &amp; DOF_SECF_LOAD)) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;referenced section is not loadable&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (type != DOF_SECT_NONE &amp;&amp; type != sec-&gt;dofs_type) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;referenced section is the wrong type&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">return</span> (sec);
}

<span class="enscript-type">static</span> dtrace_probedesc_t *
<span class="enscript-function-name">dtrace_dof_probedesc</span>(dof_hdr_t *dof, dof_sec_t *sec, dtrace_probedesc_t *desc)
{
	dof_probedesc_t *probe;
	dof_sec_t *strtab;
	uintptr_t daddr = (uintptr_t)dof;
	uintptr_t str;
	size_t size;

	<span class="enscript-keyword">if</span> (sec-&gt;dofs_type != DOF_SECT_PROBEDESC) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;invalid probe section&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (sec-&gt;dofs_align != <span class="enscript-keyword">sizeof</span> (dof_secidx_t)) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;bad alignment in probe description&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (sec-&gt;dofs_offset + <span class="enscript-keyword">sizeof</span> (dof_probedesc_t) &gt; dof-&gt;dofh_loadsz) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;truncated probe description&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	probe = (dof_probedesc_t *)(uintptr_t)(daddr + sec-&gt;dofs_offset);
	strtab = dtrace_dof_sect(dof, DOF_SECT_STRTAB, probe-&gt;dofp_strtab);

	<span class="enscript-keyword">if</span> (strtab == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	str = daddr + strtab-&gt;dofs_offset;
	size = strtab-&gt;dofs_size;

	<span class="enscript-keyword">if</span> (probe-&gt;dofp_provider &gt;= strtab-&gt;dofs_size) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;corrupt probe provider&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	(<span class="enscript-type">void</span>) strncpy(desc-&gt;dtpd_provider,
	    (<span class="enscript-type">char</span> *)(str + probe-&gt;dofp_provider),
	    MIN(DTRACE_PROVNAMELEN - 1, size - probe-&gt;dofp_provider));

	<span class="enscript-comment">/* APPLE NOTE: Darwin employs size bounded string operation. */</span>
	desc-&gt;dtpd_provider[DTRACE_PROVNAMELEN - 1] = <span class="enscript-string">'\0'</span>;

	<span class="enscript-keyword">if</span> (probe-&gt;dofp_mod &gt;= strtab-&gt;dofs_size) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;corrupt probe module&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	(<span class="enscript-type">void</span>) strncpy(desc-&gt;dtpd_mod, (<span class="enscript-type">char</span> *)(str + probe-&gt;dofp_mod),
	    MIN(DTRACE_MODNAMELEN - 1, size - probe-&gt;dofp_mod));

	<span class="enscript-comment">/* APPLE NOTE: Darwin employs size bounded string operation. */</span>
	desc-&gt;dtpd_mod[DTRACE_MODNAMELEN - 1] = <span class="enscript-string">'\0'</span>;

	<span class="enscript-keyword">if</span> (probe-&gt;dofp_func &gt;= strtab-&gt;dofs_size) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;corrupt probe function&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	(<span class="enscript-type">void</span>) strncpy(desc-&gt;dtpd_func, (<span class="enscript-type">char</span> *)(str + probe-&gt;dofp_func),
	    MIN(DTRACE_FUNCNAMELEN - 1, size - probe-&gt;dofp_func));

	<span class="enscript-comment">/* APPLE NOTE: Darwin employs size bounded string operation. */</span>	
	desc-&gt;dtpd_func[DTRACE_FUNCNAMELEN - 1] = <span class="enscript-string">'\0'</span>;

	<span class="enscript-keyword">if</span> (probe-&gt;dofp_name &gt;= strtab-&gt;dofs_size) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;corrupt probe name&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	(<span class="enscript-type">void</span>) strncpy(desc-&gt;dtpd_name, (<span class="enscript-type">char</span> *)(str + probe-&gt;dofp_name),
	    MIN(DTRACE_NAMELEN - 1, size - probe-&gt;dofp_name));

	<span class="enscript-comment">/* APPLE NOTE: Darwin employs size bounded string operation. */</span>	
	desc-&gt;dtpd_name[DTRACE_NAMELEN - 1] = <span class="enscript-string">'\0'</span>;

	<span class="enscript-keyword">return</span> (desc);
}

<span class="enscript-type">static</span> dtrace_difo_t *
<span class="enscript-function-name">dtrace_dof_difo</span>(dof_hdr_t *dof, dof_sec_t *sec, dtrace_vstate_t *vstate,
    cred_t *cr)
{
	dtrace_difo_t *dp;
	size_t ttl = 0;
	dof_difohdr_t *dofd;
	uintptr_t daddr = (uintptr_t)dof;
	size_t max_size = dtrace_difo_maxsize;
	uint_t i;
	<span class="enscript-type">int</span> l, n;
		

	<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> {
		<span class="enscript-type">int</span> section;
		<span class="enscript-type">int</span> bufoffs;
		<span class="enscript-type">int</span> lenoffs;
		<span class="enscript-type">int</span> entsize;
		<span class="enscript-type">int</span> align;
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg;
	} difo[] = {
		{ DOF_SECT_DIF, offsetof(dtrace_difo_t, dtdo_buf),
		offsetof(dtrace_difo_t, dtdo_len), <span class="enscript-keyword">sizeof</span> (dif_instr_t),
		<span class="enscript-keyword">sizeof</span> (dif_instr_t), <span class="enscript-string">&quot;multiple DIF sections&quot;</span> },

		{ DOF_SECT_INTTAB, offsetof(dtrace_difo_t, dtdo_inttab),
		offsetof(dtrace_difo_t, dtdo_intlen), <span class="enscript-keyword">sizeof</span> (uint64_t),
		<span class="enscript-keyword">sizeof</span> (uint64_t), <span class="enscript-string">&quot;multiple integer tables&quot;</span> },

		{ DOF_SECT_STRTAB, offsetof(dtrace_difo_t, dtdo_strtab),
		offsetof(dtrace_difo_t, dtdo_strlen), 0,
		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">char</span>), <span class="enscript-string">&quot;multiple string tables&quot;</span> },

		{ DOF_SECT_VARTAB, offsetof(dtrace_difo_t, dtdo_vartab),
		offsetof(dtrace_difo_t, dtdo_varlen), <span class="enscript-keyword">sizeof</span> (dtrace_difv_t),
		<span class="enscript-keyword">sizeof</span> (uint_t), <span class="enscript-string">&quot;multiple variable tables&quot;</span> },

		{ DOF_SECT_NONE, 0, 0, 0, 0, NULL }
	};

	<span class="enscript-keyword">if</span> (sec-&gt;dofs_type != DOF_SECT_DIFOHDR) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;invalid DIFO header section&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (sec-&gt;dofs_align != <span class="enscript-keyword">sizeof</span> (dof_secidx_t)) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;bad alignment in DIFO header&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (sec-&gt;dofs_size &lt; <span class="enscript-keyword">sizeof</span> (dof_difohdr_t) ||
	    sec-&gt;dofs_size % <span class="enscript-keyword">sizeof</span> (dof_secidx_t)) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;bad size in DIFO header&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	dofd = (dof_difohdr_t *)(uintptr_t)(daddr + sec-&gt;dofs_offset);
	n = (sec-&gt;dofs_size - <span class="enscript-keyword">sizeof</span> (*dofd)) / <span class="enscript-keyword">sizeof</span> (dof_secidx_t) + 1;

	dp = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_difo_t), KM_SLEEP);
	dp-&gt;dtdo_rtype = dofd-&gt;dofd_rtype;

	<span class="enscript-keyword">for</span> (l = 0; l &lt; n; l++) {
		dof_sec_t *subsec;
		<span class="enscript-type">void</span> **bufp;
		uint32_t *lenp;

		<span class="enscript-keyword">if</span> ((subsec = dtrace_dof_sect(dof, DOF_SECT_NONE,
		    dofd-&gt;dofd_links[l])) == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>; <span class="enscript-comment">/* invalid section link */</span>

		<span class="enscript-keyword">if</span> (ttl + subsec-&gt;dofs_size &gt; max_size) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;exceeds maximum size&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
		}

		ttl += subsec-&gt;dofs_size;

		<span class="enscript-keyword">for</span> (i = 0; difo[i].section != DOF_SECT_NONE; i++) {

			<span class="enscript-keyword">if</span> (subsec-&gt;dofs_type != (uint32_t)difo[i].section)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (!(subsec-&gt;dofs_flags &amp; DOF_SECF_LOAD)) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;section not loaded&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
			}

			<span class="enscript-keyword">if</span> (subsec-&gt;dofs_align != (uint32_t)difo[i].align) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;bad alignment&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
			}

			bufp = (<span class="enscript-type">void</span> **)((uintptr_t)dp + difo[i].bufoffs);
			lenp = (uint32_t *)((uintptr_t)dp + difo[i].lenoffs);

			<span class="enscript-keyword">if</span> (*bufp != NULL) {
				dtrace_dof_error(dof, difo[i].msg);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
			}

			<span class="enscript-keyword">if</span> ((uint32_t)difo[i].entsize != subsec-&gt;dofs_entsize) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;entry size mismatch&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
			}

			<span class="enscript-keyword">if</span> (subsec-&gt;dofs_entsize != 0 &amp;&amp;
			    (subsec-&gt;dofs_size % subsec-&gt;dofs_entsize) != 0) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;corrupt entry size&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
			}

			*lenp = subsec-&gt;dofs_size;
			*bufp = kmem_alloc(subsec-&gt;dofs_size, KM_SLEEP);
			bcopy((<span class="enscript-type">char</span> *)(uintptr_t)(daddr + subsec-&gt;dofs_offset),
			    *bufp, subsec-&gt;dofs_size);

			<span class="enscript-keyword">if</span> (subsec-&gt;dofs_entsize != 0)
				*lenp /= subsec-&gt;dofs_entsize;

			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * If we encounter a loadable DIFO sub-section that is not
		 * known to us, assume this is a broken program and fail.
		 */</span>
		<span class="enscript-keyword">if</span> (difo[i].section == DOF_SECT_NONE &amp;&amp;
		    (subsec-&gt;dofs_flags &amp; DOF_SECF_LOAD)) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;unrecognized DIFO subsection&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
		}
	}
	
	<span class="enscript-keyword">if</span> (dp-&gt;dtdo_buf == NULL) {
		<span class="enscript-comment">/*
		 * We can't have a DIF object without DIF text.
		 */</span>
		dtrace_dof_error(dof, <span class="enscript-string">&quot;missing DIF text&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
	}

	<span class="enscript-comment">/*
	 * Before we validate the DIF object, run through the variable table
	 * looking for the strings -- if any of their size are under, we'll set
	 * their size to be the system-wide default string size.  Note that
	 * this should _not_ happen if the &quot;strsize&quot; option has been set --
	 * in this case, the compiler should have set the size to reflect the
	 * setting of the option.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; dp-&gt;dtdo_varlen; i++) {
		dtrace_difv_t *v = &amp;dp-&gt;dtdo_vartab[i];
		dtrace_diftype_t *t = &amp;v-&gt;dtdv_type;

		<span class="enscript-keyword">if</span> (v-&gt;dtdv_id &lt; DIF_VAR_OTHER_UBASE)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (t-&gt;dtdt_kind == DIF_TYPE_STRING &amp;&amp; t-&gt;dtdt_size == 0)
			t-&gt;dtdt_size = dtrace_strsize_default;
	}

	<span class="enscript-keyword">if</span> (dtrace_difo_validate(dp, vstate, DIF_DIR_NREGS, cr) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

	dtrace_difo_init(dp, vstate);
	<span class="enscript-keyword">return</span> (dp);

<span class="enscript-reference">err</span>:
	kmem_free(dp-&gt;dtdo_buf, dp-&gt;dtdo_len * <span class="enscript-keyword">sizeof</span> (dif_instr_t));
	kmem_free(dp-&gt;dtdo_inttab, dp-&gt;dtdo_intlen * <span class="enscript-keyword">sizeof</span> (uint64_t));
	kmem_free(dp-&gt;dtdo_strtab, dp-&gt;dtdo_strlen);
	kmem_free(dp-&gt;dtdo_vartab, dp-&gt;dtdo_varlen * <span class="enscript-keyword">sizeof</span> (dtrace_difv_t));

	kmem_free(dp, <span class="enscript-keyword">sizeof</span> (dtrace_difo_t));
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> dtrace_predicate_t *
<span class="enscript-function-name">dtrace_dof_predicate</span>(dof_hdr_t *dof, dof_sec_t *sec, dtrace_vstate_t *vstate,
    cred_t *cr)
{
	dtrace_difo_t *dp;

	<span class="enscript-keyword">if</span> ((dp = dtrace_dof_difo(dof, sec, vstate, cr)) == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">return</span> (dtrace_predicate_create(dp));
}

<span class="enscript-type">static</span> dtrace_actdesc_t *
<span class="enscript-function-name">dtrace_dof_actdesc</span>(dof_hdr_t *dof, dof_sec_t *sec, dtrace_vstate_t *vstate,
    cred_t *cr)
{
	dtrace_actdesc_t *act, *first = NULL, *last = NULL, *next;
	dof_actdesc_t *desc;
	dof_sec_t *difosec;
	size_t offs;
	uintptr_t daddr = (uintptr_t)dof;
	uint64_t arg;
	dtrace_actkind_t kind;

	<span class="enscript-keyword">if</span> (sec-&gt;dofs_type != DOF_SECT_ACTDESC) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;invalid action section&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (sec-&gt;dofs_offset + <span class="enscript-keyword">sizeof</span> (dof_actdesc_t) &gt; dof-&gt;dofh_loadsz) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;truncated action description&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (sec-&gt;dofs_align != <span class="enscript-keyword">sizeof</span> (uint64_t)) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;bad alignment in action description&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (sec-&gt;dofs_size &lt; sec-&gt;dofs_entsize) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;section entry size exceeds total size&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (sec-&gt;dofs_entsize != <span class="enscript-keyword">sizeof</span> (dof_actdesc_t)) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;bad entry size in action description&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (sec-&gt;dofs_size / sec-&gt;dofs_entsize &gt; dtrace_actions_max) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;actions exceed dtrace_actions_max&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">for</span> (offs = 0; offs &lt; sec-&gt;dofs_size; offs += sec-&gt;dofs_entsize) {
		desc = (dof_actdesc_t *)(daddr +
		    (uintptr_t)sec-&gt;dofs_offset + offs);
		kind = (dtrace_actkind_t)desc-&gt;dofa_kind;

		<span class="enscript-keyword">if</span> ((DTRACEACT_ISPRINTFLIKE(kind) &amp;&amp;
		    (kind != DTRACEACT_PRINTA || desc-&gt;dofa_strtab != DOF_SECIDX_NONE)) ||
		    (kind == DTRACEACT_DIFEXPR &amp;&amp; desc-&gt;dofa_strtab != DOF_SECIDX_NONE))
		{
			dof_sec_t *strtab;
			<span class="enscript-type">char</span> *str, *fmt;
			uint64_t i;

			<span class="enscript-comment">/*
			 * The argument to these actions is an index into the
			 * DOF string table.  For printf()-like actions, this
			 * is the format string.  For print(), this is the
			 * CTF type of the expression result.
			 */</span>
			<span class="enscript-keyword">if</span> ((strtab = dtrace_dof_sect(dof,
			    DOF_SECT_STRTAB, desc-&gt;dofa_strtab)) == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

			str = (<span class="enscript-type">char</span> *)((uintptr_t)dof +
			    (uintptr_t)strtab-&gt;dofs_offset);

			<span class="enscript-keyword">for</span> (i = desc-&gt;dofa_arg; i &lt; strtab-&gt;dofs_size; i++) {
				<span class="enscript-keyword">if</span> (str[i] == <span class="enscript-string">'\0'</span>)
					<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (i &gt;= strtab-&gt;dofs_size) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;bogus format string&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
			}

			<span class="enscript-keyword">if</span> (i == desc-&gt;dofa_arg) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;empty format string&quot;</span>);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
			}

			i -= desc-&gt;dofa_arg;
			fmt = kmem_alloc(i + 1, KM_SLEEP);
			bcopy(&amp;str[desc-&gt;dofa_arg], fmt, i + 1);
			arg = (uint64_t)(uintptr_t)fmt;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (kind == DTRACEACT_PRINTA) {
				ASSERT(desc-&gt;dofa_strtab == DOF_SECIDX_NONE);
				arg = 0;
			} <span class="enscript-keyword">else</span> {
				arg = desc-&gt;dofa_arg;
			}
		}

		act = dtrace_actdesc_create(kind, desc-&gt;dofa_ntuple,
		    desc-&gt;dofa_uarg, arg);

		<span class="enscript-keyword">if</span> (last != NULL) {
			last-&gt;dtad_next = act;
		} <span class="enscript-keyword">else</span> {
			first = act;
		}

		last = act;

		<span class="enscript-keyword">if</span> (desc-&gt;dofa_difo == DOF_SECIDX_NONE)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> ((difosec = dtrace_dof_sect(dof,
		    DOF_SECT_DIFOHDR, desc-&gt;dofa_difo)) == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

		act-&gt;dtad_difo = dtrace_dof_difo(dof, difosec, vstate, cr);

		<span class="enscript-keyword">if</span> (act-&gt;dtad_difo == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
	}

	ASSERT(first != NULL);
	<span class="enscript-keyword">return</span> (first);

<span class="enscript-reference">err</span>:
	<span class="enscript-keyword">for</span> (act = first; act != NULL; act = next) {
		next = act-&gt;dtad_next;
		dtrace_actdesc_release(act, vstate);
	}

	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> dtrace_ecbdesc_t *
<span class="enscript-function-name">dtrace_dof_ecbdesc</span>(dof_hdr_t *dof, dof_sec_t *sec, dtrace_vstate_t *vstate,
    cred_t *cr)
{
	dtrace_ecbdesc_t *ep;
	dof_ecbdesc_t *ecb;
	dtrace_probedesc_t *desc;
	dtrace_predicate_t *pred = NULL;

	<span class="enscript-keyword">if</span> (sec-&gt;dofs_size &lt; <span class="enscript-keyword">sizeof</span> (dof_ecbdesc_t)) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;truncated ECB description&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (sec-&gt;dofs_align != <span class="enscript-keyword">sizeof</span> (uint64_t)) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;bad alignment in ECB description&quot;</span>);
		<span class="enscript-keyword">return</span> (NULL);
	}

	ecb = (dof_ecbdesc_t *)((uintptr_t)dof + (uintptr_t)sec-&gt;dofs_offset);
	sec = dtrace_dof_sect(dof, DOF_SECT_PROBEDESC, ecb-&gt;dofe_probes);

	<span class="enscript-keyword">if</span> (sec == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	ep = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_ecbdesc_t), KM_SLEEP);
	ep-&gt;dted_uarg = ecb-&gt;dofe_uarg;
	desc = &amp;ep-&gt;dted_probe;

	<span class="enscript-keyword">if</span> (dtrace_dof_probedesc(dof, sec, desc) == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

	<span class="enscript-keyword">if</span> (ecb-&gt;dofe_pred != DOF_SECIDX_NONE) {
		<span class="enscript-keyword">if</span> ((sec = dtrace_dof_sect(dof,
		    DOF_SECT_DIFOHDR, ecb-&gt;dofe_pred)) == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

		<span class="enscript-keyword">if</span> ((pred = dtrace_dof_predicate(dof, sec, vstate, cr)) == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

		ep-&gt;dted_pred.dtpdd_predicate = pred;
	}

	<span class="enscript-keyword">if</span> (ecb-&gt;dofe_actions != DOF_SECIDX_NONE) {
		<span class="enscript-keyword">if</span> ((sec = dtrace_dof_sect(dof,
		    DOF_SECT_ACTDESC, ecb-&gt;dofe_actions)) == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

		ep-&gt;dted_action = dtrace_dof_actdesc(dof, sec, vstate, cr);

		<span class="enscript-keyword">if</span> (ep-&gt;dted_action == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
	}

	<span class="enscript-keyword">return</span> (ep);

<span class="enscript-reference">err</span>:
	<span class="enscript-keyword">if</span> (pred != NULL)
		dtrace_predicate_release(pred, vstate);
	kmem_free(ep, <span class="enscript-keyword">sizeof</span> (dtrace_ecbdesc_t));
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * APPLE NOTE: dyld handles dof relocation.
 * Darwin does not need dtrace_dof_relocate()
 */</span>

<span class="enscript-comment">/*
 * The dof_hdr_t passed to dtrace_dof_slurp() should be a partially validated
 * header:  it should be at the front of a memory region that is at least
 * sizeof (dof_hdr_t) in size -- and then at least dof_hdr.dofh_loadsz in
 * size.  It need not be validated in any other way.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_dof_slurp</span>(dof_hdr_t *dof, dtrace_vstate_t *vstate, cred_t *cr,
    dtrace_enabling_t **enabp, uint64_t ubase, <span class="enscript-type">int</span> noprobes)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ubase</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	uint64_t len = dof-&gt;dofh_loadsz, seclen;
	uintptr_t daddr = (uintptr_t)dof;
	dtrace_ecbdesc_t *ep;
	dtrace_enabling_t *enab;
	uint_t i;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	ASSERT(dof-&gt;dofh_loadsz &gt;= <span class="enscript-keyword">sizeof</span> (dof_hdr_t));

	<span class="enscript-comment">/*
	 * Check the DOF header identification bytes.  In addition to checking
	 * valid settings, we also verify that unused bits/bytes are zeroed so
	 * we can use them later without fear of regressing existing binaries.
	 */</span>
	<span class="enscript-keyword">if</span> (bcmp(&amp;dof-&gt;dofh_ident[DOF_ID_MAG0],
	    DOF_MAG_STRING, DOF_MAG_STRLEN) != 0) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;DOF magic string mismatch&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (dof-&gt;dofh_ident[DOF_ID_MODEL] != DOF_MODEL_ILP32 &amp;&amp;
	    dof-&gt;dofh_ident[DOF_ID_MODEL] != DOF_MODEL_LP64) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;DOF has invalid data model&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (dof-&gt;dofh_ident[DOF_ID_ENCODING] != DOF_ENCODE_NATIVE) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;DOF encoding mismatch&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-comment">/*
	 * APPLE NOTE: Darwin only supports DOF_VERSION_3 for now.
	 */</span>
	<span class="enscript-keyword">if</span> (dof-&gt;dofh_ident[DOF_ID_VERSION] != DOF_VERSION_3) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;DOF version mismatch&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (dof-&gt;dofh_ident[DOF_ID_DIFVERS] != DIF_VERSION_2) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;DOF uses unsupported instruction set&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (dof-&gt;dofh_ident[DOF_ID_DIFIREG] &gt; DIF_DIR_NREGS) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;DOF uses too many integer registers&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (dof-&gt;dofh_ident[DOF_ID_DIFTREG] &gt; DIF_DTR_NREGS) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;DOF uses too many tuple registers&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">for</span> (i = DOF_ID_PAD; i &lt; DOF_ID_SIZE; i++) {
		<span class="enscript-keyword">if</span> (dof-&gt;dofh_ident[i] != 0) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;DOF has invalid ident byte set&quot;</span>);
			<span class="enscript-keyword">return</span> (-1);
		}
	}

	<span class="enscript-keyword">if</span> (dof-&gt;dofh_flags &amp; ~DOF_FL_VALID) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;DOF has invalid flag bits set&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (dof-&gt;dofh_secsize == 0) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;zero section header size&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-comment">/*
	 * Check that the section headers don't exceed the amount of DOF
	 * data.  Note that we cast the section size and number of sections
	 * to uint64_t's to prevent possible overflow in the multiplication.
	 */</span>
	seclen = (uint64_t)dof-&gt;dofh_secnum * (uint64_t)dof-&gt;dofh_secsize;

	<span class="enscript-keyword">if</span> (dof-&gt;dofh_secoff &gt; len || seclen &gt; len ||
	    dof-&gt;dofh_secoff + seclen &gt; len) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;truncated section headers&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (!IS_P2ALIGNED(dof-&gt;dofh_secoff, <span class="enscript-keyword">sizeof</span> (uint64_t))) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;misaligned section headers&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (!IS_P2ALIGNED(dof-&gt;dofh_secsize, <span class="enscript-keyword">sizeof</span> (uint64_t))) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;misaligned section size&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-comment">/*
	 * Take an initial pass through the section headers to be sure that
	 * the headers don't have stray offsets.  If the 'noprobes' flag is
	 * set, do not permit sections relating to providers, probes, or args.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; dof-&gt;dofh_secnum; i++) {
		dof_sec_t *sec = (dof_sec_t *)(daddr +
		    (uintptr_t)dof-&gt;dofh_secoff + i * dof-&gt;dofh_secsize);

		<span class="enscript-keyword">if</span> (noprobes) {
			<span class="enscript-keyword">switch</span> (sec-&gt;dofs_type) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DOF_SECT_PROVIDER</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DOF_SECT_PROBES</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DOF_SECT_PRARGS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DOF_SECT_PROFFS</span>:
				dtrace_dof_error(dof, <span class="enscript-string">&quot;illegal sections &quot;</span>
				    <span class="enscript-string">&quot;for enabling&quot;</span>);
				<span class="enscript-keyword">return</span> (-1);
			}
		}

		<span class="enscript-keyword">if</span> (!(sec-&gt;dofs_flags &amp; DOF_SECF_LOAD))
			<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* just ignore non-loadable sections */</span>

		<span class="enscript-keyword">if</span> (sec-&gt;dofs_align &amp; (sec-&gt;dofs_align - 1)) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;bad section alignment&quot;</span>);
			<span class="enscript-keyword">return</span> (-1);
		}

		<span class="enscript-keyword">if</span> (sec-&gt;dofs_offset &amp; (sec-&gt;dofs_align - 1)) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;misaligned section&quot;</span>);
			<span class="enscript-keyword">return</span> (-1);
		}

		<span class="enscript-keyword">if</span> (sec-&gt;dofs_offset &gt; len || sec-&gt;dofs_size &gt; len ||
		    sec-&gt;dofs_offset + sec-&gt;dofs_size &gt; len) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;corrupt section header&quot;</span>);
			<span class="enscript-keyword">return</span> (-1);
		}

		<span class="enscript-keyword">if</span> (sec-&gt;dofs_type == DOF_SECT_STRTAB &amp;&amp; *((<span class="enscript-type">char</span> *)daddr +
		    sec-&gt;dofs_offset + sec-&gt;dofs_size - 1) != <span class="enscript-string">'\0'</span>) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;non-terminating string table&quot;</span>);
			<span class="enscript-keyword">return</span> (-1);
		}
	}

	<span class="enscript-comment">/*
	 * APPLE NOTE: We have no further relocation to perform.
	 * All dof values are relative offsets.
	 */</span>

	<span class="enscript-keyword">if</span> ((enab = *enabp) == NULL)
		enab = *enabp = dtrace_enabling_create(vstate);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; dof-&gt;dofh_secnum; i++) {
		dof_sec_t *sec = (dof_sec_t *)(daddr +
		    (uintptr_t)dof-&gt;dofh_secoff + i * dof-&gt;dofh_secsize);

		<span class="enscript-keyword">if</span> (sec-&gt;dofs_type != DOF_SECT_ECBDESC)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * APPLE NOTE: Defend against gcc 4.0 botch on x86.
		 * not all paths out of inlined dtrace_dof_ecbdesc
		 * are checked for the NULL return value.
		 * Check for NULL explicitly here.
		*/</span>
		ep = dtrace_dof_ecbdesc(dof, sec, vstate, cr);
		<span class="enscript-keyword">if</span> (ep == NULL) {
			dtrace_enabling_destroy(enab);
			*enabp = NULL;
			<span class="enscript-keyword">return</span> (-1);
		}
		
		dtrace_enabling_add(enab, ep);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Process DOF for any options.  This routine assumes that the DOF has been
 * at least processed by dtrace_dof_slurp().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_dof_options</span>(dof_hdr_t *dof, dtrace_state_t *state)
{
	uint_t i;
	<span class="enscript-type">int</span> rval;
	uint32_t entsize;
	size_t offs;
	dof_optdesc_t *desc;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; dof-&gt;dofh_secnum; i++) {
		dof_sec_t *sec = (dof_sec_t *)((uintptr_t)dof +
		    (uintptr_t)dof-&gt;dofh_secoff + i * dof-&gt;dofh_secsize);

		<span class="enscript-keyword">if</span> (sec-&gt;dofs_type != DOF_SECT_OPTDESC)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (sec-&gt;dofs_align != <span class="enscript-keyword">sizeof</span> (uint64_t)) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;bad alignment in &quot;</span>
			    <span class="enscript-string">&quot;option description&quot;</span>);
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		<span class="enscript-keyword">if</span> ((entsize = sec-&gt;dofs_entsize) == 0) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;zeroed option entry size&quot;</span>);
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		<span class="enscript-keyword">if</span> (entsize &lt; <span class="enscript-keyword">sizeof</span> (dof_optdesc_t)) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;bad option entry size&quot;</span>);
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		<span class="enscript-keyword">for</span> (offs = 0; offs &lt; sec-&gt;dofs_size; offs += entsize) {
			desc = (dof_optdesc_t *)((uintptr_t)dof +
			    (uintptr_t)sec-&gt;dofs_offset + offs);

			<span class="enscript-keyword">if</span> (desc-&gt;dofo_strtab != DOF_SECIDX_NONE) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;non-zero option string&quot;</span>);
				<span class="enscript-keyword">return</span> (EINVAL);
			}

			<span class="enscript-keyword">if</span> (desc-&gt;dofo_value == (uint64_t)DTRACEOPT_UNSET) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;unset option&quot;</span>);
				<span class="enscript-keyword">return</span> (EINVAL);
			}

			<span class="enscript-keyword">if</span> ((rval = dtrace_state_option(state,
			    desc-&gt;dofo_option, desc-&gt;dofo_value)) != 0) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;rejected option&quot;</span>);
				<span class="enscript-keyword">return</span> (rval);
			}
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * DTrace Consumer State Functions
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_dstate_init</span>(dtrace_dstate_t *dstate, size_t size)
{
	size_t hashsize, maxper, min_size, chunksize = dstate-&gt;dtds_chunksize;
	<span class="enscript-type">void</span> *base;
	uintptr_t limit;
	dtrace_dynvar_t *dvar, *next, *start;
	size_t i;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	ASSERT(dstate-&gt;dtds_base == NULL &amp;&amp; dstate-&gt;dtds_percpu == NULL);

	bzero(dstate, <span class="enscript-keyword">sizeof</span> (dtrace_dstate_t));

	<span class="enscript-keyword">if</span> ((dstate-&gt;dtds_chunksize = chunksize) == 0)
		dstate-&gt;dtds_chunksize = DTRACE_DYNVAR_CHUNKSIZE;

	<span class="enscript-keyword">if</span> (size &lt; (min_size = dstate-&gt;dtds_chunksize + <span class="enscript-keyword">sizeof</span> (dtrace_dynhash_t)))
		size = min_size;

	<span class="enscript-keyword">if</span> ((base = kmem_zalloc(size, KM_NOSLEEP)) == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	dstate-&gt;dtds_size = size;
	dstate-&gt;dtds_base = base;
	dstate-&gt;dtds_percpu = kmem_cache_alloc(dtrace_state_cache, KM_SLEEP);
	bzero(dstate-&gt;dtds_percpu, (<span class="enscript-type">int</span>)NCPU * <span class="enscript-keyword">sizeof</span> (dtrace_dstate_percpu_t));

	hashsize = size / (dstate-&gt;dtds_chunksize + <span class="enscript-keyword">sizeof</span> (dtrace_dynhash_t));

	<span class="enscript-keyword">if</span> (hashsize != 1 &amp;&amp; (hashsize &amp; 1))
		hashsize--;

	dstate-&gt;dtds_hashsize = hashsize;
	dstate-&gt;dtds_hash = dstate-&gt;dtds_base;

	<span class="enscript-comment">/*
	 * Set all of our hash buckets to point to the single sink, and (if
	 * it hasn't already been set), set the sink's hash value to be the
	 * sink sentinel value.  The sink is needed for dynamic variable
	 * lookups to know that they have iterated over an entire, valid hash
	 * chain.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; hashsize; i++)
		dstate-&gt;dtds_hash[i].dtdh_chain = &amp;dtrace_dynhash_sink;

	<span class="enscript-keyword">if</span> (dtrace_dynhash_sink.dtdv_hashval != DTRACE_DYNHASH_SINK)
		dtrace_dynhash_sink.dtdv_hashval = DTRACE_DYNHASH_SINK;

	<span class="enscript-comment">/*
	 * Determine number of active CPUs.  Divide free list evenly among
	 * active CPUs.
	 */</span>
	start = (dtrace_dynvar_t *)
	    ((uintptr_t)base + hashsize * <span class="enscript-keyword">sizeof</span> (dtrace_dynhash_t));
	limit = (uintptr_t)base + size;

	maxper = (limit - (uintptr_t)start) / (<span class="enscript-type">int</span>)NCPU;
	maxper = (maxper / dstate-&gt;dtds_chunksize) * dstate-&gt;dtds_chunksize;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; NCPU; i++) {
		dstate-&gt;dtds_percpu[i].dtdsc_free = dvar = start;

		<span class="enscript-comment">/*
		 * If we don't even have enough chunks to make it once through
		 * NCPUs, we're just going to allocate everything to the first
		 * CPU.  And if we're on the last CPU, we're going to allocate
		 * whatever is left over.  In either case, we set the limit to
		 * be the limit of the dynamic variable space.
		 */</span>
		<span class="enscript-keyword">if</span> (maxper == 0 || i == NCPU - 1) {
			limit = (uintptr_t)base + size;
			start = NULL;
		} <span class="enscript-keyword">else</span> {
			limit = (uintptr_t)start + maxper;
			start = (dtrace_dynvar_t *)limit;
		}

		ASSERT(limit &lt;= (uintptr_t)base + size);

		<span class="enscript-keyword">for</span> (;;) {
			next = (dtrace_dynvar_t *)((uintptr_t)dvar +
			    dstate-&gt;dtds_chunksize);

			<span class="enscript-keyword">if</span> ((uintptr_t)next + dstate-&gt;dtds_chunksize &gt;= limit)
				<span class="enscript-keyword">break</span>;

			dvar-&gt;dtdv_next = next;
			dvar = next;
		}

		<span class="enscript-keyword">if</span> (maxper == 0)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_dstate_fini</span>(dtrace_dstate_t *dstate)
{
	lck_mtx_assert(&amp;cpu_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (dstate-&gt;dtds_base == NULL)
		<span class="enscript-keyword">return</span>;

	kmem_free(dstate-&gt;dtds_base, dstate-&gt;dtds_size);
	kmem_cache_free(dtrace_state_cache, dstate-&gt;dtds_percpu);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_vstate_fini</span>(dtrace_vstate_t *vstate)
{
	<span class="enscript-comment">/*
	 * Logical XOR, where are you?
	 */</span>
	ASSERT((vstate-&gt;dtvs_nglobals == 0) ^ (vstate-&gt;dtvs_globals != NULL));

	<span class="enscript-keyword">if</span> (vstate-&gt;dtvs_nglobals &gt; 0) {
		kmem_free(vstate-&gt;dtvs_globals, vstate-&gt;dtvs_nglobals *
		    <span class="enscript-keyword">sizeof</span> (dtrace_statvar_t *));
	}

	<span class="enscript-keyword">if</span> (vstate-&gt;dtvs_ntlocals &gt; 0) {
		kmem_free(vstate-&gt;dtvs_tlocals, vstate-&gt;dtvs_ntlocals *
		    <span class="enscript-keyword">sizeof</span> (dtrace_difv_t));
	}

	ASSERT((vstate-&gt;dtvs_nlocals == 0) ^ (vstate-&gt;dtvs_locals != NULL));

	<span class="enscript-keyword">if</span> (vstate-&gt;dtvs_nlocals &gt; 0) {
		kmem_free(vstate-&gt;dtvs_locals, vstate-&gt;dtvs_nlocals *
		    <span class="enscript-keyword">sizeof</span> (dtrace_statvar_t *));
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_state_clean</span>(dtrace_state_t *state)
{
	<span class="enscript-keyword">if</span> (state-&gt;dts_activity == DTRACE_ACTIVITY_INACTIVE)
		<span class="enscript-keyword">return</span>;

	dtrace_dynvar_clean(&amp;state-&gt;dts_vstate.dtvs_dynvars);
	dtrace_speculation_clean(state);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_state_deadman</span>(dtrace_state_t *state)
{
	hrtime_t now;

	dtrace_sync();

	now = dtrace_gethrtime();

	<span class="enscript-keyword">if</span> (state != dtrace_anon.dta_state &amp;&amp;
	    now - state-&gt;dts_laststatus &gt;= dtrace_deadman_user)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * We must be sure that dts_alive never appears to be less than the
	 * value upon entry to dtrace_state_deadman(), and because we lack a
	 * dtrace_cas64(), we cannot store to it atomically.  We thus instead
	 * store INT64_MAX to it, followed by a memory barrier, followed by
	 * the new value.  This assures that dts_alive never appears to be
	 * less than its true value, regardless of the order in which the
	 * stores to the underlying storage are issued.
	 */</span>
	state-&gt;dts_alive = INT64_MAX;
	dtrace_membar_producer();
	state-&gt;dts_alive = now;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_state_create</span>(dev_t *devp, cred_t *cr, dtrace_state_t **new_state)
{
	minor_t minor;
	major_t major;
	<span class="enscript-type">char</span> c[30];
	dtrace_state_t *state;
	dtrace_optval_t *opt;
	<span class="enscript-type">int</span> bufsize = (<span class="enscript-type">int</span>)NCPU * <span class="enscript-keyword">sizeof</span> (dtrace_buffer_t), i;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	lck_mtx_assert(&amp;cpu_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* Cause restart */</span>
	*new_state = NULL;
	
	<span class="enscript-comment">/*
	 * Darwin's DEVFS layer acquired the minor number for this &quot;device&quot; when it called
	 * dtrace_devfs_clone_func(). At that time, dtrace_devfs_clone_func() proposed a minor number
	 * (next unused according to vmem_alloc()) and then immediately put the number back in play
	 * (by calling vmem_free()). Now that minor number is being used for an open, so committing it
	 * to use. The following vmem_alloc() must deliver that same minor number. FIXME.
	 */</span>

	minor = (minor_t)(uintptr_t)vmem_alloc(dtrace_minor, 1,
	    VM_BESTFIT | VM_SLEEP);

	<span class="enscript-keyword">if</span> (NULL != devp) {
    	ASSERT(getminor(*devp) == minor);
		<span class="enscript-keyword">if</span> (getminor(*devp) != minor) {
			printf(<span class="enscript-string">&quot;dtrace_open: couldn't re-acquire vended minor number %d. Instead got %d\n&quot;</span>, 
					getminor(*devp), minor);
			vmem_free(dtrace_minor, (<span class="enscript-type">void</span> *)(uintptr_t)minor, 1);
			<span class="enscript-keyword">return</span> (ERESTART);	<span class="enscript-comment">/* can't reacquire */</span>
		}
	} <span class="enscript-keyword">else</span> {
        <span class="enscript-comment">/* NULL==devp iff &quot;Anonymous state&quot; (see dtrace_anon_property),
		 * so just vend the minor device number here de novo since no &quot;open&quot; has occurred. */</span>
	}

	<span class="enscript-keyword">if</span> (ddi_soft_state_zalloc(dtrace_softstate, minor) != DDI_SUCCESS) {
		vmem_free(dtrace_minor, (<span class="enscript-type">void</span> *)(uintptr_t)minor, 1);
		<span class="enscript-keyword">return</span> (EAGAIN);	<span class="enscript-comment">/* temporary resource shortage */</span>
	}

	state = ddi_get_soft_state(dtrace_softstate, minor);
	state-&gt;dts_epid = DTRACE_EPIDNONE + 1;

	(<span class="enscript-type">void</span>) snprintf(c, <span class="enscript-keyword">sizeof</span> (c), <span class="enscript-string">&quot;dtrace_aggid_%d&quot;</span>, minor);
	state-&gt;dts_aggid_arena = vmem_create(c, (<span class="enscript-type">void</span> *)1, UINT32_MAX, 1,
	    NULL, NULL, NULL, 0, VM_SLEEP | VMC_IDENTIFIER);

	<span class="enscript-keyword">if</span> (devp != NULL) {
		major = getemajor(*devp);
	} <span class="enscript-keyword">else</span> {
		major = ddi_driver_major(dtrace_devi);
	}

	state-&gt;dts_dev = makedevice(major, minor);

	<span class="enscript-keyword">if</span> (devp != NULL)
		*devp = state-&gt;dts_dev;

	<span class="enscript-comment">/*
	 * We allocate NCPU buffers.  On the one hand, this can be quite
	 * a bit of memory per instance (nearly 36K on a Starcat).  On the
	 * other hand, it saves an additional memory reference in the probe
	 * path.
	 */</span>
	state-&gt;dts_buffer = kmem_zalloc(bufsize, KM_SLEEP);
	state-&gt;dts_aggbuffer = kmem_zalloc(bufsize, KM_SLEEP);
	state-&gt;dts_cleaner = CYCLIC_NONE;
	state-&gt;dts_deadman = CYCLIC_NONE;
	state-&gt;dts_vstate.dtvs_state = state;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; DTRACEOPT_MAX; i++)
		state-&gt;dts_options[i] = DTRACEOPT_UNSET;

	<span class="enscript-comment">/*
	 * Set the default options.
	 */</span>
	opt = state-&gt;dts_options;
	opt[DTRACEOPT_BUFPOLICY] = DTRACEOPT_BUFPOLICY_SWITCH;
	opt[DTRACEOPT_BUFRESIZE] = DTRACEOPT_BUFRESIZE_AUTO;
	opt[DTRACEOPT_NSPEC] = dtrace_nspec_default;
	opt[DTRACEOPT_SPECSIZE] = dtrace_specsize_default;
	opt[DTRACEOPT_CPU] = (dtrace_optval_t)DTRACE_CPUALL;
	opt[DTRACEOPT_STRSIZE] = dtrace_strsize_default;
	opt[DTRACEOPT_STACKFRAMES] = dtrace_stackframes_default;
	opt[DTRACEOPT_USTACKFRAMES] = dtrace_ustackframes_default;
	opt[DTRACEOPT_CLEANRATE] = dtrace_cleanrate_default;
	opt[DTRACEOPT_AGGRATE] = dtrace_aggrate_default;
	opt[DTRACEOPT_SWITCHRATE] = dtrace_switchrate_default;
	opt[DTRACEOPT_STATUSRATE] = dtrace_statusrate_default;
	opt[DTRACEOPT_JSTACKFRAMES] = dtrace_jstackframes_default;
	opt[DTRACEOPT_JSTACKSTRSIZE] = dtrace_jstackstrsize_default;

	state-&gt;dts_activity = DTRACE_ACTIVITY_INACTIVE;

	<span class="enscript-comment">/*
	 * Depending on the user credentials, we set flag bits which alter probe
	 * visibility or the amount of destructiveness allowed.  In the case of
	 * actual anonymous tracing, or the possession of all privileges, all of
	 * the normal checks are bypassed.
	 */</span>
	<span class="enscript-keyword">if</span> (cr == NULL || PRIV_POLICY_ONLY(cr, PRIV_ALL, B_FALSE)) {
		state-&gt;dts_cred.dcr_visible = DTRACE_CRV_ALL;
		state-&gt;dts_cred.dcr_action = DTRACE_CRA_ALL;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Set up the credentials for this instantiation.  We take a
		 * hold on the credential to prevent it from disappearing on
		 * us; this in turn prevents the zone_t referenced by this
		 * credential from disappearing.  This means that we can
		 * examine the credential and the zone from probe context.
		 */</span>
		crhold(cr);
		state-&gt;dts_cred.dcr_cred = cr;

		<span class="enscript-comment">/*
		 * CRA_PROC means &quot;we have *some* privilege for dtrace&quot; and
		 * unlocks the use of variables like pid, zonename, etc.
		 */</span>
		<span class="enscript-keyword">if</span> (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_USER, B_FALSE) ||
		    PRIV_POLICY_ONLY(cr, PRIV_DTRACE_PROC, B_FALSE)) {
			state-&gt;dts_cred.dcr_action |= DTRACE_CRA_PROC;
		}

		<span class="enscript-comment">/*
		 * dtrace_user allows use of syscall and profile providers.
		 * If the user also has proc_owner and/or proc_zone, we
		 * extend the scope to include additional visibility and
		 * destructive power.
		 */</span>
		<span class="enscript-keyword">if</span> (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_USER, B_FALSE)) {
			<span class="enscript-keyword">if</span> (PRIV_POLICY_ONLY(cr, PRIV_PROC_OWNER, B_FALSE)) {
				state-&gt;dts_cred.dcr_visible |=
				    DTRACE_CRV_ALLPROC;

				state-&gt;dts_cred.dcr_action |=
				    DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER;
			}

			<span class="enscript-keyword">if</span> (PRIV_POLICY_ONLY(cr, PRIV_PROC_ZONE, B_FALSE)) {
				state-&gt;dts_cred.dcr_visible |=
				    DTRACE_CRV_ALLZONE;

				state-&gt;dts_cred.dcr_action |=
				    DTRACE_CRA_PROC_DESTRUCTIVE_ALLZONE;
			}

			<span class="enscript-comment">/*
			 * If we have all privs in whatever zone this is,
			 * we can do destructive things to processes which
			 * have altered credentials.
			 *
			 * APPLE NOTE: Darwin doesn't do zones.
			 * Behave as if zone always has destructive privs.
			 */</span>

			state-&gt;dts_cred.dcr_action |=
				DTRACE_CRA_PROC_DESTRUCTIVE_CREDCHG;
		}

		<span class="enscript-comment">/*
		 * Holding the dtrace_kernel privilege also implies that
		 * the user has the dtrace_user privilege from a visibility
		 * perspective.  But without further privileges, some
		 * destructive actions are not available.
		 */</span>
		<span class="enscript-keyword">if</span> (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_KERNEL, B_FALSE)) {
			<span class="enscript-comment">/*
			 * Make all probes in all zones visible.  However,
			 * this doesn't mean that all actions become available
			 * to all zones.
			 */</span>
			state-&gt;dts_cred.dcr_visible |= DTRACE_CRV_KERNEL |
			    DTRACE_CRV_ALLPROC | DTRACE_CRV_ALLZONE;

			state-&gt;dts_cred.dcr_action |= DTRACE_CRA_KERNEL |
			    DTRACE_CRA_PROC;
			<span class="enscript-comment">/*
			 * Holding proc_owner means that destructive actions
			 * for *this* zone are allowed.
			 */</span>
			<span class="enscript-keyword">if</span> (PRIV_POLICY_ONLY(cr, PRIV_PROC_OWNER, B_FALSE))
				state-&gt;dts_cred.dcr_action |=
				    DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER;

			<span class="enscript-comment">/*
			 * Holding proc_zone means that destructive actions
			 * for this user/group ID in all zones is allowed.
			 */</span>
			<span class="enscript-keyword">if</span> (PRIV_POLICY_ONLY(cr, PRIV_PROC_ZONE, B_FALSE))
				state-&gt;dts_cred.dcr_action |=
				    DTRACE_CRA_PROC_DESTRUCTIVE_ALLZONE;

			<span class="enscript-comment">/*
			 * If we have all privs in whatever zone this is,
			 * we can do destructive things to processes which
			 * have altered credentials.
			 *
			 * APPLE NOTE: Darwin doesn't do zones.			 
			 * Behave as if zone always has destructive privs.
			 */</span>			
			state-&gt;dts_cred.dcr_action |=
				DTRACE_CRA_PROC_DESTRUCTIVE_CREDCHG;
		}

		<span class="enscript-comment">/*
		 * Holding the dtrace_proc privilege gives control over fasttrap
		 * and pid providers.  We need to grant wider destructive
		 * privileges in the event that the user has proc_owner and/or
		 * proc_zone.
		 */</span>
		<span class="enscript-keyword">if</span> (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_PROC, B_FALSE)) {
			<span class="enscript-keyword">if</span> (PRIV_POLICY_ONLY(cr, PRIV_PROC_OWNER, B_FALSE))
				state-&gt;dts_cred.dcr_action |=
				    DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER;

			<span class="enscript-keyword">if</span> (PRIV_POLICY_ONLY(cr, PRIV_PROC_ZONE, B_FALSE))
				state-&gt;dts_cred.dcr_action |=
				    DTRACE_CRA_PROC_DESTRUCTIVE_ALLZONE;
		}
	}

	*new_state = state;
	<span class="enscript-keyword">return</span>(0);  <span class="enscript-comment">/* Success */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_state_buffer</span>(dtrace_state_t *state, dtrace_buffer_t *buf, <span class="enscript-type">int</span> which)
{
	dtrace_optval_t *opt = state-&gt;dts_options, size;
	processorid_t cpu = 0;
	<span class="enscript-type">int</span> flags = 0, rval;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	lck_mtx_assert(&amp;cpu_lock, LCK_MTX_ASSERT_OWNED);
	ASSERT(which &lt; DTRACEOPT_MAX);
	ASSERT(state-&gt;dts_activity == DTRACE_ACTIVITY_INACTIVE ||
	    (state == dtrace_anon.dta_state &amp;&amp;
	    state-&gt;dts_activity == DTRACE_ACTIVITY_ACTIVE));

	<span class="enscript-keyword">if</span> (opt[which] == DTRACEOPT_UNSET || opt[which] == 0)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (opt[DTRACEOPT_CPU] != DTRACEOPT_UNSET)
		cpu = opt[DTRACEOPT_CPU];

	<span class="enscript-keyword">if</span> (which == DTRACEOPT_SPECSIZE)
		flags |= DTRACEBUF_NOSWITCH;

	<span class="enscript-keyword">if</span> (which == DTRACEOPT_BUFSIZE) {
		<span class="enscript-keyword">if</span> (opt[DTRACEOPT_BUFPOLICY] == DTRACEOPT_BUFPOLICY_RING)
			flags |= DTRACEBUF_RING;

		<span class="enscript-keyword">if</span> (opt[DTRACEOPT_BUFPOLICY] == DTRACEOPT_BUFPOLICY_FILL)
			flags |= DTRACEBUF_FILL;

		<span class="enscript-keyword">if</span> (state != dtrace_anon.dta_state ||
		    state-&gt;dts_activity != DTRACE_ACTIVITY_ACTIVE)
			flags |= DTRACEBUF_INACTIVE;
	}

	<span class="enscript-keyword">for</span> (size = opt[which]; (size_t)size &gt;= <span class="enscript-keyword">sizeof</span> (uint64_t); size &gt;&gt;= 1) {
		<span class="enscript-comment">/*
		 * The size must be 8-byte aligned.  If the size is not 8-byte
		 * aligned, drop it down by the difference.
		 */</span>
		<span class="enscript-keyword">if</span> (size &amp; (<span class="enscript-keyword">sizeof</span> (uint64_t) - 1))
			size -= size &amp; (<span class="enscript-keyword">sizeof</span> (uint64_t) - 1);

		<span class="enscript-keyword">if</span> (size &lt; state-&gt;dts_reserve) {
			<span class="enscript-comment">/*
			 * Buffers always must be large enough to accommodate
			 * their prereserved space.  We return E2BIG instead
			 * of ENOMEM in this case to allow for user-level
			 * software to differentiate the cases.
			 */</span>
			<span class="enscript-keyword">return</span> (E2BIG);
		}

		rval = dtrace_buffer_alloc(buf, size, flags, cpu);

		<span class="enscript-keyword">if</span> (rval != ENOMEM) {
			opt[which] = size;
			<span class="enscript-keyword">return</span> (rval);
		}

		<span class="enscript-keyword">if</span> (opt[DTRACEOPT_BUFRESIZE] == DTRACEOPT_BUFRESIZE_MANUAL)
			<span class="enscript-keyword">return</span> (rval);
	}

	<span class="enscript-keyword">return</span> (ENOMEM);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_state_buffers</span>(dtrace_state_t *state)
{
	dtrace_speculation_t *spec = state-&gt;dts_speculations;
	<span class="enscript-type">int</span> rval, i;

	<span class="enscript-keyword">if</span> ((rval = dtrace_state_buffer(state, state-&gt;dts_buffer,
	    DTRACEOPT_BUFSIZE)) != 0)
		<span class="enscript-keyword">return</span> (rval);

	<span class="enscript-keyword">if</span> ((rval = dtrace_state_buffer(state, state-&gt;dts_aggbuffer,
	    DTRACEOPT_AGGSIZE)) != 0)
		<span class="enscript-keyword">return</span> (rval);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; state-&gt;dts_nspeculations; i++) {
		<span class="enscript-keyword">if</span> ((rval = dtrace_state_buffer(state,
		    spec[i].dtsp_buffer, DTRACEOPT_SPECSIZE)) != 0)
			<span class="enscript-keyword">return</span> (rval);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_state_prereserve</span>(dtrace_state_t *state)
{
	dtrace_ecb_t *ecb;
	dtrace_probe_t *probe;

	state-&gt;dts_reserve = 0;

	<span class="enscript-keyword">if</span> (state-&gt;dts_options[DTRACEOPT_BUFPOLICY] != DTRACEOPT_BUFPOLICY_FILL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * If our buffer policy is a &quot;fill&quot; buffer policy, we need to set the
	 * prereserved space to be the space required by the END probes.
	 */</span>
	probe = dtrace_probes[dtrace_probeid_end - 1];
	ASSERT(probe != NULL);

	<span class="enscript-keyword">for</span> (ecb = probe-&gt;dtpr_ecb; ecb != NULL; ecb = ecb-&gt;dte_next) {
		<span class="enscript-keyword">if</span> (ecb-&gt;dte_state != state)
			<span class="enscript-keyword">continue</span>;

		state-&gt;dts_reserve += ecb-&gt;dte_needed + ecb-&gt;dte_alignment;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_state_go</span>(dtrace_state_t *state, processorid_t *cpu)
{
	dtrace_optval_t *opt = state-&gt;dts_options, sz, nspec;
	dtrace_speculation_t *spec;
	dtrace_buffer_t *buf;
	cyc_handler_t hdlr;
	cyc_time_t when;
	<span class="enscript-type">int</span> rval = 0, i, bufsize = (<span class="enscript-type">int</span>)NCPU * <span class="enscript-keyword">sizeof</span> (dtrace_buffer_t);
	dtrace_icookie_t cookie;

	lck_mtx_lock(&amp;cpu_lock);
	lck_mtx_lock(&amp;dtrace_lock);

	<span class="enscript-keyword">if</span> (state-&gt;dts_activity != DTRACE_ACTIVITY_INACTIVE) {
		rval = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Before we can perform any checks, we must prime all of the
	 * retained enablings that correspond to this state.
	 */</span>
	dtrace_enabling_prime(state);

	<span class="enscript-keyword">if</span> (state-&gt;dts_destructive &amp;&amp; !state-&gt;dts_cred.dcr_destructive) {
		rval = EACCES;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	dtrace_state_prereserve(state);

	<span class="enscript-comment">/*
	 * Now we want to do is try to allocate our speculations.
	 * We do not automatically resize the number of speculations; if
	 * this fails, we will fail the operation.
	 */</span>
	nspec = opt[DTRACEOPT_NSPEC];
	ASSERT(nspec != DTRACEOPT_UNSET);

	<span class="enscript-keyword">if</span> (nspec &gt; INT_MAX) {
		rval = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	spec = kmem_zalloc(nspec * <span class="enscript-keyword">sizeof</span> (dtrace_speculation_t), KM_NOSLEEP);

	<span class="enscript-keyword">if</span> (spec == NULL) {
		rval = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	state-&gt;dts_speculations = spec;
	state-&gt;dts_nspeculations = (<span class="enscript-type">int</span>)nspec;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; nspec; i++) {
		<span class="enscript-keyword">if</span> ((buf = kmem_zalloc(bufsize, KM_NOSLEEP)) == NULL) {
			rval = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
		}

		spec[i].dtsp_buffer = buf;
	}

	<span class="enscript-keyword">if</span> (opt[DTRACEOPT_GRABANON] != DTRACEOPT_UNSET) {
		<span class="enscript-keyword">if</span> (dtrace_anon.dta_state == NULL) {
			rval = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-keyword">if</span> (state-&gt;dts_necbs != 0) {
			rval = EALREADY;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		state-&gt;dts_anon = dtrace_anon_grab();
		ASSERT(state-&gt;dts_anon != NULL);
		state = state-&gt;dts_anon;

		<span class="enscript-comment">/*
		 * We want &quot;grabanon&quot; to be set in the grabbed state, so we'll
		 * copy that option value from the grabbing state into the
		 * grabbed state.
		 */</span>
		state-&gt;dts_options[DTRACEOPT_GRABANON] =
		    opt[DTRACEOPT_GRABANON];

		*cpu = dtrace_anon.dta_beganon;

		<span class="enscript-comment">/*
		 * If the anonymous state is active (as it almost certainly
		 * is if the anonymous enabling ultimately matched anything),
		 * we don't allow any further option processing -- but we
		 * don't return failure.
		 */</span>
		<span class="enscript-keyword">if</span> (state-&gt;dts_activity != DTRACE_ACTIVITY_INACTIVE)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (opt[DTRACEOPT_AGGSIZE] != DTRACEOPT_UNSET &amp;&amp;
	    opt[DTRACEOPT_AGGSIZE] != 0) {
		<span class="enscript-keyword">if</span> (state-&gt;dts_aggregations == NULL) {
			<span class="enscript-comment">/*
			 * We're not going to create an aggregation buffer
			 * because we don't have any ECBs that contain
			 * aggregations -- set this option to 0.
			 */</span>
			opt[DTRACEOPT_AGGSIZE] = 0;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * If we have an aggregation buffer, we must also have
			 * a buffer to use as scratch.
			 */</span>
			<span class="enscript-keyword">if</span> (opt[DTRACEOPT_BUFSIZE] == DTRACEOPT_UNSET ||
			  (size_t)opt[DTRACEOPT_BUFSIZE] &lt; state-&gt;dts_needed) {
				opt[DTRACEOPT_BUFSIZE] = state-&gt;dts_needed;
			}
		}
	}

	<span class="enscript-keyword">if</span> (opt[DTRACEOPT_SPECSIZE] != DTRACEOPT_UNSET &amp;&amp;
	    opt[DTRACEOPT_SPECSIZE] != 0) {
		<span class="enscript-keyword">if</span> (!state-&gt;dts_speculates) {
			<span class="enscript-comment">/*
			 * We're not going to create speculation buffers
			 * because we don't have any ECBs that actually
			 * speculate -- set the speculation size to 0.
			 */</span>
			opt[DTRACEOPT_SPECSIZE] = 0;
		}
	}

	<span class="enscript-comment">/*
	 * The bare minimum size for any buffer that we're actually going to
	 * do anything to is sizeof (uint64_t).
	 */</span>
	sz = <span class="enscript-keyword">sizeof</span> (uint64_t);

	<span class="enscript-keyword">if</span> ((state-&gt;dts_needed != 0 &amp;&amp; opt[DTRACEOPT_BUFSIZE] &lt; sz) ||
	    (state-&gt;dts_speculates &amp;&amp; opt[DTRACEOPT_SPECSIZE] &lt; sz) ||
	    (state-&gt;dts_aggregations != NULL &amp;&amp; opt[DTRACEOPT_AGGSIZE] &lt; sz)) {
		<span class="enscript-comment">/*
		 * A buffer size has been explicitly set to 0 (or to a size
		 * that will be adjusted to 0) and we need the space -- we
		 * need to return failure.  We return ENOSPC to differentiate
		 * it from failing to allocate a buffer due to failure to meet
		 * the reserve (for which we return E2BIG).
		 */</span>
		rval = ENOSPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> ((rval = dtrace_state_buffers(state)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

	<span class="enscript-keyword">if</span> ((sz = opt[DTRACEOPT_DYNVARSIZE]) == DTRACEOPT_UNSET)
		sz = dtrace_dstate_defsize;

	<span class="enscript-keyword">do</span> {
		rval = dtrace_dstate_init(&amp;state-&gt;dts_vstate.dtvs_dynvars, sz);

		<span class="enscript-keyword">if</span> (rval == 0)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (opt[DTRACEOPT_BUFRESIZE] == DTRACEOPT_BUFRESIZE_MANUAL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
	} <span class="enscript-keyword">while</span> (sz &gt;&gt;= 1);

	opt[DTRACEOPT_DYNVARSIZE] = sz;

	<span class="enscript-keyword">if</span> (rval != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

	<span class="enscript-keyword">if</span> (opt[DTRACEOPT_STATUSRATE] &gt; dtrace_statusrate_max)
		opt[DTRACEOPT_STATUSRATE] = dtrace_statusrate_max;

	<span class="enscript-keyword">if</span> (opt[DTRACEOPT_CLEANRATE] == 0)
		opt[DTRACEOPT_CLEANRATE] = dtrace_cleanrate_max;

	<span class="enscript-keyword">if</span> (opt[DTRACEOPT_CLEANRATE] &lt; dtrace_cleanrate_min)
		opt[DTRACEOPT_CLEANRATE] = dtrace_cleanrate_min;

	<span class="enscript-keyword">if</span> (opt[DTRACEOPT_CLEANRATE] &gt; dtrace_cleanrate_max)
		opt[DTRACEOPT_CLEANRATE] = dtrace_cleanrate_max;

	hdlr.cyh_func = (cyc_func_t)dtrace_state_clean;
	hdlr.cyh_arg = state;
	hdlr.cyh_level = CY_LOW_LEVEL;

	when.cyt_when = 0;
	when.cyt_interval = opt[DTRACEOPT_CLEANRATE];

	state-&gt;dts_cleaner = cyclic_add(&amp;hdlr, &amp;when);

	hdlr.cyh_func = (cyc_func_t)dtrace_state_deadman;
	hdlr.cyh_arg = state;
	hdlr.cyh_level = CY_LOW_LEVEL;

	when.cyt_when = 0;
	when.cyt_interval = dtrace_deadman_interval;

	state-&gt;dts_alive = state-&gt;dts_laststatus = dtrace_gethrtime();
	state-&gt;dts_deadman = cyclic_add(&amp;hdlr, &amp;when);

	state-&gt;dts_activity = DTRACE_ACTIVITY_WARMUP;

	<span class="enscript-comment">/*
	 * Now it's time to actually fire the BEGIN probe.  We need to disable
	 * interrupts here both to record the CPU on which we fired the BEGIN
	 * probe (the data from this CPU will be processed first at user
	 * level) and to manually activate the buffer for this CPU.
	 */</span>
	cookie = dtrace_interrupt_disable();
	*cpu = CPU-&gt;cpu_id;
	ASSERT(state-&gt;dts_buffer[*cpu].dtb_flags &amp; DTRACEBUF_INACTIVE);
	state-&gt;dts_buffer[*cpu].dtb_flags &amp;= ~DTRACEBUF_INACTIVE;

	dtrace_probe(dtrace_probeid_begin,
	    (uint64_t)(uintptr_t)state, 0, 0, 0, 0);
	dtrace_interrupt_enable(cookie);
	<span class="enscript-comment">/*
	 * We may have had an exit action from a BEGIN probe; only change our
	 * state to ACTIVE if we're still in WARMUP.
	 */</span>
	ASSERT(state-&gt;dts_activity == DTRACE_ACTIVITY_WARMUP ||
	    state-&gt;dts_activity == DTRACE_ACTIVITY_DRAINING);

	<span class="enscript-keyword">if</span> (state-&gt;dts_activity == DTRACE_ACTIVITY_WARMUP)
		state-&gt;dts_activity = DTRACE_ACTIVITY_ACTIVE;

	<span class="enscript-comment">/*
	 * Regardless of whether or not now we're in ACTIVE or DRAINING, we
	 * want each CPU to transition its principal buffer out of the
	 * INACTIVE state.  Doing this assures that no CPU will suddenly begin
	 * processing an ECB halfway down a probe's ECB chain; all CPUs will
	 * atomically transition from processing none of a state's ECBs to
	 * processing all of them.
	 */</span>
	dtrace_xcall(DTRACE_CPUALL,
	    (dtrace_xcall_t)dtrace_buffer_activate, state);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

<span class="enscript-reference">err</span>:
	dtrace_buffer_free(state-&gt;dts_buffer);
	dtrace_buffer_free(state-&gt;dts_aggbuffer);

	<span class="enscript-keyword">if</span> ((nspec = state-&gt;dts_nspeculations) == 0) {
		ASSERT(state-&gt;dts_speculations == NULL);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	spec = state-&gt;dts_speculations;
	ASSERT(spec != NULL);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; state-&gt;dts_nspeculations; i++) {
		<span class="enscript-keyword">if</span> ((buf = spec[i].dtsp_buffer) == NULL)
			<span class="enscript-keyword">break</span>;

		dtrace_buffer_free(buf);
		kmem_free(buf, bufsize);
	}

	kmem_free(spec, nspec * <span class="enscript-keyword">sizeof</span> (dtrace_speculation_t));
	state-&gt;dts_nspeculations = 0;
	state-&gt;dts_speculations = NULL;

<span class="enscript-reference">out</span>:
	lck_mtx_unlock(&amp;dtrace_lock);
	lck_mtx_unlock(&amp;cpu_lock);

	<span class="enscript-keyword">return</span> (rval);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_state_stop</span>(dtrace_state_t *state, processorid_t *cpu)
{
	dtrace_icookie_t cookie;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (state-&gt;dts_activity != DTRACE_ACTIVITY_ACTIVE &amp;&amp;
	    state-&gt;dts_activity != DTRACE_ACTIVITY_DRAINING)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/*
	 * We'll set the activity to DTRACE_ACTIVITY_DRAINING, and issue a sync
	 * to be sure that every CPU has seen it.  See below for the details
	 * on why this is done.
	 */</span>
	state-&gt;dts_activity = DTRACE_ACTIVITY_DRAINING;
	dtrace_sync();

	<span class="enscript-comment">/*
	 * By this point, it is impossible for any CPU to be still processing
	 * with DTRACE_ACTIVITY_ACTIVE.  We can thus set our activity to
	 * DTRACE_ACTIVITY_COOLDOWN and know that we're not racing with any
	 * other CPU in dtrace_buffer_reserve().  This allows dtrace_probe()
	 * and callees to know that the activity is DTRACE_ACTIVITY_COOLDOWN
	 * iff we're in the END probe.
	 */</span>
	state-&gt;dts_activity = DTRACE_ACTIVITY_COOLDOWN;
	dtrace_sync();
	ASSERT(state-&gt;dts_activity == DTRACE_ACTIVITY_COOLDOWN);

	<span class="enscript-comment">/*
	 * Finally, we can release the reserve and call the END probe.  We
	 * disable interrupts across calling the END probe to allow us to
	 * return the CPU on which we actually called the END probe.  This
	 * allows user-land to be sure that this CPU's principal buffer is
	 * processed last.
	 */</span>
	state-&gt;dts_reserve = 0;

	cookie = dtrace_interrupt_disable();
	*cpu = CPU-&gt;cpu_id;
	dtrace_probe(dtrace_probeid_end,
	    (uint64_t)(uintptr_t)state, 0, 0, 0, 0);
	dtrace_interrupt_enable(cookie);

	state-&gt;dts_activity = DTRACE_ACTIVITY_STOPPED;
	dtrace_sync();

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_state_option</span>(dtrace_state_t *state, dtrace_optid_t option,
    dtrace_optval_t val)
{
	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (state-&gt;dts_activity != DTRACE_ACTIVITY_INACTIVE)
		<span class="enscript-keyword">return</span> (EBUSY);

	<span class="enscript-keyword">if</span> (option &gt;= DTRACEOPT_MAX)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (option != DTRACEOPT_CPU &amp;&amp; val &lt; 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">switch</span> (option) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEOPT_DESTRUCTIVE</span>:
		<span class="enscript-comment">/*
		 * Prevent consumers from enabling destructive actions if DTrace
		 * is running in a restricted environment, or if actions are
		 * disallowed.
		 */</span>
		<span class="enscript-keyword">if</span> (dtrace_is_restricted() || dtrace_destructive_disallow)
			<span class="enscript-keyword">return</span> (EACCES);

		state-&gt;dts_cred.dcr_destructive = 1;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEOPT_BUFSIZE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEOPT_DYNVARSIZE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEOPT_AGGSIZE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEOPT_SPECSIZE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEOPT_STRSIZE</span>:
		<span class="enscript-keyword">if</span> (val &lt; 0)
			<span class="enscript-keyword">return</span> (EINVAL);

		<span class="enscript-keyword">if</span> (val &gt;= LONG_MAX) {
			<span class="enscript-comment">/*
			 * If this is an otherwise negative value, set it to
			 * the highest multiple of 128m less than LONG_MAX.
			 * Technically, we're adjusting the size without
			 * regard to the buffer resizing policy, but in fact,
			 * this has no effect -- if we set the buffer size to
			 * ~LONG_MAX and the buffer policy is ultimately set to
			 * be &quot;manual&quot;, the buffer allocation is guaranteed to
			 * fail, if only because the allocation requires two
			 * buffers.  (We set the the size to the highest
			 * multiple of 128m because it ensures that the size
			 * will remain a multiple of a megabyte when
			 * repeatedly halved -- all the way down to 15m.)
			 */</span>
			val = LONG_MAX - (1 &lt;&lt; 27) + 1;
		}
	}

	state-&gt;dts_options[option] = val;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_state_destroy</span>(dtrace_state_t *state)
{
	dtrace_ecb_t *ecb;
	dtrace_vstate_t *vstate = &amp;state-&gt;dts_vstate;
	minor_t minor = getminor(state-&gt;dts_dev);
	<span class="enscript-type">int</span> i, bufsize = (<span class="enscript-type">int</span>)NCPU * <span class="enscript-keyword">sizeof</span> (dtrace_buffer_t);
	dtrace_speculation_t *spec = state-&gt;dts_speculations;
	<span class="enscript-type">int</span> nspec = state-&gt;dts_nspeculations;
	uint32_t match;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	lck_mtx_assert(&amp;cpu_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/*
	 * First, retract any retained enablings for this state.
	 */</span>
	dtrace_enabling_retract(state);
	ASSERT(state-&gt;dts_nretained == 0);

	<span class="enscript-keyword">if</span> (state-&gt;dts_activity == DTRACE_ACTIVITY_ACTIVE ||
	    state-&gt;dts_activity == DTRACE_ACTIVITY_DRAINING) {
		<span class="enscript-comment">/*
		 * We have managed to come into dtrace_state_destroy() on a
		 * hot enabling -- almost certainly because of a disorderly
		 * shutdown of a consumer.  (That is, a consumer that is
		 * exiting without having called dtrace_stop().) In this case,
		 * we're going to set our activity to be KILLED, and then
		 * issue a sync to be sure that everyone is out of probe
		 * context before we start blowing away ECBs.
		 */</span>
		state-&gt;dts_activity = DTRACE_ACTIVITY_KILLED;
		dtrace_sync();
	}

	<span class="enscript-comment">/*
	 * Release the credential hold we took in dtrace_state_create().
	 */</span>
	<span class="enscript-keyword">if</span> (state-&gt;dts_cred.dcr_cred != NULL)
		crfree(state-&gt;dts_cred.dcr_cred);

	<span class="enscript-comment">/*
	 * Now we can safely disable and destroy any enabled probes.  Because
	 * any DTRACE_PRIV_KERNEL probes may actually be slowing our progress
	 * (especially if they're all enabled), we take two passes through the
	 * ECBs:  in the first, we disable just DTRACE_PRIV_KERNEL probes, and
	 * in the second we disable whatever is left over.
	 */</span>
	<span class="enscript-keyword">for</span> (match = DTRACE_PRIV_KERNEL; ; match = 0) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; state-&gt;dts_necbs; i++) {
			<span class="enscript-keyword">if</span> ((ecb = state-&gt;dts_ecbs[i]) == NULL)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (match &amp;&amp; ecb-&gt;dte_probe != NULL) {
				dtrace_probe_t *probe = ecb-&gt;dte_probe;
				dtrace_provider_t *prov = probe-&gt;dtpr_provider;

				<span class="enscript-keyword">if</span> (!(prov-&gt;dtpv_priv.dtpp_flags &amp; match))
					<span class="enscript-keyword">continue</span>;
			}

			dtrace_ecb_disable(ecb);
			dtrace_ecb_destroy(ecb);
		}

		<span class="enscript-keyword">if</span> (!match)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * Before we free the buffers, perform one more sync to assure that
	 * every CPU is out of probe context.
	 */</span>
	dtrace_sync();

	dtrace_buffer_free(state-&gt;dts_buffer);
	dtrace_buffer_free(state-&gt;dts_aggbuffer);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; nspec; i++)
		dtrace_buffer_free(spec[i].dtsp_buffer);

	<span class="enscript-keyword">if</span> (state-&gt;dts_cleaner != CYCLIC_NONE)
		cyclic_remove(state-&gt;dts_cleaner);

	<span class="enscript-keyword">if</span> (state-&gt;dts_deadman != CYCLIC_NONE)
		cyclic_remove(state-&gt;dts_deadman);

	dtrace_dstate_fini(&amp;vstate-&gt;dtvs_dynvars);
	dtrace_vstate_fini(vstate);
	kmem_free(state-&gt;dts_ecbs, state-&gt;dts_necbs * <span class="enscript-keyword">sizeof</span> (dtrace_ecb_t *));

	<span class="enscript-keyword">if</span> (state-&gt;dts_aggregations != NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; state-&gt;dts_naggregations; i++)
			ASSERT(state-&gt;dts_aggregations[i] == NULL);
#<span class="enscript-reference">endif</span>
		ASSERT(state-&gt;dts_naggregations &gt; 0);
		kmem_free(state-&gt;dts_aggregations,
		    state-&gt;dts_naggregations * <span class="enscript-keyword">sizeof</span> (dtrace_aggregation_t *));
	}

	kmem_free(state-&gt;dts_buffer, bufsize);
	kmem_free(state-&gt;dts_aggbuffer, bufsize);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; nspec; i++)
		kmem_free(spec[i].dtsp_buffer, bufsize);

	kmem_free(spec, nspec * <span class="enscript-keyword">sizeof</span> (dtrace_speculation_t));

	dtrace_format_destroy(state);

	vmem_destroy(state-&gt;dts_aggid_arena);
	ddi_soft_state_free(dtrace_softstate, minor);
	vmem_free(dtrace_minor, (<span class="enscript-type">void</span> *)(uintptr_t)minor, 1);
}

<span class="enscript-comment">/*
 * DTrace Anonymous Enabling Functions
 */</span>
<span class="enscript-type">static</span> dtrace_state_t *
<span class="enscript-function-name">dtrace_anon_grab</span>(<span class="enscript-type">void</span>)
{
	dtrace_state_t *state;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> ((state = dtrace_anon.dta_state) == NULL) {
		ASSERT(dtrace_anon.dta_enabling == NULL);
		<span class="enscript-keyword">return</span> (NULL);
	}

	ASSERT(dtrace_anon.dta_enabling != NULL);
	ASSERT(dtrace_retained != NULL);

	dtrace_enabling_destroy(dtrace_anon.dta_enabling);
	dtrace_anon.dta_enabling = NULL;
	dtrace_anon.dta_state = NULL;

	<span class="enscript-keyword">return</span> (state);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_anon_property</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i, rv;
	dtrace_state_t *state;
	dof_hdr_t *dof;
	<span class="enscript-type">char</span> c[32];		<span class="enscript-comment">/* enough for &quot;dof-data-&quot; + digits */</span>

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	lck_mtx_assert(&amp;cpu_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">for</span> (i = 0; ; i++) {
		(<span class="enscript-type">void</span>) snprintf(c, <span class="enscript-keyword">sizeof</span> (c), <span class="enscript-string">&quot;dof-data-%d&quot;</span>, i);

		dtrace_err_verbose = 1;

		<span class="enscript-keyword">if</span> ((dof = dtrace_dof_property(c)) == NULL) {
			dtrace_err_verbose = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * We want to create anonymous state, so we need to transition
		 * the kernel debugger to indicate that DTrace is active.  If
		 * this fails (e.g. because the debugger has modified text in
		 * some way), we won't continue with the processing.
		 */</span>
		<span class="enscript-keyword">if</span> (kdi_dtrace_set(KDI_DTSET_DTRACE_ACTIVATE) != 0) {
			cmn_err(CE_NOTE, <span class="enscript-string">&quot;kernel debugger active; anonymous &quot;</span>
			    <span class="enscript-string">&quot;enabling ignored.&quot;</span>);
			dtrace_dof_destroy(dof);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * If we haven't allocated an anonymous state, we'll do so now.
		 */</span>
		<span class="enscript-keyword">if</span> ((state = dtrace_anon.dta_state) == NULL) {
			rv = dtrace_state_create(NULL, NULL, &amp;state);
			dtrace_anon.dta_state = state;
			<span class="enscript-keyword">if</span> (rv != 0 || state == NULL) {
				<span class="enscript-comment">/*
				 * This basically shouldn't happen:  the only
				 * failure mode from dtrace_state_create() is a
				 * failure of ddi_soft_state_zalloc() that
				 * itself should never happen.  Still, the
				 * interface allows for a failure mode, and
				 * we want to fail as gracefully as possible:
				 * we'll emit an error message and cease
				 * processing anonymous state in this case.
				 */</span>
				cmn_err(CE_WARN, <span class="enscript-string">&quot;failed to create &quot;</span>
				    <span class="enscript-string">&quot;anonymous state&quot;</span>);
				dtrace_dof_destroy(dof);
				<span class="enscript-keyword">break</span>;
			}
		}

		rv = dtrace_dof_slurp(dof, &amp;state-&gt;dts_vstate, CRED(),
		    &amp;dtrace_anon.dta_enabling, 0, B_TRUE);

		<span class="enscript-keyword">if</span> (rv == 0)
			rv = dtrace_dof_options(dof, state);

		dtrace_err_verbose = 0;
		dtrace_dof_destroy(dof);

		<span class="enscript-keyword">if</span> (rv != 0) {
			<span class="enscript-comment">/*
			 * This is malformed DOF; chuck any anonymous state
			 * that we created.
			 */</span>
			ASSERT(dtrace_anon.dta_enabling == NULL);
			dtrace_state_destroy(state);
			dtrace_anon.dta_state = NULL;
			<span class="enscript-keyword">break</span>;
		}

		ASSERT(dtrace_anon.dta_enabling != NULL);
	}

	<span class="enscript-keyword">if</span> (dtrace_anon.dta_enabling != NULL) {
		<span class="enscript-type">int</span> rval;

		<span class="enscript-comment">/*
		 * dtrace_enabling_retain() can only fail because we are
		 * trying to retain more enablings than are allowed -- but
		 * we only have one anonymous enabling, and we are guaranteed
		 * to be allowed at least one retained enabling; we assert
		 * that dtrace_enabling_retain() returns success.
		 */</span>
		rval = dtrace_enabling_retain(dtrace_anon.dta_enabling);
		ASSERT(rval == 0);

		dtrace_enabling_dump(dtrace_anon.dta_enabling);
	}
}

<span class="enscript-comment">/*
 * DTrace Helper Functions
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_helper_trace</span>(dtrace_helper_action_t *helper,
    dtrace_mstate_t *mstate, dtrace_vstate_t *vstate, <span class="enscript-type">int</span> where)
{
	uint32_t size, next, nnext;
	<span class="enscript-type">int</span> i;
	dtrace_helptrace_t *ent;
	uint16_t flags = cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags;

	<span class="enscript-keyword">if</span> (!dtrace_helptrace_enabled)
		<span class="enscript-keyword">return</span>;

	ASSERT((uint32_t)vstate-&gt;dtvs_nlocals &lt;= dtrace_helptrace_nlocals);

	<span class="enscript-comment">/*
	 * What would a tracing framework be without its own tracing
	 * framework?  (Well, a hell of a lot simpler, for starters...)
	 */</span>
	size = <span class="enscript-keyword">sizeof</span> (dtrace_helptrace_t) + dtrace_helptrace_nlocals *
	    <span class="enscript-keyword">sizeof</span> (uint64_t) - <span class="enscript-keyword">sizeof</span> (uint64_t);

	<span class="enscript-comment">/*
	 * Iterate until we can allocate a slot in the trace buffer.
	 */</span>
	<span class="enscript-keyword">do</span> {
		next = dtrace_helptrace_next;

		<span class="enscript-keyword">if</span> (next + size &lt; dtrace_helptrace_bufsize) {
			nnext = next + size;
		} <span class="enscript-keyword">else</span> {
			nnext = size;
		}
	} <span class="enscript-keyword">while</span> (dtrace_cas32(&amp;dtrace_helptrace_next, next, nnext) != next);

	<span class="enscript-comment">/*
	 * We have our slot; fill it in.
	 */</span>
	<span class="enscript-keyword">if</span> (nnext == size)
		next = 0;

	ent = (dtrace_helptrace_t *)&amp;dtrace_helptrace_buffer[next];
	ent-&gt;dtht_helper = helper;
	ent-&gt;dtht_where = where;
	ent-&gt;dtht_nlocals = vstate-&gt;dtvs_nlocals;

	ent-&gt;dtht_fltoffs = (mstate-&gt;dtms_present &amp; DTRACE_MSTATE_FLTOFFS) ?
	    mstate-&gt;dtms_fltoffs : -1;
	ent-&gt;dtht_fault = DTRACE_FLAGS2FLT(flags);
	ent-&gt;dtht_illval = cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_illval;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; vstate-&gt;dtvs_nlocals; i++) {
		dtrace_statvar_t *svar;

		<span class="enscript-keyword">if</span> ((svar = vstate-&gt;dtvs_locals[i]) == NULL)
			<span class="enscript-keyword">continue</span>;

		ASSERT(svar-&gt;dtsv_size &gt;= (<span class="enscript-type">int</span>)NCPU * <span class="enscript-keyword">sizeof</span> (uint64_t));
		ent-&gt;dtht_locals[i] =
		    ((uint64_t *)(uintptr_t)svar-&gt;dtsv_data)[CPU-&gt;cpu_id];
	}
}

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">dtrace_helper</span>(<span class="enscript-type">int</span> which, dtrace_mstate_t *mstate,
    dtrace_state_t *state, uint64_t arg0, uint64_t arg1)
{
	uint16_t *flags = &amp;cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags;
	uint64_t sarg0 = mstate-&gt;dtms_arg[0];
	uint64_t sarg1 = mstate-&gt;dtms_arg[1];
	uint64_t rval = 0;
	dtrace_helpers_t *helpers = curproc-&gt;p_dtrace_helpers;
	dtrace_helper_action_t *helper;
	dtrace_vstate_t *vstate;
	dtrace_difo_t *pred;
	<span class="enscript-type">int</span> i, trace = dtrace_helptrace_enabled;

	ASSERT(which &gt;= 0 &amp;&amp; which &lt; DTRACE_NHELPER_ACTIONS);

	<span class="enscript-keyword">if</span> (helpers == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> ((helper = helpers-&gt;dthps_actions[which]) == NULL)
		<span class="enscript-keyword">return</span> (0);

	vstate = &amp;helpers-&gt;dthps_vstate;
	mstate-&gt;dtms_arg[0] = arg0;
	mstate-&gt;dtms_arg[1] = arg1;

	<span class="enscript-comment">/*
	 * Now iterate over each helper.  If its predicate evaluates to 'true',
	 * we'll call the corresponding actions.  Note that the below calls
	 * to dtrace_dif_emulate() may set faults in machine state.  This is
	 * okay:  our caller (the outer dtrace_dif_emulate()) will simply plow
	 * the stored DIF offset with its own (which is the desired behavior).
	 * Also, note the calls to dtrace_dif_emulate() may allocate scratch
	 * from machine state; this is okay, too.
	 */</span>
	<span class="enscript-keyword">for</span> (; helper != NULL; helper = helper-&gt;dtha_next) {
		<span class="enscript-keyword">if</span> ((pred = helper-&gt;dtha_predicate) != NULL) {
			<span class="enscript-keyword">if</span> (trace)
				dtrace_helper_trace(helper, mstate, vstate, 0);

			<span class="enscript-keyword">if</span> (!dtrace_dif_emulate(pred, mstate, vstate, state))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;

			<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_FAULT)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
		}

		<span class="enscript-keyword">for</span> (i = 0; i &lt; helper-&gt;dtha_nactions; i++) {
			<span class="enscript-keyword">if</span> (trace)
				dtrace_helper_trace(helper,
				    mstate, vstate, i + 1);

			rval = dtrace_dif_emulate(helper-&gt;dtha_actions[i],
			    mstate, vstate, state);

			<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_FAULT)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;
		}

<span class="enscript-reference">next</span>:
		<span class="enscript-keyword">if</span> (trace)
			dtrace_helper_trace(helper, mstate, vstate,
			    DTRACE_HELPTRACE_NEXT);
	}

	<span class="enscript-keyword">if</span> (trace)
		dtrace_helper_trace(helper, mstate, vstate,
		    DTRACE_HELPTRACE_DONE);

	<span class="enscript-comment">/*
	 * Restore the arg0 that we saved upon entry.
	 */</span>
	mstate-&gt;dtms_arg[0] = sarg0;
	mstate-&gt;dtms_arg[1] = sarg1;

	<span class="enscript-keyword">return</span> (rval);

<span class="enscript-reference">err</span>:
	<span class="enscript-keyword">if</span> (trace)
		dtrace_helper_trace(helper, mstate, vstate,
		    DTRACE_HELPTRACE_ERR);

	<span class="enscript-comment">/*
	 * Restore the arg0 that we saved upon entry.
	 */</span>
	mstate-&gt;dtms_arg[0] = sarg0;
	mstate-&gt;dtms_arg[1] = sarg1;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_helper_action_destroy</span>(dtrace_helper_action_t *helper,
    dtrace_vstate_t *vstate)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (helper-&gt;dtha_predicate != NULL)
		dtrace_difo_release(helper-&gt;dtha_predicate, vstate);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; helper-&gt;dtha_nactions; i++) {
		ASSERT(helper-&gt;dtha_actions[i] != NULL);
		dtrace_difo_release(helper-&gt;dtha_actions[i], vstate);
	}

	kmem_free(helper-&gt;dtha_actions,
	    helper-&gt;dtha_nactions * <span class="enscript-keyword">sizeof</span> (dtrace_difo_t *));
	kmem_free(helper, <span class="enscript-keyword">sizeof</span> (dtrace_helper_action_t));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_helper_destroygen</span>(proc_t* p, <span class="enscript-type">int</span> gen)
{
	dtrace_helpers_t *help = p-&gt;p_dtrace_helpers;
	dtrace_vstate_t *vstate;
	uint_t i;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (help == NULL || gen &gt; help-&gt;dthps_generation)
		<span class="enscript-keyword">return</span> (EINVAL);

	vstate = &amp;help-&gt;dthps_vstate;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; DTRACE_NHELPER_ACTIONS; i++) {
		dtrace_helper_action_t *last = NULL, *h, *next;

		<span class="enscript-keyword">for</span> (h = help-&gt;dthps_actions[i]; h != NULL; h = next) {
			next = h-&gt;dtha_next;

			<span class="enscript-keyword">if</span> (h-&gt;dtha_generation == gen) {
				<span class="enscript-keyword">if</span> (last != NULL) {
					last-&gt;dtha_next = next;
				} <span class="enscript-keyword">else</span> {
					help-&gt;dthps_actions[i] = next;
				}

				dtrace_helper_action_destroy(h, vstate);
			} <span class="enscript-keyword">else</span> {
				last = h;
			}
		}
	}

	<span class="enscript-comment">/*
	 * Interate until we've cleared out all helper providers with the
	 * given generation number.
	 */</span>
	<span class="enscript-keyword">for</span> (;;) {
		dtrace_helper_provider_t *prov = NULL;

		<span class="enscript-comment">/*
		 * Look for a helper provider with the right generation. We
		 * have to start back at the beginning of the list each time
		 * because we drop dtrace_lock. It's unlikely that we'll make
		 * more than two passes.
		 */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; help-&gt;dthps_nprovs; i++) {
			prov = help-&gt;dthps_provs[i];

			<span class="enscript-keyword">if</span> (prov-&gt;dthp_generation == gen)
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * If there were no matches, we're done.
		 */</span>
		<span class="enscript-keyword">if</span> (i == help-&gt;dthps_nprovs)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * Move the last helper provider into this slot.
		 */</span>
		help-&gt;dthps_nprovs--;
		help-&gt;dthps_provs[i] = help-&gt;dthps_provs[help-&gt;dthps_nprovs];
		help-&gt;dthps_provs[help-&gt;dthps_nprovs] = NULL;

		lck_mtx_unlock(&amp;dtrace_lock);

		<span class="enscript-comment">/*
		 * If we have a meta provider, remove this helper provider.
		 */</span>
		lck_mtx_lock(&amp;dtrace_meta_lock);
		<span class="enscript-keyword">if</span> (dtrace_meta_pid != NULL) {
			ASSERT(dtrace_deferred_pid == NULL);
			dtrace_helper_provider_remove(&amp;prov-&gt;dthp_prov,
			    p-&gt;p_pid);
		}
		lck_mtx_unlock(&amp;dtrace_meta_lock);

		dtrace_helper_provider_destroy(prov);

		lck_mtx_lock(&amp;dtrace_lock);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_helper_validate</span>(dtrace_helper_action_t *helper)
{
	<span class="enscript-type">int</span> err = 0, i;
	dtrace_difo_t *dp;

	<span class="enscript-keyword">if</span> ((dp = helper-&gt;dtha_predicate) != NULL)
		err += dtrace_difo_validate_helper(dp);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; helper-&gt;dtha_nactions; i++)
		err += dtrace_difo_validate_helper(helper-&gt;dtha_actions[i]);

	<span class="enscript-keyword">return</span> (err == 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_helper_action_add</span>(proc_t* p, <span class="enscript-type">int</span> which, dtrace_ecbdesc_t *ep)
{
	dtrace_helpers_t *help;
	dtrace_helper_action_t *helper, *last;
	dtrace_actdesc_t *act;
	dtrace_vstate_t *vstate;
	dtrace_predicate_t *pred;
	<span class="enscript-type">int</span> count = 0, nactions = 0, i;

	<span class="enscript-keyword">if</span> (which &lt; 0 || which &gt;= DTRACE_NHELPER_ACTIONS)
		<span class="enscript-keyword">return</span> (EINVAL);

	help = p-&gt;p_dtrace_helpers;
	last = help-&gt;dthps_actions[which];
	vstate = &amp;help-&gt;dthps_vstate;

	<span class="enscript-keyword">for</span> (count = 0; last != NULL; last = last-&gt;dtha_next) {
		count++;
		<span class="enscript-keyword">if</span> (last-&gt;dtha_next == NULL)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * If we already have dtrace_helper_actions_max helper actions for this
	 * helper action type, we'll refuse to add a new one.
	 */</span>
	<span class="enscript-keyword">if</span> (count &gt;= dtrace_helper_actions_max)
		<span class="enscript-keyword">return</span> (ENOSPC);

	helper = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_helper_action_t), KM_SLEEP);
	helper-&gt;dtha_generation = help-&gt;dthps_generation;

	<span class="enscript-keyword">if</span> ((pred = ep-&gt;dted_pred.dtpdd_predicate) != NULL) {
		ASSERT(pred-&gt;dtp_difo != NULL);
		dtrace_difo_hold(pred-&gt;dtp_difo);
		helper-&gt;dtha_predicate = pred-&gt;dtp_difo;
	}

	<span class="enscript-keyword">for</span> (act = ep-&gt;dted_action; act != NULL; act = act-&gt;dtad_next) {
		<span class="enscript-keyword">if</span> (act-&gt;dtad_kind != DTRACEACT_DIFEXPR)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

		<span class="enscript-keyword">if</span> (act-&gt;dtad_difo == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

		nactions++;
	}

	helper-&gt;dtha_actions = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_difo_t *) *
	    (helper-&gt;dtha_nactions = nactions), KM_SLEEP);

	<span class="enscript-keyword">for</span> (act = ep-&gt;dted_action, i = 0; act != NULL; act = act-&gt;dtad_next) {
		dtrace_difo_hold(act-&gt;dtad_difo);
		helper-&gt;dtha_actions[i++] = act-&gt;dtad_difo;
	}

	<span class="enscript-keyword">if</span> (!dtrace_helper_validate(helper))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">err</span>;

	<span class="enscript-keyword">if</span> (last == NULL) {
		help-&gt;dthps_actions[which] = helper;
	} <span class="enscript-keyword">else</span> {
		last-&gt;dtha_next = helper;
	}

	<span class="enscript-keyword">if</span> ((uint32_t)vstate-&gt;dtvs_nlocals &gt; dtrace_helptrace_nlocals) {
		dtrace_helptrace_nlocals = vstate-&gt;dtvs_nlocals;
		dtrace_helptrace_next = 0;
	}

	<span class="enscript-keyword">return</span> (0);
<span class="enscript-reference">err</span>:
	dtrace_helper_action_destroy(helper, vstate);
	<span class="enscript-keyword">return</span> (EINVAL);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_helper_provider_register</span>(proc_t *p, dtrace_helpers_t *help,
    dof_helper_t *dofhp)
{
	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_NOTOWNED);

	lck_mtx_lock(&amp;dtrace_meta_lock);
	lck_mtx_lock(&amp;dtrace_lock);

	<span class="enscript-keyword">if</span> (!dtrace_attached() || dtrace_meta_pid == NULL) {
		<span class="enscript-comment">/*
		 * If the dtrace module is loaded but not attached, or if
		 * there aren't isn't a meta provider registered to deal with
		 * these provider descriptions, we need to postpone creating
		 * the actual providers until later.
		 */</span>

		<span class="enscript-keyword">if</span> (help-&gt;dthps_next == NULL &amp;&amp; help-&gt;dthps_prev == NULL &amp;&amp;
		    dtrace_deferred_pid != help) {
			help-&gt;dthps_deferred = 1;
			help-&gt;dthps_pid = p-&gt;p_pid;
			help-&gt;dthps_next = dtrace_deferred_pid;
			help-&gt;dthps_prev = NULL;
			<span class="enscript-keyword">if</span> (dtrace_deferred_pid != NULL)
				dtrace_deferred_pid-&gt;dthps_prev = help;
			dtrace_deferred_pid = help;
		}

		lck_mtx_unlock(&amp;dtrace_lock);

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dofhp != NULL) {
		<span class="enscript-comment">/*
		 * If the dtrace module is loaded and we have a particular
		 * helper provider description, pass that off to the
		 * meta provider.
		 */</span>

		lck_mtx_unlock(&amp;dtrace_lock);

		dtrace_helper_provide(dofhp, p-&gt;p_pid);

	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Otherwise, just pass all the helper provider descriptions
		 * off to the meta provider.
		 */</span>

		uint_t i;
		lck_mtx_unlock(&amp;dtrace_lock);

		<span class="enscript-keyword">for</span> (i = 0; i &lt; help-&gt;dthps_nprovs; i++) {
			dtrace_helper_provide(&amp;help-&gt;dthps_provs[i]-&gt;dthp_prov,
			    p-&gt;p_pid);
		}
	}

	lck_mtx_unlock(&amp;dtrace_meta_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_helper_provider_add</span>(proc_t* p, dof_helper_t *dofhp, <span class="enscript-type">int</span> gen)
{
	dtrace_helpers_t *help;
	dtrace_helper_provider_t *hprov, **tmp_provs;
	uint_t tmp_maxprovs, i;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	help = p-&gt;p_dtrace_helpers;
	ASSERT(help != NULL);

	<span class="enscript-comment">/*
	 * If we already have dtrace_helper_providers_max helper providers,
	 * we're refuse to add a new one.
	 */</span>
	<span class="enscript-keyword">if</span> (help-&gt;dthps_nprovs &gt;= dtrace_helper_providers_max)
		<span class="enscript-keyword">return</span> (ENOSPC);

	<span class="enscript-comment">/*
	 * Check to make sure this isn't a duplicate.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; help-&gt;dthps_nprovs; i++) {
		<span class="enscript-keyword">if</span> (dofhp-&gt;dofhp_addr ==
		    help-&gt;dthps_provs[i]-&gt;dthp_prov.dofhp_addr)
			<span class="enscript-keyword">return</span> (EALREADY);
	}

	hprov = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_helper_provider_t), KM_SLEEP);
	hprov-&gt;dthp_prov = *dofhp;
	hprov-&gt;dthp_ref = 1;
	hprov-&gt;dthp_generation = gen;

	<span class="enscript-comment">/*
	 * Allocate a bigger table for helper providers if it's already full.
	 */</span>
	<span class="enscript-keyword">if</span> (help-&gt;dthps_maxprovs == help-&gt;dthps_nprovs) {
		tmp_maxprovs = help-&gt;dthps_maxprovs;
		tmp_provs = help-&gt;dthps_provs;

		<span class="enscript-keyword">if</span> (help-&gt;dthps_maxprovs == 0)
			help-&gt;dthps_maxprovs = 2;
		<span class="enscript-keyword">else</span>
			help-&gt;dthps_maxprovs *= 2;
		<span class="enscript-keyword">if</span> (help-&gt;dthps_maxprovs &gt; dtrace_helper_providers_max)
			help-&gt;dthps_maxprovs = dtrace_helper_providers_max;

		ASSERT(tmp_maxprovs &lt; help-&gt;dthps_maxprovs);

		help-&gt;dthps_provs = kmem_zalloc(help-&gt;dthps_maxprovs *
		    <span class="enscript-keyword">sizeof</span> (dtrace_helper_provider_t *), KM_SLEEP);

		<span class="enscript-keyword">if</span> (tmp_provs != NULL) {
			bcopy(tmp_provs, help-&gt;dthps_provs, tmp_maxprovs *
			    <span class="enscript-keyword">sizeof</span> (dtrace_helper_provider_t *));
			kmem_free(tmp_provs, tmp_maxprovs *
			    <span class="enscript-keyword">sizeof</span> (dtrace_helper_provider_t *));
		}
	}

	help-&gt;dthps_provs[help-&gt;dthps_nprovs] = hprov;
	help-&gt;dthps_nprovs++;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_helper_provider_destroy</span>(dtrace_helper_provider_t *hprov)
{
	lck_mtx_lock(&amp;dtrace_lock);

	<span class="enscript-keyword">if</span> (--hprov-&gt;dthp_ref == 0) {
		dof_hdr_t *dof;
		lck_mtx_unlock(&amp;dtrace_lock);
		dof = (dof_hdr_t *)(uintptr_t)hprov-&gt;dthp_prov.dofhp_dof;
		dtrace_dof_destroy(dof);
		kmem_free(hprov, <span class="enscript-keyword">sizeof</span> (dtrace_helper_provider_t));
	} <span class="enscript-keyword">else</span> {
		lck_mtx_unlock(&amp;dtrace_lock);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_helper_provider_validate</span>(dof_hdr_t *dof, dof_sec_t *sec)
{
	uintptr_t daddr = (uintptr_t)dof;
	dof_sec_t *str_sec, *prb_sec, *arg_sec, *off_sec, *enoff_sec;
	dof_provider_t *provider;
	dof_probe_t *probe;
	uint8_t *arg;
	<span class="enscript-type">char</span> *strtab, *typestr;
	dof_stridx_t typeidx;
	size_t typesz;
	uint_t nprobes, j, k;

	ASSERT(sec-&gt;dofs_type == DOF_SECT_PROVIDER);

	<span class="enscript-keyword">if</span> (sec-&gt;dofs_offset &amp; (<span class="enscript-keyword">sizeof</span> (uint_t) - 1)) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;misaligned section offset&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-comment">/*
	 * The section needs to be large enough to contain the DOF provider
	 * structure appropriate for the given version.
	 */</span>
	<span class="enscript-keyword">if</span> (sec-&gt;dofs_size &lt;
	    ((dof-&gt;dofh_ident[DOF_ID_VERSION] == DOF_VERSION_1) ?
	    offsetof(dof_provider_t, dofpv_prenoffs) :
	    <span class="enscript-keyword">sizeof</span> (dof_provider_t))) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;provider section too small&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	provider = (dof_provider_t *)(uintptr_t)(daddr + sec-&gt;dofs_offset);
	str_sec = dtrace_dof_sect(dof, DOF_SECT_STRTAB, provider-&gt;dofpv_strtab);
	prb_sec = dtrace_dof_sect(dof, DOF_SECT_PROBES, provider-&gt;dofpv_probes);
	arg_sec = dtrace_dof_sect(dof, DOF_SECT_PRARGS, provider-&gt;dofpv_prargs);
	off_sec = dtrace_dof_sect(dof, DOF_SECT_PROFFS, provider-&gt;dofpv_proffs);

	<span class="enscript-keyword">if</span> (str_sec == NULL || prb_sec == NULL ||
	    arg_sec == NULL || off_sec == NULL)
		<span class="enscript-keyword">return</span> (-1);

	enoff_sec = NULL;

	<span class="enscript-keyword">if</span> (dof-&gt;dofh_ident[DOF_ID_VERSION] != DOF_VERSION_1 &amp;&amp;
	    provider-&gt;dofpv_prenoffs != DOF_SECT_NONE &amp;&amp;
	    (enoff_sec = dtrace_dof_sect(dof, DOF_SECT_PRENOFFS,
	    provider-&gt;dofpv_prenoffs)) == NULL)
		<span class="enscript-keyword">return</span> (-1);

	strtab = (<span class="enscript-type">char</span> *)(uintptr_t)(daddr + str_sec-&gt;dofs_offset);

	<span class="enscript-keyword">if</span> (provider-&gt;dofpv_name &gt;= str_sec-&gt;dofs_size ||
	    strlen(strtab + provider-&gt;dofpv_name) &gt;= DTRACE_PROVNAMELEN) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;invalid provider name&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (prb_sec-&gt;dofs_entsize == 0 ||
	    prb_sec-&gt;dofs_entsize &gt; prb_sec-&gt;dofs_size) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;invalid entry size&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (prb_sec-&gt;dofs_entsize &amp; (<span class="enscript-keyword">sizeof</span> (uintptr_t) - 1)) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;misaligned entry size&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (off_sec-&gt;dofs_entsize != <span class="enscript-keyword">sizeof</span> (uint32_t)) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;invalid entry size&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (off_sec-&gt;dofs_offset &amp; (<span class="enscript-keyword">sizeof</span> (uint32_t) - 1)) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;misaligned section offset&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (arg_sec-&gt;dofs_entsize != <span class="enscript-keyword">sizeof</span> (uint8_t)) {
		dtrace_dof_error(dof, <span class="enscript-string">&quot;invalid entry size&quot;</span>);
		<span class="enscript-keyword">return</span> (-1);
	}

	arg = (uint8_t *)(uintptr_t)(daddr + arg_sec-&gt;dofs_offset);

	nprobes = prb_sec-&gt;dofs_size / prb_sec-&gt;dofs_entsize;

	<span class="enscript-comment">/*
	 * Take a pass through the probes to check for errors.
	 */</span>
	<span class="enscript-keyword">for</span> (j = 0; j &lt; nprobes; j++) {
		probe = (dof_probe_t *)(uintptr_t)(daddr +
		    prb_sec-&gt;dofs_offset + j * prb_sec-&gt;dofs_entsize);

		<span class="enscript-keyword">if</span> (probe-&gt;dofpr_func &gt;= str_sec-&gt;dofs_size) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;invalid function name&quot;</span>);
			<span class="enscript-keyword">return</span> (-1);
		}

		<span class="enscript-keyword">if</span> (strlen(strtab + probe-&gt;dofpr_func) &gt;= DTRACE_FUNCNAMELEN) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;function name too long&quot;</span>);
			<span class="enscript-keyword">return</span> (-1);
		}

		<span class="enscript-keyword">if</span> (probe-&gt;dofpr_name &gt;= str_sec-&gt;dofs_size ||
		    strlen(strtab + probe-&gt;dofpr_name) &gt;= DTRACE_NAMELEN) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;invalid probe name&quot;</span>);
			<span class="enscript-keyword">return</span> (-1);
		}

		<span class="enscript-comment">/*
		 * The offset count must not wrap the index, and the offsets
		 * must also not overflow the section's data.
		 */</span>
		<span class="enscript-keyword">if</span> (probe-&gt;dofpr_offidx + probe-&gt;dofpr_noffs &lt;
		    probe-&gt;dofpr_offidx ||
		    (probe-&gt;dofpr_offidx + probe-&gt;dofpr_noffs) *
		    off_sec-&gt;dofs_entsize &gt; off_sec-&gt;dofs_size) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;invalid probe offset&quot;</span>);
			<span class="enscript-keyword">return</span> (-1);
		}

		<span class="enscript-keyword">if</span> (dof-&gt;dofh_ident[DOF_ID_VERSION] != DOF_VERSION_1) {
			<span class="enscript-comment">/*
			 * If there's no is-enabled offset section, make sure
			 * there aren't any is-enabled offsets. Otherwise
			 * perform the same checks as for probe offsets
			 * (immediately above).
			 */</span>
			<span class="enscript-keyword">if</span> (enoff_sec == NULL) {
				<span class="enscript-keyword">if</span> (probe-&gt;dofpr_enoffidx != 0 ||
				    probe-&gt;dofpr_nenoffs != 0) {
					dtrace_dof_error(dof, <span class="enscript-string">&quot;is-enabled &quot;</span>
					    <span class="enscript-string">&quot;offsets with null section&quot;</span>);
					<span class="enscript-keyword">return</span> (-1);
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (probe-&gt;dofpr_enoffidx +
			    probe-&gt;dofpr_nenoffs &lt; probe-&gt;dofpr_enoffidx ||
			    (probe-&gt;dofpr_enoffidx + probe-&gt;dofpr_nenoffs) *
			    enoff_sec-&gt;dofs_entsize &gt; enoff_sec-&gt;dofs_size) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;invalid is-enabled &quot;</span>
				    <span class="enscript-string">&quot;offset&quot;</span>);
				<span class="enscript-keyword">return</span> (-1);
			}

			<span class="enscript-keyword">if</span> (probe-&gt;dofpr_noffs + probe-&gt;dofpr_nenoffs == 0) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;zero probe and &quot;</span>
				    <span class="enscript-string">&quot;is-enabled offsets&quot;</span>);
				<span class="enscript-keyword">return</span> (-1);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (probe-&gt;dofpr_noffs == 0) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;zero probe offsets&quot;</span>);
			<span class="enscript-keyword">return</span> (-1);
		}

		<span class="enscript-keyword">if</span> (probe-&gt;dofpr_argidx + probe-&gt;dofpr_xargc &lt;
		    probe-&gt;dofpr_argidx ||
		    (probe-&gt;dofpr_argidx + probe-&gt;dofpr_xargc) *
		    arg_sec-&gt;dofs_entsize &gt; arg_sec-&gt;dofs_size) {
			dtrace_dof_error(dof, <span class="enscript-string">&quot;invalid args&quot;</span>);
			<span class="enscript-keyword">return</span> (-1);
		}

		typeidx = probe-&gt;dofpr_nargv;
		typestr = strtab + probe-&gt;dofpr_nargv;
		<span class="enscript-keyword">for</span> (k = 0; k &lt; probe-&gt;dofpr_nargc; k++) {
			<span class="enscript-keyword">if</span> (typeidx &gt;= str_sec-&gt;dofs_size) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;bad &quot;</span>
				    <span class="enscript-string">&quot;native argument type&quot;</span>);
				<span class="enscript-keyword">return</span> (-1);
			}

			typesz = strlen(typestr) + 1;
			<span class="enscript-keyword">if</span> (typesz &gt; DTRACE_ARGTYPELEN) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;native &quot;</span>
				    <span class="enscript-string">&quot;argument type too long&quot;</span>);
				<span class="enscript-keyword">return</span> (-1);
			}
			typeidx += typesz;
			typestr += typesz;
		}

		typeidx = probe-&gt;dofpr_xargv;
		typestr = strtab + probe-&gt;dofpr_xargv;
		<span class="enscript-keyword">for</span> (k = 0; k &lt; probe-&gt;dofpr_xargc; k++) {
			<span class="enscript-keyword">if</span> (arg[probe-&gt;dofpr_argidx + k] &gt; probe-&gt;dofpr_nargc) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;bad &quot;</span>
				    <span class="enscript-string">&quot;native argument index&quot;</span>);
				<span class="enscript-keyword">return</span> (-1);
			}

			<span class="enscript-keyword">if</span> (typeidx &gt;= str_sec-&gt;dofs_size) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;bad &quot;</span>
				    <span class="enscript-string">&quot;translated argument type&quot;</span>);
				<span class="enscript-keyword">return</span> (-1);
			}

			typesz = strlen(typestr) + 1;
			<span class="enscript-keyword">if</span> (typesz &gt; DTRACE_ARGTYPELEN) {
				dtrace_dof_error(dof, <span class="enscript-string">&quot;translated argument &quot;</span>
				    <span class="enscript-string">&quot;type too long&quot;</span>);
				<span class="enscript-keyword">return</span> (-1);
			}

			typeidx += typesz;
			typestr += typesz;
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_helper_slurp</span>(proc_t* p, dof_hdr_t *dof, dof_helper_t *dhp)
{
	dtrace_helpers_t *help;
	dtrace_vstate_t *vstate;
	dtrace_enabling_t *enab = NULL;
	<span class="enscript-type">int</span> i, gen, rv, nhelpers = 0, nprovs = 0, destroy = 1;
	uintptr_t daddr = (uintptr_t)dof;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> ((help = p-&gt;p_dtrace_helpers) == NULL)
		help = dtrace_helpers_create(p);

	vstate = &amp;help-&gt;dthps_vstate;

	<span class="enscript-keyword">if</span> ((rv = dtrace_dof_slurp(dof, vstate, NULL, &amp;enab,
	    dhp != NULL ? dhp-&gt;dofhp_addr : 0, B_FALSE)) != 0) {
		dtrace_dof_destroy(dof);
		<span class="enscript-keyword">return</span> (rv);
	}

	<span class="enscript-comment">/*
	 * Look for helper providers and validate their descriptions.
	 */</span>
	<span class="enscript-keyword">if</span> (dhp != NULL) {
		<span class="enscript-keyword">for</span> (i = 0; (uint32_t)i &lt; dof-&gt;dofh_secnum; i++) {
			dof_sec_t *sec = (dof_sec_t *)(uintptr_t)(daddr +
			    dof-&gt;dofh_secoff + i * dof-&gt;dofh_secsize);

			<span class="enscript-keyword">if</span> (sec-&gt;dofs_type != DOF_SECT_PROVIDER)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (dtrace_helper_provider_validate(dof, sec) != 0) {
				dtrace_enabling_destroy(enab);
				dtrace_dof_destroy(dof);
				<span class="enscript-keyword">return</span> (-1);
			}

			nprovs++;
		}
	}

	<span class="enscript-comment">/*
	 * Now we need to walk through the ECB descriptions in the enabling.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; enab-&gt;dten_ndesc; i++) {
		dtrace_ecbdesc_t *ep = enab-&gt;dten_desc[i];
		dtrace_probedesc_t *desc = &amp;ep-&gt;dted_probe;

		<span class="enscript-comment">/* APPLE NOTE: Darwin employs size bounded string operation. */</span>
		<span class="enscript-keyword">if</span> (!LIT_STRNEQL(desc-&gt;dtpd_provider, <span class="enscript-string">&quot;dtrace&quot;</span>))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (!LIT_STRNEQL(desc-&gt;dtpd_mod, <span class="enscript-string">&quot;helper&quot;</span>))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (!LIT_STRNEQL(desc-&gt;dtpd_func, <span class="enscript-string">&quot;ustack&quot;</span>))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> ((rv = dtrace_helper_action_add(p, DTRACE_HELPER_ACTION_USTACK,
		    ep)) != 0) {
			<span class="enscript-comment">/*
			 * Adding this helper action failed -- we are now going
			 * to rip out the entire generation and return failure.
			 */</span>
			(<span class="enscript-type">void</span>) dtrace_helper_destroygen(p, help-&gt;dthps_generation);
			dtrace_enabling_destroy(enab);
			dtrace_dof_destroy(dof);
			<span class="enscript-keyword">return</span> (-1);
		}

		nhelpers++;
	}

	<span class="enscript-keyword">if</span> (nhelpers &lt; enab-&gt;dten_ndesc)
		dtrace_dof_error(dof, <span class="enscript-string">&quot;unmatched helpers&quot;</span>);

	gen = help-&gt;dthps_generation++;
	dtrace_enabling_destroy(enab);

	<span class="enscript-keyword">if</span> (dhp != NULL &amp;&amp; nprovs &gt; 0) {
		dhp-&gt;dofhp_dof = (uint64_t)(uintptr_t)dof;
		<span class="enscript-keyword">if</span> (dtrace_helper_provider_add(p, dhp, gen) == 0) {
			lck_mtx_unlock(&amp;dtrace_lock);
			dtrace_helper_provider_register(p, help, dhp);
			lck_mtx_lock(&amp;dtrace_lock);

			destroy = 0;
		}
	}

	<span class="enscript-keyword">if</span> (destroy)
		dtrace_dof_destroy(dof);

	<span class="enscript-keyword">return</span> (gen);
}

<span class="enscript-comment">/*
 * APPLE NOTE:  DTrace lazy dof implementation
 *
 * DTrace user static probes (USDT probes) and helper actions are loaded
 * in a process by proccessing dof sections. The dof sections are passed
 * into the kernel by dyld, in a dof_ioctl_data_t block. It is rather
 * expensive to process dof for a process that will never use it. There
 * is a memory cost (allocating the providers/probes), and a cpu cost
 * (creating the providers/probes).
 *
 * To reduce this cost, we use &quot;lazy dof&quot;. The normal proceedure for
 * dof processing is to copyin the dof(s) pointed to by the dof_ioctl_data_t
 * block, and invoke dof_slurp_helper() on them. When &quot;lazy dof&quot; is
 * used, each process retains the dof_ioctl_data_t block, instead of
 * copying in the data it points to.
 *
 * The dof_ioctl_data_t blocks are managed as if they were the actual
 * processed dof; on fork the block is copied to the child, on exec and
 * exit the block is freed.
 *
 * If the process loads library(s) containing additional dof, the
 * new dof_ioctl_data_t is merged with the existing block.
 *
 * There are a few catches that make this slightly more difficult.
 * When dyld registers dof_ioctl_data_t blocks, it expects a unique
 * identifier value for each dof in the block. In non-lazy dof terms,
 * this is the generation that dof was loaded in. If we hand back
 * a UID for a lazy dof, that same UID must be able to unload the
 * dof once it has become non-lazy. To meet this requirement, the
 * code that loads lazy dof requires that the UID's for dof(s) in
 * the lazy dof be sorted, and in ascending order. It is okay to skip
 * UID's, I.E., 1 -&gt; 5 -&gt; 6 is legal.
 *
 * Once a process has become non-lazy, it will stay non-lazy. All
 * future dof operations for that process will be non-lazy, even
 * if the dof mode transitions back to lazy.
 *
 * Always do lazy dof checks before non-lazy (I.E. In fork, exit, exec.).
 * That way if the lazy check fails due to transitioning to non-lazy, the
 * right thing is done with the newly faulted in dof.
 */</span>

<span class="enscript-comment">/*
 * This method is a bit squicky. It must handle:
 *
 * dof should not be lazy.
 * dof should have been handled lazily, but there was an error
 * dof was handled lazily, and needs to be freed.
 * dof was handled lazily, and must not be freed.
 *
 * 
 * Returns EACCESS if dof should be handled non-lazily.
 * 
 * KERN_SUCCESS and all other return codes indicate lazy handling of dof.
 * 
 * If the dofs data is claimed by this method, dofs_claimed will be set.
 * Callers should not free claimed dofs.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_lazy_dofs_add</span>(proc_t *p, dof_ioctl_data_t* incoming_dofs, <span class="enscript-type">int</span> *dofs_claimed)
{
	ASSERT(p);
	ASSERT(incoming_dofs &amp;&amp; incoming_dofs-&gt;dofiod_count &gt; 0);

	<span class="enscript-type">int</span> rval = 0;
	*dofs_claimed = 0;

	lck_rw_lock_shared(&amp;dtrace_dof_mode_lock);

	<span class="enscript-comment">/*
	 * If we have lazy dof, dof mode better be LAZY_ON.
	 */</span>
	ASSERT(p-&gt;p_dtrace_lazy_dofs == NULL || dtrace_dof_mode == DTRACE_DOF_MODE_LAZY_ON);
	ASSERT(p-&gt;p_dtrace_lazy_dofs == NULL || p-&gt;p_dtrace_helpers == NULL);
	ASSERT(dtrace_dof_mode != DTRACE_DOF_MODE_NEVER);

	<span class="enscript-comment">/*
	 * Any existing helpers force non-lazy behavior.
	 */</span>
	<span class="enscript-keyword">if</span> (dtrace_dof_mode == DTRACE_DOF_MODE_LAZY_ON &amp;&amp; (p-&gt;p_dtrace_helpers == NULL)) {
		lck_mtx_lock(&amp;p-&gt;p_dtrace_sprlock);

		dof_ioctl_data_t* existing_dofs = p-&gt;p_dtrace_lazy_dofs;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> existing_dofs_count = (existing_dofs) ? existing_dofs-&gt;dofiod_count : 0;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i, merged_dofs_count = incoming_dofs-&gt;dofiod_count + existing_dofs_count;

		<span class="enscript-comment">/*
		 * Range check...
		 */</span>
		<span class="enscript-keyword">if</span> (merged_dofs_count == 0 || merged_dofs_count &gt; 1024) {
			dtrace_dof_error(NULL, <span class="enscript-string">&quot;lazy_dofs_add merged_dofs_count out of range&quot;</span>);
			rval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock</span>;
		}
		
		<span class="enscript-comment">/*
		 * Each dof being added must be assigned a unique generation.
		 */</span>
		uint64_t generation = (existing_dofs) ? existing_dofs-&gt;dofiod_helpers[existing_dofs_count - 1].dofhp_dof + 1 : 1;
		<span class="enscript-keyword">for</span> (i=0; i&lt;incoming_dofs-&gt;dofiod_count; i++) {
			<span class="enscript-comment">/*
			 * We rely on these being the same so we can overwrite dofhp_dof and not lose info.
			 */</span>
			ASSERT(incoming_dofs-&gt;dofiod_helpers[i].dofhp_dof == incoming_dofs-&gt;dofiod_helpers[i].dofhp_addr);
			incoming_dofs-&gt;dofiod_helpers[i].dofhp_dof = generation++;
		}

		
		<span class="enscript-keyword">if</span> (existing_dofs) {
			<span class="enscript-comment">/*
			 * Merge the existing and incoming dofs
			 */</span>
			size_t merged_dofs_size = DOF_IOCTL_DATA_T_SIZE(merged_dofs_count);
			dof_ioctl_data_t* merged_dofs = kmem_alloc(merged_dofs_size, KM_SLEEP);

			bcopy(&amp;existing_dofs-&gt;dofiod_helpers[0],
			      &amp;merged_dofs-&gt;dofiod_helpers[0],
			      <span class="enscript-keyword">sizeof</span>(dof_helper_t) * existing_dofs_count);
			bcopy(&amp;incoming_dofs-&gt;dofiod_helpers[0],
			      &amp;merged_dofs-&gt;dofiod_helpers[existing_dofs_count],
			      <span class="enscript-keyword">sizeof</span>(dof_helper_t) * incoming_dofs-&gt;dofiod_count);

			merged_dofs-&gt;dofiod_count = merged_dofs_count;

			kmem_free(existing_dofs, DOF_IOCTL_DATA_T_SIZE(existing_dofs_count));

			p-&gt;p_dtrace_lazy_dofs = merged_dofs;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Claim the incoming dofs
			 */</span>
			*dofs_claimed = 1;
			p-&gt;p_dtrace_lazy_dofs = incoming_dofs;
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		dof_ioctl_data_t* all_dofs = p-&gt;p_dtrace_lazy_dofs;
		<span class="enscript-keyword">for</span> (i=0; i&lt;all_dofs-&gt;dofiod_count-1; i++) {
			ASSERT(all_dofs-&gt;dofiod_helpers[i].dofhp_dof &lt; all_dofs-&gt;dofiod_helpers[i+1].dofhp_dof);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

<span class="enscript-reference">unlock</span>:
		lck_mtx_unlock(&amp;p-&gt;p_dtrace_sprlock);
	} <span class="enscript-keyword">else</span> {
		rval = EACCES;
	}

 	lck_rw_unlock_shared(&amp;dtrace_dof_mode_lock);

	<span class="enscript-keyword">return</span> rval;
}

<span class="enscript-comment">/*
 * Returns:
 *
 * EINVAL: lazy dof is enabled, but the requested generation was not found.
 * EACCES: This removal needs to be handled non-lazily. 
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_lazy_dofs_remove</span>(proc_t *p, <span class="enscript-type">int</span> generation)
{
	<span class="enscript-type">int</span> rval = EINVAL;

	lck_rw_lock_shared(&amp;dtrace_dof_mode_lock);

	<span class="enscript-comment">/*
	 * If we have lazy dof, dof mode better be LAZY_ON.
	 */</span>
	ASSERT(p-&gt;p_dtrace_lazy_dofs == NULL || dtrace_dof_mode == DTRACE_DOF_MODE_LAZY_ON);
	ASSERT(p-&gt;p_dtrace_lazy_dofs == NULL || p-&gt;p_dtrace_helpers == NULL);
	ASSERT(dtrace_dof_mode != DTRACE_DOF_MODE_NEVER);

	<span class="enscript-comment">/*
	 * Any existing helpers force non-lazy behavior.
	 */</span>
	<span class="enscript-keyword">if</span> (dtrace_dof_mode == DTRACE_DOF_MODE_LAZY_ON &amp;&amp; (p-&gt;p_dtrace_helpers == NULL)) {
		lck_mtx_lock(&amp;p-&gt;p_dtrace_sprlock);

		dof_ioctl_data_t* existing_dofs = p-&gt;p_dtrace_lazy_dofs;
		
		<span class="enscript-keyword">if</span> (existing_dofs) {		
			<span class="enscript-type">int</span> index, existing_dofs_count = existing_dofs-&gt;dofiod_count;
			<span class="enscript-keyword">for</span> (index=0; index&lt;existing_dofs_count; index++) {
				<span class="enscript-keyword">if</span> ((<span class="enscript-type">int</span>)existing_dofs-&gt;dofiod_helpers[index].dofhp_dof == generation) {
					dof_ioctl_data_t* removed_dofs = NULL;
				
					<span class="enscript-comment">/*
					 * If there is only 1 dof, we'll delete it and swap in NULL.
					 */</span>
					<span class="enscript-keyword">if</span> (existing_dofs_count &gt; 1) {
						<span class="enscript-type">int</span> removed_dofs_count = existing_dofs_count - 1;
						size_t removed_dofs_size = DOF_IOCTL_DATA_T_SIZE(removed_dofs_count);
					
						removed_dofs = kmem_alloc(removed_dofs_size, KM_SLEEP);
						removed_dofs-&gt;dofiod_count = removed_dofs_count;
					
						<span class="enscript-comment">/*
						 * copy the remaining data.
						 */</span>
						<span class="enscript-keyword">if</span> (index &gt; 0) {
							bcopy(&amp;existing_dofs-&gt;dofiod_helpers[0],
							      &amp;removed_dofs-&gt;dofiod_helpers[0],
							      index * <span class="enscript-keyword">sizeof</span>(dof_helper_t));
						}
					
						<span class="enscript-keyword">if</span> (index &lt; existing_dofs_count-1) {
							bcopy(&amp;existing_dofs-&gt;dofiod_helpers[index+1],
							      &amp;removed_dofs-&gt;dofiod_helpers[index],
							      (existing_dofs_count - index - 1) * <span class="enscript-keyword">sizeof</span>(dof_helper_t));
						}
					}
				
					kmem_free(existing_dofs, DOF_IOCTL_DATA_T_SIZE(existing_dofs_count));
				
					p-&gt;p_dtrace_lazy_dofs = removed_dofs;

					rval = KERN_SUCCESS;

					<span class="enscript-keyword">break</span>;
				}
			}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
			dof_ioctl_data_t* all_dofs = p-&gt;p_dtrace_lazy_dofs;
			<span class="enscript-keyword">if</span> (all_dofs) {
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
				<span class="enscript-keyword">for</span> (i=0; i&lt;all_dofs-&gt;dofiod_count-1; i++) {
					ASSERT(all_dofs-&gt;dofiod_helpers[i].dofhp_dof &lt; all_dofs-&gt;dofiod_helpers[i+1].dofhp_dof);
				}
			}
#<span class="enscript-reference">endif</span>

		}

		lck_mtx_unlock(&amp;p-&gt;p_dtrace_sprlock);
	} <span class="enscript-keyword">else</span> {		
		rval = EACCES;
	}
	
	lck_rw_unlock_shared(&amp;dtrace_dof_mode_lock);
	
	<span class="enscript-keyword">return</span> rval;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_lazy_dofs_destroy</span>(proc_t *p)
{
	lck_rw_lock_shared(&amp;dtrace_dof_mode_lock);
	lck_mtx_lock(&amp;p-&gt;p_dtrace_sprlock);
	
	<span class="enscript-comment">/*
	 * If we have lazy dof, dof mode better be LAZY_ON, or we must be exiting.
	 * We cannot assert against DTRACE_DOF_MODE_NEVER here, because we are called from
	 * kern_exit.c and kern_exec.c.
	 */</span>
	ASSERT(p-&gt;p_dtrace_lazy_dofs == NULL || dtrace_dof_mode == DTRACE_DOF_MODE_LAZY_ON || p-&gt;p_lflag &amp; P_LEXIT);
	ASSERT(p-&gt;p_dtrace_lazy_dofs == NULL || p-&gt;p_dtrace_helpers == NULL);

	dof_ioctl_data_t* lazy_dofs = p-&gt;p_dtrace_lazy_dofs;
	p-&gt;p_dtrace_lazy_dofs = NULL;

	lck_mtx_unlock(&amp;p-&gt;p_dtrace_sprlock);
	lck_rw_unlock_shared(&amp;dtrace_dof_mode_lock);

	<span class="enscript-keyword">if</span> (lazy_dofs) {
		kmem_free(lazy_dofs, DOF_IOCTL_DATA_T_SIZE(lazy_dofs-&gt;dofiod_count));
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_lazy_dofs_duplicate</span>(proc_t *parent, proc_t *child)
{
	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_NOTOWNED);
	lck_mtx_assert(&amp;parent-&gt;p_dtrace_sprlock, LCK_MTX_ASSERT_NOTOWNED);
	lck_mtx_assert(&amp;child-&gt;p_dtrace_sprlock, LCK_MTX_ASSERT_NOTOWNED);

	lck_rw_lock_shared(&amp;dtrace_dof_mode_lock);
	lck_mtx_lock(&amp;parent-&gt;p_dtrace_sprlock);

	<span class="enscript-comment">/*
	 * If we have lazy dof, dof mode better be LAZY_ON, or we must be exiting.
	 * We cannot assert against DTRACE_DOF_MODE_NEVER here, because we are called from
	 * kern_fork.c
	 */</span>
	ASSERT(parent-&gt;p_dtrace_lazy_dofs == NULL || dtrace_dof_mode == DTRACE_DOF_MODE_LAZY_ON);
	ASSERT(parent-&gt;p_dtrace_lazy_dofs == NULL || parent-&gt;p_dtrace_helpers == NULL);
	<span class="enscript-comment">/*
	 * In theory we should hold the child sprlock, but this is safe...
	 */</span>
	ASSERT(child-&gt;p_dtrace_lazy_dofs == NULL &amp;&amp; child-&gt;p_dtrace_helpers == NULL);

	dof_ioctl_data_t* parent_dofs = parent-&gt;p_dtrace_lazy_dofs;
	dof_ioctl_data_t* child_dofs = NULL;
	<span class="enscript-keyword">if</span> (parent_dofs) {
		size_t parent_dofs_size = DOF_IOCTL_DATA_T_SIZE(parent_dofs-&gt;dofiod_count);
		child_dofs = kmem_alloc(parent_dofs_size, KM_SLEEP);
		bcopy(parent_dofs, child_dofs, parent_dofs_size);
	}

	lck_mtx_unlock(&amp;parent-&gt;p_dtrace_sprlock);
 
	<span class="enscript-keyword">if</span> (child_dofs) {
		lck_mtx_lock(&amp;child-&gt;p_dtrace_sprlock);
		child-&gt;p_dtrace_lazy_dofs = child_dofs;
		lck_mtx_unlock(&amp;child-&gt;p_dtrace_sprlock);
	}

	lck_rw_unlock_shared(&amp;dtrace_dof_mode_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_lazy_dofs_proc_iterate_filter</span>(proc_t *p, <span class="enscript-type">void</span>* ignored)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ignored</span>)
	<span class="enscript-comment">/*
	 * Okay to NULL test without taking the sprlock.
	 */</span>
	<span class="enscript-keyword">return</span> p-&gt;p_dtrace_lazy_dofs != NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_lazy_dofs_proc_iterate_doit</span>(proc_t *p, <span class="enscript-type">void</span>* ignored)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ignored</span>)
	<span class="enscript-comment">/*
	 * It is possible this process may exit during our attempt to
	 * fault in the dof. We could fix this by holding locks longer,
	 * but the errors are benign.
	 */</span>
	lck_mtx_lock(&amp;p-&gt;p_dtrace_sprlock);

	<span class="enscript-comment">/*
	 * In this case only, it is okay to have lazy dof when dof mode is DTRACE_DOF_MODE_LAZY_OFF
	 */</span>
	ASSERT(p-&gt;p_dtrace_lazy_dofs == NULL || p-&gt;p_dtrace_helpers == NULL);
	ASSERT(dtrace_dof_mode == DTRACE_DOF_MODE_LAZY_OFF);


	dof_ioctl_data_t* lazy_dofs = p-&gt;p_dtrace_lazy_dofs;
	p-&gt;p_dtrace_lazy_dofs = NULL;

	lck_mtx_unlock(&amp;p-&gt;p_dtrace_sprlock);

	<span class="enscript-comment">/*
	 * Process each dof_helper_t
	 */</span>
	<span class="enscript-keyword">if</span> (lazy_dofs != NULL) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
		<span class="enscript-type">int</span> rval;

		<span class="enscript-keyword">for</span> (i=0; i&lt;lazy_dofs-&gt;dofiod_count; i++) {
			<span class="enscript-comment">/*
			 * When loading lazy dof, we depend on the generations being sorted in ascending order.
			 */</span>
			ASSERT(i &gt;= (lazy_dofs-&gt;dofiod_count - 1) || lazy_dofs-&gt;dofiod_helpers[i].dofhp_dof &lt; lazy_dofs-&gt;dofiod_helpers[i+1].dofhp_dof);

			dof_helper_t *dhp = &amp;lazy_dofs-&gt;dofiod_helpers[i];

			<span class="enscript-comment">/*
			 * We stored the generation in dofhp_dof. Save it, and restore the original value.
			 */</span>
			<span class="enscript-type">int</span> generation = dhp-&gt;dofhp_dof;
			dhp-&gt;dofhp_dof = dhp-&gt;dofhp_addr;

			dof_hdr_t *dof = dtrace_dof_copyin_from_proc(p, dhp-&gt;dofhp_dof, &amp;rval);
		
			<span class="enscript-keyword">if</span> (dof != NULL) {
				dtrace_helpers_t *help;
								
				lck_mtx_lock(&amp;dtrace_lock);
				
				<span class="enscript-comment">/*
				 * This must be done with the dtrace_lock held
				 */</span>
				<span class="enscript-keyword">if</span> ((help = p-&gt;p_dtrace_helpers) == NULL)
					help = dtrace_helpers_create(p);
				
				<span class="enscript-comment">/*
				 * If the generation value has been bumped, someone snuck in
				 * when we released the dtrace lock. We have to dump this generation,
				 * there is no safe way to load it.
				 */</span>
				<span class="enscript-keyword">if</span> (help-&gt;dthps_generation &lt;= generation) {
					help-&gt;dthps_generation = generation;
					
					<span class="enscript-comment">/*
					 * dtrace_helper_slurp() takes responsibility for the dof --
					 * it may free it now or it may save it and free it later.
					 */</span>
					<span class="enscript-keyword">if</span> ((rval = dtrace_helper_slurp(p, dof, dhp)) != generation) {
						dtrace_dof_error(NULL, <span class="enscript-string">&quot;returned value did not match expected generation&quot;</span>);
					}
				}
				
				lck_mtx_unlock(&amp;dtrace_lock);
			}
		}

		kmem_free(lazy_dofs, DOF_IOCTL_DATA_T_SIZE(lazy_dofs-&gt;dofiod_count));
	}

	<span class="enscript-keyword">return</span> PROC_RETURNED;
}

<span class="enscript-type">static</span> dtrace_helpers_t *
<span class="enscript-function-name">dtrace_helpers_create</span>(proc_t *p)
{
	dtrace_helpers_t *help;

	lck_mtx_assert(&amp;dtrace_lock, LCK_MTX_ASSERT_OWNED);
	ASSERT(p-&gt;p_dtrace_helpers == NULL);

	help = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_helpers_t), KM_SLEEP);
	help-&gt;dthps_actions = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_helper_action_t *) *
	    DTRACE_NHELPER_ACTIONS, KM_SLEEP);

	p-&gt;p_dtrace_helpers = help;
	dtrace_helpers++;

	<span class="enscript-keyword">return</span> (help);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_helpers_destroy</span>(proc_t* p)
{
	dtrace_helpers_t *help;
	dtrace_vstate_t *vstate;
	uint_t i;

	lck_mtx_lock(&amp;dtrace_lock);

	ASSERT(p-&gt;p_dtrace_helpers != NULL);
	ASSERT(dtrace_helpers &gt; 0);

	help = p-&gt;p_dtrace_helpers;
	vstate = &amp;help-&gt;dthps_vstate;

	<span class="enscript-comment">/*
	 * We're now going to lose the help from this process.
	 */</span>
	p-&gt;p_dtrace_helpers = NULL;
	dtrace_sync();

	<span class="enscript-comment">/*
	 * Destory the helper actions.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; DTRACE_NHELPER_ACTIONS; i++) {
		dtrace_helper_action_t *h, *next;

		<span class="enscript-keyword">for</span> (h = help-&gt;dthps_actions[i]; h != NULL; h = next) {
			next = h-&gt;dtha_next;
			dtrace_helper_action_destroy(h, vstate);
			h = next;
		}
	}

	lck_mtx_unlock(&amp;dtrace_lock);

	<span class="enscript-comment">/*
	 * Destroy the helper providers.
	 */</span>
	<span class="enscript-keyword">if</span> (help-&gt;dthps_maxprovs &gt; 0) {
		lck_mtx_lock(&amp;dtrace_meta_lock);
		<span class="enscript-keyword">if</span> (dtrace_meta_pid != NULL) {
			ASSERT(dtrace_deferred_pid == NULL);

			<span class="enscript-keyword">for</span> (i = 0; i &lt; help-&gt;dthps_nprovs; i++) {
				dtrace_helper_provider_remove(
				    &amp;help-&gt;dthps_provs[i]-&gt;dthp_prov, p-&gt;p_pid);
			}
		} <span class="enscript-keyword">else</span> {
			lck_mtx_lock(&amp;dtrace_lock);
			ASSERT(help-&gt;dthps_deferred == 0 ||
			    help-&gt;dthps_next != NULL ||
			    help-&gt;dthps_prev != NULL ||
			    help == dtrace_deferred_pid);

			<span class="enscript-comment">/*
			 * Remove the helper from the deferred list.
			 */</span>
			<span class="enscript-keyword">if</span> (help-&gt;dthps_next != NULL)
				help-&gt;dthps_next-&gt;dthps_prev = help-&gt;dthps_prev;
			<span class="enscript-keyword">if</span> (help-&gt;dthps_prev != NULL)
				help-&gt;dthps_prev-&gt;dthps_next = help-&gt;dthps_next;
			<span class="enscript-keyword">if</span> (dtrace_deferred_pid == help) {
				dtrace_deferred_pid = help-&gt;dthps_next;
				ASSERT(help-&gt;dthps_prev == NULL);
			}

			lck_mtx_unlock(&amp;dtrace_lock);
		}

		lck_mtx_unlock(&amp;dtrace_meta_lock);

		<span class="enscript-keyword">for</span> (i = 0; i &lt; help-&gt;dthps_nprovs; i++) {
			dtrace_helper_provider_destroy(help-&gt;dthps_provs[i]);
		}

		kmem_free(help-&gt;dthps_provs, help-&gt;dthps_maxprovs *
		    <span class="enscript-keyword">sizeof</span> (dtrace_helper_provider_t *));
	}

	lck_mtx_lock(&amp;dtrace_lock);

	dtrace_vstate_fini(&amp;help-&gt;dthps_vstate);
	kmem_free(help-&gt;dthps_actions,
	    <span class="enscript-keyword">sizeof</span> (dtrace_helper_action_t *) * DTRACE_NHELPER_ACTIONS);
	kmem_free(help, <span class="enscript-keyword">sizeof</span> (dtrace_helpers_t));

	--dtrace_helpers;
	lck_mtx_unlock(&amp;dtrace_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_helpers_duplicate</span>(proc_t *from, proc_t *to)
{
	dtrace_helpers_t *help, *newhelp;
	dtrace_helper_action_t *helper, *new, *last;
	dtrace_difo_t *dp;
	dtrace_vstate_t *vstate;
	uint_t i;
	<span class="enscript-type">int</span> j, sz, hasprovs = 0;

	lck_mtx_lock(&amp;dtrace_lock);
	ASSERT(from-&gt;p_dtrace_helpers != NULL);
	ASSERT(dtrace_helpers &gt; 0);

	help = from-&gt;p_dtrace_helpers;
	newhelp = dtrace_helpers_create(to);
	ASSERT(to-&gt;p_dtrace_helpers != NULL);

	newhelp-&gt;dthps_generation = help-&gt;dthps_generation;
	vstate = &amp;newhelp-&gt;dthps_vstate;

	<span class="enscript-comment">/*
	 * Duplicate the helper actions.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; DTRACE_NHELPER_ACTIONS; i++) {
		<span class="enscript-keyword">if</span> ((helper = help-&gt;dthps_actions[i]) == NULL)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">for</span> (last = NULL; helper != NULL; helper = helper-&gt;dtha_next) {
			new = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (dtrace_helper_action_t),
			    KM_SLEEP);
			new-&gt;dtha_generation = helper-&gt;dtha_generation;

			<span class="enscript-keyword">if</span> ((dp = helper-&gt;dtha_predicate) != NULL) {
				dp = dtrace_difo_duplicate(dp, vstate);
				new-&gt;dtha_predicate = dp;
			}

			new-&gt;dtha_nactions = helper-&gt;dtha_nactions;
			sz = <span class="enscript-keyword">sizeof</span> (dtrace_difo_t *) * new-&gt;dtha_nactions;
			new-&gt;dtha_actions = kmem_alloc(sz, KM_SLEEP);

			<span class="enscript-keyword">for</span> (j = 0; j &lt; new-&gt;dtha_nactions; j++) {
				dtrace_difo_t *dpj = helper-&gt;dtha_actions[j];

				ASSERT(dpj != NULL);
				dpj = dtrace_difo_duplicate(dpj, vstate);
				new-&gt;dtha_actions[j] = dpj;
			}

			<span class="enscript-keyword">if</span> (last != NULL) {
				last-&gt;dtha_next = new;
			} <span class="enscript-keyword">else</span> {
				newhelp-&gt;dthps_actions[i] = new;
			}

			last = new;
		}
	}

	<span class="enscript-comment">/*
	 * Duplicate the helper providers and register them with the
	 * DTrace framework.
	 */</span>
	<span class="enscript-keyword">if</span> (help-&gt;dthps_nprovs &gt; 0) {
		newhelp-&gt;dthps_nprovs = help-&gt;dthps_nprovs;
		newhelp-&gt;dthps_maxprovs = help-&gt;dthps_nprovs;
		newhelp-&gt;dthps_provs = kmem_alloc(newhelp-&gt;dthps_nprovs *
		    <span class="enscript-keyword">sizeof</span> (dtrace_helper_provider_t *), KM_SLEEP);
		<span class="enscript-keyword">for</span> (i = 0; i &lt; newhelp-&gt;dthps_nprovs; i++) {
			newhelp-&gt;dthps_provs[i] = help-&gt;dthps_provs[i];
			newhelp-&gt;dthps_provs[i]-&gt;dthp_ref++;
		}

		hasprovs = 1;
	}

	lck_mtx_unlock(&amp;dtrace_lock);

	<span class="enscript-keyword">if</span> (hasprovs)
		dtrace_helper_provider_register(to, newhelp, NULL);
}

<span class="enscript-comment">/*
 * DTrace Hook Functions
 */</span>

<span class="enscript-comment">/*
 * APPLE NOTE:  dtrace_modctl_* routines for kext support.
 * Used to manipulate the modctl list within dtrace xnu.
 */</span>

modctl_t *dtrace_modctl_list;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_modctl_add</span>(<span class="enscript-type">struct</span> modctl * newctl)
{
	<span class="enscript-type">struct</span> modctl *nextp, *prevp;

	ASSERT(newctl != NULL);
	lck_mtx_assert(&amp;mod_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">// Insert new module at the front of the list,
</span>	
	newctl-&gt;mod_next = dtrace_modctl_list;
	dtrace_modctl_list = newctl;

	<span class="enscript-comment">/*
	 * If a module exists with the same name, then that module
	 * must have been unloaded with enabled probes. We will move
	 * the unloaded module to the new module's stale chain and
	 * then stop traversing the list.
	 */</span>

	prevp = newctl;
	nextp = newctl-&gt;mod_next;
    
	<span class="enscript-keyword">while</span> (nextp != NULL) {
		<span class="enscript-keyword">if</span> (nextp-&gt;mod_loaded) {
			<span class="enscript-comment">/* This is a loaded module. Keep traversing. */</span>
			prevp = nextp;
			nextp = nextp-&gt;mod_next;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Found an unloaded module */</span>
			<span class="enscript-keyword">if</span> (strncmp (newctl-&gt;mod_modname, nextp-&gt;mod_modname, KMOD_MAX_NAME)) {
				<span class="enscript-comment">/* Names don't match. Keep traversing. */</span>
				prevp = nextp;
				nextp = nextp-&gt;mod_next;
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* We found a stale entry, move it. We're done. */</span>
				prevp-&gt;mod_next = nextp-&gt;mod_next;
				newctl-&gt;mod_stale = nextp;
				nextp-&gt;mod_next = NULL;
				<span class="enscript-keyword">break</span>;
			}
		}
	}
}

<span class="enscript-type">static</span> modctl_t *
<span class="enscript-function-name">dtrace_modctl_lookup</span>(<span class="enscript-type">struct</span> kmod_info * kmod)
{
    lck_mtx_assert(&amp;mod_lock, LCK_MTX_ASSERT_OWNED);

    <span class="enscript-type">struct</span> modctl * ctl;

    <span class="enscript-keyword">for</span> (ctl = dtrace_modctl_list; ctl; ctl=ctl-&gt;mod_next) {
	<span class="enscript-keyword">if</span> (ctl-&gt;mod_id == kmod-&gt;id)
	    <span class="enscript-keyword">return</span>(ctl);
    }
    <span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * This routine is called from dtrace_module_unloaded().
 * It removes a modctl structure and its stale chain
 * from the kext shadow list.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_modctl_remove</span>(<span class="enscript-type">struct</span> modctl * ctl)
{
	ASSERT(ctl != NULL);
	lck_mtx_assert(&amp;mod_lock, LCK_MTX_ASSERT_OWNED);
	modctl_t *prevp, *nextp, *curp;

	<span class="enscript-comment">// Remove stale chain first
</span>	<span class="enscript-keyword">for</span> (curp=ctl-&gt;mod_stale; curp != NULL; curp=nextp) {
		nextp = curp-&gt;mod_stale;
		<span class="enscript-comment">/* There should NEVER be user symbols allocated at this point */</span>
		ASSERT(curp-&gt;mod_user_symbols == NULL);	
		kmem_free(curp, <span class="enscript-keyword">sizeof</span>(modctl_t));
	}

	prevp = NULL;
	curp = dtrace_modctl_list;
	
	<span class="enscript-keyword">while</span> (curp != ctl) {
		prevp = curp;
		curp = curp-&gt;mod_next;
	}

	<span class="enscript-keyword">if</span> (prevp != NULL) {
		prevp-&gt;mod_next = ctl-&gt;mod_next;
	}
	<span class="enscript-keyword">else</span> {
		dtrace_modctl_list = ctl-&gt;mod_next;
	}

	<span class="enscript-comment">/* There should NEVER be user symbols allocated at this point */</span>
	ASSERT(ctl-&gt;mod_user_symbols == NULL);

	kmem_free (ctl, <span class="enscript-keyword">sizeof</span>(modctl_t));
}
	
<span class="enscript-comment">/*
 * APPLE NOTE: The kext loader will call dtrace_module_loaded
 * when the kext is loaded in memory, but before calling the
 * kext's start routine.
 *
 * Return 0 on success
 * Return -1 on failure
 */</span>
	
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_module_loaded</span>(<span class="enscript-type">struct</span> kmod_info *kmod, uint32_t flag)
{
	dtrace_provider_t *prv;

	<span class="enscript-comment">/*
	 * If kernel symbols have been disabled, return immediately
	 * DTRACE_KERNEL_SYMBOLS_NEVER is a permanent mode, it is safe to test without holding locks
	 */</span>
	<span class="enscript-keyword">if</span> (dtrace_kernel_symbol_mode == DTRACE_KERNEL_SYMBOLS_NEVER)
		<span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-type">struct</span> modctl *ctl = NULL;
	<span class="enscript-keyword">if</span> (!kmod || kmod-&gt;address == 0 || kmod-&gt;size == 0)
		<span class="enscript-keyword">return</span>(-1);
		
	lck_mtx_lock(&amp;dtrace_provider_lock);
	lck_mtx_lock(&amp;mod_lock);	
	
	<span class="enscript-comment">/*
	 * Have we seen this kext before?
	 */</span>

	ctl = dtrace_modctl_lookup(kmod);

	<span class="enscript-keyword">if</span> (ctl != NULL) {
		<span class="enscript-comment">/* bail... we already have this kext in the modctl list */</span>
		lck_mtx_unlock(&amp;mod_lock);
		lck_mtx_unlock(&amp;dtrace_provider_lock);
		<span class="enscript-keyword">if</span> (dtrace_err_verbose)
			cmn_err(CE_WARN, <span class="enscript-string">&quot;dtrace load module already exists '%s %u' is failing against '%s %u'&quot;</span>, kmod-&gt;name, (uint_t)kmod-&gt;id, ctl-&gt;mod_modname, ctl-&gt;mod_id);
		<span class="enscript-keyword">return</span>(-1);
	}
	<span class="enscript-keyword">else</span> {
		ctl = kmem_alloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> modctl), KM_SLEEP);
		<span class="enscript-keyword">if</span> (ctl == NULL) {
			<span class="enscript-keyword">if</span> (dtrace_err_verbose)
				cmn_err(CE_WARN, <span class="enscript-string">&quot;dtrace module load '%s %u' is failing &quot;</span>, kmod-&gt;name, (uint_t)kmod-&gt;id);
			lck_mtx_unlock(&amp;mod_lock);
			lck_mtx_unlock(&amp;dtrace_provider_lock);
			<span class="enscript-keyword">return</span> (-1);
		}
		ctl-&gt;mod_next = NULL;
		ctl-&gt;mod_stale = NULL;
		strlcpy (ctl-&gt;mod_modname, kmod-&gt;name, <span class="enscript-keyword">sizeof</span>(ctl-&gt;mod_modname));
		ctl-&gt;mod_loadcnt = kmod-&gt;id;
		ctl-&gt;mod_nenabled = 0;
		ctl-&gt;mod_address  = kmod-&gt;address;
		ctl-&gt;mod_size = kmod-&gt;size;
		ctl-&gt;mod_id = kmod-&gt;id;
		ctl-&gt;mod_loaded = 1;
		ctl-&gt;mod_flags = 0;
		ctl-&gt;mod_user_symbols = NULL;
		
		<span class="enscript-comment">/*
		 * Find the UUID for this module, if it has one
		 */</span>
		kernel_mach_header_t* header = (kernel_mach_header_t *)ctl-&gt;mod_address;
		<span class="enscript-type">struct</span> load_command* load_cmd = (<span class="enscript-type">struct</span> load_command *)&amp;header[1];
		uint32_t i;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; header-&gt;ncmds; i++) {
			<span class="enscript-keyword">if</span> (load_cmd-&gt;cmd == LC_UUID) {
				<span class="enscript-type">struct</span> uuid_command* uuid_cmd = (<span class="enscript-type">struct</span> uuid_command *)load_cmd;
				memcpy(ctl-&gt;mod_uuid, uuid_cmd-&gt;uuid, <span class="enscript-keyword">sizeof</span>(uuid_cmd-&gt;uuid));
				ctl-&gt;mod_flags |= MODCTL_HAS_UUID;
				<span class="enscript-keyword">break</span>;
			}
			load_cmd = (<span class="enscript-type">struct</span> load_command *)((caddr_t)load_cmd + load_cmd-&gt;cmdsize);
		}
		
		<span class="enscript-keyword">if</span> (ctl-&gt;mod_address == g_kernel_kmod_info.address) {
			ctl-&gt;mod_flags |= MODCTL_IS_MACH_KERNEL;
		}
	}
	dtrace_modctl_add(ctl);
	
	<span class="enscript-comment">/*
	 * We must hold the dtrace_lock to safely test non permanent dtrace_fbt_symbol_mode(s)
	 */</span>
	lck_mtx_lock(&amp;dtrace_lock);
	
	<span class="enscript-comment">/*
	 * DTrace must decide if it will instrument modules lazily via
	 * userspace symbols (default mode), or instrument immediately via 
	 * kernel symbols (non-default mode)
	 *
	 * When in default/lazy mode, DTrace will only support modules
	 * built with a valid UUID.
	 *
	 * Overriding the default can be done explicitly in one of
	 * the following two ways.
	 *
	 * A module can force symbols from kernel space using the plist key,
	 * OSBundleForceDTraceInit (see kmod.h).  If this per kext state is set,
	 * we fall through and instrument this module now.
	 *
	 * Or, the boot-arg, dtrace_kernel_symbol_mode, can be set to force symbols
	 * from kernel space (see dtrace_impl.h).  If this system state is set
	 * to a non-userspace mode, we fall through and instrument the module now.
	 */</span>

	<span class="enscript-keyword">if</span> ((dtrace_kernel_symbol_mode == DTRACE_KERNEL_SYMBOLS_FROM_USERSPACE) &amp;&amp;
	    (!(flag &amp; KMOD_DTRACE_FORCE_INIT)))
	{
		<span class="enscript-comment">/* We will instrument the module lazily -- this is the default */</span>
		lck_mtx_unlock(&amp;dtrace_lock);
		lck_mtx_unlock(&amp;mod_lock);
		lck_mtx_unlock(&amp;dtrace_provider_lock);
		<span class="enscript-keyword">return</span> 0;
	}
	
	<span class="enscript-comment">/* We will instrument the module immediately using kernel symbols */</span>
	ctl-&gt;mod_flags |= MODCTL_HAS_KERNEL_SYMBOLS;
	
	lck_mtx_unlock(&amp;dtrace_lock);
	
	<span class="enscript-comment">/*
	 * We're going to call each providers per-module provide operation
	 * specifying only this module.
	 */</span>
	<span class="enscript-keyword">for</span> (prv = dtrace_provider; prv != NULL; prv = prv-&gt;dtpv_next)
		prv-&gt;dtpv_pops.dtps_provide_module(prv-&gt;dtpv_arg, ctl);	
	
	<span class="enscript-comment">/*
	 * APPLE NOTE: The contract with the kext loader is that once this function
	 * has completed, it may delete kernel symbols at will.
	 * We must set this while still holding the mod_lock.
	 */</span>
	ctl-&gt;mod_flags &amp;= ~MODCTL_HAS_KERNEL_SYMBOLS;
	
	lck_mtx_unlock(&amp;mod_lock);
	lck_mtx_unlock(&amp;dtrace_provider_lock);
	
	<span class="enscript-comment">/*
	 * If we have any retained enablings, we need to match against them.
	 * Enabling probes requires that cpu_lock be held, and we cannot hold
	 * cpu_lock here -- it is legal for cpu_lock to be held when loading a
	 * module.  (In particular, this happens when loading scheduling
	 * classes.)  So if we have any retained enablings, we need to dispatch
	 * our task queue to do the match for us.
	 */</span>
	lck_mtx_lock(&amp;dtrace_lock);
	
	<span class="enscript-keyword">if</span> (dtrace_retained == NULL) {
		lck_mtx_unlock(&amp;dtrace_lock);
		<span class="enscript-keyword">return</span> 0;
	}
	
	<span class="enscript-comment">/* APPLE NOTE!
	 *
	 * The cpu_lock mentioned above is only held by dtrace code, Apple's xnu never actually
	 * holds it for any reason. Thus the comment above is invalid, we can directly invoke
	 * dtrace_enabling_matchall without jumping through all the hoops, and we can avoid
	 * the delay call as well.
	 */</span>
	lck_mtx_unlock(&amp;dtrace_lock);
	
	dtrace_enabling_matchall();
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Return 0 on success
 * Return -1 on failure
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_module_unloaded</span>(<span class="enscript-type">struct</span> kmod_info *kmod)
{
	dtrace_probe_t template, *probe, *first, *next;
	dtrace_provider_t *prov;
        <span class="enscript-type">struct</span> modctl *ctl = NULL;
	<span class="enscript-type">struct</span> modctl *syncctl = NULL;
	<span class="enscript-type">struct</span> modctl *nextsyncctl = NULL;
	<span class="enscript-type">int</span> syncmode = 0;
	
        lck_mtx_lock(&amp;dtrace_provider_lock);
	lck_mtx_lock(&amp;mod_lock);
	lck_mtx_lock(&amp;dtrace_lock);

	<span class="enscript-keyword">if</span> (kmod == NULL) {
	    syncmode = 1;
	}
	<span class="enscript-keyword">else</span> {
	    ctl = dtrace_modctl_lookup(kmod);
	    <span class="enscript-keyword">if</span> (ctl == NULL)
	    {
		lck_mtx_unlock(&amp;dtrace_lock);
		lck_mtx_unlock(&amp;mod_lock);
		lck_mtx_unlock(&amp;dtrace_provider_lock);
		<span class="enscript-keyword">return</span> (-1);
	    }
	    ctl-&gt;mod_loaded = 0;
	    ctl-&gt;mod_address = 0;
	    ctl-&gt;mod_size = 0;
	}
	
	<span class="enscript-keyword">if</span> (dtrace_bymod == NULL) {
		<span class="enscript-comment">/*
		 * The DTrace module is loaded (obviously) but not attached;
		 * we don't have any work to do.
		 */</span>
	         <span class="enscript-keyword">if</span> (ctl != NULL)
			 (<span class="enscript-type">void</span>)dtrace_modctl_remove(ctl);
		 lck_mtx_unlock(&amp;dtrace_lock);
		 lck_mtx_unlock(&amp;mod_lock);
		 lck_mtx_unlock(&amp;dtrace_provider_lock);
		 <span class="enscript-keyword">return</span>(0);
	}

	<span class="enscript-comment">/* Syncmode set means we target and traverse entire modctl list. */</span>
        <span class="enscript-keyword">if</span> (syncmode)
	    nextsyncctl = dtrace_modctl_list;

<span class="enscript-reference">syncloop</span>:
	<span class="enscript-keyword">if</span> (syncmode)
	{
	    <span class="enscript-comment">/* find a stale modctl struct */</span>
	    <span class="enscript-keyword">for</span> (syncctl = nextsyncctl; syncctl != NULL; syncctl=syncctl-&gt;mod_next) {
		<span class="enscript-keyword">if</span> (syncctl-&gt;mod_address == 0)
		    <span class="enscript-keyword">break</span>;
	    }
	    <span class="enscript-keyword">if</span> (syncctl==NULL)
	    {
		<span class="enscript-comment">/* We have no more work to do */</span>
		lck_mtx_unlock(&amp;dtrace_lock);
		lck_mtx_unlock(&amp;mod_lock);
		lck_mtx_unlock(&amp;dtrace_provider_lock);
		<span class="enscript-keyword">return</span>(0);
	    }
	    <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* keep track of next syncctl in case this one is removed */</span>
		nextsyncctl = syncctl-&gt;mod_next;
		ctl = syncctl;
	    }
	}

	template.dtpr_mod = ctl-&gt;mod_modname;
	
	<span class="enscript-keyword">for</span> (probe = first = dtrace_hash_lookup(dtrace_bymod, &amp;template);
	    probe != NULL; probe = probe-&gt;dtpr_nextmod) {
	        <span class="enscript-keyword">if</span> (probe-&gt;dtpr_ecb != NULL) {
			<span class="enscript-comment">/*
			 * This shouldn't _actually_ be possible -- we're
			 * unloading a module that has an enabled probe in it.
			 * (It's normally up to the provider to make sure that
			 * this can't happen.)  However, because dtps_enable()
			 * doesn't have a failure mode, there can be an
			 * enable/unload race.  Upshot:  we don't want to
			 * assert, but we're not going to disable the
			 * probe, either.
			 */</span>


		        <span class="enscript-keyword">if</span> (syncmode) {
			    <span class="enscript-comment">/* We're syncing, let's look at next in list */</span>
			    <span class="enscript-keyword">goto</span> <span class="enscript-reference">syncloop</span>;
			}

			lck_mtx_unlock(&amp;dtrace_lock);
			lck_mtx_unlock(&amp;mod_lock);
			lck_mtx_unlock(&amp;dtrace_provider_lock);
		    
			<span class="enscript-keyword">if</span> (dtrace_err_verbose) {
				cmn_err(CE_WARN, <span class="enscript-string">&quot;unloaded module '%s' had &quot;</span>
				    <span class="enscript-string">&quot;enabled probes&quot;</span>, ctl-&gt;mod_modname);
			}
			<span class="enscript-keyword">return</span>(-1);
		}
	}

	probe = first;

	<span class="enscript-keyword">for</span> (first = NULL; probe != NULL; probe = next) {
		ASSERT(dtrace_probes[probe-&gt;dtpr_id - 1] == probe);

		dtrace_probes[probe-&gt;dtpr_id - 1] = NULL;
		probe-&gt;dtpr_provider-&gt;dtpv_probe_count--;					

		next = probe-&gt;dtpr_nextmod;
		dtrace_hash_remove(dtrace_bymod, probe);
		dtrace_hash_remove(dtrace_byfunc, probe);
		dtrace_hash_remove(dtrace_byname, probe);

		<span class="enscript-keyword">if</span> (first == NULL) {
			first = probe;
			probe-&gt;dtpr_nextmod = NULL;
		} <span class="enscript-keyword">else</span> {
			probe-&gt;dtpr_nextmod = first;
			first = probe;
		}
	}

	<span class="enscript-comment">/*
	 * We've removed all of the module's probes from the hash chains and
	 * from the probe array.  Now issue a dtrace_sync() to be sure that
	 * everyone has cleared out from any probe array processing.
	 */</span>
	dtrace_sync();

	<span class="enscript-keyword">for</span> (probe = first; probe != NULL; probe = first) {
		first = probe-&gt;dtpr_nextmod;
		prov = probe-&gt;dtpr_provider;
		prov-&gt;dtpv_pops.dtps_destroy(prov-&gt;dtpv_arg, probe-&gt;dtpr_id,
		    probe-&gt;dtpr_arg);
		kmem_free(probe-&gt;dtpr_mod, strlen(probe-&gt;dtpr_mod) + 1);
		kmem_free(probe-&gt;dtpr_func, strlen(probe-&gt;dtpr_func) + 1);
		kmem_free(probe-&gt;dtpr_name, strlen(probe-&gt;dtpr_name) + 1);
		vmem_free(dtrace_arena, (<span class="enscript-type">void</span> *)(uintptr_t)probe-&gt;dtpr_id, 1);

		zfree(dtrace_probe_t_zone, probe);
	}

	dtrace_modctl_remove(ctl);
	
	<span class="enscript-keyword">if</span> (syncmode)
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">syncloop</span>;

	lck_mtx_unlock(&amp;dtrace_lock);
	lck_mtx_unlock(&amp;mod_lock);
	lck_mtx_unlock(&amp;dtrace_provider_lock);

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_suspend</span>(<span class="enscript-type">void</span>)
{
	dtrace_probe_foreach(offsetof(dtrace_pops_t, dtps_suspend));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_resume</span>(<span class="enscript-type">void</span>)
{
	dtrace_probe_foreach(offsetof(dtrace_pops_t, dtps_resume));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_cpu_setup</span>(cpu_setup_t what, processorid_t cpu)
{
	lck_mtx_assert(&amp;cpu_lock, LCK_MTX_ASSERT_OWNED);
	lck_mtx_lock(&amp;dtrace_lock);

	<span class="enscript-keyword">switch</span> (what) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">CPU_CONFIG</span>: {
		dtrace_state_t *state;
		dtrace_optval_t *opt, rs, c;

		<span class="enscript-comment">/*
		 * For now, we only allocate a new buffer for anonymous state.
		 */</span>
		<span class="enscript-keyword">if</span> ((state = dtrace_anon.dta_state) == NULL)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (state-&gt;dts_activity != DTRACE_ACTIVITY_ACTIVE)
			<span class="enscript-keyword">break</span>;

		opt = state-&gt;dts_options;
		c = opt[DTRACEOPT_CPU];

		<span class="enscript-keyword">if</span> (c != DTRACE_CPUALL &amp;&amp; c != DTRACEOPT_UNSET &amp;&amp; c != cpu)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * Regardless of what the actual policy is, we're going to
		 * temporarily set our resize policy to be manual.  We're
		 * also going to temporarily set our CPU option to denote
		 * the newly configured CPU.
		 */</span>
		rs = opt[DTRACEOPT_BUFRESIZE];
		opt[DTRACEOPT_BUFRESIZE] = DTRACEOPT_BUFRESIZE_MANUAL;
		opt[DTRACEOPT_CPU] = (dtrace_optval_t)cpu;

		(<span class="enscript-type">void</span>) dtrace_state_buffers(state);

		opt[DTRACEOPT_BUFRESIZE] = rs;
		opt[DTRACEOPT_CPU] = c;

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">CPU_UNCONFIG</span>:
		<span class="enscript-comment">/*
		 * We don't free the buffer in the CPU_UNCONFIG case.  (The
		 * buffer will be freed when the consumer exits.)
		 */</span>
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	lck_mtx_unlock(&amp;dtrace_lock);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_cpu_setup_initial</span>(processorid_t cpu)
{
	(<span class="enscript-type">void</span>) dtrace_cpu_setup(CPU_CONFIG, cpu);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_toxrange_add</span>(uintptr_t base, uintptr_t limit)
{
	<span class="enscript-keyword">if</span> (dtrace_toxranges &gt;= dtrace_toxranges_max) {
		<span class="enscript-type">int</span> osize, nsize;
		dtrace_toxrange_t *range;

		osize = dtrace_toxranges_max * <span class="enscript-keyword">sizeof</span> (dtrace_toxrange_t);

		<span class="enscript-keyword">if</span> (osize == 0) {
			ASSERT(dtrace_toxrange == NULL);
			ASSERT(dtrace_toxranges_max == 0);
			dtrace_toxranges_max = 1;
		} <span class="enscript-keyword">else</span> {
			dtrace_toxranges_max &lt;&lt;= 1;
		}

		nsize = dtrace_toxranges_max * <span class="enscript-keyword">sizeof</span> (dtrace_toxrange_t);
		range = kmem_zalloc(nsize, KM_SLEEP);

		<span class="enscript-keyword">if</span> (dtrace_toxrange != NULL) {
			ASSERT(osize != 0);
			bcopy(dtrace_toxrange, range, osize);
			kmem_free(dtrace_toxrange, osize);
		}

		dtrace_toxrange = range;
	}

	ASSERT(dtrace_toxrange[dtrace_toxranges].dtt_base == 0);
	ASSERT(dtrace_toxrange[dtrace_toxranges].dtt_limit == 0);

	dtrace_toxrange[dtrace_toxranges].dtt_base = base;
	dtrace_toxrange[dtrace_toxranges].dtt_limit = limit;
	dtrace_toxranges++;
}

<span class="enscript-comment">/*
 * DTrace Driver Cookbook Functions
 */</span>
<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_attach</span>(dev_info_t *devi, ddi_attach_cmd_t cmd)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cmd</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	dtrace_provider_id_t id;
	dtrace_state_t *state = NULL;
	dtrace_enabling_t *enab;

	lck_mtx_lock(&amp;cpu_lock);
	lck_mtx_lock(&amp;dtrace_provider_lock);
	lck_mtx_lock(&amp;dtrace_lock);

	<span class="enscript-keyword">if</span> (ddi_soft_state_init(&amp;dtrace_softstate,
	    <span class="enscript-keyword">sizeof</span> (dtrace_state_t), 0) != 0) {
		cmn_err(CE_NOTE, <span class="enscript-string">&quot;/dev/dtrace failed to initialize soft state&quot;</span>);
		lck_mtx_unlock(&amp;dtrace_lock);
		lck_mtx_unlock(&amp;dtrace_provider_lock);
		lck_mtx_unlock(&amp;cpu_lock);
		<span class="enscript-keyword">return</span> (DDI_FAILURE);
	}

	<span class="enscript-comment">/* Darwin uses BSD cloning device driver to automagically obtain minor device number. */</span>

	ddi_report_dev(devi);
	dtrace_devi = devi;

	dtrace_modload = dtrace_module_loaded;
	dtrace_modunload = dtrace_module_unloaded;
	dtrace_cpu_init = dtrace_cpu_setup_initial;
	dtrace_helpers_cleanup = dtrace_helpers_destroy;
	dtrace_helpers_fork = dtrace_helpers_duplicate;
	dtrace_cpustart_init = dtrace_suspend;
	dtrace_cpustart_fini = dtrace_resume;
	dtrace_debugger_init = dtrace_suspend;
	dtrace_debugger_fini = dtrace_resume;

	register_cpu_setup_func((cpu_setup_func_t *)dtrace_cpu_setup, NULL);

	lck_mtx_assert(&amp;cpu_lock, LCK_MTX_ASSERT_OWNED);

	dtrace_arena = vmem_create(<span class="enscript-string">&quot;dtrace&quot;</span>, (<span class="enscript-type">void</span> *)1, UINT32_MAX, 1,
	    NULL, NULL, NULL, 0, VM_SLEEP | VMC_IDENTIFIER);
	dtrace_minor = vmem_create(<span class="enscript-string">&quot;dtrace_minor&quot;</span>, (<span class="enscript-type">void</span> *)DTRACEMNRN_CLONE,
	    UINT32_MAX - DTRACEMNRN_CLONE, 1, NULL, NULL, NULL, 0,
	    VM_SLEEP | VMC_IDENTIFIER);
	dtrace_taskq = taskq_create(<span class="enscript-string">&quot;dtrace_taskq&quot;</span>, 1, maxclsyspri,
	    1, INT_MAX, 0);

	dtrace_state_cache = kmem_cache_create(<span class="enscript-string">&quot;dtrace_state_cache&quot;</span>,
	    <span class="enscript-keyword">sizeof</span> (dtrace_dstate_percpu_t) * (<span class="enscript-type">int</span>)NCPU, DTRACE_STATE_ALIGN,
	    NULL, NULL, NULL, NULL, NULL, 0);

	lck_mtx_assert(&amp;cpu_lock, LCK_MTX_ASSERT_OWNED);
	dtrace_bymod = dtrace_hash_create(offsetof(dtrace_probe_t, dtpr_mod),
	    offsetof(dtrace_probe_t, dtpr_nextmod),
	    offsetof(dtrace_probe_t, dtpr_prevmod));

	dtrace_byfunc = dtrace_hash_create(offsetof(dtrace_probe_t, dtpr_func),
	    offsetof(dtrace_probe_t, dtpr_nextfunc),
	    offsetof(dtrace_probe_t, dtpr_prevfunc));

	dtrace_byname = dtrace_hash_create(offsetof(dtrace_probe_t, dtpr_name),
	    offsetof(dtrace_probe_t, dtpr_nextname),
	    offsetof(dtrace_probe_t, dtpr_prevname));

	<span class="enscript-keyword">if</span> (dtrace_retain_max &lt; 1) {
		cmn_err(CE_WARN, <span class="enscript-string">&quot;illegal value (%lu) for dtrace_retain_max; &quot;</span>
		    <span class="enscript-string">&quot;setting to 1&quot;</span>, dtrace_retain_max);
		dtrace_retain_max = 1;
	}

	<span class="enscript-comment">/*
	 * Now discover our toxic ranges.
	 */</span>
	dtrace_toxic_ranges(dtrace_toxrange_add);

	<span class="enscript-comment">/*
	 * Before we register ourselves as a provider to our own framework,
	 * we would like to assert that dtrace_provider is NULL -- but that's
	 * not true if we were loaded as a dependency of a DTrace provider.
	 * Once we've registered, we can assert that dtrace_provider is our
	 * pseudo provider.
	 */</span>
	(<span class="enscript-type">void</span>) dtrace_register(<span class="enscript-string">&quot;dtrace&quot;</span>, &amp;dtrace_provider_attr,
	    DTRACE_PRIV_NONE, 0, &amp;dtrace_provider_ops, NULL, &amp;id);

	ASSERT(dtrace_provider != NULL);
	ASSERT((dtrace_provider_id_t)dtrace_provider == id);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__x86_64__</span>)
	dtrace_probeid_begin = dtrace_probe_create((dtrace_provider_id_t)
	    dtrace_provider, NULL, NULL, <span class="enscript-string">&quot;BEGIN&quot;</span>, 1, NULL);
	dtrace_probeid_end = dtrace_probe_create((dtrace_provider_id_t)
	    dtrace_provider, NULL, NULL, <span class="enscript-string">&quot;END&quot;</span>, 0, NULL);
	dtrace_probeid_error = dtrace_probe_create((dtrace_provider_id_t)
	    dtrace_provider, NULL, NULL, <span class="enscript-string">&quot;ERROR&quot;</span>, 3, NULL);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unknown</span> <span class="enscript-variable-name">Architecture</span>
#<span class="enscript-reference">endif</span>

	dtrace_anon_property();
	lck_mtx_unlock(&amp;cpu_lock);

	<span class="enscript-comment">/*
	 * If DTrace helper tracing is enabled, we need to allocate the
	 * trace buffer and initialize the values.
	 */</span>
	<span class="enscript-keyword">if</span> (dtrace_helptrace_enabled) {
		ASSERT(dtrace_helptrace_buffer == NULL);
		dtrace_helptrace_buffer =
		    kmem_zalloc(dtrace_helptrace_bufsize, KM_SLEEP);
		dtrace_helptrace_next = 0;
	}

	<span class="enscript-comment">/*
	 * If there are already providers, we must ask them to provide their
	 * probes, and then match any anonymous enabling against them.  Note
	 * that there should be no other retained enablings at this time:
	 * the only retained enablings at this time should be the anonymous
	 * enabling.
	 */</span>
	<span class="enscript-keyword">if</span> (dtrace_anon.dta_enabling != NULL) {
		ASSERT(dtrace_retained == dtrace_anon.dta_enabling);

		<span class="enscript-comment">/*
		 * APPLE NOTE: if handling anonymous dof, switch symbol modes.
		 */</span>
		<span class="enscript-keyword">if</span> (dtrace_kernel_symbol_mode == DTRACE_KERNEL_SYMBOLS_FROM_USERSPACE) {
			dtrace_kernel_symbol_mode = DTRACE_KERNEL_SYMBOLS_FROM_KERNEL;
		}
		
		dtrace_enabling_provide(NULL);
		state = dtrace_anon.dta_state;

		<span class="enscript-comment">/*
		 * We couldn't hold cpu_lock across the above call to
		 * dtrace_enabling_provide(), but we must hold it to actually
		 * enable the probes.  We have to drop all of our locks, pick
		 * up cpu_lock, and regain our locks before matching the
		 * retained anonymous enabling.
		 */</span>
		lck_mtx_unlock(&amp;dtrace_lock);
		lck_mtx_unlock(&amp;dtrace_provider_lock);

		lck_mtx_lock(&amp;cpu_lock);
		lck_mtx_lock(&amp;dtrace_provider_lock);
		lck_mtx_lock(&amp;dtrace_lock);

		<span class="enscript-keyword">if</span> ((enab = dtrace_anon.dta_enabling) != NULL)
			(<span class="enscript-type">void</span>) dtrace_enabling_match(enab, NULL);

		lck_mtx_unlock(&amp;cpu_lock);
	}

	lck_mtx_unlock(&amp;dtrace_lock);
	lck_mtx_unlock(&amp;dtrace_provider_lock);

	<span class="enscript-keyword">if</span> (state != NULL) {
		<span class="enscript-comment">/*
		 * If we created any anonymous state, set it going now.
		 */</span>
		(<span class="enscript-type">void</span>) dtrace_state_go(state, &amp;dtrace_anon.dta_beganon);
	}

	<span class="enscript-keyword">return</span> (DDI_SUCCESS);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_open</span>(dev_t *devp, <span class="enscript-type">int</span> flag, <span class="enscript-type">int</span> otyp, cred_t *cred_p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">flag</span>, <span class="enscript-variable-name">otyp</span>)
	dtrace_state_t *state;
	uint32_t priv;
	uid_t uid;
	zoneid_t zoneid;
	<span class="enscript-type">int</span> rv;

	<span class="enscript-comment">/* APPLE: Darwin puts Helper on its own major device. */</span>

	<span class="enscript-comment">/*
	 * If no DTRACE_PRIV_* bits are set in the credential, then the
	 * caller lacks sufficient permission to do anything with DTrace.
	 */</span>
	dtrace_cred2priv(cred_p, &amp;priv, &amp;uid, &amp;zoneid);
	<span class="enscript-keyword">if</span> (priv == DTRACE_PRIV_NONE)
		<span class="enscript-keyword">return</span> (EACCES);

	<span class="enscript-comment">/*
	 * APPLE NOTE: We delay the initialization of fasttrap as late as possible.
	 * It certainly can't be later than now!
	 */</span>
	fasttrap_init();

	<span class="enscript-comment">/*
	 * Ask all providers to provide all their probes.
	 */</span>
	lck_mtx_lock(&amp;dtrace_provider_lock);
	dtrace_probe_provide(NULL, NULL);
	lck_mtx_unlock(&amp;dtrace_provider_lock);

	lck_mtx_lock(&amp;cpu_lock);
	lck_mtx_lock(&amp;dtrace_lock);
	dtrace_opens++;
	dtrace_membar_producer();

	<span class="enscript-comment">/*
	 * If the kernel debugger is active (that is, if the kernel debugger
	 * modified text in some way), we won't allow the open.
	 */</span>
	<span class="enscript-keyword">if</span> (kdi_dtrace_set(KDI_DTSET_DTRACE_ACTIVATE) != 0) {
		dtrace_opens--;
		lck_mtx_unlock(&amp;dtrace_lock);
		lck_mtx_unlock(&amp;cpu_lock);
		<span class="enscript-keyword">return</span> (EBUSY);
	}

	rv = dtrace_state_create(devp, cred_p, &amp;state);
	lck_mtx_unlock(&amp;cpu_lock);

	<span class="enscript-keyword">if</span> (rv != 0 || state == NULL) {
		<span class="enscript-keyword">if</span> (--dtrace_opens == 0 &amp;&amp; dtrace_anon.dta_enabling == NULL)
			(<span class="enscript-type">void</span>) kdi_dtrace_set(KDI_DTSET_DTRACE_DEACTIVATE);
		lck_mtx_unlock(&amp;dtrace_lock);
		<span class="enscript-comment">/* propagate EAGAIN or ERESTART */</span>
		<span class="enscript-keyword">return</span> (rv);
	}
	
	lck_mtx_unlock(&amp;dtrace_lock);

	lck_rw_lock_exclusive(&amp;dtrace_dof_mode_lock);

	<span class="enscript-comment">/*
	 * If we are currently lazy, transition states.
	 *
	 * Unlike dtrace_close, we do not need to check the
	 * value of dtrace_opens, as any positive value (and
	 * we count as 1) means we transition states.
	 */</span>
	<span class="enscript-keyword">if</span> (dtrace_dof_mode == DTRACE_DOF_MODE_LAZY_ON) {
		dtrace_dof_mode = DTRACE_DOF_MODE_LAZY_OFF;
		
		<span class="enscript-comment">/*
		 * Iterate all existing processes and load lazy dofs.
		 */</span>
		proc_iterate(PROC_ALLPROCLIST | PROC_NOWAITTRANS,
			     dtrace_lazy_dofs_proc_iterate_doit,
			     NULL,
			     dtrace_lazy_dofs_proc_iterate_filter,
			     NULL);
	}

	lck_rw_unlock_exclusive(&amp;dtrace_dof_mode_lock);

	<span class="enscript-comment">/*
	 * Update kernel symbol state.
	 *
	 * We must own the provider and dtrace locks. 
	 *
	 * NOTE! It may appear there is a race by setting this value so late
	 * after dtrace_probe_provide. However, any kext loaded after the
	 * call to probe provide and before we set LAZY_OFF will be marked as
	 * eligible for symbols from userspace. The same dtrace that is currently
	 * calling dtrace_open() (this call!) will get a list of kexts needing
	 * symbols and fill them in, thus closing the race window.
	 *
	 * We want to set this value only after it certain it will succeed, as
	 * this significantly reduces the complexity of error exits.
	 */</span>
	lck_mtx_lock(&amp;dtrace_lock);
	<span class="enscript-keyword">if</span> (dtrace_kernel_symbol_mode == DTRACE_KERNEL_SYMBOLS_FROM_USERSPACE) {
		dtrace_kernel_symbol_mode = DTRACE_KERNEL_SYMBOLS_FROM_KERNEL;
	}
	lck_mtx_unlock(&amp;dtrace_lock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_close</span>(dev_t dev, <span class="enscript-type">int</span> flag, <span class="enscript-type">int</span> otyp, cred_t *cred_p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">flag</span>, <span class="enscript-variable-name">otyp</span>, <span class="enscript-variable-name">cred_p</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	minor_t minor = getminor(dev);
	dtrace_state_t *state;

	<span class="enscript-comment">/* APPLE NOTE: Darwin puts Helper on its own major device. */</span>

	state = ddi_get_soft_state(dtrace_softstate, minor);

	lck_mtx_lock(&amp;cpu_lock);
	lck_mtx_lock(&amp;dtrace_lock);

	<span class="enscript-keyword">if</span> (state-&gt;dts_anon) {
		<span class="enscript-comment">/*
		 * There is anonymous state. Destroy that first.
		 */</span>
		ASSERT(dtrace_anon.dta_state == NULL);
		dtrace_state_destroy(state-&gt;dts_anon);
	}

	dtrace_state_destroy(state);
	ASSERT(dtrace_opens &gt; 0);

	<span class="enscript-comment">/*
	 * Only relinquish control of the kernel debugger interface when there
	 * are no consumers and no anonymous enablings.
	 */</span>
	<span class="enscript-keyword">if</span> (--dtrace_opens == 0 &amp;&amp; dtrace_anon.dta_enabling == NULL)
		(<span class="enscript-type">void</span>) kdi_dtrace_set(KDI_DTSET_DTRACE_DEACTIVATE);
	
	lck_mtx_unlock(&amp;dtrace_lock);
	lck_mtx_unlock(&amp;cpu_lock);

	<span class="enscript-comment">/*
	 * Lock ordering requires the dof mode lock be taken before
	 * the dtrace_lock.
	 */</span>
	lck_rw_lock_exclusive(&amp;dtrace_dof_mode_lock);
	lck_mtx_lock(&amp;dtrace_lock);
	
	<span class="enscript-keyword">if</span> (dtrace_opens == 0) {
		<span class="enscript-comment">/*
		 * If we are currently lazy-off, and this is the last close, transition to
		 * lazy state.
		 */</span>
		<span class="enscript-keyword">if</span> (dtrace_dof_mode == DTRACE_DOF_MODE_LAZY_OFF) {
			dtrace_dof_mode = DTRACE_DOF_MODE_LAZY_ON;
		}

		<span class="enscript-comment">/*
		 * If we are the last dtrace client, switch back to lazy (from userspace) symbols
		 */</span>
		<span class="enscript-keyword">if</span> (dtrace_kernel_symbol_mode == DTRACE_KERNEL_SYMBOLS_FROM_KERNEL) {
			dtrace_kernel_symbol_mode = DTRACE_KERNEL_SYMBOLS_FROM_USERSPACE;
		}
	}
	
	lck_mtx_unlock(&amp;dtrace_lock);
	lck_rw_unlock_exclusive(&amp;dtrace_dof_mode_lock);
	
	<span class="enscript-comment">/*
	 * Kext probes may be retained past the end of the kext's lifespan. The
	 * probes are kept until the last reference to them has been removed.
	 * Since closing an active dtrace context is likely to drop that last reference,
	 * lets take a shot at cleaning out the orphaned probes now.
	 */</span>
	dtrace_module_unloaded(NULL);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_ioctl_helper</span>(u_long cmd, caddr_t arg, <span class="enscript-type">int</span> *rv)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">rv</span>)
	<span class="enscript-comment">/*
	 * Safe to check this outside the dof mode lock
	 */</span>
	<span class="enscript-keyword">if</span> (dtrace_dof_mode == DTRACE_DOF_MODE_NEVER)
		<span class="enscript-keyword">return</span> KERN_SUCCESS;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEHIOC_ADDDOF</span>:
	                {
			dof_helper_t *dhp = NULL;
			size_t dof_ioctl_data_size;
			dof_ioctl_data_t* multi_dof;
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
			<span class="enscript-type">int</span> rval = 0;
			user_addr_t user_address = *(user_addr_t*)arg;
			uint64_t dof_count;
			<span class="enscript-type">int</span> multi_dof_claimed = 0;
			proc_t* p = current_proc();

			<span class="enscript-comment">/*
			 * Read the number of DOF sections being passed in.
			 */</span>
			<span class="enscript-keyword">if</span> (copyin(user_address + offsetof(dof_ioctl_data_t, dofiod_count),
				   &amp;dof_count,
				   <span class="enscript-keyword">sizeof</span>(dof_count))) {
				dtrace_dof_error(NULL, <span class="enscript-string">&quot;failed to copyin dofiod_count&quot;</span>);
				<span class="enscript-keyword">return</span> (EFAULT);
			}
				   			
			<span class="enscript-comment">/*
			 * Range check the count.
			 */</span>
			<span class="enscript-keyword">if</span> (dof_count == 0 || dof_count &gt; 1024) {
				dtrace_dof_error(NULL, <span class="enscript-string">&quot;dofiod_count is not valid&quot;</span>);
				<span class="enscript-keyword">return</span> (EINVAL);
			}
			
			<span class="enscript-comment">/*
			 * Allocate a correctly sized structure and copyin the data.
			 */</span>
			dof_ioctl_data_size = DOF_IOCTL_DATA_T_SIZE(dof_count);
			<span class="enscript-keyword">if</span> ((multi_dof = kmem_alloc(dof_ioctl_data_size, KM_SLEEP)) == NULL) 
				<span class="enscript-keyword">return</span> (ENOMEM);
			
			<span class="enscript-comment">/* NOTE! We can no longer exit this method via return */</span>
			<span class="enscript-keyword">if</span> (copyin(user_address, multi_dof, dof_ioctl_data_size) != 0) {
				dtrace_dof_error(NULL, <span class="enscript-string">&quot;failed copyin of dof_ioctl_data_t&quot;</span>);
				rval = EFAULT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
			}
			
			<span class="enscript-comment">/*
			 * Check that the count didn't change between the first copyin and the second.
			 */</span>
			<span class="enscript-keyword">if</span> (multi_dof-&gt;dofiod_count != dof_count) {
				rval = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;
			}

			<span class="enscript-comment">/*
			 * Try to process lazily first.
			 */</span>
			rval = dtrace_lazy_dofs_add(p, multi_dof, &amp;multi_dof_claimed);

			<span class="enscript-comment">/*
			 * If rval is EACCES, we must be non-lazy.
			 */</span>
			<span class="enscript-keyword">if</span> (rval == EACCES) {
				rval = 0;
				<span class="enscript-comment">/*
				 * Process each dof_helper_t
				 */</span>
				i = 0;
				<span class="enscript-keyword">do</span> {
					dhp = &amp;multi_dof-&gt;dofiod_helpers[i];
					
					dof_hdr_t *dof = dtrace_dof_copyin(dhp-&gt;dofhp_dof, &amp;rval);
					
					<span class="enscript-keyword">if</span> (dof != NULL) {					
						lck_mtx_lock(&amp;dtrace_lock);
						
						<span class="enscript-comment">/*
						 * dtrace_helper_slurp() takes responsibility for the dof --
						 * it may free it now or it may save it and free it later.
						 */</span>
						<span class="enscript-keyword">if</span> ((dhp-&gt;dofhp_dof = (uint64_t)dtrace_helper_slurp(p, dof, dhp)) == -1ULL) {
							rval = EINVAL;
						}
						
						lck_mtx_unlock(&amp;dtrace_lock);
					}
				} <span class="enscript-keyword">while</span> (++i &lt; multi_dof-&gt;dofiod_count &amp;&amp; rval == 0);
			}

			<span class="enscript-comment">/*
			 * We need to copyout the multi_dof struct, because it contains
			 * the generation (unique id) values needed to call DTRACEHIOC_REMOVE
			 *
			 * This could certainly be better optimized.
			 */</span>
			<span class="enscript-keyword">if</span> (copyout(multi_dof, user_address, dof_ioctl_data_size) != 0) {
				dtrace_dof_error(NULL, <span class="enscript-string">&quot;failed copyout of dof_ioctl_data_t&quot;</span>);
				<span class="enscript-comment">/* Don't overwrite pre-existing error code */</span>
				<span class="enscript-keyword">if</span> (rval == 0) rval = EFAULT;
			}
			
		<span class="enscript-reference">cleanup</span>:
			<span class="enscript-comment">/*
			 * If we had to allocate struct memory, free it.
			 */</span>
			<span class="enscript-keyword">if</span> (multi_dof != NULL &amp;&amp; !multi_dof_claimed) {
				kmem_free(multi_dof, dof_ioctl_data_size);
			}
			
			<span class="enscript-keyword">return</span> rval;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEHIOC_REMOVE</span>: {
			<span class="enscript-type">int</span> generation = *(<span class="enscript-type">int</span>*)arg;
			proc_t* p = current_proc();

			<span class="enscript-comment">/*
			 * Try lazy first.
			 */</span>
			<span class="enscript-type">int</span> rval = dtrace_lazy_dofs_remove(p, generation);
			
			<span class="enscript-comment">/*
			 * EACCES means non-lazy
			 */</span>
			<span class="enscript-keyword">if</span> (rval == EACCES) {
				lck_mtx_lock(&amp;dtrace_lock);
				rval = dtrace_helper_destroygen(p, generation);
				lck_mtx_unlock(&amp;dtrace_lock);
			}

			<span class="enscript-keyword">return</span> (rval);
		}

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> ENOTTY;
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_ioctl</span>(dev_t dev, u_long cmd, user_addr_t arg, <span class="enscript-type">int</span> md, cred_t *cr, <span class="enscript-type">int</span> *rv)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">md</span>)
	minor_t minor = getminor(dev);
	dtrace_state_t *state;
	<span class="enscript-type">int</span> rval;

	<span class="enscript-comment">/* Darwin puts Helper on its own major device. */</span>

	state = ddi_get_soft_state(dtrace_softstate, minor);

	<span class="enscript-keyword">if</span> (state-&gt;dts_anon) {
	   ASSERT(dtrace_anon.dta_state == NULL);
	   state = state-&gt;dts_anon;
	}

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_PROVIDER</span>: {
		dtrace_providerdesc_t pvd;
		dtrace_provider_t *pvp;

		<span class="enscript-keyword">if</span> (copyin(arg, &amp;pvd, <span class="enscript-keyword">sizeof</span> (pvd)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		pvd.dtvd_name[DTRACE_PROVNAMELEN - 1] = <span class="enscript-string">'\0'</span>;
		lck_mtx_lock(&amp;dtrace_provider_lock);

		<span class="enscript-keyword">for</span> (pvp = dtrace_provider; pvp != NULL; pvp = pvp-&gt;dtpv_next) {
			<span class="enscript-keyword">if</span> (strncmp(pvp-&gt;dtpv_name, pvd.dtvd_name, DTRACE_PROVNAMELEN) == 0)
				<span class="enscript-keyword">break</span>;
		}

		lck_mtx_unlock(&amp;dtrace_provider_lock);

		<span class="enscript-keyword">if</span> (pvp == NULL)
			<span class="enscript-keyword">return</span> (ESRCH);

		bcopy(&amp;pvp-&gt;dtpv_priv, &amp;pvd.dtvd_priv, <span class="enscript-keyword">sizeof</span> (dtrace_ppriv_t));
		bcopy(&amp;pvp-&gt;dtpv_attr, &amp;pvd.dtvd_attr, <span class="enscript-keyword">sizeof</span> (dtrace_pattr_t));
		<span class="enscript-keyword">if</span> (copyout(&amp;pvd, arg, <span class="enscript-keyword">sizeof</span> (pvd)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_EPROBE</span>: {
		dtrace_eprobedesc_t epdesc;
		dtrace_ecb_t *ecb;
		dtrace_action_t *act;
		<span class="enscript-type">void</span> *buf;
		size_t size;
		uintptr_t dest;
		<span class="enscript-type">int</span> nrecs;

		<span class="enscript-keyword">if</span> (copyin(arg, &amp;epdesc, <span class="enscript-keyword">sizeof</span> (epdesc)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		lck_mtx_lock(&amp;dtrace_lock);

		<span class="enscript-keyword">if</span> ((ecb = dtrace_epid2ecb(state, epdesc.dtepd_epid)) == NULL) {
			lck_mtx_unlock(&amp;dtrace_lock);
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		<span class="enscript-keyword">if</span> (ecb-&gt;dte_probe == NULL) {
			lck_mtx_unlock(&amp;dtrace_lock);
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		epdesc.dtepd_probeid = ecb-&gt;dte_probe-&gt;dtpr_id;
		epdesc.dtepd_uarg = ecb-&gt;dte_uarg;
		epdesc.dtepd_size = ecb-&gt;dte_size;

		nrecs = epdesc.dtepd_nrecs;
		epdesc.dtepd_nrecs = 0;
		<span class="enscript-keyword">for</span> (act = ecb-&gt;dte_action; act != NULL; act = act-&gt;dta_next) {
			<span class="enscript-keyword">if</span> (DTRACEACT_ISAGG(act-&gt;dta_kind) || act-&gt;dta_intuple)
				<span class="enscript-keyword">continue</span>;

			epdesc.dtepd_nrecs++;
		}

		<span class="enscript-comment">/*
		 * Now that we have the size, we need to allocate a temporary
		 * buffer in which to store the complete description.  We need
		 * the temporary buffer to be able to drop dtrace_lock()
		 * across the copyout(), below.
		 */</span>
		size = <span class="enscript-keyword">sizeof</span> (dtrace_eprobedesc_t) +
			(epdesc.dtepd_nrecs * <span class="enscript-keyword">sizeof</span> (dtrace_recdesc_t));

		buf = kmem_alloc(size, KM_SLEEP);
		dest = (uintptr_t)buf;

		bcopy(&amp;epdesc, (<span class="enscript-type">void</span> *)dest, <span class="enscript-keyword">sizeof</span> (epdesc));
		dest += offsetof(dtrace_eprobedesc_t, dtepd_rec[0]);

		<span class="enscript-keyword">for</span> (act = ecb-&gt;dte_action; act != NULL; act = act-&gt;dta_next) {
			<span class="enscript-keyword">if</span> (DTRACEACT_ISAGG(act-&gt;dta_kind) || act-&gt;dta_intuple)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (nrecs-- == 0)
				<span class="enscript-keyword">break</span>;

			bcopy(&amp;act-&gt;dta_rec, (<span class="enscript-type">void</span> *)dest,
			<span class="enscript-keyword">sizeof</span> (dtrace_recdesc_t));
			dest += <span class="enscript-keyword">sizeof</span> (dtrace_recdesc_t);
		}

		lck_mtx_unlock(&amp;dtrace_lock);

		<span class="enscript-keyword">if</span> (copyout(buf, arg, dest - (uintptr_t)buf) != 0) {
			kmem_free(buf, size);
			<span class="enscript-keyword">return</span> (EFAULT);
		}

		kmem_free(buf, size);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_AGGDESC</span>: {
		dtrace_aggdesc_t aggdesc;
		dtrace_action_t *act;
		dtrace_aggregation_t *agg;
		<span class="enscript-type">int</span> nrecs;
		uint32_t offs;
		dtrace_recdesc_t *lrec;
		<span class="enscript-type">void</span> *buf;
		size_t size;
		uintptr_t dest;

		<span class="enscript-keyword">if</span> (copyin(arg, &amp;aggdesc, <span class="enscript-keyword">sizeof</span> (aggdesc)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		lck_mtx_lock(&amp;dtrace_lock);

		<span class="enscript-keyword">if</span> ((agg = dtrace_aggid2agg(state, aggdesc.dtagd_id)) == NULL) {
			lck_mtx_unlock(&amp;dtrace_lock);
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		aggdesc.dtagd_epid = agg-&gt;dtag_ecb-&gt;dte_epid;

		nrecs = aggdesc.dtagd_nrecs;
		aggdesc.dtagd_nrecs = 0;

		offs = agg-&gt;dtag_base;
		lrec = &amp;agg-&gt;dtag_action.dta_rec;
		aggdesc.dtagd_size = lrec-&gt;dtrd_offset + lrec-&gt;dtrd_size - offs;

		<span class="enscript-keyword">for</span> (act = agg-&gt;dtag_first; ; act = act-&gt;dta_next) {
			ASSERT(act-&gt;dta_intuple ||
			DTRACEACT_ISAGG(act-&gt;dta_kind));

			<span class="enscript-comment">/*
			 * If this action has a record size of zero, it
			 * denotes an argument to the aggregating action.
			 * Because the presence of this record doesn't (or
			 * shouldn't) affect the way the data is interpreted,
			 * we don't copy it out to save user-level the
			 * confusion of dealing with a zero-length record.
			 */</span>
			<span class="enscript-keyword">if</span> (act-&gt;dta_rec.dtrd_size == 0) {
				ASSERT(agg-&gt;dtag_hasarg);
				<span class="enscript-keyword">continue</span>;
			}

			aggdesc.dtagd_nrecs++;

			<span class="enscript-keyword">if</span> (act == &amp;agg-&gt;dtag_action)
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * Now that we have the size, we need to allocate a temporary
		 * buffer in which to store the complete description.  We need
		 * the temporary buffer to be able to drop dtrace_lock()
		 * across the copyout(), below.
		 */</span>
		size = <span class="enscript-keyword">sizeof</span> (dtrace_aggdesc_t) +
			(aggdesc.dtagd_nrecs * <span class="enscript-keyword">sizeof</span> (dtrace_recdesc_t));

		buf = kmem_alloc(size, KM_SLEEP);
		dest = (uintptr_t)buf;

		bcopy(&amp;aggdesc, (<span class="enscript-type">void</span> *)dest, <span class="enscript-keyword">sizeof</span> (aggdesc));
		dest += offsetof(dtrace_aggdesc_t, dtagd_rec[0]);

		<span class="enscript-keyword">for</span> (act = agg-&gt;dtag_first; ; act = act-&gt;dta_next) {
			dtrace_recdesc_t rec = act-&gt;dta_rec;

			<span class="enscript-comment">/*
			 * See the comment in the above loop for why we pass
			 * over zero-length records.
			 */</span>
			<span class="enscript-keyword">if</span> (rec.dtrd_size == 0) {
				ASSERT(agg-&gt;dtag_hasarg);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">if</span> (nrecs-- == 0)
				<span class="enscript-keyword">break</span>;

			rec.dtrd_offset -= offs;
			bcopy(&amp;rec, (<span class="enscript-type">void</span> *)dest, <span class="enscript-keyword">sizeof</span> (rec));
			dest += <span class="enscript-keyword">sizeof</span> (dtrace_recdesc_t);

			<span class="enscript-keyword">if</span> (act == &amp;agg-&gt;dtag_action)
				<span class="enscript-keyword">break</span>;
		}

		lck_mtx_unlock(&amp;dtrace_lock);

		<span class="enscript-keyword">if</span> (copyout(buf, arg, dest - (uintptr_t)buf) != 0) {
			kmem_free(buf, size);
			<span class="enscript-keyword">return</span> (EFAULT);
		}

		kmem_free(buf, size);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_ENABLE</span>: {
		dof_hdr_t *dof;
		dtrace_enabling_t *enab = NULL;
		dtrace_vstate_t *vstate;
		<span class="enscript-type">int</span> err = 0;

		*rv = 0;

		<span class="enscript-comment">/*
		 * If a NULL argument has been passed, we take this as our
		 * cue to reevaluate our enablings.
		 */</span>
		<span class="enscript-keyword">if</span> (arg == 0) {
			dtrace_enabling_matchall();

			<span class="enscript-keyword">return</span> (0);
		}

		<span class="enscript-keyword">if</span> ((dof = dtrace_dof_copyin(arg, &amp;rval)) == NULL)
			<span class="enscript-keyword">return</span> (rval);

		lck_mtx_lock(&amp;cpu_lock);
		lck_mtx_lock(&amp;dtrace_lock);
		vstate = &amp;state-&gt;dts_vstate;

		<span class="enscript-keyword">if</span> (state-&gt;dts_activity != DTRACE_ACTIVITY_INACTIVE) {
			lck_mtx_unlock(&amp;dtrace_lock);
			lck_mtx_unlock(&amp;cpu_lock);
			dtrace_dof_destroy(dof);
			<span class="enscript-keyword">return</span> (EBUSY);
		}

		<span class="enscript-keyword">if</span> (dtrace_dof_slurp(dof, vstate, cr, &amp;enab, 0, B_TRUE) != 0) {
			lck_mtx_unlock(&amp;dtrace_lock);
			lck_mtx_unlock(&amp;cpu_lock);
			dtrace_dof_destroy(dof);
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		<span class="enscript-keyword">if</span> ((rval = dtrace_dof_options(dof, state)) != 0) {
			dtrace_enabling_destroy(enab);
			lck_mtx_unlock(&amp;dtrace_lock);
			lck_mtx_unlock(&amp;cpu_lock);
			dtrace_dof_destroy(dof);
			<span class="enscript-keyword">return</span> (rval);
		}

		<span class="enscript-keyword">if</span> ((err = dtrace_enabling_match(enab, rv)) == 0) {
			err = dtrace_enabling_retain(enab);
		} <span class="enscript-keyword">else</span> {
			dtrace_enabling_destroy(enab);
		}

		lck_mtx_unlock(&amp;dtrace_lock);
		lck_mtx_unlock(&amp;cpu_lock);
		dtrace_dof_destroy(dof);

		<span class="enscript-keyword">return</span> (err);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_REPLICATE</span>: {
		dtrace_repldesc_t desc;
		dtrace_probedesc_t *match = &amp;desc.dtrpd_match;
		dtrace_probedesc_t *create = &amp;desc.dtrpd_create;
		<span class="enscript-type">int</span> err;

		<span class="enscript-keyword">if</span> (copyin(arg, &amp;desc, <span class="enscript-keyword">sizeof</span> (desc)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		match-&gt;dtpd_provider[DTRACE_PROVNAMELEN - 1] = <span class="enscript-string">'\0'</span>;
		match-&gt;dtpd_mod[DTRACE_MODNAMELEN - 1] = <span class="enscript-string">'\0'</span>;
		match-&gt;dtpd_func[DTRACE_FUNCNAMELEN - 1] = <span class="enscript-string">'\0'</span>;
		match-&gt;dtpd_name[DTRACE_NAMELEN - 1] = <span class="enscript-string">'\0'</span>;

		create-&gt;dtpd_provider[DTRACE_PROVNAMELEN - 1] = <span class="enscript-string">'\0'</span>;
		create-&gt;dtpd_mod[DTRACE_MODNAMELEN - 1] = <span class="enscript-string">'\0'</span>;
		create-&gt;dtpd_func[DTRACE_FUNCNAMELEN - 1] = <span class="enscript-string">'\0'</span>;
		create-&gt;dtpd_name[DTRACE_NAMELEN - 1] = <span class="enscript-string">'\0'</span>;

		lck_mtx_lock(&amp;dtrace_lock);
		err = dtrace_enabling_replicate(state, match, create);
		lck_mtx_unlock(&amp;dtrace_lock);

		<span class="enscript-keyword">return</span> (err);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_PROBEMATCH</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_PROBES</span>: {
		dtrace_probe_t *probe = NULL;
		dtrace_probedesc_t desc;
		dtrace_probekey_t pkey;
		dtrace_id_t i;
		<span class="enscript-type">int</span> m = 0;
		uint32_t priv;
		uid_t uid;
		zoneid_t zoneid;

		<span class="enscript-keyword">if</span> (copyin(arg, &amp;desc, <span class="enscript-keyword">sizeof</span> (desc)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		desc.dtpd_provider[DTRACE_PROVNAMELEN - 1] = <span class="enscript-string">'\0'</span>;
		desc.dtpd_mod[DTRACE_MODNAMELEN - 1] = <span class="enscript-string">'\0'</span>;
		desc.dtpd_func[DTRACE_FUNCNAMELEN - 1] = <span class="enscript-string">'\0'</span>;
		desc.dtpd_name[DTRACE_NAMELEN - 1] = <span class="enscript-string">'\0'</span>;

		<span class="enscript-comment">/*
		 * Before we attempt to match this probe, we want to give
		 * all providers the opportunity to provide it.
		 */</span>
		<span class="enscript-keyword">if</span> (desc.dtpd_id == DTRACE_IDNONE) {
			lck_mtx_lock(&amp;dtrace_provider_lock);
			dtrace_probe_provide(&amp;desc, NULL);
			lck_mtx_unlock(&amp;dtrace_provider_lock);
			desc.dtpd_id++;
		}

		<span class="enscript-keyword">if</span> (cmd == DTRACEIOC_PROBEMATCH)  {
			dtrace_probekey(&amp;desc, &amp;pkey);
			pkey.dtpk_id = DTRACE_IDNONE;
		}

		dtrace_cred2priv(cr, &amp;priv, &amp;uid, &amp;zoneid);

		lck_mtx_lock(&amp;dtrace_lock);

		<span class="enscript-keyword">if</span> (cmd == DTRACEIOC_PROBEMATCH) {
                        <span class="enscript-comment">/* Quiet compiler warning */</span>
			<span class="enscript-keyword">for</span> (i = desc.dtpd_id; i &lt;= (dtrace_id_t)dtrace_nprobes; i++) {
				<span class="enscript-keyword">if</span> ((probe = dtrace_probes[i - 1]) != NULL &amp;&amp;
					(m = dtrace_match_probe(probe, &amp;pkey,
					priv, uid, zoneid)) != 0)
					<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (m &lt; 0) {
				lck_mtx_unlock(&amp;dtrace_lock);
				<span class="enscript-keyword">return</span> (EINVAL);
			}

		} <span class="enscript-keyword">else</span> {
                        <span class="enscript-comment">/* Quiet compiler warning */</span>
			<span class="enscript-keyword">for</span> (i = desc.dtpd_id; i &lt;= (dtrace_id_t)dtrace_nprobes; i++) {
				<span class="enscript-keyword">if</span> ((probe = dtrace_probes[i - 1]) != NULL &amp;&amp;
					dtrace_match_priv(probe, priv, uid, zoneid))
					<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> (probe == NULL) {
			lck_mtx_unlock(&amp;dtrace_lock);
			<span class="enscript-keyword">return</span> (ESRCH);
		}

		dtrace_probe_description(probe, &amp;desc);
		lck_mtx_unlock(&amp;dtrace_lock);

		<span class="enscript-keyword">if</span> (copyout(&amp;desc, arg, <span class="enscript-keyword">sizeof</span> (desc)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_PROBEARG</span>: {
		dtrace_argdesc_t desc;
		dtrace_probe_t *probe;
		dtrace_provider_t *prov;

		<span class="enscript-keyword">if</span> (copyin(arg, &amp;desc, <span class="enscript-keyword">sizeof</span> (desc)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		<span class="enscript-keyword">if</span> (desc.dtargd_id == DTRACE_IDNONE)
			<span class="enscript-keyword">return</span> (EINVAL);

		<span class="enscript-keyword">if</span> (desc.dtargd_ndx == DTRACE_ARGNONE)
			<span class="enscript-keyword">return</span> (EINVAL);

		lck_mtx_lock(&amp;dtrace_provider_lock);
		lck_mtx_lock(&amp;mod_lock);
		lck_mtx_lock(&amp;dtrace_lock);

                <span class="enscript-comment">/* Quiet compiler warning */</span>
		<span class="enscript-keyword">if</span> (desc.dtargd_id &gt; (dtrace_id_t)dtrace_nprobes) {
			lck_mtx_unlock(&amp;dtrace_lock);
			lck_mtx_unlock(&amp;mod_lock);
			lck_mtx_unlock(&amp;dtrace_provider_lock);
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		<span class="enscript-keyword">if</span> ((probe = dtrace_probes[desc.dtargd_id - 1]) == NULL) {
			lck_mtx_unlock(&amp;dtrace_lock);
			lck_mtx_unlock(&amp;mod_lock);
			lck_mtx_unlock(&amp;dtrace_provider_lock);
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		lck_mtx_unlock(&amp;dtrace_lock);

		prov = probe-&gt;dtpr_provider;

		<span class="enscript-keyword">if</span> (prov-&gt;dtpv_pops.dtps_getargdesc == NULL) {
		<span class="enscript-comment">/*
		 * There isn't any typed information for this probe.
		 * Set the argument number to DTRACE_ARGNONE.
		 */</span>
			desc.dtargd_ndx = DTRACE_ARGNONE;
		} <span class="enscript-keyword">else</span> {
			desc.dtargd_native[0] = <span class="enscript-string">'\0'</span>;
			desc.dtargd_xlate[0] = <span class="enscript-string">'\0'</span>;
			desc.dtargd_mapping = desc.dtargd_ndx;

			prov-&gt;dtpv_pops.dtps_getargdesc(prov-&gt;dtpv_arg,
			probe-&gt;dtpr_id, probe-&gt;dtpr_arg, &amp;desc);
		}

		lck_mtx_unlock(&amp;mod_lock);
		lck_mtx_unlock(&amp;dtrace_provider_lock);

		<span class="enscript-keyword">if</span> (copyout(&amp;desc, arg, <span class="enscript-keyword">sizeof</span> (desc)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_GO</span>: {
		processorid_t cpuid;
		rval = dtrace_state_go(state, &amp;cpuid);

		<span class="enscript-keyword">if</span> (rval != 0)
			<span class="enscript-keyword">return</span> (rval);

		<span class="enscript-keyword">if</span> (copyout(&amp;cpuid, arg, <span class="enscript-keyword">sizeof</span> (cpuid)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_STOP</span>: {
		processorid_t cpuid;

		lck_mtx_lock(&amp;dtrace_lock);
		rval = dtrace_state_stop(state, &amp;cpuid);
		lck_mtx_unlock(&amp;dtrace_lock);

		<span class="enscript-keyword">if</span> (rval != 0)
			<span class="enscript-keyword">return</span> (rval);

		<span class="enscript-keyword">if</span> (copyout(&amp;cpuid, arg, <span class="enscript-keyword">sizeof</span> (cpuid)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_DOFGET</span>: {
		dof_hdr_t hdr, *dof;
		uint64_t len;

		<span class="enscript-keyword">if</span> (copyin(arg, &amp;hdr, <span class="enscript-keyword">sizeof</span> (hdr)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		lck_mtx_lock(&amp;dtrace_lock);
		dof = dtrace_dof_create(state);
		lck_mtx_unlock(&amp;dtrace_lock);

		len = MIN(hdr.dofh_loadsz, dof-&gt;dofh_loadsz);
		rval = copyout(dof, arg, len);
		dtrace_dof_destroy(dof);

		<span class="enscript-keyword">return</span> (rval == 0 ? 0 : EFAULT);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_AGGSNAP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_BUFSNAP</span>: {
		dtrace_bufdesc_t desc;
		caddr_t cached;
		dtrace_buffer_t *buf;

		<span class="enscript-keyword">if</span> (copyin(arg, &amp;desc, <span class="enscript-keyword">sizeof</span> (desc)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		<span class="enscript-keyword">if</span> ((<span class="enscript-type">int</span>)desc.dtbd_cpu &lt; 0 || desc.dtbd_cpu &gt;= NCPU)
			<span class="enscript-keyword">return</span> (EINVAL);

		lck_mtx_lock(&amp;dtrace_lock);

		<span class="enscript-keyword">if</span> (cmd == DTRACEIOC_BUFSNAP) {
			buf = &amp;state-&gt;dts_buffer[desc.dtbd_cpu];
		} <span class="enscript-keyword">else</span> {
			buf = &amp;state-&gt;dts_aggbuffer[desc.dtbd_cpu];
		}

		<span class="enscript-keyword">if</span> (buf-&gt;dtb_flags &amp; (DTRACEBUF_RING | DTRACEBUF_FILL)) {
			size_t sz = buf-&gt;dtb_offset;

			<span class="enscript-keyword">if</span> (state-&gt;dts_activity != DTRACE_ACTIVITY_STOPPED) {
				lck_mtx_unlock(&amp;dtrace_lock);
				<span class="enscript-keyword">return</span> (EBUSY);
			}

			<span class="enscript-comment">/*
			 * If this buffer has already been consumed, we're
			 * going to indicate that there's nothing left here
			 * to consume.
			 */</span>
			<span class="enscript-keyword">if</span> (buf-&gt;dtb_flags &amp; DTRACEBUF_CONSUMED) {
				lck_mtx_unlock(&amp;dtrace_lock);

				desc.dtbd_size = 0;
				desc.dtbd_drops = 0;
				desc.dtbd_errors = 0;
				desc.dtbd_oldest = 0;
				sz = <span class="enscript-keyword">sizeof</span> (desc);

				<span class="enscript-keyword">if</span> (copyout(&amp;desc, arg, sz) != 0)
					<span class="enscript-keyword">return</span> (EFAULT);

				<span class="enscript-keyword">return</span> (0);
			}

			<span class="enscript-comment">/*
			 * If this is a ring buffer that has wrapped, we want
			 * to copy the whole thing out.
			 */</span>
			<span class="enscript-keyword">if</span> (buf-&gt;dtb_flags &amp; DTRACEBUF_WRAPPED) {
				dtrace_buffer_polish(buf);
				sz = buf-&gt;dtb_size;
			}

			<span class="enscript-keyword">if</span> (copyout(buf-&gt;dtb_tomax, (user_addr_t)desc.dtbd_data, sz) != 0) {
				lck_mtx_unlock(&amp;dtrace_lock);
				<span class="enscript-keyword">return</span> (EFAULT);
			}

			desc.dtbd_size = sz;
			desc.dtbd_drops = buf-&gt;dtb_drops;
			desc.dtbd_errors = buf-&gt;dtb_errors;
			desc.dtbd_oldest = buf-&gt;dtb_xamot_offset;
			desc.dtbd_timestamp = dtrace_gethrtime();

			lck_mtx_unlock(&amp;dtrace_lock);

			<span class="enscript-keyword">if</span> (copyout(&amp;desc, arg, <span class="enscript-keyword">sizeof</span> (desc)) != 0)
				<span class="enscript-keyword">return</span> (EFAULT);

			buf-&gt;dtb_flags |= DTRACEBUF_CONSUMED;

			<span class="enscript-keyword">return</span> (0);
		}

		<span class="enscript-keyword">if</span> (buf-&gt;dtb_tomax == NULL) {
			ASSERT(buf-&gt;dtb_xamot == NULL);
			lck_mtx_unlock(&amp;dtrace_lock);
			<span class="enscript-keyword">return</span> (ENOENT);
		}

		cached = buf-&gt;dtb_tomax;
		ASSERT(!(buf-&gt;dtb_flags &amp; DTRACEBUF_NOSWITCH));

		dtrace_xcall(desc.dtbd_cpu,
			(dtrace_xcall_t)dtrace_buffer_switch, buf);

		state-&gt;dts_errors += buf-&gt;dtb_xamot_errors;

		<span class="enscript-comment">/*
		* If the buffers did not actually switch, then the cross call
		* did not take place -- presumably because the given CPU is
		* not in the ready set.  If this is the case, we'll return
		* ENOENT.
		*/</span>
		<span class="enscript-keyword">if</span> (buf-&gt;dtb_tomax == cached) {
			ASSERT(buf-&gt;dtb_xamot != cached);
			lck_mtx_unlock(&amp;dtrace_lock);
			<span class="enscript-keyword">return</span> (ENOENT);
		}

		ASSERT(cached == buf-&gt;dtb_xamot);

		<span class="enscript-comment">/*
		* We have our snapshot; now copy it out.
		*/</span>
		<span class="enscript-keyword">if</span> (copyout(buf-&gt;dtb_xamot, (user_addr_t)desc.dtbd_data,
					buf-&gt;dtb_xamot_offset) != 0) {
			lck_mtx_unlock(&amp;dtrace_lock);
			<span class="enscript-keyword">return</span> (EFAULT);
		}

		desc.dtbd_size = buf-&gt;dtb_xamot_offset;
		desc.dtbd_drops = buf-&gt;dtb_xamot_drops;
		desc.dtbd_errors = buf-&gt;dtb_xamot_errors;
		desc.dtbd_oldest = 0;
		desc.dtbd_timestamp = buf-&gt;dtb_switched;

		lck_mtx_unlock(&amp;dtrace_lock);

		<span class="enscript-comment">/*
		 * Finally, copy out the buffer description.
		 */</span>
		<span class="enscript-keyword">if</span> (copyout(&amp;desc, arg, <span class="enscript-keyword">sizeof</span> (desc)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_CONF</span>: {
		dtrace_conf_t conf;

		bzero(&amp;conf, <span class="enscript-keyword">sizeof</span> (conf));
		conf.dtc_difversion = DIF_VERSION;
		conf.dtc_difintregs = DIF_DIR_NREGS;
		conf.dtc_diftupregs = DIF_DTR_NREGS;
		conf.dtc_ctfmodel = CTF_MODEL_NATIVE;

		<span class="enscript-keyword">if</span> (copyout(&amp;conf, arg, <span class="enscript-keyword">sizeof</span> (conf)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_STATUS</span>: {
		dtrace_status_t stat;
		dtrace_dstate_t *dstate;
		<span class="enscript-type">int</span> i, j;
		uint64_t nerrs;

		<span class="enscript-comment">/*
		* See the comment in dtrace_state_deadman() for the reason
		* for setting dts_laststatus to INT64_MAX before setting
		* it to the correct value.
		*/</span>
		state-&gt;dts_laststatus = INT64_MAX;
		dtrace_membar_producer();
		state-&gt;dts_laststatus = dtrace_gethrtime();

		bzero(&amp;stat, <span class="enscript-keyword">sizeof</span> (stat));

		lck_mtx_lock(&amp;dtrace_lock);

		<span class="enscript-keyword">if</span> (state-&gt;dts_activity == DTRACE_ACTIVITY_INACTIVE) {
			lck_mtx_unlock(&amp;dtrace_lock);
			<span class="enscript-keyword">return</span> (ENOENT);
		}

		<span class="enscript-keyword">if</span> (state-&gt;dts_activity == DTRACE_ACTIVITY_DRAINING)
			stat.dtst_exiting = 1;

		nerrs = state-&gt;dts_errors;
		dstate = &amp;state-&gt;dts_vstate.dtvs_dynvars;

		<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)NCPU; i++) {
			dtrace_dstate_percpu_t *dcpu = &amp;dstate-&gt;dtds_percpu[i];

			stat.dtst_dyndrops += dcpu-&gt;dtdsc_drops;
			stat.dtst_dyndrops_dirty += dcpu-&gt;dtdsc_dirty_drops;
			stat.dtst_dyndrops_rinsing += dcpu-&gt;dtdsc_rinsing_drops;

			<span class="enscript-keyword">if</span> (state-&gt;dts_buffer[i].dtb_flags &amp; DTRACEBUF_FULL)
				stat.dtst_filled++;

			nerrs += state-&gt;dts_buffer[i].dtb_errors;

			<span class="enscript-keyword">for</span> (j = 0; j &lt; state-&gt;dts_nspeculations; j++) {
				dtrace_speculation_t *spec;
				dtrace_buffer_t *buf;

				spec = &amp;state-&gt;dts_speculations[j];
				buf = &amp;spec-&gt;dtsp_buffer[i];
				stat.dtst_specdrops += buf-&gt;dtb_xamot_drops;
			}
		}

		stat.dtst_specdrops_busy = state-&gt;dts_speculations_busy;
		stat.dtst_specdrops_unavail = state-&gt;dts_speculations_unavail;
		stat.dtst_stkstroverflows = state-&gt;dts_stkstroverflows;
		stat.dtst_dblerrors = state-&gt;dts_dblerrors;
		stat.dtst_killed =
			(state-&gt;dts_activity == DTRACE_ACTIVITY_KILLED);
		stat.dtst_errors = nerrs;

		lck_mtx_unlock(&amp;dtrace_lock);

		<span class="enscript-keyword">if</span> (copyout(&amp;stat, arg, <span class="enscript-keyword">sizeof</span> (stat)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_FORMAT</span>: {
		dtrace_fmtdesc_t fmt;
		<span class="enscript-type">char</span> *str;
		<span class="enscript-type">int</span> len;

		<span class="enscript-keyword">if</span> (copyin(arg, &amp;fmt, <span class="enscript-keyword">sizeof</span> (fmt)) != 0)
			<span class="enscript-keyword">return</span> (EFAULT);

		lck_mtx_lock(&amp;dtrace_lock);

		<span class="enscript-keyword">if</span> (fmt.dtfd_format == 0 ||
			fmt.dtfd_format &gt; state-&gt;dts_nformats) {
			lck_mtx_unlock(&amp;dtrace_lock);
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		<span class="enscript-comment">/*
		 * Format strings are allocated contiguously and they are
		 * never freed; if a format index is less than the number
		 * of formats, we can assert that the format map is non-NULL
		 * and that the format for the specified index is non-NULL.
		 */</span>
		ASSERT(state-&gt;dts_formats != NULL);
		str = state-&gt;dts_formats[fmt.dtfd_format - 1];
		ASSERT(str != NULL);

		len = strlen(str) + 1;

		<span class="enscript-keyword">if</span> (len &gt; fmt.dtfd_length) {
			fmt.dtfd_length = len;

			<span class="enscript-keyword">if</span> (copyout(&amp;fmt, arg, <span class="enscript-keyword">sizeof</span> (fmt)) != 0) {
				lck_mtx_unlock(&amp;dtrace_lock);
				<span class="enscript-keyword">return</span> (EINVAL);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (copyout(str, (user_addr_t)fmt.dtfd_string, len) != 0) {
				lck_mtx_unlock(&amp;dtrace_lock);
				<span class="enscript-keyword">return</span> (EINVAL);
			}
		}

		lck_mtx_unlock(&amp;dtrace_lock);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_MODUUIDSLIST</span>: {
		size_t module_uuids_list_size;
		dtrace_module_uuids_list_t* uuids_list;
		uint64_t dtmul_count;

		<span class="enscript-comment">/*
		 * Security restrictions make this operation illegal, if this is enabled DTrace
		 * must refuse to provide any fbt probes.
		 */</span>
		<span class="enscript-keyword">if</span> (dtrace_fbt_probes_restricted()) {
			cmn_err(CE_WARN, <span class="enscript-string">&quot;security restrictions disallow DTRACEIOC_MODUUIDSLIST&quot;</span>);	
			<span class="enscript-keyword">return</span> (EPERM);
		}

		<span class="enscript-comment">/*
		 * Fail if the kernel symbol mode makes this operation illegal.
		 * Both NEVER &amp; ALWAYS_FROM_KERNEL are permanent states, it is legal to check
		 * for them without holding the dtrace_lock.
		 */</span>		
		<span class="enscript-keyword">if</span> (dtrace_kernel_symbol_mode == DTRACE_KERNEL_SYMBOLS_NEVER ||
		    dtrace_kernel_symbol_mode == DTRACE_KERNEL_SYMBOLS_ALWAYS_FROM_KERNEL) {
			cmn_err(CE_WARN, <span class="enscript-string">&quot;dtrace_kernel_symbol_mode of %u disallows DTRACEIOC_MODUUIDSLIST&quot;</span>, dtrace_kernel_symbol_mode);
			<span class="enscript-keyword">return</span> (EPERM);
		}
			
		<span class="enscript-comment">/*
		 * Read the number of symbolsdesc structs being passed in.
		 */</span>
		<span class="enscript-keyword">if</span> (copyin(arg + offsetof(dtrace_module_uuids_list_t, dtmul_count),
			   &amp;dtmul_count,
			   <span class="enscript-keyword">sizeof</span>(dtmul_count))) {
			cmn_err(CE_WARN, <span class="enscript-string">&quot;failed to copyin dtmul_count&quot;</span>);
			<span class="enscript-keyword">return</span> (EFAULT);
		}
		
		<span class="enscript-comment">/*
		 * Range check the count. More than 2k kexts is probably an error.
		 */</span>
		<span class="enscript-keyword">if</span> (dtmul_count &gt; 2048) {
			cmn_err(CE_WARN, <span class="enscript-string">&quot;dtmul_count is not valid&quot;</span>);
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		<span class="enscript-comment">/*
		 * For all queries, we return EINVAL when the user specified
		 * count does not match the actual number of modules we find
		 * available.
		 *
		 * If the user specified count is zero, then this serves as a
		 * simple query to count the available modules in need of symbols.
		 */</span>
		
		rval = 0;

		<span class="enscript-keyword">if</span> (dtmul_count == 0)
		{
			lck_mtx_lock(&amp;mod_lock);
			<span class="enscript-type">struct</span> modctl* ctl = dtrace_modctl_list;
			<span class="enscript-keyword">while</span> (ctl) {
				<span class="enscript-comment">/* Update the private probes bit */</span>
				<span class="enscript-keyword">if</span> (dtrace_provide_private_probes)
					ctl-&gt;mod_flags |= MODCTL_FBT_PROVIDE_PRIVATE_PROBES;

				ASSERT(!MOD_HAS_USERSPACE_SYMBOLS(ctl));
				<span class="enscript-keyword">if</span> (!MOD_SYMBOLS_DONE(ctl)) {
					dtmul_count++;
					rval = EINVAL;
				}
				ctl = ctl-&gt;mod_next;
			}
			lck_mtx_unlock(&amp;mod_lock);
			
			<span class="enscript-keyword">if</span> (copyout(&amp;dtmul_count, arg, <span class="enscript-keyword">sizeof</span> (dtmul_count)) != 0)
				<span class="enscript-keyword">return</span> (EFAULT);
			<span class="enscript-keyword">else</span>
				<span class="enscript-keyword">return</span> (rval);
		}
		
		<span class="enscript-comment">/*
		 * If we reach this point, then we have a request for full list data.
		 * Allocate a correctly sized structure and copyin the data.
		 */</span>
		module_uuids_list_size = DTRACE_MODULE_UUIDS_LIST_SIZE(dtmul_count);
		<span class="enscript-keyword">if</span> ((uuids_list = kmem_alloc(module_uuids_list_size, KM_SLEEP)) == NULL) 
			<span class="enscript-keyword">return</span> (ENOMEM);
		
		<span class="enscript-comment">/* NOTE! We can no longer exit this method via return */</span>
		<span class="enscript-keyword">if</span> (copyin(arg, uuids_list, module_uuids_list_size) != 0) {
			cmn_err(CE_WARN, <span class="enscript-string">&quot;failed copyin of dtrace_module_uuids_list_t&quot;</span>);
			rval = EFAULT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">moduuidslist_cleanup</span>;
		}
		
		<span class="enscript-comment">/*
		 * Check that the count didn't change between the first copyin and the second.
		 */</span>
		<span class="enscript-keyword">if</span> (uuids_list-&gt;dtmul_count != dtmul_count) {
			rval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">moduuidslist_cleanup</span>;
		}
		
		<span class="enscript-comment">/*
		 * Build the list of UUID's that need symbols
		 */</span>
		lck_mtx_lock(&amp;mod_lock);
		
		dtmul_count = 0;
		
		<span class="enscript-type">struct</span> modctl* ctl = dtrace_modctl_list;
		<span class="enscript-keyword">while</span> (ctl) {
			<span class="enscript-comment">/* Update the private probes bit */</span>
			<span class="enscript-keyword">if</span> (dtrace_provide_private_probes)
				ctl-&gt;mod_flags |= MODCTL_FBT_PROVIDE_PRIVATE_PROBES;

			<span class="enscript-comment">/*
			 * We assume that userspace symbols will be &quot;better&quot; than kernel level symbols,
			 * as userspace can search for dSYM(s) and symbol'd binaries. Even if kernel syms
			 * are available, add user syms if the module might use them.
			 */</span>
			ASSERT(!MOD_HAS_USERSPACE_SYMBOLS(ctl));
			<span class="enscript-keyword">if</span> (!MOD_SYMBOLS_DONE(ctl)) {
				UUID* uuid = &amp;uuids_list-&gt;dtmul_uuid[dtmul_count];
				<span class="enscript-keyword">if</span> (dtmul_count++ &lt; uuids_list-&gt;dtmul_count) {
					memcpy(uuid, ctl-&gt;mod_uuid, <span class="enscript-keyword">sizeof</span>(UUID));
				}
			}
			ctl = ctl-&gt;mod_next;
		}
		
		lck_mtx_unlock(&amp;mod_lock);
		
		<span class="enscript-keyword">if</span> (uuids_list-&gt;dtmul_count &lt; dtmul_count)
			rval = EINVAL;
		
		uuids_list-&gt;dtmul_count = dtmul_count;
		
		<span class="enscript-comment">/*
		 * Copyout the symbols list (or at least the count!)
		 */</span>
		<span class="enscript-keyword">if</span> (copyout(uuids_list, arg, module_uuids_list_size) != 0) {
			cmn_err(CE_WARN, <span class="enscript-string">&quot;failed copyout of dtrace_symbolsdesc_list_t&quot;</span>);
			rval = EFAULT;
		}
		
	<span class="enscript-reference">moduuidslist_cleanup</span>:
		<span class="enscript-comment">/*
		 * If we had to allocate struct memory, free it.
		 */</span>
		<span class="enscript-keyword">if</span> (uuids_list != NULL) {
			kmem_free(uuids_list, module_uuids_list_size);
		}
		
		<span class="enscript-keyword">return</span> rval;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_PROVMODSYMS</span>: {
		size_t module_symbols_size;
		dtrace_module_symbols_t* module_symbols;
		uint64_t dtmodsyms_count;

		<span class="enscript-comment">/*
		 * Security restrictions make this operation illegal, if this is enabled DTrace
		 * must refuse to provide any fbt probes.
		 */</span>
		<span class="enscript-keyword">if</span> (dtrace_fbt_probes_restricted()) {
			cmn_err(CE_WARN, <span class="enscript-string">&quot;security restrictions disallow DTRACEIOC_MODUUIDSLIST&quot;</span>);	
			<span class="enscript-keyword">return</span> (EPERM);
		}

		<span class="enscript-comment">/*
		 * Fail if the kernel symbol mode makes this operation illegal.
		 * Both NEVER &amp; ALWAYS_FROM_KERNEL are permanent states, it is legal to check
		 * for them without holding the dtrace_lock.
		 */</span>
		<span class="enscript-keyword">if</span> (dtrace_kernel_symbol_mode == DTRACE_KERNEL_SYMBOLS_NEVER ||
		    dtrace_kernel_symbol_mode == DTRACE_KERNEL_SYMBOLS_ALWAYS_FROM_KERNEL) {
			cmn_err(CE_WARN, <span class="enscript-string">&quot;dtrace_kernel_symbol_mode of %u disallows DTRACEIOC_PROVMODSYMS&quot;</span>, dtrace_kernel_symbol_mode);
			<span class="enscript-keyword">return</span> (EPERM);
		}
		
		<span class="enscript-comment">/*
		 * Read the number of module symbols structs being passed in.
		 */</span>
		<span class="enscript-keyword">if</span> (copyin(arg + offsetof(dtrace_module_symbols_t, dtmodsyms_count),
			   &amp;dtmodsyms_count,
			   <span class="enscript-keyword">sizeof</span>(dtmodsyms_count))) {
			cmn_err(CE_WARN, <span class="enscript-string">&quot;failed to copyin dtmodsyms_count&quot;</span>);
			<span class="enscript-keyword">return</span> (EFAULT);
		}
		
		<span class="enscript-comment">/*
		 * Range check the count. How much data can we pass around?
		 * FIX ME!
		 */</span>
		<span class="enscript-keyword">if</span> (dtmodsyms_count == 0 || (dtmodsyms_count &gt; 100 * 1024)) {
			cmn_err(CE_WARN, <span class="enscript-string">&quot;dtmodsyms_count is not valid&quot;</span>);
			<span class="enscript-keyword">return</span> (EINVAL);
		}
			
		<span class="enscript-comment">/*
		 * Allocate a correctly sized structure and copyin the data.
		 */</span>
		module_symbols_size = DTRACE_MODULE_SYMBOLS_SIZE(dtmodsyms_count);
		<span class="enscript-keyword">if</span> ((module_symbols = kmem_alloc(module_symbols_size, KM_SLEEP)) == NULL) 
			<span class="enscript-keyword">return</span> (ENOMEM);
			
		rval = 0;

		<span class="enscript-comment">/* NOTE! We can no longer exit this method via return */</span>
		<span class="enscript-keyword">if</span> (copyin(arg, module_symbols, module_symbols_size) != 0) {
			cmn_err(CE_WARN, <span class="enscript-string">&quot;failed copyin of dtrace_module_symbols_t, symbol count %llu&quot;</span>, module_symbols-&gt;dtmodsyms_count);
			rval = EFAULT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">module_symbols_cleanup</span>;
		}
			
		<span class="enscript-comment">/*
		 * Check that the count didn't change between the first copyin and the second.
		 */</span>
		<span class="enscript-keyword">if</span> (module_symbols-&gt;dtmodsyms_count != dtmodsyms_count) {
			rval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">module_symbols_cleanup</span>;
		}
			
		<span class="enscript-comment">/*
		 * Find the modctl to add symbols to.
		 */</span>
		lck_mtx_lock(&amp;dtrace_provider_lock);
		lck_mtx_lock(&amp;mod_lock);
		
		<span class="enscript-type">struct</span> modctl* ctl = dtrace_modctl_list;
		<span class="enscript-keyword">while</span> (ctl) {
			<span class="enscript-comment">/* Update the private probes bit */</span>
			<span class="enscript-keyword">if</span> (dtrace_provide_private_probes)
				ctl-&gt;mod_flags |= MODCTL_FBT_PROVIDE_PRIVATE_PROBES;

			ASSERT(!MOD_HAS_USERSPACE_SYMBOLS(ctl));
			<span class="enscript-keyword">if</span> (MOD_HAS_UUID(ctl) &amp;&amp; !MOD_SYMBOLS_DONE(ctl)) {
				<span class="enscript-keyword">if</span> (memcmp(module_symbols-&gt;dtmodsyms_uuid, ctl-&gt;mod_uuid, <span class="enscript-keyword">sizeof</span>(UUID)) == 0) {
					<span class="enscript-comment">/* BINGO! */</span>
					ctl-&gt;mod_user_symbols = module_symbols;
					<span class="enscript-keyword">break</span>;
				}
			}
			ctl = ctl-&gt;mod_next;
		}

		<span class="enscript-keyword">if</span> (ctl) {
			dtrace_provider_t *prv;

			<span class="enscript-comment">/*
			 * We're going to call each providers per-module provide operation
			 * specifying only this module.
			 */</span>
			<span class="enscript-keyword">for</span> (prv = dtrace_provider; prv != NULL; prv = prv-&gt;dtpv_next)
				prv-&gt;dtpv_pops.dtps_provide_module(prv-&gt;dtpv_arg, ctl);	
						
			<span class="enscript-comment">/*
			 * We gave every provider a chance to provide with the user syms, go ahead and clear them
			 */</span>
			ctl-&gt;mod_user_symbols = NULL; <span class="enscript-comment">/* MUST reset this to clear HAS_USERSPACE_SYMBOLS */</span>
		}
		
		lck_mtx_unlock(&amp;mod_lock);
		lck_mtx_unlock(&amp;dtrace_provider_lock);

	<span class="enscript-reference">module_symbols_cleanup</span>:
		<span class="enscript-comment">/*
		 * If we had to allocate struct memory, free it.
		 */</span>
		<span class="enscript-keyword">if</span> (module_symbols != NULL) {
			kmem_free(module_symbols, module_symbols_size);
		}
		
		<span class="enscript-keyword">return</span> rval;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACEIOC_PROCWAITFOR</span>: {
		dtrace_procdesc_t pdesc = {
			.p_name = {0},
			.p_pid  = -1
		};

		<span class="enscript-keyword">if</span> ((rval = copyin(arg, &amp;pdesc, <span class="enscript-keyword">sizeof</span>(pdesc))) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">proc_waitfor_error</span>;

		<span class="enscript-keyword">if</span> ((rval = dtrace_proc_waitfor(&amp;pdesc)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">proc_waitfor_error</span>;

		<span class="enscript-keyword">if</span> ((rval = copyout(&amp;pdesc, arg, <span class="enscript-keyword">sizeof</span>(pdesc))) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">proc_waitfor_error</span>;

		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-reference">proc_waitfor_error</span>:
		<span class="enscript-comment">/* The process was suspended, revert this since the client will not do it. */</span>
		<span class="enscript-keyword">if</span> (pdesc.p_pid != -1) {
			proc_t *proc = proc_find(pdesc.p_pid);
			<span class="enscript-keyword">if</span> (proc != PROC_NULL) {
				task_pidresume(proc-&gt;task);
				proc_rele(proc);
			}
		}

		<span class="enscript-keyword">return</span> rval;
	}

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (ENOTTY);
}

<span class="enscript-comment">/*
 * APPLE NOTE:  dtrace_detach not implemented
 */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_detach</span>(dev_info_t *dip, ddi_detach_cmd_t cmd)
{
	dtrace_state_t *state;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DDI_DETACH</span>:
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DDI_SUSPEND</span>:
		<span class="enscript-keyword">return</span> (DDI_SUCCESS);

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (DDI_FAILURE);
	}

	lck_mtx_lock(&amp;cpu_lock);
	lck_mtx_lock(&amp;dtrace_provider_lock);
	lck_mtx_lock(&amp;dtrace_lock);

	ASSERT(dtrace_opens == 0);

	<span class="enscript-keyword">if</span> (dtrace_helpers &gt; 0) {
		lck_mtx_unlock(&amp;dtrace_lock);
		lck_mtx_unlock(&amp;dtrace_provider_lock);
		lck_mtx_unlock(&amp;cpu_lock);
		<span class="enscript-keyword">return</span> (DDI_FAILURE);
	}

	<span class="enscript-keyword">if</span> (dtrace_unregister((dtrace_provider_id_t)dtrace_provider) != 0) {
		lck_mtx_unlock(&amp;dtrace_lock);
		lck_mtx_unlock(&amp;dtrace_provider_lock);
		lck_mtx_unlock(&amp;cpu_lock);
		<span class="enscript-keyword">return</span> (DDI_FAILURE);
	}

	dtrace_provider = NULL;

	<span class="enscript-keyword">if</span> ((state = dtrace_anon_grab()) != NULL) {
		<span class="enscript-comment">/*
		 * If there were ECBs on this state, the provider should
		 * have not been allowed to detach; assert that there is
		 * none.
		 */</span>
		ASSERT(state-&gt;dts_necbs == 0);
		dtrace_state_destroy(state);

		<span class="enscript-comment">/*
		 * If we're being detached with anonymous state, we need to
		 * indicate to the kernel debugger that DTrace is now inactive.
		 */</span>
		(<span class="enscript-type">void</span>) kdi_dtrace_set(KDI_DTSET_DTRACE_DEACTIVATE);
	}

	bzero(&amp;dtrace_anon, <span class="enscript-keyword">sizeof</span> (dtrace_anon_t));
	unregister_cpu_setup_func((cpu_setup_func_t *)dtrace_cpu_setup, NULL);
	dtrace_cpu_init = NULL;
	dtrace_helpers_cleanup = NULL;
	dtrace_helpers_fork = NULL;
	dtrace_cpustart_init = NULL;
	dtrace_cpustart_fini = NULL;
	dtrace_debugger_init = NULL;
	dtrace_debugger_fini = NULL;
	dtrace_kreloc_init = NULL;
	dtrace_kreloc_fini = NULL;
	dtrace_modload = NULL;
	dtrace_modunload = NULL;

	lck_mtx_unlock(&amp;cpu_lock);

	<span class="enscript-keyword">if</span> (dtrace_helptrace_enabled) {
		kmem_free(dtrace_helptrace_buffer, dtrace_helptrace_bufsize);
		dtrace_helptrace_buffer = NULL;
	}

	kmem_free(dtrace_probes, dtrace_nprobes * <span class="enscript-keyword">sizeof</span> (dtrace_probe_t *));
	dtrace_probes = NULL;
	dtrace_nprobes = 0;

	dtrace_hash_destroy(dtrace_bymod);
	dtrace_hash_destroy(dtrace_byfunc);
	dtrace_hash_destroy(dtrace_byname);
	dtrace_bymod = NULL;
	dtrace_byfunc = NULL;
	dtrace_byname = NULL;

	kmem_cache_destroy(dtrace_state_cache);
	vmem_destroy(dtrace_minor);
	vmem_destroy(dtrace_arena);

	<span class="enscript-keyword">if</span> (dtrace_toxrange != NULL) {
		kmem_free(dtrace_toxrange,
		    dtrace_toxranges_max * <span class="enscript-keyword">sizeof</span> (dtrace_toxrange_t));
		dtrace_toxrange = NULL;
		dtrace_toxranges = 0;
		dtrace_toxranges_max = 0;
	}

	ddi_remove_minor_node(dtrace_devi, NULL);
	dtrace_devi = NULL;

	ddi_soft_state_fini(&amp;dtrace_softstate);

	ASSERT(dtrace_vtime_references == 0);
	ASSERT(dtrace_opens == 0);
	ASSERT(dtrace_retained == NULL);

	lck_mtx_unlock(&amp;dtrace_lock);
	lck_mtx_unlock(&amp;dtrace_provider_lock);

	<span class="enscript-comment">/*
	 * We don't destroy the task queue until after we have dropped our
	 * locks (taskq_destroy() may block on running tasks).  To prevent
	 * attempting to do work after we have effectively detached but before
	 * the task queue has been destroyed, all tasks dispatched via the
	 * task queue must check that DTrace is still attached before
	 * performing any operation.
	 */</span>
	taskq_destroy(dtrace_taskq);
	dtrace_taskq = NULL;

	<span class="enscript-keyword">return</span> (DDI_SUCCESS);
}
#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* __APPLE__ */</span>

d_open_t _dtrace_open, helper_open;
d_close_t _dtrace_close, helper_close;
d_ioctl_t _dtrace_ioctl, helper_ioctl;

<span class="enscript-type">int</span> 
<span class="enscript-function-name">_dtrace_open</span>(dev_t dev, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> devtype, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	dev_t locdev = dev;

	<span class="enscript-keyword">return</span>  dtrace_open( &amp;locdev, flags, devtype, CRED());
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">helper_open</span>(dev_t dev, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> devtype, <span class="enscript-type">struct</span> proc *p)
{	
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dev</span>,<span class="enscript-variable-name">flags</span>,<span class="enscript-variable-name">devtype</span>,<span class="enscript-variable-name">p</span>)
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">_dtrace_close</span>(dev_t dev, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> devtype, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	<span class="enscript-keyword">return</span> dtrace_close( dev, flags, devtype, CRED());
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">helper_close</span>(dev_t dev, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> devtype, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dev</span>,<span class="enscript-variable-name">flags</span>,<span class="enscript-variable-name">devtype</span>,<span class="enscript-variable-name">p</span>)
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">_dtrace_ioctl</span>(dev_t dev, u_long cmd, caddr_t data, <span class="enscript-type">int</span> fflag, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	<span class="enscript-type">int</span> err, rv = 0;
    user_addr_t uaddrp;

    <span class="enscript-keyword">if</span> (proc_is64bit(p))
		uaddrp = *(user_addr_t *)data;
	<span class="enscript-keyword">else</span>
		uaddrp = (user_addr_t) *(uint32_t *)data;

	err = dtrace_ioctl(dev, cmd, uaddrp, fflag, CRED(), &amp;rv);
	
	<span class="enscript-comment">/* Darwin's BSD ioctls only return -1 or zero. Overload errno to mimic Solaris. 20 bits suffice. */</span>
	<span class="enscript-keyword">if</span> (err != 0) {
		ASSERT( (err &amp; 0xfffff000) == 0 );
		<span class="enscript-keyword">return</span> (err &amp; 0xfff); <span class="enscript-comment">/* ioctl will return -1 and will set errno to an error code &lt; 4096 */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rv != 0) {
		ASSERT( (rv &amp; 0xfff00000) == 0 );
		<span class="enscript-keyword">return</span> (((rv &amp; 0xfffff) &lt;&lt; 12)); <span class="enscript-comment">/* ioctl will return -1 and will set errno to a value &gt;= 4096 */</span>
	} <span class="enscript-keyword">else</span> 
		<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">helper_ioctl</span>(dev_t dev, u_long cmd, caddr_t data, <span class="enscript-type">int</span> fflag, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dev</span>,<span class="enscript-variable-name">fflag</span>,<span class="enscript-variable-name">p</span>)
	<span class="enscript-type">int</span> err, rv = 0;
	
	err = dtrace_ioctl_helper(cmd, data, &amp;rv);
	<span class="enscript-comment">/* Darwin's BSD ioctls only return -1 or zero. Overload errno to mimic Solaris. 20 bits suffice. */</span>
	<span class="enscript-keyword">if</span> (err != 0) {
		ASSERT( (err &amp; 0xfffff000) == 0 );
		<span class="enscript-keyword">return</span> (err &amp; 0xfff); <span class="enscript-comment">/* ioctl will return -1 and will set errno to an error code &lt; 4096 */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rv != 0) {
		ASSERT( (rv &amp; 0xfff00000) == 0 );
		<span class="enscript-keyword">return</span> (((rv &amp; 0xfffff) &lt;&lt; 12)); <span class="enscript-comment">/* ioctl will return -1 and will set errno to a value &gt;= 4096 */</span>
	} <span class="enscript-keyword">else</span> 
		<span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HELPER_MAJOR</span>  -24 <span class="enscript-comment">/* let the kernel pick the device number */</span>

<span class="enscript-comment">/*
 * A struct describing which functions will get invoked for certain
 * actions.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cdevsw helper_cdevsw =
{
	helper_open,		<span class="enscript-comment">/* open */</span>
	helper_close,		<span class="enscript-comment">/* close */</span>
	eno_rdwrt,			<span class="enscript-comment">/* read */</span>
	eno_rdwrt,			<span class="enscript-comment">/* write */</span>
	helper_ioctl,		<span class="enscript-comment">/* ioctl */</span>
	(stop_fcn_t *)nulldev, <span class="enscript-comment">/* stop */</span>
	(reset_fcn_t *)nulldev, <span class="enscript-comment">/* reset */</span>
	NULL,				<span class="enscript-comment">/* tty's */</span>
	eno_select,			<span class="enscript-comment">/* select */</span>
	eno_mmap,			<span class="enscript-comment">/* mmap */</span>
	eno_strat,			<span class="enscript-comment">/* strategy */</span>
	eno_getc,			<span class="enscript-comment">/* getc */</span>
	eno_putc,			<span class="enscript-comment">/* putc */</span>
	0					<span class="enscript-comment">/* type */</span>
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> helper_majdevno = 0;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> gDTraceInited = 0;

<span class="enscript-type">void</span>
<span class="enscript-function-name">helper_init</span>( <span class="enscript-type">void</span> )
{
	<span class="enscript-comment">/*
	 * Once the &quot;helper&quot; is initialized, it can take ioctl calls that use locks
	 * and zones initialized in dtrace_init. Make certain dtrace_init was called
	 * before us.
	 */</span>

	<span class="enscript-keyword">if</span> (!gDTraceInited) {
		panic(<span class="enscript-string">&quot;helper_init before dtrace_init\n&quot;</span>);
	}

	<span class="enscript-keyword">if</span> (0 &gt;= helper_majdevno)
	{
		helper_majdevno = cdevsw_add(HELPER_MAJOR, &amp;helper_cdevsw);
		
		<span class="enscript-keyword">if</span> (helper_majdevno &lt; 0) {
			printf(<span class="enscript-string">&quot;helper_init: failed to allocate a major number!\n&quot;</span>);
			<span class="enscript-keyword">return</span>;
		}
		
		<span class="enscript-keyword">if</span> (NULL == devfs_make_node( makedev(helper_majdevno, 0), DEVFS_CHAR, UID_ROOT, GID_WHEEL, 0666, 
					DTRACEMNR_HELPER, 0 )) {
			printf(<span class="enscript-string">&quot;dtrace_init: failed to devfs_make_node for helper!\n&quot;</span>);
			<span class="enscript-keyword">return</span>;
		}
	} <span class="enscript-keyword">else</span>
		panic(<span class="enscript-string">&quot;helper_init: called twice!\n&quot;</span>);
}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">HELPER_MAJOR</span>

<span class="enscript-comment">/*
 * Called with DEVFS_LOCK held, so vmem_alloc's underlying blist structures are protected.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_clone_func</span>(dev_t dev, <span class="enscript-type">int</span> action)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dev</span>)

	<span class="enscript-keyword">if</span> (action == DEVFS_CLONE_ALLOC) {
		<span class="enscript-keyword">if</span> (NULL == dtrace_minor) <span class="enscript-comment">/* Arena not created yet!?! */</span>
			<span class="enscript-keyword">return</span> 0;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Propose a minor number, namely the next number that vmem_alloc() will return.
			 * Immediately put it back in play by calling vmem_free(). FIXME.
			 */</span>
			<span class="enscript-type">int</span> ret = (<span class="enscript-type">int</span>)(uintptr_t)vmem_alloc(dtrace_minor, 1, VM_BESTFIT | VM_SLEEP);

			vmem_free(dtrace_minor, (<span class="enscript-type">void</span> *)(uintptr_t)ret, 1);

			<span class="enscript-keyword">return</span> ret;
		}
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (action == DEVFS_CLONE_FREE) {
		<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span> -1;
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_MAJOR</span>  -24 <span class="enscript-comment">/* let the kernel pick the device number */</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cdevsw dtrace_cdevsw =
{
	_dtrace_open,		<span class="enscript-comment">/* open */</span>
	_dtrace_close,		<span class="enscript-comment">/* close */</span>
	eno_rdwrt,			<span class="enscript-comment">/* read */</span>
	eno_rdwrt,			<span class="enscript-comment">/* write */</span>
	_dtrace_ioctl,		<span class="enscript-comment">/* ioctl */</span>
	(stop_fcn_t *)nulldev, <span class="enscript-comment">/* stop */</span>
	(reset_fcn_t *)nulldev, <span class="enscript-comment">/* reset */</span>
	NULL,				<span class="enscript-comment">/* tty's */</span>
	eno_select,			<span class="enscript-comment">/* select */</span>
	eno_mmap,			<span class="enscript-comment">/* mmap */</span>
	eno_strat,			<span class="enscript-comment">/* strategy */</span>
	eno_getc,			<span class="enscript-comment">/* getc */</span>
	eno_putc,			<span class="enscript-comment">/* putc */</span>
	0					<span class="enscript-comment">/* type */</span>
};

lck_attr_t* dtrace_lck_attr;
lck_grp_attr_t* dtrace_lck_grp_attr;
lck_grp_t* dtrace_lck_grp;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> gMajDevNo;

<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_init</span>( <span class="enscript-type">void</span> )
{
	<span class="enscript-keyword">if</span> (0 == gDTraceInited) {
		<span class="enscript-type">int</span> i, ncpu;
		size_t size = <span class="enscript-keyword">sizeof</span>(dtrace_buffer_memory_maxsize);

		<span class="enscript-comment">/*
		 * DTrace allocates buffers based on the maximum number
		 * of enabled cpus. This call avoids any race when finding
		 * that count.
		 */</span>
		ASSERT(dtrace_max_cpus == 0);
		ncpu = dtrace_max_cpus = ml_get_max_cpus();

		<span class="enscript-comment">/*
		 * Retrieve the size of the physical memory in order to define
		 * the state buffer memory maximal size.  If we cannot retrieve
		 * this value, we'll consider that we have 1Gb of memory per CPU, that's
		 * still better than raising a kernel panic.
		 */</span>
		<span class="enscript-keyword">if</span> (0 != kernel_sysctlbyname(<span class="enscript-string">&quot;hw.memsize&quot;</span>, &amp;dtrace_buffer_memory_maxsize,
		                             &amp;size, NULL, 0))
		{
			dtrace_buffer_memory_maxsize = ncpu * 1024 * 1024 * 1024;
			printf(<span class="enscript-string">&quot;dtrace_init: failed to retrieve the hw.memsize, defaulted to %lld bytes\n&quot;</span>,
			       dtrace_buffer_memory_maxsize);
		}

		<span class="enscript-comment">/*
		 * Finally, divide by three to prevent DTrace from eating too
		 * much memory.
		 */</span>
		dtrace_buffer_memory_maxsize /= 3;
		ASSERT(dtrace_buffer_memory_maxsize &gt; 0);

		gMajDevNo = cdevsw_add(DTRACE_MAJOR, &amp;dtrace_cdevsw);

		<span class="enscript-keyword">if</span> (gMajDevNo &lt; 0) {
			printf(<span class="enscript-string">&quot;dtrace_init: failed to allocate a major number!\n&quot;</span>);
			gDTraceInited = 0;
			<span class="enscript-keyword">return</span>;
		}

		<span class="enscript-keyword">if</span> (NULL == devfs_make_node_clone( makedev(gMajDevNo, 0), DEVFS_CHAR, UID_ROOT, GID_WHEEL, 0666, 
					dtrace_clone_func, DTRACEMNR_DTRACE, 0 )) {
			printf(<span class="enscript-string">&quot;dtrace_init: failed to devfs_make_node_clone for dtrace!\n&quot;</span>);
			gDTraceInited = 0;
			<span class="enscript-keyword">return</span>;
		}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DTRACE_MEMORY_ZONES</span>)
		<span class="enscript-comment">/*
		 * Initialize the dtrace kalloc-emulation zones.
		 */</span>
		dtrace_alloc_init();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DTRACE_MEMORY_ZONES */</span>

		<span class="enscript-comment">/*
		 * Allocate the dtrace_probe_t zone
		 */</span>
		dtrace_probe_t_zone = zinit(<span class="enscript-keyword">sizeof</span>(dtrace_probe_t),
					    1024 * <span class="enscript-keyword">sizeof</span>(dtrace_probe_t),
					    <span class="enscript-keyword">sizeof</span>(dtrace_probe_t),
					    <span class="enscript-string">&quot;dtrace.dtrace_probe_t&quot;</span>);

		<span class="enscript-comment">/*
		 * Create the dtrace lock group and attrs.
		 */</span>
		dtrace_lck_attr = lck_attr_alloc_init();
		dtrace_lck_grp_attr= lck_grp_attr_alloc_init();		
		dtrace_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;dtrace&quot;</span>,  dtrace_lck_grp_attr);

		<span class="enscript-comment">/*
		 * We have to initialize all locks explicitly
		 */</span>
		lck_mtx_init(&amp;dtrace_lock, dtrace_lck_grp, dtrace_lck_attr);
		lck_mtx_init(&amp;dtrace_provider_lock, dtrace_lck_grp, dtrace_lck_attr);
		lck_mtx_init(&amp;dtrace_meta_lock, dtrace_lck_grp, dtrace_lck_attr);
		lck_mtx_init(&amp;dtrace_procwaitfor_lock, dtrace_lck_grp, dtrace_lck_attr);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
		lck_mtx_init(&amp;dtrace_errlock, dtrace_lck_grp, dtrace_lck_attr);
#<span class="enscript-reference">endif</span>
		lck_rw_init(&amp;dtrace_dof_mode_lock, dtrace_lck_grp, dtrace_lck_attr);

		<span class="enscript-comment">/*
		 * The cpu_core structure consists of per-CPU state available in any context.
		 * On some architectures, this may mean that the page(s) containing the
		 * NCPU-sized array of cpu_core structures must be locked in the TLB -- it
		 * is up to the platform to assure that this is performed properly.  Note that
		 * the structure is sized to avoid false sharing.
		 */</span>
		lck_mtx_init(&amp;cpu_lock, dtrace_lck_grp, dtrace_lck_attr);
		lck_mtx_init(&amp;cyc_lock, dtrace_lck_grp, dtrace_lck_attr);
		lck_mtx_init(&amp;mod_lock, dtrace_lck_grp, dtrace_lck_attr);

		<span class="enscript-comment">/*
		 * Initialize the CPU offline/online hooks.
		 */</span>
		dtrace_install_cpu_hooks();

		dtrace_modctl_list = NULL;

		cpu_core = (cpu_core_t *)kmem_zalloc( ncpu * <span class="enscript-keyword">sizeof</span>(cpu_core_t), KM_SLEEP );
		<span class="enscript-keyword">for</span> (i = 0; i &lt; ncpu; ++i) {
			lck_mtx_init(&amp;cpu_core[i].cpuc_pid_lock, dtrace_lck_grp, dtrace_lck_attr);
		}

		cpu_list = (dtrace_cpu_t *)kmem_zalloc( ncpu * <span class="enscript-keyword">sizeof</span>(dtrace_cpu_t), KM_SLEEP );
		<span class="enscript-keyword">for</span> (i = 0; i &lt; ncpu; ++i) {
			cpu_list[i].cpu_id = (processorid_t)i;
			cpu_list[i].cpu_next = &amp;(cpu_list[(i+1) % ncpu]);
			LIST_INIT(&amp;cpu_list[i].cpu_cyc_list);
			lck_rw_init(&amp;cpu_list[i].cpu_ft_lock, dtrace_lck_grp, dtrace_lck_attr);
		}

		lck_mtx_lock(&amp;cpu_lock);
		<span class="enscript-keyword">for</span> (i = 0; i &lt; ncpu; ++i) 
			<span class="enscript-comment">/* FIXME: track CPU configuration a la CHUD Processor Pref Pane. */</span>
			dtrace_cpu_setup_initial( (processorid_t)i ); <span class="enscript-comment">/* In lieu of register_cpu_setup_func() callback */</span>
		lck_mtx_unlock(&amp;cpu_lock);

		(<span class="enscript-type">void</span>)dtrace_abs_to_nano(0LL); <span class="enscript-comment">/* Force once only call to clock_timebase_info (which can take a lock) */</span>

		dtrace_isa_init();
		<span class="enscript-comment">/*
		 * See dtrace_impl.h for a description of dof modes.
		 * The default is lazy dof.
		 *
		 * FIXME: Warn if state is LAZY_OFF? It won't break anything, but
		 * makes no sense...
		 */</span>
		<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;dtrace_dof_mode&quot;</span>, &amp;dtrace_dof_mode, <span class="enscript-keyword">sizeof</span> (dtrace_dof_mode))) {
			dtrace_dof_mode = DTRACE_DOF_MODE_LAZY_ON;
		}

		<span class="enscript-comment">/*
		 * Sanity check of dof mode value.
		 */</span>
		<span class="enscript-keyword">switch</span> (dtrace_dof_mode) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACE_DOF_MODE_NEVER</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACE_DOF_MODE_LAZY_ON</span>:
				<span class="enscript-comment">/* valid modes, but nothing else we need to do */</span>
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACE_DOF_MODE_LAZY_OFF</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACE_DOF_MODE_NON_LAZY</span>:
				<span class="enscript-comment">/* Cannot wait for a dtrace_open to init fasttrap */</span>
				fasttrap_init();
				<span class="enscript-keyword">break</span>;

			<span class="enscript-reference">default</span>:
				<span class="enscript-comment">/* Invalid, clamp to non lazy */</span>
				dtrace_dof_mode = DTRACE_DOF_MODE_NON_LAZY;
				fasttrap_init();
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * See dtrace_impl.h for a description of kernel symbol modes.
		 * The default is to wait for symbols from userspace (lazy symbols).
		 */</span>
		<span class="enscript-keyword">if</span> (!PE_parse_boot_argn(<span class="enscript-string">&quot;dtrace_kernel_symbol_mode&quot;</span>, &amp;dtrace_kernel_symbol_mode, <span class="enscript-keyword">sizeof</span> (dtrace_kernel_symbol_mode))) {
			dtrace_kernel_symbol_mode = DTRACE_KERNEL_SYMBOLS_FROM_USERSPACE;
		}

		dtrace_restriction_policy_load();

		gDTraceInited = 1;

	} <span class="enscript-keyword">else</span>
		panic(<span class="enscript-string">&quot;dtrace_init: called twice!\n&quot;</span>);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_postinit</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 * Called from bsd_init after all provider's *_init() routines have been
	 * run. That way, anonymous DOF enabled under dtrace_attach() is safe
	 * to go.
	 */</span>
	dtrace_attach( (dev_info_t *)(uintptr_t)makedev(gMajDevNo, 0), 0 ); <span class="enscript-comment">/* Punning a dev_t to a dev_info_t* */</span>
	
	<span class="enscript-comment">/*
	 * Add the mach_kernel to the module list for lazy processing
	 */</span>
	<span class="enscript-type">struct</span> kmod_info fake_kernel_kmod;
	memset(&amp;fake_kernel_kmod, 0, <span class="enscript-keyword">sizeof</span>(fake_kernel_kmod));
	
	strlcpy(fake_kernel_kmod.name, <span class="enscript-string">&quot;mach_kernel&quot;</span>, <span class="enscript-keyword">sizeof</span>(fake_kernel_kmod.name));
	fake_kernel_kmod.id = 1;
	fake_kernel_kmod.address = g_kernel_kmod_info.address;
	fake_kernel_kmod.size = g_kernel_kmod_info.size;

	<span class="enscript-keyword">if</span> (dtrace_module_loaded(&amp;fake_kernel_kmod, 0) != 0) {
		printf(<span class="enscript-string">&quot;dtrace_postinit: Could not register mach_kernel modctl\n&quot;</span>);
	}
	
	(<span class="enscript-type">void</span>)OSKextRegisterKextsWithDTrace();
}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">DTRACE_MAJOR</span>

<span class="enscript-comment">/*
 * Routines used to register interest in cpu's being added to or removed
 * from the system.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">register_cpu_setup_func</span>(cpu_setup_func_t *ignore1, <span class="enscript-type">void</span> *ignore2)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ignore1</span>,<span class="enscript-variable-name">ignore2</span>)
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">unregister_cpu_setup_func</span>(cpu_setup_func_t *ignore1, <span class="enscript-type">void</span> *ignore2)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ignore1</span>,<span class="enscript-variable-name">ignore2</span>)
}
</pre>
<hr />
</body></html>