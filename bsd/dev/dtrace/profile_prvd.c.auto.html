<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>profile_prvd.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">profile_prvd.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or <a href="http://www.opensolaris.org/os/licensing.">http://www.opensolaris.org/os/licensing.</a>
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets &quot;[]&quot; replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */</span>
<span class="enscript-comment">/*
 * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */</span>

<span class="enscript-comment">/* #pragma ident	&quot;@(#)profile.c	1.7	07/01/10 SMI&quot; */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_KERNEL</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_KERNEL</span> <span class="enscript-comment">/* Solaris vs. Darwin */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_data.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_status.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/devfs.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace_impl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace_glue.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/pal_routines.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-type">extern</span> x86_saved_state_t *<span class="enscript-function-name">find_kern_regs</span>(thread_t);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unknown</span> <span class="enscript-variable-name">architecture</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">ASSERT</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ASSERT</span>(x) do {} while(0)

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">profile_init</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> dev_info_t *profile_devi;
<span class="enscript-type">static</span> dtrace_provider_id_t profile_id;

<span class="enscript-comment">/*
 * Regardless of platform, the stack frames look like this in the case of the
 * profile provider:
 *
 *	profile_fire
 *	cyclic_expire
 *	cyclic_fire
 *	[ cbe ]
 *	[ interrupt code ]
 *
 * On x86, there are five frames from the generic interrupt code; further, the
 * interrupted instruction appears as its own stack frame, giving us a total of
 * 10.
 *
 * On SPARC, the picture is further complicated because the compiler
 * optimizes away tail-calls -- so the following frames are optimized away:
 *
 * 	profile_fire
 *	cyclic_expire
 *
 * This gives three frames.  However, on DEBUG kernels, the cyclic_expire
 * frame cannot be tail-call eliminated, yielding four frames in this case.
 *
 * All of the above constraints lead to the mess below.  Yes, the profile
 * provider should ideally figure this out on-the-fly by hitting one of its own
 * probes and then walking its own stack trace.  This is complicated, however,
 * and the static definition doesn't seem to be overly brittle.  Still, we
 * allow for a manual override in case we get it completely wrong.
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PROF_ARTIFICIAL_FRAMES</span>  9
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unknown</span> <span class="enscript-variable-name">architecture</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PROF_NAMELEN</span>		15

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PROF_PROFILE</span>		0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PROF_TICK</span>		1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PROF_PREFIX_PROFILE</span>	<span class="enscript-string">&quot;profile-&quot;</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PROF_PREFIX_TICK</span>	<span class="enscript-string">&quot;tick-&quot;</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> profile_probe {
	<span class="enscript-type">char</span>		prof_name[PROF_NAMELEN];
	dtrace_id_t	prof_id;
	<span class="enscript-type">int</span>		prof_kind;
	hrtime_t	prof_interval;
	cyclic_id_t	prof_cyclic;
} profile_probe_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> profile_probe_percpu {
	hrtime_t	profc_expected;
	hrtime_t	profc_interval;
	profile_probe_t	*profc_probe;
} profile_probe_percpu_t;

hrtime_t	profile_interval_min = NANOSEC / 5000;		<span class="enscript-comment">/* 5000 hz */</span>
<span class="enscript-type">int</span>		profile_aframes = 0;				<span class="enscript-comment">/* override */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> profile_rates[] = {
    97, 199, 499, 997, 1999,
    4001, 4999, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> profile_ticks[] = {
    1, 10, 100, 500, 1000,
    5000, 0, 0, 0, 0,
    0, 0, 0, 0, 0
};

<span class="enscript-comment">/*
 * profile_max defines the upper bound on the number of profile probes that
 * can exist (this is to prevent malicious or clumsy users from exhausing
 * system resources by creating a slew of profile probes). At mod load time,
 * this gets its value from PROFILE_MAX_DEFAULT or profile-max-probes if it's
 * present in the profile.conf file.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PROFILE_MAX_DEFAULT</span>	1000	<span class="enscript-comment">/* default max. number of probes */</span>
<span class="enscript-type">static</span> uint32_t profile_max;		<span class="enscript-comment">/* maximum number of profile probes */</span>
<span class="enscript-type">static</span> uint32_t profile_total;	<span class="enscript-comment">/* current number of profile probes */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">profile_fire</span>(<span class="enscript-type">void</span> *arg)
{
	profile_probe_percpu_t *pcpu = arg;
	profile_probe_t *prof = pcpu-&gt;profc_probe;
	hrtime_t late;

	late = dtrace_gethrtime() - pcpu-&gt;profc_expected;
	pcpu-&gt;profc_expected += pcpu-&gt;profc_interval;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
	x86_saved_state_t *kern_regs = find_kern_regs(current_thread());

	<span class="enscript-keyword">if</span> (NULL != kern_regs) {
		<span class="enscript-comment">/* Kernel was interrupted. */</span>
		dtrace_probe(prof-&gt;prof_id, saved_state64(kern_regs)-&gt;isf.rip,  0x0, late, 0, 0);

	} <span class="enscript-keyword">else</span> {
		pal_register_cache_state(current_thread(), VALID);
		<span class="enscript-comment">/* Possibly a user interrupt */</span>
		x86_saved_state_t   *tagged_regs = (x86_saved_state_t *)find_user_regs(current_thread());

		<span class="enscript-keyword">if</span> (NULL == tagged_regs) {
			<span class="enscript-comment">/* Too bad, so sad, no useful interrupt state. */</span>
			dtrace_probe(prof-&gt;prof_id, 0xcafebabe,
	    		0x0, late, 0, 0); <span class="enscript-comment">/* XXX_BOGUS also see profile_usermode() below. */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (is_saved_state64(tagged_regs)) {
			x86_saved_state64_t *regs = saved_state64(tagged_regs);

			dtrace_probe(prof-&gt;prof_id, 0x0, regs-&gt;isf.rip, late, 0, 0);
		} <span class="enscript-keyword">else</span> {
			x86_saved_state32_t *regs = saved_state32(tagged_regs);

			dtrace_probe(prof-&gt;prof_id, 0x0, regs-&gt;eip, late, 0, 0);
		}
	}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unknown</span> <span class="enscript-variable-name">architecture</span>
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">profile_tick</span>(<span class="enscript-type">void</span> *arg)
{
	profile_probe_t *prof = arg;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
	x86_saved_state_t *kern_regs = find_kern_regs(current_thread());

	<span class="enscript-keyword">if</span> (NULL != kern_regs) {
		<span class="enscript-comment">/* Kernel was interrupted. */</span>
		dtrace_probe(prof-&gt;prof_id, saved_state64(kern_regs)-&gt;isf.rip,  0x0, 0, 0, 0);
	} <span class="enscript-keyword">else</span> {
		pal_register_cache_state(current_thread(), VALID);
		<span class="enscript-comment">/* Possibly a user interrupt */</span>
		x86_saved_state_t   *tagged_regs = (x86_saved_state_t *)find_user_regs(current_thread());

		<span class="enscript-keyword">if</span> (NULL == tagged_regs) {
			<span class="enscript-comment">/* Too bad, so sad, no useful interrupt state. */</span>
			dtrace_probe(prof-&gt;prof_id, 0xcafebabe,
	    		0x0, 0, 0, 0); <span class="enscript-comment">/* XXX_BOGUS also see profile_usermode() below. */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (is_saved_state64(tagged_regs)) {
			x86_saved_state64_t *regs = saved_state64(tagged_regs);

			dtrace_probe(prof-&gt;prof_id, 0x0, regs-&gt;isf.rip, 0, 0, 0);
		} <span class="enscript-keyword">else</span> {
			x86_saved_state32_t *regs = saved_state32(tagged_regs);

			dtrace_probe(prof-&gt;prof_id, 0x0, regs-&gt;eip, 0, 0, 0);
		}
	}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unknown</span> <span class="enscript-variable-name">architecture</span>
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">profile_create</span>(hrtime_t interval, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> kind)
{
	profile_probe_t *prof;

	<span class="enscript-keyword">if</span> (interval &lt; profile_interval_min)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (dtrace_probe_lookup(profile_id, NULL, NULL, name) != 0)
		<span class="enscript-keyword">return</span>;

	atomic_add_32(&amp;profile_total, 1);
	<span class="enscript-keyword">if</span> (profile_total &gt; profile_max) {
		atomic_add_32(&amp;profile_total, -1);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (PROF_TICK == kind)
		prof = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (profile_probe_t), KM_SLEEP);
	<span class="enscript-keyword">else</span>
		prof = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (profile_probe_t) + NCPU*<span class="enscript-keyword">sizeof</span>(profile_probe_percpu_t), KM_SLEEP);

	(<span class="enscript-type">void</span>) strlcpy(prof-&gt;prof_name, name, <span class="enscript-keyword">sizeof</span>(prof-&gt;prof_name));
	prof-&gt;prof_interval = interval;
	prof-&gt;prof_cyclic = CYCLIC_NONE;
	prof-&gt;prof_kind = kind;
	prof-&gt;prof_id = dtrace_probe_create(profile_id,
	    NULL, NULL, name,
	    profile_aframes ? profile_aframes : PROF_ARTIFICIAL_FRAMES, prof);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">profile_provide</span>(<span class="enscript-type">void</span> *arg, <span class="enscript-type">const</span> dtrace_probedesc_t *desc)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	<span class="enscript-type">int</span> i, j, rate, kind;
	hrtime_t val = 0, mult = 1, len;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, *suffix = NULL;

	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> {
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *prefix;
		<span class="enscript-type">int</span> kind;
	} types[] = {
		{ PROF_PREFIX_PROFILE, PROF_PROFILE },
		{ PROF_PREFIX_TICK, PROF_TICK },
		{ NULL, 0 }
	};

	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> {
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name;
		hrtime_t mult;
	} suffixes[] = {
		{ <span class="enscript-string">&quot;ns&quot;</span>, 	NANOSEC / NANOSEC },
		{ <span class="enscript-string">&quot;nsec&quot;</span>,	NANOSEC / NANOSEC },
		{ <span class="enscript-string">&quot;us&quot;</span>,		NANOSEC / MICROSEC },
		{ <span class="enscript-string">&quot;usec&quot;</span>,	NANOSEC / MICROSEC },
		{ <span class="enscript-string">&quot;ms&quot;</span>,		NANOSEC / MILLISEC },
		{ <span class="enscript-string">&quot;msec&quot;</span>,	NANOSEC / MILLISEC },
		{ <span class="enscript-string">&quot;s&quot;</span>,		NANOSEC / SEC },
		{ <span class="enscript-string">&quot;sec&quot;</span>,	NANOSEC / SEC },
		{ <span class="enscript-string">&quot;m&quot;</span>,		NANOSEC * (hrtime_t)60 },
		{ <span class="enscript-string">&quot;min&quot;</span>,	NANOSEC * (hrtime_t)60 },
		{ <span class="enscript-string">&quot;h&quot;</span>,		NANOSEC * (hrtime_t)(60 * 60) },
		{ <span class="enscript-string">&quot;hour&quot;</span>,	NANOSEC * (hrtime_t)(60 * 60) },
		{ <span class="enscript-string">&quot;d&quot;</span>,		NANOSEC * (hrtime_t)(24 * 60 * 60) },
		{ <span class="enscript-string">&quot;day&quot;</span>,	NANOSEC * (hrtime_t)(24 * 60 * 60) },
		{ <span class="enscript-string">&quot;hz&quot;</span>,		0 },
		{ NULL, 0 }
	};		

	<span class="enscript-keyword">if</span> (desc == NULL) {
		<span class="enscript-type">char</span> n[PROF_NAMELEN];

		<span class="enscript-comment">/*
		 * If no description was provided, provide all of our probes.
		 */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)(<span class="enscript-keyword">sizeof</span> (profile_rates) / <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>)); i++) {
			<span class="enscript-keyword">if</span> ((rate = profile_rates[i]) == 0)
				<span class="enscript-keyword">continue</span>;

			(<span class="enscript-type">void</span>) snprintf(n, PROF_NAMELEN, <span class="enscript-string">&quot;%s%d&quot;</span>,
			    PROF_PREFIX_PROFILE, rate);
			profile_create(NANOSEC / rate, n, PROF_PROFILE);
		}

		<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)(<span class="enscript-keyword">sizeof</span> (profile_ticks) / <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>)); i++) {
			<span class="enscript-keyword">if</span> ((rate = profile_ticks[i]) == 0)
				<span class="enscript-keyword">continue</span>;

			(<span class="enscript-type">void</span>) snprintf(n, PROF_NAMELEN, <span class="enscript-string">&quot;%s%d&quot;</span>,
			    PROF_PREFIX_TICK, rate);
			profile_create(NANOSEC / rate, n, PROF_TICK);
		}

		<span class="enscript-keyword">return</span>;
	}

	name = desc-&gt;dtpd_name;

	<span class="enscript-keyword">for</span> (i = 0; types[i].prefix != NULL; i++) {
		len = strlen(types[i].prefix);

		<span class="enscript-keyword">if</span> (strncmp(name, types[i].prefix, len) != 0)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (types[i].prefix == NULL)
		<span class="enscript-keyword">return</span>;

	kind = types[i].kind;
	j = strlen(name) - len;

	<span class="enscript-comment">/*
	 * We need to start before any time suffix.
	 */</span>
	<span class="enscript-keyword">for</span> (j = strlen(name); j &gt;= len; j--) {
		<span class="enscript-keyword">if</span> (name[j] &gt;= <span class="enscript-string">'0'</span> &amp;&amp; name[j] &lt;= <span class="enscript-string">'9'</span>)
			<span class="enscript-keyword">break</span>;
		suffix = &amp;name[j];
	}

	ASSERT(suffix != NULL);

	<span class="enscript-comment">/*
	 * Now determine the numerical value present in the probe name.
	 */</span>
	<span class="enscript-keyword">for</span> (; j &gt;= len; j--) {
		<span class="enscript-keyword">if</span> (name[j] &lt; <span class="enscript-string">'0'</span> || name[j] &gt; <span class="enscript-string">'9'</span>)
			<span class="enscript-keyword">return</span>;

		val += (name[j] - <span class="enscript-string">'0'</span>) * mult;
		mult *= (hrtime_t)10;
	}

	<span class="enscript-keyword">if</span> (val == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * Look-up the suffix to determine the multiplier.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0, mult = 0; suffixes[i].name != NULL; i++) {
		<span class="enscript-comment">/* APPLE NOTE: Darwin employs size bounded string operations */</span>
		<span class="enscript-keyword">if</span> (strncasecmp(suffixes[i].name, suffix, strlen(suffixes[i].name) + 1) == 0) {
			mult = suffixes[i].mult;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (suffixes[i].name == NULL &amp;&amp; *suffix != <span class="enscript-string">'\0'</span>)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (mult == 0) {
		<span class="enscript-comment">/*
		 * The default is frequency-per-second.
		 */</span>
		val = NANOSEC / val;
	} <span class="enscript-keyword">else</span> {
		val *= mult;
	}

	profile_create(val, name, kind);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">profile_destroy</span>(<span class="enscript-type">void</span> *arg, dtrace_id_t id, <span class="enscript-type">void</span> *parg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>,<span class="enscript-variable-name">id</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	profile_probe_t *prof = parg;

	ASSERT(prof-&gt;prof_cyclic == CYCLIC_NONE);

	<span class="enscript-keyword">if</span> (prof-&gt;prof_kind == PROF_TICK)
		kmem_free(prof, <span class="enscript-keyword">sizeof</span> (profile_probe_t));
	<span class="enscript-keyword">else</span>
		kmem_free(prof, <span class="enscript-keyword">sizeof</span> (profile_probe_t) + NCPU*<span class="enscript-keyword">sizeof</span>(profile_probe_percpu_t));

	ASSERT(profile_total &gt;= 1);
	atomic_add_32(&amp;profile_total, -1);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">profile_online</span>(<span class="enscript-type">void</span> *arg, dtrace_cpu_t *cpu, cyc_handler_t *hdlr, cyc_time_t *when)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cpu</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	profile_probe_t *prof = arg;
	profile_probe_percpu_t *pcpu;

	pcpu = ((profile_probe_percpu_t *)(&amp;(prof[1]))) + cpu_number();
	pcpu-&gt;profc_probe = prof;

	hdlr-&gt;cyh_func = profile_fire;
	hdlr-&gt;cyh_arg = pcpu;
	hdlr-&gt;cyh_level = CY_HIGH_LEVEL;

	when-&gt;cyt_interval = prof-&gt;prof_interval;
	when-&gt;cyt_when = dtrace_gethrtime() + when-&gt;cyt_interval;

	pcpu-&gt;profc_expected = when-&gt;cyt_when;
	pcpu-&gt;profc_interval = when-&gt;cyt_interval;
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">profile_offline</span>(<span class="enscript-type">void</span> *arg, dtrace_cpu_t *cpu, <span class="enscript-type">void</span> *oarg)
{
	profile_probe_percpu_t *pcpu = oarg;

	ASSERT(pcpu-&gt;profc_probe == arg);
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">pcpu</span>,<span class="enscript-variable-name">arg</span>,<span class="enscript-variable-name">cpu</span>) <span class="enscript-comment">/* __APPLE__ */</span>
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">profile_enable</span>(<span class="enscript-type">void</span> *arg, dtrace_id_t id, <span class="enscript-type">void</span> *parg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>,<span class="enscript-variable-name">id</span>) <span class="enscript-comment">/* __APPLE__ */</span>
	profile_probe_t *prof = parg;
	cyc_omni_handler_t omni;
	cyc_handler_t hdlr;
	cyc_time_t when;

	ASSERT(prof-&gt;prof_interval != 0);
	ASSERT(MUTEX_HELD(&amp;cpu_lock));

	<span class="enscript-keyword">if</span> (prof-&gt;prof_kind == PROF_TICK) {
		hdlr.cyh_func = profile_tick;
		hdlr.cyh_arg = prof;
		hdlr.cyh_level = CY_HIGH_LEVEL;

		when.cyt_interval = prof-&gt;prof_interval;
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
		when.cyt_when = dtrace_gethrtime() + when.cyt_interval;
#<span class="enscript-reference">else</span>
		when.cyt_when = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>
	} <span class="enscript-keyword">else</span> {
		ASSERT(prof-&gt;prof_kind == PROF_PROFILE);
		omni.cyo_online = profile_online;
		omni.cyo_offline = profile_offline;
		omni.cyo_arg = prof;
	}

	<span class="enscript-keyword">if</span> (prof-&gt;prof_kind == PROF_TICK) {
		prof-&gt;prof_cyclic = cyclic_timer_add(&amp;hdlr, &amp;when);
	} <span class="enscript-keyword">else</span> {
		prof-&gt;prof_cyclic = (cyclic_id_t)cyclic_add_omni(&amp;omni); <span class="enscript-comment">/* cast puns cyclic_id_list_t with cyclic_id_t */</span>
	}

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">profile_disable</span>(<span class="enscript-type">void</span> *arg, dtrace_id_t id, <span class="enscript-type">void</span> *parg)
{
	profile_probe_t *prof = parg;

	ASSERT(prof-&gt;prof_cyclic != CYCLIC_NONE);
	ASSERT(MUTEX_HELD(&amp;cpu_lock));

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>,<span class="enscript-variable-name">id</span>)
	<span class="enscript-keyword">if</span> (prof-&gt;prof_kind == PROF_TICK) {
		cyclic_timer_remove(prof-&gt;prof_cyclic);
	} <span class="enscript-keyword">else</span> {
		cyclic_remove_omni((cyclic_id_list_t)prof-&gt;prof_cyclic); <span class="enscript-comment">/* cast puns cyclic_id_list_t with cyclic_id_t */</span>
	}
	prof-&gt;prof_cyclic = CYCLIC_NONE;
}

<span class="enscript-comment">/*
 * APPLE NOTE:  profile_usermode call not supported.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">profile_usermode</span>(<span class="enscript-type">void</span> *arg, dtrace_id_t id, <span class="enscript-type">void</span> *parg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>,<span class="enscript-variable-name">id</span>,<span class="enscript-variable-name">parg</span>)
	<span class="enscript-keyword">return</span> 1; <span class="enscript-comment">/* XXX_BOGUS */</span>
}

<span class="enscript-type">static</span> dtrace_pattr_t profile_attr = {
{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
{ DTRACE_STABILITY_UNSTABLE, DTRACE_STABILITY_UNSTABLE, DTRACE_CLASS_UNKNOWN },
{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
};

<span class="enscript-type">static</span> dtrace_pops_t profile_pops = {
	profile_provide,
	NULL,
	profile_enable,
	profile_disable,
	NULL,
	NULL,
	NULL,
	NULL,
	profile_usermode,
	profile_destroy
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">profile_attach</span>(dev_info_t *devi, ddi_attach_cmd_t cmd)
{
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DDI_ATTACH</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DDI_RESUME</span>:
		<span class="enscript-keyword">return</span> (DDI_SUCCESS);
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (DDI_FAILURE);
	}

	<span class="enscript-keyword">if</span> (ddi_create_minor_node(devi, <span class="enscript-string">&quot;profile&quot;</span>, S_IFCHR, 0,
	    DDI_PSEUDO, 0) == DDI_FAILURE ||
	    dtrace_register(<span class="enscript-string">&quot;profile&quot;</span>, &amp;profile_attr,
	    DTRACE_PRIV_KERNEL | DTRACE_PRIV_USER, NULL,
	    &amp;profile_pops, NULL, &amp;profile_id) != 0) {
		ddi_remove_minor_node(devi, NULL);
		<span class="enscript-keyword">return</span> (DDI_FAILURE);
	}

	profile_max = PROFILE_MAX_DEFAULT;

	ddi_report_dev(devi);
	profile_devi = devi;
	<span class="enscript-keyword">return</span> (DDI_SUCCESS);
}

<span class="enscript-comment">/*
 * APPLE NOTE:  profile_detach not implemented
 */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__APPLE__</span>)
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">profile_detach</span>(dev_info_t *devi, ddi_detach_cmd_t cmd)
{
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DDI_DETACH</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DDI_SUSPEND</span>:
		<span class="enscript-keyword">return</span> (DDI_SUCCESS);
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (DDI_FAILURE);
	}

	<span class="enscript-keyword">if</span> (dtrace_unregister(profile_id) != 0)
		<span class="enscript-keyword">return</span> (DDI_FAILURE);

	ddi_remove_minor_node(devi, NULL);
	<span class="enscript-keyword">return</span> (DDI_SUCCESS);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE__ */</span>

d_open_t _profile_open;

<span class="enscript-type">int</span> <span class="enscript-function-name">_profile_open</span>(dev_t dev, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> devtype, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dev</span>,<span class="enscript-variable-name">flags</span>,<span class="enscript-variable-name">devtype</span>,<span class="enscript-variable-name">p</span>)
	<span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PROFILE_MAJOR</span>  -24 <span class="enscript-comment">/* let the kernel pick the device number */</span>

<span class="enscript-comment">/*
 * A struct describing which functions will get invoked for certain
 * actions.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cdevsw profile_cdevsw =
{
	_profile_open,		<span class="enscript-comment">/* open */</span>
	eno_opcl,			<span class="enscript-comment">/* close */</span>
	eno_rdwrt,			<span class="enscript-comment">/* read */</span>
	eno_rdwrt,			<span class="enscript-comment">/* write */</span>
	eno_ioctl,			<span class="enscript-comment">/* ioctl */</span>
	(stop_fcn_t *)nulldev, <span class="enscript-comment">/* stop */</span>
	(reset_fcn_t *)nulldev, <span class="enscript-comment">/* reset */</span>
	NULL,				<span class="enscript-comment">/* tty's */</span>
	eno_select,			<span class="enscript-comment">/* select */</span>
	eno_mmap,			<span class="enscript-comment">/* mmap */</span>
	eno_strat,			<span class="enscript-comment">/* strategy */</span>
	eno_getc,			<span class="enscript-comment">/* getc */</span>
	eno_putc,			<span class="enscript-comment">/* putc */</span>
	0					<span class="enscript-comment">/* type */</span>
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> gProfileInited = 0;

<span class="enscript-type">void</span> <span class="enscript-function-name">profile_init</span>( <span class="enscript-type">void</span> )
{
	<span class="enscript-keyword">if</span> (0 == gProfileInited)
	{
		<span class="enscript-type">int</span> majdevno = cdevsw_add(PROFILE_MAJOR, &amp;profile_cdevsw);
		
		<span class="enscript-keyword">if</span> (majdevno &lt; 0) {
			printf(<span class="enscript-string">&quot;profile_init: failed to allocate a major number!\n&quot;</span>);
			gProfileInited = 0;
			<span class="enscript-keyword">return</span>;
		}

		profile_attach( (dev_info_t	*)(uintptr_t)majdevno, DDI_ATTACH );

		gProfileInited = 1;
	} <span class="enscript-keyword">else</span>
		panic(<span class="enscript-string">&quot;profile_init: called twice!\n&quot;</span>);
}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">PROFILE_MAJOR</span>
</pre>
<hr />
</body></html>