<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>dtrace_isa.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">dtrace_isa.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2005-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MACH__POSIX_C_SOURCE_PRIVATE</span> 1 <span class="enscript-comment">/* pulls in suitable savearea from mach/ppc/thread_status.h */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_status.h&gt;</span>

<span class="enscript-type">typedef</span> x86_saved_state_t savearea_t;

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace_impl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/devfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/pal_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/mp.h&gt;</span>

<span class="enscript-comment">/*
 * APPLE NOTE:  The regmap is used to decode which 64bit uregs[] register
 * is being accessed when passed the 32bit uregs[] constant (based on
 * the reg.d translator file). The dtrace_getreg() is smart enough to handle
 * the register mappings.   The register set definitions are the same as
 * those used by the fasttrap_getreg code.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;fasttrap_regset.h&quot;</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> uint8_t regmap[19] = {
    REG_GS,		<span class="enscript-comment">/* GS */</span>
    REG_FS,		<span class="enscript-comment">/* FS */</span>
    REG_ES,		<span class="enscript-comment">/* ES */</span>
    REG_DS,		<span class="enscript-comment">/* DS */</span>
    REG_RDI,		<span class="enscript-comment">/* EDI */</span>
    REG_RSI,		<span class="enscript-comment">/* ESI */</span>
    REG_RBP,		<span class="enscript-comment">/* EBP, REG_FP  */</span>
    REG_RSP,		<span class="enscript-comment">/* ESP */</span>
    REG_RBX,		<span class="enscript-comment">/* EBX */</span>
    REG_RDX,		<span class="enscript-comment">/* EDX, REG_R1  */</span>
    REG_RCX,		<span class="enscript-comment">/* ECX */</span>
    REG_RAX,		<span class="enscript-comment">/* EAX, REG_R0  */</span>
    REG_TRAPNO,		<span class="enscript-comment">/* TRAPNO */</span>
    REG_ERR,		<span class="enscript-comment">/* ERR */</span>
    REG_RIP,		<span class="enscript-comment">/* EIP, REG_PC  */</span>
    REG_CS,		<span class="enscript-comment">/* CS */</span>
    REG_RFL,		<span class="enscript-comment">/* EFL, REG_PS  */</span>
    REG_RSP,		<span class="enscript-comment">/* UESP, REG_SP */</span>
    REG_SS		<span class="enscript-comment">/* SS */</span>
};    

<span class="enscript-type">extern</span> dtrace_id_t      dtrace_probeid_error;   <span class="enscript-comment">/* special ERROR probe */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_probe_error</span>(dtrace_state_t *state, dtrace_epid_t epid, <span class="enscript-type">int</span> which,
    <span class="enscript-type">int</span> fltoffs, <span class="enscript-type">int</span> fault, uint64_t illval)
{
    <span class="enscript-comment">/*
     * For the case of the error probe firing lets
     * stash away &quot;illval&quot; here, and special-case retrieving it in DIF_VARIABLE_ARG.
     */</span>
    state-&gt;dts_arg_error_illval = illval;
    dtrace_probe( dtrace_probeid_error, (uint64_t)(uintptr_t)state, epid, which, fltoffs, fault );
}

<span class="enscript-comment">/*
 * Atomicity and synchronization
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_membar_producer</span>(<span class="enscript-type">void</span>)
{
	__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;sfence&quot;</span>);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_membar_consumer</span>(<span class="enscript-type">void</span>)
{
	__asm__ <span class="enscript-type">volatile</span>(<span class="enscript-string">&quot;lfence&quot;</span>);
}

<span class="enscript-comment">/*
 * Interrupt manipulation
 * XXX dtrace_getipl() can be called from probe context.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_getipl</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 * XXX Drat, get_interrupt_level is MACH_KERNEL_PRIVATE
	 * in osfmk/kern/cpu_data.h
	 */</span>
	<span class="enscript-comment">/* return get_interrupt_level(); */</span>
	<span class="enscript-keyword">return</span> (ml_at_interrupt_context() ? 1: 0);
}

<span class="enscript-comment">/*
 * MP coordination
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> xcArg {
	processorid_t cpu;
	dtrace_xcall_t f;
	<span class="enscript-type">void</span> *arg;
} xcArg_t;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">xcRemote</span>( <span class="enscript-type">void</span> *foo )
{
	xcArg_t *pArg = (xcArg_t *)foo;
	
	<span class="enscript-keyword">if</span> ( pArg-&gt;cpu == CPU-&gt;cpu_id || pArg-&gt;cpu == DTRACE_CPUALL ) {
		(pArg-&gt;f)(pArg-&gt;arg);
	}
}


<span class="enscript-comment">/*
 * dtrace_xcall() is not called from probe context.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_xcall</span>(processorid_t cpu, dtrace_xcall_t f, <span class="enscript-type">void</span> *arg)
{
	xcArg_t xcArg;
	
	xcArg.cpu = cpu;
	xcArg.f = f;
	xcArg.arg = arg;

	<span class="enscript-keyword">if</span> (cpu == DTRACE_CPUALL) {
		mp_cpus_call (CPUMASK_ALL, ASYNC, xcRemote, (<span class="enscript-type">void</span>*)&amp;xcArg);
	}
	<span class="enscript-keyword">else</span> {
		mp_cpus_call (cpu_to_cpumask((cpu_t)cpu), ASYNC, xcRemote, (<span class="enscript-type">void</span>*)&amp;xcArg);
	}
}

<span class="enscript-comment">/*
 * Initialization
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_isa_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Runtime and ABI
 */</span>
uint64_t
<span class="enscript-function-name">dtrace_getreg</span>(<span class="enscript-type">struct</span> regs *savearea, uint_t reg)
{
	boolean_t is64Bit = proc_is64bit(current_proc());
	x86_saved_state_t *regs = (x86_saved_state_t *)savearea;

	<span class="enscript-keyword">if</span> (is64Bit) {
	    <span class="enscript-keyword">if</span> (reg &lt;= SS) {
		reg = regmap[reg];
	    } <span class="enscript-keyword">else</span> {
		reg -= (SS + 1);
	    }

	    <span class="enscript-keyword">switch</span> (reg) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RDI</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.rdi);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RSI</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.rsi);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RDX</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.rdx);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RCX</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.rcx);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R8</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.r8);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R9</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.r9);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RAX</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.rax);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RBX</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.rbx);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RBP</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.rbp);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R10</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.r10);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R11</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.r11);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R12</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.r12);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R13</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.r13);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R14</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.r14);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R15</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.r15);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_FS</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.fs);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_GS</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.gs);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_TRAPNO</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.isf.trapno);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_ERR</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.isf.err);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RIP</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.isf.rip);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_CS</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.isf.cs);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_SS</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.isf.ss);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RFL</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.isf.rflags);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RSP</span>:
		<span class="enscript-keyword">return</span> (uint64_t)(regs-&gt;ss_64.isf.rsp);
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_DS</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">REG_ES</span>:
	    <span class="enscript-reference">default</span>:
		DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
		<span class="enscript-keyword">return</span> (0);
	    }
	
	} <span class="enscript-keyword">else</span> {   <span class="enscript-comment">/* is 32bit user */</span>
		<span class="enscript-comment">/* beyond register SS */</span>
		<span class="enscript-keyword">if</span> (reg &gt; x86_SAVED_STATE32_COUNT - 1) {
			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
			<span class="enscript-keyword">return</span> (0);
		}
		<span class="enscript-keyword">return</span> (uint64_t)((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)(&amp;(regs-&gt;ss_32.gs)))[reg];
	}
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RETURN_OFFSET</span> 4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RETURN_OFFSET64</span> 8

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_getustack_common</span>(uint64_t *pcstack, <span class="enscript-type">int</span> pcstack_limit, user_addr_t pc,
    user_addr_t sp)
{
#<span class="enscript-reference">if</span> 0
	<span class="enscript-type">volatile</span> uint16_t *flags =
	    (<span class="enscript-type">volatile</span> uint16_t *)&amp;cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags;

	uintptr_t oldcontext = lwp-&gt;lwp_oldcontext; <span class="enscript-comment">/* XXX signal stack crawl */</span>
	size_t s1, s2;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span> ret = 0;
	boolean_t is64Bit = proc_is64bit(current_proc());

	ASSERT(pcstack == NULL || pcstack_limit &gt; 0);
	
#<span class="enscript-reference">if</span> 0 <span class="enscript-comment">/* XXX signal stack crawl */</span>
	<span class="enscript-keyword">if</span> (p-&gt;p_model == DATAMODEL_NATIVE) {
		s1 = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> frame) + 2 * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">long</span>);
		s2 = s1 + <span class="enscript-keyword">sizeof</span> (siginfo_t);
	} <span class="enscript-keyword">else</span> {
		s1 = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> frame32) + 3 * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>);
		s2 = s1 + <span class="enscript-keyword">sizeof</span> (siginfo32_t);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">while</span> (pc != 0) {
		ret++;
		<span class="enscript-keyword">if</span> (pcstack != NULL) {
			*pcstack++ = (uint64_t)pc;
			pcstack_limit--;
			<span class="enscript-keyword">if</span> (pcstack_limit &lt;= 0)
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (sp == 0)
			<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> 0 <span class="enscript-comment">/* XXX signal stack crawl */</span>
		<span class="enscript-keyword">if</span> (oldcontext == sp + s1 || oldcontext == sp + s2) {
			<span class="enscript-keyword">if</span> (p-&gt;p_model == DATAMODEL_NATIVE) {
				ucontext_t *ucp = (ucontext_t *)oldcontext;
				greg_t *gregs = ucp-&gt;uc_mcontext.gregs;

				sp = dtrace_fulword(&amp;gregs[REG_FP]);
				pc = dtrace_fulword(&amp;gregs[REG_PC]);

				oldcontext = dtrace_fulword(&amp;ucp-&gt;uc_link);
			} <span class="enscript-keyword">else</span> {
				ucontext32_t *ucp = (ucontext32_t *)oldcontext;
				greg32_t *gregs = ucp-&gt;uc_mcontext.gregs;

				sp = dtrace_fuword32(&amp;gregs[EBP]);
				pc = dtrace_fuword32(&amp;gregs[EIP]);

				oldcontext = dtrace_fuword32(&amp;ucp-&gt;uc_link);
			}
		} 
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
		{
			<span class="enscript-keyword">if</span> (is64Bit) {
				pc = dtrace_fuword64((sp + RETURN_OFFSET64));
				sp = dtrace_fuword64(sp);
			} <span class="enscript-keyword">else</span> {
				pc = dtrace_fuword32((sp + RETURN_OFFSET));
				sp = dtrace_fuword32(sp);
			}
		}

#<span class="enscript-reference">if</span> 0 <span class="enscript-comment">/* XXX */</span>
		<span class="enscript-comment">/*
		 * This is totally bogus:  if we faulted, we're going to clear
		 * the fault and break.  This is to deal with the apparently
		 * broken Java stacks on x86.
		 */</span>
		<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_FAULT) {
			*flags &amp;= ~CPU_DTRACE_FAULT;
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-keyword">return</span> (ret);
}


<span class="enscript-comment">/*
 * The return value indicates if we've modified the stack.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_adjust_stack</span>(uint64_t **pcstack, <span class="enscript-type">int</span> *pcstack_limit, user_addr_t *pc,
                    user_addr_t sp)
{
    int64_t missing_tos;
    <span class="enscript-type">int</span> rc = 0;
    boolean_t is64Bit = proc_is64bit(current_proc());

    ASSERT(pc != NULL);

    <span class="enscript-keyword">if</span> (DTRACE_CPUFLAG_ISSET(CPU_DTRACE_ENTRY)) {
        <span class="enscript-comment">/*
         * If we found ourselves in an entry probe, the frame pointer has not
         * yet been pushed (that happens in the
         * function prologue).  The best approach is to
	 * add the current pc as a missing top of stack,
         * and back the pc up to the caller, which is stored  at the
         * current stack pointer address since the call
         * instruction puts it there right before
         * the branch.
         */</span>

        missing_tos = *pc;

        <span class="enscript-keyword">if</span> (is64Bit)
            *pc = dtrace_fuword64(sp);
        <span class="enscript-keyword">else</span>
            *pc = dtrace_fuword32(sp);
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-comment">/*
         * We might have a top of stack override, in which case we just
         * add that frame without question to the top.  This
         * happens in return probes where you have a valid
         * frame pointer, but it's for the callers frame
         * and you'd like to add the pc of the return site
         * to the frame.
         */</span>
        missing_tos = cpu_core[CPU-&gt;cpu_id].cpuc_missing_tos;
    }

    <span class="enscript-keyword">if</span> (missing_tos != 0) {
        <span class="enscript-keyword">if</span> (pcstack != NULL &amp;&amp; pcstack_limit != NULL) {
            <span class="enscript-comment">/*
	     * If the missing top of stack has been filled out, then
	     * we add it and adjust the size.
             */</span>
	    *(*pcstack)++ = missing_tos;
	    (*pcstack_limit)--;
	}
        <span class="enscript-comment">/*
	 * return 1 because we would have changed the
	 * stack whether or not it was passed in.  This
	 * ensures the stack count is correct
	 */</span>
         rc = 1;
    }
    <span class="enscript-keyword">return</span> rc;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_getupcstack</span>(uint64_t *pcstack, <span class="enscript-type">int</span> pcstack_limit)
{
	thread_t thread = current_thread();
	x86_saved_state_t *regs;
	user_addr_t pc, sp, fp;
	<span class="enscript-type">volatile</span> uint16_t *flags =
	    (<span class="enscript-type">volatile</span> uint16_t *)&amp;cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags;
	<span class="enscript-type">int</span> n;
	boolean_t is64Bit = proc_is64bit(current_proc());

	<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_FAULT)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (pcstack_limit &lt;= 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * If there's no user context we still need to zero the stack.
	 */</span>
	<span class="enscript-keyword">if</span> (thread == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">zero</span>;

	pal_register_cache_state(thread, VALID);
	regs = (x86_saved_state_t *)find_user_regs(thread);
	<span class="enscript-keyword">if</span> (regs == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">zero</span>;
		
	*pcstack++ = (uint64_t)dtrace_proc_selfpid();
	pcstack_limit--;

	<span class="enscript-keyword">if</span> (pcstack_limit &lt;= 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (is64Bit) {
		pc = regs-&gt;ss_64.isf.rip;
		sp = regs-&gt;ss_64.isf.rsp;
		fp = regs-&gt;ss_64.rbp;
	} <span class="enscript-keyword">else</span> {
		pc = regs-&gt;ss_32.eip;
		sp = regs-&gt;ss_32.uesp;
		fp = regs-&gt;ss_32.ebp;
	}

        <span class="enscript-comment">/*
	 * The return value indicates if we've modified the stack.
	 * Since there is nothing else to fix up in either case,
	 * we can safely ignore it here.
	 */</span>
	(<span class="enscript-type">void</span>)dtrace_adjust_stack(&amp;pcstack, &amp;pcstack_limit, &amp;pc, sp);

	<span class="enscript-keyword">if</span>(pcstack_limit &lt;= 0)
	    <span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * Note that unlike ppc, the x86 code does not use
	 * CPU_DTRACE_USTACK_FP. This is because x86 always
	 * traces from the fp, even in syscall/profile/fbt
	 * providers.
	 */</span>
	n = dtrace_getustack_common(pcstack, pcstack_limit, pc, fp);
	ASSERT(n &gt;= 0);
	ASSERT(n &lt;= pcstack_limit);

	pcstack += n;
	pcstack_limit -= n;

<span class="enscript-reference">zero</span>:
	<span class="enscript-keyword">while</span> (pcstack_limit-- &gt; 0)
		*pcstack++ = 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">dtrace_getustackdepth</span>(<span class="enscript-type">void</span>)
{
	thread_t thread = current_thread();
	x86_saved_state_t *regs;
	user_addr_t pc, sp, fp;
	<span class="enscript-type">int</span> n = 0;
	boolean_t is64Bit = proc_is64bit(current_proc());

	<span class="enscript-keyword">if</span> (thread == NULL)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">if</span> (DTRACE_CPUFLAG_ISSET(CPU_DTRACE_FAULT))
		<span class="enscript-keyword">return</span> (-1);

	pal_register_cache_state(thread, VALID);
	regs = (x86_saved_state_t *)find_user_regs(thread);
	<span class="enscript-keyword">if</span> (regs == NULL)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">if</span> (is64Bit) {
		pc = regs-&gt;ss_64.isf.rip;
		sp = regs-&gt;ss_64.isf.rsp;
		fp = regs-&gt;ss_64.rbp;
	} <span class="enscript-keyword">else</span> {
		pc = regs-&gt;ss_32.eip;
		sp = regs-&gt;ss_32.uesp;
		fp = regs-&gt;ss_32.ebp;
	}

	<span class="enscript-keyword">if</span> (dtrace_adjust_stack(NULL, NULL, &amp;pc, sp) == 1) {
	    <span class="enscript-comment">/*
	     * we would have adjusted the stack if we had
	     * supplied one (that is what rc == 1 means).
	     * Also, as a side effect, the pc might have
	     * been fixed up, which is good for calling
	     * in to dtrace_getustack_common.
	     */</span>
	    n++;
	}
	
	<span class="enscript-comment">/*
	 * Note that unlike ppc, the x86 code does not use
	 * CPU_DTRACE_USTACK_FP. This is because x86 always
	 * traces from the fp, even in syscall/profile/fbt
	 * providers.
	 */</span>

	n += dtrace_getustack_common(NULL, 0, pc, fp);

	<span class="enscript-keyword">return</span> (n);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_getufpstack</span>(uint64_t *pcstack, uint64_t *fpstack, <span class="enscript-type">int</span> pcstack_limit)
{
	thread_t thread = current_thread();
	savearea_t *regs;
	user_addr_t pc, sp;
	<span class="enscript-type">volatile</span> uint16_t *flags =
	    (<span class="enscript-type">volatile</span> uint16_t *)&amp;cpu_core[CPU-&gt;cpu_id].cpuc_dtrace_flags;
#<span class="enscript-reference">if</span> 0
	uintptr_t oldcontext;
	size_t s1, s2;
#<span class="enscript-reference">endif</span>
	boolean_t is64Bit = proc_is64bit(current_proc());

	<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_FAULT)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (pcstack_limit &lt;= 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * If there's no user context we still need to zero the stack.
	 */</span>
	<span class="enscript-keyword">if</span> (thread == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">zero</span>;

	regs = (savearea_t *)find_user_regs(thread);
	<span class="enscript-keyword">if</span> (regs == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">zero</span>;
		
	*pcstack++ = (uint64_t)dtrace_proc_selfpid();
	pcstack_limit--;

	<span class="enscript-keyword">if</span> (pcstack_limit &lt;= 0)
		<span class="enscript-keyword">return</span>;

	pc = regs-&gt;ss_32.eip;
	sp = regs-&gt;ss_32.ebp;
	
#<span class="enscript-reference">if</span> 0 <span class="enscript-comment">/* XXX signal stack crawl */</span>
	oldcontext = lwp-&gt;lwp_oldcontext;

	<span class="enscript-keyword">if</span> (p-&gt;p_model == DATAMODEL_NATIVE) {
		s1 = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> frame) + 2 * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">long</span>);
		s2 = s1 + <span class="enscript-keyword">sizeof</span> (siginfo_t);
	} <span class="enscript-keyword">else</span> {
		s1 = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> frame32) + 3 * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>);
		s2 = s1 + <span class="enscript-keyword">sizeof</span> (siginfo32_t);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span>(dtrace_adjust_stack(&amp;pcstack, &amp;pcstack_limit, &amp;pc, sp) == 1) {
            <span class="enscript-comment">/*
	     * we made a change.
	     */</span>
	    *fpstack++ = 0;
	    <span class="enscript-keyword">if</span> (pcstack_limit &lt;= 0)
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">while</span> (pc != 0) {
		*pcstack++ = (uint64_t)pc;
		*fpstack++ = sp;
		pcstack_limit--;
		<span class="enscript-keyword">if</span> (pcstack_limit &lt;= 0)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (sp == 0)
			<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> 0 <span class="enscript-comment">/* XXX signal stack crawl */</span>
		<span class="enscript-keyword">if</span> (oldcontext == sp + s1 || oldcontext == sp + s2) {
			<span class="enscript-keyword">if</span> (p-&gt;p_model == DATAMODEL_NATIVE) {
				ucontext_t *ucp = (ucontext_t *)oldcontext;
				greg_t *gregs = ucp-&gt;uc_mcontext.gregs;

				sp = dtrace_fulword(&amp;gregs[REG_FP]);
				pc = dtrace_fulword(&amp;gregs[REG_PC]);

				oldcontext = dtrace_fulword(&amp;ucp-&gt;uc_link);
			} <span class="enscript-keyword">else</span> {
				ucontext_t *ucp = (ucontext_t *)oldcontext;
				greg_t *gregs = ucp-&gt;uc_mcontext.gregs;

				sp = dtrace_fuword32(&amp;gregs[EBP]);
				pc = dtrace_fuword32(&amp;gregs[EIP]);

				oldcontext = dtrace_fuword32(&amp;ucp-&gt;uc_link);
			}
		} 
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
		{
			<span class="enscript-keyword">if</span> (is64Bit) {
				pc = dtrace_fuword64((sp + RETURN_OFFSET64));
				sp = dtrace_fuword64(sp);
			} <span class="enscript-keyword">else</span> {
				pc = dtrace_fuword32((sp + RETURN_OFFSET));
				sp = dtrace_fuword32(sp);
			}
		}

#<span class="enscript-reference">if</span> 0 <span class="enscript-comment">/* XXX */</span>
		<span class="enscript-comment">/*
		 * This is totally bogus:  if we faulted, we're going to clear
		 * the fault and break.  This is to deal with the apparently
		 * broken Java stacks on x86.
		 */</span>
		<span class="enscript-keyword">if</span> (*flags &amp; CPU_DTRACE_FAULT) {
			*flags &amp;= ~CPU_DTRACE_FAULT;
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span>
	}

<span class="enscript-reference">zero</span>:
	<span class="enscript-keyword">while</span> (pcstack_limit-- &gt; 0)
		*pcstack++ = 0;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_getpcstack</span>(pc_t *pcstack, <span class="enscript-type">int</span> pcstack_limit, <span class="enscript-type">int</span> aframes,
		  uint32_t *intrpc)
{
	<span class="enscript-type">struct</span> frame *fp = (<span class="enscript-type">struct</span> frame *)__builtin_frame_address(0);
	<span class="enscript-type">struct</span> frame *nextfp, *minfp, *stacktop;
	<span class="enscript-type">int</span> depth = 0;
	<span class="enscript-type">int</span> last = 0;
	uintptr_t pc;
	uintptr_t caller = CPU-&gt;cpu_dtrace_caller;
	<span class="enscript-type">int</span> on_intr;

	<span class="enscript-keyword">if</span> ((on_intr = CPU_ON_INTR(CPU)) != 0)
		stacktop = (<span class="enscript-type">struct</span> frame *)dtrace_get_cpu_int_stack_top();
	<span class="enscript-keyword">else</span>
		stacktop = (<span class="enscript-type">struct</span> frame *)(dtrace_get_kernel_stack(current_thread()) + kernel_stack_size);

	minfp = fp;

	aframes++;

	<span class="enscript-keyword">if</span> (intrpc != NULL &amp;&amp; depth &lt; pcstack_limit)
		pcstack[depth++] = (pc_t)intrpc;

	<span class="enscript-keyword">while</span> (depth &lt; pcstack_limit) {
		nextfp = *(<span class="enscript-type">struct</span> frame **)fp;
		pc = *(uintptr_t *)(((uintptr_t)fp) + RETURN_OFFSET64);

		<span class="enscript-keyword">if</span> (nextfp &lt;= minfp || nextfp &gt;= stacktop) {
			<span class="enscript-keyword">if</span> (on_intr) {
				<span class="enscript-comment">/*
				 * Hop from interrupt stack to thread stack.
				 */</span>
				vm_offset_t kstack_base = dtrace_get_kernel_stack(current_thread());

				minfp = (<span class="enscript-type">struct</span> frame *)kstack_base;
				stacktop = (<span class="enscript-type">struct</span> frame *)(kstack_base + kernel_stack_size);

				on_intr = 0;
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-comment">/*
			 * This is the last frame we can process; indicate
			 * that we should return after processing this frame.
			 */</span>
			last = 1;
		}

		<span class="enscript-keyword">if</span> (aframes &gt; 0) {
			<span class="enscript-keyword">if</span> (--aframes == 0 &amp;&amp; caller != 0) {
				<span class="enscript-comment">/*
				 * We've just run out of artificial frames,
				 * and we have a valid caller -- fill it in
				 * now.
				 */</span>
				ASSERT(depth &lt; pcstack_limit);
				pcstack[depth++] = (pc_t)caller;
				caller = 0;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (depth &lt; pcstack_limit)
				pcstack[depth++] = (pc_t)pc;
		}

		<span class="enscript-keyword">if</span> (last) {
			<span class="enscript-keyword">while</span> (depth &lt; pcstack_limit)
				pcstack[depth++] = 0;
			<span class="enscript-keyword">return</span>;
		}

		fp = nextfp;
		minfp = fp;
	}
}

<span class="enscript-type">struct</span> frame {
	<span class="enscript-type">struct</span> frame *backchain;
	uintptr_t retaddr;
};

uint64_t
<span class="enscript-function-name">dtrace_getarg</span>(<span class="enscript-type">int</span> arg, <span class="enscript-type">int</span> aframes)
{
	uint64_t val;
	<span class="enscript-type">struct</span> frame *fp = (<span class="enscript-type">struct</span> frame *)__builtin_frame_address(0);
	uintptr_t *stack;
	uintptr_t pc;
	<span class="enscript-type">int</span> i;


    <span class="enscript-comment">/*
     * A total of 6 arguments are passed via registers; any argument with
     * index of 5 or lower is therefore in a register.
     */</span>
    <span class="enscript-type">int</span> inreg = 5;

	<span class="enscript-keyword">for</span> (i = 1; i &lt;= aframes; i++) {
		fp = fp-&gt;backchain;
		pc = fp-&gt;retaddr;

		<span class="enscript-keyword">if</span> (dtrace_invop_callsite_pre != NULL
			&amp;&amp; pc  &gt;  (uintptr_t)dtrace_invop_callsite_pre
			&amp;&amp; pc  &lt;= (uintptr_t)dtrace_invop_callsite_post) {
			<span class="enscript-comment">/*
			 * In the case of x86_64, we will use the pointer to the
			 * save area structure that was pushed when we took the
			 * trap.  To get this structure, we must increment
			 * beyond the frame structure. If the
			 * argument that we're seeking is passed on the stack,
			 * we'll pull the true stack pointer out of the saved
			 * registers and decrement our argument by the number
			 * of arguments passed in registers; if the argument
			 * we're seeking is passed in regsiters, we can just
			 * load it directly.
			 */</span>

			<span class="enscript-comment">/* fp points to frame of dtrace_invop() activation. */</span>
			fp = fp-&gt;backchain; <span class="enscript-comment">/* to fbt_perfcallback() activation. */</span>
			fp = fp-&gt;backchain; <span class="enscript-comment">/* to kernel_trap() activation. */</span>
			fp = fp-&gt;backchain; <span class="enscript-comment">/* to trap_from_kernel() activation. */</span>
			
			x86_saved_state_t   *tagged_regs = (x86_saved_state_t *)&amp;fp[1];
			x86_saved_state64_t *saved_state = saved_state64(tagged_regs);

			<span class="enscript-keyword">if</span> (arg &lt;= inreg) {
				stack = (uintptr_t *)&amp;saved_state-&gt;rdi;
			} <span class="enscript-keyword">else</span> {
				fp = (<span class="enscript-type">struct</span> frame *)(saved_state-&gt;isf.rsp);
				stack = (uintptr_t *)&amp;fp[1]; <span class="enscript-comment">/* Find marshalled
								arguments */</span>
				arg -= inreg + 1;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">load</span>;
		}
	}

	<span class="enscript-comment">/*
	 * We know that we did not come through a trap to get into
	 * dtrace_probe() --  We arrive here when the provider has
	 * called dtrace_probe() directly.
	 * The probe ID is the first argument to dtrace_probe().
	 * We must advance beyond that to get the argX.
	 */</span>
	arg++; <span class="enscript-comment">/* Advance past probeID */</span>

	<span class="enscript-keyword">if</span> (arg &lt;= inreg) {
		<span class="enscript-comment">/*
		 * This shouldn't happen.  If the argument is passed in a
		 * register then it should have been, well, passed in a
		 * register...
		 */</span>
		DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
		<span class="enscript-keyword">return</span> (0);
	}

	arg -= (inreg + 1);
	stack = (uintptr_t *)&amp;fp[1]; <span class="enscript-comment">/* Find marshalled arguments */</span>

<span class="enscript-reference">load</span>:
	DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
	<span class="enscript-comment">/* dtrace_probe arguments arg0 ... arg4 are 64bits wide */</span>
	val = (uint64_t)(*(((uintptr_t *)stack) + arg));
	DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);

	<span class="enscript-keyword">return</span> (val);
}

<span class="enscript-comment">/*
 * Load/Store Safety
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">dtrace_toxic_ranges</span>(<span class="enscript-type">void</span> (*func)(uintptr_t base, uintptr_t limit))
{
	<span class="enscript-comment">/*
	 * &quot;base&quot; is the smallest toxic address in the range, &quot;limit&quot; is the first
	 * VALID address greater than &quot;base&quot;.
	 */</span>
	func(0x0, VM_MIN_KERNEL_AND_KEXT_ADDRESS);
	<span class="enscript-keyword">if</span> (VM_MAX_KERNEL_ADDRESS &lt; ~(uintptr_t)0)
			func(VM_MAX_KERNEL_ADDRESS + 1, ~(uintptr_t)0);
}

</pre>
<hr />
</body></html>