<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>fbt_x86.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">fbt_x86.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License, Version 1.0 only
 * (the &quot;License&quot;).  You may not use this file except in compliance
 * with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or <a href="http://www.opensolaris.org/os/licensing.">http://www.opensolaris.org/os/licensing.</a>
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets &quot;[]&quot; replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */</span>
<span class="enscript-comment">/*
 * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */</span>

<span class="enscript-comment">/* #pragma ident	&quot;@(#)fbt.c	1.15	05/09/19 SMI&quot; */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_KERNEL</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_KERNEL</span> <span class="enscript-comment">/* Solaris vs. Darwin */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MACH__POSIX_C_SOURCE_PRIVATE</span> 1 <span class="enscript-comment">/* pulls in suitable savearea from mach/ppc/thread_status.h */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_status.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/loader.h&gt;</span> 
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/nlist.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/kernel_mach_header.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/devfs.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace_impl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fbt.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace_glue.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_INVOP_NOP_SKIP</span> 1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_INVOP_MOVL_ESP_EBP</span> 10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_INVOP_MOVL_ESP_EBP_SKIP</span> 2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_INVOP_MOV_RSP_RBP</span> 11
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_INVOP_MOV_RSP_RBP_SKIP</span> 3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_INVOP_POP_RBP</span> 12
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_INVOP_POP_RBP_SKIP</span> 1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DTRACE_INVOP_LEAVE_SKIP</span> 1

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_PUSHL_EBP</span>			0x55
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_MOVL_ESP_EBP0_V0</span>	0x8b
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_MOVL_ESP_EBP1_V0</span>	0xec
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_MOVL_ESP_EBP0_V1</span>	0x89
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_MOVL_ESP_EBP1_V1</span>	0xe5

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_PUSH_RBP</span>			0x55
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_REX_RSP_RBP</span>			0x48
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_MOV_RSP_RBP0</span>		0x89
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_MOV_RSP_RBP1</span>		0xe5
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_POP_RBP</span>				0x5d

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_POPL_EBP</span>			0x5d
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_RET</span>					0xc3
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_RET_IMM16</span>			0xc2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_LEAVE</span>				0xc9
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_JMP_SHORT_REL</span>		0xeb <span class="enscript-comment">/* Jump short, relative, displacement relative to next instr. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_JMP_NEAR_REL</span>		0xe9 <span class="enscript-comment">/* Jump near, relative, displacement relative to next instr. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_JMP_FAR_ABS</span>			0xea <span class="enscript-comment">/* Jump far, absolute, address given in operand */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FBT_RET_LEN</span>				1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FBT_RET_IMM16_LEN</span>		3
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_JMP_SHORT_REL_LEN</span>	2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_JMP_NEAR_REL_LEN</span>	5
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_JMP_FAR_ABS_LEN</span>		5

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_PATCHVAL</span>			0xf0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FBT_AFRAMES_ENTRY</span>		7
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FBT_AFRAMES_RETURN</span>		6

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_ENTRY</span>	<span class="enscript-string">&quot;entry&quot;</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FBT_RETURN</span>	<span class="enscript-string">&quot;return&quot;</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">FBT_ADDR2NDX</span>(addr)	((((uintptr_t)(addr)) &gt;&gt; 4) &amp; fbt_probetab_mask)

<span class="enscript-type">extern</span> dtrace_provider_id_t	fbt_id;
<span class="enscript-type">extern</span> fbt_probe_t		**fbt_probetab;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>			fbt_probetab_mask;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>			gIgnoreFBTBlacklist; <span class="enscript-comment">/* From fbt_init */</span>

kern_return_t <span class="enscript-function-name">fbt_perfCallback</span>(<span class="enscript-type">int</span>, x86_saved_state_t *, uintptr_t *, __unused <span class="enscript-type">int</span>);

<span class="enscript-comment">/*
 * Critical routines that must not be probed. PR_5221096, PR_5379018.
 * The blacklist must be kept in alphabetic order for purposes of bsearch().
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> * critical_blacklist[] =
{
	<span class="enscript-string">&quot;bcopy_phys&quot;</span>,
	<span class="enscript-string">&quot;console_cpu_alloc&quot;</span>, 
	<span class="enscript-string">&quot;console_cpu_free&quot;</span>, 
	<span class="enscript-string">&quot;cpu_IA32e_disable&quot;</span>, 
	<span class="enscript-string">&quot;cpu_IA32e_enable&quot;</span>, 
	<span class="enscript-string">&quot;cpu_NMI_interrupt&quot;</span>, 
	<span class="enscript-string">&quot;cpu_control&quot;</span>, 
	<span class="enscript-string">&quot;cpu_data_alloc&quot;</span>, 
	<span class="enscript-string">&quot;cpu_desc_init&quot;</span>,
	<span class="enscript-string">&quot;cpu_desc_init64&quot;</span>, 	
	<span class="enscript-string">&quot;cpu_desc_load&quot;</span>,
	<span class="enscript-string">&quot;cpu_desc_load64&quot;</span>, 	
	<span class="enscript-string">&quot;cpu_exit_wait&quot;</span>, 
	<span class="enscript-string">&quot;cpu_info&quot;</span>, 
	<span class="enscript-string">&quot;cpu_info_count&quot;</span>, 
	<span class="enscript-string">&quot;cpu_init&quot;</span>, 
	<span class="enscript-string">&quot;cpu_interrupt&quot;</span>, 
	<span class="enscript-string">&quot;cpu_machine_init&quot;</span>, 
	<span class="enscript-string">&quot;cpu_mode_init&quot;</span>, 
	<span class="enscript-string">&quot;cpu_processor_alloc&quot;</span>, 
	<span class="enscript-string">&quot;cpu_processor_free&quot;</span>, 
	<span class="enscript-string">&quot;cpu_signal_handler&quot;</span>, 
	<span class="enscript-string">&quot;cpu_sleep&quot;</span>, 
	<span class="enscript-string">&quot;cpu_start&quot;</span>, 
	<span class="enscript-string">&quot;cpu_subtype&quot;</span>, 
	<span class="enscript-string">&quot;cpu_thread_alloc&quot;</span>, 
	<span class="enscript-string">&quot;cpu_thread_halt&quot;</span>, 
	<span class="enscript-string">&quot;cpu_thread_init&quot;</span>, 
	<span class="enscript-string">&quot;cpu_threadtype&quot;</span>, 
	<span class="enscript-string">&quot;cpu_to_processor&quot;</span>, 
	<span class="enscript-string">&quot;cpu_topology_sort&quot;</span>,
	<span class="enscript-string">&quot;cpu_topology_start_cpu&quot;</span>, 	
	<span class="enscript-string">&quot;cpu_type&quot;</span>, 
	<span class="enscript-string">&quot;cpuid_cpu_display&quot;</span>,
	<span class="enscript-string">&quot;cpuid_extfeatures&quot;</span>,
	<span class="enscript-string">&quot;handle_pending_TLB_flushes&quot;</span>,
	<span class="enscript-string">&quot;hw_compare_and_store&quot;</span>,
	<span class="enscript-string">&quot;machine_idle_cstate&quot;</span>,
	<span class="enscript-string">&quot;mca_cpu_alloc&quot;</span>,
	<span class="enscript-string">&quot;mca_cpu_init&quot;</span>,
	<span class="enscript-string">&quot;ml_nofault_copy&quot;</span>,
	<span class="enscript-string">&quot;pmap_cpu_alloc&quot;</span>, 
	<span class="enscript-string">&quot;pmap_cpu_free&quot;</span>, 
	<span class="enscript-string">&quot;pmap_cpu_high_map_vaddr&quot;</span>, 
	<span class="enscript-string">&quot;pmap_cpu_high_shared_remap&quot;</span>, 
	<span class="enscript-string">&quot;pmap_cpu_init&quot;</span>,
	<span class="enscript-string">&quot;register_cpu_setup_func&quot;</span>,
	<span class="enscript-string">&quot;unregister_cpu_setup_func&quot;</span>,
	<span class="enscript-string">&quot;vstart&quot;</span>
};
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CRITICAL_BLACKLIST_COUNT</span> (sizeof(critical_blacklist)/sizeof(critical_blacklist[0]))

<span class="enscript-comment">/*
 * The transitive closure of entry points that can be reached from probe context.
 * (Apart from routines whose names begin with dtrace_).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> * probe_ctx_closure[] =
{
	<span class="enscript-string">&quot;Debugger&quot;</span>,
	<span class="enscript-string">&quot;IS_64BIT_PROCESS&quot;</span>,
	<span class="enscript-string">&quot;OSCompareAndSwap&quot;</span>,
	<span class="enscript-string">&quot;absolutetime_to_microtime&quot;</span>,
	<span class="enscript-string">&quot;act_set_astbsd&quot;</span>,
	<span class="enscript-string">&quot;ast_pending&quot;</span>,
	<span class="enscript-string">&quot;clock_get_calendar_nanotime_nowait&quot;</span>,
	<span class="enscript-string">&quot;copyin&quot;</span>,
	<span class="enscript-string">&quot;copyin_user&quot;</span>,
	<span class="enscript-string">&quot;copyinstr&quot;</span>,
	<span class="enscript-string">&quot;copyout&quot;</span>,
	<span class="enscript-string">&quot;copyoutstr&quot;</span>,
	<span class="enscript-string">&quot;cpu_number&quot;</span>,
	<span class="enscript-string">&quot;current_proc&quot;</span>,
	<span class="enscript-string">&quot;current_processor&quot;</span>,
	<span class="enscript-string">&quot;current_task&quot;</span>,
	<span class="enscript-string">&quot;current_thread&quot;</span>,
	<span class="enscript-string">&quot;debug_enter&quot;</span>,
	<span class="enscript-string">&quot;find_user_regs&quot;</span>,
	<span class="enscript-string">&quot;flush_tlb64&quot;</span>,
	<span class="enscript-string">&quot;get_bsdtask_info&quot;</span>,
	<span class="enscript-string">&quot;get_bsdthread_info&quot;</span>,
	<span class="enscript-string">&quot;hw_atomic_and&quot;</span>,
	<span class="enscript-string">&quot;kauth_cred_get&quot;</span>,
	<span class="enscript-string">&quot;kauth_getgid&quot;</span>,
	<span class="enscript-string">&quot;kauth_getuid&quot;</span>,
	<span class="enscript-string">&quot;kernel_preempt_check&quot;</span>,
	<span class="enscript-string">&quot;mach_absolute_time&quot;</span>,
	<span class="enscript-string">&quot;max_valid_stack_address&quot;</span>,
	<span class="enscript-string">&quot;ml_at_interrupt_context&quot;</span>,
	<span class="enscript-string">&quot;ml_phys_write_byte_64&quot;</span>,
	<span class="enscript-string">&quot;ml_phys_write_half_64&quot;</span>,
	<span class="enscript-string">&quot;ml_phys_write_word_64&quot;</span>,
	<span class="enscript-string">&quot;ml_set_interrupts_enabled&quot;</span>,
	<span class="enscript-string">&quot;panic&quot;</span>,
	<span class="enscript-string">&quot;pmap64_pde&quot;</span>,
	<span class="enscript-string">&quot;pmap64_pdpt&quot;</span>,
	<span class="enscript-string">&quot;pmap_find_phys&quot;</span>,
	<span class="enscript-string">&quot;pmap_get_mapwindow&quot;</span>,
	<span class="enscript-string">&quot;pmap_pde&quot;</span>,
	<span class="enscript-string">&quot;pmap_pte&quot;</span>,
	<span class="enscript-string">&quot;pmap_put_mapwindow&quot;</span>,
	<span class="enscript-string">&quot;pmap_valid_page&quot;</span>,
	<span class="enscript-string">&quot;prf&quot;</span>,
	<span class="enscript-string">&quot;proc_is64bit&quot;</span>,
	<span class="enscript-string">&quot;proc_selfname&quot;</span>,
	<span class="enscript-string">&quot;psignal_lock&quot;</span>,
	<span class="enscript-string">&quot;rtc_nanotime_load&quot;</span>,
	<span class="enscript-string">&quot;rtc_nanotime_read&quot;</span>,
	<span class="enscript-string">&quot;sdt_getargdesc&quot;</span>,
	<span class="enscript-string">&quot;strlcpy&quot;</span>,
	<span class="enscript-string">&quot;sync_iss_to_iks_unconditionally&quot;</span>,
	<span class="enscript-string">&quot;systrace_stub&quot;</span>,
	<span class="enscript-string">&quot;timer_grab&quot;</span>
};
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PROBE_CTX_CLOSURE_COUNT</span> (sizeof(probe_ctx_closure)/sizeof(probe_ctx_closure[0]))


<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *a, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *b)
{
	<span class="enscript-keyword">return</span> strncmp((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)a, *(<span class="enscript-type">const</span> <span class="enscript-type">char</span> **)b, strlen((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)a) + 1);
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">void</span> * <span class="enscript-function-name">bsearch</span>(
	<span class="enscript-type">register</span> <span class="enscript-type">const</span> <span class="enscript-type">void</span> *key,
	<span class="enscript-type">const</span> <span class="enscript-type">void</span> *base0,
	size_t nmemb,
	<span class="enscript-type">register</span> size_t size,
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> (*compar)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *)) {

	<span class="enscript-type">register</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *base = base0;
	<span class="enscript-type">register</span> size_t lim;
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> cmp;
	<span class="enscript-type">register</span> <span class="enscript-type">const</span> <span class="enscript-type">void</span> *p;

	<span class="enscript-keyword">for</span> (lim = nmemb; lim != 0; lim &gt;&gt;= 1) {
		p = base + (lim &gt;&gt; 1) * size;
		cmp = (*compar)(key, p);
		<span class="enscript-keyword">if</span> (cmp == 0)
			<span class="enscript-keyword">return</span> p;
		<span class="enscript-keyword">if</span> (cmp &gt; 0) {	<span class="enscript-comment">/* key &gt; p: move right */</span>
			base = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)p + size;
			lim--;
		}		<span class="enscript-comment">/* else move left */</span>
	}
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * Module validation
 */</span> 
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">is_module_valid</span>(<span class="enscript-type">struct</span> modctl* ctl)
{
	ASSERT(!MOD_FBT_PROBES_PROVIDED(ctl));
	ASSERT(!MOD_FBT_INVALID(ctl));
	
	<span class="enscript-keyword">if</span> (0 == ctl-&gt;mod_address || 0 == ctl-&gt;mod_size) {
		<span class="enscript-keyword">return</span> FALSE;
	}
	
	<span class="enscript-keyword">if</span> (0 == ctl-&gt;mod_loaded) {
	        <span class="enscript-keyword">return</span> FALSE;
	}
	
	<span class="enscript-keyword">if</span> (strstr(ctl-&gt;mod_modname, <span class="enscript-string">&quot;CHUD&quot;</span>) != NULL)
		<span class="enscript-keyword">return</span> FALSE;
	
        <span class="enscript-comment">/*
	 * If the user sets this, trust they know what they are doing.
	 */</span>
	<span class="enscript-keyword">if</span> (gIgnoreFBTBlacklist)   <span class="enscript-comment">/* per boot-arg set in fbt_init() */</span>
		<span class="enscript-keyword">return</span> TRUE;

	<span class="enscript-comment">/*
	 * These drivers control low level functions that when traced
	 * cause problems often in the sleep/wake paths as well as 
	 * critical debug and panic paths.
	 * If somebody really wants to drill in on one of these kexts, then
	 * they can override blacklisting using the boot-arg above.
	 */</span>

	<span class="enscript-keyword">if</span> (strstr(ctl-&gt;mod_modname, <span class="enscript-string">&quot;AppleACPIEC&quot;</span>) != NULL)
		<span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-keyword">if</span> (strstr(ctl-&gt;mod_modname, <span class="enscript-string">&quot;AppleACPIPlatform&quot;</span>) != NULL)
		<span class="enscript-keyword">return</span> FALSE;	

	<span class="enscript-keyword">if</span> (strstr(ctl-&gt;mod_modname, <span class="enscript-string">&quot;AppleRTC&quot;</span>) != NULL)
		<span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-keyword">if</span> (strstr(ctl-&gt;mod_modname, <span class="enscript-string">&quot;IOACPIFamily&quot;</span>) != NULL)
		<span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-keyword">if</span> (strstr(ctl-&gt;mod_modname, <span class="enscript-string">&quot;AppleIntelCPUPowerManagement&quot;</span>) != NULL)
		<span class="enscript-keyword">return</span> FALSE;
	
	<span class="enscript-keyword">if</span> (strstr(ctl-&gt;mod_modname, <span class="enscript-string">&quot;AppleProfile&quot;</span>) != NULL)
		<span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-keyword">if</span> (strstr(ctl-&gt;mod_modname, <span class="enscript-string">&quot;AppleIntelProfile&quot;</span>) != NULL)
		<span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-keyword">if</span> (strstr(ctl-&gt;mod_modname, <span class="enscript-string">&quot;AppleEFI&quot;</span>) != NULL)
		<span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-comment">/*
 * FBT probe name validation
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">is_symbol_valid</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span>* name)
{
	<span class="enscript-comment">/*
	 * If the user set this, trust they know what they are doing.
	 */</span>
	<span class="enscript-keyword">if</span> (gIgnoreFBTBlacklist)
		<span class="enscript-keyword">return</span> TRUE;
		
	<span class="enscript-keyword">if</span> (LIT_STRNSTART(name, <span class="enscript-string">&quot;dtrace_&quot;</span>) &amp;&amp; !LIT_STRNSTART(name, <span class="enscript-string">&quot;dtrace_safe_&quot;</span>)) {
		<span class="enscript-comment">/*
		 * Anything beginning with &quot;dtrace_&quot; may be called
		 * from probe context unless it explitly indicates
		 * that it won't be called from probe context by
		 * using the prefix &quot;dtrace_safe_&quot;.
		 */</span>
		<span class="enscript-keyword">return</span> FALSE;
	}
	
	<span class="enscript-keyword">if</span> (LIT_STRNSTART(name, <span class="enscript-string">&quot;fasttrap_&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;fuword&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;suword&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;sprlock&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;sprunlock&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;uread&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;uwrite&quot;</span>)) {
		<span class="enscript-keyword">return</span> FALSE; <span class="enscript-comment">/* Fasttrap inner-workings. */</span>
	}
	
	<span class="enscript-keyword">if</span> (LIT_STRNSTART(name, <span class="enscript-string">&quot;dsmos_&quot;</span>)) 
		<span class="enscript-keyword">return</span> FALSE; <span class="enscript-comment">/* Don't Steal Mac OS X! */</span>
	
        <span class="enscript-keyword">if</span> (LIT_STRNSTART(name, <span class="enscript-string">&quot;_dtrace&quot;</span>))
		<span class="enscript-keyword">return</span> FALSE; <span class="enscript-comment">/* Shims in dtrace.c */</span>
	
	<span class="enscript-keyword">if</span> (LIT_STRNSTART(name, <span class="enscript-string">&quot;chud&quot;</span>))
		<span class="enscript-keyword">return</span> FALSE; <span class="enscript-comment">/* Professional courtesy. */</span>
	
	<span class="enscript-keyword">if</span> (LIT_STRNSTART(name, <span class="enscript-string">&quot;hibernate_&quot;</span>))
		<span class="enscript-keyword">return</span> FALSE; <span class="enscript-comment">/* Let sleeping dogs lie. */</span>

	<span class="enscript-keyword">if</span> (LIT_STRNEQL(name, <span class="enscript-string">&quot;_ZNK6OSData14getBytesNoCopyEv&quot;</span>))
		<span class="enscript-keyword">return</span> FALSE;  <span class="enscript-comment">/* Data::getBytesNoCopy, IOHibernateSystemWake path */</span>
	
	<span class="enscript-keyword">if</span> (LIT_STRNEQL(name, <span class="enscript-string">&quot;_ZN9IOService14newTemperatureElPS_&quot;</span>) || <span class="enscript-comment">/* IOService::newTemperature */</span>
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;_ZN9IOService26temperatureCriticalForZoneEPS_&quot;</span>)) { <span class="enscript-comment">/* IOService::temperatureCriticalForZone */</span>
		<span class="enscript-keyword">return</span> FALSE; <span class="enscript-comment">/* Per the fire code */</span>
	}
	
	<span class="enscript-comment">/*
	 * Place no probes (illegal instructions) in the exception handling path!
	 */</span>
	<span class="enscript-keyword">if</span> (LIT_STRNEQL(name, <span class="enscript-string">&quot;t_invop&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;enter_lohandler&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;lo_alltraps&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;kernel_trap&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;interrupt&quot;</span>) ||		  
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;i386_astintr&quot;</span>)) {
		<span class="enscript-keyword">return</span> FALSE;
	}
	
	<span class="enscript-keyword">if</span> (LIT_STRNEQL(name, <span class="enscript-string">&quot;current_thread&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;ast_pending&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;fbt_perfCallback&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;machine_thread_get_kern_state&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;get_threadtask&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;ml_set_interrupts_enabled&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;dtrace_invop&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;fbt_invop&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;sdt_invop&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;max_valid_stack_address&quot;</span>)) {
		<span class="enscript-keyword">return</span> FALSE;
	}
	
	<span class="enscript-comment">/*
	 * Voodoo.
	 */</span>
	<span class="enscript-keyword">if</span> (LIT_STRNSTART(name, <span class="enscript-string">&quot;machine_stack_&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;mapping_&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;tmrCvt&quot;</span>) ||
	    
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;tsc_&quot;</span>) ||
	    
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;pmCPU&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;pmKextRegister&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;pmMarkAllCPUsOff&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;pmSafeMode&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;pmTimerSave&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;pmTimerRestore&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;pmUnRegister&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;pms&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;power_management_init&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;usimple_&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;lck_spin_lock&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;lck_spin_unlock&quot;</span>) ||		  
	    
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;rtc_&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;_rtc_&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;rtclock_&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;clock_&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;absolutetime_to_&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;setPop&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;nanoseconds_to_absolutetime&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;nanotime_to_absolutetime&quot;</span>) ||
	    
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;etimer_&quot;</span>) ||
	    
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;commpage_&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;pmap_&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;ml_&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;PE_&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;kprintf&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;lapic_&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;act_machine&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;acpi_&quot;</span>)  ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;pal_&quot;</span>)){
		<span class="enscript-keyword">return</span> FALSE;
	}

	<span class="enscript-comment">/*
         * Avoid machine_ routines. PR_5346750.
         */</span>
        <span class="enscript-keyword">if</span> (LIT_STRNSTART(name, <span class="enscript-string">&quot;machine_&quot;</span>))
		<span class="enscript-keyword">return</span> FALSE;
	
	<span class="enscript-keyword">if</span> (LIT_STRNEQL(name, <span class="enscript-string">&quot;handle_pending_TLB_flushes&quot;</span>))
		<span class="enscript-keyword">return</span> FALSE;
	
        <span class="enscript-comment">/*
         * Place no probes on critical routines. PR_5221096
         */</span>
        <span class="enscript-keyword">if</span> (bsearch( name, critical_blacklist, CRITICAL_BLACKLIST_COUNT, <span class="enscript-keyword">sizeof</span>(name), _cmp ) != NULL)
                <span class="enscript-keyword">return</span> FALSE;
	
        <span class="enscript-comment">/*
	 * Place no probes that could be hit in probe context.
	 */</span>
	<span class="enscript-keyword">if</span> (bsearch( name, probe_ctx_closure, PROBE_CTX_CLOSURE_COUNT, <span class="enscript-keyword">sizeof</span>(name), _cmp ) != NULL) {
		<span class="enscript-keyword">return</span> FALSE;
	}
	
	<span class="enscript-comment">/*
	 * Place no probes that could be hit on the way to the debugger.
	 */</span>
	<span class="enscript-keyword">if</span> (LIT_STRNSTART(name, <span class="enscript-string">&quot;kdp_&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;kdb_&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;kdbg_&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;kdebug_&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;kernel_debug&quot;</span>) ||
	    LIT_STRNSTART(name, <span class="enscript-string">&quot;debug_&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;Debugger&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;Call_DebuggerC&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;lock_debugger&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;unlock_debugger&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;packA&quot;</span>)  ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;unpackA&quot;</span>)  ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;SysChoked&quot;</span>))  {
		<span class="enscript-keyword">return</span> FALSE;
	}
	
	
	<span class="enscript-comment">/*
	 * Place no probes that could be hit on the way to a panic.
	 */</span>
	<span class="enscript-keyword">if</span> (NULL != strstr(name, <span class="enscript-string">&quot;panic_&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;panic&quot;</span>) ||
	    LIT_STRNEQL(name, <span class="enscript-string">&quot;preemption_underflow_panic&quot;</span>)) {
		<span class="enscript-keyword">return</span> FALSE;
	}
	
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fbt_invop</span>(uintptr_t addr, uintptr_t *state, uintptr_t rval)
{
	fbt_probe_t *fbt = fbt_probetab[FBT_ADDR2NDX(addr)];
	
	<span class="enscript-keyword">for</span> (; fbt != NULL; fbt = fbt-&gt;fbtp_hashnext) {
		<span class="enscript-keyword">if</span> ((uintptr_t)fbt-&gt;fbtp_patchpoint == addr) {

			<span class="enscript-keyword">if</span> (fbt-&gt;fbtp_roffset == 0) {
				x86_saved_state64_t *regs = (x86_saved_state64_t *)state;

				CPU-&gt;cpu_dtrace_caller = *(uintptr_t *)(((uintptr_t)(regs-&gt;isf.rsp))+<span class="enscript-keyword">sizeof</span>(uint64_t)); <span class="enscript-comment">// 8(%rsp)
</span>				<span class="enscript-comment">/* 64-bit ABI, arguments passed in registers. */</span>
				dtrace_probe(fbt-&gt;fbtp_id, regs-&gt;rdi, regs-&gt;rsi, regs-&gt;rdx, regs-&gt;rcx, regs-&gt;r8);
				CPU-&gt;cpu_dtrace_caller = 0;
			} <span class="enscript-keyword">else</span> {

				dtrace_probe(fbt-&gt;fbtp_id, fbt-&gt;fbtp_roffset, rval, 0, 0, 0);
				CPU-&gt;cpu_dtrace_caller = 0;
			}

			<span class="enscript-keyword">return</span> (fbt-&gt;fbtp_rval);
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_USER_TRAP</span>(regs) (regs &amp;&amp; (((regs)-&gt;isf.cs &amp; 3) != 0))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">T_INVALID_OPCODE</span> 6
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FBT_EXCEPTION_CODE</span> T_INVALID_OPCODE
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">T_PREEMPT</span>       255

kern_return_t
<span class="enscript-function-name">fbt_perfCallback</span>(
                <span class="enscript-type">int</span>         		trapno,
                x86_saved_state_t 	*tagged_regs,
		uintptr_t		*lo_spp,
                __unused <span class="enscript-type">int</span>        unused2)
{
	kern_return_t retval = KERN_FAILURE;
	x86_saved_state64_t *saved_state = saved_state64(tagged_regs);

	<span class="enscript-keyword">if</span> (FBT_EXCEPTION_CODE == trapno &amp;&amp; !IS_USER_TRAP(saved_state)) {
		boolean_t oldlevel;
		uint64_t rsp_probe, fp, delta = 0;
		uintptr_t old_sp;
		uint32_t *pDst;
		<span class="enscript-type">int</span> emul;


		oldlevel = ml_set_interrupts_enabled(FALSE);

		<span class="enscript-comment">/* Calculate where the stack pointer was when the probe instruction &quot;fired.&quot; */</span>
		rsp_probe = saved_state-&gt;isf.rsp; <span class="enscript-comment">/* Easy, x86_64 establishes this value in idt64.s */</span>

		__asm__ <span class="enscript-type">volatile</span>(
			<span class="enscript-string">&quot;Ldtrace_invop_callsite_pre_label:\n&quot;</span>
			<span class="enscript-string">&quot;.data\n&quot;</span>
			<span class="enscript-string">&quot;.private_extern _dtrace_invop_callsite_pre\n&quot;</span>
			<span class="enscript-string">&quot;_dtrace_invop_callsite_pre:\n&quot;</span>
			<span class="enscript-string">&quot;  .quad Ldtrace_invop_callsite_pre_label\n&quot;</span>
			<span class="enscript-string">&quot;.text\n&quot;</span>
				 );

		emul = dtrace_invop( saved_state-&gt;isf.rip, (uintptr_t *)saved_state, saved_state-&gt;rax );

		__asm__ <span class="enscript-type">volatile</span>(
			<span class="enscript-string">&quot;Ldtrace_invop_callsite_post_label:\n&quot;</span>
			<span class="enscript-string">&quot;.data\n&quot;</span>
			<span class="enscript-string">&quot;.private_extern _dtrace_invop_callsite_post\n&quot;</span>
			<span class="enscript-string">&quot;_dtrace_invop_callsite_post:\n&quot;</span>
			<span class="enscript-string">&quot;  .quad Ldtrace_invop_callsite_post_label\n&quot;</span>
			<span class="enscript-string">&quot;.text\n&quot;</span>
				 );		

		<span class="enscript-keyword">switch</span> (emul) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACE_INVOP_NOP</span>:
			saved_state-&gt;isf.rip += DTRACE_INVOP_NOP_SKIP;	<span class="enscript-comment">/* Skip over the patched NOP (planted by sdt). */</span>
			retval = KERN_SUCCESS;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACE_INVOP_MOV_RSP_RBP</span>:
			saved_state-&gt;rbp = rsp_probe;							<span class="enscript-comment">/* Emulate patched mov %rsp,%rbp */</span>
			saved_state-&gt;isf.rip += DTRACE_INVOP_MOV_RSP_RBP_SKIP;	<span class="enscript-comment">/* Skip over the bytes of the patched mov %rsp,%rbp */</span>
			retval = KERN_SUCCESS;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACE_INVOP_POP_RBP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DTRACE_INVOP_LEAVE</span>:
<span class="enscript-comment">/*
 * Emulate first micro-op of patched leave: mov %rbp,%rsp
 * fp points just below the return address slot for target's ret 
 * and at the slot holding the frame pointer saved by the target's prologue.
 */</span>
			fp = saved_state-&gt;rbp;
<span class="enscript-comment">/* Emulate second micro-op of patched leave: patched pop %rbp
 * savearea rbp is set for the frame of the caller to target
 * The *live* %rsp will be adjusted below for pop increment(s)
 */</span>
			saved_state-&gt;rbp = *(uint64_t *)fp;
<span class="enscript-comment">/* Skip over the patched leave */</span>
			saved_state-&gt;isf.rip += DTRACE_INVOP_LEAVE_SKIP;
<span class="enscript-comment">/*
 * Lift the stack to account for the emulated leave
 * Account for words local in this frame
 * (in &quot;case DTRACE_INVOP_POPL_EBP:&quot; this is zero.)
 */</span>
			delta = ((uint32_t *)fp) - ((uint32_t *)rsp_probe); <span class="enscript-comment">/* delta is a *word* increment */</span>
<span class="enscript-comment">/* Account for popping off the rbp (just accomplished by the emulation
 * above...)
 */</span>
			delta += 2;
			saved_state-&gt;isf.rsp += (delta &lt;&lt; 2);
<span class="enscript-comment">/* Obtain the stack pointer recorded by the trampolines */</span>
			old_sp = *lo_spp;
<span class="enscript-comment">/* Shift contents of stack */</span>
			<span class="enscript-keyword">for</span> (pDst = (uint32_t *)fp;
			     pDst &gt; (((uint32_t *)old_sp));
				 pDst--)
				*pDst = pDst[-delta];

<span class="enscript-comment">/* Track the stack lift in &quot;saved_state&quot;. */</span>
			saved_state = (x86_saved_state64_t *) (((uintptr_t)saved_state) + (delta &lt;&lt; 2));
<span class="enscript-comment">/* Adjust the stack pointer utilized by the trampolines */</span>
			*lo_spp = old_sp + (delta &lt;&lt; 2);

			retval = KERN_SUCCESS;
			<span class="enscript-keyword">break</span>;
			
		<span class="enscript-reference">default</span>:
			retval = KERN_FAILURE;
			<span class="enscript-keyword">break</span>;
		}
		saved_state-&gt;isf.trapno = T_PREEMPT; <span class="enscript-comment">/* Avoid call to i386_astintr()! */</span>

		ml_set_interrupts_enabled(oldlevel);
	}

	<span class="enscript-keyword">return</span> retval;
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">__provide_probe_64</span>(<span class="enscript-type">struct</span> modctl *ctl, uintptr_t instrLow, uintptr_t instrHigh, <span class="enscript-type">char</span> *modname, <span class="enscript-type">char</span>* symbolName, machine_inst_t* symbolStart)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			j;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			doenable = 0;
	dtrace_id_t			thisid;

	fbt_probe_t *newfbt, *retfbt, *entryfbt;
	machine_inst_t *instr, *limit, theInstr, i1, i2, i3;
	<span class="enscript-type">int</span> size;
		
	<span class="enscript-keyword">for</span> (j = 0, instr = symbolStart, theInstr = 0;
	     (j &lt; 4) &amp;&amp; ((uintptr_t)instr &gt;= instrLow) &amp;&amp; (instrHigh &gt; (uintptr_t)(instr + 2)); 
	     j++) {
		theInstr = instr[0];
		<span class="enscript-keyword">if</span> (theInstr == FBT_PUSH_RBP || theInstr == FBT_RET || theInstr == FBT_RET_IMM16)
			<span class="enscript-keyword">break</span>;
		
		<span class="enscript-keyword">if</span> ((size = dtrace_instr_size(instr)) &lt;= 0)
			<span class="enscript-keyword">break</span>;
		
		instr += size;
	}
	
	<span class="enscript-keyword">if</span> (theInstr != FBT_PUSH_RBP)
		<span class="enscript-keyword">return</span>;
	
	i1 = instr[1];
	i2 = instr[2];
	i3 = instr[3];
	
	limit = (machine_inst_t *)instrHigh;
	
	<span class="enscript-keyword">if</span> (i1 == FBT_REX_RSP_RBP &amp;&amp; i2 == FBT_MOV_RSP_RBP0 &amp;&amp; i3 == FBT_MOV_RSP_RBP1) {
		instr += 1; <span class="enscript-comment">/* Advance to the mov %rsp,%rbp */</span>
		theInstr = i1;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span>;
	}
#<span class="enscript-reference">if</span> 0
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Sometimes, the compiler will schedule an intervening instruction
		 * in the function prologue. Example:
		 *
		 * _mach_vm_read:
		 * 000006d8        pushl   %ebp
		 * 000006d9        movl    $0x00000004,%edx
		 * 000006de        movl    %esp,%ebp
		 * 
		 * Try the next instruction, to see if it is a movl %esp,%ebp
		 */</span>
		
		instr += 1; <span class="enscript-comment">/* Advance past the pushl %ebp */</span>
		<span class="enscript-keyword">if</span> ((size = dtrace_instr_size(instr)) &lt;= 0)
			<span class="enscript-keyword">return</span>;
		
		instr += size;
		
		<span class="enscript-keyword">if</span> ((instr + 1) &gt;= limit)
			<span class="enscript-keyword">return</span>;
		
		i1 = instr[0];
		i2 = instr[1];
		
		<span class="enscript-keyword">if</span> (!(i1 == FBT_MOVL_ESP_EBP0_V0 &amp;&amp; i2 == FBT_MOVL_ESP_EBP1_V0) &amp;&amp;
		    !(i1 == FBT_MOVL_ESP_EBP0_V1 &amp;&amp; i2 == FBT_MOVL_ESP_EBP1_V1))
			<span class="enscript-keyword">return</span>;
		
		<span class="enscript-comment">/* instr already points at the movl %esp,%ebp */</span>
		theInstr = i1;
	}
#<span class="enscript-reference">endif</span>
	thisid = dtrace_probe_lookup(fbt_id, modname, symbolName, FBT_ENTRY);
	newfbt = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (fbt_probe_t), KM_SLEEP);
	strlcpy( (<span class="enscript-type">char</span> *)&amp;(newfbt-&gt;fbtp_name), symbolName, MAX_FBTP_NAME_CHARS );
	
	<span class="enscript-keyword">if</span> (thisid != 0) {
		<span class="enscript-comment">/*
		 * The dtrace_probe previously existed, so we have to hook
		 * the newfbt entry onto the end of the existing fbt's chain.
		 * If we find an fbt entry that was previously patched to
		 * fire, (as indicated by the current patched value), then
		 * we want to enable this newfbt on the spot.
		 */</span>
		entryfbt = dtrace_probe_arg (fbt_id, thisid);
		ASSERT (entryfbt != NULL);
		<span class="enscript-keyword">for</span>(; entryfbt != NULL; entryfbt = entryfbt-&gt;fbtp_next) {
			<span class="enscript-keyword">if</span> (entryfbt-&gt;fbtp_currentval == entryfbt-&gt;fbtp_patchval)
				doenable++;
			
			<span class="enscript-keyword">if</span> (entryfbt-&gt;fbtp_next == NULL) {
				entryfbt-&gt;fbtp_next = newfbt;
				newfbt-&gt;fbtp_id = entryfbt-&gt;fbtp_id;
				<span class="enscript-keyword">break</span>;
			}
		}		    
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * The dtrace_probe did not previously exist, so we
		 * create it and hook in the newfbt.  Since the probe is
		 * new, we obviously do not need to enable it on the spot.
		 */</span>
		newfbt-&gt;fbtp_id = dtrace_probe_create(fbt_id, modname, symbolName, FBT_ENTRY, FBT_AFRAMES_ENTRY, newfbt);
		doenable = 0;
	}
	
	newfbt-&gt;fbtp_patchpoint = instr;
	newfbt-&gt;fbtp_ctl = ctl;
	newfbt-&gt;fbtp_loadcnt = ctl-&gt;mod_loadcnt;
	newfbt-&gt;fbtp_rval = DTRACE_INVOP_MOV_RSP_RBP;
	newfbt-&gt;fbtp_savedval = theInstr;
	newfbt-&gt;fbtp_patchval = FBT_PATCHVAL;
	newfbt-&gt;fbtp_currentval = 0;
	newfbt-&gt;fbtp_hashnext = fbt_probetab[FBT_ADDR2NDX(instr)];
	fbt_probetab[FBT_ADDR2NDX(instr)] = newfbt;
	
	<span class="enscript-keyword">if</span> (doenable)
		fbt_enable(NULL, newfbt-&gt;fbtp_id, newfbt);
	
	<span class="enscript-comment">/*
	 * The fbt entry chain is in place, one entry point per symbol.
	 * The fbt return chain can have multiple return points per symbol.
	 * Here we find the end of the fbt return chain.
	 */</span>
	
	doenable=0;
	
	thisid = dtrace_probe_lookup(fbt_id, modname, symbolName, FBT_RETURN);
	<span class="enscript-keyword">if</span> (thisid != 0) {
		<span class="enscript-comment">/* The dtrace_probe previously existed, so we have to
		 * find the end of the existing fbt chain.  If we find
		 * an fbt return that was previously patched to fire,
		 * (as indicated by the currrent patched value), then
		 * we want to enable any new fbts on the spot.
		 */</span>
		retfbt = dtrace_probe_arg (fbt_id, thisid);
		ASSERT(retfbt != NULL);
		<span class="enscript-keyword">for</span> (;  retfbt != NULL; retfbt =  retfbt-&gt;fbtp_next) {
			<span class="enscript-keyword">if</span> (retfbt-&gt;fbtp_currentval == retfbt-&gt;fbtp_patchval)
				doenable++;
			<span class="enscript-keyword">if</span>(retfbt-&gt;fbtp_next == NULL)
				<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">else</span> {
		doenable = 0;
		retfbt = NULL;
	}
	
<span class="enscript-reference">again</span>:
	<span class="enscript-keyword">if</span> (instr &gt;= limit)
		<span class="enscript-keyword">return</span>;
	
	<span class="enscript-comment">/*
	 * If this disassembly fails, then we've likely walked off into
	 * a jump table or some other unsuitable area.  Bail out of the
	 * disassembly now.
	 */</span>
	<span class="enscript-keyword">if</span> ((size = dtrace_instr_size(instr)) &lt;= 0)
		<span class="enscript-keyword">return</span>;
	
	<span class="enscript-comment">/*
	 * We (desperately) want to avoid erroneously instrumenting a
	 * jump table, especially given that our markers are pretty
	 * short:  two bytes on x86, and just one byte on amd64.  To
	 * determine if we're looking at a true instruction sequence
	 * or an inline jump table that happens to contain the same
	 * byte sequences, we resort to some heuristic sleeze:  we
	 * treat this instruction as being contained within a pointer,
	 * and see if that pointer points to within the body of the
	 * function.  If it does, we refuse to instrument it.
	 */</span>
	<span class="enscript-keyword">for</span> (j = 0; j &lt; <span class="enscript-keyword">sizeof</span> (uintptr_t); j++) {
		uintptr_t check = (uintptr_t)instr - j;
		uint8_t *ptr;
		
		<span class="enscript-keyword">if</span> (check &lt; (uintptr_t)symbolStart)
			<span class="enscript-keyword">break</span>;
		
		<span class="enscript-keyword">if</span> (check + <span class="enscript-keyword">sizeof</span> (uintptr_t) &gt; (uintptr_t)limit)
			<span class="enscript-keyword">continue</span>;
		
		ptr = *(uint8_t **)check;
		
		<span class="enscript-keyword">if</span> (ptr &gt;= (uint8_t *)symbolStart &amp;&amp; ptr &lt; limit) {
			instr += size;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
		}
	}
	
	<span class="enscript-comment">/*
	 * OK, it's an instruction.
	 */</span>
	theInstr = instr[0];
	
	<span class="enscript-comment">/* Walked onto the start of the next routine? If so, bail out of this function. */</span>
	<span class="enscript-keyword">if</span> (theInstr == FBT_PUSH_RBP)
		<span class="enscript-keyword">return</span>;
	
	<span class="enscript-keyword">if</span> (!(size == 1 &amp;&amp; (theInstr == FBT_POP_RBP || theInstr == FBT_LEAVE))) {
		instr += size;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}
	
	<span class="enscript-comment">/*
	 * Found the pop %rbp; or leave.
	 */</span>
	machine_inst_t *patch_instr = instr;
	
	<span class="enscript-comment">/*
	 * Scan forward for a &quot;ret&quot;, or &quot;jmp&quot;.
	 */</span>
	instr += size;
	<span class="enscript-keyword">if</span> (instr &gt;= limit)
		<span class="enscript-keyword">return</span>;
	
	size = dtrace_instr_size(instr);
	<span class="enscript-keyword">if</span> (size &lt;= 0) <span class="enscript-comment">/* Failed instruction decode? */</span>
		<span class="enscript-keyword">return</span>;
	
	theInstr = instr[0];
	
	<span class="enscript-keyword">if</span> (!(size == FBT_RET_LEN &amp;&amp; (theInstr == FBT_RET)) &amp;&amp;
	    !(size == FBT_RET_IMM16_LEN &amp;&amp; (theInstr == FBT_RET_IMM16)) &amp;&amp;
	    !(size == FBT_JMP_SHORT_REL_LEN &amp;&amp; (theInstr == FBT_JMP_SHORT_REL)) &amp;&amp;
	    !(size == FBT_JMP_NEAR_REL_LEN &amp;&amp; (theInstr == FBT_JMP_NEAR_REL)) &amp;&amp;
	    !(size == FBT_JMP_FAR_ABS_LEN &amp;&amp; (theInstr == FBT_JMP_FAR_ABS)))
		<span class="enscript-keyword">return</span>;
	
	<span class="enscript-comment">/*
	 * pop %rbp; ret; or leave; ret; or leave; jmp tailCalledFun; -- We have a winner!
	 */</span>
	newfbt = kmem_zalloc(<span class="enscript-keyword">sizeof</span> (fbt_probe_t), KM_SLEEP);
	strlcpy( (<span class="enscript-type">char</span> *)&amp;(newfbt-&gt;fbtp_name), symbolName, MAX_FBTP_NAME_CHARS );
	
	<span class="enscript-keyword">if</span> (retfbt == NULL) {
		newfbt-&gt;fbtp_id = dtrace_probe_create(fbt_id, modname,
						      symbolName, FBT_RETURN, FBT_AFRAMES_RETURN, newfbt);
	} <span class="enscript-keyword">else</span> {
		retfbt-&gt;fbtp_next = newfbt;
		newfbt-&gt;fbtp_id = retfbt-&gt;fbtp_id;
	}
	
	retfbt = newfbt;
	newfbt-&gt;fbtp_patchpoint = patch_instr;
	newfbt-&gt;fbtp_ctl = ctl;
	newfbt-&gt;fbtp_loadcnt = ctl-&gt;mod_loadcnt;
	
	<span class="enscript-keyword">if</span> (*patch_instr == FBT_POP_RBP) {
		newfbt-&gt;fbtp_rval = DTRACE_INVOP_POP_RBP;
	} <span class="enscript-keyword">else</span> {
		ASSERT(*patch_instr == FBT_LEAVE);
		newfbt-&gt;fbtp_rval = DTRACE_INVOP_LEAVE;
	}
	newfbt-&gt;fbtp_roffset =
	(uintptr_t)(patch_instr - (uint8_t *)symbolStart);
	
	newfbt-&gt;fbtp_savedval = *patch_instr;
	newfbt-&gt;fbtp_patchval = FBT_PATCHVAL;
	newfbt-&gt;fbtp_hashnext = fbt_probetab[FBT_ADDR2NDX(patch_instr)];
	fbt_probetab[FBT_ADDR2NDX(patch_instr)] = newfbt;
	
	<span class="enscript-keyword">if</span> (doenable)
		fbt_enable(NULL, newfbt-&gt;fbtp_id, newfbt);
	
	instr += size;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">__kernel_syms_provide_module</span>(<span class="enscript-type">void</span> *arg, <span class="enscript-type">struct</span> modctl *ctl)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>)
	kernel_mach_header_t		*mh;
	<span class="enscript-type">struct</span> load_command		*cmd;
	kernel_segment_command_t	*orig_ts = NULL, *orig_le = NULL;
	<span class="enscript-type">struct</span> symtab_command		*orig_st = NULL;
	kernel_nlist_t			*sym = NULL;
	<span class="enscript-type">char</span>				*strings;
	uintptr_t			instrLow, instrHigh;
	<span class="enscript-type">char</span>				*modname;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			i;
	
	mh = (kernel_mach_header_t *)(ctl-&gt;mod_address);
	modname = ctl-&gt;mod_modname;
	
	<span class="enscript-keyword">if</span> (mh-&gt;magic != MH_MAGIC_KERNEL)
		<span class="enscript-keyword">return</span>;
	
	cmd = (<span class="enscript-type">struct</span> load_command *) &amp;mh[1];
	<span class="enscript-keyword">for</span> (i = 0; i &lt; mh-&gt;ncmds; i++) {
		<span class="enscript-keyword">if</span> (cmd-&gt;cmd == LC_SEGMENT_KERNEL) {
			kernel_segment_command_t *orig_sg = (kernel_segment_command_t *) cmd;
			
			<span class="enscript-keyword">if</span> (LIT_STRNEQL(orig_sg-&gt;segname, SEG_TEXT))
				orig_ts = orig_sg;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (LIT_STRNEQL(orig_sg-&gt;segname, SEG_LINKEDIT))
				orig_le = orig_sg;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (LIT_STRNEQL(orig_sg-&gt;segname, <span class="enscript-string">&quot;&quot;</span>))
				orig_ts = orig_sg; <span class="enscript-comment">/* kexts have a single unnamed segment */</span>
		}
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd-&gt;cmd == LC_SYMTAB)
			orig_st = (<span class="enscript-type">struct</span> symtab_command *) cmd;
		
		cmd = (<span class="enscript-type">struct</span> load_command *) ((caddr_t) cmd + cmd-&gt;cmdsize);
	}
	
	<span class="enscript-keyword">if</span> ((orig_ts == NULL) || (orig_st == NULL) || (orig_le == NULL))
		<span class="enscript-keyword">return</span>;
	
	sym = (kernel_nlist_t *)(orig_le-&gt;vmaddr + orig_st-&gt;symoff - orig_le-&gt;fileoff);
	strings = (<span class="enscript-type">char</span> *)(orig_le-&gt;vmaddr + orig_st-&gt;stroff - orig_le-&gt;fileoff);
	
	<span class="enscript-comment">/* Find extent of the TEXT section */</span>
	instrLow = (uintptr_t)orig_ts-&gt;vmaddr;
	instrHigh = (uintptr_t)(orig_ts-&gt;vmaddr + orig_ts-&gt;vmsize);
	
	<span class="enscript-keyword">for</span> (i = 0; i &lt; orig_st-&gt;nsyms; i++) {
		uint8_t n_type = sym[i].n_type &amp; (N_TYPE | N_EXT);
		<span class="enscript-type">char</span> *name = strings + sym[i].n_un.n_strx;
		
		<span class="enscript-comment">/* Check that the symbol is a global and that it has a name. */</span>
		<span class="enscript-keyword">if</span> (((N_SECT | N_EXT) != n_type &amp;&amp; (N_ABS | N_EXT) != n_type))
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-keyword">if</span> (0 == sym[i].n_un.n_strx) <span class="enscript-comment">/* iff a null, &quot;&quot;, name. */</span>
			<span class="enscript-keyword">continue</span>;
		
		<span class="enscript-comment">/* Lop off omnipresent leading underscore. */</span>			
		<span class="enscript-keyword">if</span> (*name == <span class="enscript-string">'_'</span>)
			name += 1;
		
		<span class="enscript-comment">/*
		 * We're only blacklisting functions in the kernel for now.
		 */</span>
		<span class="enscript-keyword">if</span> (MOD_IS_MACH_KERNEL(ctl) &amp;&amp; !is_symbol_valid(name))
			<span class="enscript-keyword">continue</span>;
		
		__provide_probe_64(ctl, instrLow, instrHigh, modname, name, (machine_inst_t*)sym[i].n_value);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">__user_syms_provide_module</span>(<span class="enscript-type">void</span> *arg, <span class="enscript-type">struct</span> modctl *ctl)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>)
	<span class="enscript-type">char</span>				*modname;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>			i;
	
	modname = ctl-&gt;mod_modname;
	
	dtrace_module_symbols_t* module_symbols = ctl-&gt;mod_user_symbols;
	<span class="enscript-keyword">if</span> (module_symbols) {
		<span class="enscript-keyword">for</span> (i=0; i&lt;module_symbols-&gt;dtmodsyms_count; i++) {

		        <span class="enscript-comment">/* 
			 * symbol-&gt;dtsym_addr (the symbol address) passed in from
			 * user space, is already slid for both kexts and kernel.
			 */</span>
			dtrace_symbol_t* symbol = &amp;module_symbols-&gt;dtmodsyms_symbols[i];

			<span class="enscript-type">char</span>* name = symbol-&gt;dtsym_name;
			
			<span class="enscript-comment">/* Lop off omnipresent leading underscore. */</span>			
			<span class="enscript-keyword">if</span> (*name == <span class="enscript-string">'_'</span>)
				name += 1;
			
			<span class="enscript-comment">/*
			 * We're only blacklisting functions in the kernel for now.
			 */</span>
                        <span class="enscript-keyword">if</span> (MOD_IS_MACH_KERNEL(ctl) &amp;&amp; !is_symbol_valid(name))
			        <span class="enscript-keyword">continue</span>;
			
			__provide_probe_64(ctl, (uintptr_t)symbol-&gt;dtsym_addr, (uintptr_t)(symbol-&gt;dtsym_addr + symbol-&gt;dtsym_size), modname, name, (machine_inst_t*)(uintptr_t)symbol-&gt;dtsym_addr);
		}
	}
}

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> dtrace_kernel_symbol_mode;

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">fbt_provide_module</span>(<span class="enscript-type">void</span> *arg, <span class="enscript-type">struct</span> modctl *ctl)
{
	ASSERT(ctl != NULL);
	ASSERT(dtrace_kernel_symbol_mode != DTRACE_KERNEL_SYMBOLS_NEVER);
	lck_mtx_assert(&amp;mod_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (MOD_FBT_DONE(ctl))
		<span class="enscript-keyword">return</span>;
	
	<span class="enscript-keyword">if</span> (!is_module_valid(ctl)) {
		ctl-&gt;mod_flags |= MODCTL_FBT_INVALID;
		<span class="enscript-keyword">return</span>;
	}
	
	<span class="enscript-keyword">if</span> (MOD_HAS_KERNEL_SYMBOLS(ctl)) {
		__kernel_syms_provide_module(arg, ctl);
		ctl-&gt;mod_flags |= MODCTL_FBT_PROBES_PROVIDED;
		<span class="enscript-keyword">return</span>;
	}
	
	<span class="enscript-keyword">if</span> (MOD_HAS_USERSPACE_SYMBOLS(ctl)) {
		__user_syms_provide_module(arg, ctl);
		ctl-&gt;mod_flags |= MODCTL_FBT_PROBES_PROVIDED;
		<span class="enscript-keyword">if</span> (MOD_FBT_PROVIDE_PRIVATE_PROBES(ctl))
			ctl-&gt;mod_flags |= MODCTL_FBT_PRIVATE_PROBES_PROVIDED;
		<span class="enscript-keyword">return</span>;
	}	
}
</pre>
<hr />
</body></html>