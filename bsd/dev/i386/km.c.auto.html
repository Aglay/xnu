<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>km.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">km.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* 	Copyright (c) 1992 NeXT Computer, Inc.  All rights reserved. 
 *
 * km.m - kernel keyboard/monitor module, procedural interface.
 *
 * HISTORY
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/tty.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/cons.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>		<span class="enscript-comment">/* for kmopen */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>		
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>		<span class="enscript-comment">/* for kmopen */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/msgbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/kmreg_com.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/i386/boot.h&gt;</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> hz;

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cnputcusr</span>(<span class="enscript-type">char</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">cngetc</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span>	kminit(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	cons_cinput(<span class="enscript-type">char</span> ch);

<span class="enscript-comment">/*
 * 'Global' variables, shared only by this file and conf.c.
 */</span>
<span class="enscript-type">struct</span> tty *km_tty[1] = { 0 };

<span class="enscript-comment">/*
 * this works early on, after initialize_screen() but before autoconf (and thus
 * before we have a kmDevice).
 */</span>
<span class="enscript-type">int</span> disableConsoleOutput;

<span class="enscript-comment">/*
 * 'Global' variables, shared only by this file and kmDevice.m.
 */</span>
<span class="enscript-type">int</span> initialized = 0;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kmoutput</span>(<span class="enscript-type">struct</span> tty *tp);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kmstart</span>(<span class="enscript-type">struct</span> tty *tp);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">KeyboardOpen</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span>
<span class="enscript-function-name">kminit</span>(<span class="enscript-type">void</span>)
{
	km_tty[0] = ttymalloc();
   	km_tty[0]-&gt;t_dev = makedev(12, 0);
	initialized = 1;
}

<span class="enscript-comment">/*
 * cdevsw interface to km driver.
 */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">kmopen</span>(dev_t dev, <span class="enscript-type">int</span> flag, __unused <span class="enscript-type">int</span> devtype, proc_t pp)
{
	<span class="enscript-type">int</span> unit;
	<span class="enscript-type">struct</span> tty *tp;
	<span class="enscript-type">struct</span> winsize *wp;
	<span class="enscript-type">int</span> ret;
	
	unit = minor(dev);
	<span class="enscript-keyword">if</span>(unit &gt;= 1)
		<span class="enscript-keyword">return</span> (ENXIO);

	tp = km_tty[unit];

	tty_lock(tp);

	tp-&gt;t_oproc = kmstart;
	tp-&gt;t_param = NULL;
	tp-&gt;t_dev = dev;
	
	<span class="enscript-keyword">if</span> ( !(tp-&gt;t_state &amp; TS_ISOPEN) ) {
		tp-&gt;t_iflag = TTYDEF_IFLAG;
		tp-&gt;t_oflag = TTYDEF_OFLAG;
		tp-&gt;t_cflag = (CREAD | CS8 | CLOCAL);
		tp-&gt;t_lflag = TTYDEF_LFLAG;
		tp-&gt;t_ispeed = tp-&gt;t_ospeed = TTYDEF_SPEED;
		termioschars(&amp;tp-&gt;t_termios);
		ttsetwater(tp);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((tp-&gt;t_state &amp; TS_XCLUDE) &amp;&amp; proc_suser(pp)) {
		ret = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	tp-&gt;t_state |= TS_CARR_ON; <span class="enscript-comment">/* lie and say carrier exists and is on. */</span>

	ret = ((*linesw[tp-&gt;t_line].l_open)(dev, tp));
	{
		PE_Video video;
		wp = &amp;tp-&gt;t_winsize;
		<span class="enscript-comment">/*
		* Magic numbers.  These are CHARWIDTH and CHARHEIGHT
		 * from pexpert/i386/video_console.c
		 */</span>
		wp-&gt;ws_xpixel = 8;
		wp-&gt;ws_ypixel = 16;

		tty_unlock(tp);		<span class="enscript-comment">/* XXX race window */</span>

		<span class="enscript-keyword">if</span> (flag &amp; O_POPUP)
			PE_initialize_console(0, kPETextScreen);

		bzero(&amp;video, <span class="enscript-keyword">sizeof</span>(video));
		PE_current_console(&amp;video);

		tty_lock(tp);

                <span class="enscript-keyword">if</span>( video.v_display == FB_TEXT_MODE &amp;&amp; video.v_width != 0 &amp;&amp; video.v_height != 0 ) {
			wp-&gt;ws_col = video.v_width / wp-&gt;ws_xpixel;
			wp-&gt;ws_row = video.v_height / wp-&gt;ws_ypixel;
		} <span class="enscript-keyword">else</span> {
			wp-&gt;ws_col = 100;
			wp-&gt;ws_row = 36;
		}
	}

<span class="enscript-reference">out</span>:
	tty_unlock(tp);

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">kmclose</span>(dev_t dev, <span class="enscript-type">int</span> flag, __unused <span class="enscript-type">int</span> mode, __unused proc_t p)
{
	<span class="enscript-type">int</span> ret;
	<span class="enscript-type">struct</span> tty *tp = km_tty[minor(dev)];

	tty_lock(tp);
	ret = (*linesw[tp-&gt;t_line].l_close)(tp,flag);
	ttyclose(tp);
	tty_unlock(tp);

	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">kmread</span>(dev_t dev, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> ioflag)
{
	<span class="enscript-type">int</span> ret;
	<span class="enscript-type">struct</span> tty *tp = km_tty[minor(dev)];

	tty_lock(tp);
	ret = (*linesw[tp-&gt;t_line].l_read)(tp, uio, ioflag);
	tty_unlock(tp);

	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">kmwrite</span>(dev_t dev, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> ioflag)
{
	<span class="enscript-type">int</span> ret;
	<span class="enscript-type">struct</span> tty *tp = km_tty[minor(dev)];

	tty_lock(tp);
	ret = (*linesw[tp-&gt;t_line].l_write)(tp, uio, ioflag);
	tty_unlock(tp);

	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">kmioctl</span>(dev_t dev, u_long cmd, caddr_t data, <span class="enscript-type">int</span> flag, proc_t p)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> tty *tp = km_tty[minor(dev)];
	<span class="enscript-type">struct</span> winsize *wp;

	tty_lock(tp);
	
	<span class="enscript-keyword">switch</span> (cmd) {
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">KMIOCSIZE</span>:
		wp = (<span class="enscript-type">struct</span> winsize *)data;
		*wp = tp-&gt;t_winsize;
		<span class="enscript-keyword">break</span>;
		
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TIOCSWINSZ</span>:
		<span class="enscript-comment">/* Prevent changing of console size --
		 * this ensures that login doesn't revert to the
		 * termcap-defined size
		 */</span>
		error = EINVAL;
		<span class="enscript-keyword">break</span>;

	    <span class="enscript-comment">/* Bodge in the CLOCAL flag as the km device is always local */</span>
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TIOCSETA_32</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TIOCSETAW_32</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TIOCSETAF_32</span>:
		{
			<span class="enscript-type">struct</span> termios32 *t = (<span class="enscript-type">struct</span> termios32 *)data;
			t-&gt;c_cflag |= CLOCAL;
			<span class="enscript-comment">/* No Break */</span>
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fallthrough</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TIOCSETA_64</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TIOCSETAW_64</span>:
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">TIOCSETAF_64</span>:
		{
			<span class="enscript-type">struct</span> user_termios *t = (<span class="enscript-type">struct</span> user_termios *)data;
			t-&gt;c_cflag |= CLOCAL;
			<span class="enscript-comment">/* No Break */</span>
		}
<span class="enscript-reference">fallthrough</span>:
	    <span class="enscript-reference">default</span>:		
		error = (*linesw[tp-&gt;t_line].l_ioctl)(tp, cmd, data, flag, p);
		<span class="enscript-keyword">if</span> (ENOTTY != error)
			<span class="enscript-keyword">break</span>;
		error = ttioctl_locked(tp, cmd, data, flag, p);
		<span class="enscript-keyword">break</span>;
	}

	tty_unlock(tp);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * kmputc
 *
 * Output a character to the serial console driver via cnputcusr(),
 * which is exported by that driver.
 *
 * Locks:       Assumes tp in the calling tty driver code is locked on
 *              entry, remains locked on exit
 *
 * Notes:       Called from kmoutput(); giving the locking output
 *              assumptions here, this routine should be static (and
 *              inlined, given there is only one call site).
 */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">kmputc</span>(__unused dev_t dev, <span class="enscript-type">char</span> c)
{
	<span class="enscript-keyword">if</span>(!disableConsoleOutput &amp;&amp; initialized) {
		<span class="enscript-comment">/* OCRNL */</span>
		<span class="enscript-keyword">if</span>(c == <span class="enscript-string">'\n'</span>)
			cnputcusr(<span class="enscript-string">'\r'</span>);
		cnputcusr(c);
	}

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Callouts from linesw.
 */</span>
 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KM_LOWAT_DELAY</span>	((ns_time_t)1000)

<span class="enscript-comment">/*
 * t_oproc for this driver; called from within the line discipline
 *
 * Locks:	Assumes tp is locked on entry, remains locked on exit
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">kmstart</span>(<span class="enscript-type">struct</span> tty *tp)
{
	<span class="enscript-keyword">if</span> (tp-&gt;t_state &amp; (TS_TIMEOUT | TS_BUSY | TS_TTSTOP))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> (tp-&gt;t_outq.c_cc == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	tp-&gt;t_state |= TS_BUSY;
	kmoutput(tp);
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">out</span>:
	(*linesw[tp-&gt;t_line].l_start)(tp);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/* 
 * One-shot output retry timeout from kmoutput(); re-calls kmoutput() at
 * intervals until the output queue for the tty is empty, at which point
 * the timeout is not rescheduled by kmoutput()
 * 
 * This function must take the tty_lock() around the kmoutput() call; it
 * ignores the return value.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kmtimeout</span>(<span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> tty	*tp = (<span class="enscript-type">struct</span> tty *)arg;

	tty_lock(tp);
	(<span class="enscript-type">void</span>)kmoutput(tp);
	tty_unlock(tp);
}

<span class="enscript-comment">/*
 * kmoutput
 *
 * Locks:	Assumes tp is locked on entry, remains locked on exit
 *
 * Notes:	Called from kmstart() and kmtimeout(); kmtimeout() is a
 *		timer initiated by this routine to deal with pending
 *		output not yet flushed (output is flushed at a maximum
 *		of sizeof(buf) charatcers at a time before dropping into
 *		the timeout code).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">kmoutput</span>(<span class="enscript-type">struct</span> tty *tp)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> 	buf[80];	<span class="enscript-comment">/* buffer; limits output per call */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>	*cp;
	<span class="enscript-type">int</span> 		cc = -1;


	<span class="enscript-comment">/* While there is data available to be output... */</span>
	<span class="enscript-keyword">while</span> (tp-&gt;t_outq.c_cc &gt; 0) {
		cc = ndqb(&amp;tp-&gt;t_outq, 0);
		<span class="enscript-keyword">if</span> (cc == 0)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/*
		 * attempt to output as many characters as are available,
		 * up to the available transfer buffer size.
		 */</span>
		cc = min(cc, <span class="enscript-keyword">sizeof</span>(buf));
		<span class="enscript-comment">/* copy the output queue contents to the buffer */</span>
		(<span class="enscript-type">void</span>) q_to_b(&amp;tp-&gt;t_outq, buf, cc);
		<span class="enscript-keyword">for</span> (cp = buf; cp &lt; &amp;buf[cc]; cp++) {
			<span class="enscript-comment">/* output the buffer one charatcer at a time */</span>
			kmputc(tp-&gt;t_dev, *cp &amp; 0x7f);
		}
	}
	<span class="enscript-comment">/*
	 * XXX This is likely not necessary, as the tty output queue is not
	 * XXX writeable while we hold the tty_lock().
	 */</span>
        <span class="enscript-keyword">if</span> (tp-&gt;t_outq.c_cc &gt; 0) {
		timeout(kmtimeout, tp, hz);
	}
	tp-&gt;t_state &amp;= ~TS_BUSY;
	<span class="enscript-comment">/* Start the output processing for the line discipline */</span>
	(*linesw[tp-&gt;t_line].l_start)(tp);

	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/*
 * cons_cinput
 *
 * Driver character input from the polled mode serial console driver calls
 * this routine to input a character from the serial driver into the tty
 * line discipline specific input processing receiv interrupt routine,
 * l_rint().
 *
 * Locks:       Assumes that the tty_lock() is NOT held on the tp, so a
 *              serial driver should NOT call this function as a result
 *              of being called from a function which already holds the
 *              lock; ECHOE will be handled at the line discipline, if
 *              output echo processing is going to occur.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">cons_cinput</span>(<span class="enscript-type">char</span> ch)
{
	<span class="enscript-type">struct</span> tty *tp = km_tty[0];	<span class="enscript-comment">/* XXX */</span>

	tty_lock(tp);
	(*linesw[tp-&gt;t_line].l_rint) (ch, tp);
	tty_unlock(tp);
}
</pre>
<hr />
</body></html>