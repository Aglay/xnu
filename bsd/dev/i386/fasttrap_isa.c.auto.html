<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>fasttrap_isa.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">fasttrap_isa.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the &quot;License&quot;).
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or <a href="http://www.opensolaris.org/os/licensing.">http://www.opensolaris.org/os/licensing.</a>
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets &quot;[]&quot; replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */</span>

<span class="enscript-comment">/*
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */</span>

<span class="enscript-comment">/*
 * #pragma ident	&quot;@(#)fasttrap_isa.c	1.27	08/04/09 SMI&quot;
 */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_KERNEL</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_KERNEL</span> <span class="enscript-comment">/* Solaris vs. Darwin */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fasttrap_isa.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fasttrap_impl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace_impl.h&gt;</span>
<span class="enscript-type">extern</span> dtrace_id_t dtrace_probeid_error;

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;fasttrap_regset.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace_ptss.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/pal_routines.h&gt;</span>

<span class="enscript-comment">/* Solaris proc_t is the struct. Darwin's proc_t is a pointer to it. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">proc_t</span> struct proc <span class="enscript-comment">/* Steer clear of the Darwin typedef for proc_t */</span>

<span class="enscript-comment">/*
 * Lossless User-Land Tracing on x86
 * ---------------------------------
 *
 * The execution of most instructions is not dependent on the address; for
 * these instructions it is sufficient to copy them into the user process's
 * address space and execute them. To effectively single-step an instruction
 * in user-land, we copy out the following sequence of instructions to scratch
 * space in the user thread's ulwp_t structure.
 *
 * We then set the program counter (%eip or %rip) to point to this scratch
 * space. Once execution resumes, the original instruction is executed and
 * then control flow is redirected to what was originally the subsequent
 * instruction. If the kernel attemps to deliver a signal while single-
 * stepping, the signal is deferred and the program counter is moved into the
 * second sequence of instructions. The second sequence ends in a trap into
 * the kernel where the deferred signal is then properly handled and delivered.
 *
 * For instructions whose execute is position dependent, we perform simple
 * emulation. These instructions are limited to control transfer
 * instructions in 32-bit mode, but in 64-bit mode there's the added wrinkle
 * of %rip-relative addressing that means that almost any instruction can be
 * position dependent. For all the details on how we emulate generic
 * instructions included %rip-relative instructions, see the code in
 * fasttrap_pid_probe() below where we handle instructions of type
 * FASTTRAP_T_COMMON (under the header: Generic Instruction Tracing).
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">FASTTRAP_MODRM_MOD</span>(modrm)	(((modrm) &gt;&gt; 6) &amp; 0x3)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">FASTTRAP_MODRM_REG</span>(modrm)	(((modrm) &gt;&gt; 3) &amp; 0x7)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">FASTTRAP_MODRM_RM</span>(modrm)	((modrm) &amp; 0x7)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">FASTTRAP_MODRM</span>(mod, reg, rm)	(((mod) &lt;&lt; 6) | ((reg) &lt;&lt; 3) | (rm))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">FASTTRAP_SIB_SCALE</span>(sib)		(((sib) &gt;&gt; 6) &amp; 0x3)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">FASTTRAP_SIB_INDEX</span>(sib)		(((sib) &gt;&gt; 3) &amp; 0x7)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">FASTTRAP_SIB_BASE</span>(sib)		((sib) &amp; 0x7)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">FASTTRAP_REX_W</span>(rex)		(((rex) &gt;&gt; 3) &amp; 1)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">FASTTRAP_REX_R</span>(rex)		(((rex) &gt;&gt; 2) &amp; 1)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">FASTTRAP_REX_X</span>(rex)		(((rex) &gt;&gt; 1) &amp; 1)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">FASTTRAP_REX_B</span>(rex)		((rex) &amp; 1)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">FASTTRAP_REX</span>(w, r, x, b)	\
	(0x40 | ((w) &lt;&lt; 3) | ((r) &lt;&lt; 2) | ((x) &lt;&lt; 1) | (b))

<span class="enscript-comment">/*
 * Single-byte op-codes.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_PUSHL_EBP</span>	0x55

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JO</span>		0x70
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JNO</span>		0x71
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JB</span>		0x72
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JAE</span>		0x73
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JE</span>		0x74
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JNE</span>		0x75
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JBE</span>		0x76
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JA</span>		0x77
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JS</span>		0x78
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JNS</span>		0x79
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JP</span>		0x7a
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JNP</span>		0x7b
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JL</span>		0x7c
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JGE</span>		0x7d
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JLE</span>		0x7e
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JG</span>		0x7f

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_NOP</span>		0x90

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_MOV_EAX</span>	0xb8
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_MOV_ECX</span>	0xb9

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_RET16</span>		0xc2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_RET</span>		0xc3

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_LOOPNZ</span>		0xe0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_LOOPZ</span>		0xe1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_LOOP</span>		0xe2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JCXZ</span>		0xe3

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_CALL</span>		0xe8
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JMP32</span>		0xe9
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_JMP8</span>		0xeb

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_INT3</span>		0xcc
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_INT</span>		0xcd
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">T_DTRACE_RET</span>		0x7f

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_2_BYTE_OP</span>	0x0f
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_GROUP5_OP</span>	0xff

<span class="enscript-comment">/*
 * Two-byte op-codes (second byte only).
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JO</span>		0x80
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JNO</span>		0x81
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JB</span>		0x82
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JAE</span>		0x83
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JE</span>		0x84
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JNE</span>		0x85
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JBE</span>		0x86
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JA</span>		0x87
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JS</span>		0x88
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JNS</span>		0x89
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JP</span>		0x8a
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JNP</span>		0x8b
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JL</span>		0x8c
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JGE</span>		0x8d
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JLE</span>		0x8e
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_0F_JG</span>		0x8f

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_EFLAGS_OF</span>	0x800
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_EFLAGS_DF</span>	0x400
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_EFLAGS_SF</span>	0x080
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_EFLAGS_ZF</span>	0x040
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_EFLAGS_AF</span>	0x010
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_EFLAGS_PF</span>	0x004
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_EFLAGS_CF</span>	0x001

<span class="enscript-comment">/*
 * Instruction prefixes.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_PREFIX_OPERAND</span>	0x66
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_PREFIX_ADDRESS</span>	0x67
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_PREFIX_CS</span>	0x2E
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_PREFIX_DS</span>	0x3E
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_PREFIX_ES</span>	0x26
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_PREFIX_FS</span>	0x64
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_PREFIX_GS</span>	0x65
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_PREFIX_SS</span>	0x36
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_PREFIX_LOCK</span>	0xF0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_PREFIX_REP</span>	0xF3
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_PREFIX_REPNE</span>	0xF2

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">FASTTRAP_NOREG</span>	0xff

<span class="enscript-comment">/*
 * Map between instruction register encodings and the kernel constants which
 * correspond to indicies into struct regs.
 */</span>

<span class="enscript-comment">/*
 * APPLE NOTE: We are cheating here. The regmap is used to decode which register
 * a given instruction is trying to reference. OS X does not have extended registers
 * for 32 bit apps, but the *order* is the same. So for 32 bit state, we will return:
 *
 * REG_RAX -&gt; EAX
 * REG_RCX -&gt; ECX
 * REG_RDX -&gt; EDX
 * REG_RBX -&gt; EBX
 * REG_RSP -&gt; UESP
 * REG_RBP -&gt; EBP
 * REG_RSI -&gt; ESI
 * REG_RDI -&gt; EDI
 *
 * The fasttrap_getreg function knows how to make the correct transformation.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> uint8_t regmap[16] = {
	REG_RAX, REG_RCX, REG_RDX, REG_RBX, REG_RSP, REG_RBP, REG_RSI, REG_RDI,
	REG_R8, REG_R9, REG_R10, REG_R11, REG_R12, REG_R13, REG_R14, REG_R15,
};

<span class="enscript-type">static</span> user_addr_t <span class="enscript-function-name">fasttrap_getreg</span>(x86_saved_state_t *, uint_t);

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">fasttrap_anarg</span>(x86_saved_state_t *regs, <span class="enscript-type">int</span> function_entry, <span class="enscript-type">int</span> argno)
{
	uint64_t value;
	<span class="enscript-type">int</span> shift = function_entry ? 1 : 0;

	x86_saved_state64_t *regs64;
	x86_saved_state32_t *regs32;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> p_model;

        <span class="enscript-keyword">if</span> (is_saved_state64(regs)) {
                regs64 = saved_state64(regs);
		regs32 = NULL;
		p_model = DATAMODEL_LP64;
        } <span class="enscript-keyword">else</span> {
		regs64 = NULL;
                regs32 = saved_state32(regs);
		p_model = DATAMODEL_ILP32;
        }

	<span class="enscript-keyword">if</span> (p_model == DATAMODEL_LP64) {
		user_addr_t stack;
		
		<span class="enscript-comment">/*
		 * In 64-bit mode, the first six arguments are stored in
		 * registers.
		 */</span>
		<span class="enscript-keyword">if</span> (argno &lt; 6)
			<span class="enscript-keyword">return</span> ((&amp;regs64-&gt;rdi)[argno]);

		stack = regs64-&gt;isf.rsp + <span class="enscript-keyword">sizeof</span>(uint64_t) * (argno - 6 + shift);
		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
		value = dtrace_fuword64(stack);
		DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT | CPU_DTRACE_BADADDR);
	} <span class="enscript-keyword">else</span> {
		uint32_t *stack = (uint32_t *)(uintptr_t)(regs32-&gt;uesp);
		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
		value = dtrace_fuword32((user_addr_t)(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)&amp;stack[argno + shift]);
		DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT | CPU_DTRACE_BADADDR);
	}

	<span class="enscript-keyword">return</span> (value);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fasttrap_tracepoint_init</span>(proc_t *p, fasttrap_tracepoint_t *tp, user_addr_t pc,
    fasttrap_probe_type_t type)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">type</span>)
	uint8_t instr[FASTTRAP_MAX_INSTR_SIZE + 10];
	size_t len = FASTTRAP_MAX_INSTR_SIZE;
	size_t first = MIN(len, PAGE_SIZE - (pc &amp; PAGE_MASK));
	uint_t start = 0;
	size_t size;
	<span class="enscript-type">int</span> rmindex;
	uint8_t seg, rex = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> p_model = (p-&gt;p_flag &amp; P_LP64) ? DATAMODEL_LP64 : DATAMODEL_ILP32;

	<span class="enscript-comment">/*
	 * Read the instruction at the given address out of the process's
	 * address space. We don't have to worry about a debugger
	 * changing this instruction before we overwrite it with our trap
	 * instruction since P_PR_LOCK is set. Since instructions can span
	 * pages, we potentially read the instruction in two parts. If the
	 * second part fails, we just zero out that part of the instruction.
	 */</span>
	<span class="enscript-comment">/*
	 * APPLE NOTE: Of course, we do not have a P_PR_LOCK, so this is racey...
	 */</span>
	<span class="enscript-keyword">if</span> (uread(p, &amp;instr[0], first, pc) != 0)
		<span class="enscript-keyword">return</span> (-1);
	<span class="enscript-keyword">if</span> (len &gt; first &amp;&amp;
	    uread(p, &amp;instr[first], len - first, pc + first) != 0) {
		bzero(&amp;instr[first], len - first);
		len = first;
	}

	<span class="enscript-comment">/*
	 * If the disassembly fails, then we have a malformed instruction.
	 */</span>
	<span class="enscript-keyword">if</span> ((size = dtrace_instr_size_isa(instr, p_model, &amp;rmindex)) &lt;= 0)
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-comment">/*
	 * Make sure the disassembler isn't completely broken.
	 */</span>
	ASSERT(-1 &lt;= rmindex &amp;&amp; rmindex &lt; (<span class="enscript-type">int</span>)size);

	<span class="enscript-comment">/*
	 * If the computed size is greater than the number of bytes read,
	 * then it was a malformed instruction possibly because it fell on a
	 * page boundary and the subsequent page was missing or because of
	 * some malicious user.
	 */</span>
	<span class="enscript-keyword">if</span> (size &gt; len)
		<span class="enscript-keyword">return</span> (-1);

	tp-&gt;ftt_size = (uint8_t)size;
	tp-&gt;ftt_segment = FASTTRAP_SEG_NONE;

	<span class="enscript-comment">/*
	 * Find the start of the instruction's opcode by processing any
	 * legacy prefixes.
	 */</span>
	<span class="enscript-keyword">for</span> (;;) {
		seg = 0;
		<span class="enscript-keyword">switch</span> (instr[start]) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_PREFIX_SS</span>:
			seg++;
			<span class="enscript-comment">/*FALLTHRU*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_PREFIX_GS</span>:
			seg++;
			<span class="enscript-comment">/*FALLTHRU*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_PREFIX_FS</span>:
			seg++;
			<span class="enscript-comment">/*FALLTHRU*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_PREFIX_ES</span>:
			seg++;
			<span class="enscript-comment">/*FALLTHRU*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_PREFIX_DS</span>:
			seg++;
			<span class="enscript-comment">/*FALLTHRU*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_PREFIX_CS</span>:
			seg++;
			<span class="enscript-comment">/*FALLTHRU*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_PREFIX_OPERAND</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_PREFIX_ADDRESS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_PREFIX_LOCK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_PREFIX_REP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_PREFIX_REPNE</span>:
			<span class="enscript-keyword">if</span> (seg != 0) {
				<span class="enscript-comment">/*
				 * It's illegal for an instruction to specify
				 * two segment prefixes -- give up on this
				 * illegal instruction.
				 */</span>
				<span class="enscript-keyword">if</span> (tp-&gt;ftt_segment != FASTTRAP_SEG_NONE)
					<span class="enscript-keyword">return</span> (-1);

				tp-&gt;ftt_segment = seg;
			}
			start++;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * Identify the REX prefix on 64-bit processes.
	 */</span>
	<span class="enscript-keyword">if</span> (p_model == DATAMODEL_LP64 &amp;&amp; (instr[start] &amp; 0xf0) == 0x40)
		rex = instr[start++];

	<span class="enscript-comment">/*
	 * Now that we're pretty sure that the instruction is okay, copy the
	 * valid part to the tracepoint.
	 */</span>
	bcopy(instr, tp-&gt;ftt_instr, FASTTRAP_MAX_INSTR_SIZE);

	tp-&gt;ftt_type = FASTTRAP_T_COMMON;
	<span class="enscript-keyword">if</span> (instr[start] == FASTTRAP_2_BYTE_OP) {
		<span class="enscript-keyword">switch</span> (instr[start + 1]) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JNO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JAE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JNE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JBE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JNS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JNP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JGE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JLE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_0F_JG</span>:
			tp-&gt;ftt_type = FASTTRAP_T_JCC;
			tp-&gt;ftt_code = (instr[start + 1] &amp; 0x0f) | FASTTRAP_JO;
			tp-&gt;ftt_dest = pc + tp-&gt;ftt_size +
			    <span class="enscript-comment">/* LINTED - alignment */</span>
			    *(int32_t *)&amp;instr[start + 2];
			<span class="enscript-keyword">break</span>;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (instr[start] == FASTTRAP_GROUP5_OP) {
		uint_t mod = FASTTRAP_MODRM_MOD(instr[start + 1]);
		uint_t reg = FASTTRAP_MODRM_REG(instr[start + 1]);
		uint_t rm = FASTTRAP_MODRM_RM(instr[start + 1]);

		<span class="enscript-keyword">if</span> (reg == 2 || reg == 4) {
			uint_t i, sz;

			<span class="enscript-keyword">if</span> (reg == 2)
				tp-&gt;ftt_type = FASTTRAP_T_CALL;
			<span class="enscript-keyword">else</span>
				tp-&gt;ftt_type = FASTTRAP_T_JMP;

			<span class="enscript-keyword">if</span> (mod == 3)
				tp-&gt;ftt_code = 2;
			<span class="enscript-keyword">else</span>
				tp-&gt;ftt_code = 1;

			ASSERT(p_model == DATAMODEL_LP64 || rex == 0);

			<span class="enscript-comment">/*
			 * See AMD x86-64 Architecture Programmer's Manual
			 * Volume 3, Section 1.2.7, Table 1-12, and
			 * Appendix A.3.1, Table A-15.
			 */</span>
			<span class="enscript-keyword">if</span> (mod != 3 &amp;&amp; rm == 4) {
				uint8_t sib = instr[start + 2];
				uint_t index = FASTTRAP_SIB_INDEX(sib);
				uint_t base = FASTTRAP_SIB_BASE(sib);

				tp-&gt;ftt_scale = FASTTRAP_SIB_SCALE(sib);

				tp-&gt;ftt_index = (index == 4) ?
				    FASTTRAP_NOREG :
				    regmap[index | (FASTTRAP_REX_X(rex) &lt;&lt; 3)];
				tp-&gt;ftt_base = (mod == 0 &amp;&amp; base == 5) ?
				    FASTTRAP_NOREG :
				    regmap[base | (FASTTRAP_REX_B(rex) &lt;&lt; 3)];

				i = 3;
				sz = mod == 1 ? 1 : 4;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * In 64-bit mode, mod == 0 and r/m == 5
				 * denotes %rip-relative addressing; in 32-bit
				 * mode, the base register isn't used. In both
				 * modes, there is a 32-bit operand.
				 */</span>
				<span class="enscript-keyword">if</span> (mod == 0 &amp;&amp; rm == 5) {
					<span class="enscript-keyword">if</span> (p_model == DATAMODEL_LP64)
						tp-&gt;ftt_base = REG_RIP;
					<span class="enscript-keyword">else</span>
						tp-&gt;ftt_base = FASTTRAP_NOREG;
					sz = 4;
				} <span class="enscript-keyword">else</span>  {
					uint8_t base = rm |
					    (FASTTRAP_REX_B(rex) &lt;&lt; 3);

					tp-&gt;ftt_base = regmap[base];
					sz = mod == 1 ? 1 : mod == 2 ? 4 : 0;
				}
				tp-&gt;ftt_index = FASTTRAP_NOREG;
				i = 2;
			}

			<span class="enscript-keyword">if</span> (sz == 1) {
				tp-&gt;ftt_dest = *(int8_t *)&amp;instr[start + i];
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sz == 4) {
				<span class="enscript-comment">/* LINTED - alignment */</span>
				tp-&gt;ftt_dest = *(int32_t *)&amp;instr[start + i];
			} <span class="enscript-keyword">else</span> {
				tp-&gt;ftt_dest = 0;
			}
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">switch</span> (instr[start]) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_RET</span>:
			tp-&gt;ftt_type = FASTTRAP_T_RET;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_RET16</span>:
			tp-&gt;ftt_type = FASTTRAP_T_RET16;
			<span class="enscript-comment">/* LINTED - alignment */</span>
			tp-&gt;ftt_dest = *(uint16_t *)&amp;instr[start + 1];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JNO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JB</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JAE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JNE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JBE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JNS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JNP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JGE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JLE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JG</span>:
			tp-&gt;ftt_type = FASTTRAP_T_JCC;
			tp-&gt;ftt_code = instr[start];
			tp-&gt;ftt_dest = pc + tp-&gt;ftt_size +
			    (int8_t)instr[start + 1];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_LOOPNZ</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_LOOPZ</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_LOOP</span>:
			tp-&gt;ftt_type = FASTTRAP_T_LOOP;
			tp-&gt;ftt_code = instr[start];
			tp-&gt;ftt_dest = pc + tp-&gt;ftt_size +
			    (int8_t)instr[start + 1];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JCXZ</span>:
			tp-&gt;ftt_type = FASTTRAP_T_JCXZ;
			tp-&gt;ftt_dest = pc + tp-&gt;ftt_size +
			    (int8_t)instr[start + 1];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_CALL</span>:
			tp-&gt;ftt_type = FASTTRAP_T_CALL;
			tp-&gt;ftt_dest = pc + tp-&gt;ftt_size +
			    <span class="enscript-comment">/* LINTED - alignment */</span>
			    *(int32_t *)&amp;instr[start + 1];
			tp-&gt;ftt_code = 0;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JMP32</span>:
			tp-&gt;ftt_type = FASTTRAP_T_JMP;
			tp-&gt;ftt_dest = pc + tp-&gt;ftt_size +
				<span class="enscript-comment">/* LINTED - alignment */</span>
			    *(int32_t *)&amp;instr[start + 1];
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JMP8</span>:
			tp-&gt;ftt_type = FASTTRAP_T_JMP;
			tp-&gt;ftt_dest = pc + tp-&gt;ftt_size +
			    (int8_t)instr[start + 1];
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_PUSHL_EBP</span>:
			<span class="enscript-keyword">if</span> (start == 0)
				tp-&gt;ftt_type = FASTTRAP_T_PUSHL_EBP;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_NOP</span>:
			ASSERT(p_model == DATAMODEL_LP64 || rex == 0);

			<span class="enscript-comment">/*
			 * On sol64 we have to be careful not to confuse a nop
			 * (actually xchgl %eax, %eax) with an instruction using
			 * the same opcode, but that does something different
			 * (e.g. xchgl %r8d, %eax or xcghq %r8, %rax).
			 */</span>
			<span class="enscript-keyword">if</span> (FASTTRAP_REX_B(rex) == 0)
				tp-&gt;ftt_type = FASTTRAP_T_NOP;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_INT3</span>:
			<span class="enscript-comment">/*
			 * The pid provider shares the int3 trap with debugger
			 * breakpoints so we can't instrument them.
			 */</span>
			ASSERT(instr[start] == FASTTRAP_INSTR);
			<span class="enscript-keyword">return</span> (-1);

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_INT</span>:
			<span class="enscript-comment">/*
			 * Interrupts seem like they could be traced with
			 * no negative implications, but it's possible that
			 * a thread could be redirected by the trap handling
			 * code which would eventually return to the
			 * instruction after the interrupt. If the interrupt
			 * were in our scratch space, the subsequent
			 * instruction might be overwritten before we return.
			 * Accordingly we refuse to instrument any interrupt.
			 */</span>
			<span class="enscript-keyword">return</span> (-1);
		}
	}

	<span class="enscript-keyword">if</span> (p_model == DATAMODEL_LP64 &amp;&amp; tp-&gt;ftt_type == FASTTRAP_T_COMMON) {
		<span class="enscript-comment">/*
		 * If the process is 64-bit and the instruction type is still
		 * FASTTRAP_T_COMMON -- meaning we're going to copy it out an
		 * execute it -- we need to watch for %rip-relative
		 * addressing mode. See the portion of fasttrap_pid_probe()
		 * below where we handle tracepoints with type
		 * FASTTRAP_T_COMMON for how we emulate instructions that
		 * employ %rip-relative addressing.
		 */</span>
		<span class="enscript-keyword">if</span> (rmindex != -1) {
			uint_t mod = FASTTRAP_MODRM_MOD(instr[rmindex]);
			uint_t reg = FASTTRAP_MODRM_REG(instr[rmindex]);
			uint_t rm = FASTTRAP_MODRM_RM(instr[rmindex]);

			ASSERT(rmindex &gt; (<span class="enscript-type">int</span>)start);

			<span class="enscript-keyword">if</span> (mod == 0 &amp;&amp; rm == 5) {
				<span class="enscript-comment">/*
				 * We need to be sure to avoid other
				 * registers used by this instruction. While
				 * the reg field may determine the op code
				 * rather than denoting a register, assuming
				 * that it denotes a register is always safe.
				 * We leave the REX field intact and use
				 * whatever value's there for simplicity.
				 */</span>
				<span class="enscript-keyword">if</span> (reg != 0) {
					tp-&gt;ftt_ripmode = FASTTRAP_RIP_1 |
					    (FASTTRAP_RIP_X *
					    FASTTRAP_REX_B(rex));
					rm = 0;
				} <span class="enscript-keyword">else</span> {
					tp-&gt;ftt_ripmode = FASTTRAP_RIP_2 |
					    (FASTTRAP_RIP_X *
					    FASTTRAP_REX_B(rex));
					rm = 1;
				}

				tp-&gt;ftt_modrm = tp-&gt;ftt_instr[rmindex];
				tp-&gt;ftt_instr[rmindex] =
				    FASTTRAP_MODRM(2, reg, rm);
			}
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fasttrap_tracepoint_install</span>(proc_t *p, fasttrap_tracepoint_t *tp)
{
	fasttrap_instr_t instr = FASTTRAP_INSTR;

	<span class="enscript-keyword">if</span> (uwrite(p, &amp;instr, 1, tp-&gt;ftt_pc) != 0)
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fasttrap_tracepoint_remove</span>(proc_t *p, fasttrap_tracepoint_t *tp)
{
	uint8_t instr;

	<span class="enscript-comment">/*
	 * Distinguish between read or write failures and a changed
	 * instruction.
	 */</span>
	<span class="enscript-keyword">if</span> (uread(p, &amp;instr, 1, tp-&gt;ftt_pc) != 0)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> (instr != FASTTRAP_INSTR)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> (uwrite(p, &amp;tp-&gt;ftt_instr[0], 1, tp-&gt;ftt_pc) != 0)
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">fasttrap_return_common</span>(x86_saved_state_t *regs, user_addr_t pc, pid_t pid,
    user_addr_t new_pc)
{
	x86_saved_state64_t *regs64;
	x86_saved_state32_t *regs32;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> p_model;

	dtrace_icookie_t cookie;

        <span class="enscript-keyword">if</span> (is_saved_state64(regs)) {
                regs64 = saved_state64(regs);
		regs32 = NULL;
		p_model = DATAMODEL_LP64;
        } <span class="enscript-keyword">else</span> {
		regs64 = NULL;
                regs32 = saved_state32(regs);
		p_model = DATAMODEL_ILP32;
        }

	fasttrap_tracepoint_t *tp;
	fasttrap_bucket_t *bucket;
	fasttrap_id_t *id;
	lck_mtx_t *pid_mtx;

	pid_mtx = &amp;cpu_core[CPU-&gt;cpu_id].cpuc_pid_lock;
	lck_mtx_lock(pid_mtx);
	bucket = &amp;fasttrap_tpoints.fth_table[FASTTRAP_TPOINTS_INDEX(pid, pc)];

	<span class="enscript-keyword">for</span> (tp = bucket-&gt;ftb_data; tp != NULL; tp = tp-&gt;ftt_next) {
		<span class="enscript-keyword">if</span> (pid == tp-&gt;ftt_pid &amp;&amp; pc == tp-&gt;ftt_pc &amp;&amp;
		    tp-&gt;ftt_proc-&gt;ftpc_acount != 0)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * Don't sweat it if we can't find the tracepoint again; unlike
	 * when we're in fasttrap_pid_probe(), finding the tracepoint here
	 * is not essential to the correct execution of the process.
	 */</span>
	<span class="enscript-keyword">if</span> (tp == NULL) {
		lck_mtx_unlock(pid_mtx);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">for</span> (id = tp-&gt;ftt_retids; id != NULL; id = id-&gt;fti_next) {
		<span class="enscript-comment">/*
		 * If there's a branch that could act as a return site, we
		 * need to trace it, and check here if the program counter is
		 * external to the function.
		 */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;ftt_type != FASTTRAP_T_RET &amp;&amp;
		    tp-&gt;ftt_type != FASTTRAP_T_RET16 &amp;&amp;
		    new_pc - id-&gt;fti_probe-&gt;ftp_faddr &lt;
		    id-&gt;fti_probe-&gt;ftp_fsize)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * Provide a hint to the stack trace functions to add the
		 * following pc to the top of the stack since it's missing
		 * on a return probe yet highly desirable for consistency.
		 */</span>
		cookie = dtrace_interrupt_disable();
		cpu_core[CPU-&gt;cpu_id].cpuc_missing_tos = pc;
		<span class="enscript-keyword">if</span> (ISSET(current_proc()-&gt;p_lflag, P_LNOATTACH)) {
			dtrace_probe(dtrace_probeid_error, 0 <span class="enscript-comment">/* state */</span>, id-&gt;fti_probe-&gt;ftp_id, 
				     1 <span class="enscript-comment">/* ndx */</span>, -1 <span class="enscript-comment">/* offset */</span>, DTRACEFLT_UPRIV);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (p_model == DATAMODEL_LP64) {
			dtrace_probe(id-&gt;fti_probe-&gt;ftp_id,
				     pc - id-&gt;fti_probe-&gt;ftp_faddr,
				     regs64-&gt;rax, regs64-&gt;rdx, 0, 0);
		} <span class="enscript-keyword">else</span> {
			dtrace_probe(id-&gt;fti_probe-&gt;ftp_id,
				     pc - id-&gt;fti_probe-&gt;ftp_faddr,
				     regs32-&gt;eax, regs32-&gt;edx, 0, 0);
		}
		<span class="enscript-comment">/* remove the hint */</span>
		cpu_core[CPU-&gt;cpu_id].cpuc_missing_tos = 0;
		dtrace_interrupt_enable(cookie);
	}

	lck_mtx_unlock(pid_mtx);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">fasttrap_sigsegv</span>(proc_t *p, uthread_t t, user_addr_t addr)
{	
	proc_lock(p);

	<span class="enscript-comment">/* Set fault address and mark signal */</span>
	t-&gt;uu_code = addr;
	t-&gt;uu_siglist |= sigmask(SIGSEGV);

	<span class="enscript-comment">/* 
         * XXX These two line may be redundant; if not, then we need
	 * XXX to potentially set the data address in the machine
	 * XXX specific thread state structure to indicate the address.
	 */</span>
	t-&gt;uu_exception = KERN_INVALID_ADDRESS;		<span class="enscript-comment">/* SIGSEGV */</span>
	t-&gt;uu_subcode = 0;	<span class="enscript-comment">/* XXX pad */</span>

	proc_unlock(p);

	<span class="enscript-comment">/* raise signal */</span>
	signal_setast(t-&gt;uu_context.vc_thread);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">fasttrap_usdt_args64</span>(fasttrap_probe_t *probe, x86_saved_state64_t *regs64, <span class="enscript-type">int</span> argc,
    uint64_t *argv)
{
	<span class="enscript-type">int</span> i, x, cap = MIN(argc, probe-&gt;ftp_nargs);
	user_addr_t stack = (user_addr_t)regs64-&gt;isf.rsp;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; cap; i++) {
		x = probe-&gt;ftp_argmap[i];

		<span class="enscript-keyword">if</span> (x &lt; 6) {
			<span class="enscript-comment">/* FIXME! This may be broken, needs testing */</span>
			argv[i] = (&amp;regs64-&gt;rdi)[x];
		} <span class="enscript-keyword">else</span> {
			fasttrap_fuword64_noerr(stack + (x * <span class="enscript-keyword">sizeof</span>(uint64_t)), &amp;argv[i]);
		}
	}

	<span class="enscript-keyword">for</span> (; i &lt; argc; i++) {
		argv[i] = 0;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">fasttrap_usdt_args32</span>(fasttrap_probe_t *probe, x86_saved_state32_t *regs32, <span class="enscript-type">int</span> argc,
    uint32_t *argv)
{
	<span class="enscript-type">int</span> i, x, cap = MIN(argc, probe-&gt;ftp_nargs);
	uint32_t *stack = (uint32_t *)(uintptr_t)(regs32-&gt;uesp);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; cap; i++) {
		x = probe-&gt;ftp_argmap[i];

		fasttrap_fuword32_noerr((user_addr_t)(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)&amp;stack[x], &amp;argv[i]);
	}

	<span class="enscript-keyword">for</span> (; i &lt; argc; i++) {
		argv[i] = 0;
	}
}

<span class="enscript-comment">/*
 * FIXME!
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fasttrap_do_seg</span>(fasttrap_tracepoint_t *tp, x86_saved_state_t *rp, user_addr_t *addr) <span class="enscript-comment">// 64 bit
</span>{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">tp</span>, <span class="enscript-variable-name">rp</span>, <span class="enscript-variable-name">addr</span>)
	printf(<span class="enscript-string">&quot;fasttrap_do_seg() called while unimplemented.\n&quot;</span>);
#<span class="enscript-reference">if</span> 0
	proc_t *p = curproc;
	user_desc_t *desc;
	uint16_t sel, ndx, type;
	uintptr_t limit;

	<span class="enscript-keyword">switch</span> (tp-&gt;ftt_segment) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_SEG_CS</span>:
		sel = rp-&gt;r_cs;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_SEG_DS</span>:
		sel = rp-&gt;r_ds;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_SEG_ES</span>:
		sel = rp-&gt;r_es;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_SEG_FS</span>:
		sel = rp-&gt;r_fs;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_SEG_GS</span>:
		sel = rp-&gt;r_gs;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_SEG_SS</span>:
		sel = rp-&gt;r_ss;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * Make sure the given segment register specifies a user priority
	 * selector rather than a kernel selector.
	 */</span>
	<span class="enscript-keyword">if</span> (!SELISUPL(sel))
		<span class="enscript-keyword">return</span> (-1);

	ndx = SELTOIDX(sel);

	<span class="enscript-comment">/*
	 * Check the bounds and grab the descriptor out of the specified
	 * descriptor table.
	 */</span>
	<span class="enscript-keyword">if</span> (SELISLDT(sel)) {
		<span class="enscript-keyword">if</span> (ndx &gt; p-&gt;p_ldtlimit)
			<span class="enscript-keyword">return</span> (-1);

		desc = p-&gt;p_ldt + ndx;

	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (ndx &gt;= NGDT)
			<span class="enscript-keyword">return</span> (-1);

		desc = cpu_get_gdt() + ndx;
	}

	<span class="enscript-comment">/*
	 * The descriptor must have user privilege level and it must be
	 * present in memory.
	 */</span>
	<span class="enscript-keyword">if</span> (desc-&gt;usd_dpl != SEL_UPL || desc-&gt;usd_p != 1)
		<span class="enscript-keyword">return</span> (-1);

	type = desc-&gt;usd_type;

	<span class="enscript-comment">/*
	 * If the S bit in the type field is not set, this descriptor can
	 * only be used in system context.
	 */</span>
	<span class="enscript-keyword">if</span> ((type &amp; 0x10) != 0x10)
		<span class="enscript-keyword">return</span> (-1);

	limit = USEGD_GETLIMIT(desc) * (desc-&gt;usd_gran ? PAGESIZE : 1);

	<span class="enscript-keyword">if</span> (tp-&gt;ftt_segment == FASTTRAP_SEG_CS) {
		<span class="enscript-comment">/*
		 * The code/data bit and readable bit must both be set.
		 */</span>
		<span class="enscript-keyword">if</span> ((type &amp; 0xa) != 0xa)
			<span class="enscript-keyword">return</span> (-1);

		<span class="enscript-keyword">if</span> (*addr &gt; limit)
			<span class="enscript-keyword">return</span> (-1);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * The code/data bit must be clear.
		 */</span>
		<span class="enscript-keyword">if</span> ((type &amp; 0x8) != 0)
			<span class="enscript-keyword">return</span> (-1);

		<span class="enscript-comment">/*
		 * If the expand-down bit is clear, we just check the limit as
		 * it would naturally be applied. Otherwise, we need to check
		 * that the address is the range [limit + 1 .. 0xffff] or
		 * [limit + 1 ... 0xffffffff] depending on if the default
		 * operand size bit is set.
		 */</span>
		<span class="enscript-keyword">if</span> ((type &amp; 0x4) == 0) {
			<span class="enscript-keyword">if</span> (*addr &gt; limit)
				<span class="enscript-keyword">return</span> (-1);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (desc-&gt;usd_def32) {
			<span class="enscript-keyword">if</span> (*addr &lt; limit + 1 || 0xffff &lt; *addr)
				<span class="enscript-keyword">return</span> (-1);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (*addr &lt; limit + 1 || 0xffffffff &lt; *addr)
				<span class="enscript-keyword">return</span> (-1);
		}
	}

	*addr += USEGD_GETBASE(desc);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0 */</span>
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Due to variances between Solaris and xnu, I have split this into a 32 bit and 64 bit
 * code path. It still takes an x86_saved_state_t* argument, because it must sometimes
 * call other methods that require a x86_saved_state_t.
 *
 * NOTE!!!!
 *
 * Any changes made to this method must be echo'd in fasttrap_pid_probe64!
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fasttrap_pid_probe32</span>(x86_saved_state_t *regs)
{
	ASSERT(is_saved_state32(regs));

	x86_saved_state32_t *regs32  = saved_state32(regs);
	user_addr_t pc = regs32-&gt;eip - 1;
	proc_t *p = current_proc();
	user_addr_t new_pc = 0;
	fasttrap_bucket_t *bucket;
	lck_mtx_t *pid_mtx;
	fasttrap_tracepoint_t *tp, tp_local;
	pid_t pid;
	dtrace_icookie_t cookie;
	uint_t is_enabled = 0;

	uthread_t uthread = (uthread_t)get_bsdthread_info(current_thread());

	<span class="enscript-comment">/*
	 * It's possible that a user (in a veritable orgy of bad planning)
	 * could redirect this thread's flow of control before it reached the
	 * return probe fasttrap. In this case we need to kill the process
	 * since it's in a unrecoverable state.
	 */</span>
	<span class="enscript-keyword">if</span> (uthread-&gt;t_dtrace_step) {
		ASSERT(uthread-&gt;t_dtrace_on);
		fasttrap_sigtrap(p, uthread, pc);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * Clear all user tracing flags.
	 */</span>
	uthread-&gt;t_dtrace_ft = 0;
	uthread-&gt;t_dtrace_pc = 0;
	uthread-&gt;t_dtrace_npc = 0;
	uthread-&gt;t_dtrace_scrpc = 0;
	uthread-&gt;t_dtrace_astpc = 0;

	<span class="enscript-comment">/*
	 * Treat a child created by a call to vfork(2) as if it were its
	 * parent. We know that there's only one thread of control in such a
	 * process: this one.
	 */</span>
	<span class="enscript-keyword">if</span> (p-&gt;p_lflag &amp; P_LINVFORK) {
		proc_list_lock();
		<span class="enscript-keyword">while</span> (p-&gt;p_lflag &amp; P_LINVFORK)
			p = p-&gt;p_pptr;
		proc_list_unlock();
	}

	pid = p-&gt;p_pid;
	pid_mtx = &amp;cpu_core[CPU-&gt;cpu_id].cpuc_pid_lock;
	lck_mtx_lock(pid_mtx);
	bucket = &amp;fasttrap_tpoints.fth_table[FASTTRAP_TPOINTS_INDEX(pid, pc)];

	<span class="enscript-comment">/*
	 * Lookup the tracepoint that the process just hit.
	 */</span>
	<span class="enscript-keyword">for</span> (tp = bucket-&gt;ftb_data; tp != NULL; tp = tp-&gt;ftt_next) {
		<span class="enscript-keyword">if</span> (pid == tp-&gt;ftt_pid &amp;&amp; pc == tp-&gt;ftt_pc &amp;&amp;
		    tp-&gt;ftt_proc-&gt;ftpc_acount != 0)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * If we couldn't find a matching tracepoint, either a tracepoint has
	 * been inserted without using the pid&lt;pid&gt; ioctl interface (see
	 * fasttrap_ioctl), or somehow we have mislaid this tracepoint.
	 */</span>
	<span class="enscript-keyword">if</span> (tp == NULL) {
		lck_mtx_unlock(pid_mtx);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-comment">/*
	 * Set the program counter to the address of the traced instruction
	 * so that it looks right in ustack() output.
	 */</span>
	regs32-&gt;eip = pc;

	<span class="enscript-keyword">if</span> (tp-&gt;ftt_ids != NULL) {
		fasttrap_id_t *id;
		
		uint32_t s0, s1, s2, s3, s4, s5;
		uint32_t *stack = (uint32_t *)(uintptr_t)(regs32-&gt;uesp);
		
		<span class="enscript-comment">/*
		 * In 32-bit mode, all arguments are passed on the
		 * stack. If this is a function entry probe, we need
		 * to skip the first entry on the stack as it
		 * represents the return address rather than a
		 * parameter to the function.
		 */</span>
		fasttrap_fuword32_noerr((user_addr_t)(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)&amp;stack[0], &amp;s0);
		fasttrap_fuword32_noerr((user_addr_t)(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)&amp;stack[1], &amp;s1);
		fasttrap_fuword32_noerr((user_addr_t)(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)&amp;stack[2], &amp;s2);
		fasttrap_fuword32_noerr((user_addr_t)(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)&amp;stack[3], &amp;s3);
		fasttrap_fuword32_noerr((user_addr_t)(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)&amp;stack[4], &amp;s4);
		fasttrap_fuword32_noerr((user_addr_t)(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)&amp;stack[5], &amp;s5);
		
		<span class="enscript-keyword">for</span> (id = tp-&gt;ftt_ids; id != NULL; id = id-&gt;fti_next) {
			fasttrap_probe_t *probe = id-&gt;fti_probe;
			
			<span class="enscript-keyword">if</span> (ISSET(current_proc()-&gt;p_lflag, P_LNOATTACH)) {
				dtrace_probe(dtrace_probeid_error, 0 <span class="enscript-comment">/* state */</span>, probe-&gt;ftp_id, 
					     1 <span class="enscript-comment">/* ndx */</span>, -1 <span class="enscript-comment">/* offset */</span>, DTRACEFLT_UPRIV);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (id-&gt;fti_ptype == DTFTP_ENTRY) {
				<span class="enscript-comment">/*
				 * We note that this was an entry
				 * probe to help ustack() find the
				 * first caller.
				 */</span>
				cookie = dtrace_interrupt_disable();
				DTRACE_CPUFLAG_SET(CPU_DTRACE_ENTRY);
				dtrace_probe(probe-&gt;ftp_id, s1, s2,
					     s3, s4, s5);
				DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_ENTRY);
				dtrace_interrupt_enable(cookie);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (id-&gt;fti_ptype == DTFTP_IS_ENABLED) {
				<span class="enscript-comment">/*
				 * Note that in this case, we don't
				 * call dtrace_probe() since it's only
				 * an artificial probe meant to change
				 * the flow of control so that it
				 * encounters the true probe.
				 */</span>
				is_enabled = 1;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (probe-&gt;ftp_argmap == NULL) {
				dtrace_probe(probe-&gt;ftp_id, s0, s1,
					     s2, s3, s4);
			} <span class="enscript-keyword">else</span> {
				uint32_t t[5];
				
				fasttrap_usdt_args32(probe, regs32,
						     <span class="enscript-keyword">sizeof</span> (t) / <span class="enscript-keyword">sizeof</span> (t[0]), t);
				
				dtrace_probe(probe-&gt;ftp_id, t[0], t[1],
					     t[2], t[3], t[4]);
			}

			<span class="enscript-comment">/* APPLE NOTE: Oneshot probes get one and only one chance... */</span>
			<span class="enscript-keyword">if</span> (probe-&gt;ftp_prov-&gt;ftp_provider_type == DTFTP_PROVIDER_ONESHOT) {
				fasttrap_tracepoint_remove(p, tp);
			}
		}
	}

	<span class="enscript-comment">/*
	 * We're about to do a bunch of work so we cache a local copy of
	 * the tracepoint to emulate the instruction, and then find the
	 * tracepoint again later if we need to light up any return probes.
	 */</span>
	tp_local = *tp;
	lck_mtx_unlock(pid_mtx);
	tp = &amp;tp_local;

	<span class="enscript-comment">/*
	 * Set the program counter to appear as though the traced instruction
	 * had completely executed. This ensures that fasttrap_getreg() will
	 * report the expected value for REG_RIP.
	 */</span>
	regs32-&gt;eip = pc + tp-&gt;ftt_size;

	<span class="enscript-comment">/*
	 * If there's an is-enabled probe connected to this tracepoint it
	 * means that there was a 'xorl %eax, %eax' or 'xorq %rax, %rax'
	 * instruction that was placed there by DTrace when the binary was
	 * linked. As this probe is, in fact, enabled, we need to stuff 1
	 * into %eax or %rax. Accordingly, we can bypass all the instruction
	 * emulation logic since we know the inevitable result. It's possible
	 * that a user could construct a scenario where the 'is-enabled'
	 * probe was on some other instruction, but that would be a rather
	 * exotic way to shoot oneself in the foot.
	 */</span>
	<span class="enscript-keyword">if</span> (is_enabled) {
		regs32-&gt;eax = 1;
		new_pc = regs32-&gt;eip;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * We emulate certain types of instructions to ensure correctness
	 * (in the case of position dependent instructions) or optimize
	 * common cases. The rest we have the thread execute back in user-
	 * land.
	 */</span>
	<span class="enscript-keyword">switch</span> (tp-&gt;ftt_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_RET</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_RET16</span>:
		{
			user_addr_t dst;
			user_addr_t addr;
			<span class="enscript-type">int</span> ret;

			<span class="enscript-comment">/*
			 * We have to emulate _every_ facet of the behavior of a ret
			 * instruction including what happens if the load from %esp
			 * fails; in that case, we send a SIGSEGV.
			 */</span>
			uint32_t dst32;
			ret = fasttrap_fuword32((user_addr_t)regs32-&gt;uesp, &amp;dst32);
			dst = dst32;
			addr = regs32-&gt;uesp + <span class="enscript-keyword">sizeof</span> (uint32_t);

			<span class="enscript-keyword">if</span> (ret == -1) {
				fasttrap_sigsegv(p, uthread, (user_addr_t)regs32-&gt;uesp);
				new_pc = pc;
				<span class="enscript-keyword">break</span>;
			}
			
			<span class="enscript-keyword">if</span> (tp-&gt;ftt_type == FASTTRAP_T_RET16)
				addr += tp-&gt;ftt_dest;
			
			regs32-&gt;uesp = addr;
			new_pc = dst;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_JCC</span>:
		{
			uint_t taken;
			
			<span class="enscript-keyword">switch</span> (tp-&gt;ftt_code) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JO</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_OF) != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JNO</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_OF) == 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JB</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_CF) != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JAE</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_CF) == 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JE</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_ZF) != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JNE</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_ZF) == 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JBE</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_CF) != 0 ||
						(regs32-&gt;efl &amp; FASTTRAP_EFLAGS_ZF) != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JA</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_CF) == 0 &amp;&amp;
						(regs32-&gt;efl &amp; FASTTRAP_EFLAGS_ZF) == 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JS</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_SF) != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JNS</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_SF) == 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JP</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_PF) != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JNP</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_PF) == 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JL</span>:
					taken = ((regs32-&gt;efl &amp; FASTTRAP_EFLAGS_SF) == 0) !=
						((regs32-&gt;efl &amp; FASTTRAP_EFLAGS_OF) == 0);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JGE</span>:
					taken = ((regs32-&gt;efl &amp; FASTTRAP_EFLAGS_SF) == 0) ==
						((regs32-&gt;efl &amp; FASTTRAP_EFLAGS_OF) == 0);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JLE</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_ZF) != 0 ||
						((regs32-&gt;efl &amp; FASTTRAP_EFLAGS_SF) == 0) !=
						((regs32-&gt;efl &amp; FASTTRAP_EFLAGS_OF) == 0);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JG</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_ZF) == 0 &amp;&amp;
						((regs32-&gt;efl &amp; FASTTRAP_EFLAGS_SF) == 0) ==
						((regs32-&gt;efl &amp; FASTTRAP_EFLAGS_OF) == 0);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-reference">default</span>:
					taken = FALSE;
			}
			
			<span class="enscript-keyword">if</span> (taken)
				new_pc = tp-&gt;ftt_dest;
			<span class="enscript-keyword">else</span>
				new_pc = pc + tp-&gt;ftt_size;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_LOOP</span>:
		{
			uint_t taken;
			greg_t cx = regs32-&gt;ecx--;

			<span class="enscript-keyword">switch</span> (tp-&gt;ftt_code) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_LOOPNZ</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_ZF) == 0 &amp;&amp;
						cx != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_LOOPZ</span>:
					taken = (regs32-&gt;efl &amp; FASTTRAP_EFLAGS_ZF) != 0 &amp;&amp;
						cx != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_LOOP</span>:
					taken = (cx != 0);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-reference">default</span>:
					taken = FALSE;
			}
			
			<span class="enscript-keyword">if</span> (taken)
				new_pc = tp-&gt;ftt_dest;
			<span class="enscript-keyword">else</span>
				new_pc = pc + tp-&gt;ftt_size;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_JCXZ</span>:
		{
			greg_t cx = regs32-&gt;ecx;
			
			<span class="enscript-keyword">if</span> (cx == 0)
				new_pc = tp-&gt;ftt_dest;
			<span class="enscript-keyword">else</span>
				new_pc = pc + tp-&gt;ftt_size;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_PUSHL_EBP</span>:
		{
			user_addr_t addr = regs32-&gt;uesp - <span class="enscript-keyword">sizeof</span> (uint32_t);
			<span class="enscript-type">int</span> ret = fasttrap_suword32(addr, (uint32_t)regs32-&gt;ebp);
			
			<span class="enscript-keyword">if</span> (ret == -1) {
				fasttrap_sigsegv(p, uthread, addr);
				new_pc = pc;
				<span class="enscript-keyword">break</span>;
			}
			
			regs32-&gt;uesp = addr;
			new_pc = pc + tp-&gt;ftt_size;
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_NOP</span>:
			new_pc = pc + tp-&gt;ftt_size;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_JMP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_CALL</span>:
			<span class="enscript-keyword">if</span> (tp-&gt;ftt_code == 0) {
				new_pc = tp-&gt;ftt_dest;
			} <span class="enscript-keyword">else</span> {
				user_addr_t <span class="enscript-comment">/* value ,*/</span> addr = tp-&gt;ftt_dest;

				<span class="enscript-keyword">if</span> (tp-&gt;ftt_base != FASTTRAP_NOREG)
					addr += fasttrap_getreg(regs, tp-&gt;ftt_base);
				<span class="enscript-keyword">if</span> (tp-&gt;ftt_index != FASTTRAP_NOREG)
					addr += fasttrap_getreg(regs, tp-&gt;ftt_index) &lt;&lt;
						tp-&gt;ftt_scale;
				
				<span class="enscript-keyword">if</span> (tp-&gt;ftt_code == 1) {
					<span class="enscript-comment">/*
					 * If there's a segment prefix for this
					 * instruction, we'll need to check permissions
					 * and bounds on the given selector, and adjust
					 * the address accordingly.
					 */</span>
					<span class="enscript-keyword">if</span> (tp-&gt;ftt_segment != FASTTRAP_SEG_NONE &amp;&amp;
					    fasttrap_do_seg(tp, regs, &amp;addr) != 0) {
						fasttrap_sigsegv(p, uthread, addr);
						new_pc = pc;
						<span class="enscript-keyword">break</span>;
					}
					
					uint32_t value32;
					addr = (user_addr_t)(uint32_t)addr;
					<span class="enscript-keyword">if</span> (fasttrap_fuword32(addr, &amp;value32) == -1) {
						fasttrap_sigsegv(p, uthread, addr);
						new_pc = pc;
						<span class="enscript-keyword">break</span>;
					}
					new_pc = value32;
				} <span class="enscript-keyword">else</span> {
					new_pc = addr;
				}
			}

			<span class="enscript-comment">/*
			 * If this is a call instruction, we need to push the return
			 * address onto the stack. If this fails, we send the process
			 * a SIGSEGV and reset the pc to emulate what would happen if
			 * this instruction weren't traced.
			 */</span>
			<span class="enscript-keyword">if</span> (tp-&gt;ftt_type == FASTTRAP_T_CALL) {
				user_addr_t addr = regs32-&gt;uesp - <span class="enscript-keyword">sizeof</span> (uint32_t);
				<span class="enscript-type">int</span> ret = fasttrap_suword32(addr, (uint32_t)(pc + tp-&gt;ftt_size));
				
				<span class="enscript-keyword">if</span> (ret == -1) {
					fasttrap_sigsegv(p, uthread, addr);
					new_pc = pc;
					<span class="enscript-keyword">break</span>;
				}
				
				regs32-&gt;uesp = addr;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_COMMON</span>:
		{
			user_addr_t addr;
			uint8_t scratch[2 * FASTTRAP_MAX_INSTR_SIZE + 7];
			uint_t i = 0;

			<span class="enscript-comment">/*
			 * Generic Instruction Tracing
			 * ---------------------------
			 *
			 * This is the layout of the scratch space in the user-land
			 * thread structure for our generated instructions.
			 *
			 *	32-bit mode			bytes
			 *	------------------------	-----
			 * a:	&lt;original instruction&gt;		&lt;= 15
			 *	jmp	&lt;pc + tp-&gt;ftt_size&gt;	    5
			 * b:	&lt;original instrction&gt;		&lt;= 15
			 *	int	T_DTRACE_RET		    2
			 *					-----
			 *					&lt;= 37
			 *
			 *	64-bit mode			bytes
			 *	------------------------	-----
			 * a:	&lt;original instruction&gt;		&lt;= 15
			 *	jmp	0(%rip)			    6
			 *	&lt;pc + tp-&gt;ftt_size&gt;		    8
			 * b:	&lt;original instruction&gt;		&lt;= 15
			 * 	int	T_DTRACE_RET		    2
			 * 					-----
			 * 					&lt;= 46
			 *
			 * The %pc is set to a, and curthread-&gt;t_dtrace_astpc is set
			 * to b. If we encounter a signal on the way out of the
			 * kernel, trap() will set %pc to curthread-&gt;t_dtrace_astpc
			 * so that we execute the original instruction and re-enter
			 * the kernel rather than redirecting to the next instruction.
			 *
			 * If there are return probes (so we know that we're going to
			 * need to reenter the kernel after executing the original
			 * instruction), the scratch space will just contain the
			 * original instruction followed by an interrupt -- the same
			 * data as at b.
			 */</span>

			addr = uthread-&gt;t_dtrace_scratch-&gt;addr;

			<span class="enscript-keyword">if</span> (addr == 0LL) {
				fasttrap_sigtrap(p, uthread, pc); <span class="enscript-comment">// Should be killing target proc
</span>				new_pc = pc;
				<span class="enscript-keyword">break</span>;
			}

			ASSERT(tp-&gt;ftt_size &lt; FASTTRAP_MAX_INSTR_SIZE);

			uthread-&gt;t_dtrace_scrpc = addr;
			bcopy(tp-&gt;ftt_instr, &amp;scratch[i], tp-&gt;ftt_size);
			i += tp-&gt;ftt_size;

			<span class="enscript-comment">/*
			 * Set up the jmp to the next instruction; note that
			 * the size of the traced instruction cancels out.
			 */</span>
			scratch[i++] = FASTTRAP_JMP32;
			<span class="enscript-comment">/* LINTED - alignment */</span>
			*(uint32_t *)&amp;scratch[i] = pc - addr - 5;
			i += <span class="enscript-keyword">sizeof</span> (uint32_t);

			uthread-&gt;t_dtrace_astpc = addr + i;
			bcopy(tp-&gt;ftt_instr, &amp;scratch[i], tp-&gt;ftt_size);
			i += tp-&gt;ftt_size;
			scratch[i++] = FASTTRAP_INT;
			scratch[i++] = T_DTRACE_RET;
			
			ASSERT(i &lt;= <span class="enscript-keyword">sizeof</span> (scratch));

			<span class="enscript-keyword">if</span> (fasttrap_copyout(scratch, addr, i)) {
				fasttrap_sigtrap(p, uthread, pc);
				new_pc = pc;
				<span class="enscript-keyword">break</span>;
			}
			
			<span class="enscript-keyword">if</span> (tp-&gt;ftt_retids != NULL) {
				uthread-&gt;t_dtrace_step = 1;
				uthread-&gt;t_dtrace_ret = 1;
				new_pc = uthread-&gt;t_dtrace_astpc;
			} <span class="enscript-keyword">else</span> {
				new_pc = uthread-&gt;t_dtrace_scrpc;
			}
			
			uthread-&gt;t_dtrace_pc = pc;
			uthread-&gt;t_dtrace_npc = pc + tp-&gt;ftt_size;
			uthread-&gt;t_dtrace_on = 1;
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;fasttrap: mishandled an instruction&quot;</span>);
	}
	
<span class="enscript-reference">done</span>:
	<span class="enscript-comment">/*
	 * APPLE NOTE:
	 *
	 * We're setting this earlier than Solaris does, to get a &quot;correct&quot;
	 * ustack() output. In the Sun code,  a() -&gt; b() -&gt; c() -&gt; d() is
	 * reported at: d, b, a. The new way gives c, b, a, which is closer
	 * to correct, as the return instruction has already exectued.
	 */</span>
	regs32-&gt;eip = new_pc;

	<span class="enscript-comment">/*
	 * If there were no return probes when we first found the tracepoint,
	 * we should feel no obligation to honor any return probes that were
	 * subsequently enabled -- they'll just have to wait until the next
	 * time around.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;ftt_retids != NULL) {
		<span class="enscript-comment">/*
		 * We need to wait until the results of the instruction are
		 * apparent before invoking any return probes. If this
		 * instruction was emulated we can just call
		 * fasttrap_return_common(); if it needs to be executed, we
		 * need to wait until the user thread returns to the kernel.
		 */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;ftt_type != FASTTRAP_T_COMMON) {
			fasttrap_return_common(regs, pc, pid, new_pc);
		} <span class="enscript-keyword">else</span> {
			ASSERT(uthread-&gt;t_dtrace_ret != 0);
			ASSERT(uthread-&gt;t_dtrace_pc == pc);
			ASSERT(uthread-&gt;t_dtrace_scrpc != 0);
			ASSERT(new_pc == uthread-&gt;t_dtrace_astpc);
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Due to variances between Solaris and xnu, I have split this into a 32 bit and 64 bit
 * code path. It still takes an x86_saved_state_t* argument, because it must sometimes
 * call other methods that require a x86_saved_state_t.
 *
 * NOTE!!!!
 *
 * Any changes made to this method must be echo'd in fasttrap_pid_probe32!
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fasttrap_pid_probe64</span>(x86_saved_state_t *regs)
{
	ASSERT(is_saved_state64(regs));

	x86_saved_state64_t *regs64 = saved_state64(regs);
	user_addr_t pc = regs64-&gt;isf.rip - 1;
	proc_t *p = current_proc();
	user_addr_t new_pc = 0;
	fasttrap_bucket_t *bucket;
	lck_mtx_t *pid_mtx;
	fasttrap_tracepoint_t *tp, tp_local;
	pid_t pid;
	dtrace_icookie_t cookie;
	uint_t is_enabled = 0;

	uthread_t uthread = (uthread_t)get_bsdthread_info(current_thread());

	<span class="enscript-comment">/*
	 * It's possible that a user (in a veritable orgy of bad planning)
	 * could redirect this thread's flow of control before it reached the
	 * return probe fasttrap. In this case we need to kill the process
	 * since it's in a unrecoverable state.
	 */</span>
	<span class="enscript-keyword">if</span> (uthread-&gt;t_dtrace_step) {
		ASSERT(uthread-&gt;t_dtrace_on);
		fasttrap_sigtrap(p, uthread, pc);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * Clear all user tracing flags.
	 */</span>
	uthread-&gt;t_dtrace_ft = 0;
	uthread-&gt;t_dtrace_pc = 0;
	uthread-&gt;t_dtrace_npc = 0;
	uthread-&gt;t_dtrace_scrpc = 0;
	uthread-&gt;t_dtrace_astpc = 0;
	uthread-&gt;t_dtrace_regv = 0;

	<span class="enscript-comment">/*
	 * Treat a child created by a call to vfork(2) as if it were its
	 * parent. We know that there's only one thread of control in such a
	 * process: this one.
	 */</span>
	<span class="enscript-keyword">if</span> (p-&gt;p_lflag &amp; P_LINVFORK) {
		proc_list_lock();
		<span class="enscript-keyword">while</span> (p-&gt;p_lflag &amp; P_LINVFORK)
			p = p-&gt;p_pptr;
		proc_list_unlock();
	}

	pid = p-&gt;p_pid;
	pid_mtx = &amp;cpu_core[CPU-&gt;cpu_id].cpuc_pid_lock;
	lck_mtx_lock(pid_mtx);
	bucket = &amp;fasttrap_tpoints.fth_table[FASTTRAP_TPOINTS_INDEX(pid, pc)];

	<span class="enscript-comment">/*
	 * Lookup the tracepoint that the process just hit.
	 */</span>
	<span class="enscript-keyword">for</span> (tp = bucket-&gt;ftb_data; tp != NULL; tp = tp-&gt;ftt_next) {
		<span class="enscript-keyword">if</span> (pid == tp-&gt;ftt_pid &amp;&amp; pc == tp-&gt;ftt_pc &amp;&amp;
		    tp-&gt;ftt_proc-&gt;ftpc_acount != 0)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * If we couldn't find a matching tracepoint, either a tracepoint has
	 * been inserted without using the pid&lt;pid&gt; ioctl interface (see
	 * fasttrap_ioctl), or somehow we have mislaid this tracepoint.
	 */</span>
	<span class="enscript-keyword">if</span> (tp == NULL) {
		lck_mtx_unlock(pid_mtx);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-comment">/*
	 * Set the program counter to the address of the traced instruction
	 * so that it looks right in ustack() output.
	 */</span>
	regs64-&gt;isf.rip = pc;

	<span class="enscript-keyword">if</span> (tp-&gt;ftt_ids != NULL) {
		fasttrap_id_t *id;

		<span class="enscript-keyword">for</span> (id = tp-&gt;ftt_ids; id != NULL; id = id-&gt;fti_next) {
			fasttrap_probe_t *probe = id-&gt;fti_probe;
			
			<span class="enscript-keyword">if</span> (ISSET(current_proc()-&gt;p_lflag, P_LNOATTACH)) {
				dtrace_probe(dtrace_probeid_error, 0 <span class="enscript-comment">/* state */</span>, probe-&gt;ftp_id, 
					     1 <span class="enscript-comment">/* ndx */</span>, -1 <span class="enscript-comment">/* offset */</span>, DTRACEFLT_UPRIV);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (id-&gt;fti_ptype == DTFTP_ENTRY) {
				<span class="enscript-comment">/*
				 * We note that this was an entry
				 * probe to help ustack() find the
				 * first caller.
				 */</span>
				cookie = dtrace_interrupt_disable();
				DTRACE_CPUFLAG_SET(CPU_DTRACE_ENTRY);
				dtrace_probe(probe-&gt;ftp_id, regs64-&gt;rdi,
					     regs64-&gt;rsi, regs64-&gt;rdx, regs64-&gt;rcx,
					     regs64-&gt;r8);
				DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_ENTRY);
				dtrace_interrupt_enable(cookie);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (id-&gt;fti_ptype == DTFTP_IS_ENABLED) {
				<span class="enscript-comment">/*
				 * Note that in this case, we don't
				 * call dtrace_probe() since it's only
				 * an artificial probe meant to change
				 * the flow of control so that it
				 * encounters the true probe.
				 */</span>
				is_enabled = 1;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (probe-&gt;ftp_argmap == NULL) {
				dtrace_probe(probe-&gt;ftp_id, regs64-&gt;rdi,
					     regs64-&gt;rsi, regs64-&gt;rdx, regs64-&gt;rcx,
					     regs64-&gt;r8);
			} <span class="enscript-keyword">else</span> {
				uint64_t t[5];
				
				fasttrap_usdt_args64(probe, regs64,
						     <span class="enscript-keyword">sizeof</span> (t) / <span class="enscript-keyword">sizeof</span> (t[0]), t);
				
				dtrace_probe(probe-&gt;ftp_id, t[0], t[1],
					     t[2], t[3], t[4]);
			}

			<span class="enscript-comment">/* APPLE NOTE: Oneshot probes get one and only one chance... */</span>
			<span class="enscript-keyword">if</span> (probe-&gt;ftp_prov-&gt;ftp_provider_type == DTFTP_PROVIDER_ONESHOT) {
				fasttrap_tracepoint_remove(p, tp);
			}
		}
	}

	<span class="enscript-comment">/*
	 * We're about to do a bunch of work so we cache a local copy of
	 * the tracepoint to emulate the instruction, and then find the
	 * tracepoint again later if we need to light up any return probes.
	 */</span>
	tp_local = *tp;
	lck_mtx_unlock(pid_mtx);
	tp = &amp;tp_local;

	<span class="enscript-comment">/*
	 * Set the program counter to appear as though the traced instruction
	 * had completely executed. This ensures that fasttrap_getreg() will
	 * report the expected value for REG_RIP.
	 */</span>
	regs64-&gt;isf.rip = pc + tp-&gt;ftt_size;

	<span class="enscript-comment">/*
	 * If there's an is-enabled probe connected to this tracepoint it
	 * means that there was a 'xorl %eax, %eax' or 'xorq %rax, %rax'
	 * instruction that was placed there by DTrace when the binary was
	 * linked. As this probe is, in fact, enabled, we need to stuff 1
	 * into %eax or %rax. Accordingly, we can bypass all the instruction
	 * emulation logic since we know the inevitable result. It's possible
	 * that a user could construct a scenario where the 'is-enabled'
	 * probe was on some other instruction, but that would be a rather
	 * exotic way to shoot oneself in the foot.
	 */</span>
	<span class="enscript-keyword">if</span> (is_enabled) {
		regs64-&gt;rax = 1;
		new_pc = regs64-&gt;isf.rip;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * We emulate certain types of instructions to ensure correctness
	 * (in the case of position dependent instructions) or optimize
	 * common cases. The rest we have the thread execute back in user-
	 * land.
	 */</span>
	<span class="enscript-keyword">switch</span> (tp-&gt;ftt_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_RET</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_RET16</span>:
		{
			user_addr_t dst;
			user_addr_t addr;
			<span class="enscript-type">int</span> ret;
			
			<span class="enscript-comment">/*
			 * We have to emulate _every_ facet of the behavior of a ret
			 * instruction including what happens if the load from %esp
			 * fails; in that case, we send a SIGSEGV.
			 */</span>
			ret = fasttrap_fuword64((user_addr_t)regs64-&gt;isf.rsp, &amp;dst);
			addr = regs64-&gt;isf.rsp + <span class="enscript-keyword">sizeof</span> (uint64_t);
			
			<span class="enscript-keyword">if</span> (ret == -1) {
				fasttrap_sigsegv(p, uthread, (user_addr_t)regs64-&gt;isf.rsp);
				new_pc = pc;
				<span class="enscript-keyword">break</span>;
			}
			
			<span class="enscript-keyword">if</span> (tp-&gt;ftt_type == FASTTRAP_T_RET16)
				addr += tp-&gt;ftt_dest;
			
			regs64-&gt;isf.rsp = addr;
			new_pc = dst;
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_JCC</span>:
		{
			uint_t taken;
			
			<span class="enscript-keyword">switch</span> (tp-&gt;ftt_code) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JO</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_OF) != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JNO</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_OF) == 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JB</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_CF) != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JAE</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_CF) == 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JE</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_ZF) != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JNE</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_ZF) == 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JBE</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_CF) != 0 ||
						(regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_ZF) != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JA</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_CF) == 0 &amp;&amp;
						(regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_ZF) == 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JS</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_SF) != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JNS</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_SF) == 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JP</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_PF) != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JNP</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_PF) == 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JL</span>:
					taken = ((regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_SF) == 0) !=
						((regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_OF) == 0);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JGE</span>:
					taken = ((regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_SF) == 0) ==
						((regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_OF) == 0);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JLE</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_ZF) != 0 ||
						((regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_SF) == 0) !=
						((regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_OF) == 0);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_JG</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_ZF) == 0 &amp;&amp;
						((regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_SF) == 0) ==
						((regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_OF) == 0);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-reference">default</span>:
					taken = FALSE;
			}
			
			<span class="enscript-keyword">if</span> (taken)
				new_pc = tp-&gt;ftt_dest;
			<span class="enscript-keyword">else</span>
				new_pc = pc + tp-&gt;ftt_size;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_LOOP</span>:
		{
			uint_t taken;
			uint64_t cx = regs64-&gt;rcx--;
			
			<span class="enscript-keyword">switch</span> (tp-&gt;ftt_code) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_LOOPNZ</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_ZF) == 0 &amp;&amp;
						cx != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_LOOPZ</span>:
					taken = (regs64-&gt;isf.rflags &amp; FASTTRAP_EFLAGS_ZF) != 0 &amp;&amp;
						cx != 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_LOOP</span>:
					taken = (cx != 0);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-reference">default</span>:
					taken = FALSE;
			}
			
			<span class="enscript-keyword">if</span> (taken)
				new_pc = tp-&gt;ftt_dest;
			<span class="enscript-keyword">else</span>
				new_pc = pc + tp-&gt;ftt_size;
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_JCXZ</span>:
		{
			uint64_t cx = regs64-&gt;rcx;

			<span class="enscript-keyword">if</span> (cx == 0)
				new_pc = tp-&gt;ftt_dest;
			<span class="enscript-keyword">else</span>
				new_pc = pc + tp-&gt;ftt_size;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_PUSHL_EBP</span>:
		{
			user_addr_t addr = regs64-&gt;isf.rsp - <span class="enscript-keyword">sizeof</span> (uint64_t);
			<span class="enscript-type">int</span> ret = fasttrap_suword64(addr, (uint64_t)regs64-&gt;rbp);
			
			<span class="enscript-keyword">if</span> (ret == -1) {
				fasttrap_sigsegv(p, uthread, addr);
				new_pc = pc;
				<span class="enscript-keyword">break</span>;
			}
			
			regs64-&gt;isf.rsp = addr;
			new_pc = pc + tp-&gt;ftt_size;
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_NOP</span>:
			new_pc = pc + tp-&gt;ftt_size;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_JMP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_CALL</span>:
			<span class="enscript-keyword">if</span> (tp-&gt;ftt_code == 0) {
				new_pc = tp-&gt;ftt_dest;
			} <span class="enscript-keyword">else</span> {
				user_addr_t value, addr = tp-&gt;ftt_dest;
				
				<span class="enscript-keyword">if</span> (tp-&gt;ftt_base != FASTTRAP_NOREG)
					addr += fasttrap_getreg(regs, tp-&gt;ftt_base);
				<span class="enscript-keyword">if</span> (tp-&gt;ftt_index != FASTTRAP_NOREG)
					addr += fasttrap_getreg(regs, tp-&gt;ftt_index) &lt;&lt;
						tp-&gt;ftt_scale;
				
				<span class="enscript-keyword">if</span> (tp-&gt;ftt_code == 1) {
					<span class="enscript-comment">/*
					 * If there's a segment prefix for this
					 * instruction, we'll need to check permissions
					 * and bounds on the given selector, and adjust
					 * the address accordingly.
					 */</span>
					<span class="enscript-keyword">if</span> (tp-&gt;ftt_segment != FASTTRAP_SEG_NONE &amp;&amp;
					    fasttrap_do_seg(tp, regs, &amp;addr) != 0) {
						fasttrap_sigsegv(p, uthread, addr);
						new_pc = pc;
						<span class="enscript-keyword">break</span>;
					}
					
					<span class="enscript-keyword">if</span> (fasttrap_fuword64(addr, &amp;value) == -1) {
						fasttrap_sigsegv(p, uthread, addr);
						new_pc = pc;
						<span class="enscript-keyword">break</span>;
					}
					new_pc = value;
				} <span class="enscript-keyword">else</span> {
					new_pc = addr;
				}
			}

			<span class="enscript-comment">/*
			 * If this is a call instruction, we need to push the return
			 * address onto the stack. If this fails, we send the process
			 * a SIGSEGV and reset the pc to emulate what would happen if
			 * this instruction weren't traced.
			 */</span>
			<span class="enscript-keyword">if</span> (tp-&gt;ftt_type == FASTTRAP_T_CALL) {
				user_addr_t addr = regs64-&gt;isf.rsp - <span class="enscript-keyword">sizeof</span> (uint64_t);
				<span class="enscript-type">int</span> ret = fasttrap_suword64(addr, pc + tp-&gt;ftt_size);
				
				<span class="enscript-keyword">if</span> (ret == -1) {
					fasttrap_sigsegv(p, uthread, addr);
					new_pc = pc;
					<span class="enscript-keyword">break</span>;
				}
				
				regs64-&gt;isf.rsp = addr;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_T_COMMON</span>:
		{
			user_addr_t addr;
			uint8_t scratch[2 * FASTTRAP_MAX_INSTR_SIZE + 22];
			uint_t i = 0;
			
			<span class="enscript-comment">/*
			 * Generic Instruction Tracing
			 * ---------------------------
			 *
			 * This is the layout of the scratch space in the user-land
			 * thread structure for our generated instructions.
			 *
			 *	32-bit mode			bytes
			 *	------------------------	-----
			 * a:	&lt;original instruction&gt;		&lt;= 15
			 *	jmp	&lt;pc + tp-&gt;ftt_size&gt;	    5
			 * b:	&lt;original instrction&gt;		&lt;= 15
			 *	int	T_DTRACE_RET		    2
			 *					-----
			 *					&lt;= 37
			 *
			 *	64-bit mode			bytes
			 *	------------------------	-----
			 * a:	&lt;original instruction&gt;		&lt;= 15
			 *	jmp	0(%rip)			    6
			 *	&lt;pc + tp-&gt;ftt_size&gt;		    8
			 * b:	&lt;original instruction&gt;		&lt;= 15
			 * 	int	T_DTRACE_RET		    2
			 * 					-----
			 * 					&lt;= 46
			 *
			 * The %pc is set to a, and curthread-&gt;t_dtrace_astpc is set
			 * to b. If we encounter a signal on the way out of the
			 * kernel, trap() will set %pc to curthread-&gt;t_dtrace_astpc
			 * so that we execute the original instruction and re-enter
			 * the kernel rather than redirecting to the next instruction.
			 *
			 * If there are return probes (so we know that we're going to
			 * need to reenter the kernel after executing the original
			 * instruction), the scratch space will just contain the
			 * original instruction followed by an interrupt -- the same
			 * data as at b.
			 *
			 * %rip-relative Addressing
			 * ------------------------
			 *
			 * There's a further complication in 64-bit mode due to %rip-
			 * relative addressing. While this is clearly a beneficial
			 * architectural decision for position independent code, it's
			 * hard not to see it as a personal attack against the pid
			 * provider since before there was a relatively small set of
			 * instructions to emulate; with %rip-relative addressing,
			 * almost every instruction can potentially depend on the
			 * address at which it's executed. Rather than emulating
			 * the broad spectrum of instructions that can now be
			 * position dependent, we emulate jumps and others as in
			 * 32-bit mode, and take a different tack for instructions
			 * using %rip-relative addressing.
			 *
			 * For every instruction that uses the ModRM byte, the
			 * in-kernel disassembler reports its location. We use the
			 * ModRM byte to identify that an instruction uses
			 * %rip-relative addressing and to see what other registers
			 * the instruction uses. To emulate those instructions,
			 * we modify the instruction to be %rax-relative rather than
			 * %rip-relative (or %rcx-relative if the instruction uses
			 * %rax; or %r8- or %r9-relative if the REX.B is present so
			 * we don't have to rewrite the REX prefix). We then load
			 * the value that %rip would have been into the scratch
			 * register and generate an instruction to reset the scratch
			 * register back to its original value. The instruction
			 * sequence looks like this:
			 *
			 *	64-mode %rip-relative		bytes
			 *	------------------------	-----
			 * a:	&lt;modified instruction&gt;		&lt;= 15
			 *	movq	$&lt;value&gt;, %&lt;scratch&gt;	    6
			 *	jmp	0(%rip)			    6
			 *	&lt;pc + tp-&gt;ftt_size&gt;		    8
			 * b:	&lt;modified instruction&gt;  	&lt;= 15
			 * 	int	T_DTRACE_RET		    2
			 * 					-----
			 *					   52
			 *
			 * We set curthread-&gt;t_dtrace_regv so that upon receiving
			 * a signal we can reset the value of the scratch register.
			 */</span>

			addr = uthread-&gt;t_dtrace_scratch-&gt;addr;

			<span class="enscript-keyword">if</span> (addr == 0LL) {
				fasttrap_sigtrap(p, uthread, pc); <span class="enscript-comment">// Should be killing target proc
</span>				new_pc = pc;
				<span class="enscript-keyword">break</span>;
			}

			ASSERT(tp-&gt;ftt_size &lt; FASTTRAP_MAX_INSTR_SIZE);

			uthread-&gt;t_dtrace_scrpc = addr;
			bcopy(tp-&gt;ftt_instr, &amp;scratch[i], tp-&gt;ftt_size);
			i += tp-&gt;ftt_size;

			<span class="enscript-keyword">if</span> (tp-&gt;ftt_ripmode != 0) {
				uint64_t* reg;
				
				ASSERT(tp-&gt;ftt_ripmode &amp;
				       (FASTTRAP_RIP_1 | FASTTRAP_RIP_2));
				
				<span class="enscript-comment">/*
				 * If this was a %rip-relative instruction, we change
				 * it to be either a %rax- or %rcx-relative
				 * instruction (depending on whether those registers
				 * are used as another operand; or %r8- or %r9-
				 * relative depending on the value of REX.B). We then
				 * set that register and generate a movq instruction
				 * to reset the value.
				 */</span>
				<span class="enscript-keyword">if</span> (tp-&gt;ftt_ripmode &amp; FASTTRAP_RIP_X)
					scratch[i++] = FASTTRAP_REX(1, 0, 0, 1);
				<span class="enscript-keyword">else</span>
					scratch[i++] = FASTTRAP_REX(1, 0, 0, 0);
				
				<span class="enscript-keyword">if</span> (tp-&gt;ftt_ripmode &amp; FASTTRAP_RIP_1)
					scratch[i++] = FASTTRAP_MOV_EAX;
				<span class="enscript-keyword">else</span>
					scratch[i++] = FASTTRAP_MOV_ECX;
				
				<span class="enscript-keyword">switch</span> (tp-&gt;ftt_ripmode) {
					<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_RIP_1</span>:
						reg = &amp;regs64-&gt;rax;
						uthread-&gt;t_dtrace_reg = REG_RAX;
						<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_RIP_2</span>:
						reg = &amp;regs64-&gt;rcx;
						uthread-&gt;t_dtrace_reg = REG_RCX;
						<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_RIP_1</span> | FASTTRAP_RIP_X:
						reg = &amp;regs64-&gt;r8;
						uthread-&gt;t_dtrace_reg = REG_R8;
						<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">case</span> <span class="enscript-reference">FASTTRAP_RIP_2</span> | FASTTRAP_RIP_X:
						reg = &amp;regs64-&gt;r9;
						uthread-&gt;t_dtrace_reg = REG_R9;
						<span class="enscript-keyword">break</span>;
					<span class="enscript-reference">default</span>:
						reg = NULL;
						panic(<span class="enscript-string">&quot;unhandled ripmode in fasttrap_pid_probe64&quot;</span>);
				}
				
				<span class="enscript-comment">/* LINTED - alignment */</span>
				*(uint64_t *)&amp;scratch[i] = *reg;
				uthread-&gt;t_dtrace_regv = *reg;
				*reg = pc + tp-&gt;ftt_size;
				i += <span class="enscript-keyword">sizeof</span> (uint64_t);
			}

			<span class="enscript-comment">/*
			 * Generate the branch instruction to what would have
			 * normally been the subsequent instruction. In 32-bit mode,
			 * this is just a relative branch; in 64-bit mode this is a
			 * %rip-relative branch that loads the 64-bit pc value
			 * immediately after the jmp instruction.
			 */</span>
			scratch[i++] = FASTTRAP_GROUP5_OP;
			scratch[i++] = FASTTRAP_MODRM(0, 4, 5);
			<span class="enscript-comment">/* LINTED - alignment */</span>
			*(uint32_t *)&amp;scratch[i] = 0;
			i += <span class="enscript-keyword">sizeof</span> (uint32_t);
			<span class="enscript-comment">/* LINTED - alignment */</span>
			*(uint64_t *)&amp;scratch[i] = pc + tp-&gt;ftt_size;
			i += <span class="enscript-keyword">sizeof</span> (uint64_t);

			uthread-&gt;t_dtrace_astpc = addr + i;
			bcopy(tp-&gt;ftt_instr, &amp;scratch[i], tp-&gt;ftt_size);
			i += tp-&gt;ftt_size;
			scratch[i++] = FASTTRAP_INT;
			scratch[i++] = T_DTRACE_RET;

			ASSERT(i &lt;= <span class="enscript-keyword">sizeof</span> (scratch));

			<span class="enscript-keyword">if</span> (fasttrap_copyout(scratch, addr, i)) {
				fasttrap_sigtrap(p, uthread, pc);
				new_pc = pc;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (tp-&gt;ftt_retids != NULL) {
				uthread-&gt;t_dtrace_step = 1;
				uthread-&gt;t_dtrace_ret = 1;
				new_pc = uthread-&gt;t_dtrace_astpc;
			} <span class="enscript-keyword">else</span> {
				new_pc = uthread-&gt;t_dtrace_scrpc;
			}
			
			uthread-&gt;t_dtrace_pc = pc;
			uthread-&gt;t_dtrace_npc = pc + tp-&gt;ftt_size;
			uthread-&gt;t_dtrace_on = 1;
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;fasttrap: mishandled an instruction&quot;</span>);
	}
	
<span class="enscript-reference">done</span>:
	<span class="enscript-comment">/*
	 * APPLE NOTE:
	 *
	 * We're setting this earlier than Solaris does, to get a &quot;correct&quot;
	 * ustack() output. In the Sun code,  a() -&gt; b() -&gt; c() -&gt; d() is
	 * reported at: d, b, a. The new way gives c, b, a, which is closer
	 * to correct, as the return instruction has already exectued.
	 */</span>
	regs64-&gt;isf.rip = new_pc;


	<span class="enscript-comment">/*
	 * If there were no return probes when we first found the tracepoint,
	 * we should feel no obligation to honor any return probes that were
	 * subsequently enabled -- they'll just have to wait until the next
	 * time around.
	 */</span>
	<span class="enscript-keyword">if</span> (tp-&gt;ftt_retids != NULL) {
		<span class="enscript-comment">/*
		 * We need to wait until the results of the instruction are
		 * apparent before invoking any return probes. If this
		 * instruction was emulated we can just call
		 * fasttrap_return_common(); if it needs to be executed, we
		 * need to wait until the user thread returns to the kernel.
		 */</span>
		<span class="enscript-keyword">if</span> (tp-&gt;ftt_type != FASTTRAP_T_COMMON) {
			fasttrap_return_common(regs, pc, pid, new_pc);
		} <span class="enscript-keyword">else</span> {
			ASSERT(uthread-&gt;t_dtrace_ret != 0);
			ASSERT(uthread-&gt;t_dtrace_pc == pc);
			ASSERT(uthread-&gt;t_dtrace_scrpc != 0);
			ASSERT(new_pc == uthread-&gt;t_dtrace_astpc);
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fasttrap_pid_probe</span>(x86_saved_state_t *regs)
{
        <span class="enscript-keyword">if</span> (is_saved_state64(regs))
		<span class="enscript-keyword">return</span> fasttrap_pid_probe64(regs);

	<span class="enscript-keyword">return</span> fasttrap_pid_probe32(regs);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fasttrap_return_probe</span>(x86_saved_state_t *regs)
{
	x86_saved_state64_t *regs64;
	x86_saved_state32_t *regs32;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> p_model;

        <span class="enscript-keyword">if</span> (is_saved_state64(regs)) {
                regs64 = saved_state64(regs);
		regs32 = NULL;
		p_model = DATAMODEL_LP64;
        } <span class="enscript-keyword">else</span> {
		regs64 = NULL;
                regs32 = saved_state32(regs);
		p_model = DATAMODEL_ILP32;
        }

	proc_t *p = current_proc();
	uthread_t uthread = (uthread_t)get_bsdthread_info(current_thread());
	user_addr_t pc = uthread-&gt;t_dtrace_pc;
	user_addr_t npc = uthread-&gt;t_dtrace_npc;

	uthread-&gt;t_dtrace_pc = 0;
	uthread-&gt;t_dtrace_npc = 0;
	uthread-&gt;t_dtrace_scrpc = 0;
	uthread-&gt;t_dtrace_astpc = 0;

	<span class="enscript-comment">/*
	 * Treat a child created by a call to vfork(2) as if it were its
	 * parent. We know that there's only one thread of control in such a
	 * process: this one.
	 */</span>
	proc_list_lock();
	<span class="enscript-keyword">while</span> (p-&gt;p_lflag &amp; P_LINVFORK)
		p = p-&gt;p_pptr;
	proc_list_unlock();

	<span class="enscript-comment">/*
	 * We set rp-&gt;r_pc to the address of the traced instruction so
	 * that it appears to dtrace_probe() that we're on the original
	 * instruction, and so that the user can't easily detect our
	 * complex web of lies. dtrace_return_probe() (our caller)
	 * will correctly set %pc after we return.
	 */</span>
	<span class="enscript-keyword">if</span> (p_model == DATAMODEL_LP64)
		regs64-&gt;isf.rip = pc;
	<span class="enscript-keyword">else</span>
		regs32-&gt;eip = pc;

	fasttrap_return_common(regs, pc, p-&gt;p_pid, npc);

	<span class="enscript-keyword">return</span> (0);
}

uint64_t
<span class="enscript-function-name">fasttrap_pid_getarg</span>(<span class="enscript-type">void</span> *arg, dtrace_id_t id, <span class="enscript-type">void</span> *parg, <span class="enscript-type">int</span> argno,
    <span class="enscript-type">int</span> aframes)
{
	pal_register_cache_state(current_thread(), VALID);
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>, <span class="enscript-variable-name">id</span>, <span class="enscript-variable-name">parg</span>, <span class="enscript-variable-name">aframes</span>)
	<span class="enscript-keyword">return</span> (fasttrap_anarg((x86_saved_state_t *)find_user_regs(current_thread()), 1, argno));
}

uint64_t
<span class="enscript-function-name">fasttrap_usdt_getarg</span>(<span class="enscript-type">void</span> *arg, dtrace_id_t id, <span class="enscript-type">void</span> *parg, <span class="enscript-type">int</span> argno,
    <span class="enscript-type">int</span> aframes)
{
	pal_register_cache_state(current_thread(), VALID);
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>, <span class="enscript-variable-name">id</span>, <span class="enscript-variable-name">parg</span>, <span class="enscript-variable-name">aframes</span>)
	<span class="enscript-keyword">return</span> (fasttrap_anarg((x86_saved_state_t *)find_user_regs(current_thread()), 0, argno));
}

<span class="enscript-comment">/*
 * APPLE NOTE: See comments by regmap array definition. We are cheating
 * when returning 32 bit registers.
 */</span>
<span class="enscript-type">static</span> user_addr_t
<span class="enscript-function-name">fasttrap_getreg</span>(x86_saved_state_t *regs, uint_t reg)
{
	<span class="enscript-keyword">if</span> (is_saved_state64(regs)) {
		x86_saved_state64_t *regs64 = saved_state64(regs);

		<span class="enscript-keyword">switch</span> (reg) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RAX</span>:		<span class="enscript-keyword">return</span> regs64-&gt;rax;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RCX</span>:		<span class="enscript-keyword">return</span> regs64-&gt;rcx;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RDX</span>:		<span class="enscript-keyword">return</span> regs64-&gt;rdx;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RBX</span>:		<span class="enscript-keyword">return</span> regs64-&gt;rbx;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RSP</span>:		<span class="enscript-keyword">return</span> regs64-&gt;isf.rsp;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RBP</span>:		<span class="enscript-keyword">return</span> regs64-&gt;rbp;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RSI</span>:		<span class="enscript-keyword">return</span> regs64-&gt;rsi;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RDI</span>:		<span class="enscript-keyword">return</span> regs64-&gt;rdi;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R8</span>:		<span class="enscript-keyword">return</span> regs64-&gt;r8;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R9</span>:		<span class="enscript-keyword">return</span> regs64-&gt;r9;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R10</span>:		<span class="enscript-keyword">return</span> regs64-&gt;r10;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R11</span>:		<span class="enscript-keyword">return</span> regs64-&gt;r11;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R12</span>:		<span class="enscript-keyword">return</span> regs64-&gt;r12;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R13</span>:		<span class="enscript-keyword">return</span> regs64-&gt;r13;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R14</span>:		<span class="enscript-keyword">return</span> regs64-&gt;r14;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_R15</span>:		<span class="enscript-keyword">return</span> regs64-&gt;r15;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_TRAPNO</span>:	<span class="enscript-keyword">return</span> regs64-&gt;isf.trapno;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_ERR</span>:		<span class="enscript-keyword">return</span> regs64-&gt;isf.err;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RIP</span>:		<span class="enscript-keyword">return</span> regs64-&gt;isf.rip;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_CS</span>:		<span class="enscript-keyword">return</span> regs64-&gt;isf.cs;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RFL</span>:		<span class="enscript-keyword">return</span> regs64-&gt;isf.rflags;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_SS</span>:		<span class="enscript-keyword">return</span> regs64-&gt;isf.ss;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_FS</span>:		<span class="enscript-keyword">return</span> regs64-&gt;fs;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_GS</span>:		<span class="enscript-keyword">return</span> regs64-&gt;gs;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_ES</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_DS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_FSBASE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_GSBASE</span>:
				<span class="enscript-comment">// Important to distinguish these requests (which should be legal) from other values.
</span>				panic(<span class="enscript-string">&quot;dtrace: unimplemented x86_64 getreg()&quot;</span>);
		}

		panic(<span class="enscript-string">&quot;dtrace: unhandled x86_64 getreg() constant&quot;</span>);
	} <span class="enscript-keyword">else</span> {
		x86_saved_state32_t *regs32 = saved_state32(regs);

		<span class="enscript-keyword">switch</span> (reg) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RAX</span>:		<span class="enscript-keyword">return</span> regs32-&gt;eax;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RCX</span>:		<span class="enscript-keyword">return</span> regs32-&gt;ecx;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RDX</span>:		<span class="enscript-keyword">return</span> regs32-&gt;edx;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RBX</span>:		<span class="enscript-keyword">return</span> regs32-&gt;ebx;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RSP</span>:		<span class="enscript-keyword">return</span> regs32-&gt;uesp;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RBP</span>:		<span class="enscript-keyword">return</span> regs32-&gt;ebp;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RSI</span>:		<span class="enscript-keyword">return</span> regs32-&gt;esi;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">REG_RDI</span>:		<span class="enscript-keyword">return</span> regs32-&gt;edi;
		}

		panic(<span class="enscript-string">&quot;dtrace: unhandled i386 getreg() constant&quot;</span>);
	}

	<span class="enscript-keyword">return</span> 0;
}
</pre>
<hr />
</body></html>