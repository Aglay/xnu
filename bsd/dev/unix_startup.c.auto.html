<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>unix_startup.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">unix_startup.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1992,7 NeXT Computer, Inc.
 *
 * Unix data structure initialization.
 *
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/clist.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/tty.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/cons.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>

<span class="enscript-type">extern</span> uint32_t kern_maxvnodes;
<span class="enscript-type">extern</span> vm_map_t mb_map;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span> || <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">extern</span> uint32_t   tcp_sendspace;
<span class="enscript-type">extern</span> uint32_t   tcp_recvspace;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span>            <span class="enscript-function-name">bsd_bufferinit</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	bsd_mbuf_cluster_reserve(boolean_t *);
<span class="enscript-type">void</span> <span class="enscript-function-name">bsd_scale_setup</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">bsd_exec_setup</span>(<span class="enscript-type">int</span>);

<span class="enscript-comment">/*
 * Declare these as initialized data so we can patch them.
 */</span>

#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">NBUF</span>
<span class="enscript-type">int</span>             max_nbuf_headers = NBUF;
<span class="enscript-type">int</span>             niobuf_headers = (NBUF / 2) + 2048;
<span class="enscript-type">int</span> 		nbuf_hashelements = NBUF;
<span class="enscript-type">int</span> 		nbuf_headers = NBUF;
#<span class="enscript-reference">else</span>
<span class="enscript-type">int</span>             max_nbuf_headers = 0;
<span class="enscript-type">int</span>             niobuf_headers = 0;
<span class="enscript-type">int</span> 		nbuf_hashelements = 0;
<span class="enscript-type">int</span>		nbuf_headers = 0;
#<span class="enscript-reference">endif</span>

<span class="enscript-function-name">SYSCTL_INT</span> (_kern, OID_AUTO, nbuf, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;nbuf_headers, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span> (_kern, OID_AUTO, maxnbuf, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;max_nbuf_headers, 0, <span class="enscript-string">&quot;&quot;</span>);

__private_extern__ <span class="enscript-type">int</span> customnbuf = 0;
<span class="enscript-type">int</span>             serverperfmode = 0;	<span class="enscript-comment">/* Flag indicates a server boot when set */</span>
<span class="enscript-type">int</span>             ncl = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SOCKETS</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mbuf_poolsz;
#<span class="enscript-reference">endif</span>

vm_map_t        buffer_map;
vm_map_t        bufferhdr_map;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> vnodes_sized = 0;

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>     <span class="enscript-function-name">bsd_startupearly</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span>
<span class="enscript-function-name">bsd_startupearly</span>(<span class="enscript-type">void</span>)
{
	vm_offset_t     firstaddr;
	vm_size_t       size;
	kern_return_t   ret;

	<span class="enscript-comment">/* clip the number of buf headers upto 16k */</span>
	<span class="enscript-keyword">if</span> (max_nbuf_headers == 0)
		max_nbuf_headers = atop_kernel(sane_size / 50);	<span class="enscript-comment">/* Get 2% of ram, but no more than we can map */</span>
	<span class="enscript-keyword">if</span> ((customnbuf == 0) &amp;&amp; (max_nbuf_headers &gt; 16384))
		max_nbuf_headers = 16384;
	<span class="enscript-keyword">if</span> (max_nbuf_headers &lt; CONFIG_MIN_NBUF)
		max_nbuf_headers = CONFIG_MIN_NBUF;

	<span class="enscript-comment">/* clip the number of hash elements  to 200000 */</span>
	<span class="enscript-keyword">if</span> ( (customnbuf == 0 ) &amp;&amp; nbuf_hashelements == 0) {
		nbuf_hashelements = atop_kernel(sane_size / 50);
		<span class="enscript-keyword">if</span> (nbuf_hashelements &gt; 200000)
			nbuf_hashelements = 200000;
	} <span class="enscript-keyword">else</span>
		nbuf_hashelements = max_nbuf_headers;

	<span class="enscript-keyword">if</span> (niobuf_headers == 0) {
		<span class="enscript-keyword">if</span> (max_nbuf_headers &lt; 4096)
			niobuf_headers = max_nbuf_headers;
		<span class="enscript-keyword">else</span>
			niobuf_headers = (max_nbuf_headers / 2) + 2048;
	}
	<span class="enscript-keyword">if</span> (niobuf_headers &lt; CONFIG_MIN_NIOBUF)
		niobuf_headers = CONFIG_MIN_NIOBUF;

	size = (max_nbuf_headers + niobuf_headers) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> buf);
	size = round_page(size);

	ret = kmem_suballoc(kernel_map,
			    &amp;firstaddr,
			    size,
			    FALSE,
			    VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_KERN_MEMORY_FILE),
			    &amp;bufferhdr_map);

	<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;Failed to create bufferhdr_map&quot;</span>);

	ret = kernel_memory_allocate(bufferhdr_map,
				     &amp;firstaddr,
				     size,
				     0,
				     KMA_HERE | KMA_KOBJECT,
				     VM_KERN_MEMORY_FILE);

	<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;Failed to allocate bufferhdr_map&quot;</span>);

	buf_headers = (<span class="enscript-type">struct</span> buf *) firstaddr;
	bzero(buf_headers, size);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SOCKETS</span>
	{
		<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	maxspace = 128 * 1024;
		<span class="enscript-type">int</span>             scale;

		nmbclusters = bsd_mbuf_cluster_reserve(NULL) / MCLBYTES;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span> || <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">if</span> ((scale = nmbclusters / NMBCLUSTERS) &gt; 1) {
			tcp_sendspace *= scale;
			tcp_recvspace *= scale;

			<span class="enscript-keyword">if</span> (tcp_sendspace &gt; maxspace)
				tcp_sendspace = maxspace;
			<span class="enscript-keyword">if</span> (tcp_recvspace &gt; maxspace)
				tcp_recvspace = maxspace;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET || INET6 */</span>
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* SOCKETS */</span>

	<span class="enscript-keyword">if</span> (vnodes_sized == 0) {
		<span class="enscript-keyword">if</span> (!PE_get_default(<span class="enscript-string">&quot;kern.maxvnodes&quot;</span>, &amp;desiredvnodes, <span class="enscript-keyword">sizeof</span>(desiredvnodes))) {
			<span class="enscript-comment">/*
			 * Size vnodes based on memory 
			 * Number vnodes  is (memsize/64k) + 1024 
			 * This is the calculation that is used by launchd in tiger
			 * we are clipping the max based on 16G 
			 * ie ((16*1024*1024*1024)/(64 *1024)) + 1024 = 263168;
			 * CONFIG_VNODES is set to 263168 for &quot;medium&quot; configurations (the default)
			 * but can be smaller or larger. 
			 */</span>
			desiredvnodes  = (sane_size/65536) + 1024;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_VNODES</span>
				<span class="enscript-keyword">if</span> (desiredvnodes &gt; CONFIG_VNODES)
					desiredvnodes = CONFIG_VNODES;
#<span class="enscript-reference">endif</span>
		}
		vnodes_sized = 1;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bsd_bufferinit</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SOCKETS</span>
	kern_return_t   ret;
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Note: Console device initialized in kminit() from bsd_autoconf()
	 * prior to call to us in bsd_init().
	 */</span>

	bsd_startupearly();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SOCKETS</span>
	ret = kmem_suballoc(kernel_map,
			    (vm_offset_t *) &amp;mbutl,
			    (vm_size_t) (nmbclusters * MCLBYTES),
			    FALSE,
			    VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_KERN_MEMORY_MBUF),
			    &amp;mb_map);

	<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;Failed to allocate mb_map\n&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* SOCKETS */</span>

	<span class="enscript-comment">/*
	 * Set up buffers, so they can be used to read disk labels.
	 */</span>
	bufinit();
}

<span class="enscript-comment">/* 512 MB (K32) or 2 GB (K64) hard limit on size of the mbuf pool */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_MBUF_POOL</span>	(512 &lt;&lt; MBSHIFT)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_MBUF_POOL</span>	(2ULL &lt;&lt; GBSHIFT)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_NCL</span>		(MAX_MBUF_POOL &gt;&gt; MCLSHIFT)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SOCKETS</span>
<span class="enscript-comment">/*
 * this has been broken out into a separate routine that
 * can be called from the x86 early vm initialization to
 * determine how much lo memory to reserve on systems with
 * DMA hardware that can't fully address all of the physical
 * memory that is present.
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bsd_mbuf_cluster_reserve</span>(boolean_t *overridden)
{
	<span class="enscript-type">int</span> mbuf_pool = 0;
	<span class="enscript-type">static</span> boolean_t was_overridden = FALSE;

	<span class="enscript-comment">/* If called more than once, return the previously calculated size */</span>
	<span class="enscript-keyword">if</span> (mbuf_poolsz != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-comment">/*
	 * Some of these are parsed in parse_bsd_args(), but for x86 we get
	 * here early from i386_vm_init() and so we parse them now, in order
	 * to correctly compute the size of the low-memory VM pool.  It is
	 * redundant but rather harmless.
	 */</span>
	(<span class="enscript-type">void</span>) PE_parse_boot_argn(<span class="enscript-string">&quot;ncl&quot;</span>, &amp;ncl, <span class="enscript-keyword">sizeof</span> (ncl));
	(<span class="enscript-type">void</span>) PE_parse_boot_argn(<span class="enscript-string">&quot;mbuf_pool&quot;</span>, &amp;mbuf_pool, <span class="enscript-keyword">sizeof</span> (mbuf_pool));

	<span class="enscript-comment">/*
	 * Convert &quot;mbuf_pool&quot; from MB to # of 2KB clusters; it is
	 * equivalent to &quot;ncl&quot;, except that it uses different unit.
	 */</span>
	<span class="enscript-keyword">if</span> (mbuf_pool != 0)
		ncl = (mbuf_pool &lt;&lt; MBSHIFT) &gt;&gt; MCLSHIFT;

        <span class="enscript-keyword">if</span> (sane_size &gt; (64 * 1024 * 1024) || ncl != 0) {

		<span class="enscript-keyword">if</span> (ncl || serverperfmode)
			was_overridden = TRUE;

	        <span class="enscript-keyword">if</span> ((nmbclusters = ncl) == 0) {
			<span class="enscript-comment">/* Auto-configure the mbuf pool size */</span>
			nmbclusters = mbuf_default_ncl(serverperfmode, sane_size);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Make sure it's not odd in case ncl is manually set */</span>
			<span class="enscript-keyword">if</span> (nmbclusters &amp; 0x1)
				--nmbclusters;

			<span class="enscript-comment">/* And obey the upper limit */</span>
			<span class="enscript-keyword">if</span> (nmbclusters &gt; MAX_NCL)
				nmbclusters = MAX_NCL;
		}

		<span class="enscript-comment">/* Round it down to nearest multiple of PAGE_SIZE */</span>
		nmbclusters = P2ROUNDDOWN(nmbclusters, NCLPG);
	}
	mbuf_poolsz = nmbclusters &lt;&lt; MCLSHIFT;
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (overridden)
		*overridden = was_overridden;

	<span class="enscript-keyword">return</span> (mbuf_poolsz);
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcp_tcbhashsize;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> max_cached_sock_count;
#<span class="enscript-reference">endif</span> 


<span class="enscript-type">void</span>
<span class="enscript-function-name">bsd_scale_setup</span>(<span class="enscript-type">int</span> scale)
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
	<span class="enscript-keyword">if</span> ((scale &gt; 0) &amp;&amp; (serverperfmode == 0)) {
		maxproc *= scale;
		maxprocperuid = (maxproc * 2) / 3;
	}
	<span class="enscript-comment">/* Apply server scaling rules */</span>
	<span class="enscript-keyword">if</span> ((scale &gt;  0) &amp;&amp; (serverperfmode !=0)) {
		maxproc = 2500 * scale;
		hard_maxproc = maxproc;
		<span class="enscript-comment">/* no fp usage */</span>
		maxprocperuid = (maxproc*3)/4;
		maxfiles = (150000 * scale);
		maxfilesperproc = maxfiles/2;
		desiredvnodes = maxfiles;
		vnodes_sized = 1;
		tcp_tfo_backlog = 100 * scale;
		<span class="enscript-keyword">if</span> (scale &gt; 4) {
			<span class="enscript-comment">/* clip somaxconn at 32G level */</span>
			somaxconn = 2048;
			<span class="enscript-comment">/*
			 * For scale &gt; 4 (&gt; 32G), clip
			 * tcp_tcbhashsize to 32K
			 */</span>
			tcp_tcbhashsize = 32 *1024;

			<span class="enscript-keyword">if</span> (scale &gt; 7) {
				<span class="enscript-comment">/* clip at 64G level */</span>
				max_cached_sock_count = 165000;
			} <span class="enscript-keyword">else</span> {
				max_cached_sock_count = 60000 + ((scale-1) * 15000);
			}
		} <span class="enscript-keyword">else</span> {
			somaxconn = 512*scale;
			tcp_tcbhashsize = 4*1024*scale;
			max_cached_sock_count = 60000 + ((scale-1) * 15000);
		}
	}
#<span class="enscript-reference">endif</span>
	bsd_exec_setup(scale);
}

</pre>
<hr />
</body></html>