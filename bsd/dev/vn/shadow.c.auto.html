<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>shadow.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">shadow.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2001-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * shadow.c
 *
 * Implement copy-on-write shadow map to allow a disk image to be
 * mounted read-only, yet be writable by transferring writes to a
 * &quot;shadow&quot; file.  Subsequent reads from blocks that have been
 * written will then go the &quot;shadow&quot; file.
 *
 * The map has two parts:
 * 1) a bit map to track which blocks have been written
 * 2) a band map to map a &quot;band&quot; within the original file to a corresponding
 *    &quot;band&quot; in the shadow file.  Each band has the same size.
 *
 * The band map is used to ensure that blocks that are contiguous in the 
 * original file will remain contiguous in the shadow file.
 *
 * For debugging purposes, this file can be compiled standalone using:
 * cc -o shadow shadow.c -DTEST_SHADOW
 */</span>

<span class="enscript-comment">/*
 * Modification History
 *
 * December 21, 2001 	Dieter Siegmund (<a href="mailto:dieter@apple.com">dieter@apple.com</a>)
 * - initial revision
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">TEST_SHADOW</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">my_malloc</span>(a)	malloc(a)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">my_free</span>(a)	free(a)
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !TEST_SHADOW */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">my_malloc</span>(a)	_MALLOC(a, M_TEMP, M_WAITOK)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">my_free</span>(a)	FREE(a, M_TEMP)
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* TEST_SHADOW */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;shadow.h&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UINT32_ALL_ONES</span>			((uint32_t)(-1))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">USHORT_ALL_ONES</span>			((u_short)(-1))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UCHAR_ALL_ONES</span>			((u_char)(-1))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">my_trunc</span>(value, divisor)	((value) / (divisor) * (divisor))

<span class="enscript-comment">/* a band size of 128K can represent a file up to 8GB */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BAND_SIZE_DEFAULT_POWER_2</span>	17
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BAND_SIZE_DEFAULT</span>		(1 &lt;&lt; BAND_SIZE_DEFAULT_POWER_2)

<span class="enscript-type">typedef</span> u_short	band_number_t;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BAND_ZERO</span>			((band_number_t)0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BAND_MAX</span>			((band_number_t)65535)

<span class="enscript-type">struct</span> shadow_map {
    uint32_t		blocks_per_band;<span class="enscript-comment">/* size in blocks */</span>
    uint32_t		block_size;
    u_char *		block_bitmap;		<span class="enscript-comment">/* 1 bit per block; 1=written */</span>
    band_number_t *	bands;			<span class="enscript-comment">/* band map array */</span>
    uint32_t		file_size_blocks;	<span class="enscript-comment">/* size of file in bands */</span>
    uint32_t		shadow_size_bands;	<span class="enscript-comment">/* size of shadow in bands */</span>
    uint32_t 		next_band;		<span class="enscript-comment">/* next free band */</span>
    uint32_t		zeroth_band;		<span class="enscript-comment">/* special-case 0th band */</span>
};


<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
    uint32_t	byte;
    uint32_t	bit;
} bitmap_offset_t;

<span class="enscript-type">static</span> __inline__ u_char
<span class="enscript-function-name">bit</span>(<span class="enscript-type">int</span> b)
{
    <span class="enscript-keyword">return</span> ((u_char)(1 &lt;&lt; b));
}

<span class="enscript-comment">/* 
 * Function: bits_lower
 * Purpose:
 *   Return a byte value in which bits numbered lower than 'b' are set.
 */</span>
<span class="enscript-type">static</span> __inline__ u_char
<span class="enscript-function-name">bits_lower</span>(<span class="enscript-type">int</span> b)
{
    <span class="enscript-keyword">return</span> ((u_char)(bit(b) - 1));
}

<span class="enscript-comment">/*
 * Function: byte_set_bits
 * Purpose:
 *   Set the given range of bits within a byte.
 */</span>
<span class="enscript-type">static</span> __inline__ u_char
<span class="enscript-function-name">byte_set_bits</span>(<span class="enscript-type">int</span> start, <span class="enscript-type">int</span> end)
{
    <span class="enscript-keyword">return</span> ((u_char)((~bits_lower(start)) &amp; (bits_lower(end) | bit(end))));
}

<span class="enscript-type">static</span> __inline__ bitmap_offset_t
<span class="enscript-function-name">bitmap_offset</span>(off_t where)
{
    bitmap_offset_t	b;

    b.byte = where / NBBY;
    b.bit = where % NBBY;
    <span class="enscript-keyword">return</span> (b);
}

<span class="enscript-comment">/* 
 * Function: bitmap_set
 *
 * Purpose:
 *   Set the given range of bits.
 *
 *   This algorithm tries to set the extents using the biggest
 *   units, using longs, then a short, then a byte, then bits.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">bitmap_set</span>(u_char * map, uint32_t start_bit, uint32_t bit_count)
{
    bitmap_offset_t 	start;
    bitmap_offset_t	end;

    start = bitmap_offset(start_bit);
    end = bitmap_offset(start_bit + bit_count);
    <span class="enscript-keyword">if</span> (start.byte &lt; end.byte) {
	uint32_t n_bytes;

	<span class="enscript-keyword">if</span> (start.bit) {
	    map[start.byte] |= byte_set_bits(start.bit, NBBY - 1);
	    start.bit = 0;
	    start.byte++;
	    <span class="enscript-keyword">if</span> (start.byte == end.byte)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}
			
	n_bytes = end.byte - start.byte;
	
	<span class="enscript-keyword">while</span> (n_bytes &gt;= (<span class="enscript-keyword">sizeof</span>(uint32_t))) {
	    *((uint32_t *)(map + start.byte)) = UINT32_ALL_ONES;
	    start.byte += <span class="enscript-keyword">sizeof</span>(uint32_t);
	    n_bytes -= <span class="enscript-keyword">sizeof</span>(uint32_t);
	}
	<span class="enscript-keyword">if</span> (n_bytes &gt;= <span class="enscript-keyword">sizeof</span>(u_short)) {
	    *((u_short *)(map + start.byte)) = USHORT_ALL_ONES;
	    start.byte += <span class="enscript-keyword">sizeof</span>(u_short);
	    n_bytes -= <span class="enscript-keyword">sizeof</span>(u_short);
	}
	<span class="enscript-keyword">if</span> (n_bytes == 1) {
	    map[start.byte] = UCHAR_ALL_ONES;
	    start.byte++;
	    n_bytes = 0;
	}
    }

 <span class="enscript-reference">end</span>:
    <span class="enscript-keyword">if</span> (end.bit &gt; start.bit) {
	map[start.byte] |= byte_set_bits(start.bit, end.bit - 1);
    }

    <span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Function: bitmap_get
 *
 * Purpose:
 *   Return the number of bits in the range that are the same e.g.
 *   11101 returns 3 because the first 3 bits are the same (1's), whereas
 *   001100 returns 2 because the first 2 bits are the same.
 *   This algorithm tries to count things in as big a chunk as possible,
 *   first aligning to a byte offset, then trying to count longs, a short,
 *   a byte, then any remaining bits to find the bit that is different.
 */</span>

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">bitmap_get</span>(u_char * map, uint32_t start_bit, uint32_t bit_count, 
	   boolean_t * ret_is_set)
{
    uint32_t		count;
    <span class="enscript-type">int</span>			i;
    boolean_t		is_set;
    bitmap_offset_t 	start;
    bitmap_offset_t	end;

    start = bitmap_offset(start_bit);
    end = bitmap_offset(start_bit + bit_count);

    is_set = (map[start.byte] &amp; bit(start.bit)) ? TRUE : FALSE;
    count = 0;

    <span class="enscript-keyword">if</span> (start.byte &lt; end.byte) {
	uint32_t n_bytes;

	<span class="enscript-keyword">if</span> (start.bit) { <span class="enscript-comment">/* try to align to a byte */</span>
	    <span class="enscript-keyword">for</span> (i = start.bit; i &lt; NBBY; i++) {
		boolean_t	this_is_set;

		this_is_set = (map[start.byte] &amp; bit(i)) ? TRUE : FALSE;
		<span class="enscript-keyword">if</span> (this_is_set != is_set) {
		    <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>; <span class="enscript-comment">/* found bit that was different, we're done */</span>
		}
		count++;
	    }
	    start.bit = 0; <span class="enscript-comment">/* made it to the next byte */</span>
	    start.byte++;
	    <span class="enscript-keyword">if</span> (start.byte == end.byte)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; <span class="enscript-comment">/* no more bytes, check for any leftover bits */</span>
	}
	<span class="enscript-comment">/* calculate how many bytes are left in the range */</span>
	n_bytes = end.byte - start.byte;

	<span class="enscript-comment">/* check for 4 bytes of the same bits */</span>
	<span class="enscript-keyword">while</span> (n_bytes &gt;= <span class="enscript-keyword">sizeof</span>(uint32_t)) {
	    uint32_t * valPtr = (uint32_t *)(map + start.byte);
	    <span class="enscript-keyword">if</span> ((is_set &amp;&amp; *valPtr == UINT32_ALL_ONES) 
		|| (!is_set &amp;&amp; *valPtr == 0)) {
		count += <span class="enscript-keyword">sizeof</span>(*valPtr) * NBBY;
		start.byte += <span class="enscript-keyword">sizeof</span>(*valPtr);
		n_bytes -= <span class="enscript-keyword">sizeof</span>(*valPtr);
	    }
	    <span class="enscript-keyword">else</span>
		<span class="enscript-keyword">break</span>; <span class="enscript-comment">/* bits differ */</span>

	}
	<span class="enscript-comment">/* check for 2 bytes of the same bits */</span>
	<span class="enscript-keyword">if</span> (n_bytes &gt;= <span class="enscript-keyword">sizeof</span>(u_short)) {
	    u_short * valPtr = (u_short *)(map + start.byte);
			
	    <span class="enscript-keyword">if</span> ((is_set &amp;&amp; *valPtr == USHORT_ALL_ONES) 
		|| (!is_set &amp;&amp; (*valPtr == 0))) {
		count += <span class="enscript-keyword">sizeof</span>(*valPtr) * NBBY;
		start.byte += <span class="enscript-keyword">sizeof</span>(*valPtr);
		n_bytes -= <span class="enscript-keyword">sizeof</span>(*valPtr);
	    }
	}

	<span class="enscript-comment">/* check for 1 byte of the same bits */</span>
	<span class="enscript-keyword">if</span> (n_bytes) { 
	    <span class="enscript-keyword">if</span> ((is_set &amp;&amp; map[start.byte] == UCHAR_ALL_ONES) 
		|| (!is_set &amp;&amp; map[start.byte] == 0)) {
		count += NBBY;
		start.byte++;
		n_bytes--;
	    }
	    <span class="enscript-comment">/* we found bits that were different, find the first one */</span>
	    <span class="enscript-keyword">if</span> (n_bytes) { 
		<span class="enscript-keyword">for</span> (i = 0; i &lt; NBBY; i++) {
		    boolean_t	this_is_set;

		    this_is_set = (map[start.byte] &amp; bit(i)) ? TRUE : FALSE;
		    <span class="enscript-keyword">if</span> (this_is_set != is_set) {
			<span class="enscript-keyword">break</span>;
		    }
		    count++;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	    }
	}
    }

 <span class="enscript-reference">end</span>:
    <span class="enscript-keyword">for</span> (i = start.bit; i &lt; (<span class="enscript-type">int</span>)end.bit; i++) {
	boolean_t this_is_set = (map[start.byte] &amp; bit(i)) ? TRUE : FALSE;
	
	<span class="enscript-keyword">if</span> (this_is_set != is_set) {
	    <span class="enscript-keyword">break</span>;
	}
	count++;
    }

 <span class="enscript-reference">done</span>:
    *ret_is_set = is_set;
    <span class="enscript-keyword">return</span> (count);
}

<span class="enscript-type">static</span> __inline__ band_number_t
<span class="enscript-function-name">shadow_map_block_to_band</span>(shadow_map_t * map, uint32_t block)
{
    <span class="enscript-keyword">return</span> (block / map-&gt;blocks_per_band);
}

<span class="enscript-comment">/*
 * Function: shadow_map_mapped_band
 * Purpose:
 *   Return the mapped band for the given band.
 *   If map_it is FALSE, and the band is not mapped, return FALSE.
 *   If map_it is TRUE, then this function will always return TRUE.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">shadow_map_mapped_band</span>(shadow_map_t * map, band_number_t band,
		       boolean_t map_it, band_number_t * mapped_band)
{
    boolean_t		is_mapped = FALSE;

    <span class="enscript-keyword">if</span> (band == map-&gt;zeroth_band) {
	*mapped_band = BAND_ZERO;
	is_mapped = TRUE;
    }
    <span class="enscript-keyword">else</span> {
	*mapped_band = map-&gt;bands[band];
	<span class="enscript-keyword">if</span> (*mapped_band == BAND_ZERO) {
	    <span class="enscript-keyword">if</span> (map_it) {
		<span class="enscript-comment">/* grow the file */</span>
		<span class="enscript-keyword">if</span> (map-&gt;next_band == 0) {
		    <span class="enscript-comment">/* remember the zero'th band */</span>
		    map-&gt;zeroth_band = band;
		}
		*mapped_band = map-&gt;bands[band] = map-&gt;next_band++;
		is_mapped = TRUE;
	    }
	}
	<span class="enscript-keyword">else</span> {
	    is_mapped = TRUE;
	}
    }
    <span class="enscript-keyword">return</span> (is_mapped);
}

<span class="enscript-comment">/* 
 * Function: shadow_map_contiguous
 *
 * Purpose:
 *   Return the first offset within the range position..(position + count) 
 *   that is not a contiguous mapped band.
 *
 *   If called with is_write = TRUE, this function will map bands as it goes.
 */</span>
<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">shadow_map_contiguous</span>(shadow_map_t * map, uint32_t start_block,
		      uint32_t num_blocks, boolean_t is_write)
{
    band_number_t	band = shadow_map_block_to_band(map, start_block);
    uint32_t		end_block = start_block + num_blocks;
    boolean_t		is_mapped;
    band_number_t	mapped_band;
    uint32_t		ret_end_block = end_block;
    uint32_t		p;

    is_mapped = shadow_map_mapped_band(map, band, is_write, &amp;mapped_band);
    <span class="enscript-keyword">if</span> (is_write == FALSE &amp;&amp; is_mapped == FALSE) {
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> happened = 0;
	<span class="enscript-comment">/* this can't happen */</span>
	<span class="enscript-keyword">if</span> (happened == 0) {
	    printf(<span class="enscript-string">&quot;shadow_map_contiguous: this can't happen!\n&quot;</span>);
	    happened = 1;
	}
	<span class="enscript-keyword">return</span> (start_block);
    }
    <span class="enscript-keyword">for</span> (p = my_trunc(start_block + map-&gt;blocks_per_band, 
		      map-&gt;blocks_per_band);
	 p &lt; end_block; p += map-&gt;blocks_per_band) {
	band_number_t 	next_mapped_band;
		
	band++;
	is_mapped = shadow_map_mapped_band(map, band, is_write,
					   &amp;next_mapped_band);
	<span class="enscript-keyword">if</span> (is_write == FALSE &amp;&amp; is_mapped == FALSE) {
	    <span class="enscript-keyword">return</span> (p);
	}
	<span class="enscript-keyword">if</span> ((mapped_band + 1) != next_mapped_band) {
	    <span class="enscript-comment">/* not contiguous */</span>
	    ret_end_block = p;
	    <span class="enscript-keyword">break</span>;
	}
	mapped_band = next_mapped_band;
    }
    <span class="enscript-keyword">return</span> (ret_end_block);
}


<span class="enscript-comment">/* 
 * Function: block_bitmap_size
 * Purpose:
 *   The number of bytes required in a block bitmap to represent a file of size 
 *   file_size.
 *
 *   The bytes required is the number of blocks in the file,
 *   divided by the number of bits per byte.
 * Note:
 *   An 8GB file requires (assuming 512 byte block):
 *   2^33 / 2^9 / 2^3 = 2^21 = 2MB
 *   of bitmap space.  This is a non-trival amount of memory,
 *   particularly since most of the bits will be zero.
 *   A sparse bitmap would really help in this case.
 */</span>
<span class="enscript-type">static</span> __inline__ uint32_t
<span class="enscript-function-name">block_bitmap_size</span>(off_t file_size, uint32_t block_size)
{
    off_t blocks = howmany(file_size, block_size);
    <span class="enscript-keyword">return</span> (howmany(blocks, NBBY));
}

<span class="enscript-comment">/*
 * Function: shadow_map_read
 *
 * Purpose:
 *   Calculate the block offset within the shadow to read, and the number
 *   blocks to read.  The input values (block_offset, block_count) refer
 *   to the original file.
 *
 *   The output values (*incr_block_offset, *incr_block_count) refer to the
 *   shadow file if the return value is TRUE.  They refer to the original
 *   file if the return value is FALSE.

 *   Blocks within a band may or may not have been written, in addition,
 *   Bands are not necessarily contiguous, therefore:
 *   	*incr_block_count &lt;= block_count
 *   The caller must be prepared to call this function interatively
 *   to complete the whole i/o.
 * Returns:
 *   TRUE if the shadow file should be read, FALSE if the original file
 *   should be read.
 */</span>
boolean_t
<span class="enscript-function-name">shadow_map_read</span>(shadow_map_t * map, uint32_t block_offset, uint32_t block_count,
		uint32_t * incr_block_offset, uint32_t * incr_block_count)
{
    boolean_t		written = FALSE;
    uint32_t		n_blocks;

    <span class="enscript-keyword">if</span> (block_offset &gt;= map-&gt;file_size_blocks
	|| (block_offset + block_count) &gt; map-&gt;file_size_blocks) {
	printf(<span class="enscript-string">&quot;shadow_map_read: request (%d, %d) exceeds file size %d\n&quot;</span>,
	       block_offset, block_count, map-&gt;file_size_blocks);
	*incr_block_count = 0;
    }
    n_blocks = bitmap_get(map-&gt;block_bitmap, block_offset, block_count,
			  &amp;written);
    <span class="enscript-keyword">if</span> (written == FALSE) {
	*incr_block_count = n_blocks;
	*incr_block_offset = block_offset;
    }
    <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* start has been written, and therefore mapped */</span>
	band_number_t	mapped_band;
	uint32_t		band_limit;
	
	mapped_band = map-&gt;bands[shadow_map_block_to_band(map, block_offset)];
	*incr_block_offset = mapped_band * map-&gt;blocks_per_band
	    + (block_offset % map-&gt;blocks_per_band);
	band_limit 
	    = shadow_map_contiguous(map, block_offset, block_count, FALSE);
	*incr_block_count = band_limit - block_offset;
	<span class="enscript-keyword">if</span> (*incr_block_count &gt; n_blocks) {
	    *incr_block_count = n_blocks;
	}
    }
    <span class="enscript-keyword">return</span> (written);
}

<span class="enscript-comment">/*
 * Function: shadow_map_write
 *
 * Purpose:
 *   Calculate the block offset within the shadow to write, and the number
 *   blocks to write.  The input values (block_offset, block_count) refer
 *   to the original file.  The output values 
 *   (*incr_block_offset, *incr_block_count) refer to the shadow file.
 *
 *   Bands are not necessarily contiguous, therefore:
 *   	*incr_block_count &lt;= block_count
 *   The caller must be prepared to call this function interatively
 *   to complete the whole i/o.
 * Returns:
 *   TRUE if the shadow file was grown, FALSE otherwise. 
 */</span>
boolean_t
<span class="enscript-function-name">shadow_map_write</span>(shadow_map_t * map, uint32_t block_offset, 
		 uint32_t block_count, uint32_t * incr_block_offset, 
		 uint32_t * incr_block_count)
{
    uint32_t		band_limit;
    band_number_t	mapped_band;
    boolean_t		shadow_grew = FALSE;

    <span class="enscript-keyword">if</span> (block_offset &gt;= map-&gt;file_size_blocks
	|| (block_offset + block_count) &gt; map-&gt;file_size_blocks) {
	printf(<span class="enscript-string">&quot;shadow_map_write: request (%d, %d) exceeds file size %d\n&quot;</span>,
	       block_offset, block_count, map-&gt;file_size_blocks);
	*incr_block_count = 0;
    }
    
    band_limit = shadow_map_contiguous(map, block_offset, block_count, TRUE);
    mapped_band = map-&gt;bands[shadow_map_block_to_band(map, block_offset)];
    *incr_block_offset = mapped_band * map-&gt;blocks_per_band
	+ (block_offset % map-&gt;blocks_per_band);
    *incr_block_count = band_limit - block_offset;

    <span class="enscript-comment">/* mark these blocks as written */</span>
    bitmap_set(map-&gt;block_bitmap, block_offset, *incr_block_count);

    <span class="enscript-keyword">if</span> (map-&gt;next_band &gt; map-&gt;shadow_size_bands) {
	map-&gt;shadow_size_bands = map-&gt;next_band;
	shadow_grew = TRUE;
    }
    <span class="enscript-keyword">return</span> (shadow_grew);
}

boolean_t
<span class="enscript-function-name">shadow_map_is_written</span>(shadow_map_t * map, uint32_t block_offset)
{
    bitmap_offset_t 	b;

    b = bitmap_offset(block_offset);
    <span class="enscript-keyword">return</span> ((map-&gt;block_bitmap[b.byte] &amp; bit(b.bit)) ? TRUE : FALSE);
}

<span class="enscript-comment">/*
 * Function: shadow_map_shadow_size
 *
 * Purpose:
 *   To return the size of the shadow file in blocks.
 */</span>
uint32_t
<span class="enscript-function-name">shadow_map_shadow_size</span>(shadow_map_t * map)
{
    <span class="enscript-keyword">return</span> (map-&gt;shadow_size_bands * map-&gt;blocks_per_band);
}

<span class="enscript-comment">/* 
 * Function: shadow_map_create
 *
 * Purpose:
 *   Allocate the dynamic data for keeping track of the shadow dirty blocks
 *   and the band mapping table.
 * Returns:
 *   NULL if an error occurred.
 */</span>
shadow_map_t *
<span class="enscript-function-name">shadow_map_create</span>(off_t file_size, off_t shadow_size, 
		  uint32_t band_size, uint32_t block_size)
{
    <span class="enscript-type">void</span> *		block_bitmap = NULL;
    uint32_t		bitmap_size;
    band_number_t *	bands = NULL;
    shadow_map_t *	map;
    uint32_t		n_bands = 0;

    <span class="enscript-keyword">if</span> (band_size == 0) {
	band_size = BAND_SIZE_DEFAULT;
    }

    n_bands = howmany(file_size, band_size);
    <span class="enscript-keyword">if</span> (n_bands &gt; (BAND_MAX + 1)) {
	printf(<span class="enscript-string">&quot;file is too big: %d &gt; %d\n&quot;</span>,
	       n_bands, BAND_MAX);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failure</span>;
    }

    <span class="enscript-comment">/* create a block bitmap, one bit per block */</span>
    bitmap_size = block_bitmap_size(file_size, block_size);
    block_bitmap = my_malloc(bitmap_size);
    <span class="enscript-keyword">if</span> (block_bitmap == NULL) {
	printf(<span class="enscript-string">&quot;failed to allocate bitmap\n&quot;</span>);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failure</span>;
    }
    bzero(block_bitmap, bitmap_size);

    <span class="enscript-comment">/* get the band map */</span>
    bands = (band_number_t *)my_malloc(n_bands * <span class="enscript-keyword">sizeof</span>(band_number_t));
    <span class="enscript-keyword">if</span> (bands == NULL) {
	printf(<span class="enscript-string">&quot;failed to allocate bands\n&quot;</span>);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failure</span>;
    }
    bzero(bands, n_bands * <span class="enscript-keyword">sizeof</span>(band_number_t));

    map = my_malloc(<span class="enscript-keyword">sizeof</span>(*map));
    <span class="enscript-keyword">if</span> (map == NULL) {
	printf(<span class="enscript-string">&quot;failed to allocate map\n&quot;</span>);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failure</span>;
    }
    map-&gt;blocks_per_band = band_size / block_size;
    map-&gt;block_bitmap = block_bitmap;
    map-&gt;bands = bands;
    map-&gt;file_size_blocks = n_bands * map-&gt;blocks_per_band;
    map-&gt;next_band = 0;
    map-&gt;zeroth_band = -1;
    map-&gt;shadow_size_bands = howmany(shadow_size, band_size);
    map-&gt;block_size = block_size;
    <span class="enscript-keyword">return</span> (map);
	
 <span class="enscript-reference">failure</span>:
    <span class="enscript-keyword">if</span> (block_bitmap)
	my_free(block_bitmap);
    <span class="enscript-keyword">if</span> (bands)
	my_free(bands);
    <span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * Function: shadow_map_free
 * Purpose:
 *   Frees the data structure to deal with the shadow map.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">shadow_map_free</span>(shadow_map_t * map)
{	
    <span class="enscript-keyword">if</span> (map-&gt;block_bitmap)
	my_free(map-&gt;block_bitmap);
    <span class="enscript-keyword">if</span> (map-&gt;bands)
	my_free(map-&gt;bands);
    map-&gt;block_bitmap = NULL;
    map-&gt;bands = NULL;
    my_free(map);
    <span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">TEST_SHADOW</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BAND_SIZE_BLOCKS</span>	(BAND_SIZE_DEFAULT / 512)

<span class="enscript-type">enum</span> {
    ReadRequest,
    WriteRequest,
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
    <span class="enscript-type">int</span>		type;
    uint32_t	offset;
    uint32_t	count;
} block_request_t;

<span class="enscript-type">int</span>
<span class="enscript-function-name">main</span>()
{
    shadow_map_t *	map;
    <span class="enscript-type">int</span> 		i;
    block_request_t 	requests[] = {
	{ WriteRequest, BAND_SIZE_BLOCKS * 2, 1 },
	{ ReadRequest, BAND_SIZE_BLOCKS / 2, BAND_SIZE_BLOCKS * 2 - 2 },
	{ WriteRequest, BAND_SIZE_BLOCKS * 1, 5 * BAND_SIZE_BLOCKS + 3},
	{ ReadRequest, 0, BAND_SIZE_BLOCKS * 10 },
	{ WriteRequest, BAND_SIZE_BLOCKS * (BAND_MAX - 1),
	  BAND_SIZE_BLOCKS * 2},
	{ 0, 0 },
    };
    
    map = shadow_map_create(1024 * 1024 * 1024 * 8ULL, 0, 0, 512);
    <span class="enscript-keyword">if</span> (map == NULL) {
	printf(<span class="enscript-string">&quot;shadow_map_create failed\n&quot;</span>);
	exit(1);
    }
    <span class="enscript-keyword">for</span> (i = 0; TRUE; i++) {
	uint32_t		offset;
	uint32_t		resid;
	boolean_t	shadow_grew;
	boolean_t	read_shadow;

    	<span class="enscript-keyword">if</span> (requests[i].count == 0) {
	    <span class="enscript-keyword">break</span>;
	}
	offset = requests[i].offset;
	resid = requests[i].count;
	printf(<span class="enscript-string">&quot;\n%s REQUEST (%ld, %ld)\n&quot;</span>, 
	       requests[i].type == WriteRequest ? <span class="enscript-string">&quot;WRITE&quot;</span> : <span class="enscript-string">&quot;READ&quot;</span>,
	       offset, resid);
	<span class="enscript-keyword">switch</span> (requests[i].type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">WriteRequest</span>:
	    <span class="enscript-keyword">while</span> (resid &gt; 0) {
		uint32_t this_offset;
		uint32_t this_count;
		
		shadow_grew = shadow_map_write(map, offset,
					       resid,
					       &amp;this_offset,
					       &amp;this_count);
		printf(<span class="enscript-string">&quot;\t(%ld, %ld) =&gt; (%ld, %ld)&quot;</span>,
		       offset, resid, this_offset, this_count);
		resid -= this_count;
		offset += this_count;
		<span class="enscript-keyword">if</span> (shadow_grew) {
		    printf(<span class="enscript-string">&quot; shadow grew to %ld&quot;</span>, shadow_map_shadow_size(map));
		}
		printf(<span class="enscript-string">&quot;\n&quot;</span>);
	    }
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ReadRequest</span>:
	    <span class="enscript-keyword">while</span> (resid &gt; 0) {
		uint32_t this_offset;
		uint32_t this_count;
		
		read_shadow = shadow_map_read(map, offset,
					      resid,
					      &amp;this_offset,
					      &amp;this_count);
		printf(<span class="enscript-string">&quot;\t(%ld, %ld) =&gt; (%ld, %ld)%s\n&quot;</span>,
		       offset, resid, this_offset, this_count,
		       read_shadow ? <span class="enscript-string">&quot; from shadow&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
		<span class="enscript-keyword">if</span> (this_count == 0) {
		    printf(<span class="enscript-string">&quot;this_count is 0, aborting\n&quot;</span>);
		    <span class="enscript-keyword">break</span>;
		}
		resid -= this_count;
		offset += this_count;
	    }
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
	    <span class="enscript-keyword">break</span>;
	}
    }
    <span class="enscript-keyword">if</span> (map) {
	shadow_map_free(map);
    }
    exit(0);
    <span class="enscript-keyword">return</span> (0);
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>