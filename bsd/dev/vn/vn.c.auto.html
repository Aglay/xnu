<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vn.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vn.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2010 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah Hdr: vn.c 1.13 94/04/02
 *
 *	from: @(#)vn.c	8.6 (Berkeley) 4/1/94
 * $FreeBSD: src/sys/dev/vn/vn.c,v 1.105.2.4 2001/11/18 07:11:00 dillon Exp $
 */</span>

<span class="enscript-comment">/*
 * Vnode disk driver.
 *
 * Block/character interface to a vnode.  Allows one to treat a file
 * as a disk (e.g. build a filesystem in it, mount it, etc.).
 *
 * NOTE 1: This uses the vnop_blockmap/vnop_strategy interface to the vnode
 * instead of a simple VOP_RDWR.  We do this to avoid distorting the
 * local buffer cache.
 *
 * NOTE 2: There is a security issue involved with this driver.
 * Once mounted all access to the contents of the &quot;mapped&quot; file via
 * the special file is controlled by the permissions on the special
 * file, the protection of the mapped file is ignored (effectively,
 * by using root credentials in all transactions).
 *
 * NOTE 3: Doesn't interact with leases, should it?
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;vndevice.h&quot;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NVNDEVICE</span> &gt; 0

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disk.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnioctl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pager.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/devfs.h&gt;</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;shadow.h&quot;</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">vndevice_do_init</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> ioctl_fcn_t		vnioctl_chr;
<span class="enscript-type">static</span> ioctl_fcn_t		vnioctl_blk;
<span class="enscript-type">static</span> open_close_fcn_t		vnopen;
<span class="enscript-type">static</span> open_close_fcn_t		vnclose;
<span class="enscript-type">static</span> psize_fcn_t		vnsize;
<span class="enscript-type">static</span> strategy_fcn_t		vnstrategy;
<span class="enscript-type">static</span> read_write_fcn_t		vnread;
<span class="enscript-type">static</span> read_write_fcn_t		vnwrite;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	vndevice_bdev_major;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	vndevice_cdev_major;

<span class="enscript-comment">/*
 * cdevsw
 *	D_DISK		we want to look like a disk
 *	D_CANFREE	We support B_FREEBUF
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> bdevsw vn_bdevsw = {
	<span class="enscript-comment">/* open */</span>	vnopen,
	<span class="enscript-comment">/* close */</span>	vnclose,
	<span class="enscript-comment">/* strategy */</span>	vnstrategy,
	<span class="enscript-comment">/* ioctl */</span>	vnioctl_blk,
	<span class="enscript-comment">/* dump */</span>	eno_dump,
	<span class="enscript-comment">/* psize */</span>	vnsize,
	<span class="enscript-comment">/* flags */</span>	D_DISK,
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cdevsw vn_cdevsw = {
	<span class="enscript-comment">/* open */</span>	vnopen,
	<span class="enscript-comment">/* close */</span>	vnclose,
	<span class="enscript-comment">/* read */</span>	vnread,
	<span class="enscript-comment">/* write */</span>	vnwrite,
	<span class="enscript-comment">/* ioctl */</span>	vnioctl_chr,
	<span class="enscript-comment">/* stop */</span>	eno_stop,
	<span class="enscript-comment">/* reset */</span>	eno_reset,
	<span class="enscript-comment">/* ttys */</span>	NULL,
	<span class="enscript-comment">/* select */</span>	eno_select,
	<span class="enscript-comment">/* mmap */</span>	eno_mmap,
	<span class="enscript-comment">/* strategy */</span>	eno_strat,
	<span class="enscript-comment">/* getc */</span>	eno_getc,
	<span class="enscript-comment">/* putc */</span>	eno_putc,
	<span class="enscript-comment">/* flags */</span>	D_DISK,
};

<span class="enscript-type">struct</span> vn_softc {
	u_int64_t	sc_fsize;	<span class="enscript-comment">/* file size in bytes 		*/</span>
	u_int64_t	sc_size;	<span class="enscript-comment">/* size of vn, sc_secsize scale	*/</span>
	<span class="enscript-type">int</span>		sc_flags;	<span class="enscript-comment">/* flags 			*/</span>
	u_int32_t		sc_secsize;	<span class="enscript-comment">/* sector size			*/</span>
	<span class="enscript-type">struct</span> vnode	*sc_vp;		<span class="enscript-comment">/* vnode if not NULL		*/</span>
	uint32_t	sc_vid;
	<span class="enscript-type">int</span>		sc_open_flags;
	<span class="enscript-type">struct</span> vnode	*sc_shadow_vp;	<span class="enscript-comment">/* shadow vnode if not NULL	*/</span>
	uint32_t	sc_shadow_vid;
	shadow_map_t *	sc_shadow_map;	<span class="enscript-comment">/* shadow map if not NULL	*/</span>
	kauth_cred_t	sc_cred;	<span class="enscript-comment">/* credentials 			*/</span>
	u_int32_t	sc_options;	<span class="enscript-comment">/* options 			*/</span>
	<span class="enscript-type">void</span> *		sc_bdev;
	<span class="enscript-type">void</span> *		sc_cdev;
} vn_table[NVNDEVICE];

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ROOT_IMAGE_UNIT</span>	0

<span class="enscript-comment">/* sc_flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VNF_INITED</span>	0x01
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">VNF_READONLY</span>	0x02

<span class="enscript-type">static</span> u_int32_t	vn_options;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IFOPT</span>(vn,opt) if (((vn)-&gt;sc_options|vn_options) &amp; (opt))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TESTOPT</span>(vn,opt) (((vn)-&gt;sc_options|vn_options) &amp; (opt))

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	setcred(<span class="enscript-type">struct</span> vnode * vp, kauth_cred_t cred);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	vnclear (<span class="enscript-type">struct</span> vn_softc *vn, vfs_context_t  ctx);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vn_ioctl_to_64</span>(<span class="enscript-type">struct</span> vn_ioctl_32 *from, <span class="enscript-type">struct</span> vn_ioctl_64 *to);
<span class="enscript-type">void</span> <span class="enscript-function-name">vndevice_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">vndevice_root_image</span>(<span class="enscript-type">char</span> * path, <span class="enscript-type">char</span> devname[], dev_t * dev_p);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vniocattach_file</span>(<span class="enscript-type">struct</span> vn_softc *vn,
		 <span class="enscript-type">struct</span> vn_ioctl_64 *vniop,
		 dev_t dev,
		 <span class="enscript-type">int</span> in_kernel,
		 proc_t p);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vniocattach_shadow</span>(<span class="enscript-type">struct</span> vn_softc * vn,
		   <span class="enscript-type">struct</span> vn_ioctl_64 *vniop,
		   dev_t dev,
		   <span class="enscript-type">int</span> in_kernel,
		   proc_t p);
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">vnunit</span>(dev_t dev)
{
	<span class="enscript-keyword">return</span> (minor(dev));
}

<span class="enscript-type">static</span>	<span class="enscript-type">int</span>
<span class="enscript-function-name">vnclose</span>(__unused dev_t dev, __unused <span class="enscript-type">int</span> flags, 
		__unused <span class="enscript-type">int</span> devtype, __unused proc_t p)
{
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span>	<span class="enscript-type">int</span>
<span class="enscript-function-name">vnopen</span>(dev_t dev, <span class="enscript-type">int</span> flags, __unused <span class="enscript-type">int</span> devtype, __unused proc_t p)
{
	<span class="enscript-type">struct</span> vn_softc *vn;
	<span class="enscript-type">int</span> unit;

	unit = vnunit(dev);
	<span class="enscript-keyword">if</span> (vnunit(dev) &gt;= NVNDEVICE) {
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	vn = vn_table + unit;
	<span class="enscript-keyword">if</span> ((flags &amp; FWRITE) &amp;&amp; (vn-&gt;sc_flags &amp; VNF_READONLY))
		<span class="enscript-keyword">return</span> (EACCES);

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">file_io</span>(<span class="enscript-type">struct</span> vnode * vp, vfs_context_t ctx, 
	<span class="enscript-type">enum</span> uio_rw op, <span class="enscript-type">char</span> * base, off_t offset, user_ssize_t count,
	user_ssize_t * resid)
{
	uio_t 		auio;
	<span class="enscript-type">int</span>		error;
	<span class="enscript-type">char</span>		uio_buf[UIO_SIZEOF(1)];
	
	auio = uio_createwithbuffer(1, offset, UIO_SYSSPACE, op, 
				    &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	uio_addiov(auio, CAST_USER_ADDR_T(base), count);
	<span class="enscript-keyword">if</span> (op == UIO_READ)
		error = VNOP_READ(vp, auio, IO_SYNC, ctx);
	<span class="enscript-keyword">else</span>
		error = VNOP_WRITE(vp, auio, IO_SYNC, ctx);

	<span class="enscript-keyword">if</span> (resid != NULL) {
		*resid = uio_resid(auio);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> __inline__ off_t
<span class="enscript-function-name">block_round</span>(off_t o, <span class="enscript-type">int</span> blocksize)
{
	<span class="enscript-keyword">return</span> ((o + blocksize - 1) / blocksize);
}

<span class="enscript-type">static</span> __inline__ off_t
<span class="enscript-function-name">block_truncate</span>(off_t o, <span class="enscript-type">int</span> blocksize)
{
	<span class="enscript-keyword">return</span> (o / blocksize);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">int</span>
<span class="enscript-function-name">block_remainder</span>(off_t o, <span class="enscript-type">int</span> blocksize)
{
	<span class="enscript-keyword">return</span> (o % blocksize);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnread_shadow</span>(<span class="enscript-type">struct</span> vn_softc * vn, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> ioflag, 
	      vfs_context_t ctx)
{
	u_int32_t		blocksize = vn-&gt;sc_secsize;
	<span class="enscript-type">int</span> 		error = 0;
	off_t		offset;
	user_ssize_t	resid;
	off_t		orig_offset;
	user_ssize_t	orig_resid;

	orig_resid = resid = uio_resid(uio);
	orig_offset = offset = uio_offset(uio);

	<span class="enscript-keyword">while</span> (resid &gt; 0) {
		u_int32_t		remainder;
		u_int32_t		this_block_number;
		u_int32_t		this_block_count;
		off_t		this_offset;
		user_ssize_t	this_resid;
		<span class="enscript-type">struct</span> vnode *	vp;

		<span class="enscript-comment">/* figure out which blocks to read */</span>
		remainder = block_remainder(offset, blocksize);
		<span class="enscript-keyword">if</span> (shadow_map_read(vn-&gt;sc_shadow_map,
				    block_truncate(offset, blocksize),
				    block_round(resid + remainder, blocksize),
				    &amp;this_block_number, &amp;this_block_count)) {
			vp = vn-&gt;sc_shadow_vp;
		}
		<span class="enscript-keyword">else</span> {
			vp = vn-&gt;sc_vp;
		}

		<span class="enscript-comment">/* read the blocks (or parts thereof) */</span>
		this_offset = (off_t)this_block_number * blocksize + remainder;
		uio_setoffset(uio, this_offset);
		this_resid = this_block_count * blocksize - remainder;
		<span class="enscript-keyword">if</span> (this_resid &gt; resid) {
			this_resid = resid;
		}
		uio_setresid(uio, this_resid);
		error = VNOP_READ(vp, uio, ioflag, ctx);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* figure out how much we actually read */</span>
		this_resid -= uio_resid(uio);
		<span class="enscript-keyword">if</span> (this_resid == 0) {
			printf(<span class="enscript-string">&quot;vn device: vnread_shadow zero length read\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		}
		resid -= this_resid;
		offset += this_resid;
	}
	uio_setresid(uio, resid);
	uio_setoffset(uio, offset);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vncopy_block_to_shadow</span>(<span class="enscript-type">struct</span> vn_softc * vn, vfs_context_t ctx,
		       u_int32_t file_block, u_int32_t shadow_block)
{
	<span class="enscript-type">int</span>	error;
	<span class="enscript-type">char</span> *	tmpbuf;

	tmpbuf = _MALLOC(vn-&gt;sc_secsize, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (tmpbuf == NULL) {
	    <span class="enscript-keyword">return</span> (ENOMEM);
	}
	<span class="enscript-comment">/* read one block from file at file_block offset */</span>
	error = file_io(vn-&gt;sc_vp, ctx, UIO_READ,
			tmpbuf, (off_t)file_block * vn-&gt;sc_secsize, 
			vn-&gt;sc_secsize, NULL);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/* write one block to shadow file at shadow_block offset */</span>
	error = file_io(vn-&gt;sc_shadow_vp, ctx, UIO_WRITE,
			tmpbuf, (off_t)shadow_block * vn-&gt;sc_secsize, 
			vn-&gt;sc_secsize, NULL);
 <span class="enscript-reference">done</span>:
	FREE(tmpbuf, M_TEMP);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">enum</span> {
	FLAGS_FIRST_BLOCK_PARTIAL = 0x1,
	FLAGS_LAST_BLOCK_PARTIAL = 0x2
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnwrite_shadow</span>(<span class="enscript-type">struct</span> vn_softc * vn, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> ioflag, 
	       vfs_context_t ctx)
{
	u_int32_t		blocksize = vn-&gt;sc_secsize;
	<span class="enscript-type">int</span> 		error = 0;
	user_ssize_t	resid;
	off_t		offset;

	resid = uio_resid(uio);
	offset = uio_offset(uio);

	<span class="enscript-keyword">while</span> (resid &gt; 0) {
		<span class="enscript-type">int</span>		flags = 0;
		u_int32_t		offset_block_number;
		u_int32_t		remainder;
		u_int32_t		resid_block_count;
		u_int32_t		shadow_block_count;
		u_int32_t		shadow_block_number;
		user_ssize_t	this_resid;

		<span class="enscript-comment">/* figure out which blocks to write */</span>
		offset_block_number = block_truncate(offset, blocksize);
		remainder = block_remainder(offset, blocksize);
		resid_block_count = block_round(resid + remainder, blocksize);
		<span class="enscript-comment">/* figure out if the first or last blocks are partial writes */</span>
		<span class="enscript-keyword">if</span> (remainder &gt; 0
		    &amp;&amp; !shadow_map_is_written(vn-&gt;sc_shadow_map,
					      offset_block_number)) {
			<span class="enscript-comment">/* the first block is a partial write */</span>
			flags |= FLAGS_FIRST_BLOCK_PARTIAL;
		}
		<span class="enscript-keyword">if</span> (resid_block_count &gt; 1
		    &amp;&amp; !shadow_map_is_written(vn-&gt;sc_shadow_map,
					      offset_block_number
					      + resid_block_count - 1)
		    &amp;&amp; block_remainder(offset + resid, blocksize) &gt; 0) {
			<span class="enscript-comment">/* the last block is a partial write */</span>
			flags |= FLAGS_LAST_BLOCK_PARTIAL;
		}
		<span class="enscript-keyword">if</span> (shadow_map_write(vn-&gt;sc_shadow_map,
				     offset_block_number, resid_block_count,
				     &amp;shadow_block_number, 
				     &amp;shadow_block_count)) {
			<span class="enscript-comment">/* shadow file is growing */</span>
#<span class="enscript-reference">if</span> 0
			<span class="enscript-comment">/* truncate the file to its new length before write */</span>
			off_t	size;
			size = (off_t)shadow_map_shadow_size(vn-&gt;sc_shadow_map) 
				* vn-&gt;sc_secsize;
			vnode_setsize(vn-&gt;sc_shadow_vp, size, IO_SYNC, ctx);
#<span class="enscript-reference">endif</span>
		}
		<span class="enscript-comment">/* write the blocks (or parts thereof) */</span>
		uio_setoffset(uio, (off_t)
			      shadow_block_number * blocksize + remainder);
		this_resid = (off_t)shadow_block_count * blocksize - remainder;
		<span class="enscript-keyword">if</span> (this_resid &gt;= resid) {
			this_resid = resid;
			<span class="enscript-keyword">if</span> ((flags &amp; FLAGS_LAST_BLOCK_PARTIAL) != 0) {
				<span class="enscript-comment">/* copy the last block to the shadow */</span>
				u_int32_t 	d;
				u_int32_t	s;

				s = offset_block_number 
					+ resid_block_count - 1;
				d = shadow_block_number 
					+ shadow_block_count - 1;
				error = vncopy_block_to_shadow(vn, ctx, s, d);
				<span class="enscript-keyword">if</span> (error) {
					printf(<span class="enscript-string">&quot;vnwrite_shadow: failed to copy&quot;</span>
					       <span class="enscript-string">&quot; block %u to shadow block %u\n&quot;</span>,
					       s, d);
					<span class="enscript-keyword">break</span>;
				}
			}
		}
		uio_setresid(uio, this_resid);
		<span class="enscript-keyword">if</span> ((flags &amp; FLAGS_FIRST_BLOCK_PARTIAL) != 0) {
			<span class="enscript-comment">/* copy the first block to the shadow */</span>
			error = vncopy_block_to_shadow(vn, ctx,
						       offset_block_number,
						       shadow_block_number);
			<span class="enscript-keyword">if</span> (error) {
				printf(<span class="enscript-string">&quot;vnwrite_shadow: failed to&quot;</span>
				       <span class="enscript-string">&quot; copy block %u to shadow block %u\n&quot;</span>, 
				       offset_block_number, 
				       shadow_block_number);
				<span class="enscript-keyword">break</span>;
			}
		}
		error = VNOP_WRITE(vn-&gt;sc_shadow_vp, uio, ioflag, ctx);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* figure out how much we actually wrote */</span>
		this_resid -= uio_resid(uio);
		<span class="enscript-keyword">if</span> (this_resid == 0) {
			printf(<span class="enscript-string">&quot;vn device: vnwrite_shadow zero length write\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		}
		resid -= this_resid;
		offset += this_resid;
	}
	uio_setresid(uio, resid);
	uio_setoffset(uio, offset);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">vnread</span>(dev_t dev, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> ioflag)
{
	<span class="enscript-type">struct</span> vfs_context  	context; 		
	<span class="enscript-type">int</span> 			error = 0;
	off_t			offset;
	proc_t			p;
	user_ssize_t		resid;
	<span class="enscript-type">struct</span> vn_softc *	vn;
	<span class="enscript-type">int</span> 			unit;

	unit = vnunit(dev);
	<span class="enscript-keyword">if</span> (vnunit(dev) &gt;= NVNDEVICE) {
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	p = current_proc();
	vn = vn_table + unit;
	<span class="enscript-keyword">if</span> ((vn-&gt;sc_flags &amp; VNF_INITED) == 0) {
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	context.vc_thread = current_thread();
	context.vc_ucred = vn-&gt;sc_cred;

	error = vnode_getwithvid(vn-&gt;sc_vp, vn-&gt;sc_vid);
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-comment">/* the vnode is no longer available, abort */</span>
		error = ENXIO;
		vnclear(vn, &amp;context);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	resid = uio_resid(uio);
	offset = uio_offset(uio);

	<span class="enscript-comment">/*
	 * If out of bounds return an error.  If at the EOF point,
	 * simply read less.
	 */</span>
	<span class="enscript-keyword">if</span> (offset &gt;= (off_t)vn-&gt;sc_fsize) {
		<span class="enscript-keyword">if</span> (offset &gt; (off_t)vn-&gt;sc_fsize) {
			error = EINVAL;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/*
	 * If the request crosses EOF, truncate the request.
	 */</span>
	<span class="enscript-keyword">if</span> ((offset + resid) &gt; (off_t)vn-&gt;sc_fsize) {
		resid = vn-&gt;sc_fsize - offset;
		uio_setresid(uio, resid);
	}

	<span class="enscript-keyword">if</span> (vn-&gt;sc_shadow_vp != NULL) {
		error = vnode_getwithvid(vn-&gt;sc_shadow_vp,
					 vn-&gt;sc_shadow_vid);
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-comment">/* the vnode is no longer available, abort */</span>
			error = ENXIO;
			vnode_put(vn-&gt;sc_vp);
			vnclear(vn, &amp;context);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		error = vnread_shadow(vn, uio, ioflag, &amp;context);
		vnode_put(vn-&gt;sc_shadow_vp);
	} <span class="enscript-keyword">else</span> {
		error = VNOP_READ(vn-&gt;sc_vp, uio, ioflag, &amp;context);
	}
	vnode_put(vn-&gt;sc_vp);
 <span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">vnwrite</span>(dev_t dev, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> ioflag)
{
	<span class="enscript-type">struct</span> vfs_context  	context;
	<span class="enscript-type">int</span> 			error;
	off_t			offset;
	proc_t			p;
	user_ssize_t		resid;
	<span class="enscript-type">struct</span> vn_softc *	vn;
	<span class="enscript-type">int</span> 			unit;

	unit = vnunit(dev);
	<span class="enscript-keyword">if</span> (vnunit(dev) &gt;= NVNDEVICE) {
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	p = current_proc();
	vn = vn_table + unit;
	<span class="enscript-keyword">if</span> ((vn-&gt;sc_flags &amp; VNF_INITED) == 0) {
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (vn-&gt;sc_flags &amp; VNF_READONLY) {
		error = EROFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	context.vc_thread = current_thread();
	context.vc_ucred = vn-&gt;sc_cred;

	error = vnode_getwithvid(vn-&gt;sc_vp, vn-&gt;sc_vid);
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-comment">/* the vnode is no longer available, abort */</span>
		error = ENXIO;
		vnclear(vn, &amp;context);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	resid = uio_resid(uio);
	offset = uio_offset(uio);

	<span class="enscript-comment">/*
	 * If out of bounds return an error.  If at the EOF point,
	 * simply write less.
	 */</span>
	<span class="enscript-keyword">if</span> (offset &gt;= (off_t)vn-&gt;sc_fsize) {
		<span class="enscript-keyword">if</span> (offset &gt; (off_t)vn-&gt;sc_fsize) {
			error = EINVAL;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/*
	 * If the request crosses EOF, truncate the request.
	 */</span>
	<span class="enscript-keyword">if</span> ((offset + resid) &gt; (off_t)vn-&gt;sc_fsize) {
		resid = (off_t)vn-&gt;sc_fsize - offset;
		uio_setresid(uio, resid);
	}

	<span class="enscript-keyword">if</span> (vn-&gt;sc_shadow_vp != NULL) {
		error = vnode_getwithvid(vn-&gt;sc_shadow_vp,
					 vn-&gt;sc_shadow_vid);
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-comment">/* the vnode is no longer available, abort */</span>
			error = ENXIO;
			vnode_put(vn-&gt;sc_vp);
			vnclear(vn, &amp;context);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		error = vnwrite_shadow(vn, uio, ioflag, &amp;context);
		vnode_put(vn-&gt;sc_shadow_vp);
	} <span class="enscript-keyword">else</span> {
		error = VNOP_WRITE(vn-&gt;sc_vp, uio, ioflag, &amp;context);
	}
	vnode_put(vn-&gt;sc_vp);
 <span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">shadow_read</span>(<span class="enscript-type">struct</span> vn_softc * vn, <span class="enscript-type">struct</span> buf * bp, <span class="enscript-type">char</span> * base,
	vfs_context_t ctx)
{
	u_int32_t		blocksize = vn-&gt;sc_secsize;
	<span class="enscript-type">int</span> 		error = 0;
	u_int32_t		offset;
	boolean_t	read_shadow;
	u_int32_t		resid;
	u_int32_t		start = 0;

	offset = buf_blkno(bp);
	resid =  buf_resid(bp) / blocksize;
	<span class="enscript-keyword">while</span> (resid &gt; 0) {
		user_ssize_t	temp_resid;
		u_int32_t		this_offset;
		u_int32_t		this_resid;
		<span class="enscript-type">struct</span> vnode *	vp;

		read_shadow = shadow_map_read(vn-&gt;sc_shadow_map,
					      offset, resid,
					      &amp;this_offset, &amp;this_resid);
		<span class="enscript-keyword">if</span> (read_shadow) {
			vp = vn-&gt;sc_shadow_vp;
		}
		<span class="enscript-keyword">else</span> {
			vp = vn-&gt;sc_vp;
		}
		error = file_io(vp, ctx, UIO_READ, base + start,
				(off_t)this_offset * blocksize,
				(user_ssize_t)this_resid * blocksize, 
				&amp;temp_resid);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">break</span>;
		}
		this_resid -= (temp_resid / blocksize);
		<span class="enscript-keyword">if</span> (this_resid == 0) {
			printf(<span class="enscript-string">&quot;vn device: shadow_read zero length read\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		}
		resid -= this_resid;
		offset += this_resid;
		start += this_resid * blocksize;
	}
	buf_setresid(bp, resid * blocksize);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">shadow_write</span>(<span class="enscript-type">struct</span> vn_softc * vn, <span class="enscript-type">struct</span> buf * bp, <span class="enscript-type">char</span> * base, 
	     vfs_context_t ctx)
{
	u_int32_t		blocksize = vn-&gt;sc_secsize;
	<span class="enscript-type">int</span> 		error = 0;
	u_int32_t		offset;
	boolean_t	shadow_grew;
	u_int32_t		resid;
	u_int32_t		start = 0;

	offset = buf_blkno(bp);
	resid =  buf_resid(bp) / blocksize;
	<span class="enscript-keyword">while</span> (resid &gt; 0) {
		user_ssize_t	temp_resid;
		u_int32_t		this_offset;
		u_int32_t		this_resid;

		shadow_grew = shadow_map_write(vn-&gt;sc_shadow_map, 
					       offset, resid, 
					       &amp;this_offset, &amp;this_resid);
		<span class="enscript-keyword">if</span> (shadow_grew) {
#<span class="enscript-reference">if</span> 0
			off_t	size;
			<span class="enscript-comment">/* truncate the file to its new length before write */</span>
			size = (off_t)shadow_map_shadow_size(vn-&gt;sc_shadow_map) 
				* blocksize;
			vnode_setsize(vn-&gt;sc_shadow_vp, size, IO_SYNC, ctx);
#<span class="enscript-reference">endif</span>
		}
		error = file_io(vn-&gt;sc_shadow_vp, ctx, UIO_WRITE, 
				base + start,
				(off_t)this_offset * blocksize,
				(user_ssize_t)this_resid * blocksize, 
				&amp;temp_resid);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">break</span>;
		}
		this_resid -= (temp_resid / blocksize);
		<span class="enscript-keyword">if</span> (this_resid == 0) {
			printf(<span class="enscript-string">&quot;vn device: shadow_write zero length write\n&quot;</span>);
			<span class="enscript-keyword">break</span>;
		}
		resid -= this_resid;
		offset += this_resid;
		start += this_resid * blocksize;
	}
	buf_setresid(bp, resid * blocksize);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vn_readwrite_io</span>(<span class="enscript-type">struct</span> vn_softc * vn, <span class="enscript-type">struct</span> buf * bp, vfs_context_t ctx)
{
	<span class="enscript-type">int</span>			error = 0;
	<span class="enscript-type">char</span> *			iov_base;
	caddr_t 		vaddr;

	<span class="enscript-keyword">if</span> (buf_map(bp, &amp;vaddr)) 
	        panic(<span class="enscript-string">&quot;vn device: buf_map failed&quot;</span>);
	iov_base = (<span class="enscript-type">char</span> *)vaddr;

	<span class="enscript-keyword">if</span> (vn-&gt;sc_shadow_vp == NULL) {
	        user_ssize_t		temp_resid;

		error = file_io(vn-&gt;sc_vp, ctx,
				buf_flags(bp) &amp; B_READ ? UIO_READ : UIO_WRITE,
				iov_base,
				(off_t)buf_blkno(bp) * vn-&gt;sc_secsize,
				buf_resid(bp), &amp;temp_resid);
		buf_setresid(bp, temp_resid);
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (buf_flags(bp) &amp; B_READ)
			error = shadow_read(vn, bp, iov_base, ctx);
		<span class="enscript-keyword">else</span>
			error = shadow_write(vn, bp, iov_base, ctx);
	}
	buf_unmap(bp);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vnstrategy</span>(<span class="enscript-type">struct</span> buf *bp)
{
	<span class="enscript-type">struct</span> vn_softc *vn;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">long</span> sz;	<span class="enscript-comment">/* in sc_secsize chunks */</span>
	daddr64_t blk_num;
	<span class="enscript-type">struct</span> vnode *		shadow_vp = NULL;
	<span class="enscript-type">struct</span> vnode *		vp = NULL;
	<span class="enscript-type">struct</span> vfs_context  	context; 

	vn = vn_table + vnunit(buf_device(bp));
	<span class="enscript-keyword">if</span> ((vn-&gt;sc_flags &amp; VNF_INITED) == 0) {
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	context.vc_thread = current_thread();
	context.vc_ucred = vn-&gt;sc_cred;

	buf_setresid(bp, buf_count(bp));
	<span class="enscript-comment">/*
	 * Check for required alignment.  Transfers must be a valid
	 * multiple of the sector size.
	 */</span>
	blk_num = buf_blkno(bp);
	<span class="enscript-keyword">if</span> (buf_count(bp) % vn-&gt;sc_secsize != 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	sz = howmany(buf_count(bp), vn-&gt;sc_secsize);

	<span class="enscript-comment">/*
	 * If out of bounds return an error.  If at the EOF point,
	 * simply read or write less.
	 */</span>
	<span class="enscript-keyword">if</span> (blk_num &gt;= 0 &amp;&amp; (u_int64_t)blk_num &gt;= vn-&gt;sc_size) {
		<span class="enscript-keyword">if</span> (blk_num &gt; 0 &amp;&amp; (u_int64_t)blk_num &gt; vn-&gt;sc_size) {
			error = EINVAL;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/*
	 * If the request crosses EOF, truncate the request.
	 */</span>
	<span class="enscript-keyword">if</span> ((blk_num + sz) &gt; 0 &amp;&amp; ((u_int64_t)(blk_num + sz)) &gt; vn-&gt;sc_size) {
		buf_setcount(bp, (vn-&gt;sc_size - blk_num) * vn-&gt;sc_secsize);
		buf_setresid(bp, buf_count(bp));
	}
	vp = vn-&gt;sc_vp;
	<span class="enscript-keyword">if</span> (vp == NULL) {
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = vnode_getwithvid(vp, vn-&gt;sc_vid);
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-comment">/* the vnode is no longer available, abort */</span>
		error = ENXIO;
		vnclear(vn, &amp;context);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	shadow_vp = vn-&gt;sc_shadow_vp;
	<span class="enscript-keyword">if</span> (shadow_vp != NULL) {
		error = vnode_getwithvid(shadow_vp,
					 vn-&gt;sc_shadow_vid);
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-comment">/* the vnode is no longer available, abort */</span>
			error = ENXIO;
			vnode_put(vn-&gt;sc_vp);
			vnclear(vn, &amp;context);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	error = vn_readwrite_io(vn, bp, &amp;context);
	vnode_put(vp);
	<span class="enscript-keyword">if</span> (shadow_vp != NULL) {
		vnode_put(shadow_vp);
	}

 <span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (error) {
	        buf_seterror(bp, error);
	}
	buf_biodone(bp);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span>	<span class="enscript-type">int</span>
<span class="enscript-function-name">vnioctl</span>(dev_t dev, u_long cmd, caddr_t data,
	__unused <span class="enscript-type">int</span> flag, proc_t p,
	<span class="enscript-type">int</span> is_char)
{
	<span class="enscript-type">struct</span> vn_softc *vn;
	<span class="enscript-type">struct</span> vn_ioctl_64 *viop;
	<span class="enscript-type">int</span> error;
	u_int32_t *f;
	u_int64_t * o;
	<span class="enscript-type">int</span> unit;
	<span class="enscript-type">struct</span> vfsioattr ioattr;
	<span class="enscript-type">struct</span> vn_ioctl_64 user_vnio;
	<span class="enscript-type">struct</span> vfs_context  	context;

	unit = vnunit(dev);
	<span class="enscript-keyword">if</span> (vnunit(dev) &gt;= NVNDEVICE) {
		<span class="enscript-keyword">return</span> (ENXIO);
	}

	vn = vn_table + unit;
	error = proc_suser(p);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	context.vc_thread = current_thread();
	context.vc_ucred = vn-&gt;sc_cred;

	viop = (<span class="enscript-type">struct</span> vn_ioctl_64 *)data;
	f = (u_int32_t *)data;
	o = (u_int64_t *)data;
	<span class="enscript-keyword">switch</span> (cmd) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCDETACH32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCDETACH</span>:
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCDETACH</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCDETACH64</span>:
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETBLOCKSIZE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCSETBLOCKSIZE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXBLOCKCOUNTREAD</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXBLOCKCOUNTWRITE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXSEGMENTCOUNTREAD</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXSEGMENTCOUNTWRITE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXSEGMENTBYTECOUNTREAD</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXSEGMENTBYTECOUNTWRITE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETBLOCKCOUNT</span>:
		<span class="enscript-keyword">if</span> ((vn-&gt;sc_flags &amp; VNF_INITED) == 0) {
			error = ENXIO;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (vn-&gt;sc_vp != NULL)
		vfs_ioattr(vnode_mount(vn-&gt;sc_vp), &amp;ioattr);
	<span class="enscript-keyword">else</span>
		bzero(&amp;ioattr, <span class="enscript-keyword">sizeof</span>(ioattr));

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCISVIRTUAL</span>:
		*f = 1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXBLOCKCOUNTREAD</span>:
		*o = ioattr.io_maxreadcnt / vn-&gt;sc_secsize;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXBLOCKCOUNTWRITE</span>:
		*o = ioattr.io_maxwritecnt / vn-&gt;sc_secsize;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXBYTECOUNTREAD</span>:
		*o = ioattr.io_maxreadcnt;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXBYTECOUNTWRITE</span>:
		*o = ioattr.io_maxwritecnt;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXSEGMENTCOUNTREAD</span>:
		*o = ioattr.io_segreadcnt;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXSEGMENTCOUNTWRITE</span>:
		*o = ioattr.io_segwritecnt;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXSEGMENTBYTECOUNTREAD</span>:
		*o = ioattr.io_maxsegreadsize;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXSEGMENTBYTECOUNTWRITE</span>:
		*o = ioattr.io_maxsegwritesize;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETBLOCKSIZE</span>:
	        *f = vn-&gt;sc_secsize;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCSETBLOCKSIZE</span>:
		<span class="enscript-keyword">if</span> (is_char) {
			<span class="enscript-comment">/* can only set block size on block device */</span>
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (*f &lt; DEV_BSIZE) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (vn-&gt;sc_shadow_vp != NULL) {
			<span class="enscript-keyword">if</span> (*f == (<span class="enscript-type">unsigned</span>)vn-&gt;sc_secsize) {
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/* can't change the block size if already shadowing */</span>
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		vn-&gt;sc_secsize = *f;
		<span class="enscript-comment">/* recompute the size in terms of the new blocksize */</span>
		vn-&gt;sc_size = vn-&gt;sc_fsize / vn-&gt;sc_secsize;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCISWRITABLE</span>:
		*f = 1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETBLOCKCOUNT</span>:
		*o = vn-&gt;sc_size;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCSHADOW32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCSHADOW</span>:
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCSHADOW</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCSHADOW64</span>:
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (vn-&gt;sc_shadow_vp != NULL) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (vn-&gt;sc_vp == NULL) {
			<span class="enscript-comment">/* much be attached before we can shadow */</span>
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (!proc_is64bit(p)) {
			<span class="enscript-comment">/* downstream code expects LP64 version of vn_ioctl structure */</span>
			vn_ioctl_to_64((<span class="enscript-type">struct</span> vn_ioctl_32 *)viop, &amp;user_vnio);
			viop = &amp;user_vnio;
		}
		<span class="enscript-keyword">if</span> (viop-&gt;vn_file == USER_ADDR_NULL) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		error = vniocattach_shadow(vn, viop, dev, 0, p);
		<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCATTACH32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCATTACH</span>:
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCATTACH</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCATTACH64</span>:
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (is_char) {
			<span class="enscript-comment">/* attach only on block device */</span>
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (vn-&gt;sc_flags &amp; VNF_INITED) {
			error = EBUSY;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (!proc_is64bit(p)) {
			<span class="enscript-comment">/* downstream code expects LP64 version of vn_ioctl structure */</span>
			vn_ioctl_to_64((<span class="enscript-type">struct</span> vn_ioctl_32 *)viop, &amp;user_vnio);
			viop = &amp;user_vnio;
		}
		<span class="enscript-keyword">if</span> (viop-&gt;vn_file == USER_ADDR_NULL) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		error = vniocattach_file(vn, viop, dev, 0, p);
		<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCDETACH32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCDETACH</span>:
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCDETACH</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCDETACH64</span>:
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (is_char) {
			<span class="enscript-comment">/* detach only on block device */</span>
			error = ENODEV;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* Note: spec_open won't open a mounted block device */</span>

		<span class="enscript-comment">/*
		 * XXX handle i/o in progress.  Return EBUSY, or wait, or
		 * flush the i/o.
		 * XXX handle multiple opens of the device.  Return EBUSY,
		 * or revoke the fd's.
		 * How are these problems handled for removable and failing
		 * hardware devices? (Hint: They are not)
		 */</span>
		vnclear(vn, &amp;context);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCGSET</span>:
		vn_options |= *f;
		*f = vn_options;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCGCLEAR</span>:
		vn_options &amp;= ~(*f);
		*f = vn_options;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCUSET</span>:
		vn-&gt;sc_options |= *f;
		*f = vn-&gt;sc_options;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNIOCUCLEAR</span>:
		vn-&gt;sc_options &amp;= ~(*f);
		*f = vn-&gt;sc_options;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = ENOTTY;
		<span class="enscript-keyword">break</span>;
	}
 <span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">static</span>	<span class="enscript-type">int</span>
<span class="enscript-function-name">vnioctl_chr</span>(dev_t dev, u_long cmd, caddr_t data, <span class="enscript-type">int</span> flag, proc_t p)
{
	<span class="enscript-keyword">return</span> (vnioctl(dev, cmd, data, flag, p, TRUE));
}

<span class="enscript-type">static</span>	<span class="enscript-type">int</span>
<span class="enscript-function-name">vnioctl_blk</span>(dev_t dev, u_long cmd, caddr_t data, <span class="enscript-type">int</span> flag, proc_t p)
{
	<span class="enscript-keyword">return</span> (vnioctl(dev, cmd, data, flag, p, FALSE));
}

<span class="enscript-comment">/*
 *	vniocattach_file:
 *
 *	Attach a file to a VN partition.  Return the size in the vn_size
 *	field.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vniocattach_file</span>(<span class="enscript-type">struct</span> vn_softc *vn,
		 <span class="enscript-type">struct</span> vn_ioctl_64 *vniop,
		 dev_t dev,
		 <span class="enscript-type">int</span> in_kernel,
		 proc_t p)
{
	dev_t	cdev;
	vfs_context_t ctx = vfs_context_current();
	kauth_cred_t cred;
	<span class="enscript-type">struct</span> nameidata nd;
	off_t file_size;
	<span class="enscript-type">int</span> error, flags;

	flags = FREAD|FWRITE;
	<span class="enscript-keyword">if</span> (in_kernel) {
		NDINIT(&amp;nd, LOOKUP, OP_OPEN, FOLLOW, UIO_SYSSPACE, vniop-&gt;vn_file, ctx);
	}
	<span class="enscript-keyword">else</span> {
		NDINIT(&amp;nd, LOOKUP, OP_OPEN, FOLLOW, 
			   (IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32), 
			   vniop-&gt;vn_file, ctx);
	}
	<span class="enscript-comment">/* vn_open gives both long- and short-term references */</span>
	error = vn_open(&amp;nd, flags, 0);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (error != EACCES &amp;&amp; error != EPERM &amp;&amp; error != EROFS) {
			<span class="enscript-keyword">return</span> (error);
		}
		flags &amp;= ~FWRITE;
		<span class="enscript-keyword">if</span> (in_kernel) {
			NDINIT(&amp;nd, LOOKUP, OP_OPEN, FOLLOW, UIO_SYSSPACE, 
			       vniop-&gt;vn_file, ctx);
		}
		<span class="enscript-keyword">else</span> {
			NDINIT(&amp;nd, LOOKUP, OP_OPEN, FOLLOW, 
				   (IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32), 
			       vniop-&gt;vn_file, ctx);
		}
		error = vn_open(&amp;nd, flags, 0);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">return</span> (error);
		}
	}
	<span class="enscript-keyword">if</span> (nd.ni_vp-&gt;v_type != VREG) {
		error = EINVAL;
	}
	<span class="enscript-keyword">else</span> {
		error = vnode_size(nd.ni_vp, &amp;file_size, ctx);
	}
	<span class="enscript-keyword">if</span> (error != 0) {
		(<span class="enscript-type">void</span>) vn_close(nd.ni_vp, flags, ctx);
		vnode_put(nd.ni_vp);
		<span class="enscript-keyword">return</span> (error);
	}
	cred = kauth_cred_proc_ref(p);
	nd.ni_vp-&gt;v_flag |= VNOCACHE_DATA;
	error = setcred(nd.ni_vp, cred);
	<span class="enscript-keyword">if</span> (error) {
		(<span class="enscript-type">void</span>)vn_close(nd.ni_vp, flags, ctx);
		vnode_put(nd.ni_vp);
		kauth_cred_unref(&amp;cred);
		<span class="enscript-keyword">return</span>(error);
	}
	vn-&gt;sc_secsize = DEV_BSIZE;
	vn-&gt;sc_fsize = file_size;
	vn-&gt;sc_size = file_size / vn-&gt;sc_secsize;
	vn-&gt;sc_vp = nd.ni_vp;
	vn-&gt;sc_vid = vnode_vid(nd.ni_vp);
	vn-&gt;sc_open_flags = flags;
	vn-&gt;sc_cred = cred;
	cdev = makedev(vndevice_cdev_major, minor(dev));
	vn-&gt;sc_cdev = devfs_make_node(cdev, DEVFS_CHAR,
				      UID_ROOT, GID_OPERATOR, 
				      0600, <span class="enscript-string">&quot;rvn%d&quot;</span>, 
				      minor(dev));
	vn-&gt;sc_flags |= VNF_INITED;
	<span class="enscript-keyword">if</span> (flags == FREAD)
		vn-&gt;sc_flags |= VNF_READONLY;
	<span class="enscript-comment">/* lose the short-term reference */</span>
	vnode_put(nd.ni_vp);
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vniocattach_shadow</span>(<span class="enscript-type">struct</span> vn_softc *vn, <span class="enscript-type">struct</span> vn_ioctl_64 *vniop, 
				   __unused dev_t dev, <span class="enscript-type">int</span> in_kernel, proc_t p)
{
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">int</span> error, flags;
	shadow_map_t *	map;
	off_t file_size;

	flags = FREAD|FWRITE;
	<span class="enscript-keyword">if</span> (in_kernel) {
		NDINIT(&amp;nd, LOOKUP, OP_OPEN, FOLLOW, UIO_SYSSPACE, vniop-&gt;vn_file, ctx);
	}
	<span class="enscript-keyword">else</span> {
		NDINIT(&amp;nd, LOOKUP, OP_OPEN, FOLLOW, 
			   (IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32), 
			   vniop-&gt;vn_file, ctx);
	}
	<span class="enscript-comment">/* vn_open gives both long- and short-term references */</span>
	error = vn_open(&amp;nd, flags, 0);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/* shadow MUST be writable! */</span>
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (nd.ni_vp-&gt;v_type != VREG 
	    || (error = vnode_size(nd.ni_vp, &amp;file_size, ctx))) {
		(<span class="enscript-type">void</span>)vn_close(nd.ni_vp, flags, ctx);
		vnode_put(nd.ni_vp);
		<span class="enscript-keyword">return</span> (error ? error : EINVAL);
	}
	map = shadow_map_create(vn-&gt;sc_fsize, file_size,
				0, vn-&gt;sc_secsize);
	<span class="enscript-keyword">if</span> (map == NULL) {
		(<span class="enscript-type">void</span>)vn_close(nd.ni_vp, flags, ctx);
		vnode_put(nd.ni_vp);
		vn-&gt;sc_shadow_vp = NULL;
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	vn-&gt;sc_shadow_vp = nd.ni_vp;
	vn-&gt;sc_shadow_vid = vnode_vid(nd.ni_vp);
	vn-&gt;sc_shadow_vp-&gt;v_flag |= VNOCACHE_DATA;
	vn-&gt;sc_shadow_map = map;
	vn-&gt;sc_flags &amp;= ~VNF_READONLY; <span class="enscript-comment">/* we're now read/write */</span>

	<span class="enscript-comment">/* lose the short-term reference */</span>
	vnode_put(nd.ni_vp);
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vndevice_root_image</span>(<span class="enscript-type">char</span> * path, <span class="enscript-type">char</span> devname[], dev_t * dev_p)
{
	<span class="enscript-type">int</span> 			error = 0;
	<span class="enscript-type">struct</span> vn_softc *		vn;
	<span class="enscript-type">struct</span> vn_ioctl_64 	vnio;

	vnio.vn_file = CAST_USER_ADDR_T(path);
	vnio.vn_size = 0;

	vn = vn_table + ROOT_IMAGE_UNIT;
	*dev_p = makedev(vndevice_bdev_major, 
			 ROOT_IMAGE_UNIT);
	snprintf(devname, 16, <span class="enscript-string">&quot;vn%d&quot;</span>, ROOT_IMAGE_UNIT);
	error = vniocattach_file(vn, &amp;vnio, *dev_p, 1, current_proc());
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Duplicate the current processes' credentials.  Since we are called only
 * as the result of a SET ioctl and only root can do that, any future access
 * to this &quot;disk&quot; is essentially as root.  Note that credentials may change
 * if some other uid can write directly to the mapped file (NFS).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">setcred</span>(<span class="enscript-type">struct</span> vnode * vp, kauth_cred_t cred)
{
	<span class="enscript-type">char</span> *tmpbuf;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> vfs_context  context; 		

	<span class="enscript-comment">/*
	 * Horrible kludge to establish credentials for NFS  XXX.
	 */</span>
	context.vc_thread = current_thread();
	context.vc_ucred = cred;
	tmpbuf = _MALLOC(DEV_BSIZE, M_TEMP, M_WAITOK);
	error = file_io(vp, &amp;context, UIO_READ, tmpbuf, 0, DEV_BSIZE, NULL);
	FREE(tmpbuf, M_TEMP);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnclear</span>(<span class="enscript-type">struct</span> vn_softc *vn, vfs_context_t ctx)
{
	<span class="enscript-keyword">if</span> (vn-&gt;sc_vp != NULL) {
		<span class="enscript-comment">/* release long-term reference */</span>
		(<span class="enscript-type">void</span>)vn_close(vn-&gt;sc_vp, vn-&gt;sc_open_flags, ctx);
		vn-&gt;sc_vp = NULL;
	}
	<span class="enscript-keyword">if</span> (vn-&gt;sc_shadow_vp != NULL) {
		<span class="enscript-comment">/* release long-term reference */</span>
		(<span class="enscript-type">void</span>)vn_close(vn-&gt;sc_shadow_vp, FREAD | FWRITE, ctx);
		vn-&gt;sc_shadow_vp = NULL;
	}
	<span class="enscript-keyword">if</span> (vn-&gt;sc_shadow_map != NULL) {
		shadow_map_free(vn-&gt;sc_shadow_map);
		vn-&gt;sc_shadow_map = NULL;
	}
	vn-&gt;sc_flags &amp;= ~(VNF_INITED | VNF_READONLY);
	<span class="enscript-keyword">if</span> (vn-&gt;sc_cred) {
		kauth_cred_unref(&amp;vn-&gt;sc_cred);
	}
	vn-&gt;sc_size = 0;
	vn-&gt;sc_fsize = 0;
	<span class="enscript-keyword">if</span> (vn-&gt;sc_cdev) {
		devfs_remove(vn-&gt;sc_cdev);
		vn-&gt;sc_cdev = NULL;
	}
}

<span class="enscript-type">static</span>	<span class="enscript-type">int</span>
<span class="enscript-function-name">vnsize</span>(dev_t dev)
{
	<span class="enscript-type">int</span>	secsize;
	<span class="enscript-type">struct</span> vn_softc *vn;
	<span class="enscript-type">int</span> unit;

	unit = vnunit(dev);
	<span class="enscript-keyword">if</span> (vnunit(dev) &gt;= NVNDEVICE) {
		<span class="enscript-keyword">return</span> (-1);
	}

	vn = vn_table + unit;
	<span class="enscript-keyword">if</span> ((vn-&gt;sc_flags &amp; VNF_INITED) == 0)
		secsize = -1;
	<span class="enscript-keyword">else</span>
		secsize = vn-&gt;sc_secsize;

	<span class="enscript-keyword">return</span> (secsize);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CDEV_MAJOR</span> 	-1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BDEV_MAJOR</span> 	-1
<span class="enscript-type">static</span> <span class="enscript-type">int</span> vndevice_inited = 0;

<span class="enscript-type">void</span> 
<span class="enscript-function-name">vndevice_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (vndevice_inited)
		<span class="enscript-keyword">return</span>;
		
	vndevice_do_init();
}
		
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">vndevice_do_init</span>( <span class="enscript-type">void</span> )
{
	<span class="enscript-type">int</span> 	i;

	vndevice_bdev_major = bdevsw_add(BDEV_MAJOR, &amp;vn_bdevsw);

	<span class="enscript-keyword">if</span> (vndevice_bdev_major &lt; 0) {
		printf(<span class="enscript-string">&quot;vndevice_init: bdevsw_add() returned %d\n&quot;</span>,
		       vndevice_bdev_major);
		<span class="enscript-keyword">return</span>;
	}
	vndevice_cdev_major = cdevsw_add_with_bdev(CDEV_MAJOR, &amp;vn_cdevsw,
						   vndevice_bdev_major);
	<span class="enscript-keyword">if</span> (vndevice_cdev_major &lt; 0) {
		printf(<span class="enscript-string">&quot;vndevice_init: cdevsw_add() returned %d\n&quot;</span>,
		       vndevice_cdev_major);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">for</span> (i = 0; i &lt; NVNDEVICE; i++) {
		dev_t	dev = makedev(vndevice_bdev_major, i);
		vn_table[i].sc_bdev = devfs_make_node(dev, DEVFS_BLOCK,
						      UID_ROOT, GID_OPERATOR, 
						      0600, <span class="enscript-string">&quot;vn%d&quot;</span>, 
						      i);
		<span class="enscript-keyword">if</span> (vn_table[i].sc_bdev == NULL)
			printf(<span class="enscript-string">&quot;vninit: devfs_make_node failed!\n&quot;</span>);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">vn_ioctl_to_64</span>(<span class="enscript-type">struct</span> vn_ioctl_32 *from, <span class="enscript-type">struct</span> vn_ioctl_64 *to) 
{
	to-&gt;vn_file = CAST_USER_ADDR_T(from-&gt;vn_file);
	to-&gt;vn_size = from-&gt;vn_size;
	to-&gt;vn_control = from-&gt;vn_control;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NVNDEVICE */</span>
</pre>
<hr />
</body></html>