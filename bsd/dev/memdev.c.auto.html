<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>memdev.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">memdev.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2004-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah Hdr: vn.c 1.13 94/04/02
 *
 *	from: @(#)vn.c	8.6 (Berkeley) 4/1/94
 * $FreeBSD: src/sys/dev/vn/vn.c,v 1.105.2.4 2001/11/18 07:11:00 dillon Exp $
 */</span>

<span class="enscript-comment">/*
 * RAM disk driver.
 *
 * Block interface to a ramdisk.  
 *
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disk.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/pmap.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pager.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/devfs.h&gt;</span>


<span class="enscript-type">void</span> 		mdevinit(<span class="enscript-type">int</span> the_cnt);

<span class="enscript-type">static</span> open_close_fcn_t	mdevopen;
<span class="enscript-type">static</span> open_close_fcn_t	mdevclose;
<span class="enscript-type">static</span> psize_fcn_t		mdevsize;
<span class="enscript-type">static</span> strategy_fcn_t	mdevstrategy;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>				mdevbioctl(dev_t dev, u_long cmd, caddr_t data, <span class="enscript-type">int</span> flag, <span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>				mdevcioctl(dev_t dev, u_long cmd, caddr_t data, <span class="enscript-type">int</span> flag, <span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 				mdevrw(dev_t dev, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> ioflag);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_MEMDEV_INSECURE</span>

<span class="enscript-type">static</span> <span class="enscript-type">char</span> *			nonspace(<span class="enscript-type">char</span> *pos, <span class="enscript-type">char</span> *end);
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *			getspace(<span class="enscript-type">char</span> *pos, <span class="enscript-type">char</span> *end);
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *			cvtnum(<span class="enscript-type">char</span> *pos, <span class="enscript-type">char</span> *end, uint64_t *num);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MEMDEV_INSECURE */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		bcopy_phys(addr64_t from, addr64_t to, vm_size_t bytes);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>		mapping_set_mod(ppnum_t pn);
<span class="enscript-type">extern</span> ppnum_t 	pmap_find_phys(pmap_t pmap, addr64_t va);


<span class="enscript-comment">/*
 * cdevsw
 *	D_DISK		we want to look like a disk
 *	D_CANFREE	We support B_FREEBUF
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> bdevsw mdevbdevsw = {
	<span class="enscript-comment">/* open */</span>	mdevopen,
	<span class="enscript-comment">/* close */</span>	mdevclose,
	<span class="enscript-comment">/* strategy */</span>	mdevstrategy,
	<span class="enscript-comment">/* ioctl */</span>	mdevbioctl,
	<span class="enscript-comment">/* dump */</span>	eno_dump,
	<span class="enscript-comment">/* psize */</span>	mdevsize,
	<span class="enscript-comment">/* flags */</span>	D_DISK,
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cdevsw mdevcdevsw = {
	<span class="enscript-comment">/* open */</span>	mdevopen,
	<span class="enscript-comment">/* close */</span>	mdevclose,
	<span class="enscript-comment">/* read */</span>	mdevrw,
	<span class="enscript-comment">/* write */</span>	mdevrw,
	<span class="enscript-comment">/* ioctl */</span>	mdevcioctl,
	<span class="enscript-comment">/* stop */</span>	eno_stop,
	<span class="enscript-comment">/* reset */</span>	eno_reset,
	<span class="enscript-comment">/* ttys */</span>	NULL,
	<span class="enscript-comment">/* select */</span>	eno_select,
	<span class="enscript-comment">/* mmap */</span>	eno_mmap,
	<span class="enscript-comment">/* strategy */</span>	eno_strat,
	<span class="enscript-comment">/* getc */</span>	eno_getc,
	<span class="enscript-comment">/* putc */</span>	eno_putc,
	<span class="enscript-comment">/* flags */</span>	D_DISK,
};

<span class="enscript-type">struct</span> mdev {
	uint64_t	mdBase;		<span class="enscript-comment">/* file size in bytes */</span>
	uint32_t	mdSize;		<span class="enscript-comment">/* file size in bytes */</span>
	<span class="enscript-type">int</span>			mdFlags;	<span class="enscript-comment">/* flags */</span>
	<span class="enscript-type">int</span>			mdSecsize;	<span class="enscript-comment">/* sector size */</span>
	<span class="enscript-type">int</span>			mdBDev;		<span class="enscript-comment">/* Block device number */</span>
	<span class="enscript-type">int</span>			mdCDev;		<span class="enscript-comment">/* Character device number */</span>
	<span class="enscript-type">void</span> *		mdbdevb;
	<span class="enscript-type">void</span> *		mdcdevb;
} mdev[16];

<span class="enscript-comment">/* mdFlags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mdInited</span>	0x01	<span class="enscript-comment">/* This device defined */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">mdRO</span>		0x02	<span class="enscript-comment">/* This device is read-only */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">mdPhys</span>		0x04	<span class="enscript-comment">/* This device is in physical memory */</span>

<span class="enscript-type">int</span> mdevBMajor = -1;
<span class="enscript-type">int</span> mdevCMajor = -1;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mdevioctl</span>(dev_t dev, u_long cmd, caddr_t data, <span class="enscript-type">int</span> flag, <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">int</span> is_char);
dev_t <span class="enscript-function-name">mdevadd</span>(<span class="enscript-type">int</span> devid, uint64_t base, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> size, <span class="enscript-type">int</span> phys);
dev_t <span class="enscript-function-name">mdevlookup</span>(<span class="enscript-type">int</span> devid);
<span class="enscript-type">void</span> <span class="enscript-function-name">mdevremoveall</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span>	<span class="enscript-type">int</span> mdevclose(__unused dev_t dev, __unused <span class="enscript-type">int</span> flags, 
					  __unused <span class="enscript-type">int</span> devtype, __unused <span class="enscript-type">struct</span> proc *p) {

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span>	<span class="enscript-type">int</span> mdevopen(dev_t dev, <span class="enscript-type">int</span> flags, __unused <span class="enscript-type">int</span> devtype, __unused <span class="enscript-type">struct</span> proc *p) {
	
	<span class="enscript-type">int</span> devid;

	devid = minor(dev);									<span class="enscript-comment">/* Get minor device number */</span>

	<span class="enscript-keyword">if</span> (devid &gt;= 16) <span class="enscript-keyword">return</span> (ENXIO);						<span class="enscript-comment">/* Not valid */</span>

	<span class="enscript-keyword">if</span> ((flags &amp; FWRITE) &amp;&amp; (mdev[devid].mdFlags &amp; mdRO)) <span class="enscript-keyword">return</span> (EACCES);	<span class="enscript-comment">/* Currently mounted RO */</span>

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mdevrw</span>(dev_t dev, <span class="enscript-type">struct</span> uio *uio, __unused <span class="enscript-type">int</span> ioflag) {
	<span class="enscript-type">int</span> 			status;
	addr64_t		mdata;
	<span class="enscript-type">int</span> 			devid;
	<span class="enscript-type">enum</span> uio_seg 	saveflag;

	devid = minor(dev);									<span class="enscript-comment">/* Get minor device number */</span>

	<span class="enscript-keyword">if</span> (devid &gt;= 16) <span class="enscript-keyword">return</span> (ENXIO);						<span class="enscript-comment">/* Not valid */</span>
	<span class="enscript-keyword">if</span> (!(mdev[devid].mdFlags &amp; mdInited))  <span class="enscript-keyword">return</span> (ENXIO);	<span class="enscript-comment">/* Have we actually been defined yet? */</span>

	mdata = ((addr64_t)mdev[devid].mdBase &lt;&lt; 12) + uio-&gt;uio_offset;	<span class="enscript-comment">/* Point to the area in &quot;file&quot; */</span>
	
	saveflag = uio-&gt;uio_segflg;							<span class="enscript-comment">/* Remember what the request is */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LP64_DEBUG</span>
	<span class="enscript-keyword">if</span> (UIO_IS_USER_SPACE(uio) == 0 &amp;&amp; UIO_IS_SYS_SPACE(uio) == 0) {
	  panic(<span class="enscript-string">&quot;mdevrw - invalid uio_segflg\n&quot;</span>); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LP64_DEBUG */</span>
	<span class="enscript-comment">/* Make sure we are moving from physical ram if physical device */</span>
	<span class="enscript-keyword">if</span> (mdev[devid].mdFlags &amp; mdPhys) {
		<span class="enscript-keyword">if</span> (uio-&gt;uio_segflg == UIO_USERSPACE64) 
			uio-&gt;uio_segflg = UIO_PHYS_USERSPACE64;	
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uio-&gt;uio_segflg == UIO_USERSPACE32)
			uio-&gt;uio_segflg = UIO_PHYS_USERSPACE32;	
		<span class="enscript-keyword">else</span>
			uio-&gt;uio_segflg = UIO_PHYS_USERSPACE;	
	}
	status = uiomove64(mdata, uio_resid(uio), uio);		<span class="enscript-comment">/* Move the data */</span>
	uio-&gt;uio_segflg = saveflag;							<span class="enscript-comment">/* Restore the flag */</span>

	<span class="enscript-keyword">return</span> (status);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mdevstrategy</span>(<span class="enscript-type">struct</span> buf *bp) {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> left, lop, csize;
	vm_offset_t vaddr, blkoff;
	<span class="enscript-type">int</span> devid;
	addr64_t paddr, fvaddr;
	ppnum_t pp;

	devid = minor(buf_device(bp));							<span class="enscript-comment">/* Get minor device number */</span>

	<span class="enscript-keyword">if</span> ((mdev[devid].mdFlags &amp; mdInited) == 0) {		<span class="enscript-comment">/* Have we actually been defined yet? */</span>
	        buf_seterror(bp, ENXIO);
		buf_biodone(bp);
		<span class="enscript-keyword">return</span>;
	}

	buf_setresid(bp, buf_count(bp));						<span class="enscript-comment">/* Set byte count */</span>
	
	blkoff = buf_blkno(bp) * mdev[devid].mdSecsize;		<span class="enscript-comment">/* Get offset into file */</span>

<span class="enscript-comment">/*
 *	Note that reading past end is an error, but reading at end is an EOF.  For these
 *	we just return with resid == count.
 */</span>

	<span class="enscript-keyword">if</span> (blkoff &gt;= (mdev[devid].mdSize &lt;&lt; 12)) {			<span class="enscript-comment">/* Are they trying to read/write at/after end? */</span>
		<span class="enscript-keyword">if</span>(blkoff != (mdev[devid].mdSize &lt;&lt; 12)) {		<span class="enscript-comment">/* Are we trying to read after EOF? */</span>
		        buf_seterror(bp, EINVAL);						<span class="enscript-comment">/* Yeah, this is an error */</span>
		}
		buf_biodone(bp);								<span class="enscript-comment">/* Return */</span>
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> ((blkoff + buf_count(bp)) &gt; (mdev[devid].mdSize &lt;&lt; 12)) {		<span class="enscript-comment">/* Will this read go past end? */</span>
		buf_setcount(bp, ((mdev[devid].mdSize &lt;&lt; 12) - blkoff));	<span class="enscript-comment">/* Yes, trim to max */</span>
	}
	<span class="enscript-comment">/*
	 * make sure the buffer's data area is
	 * accessible
	 */</span>
	<span class="enscript-keyword">if</span> (buf_map(bp, (caddr_t *)&amp;vaddr))
	        panic(<span class="enscript-string">&quot;ramstrategy: buf_map failed\n&quot;</span>);

	fvaddr = (mdev[devid].mdBase &lt;&lt; 12) + blkoff;		<span class="enscript-comment">/* Point to offset into ram disk */</span>
	
	<span class="enscript-keyword">if</span> (buf_flags(bp) &amp; B_READ) {					<span class="enscript-comment">/* Is this a read? */</span>
		<span class="enscript-keyword">if</span>(!(mdev[devid].mdFlags &amp; mdPhys)) {			<span class="enscript-comment">/* Physical mapped disk? */</span>
			bcopy((<span class="enscript-type">void</span> *)((uintptr_t)fvaddr),
				(<span class="enscript-type">void</span> *)vaddr, (size_t)buf_count(bp));	<span class="enscript-comment">/* This is virtual, just get the data */</span>
		}
		<span class="enscript-keyword">else</span> {
			left = buf_count(bp);						<span class="enscript-comment">/* Init the amount left to copy */</span>
			<span class="enscript-keyword">while</span>(left) {								<span class="enscript-comment">/* Go until it is all copied */</span>
				
				lop = min((4096 - (vaddr &amp; 4095)), (4096 - (fvaddr &amp; 4095)));	<span class="enscript-comment">/* Get smallest amount left on sink and source */</span>
				csize = min(lop, left);					<span class="enscript-comment">/* Don't move more than we need to */</span>
				
				pp = pmap_find_phys(kernel_pmap, (addr64_t)((uintptr_t)vaddr));	<span class="enscript-comment">/* Get the sink physical address */</span>
				<span class="enscript-keyword">if</span>(!pp) {								<span class="enscript-comment">/* Not found, what gives? */</span>
					panic(<span class="enscript-string">&quot;mdevstrategy: sink address %016llX not mapped\n&quot;</span>, (addr64_t)((uintptr_t)vaddr));
				}
				paddr = (addr64_t)(((addr64_t)pp &lt;&lt; 12) | (addr64_t)(vaddr &amp; 4095));	<span class="enscript-comment">/* Get actual address */</span>
				bcopy_phys(fvaddr, paddr, csize);		<span class="enscript-comment">/* Copy this on in */</span>
				mapping_set_mod(paddr &gt;&gt; 12);			<span class="enscript-comment">/* Make sure we know that it is modified */</span>
				
				left = left - csize;					<span class="enscript-comment">/* Calculate what is left */</span>
				vaddr = vaddr + csize;					<span class="enscript-comment">/* Move to next sink address */</span>
				fvaddr = fvaddr + csize;				<span class="enscript-comment">/* Bump to next physical address */</span>
			}
		}
	}
	<span class="enscript-keyword">else</span> {												<span class="enscript-comment">/* This is a write */</span>
		<span class="enscript-keyword">if</span>(!(mdev[devid].mdFlags &amp; mdPhys)) {			<span class="enscript-comment">/* Physical mapped disk? */</span>
			bcopy((<span class="enscript-type">void</span> *)vaddr, (<span class="enscript-type">void</span> *)((uintptr_t)fvaddr),
				(size_t)buf_count(bp));		<span class="enscript-comment">/* This is virtual, just put the data */</span>
		}
		<span class="enscript-keyword">else</span> {
			left = buf_count(bp);						<span class="enscript-comment">/* Init the amount left to copy */</span>
			<span class="enscript-keyword">while</span>(left) {								<span class="enscript-comment">/* Go until it is all copied */</span>
				
				lop = min((4096 - (vaddr &amp; 4095)), (4096 - (fvaddr &amp; 4095)));	<span class="enscript-comment">/* Get smallest amount left on sink and source */</span>
				csize = min(lop, left);					<span class="enscript-comment">/* Don't move more than we need to */</span>
				
				pp = pmap_find_phys(kernel_pmap, (addr64_t)((uintptr_t)vaddr));	<span class="enscript-comment">/* Get the source physical address */</span>
				<span class="enscript-keyword">if</span>(!pp) {								<span class="enscript-comment">/* Not found, what gives? */</span>
					panic(<span class="enscript-string">&quot;mdevstrategy: source address %016llX not mapped\n&quot;</span>, (addr64_t)((uintptr_t)vaddr));
				}
				paddr = (addr64_t)(((addr64_t)pp &lt;&lt; 12) | (addr64_t)(vaddr &amp; 4095));	<span class="enscript-comment">/* Get actual address */</span>
			
				bcopy_phys(paddr, fvaddr, csize);		<span class="enscript-comment">/* Move this on out */</span>
				
				left = left - csize;					<span class="enscript-comment">/* Calculate what is left */</span>
				vaddr = vaddr + csize;					<span class="enscript-comment">/* Move to next sink address */</span>
				fvaddr = fvaddr + csize;				<span class="enscript-comment">/* Bump to next physical address */</span>
			}
		}
	}
	<span class="enscript-comment">/*
	 * buf_unmap takes care of all the cases
	 * it will unmap the buffer from kernel
	 * virtual space if that was the state
	 * when we mapped it.
	 */</span>
	buf_unmap(bp);

	buf_setresid(bp, 0);									<span class="enscript-comment">/* Nothing more to do */</span>	
	buf_biodone(bp);									<span class="enscript-comment">/* Say we've finished */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mdevbioctl</span>(dev_t dev, u_long cmd, caddr_t data, <span class="enscript-type">int</span> flag, <span class="enscript-type">struct</span> proc *p) {
	<span class="enscript-keyword">return</span> (mdevioctl(dev, cmd, data, flag, p, 0));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mdevcioctl</span>(dev_t dev, u_long cmd, caddr_t data, <span class="enscript-type">int</span> flag, <span class="enscript-type">struct</span> proc *p) {
	<span class="enscript-keyword">return</span> (mdevioctl(dev, cmd, data, flag, p, 1));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mdevioctl</span>(dev_t dev, u_long cmd, caddr_t data, __unused <span class="enscript-type">int</span> flag, 
					 <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">int</span> is_char) {
	<span class="enscript-type">int</span> error;
	u_int32_t *f;
	u_int64_t *o;
	<span class="enscript-type">int</span> devid;
	dk_memdev_info_t * memdev_info;

	devid = minor(dev);									<span class="enscript-comment">/* Get minor device number */</span>

	<span class="enscript-keyword">if</span> (devid &gt;= 16) <span class="enscript-keyword">return</span> (ENXIO);						<span class="enscript-comment">/* Not valid */</span>

	error = proc_suser(p);			<span class="enscript-comment">/* Are we superman? */</span>
	<span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">return</span> (error);							<span class="enscript-comment">/* Nope... */</span>

	f = (u_int32_t*)data;
	o = (u_int64_t *)data;
	memdev_info = (dk_memdev_info_t *) data;

	<span class="enscript-keyword">switch</span> (cmd) {

		<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXBLOCKCOUNTREAD</span>:
			*o = 32;
			<span class="enscript-keyword">break</span>;
		
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXBLOCKCOUNTWRITE</span>:
			*o = 32;
			<span class="enscript-keyword">break</span>;
		
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXSEGMENTCOUNTREAD</span>:
			*o = 32;
			<span class="enscript-keyword">break</span>;
		
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMAXSEGMENTCOUNTWRITE</span>:
			*o = 32;
			<span class="enscript-keyword">break</span>;
		
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETBLOCKSIZE</span>:
			*f = mdev[devid].mdSecsize;
			<span class="enscript-keyword">break</span>;
		
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCSETBLOCKSIZE</span>:
			<span class="enscript-keyword">if</span> (is_char) <span class="enscript-keyword">return</span> (ENODEV);				<span class="enscript-comment">/* We can only do this for a block */</span>

			<span class="enscript-keyword">if</span> (*f &lt; DEV_BSIZE) <span class="enscript-keyword">return</span> (EINVAL);		<span class="enscript-comment">/* Too short? */</span>

			mdev[devid].mdSecsize = *f;					<span class="enscript-comment">/* set the new block size */</span>
			<span class="enscript-keyword">break</span>;
			
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCISWRITABLE</span>:
			*f = 1;
			<span class="enscript-keyword">break</span>;
			
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETBLOCKCOUNT</span>:
			<span class="enscript-keyword">if</span>(!(mdev[devid].mdFlags &amp; mdInited)) <span class="enscript-keyword">return</span> (ENXIO);
			*o = ((mdev[devid].mdSize &lt;&lt; 12) + mdev[devid].mdSecsize - 1) / mdev[devid].mdSecsize;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * We're interested in the following bits of information:
		 *   Are you a memory-backed device (always yes, in this case)?
		 *   Physical memory (mdPhys)?
		 *   What is your base page?
		 *   What is your size?
		 */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DKIOCGETMEMDEVINFO</span>:
			<span class="enscript-keyword">if</span> (!(mdev[devid].mdFlags &amp; mdInited)) <span class="enscript-keyword">return</span> (ENXIO);
			memdev_info-&gt;mi_mdev = TRUE;
			memdev_info-&gt;mi_phys = (mdev[devid].mdFlags &amp; mdPhys) ? TRUE : FALSE;
			memdev_info-&gt;mi_base = mdev[devid].mdBase;
			memdev_info-&gt;mi_size = mdev[devid].mdSize;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = ENOTTY;
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-type">static</span>	<span class="enscript-type">int</span> mdevsize(dev_t dev) {

	<span class="enscript-type">int</span> devid;

	devid = minor(dev);									<span class="enscript-comment">/* Get minor device number */</span>
	<span class="enscript-keyword">if</span> (devid &gt;= 16) <span class="enscript-keyword">return</span> (ENXIO);						<span class="enscript-comment">/* Not valid */</span>

	<span class="enscript-keyword">if</span> ((mdev[devid].mdFlags &amp; mdInited) == 0) <span class="enscript-keyword">return</span>(-1);		<span class="enscript-comment">/* Not inited yet */</span>

	<span class="enscript-keyword">return</span>(mdev[devid].mdSecsize);
}

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">mdevinit</span>(__unused <span class="enscript-type">int</span> the_cnt) {

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_MEMDEV_INSECURE</span>

	<span class="enscript-type">int</span> devid, phys;
	uint64_t base;
	uint64_t size;
	<span class="enscript-type">char</span> *ba, *lp;
	dev_t dev;
	
	
	ba = PE_boot_args();								<span class="enscript-comment">/* Get the boot arguments */</span>
	lp = ba + 256;										<span class="enscript-comment">/* Point to the end */</span>
		
	<span class="enscript-keyword">while</span>(1) {											<span class="enscript-comment">/* Step through, looking for our keywords */</span>
		phys = 0;										<span class="enscript-comment">/* Assume virtual memory device */</span>
		ba = nonspace(ba, lp);							<span class="enscript-comment">/* Find non-space */</span>
		<span class="enscript-keyword">if</span>(ba &gt;= lp) <span class="enscript-keyword">return</span>;							<span class="enscript-comment">/* We are done if no more... */</span>
		<span class="enscript-keyword">if</span>(((ba[0] != <span class="enscript-string">'v'</span>) &amp;&amp; (ba[0] != <span class="enscript-string">'p'</span>))  
		  || (ba[1] != <span class="enscript-string">'m'</span>) || (ba[2] != <span class="enscript-string">'d'</span>) || (ba[4] != <span class="enscript-string">'='</span>)
		  || (ba[3] &lt; <span class="enscript-string">'0'</span>) || (ba[3] &gt; <span class="enscript-string">'f'</span>) 
		  || ((ba[3] &gt; <span class="enscript-string">'9'</span>) &amp;&amp; (ba[3] &lt; <span class="enscript-string">'a'</span>))) {		<span class="enscript-comment">/* Is this of form &quot;vmdx=&quot; or &quot;pmdx=&quot; where x is hex digit? */</span>
			
			ba = getspace(ba, lp);						<span class="enscript-comment">/* Find next white space or end */</span>
			<span class="enscript-keyword">continue</span>;									<span class="enscript-comment">/* Start looking for the next one */</span>
		}
		
		<span class="enscript-keyword">if</span>(ba[0] == <span class="enscript-string">'p'</span>) phys = 1;						<span class="enscript-comment">/* Set physical memory disk */</span>
		
		devid = ba[3] &amp; 0xF;							<span class="enscript-comment">/* Assume digit */</span>
		<span class="enscript-keyword">if</span>(ba[3] &gt; <span class="enscript-string">'9'</span>) devid += 9;						<span class="enscript-comment">/* Adjust for hex digits */</span>
	
		ba = &amp;ba[5];									<span class="enscript-comment">/* Step past keyword */</span>
		ba = cvtnum(ba, lp, &amp;base);						<span class="enscript-comment">/* Convert base of memory disk */</span>
		<span class="enscript-keyword">if</span>(ba &gt;= lp) <span class="enscript-keyword">return</span>;							<span class="enscript-comment">/* Malformed one at the end, leave */</span>
		<span class="enscript-keyword">if</span>(ba[0] != <span class="enscript-string">'.'</span>) <span class="enscript-keyword">continue</span>;						<span class="enscript-comment">/* If not length separater, try next... */</span>
		<span class="enscript-keyword">if</span>(base &amp; 0xFFF) <span class="enscript-keyword">continue</span>;						<span class="enscript-comment">/* Only allow page aligned stuff */</span>
	
		ba++;											<span class="enscript-comment">/* Step past '.' */</span>
		ba = cvtnum(ba, lp, &amp;size);						<span class="enscript-comment">/* Try to convert it */</span>
		<span class="enscript-keyword">if</span>(!size || (size &amp; 0xFFF)) <span class="enscript-keyword">continue</span>;			<span class="enscript-comment">/* Allow only non-zer page size multiples */</span>
		<span class="enscript-keyword">if</span>(ba &lt; lp) {									<span class="enscript-comment">/* If we are not at end, check end character */</span>
			<span class="enscript-keyword">if</span>((ba[0] != <span class="enscript-string">' '</span>) &amp;&amp; (ba[0] != 0)) <span class="enscript-keyword">continue</span>;	<span class="enscript-comment">/* End must be null or space */</span>
		}
		
		dev = mdevadd(devid, base &gt;&gt; 12, (<span class="enscript-type">unsigned</span>)size &gt;&gt; 12, phys);	<span class="enscript-comment">/* Go add the device */</span> 
	}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MEMDEV_INSECURE */</span>

	<span class="enscript-keyword">return</span>;

}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_MEMDEV_INSECURE</span>

<span class="enscript-type">char</span> *<span class="enscript-function-name">nonspace</span>(<span class="enscript-type">char</span> *pos, <span class="enscript-type">char</span> *end) {					<span class="enscript-comment">/* Find next non-space in string */</span>

	<span class="enscript-keyword">if</span>(pos &gt;= end) <span class="enscript-keyword">return</span> end;							<span class="enscript-comment">/* Don't go past end */</span>
	<span class="enscript-keyword">if</span>(pos[0] == 0) <span class="enscript-keyword">return</span> end;							<span class="enscript-comment">/* If at null, make end */</span>
	
	<span class="enscript-keyword">while</span>(1) {											<span class="enscript-comment">/* Keep going */</span>
		<span class="enscript-keyword">if</span>(pos[0] != <span class="enscript-string">' '</span>) <span class="enscript-keyword">return</span> pos;					<span class="enscript-comment">/* Leave if we found one */</span>
		pos++;											<span class="enscript-comment">/* Stop */</span>
		<span class="enscript-keyword">if</span>(pos &gt;= end) <span class="enscript-keyword">return</span> end;						<span class="enscript-comment">/* Quit if we run off end */</span>
	}
}

<span class="enscript-type">char</span> *<span class="enscript-function-name">getspace</span>(<span class="enscript-type">char</span> *pos, <span class="enscript-type">char</span> *end) {					<span class="enscript-comment">/* Find next non-space in string */</span>

	<span class="enscript-keyword">while</span>(1) {											<span class="enscript-comment">/* Keep going */</span>
		<span class="enscript-keyword">if</span>(pos &gt;= end) <span class="enscript-keyword">return</span> end;						<span class="enscript-comment">/* Don't go past end */</span>
		<span class="enscript-keyword">if</span>(pos[0] == 0) <span class="enscript-keyword">return</span> end;						<span class="enscript-comment">/* Leave if we hit null */</span>
		<span class="enscript-keyword">if</span>(pos[0] == <span class="enscript-string">' '</span>) <span class="enscript-keyword">return</span> pos;					<span class="enscript-comment">/* Leave if we found one */</span>
		pos++;											<span class="enscript-comment">/* Stop */</span>
	}
}

<span class="enscript-type">char</span> *<span class="enscript-function-name">cvtnum</span>(<span class="enscript-type">char</span> *pos, <span class="enscript-type">char</span> *end, uint64_t *num) {		<span class="enscript-comment">/* Convert to a number */</span>

	<span class="enscript-type">int</span> rad, dig;
	
	*num = 0;											<span class="enscript-comment">/* Set answer to 0 to start */</span>	
	rad = 10;

	<span class="enscript-keyword">if</span>(pos &gt;= end) <span class="enscript-keyword">return</span> end;							<span class="enscript-comment">/* Don't go past end */</span>
	<span class="enscript-keyword">if</span>(pos[0] == 0) <span class="enscript-keyword">return</span> end;							<span class="enscript-comment">/* If at null, make end */</span>
	
	<span class="enscript-keyword">if</span>(pos[0] == <span class="enscript-string">'0'</span> &amp;&amp; ((pos[1] == <span class="enscript-string">'x'</span>) || (pos[1] == <span class="enscript-string">'x'</span>))) {	<span class="enscript-comment">/* A hex constant? */</span>
		rad = 16;
		pos += 2;										<span class="enscript-comment">/* Point to the number */</span>
	}
	
	<span class="enscript-keyword">while</span>(1) {											<span class="enscript-comment">/* Convert it */</span>
		
		<span class="enscript-keyword">if</span>(pos &gt;= end) <span class="enscript-keyword">return</span> end;						<span class="enscript-comment">/* Don't go past end */</span>
		<span class="enscript-keyword">if</span>(pos[0] == 0) <span class="enscript-keyword">return</span> end;						<span class="enscript-comment">/* If at null, make end */</span>
		<span class="enscript-keyword">if</span>(pos[0] &lt; <span class="enscript-string">'0'</span>) <span class="enscript-keyword">return</span> pos;					<span class="enscript-comment">/* Leave if non-digit */</span>
		dig = pos[0] &amp; 0xF;								<span class="enscript-comment">/* Extract digit */</span>
		<span class="enscript-keyword">if</span>(pos[0] &gt; <span class="enscript-string">'9'</span>) {								<span class="enscript-comment">/* Is it bigger than 9? */</span>
			<span class="enscript-keyword">if</span>(rad == 10) <span class="enscript-keyword">return</span> pos;					<span class="enscript-comment">/* Leave if not base 10 */</span>
			<span class="enscript-keyword">if</span>(!(((pos[0] &gt;= <span class="enscript-string">'A'</span>) &amp;&amp; (pos[0] &lt;= <span class="enscript-string">'F'</span>)) 
			  || ((pos[0] &gt;= <span class="enscript-string">'a'</span>) &amp;&amp; (pos[0] &lt;= <span class="enscript-string">'f'</span>)))) <span class="enscript-keyword">return</span> pos;	<span class="enscript-comment">/* Leave if bogus char */</span>
			 dig = dig + 9;								<span class="enscript-comment">/* Adjust for character */</span>
		}
		*num = (*num * rad) + dig;						<span class="enscript-comment">/* Accumulate the number */</span>
		pos++;											<span class="enscript-comment">/* Step on */</span>
	}
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MEMDEV_INSECURE */</span>

dev_t <span class="enscript-function-name">mdevadd</span>(<span class="enscript-type">int</span> devid, uint64_t base, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> size, <span class="enscript-type">int</span> phys) {
	
	<span class="enscript-type">int</span> i;
	
	<span class="enscript-keyword">if</span>(devid &lt; 0) {

		devid = -1;
		<span class="enscript-keyword">for</span>(i = 0; i &lt; 16; i++) {						<span class="enscript-comment">/* Search all known memory devices */</span>
			<span class="enscript-keyword">if</span>(!(mdev[i].mdFlags &amp; mdInited)) {			<span class="enscript-comment">/* Is this a free one? */</span>
				<span class="enscript-keyword">if</span>(devid &lt; 0)devid = i;					<span class="enscript-comment">/* Remember first free one */</span>
				<span class="enscript-keyword">continue</span>;								<span class="enscript-comment">/* Skip check */</span>
			}
			<span class="enscript-keyword">if</span>(!(((base + size -1 ) &lt; mdev[i].mdBase) || ((mdev[i].mdBase + mdev[i].mdSize - 1) &lt; base))) {	<span class="enscript-comment">/* Is there any overlap? */</span>
				panic(<span class="enscript-string">&quot;mdevadd: attempt to add overlapping memory device at %016llX-%016llX\n&quot;</span>, mdev[i].mdBase, mdev[i].mdBase + mdev[i].mdSize - 1);
			}
		}
		<span class="enscript-keyword">if</span>(devid &lt; 0) {									<span class="enscript-comment">/* Do we have free slots? */</span>
			panic(<span class="enscript-string">&quot;mdevadd: attempt to add more than 16 memory devices\n&quot;</span>);
		}
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span>(devid &gt;= 16) {								<span class="enscript-comment">/* Giving us something bogus? */</span>
			panic(<span class="enscript-string">&quot;mdevadd: attempt to explicitly add a bogus memory device: %08X\n&quot;</span>, devid);
		}
		<span class="enscript-keyword">if</span>(mdev[devid].mdFlags &amp; mdInited) {			<span class="enscript-comment">/* Already there? */</span>
			panic(<span class="enscript-string">&quot;mdevadd: attempt to explicitly add a previously defined memory device: %08X\n&quot;</span>, devid);
		}
	}
	
	<span class="enscript-keyword">if</span>(mdevBMajor &lt; 0) {								<span class="enscript-comment">/* Have we gotten a major number yet? */</span>
		mdevBMajor = bdevsw_add(-1, &amp;mdevbdevsw);		<span class="enscript-comment">/* Add to the table and figure out a major number */</span>
		<span class="enscript-keyword">if</span> (mdevBMajor &lt; 0) {
			printf(<span class="enscript-string">&quot;mdevadd: error - bdevsw_add() returned %d\n&quot;</span>, mdevBMajor);
			<span class="enscript-keyword">return</span> -1;
		}
	}
	
	<span class="enscript-keyword">if</span>(mdevCMajor &lt; 0) {								<span class="enscript-comment">/* Have we gotten a major number yet? */</span>
		mdevCMajor = cdevsw_add_with_bdev(-1, &amp;mdevcdevsw, mdevBMajor);		<span class="enscript-comment">/* Add to the table and figure out a major number */</span>
		<span class="enscript-keyword">if</span> (mdevCMajor &lt; 0) {
			printf(<span class="enscript-string">&quot;ramdevice_init: error - cdevsw_add() returned %d\n&quot;</span>, mdevCMajor);
			<span class="enscript-keyword">return</span> -1;
		}
	}

	mdev[devid].mdBDev = makedev(mdevBMajor, devid);	<span class="enscript-comment">/* Get the device number */</span>
	mdev[devid].mdbdevb = devfs_make_node(mdev[devid].mdBDev, DEVFS_BLOCK,	<span class="enscript-comment">/* Make the node */</span>
						  UID_ROOT, GID_OPERATOR, 
						  0600, <span class="enscript-string">&quot;md%d&quot;</span>, devid);
	<span class="enscript-keyword">if</span> (mdev[devid].mdbdevb == NULL) {					<span class="enscript-comment">/* Did we make one? */</span>
		printf(<span class="enscript-string">&quot;mdevadd: devfs_make_node for block failed!\n&quot;</span>);
		<span class="enscript-keyword">return</span> -1;										<span class="enscript-comment">/* Nope... */</span>
	}

	mdev[devid].mdCDev = makedev(mdevCMajor, devid);	<span class="enscript-comment">/* Get the device number */</span>
	mdev[devid].mdcdevb = devfs_make_node(mdev[devid].mdCDev, DEVFS_CHAR,		<span class="enscript-comment">/* Make the node */</span>
						  UID_ROOT, GID_OPERATOR, 
						  0600, <span class="enscript-string">&quot;rmd%d&quot;</span>, devid);
	<span class="enscript-keyword">if</span> (mdev[devid].mdcdevb == NULL) {					<span class="enscript-comment">/* Did we make one? */</span>
		printf(<span class="enscript-string">&quot;mdevadd: devfs_make_node for character failed!\n&quot;</span>);
		<span class="enscript-keyword">return</span> -1;										<span class="enscript-comment">/* Nope... */</span>
	}
	
	mdev[devid].mdBase = base;							<span class="enscript-comment">/* Set the base address of ram disk */</span>
	mdev[devid].mdSize = size;							<span class="enscript-comment">/* Set the length of the ram disk */</span>
	mdev[devid].mdSecsize = DEV_BSIZE;					<span class="enscript-comment">/* Set starting block size */</span>
	<span class="enscript-keyword">if</span>(phys) mdev[devid].mdFlags |= mdPhys;				<span class="enscript-comment">/* Show that we are in physical memory */</span>
	mdev[devid].mdFlags |= mdInited;					<span class="enscript-comment">/* Show we are all set up */</span>
	printf(<span class="enscript-string">&quot;Added memory device md%x/rmd%x (%08X/%08X) at %016llX for %016llX\n&quot;</span>, 
		   devid, devid, mdev[devid].mdBDev, mdev[devid].mdCDev, base &lt;&lt; 12, (uint64_t)size &lt;&lt; 12);
	<span class="enscript-keyword">return</span> mdev[devid].mdBDev;
}


dev_t <span class="enscript-function-name">mdevlookup</span>(<span class="enscript-type">int</span> devid) {
	
	<span class="enscript-keyword">if</span>((devid &lt; 0) || (devid &gt; 15)) <span class="enscript-keyword">return</span> -1;			<span class="enscript-comment">/* Filter any bogus requests */</span>
	<span class="enscript-keyword">if</span>(!(mdev[devid].mdFlags &amp; mdInited)) <span class="enscript-keyword">return</span> -1;	<span class="enscript-comment">/* This one hasn't been defined */</span>
	<span class="enscript-keyword">return</span> mdev[devid].mdBDev;							<span class="enscript-comment">/* Return the device number */</span>
}

<span class="enscript-type">void</span> <span class="enscript-function-name">mdevremoveall</span>(<span class="enscript-type">void</span>) {

	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span>(i = 0; i &lt; 16; i++) {
		<span class="enscript-keyword">if</span>(!(mdev[i].mdFlags &amp; mdInited)) <span class="enscript-keyword">continue</span>;	<span class="enscript-comment">/* Ignore unused mdevs */</span>

		devfs_remove(mdev[i].mdbdevb);			<span class="enscript-comment">/* Remove the block device */</span>
		devfs_remove(mdev[i].mdcdevb);			<span class="enscript-comment">/* Remove the character device */</span>

		mdev[i].mdBase = 0;				<span class="enscript-comment">/* Clear the mdev's storage */</span>
		mdev[i].mdSize = 0;
		mdev[i].mdSecsize = 0;
		mdev[i].mdFlags = 0;
		mdev[i].mdBDev = 0;
		mdev[i].mdCDev = 0;
		mdev[i].mdbdevb = 0;
		mdev[i].mdcdevb = 0;
	}
}
</pre>
<hr />
</body></html>