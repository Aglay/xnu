<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>mockfs_vnops.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">mockfs_vnops.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/mockfs/mockfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/mockfs/mockfs_vnops.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vfs/vfs_support.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>

<span class="enscript-comment">/*
 * VOPFUNC macro; why do we have so many distinct definitions of this?
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VOPFUNC</span> int (*)(void *)

<span class="enscript-comment">/*
 * VNOP functions that mockfs implements.  See xnu/bsd/sys/vnode_if.h for information on what
 *   each function does in generic terms.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">mockfs_lookup</span>(<span class="enscript-type">struct</span> vnop_lookup_args * ap);
<span class="enscript-type">int</span> <span class="enscript-function-name">mockfs_getattr</span>(<span class="enscript-type">struct</span> vnop_getattr_args * ap);
<span class="enscript-type">int</span> <span class="enscript-function-name">mockfs_read</span>(<span class="enscript-type">struct</span> vnop_read_args * ap);
<span class="enscript-type">int</span> <span class="enscript-function-name">mockfs_strategy</span>(<span class="enscript-type">struct</span> vnop_strategy_args * ap);
<span class="enscript-type">int</span> <span class="enscript-function-name">mockfs_pagein</span>(<span class="enscript-type">struct</span> vnop_pagein_args * ap);
<span class="enscript-type">int</span> <span class="enscript-function-name">mockfs_reclaim</span>(__unused <span class="enscript-type">struct</span> vnop_reclaim_args * ap);
<span class="enscript-type">int</span> <span class="enscript-function-name">mockfs_blockmap</span>(<span class="enscript-type">struct</span> vnop_blockmap_args * ap);

<span class="enscript-comment">/*
 * struct vnop_lookup_args {
 *   struct vnodeop_desc *a_desc; // We don't care about this (for now)
 *   vnode_t a_dvp;               // vnode for the directory we are performing the lookup in
 *   vnode_t *a_vpp;              // Return parameter: the vnode we matched the lookup to
 *   struct componentname *a_cnp; // Description of the file we are looking for
 *   vfs_context_t a_context;     // We don't care about this (for now)
 * };
 *
 * mockfs_lookup:
 *   Given a vnode for a directory (a_dvp) and a file description (a_cnp), looks for a file matching
 *   the description in the directory, and give a vnode with an iocount for the file (*a_vpp), if the
 *   file was found.  For mockfs, because we realistically have 3 vnodes, the filesystem information
 *   is extremely sparse, so the details on naming are all implemented in mockfs_lookup; the generic VFS
 *   information is enough for us to distinguish between all 3 files.  Any lookup not done in the root
 *   vnode fails, by definition.  Each vnode has the following names in relation to the root vnode:
 *
 *   The root vnode:
 *     &quot;sbin&quot;
 *
 *   The devfs vnode:
 *     &quot;dev&quot;
 *
 *   The executable vnode
 *     &quot;launchd&quot;
 *
 * Returns 0 on success, or an error.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">mockfs_lookup</span>(<span class="enscript-type">struct</span> vnop_lookup_args * ap)
{
	<span class="enscript-type">char</span> held_char;
	<span class="enscript-type">int</span> rvalue;
	<span class="enscript-type">int</span> op;
	mockfs_fsnode_t fsnode;
	mockfs_fsnode_t target_fsnode;
	vnode_t dvp;
	vnode_t * vpp;
	vfs_context_t ctx;
	<span class="enscript-type">struct</span> componentname * cnp;

	rvalue = 0;
	dvp = ap-&gt;a_dvp;
	vpp = ap-&gt;a_vpp;
	cnp = ap-&gt;a_cnp;
	ctx = ap-&gt;a_context;
	op = cnp-&gt;cn_nameiop;
	fsnode = (mockfs_fsnode_t) dvp-&gt;v_data;
	target_fsnode = NULL;

	<span class="enscript-keyword">if</span> ((op == LOOKUP) &amp;&amp; (fsnode-&gt;type == MOCKFS_ROOT)) {
		<span class="enscript-comment">/*
		 * Okay, we're looking in the root directory, so we aren't necessarily
		 *   going to fail.  What are we looking for?
		 */</span>

		held_char = cnp-&gt;cn_nameptr[cnp-&gt;cn_namelen];
		cnp-&gt;cn_nameptr[cnp-&gt;cn_namelen] = <span class="enscript-string">'\0'</span>;

		<span class="enscript-comment">/*
		 * We'll resolve sbin to /, and launchd to the executable for the moment, so that I don't
		 *   accidentally commit a change to the init_process pathname.  We map from name to node type
		 *   here, as mockfs doesn't current use names; just unique types.
		 */</span>
		<span class="enscript-keyword">if</span> (!strncmp(cnp-&gt;cn_nameptr, <span class="enscript-string">&quot;sbin&quot;</span>, 5))
			target_fsnode = fsnode;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strncmp(cnp-&gt;cn_nameptr, <span class="enscript-string">&quot;dev&quot;</span>, 4))
			mockfs_fsnode_child_by_type(fsnode, MOCKFS_DEV, &amp;target_fsnode);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strncmp(cnp-&gt;cn_nameptr, <span class="enscript-string">&quot;launchd&quot;</span>, 8))
			mockfs_fsnode_child_by_type(fsnode, MOCKFS_FILE, &amp;target_fsnode);
		<span class="enscript-keyword">else</span>
			rvalue = ENOENT;

		cnp-&gt;cn_nameptr[cnp-&gt;cn_namelen] = held_char;

		<span class="enscript-keyword">if</span> (target_fsnode)
			rvalue = mockfs_fsnode_vnode(target_fsnode, vpp);
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * We aren't looking in root; the query may actually be reasonable, but we're not
		 *   going to support it.
		 */</span>
		rvalue = ENOENT;
	}

	<span class="enscript-keyword">return</span> rvalue;	
}

<span class="enscript-comment">/*
 * struct vnop_getattr_args {
 *   struct vnodeop_desc *a_desc; // We don't care about this (for now)
 *   vnode_t a_vp;                // Pointer to the vnode we are interested in
 *   struct vnode_attr *a_vap;    // Details the requested attributes, and used to return attributes
 *   vfs_context_t a_context;     // We don't care about this (for now)
 * };
 *
 * mockfs_getattr:
 *   Given a vnode (a_vp), returns the attributes requested for that vnode (*a_vap).  For mockfs, we don't care
 *   about the majority of attributes (we are not a fully featured filesystem).  We will return a minimal set of
 *   attributes for any request, regardless of which attributes were requested, to ensure that we look like a sane
 *   file, and so that permissions are set appropriately to allow execution of the executable vnode.
 *
 * Returns 0 on success, or an error.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">mockfs_getattr</span>(<span class="enscript-type">struct</span> vnop_getattr_args * ap)
{
	<span class="enscript-comment">/*
	 * For the moment, we don't actually care about most attributes.  We'll
	 *   deal with actually managing attributes as part of the general cleanup.
	 */</span>
	vnode_t vp;
	mockfs_fsnode_t fsnode;
	<span class="enscript-type">struct</span> vnode_attr * vap;

	vp = ap-&gt;a_vp;
	fsnode = (mockfs_fsnode_t)vp-&gt;v_data;
	vap = ap-&gt;a_vap;
	bzero(vap, <span class="enscript-keyword">sizeof</span>(*vap));
	VATTR_RETURN(vap, va_nlink, 1); <span class="enscript-comment">/* Simply assert that someone has at least one link to us */</span>
	VATTR_RETURN(vap, va_mode, VREAD | VWRITE | VEXEC);
	VATTR_RETURN(vap, va_fileid, fsnode-&gt;type);
	VATTR_RETURN(vap, va_total_size, fsnode-&gt;size);
	VATTR_RETURN(vap, va_total_alloc, fsnode-&gt;size);
	VATTR_RETURN(vap, va_data_size, fsnode-&gt;size);
	VATTR_RETURN(vap, va_data_alloc, fsnode-&gt;size);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * struct vnop_read_args {
 *   struct vnodeop_desc *a_desc; // We don't care about this (for now)
 *   vnode_t a_vp;                // Pointer to the vnode we are interested in
 *   struct uio *a_uio;           // Description of the request
 *   int a_ioflag;                // IO flags (we don't care about these)
 *   vfs_context_t a_context;     // We don't care about this (for now)
 * };
 *
 * mockfs_read:
 *   Given a vnode (a_vp), a set of flags (a_ioflag), and a description of a read request (a_uio), executes the read
 *   request and returns the resulting data through the description (a_uio).  mockfs has very little to do here; we
 *   merely mandate that any read attempt MUST be on VREG (our MOCKFS_FILE object), as it is the only vnode that has
 *   a backing store that can support a read (the other node types being purely in-memory hacks).  Because we do not
 *   support VNOP_OPEN, we can probably assume that the kernel is the only entity that will ever issue a VNOP_READ
 *   (as part of the exec path) to a mockfs vnode.
 *
 * Returns 0 on success, or an error.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">mockfs_read</span>(<span class="enscript-type">struct</span> vnop_read_args * ap)
{
	<span class="enscript-type">int</span> rvalue;
	vnode_t vp;
	mockfs_fsnode_t fsnode;

	vp = ap-&gt;a_vp;
	fsnode = (mockfs_fsnode_t) vp-&gt;v_data;

	<span class="enscript-comment">/*
	 * We're just an ugly frontend for the devnode, so we shouldn't need to do much for reads;
	 *   pass the work to cluster_read.
	 */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VREG) {
		rvalue = cluster_read(vp, ap-&gt;a_uio, fsnode-&gt;size, ap-&gt;a_ioflag);
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * You've tried to read from a nonregular file; I hate you.
		 */</span>
		rvalue = ENOTSUP;
	}

	<span class="enscript-keyword">return</span> rvalue;
}

<span class="enscript-comment">/*
 * struct vnop_reclaim_args {
 *   struct vnodeop_desc *a_desc; // We don't care about this (for now)
 *   vnode_t a_vp;                // Pointer to the vnode we are reclaiming
 *   vfs_context_t a_context;     // We don't care about this (for now)
 * };
 *
 * mockfs_reclaim:
 *   Given a vnode (a_vp), performs any cleanup needed to allow VFS to reclaim the vnode.  Because the mockfs tree
 *   is always in memory, we have very little to do as part of reclaim, so we'll just zero a few pointers and let
 *   VFS reclaim the vnode.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">mockfs_reclaim</span>(<span class="enscript-type">struct</span> vnop_reclaim_args * ap)
{
	<span class="enscript-type">int</span> rvalue;
	vnode_t vp;
	mockfs_fsnode_t fsnode;

	vp = ap-&gt;a_vp;
	fsnode = (mockfs_fsnode_t) vnode_fsnode(vp);
	rvalue = mockfs_fsnode_drop_vnode(fsnode);

	<span class="enscript-keyword">return</span> rvalue;
}

<span class="enscript-comment">/*
 * struct vnop_strategy_args {
 *   struct vnodeop_desc *a_desc; // We don't care about this (for now)
 *   struct buf *a_bp;            // Description of the desired IO
 * };
 *
 * mockfs_strategy:
 *   Given an IO description (a_bp), does any preparations required by the filesystem, and then passes the IO off to
 *   the appropriate device.  mockfs doesn't need to do anything to prepare for the IO, so we simply pass it off to
 *   our backing device.
 *
 * Returns 0 on success, or an error.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">mockfs_strategy</span>(<span class="enscript-type">struct</span> vnop_strategy_args * ap)
{
	<span class="enscript-type">int</span> rvalue;
	vnode_t dvp;

	<span class="enscript-comment">/*
	 * We'll avoid checking for a memory-backed device here; we already do this for blockmap, which will be
	 *   called as part of the IO path.
	 */</span>

	dvp = vfs_devvp(buf_vnode(ap-&gt;a_bp)-&gt;v_mount);

	<span class="enscript-keyword">if</span> (dvp) {
		rvalue = buf_strategy(dvp, ap);
		vnode_put(dvp);
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * I'm not certain this is the BEST error to return for this case.
		 */</span>
		rvalue = EIO;
	}

	<span class="enscript-keyword">return</span> rvalue;
}

<span class="enscript-comment">/*
 * struct vnop_pagein_args {
 *   struct vnodeop_desc *a_desc; // We don't care about this (for now)
 *   vnode_t a_vp;                // Pointer to the vnode we are interested in
 *   upl_t a_pl;                  // Describes the pages that need to be paged in
 *   upl_offset_t a_pl_offset;    // Offset in the UPL to start placing data at
 *   off_t a_f_offset;            // File offset to begin paging in at
 *   size_t a_size;               // Bytes of data to page in
 *   int a_flags;                 // UPL flags (we don't care about these)
 *   vfs_context_t a_context;     // We don't care about this (for now)
 * };
 *
 * mockfs_pagegin:
 *   Given a vnode (a_vp), and a region, described by an offset (a_f_offset) and a size (a_size), pages the region
 *   into the given UPL (a_pl), starting at the UPL offset (a_pl_offset).  For mockfs, we don't have anything significant
 *   to do for pagein, so we largely serve as a wrapper to the cluster_pagein routine.
 *
 * Returns 0 on success, or an error.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">mockfs_pagein</span>(<span class="enscript-type">struct</span> vnop_pagein_args * ap)
{
	mockfs_fsnode_t fsnode;
	mockfs_mount_t mockfs_mnt;

	<span class="enscript-comment">/*
	 * Nothing special needed from us; just nab the filesize and kick the work over to cluster_pagein.
	 */</span>
	fsnode = (mockfs_fsnode_t) ap-&gt;a_vp-&gt;v_data;
	mockfs_mnt = ((mockfs_mount_t) fsnode-&gt;mnt-&gt;mnt_data);	

	<span class="enscript-comment">/*
	 * If we represent a memory backed device, we should be pointing directly to the backing store; we should never
	 *   see a pagein in this case.
	 */</span>
	<span class="enscript-keyword">if</span> (mockfs_mnt-&gt;mockfs_memory_backed)
		panic(<span class="enscript-string">&quot;mockfs_pagein called for a memory-backed device&quot;</span>);

	<span class="enscript-keyword">return</span> cluster_pagein(ap-&gt;a_vp, ap-&gt;a_pl, ap-&gt;a_pl_offset, ap-&gt;a_f_offset, ap-&gt;a_size, fsnode-&gt;size, ap-&gt;a_flags);	
}

<span class="enscript-comment">/*
 * struct vnop_blockmap_args {
 *   struct vnodeop_desc *a_desc; // We don't care about this (for now)
 *   vnode_t a_vp;                // Pointer to the vnode we are interested in
 *   off_t a_foffset;             // File offset we are interested in
 *   size_t a_size;               // Size of the region we are interested in
 *   daddr64_t *a_bpn;            // Return parameter: physical block number the region we are interest in starts at
 *   size_t *a_run;               // Return parameter: number of contiguous bytes of data 
 *   void *a_poff;                // Unused, as far as I know
 *   int a_flags;                 // Used to distinguish reads and writes; we don't care
 *   vfs_context_t a_context;     // We don't care about this (for now)
 * };
 *
 * mockfs_blockmap:
 *   Given a vnode (a_vp), and a region, described by an offset (a_foffset), and a size (a_size), tells the caller
 *   which physical block (on the backing device) the region begins at (*a_bpn), and how many bytes can be read
 *   before the first discontinuity (*a_run).  For mockfs, because only VREG files are eligible for IO, and because
 *   all VREG files are simply a frontend for the backing device, this mapping will always be one to one, and all we
 *   need to do is convert the physical offset to the physical block number.
 *
 * Returns 0 on success, or an error.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">mockfs_blockmap</span>(<span class="enscript-type">struct</span> vnop_blockmap_args * ap)
{
	<span class="enscript-type">int</span> rvalue;
	off_t foffset;
	size_t * run;
	uint32_t blksize;
	daddr64_t * bpn;
	vnode_t vp;
	mockfs_fsnode_t fsnode;

	rvalue = 0;
	foffset = ap-&gt;a_foffset;
	run = ap-&gt;a_run;
	bpn = ap-&gt;a_bpn;
	vp = ap-&gt;a_vp;
	fsnode = (mockfs_fsnode_t) vp-&gt;v_data;
	blksize = vp-&gt;v_mount-&gt;mnt_devblocksize;

	<span class="enscript-comment">/*
	 * If we represent a memory backed device, we should be pointing directly to the backing store; all IO should
	 *   be satisfied from the UBC, and any called to blockmap (inidicating an attempted IO to the backing store)
	 *   is therefore disallowed.
	 */</span>
	<span class="enscript-keyword">if</span> (((mockfs_mount_t) fsnode-&gt;mnt-&gt;mnt_data)-&gt;mockfs_memory_backed)
		printf(<span class="enscript-string">&quot;mockfs_blockmap called for a memory-backed device\n&quot;</span>);

	<span class="enscript-comment">/*
	 * This will ultimately be simple; the vnode must be VREG (init), and the mapping will be 1 to 1.
	 *   This also means that their request should always be contiguous, so the run calculation is easy!
	 */</span>
	<span class="enscript-keyword">if</span> (vp-&gt;v_type == VREG) {
		*bpn = foffset / blksize;
		*run = fsnode-&gt;size - foffset;

		<span class="enscript-keyword">if</span> (ap-&gt;a_size &gt; *run) {
			<span class="enscript-comment">/* We've been asked for more data than the backing device can provide; we're done. */</span>
			panic(<span class="enscript-string">&quot;mockfs_blockmap was asked for a region that extended past the end of the backing device&quot;</span>);
		}
	}
	<span class="enscript-keyword">else</span> {
		rvalue = ENOTSUP;
	}

	<span class="enscript-keyword">return</span> rvalue;
}

<span class="enscript-function-name">int</span> (**mockfs_vnodeop_p)(<span class="enscript-type">void</span> *);
<span class="enscript-type">struct</span> vnodeopv_entry_desc mockfs_vnodeop_entries[] = {
	{ &amp;vnop_default_desc, (VOPFUNC) vn_default_error }, <span class="enscript-comment">/* default */</span>
	{ &amp;vnop_lookup_desc, (VOPFUNC) mockfs_lookup }, <span class="enscript-comment">/* lookup */</span>
	{ &amp;vnop_create_desc, (VOPFUNC) err_create },<span class="enscript-comment">/* create */</span>
	{ &amp;vnop_open_desc, (VOPFUNC) err_open }, <span class="enscript-comment">/* open */</span>
	{ &amp;vnop_mknod_desc, (VOPFUNC) err_mknod }, <span class="enscript-comment">/* mknod */</span>
	{ &amp;vnop_close_desc, (VOPFUNC) err_close }, <span class="enscript-comment">/* close */</span>
	{ &amp;vnop_access_desc, (VOPFUNC) err_access }, <span class="enscript-comment">/* access */</span>
	{ &amp;vnop_getattr_desc, (VOPFUNC) mockfs_getattr }, <span class="enscript-comment">/* getattr */</span>
	{ &amp;vnop_setattr_desc, (VOPFUNC) err_setattr }, <span class="enscript-comment">/* setattr */</span>
	{ &amp;vnop_read_desc, (VOPFUNC) mockfs_read }, <span class="enscript-comment">/* read */</span>
	{ &amp;vnop_write_desc, (VOPFUNC) err_write }, <span class="enscript-comment">/* write */</span>
	{ &amp;vnop_ioctl_desc, (VOPFUNC) err_ioctl }, <span class="enscript-comment">/* ioctl */</span>
	{ &amp;vnop_select_desc, (VOPFUNC) err_select }, <span class="enscript-comment">/* select */</span>
	{ &amp;vnop_mmap_desc, (VOPFUNC) err_mmap }, <span class="enscript-comment">/* mmap */</span>
	{ &amp;vnop_fsync_desc, (VOPFUNC) nop_fsync }, <span class="enscript-comment">/* fsync */</span>
	{ &amp;vnop_remove_desc, (VOPFUNC) err_remove }, <span class="enscript-comment">/* remove */</span>
	{ &amp;vnop_link_desc, (VOPFUNC) err_link }, <span class="enscript-comment">/* link */</span>
	{ &amp;vnop_rename_desc, (VOPFUNC) err_rename }, <span class="enscript-comment">/* rename */</span>
	{ &amp;vnop_mkdir_desc, (VOPFUNC) err_mkdir }, <span class="enscript-comment">/* mkdir */</span>
	{ &amp;vnop_rmdir_desc, (VOPFUNC) err_rmdir }, <span class="enscript-comment">/* rmdir */</span>
	{ &amp;vnop_symlink_desc, (VOPFUNC) err_symlink }, <span class="enscript-comment">/* symlink */</span>
	{ &amp;vnop_readdir_desc, (VOPFUNC) err_readdir }, <span class="enscript-comment">/* readdir */</span>
	{ &amp;vnop_readlink_desc, (VOPFUNC) err_readlink }, <span class="enscript-comment">/* readlink */</span>
	{ &amp;vnop_inactive_desc, (VOPFUNC) err_inactive }, <span class="enscript-comment">/* inactive */</span>
	{ &amp;vnop_reclaim_desc, (VOPFUNC) mockfs_reclaim }, <span class="enscript-comment">/* reclaim */</span>
	{ &amp;vnop_strategy_desc, (VOPFUNC) mockfs_strategy }, <span class="enscript-comment">/* strategy */</span>
	{ &amp;vnop_pathconf_desc, (VOPFUNC) err_pathconf }, <span class="enscript-comment">/* pathconf */</span>
	{ &amp;vnop_advlock_desc, (VOPFUNC) err_advlock }, <span class="enscript-comment">/* advlock */</span>
	{ &amp;vnop_bwrite_desc, (VOPFUNC) err_bwrite }, <span class="enscript-comment">/* bwrite */</span>
	{ &amp;vnop_pagein_desc, (VOPFUNC) mockfs_pagein }, <span class="enscript-comment">/* pagein */</span>
	{ &amp;vnop_pageout_desc, (VOPFUNC) err_pageout }, <span class="enscript-comment">/* pageout */</span>
	{ &amp;vnop_copyfile_desc, (VOPFUNC) err_copyfile }, <span class="enscript-comment">/* copyfile */</span>
	{ &amp;vnop_blktooff_desc, (VOPFUNC) err_blktooff }, <span class="enscript-comment">/* blktooff */</span>
	{ &amp;vnop_offtoblk_desc, (VOPFUNC) err_offtoblk }, <span class="enscript-comment">/* offtoblk */</span>
	{ &amp;vnop_blockmap_desc, (VOPFUNC) mockfs_blockmap }, <span class="enscript-comment">/* blockmap */</span>
	{ (<span class="enscript-type">struct</span> vnodeop_desc *) NULL, (VOPFUNC) NULL }
};

<span class="enscript-type">struct</span> vnodeopv_desc mockfs_vnodeop_opv_desc = {
	&amp;mockfs_vnodeop_p,
	mockfs_vnodeop_entries
};

</pre>
<hr />
</body></html>