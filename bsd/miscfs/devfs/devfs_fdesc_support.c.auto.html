<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>devfs_fdesc_support.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">devfs_fdesc_support.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software donated to Berkeley by
 * Jan-Simon Pendry.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)fdesc_vnops.c	8.17 (Berkeley) 5/22/95
 *
 */</span>

<span class="enscript-comment">/*
 * /dev/fd Filesystem
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>	<span class="enscript-comment">/* boottime */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dirent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/pipe.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vfs/vfs_support.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/fdesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/devfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/devfsdefs.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FDL_WANT</span>	0x01
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FDL_LOCKED</span>	0x02
<span class="enscript-type">static</span> <span class="enscript-type">int</span> fdcache_lock;


#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">FD_STDIN</span> != <span class="enscript-variable-name">FD_STDOUT</span>-1) || (<span class="enscript-variable-name">FD_STDOUT</span> != <span class="enscript-variable-name">FD_STDERR</span>-1)
FD_STDIN, FD_STDOUT, FD_STDERR must be a sequence n, n+1, n+2
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFDCACHE</span> 3

#<span class="enscript-reference">define</span> <span class="enscript-function-name">FD_NHASH</span>(ix) \
	(&amp;fdhashtbl[(ix) &amp; fdhash])
<span class="enscript-function-name">LIST_HEAD</span>(fdhashhead, fdescnode) *fdhashtbl;
u_long fdhash;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">fdesc_attr</span>(<span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t a_context);

lck_mtx_t fdesc_mtx;
lck_grp_t *fdesc_lckgrp;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">fdesc_lock</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_lock(&amp;fdesc_mtx);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">fdesc_unlock</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_unlock(&amp;fdesc_mtx);
}


<span class="enscript-comment">/*
 * Initialise cache headers, create the devfs node
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">devfs_fdesc_init</span>()
{
	<span class="enscript-type">int</span> error = 0;
	devnode_t *rootdir = dev_root-&gt;de_dnp;
	devdirent_t *direntp;
	
	<span class="enscript-comment">/* XXX Make sure you have the right path... */</span>
	fdhashtbl = hashinit(NFDCACHE, M_CACHE, &amp;fdhash);
	fdesc_lckgrp = lck_grp_alloc_init(<span class="enscript-string">&quot;fdesc&quot;</span>, NULL);
	lck_mtx_init(&amp;fdesc_mtx, fdesc_lckgrp, NULL);

	DEVFS_LOCK();
	dev_add_entry(<span class="enscript-string">&quot;fd&quot;</span>, rootdir, DEV_DEVFD, NULL, NULL, NULL, &amp;direntp);
	devfs_fdesc_makelinks();
	DEVFS_UNLOCK();

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Called during early startup, no need to synchronize
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">devfs_fdesc_makelinks</span>()
{
	<span class="enscript-type">int</span> error = 0;
	devdirent_t *stdin_ent = NULL, *stdout_ent = NULL, *stderr_ent = NULL;
	devnode_t *root_devnode = dev_root-&gt;de_dnp;

	<span class="enscript-comment">/* We do this ugliness to get around some &quot;const&quot; warnings */</span>
	<span class="enscript-type">char</span> in[] = <span class="enscript-string">&quot;stdin&quot;</span>;
	<span class="enscript-type">char</span> out[] = <span class="enscript-string">&quot;stdout&quot;</span>;
	<span class="enscript-type">char</span> err[] = <span class="enscript-string">&quot;stderr&quot;</span>;
	<span class="enscript-type">char</span> zero[] = <span class="enscript-string">&quot;fd/0&quot;</span>;
	<span class="enscript-type">char</span> one[] = <span class="enscript-string">&quot;fd/1&quot;</span>;
	<span class="enscript-type">char</span> two[] = <span class="enscript-string">&quot;fd/2&quot;</span>;

	<span class="enscript-keyword">if</span> ((error = devfs_make_symlink(root_devnode, in, 0555, zero, &amp;stdin_ent))) {
		printf(<span class="enscript-string">&quot;Couldn't make stdin, err %d.\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> ((error = devfs_make_symlink(root_devnode, out, 0555, one, &amp;stdout_ent))) {
		printf(<span class="enscript-string">&quot;Couldn't make stdout, err %d.\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> ((error = devfs_make_symlink(root_devnode, err, 0555, two, &amp;stderr_ent))) {
		printf(<span class="enscript-string">&quot;Couldn't make stderr, err %d.\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	
	<span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">if</span> (stdin_ent) {
		dev_free_name(stdin_ent);
	}
	<span class="enscript-keyword">if</span> (stdout_ent) {
		dev_free_name(stdout_ent);
	}
	<span class="enscript-keyword">if</span> (stderr_ent) {
		dev_free_name(stderr_ent);
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fdesc_allocvp</span>(fdntype ftype, <span class="enscript-type">int</span> ix, <span class="enscript-type">struct</span> mount *mp, <span class="enscript-type">struct</span> vnode **vpp, <span class="enscript-type">enum</span> vtype vtype, <span class="enscript-type">int</span> fdno)
{
	<span class="enscript-type">struct</span> fdhashhead *fc;
	<span class="enscript-type">struct</span> fdescnode *fd;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> vid = 0;
	<span class="enscript-type">struct</span> vnode_fsparam vfsp;

	fdesc_lock();

	fc = FD_NHASH(ix);
<span class="enscript-reference">loop</span>:
	<span class="enscript-keyword">for</span> (fd = fc-&gt;lh_first; fd != 0; fd = fd-&gt;fd_hash.le_next) {
		<span class="enscript-keyword">if</span> (fd-&gt;fd_ix == ix &amp;&amp; vnode_mount(fd-&gt;fd_vnode) == mp) {
		        vid = vnode_vid(fd-&gt;fd_vnode);
			fdesc_unlock();

			<span class="enscript-keyword">if</span> (vnode_getwithvid(fd-&gt;fd_vnode, vid)) {
				fdesc_lock();
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
			}

			*vpp = fd-&gt;fd_vnode;
			(*vpp)-&gt;v_type = vtype;

			<span class="enscript-keyword">return</span> (error);
		}
	}

	<span class="enscript-comment">/* Only one thread can add to the hash at a time */</span>
	<span class="enscript-keyword">if</span> (fdcache_lock &amp; FDL_LOCKED) {
		fdcache_lock |= FDL_WANT;
		msleep((caddr_t) &amp;fdcache_lock, &amp;fdesc_mtx, PINOD, <span class="enscript-string">&quot;fdesc_allocvp&quot;</span>, NULL);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
	}

	fdcache_lock |= FDL_LOCKED;
	fdesc_unlock();

	MALLOC(fd, <span class="enscript-type">void</span> *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> fdescnode), M_TEMP, M_WAITOK);

	vfsp.vnfs_mp = mp;
	vfsp.vnfs_vtype = vtype;
	vfsp.vnfs_str = <span class="enscript-string">&quot;fdesc&quot;</span>;
	vfsp.vnfs_dvp = NULL;
	vfsp.vnfs_fsnode = fd;
	vfsp.vnfs_cnp = NULL;
	vfsp.vnfs_vops = fdesc_vnodeop_p;
	vfsp.vnfs_rdev = 0;
	vfsp.vnfs_filesize = 0;
	vfsp.vnfs_flags = VNFS_NOCACHE | VNFS_CANTCACHE;
	vfsp.vnfs_marksystem = 0;
	vfsp.vnfs_markroot = 0;

	error = vnode_create(VNCREATE_FLAVOR, VCREATESIZE, &amp;vfsp, vpp);
	<span class="enscript-keyword">if</span> (error) {
		FREE(fd, M_TEMP);
		fdesc_lock();
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
	(*vpp)-&gt;v_tag = VT_FDESC;
	fd-&gt;fd_vnode = *vpp;
	fd-&gt;fd_type = ftype;
	fd-&gt;fd_fd = -1;
	fd-&gt;fd_link = NULL;
	fd-&gt;fd_ix = ix;
	fd-&gt;fd_fd = fdno;
	
	fdesc_lock();

	LIST_INSERT_HEAD(fc, fd, fd_hash);
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/* Hold the lock when we get here */</span>
	fdcache_lock &amp;= ~FDL_LOCKED;

	<span class="enscript-keyword">if</span> (fdcache_lock &amp; FDL_WANT) {
		fdcache_lock &amp;= ~FDL_WANT;
		wakeup((caddr_t) &amp;fdcache_lock);
	}
	
	fdesc_unlock();

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * vp is the current namei directory
 * ndp is the name to locate in that directory...
 *
 * This vnop should only be called on the special directory /dev/fd.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">devfs_devfd_lookup</span>(<span class="enscript-type">struct</span> vnop_lookup_args *ap)
{
	<span class="enscript-type">struct</span> vnode **vpp = ap-&gt;a_vpp;
	<span class="enscript-type">struct</span> vnode *dvp = ap-&gt;a_dvp;
	<span class="enscript-type">struct</span> componentname *cnp = ap-&gt;a_cnp;
	<span class="enscript-type">char</span> *pname = cnp-&gt;cn_nameptr;
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(ap-&gt;a_context);
	<span class="enscript-type">int</span> numfiles = p-&gt;p_fd-&gt;fd_nfiles;
	<span class="enscript-type">int</span> fd;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> vnode *fvp;

	<span class="enscript-keyword">if</span> (cnp-&gt;cn_namelen == 1 &amp;&amp; *pname == <span class="enscript-string">'.'</span>) {
		*vpp = dvp;
		
		<span class="enscript-keyword">if</span> ( (error = vnode_get(dvp)) ) {
			<span class="enscript-keyword">return</span>(error);
		}
		<span class="enscript-keyword">return</span> (0);
	}

	fd = 0;
	<span class="enscript-keyword">while</span> (*pname &gt;= <span class="enscript-string">'0'</span> &amp;&amp; *pname &lt;= <span class="enscript-string">'9'</span>) {
		fd = 10 * fd + *pname++ - <span class="enscript-string">'0'</span>;
		<span class="enscript-keyword">if</span> (fd &gt;= numfiles)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (*pname != <span class="enscript-string">'\0'</span>) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> (fd &lt; 0 || fd &gt;= numfiles ||
			*fdfile(p, fd) == NULL ||
			(*fdflags(p, fd) &amp; UF_RESERVED)) {
		error = EBADF;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	error = fdesc_allocvp(Fdesc, FD_DESC+fd, dvp-&gt;v_mount, &amp;fvp, VNON, fd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	*vpp = fvp;
	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">bad</span>:
	*vpp = NULL;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fdesc_open</span>(<span class="enscript-type">struct</span> vnop_open_args *ap)
{
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	thread_t thr = vfs_context_thread(ap-&gt;a_context);
	uthread_t uu;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (thr == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	uu = get_bsdthread_info(thr);

	<span class="enscript-keyword">switch</span> (VTOFDESC(vp)-&gt;fd_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Fdesc</span>:
		<span class="enscript-comment">/*
		 * XXX Kludge: set uu-&gt;uu_dupfd to contain the value of the
		 * the file descriptor being sought for duplication. The error 
		 * return ensures that the vnode for this device will be
		 * released by vn_open. Open will detect this special error and
		 * take the actions in dupfdopen.  Other callers of vn_open or
		 * vnop_open will simply report the error.
		 */</span>
		uu-&gt;uu_dupfd = VTOFDESC(vp)-&gt;fd_fd;	<span class="enscript-comment">/* XXX */</span>
		error = ENODEV;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:	
		panic(<span class="enscript-string">&quot;Invalid type for fdesc node!&quot;</span>);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fdesc_attr</span>(<span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t a_context)
{
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">struct</span> proc *p = vfs_context_proc(a_context);
	<span class="enscript-type">struct</span> stat stb;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((error = fp_lookup(p, fd, &amp;fp, 0)))
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">switch</span> (FILEGLOB_DTYPE(fp-&gt;f_fglob)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_VNODE</span>:
		<span class="enscript-keyword">if</span>((error = vnode_getwithref((<span class="enscript-type">struct</span> vnode *) fp-&gt;f_fglob-&gt;fg_data)) != 0) {
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> ((error = vnode_authorize((<span class="enscript-type">struct</span> vnode *)fp-&gt;f_fglob-&gt;fg_data,
			 NULL,
			 KAUTH_VNODE_READ_ATTRIBUTES | KAUTH_VNODE_READ_SECURITY,
			 a_context)) == 0)
			error = vnode_getattr((<span class="enscript-type">struct</span> vnode *)fp-&gt;f_fglob-&gt;fg_data, vap, a_context);
		<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; vap-&gt;va_type == VDIR) {
			<span class="enscript-comment">/*
			 * directories can cause loops in the namespace,
			 * so turn off the 'x' bits to avoid trouble.
			 *
			 * XXX ACLs break this, of course
			 */</span>
			vap-&gt;va_mode &amp;= ~((VEXEC)|(VEXEC&gt;&gt;3)|(VEXEC&gt;&gt;6));
		}
		(<span class="enscript-type">void</span>)vnode_put((<span class="enscript-type">struct</span> vnode *) fp-&gt;f_fglob-&gt;fg_data);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_SOCKET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_PIPE</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SOCKETS</span>
		<span class="enscript-keyword">if</span> (FILEGLOB_DTYPE(fp-&gt;f_fglob) == DTYPE_SOCKET)
			error = soo_stat((<span class="enscript-type">struct</span> socket *)fp-&gt;f_fglob-&gt;fg_data, (<span class="enscript-type">void</span> *)&amp;stb, 0);
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* SOCKETS */</span>
			error = pipe_stat((<span class="enscript-type">struct</span> pipe *)fp-&gt;f_fglob-&gt;fg_data, (<span class="enscript-type">void</span> *)&amp;stb, 0);

		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-keyword">if</span> (FILEGLOB_DTYPE(fp-&gt;f_fglob) == DTYPE_SOCKET)
			        VATTR_RETURN(vap, va_type, VSOCK);
                        <span class="enscript-keyword">else</span>
			        VATTR_RETURN(vap, va_type, VFIFO);

			VATTR_RETURN(vap, va_mode, stb.st_mode);
			VATTR_RETURN(vap, va_nlink, stb.st_nlink);
			VATTR_RETURN(vap, va_uid, stb.st_uid);
			VATTR_RETURN(vap, va_gid, stb.st_gid);
			VATTR_RETURN(vap, va_fsid, stb.st_dev);
			VATTR_RETURN(vap, va_fileid, stb.st_ino);
			VATTR_RETURN(vap, va_data_size, stb.st_size);
			VATTR_RETURN(vap, va_access_time, stb.st_atimespec);
			VATTR_RETURN(vap, va_modify_time, stb.st_mtimespec);
			VATTR_RETURN(vap, va_change_time, stb.st_ctimespec);
			VATTR_RETURN(vap, va_gen, stb.st_gen);
			VATTR_RETURN(vap, va_flags, stb.st_flags);
			VATTR_RETURN(vap, va_rdev, stb.st_rdev);
			VATTR_RETURN(vap, va_total_alloc, stb.st_blocks * stb.st_blksize);
			VATTR_RETURN(vap, va_acl, NULL);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = EBADF;
	}

	fp_drop(p, fd, fp, 0);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fdesc_getattr</span>(<span class="enscript-type">struct</span> vnop_getattr_args *ap)
{
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> vnode_attr *vap = ap-&gt;a_vap;
	<span class="enscript-type">unsigned</span> fd;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (VTOFDESC(vp)-&gt;fd_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Fdesc</span>:
		fd = VTOFDESC(vp)-&gt;fd_fd;
		error = fdesc_attr(fd, vap, ap-&gt;a_context);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;Invalid type for an fdesc node!\n&quot;</span>);
		<span class="enscript-keyword">break</span>;	
	}
	
	<span class="enscript-comment">/* 
	 * Yes, we do this without locking, but this value is always just
	 * a snapshot.
	 */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		vp-&gt;v_type = vap-&gt;va_type;
		
		<span class="enscript-comment">/* We need an inactive to reset type to VNON */</span>
		vnode_setneedinactive(vp);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fdesc_setattr</span>(<span class="enscript-type">struct</span> vnop_setattr_args *ap)
{
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">unsigned</span> fd;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> proc * p = vfs_context_proc(ap-&gt;a_context);

	<span class="enscript-comment">/*
	 * Can't mess with the root vnode
	 */</span>
	<span class="enscript-keyword">switch</span> (VTOFDESC(ap-&gt;a_vp)-&gt;fd_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Fdesc</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;Invalid type for an fdesc node!\n&quot;</span>);
		<span class="enscript-keyword">return</span> (EACCES);
	}

	fd = VTOFDESC(ap-&gt;a_vp)-&gt;fd_fd;
	<span class="enscript-keyword">if</span> ((error = fp_lookup(vfs_context_proc(ap-&gt;a_context), fd, &amp;fp, 0)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * Can setattr the underlying vnode, but not sockets!
	 */</span>
	<span class="enscript-keyword">switch</span> (FILEGLOB_DTYPE(fp-&gt;f_fglob)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_VNODE</span>:
	{
		<span class="enscript-keyword">if</span> ((error = vnode_getwithref((<span class="enscript-type">struct</span> vnode *) fp-&gt;f_fglob-&gt;fg_data)) != 0)
			<span class="enscript-keyword">break</span>;
		error = vnode_setattr((<span class="enscript-type">struct</span> vnode *) fp-&gt;f_fglob-&gt;fg_data, ap-&gt;a_vap, ap-&gt;a_context);
		(<span class="enscript-type">void</span>)vnode_put((<span class="enscript-type">struct</span> vnode *) fp-&gt;f_fglob-&gt;fg_data);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_SOCKET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_PIPE</span>:
		error = 0;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = EBADF;
		<span class="enscript-keyword">break</span>;
	}

	fp_drop(p, fd, fp, 0);
	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">UIO_MX</span> 16

<span class="enscript-comment">/*
static struct dirtmp {
	u_int32_t d_fileno;
	u_short d_reclen;
	u_short d_namlen;
	char d_name[8];
} rootent[] = {
	{ FD_DEVFD, UIO_MX, 2, &quot;fd&quot; },
	{ FD_STDIN, UIO_MX, 5, &quot;stdin&quot; },
	{ FD_STDOUT, UIO_MX, 6, &quot;stdout&quot; },
	{ FD_STDERR, UIO_MX, 6, &quot;stderr&quot; },
	{ 0, 0, 0, &quot;&quot; }
};
*/</span>

<span class="enscript-comment">/* Only called on /dev/fd */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">devfs_devfd_readdir</span>(<span class="enscript-type">struct</span> vnop_readdir_args *ap)
{
	<span class="enscript-type">struct</span> uio *uio = ap-&gt;a_uio;
	<span class="enscript-type">struct</span> proc *p = current_proc();
	<span class="enscript-type">int</span> i, error;

	<span class="enscript-comment">/*
	 * We don't allow exporting fdesc mounts, and currently local
	 * requests do not need cookies.
	 */</span>
	<span class="enscript-keyword">if</span> (ap-&gt;a_flags &amp; (VNODE_READDIR_EXTENDED | VNODE_READDIR_REQSEEKOFF))
		<span class="enscript-keyword">return</span> (EINVAL);

	i = uio-&gt;uio_offset / UIO_MX;
	error = 0;
	<span class="enscript-keyword">while</span> (uio_resid(uio) &gt; 0) {
		<span class="enscript-keyword">if</span> (i &gt;= p-&gt;p_fd-&gt;fd_nfiles)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (*fdfile(p, i) != NULL &amp;&amp; !(*fdflags(p, i) &amp; UF_RESERVED)) {
			<span class="enscript-type">struct</span> dirent d;
			<span class="enscript-type">struct</span> dirent *dp = &amp;d;

			bzero((caddr_t) dp, UIO_MX);

			dp-&gt;d_namlen = snprintf(dp-&gt;d_name, <span class="enscript-keyword">sizeof</span>(dp-&gt;d_name),
						<span class="enscript-string">&quot;%d&quot;</span>, i);
			dp-&gt;d_reclen = UIO_MX;
			dp-&gt;d_type = DT_UNKNOWN;
			dp-&gt;d_fileno = i + FD_STDIN;
			<span class="enscript-comment">/*
			 * And ship to userland
			 */</span>
			error = uiomove((caddr_t) dp, UIO_MX, uio);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
		}
		i++;
	}

	uio-&gt;uio_offset = i * UIO_MX;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fdesc_read</span>(__unused <span class="enscript-type">struct</span> vnop_read_args *ap)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fdesc_write</span>(__unused <span class="enscript-type">struct</span> vnop_write_args *ap)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fdesc_ioctl</span>(__unused <span class="enscript-type">struct</span> vnop_ioctl_args *ap)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fdesc_select</span>(__unused <span class="enscript-type">struct</span> vnop_select_args *ap)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fdesc_inactive</span>(<span class="enscript-type">struct</span> vnop_inactive_args *ap)
{
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;

	<span class="enscript-comment">/*
	 * Clear out the v_type field to avoid
	 * nasty things happening in vgone().
	 */</span>
	vp-&gt;v_type = VNON;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fdesc_reclaim</span>(<span class="enscript-type">struct</span> vnop_reclaim_args *ap)
{
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> fdescnode *fd = VTOFDESC(vp);

	fdesc_lock();

	LIST_REMOVE(fd, fd_hash);
	FREE(vp-&gt;v_data, M_TEMP);
	vp-&gt;v_data = NULL;
	
	fdesc_unlock();

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Return POSIX pathconf information applicable to special devices.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fdesc_pathconf</span>(<span class="enscript-type">struct</span> vnop_pathconf_args *ap)
{

	<span class="enscript-keyword">switch</span> (ap-&gt;a_name) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_LINK_MAX</span>:
		*ap-&gt;a_retval = LINK_MAX;
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_MAX_CANON</span>:
		*ap-&gt;a_retval = MAX_CANON;
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_MAX_INPUT</span>:
		*ap-&gt;a_retval = MAX_INPUT;
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_PIPE_BUF</span>:
		*ap-&gt;a_retval = PIPE_BUF;
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_CHOWN_RESTRICTED</span>:
		*ap-&gt;a_retval = 200112;		<span class="enscript-comment">/* _POSIX_CHOWN_RESTRICTED */</span>
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_VDISABLE</span>:
		*ap-&gt;a_retval = _POSIX_VDISABLE;
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-comment">/* NOTREACHED */</span>
}

<span class="enscript-comment">/*
 * /dev/fd &quot;should never get here&quot; operation
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fdesc_badop</span>(<span class="enscript-type">void</span>)
{

	<span class="enscript-keyword">return</span> (ENOTSUP);
	<span class="enscript-comment">/* NOTREACHED */</span>
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VOPFUNC</span> int (*)(void *)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_create</span> (int (*) (struct  vnop_create_args *))eopnotsupp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_mknod</span> (int (*) (struct  vnop_mknod_args *))eopnotsupp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_close</span> (int (*) (struct  vnop_close_args *))nullop
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_access</span> (int (*) (struct  vnop_access_args *))nullop
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_mmap</span> (int (*) (struct  vnop_mmap_args *))eopnotsupp
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">fdesc_revoke</span> nop_revoke
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_fsync</span> (int (*) (struct  vnop_fsync_args *))nullop
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_remove</span> (int (*) (struct  vnop_remove_args *))eopnotsupp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_link</span> (int (*) (struct  vnop_link_args *))eopnotsupp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_rename</span> (int (*) (struct  vnop_rename_args *))eopnotsupp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_mkdir</span> (int (*) (struct  vnop_mkdir_args *))eopnotsupp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_rmdir</span> (int (*) (struct  vnop_rmdir_args *))eopnotsupp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_symlink</span> (int (*) (struct vnop_symlink_args *))eopnotsupp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_strategy</span> (int (*) (struct  vnop_strategy_args *))fdesc_badop
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_advlock</span> (int (*) (struct vnop_advlock_args *))eopnotsupp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_bwrite</span> (int (*) (struct  vnop_bwrite_args *))eopnotsupp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_blktooff</span> (int (*) (struct  vnop_blktooff_args *))eopnotsupp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_offtoblk</span> (int (*) (struct  vnop_offtoblk_args *))eopnotsupp
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">fdesc_blockmap</span> (int (*) (struct  vnop_blockmap_args *))eopnotsupp

<span class="enscript-function-name">int</span> (**fdesc_vnodeop_p)(<span class="enscript-type">void</span> *);
<span class="enscript-type">struct</span> vnodeopv_entry_desc devfs_fdesc_vnodeop_entries[] = {
	{ &amp;vnop_default_desc, (VOPFUNC)vn_default_error },
	{ &amp;vnop_lookup_desc, (VOPFUNC)vn_default_error},	<span class="enscript-comment">/* lookup */</span>
	{ &amp;vnop_create_desc, (VOPFUNC)fdesc_create },	<span class="enscript-comment">/* create */</span>
	{ &amp;vnop_mknod_desc, (VOPFUNC)fdesc_mknod },	<span class="enscript-comment">/* mknod */</span>
	{ &amp;vnop_open_desc, (VOPFUNC)fdesc_open },	<span class="enscript-comment">/* open */</span>
	{ &amp;vnop_close_desc, (VOPFUNC)fdesc_close },	<span class="enscript-comment">/* close */</span>
	{ &amp;vnop_access_desc, (VOPFUNC)fdesc_access },	<span class="enscript-comment">/* access */</span>
	{ &amp;vnop_getattr_desc, (VOPFUNC)fdesc_getattr },	<span class="enscript-comment">/* getattr */</span>
	{ &amp;vnop_setattr_desc, (VOPFUNC)fdesc_setattr },	<span class="enscript-comment">/* setattr */</span>
	{ &amp;vnop_read_desc, (VOPFUNC)fdesc_read },	<span class="enscript-comment">/* read */</span>
	{ &amp;vnop_write_desc, (VOPFUNC)fdesc_write },	<span class="enscript-comment">/* write */</span>
	{ &amp;vnop_ioctl_desc, (VOPFUNC)fdesc_ioctl },	<span class="enscript-comment">/* ioctl */</span>
	{ &amp;vnop_select_desc, (VOPFUNC)fdesc_select },	<span class="enscript-comment">/* select */</span>
	{ &amp;vnop_revoke_desc, (VOPFUNC)fdesc_revoke },	<span class="enscript-comment">/* revoke */</span>
	{ &amp;vnop_mmap_desc, (VOPFUNC)fdesc_mmap },	<span class="enscript-comment">/* mmap */</span>
	{ &amp;vnop_fsync_desc, (VOPFUNC)fdesc_fsync },	<span class="enscript-comment">/* fsync */</span>
	{ &amp;vnop_remove_desc, (VOPFUNC)fdesc_remove },	<span class="enscript-comment">/* remove */</span>
	{ &amp;vnop_link_desc, (VOPFUNC)fdesc_link },	<span class="enscript-comment">/* link */</span>
	{ &amp;vnop_rename_desc, (VOPFUNC)fdesc_rename },	<span class="enscript-comment">/* rename */</span>
	{ &amp;vnop_mkdir_desc, (VOPFUNC)fdesc_mkdir },	<span class="enscript-comment">/* mkdir */</span>
	{ &amp;vnop_rmdir_desc, (VOPFUNC)fdesc_rmdir },	<span class="enscript-comment">/* rmdir */</span>
	{ &amp;vnop_symlink_desc, (VOPFUNC)fdesc_symlink },	<span class="enscript-comment">/* symlink */</span>
	{ &amp;vnop_readdir_desc, (VOPFUNC)vn_default_error},<span class="enscript-comment">/* readdir */</span>
	{ &amp;vnop_readlink_desc, (VOPFUNC)err_readlink}, <span class="enscript-comment">/* readlink */</span>
	{ &amp;vnop_inactive_desc, (VOPFUNC)fdesc_inactive },<span class="enscript-comment">/* inactive */</span>
	{ &amp;vnop_reclaim_desc, (VOPFUNC)fdesc_reclaim },	<span class="enscript-comment">/* reclaim */</span>
	{ &amp;vnop_strategy_desc, (VOPFUNC)fdesc_strategy },	<span class="enscript-comment">/* strategy */</span>
	{ &amp;vnop_pathconf_desc, (VOPFUNC)fdesc_pathconf },	<span class="enscript-comment">/* pathconf */</span>
	{ &amp;vnop_advlock_desc, (VOPFUNC)fdesc_advlock },	<span class="enscript-comment">/* advlock */</span>
	{ &amp;vnop_bwrite_desc, (VOPFUNC)fdesc_bwrite },	<span class="enscript-comment">/* bwrite */</span>
	{ &amp;vnop_pagein_desc, (VOPFUNC)err_pagein },	<span class="enscript-comment">/* pagein */</span>
	{ &amp;vnop_pageout_desc, (VOPFUNC)err_pageout },	<span class="enscript-comment">/* pageout */</span>
        { &amp;vnop_copyfile_desc, (VOPFUNC)err_copyfile },	<span class="enscript-comment">/* Copyfile */</span>
	{ &amp;vnop_blktooff_desc, (VOPFUNC)fdesc_blktooff },	<span class="enscript-comment">/* blktooff */</span>
	{ &amp;vnop_blktooff_desc, (VOPFUNC)fdesc_offtoblk },	<span class="enscript-comment">/* offtoblk */</span>
	{ &amp;vnop_blockmap_desc, (VOPFUNC)fdesc_blockmap },	<span class="enscript-comment">/* blockmap */</span>
	{ (<span class="enscript-type">struct</span> vnodeop_desc*)NULL, (VOPFUNC)NULL }
};

<span class="enscript-type">struct</span> vnodeopv_desc devfs_fdesc_vnodeop_opv_desc =
	{ &amp;fdesc_vnodeop_p, devfs_fdesc_vnodeop_entries };

</pre>
<hr />
</body></html>