<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>devfs_tree.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">devfs_tree.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * Copyright 1997,1998 Julian Elischer.  All rights reserved.
 * <a href="mailto:julian@freebsd.org">julian@freebsd.org</a>
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * devfs_tree.c
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

<span class="enscript-comment">/*
 * HISTORY
 *  Dieter Siegmund (<a href="mailto:dieter@apple.com">dieter@apple.com</a>) Thu Apr  8 14:08:19 PDT 1999
 *  - removed mounting of &quot;hidden&quot; mountpoint
 *  - fixed problem in which devnode-&gt;dn_vn pointer was not
 *    updated with the vnode returned from checkalias()
 *  - replaced devfs_vntodn() with a macro VTODN()
 *  - rewrote dev_finddir() to not use recursion
 *  - added locking to avoid data structure corruption (DEVFS_(UN)LOCK())
 *  Dieter Siegmund (<a href="mailto:dieter@apple.com">dieter@apple.com</a>) Wed Jul 14 13:37:59 PDT 1999
 *  - fixed problem with devfs_dntovn() checking the v_id against the
 *    value cached in the device node; a union mount on top of us causes
 *    the v_id to get incremented thus, we would end up returning a new
 *    vnode instead of the existing one that has the mounted_here
 *    field filled in; the net effect was that the filesystem mounted
 *    on top of us would never show up
 *  - added devfs_stats to store how many data structures are actually 
 *    allocated
 */</span>

<span class="enscript-comment">/* SPLIT_DEVS means each devfs uses a different devnode for the same device */</span>
<span class="enscript-comment">/* Otherwise the same device always ends up at the same vnode even if  */</span>
<span class="enscript-comment">/* reached througgh a different devfs instance. The practical difference */</span>
<span class="enscript-comment">/* is that with the same vnode, chmods and chowns show up on all instances of */</span>
<span class="enscript-comment">/* a device. (etc) */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SPLIT_DEVS</span> 1 <span class="enscript-comment">/* maybe make this an option */</span>
<span class="enscript-comment">/*#define SPLIT_DEVS 1*/</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BSD_KERNEL_PRIVATE</span>	1	<span class="enscript-comment">/* devfs_make_link() prototype */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;devfs.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;devfsdefs.h&quot;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FDESC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;fdesc.h&quot;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> devfs_vnode_event {
	vnode_t 		dve_vp;
	uint32_t 		dve_vid;
	uint32_t		dve_events;
} *devfs_vnode_event_t;

<span class="enscript-comment">/* 
 * Size of stack buffer (fast path) for notifications.  If 
 * the number of mounts is small, no need to malloc a buffer.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NUM_STACK_ENTRIES</span> 5 

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> devfs_event_log {
	size_t 			del_max;
	size_t 			del_used;
	devfs_vnode_event_t 	del_entries;
} *devfs_event_log_t;
	

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	dev_free_hier(devdirent_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	devfs_propogate(devdirent_t *, devdirent_t *, devfs_event_log_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	dev_finddir(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, devnode_t *, <span class="enscript-type">int</span>, devnode_t **, devfs_event_log_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	dev_dup_entry(devnode_t *, devdirent_t *, devdirent_t **, <span class="enscript-type">struct</span> devfsmount *);
<span class="enscript-type">void</span>		devfs_ref_node(devnode_t *);
<span class="enscript-type">void</span> 		devfs_rele_node(devnode_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	devfs_record_event(devfs_event_log_t, devnode_t*, uint32_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 	devfs_init_event_log(devfs_event_log_t, uint32_t, devfs_vnode_event_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	devfs_release_event_log(devfs_event_log_t, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	devfs_bulk_notify(devfs_event_log_t);
<span class="enscript-type">static</span> devdirent_t *<span class="enscript-function-name">devfs_make_node_internal</span>(dev_t, devfstype_t type, uid_t, gid_t, <span class="enscript-type">int</span>, 
			<span class="enscript-type">int</span> (*clone)(dev_t dev, <span class="enscript-type">int</span> action), <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, va_list ap);


lck_grp_t	* devfs_lck_grp;
lck_grp_attr_t	* devfs_lck_grp_attr;
lck_attr_t	* devfs_lck_attr;
lck_mtx_t  	  devfs_mutex;
lck_mtx_t  	  devfs_attr_mutex;

devdirent_t *		dev_root = NULL; 	<span class="enscript-comment">/* root of backing tree */</span>
<span class="enscript-type">struct</span> devfs_stats	devfs_stats;		<span class="enscript-comment">/* hold stats */</span>

<span class="enscript-type">static</span> ino_t		devfs_unique_fileno = 0;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HIDDEN_MOUNTPOINT</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mount *devfs_hidden_mount;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HIDDEN_MOINTPOINT */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> devfs_ready = 0;
<span class="enscript-type">static</span> uint32_t devfs_nmountplanes = 0; <span class="enscript-comment">/* The first plane is not used for a mount */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEVFS_NOCREATE</span>	FALSE
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEVFS_CREATE</span>	TRUE

<span class="enscript-comment">/*
 * Set up the root directory node in the backing plane
 * This is happenning before the vfs system has been
 * set up yet, so be careful about what we reference..
 * Notice that the ops are by indirection.. as they haven't
 * been set up yet!
 * DEVFS has a hidden mountpoint that is used as the anchor point
 * for the internal 'blueprint' version of the dev filesystem tree.
 */</span>
<span class="enscript-comment">/*proto*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">devfs_sinit</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span> error;

    devfs_lck_grp_attr = lck_grp_attr_alloc_init();
	devfs_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;devfs_lock&quot;</span>, devfs_lck_grp_attr);

	devfs_lck_attr = lck_attr_alloc_init();

	lck_mtx_init(&amp;devfs_mutex, devfs_lck_grp, devfs_lck_attr);
	lck_mtx_init(&amp;devfs_attr_mutex, devfs_lck_grp, devfs_lck_attr);

	DEVFS_LOCK();
        error = dev_add_entry(<span class="enscript-string">&quot;root&quot;</span>, NULL, DEV_DIR, NULL, NULL, NULL, &amp;dev_root);
	DEVFS_UNLOCK();

	<span class="enscript-keyword">if</span> (error) {
	    printf(<span class="enscript-string">&quot;devfs_sinit: dev_add_entry failed &quot;</span>);
	    <span class="enscript-keyword">return</span> (ENOTSUP);
	}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">HIDDEN_MOUNTPOINT</span>
	MALLOC(devfs_hidden_mount, <span class="enscript-type">struct</span> mount *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mount),
	       M_MOUNT, M_WAITOK);
	bzero(devfs_hidden_mount,<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mount));
	mount_lock_init(devfs_hidden_mount);
	TAILQ_INIT(&amp;devfs_hidden_mount-&gt;mnt_vnodelist);
	TAILQ_INIT(&amp;devfs_hidden_mount-&gt;mnt_workerqueue);
	TAILQ_INIT(&amp;devfs_hidden_mount-&gt;mnt_newvnodes);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_mount_label_init(devfs_hidden_mount);
	mac_mount_label_associate(vfs_context_kernel(), devfs_hidden_mount);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Initialize the default IO constraints */</span>
	mp-&gt;mnt_maxreadcnt = mp-&gt;mnt_maxwritecnt = MAXPHYS;
	mp-&gt;mnt_segreadcnt = mp-&gt;mnt_segwritecnt = 32;
	mp-&gt;mnt_ioflags = 0;
	mp-&gt;mnt_realrootvp = NULLVP;
	mp-&gt;mnt_authcache_ttl = CACHED_LOOKUP_RIGHT_TTL;

	devfs_mount(devfs_hidden_mount,<span class="enscript-string">&quot;dummy&quot;</span>,NULL,NULL,NULL);
	dev_root-&gt;de_dnp-&gt;dn_dvm 
	    = (<span class="enscript-type">struct</span> devfsmount *)devfs_hidden_mount-&gt;mnt_data;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HIDDEN_MOUNTPOINT */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_devfs_label_associate_directory(<span class="enscript-string">&quot;/&quot;</span>, strlen(<span class="enscript-string">&quot;/&quot;</span>),
	    dev_root-&gt;de_dnp, <span class="enscript-string">&quot;/&quot;</span>);
#<span class="enscript-reference">endif</span>
	devfs_ready = 1;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/***********************************************************************\
*************************************************************************
*	Routines used to find our way to a point in the tree		*
*************************************************************************
\***********************************************************************/</span>



<span class="enscript-comment">/***************************************************************
 * Search down the linked list off a dir to find &quot;name&quot;		
 * return the devnode_t * for that node.
 *
 * called with DEVFS_LOCK held
 ***************************************************************/</span>
devdirent_t *
<span class="enscript-function-name">dev_findname</span>(devnode_t * dir, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name)
{
	devdirent_t * newfp;
	<span class="enscript-keyword">if</span> (dir-&gt;dn_type != DEV_DIR) <span class="enscript-keyword">return</span> 0;<span class="enscript-comment">/*XXX*/</span> <span class="enscript-comment">/* printf?*/</span>

	<span class="enscript-keyword">if</span> (name[0] == <span class="enscript-string">'.'</span>)
	{
		<span class="enscript-keyword">if</span>(name[1] == 0)
		{
			<span class="enscript-keyword">return</span> dir-&gt;dn_typeinfo.Dir.myname;
		}
		<span class="enscript-keyword">if</span>((name[1] == <span class="enscript-string">'.'</span>) &amp;&amp; (name[2] == 0))
		{
			<span class="enscript-comment">/* for root, .. == . */</span>
			<span class="enscript-keyword">return</span> dir-&gt;dn_typeinfo.Dir.parent-&gt;dn_typeinfo.Dir.myname;
		}
	}
	newfp = dir-&gt;dn_typeinfo.Dir.dirlist;

	<span class="enscript-keyword">while</span>(newfp)
	{
		<span class="enscript-keyword">if</span>(!(strncmp(name, newfp-&gt;de_name, <span class="enscript-keyword">sizeof</span>(newfp-&gt;de_name))))
			<span class="enscript-keyword">return</span> newfp;
		newfp = newfp-&gt;de_next;
	}
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/***********************************************************************
 * Given a starting node (0 for root) and a pathname, return the node	
 * for the end item on the path. It MUST BE A DIRECTORY. If the 'DEVFS_CREATE'
 * option is true, then create any missing nodes in the path and create
 * and return the final node as well.					
 * This is used to set up a directory, before making nodes in it..
 *
 * called with DEVFS_LOCK held
 ***********************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dev_finddir</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * path, 
	    devnode_t * dirnode,
	    <span class="enscript-type">int</span> create, 
	    devnode_t * * dn_pp,
	    devfs_event_log_t delp)
{
	devnode_t *	dnp = NULL;
	<span class="enscript-type">int</span>		error = 0;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *		scan;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-type">char</span>            fullpath[DEVMAXPATHSIZE];
#<span class="enscript-reference">endif</span>


	<span class="enscript-keyword">if</span> (!dirnode) <span class="enscript-comment">/* dirnode == NULL means start at root */</span>
	    dirnode = dev_root-&gt;de_dnp;

	<span class="enscript-keyword">if</span> (dirnode-&gt;dn_type != DEV_DIR) 
	    <span class="enscript-keyword">return</span> ENOTDIR;

	<span class="enscript-keyword">if</span> (strlen(path) &gt; (DEVMAXPATHSIZE - 1)) 
	    <span class="enscript-keyword">return</span> ENAMETOOLONG;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	strlcpy (fullpath, path, DEVMAXPATHSIZE);
#<span class="enscript-reference">endif</span>
	scan = path;

	<span class="enscript-keyword">while</span> (*scan == <span class="enscript-string">'/'</span>) 
	    scan++;

	*dn_pp = NULL;

	<span class="enscript-keyword">while</span> (1) {
	    <span class="enscript-type">char</span>		component[DEVMAXPATHSIZE];
	    devdirent_t *	dirent_p;
	    <span class="enscript-type">const</span> <span class="enscript-type">char</span> * 	start;

	    <span class="enscript-keyword">if</span> (*scan == 0) { 
		<span class="enscript-comment">/* we hit the end of the string, we're done */</span>
		*dn_pp = dirnode;
		<span class="enscript-keyword">break</span>;
	    }
	    start = scan;
	    <span class="enscript-keyword">while</span> (*scan != <span class="enscript-string">'/'</span> &amp;&amp; *scan)
		scan++;

	    strlcpy(component, start, scan - start);
	    <span class="enscript-keyword">if</span> (*scan == <span class="enscript-string">'/'</span>)
		scan++;

	    dirent_p = dev_findname(dirnode, component);
	    <span class="enscript-keyword">if</span> (dirent_p) {
		dnp = dirent_p-&gt;de_dnp;
		<span class="enscript-keyword">if</span> (dnp-&gt;dn_type != DEV_DIR) {
		    error = ENOTDIR;
		    <span class="enscript-keyword">break</span>;
		}
	    }
	    <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (!create) {
		    error = ENOENT;
		    <span class="enscript-keyword">break</span>;
		}
		error = dev_add_entry(component, dirnode, 
				       DEV_DIR, NULL, NULL, NULL, &amp;dirent_p);
		<span class="enscript-keyword">if</span> (error)
		    <span class="enscript-keyword">break</span>;
		dnp = dirent_p-&gt;de_dnp;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_devfs_label_associate_directory(
		    dirnode-&gt;dn_typeinfo.Dir.myname-&gt;de_name, 
		    strlen(dirnode-&gt;dn_typeinfo.Dir.myname-&gt;de_name),
		    dnp, fullpath);
#<span class="enscript-reference">endif</span>
		devfs_propogate(dirnode-&gt;dn_typeinfo.Dir.myname, dirent_p, delp);
	    }
	    dirnode = dnp; <span class="enscript-comment">/* continue relative to this directory */</span>
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/***********************************************************************
 * Add a new NAME element to the devfs
 * If we're creating a root node, then dirname is NULL
 * Basically this creates a new namespace entry for the device node
 *
 * Creates a name node, and links it to the supplied node
 *
 * called with DEVFS_LOCK held
 ***********************************************************************/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dev_add_name</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * name, devnode_t * dirnode, __unused devdirent_t * back, 
    devnode_t * dnp, devdirent_t * *dirent_pp)
{
	devdirent_t * 	dirent_p = NULL;

	<span class="enscript-keyword">if</span>(dirnode != NULL ) {
		<span class="enscript-keyword">if</span>(dirnode-&gt;dn_type != DEV_DIR) <span class="enscript-keyword">return</span>(ENOTDIR);
	
		<span class="enscript-keyword">if</span>( dev_findname(dirnode,name))
			<span class="enscript-keyword">return</span>(EEXIST);
	}
	<span class="enscript-comment">/*
	 * make sure the name is legal
	 * slightly misleading in the case of NULL
	 */</span>
	<span class="enscript-keyword">if</span> (!name || (strlen(name) &gt; (DEVMAXNAMESIZE - 1)))
	    <span class="enscript-keyword">return</span> (ENAMETOOLONG);

	<span class="enscript-comment">/*
	 * Allocate and fill out a new directory entry 
	 */</span>
	MALLOC(dirent_p, devdirent_t *, <span class="enscript-keyword">sizeof</span>(devdirent_t), 
	       M_DEVFSNAME, M_WAITOK);
	<span class="enscript-keyword">if</span> (!dirent_p) {
	    <span class="enscript-keyword">return</span> ENOMEM;
	}
	bzero(dirent_p,<span class="enscript-keyword">sizeof</span>(devdirent_t));

	<span class="enscript-comment">/* inherrit our parent's mount info */</span> <span class="enscript-comment">/*XXX*/</span>
	<span class="enscript-comment">/* a kludge but.... */</span>
	<span class="enscript-keyword">if</span>(dirnode &amp;&amp; ( dnp-&gt;dn_dvm == NULL)) {
		dnp-&gt;dn_dvm = dirnode-&gt;dn_dvm;
		<span class="enscript-comment">/* if(!dnp-&gt;dn_dvm) printf(&quot;parent had null dvm &quot;); */</span>
	}

	<span class="enscript-comment">/*
	 * Link the two together
	 * include the implicit link in the count of links to the devnode..
	 * this stops it from being accidentally freed later.
	 */</span>
	dirent_p-&gt;de_dnp = dnp;
	dnp-&gt;dn_links++ ; <span class="enscript-comment">/* implicit from our own name-node */</span>

	<span class="enscript-comment">/* 
	 * Make sure that we can find all the links that reference a node
	 * so that we can get them all if we need to zap the node.
	 */</span>
	<span class="enscript-keyword">if</span>(dnp-&gt;dn_linklist) {
		dirent_p-&gt;de_nextlink = dnp-&gt;dn_linklist;
		dirent_p-&gt;de_prevlinkp = dirent_p-&gt;de_nextlink-&gt;de_prevlinkp;
		dirent_p-&gt;de_nextlink-&gt;de_prevlinkp = &amp;(dirent_p-&gt;de_nextlink);
		*dirent_p-&gt;de_prevlinkp = dirent_p;
	} <span class="enscript-keyword">else</span> {
		dirent_p-&gt;de_nextlink = dirent_p;
		dirent_p-&gt;de_prevlinkp = &amp;(dirent_p-&gt;de_nextlink);
	}
	dnp-&gt;dn_linklist = dirent_p;

	<span class="enscript-comment">/*
	 * If the node is a directory, then we need to handle the 
	 * creation of the .. link.
	 * A NULL dirnode indicates a root node, so point to ourself.
	 */</span>
	<span class="enscript-keyword">if</span>(dnp-&gt;dn_type == DEV_DIR) {
		dnp-&gt;dn_typeinfo.Dir.myname = dirent_p;
		<span class="enscript-comment">/*
		 * If we are unlinking from an old dir, decrement its links
		 * as we point our '..' elsewhere
		 * Note: it's up to the calling code to remove the 
		 * us from the original directory's list
		 */</span>
		<span class="enscript-keyword">if</span>(dnp-&gt;dn_typeinfo.Dir.parent) {
			dnp-&gt;dn_typeinfo.Dir.parent-&gt;dn_links--;
		}
	 	<span class="enscript-keyword">if</span>(dirnode) {
			dnp-&gt;dn_typeinfo.Dir.parent = dirnode;
		} <span class="enscript-keyword">else</span> {
			dnp-&gt;dn_typeinfo.Dir.parent = dnp;
		}
		dnp-&gt;dn_typeinfo.Dir.parent-&gt;dn_links++; <span class="enscript-comment">/* account for the new '..' */</span>
	}

	<span class="enscript-comment">/*
	 * put the name into the directory entry.
	 */</span>
	strlcpy(dirent_p-&gt;de_name, name, DEVMAXNAMESIZE);


	<span class="enscript-comment">/*
	 * Check if we are not making a root node..
	 * (i.e. have parent)
	 */</span>
	<span class="enscript-keyword">if</span>(dirnode) {
		<span class="enscript-comment">/*
	 	 * Put it on the END of the linked list of directory entries
	 	 */</span>
		dirent_p-&gt;de_parent = dirnode; <span class="enscript-comment">/* null for root */</span>
		dirent_p-&gt;de_prevp = dirnode-&gt;dn_typeinfo.Dir.dirlast;
		dirent_p-&gt;de_next = *(dirent_p-&gt;de_prevp); <span class="enscript-comment">/* should be NULL */</span> 
							<span class="enscript-comment">/*right?*/</span>
		*(dirent_p-&gt;de_prevp) = dirent_p;
		dirnode-&gt;dn_typeinfo.Dir.dirlast = &amp;(dirent_p-&gt;de_next);
		dirnode-&gt;dn_typeinfo.Dir.entrycount++;
		dirnode-&gt;dn_len += strlen(name) + 8;<span class="enscript-comment">/*ok, ok?*/</span>
	}

	*dirent_pp = dirent_p;
	DEVFS_INCR_ENTRIES();
	<span class="enscript-keyword">return</span> 0 ;
}


<span class="enscript-comment">/***********************************************************************
 * Add a new element to the devfs plane.
 *
 * Creates a new dev_node to go with it if the prototype should not be
 * reused. (Is a DIR, or we select SPLIT_DEVS at compile time)
 * typeinfo gives us info to make our node if we don't have a prototype.
 * If typeinfo is null and proto exists, then the typeinfo field of
 * the proto is used intead in the DEVFS_CREATE case.
 * note the 'links' count is 0 (except if a dir)
 * but it is only cleared on a transition
 * so this is ok till we link it to something
 * Even in SPLIT_DEVS mode,
 * if the node already exists on the wanted plane, just return it
 *
 * called with DEVFS_LOCK held
***********************************************************************/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dev_add_node</span>(<span class="enscript-type">int</span> entrytype, devnode_type_t * typeinfo, devnode_t * proto,
	     devnode_t * *dn_pp, <span class="enscript-type">struct</span> devfsmount *dvm)
{
	devnode_t *	dnp = NULL;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> <span class="enscript-variable-name">SPLIT_DEVS</span>
	<span class="enscript-comment">/*
	 * If we have a prototype, then check if there is already a sibling
	 * on the mount plane we are looking at, if so, just return it.
	 */</span>
	<span class="enscript-keyword">if</span> (proto) {
		dnp = proto-&gt;dn_nextsibling;
		<span class="enscript-keyword">while</span>( dnp != proto) {
			<span class="enscript-keyword">if</span> (dnp-&gt;dn_dvm == dvm) {
				*dn_pp = dnp;
				<span class="enscript-keyword">return</span> (0);
			}
			dnp = dnp-&gt;dn_nextsibling;
		}
		<span class="enscript-keyword">if</span> (typeinfo == NULL)
			typeinfo = &amp;(proto-&gt;dn_typeinfo);
	}
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* SPLIT_DEVS */</span>
	<span class="enscript-keyword">if</span> ( proto ) {
		<span class="enscript-keyword">switch</span> (proto-&gt;type) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DEV_BDEV</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DEV_CDEV</span>:
				*dn_pp = proto;
				<span class="enscript-keyword">return</span> 0;
		}
	}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* SPLIT_DEVS */</span>
	MALLOC(dnp, devnode_t *, <span class="enscript-keyword">sizeof</span>(devnode_t), M_DEVFSNODE, M_WAITOK);
	<span class="enscript-keyword">if</span> (!dnp) {
	    <span class="enscript-keyword">return</span> ENOMEM;
	}

	<span class="enscript-comment">/*
	 * If we have a proto, that means that we are duplicating some
	 * other device, which can only happen if we are not at the back plane
	 */</span>
	<span class="enscript-keyword">if</span> (proto) {
		bcopy(proto, dnp, <span class="enscript-keyword">sizeof</span>(devnode_t));
		dnp-&gt;dn_links = 0;
		dnp-&gt;dn_linklist = NULL;
		dnp-&gt;dn_vn = NULL;
		dnp-&gt;dn_len = 0;
		<span class="enscript-comment">/* add to END of siblings list */</span>
		dnp-&gt;dn_prevsiblingp = proto-&gt;dn_prevsiblingp;
		*(dnp-&gt;dn_prevsiblingp) = dnp;
		dnp-&gt;dn_nextsibling = proto;
		proto-&gt;dn_prevsiblingp = &amp;(dnp-&gt;dn_nextsibling);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_devfs_label_init(dnp);
		mac_devfs_label_copy(proto-&gt;dn_label, dnp-&gt;dn_label);
#<span class="enscript-reference">endif</span>
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-type">struct</span> timeval tv;

		<span class="enscript-comment">/* 
		 * We have no prototype, so start off with a clean slate
		 */</span>
		microtime(&amp;tv);
		bzero(dnp, <span class="enscript-keyword">sizeof</span>(devnode_t));
		dnp-&gt;dn_type = entrytype;
		dnp-&gt;dn_nextsibling = dnp;
		dnp-&gt;dn_prevsiblingp = &amp;(dnp-&gt;dn_nextsibling);
		dnp-&gt;dn_atime.tv_sec = tv.tv_sec;
		dnp-&gt;dn_mtime.tv_sec = tv.tv_sec;
		dnp-&gt;dn_ctime.tv_sec = tv.tv_sec;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_devfs_label_init(dnp);
#<span class="enscript-reference">endif</span>
	}
	dnp-&gt;dn_dvm = dvm;
	dnp-&gt;dn_refcount = 0;
	dnp-&gt;dn_ino = devfs_unique_fileno;
	devfs_unique_fileno++;

	<span class="enscript-comment">/*
	 * fill out the dev node according to type
	 */</span>
	<span class="enscript-keyword">switch</span>(entrytype) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DEV_DIR</span>:
		<span class="enscript-comment">/*
		 * As it's a directory, make sure
		 * it has a null entries list
		 */</span>
		dnp-&gt;dn_typeinfo.Dir.dirlast = &amp;(dnp-&gt;dn_typeinfo.Dir.dirlist);
		dnp-&gt;dn_typeinfo.Dir.dirlist = (devdirent_t *)0;
		dnp-&gt;dn_typeinfo.Dir.entrycount = 0;
		<span class="enscript-comment">/*  until we know better, it has a null parent pointer*/</span>
		dnp-&gt;dn_typeinfo.Dir.parent = NULL;
		dnp-&gt;dn_links++; <span class="enscript-comment">/* for .*/</span>
		dnp-&gt;dn_typeinfo.Dir.myname = NULL;
		<span class="enscript-comment">/*
		 * make sure that the ops associated with it are the ops
		 * that we use (by default) for directories
		 */</span>
		dnp-&gt;dn_ops = &amp;devfs_vnodeop_p;
		dnp-&gt;dn_mode |= 0555;	<span class="enscript-comment">/* default perms */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DEV_SLNK</span>:
		<span class="enscript-comment">/*
		 * As it's a symlink allocate and store the link info
		 * Symlinks should only ever be created by the user,
		 * so they are not on the back plane and should not be 
		 * propogated forward.. a bit like directories in that way..
		 * A symlink only exists on one plane and has its own
		 * node.. therefore we might be on any random plane.
		 */</span>
	    	MALLOC(dnp-&gt;dn_typeinfo.Slnk.name, <span class="enscript-type">char</span> *, 
		       typeinfo-&gt;Slnk.namelen+1,
		       M_DEVFSNODE, M_WAITOK);
		<span class="enscript-keyword">if</span> (!dnp-&gt;dn_typeinfo.Slnk.name) {
		    	FREE(dnp,M_DEVFSNODE);
			<span class="enscript-keyword">return</span> ENOMEM;
		}
		strlcpy(dnp-&gt;dn_typeinfo.Slnk.name, typeinfo-&gt;Slnk.name,
			typeinfo-&gt;Slnk.namelen + 1);
		dnp-&gt;dn_typeinfo.Slnk.namelen = typeinfo-&gt;Slnk.namelen;
		DEVFS_INCR_STRINGSPACE(dnp-&gt;dn_typeinfo.Slnk.namelen + 1);
		dnp-&gt;dn_ops = &amp;devfs_vnodeop_p;
		dnp-&gt;dn_mode |= 0555;	<span class="enscript-comment">/* default perms */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DEV_CDEV</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DEV_BDEV</span>:
		<span class="enscript-comment">/*
		 * Make sure it has DEVICE type ops
		 * and device specific fields are correct
		 */</span>
		dnp-&gt;dn_ops = &amp;devfs_spec_vnodeop_p;
		dnp-&gt;dn_typeinfo.dev = typeinfo-&gt;dev;
		<span class="enscript-keyword">break</span>;

	#<span class="enscript-keyword">if</span> FDESC
	<span class="enscript-comment">/* /dev/fd is special */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">DEV_DEVFD</span>:
		dnp-&gt;dn_ops = &amp;devfs_devfd_vnodeop_p;
		dnp-&gt;dn_mode |= 0555;	<span class="enscript-comment">/* default perms */</span>
		<span class="enscript-keyword">break</span>;

	#endif <span class="enscript-comment">/* FDESC */</span>
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> EINVAL;
	}

	*dn_pp = dnp;
	DEVFS_INCR_NODES();
	<span class="enscript-keyword">return</span> 0 ;
}


<span class="enscript-comment">/***********************************************************************
 * called with DEVFS_LOCK held
 **********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">devnode_free</span>(devnode_t * dnp)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_devfs_label_destroy(dnp);
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">if</span> (dnp-&gt;dn_type == DEV_SLNK) {
        DEVFS_DECR_STRINGSPACE(dnp-&gt;dn_typeinfo.Slnk.namelen + 1);
	FREE(dnp-&gt;dn_typeinfo.Slnk.name, M_DEVFSNODE);
    }
    DEVFS_DECR_NODES();
    FREE(dnp, M_DEVFSNODE);
}


<span class="enscript-comment">/***********************************************************************
 * called with DEVFS_LOCK held
 **********************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">devfs_dn_free</span>(devnode_t * dnp)
{
	<span class="enscript-keyword">if</span>(--dnp-&gt;dn_links &lt;= 0 ) <span class="enscript-comment">/* can be -1 for initial free, on error */</span>
	{
		<span class="enscript-comment">/*probably need to do other cleanups XXX */</span>
		<span class="enscript-keyword">if</span> (dnp-&gt;dn_nextsibling != dnp) {
			devnode_t * * 	prevp = dnp-&gt;dn_prevsiblingp;
			*prevp = dnp-&gt;dn_nextsibling;
			dnp-&gt;dn_nextsibling-&gt;dn_prevsiblingp = prevp;
			
		}

		<span class="enscript-comment">/* Can only free if there are no references; otherwise, wait for last vnode to be reclaimed */</span>
		<span class="enscript-keyword">if</span> (dnp-&gt;dn_refcount == 0) {
		    devnode_free(dnp); 
		}
		<span class="enscript-keyword">else</span> {
		    dnp-&gt;dn_lflags |= DN_DELETE;
		}
	}
}

<span class="enscript-comment">/***********************************************************************\
*	Front Node Operations						* 
*	Add or delete a chain of front nodes				*
\***********************************************************************/</span>


<span class="enscript-comment">/***********************************************************************
 * Given a directory backing node, and a child backing node, add the
 * appropriate front nodes to the front nodes of the directory to
 * represent the child node to the user
 *
 * on failure, front nodes will either be correct or not exist for each
 * front dir, however dirs completed will not be stripped of completed
 * frontnodes on failure of a later frontnode
 *
 * This allows a new node to be propogated through all mounted planes
 *
 * called with DEVFS_LOCK held
 ***********************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">devfs_propogate</span>(devdirent_t * parent,devdirent_t * child, devfs_event_log_t delp)
{
	<span class="enscript-type">int</span>	error;
	devdirent_t * newnmp;
	devnode_t *	dnp = child-&gt;de_dnp;
	devnode_t *	pdnp = parent-&gt;de_dnp;
	devnode_t *	adnp = parent-&gt;de_dnp;
	<span class="enscript-type">int</span> type = child-&gt;de_dnp-&gt;dn_type;
	uint32_t events;
	
	events = (dnp-&gt;dn_type == DEV_DIR ? VNODE_EVENT_DIR_CREATED : VNODE_EVENT_FILE_CREATED);
	<span class="enscript-keyword">if</span> (delp != NULL) {
		devfs_record_event(delp, pdnp, events);
	}

	<span class="enscript-comment">/***********************************************
	 * Find the other instances of the parent node
	 ***********************************************/</span>
	<span class="enscript-keyword">for</span> (adnp = pdnp-&gt;dn_nextsibling;
		adnp != pdnp;
		adnp = adnp-&gt;dn_nextsibling)
	{
		<span class="enscript-comment">/*
		 * Make the node, using the original as a prototype)
		 * if the node already exists on that plane it won't be
		 * re-made..
		 */</span>
		<span class="enscript-keyword">if</span> ((error = dev_add_entry(child-&gt;de_name, adnp, type,
					   NULL, dnp, adnp-&gt;dn_dvm, 
					   &amp;newnmp)) != 0) {
			printf(<span class="enscript-string">&quot;duplicating %s failed\n&quot;</span>,child-&gt;de_name);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (delp != NULL) {
				devfs_record_event(delp, adnp, events);

				<span class="enscript-comment">/* 
				 * Slightly subtle.  We're guaranteed that there will
				 * only be a vnode hooked into this devnode if we're creating
				 * a new link to an existing node; otherwise, the devnode is new
				 * and no one can have looked it up yet. If we're making a link,
				 * then the buffer is large enough for two nodes in each 
				 * plane; otherwise, there's no vnode and this call will
				 * do nothing.
				 */</span>
				devfs_record_event(delp, newnmp-&gt;de_dnp, VNODE_EVENT_LINK);
			}
		}
	}
	<span class="enscript-keyword">return</span> 0;	<span class="enscript-comment">/* for now always succeed */</span>
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">remove_notify_count</span>(devnode_t *dnp)
{
	uint32_t notify_count = 0;
	devnode_t *dnp2;

	<span class="enscript-comment">/* 
	 * Could need to notify for one removed node on each mount and 
	 * one parent for each such node.
	 */</span>
	notify_count = devfs_nmountplanes;
	notify_count += dnp-&gt;dn_links;	
	<span class="enscript-keyword">for</span> (dnp2 = dnp-&gt;dn_nextsibling; dnp2 != dnp; dnp2 = dnp2-&gt;dn_nextsibling) {
		notify_count += dnp2-&gt;dn_links;	
	}

	<span class="enscript-keyword">return</span> notify_count;

}

<span class="enscript-comment">/***********************************************************************
 * remove all instances of this devicename [for backing nodes..]
 * note.. if there is another link to the node (non dir nodes only)
 * then the devfs_node will still exist as the ref count will be non-0
 * removing a directory node will remove all sup-nodes on all planes (ZAP)
 *
 * Used by device drivers to remove nodes that are no longer relevant
 * The argument is the 'cookie' they were given when they created the node
 * this function is exported.. see devfs.h
 ***********************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">devfs_remove</span>(<span class="enscript-type">void</span> *dirent_p)
{
	devnode_t * dnp = ((devdirent_t *)dirent_p)-&gt;de_dnp;
	devnode_t * dnp2;
	boolean_t   lastlink;
	<span class="enscript-type">struct</span> devfs_event_log event_log;
	uint32_t    log_count = 0;
	<span class="enscript-type">int</span>	    do_notify = 0;
	<span class="enscript-type">int</span>	    need_free = 0;
	<span class="enscript-type">struct</span> devfs_vnode_event stackbuf[NUM_STACK_ENTRIES];
	
	DEVFS_LOCK();

	<span class="enscript-keyword">if</span> (!devfs_ready) {
		printf(<span class="enscript-string">&quot;devfs_remove: not ready for devices!\n&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	log_count = remove_notify_count(dnp);

	<span class="enscript-keyword">if</span> (log_count &gt; NUM_STACK_ENTRIES) {
		uint32_t new_count;
<span class="enscript-reference">wrongsize</span>:
		DEVFS_UNLOCK();
		<span class="enscript-keyword">if</span> (devfs_init_event_log(&amp;event_log, log_count, NULL) == 0) {
			do_notify = 1;
			need_free = 1;
		} 	
		DEVFS_LOCK();

		new_count = remove_notify_count(dnp);
		<span class="enscript-keyword">if</span> (need_free &amp;&amp; (new_count &gt; log_count)) {
			devfs_release_event_log(&amp;event_log, 1);
			need_free = 0;
			do_notify = 0;
			log_count = log_count * 2;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">wrongsize</span>;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (devfs_init_event_log(&amp;event_log, NUM_STACK_ENTRIES, &amp;stackbuf[0]) == 0) {
			do_notify = 1;
		}
	}

	<span class="enscript-comment">/* This file has been deleted */</span>
	<span class="enscript-keyword">if</span> (do_notify != 0) {
		devfs_record_event(&amp;event_log, dnp, VNODE_EVENT_DELETE);
	}

	<span class="enscript-comment">/* keep removing the next sibling till only we exist. */</span>
	<span class="enscript-keyword">while</span> ((dnp2 = dnp-&gt;dn_nextsibling) != dnp) {

		<span class="enscript-comment">/*
		 * Keep removing the next front node till no more exist
		 */</span>
		dnp-&gt;dn_nextsibling = dnp2-&gt;dn_nextsibling; 
		dnp-&gt;dn_nextsibling-&gt;dn_prevsiblingp = &amp;(dnp-&gt;dn_nextsibling);
		dnp2-&gt;dn_nextsibling = dnp2;
		dnp2-&gt;dn_prevsiblingp = &amp;(dnp2-&gt;dn_nextsibling);
				
		<span class="enscript-comment">/* This file has been deleted in this plane */</span>
		<span class="enscript-keyword">if</span> (do_notify != 0) {
			devfs_record_event(&amp;event_log, dnp2, VNODE_EVENT_DELETE);
		}

		<span class="enscript-keyword">if</span> (dnp2-&gt;dn_linklist) {
			<span class="enscript-keyword">do</span> {
				lastlink = (1 == dnp2-&gt;dn_links);
				<span class="enscript-comment">/* Each parent of a link to this file has lost a child in this plane */</span>
				<span class="enscript-keyword">if</span> (do_notify != 0) {
					devfs_record_event(&amp;event_log, dnp2-&gt;dn_linklist-&gt;de_parent, VNODE_EVENT_FILE_REMOVED);
				}
				dev_free_name(dnp2-&gt;dn_linklist);
			} <span class="enscript-keyword">while</span> (!lastlink);
		}
	}

	<span class="enscript-comment">/*
	 * then free the main node
	 * If we are not running in SPLIT_DEVS mode, then
	 * THIS is what gets rid of the propogated nodes.
	 */</span>
	<span class="enscript-keyword">if</span> (dnp-&gt;dn_linklist) {
		<span class="enscript-keyword">do</span> {
			lastlink = (1 == dnp-&gt;dn_links);
			<span class="enscript-comment">/* Each parent of a link to this file has lost a child */</span>
			<span class="enscript-keyword">if</span> (do_notify != 0) {
				devfs_record_event(&amp;event_log, dnp-&gt;dn_linklist-&gt;de_parent, VNODE_EVENT_FILE_REMOVED);
			}
			dev_free_name(dnp-&gt;dn_linklist);
		} <span class="enscript-keyword">while</span> (!lastlink);
	}
<span class="enscript-reference">out</span>:
	DEVFS_UNLOCK();
	<span class="enscript-keyword">if</span> (do_notify != 0) {
		devfs_bulk_notify(&amp;event_log);
		devfs_release_event_log(&amp;event_log, need_free);
	}

	<span class="enscript-keyword">return</span> ;
}



<span class="enscript-comment">/***************************************************************
 * duplicate the backing tree into a tree of nodes hung off the
 * mount point given as the argument. Do this by
 * calling dev_dup_entry which recurses all the way
 * up the tree..
 *
 * called with DEVFS_LOCK held
 **************************************************************/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dev_dup_plane</span>(<span class="enscript-type">struct</span> devfsmount *devfs_mp_p)
{
	devdirent_t *	new;
	<span class="enscript-type">int</span>		error = 0;

	<span class="enscript-keyword">if</span> ((error = dev_dup_entry(NULL, dev_root, &amp;new, devfs_mp_p)))
	        <span class="enscript-keyword">return</span> error;
	devfs_mp_p-&gt;plane_root = new;
	devfs_nmountplanes++;
	<span class="enscript-keyword">return</span> error;
}



<span class="enscript-comment">/***************************************************************
 * Free a whole plane
 *
 * called with DEVFS_LOCK held
 ***************************************************************/</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">devfs_free_plane</span>(<span class="enscript-type">struct</span> devfsmount *devfs_mp_p)
{
	devdirent_t * dirent_p;

	dirent_p = devfs_mp_p-&gt;plane_root;
	<span class="enscript-keyword">if</span> (dirent_p) {
		dev_free_hier(dirent_p);
		dev_free_name(dirent_p);
	}
	devfs_mp_p-&gt;plane_root = NULL;
	devfs_nmountplanes--;

	<span class="enscript-keyword">if</span> (devfs_nmountplanes &gt; (devfs_nmountplanes+1)) {
		panic(<span class="enscript-string">&quot;plane count wrapped around.\n&quot;</span>);
	}
}


<span class="enscript-comment">/***************************************************************
 * Create and link in a new front element..
 * Parent can be 0 for a root node
 * Not presently usable to make a symlink XXX
 * (Ok, symlinks don't propogate)
 * recursively will create subnodes corresponding to equivalent
 * child nodes in the base level
 *
 * called with DEVFS_LOCK held
 ***************************************************************/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dev_dup_entry</span>(devnode_t * parent, devdirent_t * back, devdirent_t * *dnm_pp,
	      <span class="enscript-type">struct</span> devfsmount *dvm)
{
	devdirent_t *	entry_p;
	devdirent_t *	newback;
	devdirent_t *	newfront;
	<span class="enscript-type">int</span>	error;
	devnode_t *	dnp = back-&gt;de_dnp;
	<span class="enscript-type">int</span> type = dnp-&gt;dn_type;

	<span class="enscript-comment">/*
	 * go get the node made (if we need to)
	 * use the back one as a prototype
	 */</span>
	<span class="enscript-keyword">if</span> ((error = dev_add_entry(back-&gt;de_name, parent, type,
				NULL, dnp,
				parent?parent-&gt;dn_dvm:dvm, &amp;entry_p)) != 0) {
		printf(<span class="enscript-string">&quot;duplicating %s failed\n&quot;</span>,back-&gt;de_name);
	}

	<span class="enscript-comment">/*
	 * If we have just made the root, then insert the pointer to the
	 * mount information
	 */</span>
	<span class="enscript-keyword">if</span>(dvm) {
		entry_p-&gt;de_dnp-&gt;dn_dvm = dvm;
	}

	<span class="enscript-comment">/*
	 * If it is a directory, then recurse down all the other
	 * subnodes in it....
	 * note that this time we don't pass on the mount info..
	 */</span>
	<span class="enscript-keyword">if</span> (type == DEV_DIR)
	{
		<span class="enscript-keyword">for</span>(newback = back-&gt;de_dnp-&gt;dn_typeinfo.Dir.dirlist;
				newback; newback = newback-&gt;de_next)
		{
			<span class="enscript-keyword">if</span>((error = dev_dup_entry(entry_p-&gt;de_dnp,
					    newback, &amp;newfront, NULL)) != 0)
			{
				<span class="enscript-keyword">break</span>; <span class="enscript-comment">/* back out with an error */</span>
			}
		}
	}
	*dnm_pp = entry_p;
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/***************************************************************
 * Free a name node
 * remember that if there are other names pointing to the
 * dev_node then it may not get freed yet
 * can handle if there is no dnp
 *
 * called with DEVFS_LOCK held
 ***************************************************************/</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">dev_free_name</span>(devdirent_t * dirent_p)
{
	devnode_t *	parent = dirent_p-&gt;de_parent;
	devnode_t *	dnp = dirent_p-&gt;de_dnp;

	<span class="enscript-keyword">if</span>(dnp) {
		<span class="enscript-keyword">if</span>(dnp-&gt;dn_type == DEV_DIR)
		{
		    	devnode_t * p;

			<span class="enscript-keyword">if</span>(dnp-&gt;dn_typeinfo.Dir.dirlist)
				<span class="enscript-keyword">return</span> (ENOTEMPTY);
			p = dnp-&gt;dn_typeinfo.Dir.parent;
			devfs_dn_free(dnp); 	<span class="enscript-comment">/* account for '.' */</span>
			devfs_dn_free(p); 	<span class="enscript-comment">/* '..' */</span>
		}
		<span class="enscript-comment">/*
		 * unlink us from the list of links for this node
		 * If we are the only link, it's easy!
		 * if we are a DIR of course there should not be any
		 * other links.
	 	 */</span>
		<span class="enscript-keyword">if</span>(dirent_p-&gt;de_nextlink == dirent_p) {
				dnp-&gt;dn_linklist = NULL;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span>(dnp-&gt;dn_linklist == dirent_p) {
				dnp-&gt;dn_linklist = dirent_p-&gt;de_nextlink;
			}
		}
		devfs_dn_free(dnp);
	}
	
	dirent_p-&gt;de_nextlink-&gt;de_prevlinkp = dirent_p-&gt;de_prevlinkp;
	*(dirent_p-&gt;de_prevlinkp) = dirent_p-&gt;de_nextlink;

	<span class="enscript-comment">/*
	 * unlink ourselves from the directory on this plane
	 */</span>
	<span class="enscript-keyword">if</span>(parent) <span class="enscript-comment">/* if not fs root */</span>
	{
		<span class="enscript-keyword">if</span>( (*dirent_p-&gt;de_prevp = dirent_p-&gt;de_next) )<span class="enscript-comment">/* yes, assign */</span>
		{
			dirent_p-&gt;de_next-&gt;de_prevp = dirent_p-&gt;de_prevp;
		}
		<span class="enscript-keyword">else</span>
		{
			parent-&gt;dn_typeinfo.Dir.dirlast
				= dirent_p-&gt;de_prevp;
		}
		parent-&gt;dn_typeinfo.Dir.entrycount--;
		parent-&gt;dn_len -= strlen(dirent_p-&gt;de_name) + 8;
	}

	DEVFS_DECR_ENTRIES();
	FREE(dirent_p, M_DEVFSNAME);
	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/***************************************************************
 * Free a hierarchy starting at a directory node name
 * remember that if there are other names pointing to the
 * dev_node then it may not get freed yet
 * can handle if there is no dnp
 * leave the node itself allocated.
 *
 * called with DEVFS_LOCK held
 ***************************************************************/</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dev_free_hier</span>(devdirent_t * dirent_p)
{
	devnode_t *	dnp = dirent_p-&gt;de_dnp;

	<span class="enscript-keyword">if</span>(dnp) {
		<span class="enscript-keyword">if</span>(dnp-&gt;dn_type == DEV_DIR)
		{
			<span class="enscript-keyword">while</span>(dnp-&gt;dn_typeinfo.Dir.dirlist)
			{
				dev_free_hier(dnp-&gt;dn_typeinfo.Dir.dirlist);
				dev_free_name(dnp-&gt;dn_typeinfo.Dir.dirlist);
			}
		}
	}
}


<span class="enscript-comment">/***************************************************************
 * given a dev_node, find the appropriate vnode if one is already
 * associated, or get a new one and associate it with the dev_node
 *
 * called with DEVFS_LOCK held
 *
 * If an error is returned, then the dnp may have been freed (we
 * raced with a delete and lost).  A devnode should not be accessed
 * after devfs_dntovn() fails.
 ****************************************************************/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">devfs_dntovn</span>(devnode_t * dnp, <span class="enscript-type">struct</span> vnode **vn_pp, __unused <span class="enscript-type">struct</span> proc * p)
{
	<span class="enscript-type">struct</span> vnode *vn_p;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> vnode_fsparam vfsp;
	<span class="enscript-type">enum</span> vtype vtype = 0;
	<span class="enscript-type">int</span> markroot = 0;
	<span class="enscript-type">int</span> nretries = 0;
	<span class="enscript-type">int</span> n_minor = DEVFS_CLONE_ALLOC; <span class="enscript-comment">/* new minor number for clone device */</span>
	
	<span class="enscript-comment">/*
	 * We should never come in and find that our devnode has been marked for delete.
	 * The lookup should have held the lock from entry until now; it should not have
	 * been able to find a removed entry. Any other pathway would have just created
	 * the devnode and come here without dropping the devfs lock, so no one would
	 * have a chance to delete.
	 */</span>
	<span class="enscript-keyword">if</span> (dnp-&gt;dn_lflags &amp; DN_DELETE) {
		panic(<span class="enscript-string">&quot;devfs_dntovn: DN_DELETE set on a devnode upon entry.&quot;</span>);
	}

	devfs_ref_node(dnp);

<span class="enscript-reference">retry</span>:
	*vn_pp = NULL;
	vn_p = dnp-&gt;dn_vn;

	<span class="enscript-keyword">if</span> (vn_p) { <span class="enscript-comment">/* already has a vnode */</span>
	        uint32_t vid;
		
		vid = vnode_vid(vn_p);

		DEVFS_UNLOCK();

		<span class="enscript-comment">/*
		 * We want to use the drainok variant of vnode_getwithvid
		 * because we _don't_ want to get an iocount if the vnode is
		 * is blocked in vnode_drain as it can cause infinite
		 * loops in vn_open_auth. While in use vnodes are typically
		 * only reclaimed on forced unmounts, In use devfs tty vnodes
		 * can  be quite frequently reclaimed by revoke(2) or by the
		 * exit of a controlling process.
		 */</span>
	        error = vnode_getwithvid_drainok(vn_p, vid);

	        DEVFS_LOCK();

		<span class="enscript-keyword">if</span> (dnp-&gt;dn_lflags &amp; DN_DELETE) {
		        <span class="enscript-comment">/*
			 * our BUSY node got marked for
			 * deletion while the DEVFS lock
			 * was dropped...
			 */</span>
		        <span class="enscript-keyword">if</span> (error == 0) {
			        <span class="enscript-comment">/*
				 * vnode_getwithvid returned a valid ref
				 * which we need to drop
				 */</span>
			        vnode_put(vn_p);
			}
			
			<span class="enscript-comment">/* 
			 * This entry is no longer in the namespace.  This is only 
			 * possible for lookup: no other path would not find an existing
			 * vnode.  Therefore, ENOENT is a valid result.
			 */</span>
			error = ENOENT;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == ENODEV) {
			<span class="enscript-comment">/*
			 * The Filesystem is getting unmounted.
			 */</span>
			error = ENOENT;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error &amp;&amp; (nretries &lt; DEV_MAX_VNODE_RETRY)) {
			<span class="enscript-comment">/*
			 * If we got an error from vnode_getwithvid, it means
			 * we raced with a recycle and lost i.e. we asked for
			 * an iocount only after vnode_drain had been entered
			 * for the vnode and returned with an error only after
			 * devfs_reclaim was called on the vnode.  devfs_reclaim
			 * sets dn_vn to NULL but while we were waiting to
			 * reacquire DEVFS_LOCK, another vnode might have gotten
			 * associated with the dnp. In either case, we need to
			 * retry otherwise we will end up returning an ENOENT
			 * for this lookup but the next lookup will  succeed
			 * because it creates a new vnode (or a racing  lookup
			 * created a new vnode already).
			 */</span>
			error = 0;
			nretries++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}
		<span class="enscript-keyword">if</span> ( !error)
		        *vn_pp = vn_p;

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* 
	 * If we get here, then we've beaten any deletes; 
	 * if someone sets DN_DELETE during a subsequent drop
	 * of the devfs lock, we'll still vend a vnode.
	 */</span>

	<span class="enscript-keyword">if</span> (dnp-&gt;dn_lflags &amp; DN_CREATE) {
		dnp-&gt;dn_lflags |= DN_CREATEWAIT;
		msleep(&amp;dnp-&gt;dn_lflags, &amp;devfs_mutex, PRIBIO, 0 , 0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
	}

	dnp-&gt;dn_lflags |= DN_CREATE;

	<span class="enscript-keyword">switch</span> (dnp-&gt;dn_type) {
		<span class="enscript-keyword">case</span>	<span class="enscript-reference">DEV_SLNK</span>:
			vtype = VLNK;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span>	<span class="enscript-reference">DEV_DIR</span>:
			<span class="enscript-keyword">if</span> (dnp-&gt;dn_typeinfo.Dir.parent == dnp) {
				markroot = 1;
			}
			vtype = VDIR;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span>	<span class="enscript-reference">DEV_BDEV</span>:
		<span class="enscript-keyword">case</span>	<span class="enscript-reference">DEV_CDEV</span>:
		    	vtype = (dnp-&gt;dn_type == DEV_BDEV) ? VBLK : VCHR;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FDESC</span>
		<span class="enscript-keyword">case</span> 	<span class="enscript-reference">DEV_DEVFD</span>:
			vtype = VDIR;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* FDESC */</span>
	}
	vfsp.vnfs_mp = dnp-&gt;dn_dvm-&gt;mount;
	vfsp.vnfs_vtype = vtype;
	vfsp.vnfs_str = <span class="enscript-string">&quot;devfs&quot;</span>;
	vfsp.vnfs_dvp = 0;
	vfsp.vnfs_fsnode = dnp;
	vfsp.vnfs_cnp = 0;
	vfsp.vnfs_vops = *(dnp-&gt;dn_ops);
		
	<span class="enscript-keyword">if</span> (vtype == VBLK || vtype == VCHR) {
		<span class="enscript-comment">/*
		 * Ask the clone minor number function for a new minor number
		 * to use for the next device instance.  If an administative
		 * limit has been reached, this function will return -1.
		 */</span>
		<span class="enscript-keyword">if</span> (dnp-&gt;dn_clone != NULL) {
			<span class="enscript-type">int</span>	n_major = major(dnp-&gt;dn_typeinfo.dev);

			n_minor = (*dnp-&gt;dn_clone)(dnp-&gt;dn_typeinfo.dev, DEVFS_CLONE_ALLOC);
			<span class="enscript-keyword">if</span> (n_minor == -1) {
				error = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			vfsp.vnfs_rdev = makedev(n_major, n_minor);;
		} <span class="enscript-keyword">else</span> {
		vfsp.vnfs_rdev = dnp-&gt;dn_typeinfo.dev;
		}
	} <span class="enscript-keyword">else</span> {
		vfsp.vnfs_rdev = 0;
	}
	vfsp.vnfs_filesize = 0;
	vfsp.vnfs_flags = VNFS_NOCACHE | VNFS_CANTCACHE;
	<span class="enscript-comment">/* Tag system files */</span>
	vfsp.vnfs_marksystem = 0;
	vfsp.vnfs_markroot = markroot;

	DEVFS_UNLOCK();

	error = vnode_create(VNCREATE_FLAVOR, VCREATESIZE, &amp;vfsp, &amp;vn_p);
	
	<span class="enscript-comment">/* Do this before grabbing the lock */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		vnode_setneedinactive(vn_p);
	}

	DEVFS_LOCK();

	<span class="enscript-keyword">if</span> (error == 0) {
			vnode_settag(vn_p, VT_DEVFS);

			<span class="enscript-keyword">if</span> ((dnp-&gt;dn_clone != NULL) &amp;&amp; (dnp-&gt;dn_vn != NULLVP) )
				panic(<span class="enscript-string">&quot;devfs_dntovn: cloning device with a vnode?\n&quot;</span>);

			*vn_pp = vn_p;

			<span class="enscript-comment">/* 
			 * Another vnode that has this devnode as its v_data.
			 * This reference, unlike the one taken at the start
			 * of the function, persists until a VNOP_RECLAIM
			 * comes through for this vnode.
			 */</span>
			devfs_ref_node(dnp);

			<span class="enscript-comment">/* 
			 * A cloned vnode is not hooked into the devnode; every lookup
			 * gets a new vnode.
			 */</span>
			<span class="enscript-keyword">if</span> (dnp-&gt;dn_clone == NULL) {
				dnp-&gt;dn_vn = vn_p;
			} 
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (n_minor != DEVFS_CLONE_ALLOC) {
		<span class="enscript-comment">/*
		 * If we failed the create, we need to release the cloned minor
		 * back to the free list.  In general, this is only useful if
		 * the clone function results in a state change in the cloned
		 * device for which the minor number was obtained.  If we get
		 * past this point withouth falling into this case, it's
		 * assumed that any state to be released will be released when
		 * the vnode is dropped, instead.
		 */</span>
		 (<span class="enscript-type">void</span>)(*dnp-&gt;dn_clone)(dnp-&gt;dn_typeinfo.dev, DEVFS_CLONE_FREE);
	}

	dnp-&gt;dn_lflags &amp;= ~DN_CREATE;
	<span class="enscript-keyword">if</span> (dnp-&gt;dn_lflags &amp; DN_CREATEWAIT) {
		dnp-&gt;dn_lflags &amp;= ~DN_CREATEWAIT;
		wakeup(&amp;dnp-&gt;dn_lflags);
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/* 
	 * Release the reference we took to prevent deletion while we weren't holding the lock.
	 * If not returning success, then dropping this reference could delete the devnode;
	 * no one should access a devnode after a call to devfs_dntovn fails.
	 */</span>
	devfs_rele_node(dnp);

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Increment refcount on a devnode; prevents free of the node
 * while the devfs lock is not held.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">devfs_ref_node</span>(devnode_t *dnp) 
{
	dnp-&gt;dn_refcount++;
}

<span class="enscript-comment">/*
 * Release a reference on a devnode.  If the devnode is marked for 
 * free and the refcount is dropped to zero, do the free.
 */</span>
<span class="enscript-type">void</span> 
<span class="enscript-function-name">devfs_rele_node</span>(devnode_t *dnp)
{
	dnp-&gt;dn_refcount--;
	<span class="enscript-keyword">if</span> (dnp-&gt;dn_refcount &lt; 0) {
		panic(<span class="enscript-string">&quot;devfs_rele_node: devnode with a negative refcount!\n&quot;</span>);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((dnp-&gt;dn_refcount == 0) &amp;&amp; (dnp-&gt;dn_lflags &amp; DN_DELETE))  {
		devnode_free(dnp);
	}

}

<span class="enscript-comment">/***********************************************************************
 * add a whole device, with no prototype.. make name element and node
 * Used for adding the original device entries
 *
 * called with DEVFS_LOCK held
 ***********************************************************************/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dev_add_entry</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, devnode_t * parent, <span class="enscript-type">int</span> type, devnode_type_t * typeinfo,
	      devnode_t * proto, <span class="enscript-type">struct</span> devfsmount *dvm, devdirent_t * *nm_pp)
{
	devnode_t *	dnp;
	<span class="enscript-type">int</span>	error = 0;

	<span class="enscript-keyword">if</span> ((error = dev_add_node(type, typeinfo, proto, &amp;dnp, 
			(parent?parent-&gt;dn_dvm:dvm))) != 0)
	{
		printf(<span class="enscript-string">&quot;devfs: %s: base node allocation failed (Errno=%d)\n&quot;</span>,
			name,error);
		<span class="enscript-keyword">return</span> error;
	}
	<span class="enscript-keyword">if</span> ((error = dev_add_name(name ,parent ,NULL, dnp, nm_pp)) != 0)
	{
		devfs_dn_free(dnp); <span class="enscript-comment">/* 1-&gt;0 for dir, 0-&gt;(-1) for other */</span>
		printf(<span class="enscript-string">&quot;devfs: %s: name slot allocation failed (Errno=%d)\n&quot;</span>,
		       name,error);
		
	}
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">devfs_bulk_notify</span>(devfs_event_log_t delp) 
{
	uint32_t i;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; delp-&gt;del_used; i++) {
		devfs_vnode_event_t dvep = &amp;delp-&gt;del_entries[i];
		<span class="enscript-keyword">if</span> (vnode_getwithvid(dvep-&gt;dve_vp, dvep-&gt;dve_vid) == 0) {
			vnode_notify(dvep-&gt;dve_vp, dvep-&gt;dve_events, NULL);
			vnode_put(dvep-&gt;dve_vp);
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">devfs_record_event</span>(devfs_event_log_t delp, devnode_t *dnp, uint32_t events)
{
	<span class="enscript-keyword">if</span> (delp-&gt;del_used &gt;= delp-&gt;del_max) {
		panic(<span class="enscript-string">&quot;devfs event log overflowed.\n&quot;</span>);
	}

	<span class="enscript-comment">/* Can only notify for nodes that have an associated vnode */</span>
	<span class="enscript-keyword">if</span> (dnp-&gt;dn_vn != NULLVP &amp;&amp; vnode_ismonitored(dnp-&gt;dn_vn)) {
		devfs_vnode_event_t dvep = &amp;delp-&gt;del_entries[delp-&gt;del_used];
		dvep-&gt;dve_vp = dnp-&gt;dn_vn;
		dvep-&gt;dve_vid = vnode_vid(dnp-&gt;dn_vn);
		dvep-&gt;dve_events = events;
		delp-&gt;del_used++;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">devfs_init_event_log</span>(devfs_event_log_t delp, uint32_t count, devfs_vnode_event_t buf) 
{
	devfs_vnode_event_t dvearr;

	<span class="enscript-keyword">if</span> (buf == NULL)  {
		MALLOC(dvearr, devfs_vnode_event_t, count * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> devfs_vnode_event), M_TEMP, M_WAITOK | M_ZERO);
		<span class="enscript-keyword">if</span> (dvearr == NULL) {
			<span class="enscript-keyword">return</span> ENOMEM;
		}
	} <span class="enscript-keyword">else</span> {
		dvearr = buf;
	}

	delp-&gt;del_max = count;
	delp-&gt;del_used = 0;
	delp-&gt;del_entries = dvearr;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">devfs_release_event_log</span>(devfs_event_log_t delp, <span class="enscript-type">int</span> need_free)
{
	<span class="enscript-keyword">if</span> (delp-&gt;del_entries == NULL) {
		panic(<span class="enscript-string">&quot;Free of devfs notify info that has not been intialized.\n&quot;</span>);
	}

	<span class="enscript-keyword">if</span> (need_free) {
		FREE(delp-&gt;del_entries, M_TEMP);
	}

	delp-&gt;del_entries = NULL;
}

<span class="enscript-comment">/*
 * Function: devfs_make_node
 *
 * Purpose
 *   Create a device node with the given pathname in the devfs namespace.
 *
 * Parameters:
 *   dev 	- the dev_t value to associate
 *   chrblk	- block or character device (DEVFS_CHAR or DEVFS_BLOCK)
 *   uid, gid	- ownership
 *   perms	- permissions
 *   clone	- minor number cloning function
 *   fmt, ...	- path format string with printf args to format the path name
 * Returns:
 *   A handle to a device node if successful, NULL otherwise.
 */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">devfs_make_node_clone</span>(dev_t dev, <span class="enscript-type">int</span> chrblk, uid_t uid,
		gid_t gid, <span class="enscript-type">int</span> perms, <span class="enscript-type">int</span> (*clone)(dev_t dev, <span class="enscript-type">int</span> action),
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...)
{
	devdirent_t *	new_dev = NULL;
	devfstype_t 	type; 
	va_list ap;

	<span class="enscript-keyword">switch</span> (chrblk) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DEVFS_CHAR</span>:
			type = DEV_CDEV;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DEVFS_BLOCK</span>:
			type = DEV_BDEV;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	va_start(ap, fmt);
	new_dev = devfs_make_node_internal(dev, type, uid, gid, perms, clone, fmt, ap);
	va_end(ap);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> new_dev;
}


<span class="enscript-comment">/*
 * Function: devfs_make_node
 *
 * Purpose
 *   Create a device node with the given pathname in the devfs namespace.
 *
 * Parameters:
 *   dev 	- the dev_t value to associate
 *   chrblk	- block or character device (DEVFS_CHAR or DEVFS_BLOCK)
 *   uid, gid	- ownership
 *   perms	- permissions
 *   fmt, ...	- path format string with printf args to format the path name
 * Returns:
 *   A handle to a device node if successful, NULL otherwise.
 */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">devfs_make_node</span>(dev_t dev, <span class="enscript-type">int</span> chrblk, uid_t uid,
		gid_t gid, <span class="enscript-type">int</span> perms, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...)
{
	devdirent_t *	new_dev = NULL;
	devfstype_t type;
	va_list ap;

	<span class="enscript-keyword">if</span> (chrblk != DEVFS_CHAR &amp;&amp; chrblk != DEVFS_BLOCK)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	type = (chrblk == DEVFS_BLOCK ? DEV_BDEV : DEV_CDEV);

	va_start(ap, fmt);
	new_dev = devfs_make_node_internal(dev, type, uid, gid, perms, NULL, fmt, ap);
	va_end(ap);
	
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> new_dev;
}

<span class="enscript-type">static</span> devdirent_t *
<span class="enscript-function-name">devfs_make_node_internal</span>(dev_t dev, devfstype_t type, uid_t uid, 
		gid_t gid, <span class="enscript-type">int</span> perms, <span class="enscript-type">int</span> (*clone)(dev_t dev, <span class="enscript-type">int</span> action), <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, va_list ap)
{
	devdirent_t *	new_dev = NULL;
	devnode_t * dnp;
	devnode_type_t	typeinfo;

	<span class="enscript-type">char</span> 		*name, buf[256]; <span class="enscript-comment">/* XXX */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> 	*path;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-type">char</span> buff[<span class="enscript-keyword">sizeof</span>(buf)];
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span> 		i;
	uint32_t 	log_count;
	<span class="enscript-type">struct</span> devfs_event_log event_log;
	<span class="enscript-type">struct</span> devfs_vnode_event stackbuf[NUM_STACK_ENTRIES];
	<span class="enscript-type">int</span>		need_free = 0;

	vsnprintf(buf, <span class="enscript-keyword">sizeof</span>(buf), fmt, ap);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	bcopy(buf, buff, <span class="enscript-keyword">sizeof</span>(buff));
	buff[<span class="enscript-keyword">sizeof</span>(buff)-1] = 0;
#<span class="enscript-reference">endif</span>
	name = NULL;

	<span class="enscript-keyword">for</span>(i=strlen(buf); i&gt;0; i--)
		<span class="enscript-keyword">if</span>(buf[i] == <span class="enscript-string">'/'</span>) {
			name=&amp;buf[i];
			buf[i]=0;
			<span class="enscript-keyword">break</span>;
		}

	<span class="enscript-keyword">if</span> (name) {
		*name++ = <span class="enscript-string">'\0'</span>;
		path = buf;
	} <span class="enscript-keyword">else</span> {
		name = buf;
		path = <span class="enscript-string">&quot;/&quot;</span>;
	}

	log_count = devfs_nmountplanes;
	<span class="enscript-keyword">if</span> (log_count &gt; NUM_STACK_ENTRIES) {
<span class="enscript-reference">wrongsize</span>:
		need_free = 1;
		<span class="enscript-keyword">if</span> (devfs_init_event_log(&amp;event_log, log_count, NULL) != 0) {
			<span class="enscript-keyword">return</span> NULL;
		}
	} <span class="enscript-keyword">else</span> {
		need_free = 0;
		log_count = NUM_STACK_ENTRIES;
		<span class="enscript-keyword">if</span> (devfs_init_event_log(&amp;event_log, log_count, &amp;stackbuf[0]) != 0) {
			<span class="enscript-keyword">return</span> NULL;
		}
	}

	DEVFS_LOCK();
	<span class="enscript-keyword">if</span> (log_count &lt; devfs_nmountplanes) {
		DEVFS_UNLOCK();
		devfs_release_event_log(&amp;event_log, need_free);
		log_count = log_count * 2;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">wrongsize</span>;
	}
	
	<span class="enscript-keyword">if</span> (!devfs_ready) {
		printf(<span class="enscript-string">&quot;devfs_make_node: not ready for devices!\n&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* find/create directory path ie. mkdir -p */</span>
	<span class="enscript-keyword">if</span> (dev_finddir(path, NULL, DEVFS_CREATE, &amp;dnp, &amp;event_log) == 0) {
	    typeinfo.dev = dev;
	    <span class="enscript-keyword">if</span> (dev_add_entry(name, dnp, type, &amp;typeinfo, NULL, NULL, &amp;new_dev) == 0) {
		new_dev-&gt;de_dnp-&gt;dn_gid = gid;
		new_dev-&gt;de_dnp-&gt;dn_uid = uid;
		new_dev-&gt;de_dnp-&gt;dn_mode |= perms;
		new_dev-&gt;de_dnp-&gt;dn_clone = clone;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_devfs_label_associate_device(dev, new_dev-&gt;de_dnp, buff);
#<span class="enscript-reference">endif</span>
		devfs_propogate(dnp-&gt;dn_typeinfo.Dir.myname, new_dev, &amp;event_log);
	    }
	}

<span class="enscript-reference">out</span>:
	DEVFS_UNLOCK();

	devfs_bulk_notify(&amp;event_log);
	devfs_release_event_log(&amp;event_log, need_free);
	<span class="enscript-keyword">return</span> new_dev;
}

<span class="enscript-comment">/*
 * Function: devfs_make_link
 *
 * Purpose:
 *   Create a link to a previously created device node.
 *
 * Returns:
 *   0 if successful, -1 if failed
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">devfs_make_link</span>(<span class="enscript-type">void</span> *original, <span class="enscript-type">char</span> *fmt, ...)
{
	devdirent_t *	new_dev = NULL;
	devdirent_t *	orig = (devdirent_t *) original;
	devnode_t *	dirnode;	<span class="enscript-comment">/* devnode for parent directory */</span>
	<span class="enscript-type">struct</span> devfs_event_log event_log;
	uint32_t	log_count;

	va_list ap;
	<span class="enscript-type">char</span> *p, buf[256]; <span class="enscript-comment">/* XXX */</span>
	<span class="enscript-type">int</span> i;

	DEVFS_LOCK();

	<span class="enscript-keyword">if</span> (!devfs_ready) {
		DEVFS_UNLOCK();
		printf(<span class="enscript-string">&quot;devfs_make_link: not ready for devices!\n&quot;</span>);
		<span class="enscript-keyword">return</span> -1;
	}
	DEVFS_UNLOCK();

	va_start(ap, fmt);
	vsnprintf(buf, <span class="enscript-keyword">sizeof</span>(buf), fmt, ap);
	va_end(ap);

	p = NULL;

	<span class="enscript-keyword">for</span>(i=strlen(buf); i&gt;0; i--) {
		<span class="enscript-keyword">if</span>(buf[i] == <span class="enscript-string">'/'</span>) {
				p=&amp;buf[i];
				buf[i]=0;
				<span class="enscript-keyword">break</span>;
		}
	}
	
	<span class="enscript-comment">/* 
	 * One slot for each directory, one for each devnode 
	 * whose link count changes 
	 */</span>
	log_count = devfs_nmountplanes * 2;
<span class="enscript-reference">wrongsize</span>:
	<span class="enscript-keyword">if</span> (devfs_init_event_log(&amp;event_log, log_count, NULL) != 0) {
		<span class="enscript-comment">/* No lock held, no allocations done, can just return */</span>
		<span class="enscript-keyword">return</span> -1;
	}

	DEVFS_LOCK();

	<span class="enscript-keyword">if</span> (log_count &lt; devfs_nmountplanes) {
		DEVFS_UNLOCK();
		devfs_release_event_log(&amp;event_log, 1);
		log_count = log_count * 2;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">wrongsize</span>;
	}

	<span class="enscript-keyword">if</span> (p) {
	        *p++ = <span class="enscript-string">'\0'</span>;

		<span class="enscript-keyword">if</span> (dev_finddir(buf, NULL, DEVFS_CREATE, &amp;dirnode, &amp;event_log)
		    || dev_add_name(p, dirnode, NULL, orig-&gt;de_dnp, &amp;new_dev))
		        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-keyword">if</span> (dev_finddir(<span class="enscript-string">&quot;&quot;</span>, NULL, DEVFS_CREATE, &amp;dirnode, &amp;event_log)
		    || dev_add_name(buf, dirnode, NULL, orig-&gt;de_dnp, &amp;new_dev))
		        <span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	devfs_propogate(dirnode-&gt;dn_typeinfo.Dir.myname, new_dev, &amp;event_log);
<span class="enscript-reference">fail</span>:
	DEVFS_UNLOCK();
	devfs_bulk_notify(&amp;event_log);
	devfs_release_event_log(&amp;event_log, 1);

	<span class="enscript-keyword">return</span> ((new_dev != NULL) ? 0 : -1);
}
</pre>
<hr />
</body></html>