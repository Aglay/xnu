<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vnode_pager.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vnode_pager.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */</span>
<span class="enscript-comment">/*
 *	File:	vnode_pager.c
 *
 *	&quot;Swap&quot; pager that pages to/from vnodes.  Also
 *	handles demand paging from files.
 *
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>	<span class="enscript-comment">/* needs internal due to fhandle_t */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disk.h&gt;</span> 		<span class="enscript-comment">/* For DKIOC calls */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/memory_object_control.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/upl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vnode_pager.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/spl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/rpcv2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>


<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_pager_throttle</span>()
{
	<span class="enscript-type">struct</span> uthread *ut;

	ut = get_bsdthread_info(current_thread());

	<span class="enscript-keyword">if</span> (ut-&gt;uu_lowpri_window)
		throttle_lowpri_io(1);
}


boolean_t
<span class="enscript-function-name">vnode_pager_isSSD</span>(vnode_t vp)
{
	<span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_kern_flag &amp; MNTK_SSD)
		<span class="enscript-keyword">return</span> (TRUE);
	<span class="enscript-keyword">return</span> (FALSE);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_pager_issue_reprioritize_io</span>(<span class="enscript-type">struct</span> vnode *devvp, uint64_t blkno, uint32_t len, <span class="enscript-type">int</span> priority)
{
	u_int32_t blocksize = 0;
	dk_extent_t extent;
        dk_set_tier_t set_tier;
	<span class="enscript-type">int</span> error = 0;

	error = VNOP_IOCTL(devvp, DKIOCGETBLOCKSIZE, (caddr_t)&amp;blocksize, 0, vfs_context_kernel());
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span>;

	memset(&amp;extent, 0, <span class="enscript-keyword">sizeof</span>(dk_extent_t));
	memset(&amp;set_tier, 0, <span class="enscript-keyword">sizeof</span>(dk_set_tier_t));
	
	extent.offset = blkno * (u_int64_t) blocksize;
	extent.length = len;

	set_tier.extents = &amp;extent; 
	set_tier.extentsCount = 1;
	set_tier.tier = priority;
		
	error = VNOP_IOCTL(devvp, DKIOCSETTIER, (caddr_t)&amp;set_tier, 0, vfs_context_kernel());
	<span class="enscript-keyword">return</span>;
}
#<span class="enscript-reference">endif</span>

uint32_t
<span class="enscript-function-name">vnode_pager_isinuse</span>(<span class="enscript-type">struct</span> vnode *vp)
{
	<span class="enscript-keyword">if</span> (vp-&gt;v_usecount &gt; vp-&gt;v_kusecount)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">return</span> (0);
}

uint32_t
<span class="enscript-function-name">vnode_pager_return_throttle_io_limit</span>(<span class="enscript-type">struct</span> vnode *vp, uint32_t *limit)
{
	<span class="enscript-keyword">return</span>(cluster_throttle_io_limit(vp, limit));
}

vm_object_offset_t
<span class="enscript-function-name">vnode_pager_get_filesize</span>(<span class="enscript-type">struct</span> vnode *vp)
{
	<span class="enscript-keyword">return</span> (vm_object_offset_t) ubc_getsize(vp);
}

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">safe_getpath</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">char</span> *leafname, <span class="enscript-type">char</span> *path, <span class="enscript-type">int</span> _len, <span class="enscript-type">int</span> *truncated_path);

kern_return_t
<span class="enscript-function-name">vnode_pager_get_name</span>(
	<span class="enscript-type">struct</span> vnode	*vp,
	<span class="enscript-type">char</span>		*pathname,
	vm_size_t	pathname_len,
	<span class="enscript-type">char</span> 		*filename,
	vm_size_t	filename_len,
	boolean_t	*truncated_path_p)
{
	*truncated_path_p = FALSE;
	<span class="enscript-keyword">if</span> (pathname != NULL) {
		<span class="enscript-comment">/* get the path name */</span>
		safe_getpath(vp, NULL,
			     pathname, (<span class="enscript-type">int</span>) pathname_len,
			     truncated_path_p);
	}
	<span class="enscript-keyword">if</span> ((pathname == NULL || *truncated_path_p) &amp;&amp;
	    filename != NULL) {
		<span class="enscript-comment">/* get the file name */</span>
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name;

		name = vnode_getname_printable(vp);
		strlcpy(filename, name, (size_t) filename_len);
		vnode_putname_printable(name);
	}
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">vnode_pager_get_mtime</span>(
	<span class="enscript-type">struct</span> vnode	*vp,
	<span class="enscript-type">struct</span> timespec	*current_mtime,
	<span class="enscript-type">struct</span> timespec	*cs_mtime)
{
	vnode_mtime(vp, current_mtime, vfs_context_current());
	<span class="enscript-keyword">if</span> (cs_mtime != NULL) {
		ubc_get_cs_mtime(vp, cs_mtime);
	}
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

kern_return_t
<span class="enscript-function-name">vnode_pager_get_cs_blobs</span>(
	<span class="enscript-type">struct</span> vnode	*vp,
	<span class="enscript-type">void</span>		**blobs)
{
	*blobs = ubc_get_cs_blobs(vp);
	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

<span class="enscript-comment">/* 
 * vnode_trim:
 * Used to call the DKIOCUNMAP ioctl on the underlying disk device for the specified vnode.
 * Trims the region at offset bytes into the file, for length bytes.
 *
 * Care must be taken to ensure that the vnode is sufficiently reference counted at the time this
 * function is called; no iocounts or usecounts are taken on the vnode.
 * This function is non-idempotent in error cases;  We cannot un-discard the blocks if only some of them
 * are successfully discarded.
 */</span>
u_int32_t <span class="enscript-function-name">vnode_trim</span> (
		<span class="enscript-type">struct</span> vnode *vp,
		off_t offset,
		size_t length)
{
	daddr64_t io_blockno;	 <span class="enscript-comment">/* Block number corresponding to the start of the extent */</span>
	size_t io_bytecount;	<span class="enscript-comment">/* Number of bytes in current extent for the specified range */</span>
	size_t trimmed = 0;
	off_t current_offset = offset; 
	size_t remaining_length = length;
	<span class="enscript-type">int</span> error = 0;
	u_int32_t blocksize = 0;
	<span class="enscript-type">struct</span> vnode *devvp;
	dk_extent_t extent;
	dk_unmap_t unmap;


	<span class="enscript-comment">/* Get the underlying device vnode */</span>
	devvp = vp-&gt;v_mount-&gt;mnt_devvp;

	<span class="enscript-comment">/* Figure out the underlying device block size */</span>
	error  = VNOP_IOCTL(devvp, DKIOCGETBLOCKSIZE, (caddr_t)&amp;blocksize, 0, vfs_context_kernel());
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">trim_exit</span>;
	}

	<span class="enscript-comment">/* 
	 * We may not get the entire range from offset -&gt; offset+length in a single
	 * extent from the blockmap call.  Keep looping/going until we are sure we've hit
	 * the whole range or if we encounter an error.
	 */</span>
	<span class="enscript-keyword">while</span> (trimmed &lt; length) {
		<span class="enscript-comment">/*
		 * VNOP_BLOCKMAP will tell us the logical to physical block number mapping for the
		 * specified offset.  It returns blocks in contiguous chunks, so if the logical range is 
		 * broken into multiple extents, it must be called multiple times, increasing the offset
		 * in each call to ensure that the entire range is covered.
		 */</span>
		error = VNOP_BLOCKMAP (vp, current_offset, remaining_length, 
				&amp;io_blockno, &amp;io_bytecount, NULL, VNODE_READ, NULL);

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">trim_exit</span>;
		}
		<span class="enscript-comment">/* 
		 * We have a contiguous run.  Prepare &amp; issue the ioctl for the device.
		 * the DKIOCUNMAP ioctl takes offset in bytes from the start of the device.
		 */</span>
		memset (&amp;extent, 0, <span class="enscript-keyword">sizeof</span>(dk_extent_t));
		memset (&amp;unmap, 0, <span class="enscript-keyword">sizeof</span>(dk_unmap_t));
		extent.offset = (uint64_t) io_blockno * (u_int64_t) blocksize;
		extent.length = io_bytecount;
		unmap.extents = &amp;extent;
		unmap.extentsCount = 1;
		error = VNOP_IOCTL(devvp, DKIOCUNMAP, (caddr_t)&amp;unmap, 0, vfs_context_kernel());

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">trim_exit</span>;
		}
		remaining_length = remaining_length - io_bytecount;
		trimmed = trimmed + io_bytecount;
		current_offset = current_offset + io_bytecount;
	}
<span class="enscript-reference">trim_exit</span>:

	<span class="enscript-keyword">return</span> error;

}

pager_return_t
<span class="enscript-function-name">vnode_pageout</span>(<span class="enscript-type">struct</span> vnode *vp,
	upl_t			upl,
	upl_offset_t		upl_offset,
	vm_object_offset_t	f_offset,
	upl_size_t		size,
	<span class="enscript-type">int</span>			flags,
	<span class="enscript-type">int</span>			*errorp)
{
	<span class="enscript-type">int</span>		result = PAGER_SUCCESS;
	<span class="enscript-type">int</span>		error = 0;
	<span class="enscript-type">int</span>		error_ret = 0;
	daddr64_t blkno;
	<span class="enscript-type">int</span> isize;
	<span class="enscript-type">int</span> pg_index;
	<span class="enscript-type">int</span> base_index;
	upl_offset_t offset;
	upl_page_info_t *pl;
	vfs_context_t ctx = vfs_context_current();	<span class="enscript-comment">/* pager context */</span>

	isize = (<span class="enscript-type">int</span>)size;

	<span class="enscript-keyword">if</span> (isize &lt;= 0) {
	        result    = PAGER_ERROR;
		error_ret = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (UBCINFOEXISTS(vp) == 0) {
		result    = PAGER_ERROR;
		error_ret = EINVAL;

		<span class="enscript-keyword">if</span> (upl &amp;&amp; !(flags &amp; UPL_NOCOMMIT))
		        ubc_upl_abort_range(upl, upl_offset, size, UPL_ABORT_FREE_ON_EMPTY);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> ( !(flags &amp; UPL_VNODE_PAGER)) {
		<span class="enscript-comment">/*
		 * This is a pageout from the default pager,
		 * just go ahead and call vnop_pageout since
		 * it has already sorted out the dirty ranges
		 */</span>
		KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
			(MACHDBG_CODE(DBG_MACH_VM, 1)) | DBG_FUNC_START, 
			size, 1, 0, 0, 0);

		<span class="enscript-keyword">if</span> ( (error_ret = VNOP_PAGEOUT(vp, upl, upl_offset, (off_t)f_offset,
					       (size_t)size, flags, ctx)) )
			result = PAGER_ERROR;

		KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
			(MACHDBG_CODE(DBG_MACH_VM, 1)) | DBG_FUNC_END, 
			size, 1, 0, 0, 0);

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (upl == NULL) {
		<span class="enscript-type">int</span>			request_flags;

		<span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFSVNOP_PAGEOUTV2) {
			<span class="enscript-comment">/*
			 * filesystem has requested the new form of VNOP_PAGEOUT for file
			 * backed objects... we will not grab the UPL befofe calling VNOP_PAGEOUT...
			 * it is the fileystem's responsibility to grab the range we're denoting
			 * via 'f_offset' and 'size' into a UPL... this allows the filesystem to first
			 * take any locks it needs, before effectively locking the pages into a UPL...
			 */</span>
			KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE, 
				(MACHDBG_CODE(DBG_MACH_VM, 1)) | DBG_FUNC_START, 
				size, (<span class="enscript-type">int</span>)f_offset, 0, 0, 0);

			<span class="enscript-keyword">if</span> ( (error_ret = VNOP_PAGEOUT(vp, NULL, upl_offset, (off_t)f_offset,
						       size, flags, ctx)) ) {
				result = PAGER_ERROR;
			}
			KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
				(MACHDBG_CODE(DBG_MACH_VM, 1)) | DBG_FUNC_END, 
				size, 0, 0, 0, 0);

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (flags &amp; UPL_MSYNC)
			request_flags = UPL_UBC_MSYNC | UPL_RET_ONLY_DIRTY;
		<span class="enscript-keyword">else</span>
			request_flags = UPL_UBC_PAGEOUT | UPL_RET_ONLY_DIRTY;
		
	        <span class="enscript-keyword">if</span> (ubc_create_upl(vp, f_offset, size, &amp;upl, &amp;pl, request_flags) != KERN_SUCCESS) {
			result    = PAGER_ERROR;
			error_ret = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		upl_offset = 0;
	} <span class="enscript-keyword">else</span> 
		pl = ubc_upl_pageinfo(upl);

	<span class="enscript-comment">/*
	 * Ignore any non-present pages at the end of the
	 * UPL so that we aren't looking at a upl that 
	 * may already have been freed by the preceeding
	 * aborts/completions.
	 */</span>
	base_index = upl_offset / PAGE_SIZE;

	<span class="enscript-keyword">for</span> (pg_index = (upl_offset + isize) / PAGE_SIZE; pg_index &gt; base_index;) {
	        <span class="enscript-keyword">if</span> (upl_page_present(pl, --pg_index))
		        <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (pg_index == base_index) {
		        <span class="enscript-comment">/*
			 * no pages were returned, so release
			 * our hold on the upl and leave
			 */</span>
		        <span class="enscript-keyword">if</span> ( !(flags &amp; UPL_NOCOMMIT))
			        ubc_upl_abort_range(upl, upl_offset, isize, UPL_ABORT_FREE_ON_EMPTY);

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	isize = ((pg_index + 1) - base_index) * PAGE_SIZE;

	<span class="enscript-comment">/*
	 * we come here for pageouts to 'real' files and
	 * for msyncs...  the upl may not contain any
	 * dirty pages.. it's our responsibility to sort
	 * through it and find the 'runs' of dirty pages
	 * to call VNOP_PAGEOUT on...
	 */</span>

	<span class="enscript-keyword">if</span> (ubc_getsize(vp) == 0) {
	        <span class="enscript-comment">/*
		 * if the file has been effectively deleted, then
		 * we need to go through the UPL and invalidate any
		 * buffer headers we might have that reference any
		 * of it's pages
		 */</span>
		<span class="enscript-keyword">for</span> (offset = upl_offset; isize; isize -= PAGE_SIZE, offset += PAGE_SIZE) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
			<span class="enscript-keyword">if</span> (vp-&gt;v_tag == VT_NFS)
				<span class="enscript-comment">/* check with nfs if page is OK to drop */</span>
				error = nfs_buf_page_inval(vp, (off_t)f_offset);
			<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
			{
			        blkno = ubc_offtoblk(vp, (off_t)f_offset);
			        error = buf_invalblkno(vp, blkno, 0);
			}
			<span class="enscript-keyword">if</span> (error) {
			        <span class="enscript-keyword">if</span> ( !(flags &amp; UPL_NOCOMMIT))
				        ubc_upl_abort_range(upl, offset, PAGE_SIZE, UPL_ABORT_FREE_ON_EMPTY);
				<span class="enscript-keyword">if</span> (error_ret == 0)
				        error_ret = error;
				result = PAGER_ERROR;

			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( !(flags &amp; UPL_NOCOMMIT)) {
			        ubc_upl_commit_range(upl, offset, PAGE_SIZE, UPL_COMMIT_FREE_ON_EMPTY);
			}
			f_offset += PAGE_SIZE;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	offset = upl_offset;
	pg_index = base_index;

	<span class="enscript-keyword">while</span> (isize) {
		<span class="enscript-type">int</span>  xsize;
		<span class="enscript-type">int</span>  num_of_pages;

		<span class="enscript-keyword">if</span> ( !upl_page_present(pl, pg_index)) {
		        <span class="enscript-comment">/*
			 * we asked for RET_ONLY_DIRTY, so it's possible
			 * to get back empty slots in the UPL
			 * just skip over them
			 */</span>
		        f_offset += PAGE_SIZE;
			offset   += PAGE_SIZE;
			isize    -= PAGE_SIZE;
			pg_index++;

			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> ( !upl_dirty_page(pl, pg_index)) {
			<span class="enscript-comment">/*
			 * if the page is not dirty and reached here it is
			 * marked precious or it is due to invalidation in
			 * memory_object_lock request as part of truncation
			 * We also get here from vm_object_terminate()
			 * So all you need to do in these
			 * cases is to invalidate incore buffer if it is there
			 * Note we must not sleep here if the buffer is busy - that is
			 * a lock inversion which causes deadlock.
			 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
			<span class="enscript-keyword">if</span> (vp-&gt;v_tag == VT_NFS)
				<span class="enscript-comment">/* check with nfs if page is OK to drop */</span>
				error = nfs_buf_page_inval(vp, (off_t)f_offset);
			<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
			{
			        blkno = ubc_offtoblk(vp, (off_t)f_offset);
			        error = buf_invalblkno(vp, blkno, 0);
			}
			<span class="enscript-keyword">if</span> (error) {
			        <span class="enscript-keyword">if</span> ( !(flags &amp; UPL_NOCOMMIT))
				        ubc_upl_abort_range(upl, offset, PAGE_SIZE, UPL_ABORT_FREE_ON_EMPTY);
				<span class="enscript-keyword">if</span> (error_ret == 0)
				        error_ret = error;
				result = PAGER_ERROR;

			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( !(flags &amp; UPL_NOCOMMIT)) {
			        ubc_upl_commit_range(upl, offset, PAGE_SIZE, UPL_COMMIT_FREE_ON_EMPTY);
			}
		        f_offset += PAGE_SIZE;
			offset   += PAGE_SIZE;
			isize    -= PAGE_SIZE;
			pg_index++;

			<span class="enscript-keyword">continue</span>;
		}
		num_of_pages = 1;
		xsize = isize - PAGE_SIZE;

		<span class="enscript-keyword">while</span> (xsize) {
			<span class="enscript-keyword">if</span> ( !upl_dirty_page(pl, pg_index + num_of_pages))
				<span class="enscript-keyword">break</span>;
			num_of_pages++;
			xsize -= PAGE_SIZE;
		}
		xsize = num_of_pages * PAGE_SIZE;

		KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
			(MACHDBG_CODE(DBG_MACH_VM, 1)) | DBG_FUNC_START, 
			xsize, (<span class="enscript-type">int</span>)f_offset, 0, 0, 0);

		<span class="enscript-keyword">if</span> ( (error = VNOP_PAGEOUT(vp, upl, offset, (off_t)f_offset,
					   xsize, flags, ctx)) ) {
		        <span class="enscript-keyword">if</span> (error_ret == 0)
		                error_ret = error;
			result = PAGER_ERROR;
		}
		KERNEL_DEBUG_CONSTANT_IST(KDEBUG_TRACE,
			(MACHDBG_CODE(DBG_MACH_VM, 1)) | DBG_FUNC_END, 
			xsize, 0, 0, 0, 0);

	        f_offset += xsize;
		offset   += xsize;
		isize    -= xsize;
		pg_index += num_of_pages;
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (errorp)
		*errorp = error_ret;

	<span class="enscript-keyword">return</span> (result);
}


pager_return_t
<span class="enscript-function-name">vnode_pagein</span>(
	<span class="enscript-type">struct</span> vnode 		*vp,
	upl_t        		upl,
	upl_offset_t  		upl_offset,
	vm_object_offset_t	f_offset,
	upl_size_t     		size,
	<span class="enscript-type">int</span>           		flags,
	<span class="enscript-type">int</span> 			*errorp)
{
        upl_page_info_t *pl;
	<span class="enscript-type">int</span>	        result = PAGER_SUCCESS;
	<span class="enscript-type">int</span>		error = 0;
        <span class="enscript-type">int</span>             pages_in_upl;
        <span class="enscript-type">int</span>             start_pg;
        <span class="enscript-type">int</span>             last_pg;
	<span class="enscript-type">int</span>             first_pg;
        <span class="enscript-type">int</span>             xsize;
	<span class="enscript-type">int</span>		must_commit = 1;
	<span class="enscript-type">int</span>		ignore_valid_page_check = 0;

	<span class="enscript-keyword">if</span> (flags &amp; UPL_NOCOMMIT)
	        must_commit = 0;

	<span class="enscript-keyword">if</span> (flags &amp; UPL_IGNORE_VALID_PAGE_CHECK)
		ignore_valid_page_check = 1;

	<span class="enscript-keyword">if</span> (UBCINFOEXISTS(vp) == 0) {
		result = PAGER_ERROR;
		error  = PAGER_ERROR;

		<span class="enscript-keyword">if</span> (upl &amp;&amp; must_commit)
			ubc_upl_abort_range(upl, upl_offset, size, UPL_ABORT_FREE_ON_EMPTY | UPL_ABORT_ERROR);

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (upl == (upl_t)NULL) {
		flags &amp;= ~UPL_NOCOMMIT;

	        <span class="enscript-keyword">if</span> (size &gt; MAX_UPL_SIZE_BYTES) {
		        result = PAGER_ERROR;
			error  = PAGER_ERROR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFSVNOP_PAGEINV2) {
			<span class="enscript-comment">/*
			 * filesystem has requested the new form of VNOP_PAGEIN for file
			 * backed objects... we will not grab the UPL befofe calling VNOP_PAGEIN...
			 * it is the fileystem's responsibility to grab the range we're denoting
			 * via 'f_offset' and 'size' into a UPL... this allows the filesystem to first
			 * take any locks it needs, before effectively locking the pages into a UPL...
			 * so we pass a NULL into the filesystem instead of a UPL pointer... the 'upl_offset'
			 * is used to identify the &quot;must have&quot; page in the extent... the filesystem is free
			 * to clip the extent to better fit the underlying FS blocksize if it desires as 
			 * long as it continues to include the &quot;must have&quot; page... 'f_offset' + 'upl_offset'
			 * identifies that page
			 */</span>
			<span class="enscript-keyword">if</span> ( (error = VNOP_PAGEIN(vp, NULL, upl_offset, (off_t)f_offset,
						  size, flags, vfs_context_current())) ) {
				result = PAGER_ERROR;
				error  = PAGER_ERROR;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	        ubc_create_upl(vp, f_offset, size, &amp;upl, &amp;pl, UPL_UBC_PAGEIN | UPL_RET_ONLY_ABSENT);

		<span class="enscript-keyword">if</span> (upl == (upl_t)NULL) {
		        result =  PAGER_ABSENT;
			error = PAGER_ABSENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		ubc_upl_range_needed(upl, upl_offset / PAGE_SIZE, 1);

		upl_offset = 0;
		first_pg = 0;
		
		<span class="enscript-comment">/*
		 * if we get here, we've created the upl and
		 * are responsible for commiting/aborting it
		 * regardless of what the caller has passed in
		 */</span>
		must_commit = 1;
	} <span class="enscript-keyword">else</span> {
	        pl = ubc_upl_pageinfo(upl);
		first_pg = upl_offset / PAGE_SIZE;
	}
	pages_in_upl = size / PAGE_SIZE;
	DTRACE_VM2(pgpgin, <span class="enscript-type">int</span>, pages_in_upl, (uint64_t *), NULL);

	<span class="enscript-comment">/*
	 * before we start marching forward, we must make sure we end on 
	 * a present page, otherwise we will be working with a freed
         * upl
	 */</span>
	<span class="enscript-keyword">for</span> (last_pg = pages_in_upl - 1; last_pg &gt;= first_pg; last_pg--) {
		<span class="enscript-keyword">if</span> (upl_page_present(pl, last_pg))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (last_pg == first_pg) {
		        <span class="enscript-comment">/*
			 * empty UPL, no pages are present
			 */</span>
		        <span class="enscript-keyword">if</span> (must_commit)
			        ubc_upl_abort_range(upl, upl_offset, size, UPL_ABORT_FREE_ON_EMPTY);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	pages_in_upl = last_pg + 1;
	last_pg = first_pg;

	<span class="enscript-keyword">while</span> (last_pg &lt; pages_in_upl) {
	        <span class="enscript-comment">/*
		 * skip over missing pages...
		 */</span>
	        <span class="enscript-keyword">for</span> ( ; last_pg &lt; pages_in_upl; last_pg++) {
		        <span class="enscript-keyword">if</span> (upl_page_present(pl, last_pg))
			        <span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (ignore_valid_page_check == 1) {
			start_pg = last_pg;
		} <span class="enscript-keyword">else</span> {
	        	<span class="enscript-comment">/*
			 * skip over 'valid' pages... we don't want to issue I/O for these
			 */</span>
	        	<span class="enscript-keyword">for</span> (start_pg = last_pg; last_pg &lt; pages_in_upl; last_pg++) {
		        	<span class="enscript-keyword">if</span> (!upl_valid_page(pl, last_pg))
			        	<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> (last_pg &gt; start_pg) {
		        <span class="enscript-comment">/*
			 * we've found a range of valid pages
			 * if we've got COMMIT responsibility
			 * commit this range of pages back to the
			 * cache unchanged
			 */</span>
		        xsize = (last_pg - start_pg) * PAGE_SIZE;

			<span class="enscript-keyword">if</span> (must_commit)
			        ubc_upl_abort_range(upl, start_pg * PAGE_SIZE, xsize, UPL_ABORT_FREE_ON_EMPTY);
		}
		<span class="enscript-keyword">if</span> (last_pg == pages_in_upl)
		        <span class="enscript-comment">/*
			 * we're done... all pages that were present
			 * have either had I/O issued on them or 
			 * were aborted unchanged...
			 */</span>
		        <span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (!upl_page_present(pl, last_pg)) {
		        <span class="enscript-comment">/*
			 * we found a range of valid pages 
			 * terminated by a missing page...
			 * bump index to the next page and continue on
			 */</span>
		        last_pg++;
		        <span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * scan from the found invalid page looking for a valid
		 * or non-present page before the end of the upl is reached, if we
		 * find one, then it will be the last page of the request to
		 * 'cluster_io'
		 */</span>
		<span class="enscript-keyword">for</span> (start_pg = last_pg; last_pg &lt; pages_in_upl; last_pg++) {
		        <span class="enscript-keyword">if</span> (( !ignore_valid_page_check &amp;&amp; upl_valid_page(pl, last_pg)) || !upl_page_present(pl, last_pg))
			        <span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (last_pg &gt; start_pg) {
		        <span class="enscript-type">int</span> xoff;
		        xsize = (last_pg - start_pg) * PAGE_SIZE;
			xoff  = start_pg * PAGE_SIZE;

			<span class="enscript-keyword">if</span> ( (error = VNOP_PAGEIN(vp, upl, (upl_offset_t) xoff,
					       (off_t)f_offset + xoff,
					       xsize, flags, vfs_context_current())) ) {
		        	<span class="enscript-comment">/*
				 * Usually this UPL will be aborted/committed by the lower cluster layer.
				 *
				 * a)	In the case of decmpfs, however, we may return an error (EAGAIN) to avoid
				 *	a deadlock with another thread already inflating the file. 
				 *
				 * b)	In the case of content protection, EPERM is a valid error and we should respect it.
				 *
				 * In those cases, we must take care of our UPL at this layer itself.
				 */</span>
				<span class="enscript-keyword">if</span> (must_commit) {
					<span class="enscript-keyword">if</span>(error == EAGAIN) {
			        		ubc_upl_abort_range(upl, (upl_offset_t) xoff, xsize, UPL_ABORT_FREE_ON_EMPTY | UPL_ABORT_RESTART);
					}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
					<span class="enscript-keyword">if</span>(error == EPERM) {
			        		ubc_upl_abort_range(upl, (upl_offset_t) xoff, xsize, UPL_ABORT_FREE_ON_EMPTY | UPL_ABORT_ERROR);
					}
#<span class="enscript-reference">endif</span>
				}
				result = PAGER_ERROR;
				error  = PAGER_ERROR;

			}
		}
        }
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (errorp)
		*errorp = result;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_pager_shutdown</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i;
	vnode_t vp;

	<span class="enscript-keyword">for</span>(i = 0; i &lt; MAX_BACKING_STORE; i++) {
		vp = (vnode_t)(bs_port_table[i]).vp;
		<span class="enscript-keyword">if</span> (vp) {
			(bs_port_table[i]).vp = 0;

			<span class="enscript-comment">/* get rid of macx_swapon() reference */</span>
			vnode_rele(vp);
		}
	}
}


<span class="enscript-type">void</span> *
<span class="enscript-function-name">upl_get_internal_page_list</span>(upl_t upl)
{
  <span class="enscript-keyword">return</span>(UPL_GET_INTERNAL_PAGE_LIST(upl));

}
</pre>
<hr />
</body></html>