<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>vm_compressor_backing_file.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">vm_compressor_backing_file.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdint.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cprotect.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disk.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;hfs/hfs.h&gt;</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">vm_swapfile_open</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *path, vnode_t *vp);
<span class="enscript-type">void</span> <span class="enscript-function-name">vm_swapfile_close</span>(uint64_t path, vnode_t vp);
<span class="enscript-type">int</span> <span class="enscript-function-name">vm_swapfile_preallocate</span>(vnode_t vp, uint64_t *size, boolean_t *pin);
uint64_t <span class="enscript-function-name">vm_swapfile_get_blksize</span>(vnode_t vp);
uint64_t <span class="enscript-function-name">vm_swapfile_get_transfer_size</span>(vnode_t vp);
<span class="enscript-type">int</span> <span class="enscript-function-name">vm_swapfile_io</span>(vnode_t vp, uint64_t offset, uint64_t start, <span class="enscript-type">int</span> npages, <span class="enscript-type">int</span> flags);
<span class="enscript-type">int</span> <span class="enscript-function-name">vm_record_file_write</span>(<span class="enscript-type">struct</span> vnode *vp, uint64_t offset, <span class="enscript-type">char</span> *buf, <span class="enscript-type">int</span> size);


<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swapfile_open</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *path, vnode_t *vp)
{
	<span class="enscript-type">int</span> error = 0;
	vfs_context_t	ctx = vfs_context_current();

	<span class="enscript-keyword">if</span> ((error = vnode_open(path, (O_CREAT | O_TRUNC | FREAD | FWRITE), S_IRUSR | S_IWUSR, 0, vp, ctx))) {
		printf(<span class="enscript-string">&quot;Failed to open swap file %d\n&quot;</span>, error);
		*vp = NULL;
		<span class="enscript-keyword">return</span>;
	}	

	vnode_put(*vp);
}

uint64_t
<span class="enscript-function-name">vm_swapfile_get_blksize</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span> ((uint64_t)vfs_devblocksize(vnode_mount(vp)));
}

uint64_t
<span class="enscript-function-name">vm_swapfile_get_transfer_size</span>(vnode_t vp)
{
	<span class="enscript-keyword">return</span>((uint64_t)vp-&gt;v_mount-&gt;mnt_vfsstat.f_iosize);
}

<span class="enscript-type">int</span> <span class="enscript-function-name">unlink1</span>(vfs_context_t, vnode_t, user_addr_t, <span class="enscript-type">enum</span> uio_seg, <span class="enscript-type">int</span>);

<span class="enscript-type">void</span>
<span class="enscript-function-name">vm_swapfile_close</span>(uint64_t path_addr, vnode_t vp)
{
	vfs_context_t context = vfs_context_current();
	<span class="enscript-type">int</span> error;

	vnode_getwithref(vp);
	vnode_close(vp, 0, context);
	
	error = unlink1(context, NULLVP, CAST_USER_ADDR_T(path_addr),
	    UIO_SYSSPACE, 0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (error)
		printf(<span class="enscript-string">&quot;%s : unlink of %s failed with error %d&quot;</span>, __FUNCTION__,
		    (<span class="enscript-type">char</span> *)path_addr, error);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vm_swapfile_preallocate</span>(vnode_t vp, uint64_t *size, boolean_t *pin)
{
	<span class="enscript-type">int</span>		error = 0;
	uint64_t	file_size = 0;
	vfs_context_t	ctx = NULL;


	ctx = vfs_context_current();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
	{
#<span class="enscript-reference">if</span> 0	// &lt;<span class="enscript-variable-name">rdar</span>://11771612&gt;

		<span class="enscript-keyword">if</span> ((error = cp_vnode_setclass(vp, PROTECTION_CLASS_F))) {
			<span class="enscript-keyword">if</span>(config_protect_bug) {
				printf(<span class="enscript-string">&quot;swap protection class set failed with %d\n&quot;</span>, error);
			} <span class="enscript-keyword">else</span> {
				panic(<span class="enscript-string">&quot;swap protection class set failed with %d\n&quot;</span>, error);
			}
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/* initialize content protection keys manually */</span>
		<span class="enscript-keyword">if</span> ((error = cp_handle_vnop(vp, CP_WRITE_ACCESS, 0)) != 0) {
			printf(<span class="enscript-string">&quot;Content Protection key failure on swap: %d\n&quot;</span>, error);
			vnode_put(vp);
			vp = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
 		}
	}
#<span class="enscript-reference">endif</span>
	error = vnode_setsize(vp, *size, IO_NOZEROFILL, ctx);

	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;vnode_setsize for swap files failed: %d\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = vnode_size(vp, (off_t*) &amp;file_size, ctx);

	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;vnode_size (new file) for swap file failed: %d\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}	
	assert(file_size == *size);
	
	<span class="enscript-keyword">if</span> (pin != NULL &amp;&amp; *pin != FALSE) {

		assert(vnode_tag(vp) == VT_HFS);

		error = hfs_pin_vnode(VTOHFS(vp), vp, HFS_PIN_IT | HFS_DATALESS_PIN, NULL, ctx);

		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;hfs_pin_vnode for swap files failed: %d\n&quot;</span>, error);
			<span class="enscript-comment">/* this is not fatal, carry on with files wherever they landed */</span>
			*pin = FALSE;
			error = 0;
		}
	}

	vnode_lock_spin(vp);
	SET(vp-&gt;v_flag, VSWAP);
	vnode_unlock(vp);
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">vm_record_file_write</span>(vnode_t vp, uint64_t offset, <span class="enscript-type">char</span> *buf, <span class="enscript-type">int</span> size)
{
	<span class="enscript-type">int</span> error = 0;
	vfs_context_t ctx;

	ctx = vfs_context_kernel();
		
	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)buf, size, offset,
		UIO_SYSSPACE, IO_NODELOCKED, vfs_context_ucred(ctx), (<span class="enscript-type">int</span> *) 0, vfs_context_proc(ctx));

	<span class="enscript-keyword">return</span> (error);
}



<span class="enscript-type">int</span>
<span class="enscript-function-name">vm_swapfile_io</span>(vnode_t vp, uint64_t offset, uint64_t start, <span class="enscript-type">int</span> npages, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">int</span> error = 0;
	uint64_t io_size = npages * PAGE_SIZE_64;
#<span class="enscript-reference">if</span> 1
	kern_return_t	kr = KERN_SUCCESS;
	upl_t		upl = NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	count = 0;
	upl_control_flags_t upl_create_flags = 0;
	<span class="enscript-type">int</span>		upl_control_flags = 0;
	upl_size_t	upl_size = 0;

	upl_create_flags = UPL_SET_INTERNAL | UPL_SET_LITE
			| UPL_MEMORY_TAG_MAKE(VM_KERN_MEMORY_OSFMK);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENCRYPTED_SWAP</span>
	upl_control_flags = UPL_IOSYNC | UPL_PAGING_ENCRYPTED;
#<span class="enscript-reference">else</span>
	upl_control_flags = UPL_IOSYNC;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((flags &amp; SWAP_READ) == FALSE) {
		upl_create_flags |= UPL_COPYOUT_FROM;
	}
 
	upl_size = io_size;
	kr = vm_map_create_upl( kernel_map,
				start,
				&amp;upl_size,
				&amp;upl,
				NULL,
				&amp;count,
				&amp;upl_create_flags);

	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS || (upl_size != io_size)) {
		panic(<span class="enscript-string">&quot;vm_map_create_upl failed with %d\n&quot;</span>, kr);
	}

	<span class="enscript-keyword">if</span> (flags &amp; SWAP_READ) {
		vnode_pagein(vp,
			      upl,
			      0,
			      offset,
			      io_size,
			      upl_control_flags | UPL_IGNORE_VALID_PAGE_CHECK,
			      &amp;error);
		<span class="enscript-keyword">if</span> (error) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
			printf(<span class="enscript-string">&quot;vm_swapfile_io: vnode_pagein failed with %d (vp: %p, offset: 0x%llx, size:%llu)\n&quot;</span>, error, vp, offset, io_size);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* DEBUG */</span>
			printf(<span class="enscript-string">&quot;vm_swapfile_io: vnode_pagein failed with %d.\n&quot;</span>, error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>
		}
	
	} <span class="enscript-keyword">else</span> {
		vnode_pageout(vp,
			      upl,
			      0,
			      offset,
			      io_size,
			      upl_control_flags,
			      &amp;error);
		<span class="enscript-keyword">if</span> (error) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
			printf(<span class="enscript-string">&quot;vm_swapfile_io: vnode_pageout failed with %d (vp: %p, offset: 0x%llx, size:%llu)\n&quot;</span>, error, vp, offset, io_size);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* DEBUG */</span>
			printf(<span class="enscript-string">&quot;vm_swapfile_io: vnode_pageout failed with %d.\n&quot;</span>, error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>
		}
	}
	<span class="enscript-keyword">return</span> error;

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* 1 */</span>
	vfs_context_t ctx;
	ctx = vfs_context_kernel();
		
	error = vn_rdwr((flags &amp; SWAP_READ) ? UIO_READ : UIO_WRITE, vp, (caddr_t)start, io_size, offset,
		UIO_SYSSPACE, IO_SYNC | IO_NODELOCKED | IO_UNIT | IO_NOCACHE | IO_SWAP_DISPATCH, vfs_context_ucred(ctx), (<span class="enscript-type">int</span> *) 0, vfs_context_proc(ctx));

	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;vn_rdwr: Swap I/O failed with %d\n&quot;</span>, error);
	}
	<span class="enscript-keyword">return</span> error;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 1 */</span>
}


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_BATCH_TO_TRIM</span>	256

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ROUTE_ONLY</span>		0x10		<span class="enscript-comment">/* if corestorage is present, tell it to just pass */</span>
                                                <span class="enscript-comment">/* the DKIOUNMAP command through w/o acting on it */</span>
                                                <span class="enscript-comment">/* this is used by the compressed swap system to reclaim empty space */</span>


u_int32_t <span class="enscript-function-name">vnode_trim_list</span> (vnode_t vp, <span class="enscript-type">struct</span> trim_list *tl, boolean_t route_only)
{
	<span class="enscript-type">int</span>		error = 0;
	<span class="enscript-type">int</span>		trim_index = 0;
	u_int32_t	blocksize = 0;
	<span class="enscript-type">struct</span> vnode	*devvp;
	dk_extent_t	*extents;
	dk_unmap_t	unmap;
	_dk_cs_unmap_t	cs_unmap;

	<span class="enscript-keyword">if</span> ( !(vp-&gt;v_mount-&gt;mnt_ioflags &amp; MNT_IOFLAGS_UNMAP_SUPPORTED))
		<span class="enscript-keyword">return</span> (ENOTSUP);

	<span class="enscript-keyword">if</span> (tl == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/*
	 * Get the underlying device vnode and physical block size
	 */</span>
	devvp = vp-&gt;v_mount-&gt;mnt_devvp;
	blocksize = vp-&gt;v_mount-&gt;mnt_devblocksize;

	extents = kalloc(<span class="enscript-keyword">sizeof</span>(dk_extent_t) * MAX_BATCH_TO_TRIM);

	<span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_ioflags &amp; MNT_IOFLAGS_CSUNMAP_SUPPORTED) {
		memset (&amp;cs_unmap, 0, <span class="enscript-keyword">sizeof</span>(_dk_cs_unmap_t));
		cs_unmap.extents = extents;

		<span class="enscript-keyword">if</span> (route_only == TRUE)
			cs_unmap.options = ROUTE_ONLY;
	} <span class="enscript-keyword">else</span> {
		memset (&amp;unmap, 0, <span class="enscript-keyword">sizeof</span>(dk_unmap_t));
		unmap.extents = extents;
	}

	<span class="enscript-keyword">while</span> (tl) {
		daddr64_t	io_blockno;	<span class="enscript-comment">/* Block number corresponding to the start of the extent */</span>
		size_t		io_bytecount;	<span class="enscript-comment">/* Number of bytes in current extent for the specified range */</span>
		size_t		trimmed;
		size_t		remaining_length;
		off_t		current_offset; 

		current_offset = tl-&gt;tl_offset;
		remaining_length = tl-&gt;tl_length;
		trimmed = 0;
		
		<span class="enscript-comment">/* 
		 * We may not get the entire range from tl_offset -&gt; tl_offset+tl_length in a single
		 * extent from the blockmap call.  Keep looping/going until we are sure we've hit
		 * the whole range or if we encounter an error.
		 */</span>
		<span class="enscript-keyword">while</span> (trimmed &lt; tl-&gt;tl_length) {
			<span class="enscript-comment">/*
			 * VNOP_BLOCKMAP will tell us the logical to physical block number mapping for the
			 * specified offset.  It returns blocks in contiguous chunks, so if the logical range is 
			 * broken into multiple extents, it must be called multiple times, increasing the offset
			 * in each call to ensure that the entire range is covered.
			 */</span>
			error = VNOP_BLOCKMAP (vp, current_offset, remaining_length, 
					       &amp;io_blockno, &amp;io_bytecount, NULL, VNODE_READ, NULL);

			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">trim_exit</span>;
			}

			extents[trim_index].offset = (uint64_t) io_blockno * (u_int64_t) blocksize;
			extents[trim_index].length = io_bytecount;

			trim_index++;

			<span class="enscript-keyword">if</span> (trim_index == MAX_BATCH_TO_TRIM) {

				<span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_ioflags &amp; MNT_IOFLAGS_CSUNMAP_SUPPORTED) {
					cs_unmap.extentsCount = trim_index;
					error = VNOP_IOCTL(devvp, _DKIOCCSUNMAP, (caddr_t)&amp;cs_unmap, 0, vfs_context_kernel());
				} <span class="enscript-keyword">else</span> {
					unmap.extentsCount = trim_index;
					error = VNOP_IOCTL(devvp, DKIOCUNMAP, (caddr_t)&amp;unmap, 0, vfs_context_kernel());
				}
				<span class="enscript-keyword">if</span> (error) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">trim_exit</span>;
				}
				trim_index = 0;
			}
			trimmed += io_bytecount;
			current_offset += io_bytecount;
			remaining_length -= io_bytecount;
		}
		tl = tl-&gt;tl_next;
	}
	<span class="enscript-keyword">if</span> (trim_index) {
		<span class="enscript-keyword">if</span> (vp-&gt;v_mount-&gt;mnt_ioflags &amp; MNT_IOFLAGS_CSUNMAP_SUPPORTED) {
			cs_unmap.extentsCount = trim_index;
			error = VNOP_IOCTL(devvp, _DKIOCCSUNMAP, (caddr_t)&amp;cs_unmap, 0, vfs_context_kernel());
		} <span class="enscript-keyword">else</span> {
			unmap.extentsCount = trim_index;
			error = VNOP_IOCTL(devvp, DKIOCUNMAP, (caddr_t)&amp;unmap, 0, vfs_context_kernel());
		}
	}
<span class="enscript-reference">trim_exit</span>:
	kfree(extents, <span class="enscript-keyword">sizeof</span>(dk_extent_t) * MAX_BATCH_TO_TRIM);

	<span class="enscript-keyword">return</span> error;
}
</pre>
<hr />
</body></html>