<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>udp6_usrreq.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">udp6_usrreq.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$FreeBSD: src/sys/netinet6/udp6_usrreq.c,v 1.6.2.6 2001/07/29 19:32:40 ume Exp $	*/</span>
<span class="enscript-comment">/*	$KAME: udp6_usrreq.c,v 1.27 2001/05/21 05:45:10 jinmei Exp $	*/</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)udp_var.h	8.1 (Berkeley) 6/10/93
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/udp6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6protosw.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp6.h&gt;</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> ipsec_bypass;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> esp_udp_encap_port;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/necp.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FLOW_DIVERT</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/flow_divert.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* FLOW_DIVERT */</span>

<span class="enscript-comment">/*
 * UDP protocol inplementation.
 * Per RFC 768, August, 1980.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp6_abort</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp6_attach</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp6_bind</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp6_connectx</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr_list **,
    <span class="enscript-type">struct</span> sockaddr_list **, <span class="enscript-type">struct</span> proc *, uint32_t, sae_associd_t,
    sae_connid_t *, uint32_t, <span class="enscript-type">void</span> *, uint32_t, <span class="enscript-type">struct</span> uio *, user_ssize_t *);
<span class="enscript-type">static</span>	<span class="enscript-type">int</span> udp6_detach(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp6_disconnect</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp6_disconnectx</span>(<span class="enscript-type">struct</span> socket *, sae_associd_t, sae_connid_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp6_send</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> sockaddr *,
    <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">udp6_append</span>(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">struct</span> ip6_hdr *,
    <span class="enscript-type">struct</span> sockaddr_in6 *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp6_input_checksum</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> udphdr *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> fw_verbose;
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipfwsyslog</span>( <span class="enscript-type">int</span> level, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *format,...);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipfw_stealth_stats_incr_udpv6</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">/* Apple logging, log to ipfw.log */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">log_in_vain_log</span>(a) {						\
	<span class="enscript-keyword">if</span> ((udp_log_in_vain == 3) &amp;&amp; (fw_verbose == 2)) {		\
		ipfwsyslog a;						\
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((udp_log_in_vain == 4) &amp;&amp; (fw_verbose == 2)) {       \
	        ipfw_stealth_stats_incr_udpv6();			\
	} <span class="enscript-keyword">else</span> {							\
		log a;							\
	}								\
}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !IPFIREWALL */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">log_in_vain_log</span>( a ) { log a; }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !IPFIREWALL */</span>

<span class="enscript-type">struct</span> pr_usrreqs udp6_usrreqs = {
	.pru_abort =		udp6_abort,
	.pru_attach =		udp6_attach,
	.pru_bind =		udp6_bind,
	.pru_connect =		udp6_connect,
	.pru_connectx =		udp6_connectx,
	.pru_control =		in6_control,
	.pru_detach =		udp6_detach,
	.pru_disconnect =	udp6_disconnect,
	.pru_disconnectx =	udp6_disconnectx,
	.pru_peeraddr =		in6_mapped_peeraddr,
	.pru_send =		udp6_send,
	.pru_shutdown =		udp_shutdown,
	.pru_sockaddr =		in6_mapped_sockaddr,
	.pru_sosend =		sosend,
	.pru_soreceive =	soreceive,
	.pru_soreceive_list =	soreceive_list,
};

<span class="enscript-comment">/*
 * subroutine of udp6_input(), mainly for source code readability.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">udp6_append</span>(<span class="enscript-type">struct</span> inpcb *last, <span class="enscript-type">struct</span> ip6_hdr *ip6,
    <span class="enscript-type">struct</span> sockaddr_in6 *udp_in6, <span class="enscript-type">struct</span> mbuf *n, <span class="enscript-type">int</span> off, <span class="enscript-type">struct</span> ifnet *ifp)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ip6</span>)
	<span class="enscript-type">struct</span>  mbuf *opts = NULL;
	<span class="enscript-type">int</span> ret = 0;
	boolean_t cell = IFNET_IS_CELLULAR(ifp);
	boolean_t wifi = (!cell &amp;&amp; IFNET_IS_WIFI(ifp));
	boolean_t wired = (!wifi &amp;&amp; IFNET_IS_WIRED(ifp));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
	<span class="enscript-keyword">if</span> (mac_inpcb_check_deliver(last, n, AF_INET6, SOCK_DGRAM) != 0) {
		m_freem(n);
		<span class="enscript-keyword">return</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET */</span>
	<span class="enscript-keyword">if</span> ((last-&gt;in6p_flags &amp; INP_CONTROLOPTS) != 0 ||
	    (last-&gt;in6p_socket-&gt;so_options &amp; SO_TIMESTAMP) != 0 ||
	    (last-&gt;in6p_socket-&gt;so_options &amp; SO_TIMESTAMP_MONOTONIC) != 0) {
		ret = ip6_savecontrol(last, n, &amp;opts);
		<span class="enscript-keyword">if</span> (ret != 0) {
			m_freem(n);
			m_freem(opts);
			<span class="enscript-keyword">return</span>;
		}
	}
	m_adj(n, off);
	<span class="enscript-keyword">if</span> (nstat_collect) {
		INP_ADD_STAT(last, cell, wifi, wired, rxpackets, 1);
		INP_ADD_STAT(last, cell, wifi, wired, rxbytes, n-&gt;m_pkthdr.len);
	}
	so_recv_data_stat(last-&gt;in6p_socket, n, 0);
	<span class="enscript-keyword">if</span> (sbappendaddr(&amp;last-&gt;in6p_socket-&gt;so_rcv,
	    (<span class="enscript-type">struct</span> sockaddr *)udp_in6, n, opts, NULL) == 0)
		udpstat.udps_fullsock++;
	<span class="enscript-keyword">else</span>
		sorwakeup(last-&gt;in6p_socket);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">udp6_input</span>(<span class="enscript-type">struct</span> mbuf **mp, <span class="enscript-type">int</span> *offp, <span class="enscript-type">int</span> proto)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">proto</span>)
	<span class="enscript-type">struct</span> mbuf *m = *mp;
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">struct</span> udphdr *uh;
	<span class="enscript-type">struct</span> inpcb *in6p;
	<span class="enscript-type">struct</span>  mbuf *opts = NULL;
	<span class="enscript-type">int</span> off = *offp;
	<span class="enscript-type">int</span> plen, ulen, ret = 0;
	boolean_t cell, wifi, wired;
	<span class="enscript-type">struct</span> sockaddr_in6 udp_in6;
	<span class="enscript-type">struct</span> inpcbinfo *pcbinfo = &amp;udbinfo;
	<span class="enscript-type">struct</span> sockaddr_in6 fromsa;

	IP6_EXTHDR_CHECK(m, off, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr), <span class="enscript-keyword">return</span> IPPROTO_DONE);

	<span class="enscript-comment">/* Expect 32-bit aligned data pointer on strict-align platforms */</span>
	MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

	ifp = m-&gt;m_pkthdr.rcvif;
	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	cell = IFNET_IS_CELLULAR(ifp);
	wifi = (!cell &amp;&amp; IFNET_IS_WIFI(ifp));
	wired = (!wifi &amp;&amp; IFNET_IS_WIRED(ifp));

	udpstat.udps_ipackets++;

	plen = ntohs(ip6-&gt;ip6_plen) - off + <span class="enscript-keyword">sizeof</span> (*ip6);
	uh = (<span class="enscript-type">struct</span> udphdr *)(<span class="enscript-type">void</span> *)((caddr_t)ip6 + off);
	ulen = ntohs((u_short)uh-&gt;uh_ulen);

	<span class="enscript-keyword">if</span> (plen != ulen) {
		udpstat.udps_badlen++;
		IF_UDP_STATINC(ifp, badlength);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* destination port of 0 is illegal, based on RFC768. */</span>
	<span class="enscript-keyword">if</span> (uh-&gt;uh_dport == 0) {
		IF_UDP_STATINC(ifp, port0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/*
	 * Checksum extended UDP header and data.
	 */</span>
	<span class="enscript-keyword">if</span> (udp6_input_checksum(m, uh, off, ulen))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-comment">/*
	 * Construct sockaddr format source address.
	 */</span>
	init_sin6(&amp;fromsa, m);
	fromsa.sin6_port = uh-&gt;uh_sport;

	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst)) {
		<span class="enscript-type">int</span> reuse_sock = 0, mcast_delivered = 0;
		<span class="enscript-type">struct</span> ip6_moptions *imo;

		<span class="enscript-comment">/*
		 * Deliver a multicast datagram to all sockets
		 * for which the local and remote addresses and ports match
		 * those of the incoming datagram.  This allows more than
		 * one process to receive multicasts on the same port.
		 * (This really ought to be done for unicast datagrams as
		 * well, but that would cause problems with existing
		 * applications that open both address-specific sockets and
		 * a wildcard socket listening to the same port -- they would
		 * end up receiving duplicates of every unicast datagram.
		 * Those applications open the multiple sockets to overcome an
		 * inadequacy of the UDP socket interface, but for backwards
		 * compatibility we avoid the problem here rather than
		 * fixing the interface.  Maybe 4.5BSD will remedy this?)
		 */</span>

		<span class="enscript-comment">/*
		 * In a case that laddr should be set to the link-local
		 * address (this happens in RIPng), the multicast address
		 * specified in the received packet does not match with
		 * laddr. To cure this situation, the matching is relaxed
		 * if the receiving interface is the same as one specified
		 * in the socket and if the destination multicast address
		 * matches one of the multicast groups specified in the socket.
		 */</span>

		<span class="enscript-comment">/*
		 * Construct sockaddr format source address.
		 */</span>
		init_sin6(&amp;udp_in6, m); <span class="enscript-comment">/* general init */</span>
		udp_in6.sin6_port = uh-&gt;uh_sport;
		<span class="enscript-comment">/*
		 * KAME note: usually we drop udphdr from mbuf here.
		 * We need udphdr for IPsec processing so we do that later.
		 */</span>

		<span class="enscript-comment">/*
		 * Locate pcb(s) for datagram.
		 * (Algorithm copied from raw_intr().)
		 */</span>
		lck_rw_lock_shared(pcbinfo-&gt;ipi_lock);

		LIST_FOREACH(in6p, &amp;udb, inp_list) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
			<span class="enscript-type">int</span> skipit;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

			<span class="enscript-keyword">if</span> ((in6p-&gt;inp_vflag &amp; INP_IPV6) == 0)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (inp_restricted_recv(in6p, ifp))
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (in_pcb_checkstate(in6p, WNT_ACQUIRE, 0) ==
			    WNT_STOPUSING)
				<span class="enscript-keyword">continue</span>;

			udp_lock(in6p-&gt;in6p_socket, 1, 0);

			<span class="enscript-keyword">if</span> (in_pcb_checkstate(in6p, WNT_RELEASE, 1) ==
			    WNT_STOPUSING) {
				udp_unlock(in6p-&gt;in6p_socket, 1, 0);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (in6p-&gt;in6p_lport != uh-&gt;uh_dport) {
				udp_unlock(in6p-&gt;in6p_socket, 1, 0);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/*
			 * Handle socket delivery policy for any-source
			 * and source-specific multicast. [RFC3678]
			 */</span>
			imo = in6p-&gt;in6p_moptions;
			<span class="enscript-keyword">if</span> (imo &amp;&amp; IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst)) {
				<span class="enscript-type">struct</span> sockaddr_in6 mcaddr;
				<span class="enscript-type">int</span> blocked;

				IM6O_LOCK(imo);
				bzero(&amp;mcaddr, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6));
				mcaddr.sin6_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
				mcaddr.sin6_family = AF_INET6;
				mcaddr.sin6_addr = ip6-&gt;ip6_dst;

				blocked = im6o_mc_filter(imo, ifp,
				    (<span class="enscript-type">struct</span> sockaddr *)&amp;mcaddr,
				    (<span class="enscript-type">struct</span> sockaddr *)&amp;fromsa);
				IM6O_UNLOCK(imo);
				<span class="enscript-keyword">if</span> (blocked != MCAST_PASS) {
					udp_unlock(in6p-&gt;in6p_socket, 1, 0);
					<span class="enscript-keyword">if</span> (blocked == MCAST_NOTSMEMBER ||
					    blocked == MCAST_MUTED)
						udpstat.udps_filtermcast++;
					<span class="enscript-keyword">continue</span>;
				}
			}
			<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_UNSPECIFIED(&amp;in6p-&gt;in6p_faddr) &amp;&amp;
			    (!IN6_ARE_ADDR_EQUAL(&amp;in6p-&gt;in6p_faddr,
			    &amp;ip6-&gt;ip6_src) ||
			    in6p-&gt;in6p_fport != uh-&gt;uh_sport)) {
				udp_unlock(in6p-&gt;in6p_socket, 1, 0);
				<span class="enscript-keyword">continue</span>;
			}

			reuse_sock = in6p-&gt;inp_socket-&gt;so_options &amp;
			    (SO_REUSEPORT | SO_REUSEADDR);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
			skipit = 0;
			<span class="enscript-keyword">if</span> (!necp_socket_is_allowed_to_send_recv_v6(in6p,
			    uh-&gt;uh_dport, uh-&gt;uh_sport, &amp;ip6-&gt;ip6_dst,
			    &amp;ip6-&gt;ip6_src, ifp, NULL, NULL)) {
				<span class="enscript-comment">/* do not inject data to pcb */</span>
				skipit = 1;
			}
			<span class="enscript-keyword">if</span> (skipit == 0)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
			{
				<span class="enscript-type">struct</span> mbuf *n = NULL;
				<span class="enscript-comment">/*
				 * KAME NOTE: do not
				 * m_copy(m, offset, ...) below.
				 * sbappendaddr() expects M_PKTHDR,
				 * and m_copy() will copy M_PKTHDR
				 * only if offset is 0.
				 */</span>
				<span class="enscript-keyword">if</span> (reuse_sock)
					n = m_copy(m, 0, M_COPYALL);
				udp6_append(in6p, ip6, &amp;udp_in6, m,
				    off + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr), ifp);
				mcast_delivered++;
				m = n;
			}
			udp_unlock(in6p-&gt;in6p_socket, 1, 0);

			<span class="enscript-comment">/*
			 * Don't look for additional matches if this one does
			 * not have either the SO_REUSEPORT or SO_REUSEADDR
			 * socket options set.  This heuristic avoids searching
			 * through all pcbs in the common case of a non-shared
			 * port.  It assumes that an application will never
			 * clear these options after setting them.
			 */</span>
			<span class="enscript-keyword">if</span> (reuse_sock == 0 || m == NULL)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-comment">/*
			 * Expect 32-bit aligned data pointer on strict-align
			 * platforms.
			 */</span>
			MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

			<span class="enscript-comment">/*
			 * Recompute IP and UDP header pointers for new mbuf
			 */</span>
			ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
			uh = (<span class="enscript-type">struct</span> udphdr *)(<span class="enscript-type">void</span> *)((caddr_t)ip6 + off);
		}
		lck_rw_done(pcbinfo-&gt;ipi_lock);

		<span class="enscript-keyword">if</span> (mcast_delivered == 0) {
			<span class="enscript-comment">/*
			 * No matching pcb found; discard datagram.
			 * (No need to send an ICMP Port Unreachable
			 * for a broadcast or multicast datgram.)
			 */</span>
			udpstat.udps_noport++;
			udpstat.udps_noportmcast++;
			IF_UDP_STATINC(ifp, port_unreach);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

		<span class="enscript-comment">/* free the extra copy of mbuf or skipped by NECP */</span>
		<span class="enscript-keyword">if</span> (m != NULL)
			m_freem(m);
		<span class="enscript-keyword">return</span> (IPPROTO_DONE);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-comment">/*
	 * UDP to port 4500 with a payload where the first four bytes are
	 * not zero is a UDP encapsulated IPSec packet. Packets where
	 * the payload is one byte and that byte is 0xFF are NAT keepalive
	 * packets. Decapsulate the ESP packet and carry on with IPSec input
	 * or discard the NAT keep-alive.
	 */</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass == 0 &amp;&amp; (esp_udp_encap_port &amp; 0xFFFF) != 0 &amp;&amp;
	    uh-&gt;uh_dport == ntohs((u_short)esp_udp_encap_port)) {
		<span class="enscript-type">int</span> payload_len = ulen - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr) &gt; 4 ? 4 :
		    ulen - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr);

		<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; off + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr) + payload_len) {
			<span class="enscript-keyword">if</span> ((m = m_pullup(m, off + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr) +
			    payload_len)) == NULL) {
				udpstat.udps_hdrops++;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			<span class="enscript-comment">/*
			 * Expect 32-bit aligned data pointer on strict-align
			 * platforms.
			 */</span>
			MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

			ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
			uh = (<span class="enscript-type">struct</span> udphdr *)(<span class="enscript-type">void</span> *)((caddr_t)ip6 + off);
		}
		<span class="enscript-comment">/* Check for NAT keepalive packet */</span>
		<span class="enscript-keyword">if</span> (payload_len == 1 &amp;&amp; *(u_int8_t*)
		    ((caddr_t)uh + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr)) == 0xFF) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (payload_len == 4 &amp;&amp; *(u_int32_t*)(<span class="enscript-type">void</span> *)
		    ((caddr_t)uh + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr)) != 0) {
			<span class="enscript-comment">/* UDP encapsulated IPSec packet to pass through NAT */</span>
			<span class="enscript-comment">/* preserve the udp header */</span>
			*offp = off + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr);
			<span class="enscript-keyword">return</span> (esp6_input(mp, offp, IPPROTO_UDP));
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

	<span class="enscript-comment">/*
	 * Locate pcb for datagram.
	 */</span>
	in6p = in6_pcblookup_hash(&amp;udbinfo, &amp;ip6-&gt;ip6_src, uh-&gt;uh_sport,
	    &amp;ip6-&gt;ip6_dst, uh-&gt;uh_dport, 1, m-&gt;m_pkthdr.rcvif);
	<span class="enscript-keyword">if</span> (in6p == NULL) {
		IF_UDP_STATINC(ifp, port_unreach);

		<span class="enscript-keyword">if</span> (udp_log_in_vain) {
			<span class="enscript-type">char</span> buf[INET6_ADDRSTRLEN];

			strlcpy(buf, ip6_sprintf(&amp;ip6-&gt;ip6_dst), <span class="enscript-keyword">sizeof</span> (buf));
			<span class="enscript-keyword">if</span> (udp_log_in_vain &lt; 3) {
				log(LOG_INFO, <span class="enscript-string">&quot;Connection attempt to UDP &quot;</span>
				    <span class="enscript-string">&quot;%s:%d from %s:%d\n&quot;</span>, buf,
				    ntohs(uh-&gt;uh_dport),
				    ip6_sprintf(&amp;ip6-&gt;ip6_src),
				    ntohs(uh-&gt;uh_sport));
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(m-&gt;m_flags &amp; (M_BCAST | M_MCAST)) &amp;&amp;
			    !IN6_ARE_ADDR_EQUAL(&amp;ip6-&gt;ip6_dst, &amp;ip6-&gt;ip6_src)) {
				log_in_vain_log((LOG_INFO, <span class="enscript-string">&quot;Connection attempt &quot;</span>
				    <span class="enscript-string">&quot;to UDP %s:%d from %s:%d\n&quot;</span>, buf,
				    ntohs(uh-&gt;uh_dport),
				    ip6_sprintf(&amp;ip6-&gt;ip6_src),
				    ntohs(uh-&gt;uh_sport)));
			}
		}
		udpstat.udps_noport++;
		<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_MCAST) {
			printf(<span class="enscript-string">&quot;UDP6: M_MCAST is set in a unicast packet.\n&quot;</span>);
			udpstat.udps_noportmcast++;
			IF_UDP_STATINC(ifp, badmcast);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		icmp6_error(m, ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_NOPORT, 0);
		<span class="enscript-keyword">return</span> (IPPROTO_DONE);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	<span class="enscript-keyword">if</span> (!necp_socket_is_allowed_to_send_recv_v6(in6p, uh-&gt;uh_dport,
	    uh-&gt;uh_sport, &amp;ip6-&gt;ip6_dst, &amp;ip6-&gt;ip6_src, ifp, NULL, NULL)) {
		in_pcb_checkstate(in6p, WNT_RELEASE, 0);
		IF_UDP_STATINC(ifp, badipsec);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	<span class="enscript-comment">/*
	 * Construct sockaddr format source address.
	 * Stuff source address and datagram in user buffer.
	 */</span>
	udp_lock(in6p-&gt;in6p_socket, 1, 0);

	<span class="enscript-keyword">if</span> (in_pcb_checkstate(in6p, WNT_RELEASE, 1) == WNT_STOPUSING) {
		udp_unlock(in6p-&gt;in6p_socket, 1, 0);
		IF_UDP_STATINC(ifp, cleanup);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	init_sin6(&amp;udp_in6, m); <span class="enscript-comment">/* general init */</span>
	udp_in6.sin6_port = uh-&gt;uh_sport;
	<span class="enscript-keyword">if</span> ((in6p-&gt;in6p_flags &amp; INP_CONTROLOPTS) != 0 ||
	    (in6p-&gt;in6p_socket-&gt;so_options &amp; SO_TIMESTAMP) != 0 ||
	    (in6p-&gt;in6p_socket-&gt;so_options &amp; SO_TIMESTAMP_MONOTONIC) != 0) {
		ret = ip6_savecontrol(in6p, m, &amp;opts);
		<span class="enscript-keyword">if</span> (ret != 0) {
			udp_unlock(in6p-&gt;in6p_socket, 1, 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}
	m_adj(m, off + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> udphdr));
	<span class="enscript-keyword">if</span> (nstat_collect) {
		INP_ADD_STAT(in6p, cell, wifi, wired, rxpackets, 1);
		INP_ADD_STAT(in6p, cell, wifi, wired, rxbytes, m-&gt;m_pkthdr.len);
	}
	so_recv_data_stat(in6p-&gt;in6p_socket, m, 0);
	<span class="enscript-keyword">if</span> (sbappendaddr(&amp;in6p-&gt;in6p_socket-&gt;so_rcv,
	    (<span class="enscript-type">struct</span> sockaddr *)&amp;udp_in6, m, opts, NULL) == 0) {
		m = NULL;
		opts = NULL;
		udpstat.udps_fullsock++;
		udp_unlock(in6p-&gt;in6p_socket, 1, 0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	sorwakeup(in6p-&gt;in6p_socket);
	udp_unlock(in6p-&gt;in6p_socket, 1, 0);
	<span class="enscript-keyword">return</span> (IPPROTO_DONE);
<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">if</span> (m != NULL)
		m_freem(m);
	<span class="enscript-keyword">if</span> (opts != NULL)
		m_freem(opts);
	<span class="enscript-keyword">return</span> (IPPROTO_DONE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">udp6_ctlinput</span>(<span class="enscript-type">int</span> cmd, <span class="enscript-type">struct</span> sockaddr *sa, <span class="enscript-type">void</span> *d)
{
	<span class="enscript-type">struct</span> udphdr uh;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> off = 0;
	<span class="enscript-type">struct</span> ip6ctlparam *ip6cp = NULL;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in6 *sa6_src = NULL;
	<span class="enscript-type">void</span> (*notify)(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">int</span>) = udp_notify;
	<span class="enscript-type">struct</span> udp_portonly {
		u_int16_t uh_sport;
		u_int16_t uh_dport;
	} *uhp;

	<span class="enscript-keyword">if</span> (sa-&gt;sa_family != AF_INET6 ||
	    sa-&gt;sa_len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span>)cmd &gt;= PRC_NCMDS)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> (PRC_IS_REDIRECT(cmd))
		notify = in6_rtchange, d = NULL;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cmd == PRC_HOSTDEAD)
		d = NULL;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inet6ctlerrmap[cmd] == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* if the parameter is from icmp6, decode it. */</span>
	<span class="enscript-keyword">if</span> (d != NULL) {
		ip6cp = (<span class="enscript-type">struct</span> ip6ctlparam *)d;
		m = ip6cp-&gt;ip6c_m;
		ip6 = ip6cp-&gt;ip6c_ip6;
		off = ip6cp-&gt;ip6c_off;
		sa6_src = ip6cp-&gt;ip6c_src;
	} <span class="enscript-keyword">else</span> {
		m = NULL;
		ip6 = NULL;
		sa6_src = &amp;sa6_any;
	}

	<span class="enscript-keyword">if</span> (ip6 != NULL) {
		<span class="enscript-comment">/*
		 * XXX: We assume that when IPV6 is non NULL,
		 * M and OFF are valid.
		 */</span>

		<span class="enscript-comment">/* check if we can safely examine src and dst ports */</span>
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; off + <span class="enscript-keyword">sizeof</span> (*uhp))
			<span class="enscript-keyword">return</span>;

		bzero(&amp;uh, <span class="enscript-keyword">sizeof</span> (uh));
		m_copydata(m, off, <span class="enscript-keyword">sizeof</span> (*uhp), (caddr_t)&amp;uh);

		(<span class="enscript-type">void</span>) in6_pcbnotify(&amp;udbinfo, sa, uh.uh_dport,
		    (<span class="enscript-type">struct</span> sockaddr*)ip6cp-&gt;ip6c_src, uh.uh_sport,
		    cmd, NULL, notify);
	} <span class="enscript-keyword">else</span> {
		(<span class="enscript-type">void</span>) in6_pcbnotify(&amp;udbinfo, sa, 0,
		    (<span class="enscript-type">struct</span> sockaddr *)&amp;sa6_src, 0, cmd, NULL, notify);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp6_abort</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> inpcb *inp;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL) {
		panic(<span class="enscript-string">&quot;%s: so=%p null inp\n&quot;</span>, __func__, so);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	soisdisconnected(so);
	in6_pcbdetach(inp);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp6_attach</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> proto, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">proto</span>)
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">int</span> error;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp != NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	error = in_pcballoc(so, &amp;udbinfo, p);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (so-&gt;so_snd.sb_hiwat == 0 || so-&gt;so_rcv.sb_hiwat == 0) {
		error = soreserve(so, udp_sendspace, udp_recvspace);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
	}
	inp = (<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb;
	inp-&gt;inp_vflag |= INP_IPV6;
	<span class="enscript-keyword">if</span> (ip6_mapped_addr_on)
		inp-&gt;inp_vflag |= INP_IPV4;
	inp-&gt;in6p_hops = -1;	<span class="enscript-comment">/* use kernel default */</span>
	inp-&gt;in6p_cksum = -1;	<span class="enscript-comment">/* just to be sure */</span>
	<span class="enscript-comment">/*
	 * XXX: ugly!!
	 * IPv4 TTL initialization is necessary for an IPv6 socket as well,
	 * because the socket may be bound to an IPv6 wildcard address,
	 * which may match an IPv4-mapped IPv6 address.
	 */</span>
	inp-&gt;inp_ip_ttl = ip_defttl;
	<span class="enscript-keyword">if</span> (nstat_collect)
		nstat_udp_new_pcb(inp);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp6_bind</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">int</span> error;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	inp-&gt;inp_vflag &amp;= ~INP_IPV4;
	inp-&gt;inp_vflag |= INP_IPV6;
	<span class="enscript-keyword">if</span> ((inp-&gt;inp_flags &amp; IN6P_IPV6_V6ONLY) == 0) {
		<span class="enscript-type">struct</span> sockaddr_in6 *sin6_p;

		sin6_p = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)nam;

		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;sin6_p-&gt;sin6_addr)) {
			inp-&gt;inp_vflag |= INP_IPV4;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IN6_IS_ADDR_V4MAPPED(&amp;sin6_p-&gt;sin6_addr)) {
			<span class="enscript-type">struct</span> sockaddr_in sin;

			in6_sin6_2_sin(&amp;sin, sin6_p);
			inp-&gt;inp_vflag |= INP_IPV4;
			inp-&gt;inp_vflag &amp;= ~INP_IPV6;
			error = in_pcbbind(inp, (<span class="enscript-type">struct</span> sockaddr *)&amp;sin, p);
			<span class="enscript-keyword">return</span> (error);
		}
	}

	error = in6_pcbbind(inp, nam, p);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">udp6_connect</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">int</span> error;
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NECP</span>) &amp;&amp; <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">FLOW_DIVERT</span>)
	<span class="enscript-type">int</span> should_use_flow_divert = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(NECP) &amp;&amp; defined(FLOW_DIVERT) */</span>

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NECP</span>) &amp;&amp; <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">FLOW_DIVERT</span>)
	should_use_flow_divert = necp_socket_should_use_flow_divert(inp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(NECP) &amp;&amp; defined(FLOW_DIVERT) */</span>

	<span class="enscript-keyword">if</span> ((inp-&gt;inp_flags &amp; IN6P_IPV6_V6ONLY) == 0) {
		<span class="enscript-type">struct</span> sockaddr_in6 *sin6_p;

		sin6_p = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)nam;
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_V4MAPPED(&amp;sin6_p-&gt;sin6_addr)) {
			<span class="enscript-type">struct</span> sockaddr_in sin;

			<span class="enscript-keyword">if</span> (inp-&gt;inp_faddr.s_addr != INADDR_ANY)
				<span class="enscript-keyword">return</span> (EISCONN);
			in6_sin6_2_sin(&amp;sin, sin6_p);
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NECP</span>) &amp;&amp; <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">FLOW_DIVERT</span>)
			<span class="enscript-keyword">if</span> (should_use_flow_divert) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">do_flow_divert</span>;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(NECP) &amp;&amp; defined(FLOW_DIVERT) */</span>
			error = in_pcbconnect(inp, (<span class="enscript-type">struct</span> sockaddr *)&amp;sin,
			    p, IFSCOPE_NONE, NULL);
			<span class="enscript-keyword">if</span> (error == 0) {
				inp-&gt;inp_vflag |= INP_IPV4;
				inp-&gt;inp_vflag &amp;= ~INP_IPV6;
				soisconnected(so);
			}
			<span class="enscript-keyword">return</span> (error);
		}
	}

	<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_faddr))
		<span class="enscript-keyword">return</span> (EISCONN);

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NECP</span>) &amp;&amp; <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">FLOW_DIVERT</span>)
<span class="enscript-reference">do_flow_divert</span>:
	<span class="enscript-keyword">if</span> (should_use_flow_divert) {
		uint32_t fd_ctl_unit = necp_socket_get_flow_divert_control_unit(inp);
		<span class="enscript-keyword">if</span> (fd_ctl_unit &gt; 0) {
			error = flow_divert_pcb_init(so, fd_ctl_unit);
			<span class="enscript-keyword">if</span> (error == 0) {
				error = flow_divert_connect_out(so, nam, p);
			}
		} <span class="enscript-keyword">else</span> {
			error = ENETDOWN;
		}
		<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(NECP) &amp;&amp; defined(FLOW_DIVERT) */</span>

	error = in6_pcbconnect(inp, nam, p);
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-comment">/* should be non mapped addr */</span>
		<span class="enscript-keyword">if</span> (ip6_mapped_addr_on ||
		    (inp-&gt;inp_flags &amp; IN6P_IPV6_V6ONLY) == 0) {
			inp-&gt;inp_vflag &amp;= ~INP_IPV4;
			inp-&gt;inp_vflag |= INP_IPV6;
		}
		soisconnected(so);
		<span class="enscript-keyword">if</span> (inp-&gt;inp_flowhash == 0)
			inp-&gt;inp_flowhash = inp_calc_flowhash(inp);
		<span class="enscript-comment">/* update flowinfo - RFC 6437 */</span>
		<span class="enscript-keyword">if</span> (inp-&gt;inp_flow == 0 &amp;&amp;
		    inp-&gt;in6p_flags &amp; IN6P_AUTOFLOWLABEL) {
			inp-&gt;inp_flow &amp;= ~IPV6_FLOWLABEL_MASK;
			inp-&gt;inp_flow |=
			    (htonl(inp-&gt;inp_flowhash) &amp; IPV6_FLOWLABEL_MASK);
		}
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp6_connectx</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr_list **src_sl,
    <span class="enscript-type">struct</span> sockaddr_list **dst_sl, <span class="enscript-type">struct</span> proc *p, uint32_t ifscope,
    sae_associd_t aid, sae_connid_t *pcid, uint32_t flags, <span class="enscript-type">void</span> *arg,
    uint32_t arglen, <span class="enscript-type">struct</span> uio *uio, user_ssize_t *bytes_written)
{
	<span class="enscript-keyword">return</span> (udp_connectx_common(so, AF_INET6, src_sl, dst_sl,
	    p, ifscope, aid, pcid, flags, arg, arglen, uio, bytes_written));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp6_detach</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> inpcb *inp;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	in6_pcbdetach(inp);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp6_disconnect</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> inpcb *inp;

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		|| (necp_socket_should_use_flow_divert(inp))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
		)
		<span class="enscript-keyword">return</span> (inp == NULL ? EINVAL : EPROTOTYPE);

	<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV4) {
		<span class="enscript-type">struct</span> pr_usrreqs *pru;

		pru = ip_protox[IPPROTO_UDP]-&gt;pr_usrreqs;
		<span class="enscript-keyword">return</span> ((*pru-&gt;pru_disconnect)(so));
	}

	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_faddr))
		<span class="enscript-keyword">return</span> (ENOTCONN);

	in6_pcbdisconnect(inp);

	<span class="enscript-comment">/* reset flow-controlled state, just in case */</span>
	inp_reset_fc_state(inp);

	inp-&gt;in6p_laddr = in6addr_any;
	inp-&gt;in6p_last_outifp = NULL;
	so-&gt;so_state &amp;= ~SS_ISCONNECTED;		<span class="enscript-comment">/* XXX */</span>
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp6_disconnectx</span>(<span class="enscript-type">struct</span> socket *so, sae_associd_t aid, sae_connid_t cid)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cid</span>)
	<span class="enscript-keyword">if</span> (aid != SAE_ASSOCID_ANY &amp;&amp; aid != SAE_ASSOCID_ALL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (udp6_disconnect(so));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp6_send</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> sockaddr *addr,
    <span class="enscript-type">struct</span> mbuf *control, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">int</span> error = 0;
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NECP</span>) &amp;&amp; <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">FLOW_DIVERT</span>)
	<span class="enscript-type">int</span> should_use_flow_divert = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(NECP) &amp;&amp; defined(FLOW_DIVERT) */</span>

	inp = sotoinpcb(so);
	<span class="enscript-keyword">if</span> (inp == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NECP</span>) &amp;&amp; <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">FLOW_DIVERT</span>)
	should_use_flow_divert = necp_socket_should_use_flow_divert(inp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(NECP) &amp;&amp; defined(FLOW_DIVERT) */</span>

	<span class="enscript-keyword">if</span> (addr != NULL) {
		<span class="enscript-keyword">if</span> (addr-&gt;sa_len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-keyword">if</span> (addr-&gt;sa_family != AF_INET6) {
			error = EAFNOSUPPORT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

	<span class="enscript-keyword">if</span> (ip6_mapped_addr_on || (inp-&gt;inp_flags &amp; IN6P_IPV6_V6ONLY) == 0) {
		<span class="enscript-type">int</span> hasv4addr;
		<span class="enscript-type">struct</span> sockaddr_in6 *sin6 = NULL;

		<span class="enscript-keyword">if</span> (addr == NULL) {
			hasv4addr = (inp-&gt;inp_vflag &amp; INP_IPV4);
		} <span class="enscript-keyword">else</span> {
			sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)addr;
			hasv4addr =
			    IN6_IS_ADDR_V4MAPPED(&amp;sin6-&gt;sin6_addr) ? 1 : 0;
		}
		<span class="enscript-keyword">if</span> (hasv4addr) {
			<span class="enscript-type">struct</span> pr_usrreqs *pru;

			<span class="enscript-keyword">if</span> (sin6 != NULL)
				in6_sin6_2_sin_in_sock(addr);
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NECP</span>) &amp;&amp; <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">FLOW_DIVERT</span>)
			<span class="enscript-keyword">if</span> (should_use_flow_divert) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">do_flow_divert</span>;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(NECP) &amp;&amp; defined(FLOW_DIVERT) */</span>
			pru = ip_protox[IPPROTO_UDP]-&gt;pr_usrreqs;
			error = ((*pru-&gt;pru_send)(so, flags, m, addr,
			    control, p));
			<span class="enscript-comment">/* addr will just be freed in sendit(). */</span>
			<span class="enscript-keyword">return</span> (error);
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NECP</span>) &amp;&amp; <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">FLOW_DIVERT</span>)
<span class="enscript-reference">do_flow_divert</span>:
	<span class="enscript-keyword">if</span> (should_use_flow_divert) {
		<span class="enscript-comment">/* Implicit connect */</span>
		<span class="enscript-keyword">return</span> (flow_divert_implicit_data_out(so, flags, m, addr, control, p));
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* defined(NECP) &amp;&amp; defined(FLOW_DIVERT) */</span>

	<span class="enscript-keyword">return</span> (udp6_output(inp, m, addr, control, p));

<span class="enscript-reference">bad</span>:
	VERIFY(error != 0);

	<span class="enscript-keyword">if</span> (m != NULL)
		m_freem(m);
	<span class="enscript-keyword">if</span> (control != NULL)
		m_freem(control);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Checksum extended UDP header and data.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">udp6_input_checksum</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> udphdr *uh, <span class="enscript-type">int</span> off, <span class="enscript-type">int</span> ulen)
{
	<span class="enscript-type">struct</span> ifnet *ifp = m-&gt;m_pkthdr.rcvif;
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

	<span class="enscript-keyword">if</span> (uh-&gt;uh_sum == 0) {
		<span class="enscript-comment">/* UDP/IPv6 checksum is mandatory (RFC2460) */</span>
		udpstat.udps_nosum++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">badsum</span>;
	}

	<span class="enscript-keyword">if</span> ((hwcksum_rx || (ifp-&gt;if_flags &amp; IFF_LOOPBACK) ||
	    (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)) &amp;&amp;
	    (m-&gt;m_pkthdr.csum_flags &amp; CSUM_DATA_VALID)) {
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.csum_flags &amp; CSUM_PSEUDO_HDR) {
			uh-&gt;uh_sum = m-&gt;m_pkthdr.csum_rx_val;
		} <span class="enscript-keyword">else</span> {
			uint16_t sum = m-&gt;m_pkthdr.csum_rx_val;
			uint16_t start = m-&gt;m_pkthdr.csum_rx_start;

			<span class="enscript-comment">/*
			 * Perform 1's complement adjustment of octets
			 * that got included/excluded in the hardware-
			 * calculated checksum value.
			 */</span>
			<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.csum_flags &amp; CSUM_PARTIAL) &amp;&amp;
			    start != off) {
				uint16_t s, d;

				<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_src)) {
					s = ip6-&gt;ip6_src.s6_addr16[1];
					ip6-&gt;ip6_src.s6_addr16[1] = 0 ;
				}
				<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_dst)) {
					d = ip6-&gt;ip6_dst.s6_addr16[1];
					ip6-&gt;ip6_dst.s6_addr16[1] = 0;
				}

				<span class="enscript-comment">/* callee folds in sum */</span>
				sum = m_adj_sum16(m, start, off, sum);

				<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_src))
					ip6-&gt;ip6_src.s6_addr16[1] = s;
				<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_dst))
					ip6-&gt;ip6_dst.s6_addr16[1] = d;
			}

			uh-&gt;uh_sum = in6_pseudo(&amp;ip6-&gt;ip6_src, &amp;ip6-&gt;ip6_dst,
			    sum + htonl(ulen + IPPROTO_UDP));
		}
		uh-&gt;uh_sum ^= 0xffff;
	} <span class="enscript-keyword">else</span> {
		udp_in6_cksum_stats(ulen);
		uh-&gt;uh_sum = in6_cksum(m, IPPROTO_UDP, off, ulen);
	}

	<span class="enscript-keyword">if</span> (uh-&gt;uh_sum != 0) {
<span class="enscript-reference">badsum</span>:
		udpstat.udps_badsum++;
		IF_UDP_STATINC(ifp, badchksum);
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">return</span> (0);
}
</pre>
<hr />
</body></html>