<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ip6_input.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ip6_input.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ip_input.c	8.2 (Berkeley) 1/4/94
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/random/randomdev.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_protocol.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/init.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_perf.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_icmp.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/kpi_ipfilter_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_ifattach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/scope6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6protosw.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec6.h&gt;</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> ipsec_bypass;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFW2</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_fw.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFW2 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_fw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_dummynet.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

<span class="enscript-comment">/* we need it for NLOOP. */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;loop.h&quot;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pfvar.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

<span class="enscript-type">struct</span> ip6protosw *ip6_protox[IPPROTO_MAX];

<span class="enscript-type">static</span> lck_grp_attr_t	*in6_ifaddr_rwlock_grp_attr;
<span class="enscript-type">static</span> lck_grp_t	*in6_ifaddr_rwlock_grp;
<span class="enscript-type">static</span> lck_attr_t	*in6_ifaddr_rwlock_attr;
<span class="enscript-function-name">decl_lck_rw_data</span>(, in6_ifaddr_rwlock);

<span class="enscript-comment">/* Protected by in6_ifaddr_rwlock */</span>
<span class="enscript-type">struct</span> in6_ifaddr *in6_ifaddrs = NULL;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IN6_IFSTAT_REQUIRE_ALIGNED_64</span>(f)	\
	_CASSERT(!(offsetof(<span class="enscript-type">struct</span> in6_ifstat, f) % <span class="enscript-keyword">sizeof</span> (uint64_t)))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ICMP6_IFSTAT_REQUIRE_ALIGNED_64</span>(f)	\
	_CASSERT(!(offsetof(<span class="enscript-type">struct</span> icmp6_ifstat, f) % <span class="enscript-keyword">sizeof</span> (uint64_t)))

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFW2</span>
<span class="enscript-comment">/* firewall hooks */</span>
ip6_fw_chk_t *ip6_fw_chk_ptr;
ip6_fw_ctl_t *ip6_fw_ctl_ptr;
<span class="enscript-type">int</span> ip6_fw_enable = 1;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFW2 */</span>

<span class="enscript-type">struct</span> ip6stat ip6stat;

<span class="enscript-function-name">decl_lck_mtx_data</span>(, proxy6_lock);
<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, dad6_mutex_data);
<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, nd6_mutex_data);
<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, prefix6_mutex_data);
lck_mtx_t		*dad6_mutex = &amp;dad6_mutex_data;
lck_mtx_t		*nd6_mutex = &amp;nd6_mutex_data;
lck_mtx_t		*prefix6_mutex = &amp;prefix6_mutex_data;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">ENABLE_ADDRSEL</span>
<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, addrsel_mutex_data);
lck_mtx_t		*addrsel_mutex = &amp;addrsel_mutex_data;
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> lck_attr_t	*ip6_mutex_attr;
<span class="enscript-type">static</span> lck_grp_t	*ip6_mutex_grp;
<span class="enscript-type">static</span> lck_grp_attr_t	*ip6_mutex_grp_attr;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> loopattach_done;
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">addrsel_policy_init</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_reset_ip6_input_stats SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_ip6_input_measure_bins SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_ip6_input_getperf SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ip6_init_delayed</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip6_hopopts_input</span>(u_int32_t *, u_int32_t *, <span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">int</span> *);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NSTF</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">stfattach</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NSTF */</span>

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_inet6_ip6);

<span class="enscript-type">int</span> ip6_doscopedroute = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ip6, OID_AUTO, scopedroute,
	CTLFLAG_RD | CTLFLAG_LOCKED, &amp;ip6_doscopedroute, 0,
	<span class="enscript-string">&quot;Enable IPv6 scoped routing&quot;</span>);

<span class="enscript-type">static</span> uint32_t ip6_adj_clear_hwcksum = 0;
<span class="enscript-function-name">SYSCTL_UINT</span>(_net_inet6_ip6, OID_AUTO, adj_clear_hwcksum,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip6_adj_clear_hwcksum, 0,
	<span class="enscript-string">&quot;Invalidate hwcksum info when adjusting length&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip6_input_measure = 0;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet6_ip6, OID_AUTO, input_perf,
	CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ip6_input_measure, 0, sysctl_reset_ip6_input_stats, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Do time measurement&quot;</span>);

<span class="enscript-type">static</span> uint64_t ip6_input_measure_bins = 0;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet6_ip6, OID_AUTO, input_perf_bins,
	CTLTYPE_QUAD | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip6_input_measure_bins, 0,
	sysctl_ip6_input_measure_bins, <span class="enscript-string">&quot;I&quot;</span>,
	<span class="enscript-string">&quot;bins for chaining performance data histogram&quot;</span>);

<span class="enscript-type">static</span> net_perf_t net_perf;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet6_ip6, OID_AUTO, input_perf_data,
	CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED,
	0, 0, sysctl_ip6_input_getperf, <span class="enscript-string">&quot;S,net_perf&quot;</span>,
	<span class="enscript-string">&quot;IP6 input performance data (struct net_perf, net/net_perf.h)&quot;</span>);

<span class="enscript-comment">/*
 * On platforms which require strict alignment (currently for anything but
 * i386 or x86_64), check if the IP header pointer is 32-bit aligned; if not,
 * copy the contents of the mbuf chain into a new chain, and free the original
 * one.  Create some head room in the first mbuf of the new chain, in case
 * it's needed later on.
 *
 * RFC 2460 says that IPv6 headers are 64-bit aligned, but network interfaces
 * mostly align to 32-bit boundaries.  Care should be taken never to use 64-bit
 * load/store operations on the fields in IPv6 headers.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IP6_HDR_ALIGNMENT_FIXUP</span>(_m, _ifp, _action) do { } while (0)
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !__i386__ &amp;&amp; !__x86_64__ */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IP6_HDR_ALIGNMENT_FIXUP</span>(_m, _ifp, _action) do {			\
	<span class="enscript-keyword">if</span> (!IP6_HDR_ALIGNED_P(mtod(_m, caddr_t))) {			\
		<span class="enscript-type">struct</span> mbuf *_n;					\
		<span class="enscript-type">struct</span> ifnet *__ifp = (_ifp);				\
		atomic_add_64(&amp;(__ifp)-&gt;if_alignerrs, 1);		\
		<span class="enscript-keyword">if</span> (((_m)-&gt;m_flags &amp; M_PKTHDR) &amp;&amp;			\
		    (_m)-&gt;m_pkthdr.pkt_hdr != NULL)			\
			(_m)-&gt;m_pkthdr.pkt_hdr = NULL;			\
		_n = m_defrag_offset(_m, max_linkhdr, M_NOWAIT);	\
		<span class="enscript-keyword">if</span> (_n == NULL) {					\
			ip6stat.ip6s_toosmall++;			\
			m_freem(_m);					\
			(_m) = NULL;					\
			_action;					\
		} <span class="enscript-keyword">else</span> {						\
			VERIFY(_n != (_m));				\
			(_m) = _n;					\
		}							\
	}								\
} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__i386__ &amp;&amp; !__x86_64__ */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_proto_input</span>(protocol_family_t protocol, mbuf_t packet)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">protocol</span>)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-type">struct</span> timeval start_tv;
	<span class="enscript-keyword">if</span> (ip6_input_measure)
		net_perf_start_time(&amp;net_perf, &amp;start_tv);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
	ip6_input(packet);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">if</span> (ip6_input_measure) {
		net_perf_measure_time(&amp;net_perf, &amp;start_tv, 1);
		net_perf_histogram(&amp;net_perf, 1);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET */</span>
}

<span class="enscript-comment">/*
 * IP6 initialization: fill in IP6 protocol switch table.
 * All protocols not implemented in kernel go to raw IP6 protocol handler.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_init</span>(<span class="enscript-type">struct</span> ip6protosw *pp, <span class="enscript-type">struct</span> domain *dp)
{
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip6_initialized = 0;
	<span class="enscript-type">struct</span> protosw *pr;
	<span class="enscript-type">struct</span> timeval tv;
	<span class="enscript-type">int</span> i;
	domain_unguard_t unguard;

	domain_proto_mtx_lock_assert_held();
	VERIFY((pp-&gt;pr_flags &amp; (PR_INITIALIZED|PR_ATTACHED)) == PR_ATTACHED);

	_CASSERT((<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) +
	    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> icmp6_hdr)) &lt;= _MHLEN);

	<span class="enscript-keyword">if</span> (ip6_initialized)
		<span class="enscript-keyword">return</span>;
	ip6_initialized = 1;

	PE_parse_boot_argn(<span class="enscript-string">&quot;net.inet6.ip6.scopedroute&quot;</span>, &amp;ip6_doscopedroute,
	    <span class="enscript-keyword">sizeof</span> (ip6_doscopedroute));

	pr = pffindproto_locked(PF_INET6, IPPROTO_RAW, SOCK_RAW);
	<span class="enscript-keyword">if</span> (pr == NULL) {
		panic(<span class="enscript-string">&quot;%s: Unable to find [PF_INET6,IPPROTO_RAW,SOCK_RAW]\n&quot;</span>,
		    __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/* Initialize the entire ip6_protox[] array to IPPROTO_RAW. */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; IPPROTO_MAX; i++)
		ip6_protox[i] = (<span class="enscript-type">struct</span> ip6protosw *)pr;
	<span class="enscript-comment">/*
	 * Cycle through IP protocols and put them into the appropriate place
	 * in ip6_protox[], skipping protocols IPPROTO_{IP,RAW}.
	 */</span>
	VERIFY(dp == inet6domain &amp;&amp; dp-&gt;dom_family == PF_INET6);
	TAILQ_FOREACH(pr, &amp;dp-&gt;dom_protosw, pr_entry) {
		VERIFY(pr-&gt;pr_domain == dp);
		<span class="enscript-keyword">if</span> (pr-&gt;pr_protocol != 0 &amp;&amp; pr-&gt;pr_protocol != IPPROTO_RAW) {
			<span class="enscript-comment">/* Be careful to only index valid IP protocols. */</span>
			<span class="enscript-keyword">if</span> (pr-&gt;pr_protocol &lt; IPPROTO_MAX)
				ip6_protox[pr-&gt;pr_protocol] =
				    (<span class="enscript-type">struct</span> ip6protosw *)pr;
		}
	}

	ip6_mutex_grp_attr  = lck_grp_attr_alloc_init();

	ip6_mutex_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;ip6&quot;</span>, ip6_mutex_grp_attr);
	ip6_mutex_attr = lck_attr_alloc_init();

	lck_mtx_init(dad6_mutex, ip6_mutex_grp, ip6_mutex_attr);
	lck_mtx_init(nd6_mutex, ip6_mutex_grp, ip6_mutex_attr);
	lck_mtx_init(prefix6_mutex, ip6_mutex_grp, ip6_mutex_attr);
	scope6_init(ip6_mutex_grp, ip6_mutex_attr);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">ENABLE_ADDRSEL</span>
	lck_mtx_init(addrsel_mutex, ip6_mutex_grp, ip6_mutex_attr);
#<span class="enscript-reference">endif</span>

	lck_mtx_init(&amp;proxy6_lock, ip6_mutex_grp, ip6_mutex_attr);

	in6_ifaddr_rwlock_grp_attr = lck_grp_attr_alloc_init();
	in6_ifaddr_rwlock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;in6_ifaddr_rwlock&quot;</span>,
	    in6_ifaddr_rwlock_grp_attr);
	in6_ifaddr_rwlock_attr = lck_attr_alloc_init();
	lck_rw_init(&amp;in6_ifaddr_rwlock, in6_ifaddr_rwlock_grp,
	    in6_ifaddr_rwlock_attr);

	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_receive);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_hdrerr);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_toobig);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_noroute);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_addrerr);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_protounknown);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_truncated);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_discard);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_deliver);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_forward);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_request);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_discard);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_fragok);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_fragfail);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_fragcreat);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_reass_reqd);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_reass_ok);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_reass_fail);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_mcast);
	IN6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_mcast);

	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_msg);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_error);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_dstunreach);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_adminprohib);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_timeexceed);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_paramprob);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_pkttoobig);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_echo);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_echoreply);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_routersolicit);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_routeradvert);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_neighborsolicit);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_neighboradvert);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_redirect);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_mldquery);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_mldreport);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_in_mlddone);

	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_msg);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_error);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_dstunreach);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_adminprohib);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_timeexceed);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_paramprob);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_pkttoobig);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_echo);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_echoreply);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_routersolicit);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_routeradvert);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_neighborsolicit);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_neighboradvert);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_redirect);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_mldquery);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_mldreport);
	ICMP6_IFSTAT_REQUIRE_ALIGNED_64(ifs6_out_mlddone);

	getmicrotime(&amp;tv);
	ip6_desync_factor =
	    (RandomULong() ^ tv.tv_usec) % MAX_TEMP_DESYNC_FACTOR;

	in6_ifaddr_init();
	ip6_moptions_init();
	nd6_init();
	frag6_init();
	icmp6_init(NULL, dp);
	addrsel_policy_init();

	<span class="enscript-comment">/*
	 * P2P interfaces often route the local address to the loopback
	 * interface. At this point, lo0 hasn't been initialized yet, which
	 * means that we need to delay the IPv6 configuration of lo0.
	 */</span>
	net_init_add(ip6_init_delayed);

	unguard = domain_unguard_deploy();
	i = proto_register_input(PF_INET6, ip6_proto_input, NULL, 0);
	<span class="enscript-keyword">if</span> (i != 0) {
		panic(<span class="enscript-string">&quot;%s: failed to register PF_INET6 protocol: %d\n&quot;</span>,
		    __func__, i);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	domain_unguard_release(unguard);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_init_delayed</span>(<span class="enscript-type">void</span>)
{
	(<span class="enscript-type">void</span>) in6_ifattach_prelim(lo_ifp);

	<span class="enscript-comment">/* timer for regeneranation of temporary addresses randomize ID */</span>
	timeout(in6_tmpaddrtimer, NULL,
	    (ip6_temp_preferred_lifetime - ip6_desync_factor -
	    ip6_temp_regen_advance) * hz);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NSTF</span>
	stfattach();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NSTF */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_input</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">int</span> off = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr), nest;
	u_int32_t plen;
	u_int32_t rtalert = ~0;
	<span class="enscript-type">int</span> nxt = 0, ours = 0;
	<span class="enscript-type">struct</span> ifnet *inifp, *deliverifp = NULL;
	ipfilter_t inject_ipfref = NULL;
	<span class="enscript-type">int</span> seen;
	<span class="enscript-type">struct</span> in6_ifaddr *ia6 = NULL;
	<span class="enscript-type">struct</span> sockaddr_in6 *dst6;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-type">struct</span> m_tag *tag;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
	<span class="enscript-type">struct</span> {
		<span class="enscript-type">struct</span> route_in6 rin6;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-type">struct</span> ip_fw_args args;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
	} ip6ibz;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">rin6</span>	ip6ibz.rin6
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">args</span>	ip6ibz.args

	<span class="enscript-comment">/* zero out {rin6, args} */</span>
	bzero(&amp;ip6ibz, <span class="enscript-keyword">sizeof</span> (ip6ibz));

	<span class="enscript-comment">/*
	 * Check if the packet we received is valid after interface filter
	 * processing
	 */</span>
	MBUF_INPUT_CHECK(m, m-&gt;m_pkthdr.rcvif);
	inifp = m-&gt;m_pkthdr.rcvif;
	VERIFY(inifp != NULL);

	<span class="enscript-comment">/* Perform IP header alignment fixup, if needed */</span>
	IP6_HDR_ALIGNMENT_FIXUP(m, inifp, <span class="enscript-keyword">return</span>);

	m-&gt;m_pkthdr.pkt_flags &amp;= ~PKTF_FORWARDED;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-comment">/*
	 * should the inner packet be considered authentic?
	 * see comment in ah4_input().
	 */</span>
	m-&gt;m_flags &amp;= ~M_AUTHIPHDR;
	m-&gt;m_flags &amp;= ~M_AUTHIPDGM;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

	<span class="enscript-comment">/*
	 * make sure we don't have onion peering information into m_aux.
	 */</span>
	ip6_delaux(m);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-keyword">if</span> ((tag = m_tag_locate(m, KERNEL_MODULE_TAG_ID,
	    KERNEL_TAG_TYPE_DUMMYNET, NULL)) != NULL) {
		<span class="enscript-type">struct</span> dn_pkt_tag	*dn_tag;

		dn_tag = (<span class="enscript-type">struct</span> dn_pkt_tag *)(tag+1);

		args.fwa_pf_rule = dn_tag-&gt;dn_pf_rule;

		m_tag_delete(m, tag);
	}

	<span class="enscript-keyword">if</span> (args.fwa_pf_rule) {
		ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *); <span class="enscript-comment">/* In case PF got disabled */</span>

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">check_with_pf</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

	<span class="enscript-comment">/*
	 * No need to proccess packet twice if we've already seen it.
	 */</span>
	inject_ipfref = ipf_get_inject_filter(m);
	<span class="enscript-keyword">if</span> (inject_ipfref != NULL) {
		ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
		nxt = ip6-&gt;ip6_nxt;
		seen = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">injectit</span>;
	} <span class="enscript-keyword">else</span> {
		seen = 1;
	}

	<span class="enscript-comment">/*
	 * mbuf statistics
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_EXT) {
		<span class="enscript-keyword">if</span> (m-&gt;m_next != NULL)
			ip6stat.ip6s_mext2m++;
		<span class="enscript-keyword">else</span>
			ip6stat.ip6s_mext1++;
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M2MMAX</span>	(sizeof (ip6stat.ip6s_m2m) / sizeof (ip6stat.ip6s_m2m[0]))
		<span class="enscript-keyword">if</span> (m-&gt;m_next != NULL) {
			<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP) {
				<span class="enscript-comment">/* XXX */</span>
				ip6stat.ip6s_m2m[ifnet_index(lo_ifp)]++;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inifp-&gt;if_index &lt; M2MMAX) {
				ip6stat.ip6s_m2m[inifp-&gt;if_index]++;
			} <span class="enscript-keyword">else</span> {
				ip6stat.ip6s_m2m[0]++;
			}
		} <span class="enscript-keyword">else</span> {
			ip6stat.ip6s_m1++;
		}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">M2MMAX</span>
	}

	<span class="enscript-comment">/*
	 * Drop the packet if IPv6 operation is disabled on the interface.
	 */</span>
	<span class="enscript-keyword">if</span> (inifp-&gt;if_eflags &amp; IFEF_IPV6_DISABLED)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	in6_ifstat_inc_na(inifp, ifs6_in_receive);
	ip6stat.ip6s_total++;

	<span class="enscript-comment">/*
	 * L2 bridge code and some other code can return mbuf chain
	 * that does not conform to KAME requirement.  too bad.
	 * XXX: fails to join if interface MTU &gt; MCLBYTES.  jumbogram?
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_next != NULL &amp;&amp; m-&gt;m_pkthdr.len &lt; MCLBYTES) {
		<span class="enscript-type">struct</span> mbuf *n;

		MGETHDR(n, M_DONTWAIT, MT_HEADER);	<span class="enscript-comment">/* MAC-OK */</span>
		<span class="enscript-keyword">if</span> (n)
			M_COPY_PKTHDR(n, m);
		<span class="enscript-keyword">if</span> (n &amp;&amp; m-&gt;m_pkthdr.len &gt; MHLEN) {
			MCLGET(n, M_DONTWAIT);
			<span class="enscript-keyword">if</span> ((n-&gt;m_flags &amp; M_EXT) == 0) {
				m_freem(n);
				n = NULL;
			}
		}
		<span class="enscript-keyword">if</span> (n == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

		m_copydata(m, 0, m-&gt;m_pkthdr.len, mtod(n, caddr_t));
		n-&gt;m_len = m-&gt;m_pkthdr.len;
		m_freem(m);
		m = n;
	}
	IP6_EXTHDR_CHECK(m, 0, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr), { <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>; });

	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr)) {
		<span class="enscript-keyword">if</span> ((m = m_pullup(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr))) == 0) {
			ip6stat.ip6s_toosmall++;
			in6_ifstat_inc(inifp, ifs6_in_hdrerr);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

	<span class="enscript-keyword">if</span> ((ip6-&gt;ip6_vfc &amp; IPV6_VERSION_MASK) != IPV6_VERSION) {
		ip6stat.ip6s_badvers++;
		in6_ifstat_inc(inifp, ifs6_in_hdrerr);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	ip6stat.ip6s_nxthist[ip6-&gt;ip6_nxt]++;

	<span class="enscript-comment">/*
	 * Check against address spoofing/corruption.
	 */</span>
	<span class="enscript-keyword">if</span> (!(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP) &amp;&amp;
	    IN6_IS_ADDR_LOOPBACK(&amp;ip6-&gt;ip6_src)) {
		ip6stat.ip6s_badscope++;
		in6_ifstat_inc(inifp, ifs6_in_addrerr);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_src) ||
	    IN6_IS_ADDR_UNSPECIFIED(&amp;ip6-&gt;ip6_dst)) {
		<span class="enscript-comment">/*
		 * XXX: &quot;badscope&quot; is not very suitable for a multicast source.
		 */</span>
		ip6stat.ip6s_badscope++;
		in6_ifstat_inc(inifp, ifs6_in_addrerr);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MC_INTFACELOCAL(&amp;ip6-&gt;ip6_dst) &amp;&amp;
	    !(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)) {
		<span class="enscript-comment">/*
		 * In this case, the packet should come from the loopback
		 * interface.  However, we cannot just check the if_flags,
		 * because ip6_mloopback() passes the &quot;actual&quot; interface
		 * as the outgoing/incoming interface.
		 */</span>
		ip6stat.ip6s_badscope++;
		in6_ifstat_inc(inifp, ifs6_in_addrerr);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/*
	 * The following check is not documented in specs.  A malicious
	 * party may be able to use IPv4 mapped addr to confuse tcp/udp stack
	 * and bypass security checks (act as if it was from 127.0.0.1 by using
	 * IPv6 src ::ffff:127.0.0.1).  Be cautious.
	 *
	 * This check chokes if we are in an SIIT cloud.  As none of BSDs
	 * support IPv4-less kernel compilation, we cannot support SIIT
	 * environment at all.  So, it makes more sense for us to reject any
	 * malicious packets for non-SIIT environment, than try to do a
	 * partial support for SIIT environment.
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_V4MAPPED(&amp;ip6-&gt;ip6_src) ||
	    IN6_IS_ADDR_V4MAPPED(&amp;ip6-&gt;ip6_dst)) {
		ip6stat.ip6s_badscope++;
		in6_ifstat_inc(inifp, ifs6_in_addrerr);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/*
	 * Reject packets with IPv4 compatible addresses (auto tunnel).
	 *
	 * The code forbids auto tunnel relay case in RFC1933 (the check is
	 * stronger than RFC1933).  We may want to re-enable it if mech-xx
	 * is revised to forbid relaying case.
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_V4COMPAT(&amp;ip6-&gt;ip6_src) ||
	    IN6_IS_ADDR_V4COMPAT(&amp;ip6-&gt;ip6_dst)) {
		ip6stat.ip6s_badscope++;
		in6_ifstat_inc(inifp, ifs6_in_addrerr);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFW2</span>
	<span class="enscript-comment">/*
	 * Check with the firewall...
	 */</span>
	<span class="enscript-keyword">if</span> (ip6_fw_enable &amp;&amp; ip6_fw_chk_ptr) {
		u_short port = 0;
		<span class="enscript-comment">/* If ipfw says divert, we have to just drop packet */</span>
		<span class="enscript-comment">/* use port as a dummy argument */</span>
		<span class="enscript-keyword">if</span> ((*ip6_fw_chk_ptr)(&amp;ip6, NULL, &amp;port, &amp;m)) {
			m_freem(m);
			m = NULL;
		}
		<span class="enscript-keyword">if</span> (!m)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFW2 */</span>

	<span class="enscript-comment">/*
	 * Naively assume we can attribute inbound data to the route we would
	 * use to send to this destination. Asymetric routing breaks this
	 * assumption, but it still allows us to account for traffic from
	 * a remote node in the routing table.
	 * this has a very significant performance impact so we bypass
	 * if nstat_collect is disabled. We may also bypass if the
	 * protocol is tcp in the future because tcp will have a route that
	 * we can use to attribute the data to. That does mean we would not
	 * account for forwarded tcp traffic.
	 */</span>
	<span class="enscript-keyword">if</span> (nstat_collect) {
		<span class="enscript-type">struct</span> rtentry *rte =
		    ifnet_cached_rtlookup_inet6(inifp, &amp;ip6-&gt;ip6_src);
		<span class="enscript-keyword">if</span> (rte != NULL) {
			nstat_route_rx(rte, 1, m-&gt;m_pkthdr.len, 0);
			rtfree(rte);
		}
	}

	<span class="enscript-comment">/* for consistency */</span>
	m-&gt;m_pkthdr.pkt_proto = ip6-&gt;ip6_nxt;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
<span class="enscript-reference">check_with_pf</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
	<span class="enscript-comment">/* Invoke inbound packet filter */</span>
	<span class="enscript-keyword">if</span> (PF_IS_ENABLED) {
		<span class="enscript-type">int</span> error;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		error = pf_af_hook(inifp, NULL, &amp;m, AF_INET6, TRUE, &amp;args);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !DUMMYNET */</span>
		error = pf_af_hook(inifp, NULL, &amp;m, AF_INET6, TRUE, NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !DUMMYNET */</span>
		<span class="enscript-keyword">if</span> (error != 0 || m == NULL) {
			<span class="enscript-keyword">if</span> (m != NULL) {
				panic(<span class="enscript-string">&quot;%s: unexpected packet %p\n&quot;</span>,
				    __func__, m);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}
			<span class="enscript-comment">/* Already freed by callee */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

	<span class="enscript-comment">/* drop packets if interface ID portion is already filled */</span>
	<span class="enscript-keyword">if</span> (!(inifp-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp;
	    !(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)) {
		<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;ip6-&gt;ip6_src) &amp;&amp;
		    ip6-&gt;ip6_src.s6_addr16[1]) {
			ip6stat.ip6s_badscope++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_dst) &amp;&amp;
		    ip6-&gt;ip6_dst.s6_addr16[1]) {
			ip6stat.ip6s_badscope++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_IFAINFO) {
		<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;ip6-&gt;ip6_src))
			ip6-&gt;ip6_src.s6_addr16[1] =
			    htons(m-&gt;m_pkthdr.src_ifindex);
		<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_dst))
			ip6-&gt;ip6_dst.s6_addr16[1] =
			    htons(m-&gt;m_pkthdr.dst_ifindex);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;ip6-&gt;ip6_src))
			ip6-&gt;ip6_src.s6_addr16[1] = htons(inifp-&gt;if_index);
		<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_EMBED(&amp;ip6-&gt;ip6_dst))
			ip6-&gt;ip6_dst.s6_addr16[1] = htons(inifp-&gt;if_index);
	}

	<span class="enscript-comment">/*
	 * Multicast check
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst)) {
		<span class="enscript-type">struct</span>	in6_multi *in6m = NULL;

		in6_ifstat_inc_na(inifp, ifs6_in_mcast);
		<span class="enscript-comment">/*
		 * See if we belong to the destination multicast group on the
		 * arrival interface.
		 */</span>
		in6_multihead_lock_shared();
		IN6_LOOKUP_MULTI(&amp;ip6-&gt;ip6_dst, inifp, in6m);
		in6_multihead_lock_done();
		<span class="enscript-keyword">if</span> (in6m != NULL) {
			IN6M_REMREF(in6m);
			ours = 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!nd6_prproxy) {
			ip6stat.ip6s_notmember++;
			ip6stat.ip6s_cantforward++;
			in6_ifstat_inc(inifp, ifs6_in_discard);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		deliverifp = inifp;
		VERIFY(ia6 == NULL);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">hbhcheck</span>;
	}

	<span class="enscript-comment">/*
	 * Unicast check
	 *
	 * Fast path: see if the target is ourselves.
	 */</span>
	lck_rw_lock_shared(&amp;in6_ifaddr_rwlock);
	<span class="enscript-keyword">for</span> (ia6 = in6_ifaddrs; ia6 != NULL; ia6 = ia6-&gt;ia_next) {
		<span class="enscript-comment">/*
		 * No reference is held on the address, as we just need
		 * to test for a few things while holding the RW lock.
		 */</span>
		<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(&amp;ia6-&gt;ia_addr.sin6_addr, &amp;ip6-&gt;ip6_dst))
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (ia6 != NULL) {
		<span class="enscript-comment">/*
		 * For performance, test without acquiring the address lock;
		 * a lot of things in the address are set once and never
		 * changed (e.g. ia_ifp.)
		 */</span>
		<span class="enscript-keyword">if</span> (!(ia6-&gt;ia6_flags &amp; IN6_IFF_NOTREADY)) {
			<span class="enscript-comment">/* this address is ready */</span>
			ours = 1;
			deliverifp = ia6-&gt;ia_ifp;
			<span class="enscript-comment">/*
			 * record dst address information into mbuf.
			 */</span>
			(<span class="enscript-type">void</span>) ip6_setdstifaddr_info(m, 0, ia6);
			lck_rw_done(&amp;in6_ifaddr_rwlock);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">hbhcheck</span>;
		}
		lck_rw_done(&amp;in6_ifaddr_rwlock);
		ia6 = NULL;
		<span class="enscript-comment">/* address is not ready, so discard the packet. */</span>
		nd6log((LOG_INFO, <span class="enscript-string">&quot;%s: packet to an unready address %s-&gt;%s\n&quot;</span>,
		    __func__, ip6_sprintf(&amp;ip6-&gt;ip6_src),
		    ip6_sprintf(&amp;ip6-&gt;ip6_dst)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	lck_rw_done(&amp;in6_ifaddr_rwlock);

	<span class="enscript-comment">/*
	 * Slow path: route lookup.
	 */</span>
	dst6 = SIN6(&amp;rin6.ro_dst);
	dst6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
	dst6-&gt;sin6_family = AF_INET6;
	dst6-&gt;sin6_addr = ip6-&gt;ip6_dst;

	rtalloc_scoped_ign((<span class="enscript-type">struct</span> route *)&amp;rin6,
	    RTF_PRCLONING, IFSCOPE_NONE);
	<span class="enscript-keyword">if</span> (rin6.ro_rt != NULL)
		RT_LOCK_SPIN(rin6.ro_rt);

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">rt6_key</span>(r) (SIN6((r)-&gt;rt_nodes-&gt;rn_key))

	<span class="enscript-comment">/*
	 * Accept the packet if the forwarding interface to the destination
	 * according to the routing table is the loopback interface,
	 * unless the associated route has a gateway.
	 * Note that this approach causes to accept a packet if there is a
	 * route to the loopback interface for the destination of the packet.
	 * But we think it's even useful in some situations, e.g. when using
	 * a special daemon which wants to intercept the packet.
	 *
	 * XXX: some OSes automatically make a cloned route for the destination
	 * of an outgoing packet.  If the outgoing interface of the packet
	 * is a loopback one, the kernel would consider the packet to be
	 * accepted, even if we have no such address assinged on the interface.
	 * We check the cloned flag of the route entry to reject such cases,
	 * assuming that route entries for our own addresses are not made by
	 * cloning (it should be true because in6_addloop explicitly installs
	 * the host route).  However, we might have to do an explicit check
	 * while it would be less efficient.  Or, should we rather install a
	 * reject route for such a case?
	 */</span>
	<span class="enscript-keyword">if</span> (rin6.ro_rt != NULL &amp;&amp;
	    (rin6.ro_rt-&gt;rt_flags &amp; (RTF_HOST|RTF_GATEWAY)) == RTF_HOST &amp;&amp;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">RTF_WASCLONED</span>
	    !(rin6.ro_rt-&gt;rt_flags &amp; RTF_WASCLONED) &amp;&amp;
#<span class="enscript-reference">endif</span>
	    rin6.ro_rt-&gt;rt_ifp-&gt;if_type == IFT_LOOP) {
		ia6 = (<span class="enscript-type">struct</span> in6_ifaddr *)rin6.ro_rt-&gt;rt_ifa;
		<span class="enscript-comment">/*
		 * Packets to a tentative, duplicated, or somehow invalid
		 * address must not be accepted.
		 *
		 * For performance, test without acquiring the address lock;
		 * a lot of things in the address are set once and never
		 * changed (e.g. ia_ifp.)
		 */</span>
		<span class="enscript-keyword">if</span> (!(ia6-&gt;ia6_flags &amp; IN6_IFF_NOTREADY)) {
			<span class="enscript-comment">/* this address is ready */</span>
			ours = 1;
			deliverifp = ia6-&gt;ia_ifp;	<span class="enscript-comment">/* correct? */</span>
			<span class="enscript-comment">/*
			 * record dst address information into mbuf.
			 */</span>
			(<span class="enscript-type">void</span>) ip6_setdstifaddr_info(m, 0, ia6);
			RT_UNLOCK(rin6.ro_rt);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">hbhcheck</span>;
		}
		RT_UNLOCK(rin6.ro_rt);
		ia6 = NULL;
		<span class="enscript-comment">/* address is not ready, so discard the packet. */</span>
		nd6log((LOG_INFO, <span class="enscript-string">&quot;%s: packet to an unready address %s-&gt;%s\n&quot;</span>,
		    __func__, ip6_sprintf(&amp;ip6-&gt;ip6_src),
		    ip6_sprintf(&amp;ip6-&gt;ip6_dst)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> (rin6.ro_rt != NULL)
		RT_UNLOCK(rin6.ro_rt);

	<span class="enscript-comment">/*
	 * Now there is no reason to process the packet if it's not our own
	 * and we're not a router.
	 */</span>
	<span class="enscript-keyword">if</span> (!ip6_forwarding) {
		ip6stat.ip6s_cantforward++;
		in6_ifstat_inc(inifp, ifs6_in_discard);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

<span class="enscript-reference">hbhcheck</span>:
	<span class="enscript-comment">/*
	 * record dst address information into mbuf, if we don't have one yet.
	 * note that we are unable to record it, if the address is not listed
	 * as our interface address (e.g. multicast addresses, etc.)
	 */</span>
	<span class="enscript-keyword">if</span> (deliverifp != NULL &amp;&amp; ia6 == NULL) {
		ia6 = in6_ifawithifp(deliverifp, &amp;ip6-&gt;ip6_dst);
		<span class="enscript-keyword">if</span> (ia6 != NULL) {
			(<span class="enscript-type">void</span>) ip6_setdstifaddr_info(m, 0, ia6);
			IFA_REMREF(&amp;ia6-&gt;ia_ifa);
		}
	}

	<span class="enscript-comment">/*
	 * Process Hop-by-Hop options header if it's contained.
	 * m may be modified in ip6_hopopts_input().
	 * If a JumboPayload option is included, plen will also be modified.
	 */</span>
	plen = (u_int32_t)ntohs(ip6-&gt;ip6_plen);
	<span class="enscript-keyword">if</span> (ip6-&gt;ip6_nxt == IPPROTO_HOPOPTS) {
		<span class="enscript-type">struct</span> ip6_hbh *hbh;

		<span class="enscript-keyword">if</span> (ip6_hopopts_input(&amp;plen, &amp;rtalert, &amp;m, &amp;off)) {
#<span class="enscript-reference">if</span> 0	<span class="enscript-comment">/* touches NULL pointer */</span>
			in6_ifstat_inc(inifp, ifs6_in_discard);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;	<span class="enscript-comment">/* m have already been freed */</span>
		}

		<span class="enscript-comment">/* adjust pointer */</span>
		ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

		<span class="enscript-comment">/*
		 * if the payload length field is 0 and the next header field
		 * indicates Hop-by-Hop Options header, then a Jumbo Payload
		 * option MUST be included.
		 */</span>
		<span class="enscript-keyword">if</span> (ip6-&gt;ip6_plen == 0 &amp;&amp; plen == 0) {
			<span class="enscript-comment">/*
			 * Note that if a valid jumbo payload option is
			 * contained, ip6_hopopts_input() must set a valid
			 * (non-zero) payload length to the variable plen.
			 */</span>
			ip6stat.ip6s_badoptions++;
			in6_ifstat_inc(inifp, ifs6_in_discard);
			in6_ifstat_inc(inifp, ifs6_in_hdrerr);
			icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER,
			    (caddr_t)&amp;ip6-&gt;ip6_plen - (caddr_t)ip6);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/* ip6_hopopts_input() ensures that mbuf is contiguous */</span>
		hbh = (<span class="enscript-type">struct</span> ip6_hbh *)(ip6 + 1);
		nxt = hbh-&gt;ip6h_nxt;

		<span class="enscript-comment">/*
		 * If we are acting as a router and the packet contains a
		 * router alert option, see if we know the option value.
		 * Currently, we only support the option value for MLD, in which
		 * case we should pass the packet to the multicast routing
		 * daemon.
		 */</span>
		<span class="enscript-keyword">if</span> (rtalert != ~0 &amp;&amp; ip6_forwarding) {
			<span class="enscript-keyword">switch</span> (rtalert) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IP6OPT_RTALERT_MLD</span>:
				ours = 1;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-comment">/*
				 * RFC2711 requires unrecognized values must be
				 * silently ignored.
				 */</span>
				<span class="enscript-keyword">break</span>;
			}
		}
	} <span class="enscript-keyword">else</span>
		nxt = ip6-&gt;ip6_nxt;

	<span class="enscript-comment">/*
	 * Check that the amount of data in the buffers
	 * is as at least much as the IPv6 header would have us expect.
	 * Trim mbufs if longer than we expect.
	 * Drop packet if shorter than we expect.
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) &lt; plen) {
		ip6stat.ip6s_tooshort++;
		in6_ifstat_inc(inifp, ifs6_in_truncated);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &gt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) + plen) {
		<span class="enscript-comment">/*
		 * Invalidate hardware checksum info if ip6_adj_clear_hwcksum
		 * is set; useful to handle buggy drivers.  Note that this
		 * should not be enabled by default, as we may get here due
		 * to link-layer padding.
		 */</span>
		<span class="enscript-keyword">if</span> (ip6_adj_clear_hwcksum &amp;&amp;
		    (m-&gt;m_pkthdr.csum_flags &amp; CSUM_DATA_VALID) &amp;&amp;
		    !(inifp-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp;
		    !(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP)) {
			m-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_DATA_VALID;
			m-&gt;m_pkthdr.csum_data = 0;
			ip6stat.ip6s_adj_hwcsum_clr++;
		}

		ip6stat.ip6s_adj++;
		<span class="enscript-keyword">if</span> (m-&gt;m_len == m-&gt;m_pkthdr.len) {
			m-&gt;m_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) + plen;
			m-&gt;m_pkthdr.len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) + plen;
		} <span class="enscript-keyword">else</span> {
			m_adj(m, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) + plen -
			    m-&gt;m_pkthdr.len);
		}
	}

	<span class="enscript-comment">/*
	 * Forward if desirable.
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst)) {
		<span class="enscript-keyword">if</span> (!ours &amp;&amp; nd6_prproxy) {
			<span class="enscript-comment">/*
			 * If this isn't for us, this might be a Neighbor
			 * Solicitation (dst is solicited-node multicast)
			 * against an address in one of the proxied prefixes;
			 * if so, claim the packet and let icmp6_input()
			 * handle the rest.
			 */</span>
			ours = nd6_prproxy_isours(m, ip6, NULL, IFSCOPE_NONE);
			VERIFY(!ours ||
			    (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_PROXY_DST));
		}
		<span class="enscript-keyword">if</span> (!ours)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!ours) {
		<span class="enscript-comment">/*
		 * The unicast forwarding function might return the packet
		 * if we are proxying prefix(es), and if the packet is an
		 * ICMPv6 packet that has failed the zone checks, but is
		 * targetted towards a proxied address (this is optimized by
		 * way of RTF_PROXY test.)  If so, claim the packet as ours
		 * and let icmp6_input() handle the rest.  The packet's hop
		 * limit value is kept intact (it's not decremented).  This
		 * is for supporting Neighbor Unreachability Detection between
		 * proxied nodes on different links (src is link-local, dst
		 * is target address.)
		 */</span>
		<span class="enscript-keyword">if</span> ((m = ip6_forward(m, &amp;rin6, 0)) == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		VERIFY(rin6.ro_rt != NULL);
		VERIFY(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_PROXY_DST);
		deliverifp = rin6.ro_rt-&gt;rt_ifp;
		ours = 1;
	}

	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

	<span class="enscript-comment">/*
	 * Malicious party may be able to use IPv4 mapped addr to confuse
	 * tcp/udp stack and bypass security checks (act as if it was from
	 * 127.0.0.1 by using IPv6 src ::ffff:127.0.0.1).  Be cautious.
	 *
	 * For SIIT end node behavior, you may want to disable the check.
	 * However, you will  become vulnerable to attacks using IPv4 mapped
	 * source.
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_V4MAPPED(&amp;ip6-&gt;ip6_src) ||
	    IN6_IS_ADDR_V4MAPPED(&amp;ip6-&gt;ip6_dst)) {
		ip6stat.ip6s_badscope++;
		in6_ifstat_inc(inifp, ifs6_in_addrerr);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/*
	 * Tell launch routine the next header
	 */</span>
	ip6stat.ip6s_delivered++;
	in6_ifstat_inc_na(deliverifp, ifs6_in_deliver);

<span class="enscript-reference">injectit</span>:
	nest = 0;

	<span class="enscript-comment">/*
	 * Perform IP header alignment fixup again, if needed.  Note that
	 * we do it once for the outermost protocol, and we assume each
	 * protocol handler wouldn't mess with the alignment afterwards.
	 */</span>
	IP6_HDR_ALIGNMENT_FIXUP(m, inifp, <span class="enscript-keyword">return</span>);

	<span class="enscript-keyword">while</span> (nxt != IPPROTO_DONE) {
		<span class="enscript-type">struct</span> ipfilter *filter;
		<span class="enscript-type">int</span> (*pr_input)(<span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">int</span> *, <span class="enscript-type">int</span>);

		<span class="enscript-keyword">if</span> (ip6_hdrnestlimit &amp;&amp; (++nest &gt; ip6_hdrnestlimit)) {
			ip6stat.ip6s_toomanyhdr++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

		<span class="enscript-comment">/*
		 * protection against faulty packet - there should be
		 * more sanity checks in header chain processing.
		 */</span>
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; off) {
			ip6stat.ip6s_tooshort++;
			in6_ifstat_inc(inifp, ifs6_in_truncated);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
		<span class="enscript-comment">/*
		 * enforce IPsec policy checking if we are seeing last header.
		 * note that we do not visit this with protocols with pcb layer
		 * code - like udp/tcp/raw ip.
		 */</span>
		<span class="enscript-keyword">if</span> ((ipsec_bypass == 0) &amp;&amp;
		    (ip6_protox[nxt]-&gt;pr_flags &amp; PR_LASTHDR) != 0) {
			<span class="enscript-keyword">if</span> (ipsec6_in_reject(m, NULL)) {
				IPSEC_STAT_INCREMENT(ipsec6stat.in_polvio);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

		<span class="enscript-comment">/*
		 * Call IP filter
		 */</span>
		<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;ipv6_filters)) {
			ipf_ref();
			TAILQ_FOREACH(filter, &amp;ipv6_filters, ipf_link) {
				<span class="enscript-keyword">if</span> (seen == 0) {
					<span class="enscript-keyword">if</span> ((<span class="enscript-type">struct</span> ipfilter *)inject_ipfref ==
					    filter)
						seen = 1;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (filter-&gt;ipf_filter.ipf_input) {
					errno_t result;

					result = filter-&gt;ipf_filter.ipf_input(
					    filter-&gt;ipf_filter.cookie,
					    (mbuf_t *)&amp;m, off, nxt);
					<span class="enscript-keyword">if</span> (result == EJUSTRETURN) {
						ipf_unref();
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
					}
					<span class="enscript-keyword">if</span> (result != 0) {
						ipf_unref();
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
					}
				}
			}
			ipf_unref();
		}

		DTRACE_IP6(receive, <span class="enscript-type">struct</span> mbuf *, m, <span class="enscript-type">struct</span> inpcb *, NULL,
		    <span class="enscript-type">struct</span> ip6_hdr *, ip6, <span class="enscript-type">struct</span> ifnet *, inifp,
		    <span class="enscript-type">struct</span> ip *, NULL, <span class="enscript-type">struct</span> ip6_hdr *, ip6);

		<span class="enscript-keyword">if</span> ((pr_input = ip6_protox[nxt]-&gt;pr_input) == NULL) {
			m_freem(m);
			m = NULL;
			nxt = IPPROTO_DONE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ip6_protox[nxt]-&gt;pr_flags &amp; PR_PROTOLOCK)) {
			lck_mtx_lock(inet6_domain_mutex);
			nxt = pr_input(&amp;m, &amp;off, nxt);
			lck_mtx_unlock(inet6_domain_mutex);
		} <span class="enscript-keyword">else</span> {
			nxt = pr_input(&amp;m, &amp;off, nxt);
		}
	}
<span class="enscript-reference">done</span>:
	ROUTE_RELEASE(&amp;rin6);
	<span class="enscript-keyword">return</span>;
<span class="enscript-reference">bad</span>:
	m_freem(m);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_setsrcifaddr_info</span>(<span class="enscript-type">struct</span> mbuf *m, uint32_t src_idx, <span class="enscript-type">struct</span> in6_ifaddr *ia6)
{
	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	<span class="enscript-comment">/*
	 * If the source ifaddr is specified, pick up the information
	 * from there; otherwise just grab the passed-in ifindex as the
	 * caller may not have the ifaddr available.
	 */</span>
	<span class="enscript-keyword">if</span> (ia6 != NULL) {
		m-&gt;m_pkthdr.pkt_flags |= PKTF_IFAINFO;
		m-&gt;m_pkthdr.src_ifindex = ia6-&gt;ia_ifp-&gt;if_index;

		<span class="enscript-comment">/* See IN6_IFF comments in in6_var.h */</span>
		m-&gt;m_pkthdr.src_iff = (ia6-&gt;ia6_flags &amp; 0xffff);
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_pkthdr.src_iff = 0;
		m-&gt;m_pkthdr.src_ifindex = src_idx;
		<span class="enscript-keyword">if</span> (src_idx != 0)
			m-&gt;m_pkthdr.pkt_flags |= PKTF_IFAINFO;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_setdstifaddr_info</span>(<span class="enscript-type">struct</span> mbuf *m, uint32_t dst_idx, <span class="enscript-type">struct</span> in6_ifaddr *ia6)
{
	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	<span class="enscript-comment">/*
	 * If the destination ifaddr is specified, pick up the information
	 * from there; otherwise just grab the passed-in ifindex as the
	 * caller may not have the ifaddr available.
	 */</span>
	<span class="enscript-keyword">if</span> (ia6 != NULL) {
		m-&gt;m_pkthdr.pkt_flags |= PKTF_IFAINFO;
		m-&gt;m_pkthdr.dst_ifindex = ia6-&gt;ia_ifp-&gt;if_index;

		<span class="enscript-comment">/* See IN6_IFF comments in in6_var.h */</span>
		m-&gt;m_pkthdr.dst_iff = (ia6-&gt;ia6_flags &amp; 0xffff);
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_pkthdr.dst_iff = 0;
		m-&gt;m_pkthdr.dst_ifindex = dst_idx;
		<span class="enscript-keyword">if</span> (dst_idx != 0)
			m-&gt;m_pkthdr.pkt_flags |= PKTF_IFAINFO;
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_getsrcifaddr_info</span>(<span class="enscript-type">struct</span> mbuf *m, uint32_t *src_idx, uint32_t *ia6f)
{
	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	<span class="enscript-keyword">if</span> (!(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_IFAINFO))
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-keyword">if</span> (src_idx != NULL)
		*src_idx = m-&gt;m_pkthdr.src_ifindex;

	<span class="enscript-keyword">if</span> (ia6f != NULL)
		*ia6f = m-&gt;m_pkthdr.src_iff;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_getdstifaddr_info</span>(<span class="enscript-type">struct</span> mbuf *m, uint32_t *dst_idx, uint32_t *ia6f)
{
	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	<span class="enscript-keyword">if</span> (!(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_IFAINFO))
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-keyword">if</span> (dst_idx != NULL)
		*dst_idx = m-&gt;m_pkthdr.dst_ifindex;

	<span class="enscript-keyword">if</span> (ia6f != NULL)
		*ia6f = m-&gt;m_pkthdr.dst_iff;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Hop-by-Hop options header processing. If a valid jumbo payload option is
 * included, the real payload length will be stored in plenp.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_hopopts_input</span>(uint32_t *plenp, uint32_t *rtalertp, <span class="enscript-type">struct</span> mbuf **mp,
    <span class="enscript-type">int</span> *offp)
{
	<span class="enscript-type">struct</span> mbuf *m = *mp;
	<span class="enscript-type">int</span> off = *offp, hbhlen;
	<span class="enscript-type">struct</span> ip6_hbh *hbh;
	u_int8_t *opt;

	<span class="enscript-comment">/* validation of the length of the header */</span>
	IP6_EXTHDR_CHECK(m, off, <span class="enscript-keyword">sizeof</span> (*hbh), <span class="enscript-keyword">return</span> (-1));
	hbh = (<span class="enscript-type">struct</span> ip6_hbh *)(mtod(m, caddr_t) + off);
	hbhlen = (hbh-&gt;ip6h_len + 1) &lt;&lt; 3;

	IP6_EXTHDR_CHECK(m, off, hbhlen, <span class="enscript-keyword">return</span> (-1));
	hbh = (<span class="enscript-type">struct</span> ip6_hbh *)(mtod(m, caddr_t) + off);
	off += hbhlen;
	hbhlen -= <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hbh);
	opt = (u_int8_t *)hbh + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hbh);

	<span class="enscript-keyword">if</span> (ip6_process_hopopts(m, (u_int8_t *)hbh + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hbh),
	    hbhlen, rtalertp, plenp) &lt; 0)
		<span class="enscript-keyword">return</span> (-1);

	*offp = off;
	*mp = m;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Search header for all Hop-by-hop options and process each option.
 * This function is separate from ip6_hopopts_input() in order to
 * handle a case where the sending node itself process its hop-by-hop
 * options header. In such a case, the function is called from ip6_output().
 *
 * The function assumes that hbh header is located right after the IPv6 header
 * (RFC2460 p7), opthead is pointer into data content in m, and opthead to
 * opthead + hbhlen is located in continuous memory region.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_process_hopopts</span>(m, opthead, hbhlen, rtalertp, plenp)
	<span class="enscript-type">struct</span> mbuf *m;
	u_int8_t *opthead;
	<span class="enscript-type">int</span> hbhlen;
	u_int32_t *rtalertp;
	u_int32_t *plenp;
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">int</span> optlen = 0;
	u_int8_t *opt = opthead;
	u_int16_t rtalert_val;
	u_int32_t jumboplen;
	<span class="enscript-type">const</span> <span class="enscript-type">int</span> erroff = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hbh);

	<span class="enscript-keyword">for</span> (; hbhlen &gt; 0; hbhlen -= optlen, opt += optlen) {
		<span class="enscript-keyword">switch</span> (*opt) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP6OPT_PAD1</span>:
			optlen = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP6OPT_PADN</span>:
			<span class="enscript-keyword">if</span> (hbhlen &lt; IP6OPT_MINLEN) {
				ip6stat.ip6s_toosmall++;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			optlen = *(opt + 1) + 2;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP6OPT_ROUTER_ALERT</span>:
			<span class="enscript-comment">/* XXX may need check for alignment */</span>
			<span class="enscript-keyword">if</span> (hbhlen &lt; IP6OPT_RTALERT_LEN) {
				ip6stat.ip6s_toosmall++;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			<span class="enscript-keyword">if</span> (*(opt + 1) != IP6OPT_RTALERT_LEN - 2) {
				<span class="enscript-comment">/* XXX stat */</span>
				icmp6_error(m, ICMP6_PARAM_PROB,
					    ICMP6_PARAMPROB_HEADER,
					    erroff + opt + 1 - opthead);
				<span class="enscript-keyword">return</span> (-1);
			}
			optlen = IP6OPT_RTALERT_LEN;
			bcopy((caddr_t)(opt + 2), (caddr_t)&amp;rtalert_val, 2);
			*rtalertp = ntohs(rtalert_val);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IP6OPT_JUMBO</span>:
			<span class="enscript-comment">/* XXX may need check for alignment */</span>
			<span class="enscript-keyword">if</span> (hbhlen &lt; IP6OPT_JUMBO_LEN) {
				ip6stat.ip6s_toosmall++;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			<span class="enscript-keyword">if</span> (*(opt + 1) != IP6OPT_JUMBO_LEN - 2) {
				<span class="enscript-comment">/* XXX stat */</span>
				icmp6_error(m, ICMP6_PARAM_PROB,
					    ICMP6_PARAMPROB_HEADER,
					    erroff + opt + 1 - opthead);
				<span class="enscript-keyword">return</span> (-1);
			}
			optlen = IP6OPT_JUMBO_LEN;

			<span class="enscript-comment">/*
			 * IPv6 packets that have non 0 payload length
			 * must not contain a jumbo payload option.
			 */</span>
			ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
			<span class="enscript-keyword">if</span> (ip6-&gt;ip6_plen) {
				ip6stat.ip6s_badoptions++;
				icmp6_error(m, ICMP6_PARAM_PROB,
					    ICMP6_PARAMPROB_HEADER,
					    erroff + opt - opthead);
				<span class="enscript-keyword">return</span> (-1);
			}

			<span class="enscript-comment">/*
			 * We may see jumbolen in unaligned location, so
			 * we'd need to perform bcopy().
			 */</span>
			bcopy(opt + 2, &amp;jumboplen, <span class="enscript-keyword">sizeof</span> (jumboplen));
			jumboplen = (u_int32_t)htonl(jumboplen);

#<span class="enscript-reference">if</span> 1
			<span class="enscript-comment">/*
			 * if there are multiple jumbo payload options,
			 * *plenp will be non-zero and the packet will be
			 * rejected.
			 * the behavior may need some debate in ipngwg -
			 * multiple options does not make sense, however,
			 * there's no explicit mention in specification.
			 */</span>
			<span class="enscript-keyword">if</span> (*plenp != 0) {
				ip6stat.ip6s_badoptions++;
				icmp6_error(m, ICMP6_PARAM_PROB,
					    ICMP6_PARAMPROB_HEADER,
					    erroff + opt + 2 - opthead);
				<span class="enscript-keyword">return</span> (-1);
			}
#<span class="enscript-reference">endif</span>

			<span class="enscript-comment">/*
			 * jumbo payload length must be larger than 65535.
			 */</span>
			<span class="enscript-keyword">if</span> (jumboplen &lt;= IPV6_MAXPACKET) {
				ip6stat.ip6s_badoptions++;
				icmp6_error(m, ICMP6_PARAM_PROB,
					    ICMP6_PARAMPROB_HEADER,
					    erroff + opt + 2 - opthead);
				<span class="enscript-keyword">return</span> (-1);
			}
			*plenp = jumboplen;

			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:		<span class="enscript-comment">/* unknown option */</span>
			<span class="enscript-keyword">if</span> (hbhlen &lt; IP6OPT_MINLEN) {
				ip6stat.ip6s_toosmall++;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			optlen = ip6_unknown_opt(opt, m,
			    erroff + opt - opthead);
			<span class="enscript-keyword">if</span> (optlen == -1) {
				<span class="enscript-keyword">return</span> (-1);
			}
			optlen += 2;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">bad</span>:
	m_freem(m);
	<span class="enscript-keyword">return</span> (-1);
}

<span class="enscript-comment">/*
 * Unknown option processing.
 * The third argument `off' is the offset from the IPv6 header to the option,
 * which is necessary if the IPv6 header the and option header and IPv6 header
 * is not continuous in order to return an ICMPv6 error.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_unknown_opt</span>(uint8_t *optp, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off)
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6;

	<span class="enscript-keyword">switch</span> (IP6OPT_TYPE(*optp)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP6OPT_TYPE_SKIP</span>: <span class="enscript-comment">/* ignore the option */</span>
		<span class="enscript-keyword">return</span> ((<span class="enscript-type">int</span>)*(optp + 1));

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP6OPT_TYPE_DISCARD</span>:	<span class="enscript-comment">/* silently discard */</span>
		m_freem(m);
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP6OPT_TYPE_FORCEICMP</span>: <span class="enscript-comment">/* send ICMP even if multicasted */</span>
		ip6stat.ip6s_badoptions++;
		icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_OPTION, off);
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IP6OPT_TYPE_ICMP</span>: <span class="enscript-comment">/* send ICMP if not multicasted */</span>
		ip6stat.ip6s_badoptions++;
		ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst) ||
		    (m-&gt;m_flags &amp; (M_BCAST|M_MCAST))) {
			m_freem(m);
		} <span class="enscript-keyword">else</span> {
			icmp6_error(m, ICMP6_PARAM_PROB,
			    ICMP6_PARAMPROB_OPTION, off);
		}
		<span class="enscript-keyword">return</span> (-1);
	}

	m_freem(m);		<span class="enscript-comment">/* XXX: NOTREACHED */</span>
	<span class="enscript-keyword">return</span> (-1);
}

<span class="enscript-comment">/*
 * Create the &quot;control&quot; list for this pcb.
 * These functions will not modify mbuf chain at all.
 *
 * With KAME mbuf chain restriction:
 * The routine will be called from upper layer handlers like tcp6_input().
 * Thus the routine assumes that the caller (tcp6_input) have already
 * called IP6_EXTHDR_CHECK() and all the extension headers are located in the
 * very first mbuf on the mbuf chain.
 *
 * ip6_savecontrol_v4 will handle those options that are possible to be
 * set on a v4-mapped socket.
 * ip6_savecontrol will directly call ip6_savecontrol_v4 to handle those
 * options and handle the v6-only ones itself.
 */</span>
<span class="enscript-type">struct</span> mbuf **
<span class="enscript-function-name">ip6_savecontrol_v4</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> mbuf **mp,
    <span class="enscript-type">int</span> *v4only)
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

	<span class="enscript-keyword">if</span> ((inp-&gt;inp_socket-&gt;so_options &amp; SO_TIMESTAMP) != 0) {
		<span class="enscript-type">struct</span> timeval tv;

		getmicrotime(&amp;tv);
		mp = sbcreatecontrol_mbuf((caddr_t)&amp;tv, <span class="enscript-keyword">sizeof</span> (tv),
		    SCM_TIMESTAMP, SOL_SOCKET, mp);
		<span class="enscript-keyword">if</span> (*mp == NULL)
			<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-keyword">if</span> ((inp-&gt;inp_socket-&gt;so_options &amp; SO_TIMESTAMP_MONOTONIC) != 0) {
		uint64_t time;

		time = mach_absolute_time();
		mp = sbcreatecontrol_mbuf((caddr_t)&amp;time, <span class="enscript-keyword">sizeof</span> (time),
		    SCM_TIMESTAMP_MONOTONIC, SOL_SOCKET, mp);
		<span class="enscript-keyword">if</span> (*mp == NULL)
			<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-keyword">if</span> ((inp-&gt;inp_socket-&gt;so_flags &amp; SOF_RECV_TRAFFIC_CLASS) != 0) {
		<span class="enscript-type">int</span> tc = m_get_traffic_class(m);

		mp = sbcreatecontrol_mbuf((caddr_t)&amp;tc, <span class="enscript-keyword">sizeof</span> (tc),
		    SO_TRAFFIC_CLASS, SOL_SOCKET, mp);
		<span class="enscript-keyword">if</span> (*mp == NULL)
			<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> ((ip6-&gt;ip6_vfc &amp; IPV6_VERSION_MASK) != IPV6_VERSION) {
		<span class="enscript-keyword">if</span> (v4only != NULL)
			*v4only = 1;
		<span class="enscript-keyword">return</span> (mp);
	}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IS2292</span>(inp, x, y)	(((inp)-&gt;inp_flags &amp; IN6P_RFC2292) ? (x) : (y))
	<span class="enscript-comment">/* RFC 2292 sec. 5 */</span>
	<span class="enscript-keyword">if</span> ((inp-&gt;inp_flags &amp; IN6P_PKTINFO) != 0) {
		<span class="enscript-type">struct</span> in6_pktinfo pi6;

		bcopy(&amp;ip6-&gt;ip6_dst, &amp;pi6.ipi6_addr, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr));
		in6_clearscope(&amp;pi6.ipi6_addr);	<span class="enscript-comment">/* XXX */</span>
		pi6.ipi6_ifindex =
		    (m &amp;&amp; m-&gt;m_pkthdr.rcvif) ? m-&gt;m_pkthdr.rcvif-&gt;if_index : 0;

		mp = sbcreatecontrol_mbuf((caddr_t)&amp;pi6,
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_pktinfo),
		    IS2292(inp, IPV6_2292PKTINFO, IPV6_PKTINFO),
		    IPPROTO_IPV6, mp);
		<span class="enscript-keyword">if</span> (*mp == NULL)
			<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> ((inp-&gt;inp_flags &amp; IN6P_HOPLIMIT) != 0) {
		<span class="enscript-type">int</span> hlim = ip6-&gt;ip6_hlim &amp; 0xff;

		mp = sbcreatecontrol_mbuf((caddr_t)&amp;hlim, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>),
		    IS2292(inp, IPV6_2292HOPLIMIT, IPV6_HOPLIMIT),
		    IPPROTO_IPV6, mp);
		<span class="enscript-keyword">if</span> (*mp == NULL)
			<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (v4only != NULL)
		*v4only = 0;
	<span class="enscript-keyword">return</span> (mp);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_savecontrol</span>(<span class="enscript-type">struct</span> inpcb *in6p, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> mbuf **mp)
{
	<span class="enscript-type">struct</span> mbuf **np;
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	<span class="enscript-type">int</span> v4only = 0;

	*mp = NULL;
	np = ip6_savecontrol_v4(in6p, m, mp, &amp;v4only);
	<span class="enscript-keyword">if</span> (np == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mbufs</span>;

	mp = np;
	<span class="enscript-keyword">if</span> (v4only)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> ((in6p-&gt;inp_flags &amp; IN6P_TCLASS) != 0) {
		u_int32_t flowinfo;
		<span class="enscript-type">int</span> tclass;

		flowinfo = (u_int32_t)ntohl(ip6-&gt;ip6_flow &amp; IPV6_FLOWINFO_MASK);
		flowinfo &gt;&gt;= 20;

		tclass = flowinfo &amp; 0xff;
		mp = sbcreatecontrol_mbuf((caddr_t)&amp;tclass, <span class="enscript-keyword">sizeof</span> (tclass),
		    IPV6_TCLASS, IPPROTO_IPV6, mp);
		<span class="enscript-keyword">if</span> (*mp == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mbufs</span>;
	}

	<span class="enscript-comment">/*
	 * IPV6_HOPOPTS socket option.  Recall that we required super-user
	 * privilege for the option (see ip6_ctloutput), but it might be too
	 * strict, since there might be some hop-by-hop options which can be
	 * returned to normal user.
	 * See also RFC 2292 section 6 (or RFC 3542 section 8).
	 */</span>
	<span class="enscript-keyword">if</span> ((in6p-&gt;inp_flags &amp; IN6P_HOPOPTS) != 0) {
		<span class="enscript-comment">/*
		 * Check if a hop-by-hop options header is contatined in the
		 * received packet, and if so, store the options as ancillary
		 * data. Note that a hop-by-hop options header must be
		 * just after the IPv6 header, which is assured through the
		 * IPv6 input processing.
		 */</span>
		ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
		<span class="enscript-keyword">if</span> (ip6-&gt;ip6_nxt == IPPROTO_HOPOPTS) {
			<span class="enscript-type">struct</span> ip6_hbh *hbh;
			<span class="enscript-type">int</span> hbhlen = 0;
			hbh = (<span class="enscript-type">struct</span> ip6_hbh *)(ip6 + 1);
			hbhlen = (hbh-&gt;ip6h_len + 1) &lt;&lt; 3;

			<span class="enscript-comment">/*
			 * XXX: We copy the whole header even if a
			 * jumbo payload option is included, the option which
			 * is to be removed before returning according to
			 * RFC2292.
			 * Note: this constraint is removed in RFC3542
			 */</span>
			mp = sbcreatecontrol_mbuf((caddr_t)hbh, hbhlen,
			    IS2292(in6p, IPV6_2292HOPOPTS, IPV6_HOPOPTS),
			    IPPROTO_IPV6, mp);

			<span class="enscript-keyword">if</span> (*mp == NULL) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mbufs</span>;
			}
		}
	}

	<span class="enscript-keyword">if</span> ((in6p-&gt;inp_flags &amp; (IN6P_RTHDR | IN6P_DSTOPTS)) != 0) {
		<span class="enscript-type">int</span> nxt = ip6-&gt;ip6_nxt, off = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr);

		<span class="enscript-comment">/*
		 * Search for destination options headers or routing
		 * header(s) through the header chain, and stores each
		 * header as ancillary data.
		 * Note that the order of the headers remains in
		 * the chain of ancillary data.
		 */</span>
		<span class="enscript-keyword">while</span> (1) {	<span class="enscript-comment">/* is explicit loop prevention necessary? */</span>
			<span class="enscript-type">struct</span> ip6_ext *ip6e = NULL;
			<span class="enscript-type">int</span> elen;

			<span class="enscript-comment">/*
			 * if it is not an extension header, don't try to
			 * pull it from the chain.
			 */</span>
			<span class="enscript-keyword">switch</span> (nxt) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_DSTOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ROUTING</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_HOPOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>: <span class="enscript-comment">/* is it possible? */</span>
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">loopend</span>;
			}

			<span class="enscript-keyword">if</span> (off + <span class="enscript-keyword">sizeof</span> (*ip6e) &gt; m-&gt;m_len)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">loopend</span>;
			ip6e = (<span class="enscript-type">struct</span> ip6_ext *)(mtod(m, caddr_t) + off);
			<span class="enscript-keyword">if</span> (nxt == IPPROTO_AH)
				elen = (ip6e-&gt;ip6e_len + 2) &lt;&lt; 2;
			<span class="enscript-keyword">else</span>
				elen = (ip6e-&gt;ip6e_len + 1) &lt;&lt; 3;
			<span class="enscript-keyword">if</span> (off + elen &gt; m-&gt;m_len)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">loopend</span>;

			<span class="enscript-keyword">switch</span> (nxt) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_DSTOPTS</span>:
				<span class="enscript-keyword">if</span> (!(in6p-&gt;inp_flags &amp; IN6P_DSTOPTS))
					<span class="enscript-keyword">break</span>;

				mp = sbcreatecontrol_mbuf((caddr_t)ip6e, elen,
				    IS2292(in6p, IPV6_2292DSTOPTS,
				    IPV6_DSTOPTS), IPPROTO_IPV6, mp);
				<span class="enscript-keyword">if</span> (*mp == NULL) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mbufs</span>;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ROUTING</span>:
				<span class="enscript-keyword">if</span> (!(in6p-&gt;inp_flags &amp; IN6P_RTHDR))
					<span class="enscript-keyword">break</span>;

				mp = sbcreatecontrol_mbuf((caddr_t)ip6e, elen,
				    IS2292(in6p, IPV6_2292RTHDR, IPV6_RTHDR),
				    IPPROTO_IPV6, mp);
				<span class="enscript-keyword">if</span> (*mp == NULL) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">no_mbufs</span>;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_HOPOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>: <span class="enscript-comment">/* is it possible? */</span>
				<span class="enscript-keyword">break</span>;

			<span class="enscript-reference">default</span>:
				<span class="enscript-comment">/*
				 * other cases have been filtered in the above.
				 * none will visit this case.  here we supply
				 * the code just in case (nxt overwritten or
				 * other cases).
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">loopend</span>;

			}

			<span class="enscript-comment">/* proceed with the next header. */</span>
			off += elen;
			nxt = ip6e-&gt;ip6e_nxt;
			ip6e = NULL;
		}
<span class="enscript-reference">loopend</span>:
		;
	}
	<span class="enscript-keyword">return</span> (0);
<span class="enscript-reference">no_mbufs</span>:
	ip6stat.ip6s_pktdropcntrl++;
	<span class="enscript-comment">/* XXX increment a stat to show the failure */</span>
	<span class="enscript-keyword">return</span> (ENOBUFS);
}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">IS2292</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_notify_pmtu</span>(<span class="enscript-type">struct</span> inpcb *in6p, <span class="enscript-type">struct</span> sockaddr_in6 *dst, u_int32_t *mtu)
{
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">struct</span> mbuf *m_mtu;
	<span class="enscript-type">struct</span> ip6_mtuinfo mtuctl;

	so =  in6p-&gt;inp_socket;

	<span class="enscript-keyword">if</span> (mtu == NULL)
		<span class="enscript-keyword">return</span>;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (so == NULL) {		<span class="enscript-comment">/* I believe this is impossible */</span>
		panic(<span class="enscript-string">&quot;ip6_notify_pmtu: socket is NULL&quot;</span>);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
#<span class="enscript-reference">endif</span>

	bzero(&amp;mtuctl, <span class="enscript-keyword">sizeof</span> (mtuctl));	<span class="enscript-comment">/* zero-clear for safety */</span>
	mtuctl.ip6m_mtu = *mtu;
	mtuctl.ip6m_addr = *dst;
	<span class="enscript-keyword">if</span> (sa6_recoverscope(&amp;mtuctl.ip6m_addr, TRUE))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ((m_mtu = sbcreatecontrol((caddr_t)&amp;mtuctl, <span class="enscript-keyword">sizeof</span> (mtuctl),
	    IPV6_PATHMTU, IPPROTO_IPV6)) == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (sbappendaddr(&amp;so-&gt;so_rcv, SA(dst), NULL, m_mtu, NULL) == 0) {
		m_freem(m_mtu);
		<span class="enscript-comment">/* XXX: should count statistics */</span>
	} <span class="enscript-keyword">else</span> {
		sorwakeup(so);
	}
}

<span class="enscript-comment">/*
 * Get pointer to the previous header followed by the header
 * currently processed.
 * XXX: This function supposes that
 *	M includes all headers,
 *	the next header field and the header length field of each header
 *	are valid, and
 *	the sum of each header length equals to OFF.
 * Because of these assumptions, this function must be called very
 * carefully. Moreover, it will not be used in the near future when
 * we develop `neater' mechanism to process extension headers.
 */</span>
<span class="enscript-type">char</span> *
<span class="enscript-function-name">ip6_get_prevhdr</span>(m, off)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> off;
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

	<span class="enscript-keyword">if</span> (off == <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr)) {
		<span class="enscript-keyword">return</span> ((<span class="enscript-type">char</span> *)&amp;ip6-&gt;ip6_nxt);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span> len, nxt;
		<span class="enscript-type">struct</span> ip6_ext *ip6e = NULL;

		nxt = ip6-&gt;ip6_nxt;
		len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr);
		<span class="enscript-keyword">while</span> (len &lt; off) {
			ip6e = (<span class="enscript-type">struct</span> ip6_ext *)(mtod(m, caddr_t) + len);

			<span class="enscript-keyword">switch</span> (nxt) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_FRAGMENT</span>:
				len += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_frag);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
				len += (ip6e-&gt;ip6e_len + 2) &lt;&lt; 2;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				len += (ip6e-&gt;ip6e_len + 1) &lt;&lt; 3;
				<span class="enscript-keyword">break</span>;
			}
			nxt = ip6e-&gt;ip6e_nxt;
		}
		<span class="enscript-keyword">if</span> (ip6e)
			<span class="enscript-keyword">return</span> ((<span class="enscript-type">char</span> *)&amp;ip6e-&gt;ip6e_nxt);
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> (NULL);
	}
}

<span class="enscript-comment">/*
 * get next header offset.  m will be retained.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_nexthdr</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, <span class="enscript-type">int</span> proto, <span class="enscript-type">int</span> *nxtp)
{
	<span class="enscript-type">struct</span> ip6_hdr ip6;
	<span class="enscript-type">struct</span> ip6_ext ip6e;
	<span class="enscript-type">struct</span> ip6_frag fh;

	<span class="enscript-comment">/* just in case */</span>
	VERIFY(m != NULL);
	<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_PKTHDR) == 0 || m-&gt;m_pkthdr.len &lt; off)
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-keyword">switch</span> (proto) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_IPV6</span>:
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; off + <span class="enscript-keyword">sizeof</span> (ip6))
			<span class="enscript-keyword">return</span> (-1);
		m_copydata(m, off, <span class="enscript-keyword">sizeof</span> (ip6), (caddr_t)&amp;ip6);
		<span class="enscript-keyword">if</span> (nxtp)
			*nxtp = ip6.ip6_nxt;
		off += <span class="enscript-keyword">sizeof</span> (ip6);
		<span class="enscript-keyword">return</span> (off);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_FRAGMENT</span>:
		<span class="enscript-comment">/*
		 * terminate parsing if it is not the first fragment,
		 * it does not make sense to parse through it.
		 */</span>
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; off + <span class="enscript-keyword">sizeof</span> (fh))
			<span class="enscript-keyword">return</span> (-1);
		m_copydata(m, off, <span class="enscript-keyword">sizeof</span> (fh), (caddr_t)&amp;fh);
		<span class="enscript-comment">/* IP6F_OFF_MASK = 0xfff8(BigEndian), 0xf8ff(LittleEndian) */</span>
		<span class="enscript-keyword">if</span> (fh.ip6f_offlg &amp; IP6F_OFF_MASK)
			<span class="enscript-keyword">return</span> (-1);
		<span class="enscript-keyword">if</span> (nxtp)
			*nxtp = fh.ip6f_nxt;
		off += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_frag);
		<span class="enscript-keyword">return</span> (off);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; off + <span class="enscript-keyword">sizeof</span> (ip6e))
			<span class="enscript-keyword">return</span> (-1);
		m_copydata(m, off, <span class="enscript-keyword">sizeof</span> (ip6e), (caddr_t)&amp;ip6e);
		<span class="enscript-keyword">if</span> (nxtp)
			*nxtp = ip6e.ip6e_nxt;
		off += (ip6e.ip6e_len + 2) &lt;&lt; 2;
		<span class="enscript-keyword">return</span> (off);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_HOPOPTS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ROUTING</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_DSTOPTS</span>:
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; off + <span class="enscript-keyword">sizeof</span> (ip6e))
			<span class="enscript-keyword">return</span> (-1);
		m_copydata(m, off, <span class="enscript-keyword">sizeof</span> (ip6e), (caddr_t)&amp;ip6e);
		<span class="enscript-keyword">if</span> (nxtp)
			*nxtp = ip6e.ip6e_nxt;
		off += (ip6e.ip6e_len + 1) &lt;&lt; 3;
		<span class="enscript-keyword">return</span> (off);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_NONE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_IPCOMP</span>:
		<span class="enscript-comment">/* give up */</span>
		<span class="enscript-keyword">return</span> (-1);

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">return</span> (-1);
}

<span class="enscript-comment">/*
 * get offset for the last header in the chain.  m will be kept untainted.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_lasthdr</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, <span class="enscript-type">int</span> proto, <span class="enscript-type">int</span> *nxtp)
{
	<span class="enscript-type">int</span> newoff;
	<span class="enscript-type">int</span> nxt;

	<span class="enscript-keyword">if</span> (!nxtp) {
		nxt = -1;
		nxtp = &amp;nxt;
	}
	<span class="enscript-keyword">while</span> (1) {
		newoff = ip6_nexthdr(m, off, proto, nxtp);
		<span class="enscript-keyword">if</span> (newoff &lt; 0)
			<span class="enscript-keyword">return</span> (off);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (newoff &lt; off)
			<span class="enscript-keyword">return</span> (-1);	<span class="enscript-comment">/* invalid */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (newoff == off)
			<span class="enscript-keyword">return</span> (newoff);

		off = newoff;
		proto = *nxtp;
	}
}

<span class="enscript-type">struct</span> ip6aux *
<span class="enscript-function-name">ip6_addaux</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> m_tag		*tag;

	<span class="enscript-comment">/* Check if one is already allocated */</span>
	tag = m_tag_locate(m, KERNEL_MODULE_TAG_ID,
	    KERNEL_TAG_TYPE_INET6, NULL);
	<span class="enscript-keyword">if</span> (tag == NULL) {
		<span class="enscript-comment">/* Allocate a tag */</span>
		tag = m_tag_create(KERNEL_MODULE_TAG_ID, KERNEL_TAG_TYPE_INET6,
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6aux), M_DONTWAIT, m);

		<span class="enscript-comment">/* Attach it to the mbuf */</span>
		<span class="enscript-keyword">if</span> (tag) {
			m_tag_prepend(m, tag);
		}
	}

	<span class="enscript-keyword">return</span> (tag ? (<span class="enscript-type">struct</span> ip6aux *)(tag + 1) : NULL);
}

<span class="enscript-type">struct</span> ip6aux *
<span class="enscript-function-name">ip6_findaux</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> m_tag	*tag;

	tag = m_tag_locate(m, KERNEL_MODULE_TAG_ID,
	    KERNEL_TAG_TYPE_INET6, NULL);

	<span class="enscript-keyword">return</span> (tag ? (<span class="enscript-type">struct</span> ip6aux *)(tag + 1) : NULL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_delaux</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> m_tag	*tag;

	tag = m_tag_locate(m, KERNEL_MODULE_TAG_ID,
	    KERNEL_TAG_TYPE_INET6, NULL);
	<span class="enscript-keyword">if</span> (tag) {
		m_tag_delete(m, tag);
	}
}

<span class="enscript-comment">/*
 * Drain callback
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_drain</span>(<span class="enscript-type">void</span>)
{
	frag6_drain();		<span class="enscript-comment">/* fragments */</span>
	in6_rtqdrain();		<span class="enscript-comment">/* protocol cloned routes */</span>
	nd6_drain(NULL);	<span class="enscript-comment">/* cloned routes: ND6 */</span>
}

<span class="enscript-comment">/*
 * System control for IP6
 */</span>

u_char	inet6ctlerrmap[PRC_NCMDS] = {
	0,		0,		0,		0,
	0,		EMSGSIZE,	EHOSTDOWN,	EHOSTUNREACH,
	EHOSTUNREACH,	EHOSTUNREACH,	ECONNREFUSED,	ECONNREFUSED,
	EMSGSIZE,	EHOSTUNREACH,	0,		0,
	0,		0,		0,		0,
	ENOPROTOOPT
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_reset_ip6_input_stats SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, i;

	i = ip6_input_measure;
	error = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (error || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	<span class="enscript-comment">/* impose bounds */</span>
	<span class="enscript-keyword">if</span> (i &lt; 0 || i &gt; 1) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (ip6_input_measure != i &amp;&amp; i == 1) {
		net_perf_initialize(&amp;net_perf, ip6_input_measure_bins);
	}
	ip6_input_measure = i;
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_ip6_input_measure_bins SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error;
	uint64_t i;

	i = ip6_input_measure_bins;
	error = sysctl_handle_quad(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (error || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	<span class="enscript-comment">/* validate data */</span>
	<span class="enscript-keyword">if</span> (!net_perf_validate_bins(i)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	ip6_input_measure_bins = i;
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_ip6_input_getperf SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL)
		req-&gt;oldlen = (size_t)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ipstat);

	<span class="enscript-keyword">return</span> (SYSCTL_OUT(req, &amp;net_perf, MIN(<span class="enscript-keyword">sizeof</span> (net_perf), req-&gt;oldlen)));
}
</pre>
<hr />
</body></html>