<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ip6_forward.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ip6_forward.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2009-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$FreeBSD: src/sys/netinet6/ip6_forward.c,v 1.16 2002/10/16 02:25:05 sam Exp $	*/</span>
<span class="enscript-comment">/*	$KAME: ip6_forward.c,v 1.69 2001/05/17 03:48:30 itojun Exp $	*/</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/scope6_var.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key.h&gt;</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> ipsec_bypass;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_fw.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pfvar.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

<span class="enscript-comment">/*
 * Forward a packet.  If some error occurs return the sender
 * an icmp packet.  Note we can't always generate a meaningful
 * icmp message because icmp doesn't have a large enough repertoire
 * of codes and types.
 *
 * If not forwarding, just drop the packet.  This could be confusing
 * if ipforwarding was zero but some routing protocol was advancing
 * us as a gateway to somewhere.  However, we must let the routing
 * protocol deal with that.
 *
 */</span>

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">ip6_forward</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> route_in6 *ip6forward_rt,
    <span class="enscript-type">int</span> srcrt)
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	<span class="enscript-type">struct</span> sockaddr_in6 *dst;
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">int</span> error, type = 0, code = 0;
	boolean_t proxy = FALSE;
	<span class="enscript-type">struct</span> mbuf *mcopy = NULL;
	<span class="enscript-type">struct</span> ifnet *ifp, *rcvifp, *origifp;	<span class="enscript-comment">/* maybe unnecessary */</span>
	u_int32_t inzone, outzone, len;
	<span class="enscript-type">struct</span> in6_addr src_in6, dst_in6;
	uint64_t curtime = net_uptime();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-type">struct</span> secpolicy *sp = NULL;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope = IFSCOPE_NONE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
	<span class="enscript-type">struct</span> pf_mtag *pf_mtag;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

	<span class="enscript-comment">/*
	 * In the prefix proxying case, the route to the proxied node normally
	 * gets created by nd6_prproxy_ns_output(), as part of forwarding a
	 * NS (NUD/AR) packet to the proxied node.  In the event that such
	 * packet did not arrive in time before the correct route gets created,
	 * ip6_input() would have performed a rtalloc() which most likely will
	 * create the wrong cloned route; this route points back to the same
	 * interface as the inbound interface, since the parent non-scoped
	 * prefix route points there.  Therefore we check if that is the case
	 * and perform the necessary fixup to get the correct route installed.
	 */</span>
	<span class="enscript-keyword">if</span> (!srcrt &amp;&amp; nd6_prproxy &amp;&amp;
	    (rt = ip6forward_rt-&gt;ro_rt) != NULL &amp;&amp; (rt-&gt;rt_flags &amp; RTF_PROXY)) {
		nd6_proxy_find_fwdroute(m-&gt;m_pkthdr.rcvif, ip6forward_rt);
		<span class="enscript-keyword">if</span> ((rt = ip6forward_rt-&gt;ro_rt) != NULL)
			ifscope = rt-&gt;rt_ifp-&gt;if_index;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
	pf_mtag = pf_find_mtag(m);
	<span class="enscript-keyword">if</span> (pf_mtag != NULL &amp;&amp; pf_mtag-&gt;pftag_rtableid != IFSCOPE_NONE)
		ifscope = pf_mtag-&gt;pftag_rtableid;

	<span class="enscript-comment">/*
	 * If the caller provides a route which is on a different interface
	 * than the one specified for scoped forwarding, discard the route
	 * and do a lookup below.
	 */</span>
	<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE &amp;&amp; (rt = ip6forward_rt-&gt;ro_rt) != NULL) {
		RT_LOCK(rt);
		<span class="enscript-keyword">if</span> (rt-&gt;rt_ifp-&gt;if_index != ifscope) {
			RT_UNLOCK(rt);
			ROUTE_RELEASE(ip6forward_rt);
			rt = NULL;
		} <span class="enscript-keyword">else</span> {
			RT_UNLOCK(rt);
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-comment">/*
	 * Check AH/ESP integrity.
	 */</span>
	<span class="enscript-comment">/*
	 * Don't increment ip6s_cantforward because this is the check
	 * before forwarding packet actually.
	 */</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass == 0) {
		<span class="enscript-keyword">if</span> (ipsec6_in_reject(m, NULL)) {
			IPSEC_STAT_INCREMENT(ipsec6stat.in_polvio);
			m_freem(m);
			<span class="enscript-keyword">return</span> (NULL);
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*IPSEC*/</span>

	<span class="enscript-comment">/*
	 * Do not forward packets to multicast destination.
	 * Do not forward packets with unspecified source.  It was discussed
	 * in July 2000, on ipngwg mailing list.
	 */</span>
	<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; (M_BCAST|M_MCAST)) != 0 ||
	    IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst) ||
	    IN6_IS_ADDR_UNSPECIFIED(&amp;ip6-&gt;ip6_src)) {
		ip6stat.ip6s_cantforward++;
		<span class="enscript-comment">/* XXX in6_ifstat_inc(rt-&gt;rt_ifp, ifs6_in_discard) */</span>
		<span class="enscript-keyword">if</span> (ip6_log_time + ip6_log_interval &lt; curtime) {
			ip6_log_time = curtime;
			log(LOG_DEBUG,
			    <span class="enscript-string">&quot;cannot forward &quot;</span>
			    <span class="enscript-string">&quot;from %s to %s nxt %d received on %s\n&quot;</span>,
			    ip6_sprintf(&amp;ip6-&gt;ip6_src),
			    ip6_sprintf(&amp;ip6-&gt;ip6_dst),
			    ip6-&gt;ip6_nxt,
			    if_name(m-&gt;m_pkthdr.rcvif));
		}
		m_freem(m);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (ip6-&gt;ip6_hlim &lt;= IPV6_HLIMDEC) {
		<span class="enscript-comment">/* XXX in6_ifstat_inc(rt-&gt;rt_ifp, ifs6_in_discard) */</span>
		icmp6_error_flag(m, ICMP6_TIME_EXCEEDED,
				ICMP6_TIME_EXCEED_TRANSIT, 0, 0);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-comment">/*
	 * See if the destination is a proxied address, and if so pretend
	 * that it's for us.  This is mostly to handle NUD probes against
	 * the proxied addresses.  We filter for ICMPv6 here and will let
	 * icmp6_input handle the rest.
	 */</span>
	<span class="enscript-keyword">if</span> (!srcrt &amp;&amp; nd6_prproxy) {
		VERIFY(!IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst));
		proxy = nd6_prproxy_isours(m, ip6, ip6forward_rt, ifscope);
		<span class="enscript-comment">/*
		 * Don't update hop limit while proxying; RFC 4389 4.1.
		 * Also skip IPsec forwarding path processing as this
		 * packet is not to be forwarded.
		 */</span>
		<span class="enscript-keyword">if</span> (proxy)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;
	}

	ip6-&gt;ip6_hlim -= IPV6_HLIMDEC;

	<span class="enscript-comment">/*
	 * Save at most ICMPV6_PLD_MAXLEN (= the min IPv6 MTU -
	 * size of IPv6 + ICMPv6 headers) bytes of the packet in case
	 * we need to generate an ICMP6 message to the src.
	 * Thanks to M_EXT, in most cases copy will not occur.
	 *
	 * It is important to save it before IPsec processing as IPsec
	 * processing may modify the mbuf.
	 */</span>
	mcopy = m_copy(m, 0, imin(m-&gt;m_pkthdr.len, ICMPV6_PLD_MAXLEN));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;
	<span class="enscript-comment">/* get a security policy for this packet */</span>
	sp = ipsec6_getpolicybyaddr(m, IPSEC_DIR_OUTBOUND, IP_FORWARDING,
	    &amp;error);
	<span class="enscript-keyword">if</span> (sp == NULL) {
		IPSEC_STAT_INCREMENT(ipsec6stat.out_inval);
		ip6stat.ip6s_cantforward++;
		<span class="enscript-keyword">if</span> (mcopy) {
#<span class="enscript-reference">if</span> 0
			<span class="enscript-comment">/* XXX: what icmp ? */</span>
#<span class="enscript-reference">else</span>
			m_freem(mcopy);
#<span class="enscript-reference">endif</span>
		}
		m_freem(m);
		<span class="enscript-keyword">return</span> (NULL);
	}

	error = 0;

	<span class="enscript-comment">/* check policy */</span>
	<span class="enscript-keyword">switch</span> (sp-&gt;policy) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_DISCARD</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_GENERATE</span>:
		<span class="enscript-comment">/*
		 * This packet is just discarded.
		 */</span>
		IPSEC_STAT_INCREMENT(ipsec6stat.out_polvio);
		ip6stat.ip6s_cantforward++;
		key_freesp(sp, KEY_SADB_UNLOCKED);
		<span class="enscript-keyword">if</span> (mcopy) {
#<span class="enscript-reference">if</span> 0
			<span class="enscript-comment">/* XXX: what icmp ? */</span>
#<span class="enscript-reference">else</span>
			m_freem(mcopy);
#<span class="enscript-reference">endif</span>
		}
		m_freem(m);
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_BYPASS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_NONE</span>:
		<span class="enscript-comment">/* no need to do IPsec. */</span>
		key_freesp(sp, KEY_SADB_UNLOCKED);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_IPSEC</span>:
		<span class="enscript-keyword">if</span> (sp-&gt;req == NULL) {
			<span class="enscript-comment">/* XXX should be panic ? */</span>
			printf(<span class="enscript-string">&quot;ip6_forward: No IPsec request specified.\n&quot;</span>);
			ip6stat.ip6s_cantforward++;
			key_freesp(sp, KEY_SADB_UNLOCKED);
			<span class="enscript-keyword">if</span> (mcopy) {
#<span class="enscript-reference">if</span> 0
				<span class="enscript-comment">/* XXX: what icmp ? */</span>
#<span class="enscript-reference">else</span>
				m_freem(mcopy);
#<span class="enscript-reference">endif</span>
			}
			m_freem(m);
			<span class="enscript-keyword">return</span> (NULL);
		}
		<span class="enscript-comment">/* do IPsec */</span>
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_ENTRUST</span>:
	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/* should be panic ?? */</span>
		printf(<span class="enscript-string">&quot;ip6_forward: Invalid policy found. %d\n&quot;</span>, sp-&gt;policy);
		key_freesp(sp, KEY_SADB_UNLOCKED);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;
	}

    {
	<span class="enscript-type">struct</span> ipsec_output_state state;

	<span class="enscript-comment">/*
	 * All the extension headers will become inaccessible
	 * (since they can be encrypted).
	 * Don't panic, we need no more updates to extension headers
	 * on inner IPv6 packet (since they are now encapsulated).
	 *
	 * IPv6 [ESP|AH] IPv6 [extension headers] payload
	 */</span>
	bzero(&amp;state, <span class="enscript-keyword">sizeof</span>(state));
	state.m = m;
	state.dst = NULL;	<span class="enscript-comment">/* update at ipsec6_output_tunnel() */</span>

	error = ipsec6_output_tunnel(&amp;state, sp, 0);
	key_freesp(sp, KEY_SADB_UNLOCKED);
	<span class="enscript-keyword">if</span> (state.tunneled == 4) {
		ROUTE_RELEASE(&amp;state.ro);
		<span class="enscript-keyword">return</span> (NULL);  <span class="enscript-comment">/* packet is gone - sent over IPv4 */</span>
	}

	m = state.m;
	ROUTE_RELEASE(&amp;state.ro);

	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/* mbuf is already reclaimed in ipsec6_output_tunnel. */</span>
		<span class="enscript-keyword">switch</span> (error) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTUNREACH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETUNREACH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EMSGSIZE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOBUFS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOMEM</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			printf(<span class="enscript-string">&quot;ip6_output (ipsec): error code %d\n&quot;</span>, error);
			<span class="enscript-comment">/* fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOENT</span>:
			<span class="enscript-comment">/* don't show these error codes to the user */</span>
			<span class="enscript-keyword">break</span>;
		}
		ip6stat.ip6s_cantforward++;
		<span class="enscript-keyword">if</span> (mcopy) {
#<span class="enscript-reference">if</span> 0
			<span class="enscript-comment">/* XXX: what icmp ? */</span>
#<span class="enscript-reference">else</span>
			m_freem(mcopy);
#<span class="enscript-reference">endif</span>
		}
		m_freem(m);
		<span class="enscript-keyword">return</span> (NULL);
	}
    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
    <span class="enscript-reference">skip_ipsec</span>:

	dst = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;ip6forward_rt-&gt;ro_dst;
	<span class="enscript-keyword">if</span> ((rt = ip6forward_rt-&gt;ro_rt) != NULL) {
		RT_LOCK(rt);
		<span class="enscript-comment">/* Take an extra ref for ourselves */</span>
		RT_ADDREF_LOCKED(rt);
	}

	VERIFY(rt == NULL || rt == ip6forward_rt-&gt;ro_rt);
	<span class="enscript-keyword">if</span> (!srcrt) {
		<span class="enscript-comment">/*
		 * ip6forward_rt-&gt;ro_dst.sin6_addr is equal to ip6-&gt;ip6_dst
		 */</span>
		<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ip6forward_rt)) {
			<span class="enscript-keyword">if</span> (rt != NULL) {
				<span class="enscript-comment">/* Release extra ref */</span>
				RT_REMREF_LOCKED(rt);
				RT_UNLOCK(rt);
			}
			ROUTE_RELEASE(ip6forward_rt);

			<span class="enscript-comment">/* this probably fails but give it a try again */</span>
			rtalloc_scoped_ign((<span class="enscript-type">struct</span> route *)ip6forward_rt,
			    RTF_PRCLONING, ifscope);
			<span class="enscript-keyword">if</span> ((rt = ip6forward_rt-&gt;ro_rt) != NULL) {
				RT_LOCK(rt);
				<span class="enscript-comment">/* Take an extra ref for ourselves */</span>
				RT_ADDREF_LOCKED(rt);
			}
		}

		<span class="enscript-keyword">if</span> (rt == NULL) {
			ip6stat.ip6s_noroute++;
			in6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_noroute);
			<span class="enscript-keyword">if</span> (mcopy)
				icmp6_error(mcopy, ICMP6_DST_UNREACH,
					    ICMP6_DST_UNREACH_NOROUTE, 0);
			m_freem(m);
			<span class="enscript-keyword">return</span> (NULL);
		}
		RT_LOCK_ASSERT_HELD(rt);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ip6forward_rt) ||
	    !IN6_ARE_ADDR_EQUAL(&amp;ip6-&gt;ip6_dst, &amp;dst-&gt;sin6_addr)) {
		<span class="enscript-keyword">if</span> (rt != NULL) {
			<span class="enscript-comment">/* Release extra ref */</span>
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
		}
		ROUTE_RELEASE(ip6forward_rt);

		bzero(dst, <span class="enscript-keyword">sizeof</span>(*dst));
		dst-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
		dst-&gt;sin6_family = AF_INET6;
		dst-&gt;sin6_addr = ip6-&gt;ip6_dst;

		rtalloc_scoped_ign((<span class="enscript-type">struct</span> route *)ip6forward_rt,
		    RTF_PRCLONING, ifscope);
		<span class="enscript-keyword">if</span> ((rt = ip6forward_rt-&gt;ro_rt) == NULL) {
			ip6stat.ip6s_noroute++;
			in6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_noroute);
			<span class="enscript-keyword">if</span> (mcopy)
				icmp6_error(mcopy, ICMP6_DST_UNREACH,
				    ICMP6_DST_UNREACH_NOROUTE, 0);
			m_freem(m);
			<span class="enscript-keyword">return</span> (NULL);
		}
		RT_LOCK(rt);
		<span class="enscript-comment">/* Take an extra ref for ourselves */</span>
		RT_ADDREF_LOCKED(rt);
	}

	<span class="enscript-comment">/*
	 * Source scope check: if a packet can't be delivered to its
	 * destination for the reason that the destination is beyond the scope
	 * of the source address, discard the packet and return an icmp6
	 * destination unreachable error with Code 2 (beyond scope of source
	 * address) unless we are proxying (source address is link local
	 * for NUDs.)  We use a local copy of ip6_src, since in6_setscope()
	 * will possibly modify its first argument.
	 * [draft-ietf-ipngwg-icmp-v3-04.txt, Section 3.1]
	 */</span>
	src_in6 = ip6-&gt;ip6_src;
	<span class="enscript-keyword">if</span> (in6_setscope(&amp;src_in6, rt-&gt;rt_ifp, &amp;outzone)) {
		<span class="enscript-comment">/* XXX: this should not happen */</span>
		ip6stat.ip6s_cantforward++;
		ip6stat.ip6s_badscope++;
		m_freem(m);
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-keyword">if</span> (in6_setscope(&amp;src_in6, m-&gt;m_pkthdr.rcvif, &amp;inzone)) {
		ip6stat.ip6s_cantforward++;
		ip6stat.ip6s_badscope++;
		m_freem(m);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (inzone != outzone &amp;&amp; !proxy) {
		ip6stat.ip6s_cantforward++;
		ip6stat.ip6s_badscope++;
		in6_ifstat_inc(rt-&gt;rt_ifp, ifs6_in_discard);

		<span class="enscript-keyword">if</span> (ip6_log_time + ip6_log_interval &lt; curtime) {
			ip6_log_time = curtime;
			log(LOG_DEBUG,
			    <span class="enscript-string">&quot;cannot forward &quot;</span>
			    <span class="enscript-string">&quot;src %s, dst %s, nxt %d, rcvif %s, outif %s\n&quot;</span>,
			    ip6_sprintf(&amp;ip6-&gt;ip6_src),
			    ip6_sprintf(&amp;ip6-&gt;ip6_dst),
			    ip6-&gt;ip6_nxt,
			    if_name(m-&gt;m_pkthdr.rcvif), if_name(rt-&gt;rt_ifp));
		}
		<span class="enscript-comment">/* Release extra ref */</span>
		RT_REMREF_LOCKED(rt);
		RT_UNLOCK(rt);
		<span class="enscript-keyword">if</span> (mcopy) {
			icmp6_error(mcopy, ICMP6_DST_UNREACH,
				    ICMP6_DST_UNREACH_BEYONDSCOPE, 0);
		}
		m_freem(m);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-comment">/*
	 * Destination scope check: if a packet is going to break the scope
	 * zone of packet's destination address, discard it.  This case should
	 * usually be prevented by appropriately-configured routing table, but
	 * we need an explicit check because we may mistakenly forward the
	 * packet to a different zone by (e.g.) a default route.
	 */</span>
	dst_in6 = ip6-&gt;ip6_dst;
	<span class="enscript-keyword">if</span> (in6_setscope(&amp;dst_in6, m-&gt;m_pkthdr.rcvif, &amp;inzone) != 0 ||
	    in6_setscope(&amp;dst_in6, rt-&gt;rt_ifp, &amp;outzone) != 0 ||
	    inzone != outzone) {
		ip6stat.ip6s_cantforward++;
		ip6stat.ip6s_badscope++;
		m_freem(m);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &gt; rt-&gt;rt_ifp-&gt;if_mtu) {
		in6_ifstat_inc(rt-&gt;rt_ifp, ifs6_in_toobig);
		<span class="enscript-keyword">if</span> (mcopy) {
			uint32_t mtu;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
			<span class="enscript-type">struct</span> secpolicy *sp2;
			<span class="enscript-type">int</span> ipsecerror;
			size_t ipsechdrsiz;
#<span class="enscript-reference">endif</span>

			mtu = rt-&gt;rt_ifp-&gt;if_mtu;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
			<span class="enscript-comment">/*
			 * When we do IPsec tunnel ingress, we need to play
			 * with the link value (decrement IPsec header size
			 * from mtu value).  The code is much simpler than v4
			 * case, as we have the outgoing interface for
			 * encapsulated packet as &quot;rt-&gt;rt_ifp&quot;.
			 */</span>
			sp2 = ipsec6_getpolicybyaddr(mcopy, IPSEC_DIR_OUTBOUND,
				IP_FORWARDING, &amp;ipsecerror);
			<span class="enscript-keyword">if</span> (sp2) {
				ipsechdrsiz = ipsec6_hdrsiz(mcopy,
					IPSEC_DIR_OUTBOUND, NULL);
				<span class="enscript-keyword">if</span> (ipsechdrsiz &lt; mtu)
					mtu -= ipsechdrsiz;
				key_freesp(sp2, KEY_SADB_UNLOCKED);
			}
			<span class="enscript-comment">/*
			 * if mtu becomes less than minimum MTU,
			 * tell minimum MTU (and I'll need to fragment it).
			 */</span>
			<span class="enscript-keyword">if</span> (mtu &lt; IPV6_MMTU)
				mtu = IPV6_MMTU;
#<span class="enscript-reference">endif</span>
			<span class="enscript-comment">/* Release extra ref */</span>
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
			icmp6_error(mcopy, ICMP6_PACKET_TOO_BIG, 0, mtu);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Release extra ref */</span>
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
		}
		m_freem(m);
		<span class="enscript-keyword">return</span> (NULL);
 	}

	<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_GATEWAY)
		dst = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)rt-&gt;rt_gateway;

	<span class="enscript-comment">/*
	 * If we are to forward the packet using the same interface
	 * as one we got the packet from, perhaps we should send a redirect
	 * to sender to shortcut a hop.
	 * Only send redirect if source is sending directly to us,
	 * and if packet was not source routed (or has any options).
	 * Also, don't send redirect if forwarding using a route
	 * modified by a redirect.
	 */</span>
	<span class="enscript-keyword">if</span> (!proxy &amp;&amp;
	    ip6_sendredirects &amp;&amp; rt-&gt;rt_ifp == m-&gt;m_pkthdr.rcvif &amp;&amp; !srcrt &amp;&amp;
	    (rt-&gt;rt_flags &amp; (RTF_DYNAMIC|RTF_MODIFIED)) == 0) {
		<span class="enscript-keyword">if</span> ((rt-&gt;rt_ifp-&gt;if_flags &amp; IFF_POINTOPOINT) != 0) {
			<span class="enscript-comment">/*
			 * If the incoming interface is equal to the outgoing
			 * one, and the link attached to the interface is
			 * point-to-point, then it will be highly probable
			 * that a routing loop occurs. Thus, we immediately
			 * drop the packet and send an ICMPv6 error message.
			 *
			 * type/code is based on suggestion by Rich Draves.
			 * not sure if it is the best pick.
			 */</span>
			RT_REMREF_LOCKED(rt);	<span class="enscript-comment">/* Release extra ref */</span>
			RT_UNLOCK(rt);
			icmp6_error(mcopy, ICMP6_DST_UNREACH,
				    ICMP6_DST_UNREACH_ADDR, 0);
			m_freem(m);
			<span class="enscript-keyword">return</span> (NULL);
		}
		type = ND_REDIRECT;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFW2</span>
	<span class="enscript-comment">/*
	 * Check with the firewall...
	 */</span>
	<span class="enscript-keyword">if</span> (ip6_fw_enable &amp;&amp; ip6_fw_chk_ptr) {
		u_short port = 0;
		ifp = rt-&gt;rt_ifp;
		<span class="enscript-comment">/* Drop the lock but retain the extra ref */</span>
		RT_UNLOCK(rt);
		<span class="enscript-comment">/* If ipfw says divert, we have to just drop packet */</span>
		<span class="enscript-keyword">if</span> (ip6_fw_chk_ptr(&amp;ip6, ifp, &amp;port, &amp;m)) {
			m_freem(m);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freecopy</span>;
		}
		<span class="enscript-keyword">if</span> (!m) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freecopy</span>;
		}
		<span class="enscript-comment">/* We still have the extra ref on rt */</span>
		RT_LOCK(rt);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Fake scoped addresses. Note that even link-local source or
	 * destinaion can appear, if the originating node just sends the
	 * packet to us (without address resolution for the destination).
	 * Since both icmp6_error and icmp6_redirect_output fill the embedded
	 * link identifiers, we can do this stuff after making a copy for
	 * returning an error.
	 */</span>
	<span class="enscript-keyword">if</span> ((rt-&gt;rt_ifp-&gt;if_flags &amp; IFF_LOOPBACK) != 0) {
		<span class="enscript-comment">/*
		 * See corresponding comments in ip6_output.
		 * XXX: but is it possible that ip6_forward() sends a packet
		 *      to a loopback interface? I don't think so, and thus
		 *      I bark here. (<a href="mailto:jinmei@kame.net">jinmei@kame.net</a>)
		 * XXX: it is common to route invalid packets to loopback.
		 *	also, the codepath will be visited on use of ::1 in
		 *	rthdr. (itojun)
		 */</span>
#<span class="enscript-reference">if</span> 1
		<span class="enscript-keyword">if</span> ((0))
#<span class="enscript-reference">else</span>
		<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; (RTF_BLACKHOLE|RTF_REJECT)) == 0)
#<span class="enscript-reference">endif</span>
		{
			printf(<span class="enscript-string">&quot;ip6_forward: outgoing interface is loopback. &quot;</span>
				<span class="enscript-string">&quot;src %s, dst %s, nxt %d, rcvif %s, outif %s\n&quot;</span>,
				ip6_sprintf(&amp;ip6-&gt;ip6_src),
				ip6_sprintf(&amp;ip6-&gt;ip6_dst),
				ip6-&gt;ip6_nxt, if_name(m-&gt;m_pkthdr.rcvif),
				if_name(rt-&gt;rt_ifp));
		}

		<span class="enscript-comment">/* we can just use rcvif in forwarding. */</span>
		origifp = rcvifp = m-&gt;m_pkthdr.rcvif;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nd6_prproxy) {
		<span class="enscript-comment">/*
		 * In the prefix proxying case, we need to inform nd6_output()
		 * about the inbound interface, so that any subsequent NS
		 * packets generated by nd6_prproxy_ns_output() will not be
		 * sent back to that same interface.
		 */</span>
		origifp = rcvifp = m-&gt;m_pkthdr.rcvif;
	} <span class="enscript-keyword">else</span> {
		rcvifp = m-&gt;m_pkthdr.rcvif;
		origifp = rt-&gt;rt_ifp;
	}
	<span class="enscript-comment">/*
	 * clear embedded scope identifiers if necessary.
	 * in6_clearscope will touch the addresses only when necessary.
	 */</span>
	in6_clearscope(&amp;ip6-&gt;ip6_src);
	in6_clearscope(&amp;ip6-&gt;ip6_dst);

	ifp = rt-&gt;rt_ifp;
	<span class="enscript-comment">/* Drop the lock but retain the extra ref */</span>
	RT_UNLOCK(rt);

	<span class="enscript-comment">/*
	 * If this is to be processed locally, let ip6_input have it.
	 */</span>
	<span class="enscript-keyword">if</span> (proxy) {
		VERIFY(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_PROXY_DST);
		<span class="enscript-comment">/* Release extra ref */</span>
		RT_REMREF(rt);
		<span class="enscript-keyword">if</span> (mcopy != NULL)
			m_freem(mcopy);
		<span class="enscript-keyword">return</span> (m);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
	<span class="enscript-comment">/* Invoke outbound packet filter */</span>
	error = pf_af_hook(ifp, NULL, &amp;m, AF_INET6, FALSE, NULL);

	<span class="enscript-keyword">if</span> (error != 0 || m == NULL) {
		<span class="enscript-keyword">if</span> (m != NULL) {
			panic(<span class="enscript-string">&quot;%s: unexpected packet %p\n&quot;</span>, __func__, m);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		<span class="enscript-comment">/* Already freed by callee */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">senderr</span>;
	}
	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

	<span class="enscript-comment">/* Mark this packet as being forwarded from another interface */</span>
	m-&gt;m_pkthdr.pkt_flags |= PKTF_FORWARDED;
	len = m_pktlen(m);

	error = nd6_output(ifp, origifp, m, dst, rt, NULL);
	<span class="enscript-keyword">if</span> (error) {
		in6_ifstat_inc(ifp, ifs6_out_discard);
		ip6stat.ip6s_cantforward++;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Increment stats on the source interface; the ones
		 * for destination interface has been taken care of
		 * during output above by virtue of PKTF_FORWARDED.
		 */</span>
		rcvifp-&gt;if_fpackets++;
		rcvifp-&gt;if_fbytes += len;

		ip6stat.ip6s_forward++;
		in6_ifstat_inc(ifp, ifs6_out_forward);
		<span class="enscript-keyword">if</span> (type)
			ip6stat.ip6s_redirectsent++;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (mcopy) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">freecopy</span>;
			}
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
<span class="enscript-reference">senderr</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>
	<span class="enscript-keyword">if</span> (mcopy == NULL) {
		<span class="enscript-comment">/* Release extra ref */</span>
		RT_REMREF(rt);
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-keyword">switch</span> (error) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
#<span class="enscript-reference">if</span> 1
		<span class="enscript-keyword">if</span> (type == ND_REDIRECT) {
			icmp6_redirect_output(mcopy, rt);
			<span class="enscript-comment">/* Release extra ref */</span>
			RT_REMREF(rt);
			<span class="enscript-keyword">return</span> (NULL);
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freecopy</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">EMSGSIZE</span>:
		<span class="enscript-comment">/* xxx MTU is constant in PPP? */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freecopy</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOBUFS</span>:
		<span class="enscript-comment">/* Tell source to slow down like source quench in IP? */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freecopy</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETUNREACH</span>:	<span class="enscript-comment">/* shouldn't happen, checked above */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTUNREACH</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETDOWN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTDOWN</span>:
	<span class="enscript-reference">default</span>:
		type = ICMP6_DST_UNREACH;
		code = ICMP6_DST_UNREACH_ADDR;
		<span class="enscript-keyword">break</span>;
	}
	icmp6_error(mcopy, type, code, 0);
	<span class="enscript-comment">/* Release extra ref */</span>
	RT_REMREF(rt);
	<span class="enscript-keyword">return</span> (NULL);

 <span class="enscript-reference">freecopy</span>:
	m_freem(mcopy);
	<span class="enscript-comment">/* Release extra ref */</span>
	RT_REMREF(rt);
	<span class="enscript-keyword">return</span> (NULL);
}
</pre>
<hr />
</body></html>