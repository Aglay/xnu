<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ip6_fw.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ip6_fw.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$FreeBSD: src/sys/netinet6/ip6_fw.c,v 1.2.2.9 2002/04/28 05:40:27 suz Exp $	*/</span>
<span class="enscript-comment">/*	$KAME: ip6_fw.c,v 1.21 2001/01/24 01:25:32 itojun Exp $	*/</span>

<span class="enscript-comment">/*
 * Copyright (C) 1998, 1999, 2000 and 2001 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

<span class="enscript-comment">/*
 * Copyright (c) 1993 Daniel Boulet
 * Copyright (c) 1994 Ugen J.S.Antsilevich
 * Copyright (c) 1996 Alex Nash
 *
 * Redistribution and use in source forms, with and without modification,
 * are permitted provided that this entire comment appears intact.
 *
 * Redistribution in binary form may occur without any restrictions.
 * Obviously, it would be nice if you gave credit where credit is due
 * but requiring it would be too onerous.
 *
 * This software is provided ``AS IS'' without any warranties of any kind.
 */</span>

<span class="enscript-comment">/*
 * Implement IPv6 packet firewall
 */</span>


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IP6DIVERT</span>
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;NOT SUPPORTED IPV6 DIVERT&quot;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IP6FW_DIVERT_RESTART</span>
#<span class="enscript-reference">error</span> <span class="enscript-string">&quot;NOT SUPPORTED IPV6 DIVERT&quot;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/spl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_event.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_fw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_seq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_timer.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>

<span class="enscript-function-name">MALLOC_DEFINE</span>(M_IP6FW, <span class="enscript-string">&quot;Ip6Fw/Ip6Acct&quot;</span>, <span class="enscript-string">&quot;Ip6Fw/Ip6Acct chain's&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> fw6_debug = 0;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IPV6FIREWALL_VERBOSE</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> fw6_verbose = 1;
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> fw6_verbose = 0;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IPV6FIREWALL_VERBOSE_LIMIT</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> fw6_verbose_limit = IPV6FIREWALL_VERBOSE_LIMIT;
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> fw6_verbose_limit = 0;
#<span class="enscript-reference">endif</span>

<span class="enscript-function-name">LIST_HEAD</span> (ip6_fw_head, ip6_fw_chain) ip6_fw_chain;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ip6fw_kev_post_msg</span>(u_int32_t );

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SYSCTL_NODE</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip6fw_sysctl SYSCTL_HANDLER_ARGS;

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_inet6_ip6);
<span class="enscript-function-name">SYSCTL_NODE</span>(_net_inet6_ip6, OID_AUTO, fw, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;Firewall&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet6_ip6_fw, OID_AUTO, enable, 
	CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ip6_fw_enable, 0, ip6fw_sysctl, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Enable ip6fw&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ip6_fw, OID_AUTO, debug, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;fw6_debug, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ip6_fw, OID_AUTO, verbose, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;fw6_verbose, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ip6_fw, OID_AUTO, verbose_limit, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;fw6_verbose_limit, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
ip6fw_sysctl SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error;
	
	error = sysctl_handle_int(oidp, oidp-&gt;oid_arg1, oidp-&gt;oid_arg2, req);
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr)
		<span class="enscript-keyword">return</span> (error);
	
	ip6fw_kev_post_msg(KEV_IP6FW_ENABLE);
	
	<span class="enscript-keyword">return</span> error;
}

#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">dprintf</span>(a)	do {						\
				<span class="enscript-keyword">if</span> (fw6_debug)				\
					printf a;			\
			} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SNPARGS</span>(buf, len) buf + len, sizeof(buf) &gt; len ? sizeof(buf) - len : 0

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	add_entry6 __P((<span class="enscript-type">struct</span> ip6_fw_head *chainptr, <span class="enscript-type">struct</span> ip6_fw *frwl));
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	del_entry6 __P((<span class="enscript-type">struct</span> ip6_fw_head *chainptr, u_short number));
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	zero_entry6 __P((<span class="enscript-type">struct</span> ip6_fw *frwl));
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ip6_fw *check_ip6fw_struct <span class="enscript-function-name">__P</span>((<span class="enscript-type">struct</span> ip6_fw *m));
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	ip6opts_match __P((<span class="enscript-type">struct</span> ip6_hdr **ip6, <span class="enscript-type">struct</span> ip6_fw *f,
				   <span class="enscript-type">struct</span> mbuf **m,
				   <span class="enscript-type">int</span> *off, <span class="enscript-type">int</span> *nxt, u_short *offset));
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	port_match6 __P((u_short *portptr, <span class="enscript-type">int</span> nports, u_short port,
				<span class="enscript-type">int</span> range_flag));
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	tcp6flg_match __P((<span class="enscript-type">struct</span> tcphdr *tcp6, <span class="enscript-type">struct</span> ip6_fw *f));
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	icmp6type_match __P((<span class="enscript-type">struct</span> icmp6_hdr *  icmp, <span class="enscript-type">struct</span> ip6_fw * f));
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	ip6fw_report __P((<span class="enscript-type">struct</span> ip6_fw *f, <span class="enscript-type">struct</span> ip6_hdr *ip6,
				<span class="enscript-type">struct</span> ifnet *rif, <span class="enscript-type">struct</span> ifnet *oif, <span class="enscript-type">int</span> off, <span class="enscript-type">int</span> nxt));

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	ip6_fw_chk __P((<span class="enscript-type">struct</span> ip6_hdr **pip6,
			<span class="enscript-type">struct</span> ifnet *oif, u_int16_t *cookie, <span class="enscript-type">struct</span> mbuf **m));
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	ip6_fw_ctl __P((<span class="enscript-type">struct</span> sockopt *));
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cp_to_user_64</span>( <span class="enscript-type">struct</span> ip6_fw_64 *userrule_64, <span class="enscript-type">struct</span> ip6_fw *rule);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cp_from_user_64</span>( <span class="enscript-type">struct</span> ip6_fw_64 *userrule_64, <span class="enscript-type">struct</span> ip6_fw *rule);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cp_to_user_32</span>( <span class="enscript-type">struct</span> ip6_fw_32 *userrule_32, <span class="enscript-type">struct</span> ip6_fw *rule);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cp_from_user_32</span>( <span class="enscript-type">struct</span> ip6_fw_32 *userrule_32, <span class="enscript-type">struct</span> ip6_fw *rule);

<span class="enscript-type">static</span> <span class="enscript-type">char</span> err_prefix[] = <span class="enscript-string">&quot;ip6_fw_ctl:&quot;</span>;

<span class="enscript-comment">/*
 * Returns 1 if the port is matched by the vector, 0 otherwise
 */</span>
<span class="enscript-type">static</span>
__inline <span class="enscript-type">int</span>
<span class="enscript-function-name">port_match6</span>(u_short *portptr, <span class="enscript-type">int</span> nports, u_short port, <span class="enscript-type">int</span> range_flag)
{
	<span class="enscript-keyword">if</span> (!nports)
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">if</span> (range_flag) {
		<span class="enscript-keyword">if</span> (portptr[0] &lt;= port &amp;&amp; port &lt;= portptr[1]) {
			<span class="enscript-keyword">return</span> 1;
		}
		nports -= 2;
		portptr += 2;
	}
	<span class="enscript-keyword">while</span> (nports-- &gt; 0) {
		<span class="enscript-keyword">if</span> (*portptr++ == port) {
			<span class="enscript-keyword">return</span> 1;
		}
	}
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">tcp6flg_match</span>(<span class="enscript-type">struct</span> tcphdr *tcp6, <span class="enscript-type">struct</span> ip6_fw *f)
{
	u_char		flg_set, flg_clr;
	
	<span class="enscript-comment">/*
	 * If an established connection is required, reject packets that
	 * have only SYN of RST|ACK|SYN set.  Otherwise, fall through to
	 * other flag requirements.
	 */</span>
	<span class="enscript-keyword">if</span> ((f-&gt;fw_ipflg &amp; IPV6_FW_IF_TCPEST) &amp;&amp;
	    ((tcp6-&gt;th_flags &amp; (IPV6_FW_TCPF_RST | IPV6_FW_TCPF_ACK |
	    IPV6_FW_TCPF_SYN)) == IPV6_FW_TCPF_SYN))
		<span class="enscript-keyword">return</span> 0;

	flg_set = tcp6-&gt;th_flags &amp; f-&gt;fw_tcpf;
	flg_clr = tcp6-&gt;th_flags &amp; f-&gt;fw_tcpnf;

	<span class="enscript-keyword">if</span> (flg_set != f-&gt;fw_tcpf)
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">if</span> (flg_clr)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">return</span> 1;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">icmp6type_match</span>(<span class="enscript-type">struct</span> icmp6_hdr *icmp6, <span class="enscript-type">struct</span> ip6_fw *f)
{
	<span class="enscript-type">int</span> type;

	<span class="enscript-keyword">if</span> (!(f-&gt;fw_flg &amp; IPV6_FW_F_ICMPBIT))
		<span class="enscript-keyword">return</span>(1);

	type = icmp6-&gt;icmp6_type;

	<span class="enscript-comment">/* check for matching type in the bitmap */</span>
	<span class="enscript-keyword">if</span> (type &lt; IPV6_FW_ICMPTYPES_DIM * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span>) * 8 &amp;&amp;
		(f-&gt;fw_icmp6types[type / (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span>) * 8)] &amp;
		(1U &lt;&lt; (type % (8 * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span>))))))
		<span class="enscript-keyword">return</span>(1);

	<span class="enscript-keyword">return</span>(0); <span class="enscript-comment">/* no match */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">is_icmp6_query</span>(<span class="enscript-type">struct</span> ip6_hdr *ip6, <span class="enscript-type">int</span> off)
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> icmp6_hdr *icmp6;
	<span class="enscript-type">int</span> icmp6_type;

	icmp6 = (<span class="enscript-type">struct</span> icmp6_hdr *)((caddr_t)ip6 + off);
	icmp6_type = icmp6-&gt;icmp6_type;

	<span class="enscript-keyword">if</span> (icmp6_type == ICMP6_ECHO_REQUEST ||
	    icmp6_type == ICMP6_MEMBERSHIP_QUERY ||
	    icmp6_type == ICMP6_WRUREQUEST ||
	    icmp6_type == ICMP6_FQDN_QUERY ||
	    icmp6_type == ICMP6_NI_QUERY)
		<span class="enscript-keyword">return</span>(1);

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip6opts_match</span>(<span class="enscript-type">struct</span> ip6_hdr **pip6, <span class="enscript-type">struct</span> ip6_fw *f, <span class="enscript-type">struct</span> mbuf **m,
	      <span class="enscript-type">int</span> *off, <span class="enscript-type">int</span> *nxt, u_short *offset)
{
	<span class="enscript-type">int</span> len;
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = *pip6;
	<span class="enscript-type">struct</span> ip6_ext *ip6e;
	u_char	opts, nopts, nopts_sve;

	opts = f-&gt;fw_ip6opt;
	nopts = nopts_sve = f-&gt;fw_ip6nopt;

	*nxt = ip6-&gt;ip6_nxt;
	*off = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
	len = ntohs(ip6-&gt;ip6_plen) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
	<span class="enscript-keyword">while</span> (*off &lt; len) {
		ip6e = (<span class="enscript-type">struct</span> ip6_ext *)((caddr_t) ip6 + *off);
		<span class="enscript-keyword">if</span> ((*m)-&gt;m_len &lt; *off + <span class="enscript-keyword">sizeof</span>(*ip6e))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">opts_check</span>;	<span class="enscript-comment">/* XXX */</span>

		<span class="enscript-keyword">switch</span>(*nxt) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_FRAGMENT</span>:
			<span class="enscript-keyword">if</span> ((*m)-&gt;m_len &gt;= *off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_frag)) {
				<span class="enscript-type">struct</span> ip6_frag *ip6f;

				ip6f = (<span class="enscript-type">struct</span> ip6_frag *) ((caddr_t)ip6 + *off);
				*offset = ip6f-&gt;ip6f_offlg &amp; IP6F_OFF_MASK;
			}
			opts &amp;= ~IPV6_FW_IP6OPT_FRAG;
			nopts &amp;= ~IPV6_FW_IP6OPT_FRAG;
			*off += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_frag);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
			opts &amp;= ~IPV6_FW_IP6OPT_AH;
			nopts &amp;= ~IPV6_FW_IP6OPT_AH;
			*off += (ip6e-&gt;ip6e_len + 2) &lt;&lt; 2;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">switch</span> (*nxt) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_HOPOPTS</span>:
				opts &amp;= ~IPV6_FW_IP6OPT_HOPOPT;
				nopts &amp;= ~IPV6_FW_IP6OPT_HOPOPT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ROUTING</span>:
				opts &amp;= ~IPV6_FW_IP6OPT_ROUTE;
				nopts &amp;= ~IPV6_FW_IP6OPT_ROUTE;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
				opts &amp;= ~IPV6_FW_IP6OPT_ESP;
				nopts &amp;= ~IPV6_FW_IP6OPT_ESP;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_NONE</span>:
				opts &amp;= ~IPV6_FW_IP6OPT_NONXT;
				nopts &amp;= ~IPV6_FW_IP6OPT_NONXT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">opts_check</span>;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_DSTOPTS</span>:
				opts &amp;= ~IPV6_FW_IP6OPT_OPTS;
				nopts &amp;= ~IPV6_FW_IP6OPT_OPTS;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">opts_check</span>;
				<span class="enscript-keyword">break</span>;
			}
			*off += (ip6e-&gt;ip6e_len + 1) &lt;&lt; 3;
			<span class="enscript-keyword">break</span>;
		}
		*nxt = ip6e-&gt;ip6e_nxt;

	}
 <span class="enscript-reference">opts_check</span>:
	<span class="enscript-keyword">if</span> (f-&gt;fw_ip6opt == f-&gt;fw_ip6nopt)	<span class="enscript-comment">/* XXX */</span>
		<span class="enscript-keyword">return</span> 1;

	<span class="enscript-keyword">if</span> (opts == 0 &amp;&amp; nopts == nopts_sve)
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span>
__inline <span class="enscript-type">int</span>
<span class="enscript-function-name">iface_match</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">union</span> ip6_fw_if *ifu, <span class="enscript-type">int</span> byname)
{
	<span class="enscript-comment">/* Check by name or by IP address */</span>
	<span class="enscript-keyword">if</span> (byname) {
		<span class="enscript-comment">/* Check unit number (-1 is wildcard) */</span>
		<span class="enscript-keyword">if</span> (ifu-&gt;fu_via_if.unit != -1
		    &amp;&amp; ifp-&gt;if_unit != ifu-&gt;fu_via_if.unit)
			<span class="enscript-keyword">return</span>(0);
		<span class="enscript-comment">/* Check name */</span>
		<span class="enscript-keyword">if</span> (strncmp(ifp-&gt;if_name, ifu-&gt;fu_via_if.name, IP6FW_IFNLEN))
			<span class="enscript-keyword">return</span>(0);
		<span class="enscript-keyword">return</span>(1);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!IN6_IS_ADDR_UNSPECIFIED(&amp;ifu-&gt;fu_via_ip6)) {	<span class="enscript-comment">/* Zero == wildcard */</span>
		<span class="enscript-type">struct</span> ifaddr *ia;

		ifnet_lock_shared(ifp);
		<span class="enscript-keyword">for</span> (ia = ifp-&gt;if_addrlist.tqh_first; ia;
		    ia = ia-&gt;ifa_list.tqe_next)
		{
			IFA_LOCK_SPIN(ia);
			<span class="enscript-keyword">if</span> (ia-&gt;ifa_addr-&gt;sa_family != AF_INET6) {
				IFA_UNLOCK(ia);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (!IN6_ARE_ADDR_EQUAL(&amp;ifu-&gt;fu_via_ip6,
			    &amp;(((<span class="enscript-type">struct</span> sockaddr_in6 *)
			    (ia-&gt;ifa_addr))-&gt;sin6_addr))) {
				IFA_UNLOCK(ia);
				<span class="enscript-keyword">continue</span>;
			}
			IFA_UNLOCK(ia);
			ifnet_lock_done(ifp);
			<span class="enscript-keyword">return</span>(1);
		}
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">return</span>(0);
	}
	<span class="enscript-keyword">return</span>(1);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip6fw_report</span>(<span class="enscript-type">struct</span> ip6_fw *f, <span class="enscript-type">struct</span> ip6_hdr *ip6,
	<span class="enscript-type">struct</span> ifnet *rif, <span class="enscript-type">struct</span> ifnet *oif, <span class="enscript-type">int</span> off, <span class="enscript-type">int</span> nxt)
{
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> counter;
	<span class="enscript-type">struct</span> tcphdr *<span class="enscript-type">const</span> tcp6 = (<span class="enscript-type">struct</span> tcphdr *) ((caddr_t) ip6+ off);
	<span class="enscript-type">struct</span> udphdr *<span class="enscript-type">const</span> udp = (<span class="enscript-type">struct</span> udphdr *) ((caddr_t) ip6+ off);
	<span class="enscript-type">struct</span> icmp6_hdr *<span class="enscript-type">const</span> icmp6 = (<span class="enscript-type">struct</span> icmp6_hdr *) ((caddr_t) ip6+ off);
	<span class="enscript-type">int</span> count;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *action;
	<span class="enscript-type">char</span> action2[32], proto[102], name[18];
	<span class="enscript-type">int</span> len;

	count = f ? f-&gt;fw_pcnt : ++counter;
	<span class="enscript-keyword">if</span> (fw6_verbose_limit != 0 &amp;&amp; count &gt; fw6_verbose_limit)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* Print command name */</span>
	snprintf(SNPARGS(name, 0), <span class="enscript-string">&quot;ip6fw: %d&quot;</span>, f ? f-&gt;fw_number : -1);

	action = action2;
	<span class="enscript-keyword">if</span> (!f)
		action = <span class="enscript-string">&quot;Refuse&quot;</span>;
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">switch</span> (f-&gt;fw_flg &amp; IPV6_FW_F_COMMAND) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_DENY</span>:
			action = <span class="enscript-string">&quot;Deny&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_REJECT</span>:
			<span class="enscript-keyword">if</span> (f-&gt;fw_reject_code == IPV6_FW_REJECT_RST)
				action = <span class="enscript-string">&quot;Reset&quot;</span>;
			<span class="enscript-keyword">else</span>
				action = <span class="enscript-string">&quot;Unreach&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_ACCEPT</span>:
			action = <span class="enscript-string">&quot;Accept&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_COUNT</span>:
			action = <span class="enscript-string">&quot;Count&quot;</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_DIVERT</span>:
			snprintf(SNPARGS(action2, 0), <span class="enscript-string">&quot;Divert %d&quot;</span>,
			    f-&gt;fw_divert_port);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_TEE</span>:
			snprintf(SNPARGS(action2, 0), <span class="enscript-string">&quot;Tee %d&quot;</span>,
			    f-&gt;fw_divert_port);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_SKIPTO</span>:
			snprintf(SNPARGS(action2, 0), <span class="enscript-string">&quot;SkipTo %d&quot;</span>,
			    f-&gt;fw_skipto_rule);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:	
			action = <span class="enscript-string">&quot;UNKNOWN&quot;</span>;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">switch</span> (nxt) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
		len = snprintf(SNPARGS(proto, 0), <span class="enscript-string">&quot;TCP [%s]&quot;</span>,
		    ip6_sprintf(&amp;ip6-&gt;ip6_src));
		<span class="enscript-keyword">if</span> (off &gt; 0)
			len += snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot;:%d &quot;</span>,
			    ntohs(tcp6-&gt;th_sport));
		<span class="enscript-keyword">else</span>
			len += snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot; &quot;</span>);
		len += snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot;[%s]&quot;</span>,
		    ip6_sprintf(&amp;ip6-&gt;ip6_dst));
		<span class="enscript-keyword">if</span> (off &gt; 0)
			snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot;:%d&quot;</span>,
			    ntohs(tcp6-&gt;th_dport));
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
		len = snprintf(SNPARGS(proto, 0), <span class="enscript-string">&quot;UDP [%s]&quot;</span>,
		    ip6_sprintf(&amp;ip6-&gt;ip6_src));
		<span class="enscript-keyword">if</span> (off &gt; 0)
			len += snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot;:%d &quot;</span>,
			    ntohs(udp-&gt;uh_sport));
		<span class="enscript-keyword">else</span>
		    len += snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot; &quot;</span>);
		len += snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot;[%s]&quot;</span>,
		    ip6_sprintf(&amp;ip6-&gt;ip6_dst));
		<span class="enscript-keyword">if</span> (off &gt; 0)
			snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot;:%d&quot;</span>,
			    ntohs(udp-&gt;uh_dport));
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
		<span class="enscript-keyword">if</span> (off &gt; 0)
			len = snprintf(SNPARGS(proto, 0), <span class="enscript-string">&quot;IPV6-ICMP:%u.%u &quot;</span>,
			    icmp6-&gt;icmp6_type, icmp6-&gt;icmp6_code);
		<span class="enscript-keyword">else</span>
			len = snprintf(SNPARGS(proto, 0), <span class="enscript-string">&quot;IPV6-ICMP &quot;</span>);
		len += snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot;[%s]&quot;</span>,
		    ip6_sprintf(&amp;ip6-&gt;ip6_src));
		snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot; [%s]&quot;</span>,
		    ip6_sprintf(&amp;ip6-&gt;ip6_dst));
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		len = snprintf(SNPARGS(proto, 0), <span class="enscript-string">&quot;P:%d [%s]&quot;</span>, nxt,
		    ip6_sprintf(&amp;ip6-&gt;ip6_src));
		snprintf(SNPARGS(proto, len), <span class="enscript-string">&quot; [%s]&quot;</span>,
		    ip6_sprintf(&amp;ip6-&gt;ip6_dst));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (oif)
		log(LOG_AUTHPRIV | LOG_INFO, <span class="enscript-string">&quot;%s %s %s out via %s\n&quot;</span>,
		    name, action, proto, if_name(oif));
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rif)
		log(LOG_AUTHPRIV | LOG_INFO, <span class="enscript-string">&quot;%s %s %s in via %s\n&quot;</span>,
		    name, action, proto, if_name(rif));
	<span class="enscript-keyword">else</span>
		log(LOG_AUTHPRIV | LOG_INFO, <span class="enscript-string">&quot;%s %s %s&quot;</span>,
		    name, action, proto);
	<span class="enscript-keyword">if</span> (fw6_verbose_limit != 0 &amp;&amp; count == fw6_verbose_limit)
	    log(LOG_AUTHPRIV | LOG_INFO, <span class="enscript-string">&quot;ip6fw: limit reached on entry %d\n&quot;</span>,
		f ? f-&gt;fw_number : -1);
}

<span class="enscript-comment">/*
 * Parameters:
 *
 *	ip	Pointer to packet header (struct ip6_hdr *)
 *	hlen	Packet header length
 *	oif	Outgoing interface, or NULL if packet is incoming
 * #ifndef IP6FW_DIVERT_RESTART
 *	*cookie	Ignore all divert/tee rules to this port (if non-zero)
 * #else
 *	*cookie Skip up to the first rule past this rule number;
 * #endif
 *	*m	The packet; we set to NULL when/if we nuke it.
 *
 * Return value:
 *
 *	0	The packet is to be accepted and routed normally OR
 *      	the packet was denied/rejected and has been dropped;
 *		in the latter case, *m is equal to NULL upon return.
 *	port	Divert the packet to port.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_fw_chk</span>(<span class="enscript-type">struct</span> ip6_hdr **pip6,
	<span class="enscript-type">struct</span> ifnet *oif, u_int16_t *cookie, <span class="enscript-type">struct</span> mbuf **m)
{
	<span class="enscript-type">struct</span> ip6_fw_chain *chain;
	<span class="enscript-type">struct</span> ip6_fw *rule = NULL;
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = *pip6;
	<span class="enscript-type">struct</span> ifnet *<span class="enscript-type">const</span> rif = ((*m)-&gt;m_flags &amp; M_LOOP) ? lo_ifp : (*m)-&gt;m_pkthdr.rcvif;
	u_short offset = 0;
	<span class="enscript-type">int</span> off = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr), nxt = ip6-&gt;ip6_nxt;
	u_short src_port, dst_port;
#<span class="enscript-reference">ifdef</span>	<span class="enscript-variable-name">IP6FW_DIVERT_RESTART</span>
	u_int16_t skipto = *cookie;
#<span class="enscript-reference">else</span>
	u_int16_t ignport = ntohs(*cookie);
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">struct</span> timeval timenow;
	<span class="enscript-type">struct</span> tcp_respond_args tra;

	getmicrotime(&amp;timenow);

	*cookie = 0;
	<span class="enscript-comment">/*
	 * Go down the chain, looking for enlightment
	 * #ifdef IP6FW_DIVERT_RESTART
	 * If we've been asked to start at a given rule immediatly, do so.
	 * #endif
	 */</span>
	chain = LIST_FIRST(&amp;ip6_fw_chain);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IP6FW_DIVERT_RESTART</span>
	<span class="enscript-keyword">if</span> (skipto) {
		<span class="enscript-keyword">if</span> (skipto &gt;= 65535)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropit</span>;
		<span class="enscript-keyword">while</span> (chain &amp;&amp; (chain-&gt;rule-&gt;fw_number &lt;= skipto)) {
			chain = LIST_NEXT(chain, chain);
		}
		<span class="enscript-keyword">if</span> (! chain) <span class="enscript-keyword">goto</span> <span class="enscript-reference">dropit</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IP6FW_DIVERT_RESTART */</span>
	<span class="enscript-keyword">for</span> (; chain; chain = LIST_NEXT(chain, chain)) {
		<span class="enscript-type">struct</span> ip6_fw *<span class="enscript-type">const</span> f = chain-&gt;rule;

		<span class="enscript-keyword">if</span> (oif) {
			<span class="enscript-comment">/* Check direction outbound */</span>
			<span class="enscript-keyword">if</span> (!(f-&gt;fw_flg &amp; IPV6_FW_F_OUT))
				<span class="enscript-keyword">continue</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Check direction inbound */</span>
			<span class="enscript-keyword">if</span> (!(f-&gt;fw_flg &amp; IPV6_FW_F_IN))
				<span class="enscript-keyword">continue</span>;
		}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IN6_ARE_ADDR_MASKEQUAL</span>(x,y,z) (\
	(((x)-&gt;s6_addr32[0] &amp; (y)-&gt;s6_addr32[0]) == (z)-&gt;s6_addr32[0]) &amp;&amp; \
	(((x)-&gt;s6_addr32[1] &amp; (y)-&gt;s6_addr32[1]) == (z)-&gt;s6_addr32[1]) &amp;&amp; \
	(((x)-&gt;s6_addr32[2] &amp; (y)-&gt;s6_addr32[2]) == (z)-&gt;s6_addr32[2]) &amp;&amp; \
	(((x)-&gt;s6_addr32[3] &amp; (y)-&gt;s6_addr32[3]) == (z)-&gt;s6_addr32[3]))

		<span class="enscript-comment">/* If src-addr doesn't match, not this rule. */</span>
		<span class="enscript-keyword">if</span> (((f-&gt;fw_flg &amp; IPV6_FW_F_INVSRC) != 0) ^
			(!IN6_ARE_ADDR_MASKEQUAL(&amp;ip6-&gt;ip6_src,&amp;f-&gt;fw_smsk,&amp;f-&gt;fw_src)))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/* If dest-addr doesn't match, not this rule. */</span>
		<span class="enscript-keyword">if</span> (((f-&gt;fw_flg &amp; IPV6_FW_F_INVDST) != 0) ^
			(!IN6_ARE_ADDR_MASKEQUAL(&amp;ip6-&gt;ip6_dst,&amp;f-&gt;fw_dmsk,&amp;f-&gt;fw_dst)))
			<span class="enscript-keyword">continue</span>;

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">IN6_ARE_ADDR_MASKEQUAL</span>
		<span class="enscript-comment">/* Interface check */</span>
		<span class="enscript-keyword">if</span> ((f-&gt;fw_flg &amp; IF6_FW_F_VIAHACK) == IF6_FW_F_VIAHACK) {
			<span class="enscript-type">struct</span> ifnet *<span class="enscript-type">const</span> iface = oif ? oif : rif;

			<span class="enscript-comment">/* Backwards compatibility hack for &quot;via&quot; */</span>
			<span class="enscript-keyword">if</span> (!iface || !iface_match(iface,
			    &amp;f-&gt;fw_in_if, f-&gt;fw_flg &amp; IPV6_FW_F_OIFNAME))
				<span class="enscript-keyword">continue</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Check receive interface */</span>
			<span class="enscript-keyword">if</span> ((f-&gt;fw_flg &amp; IPV6_FW_F_IIFACE)
			    &amp;&amp; (!rif || !iface_match(rif,
			      &amp;f-&gt;fw_in_if, f-&gt;fw_flg &amp; IPV6_FW_F_IIFNAME)))
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-comment">/* Check outgoing interface */</span>
			<span class="enscript-keyword">if</span> ((f-&gt;fw_flg &amp; IPV6_FW_F_OIFACE)
			    &amp;&amp; (!oif || !iface_match(oif,
			      &amp;f-&gt;fw_out_if, f-&gt;fw_flg &amp; IPV6_FW_F_OIFNAME)))
				<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/* Check IP options */</span>
		<span class="enscript-keyword">if</span> (!ip6opts_match(&amp;ip6, f, m, &amp;off, &amp;nxt, &amp;offset))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/* Fragments */</span>
		<span class="enscript-keyword">if</span> ((f-&gt;fw_flg &amp; IPV6_FW_F_FRAG) &amp;&amp; !offset)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/* Check protocol; if wildcard, match */</span>
		<span class="enscript-keyword">if</span> (f-&gt;fw_prot == IPPROTO_IPV6)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">got_match</span>;

		<span class="enscript-comment">/* If different, don't match */</span>
		<span class="enscript-keyword">if</span> (nxt != f-&gt;fw_prot)
			<span class="enscript-keyword">continue</span>;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PULLUP_TO</span>(len)	do {						\
			    <span class="enscript-keyword">if</span> ((*m)-&gt;m_len &lt; (len)			\
				&amp;&amp; (*m = m_pullup(*m, (len))) == 0) {	\
				    <span class="enscript-keyword">goto</span> <span class="enscript-reference">dropit</span>;			\
			    }						\
			    *pip6 = ip6 = mtod(*m, <span class="enscript-type">struct</span> ip6_hdr *);	\
			} <span class="enscript-keyword">while</span> (0)

		<span class="enscript-comment">/* Protocol specific checks */</span>
		<span class="enscript-keyword">switch</span> (nxt) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
		    {
			<span class="enscript-type">struct</span> tcphdr *tcp6;

			<span class="enscript-keyword">if</span> (offset == 1) {	<span class="enscript-comment">/* cf. RFC 1858 */</span>
				PULLUP_TO(off + 4); <span class="enscript-comment">/* XXX ? */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bogusfrag</span>;
			}
			<span class="enscript-keyword">if</span> (offset != 0) {
				<span class="enscript-comment">/*
				 * TCP flags and ports aren't available in this
				 * packet -- if this rule specified either one,
				 * we consider the rule a non-match.
				 */</span>
				<span class="enscript-keyword">if</span> (f-&gt;fw_nports != 0 ||
				    f-&gt;fw_tcpf != f-&gt;fw_tcpnf)
					<span class="enscript-keyword">continue</span>;

				<span class="enscript-keyword">break</span>;
			}
			PULLUP_TO(off + 14);
			tcp6 = (<span class="enscript-type">struct</span> tcphdr *) ((caddr_t)ip6 + off);
			<span class="enscript-keyword">if</span> (((f-&gt;fw_tcpf != f-&gt;fw_tcpnf) ||
			   (f-&gt;fw_ipflg &amp; IPV6_FW_IF_TCPEST))  &amp;&amp;
			   !tcp6flg_match(tcp6, f))
				<span class="enscript-keyword">continue</span>;
			src_port = ntohs(tcp6-&gt;th_sport);
			dst_port = ntohs(tcp6-&gt;th_dport);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">check_ports</span>;
		    }

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
		    {
			<span class="enscript-type">struct</span> udphdr *udp;

			<span class="enscript-keyword">if</span> (offset != 0) {
				<span class="enscript-comment">/*
				 * Port specification is unavailable -- if this
				 * rule specifies a port, we consider the rule
				 * a non-match.
				 */</span>
				<span class="enscript-keyword">if</span> (f-&gt;fw_nports != 0)
					<span class="enscript-keyword">continue</span>;

				<span class="enscript-keyword">break</span>;
			}
			PULLUP_TO(off + 4);
			udp = (<span class="enscript-type">struct</span> udphdr *) ((caddr_t)ip6 + off);
			src_port = ntohs(udp-&gt;uh_sport);
			dst_port = ntohs(udp-&gt;uh_dport);
<span class="enscript-reference">check_ports</span>:
			<span class="enscript-keyword">if</span> (!port_match6(&amp;f-&gt;fw_pts[0],
			    IPV6_FW_GETNSRCP(f), src_port,
			    f-&gt;fw_flg &amp; IPV6_FW_F_SRNG))
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (!port_match6(&amp;f-&gt;fw_pts[IPV6_FW_GETNSRCP(f)],
			    IPV6_FW_GETNDSTP(f), dst_port,
			    f-&gt;fw_flg &amp; IPV6_FW_F_DRNG))
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">break</span>;
		    }

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
		    {
			<span class="enscript-type">struct</span> icmp6_hdr *icmp;

			<span class="enscript-keyword">if</span> (offset != 0)	<span class="enscript-comment">/* Type isn't valid */</span>
				<span class="enscript-keyword">break</span>;
			PULLUP_TO(off + 2);
			icmp = (<span class="enscript-type">struct</span> icmp6_hdr *) ((caddr_t)ip6 + off);
			<span class="enscript-keyword">if</span> (!icmp6type_match(icmp, f))
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">break</span>;
		    }
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">PULLUP_TO</span>

<span class="enscript-reference">bogusfrag</span>:
			<span class="enscript-keyword">if</span> (fw6_verbose)
				ip6fw_report(NULL, ip6, rif, oif, off, nxt);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropit</span>;
		}

<span class="enscript-reference">got_match</span>:
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IP6FW_DIVERT_RESTART</span>
		<span class="enscript-comment">/* Ignore divert/tee rule if socket port is &quot;ignport&quot; */</span>
		<span class="enscript-keyword">switch</span> (f-&gt;fw_flg &amp; IPV6_FW_F_COMMAND) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_DIVERT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_TEE</span>:
			<span class="enscript-keyword">if</span> (f-&gt;fw_divert_port == ignport)
				<span class="enscript-keyword">continue</span>;       <span class="enscript-comment">/* ignore this rule */</span>
			<span class="enscript-keyword">break</span>;
		}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IP6FW_DIVERT_RESTART */</span>
		<span class="enscript-comment">/* Update statistics */</span>
		f-&gt;fw_pcnt += 1;
		f-&gt;fw_bcnt += ntohs(ip6-&gt;ip6_plen);
		f-&gt;timestamp = timenow.tv_sec;

		<span class="enscript-comment">/* Log to console if desired */</span>
		<span class="enscript-keyword">if</span> ((f-&gt;fw_flg &amp; IPV6_FW_F_PRN) &amp;&amp; fw6_verbose)
			ip6fw_report(f, ip6, rif, oif, off, nxt);

		<span class="enscript-comment">/* Take appropriate action */</span>
		<span class="enscript-keyword">switch</span> (f-&gt;fw_flg &amp; IPV6_FW_F_COMMAND) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_ACCEPT</span>:
			<span class="enscript-keyword">return</span>(0);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_COUNT</span>:
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_DIVERT</span>:
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IP6FW_DIVERT_RESTART</span>
			*cookie = f-&gt;fw_number;
#<span class="enscript-reference">else</span>
			*cookie = htons(f-&gt;fw_divert_port);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IP6FW_DIVERT_RESTART */</span>
			<span class="enscript-keyword">return</span>(f-&gt;fw_divert_port);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_TEE</span>:
			<span class="enscript-comment">/*
			 * XXX someday tee packet here, but beware that you
			 * can't use m_copym() or m_copypacket() because
			 * the divert input routine modifies the mbuf
			 * (and these routines only increment reference
			 * counts in the case of mbuf clusters), so need
			 * to write custom routine.
			 */</span>
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_SKIPTO</span>:
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
			<span class="enscript-keyword">while</span> (chain-&gt;chain.le_next
			    &amp;&amp; chain-&gt;chain.le_next-&gt;rule-&gt;fw_number
				&lt; f-&gt;fw_skipto_rule)
#<span class="enscript-reference">else</span>
			<span class="enscript-keyword">while</span> (chain-&gt;chain.le_next-&gt;rule-&gt;fw_number
			    &lt; f-&gt;fw_skipto_rule)
#<span class="enscript-reference">endif</span>
				chain = chain-&gt;chain.le_next;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/* Deny/reject this packet using this rule */</span>
		rule = f;
		<span class="enscript-keyword">break</span>;
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-comment">/* Rule 65535 should always be there and should always match */</span>
	<span class="enscript-keyword">if</span> (!chain)
		panic(<span class="enscript-string">&quot;ip6_fw: chain&quot;</span>);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * At this point, we're going to drop the packet.
	 * Send a reject notice if all of the following are true:
	 *
	 * - The packet matched a reject rule
	 * - The packet is not an ICMP packet, or is an ICMP query packet
	 * - The packet is not a multicast or broadcast packet
	 */</span>
	<span class="enscript-keyword">if</span> ((rule-&gt;fw_flg &amp; IPV6_FW_F_COMMAND) == IPV6_FW_F_REJECT
	    &amp;&amp; (nxt != IPPROTO_ICMPV6 || is_icmp6_query(ip6, off))
	    &amp;&amp; !((*m)-&gt;m_flags &amp; (M_BCAST|M_MCAST))
	    &amp;&amp; !IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst)) {
		<span class="enscript-keyword">switch</span> (rule-&gt;fw_reject_code) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_REJECT_RST</span>:
		  {
			<span class="enscript-type">struct</span> tcphdr *<span class="enscript-type">const</span> tcp =
				(<span class="enscript-type">struct</span> tcphdr *) ((caddr_t)ip6 + off);
			<span class="enscript-type">struct</span> {
				<span class="enscript-type">struct</span> ip6_hdr ip6;
				<span class="enscript-type">struct</span> tcphdr th;
			} ti;
			tcp_seq ack, seq;
			<span class="enscript-type">int</span> flags;

			<span class="enscript-keyword">if</span> (offset != 0 || (tcp-&gt;th_flags &amp; TH_RST))
				<span class="enscript-keyword">break</span>;

			ti.ip6 = *ip6;
			ti.th = *tcp;
			ti.th.th_seq = ntohl(ti.th.th_seq);
			ti.th.th_ack = ntohl(ti.th.th_ack);
			ti.ip6.ip6_nxt = IPPROTO_TCP;
			<span class="enscript-keyword">if</span> (ti.th.th_flags &amp; TH_ACK) {
				ack = 0;
				seq = ti.th.th_ack;
				flags = TH_RST;
			} <span class="enscript-keyword">else</span> {
				ack = ti.th.th_seq;
				<span class="enscript-keyword">if</span> (((*m)-&gt;m_flags &amp; M_PKTHDR) != 0) {
					ack += (*m)-&gt;m_pkthdr.len - off
						- (ti.th.th_off &lt;&lt; 2);
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ip6-&gt;ip6_plen) {
					ack += ntohs(ip6-&gt;ip6_plen) + <span class="enscript-keyword">sizeof</span>(*ip6)
						- off - (ti.th.th_off &lt;&lt; 2);
				} <span class="enscript-keyword">else</span> {
					m_freem(*m);
					*m = 0;
					<span class="enscript-keyword">break</span>;
				}
				seq = 0;
				flags = TH_RST|TH_ACK;
			}
			bcopy(&amp;ti, ip6, <span class="enscript-keyword">sizeof</span>(ti));
			bzero(&amp;tra, <span class="enscript-keyword">sizeof</span>(tra));
			tra.ifscope = IFSCOPE_NONE;
			tra.awdl_unrestricted = 1;
			tcp_respond(NULL, ip6, (<span class="enscript-type">struct</span> tcphdr *)(ip6 + 1),
				*m, ack, seq, flags, &amp;tra);
			*m = NULL;
			<span class="enscript-keyword">break</span>;
		  }
		<span class="enscript-reference">default</span>:	<span class="enscript-comment">/* Send an ICMP unreachable using code */</span>
			<span class="enscript-keyword">if</span> (oif)
				(*m)-&gt;m_pkthdr.rcvif = oif;
			icmp6_error(*m, ICMP6_DST_UNREACH,
			    rule-&gt;fw_reject_code, 0);
			*m = NULL;
			<span class="enscript-keyword">break</span>;
		}
	}

<span class="enscript-reference">dropit</span>:
	<span class="enscript-comment">/*
	 * Finally, drop the packet.
	 */</span>
	<span class="enscript-keyword">if</span> (*m) {
		m_freem(*m);
		*m = NULL;
	}
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">add_entry6</span>(<span class="enscript-type">struct</span> ip6_fw_head *chainptr, <span class="enscript-type">struct</span> ip6_fw *frwl)
{
	<span class="enscript-type">struct</span> ip6_fw *ftmp = 0;
	<span class="enscript-type">struct</span> ip6_fw_chain *fwc = 0, *fcp, *fcpl = 0;
	u_short nbr = 0;
	<span class="enscript-type">int</span> s;

	fwc = _MALLOC(<span class="enscript-keyword">sizeof</span> *fwc, M_IP6FW, M_WAITOK);
	ftmp = _MALLOC(<span class="enscript-keyword">sizeof</span> *ftmp, M_IP6FW, M_WAITOK);
	<span class="enscript-keyword">if</span> (!fwc || !ftmp) {
		dprintf((<span class="enscript-string">&quot;%s malloc said no\n&quot;</span>, err_prefix));
		<span class="enscript-keyword">if</span> (fwc)  FREE(fwc, M_IP6FW);
		<span class="enscript-keyword">if</span> (ftmp) FREE(ftmp, M_IP6FW);
		<span class="enscript-keyword">return</span> (ENOSPC);
	}

	bcopy(frwl, ftmp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_fw));
	ftmp-&gt;fw_in_if.fu_via_if.name[IP6FW_IFNLEN - 1] = <span class="enscript-string">'\0'</span>;
	ftmp-&gt;fw_pcnt = 0L;
	ftmp-&gt;fw_bcnt = 0L;
	fwc-&gt;rule = ftmp;
	
	s = splnet();

	<span class="enscript-keyword">if</span> (!chainptr-&gt;lh_first) {
		LIST_INSERT_HEAD(chainptr, fwc, chain);
		splx(s);
		<span class="enscript-keyword">return</span>(0);
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ftmp-&gt;fw_number == (u_short)-1) {
		<span class="enscript-keyword">if</span> (fwc)  FREE(fwc, M_IP6FW);
		<span class="enscript-keyword">if</span> (ftmp) FREE(ftmp, M_IP6FW);
		splx(s);
		dprintf((<span class="enscript-string">&quot;%s bad rule number\n&quot;</span>, err_prefix));
		<span class="enscript-keyword">return</span> (EINVAL);
        }

	<span class="enscript-comment">/* If entry number is 0, find highest numbered rule and add 100 */</span>
	<span class="enscript-keyword">if</span> (ftmp-&gt;fw_number == 0) {
		<span class="enscript-keyword">for</span> (fcp = chainptr-&gt;lh_first; fcp; fcp = fcp-&gt;chain.le_next) {
			<span class="enscript-keyword">if</span> (fcp-&gt;rule-&gt;fw_number != (u_short)-1)
				nbr = fcp-&gt;rule-&gt;fw_number;
			<span class="enscript-keyword">else</span>
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (nbr &lt; (u_short)-1 - 100)
			nbr += 100;
		ftmp-&gt;fw_number = nbr;
	}

	<span class="enscript-comment">/* Got a valid number; now insert it, keeping the list ordered */</span>
	<span class="enscript-keyword">for</span> (fcp = chainptr-&gt;lh_first; fcp; fcp = fcp-&gt;chain.le_next) {
		<span class="enscript-keyword">if</span> (fcp-&gt;rule-&gt;fw_number &gt; ftmp-&gt;fw_number) {
			<span class="enscript-keyword">if</span> (fcpl) {
				LIST_INSERT_AFTER(fcpl, fwc, chain);
			} <span class="enscript-keyword">else</span> {
				LIST_INSERT_HEAD(chainptr, fwc, chain);
			}
			<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span> {
			fcpl = fcp;
		}
	}

	bcopy(ftmp, frwl, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_fw));
	splx(s);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">del_entry6</span>(<span class="enscript-type">struct</span> ip6_fw_head *chainptr, u_short number)
{
	<span class="enscript-type">struct</span> ip6_fw_chain *fcp;
	<span class="enscript-type">int</span> s;

	s = splnet();

	fcp = chainptr-&gt;lh_first;
	<span class="enscript-keyword">if</span> (number != (u_short)-1) {
		<span class="enscript-keyword">for</span> (; fcp; fcp = fcp-&gt;chain.le_next) {
			<span class="enscript-keyword">if</span> (fcp-&gt;rule-&gt;fw_number == number) {
				LIST_REMOVE(fcp, chain);
				splx(s);
				FREE(fcp-&gt;rule, M_IP6FW);
				FREE(fcp, M_IP6FW);
				<span class="enscript-keyword">return</span> 0;
			}
		}
	}

	splx(s);
	<span class="enscript-keyword">return</span> (EINVAL);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">zero_entry6</span>(<span class="enscript-type">struct</span> ip6_fw *frwl)
{
	<span class="enscript-type">struct</span> ip6_fw_chain *fcp;
	<span class="enscript-type">int</span> s;

	<span class="enscript-comment">/*
	 *	It's possible to insert multiple chain entries with the
	 *	same number, so we don't stop after finding the first
	 *	match if zeroing a specific entry.
	 */</span>
	s = splnet();
	<span class="enscript-keyword">for</span> (fcp = ip6_fw_chain.lh_first; fcp; fcp = fcp-&gt;chain.le_next)
		<span class="enscript-keyword">if</span> (!frwl || frwl-&gt;fw_number == 0 || frwl-&gt;fw_number == fcp-&gt;rule-&gt;fw_number) {
			fcp-&gt;rule-&gt;fw_bcnt = fcp-&gt;rule-&gt;fw_pcnt = 0;
			fcp-&gt;rule-&gt;timestamp = 0;
		}
	splx(s);

	<span class="enscript-keyword">if</span> (fw6_verbose) {
		<span class="enscript-keyword">if</span> (frwl)
			log(LOG_AUTHPRIV | LOG_NOTICE,
			    <span class="enscript-string">&quot;ip6fw: Entry %d cleared.\n&quot;</span>, frwl-&gt;fw_number);
		<span class="enscript-keyword">else</span>
			log(LOG_AUTHPRIV | LOG_NOTICE,
			    <span class="enscript-string">&quot;ip6fw: Accounting cleared.\n&quot;</span>);
	}

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ip6_fw *
<span class="enscript-function-name">check_ip6fw_struct</span>(<span class="enscript-type">struct</span> ip6_fw *frwl)
{
	<span class="enscript-comment">/* Check for invalid flag bits */</span>
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; ~IPV6_FW_F_MASK) != 0) {
		dprintf((<span class="enscript-string">&quot;%s undefined flag bits set (flags=%x)\n&quot;</span>,
		    err_prefix, frwl-&gt;fw_flg));
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-comment">/* Must apply to incoming or outgoing (or both) */</span>
	<span class="enscript-keyword">if</span> (!(frwl-&gt;fw_flg &amp; (IPV6_FW_F_IN | IPV6_FW_F_OUT))) {
		dprintf((<span class="enscript-string">&quot;%s neither in nor out\n&quot;</span>, err_prefix));
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-comment">/* Empty interface name is no good */</span>
	<span class="enscript-keyword">if</span> (((frwl-&gt;fw_flg &amp; IPV6_FW_F_IIFNAME)
	      &amp;&amp; !*frwl-&gt;fw_in_if.fu_via_if.name)
	    || ((frwl-&gt;fw_flg &amp; IPV6_FW_F_OIFNAME)
	      &amp;&amp; !*frwl-&gt;fw_out_if.fu_via_if.name)) {
		dprintf((<span class="enscript-string">&quot;%s empty interface name\n&quot;</span>, err_prefix));
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-comment">/* Sanity check interface matching */</span>
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; IF6_FW_F_VIAHACK) == IF6_FW_F_VIAHACK) {
		;		<span class="enscript-comment">/* allow &quot;via&quot; backwards compatibility */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; IPV6_FW_F_IN)
	    &amp;&amp; (frwl-&gt;fw_flg &amp; IPV6_FW_F_OIFACE)) {
		dprintf((<span class="enscript-string">&quot;%s outgoing interface check on incoming\n&quot;</span>,
		    err_prefix));
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-comment">/* Sanity check port ranges */</span>
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; IPV6_FW_F_SRNG) &amp;&amp; IPV6_FW_GETNSRCP(frwl) &lt; 2) {
		dprintf((<span class="enscript-string">&quot;%s src range set but n_src_p=%d\n&quot;</span>,
		    err_prefix, IPV6_FW_GETNSRCP(frwl)));
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; IPV6_FW_F_DRNG) &amp;&amp; IPV6_FW_GETNDSTP(frwl) &lt; 2) {
		dprintf((<span class="enscript-string">&quot;%s dst range set but n_dst_p=%d\n&quot;</span>,
		    err_prefix, IPV6_FW_GETNDSTP(frwl)));
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-keyword">if</span> (IPV6_FW_GETNSRCP(frwl) + IPV6_FW_GETNDSTP(frwl) &gt; IPV6_FW_MAX_PORTS) {
		dprintf((<span class="enscript-string">&quot;%s too many ports (%d+%d)\n&quot;</span>,
		    err_prefix, IPV6_FW_GETNSRCP(frwl), IPV6_FW_GETNDSTP(frwl)));
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-comment">/*
	 *	Protocols other than TCP/UDP don't use port range
	 */</span>
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_prot != IPPROTO_TCP) &amp;&amp;
	    (frwl-&gt;fw_prot != IPPROTO_UDP) &amp;&amp;
	    (IPV6_FW_GETNSRCP(frwl) || IPV6_FW_GETNDSTP(frwl))) {
		dprintf((<span class="enscript-string">&quot;%s port(s) specified for non TCP/UDP rule\n&quot;</span>,
		    err_prefix));
		<span class="enscript-keyword">return</span>(NULL);
	}

	<span class="enscript-comment">/*
	 *	Rather than modify the entry to make such entries work,
	 *	we reject this rule and require user level utilities
	 *	to enforce whatever policy they deem appropriate.
	 */</span>
	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_src.s6_addr32[0] &amp; (~frwl-&gt;fw_smsk.s6_addr32[0])) ||
		(frwl-&gt;fw_src.s6_addr32[1] &amp; (~frwl-&gt;fw_smsk.s6_addr32[1])) ||
		(frwl-&gt;fw_src.s6_addr32[2] &amp; (~frwl-&gt;fw_smsk.s6_addr32[2])) ||
		(frwl-&gt;fw_src.s6_addr32[3] &amp; (~frwl-&gt;fw_smsk.s6_addr32[3])) ||
		(frwl-&gt;fw_dst.s6_addr32[0] &amp; (~frwl-&gt;fw_dmsk.s6_addr32[0])) ||
		(frwl-&gt;fw_dst.s6_addr32[1] &amp; (~frwl-&gt;fw_dmsk.s6_addr32[1])) ||
		(frwl-&gt;fw_dst.s6_addr32[2] &amp; (~frwl-&gt;fw_dmsk.s6_addr32[2])) ||
		(frwl-&gt;fw_dst.s6_addr32[3] &amp; (~frwl-&gt;fw_dmsk.s6_addr32[3]))) {
		dprintf((<span class="enscript-string">&quot;%s rule never matches\n&quot;</span>, err_prefix));
		<span class="enscript-keyword">return</span>(NULL);
	}

	<span class="enscript-keyword">if</span> ((frwl-&gt;fw_flg &amp; IPV6_FW_F_FRAG) &amp;&amp;
		(frwl-&gt;fw_prot == IPPROTO_UDP || frwl-&gt;fw_prot == IPPROTO_TCP)) {
		<span class="enscript-keyword">if</span> (frwl-&gt;fw_nports) {
			dprintf((<span class="enscript-string">&quot;%s cannot mix 'frag' and ports\n&quot;</span>, err_prefix));
			<span class="enscript-keyword">return</span>(NULL);
		}
		<span class="enscript-keyword">if</span> (frwl-&gt;fw_prot == IPPROTO_TCP &amp;&amp;
			frwl-&gt;fw_tcpf != frwl-&gt;fw_tcpnf) {
			dprintf((<span class="enscript-string">&quot;%s cannot mix 'frag' with TCP flags\n&quot;</span>, err_prefix));
			<span class="enscript-keyword">return</span>(NULL);
		}
	}

	<span class="enscript-comment">/* Check command specific stuff */</span>
	<span class="enscript-keyword">switch</span> (frwl-&gt;fw_flg &amp; IPV6_FW_F_COMMAND)
	{
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_REJECT</span>:
		<span class="enscript-keyword">if</span> (frwl-&gt;fw_reject_code &gt;= 0x100
		    &amp;&amp; !(frwl-&gt;fw_prot == IPPROTO_TCP
		      &amp;&amp; frwl-&gt;fw_reject_code == IPV6_FW_REJECT_RST)) {
			dprintf((<span class="enscript-string">&quot;%s unknown reject code\n&quot;</span>, err_prefix));
			<span class="enscript-keyword">return</span>(NULL);
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_DIVERT</span>:		<span class="enscript-comment">/* Diverting to port zero is invalid */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_TEE</span>:
		<span class="enscript-keyword">if</span> (frwl-&gt;fw_divert_port == 0) {
			dprintf((<span class="enscript-string">&quot;%s can't divert to port 0\n&quot;</span>, err_prefix));
			<span class="enscript-keyword">return</span> (NULL);
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_DENY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_ACCEPT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_COUNT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_F_SKIPTO</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		dprintf((<span class="enscript-string">&quot;%s invalid command\n&quot;</span>, err_prefix));
		<span class="enscript-keyword">return</span>(NULL);
	}

	<span class="enscript-keyword">return</span> frwl;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip6fw_kev_post_msg</span>(u_int32_t event_code)
{
	<span class="enscript-type">struct</span> kev_msg		ev_msg;

	bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kev_msg));
	
	ev_msg.vendor_code = KEV_VENDOR_APPLE;
	ev_msg.kev_class = KEV_FIREWALL_CLASS;
	ev_msg.kev_subclass = KEV_IP6FW_SUBCLASS;
	ev_msg.event_code = event_code;

	kev_post_msg(&amp;ev_msg);

}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cp_to_user_64</span>( <span class="enscript-type">struct</span> ip6_fw_64 *userrule_64, <span class="enscript-type">struct</span> ip6_fw *rule)
{
	userrule_64-&gt;version = rule-&gt;version;
	userrule_64-&gt;context = CAST_USER_ADDR_T(rule-&gt;context);
	userrule_64-&gt;fw_pcnt = rule-&gt;fw_pcnt;
	userrule_64-&gt;fw_bcnt = rule-&gt;fw_bcnt;
	userrule_64-&gt;fw_src = rule-&gt;fw_src;
	userrule_64-&gt;fw_dst = rule-&gt;fw_dst;
	userrule_64-&gt;fw_smsk = rule-&gt;fw_smsk;
	userrule_64-&gt;fw_dmsk = rule-&gt;fw_dmsk;
	userrule_64-&gt;fw_number = rule-&gt;fw_number;
	userrule_64-&gt;fw_flg = rule-&gt;fw_flg;
	userrule_64-&gt;fw_ipflg = rule-&gt;fw_ipflg;
	bcopy( rule-&gt;fw_pts, userrule_64-&gt;fw_pts, IPV6_FW_MAX_PORTS);
	userrule_64-&gt;fw_ip6opt= rule-&gt;fw_ip6opt;
	userrule_64-&gt;fw_ip6nopt = rule-&gt;fw_ip6nopt;
	userrule_64-&gt;fw_tcpf = rule-&gt;fw_tcpf;
	userrule_64-&gt;fw_tcpnf = rule-&gt;fw_tcpnf;
	bcopy( rule-&gt;fw_icmp6types, userrule_64-&gt;fw_icmp6types, <span class="enscript-keyword">sizeof</span>(userrule_64-&gt;fw_icmp6types));
	userrule_64-&gt;fw_in_if = rule-&gt;fw_in_if;
	userrule_64-&gt;fw_out_if = rule-&gt;fw_out_if;
	userrule_64-&gt;timestamp = rule-&gt;timestamp;
	userrule_64-&gt;fw_un.fu_divert_port = rule-&gt;fw_un.fu_divert_port;
	userrule_64-&gt;fw_prot = rule-&gt;fw_prot;
	userrule_64-&gt;fw_nports = rule-&gt;fw_nports;
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cp_from_user_64</span>( <span class="enscript-type">struct</span> ip6_fw_64 *userrule_64, <span class="enscript-type">struct</span> ip6_fw *rule)
{
	rule-&gt;version = userrule_64-&gt;version;
	rule-&gt;context = CAST_DOWN(<span class="enscript-type">void</span> *, userrule_64-&gt;context);
	rule-&gt;fw_pcnt = userrule_64-&gt;fw_pcnt;
	rule-&gt;fw_bcnt = userrule_64-&gt;fw_bcnt;
	rule-&gt;fw_src = userrule_64-&gt;fw_src;
	rule-&gt;fw_dst = userrule_64-&gt;fw_dst;
	rule-&gt;fw_smsk = userrule_64-&gt;fw_smsk;
	rule-&gt;fw_dmsk = userrule_64-&gt;fw_dmsk;
	rule-&gt;fw_number = userrule_64-&gt;fw_number;
	rule-&gt;fw_flg = userrule_64-&gt;fw_flg;
	rule-&gt;fw_ipflg = userrule_64-&gt;fw_ipflg;
	bcopy( userrule_64-&gt;fw_pts, rule-&gt;fw_pts, IPV6_FW_MAX_PORTS);
	rule-&gt;fw_ip6opt  = userrule_64-&gt;fw_ip6opt;
	rule-&gt;fw_ip6nopt = userrule_64-&gt;fw_ip6nopt;
	rule-&gt;fw_tcpf = userrule_64-&gt;fw_tcpf;
	rule-&gt;fw_tcpnf = userrule_64-&gt;fw_tcpnf;
	bcopy( userrule_64-&gt;fw_icmp6types, rule-&gt;fw_icmp6types, <span class="enscript-keyword">sizeof</span>(userrule_64-&gt;fw_icmp6types));
	rule-&gt;fw_in_if = userrule_64-&gt;fw_in_if;
	rule-&gt;fw_out_if = userrule_64-&gt;fw_out_if;
	rule-&gt;timestamp = CAST_DOWN( <span class="enscript-type">long</span>, userrule_64-&gt;timestamp);
	rule-&gt;fw_un.fu_divert_port = userrule_64-&gt;fw_un.fu_divert_port;
	rule-&gt;fw_prot = userrule_64-&gt;fw_prot;
	rule-&gt;fw_nports = userrule_64-&gt;fw_nports;
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cp_to_user_32</span>( <span class="enscript-type">struct</span> ip6_fw_32 *userrule_32, <span class="enscript-type">struct</span> ip6_fw *rule)
{
	userrule_32-&gt;version = rule-&gt;version;
	userrule_32-&gt;context = CAST_DOWN_EXPLICIT( user32_addr_t, rule-&gt;context);
	userrule_32-&gt;fw_pcnt = rule-&gt;fw_pcnt;
	userrule_32-&gt;fw_bcnt = rule-&gt;fw_bcnt;
	userrule_32-&gt;fw_src = rule-&gt;fw_src;
	userrule_32-&gt;fw_dst = rule-&gt;fw_dst;
	userrule_32-&gt;fw_smsk = rule-&gt;fw_smsk;
	userrule_32-&gt;fw_dmsk = rule-&gt;fw_dmsk;
	userrule_32-&gt;fw_number = rule-&gt;fw_number;
	userrule_32-&gt;fw_flg = rule-&gt;fw_flg;
	userrule_32-&gt;fw_ipflg = rule-&gt;fw_ipflg;
	bcopy( rule-&gt;fw_pts, userrule_32-&gt;fw_pts, IPV6_FW_MAX_PORTS);
	userrule_32-&gt;fw_ip6opt = rule-&gt;fw_ip6opt ;
	userrule_32-&gt;fw_ip6nopt = rule-&gt;fw_ip6nopt;
	userrule_32-&gt;fw_tcpf = rule-&gt;fw_tcpf;
	userrule_32-&gt;fw_tcpnf = rule-&gt;fw_tcpnf;
	bcopy( rule-&gt;fw_icmp6types, userrule_32-&gt;fw_icmp6types, <span class="enscript-keyword">sizeof</span>(rule-&gt;fw_icmp6types));
	userrule_32-&gt;fw_in_if = rule-&gt;fw_in_if;
	userrule_32-&gt;fw_out_if = rule-&gt;fw_out_if;
	userrule_32-&gt;timestamp = rule-&gt;timestamp;
	userrule_32-&gt;fw_un.fu_divert_port = rule-&gt;fw_un.fu_divert_port;
	userrule_32-&gt;fw_prot = rule-&gt;fw_prot;
	userrule_32-&gt;fw_nports = rule-&gt;fw_nports;
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cp_from_user_32</span>( <span class="enscript-type">struct</span> ip6_fw_32 *userrule_32, <span class="enscript-type">struct</span> ip6_fw *rule)
{
	rule-&gt;version = userrule_32-&gt;version;
	rule-&gt;context = CAST_DOWN(<span class="enscript-type">void</span> *, userrule_32-&gt;context);
	rule-&gt;fw_pcnt = userrule_32-&gt;fw_pcnt;
	rule-&gt;fw_bcnt = userrule_32-&gt;fw_bcnt;
	rule-&gt;fw_src = userrule_32-&gt;fw_src;
	rule-&gt;fw_dst = userrule_32-&gt;fw_dst;
	rule-&gt;fw_smsk = userrule_32-&gt;fw_smsk;
	rule-&gt;fw_dmsk = userrule_32-&gt;fw_dmsk;
	rule-&gt;fw_number = userrule_32-&gt;fw_number;
	rule-&gt;fw_flg = userrule_32-&gt;fw_flg;
	rule-&gt;fw_ipflg = userrule_32-&gt;fw_ipflg;
	bcopy( userrule_32-&gt;fw_pts, rule-&gt;fw_pts, IPV6_FW_MAX_PORTS);
	rule-&gt;fw_ip6opt  = userrule_32-&gt;fw_ip6opt;
	rule-&gt;fw_ip6nopt = userrule_32-&gt;fw_ip6nopt;
	rule-&gt;fw_tcpf = userrule_32-&gt;fw_tcpf;
	rule-&gt;fw_tcpnf = userrule_32-&gt;fw_tcpnf;
	bcopy( userrule_32-&gt;fw_icmp6types, rule-&gt;fw_icmp6types, <span class="enscript-keyword">sizeof</span>(userrule_32-&gt;fw_icmp6types));
	rule-&gt;fw_in_if = userrule_32-&gt;fw_in_if;
	rule-&gt;fw_out_if = userrule_32-&gt;fw_out_if;
	rule-&gt;timestamp = CAST_DOWN(<span class="enscript-type">long</span>, userrule_32-&gt;timestamp);
	rule-&gt;fw_un.fu_divert_port = userrule_32-&gt;fw_un.fu_divert_port;
	rule-&gt;fw_prot = userrule_32-&gt;fw_prot;
	rule-&gt;fw_nports = userrule_32-&gt;fw_nports;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_fw_ctl</span>(<span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> spl;
	<span class="enscript-type">int</span> valsize;
	<span class="enscript-type">struct</span> ip6_fw rule;
	<span class="enscript-type">int</span> is64user=0;
	size_t	userrulesize;

	<span class="enscript-keyword">if</span> (securelevel &gt;= 3 &amp;&amp;
		(sopt-&gt;sopt_dir != SOPT_GET || sopt-&gt;sopt_name != IPV6_FW_GET))
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-keyword">if</span> ( proc_is64bit(sopt-&gt;sopt_p) ){
		is64user = 1;
		userrulesize = <span class="enscript-keyword">sizeof</span>( <span class="enscript-type">struct</span> ip6_fw_64 );
	} <span class="enscript-keyword">else</span>
		userrulesize = <span class="enscript-keyword">sizeof</span>( <span class="enscript-type">struct</span> ip6_fw_32 );
	
	<span class="enscript-comment">/* We ALWAYS expect the client to pass in a rule structure so that we can
	 * check the version of the API that they are using.  In the case of a
	 * IPV6_FW_GET operation, the first rule of the output buffer passed to us
	 * must have the version set. */</span>
	<span class="enscript-keyword">if</span> (!sopt-&gt;sopt_val || sopt-&gt;sopt_valsize &lt; userrulesize) <span class="enscript-keyword">return</span> EINVAL;

	<span class="enscript-comment">/* save sopt-&gt;sopt_valsize */</span>
	valsize = sopt-&gt;sopt_valsize;
	
	<span class="enscript-keyword">if</span> (is64user){
		<span class="enscript-type">struct</span> ip6_fw_64 userrule_64;
		
		<span class="enscript-keyword">if</span> ((error = sooptcopyin(sopt, &amp;userrule_64, userrulesize, userrulesize)))
			<span class="enscript-keyword">return</span> error;
		
		cp_from_user_64( &amp;userrule_64, &amp;rule );
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> ip6_fw_32 userrule_32;
		
		<span class="enscript-keyword">if</span> ((error = sooptcopyin(sopt, &amp;userrule_32, userrulesize, userrulesize)))
			<span class="enscript-keyword">return</span> error;
		
		cp_from_user_32( &amp;userrule_32, &amp;rule );
	}
	
	<span class="enscript-keyword">if</span> (rule.version != IPV6_FW_CURRENT_API_VERSION) <span class="enscript-keyword">return</span> EINVAL;
	rule.version = 0xFFFFFFFF;	<span class="enscript-comment">/* version is meaningless once rules &quot;make it in the door&quot;. */</span>

	<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name)
	{
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_GET</span>:
		{
			<span class="enscript-type">struct</span> ip6_fw_chain *fcp;
			<span class="enscript-type">struct</span> ip6_fw *buf;
			size_t size = 0;
			size_t rulesize = 0;

			spl = splnet();
			
			<span class="enscript-keyword">if</span> ( is64user )
				rulesize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_fw_64 );
			<span class="enscript-keyword">else</span>
				rulesize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_fw_32 );
			
			LIST_FOREACH(fcp, &amp;ip6_fw_chain, chain)
				size += rulesize;

			buf = _MALLOC(size, M_TEMP, M_WAITOK);
			<span class="enscript-keyword">if</span> (!buf) error = ENOBUFS;
			<span class="enscript-keyword">else</span>
			{
				<span class="enscript-comment">//struct ip6_fw *bp = buf;
</span>				caddr_t bp = (caddr_t)buf;
				
				LIST_FOREACH(fcp, &amp;ip6_fw_chain, chain)
				{
					<span class="enscript-comment">//bcopy(fcp-&gt;rule, bp, sizeof *bp);
</span>					<span class="enscript-keyword">if</span> ( is64user ){
						cp_to_user_64( (<span class="enscript-type">struct</span> ip6_fw_64*)bp, fcp-&gt;rule);
					}
					<span class="enscript-keyword">else</span> {
						cp_to_user_32( (<span class="enscript-type">struct</span> ip6_fw_32*)bp, fcp-&gt;rule);
					}

					( (<span class="enscript-type">struct</span> ip6_fw*)bp)-&gt;version = IPV6_FW_CURRENT_API_VERSION;
					<span class="enscript-comment">//bp++;
</span>					bp += rulesize;
				}
			}

			splx(spl);
			<span class="enscript-keyword">if</span> (buf)
			{
				sopt-&gt;sopt_valsize = valsize;
				error = sooptcopyout(sopt, buf, size);
				FREE(buf, M_TEMP);
			}

			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_FLUSH</span>:
			spl = splnet();
			<span class="enscript-keyword">while</span> (ip6_fw_chain.lh_first &amp;&amp;
				ip6_fw_chain.lh_first-&gt;rule-&gt;fw_number != (u_short)-1)
			{
				<span class="enscript-type">struct</span> ip6_fw_chain *fcp = ip6_fw_chain.lh_first;
				LIST_REMOVE(ip6_fw_chain.lh_first, chain);
				FREE(fcp-&gt;rule, M_IP6FW);
				FREE(fcp, M_IP6FW);
			}
			splx(spl);
			ip6fw_kev_post_msg(KEV_IP6FW_FLUSH);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_ZERO</span>:
			error = zero_entry6(&amp;rule);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_ADD</span>:
			<span class="enscript-keyword">if</span> (check_ip6fw_struct(&amp;rule)) {
				error = add_entry6(&amp;ip6_fw_chain, &amp;rule);

				ip6fw_kev_post_msg(KEV_IP6FW_ADD);
			} <span class="enscript-keyword">else</span>
				error = EINVAL;

			<span class="enscript-keyword">if</span> (is64user){
				<span class="enscript-type">struct</span> ip6_fw_64 userrule_64;
				cp_to_user_64( &amp;userrule_64, &amp;rule);
				error = sooptcopyout(sopt, &amp;userrule_64, userrulesize);
			}
			<span class="enscript-keyword">else</span> {
				<span class="enscript-type">struct</span> ip6_fw_32 userrule_32;
				cp_to_user_32( &amp;userrule_32, &amp;rule);
				error = sooptcopyout(sopt, &amp;userrule_32, userrulesize);
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_DEL</span>:
			<span class="enscript-keyword">if</span> (rule.fw_number == (u_short)-1)
			{
				dprintf((<span class="enscript-string">&quot;%s can't delete rule 65535\n&quot;</span>, err_prefix));
				error = EINVAL;
			}
			<span class="enscript-keyword">else</span> {
				error = del_entry6(&amp;ip6_fw_chain, rule.fw_number);

				ip6fw_kev_post_msg(KEV_IP6FW_DEL);
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			dprintf((<span class="enscript-string">&quot;%s invalid option %d\n&quot;</span>, err_prefix, sopt-&gt;sopt_name));
			error = EINVAL;
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_fw_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> ip6_fw default_rule;

	ip6_fw_chk_ptr = ip6_fw_chk;
	ip6_fw_ctl_ptr = ip6_fw_ctl;
	LIST_INIT(&amp;ip6_fw_chain);

	bzero(&amp;default_rule, <span class="enscript-keyword">sizeof</span> default_rule);
	default_rule.fw_prot = IPPROTO_IPV6;
	default_rule.fw_number = (u_short)-1;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IPV6FIREWALL_DEFAULT_TO_ACCEPT</span>
	default_rule.fw_flg |= IPV6_FW_F_ACCEPT;
#<span class="enscript-reference">else</span>
	default_rule.fw_flg |= IPV6_FW_F_DENY;
#<span class="enscript-reference">endif</span>
	default_rule.fw_flg |= IPV6_FW_F_IN | IPV6_FW_F_OUT;
	<span class="enscript-keyword">if</span> (check_ip6fw_struct(&amp;default_rule) == NULL ||
		add_entry6(&amp;ip6_fw_chain, &amp;default_rule))
		panic(<span class="enscript-string">&quot;%s&quot;</span>, __FUNCTION__);

	printf(<span class="enscript-string">&quot;IPv6 packet filtering initialized, &quot;</span>);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IPV6FIREWALL_DEFAULT_TO_ACCEPT</span>
	printf(<span class="enscript-string">&quot;default to accept, &quot;</span>);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IPV6FIREWALL_VERBOSE</span>
	printf(<span class="enscript-string">&quot;logging disabled\n&quot;</span>);
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (fw6_verbose_limit == 0)
		printf(<span class="enscript-string">&quot;unlimited logging\n&quot;</span>);
	<span class="enscript-keyword">else</span>
		printf(<span class="enscript-string">&quot;logging limited to %d packets/entry\n&quot;</span>,
		    fw6_verbose_limit);
#<span class="enscript-reference">endif</span>
}

</pre>
<hr />
</body></html>