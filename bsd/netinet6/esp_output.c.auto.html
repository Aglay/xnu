<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>esp_output.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">esp_output.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$FreeBSD: src/sys/netinet6/esp_output.c,v 1.1.2.3 2002/04/28 05:40:26 suz Exp $	*/</span>
<span class="enscript-comment">/*	$KAME: esp_output.c,v 1.44 2001/07/26 06:53:15 jinmei Exp $	*/</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_IP_VHL</span>

<span class="enscript-comment">/*
 * RFC1827/2406 Encapsulated Security Payload.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span> <span class="enscript-comment">/* for nat traversal */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ah.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ah6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/keydb.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_LAYER_BEG</span>		NETDBG_CODE(DBG_NETIPSEC, 1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_LAYER_END</span>		NETDBG_CODE(DBG_NETIPSEC, 3)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_FNC_ESPOUT</span>		NETDBG_CODE(DBG_NETIPSEC, (4 &lt;&lt; 8))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_FNC_ENCRYPT</span>		NETDBG_CODE(DBG_NETIPSEC, (5 &lt;&lt; 8))

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_output</span>(<span class="enscript-type">struct</span> mbuf *, u_char *, <span class="enscript-type">struct</span> mbuf *,
	<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> secasvar *sav);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	esp_udp_encap_port;
<span class="enscript-type">extern</span> u_int32_t natt_now;

<span class="enscript-type">extern</span> lck_mtx_t *sadb_mutex;

<span class="enscript-comment">/*
 * compute ESP header size.
 */</span>
size_t
<span class="enscript-function-name">esp_hdrsiz</span>(__unused <span class="enscript-type">struct</span> ipsecrequest *isr)
{

#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (isr == NULL)
		panic(<span class="enscript-string">&quot;esp_hdrsiz: NULL was passed.\n&quot;</span>);


	lck_mtx_lock(sadb_mutex);
	{
		<span class="enscript-type">struct</span> secasvar *sav;
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo;
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ah_algorithm *aalgo;
		size_t ivlen;
		size_t authlen;
		size_t hdrsiz;
		size_t maxpad;
	
		<span class="enscript-comment">/*%%%% this needs to change - no sav in ipsecrequest any more */</span>
		sav = isr-&gt;sav;
	
		<span class="enscript-keyword">if</span> (isr-&gt;saidx.proto != IPPROTO_ESP)
			panic(<span class="enscript-string">&quot;unsupported mode passed to esp_hdrsiz&quot;</span>);
	
		<span class="enscript-keyword">if</span> (sav == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">estimate</span>;
		<span class="enscript-keyword">if</span> (sav-&gt;state != SADB_SASTATE_MATURE
		 &amp;&amp; sav-&gt;state != SADB_SASTATE_DYING)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">estimate</span>;
	
		<span class="enscript-comment">/* we need transport mode ESP. */</span>
		algo = esp_algorithm_lookup(sav-&gt;alg_enc);
		<span class="enscript-keyword">if</span> (!algo)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">estimate</span>;
		ivlen = sav-&gt;ivlen;
		<span class="enscript-keyword">if</span> (ivlen &lt; 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">estimate</span>;
	
		<span class="enscript-keyword">if</span> (algo-&gt;padbound)
			maxpad = algo-&gt;padbound;
		<span class="enscript-keyword">else</span>
			maxpad = 4;
		maxpad += 1; <span class="enscript-comment">/* maximum 'extendsiz' is padbound + 1, see esp_output */</span>
		
		<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_OLD) {
			<span class="enscript-comment">/* RFC 1827 */</span>
			hdrsiz = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp) + ivlen + maxpad;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* RFC 2406 */</span>
			aalgo = ah_algorithm_lookup(sav-&gt;alg_auth);
			<span class="enscript-keyword">if</span> (aalgo &amp;&amp; sav-&gt;replay &amp;&amp; sav-&gt;key_auth)
				authlen = (aalgo-&gt;sumsiz)(sav);
			<span class="enscript-keyword">else</span>
				authlen = 0;
			hdrsiz = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newesp) + ivlen + maxpad + authlen;
		}
		
		<span class="enscript-comment">/*
		 * If the security association indicates that NATT is required,
		 * add the size of the NATT encapsulation header:
		 */</span>
		<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_NATT) != 0) hdrsiz += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr) + 4;
	
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> hdrsiz;
	}
<span class="enscript-reference">estimate</span>:
   lck_mtx_unlock(sadb_mutex);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * ASSUMING:
	 *	sizeof(struct newesp) &gt; sizeof(struct esp). (8)
	 *	esp_max_ivlen() = max ivlen for CBC mode
	 *	17 = (maximum padding length without random padding length)
	 *	   + (Pad Length field) + (Next Header field).
	 *	64 = maximum ICV we support.
	 *  sizeof(struct udphdr) in case NAT traversal is used
	 */</span>
	<span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newesp) + esp_max_ivlen() + 17 + AH_MAXSUMSIZE + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr);
}

<span class="enscript-comment">/*
 * Modify the packet so that the payload is encrypted.
 * The mbuf (m) must start with IPv4 or IPv6 header.
 * On failure, free the given mbuf and return NULL.
 *
 * on invocation:
 *	m   nexthdrp md
 *	v   v        v
 *	IP ......... payload
 * during the encryption:
 *	m   nexthdrp mprev md
 *	v   v        v     v
 *	IP ............... esp iv payload pad padlen nxthdr
 *	                   &lt;--&gt;&lt;-&gt;&lt;------&gt;&lt;---------------&gt;
 *	                   esplen plen    extendsiz
 *	                       ivlen
 *	                   &lt;-----&gt; esphlen
 *	&lt;-&gt; hlen
 *	&lt;-----------------&gt; espoff
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_output</span>(m, nexthdrp, md, af, sav)
	<span class="enscript-type">struct</span> mbuf *m;
	u_char *nexthdrp;
	<span class="enscript-type">struct</span> mbuf *md;
	<span class="enscript-type">int</span> af;
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">struct</span> mbuf *n;
	<span class="enscript-type">struct</span> mbuf *mprev;
	<span class="enscript-type">struct</span> esp *esp;
	<span class="enscript-type">struct</span> esptail *esptail;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo;
	u_int32_t spi;
	u_int8_t nxt = 0;
	size_t plen;	<span class="enscript-comment">/*payload length to be encrypted*/</span>
	size_t espoff;
	size_t esphlen;	<span class="enscript-comment">/* sizeof(struct esp/newesp) + ivlen */</span>
	<span class="enscript-type">int</span> ivlen;
	<span class="enscript-type">int</span> afnumber;
	size_t extendsiz;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> ipsecstat *stat;
	<span class="enscript-type">struct</span> udphdr *udp = NULL;
	<span class="enscript-type">int</span>	udp_encapsulate = (sav-&gt;flags &amp; SADB_X_EXT_NATT &amp;&amp; (af == AF_INET || af == AF_INET6) &amp;&amp;
			(esp_udp_encap_port &amp; 0xFFFF) != 0);

	KERNEL_DEBUG(DBG_FNC_ESPOUT | DBG_FUNC_START, sav-&gt;ivlen,0,0,0,0);
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		afnumber = 4;
		stat = &amp;ipsecstat;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		afnumber = 6;
		stat = &amp;ipsec6stat;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
	<span class="enscript-reference">default</span>:
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_output: unsupported af %d\n&quot;</span>, af));
		KERNEL_DEBUG(DBG_FNC_ESPOUT | DBG_FUNC_END, 1,0,0,0,0);
		<span class="enscript-keyword">return</span> 0;	<span class="enscript-comment">/* no change at all */</span>
	}

	<span class="enscript-comment">/* some sanity check */</span>
	<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_OLD) == 0 &amp;&amp; !sav-&gt;replay) {
		<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		    {
			<span class="enscript-type">struct</span> ip *ip;

			ip = mtod(m, <span class="enscript-type">struct</span> ip *);
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;esp4_output: internal error: &quot;</span>
				<span class="enscript-string">&quot;sav-&gt;replay is null: %x-&gt;%x, SPI=%u\n&quot;</span>,
				(u_int32_t)ntohl(ip-&gt;ip_src.s_addr),
				(u_int32_t)ntohl(ip-&gt;ip_dst.s_addr),
				(u_int32_t)ntohl(sav-&gt;spi)));
			IPSEC_STAT_INCREMENT(ipsecstat.out_inval);
			<span class="enscript-keyword">break</span>;
		    }
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*INET*/</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;esp6_output: internal error: &quot;</span>
				<span class="enscript-string">&quot;sav-&gt;replay is null: SPI=%u\n&quot;</span>,
				(u_int32_t)ntohl(sav-&gt;spi)));
			IPSEC_STAT_INCREMENT(ipsec6stat.out_inval);
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*INET6*/</span>
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;esp_output: should not reach here&quot;</span>);
		}
		m_freem(m);
		KERNEL_DEBUG(DBG_FNC_ESPOUT | DBG_FUNC_END, 2,0,0,0,0);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	algo = esp_algorithm_lookup(sav-&gt;alg_enc);
	<span class="enscript-keyword">if</span> (!algo) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_output: unsupported algorithm: &quot;</span>
		    <span class="enscript-string">&quot;SPI=%u\n&quot;</span>, (u_int32_t)ntohl(sav-&gt;spi)));
		m_freem(m);
		KERNEL_DEBUG(DBG_FNC_ESPOUT | DBG_FUNC_END, 3,0,0,0,0);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	spi = sav-&gt;spi;
	ivlen = sav-&gt;ivlen;
	<span class="enscript-comment">/* should be okey */</span>
	<span class="enscript-keyword">if</span> (ivlen &lt; 0) {
		panic(<span class="enscript-string">&quot;invalid ivlen&quot;</span>);
	}

    {
	<span class="enscript-comment">/*
	 * insert ESP header.
	 * XXX inserts ESP header right after IPv4 header.  should
	 * chase the header chain.
	 * XXX sequential number
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-type">struct</span> ip *ip = NULL;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = NULL;
#<span class="enscript-reference">endif</span>
	size_t esplen;	<span class="enscript-comment">/* sizeof(struct esp/newesp) */</span>
	size_t hlen = 0;	<span class="enscript-comment">/* ip header len */</span>

	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_OLD) {
		<span class="enscript-comment">/* RFC 1827 */</span>
		esplen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* RFC 2406 */</span>
		<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_DERIV)
			esplen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp);
		<span class="enscript-keyword">else</span>
			esplen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newesp);
	}
	esphlen = esplen + ivlen;

	<span class="enscript-keyword">for</span> (mprev = m; mprev &amp;&amp; mprev-&gt;m_next != md; mprev = mprev-&gt;m_next)
		;
	<span class="enscript-keyword">if</span> (mprev == NULL || mprev-&gt;m_next != md) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;esp%d_output: md is not in chain\n&quot;</span>,
		    afnumber));
		m_freem(m);
		KERNEL_DEBUG(DBG_FNC_ESPOUT | DBG_FUNC_END, 4,0,0,0,0);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	plen = 0;
	<span class="enscript-keyword">for</span> (n = md; n; n = n-&gt;m_next)
		plen += n-&gt;m_len;

	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
		hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
#<span class="enscript-reference">else</span>
		hlen = ip-&gt;ip_hl &lt;&lt; 2;
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
		hlen = <span class="enscript-keyword">sizeof</span>(*ip6);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-comment">/* make the packet over-writable */</span>
	mprev-&gt;m_next = NULL;
	<span class="enscript-keyword">if</span> ((md = ipsec_copypkt(md)) == NULL) {
		m_freem(m);
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	mprev-&gt;m_next = md;
	
	<span class="enscript-comment">/* 
	 * Translate UDP source port back to its original value.
	 * SADB_X_EXT_NATT_MULTIPLEUSERS is only set for transort mode.
	 */</span>
	<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_NATT_MULTIPLEUSERS) != 0) {
		<span class="enscript-comment">/* if not UDP - drop it */</span>
		<span class="enscript-keyword">if</span> (ip-&gt;ip_p != IPPROTO_UDP)	{
			IPSEC_STAT_INCREMENT(ipsecstat.out_inval);
			m_freem(m);
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}			
		
		udp = mtod(md, <span class="enscript-type">struct</span> udphdr *);

		<span class="enscript-comment">/* if src port not set in sav - find it */</span>
		<span class="enscript-keyword">if</span> (sav-&gt;natt_encapsulated_src_port == 0)
			<span class="enscript-keyword">if</span> (key_natt_get_translated_port(sav) == 0) {
				m_freem(m);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
		<span class="enscript-keyword">if</span> (sav-&gt;remote_ike_port == htons(udp-&gt;uh_dport)) {
			<span class="enscript-comment">/* translate UDP port */</span>
			udp-&gt;uh_dport = sav-&gt;natt_encapsulated_src_port;
			udp-&gt;uh_sum = 0;	<span class="enscript-comment">/* don't need checksum with ESP auth */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* drop the packet - can't translate the port */</span>
			IPSEC_STAT_INCREMENT(ipsecstat.out_inval);
			m_freem(m);
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
	}
		

	espoff = m-&gt;m_pkthdr.len - plen;
	
	<span class="enscript-keyword">if</span> (udp_encapsulate) {
		esphlen += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr);
		espoff += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr);
	}

	<span class="enscript-comment">/*
	 * grow the mbuf to accomodate ESP header.
	 * before: IP ... payload
	 * after:  IP ... [UDP] ESP IV payload
	 */</span>
	<span class="enscript-keyword">if</span> (M_LEADINGSPACE(md) &lt; esphlen || (md-&gt;m_flags &amp; M_EXT) != 0) {
		MGET(n, M_DONTWAIT, MT_DATA);
		<span class="enscript-keyword">if</span> (!n) {
			m_freem(m);
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		n-&gt;m_len = esphlen;
		mprev-&gt;m_next = n;
		n-&gt;m_next = md;
		m-&gt;m_pkthdr.len += esphlen;
		<span class="enscript-keyword">if</span> (udp_encapsulate) {
			udp = mtod(n, <span class="enscript-type">struct</span> udphdr *);
			esp = (<span class="enscript-type">struct</span> esp *)(<span class="enscript-type">void</span> *)((caddr_t)udp + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr));
		} <span class="enscript-keyword">else</span> {
			esp = mtod(n, <span class="enscript-type">struct</span> esp *);
		}
	} <span class="enscript-keyword">else</span> {
		md-&gt;m_len += esphlen;
		md-&gt;m_data -= esphlen;
		m-&gt;m_pkthdr.len += esphlen;
		esp = mtod(md, <span class="enscript-type">struct</span> esp *);
		<span class="enscript-keyword">if</span> (udp_encapsulate) {
			udp = mtod(md, <span class="enscript-type">struct</span> udphdr *);
			esp = (<span class="enscript-type">struct</span> esp *)(<span class="enscript-type">void</span> *)((caddr_t)udp + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr));
		} <span class="enscript-keyword">else</span> {
			esp = mtod(md, <span class="enscript-type">struct</span> esp *);
		}
	}
	
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		<span class="enscript-keyword">if</span> (esphlen &lt; (IP_MAXPACKET - ntohs(ip-&gt;ip_len)))
			ip-&gt;ip_len = htons(ntohs(ip-&gt;ip_len) + esphlen);
		<span class="enscript-keyword">else</span> {
			ipseclog((LOG_ERR,
			    <span class="enscript-string">&quot;IPv4 ESP output: size exceeds limit\n&quot;</span>));
			IPSEC_STAT_INCREMENT(ipsecstat.out_inval);
			m_freem(m);
			error = EMSGSIZE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		<span class="enscript-comment">/* total packet length will be computed in ip6_output() */</span>
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
	}
    }

	<span class="enscript-comment">/* initialize esp header. */</span>
	esp-&gt;esp_spi = spi;
	<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_OLD) == 0) {
		<span class="enscript-type">struct</span> newesp *nesp;
		nesp = (<span class="enscript-type">struct</span> newesp *)esp;
		<span class="enscript-keyword">if</span> (sav-&gt;replay-&gt;count == ~0) {
			<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_CYCSEQ) == 0) {
				<span class="enscript-comment">/* XXX Is it noisy ? */</span>
				ipseclog((LOG_WARNING,
				    <span class="enscript-string">&quot;replay counter overflowed. %s\n&quot;</span>,
				    ipsec_logsastr(sav)));
				IPSEC_STAT_INCREMENT(stat-&gt;out_inval);
				m_freem(m);
				KERNEL_DEBUG(DBG_FNC_ESPOUT | DBG_FUNC_END, 5,0,0,0,0);
				<span class="enscript-keyword">return</span> EINVAL;
			}
		}
		lck_mtx_lock(sadb_mutex);
		sav-&gt;replay-&gt;count++;
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-comment">/*
		 * XXX sequence number must not be cycled, if the SA is
		 * installed by IKE daemon.
		 */</span>
		nesp-&gt;esp_seq = htonl(sav-&gt;replay-&gt;count);
	}

    {
	<span class="enscript-comment">/*
	 * find the last mbuf. make some room for ESP trailer.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-type">struct</span> ip *ip = NULL;
#<span class="enscript-reference">endif</span>
	size_t padbound;
	u_char *extend;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> randpadmax;

	<span class="enscript-keyword">if</span> (algo-&gt;padbound)
		padbound = algo-&gt;padbound;
	<span class="enscript-keyword">else</span>
		padbound = 4;
	<span class="enscript-comment">/* ESP packet, including nxthdr field, must be length of 4n */</span>
	<span class="enscript-keyword">if</span> (padbound &lt; 4)
		padbound = 4;
	
	extendsiz = padbound - (plen % padbound);
	<span class="enscript-keyword">if</span> (extendsiz == 1)
		extendsiz = padbound + 1;

	<span class="enscript-comment">/* random padding */</span>
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		randpadmax = ip4_esp_randpad;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		randpadmax = ip6_esp_randpad;
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
	<span class="enscript-reference">default</span>:
		randpadmax = -1;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (randpadmax &lt; 0 || plen + extendsiz &gt;= randpadmax)
		;
	<span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span> pad;

		<span class="enscript-comment">/* round */</span>
		randpadmax = (randpadmax / padbound) * padbound;
		pad = (randpadmax - plen + extendsiz) / padbound;

		<span class="enscript-keyword">if</span> (pad &gt; 0)
			pad = (random() % pad) * padbound;
		<span class="enscript-keyword">else</span>
			pad = 0;

		<span class="enscript-comment">/*
		 * make sure we do not pad too much.
		 * MLEN limitation comes from the trailer attachment
		 * code below.
		 * 256 limitation comes from sequential padding.
		 * also, the 1-octet length field in ESP trailer imposes
		 * limitation (but is less strict than sequential padding
		 * as length field do not count the last 2 octets).
		 */</span>
		<span class="enscript-keyword">if</span> (extendsiz + pad &lt;= MLEN &amp;&amp; extendsiz + pad &lt; 256)
			extendsiz += pad;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (extendsiz &gt; MLEN || extendsiz &gt;= 256)
		panic(<span class="enscript-string">&quot;extendsiz too big in esp_output&quot;</span>);
#<span class="enscript-reference">endif</span>

	n = m;
	<span class="enscript-keyword">while</span> (n-&gt;m_next)
		n = n-&gt;m_next;

	<span class="enscript-comment">/*
	 * if M_EXT, the external mbuf data may be shared among
	 * two consequtive TCP packets, and it may be unsafe to use the
	 * trailing space.
	 */</span>
	<span class="enscript-keyword">if</span> (!(n-&gt;m_flags &amp; M_EXT) &amp;&amp; extendsiz &lt; M_TRAILINGSPACE(n)) {
		extend = mtod(n, u_char *) + n-&gt;m_len;
		n-&gt;m_len += extendsiz;
		m-&gt;m_pkthdr.len += extendsiz;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> mbuf *nn;

		MGET(nn, M_DONTWAIT, MT_DATA);
		<span class="enscript-keyword">if</span> (!nn) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;esp%d_output: can't alloc mbuf&quot;</span>,
			    afnumber));
			m_freem(m);
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		extend = mtod(nn, u_char *);
		nn-&gt;m_len = extendsiz;
		nn-&gt;m_next = NULL;
		n-&gt;m_next = nn;
		n = nn;
		m-&gt;m_pkthdr.len += extendsiz;
	}
	<span class="enscript-keyword">switch</span> (sav-&gt;flags &amp; SADB_X_EXT_PMASK) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_PRAND</span>:
		key_randomfill(extend, extendsiz);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_PZERO</span>:
		bzero(extend, extendsiz);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EXT_PSEQ</span>:
		<span class="enscript-keyword">for</span> (i = 0; i &lt; extendsiz; i++)
			extend[i] = (i + 1) &amp; 0xff;
		<span class="enscript-keyword">break</span>;
	}
	
	nxt = *nexthdrp;
	<span class="enscript-keyword">if</span> (udp_encapsulate) {
		*nexthdrp = IPPROTO_UDP;

		<span class="enscript-comment">/* Fill out the UDP header */</span>
		udp-&gt;uh_sport = ntohs((u_short)esp_udp_encap_port);
		udp-&gt;uh_dport = ntohs(sav-&gt;remote_ike_port);
<span class="enscript-comment">//		udp-&gt;uh_len set later, after all length tweaks are complete
</span>		udp-&gt;uh_sum = 0;
		
		<span class="enscript-comment">/* Update last sent so we know if we need to send keepalive */</span>
		sav-&gt;natt_last_activity = natt_now;
	} <span class="enscript-keyword">else</span> {
		*nexthdrp = IPPROTO_ESP;
	}

	<span class="enscript-comment">/* initialize esp trailer. */</span>
	esptail = (<span class="enscript-type">struct</span> esptail *)
		(mtod(n, u_int8_t *) + n-&gt;m_len - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esptail));
	esptail-&gt;esp_nxt = nxt;
	esptail-&gt;esp_padlen = extendsiz - 2;

	<span class="enscript-comment">/* modify IP header (for ESP header part only) */</span>
	<span class="enscript-keyword">switch</span> (af) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		<span class="enscript-keyword">if</span> (extendsiz &lt; (IP_MAXPACKET - ntohs(ip-&gt;ip_len)))
			ip-&gt;ip_len = htons(ntohs(ip-&gt;ip_len) + extendsiz);
		<span class="enscript-keyword">else</span> {
			ipseclog((LOG_ERR,
			    <span class="enscript-string">&quot;IPv4 ESP output: size exceeds limit\n&quot;</span>));
			IPSEC_STAT_INCREMENT(ipsecstat.out_inval);
			m_freem(m);
			error = EMSGSIZE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		<span class="enscript-comment">/* total packet length will be computed in ip6_output() */</span>
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
	}
    }

	<span class="enscript-comment">/*
	 * pre-compute and cache intermediate key
	 */</span>
	error = esp_schedule(algo, sav);
	<span class="enscript-keyword">if</span> (error) {
		m_freem(m);
		IPSEC_STAT_INCREMENT(stat-&gt;out_inval);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-comment">/*
	 * encrypt the packet, based on security association
	 * and the algorithm specified.
	 */</span>
	<span class="enscript-keyword">if</span> (!algo-&gt;encrypt)
		panic(<span class="enscript-string">&quot;internal error: no encrypt function&quot;</span>);
	KERNEL_DEBUG(DBG_FNC_ENCRYPT | DBG_FUNC_START, 0,0,0,0,0);
	<span class="enscript-keyword">if</span> ((*algo-&gt;encrypt)(m, espoff, plen + extendsiz, sav, algo, ivlen)) {
		<span class="enscript-comment">/* m is already freed */</span>
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;packet encryption failure\n&quot;</span>));
		IPSEC_STAT_INCREMENT(stat-&gt;out_inval);
		error = EINVAL;
		KERNEL_DEBUG(DBG_FNC_ENCRYPT | DBG_FUNC_END, 1,error,0,0,0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	KERNEL_DEBUG(DBG_FNC_ENCRYPT | DBG_FUNC_END, 2,0,0,0,0);

	<span class="enscript-comment">/*
	 * calculate ICV if required.
	 */</span>
	size_t siz = 0;
	u_char authbuf[AH_MAXSUMSIZE] __attribute__((aligned(4)));

        <span class="enscript-keyword">if</span> (algo-&gt;finalizeencrypt) {
		siz = algo-&gt;icvlen;
		<span class="enscript-keyword">if</span> ((*algo-&gt;finalizeencrypt)(sav, authbuf, siz)) {
		        ipseclog((LOG_ERR, <span class="enscript-string">&quot;packet encryption ICV failure\n&quot;</span>));
			IPSEC_STAT_INCREMENT(stat-&gt;out_inval);
			error = EINVAL;
			KERNEL_DEBUG(DBG_FNC_ENCRYPT | DBG_FUNC_END, 1,error,0,0,0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fill_icv</span>;
	}

	<span class="enscript-keyword">if</span> (!sav-&gt;replay)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">noantireplay</span>;
	<span class="enscript-keyword">if</span> (!sav-&gt;key_auth)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">noantireplay</span>;
	<span class="enscript-keyword">if</span> (sav-&gt;key_auth == SADB_AALG_NONE)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">noantireplay</span>;

    {
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ah_algorithm *aalgo;
	
		aalgo = ah_algorithm_lookup(sav-&gt;alg_auth);
		<span class="enscript-keyword">if</span> (!aalgo)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">noantireplay</span>;
		siz = ((aalgo-&gt;sumsiz)(sav) + 3) &amp; ~(4 - 1);
		<span class="enscript-keyword">if</span> (AH_MAXSUMSIZE &lt; siz)
			panic(<span class="enscript-string">&quot;assertion failed for AH_MAXSUMSIZE&quot;</span>);
	
		<span class="enscript-keyword">if</span> (esp_auth(m, espoff, m-&gt;m_pkthdr.len - espoff, sav, authbuf)) {
			ipseclog((LOG_ERR, <span class="enscript-string">&quot;ESP checksum generation failure\n&quot;</span>));
			m_freem(m);
			error = EINVAL;
			IPSEC_STAT_INCREMENT(stat-&gt;out_inval);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
    }

 <span class="enscript-reference">fill_icv</span>:
    {
	        <span class="enscript-type">struct</span> ip *ip;
		u_char *p;

		n = m;
		<span class="enscript-keyword">while</span> (n-&gt;m_next)
			n = n-&gt;m_next;
	
		<span class="enscript-keyword">if</span> (!(n-&gt;m_flags &amp; M_EXT) &amp;&amp; siz &lt; M_TRAILINGSPACE(n)) { <span class="enscript-comment">/* XXX */</span>
			n-&gt;m_len += siz;
			m-&gt;m_pkthdr.len += siz;
			p = mtod(n, u_char *) + n-&gt;m_len - siz;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> mbuf *nn;
	
			MGET(nn, M_DONTWAIT, MT_DATA);
			<span class="enscript-keyword">if</span> (!nn) {
				ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;can't alloc mbuf in esp%d_output&quot;</span>,
					afnumber));
				m_freem(m);
				error = ENOBUFS;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			nn-&gt;m_len = siz;
			nn-&gt;m_next = NULL;
			n-&gt;m_next = nn;
			n = nn;
			m-&gt;m_pkthdr.len += siz;
			p = mtod(nn, u_char *);
		}
		bcopy(authbuf, p, siz);
	
		<span class="enscript-comment">/* modify IP header (for ESP header part only) */</span>
		<span class="enscript-keyword">switch</span> (af) {
	#<span class="enscript-keyword">if</span> INET
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
			ip = mtod(m, <span class="enscript-type">struct</span> ip *);
			<span class="enscript-keyword">if</span> (siz &lt; (IP_MAXPACKET - ntohs(ip-&gt;ip_len)))
				ip-&gt;ip_len = htons(ntohs(ip-&gt;ip_len) + siz);
			<span class="enscript-keyword">else</span> {
				ipseclog((LOG_ERR,
					<span class="enscript-string">&quot;IPv4 ESP output: size exceeds limit\n&quot;</span>));
				IPSEC_STAT_INCREMENT(ipsecstat.out_inval);
				m_freem(m);
				error = EMSGSIZE;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			}
			<span class="enscript-keyword">break</span>;
	#endif
	#<span class="enscript-keyword">if</span> INET6
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			<span class="enscript-comment">/* total packet length will be computed in ip6_output() */</span>
			<span class="enscript-keyword">break</span>;
	#endif
		}
    }
    
	<span class="enscript-keyword">if</span> (udp_encapsulate) {
		<span class="enscript-type">struct</span> ip *ip;
		<span class="enscript-type">struct</span> ip6_hdr *ip6;

		<span class="enscript-keyword">switch</span> (af) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		    ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		    udp-&gt;uh_ulen = htons(ntohs(ip-&gt;ip_len) - (IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2));
		    <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		    ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
		    udp-&gt;uh_ulen = htons(plen + siz + extendsiz + esphlen);
		    udp-&gt;uh_sum = in6_pseudo(&amp;ip6-&gt;ip6_src, &amp;ip6-&gt;ip6_dst, htonl(ntohs(udp-&gt;uh_ulen) + IPPROTO_UDP));
		    m-&gt;m_pkthdr.csum_flags = CSUM_UDPIPV6;
		    m-&gt;m_pkthdr.csum_data = offsetof(<span class="enscript-type">struct</span> udphdr, uh_sum);
		    <span class="enscript-keyword">break</span>;
		}
	}

<span class="enscript-reference">noantireplay</span>:
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">if</span> (!m) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;NULL mbuf after encryption in esp%d_output&quot;</span>, afnumber));
	} <span class="enscript-keyword">else</span>
		stat-&gt;out_success++;
	stat-&gt;out_esphist[sav-&gt;alg_enc]++;
	lck_mtx_unlock(sadb_mutex);
	key_sa_recordxfer(sav, m);
	KERNEL_DEBUG(DBG_FNC_ESPOUT | DBG_FUNC_END, 6,0,0,0,0);
	<span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">fail</span>:
#<span class="enscript-reference">if</span> 1
	KERNEL_DEBUG(DBG_FNC_ESPOUT | DBG_FUNC_END, 7,error,0,0,0);
	<span class="enscript-keyword">return</span> error;
#<span class="enscript-reference">else</span>
	panic(<span class="enscript-string">&quot;something bad in esp_output&quot;</span>);
#<span class="enscript-reference">endif</span>
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">esp4_output</span>(m, sav)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;esp4_output: first mbuf too short\n&quot;</span>));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	<span class="enscript-comment">/* XXX assumes that m-&gt;m_next points to payload */</span>
	<span class="enscript-keyword">return</span> esp_output(m, &amp;ip-&gt;ip_p, m-&gt;m_next, AF_INET, sav);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*INET*/</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">esp6_output</span>(m, nexthdrp, md, sav)
	<span class="enscript-type">struct</span> mbuf *m;
	u_char *nexthdrp;
	<span class="enscript-type">struct</span> mbuf *md;
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;esp6_output: first mbuf too short\n&quot;</span>));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">return</span> esp_output(m, nexthdrp, md, AF_INET6, sav);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*INET6*/</span>
</pre>
<hr />
</body></html>