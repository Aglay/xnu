<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>in6_src.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">in6_src.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)in_pcb.c	8.2 (Berkeley) 1/4/94
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/scope6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;loop.h&quot;</span>

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_inet6_ip6);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip6_select_srcif_debug = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ip6, OID_AUTO, select_srcif_debug,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip6_select_srcif_debug, 0,
	<span class="enscript-string">&quot;log source interface selection debug info&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip6_select_srcaddr_debug = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ip6, OID_AUTO, select_srcaddr_debug,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip6_select_srcaddr_debug, 0,
	<span class="enscript-string">&quot;log source address selection debug info&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip6_select_src_expensive_secondary_if = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ip6, OID_AUTO, select_src_expensive_secondary_if,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip6_select_src_expensive_secondary_if, 0,
	<span class="enscript-string">&quot;allow source interface selection to use expensive secondaries&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ADDR_LABEL_NOTAPP</span> (-1)
<span class="enscript-type">struct</span> in6_addrpolicy defaultaddrpolicy;

<span class="enscript-type">int</span> ip6_prefer_tempaddr = 1;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">ENABLE_ADDRSEL</span>
<span class="enscript-type">extern</span> lck_mtx_t *addrsel_mutex;
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ADDRSEL_LOCK</span>()		lck_mtx_lock(addrsel_mutex)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ADDRSEL_UNLOCK</span>()	lck_mtx_unlock(addrsel_mutex)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ADDRSEL_LOCK</span>()
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ADDRSEL_UNLOCK</span>()
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">selectroute</span>(<span class="enscript-type">struct</span> sockaddr_in6 *, <span class="enscript-type">struct</span> sockaddr_in6 *,
	<span class="enscript-type">struct</span> ip6_pktopts *, <span class="enscript-type">struct</span> ip6_moptions *, <span class="enscript-type">struct</span> in6_ifaddr **,
	<span class="enscript-type">struct</span> route_in6 *, <span class="enscript-type">struct</span> ifnet **, <span class="enscript-type">struct</span> rtentry **, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>,
	<span class="enscript-type">struct</span> ip6_out_args *ip6oa);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6_selectif</span>(<span class="enscript-type">struct</span> sockaddr_in6 *, <span class="enscript-type">struct</span> ip6_pktopts *,
	<span class="enscript-type">struct</span> ip6_moptions *, <span class="enscript-type">struct</span> route_in6 *ro,
	<span class="enscript-type">struct</span> ip6_out_args *, <span class="enscript-type">struct</span> ifnet **);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">init_policy_queue</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">add_addrsel_policyent</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addrpolicy *);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">ENABLE_ADDRSEL</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">delete_addrsel_policyent</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addrpolicy *);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">walk_addrsel_policy</span>(<span class="enscript-type">int</span> (*)(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addrpolicy *, <span class="enscript-type">void</span> *),
	<span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dump_addrsel_policyent</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addrpolicy *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> in6_addrpolicy *<span class="enscript-function-name">match_addrsel_policy</span>(<span class="enscript-type">struct</span> sockaddr_in6 *);
<span class="enscript-type">void</span> <span class="enscript-function-name">addrsel_policy_init</span>(<span class="enscript-type">void</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SASEL_DO_DBG</span>(inp) \
	(ip6_select_srcaddr_debug &amp;&amp; (inp) != NULL &amp;&amp; \
	    (inp)-&gt;inp_socket != NULL &amp;&amp; \
	    ((inp)-&gt;inp_socket-&gt;so_options &amp; SO_DEBUG))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SASEL_LOG</span>(fmt, ...) \
<span class="enscript-keyword">do</span> { \
	<span class="enscript-keyword">if</span> (SASEL_DO_DBG(inp)) \
		printf(<span class="enscript-string">&quot;%s:%d &quot;</span> fmt <span class="enscript-string">&quot;\n&quot;</span>,\
		    __FUNCTION__, __LINE__, ##__VA_ARGS__); \
} <span class="enscript-keyword">while</span> (0); \

<span class="enscript-comment">/*
 * Return an IPv6 address, which is the most appropriate for a given
 * destination and user specified options.
 * If necessary, this function lookups the routing table and returns
 * an entry to the caller for later use.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">REPLACE</span>(r) do {\
	SASEL_LOG(<span class="enscript-string">&quot;REPLACE r %d ia %s ifp1 %s\n&quot;</span>, \
	    (r), s_src, ifp1-&gt;if_xname); \
	srcrule = (r); \
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">replace</span>; \
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NEXTSRC</span>(r) do {\
	SASEL_LOG(<span class="enscript-string">&quot;NEXTSRC r %d ia %s ifp1 %s\n&quot;</span>, \
	    (r), s_src, ifp1-&gt;if_xname); \
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;		<span class="enscript-comment">/* XXX: we can't use 'continue' here */</span> \
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">BREAK</span>(r) do { \
	SASEL_LOG(<span class="enscript-string">&quot;BREAK r %d ia %s ifp1 %s\n&quot;</span>, \
	    (r), s_src, ifp1-&gt;if_xname); \
	srcrule = (r); \
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;		<span class="enscript-comment">/* XXX: we can't use 'break' here */</span> \
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * Regardless of error, it will return an ifp with a reference held if the
 * caller provides a non-NULL ifpp.  The caller is responsible for checking
 * if the returned ifp is valid and release its reference at all times.
 */</span>
<span class="enscript-type">struct</span> in6_addr *
<span class="enscript-function-name">in6_selectsrc</span>(<span class="enscript-type">struct</span> sockaddr_in6 *dstsock, <span class="enscript-type">struct</span> ip6_pktopts *opts,
    <span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> route_in6 *ro,
    <span class="enscript-type">struct</span> ifnet **ifpp, <span class="enscript-type">struct</span> in6_addr *src_storage, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope,
    <span class="enscript-type">int</span> *errorp)
{
	<span class="enscript-type">struct</span> in6_addr dst;
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;
	<span class="enscript-type">struct</span> in6_ifaddr *ia = NULL, *ia_best = NULL;
	<span class="enscript-type">struct</span> in6_pktinfo *pi = NULL;
	<span class="enscript-type">int</span> dst_scope = -1, best_scope = -1, best_matchlen = -1;
	<span class="enscript-type">struct</span> in6_addrpolicy *dst_policy = NULL, *best_policy = NULL;
	u_int32_t odstzone;
	<span class="enscript-type">int</span> prefer_tempaddr;
	<span class="enscript-type">struct</span> ip6_moptions *mopts;
	<span class="enscript-type">struct</span> ip6_out_args ip6oa = { ifscope, { 0 }, IP6OAF_SELECT_SRCIF, 0 };
	boolean_t islocal = FALSE;
	uint64_t secs = net_uptime();
	<span class="enscript-type">char</span> s_src[MAX_IPv6_STR_LEN], s_dst[MAX_IPv6_STR_LEN];
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr *tmp;
	<span class="enscript-type">int</span> bestrule = IP6S_SRCRULE_0;

	dst = dstsock-&gt;sin6_addr; <span class="enscript-comment">/* make a copy for local operation */</span>
	*errorp = 0;
	<span class="enscript-keyword">if</span> (ifpp != NULL)
		*ifpp = NULL;

	<span class="enscript-keyword">if</span> (inp != NULL) {
		mopts = inp-&gt;in6p_moptions;
		<span class="enscript-keyword">if</span> (INP_NO_CELLULAR(inp))
			ip6oa.ip6oa_flags |= IP6OAF_NO_CELLULAR;
		<span class="enscript-keyword">if</span> (INP_NO_EXPENSIVE(inp))
			ip6oa.ip6oa_flags |= IP6OAF_NO_EXPENSIVE;
		<span class="enscript-keyword">if</span> (INP_AWDL_UNRESTRICTED(inp))
			ip6oa.ip6oa_flags |= IP6OAF_AWDL_UNRESTRICTED;

	} <span class="enscript-keyword">else</span> {
		mopts = NULL;
	}

	<span class="enscript-keyword">if</span> (ip6oa.ip6oa_boundif != IFSCOPE_NONE)
		ip6oa.ip6oa_flags |= IP6OAF_BOUND_IF;

	<span class="enscript-comment">/*
	 * If the source address is explicitly specified by the caller,
	 * check if the requested source address is indeed a unicast address
	 * assigned to the node, and can be used as the packet's source
	 * address.  If everything is okay, use the address as source.
	 */</span>
	<span class="enscript-keyword">if</span> (opts &amp;&amp; (pi = opts-&gt;ip6po_pktinfo) &amp;&amp;
	    !IN6_IS_ADDR_UNSPECIFIED(&amp;pi-&gt;ipi6_addr)) {
		<span class="enscript-type">struct</span> sockaddr_in6 srcsock;
		<span class="enscript-type">struct</span> in6_ifaddr *ia6;

		<span class="enscript-comment">/* get the outgoing interface */</span>
		<span class="enscript-keyword">if</span> ((*errorp = in6_selectif(dstsock, opts, mopts, ro, &amp;ip6oa,
		    &amp;ifp)) != 0) {
			src_storage = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		<span class="enscript-comment">/*
		 * determine the appropriate zone id of the source based on
		 * the zone of the destination and the outgoing interface.
		 * If the specified address is ambiguous wrt the scope zone,
		 * the interface must be specified; otherwise, ifa_ifwithaddr()
		 * will fail matching the address.
		 */</span>
		bzero(&amp;srcsock, <span class="enscript-keyword">sizeof</span> (srcsock));
		srcsock.sin6_family = AF_INET6;
		srcsock.sin6_len = <span class="enscript-keyword">sizeof</span> (srcsock);
		srcsock.sin6_addr = pi-&gt;ipi6_addr;
		<span class="enscript-keyword">if</span> (ifp != NULL) {
			*errorp = in6_setscope(&amp;srcsock.sin6_addr, ifp, NULL);
			<span class="enscript-keyword">if</span> (*errorp != 0) {
				src_storage = NULL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
		}
		ia6 = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa_ifwithaddr((<span class="enscript-type">struct</span> sockaddr *)
		    (&amp;srcsock));
		<span class="enscript-keyword">if</span> (ia6 == NULL) {
			*errorp = EADDRNOTAVAIL;
			src_storage = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		IFA_LOCK_SPIN(&amp;ia6-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> ((ia6-&gt;ia6_flags &amp; (IN6_IFF_ANYCAST | IN6_IFF_NOTREADY)) ||
		    (inp &amp;&amp; inp_restricted_send(inp, ia6-&gt;ia_ifa.ifa_ifp))) {
			IFA_UNLOCK(&amp;ia6-&gt;ia_ifa);
			IFA_REMREF(&amp;ia6-&gt;ia_ifa);
			*errorp = EHOSTUNREACH;
			src_storage = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		*src_storage = satosin6(&amp;ia6-&gt;ia_addr)-&gt;sin6_addr;
		IFA_UNLOCK(&amp;ia6-&gt;ia_ifa);
		IFA_REMREF(&amp;ia6-&gt;ia_ifa);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Otherwise, if the socket has already bound the source, just use it.
	 */</span>
	<span class="enscript-keyword">if</span> (inp != NULL &amp;&amp; !IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_laddr)) {
		src_storage = &amp;inp-&gt;in6p_laddr;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * If the address is not specified, choose the best one based on
	 * the outgoing interface and the destination address.
	 */</span>

	<span class="enscript-comment">/* get the outgoing interface */</span>
	<span class="enscript-keyword">if</span> ((*errorp = in6_selectif(dstsock, opts, mopts, ro, &amp;ip6oa,
	    &amp;ifp)) != 0) {
		src_storage = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (SASEL_DO_DBG(inp)) {
		(<span class="enscript-type">void</span>) inet_ntop(AF_INET6, &amp;dst, s_dst, <span class="enscript-keyword">sizeof</span> (s_src));

		tmp = &amp;in6addr_any;
		(<span class="enscript-type">void</span>) inet_ntop(AF_INET6, tmp, s_src, <span class="enscript-keyword">sizeof</span> (s_src));

		printf(<span class="enscript-string">&quot;%s out src %s dst %s ifscope %d ifp %s\n&quot;</span>, 
		    __func__, s_src, s_dst, ifscope,
		    ifp ? ifp-&gt;if_xname : <span class="enscript-string">&quot;NULL&quot;</span>);
	}

	*errorp = in6_setscope(&amp;dst, ifp, &amp;odstzone);
	<span class="enscript-keyword">if</span> (*errorp != 0) {
		src_storage = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	lck_rw_lock_shared(&amp;in6_ifaddr_rwlock);

	<span class="enscript-keyword">for</span> (ia = in6_ifaddrs; ia; ia = ia-&gt;ia_next) {
		<span class="enscript-type">int</span> new_scope = -1, new_matchlen = -1;
		<span class="enscript-type">struct</span> in6_addrpolicy *new_policy = NULL;
		u_int32_t srczone, osrczone, dstzone;
		<span class="enscript-type">struct</span> in6_addr src;
		<span class="enscript-type">struct</span> ifnet *ifp1 = ia-&gt;ia_ifp;
		<span class="enscript-type">int</span> srcrule;

		<span class="enscript-keyword">if</span> (SASEL_DO_DBG(inp))
			(<span class="enscript-type">void</span>) inet_ntop(AF_INET6, &amp;ia-&gt;ia_addr.sin6_addr,
			     s_src, <span class="enscript-keyword">sizeof</span> (s_src));

		IFA_LOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-comment">/*
		 * We'll never take an address that breaks the scope zone
		 * of the destination.  We also skip an address if its zone
		 * does not contain the outgoing interface.
		 * XXX: we should probably use sin6_scope_id here.
		 */</span>
		<span class="enscript-keyword">if</span> (in6_setscope(&amp;dst, ifp1, &amp;dstzone) ||
		    odstzone != dstzone) {
			SASEL_LOG(<span class="enscript-string">&quot;NEXT ia %s ifp1 %s odstzone %d != dstzone %d\n&quot;</span>,
			    s_src, ifp1-&gt;if_xname, odstzone, dstzone);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
		}
		src = ia-&gt;ia_addr.sin6_addr;
		<span class="enscript-keyword">if</span> (in6_setscope(&amp;src, ifp, &amp;osrczone) ||
		    in6_setscope(&amp;src, ifp1, &amp;srczone) ||
		    osrczone != srczone) {
			SASEL_LOG(<span class="enscript-string">&quot;NEXT ia %s ifp1 %s osrczone %d != srczone %d\n&quot;</span>,
			    s_src, ifp1-&gt;if_xname, osrczone, srczone);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
		}
		<span class="enscript-comment">/* avoid unusable addresses */</span>
		<span class="enscript-keyword">if</span> ((ia-&gt;ia6_flags &amp;
		    (IN6_IFF_NOTREADY | IN6_IFF_ANYCAST | IN6_IFF_DETACHED))) {
			SASEL_LOG(<span class="enscript-string">&quot;NEXT ia %s ifp1 %s ia6_flags 0x%x\n&quot;</span>,
			    s_src, ifp1-&gt;if_xname, ia-&gt;ia6_flags);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
		}
		<span class="enscript-keyword">if</span> (!ip6_use_deprecated &amp;&amp; IFA6_IS_DEPRECATED(ia, secs)) {
			SASEL_LOG(<span class="enscript-string">&quot;NEXT ia %s ifp1 %s IFA6_IS_DEPRECATED\n&quot;</span>,
			    s_src, ifp1-&gt;if_xname);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
		}
		<span class="enscript-keyword">if</span> (!nd6_optimistic_dad &amp;&amp;
		    (ia-&gt;ia6_flags &amp; IN6_IFF_OPTIMISTIC) != 0) {
			SASEL_LOG(<span class="enscript-string">&quot;NEXT ia %s ifp1 %s IN6_IFF_OPTIMISTIC\n&quot;</span>,
			    s_src, ifp1-&gt;if_xname);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
		}
		<span class="enscript-comment">/* Rule 1: Prefer same address */</span>
		<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(&amp;dst, &amp;ia-&gt;ia_addr.sin6_addr))
			BREAK(IP6S_SRCRULE_1); <span class="enscript-comment">/* there should be no better candidate */</span>

		<span class="enscript-keyword">if</span> (ia_best == NULL)
			REPLACE(IP6S_SRCRULE_0);

		<span class="enscript-comment">/* Rule 2: Prefer appropriate scope */</span>
		<span class="enscript-keyword">if</span> (dst_scope &lt; 0)
			dst_scope = in6_addrscope(&amp;dst);
		new_scope = in6_addrscope(&amp;ia-&gt;ia_addr.sin6_addr);
		<span class="enscript-keyword">if</span> (IN6_ARE_SCOPE_CMP(best_scope, new_scope) &lt; 0) {
			<span class="enscript-keyword">if</span> (IN6_ARE_SCOPE_CMP(best_scope, dst_scope) &lt; 0)
				REPLACE(IP6S_SRCRULE_2);
			NEXTSRC(IP6S_SRCRULE_2);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IN6_ARE_SCOPE_CMP(new_scope, best_scope) &lt; 0) {
			<span class="enscript-keyword">if</span> (IN6_ARE_SCOPE_CMP(new_scope, dst_scope) &lt; 0)
				NEXTSRC(IP6S_SRCRULE_2);
			REPLACE(IP6S_SRCRULE_2);
		}

		<span class="enscript-comment">/*
		 * Rule 3: Avoid deprecated addresses.  Note that the case of
		 * !ip6_use_deprecated is already rejected above.
		 */</span>
		<span class="enscript-keyword">if</span> (!IFA6_IS_DEPRECATED(ia_best, secs) &amp;&amp;
		    IFA6_IS_DEPRECATED(ia, secs))
			NEXTSRC(IP6S_SRCRULE_3);
		<span class="enscript-keyword">if</span> (IFA6_IS_DEPRECATED(ia_best, secs) &amp;&amp;
		    !IFA6_IS_DEPRECATED(ia, secs))
			REPLACE(IP6S_SRCRULE_3);

		<span class="enscript-comment">/*
		 * RFC 4429 says that optimistic addresses are equivalent to
		 * deprecated addresses, so avoid them here.
		 */</span>
		<span class="enscript-keyword">if</span> ((ia_best-&gt;ia6_flags &amp; IN6_IFF_OPTIMISTIC) == 0 &amp;&amp;
		    (ia-&gt;ia6_flags &amp; IN6_IFF_OPTIMISTIC) != 0)
			NEXTSRC(IP6S_SRCRULE_3);
		<span class="enscript-keyword">if</span> ((ia_best-&gt;ia6_flags &amp; IN6_IFF_OPTIMISTIC) != 0 &amp;&amp;
		    (ia-&gt;ia6_flags &amp; IN6_IFF_OPTIMISTIC) == 0)
			REPLACE(IP6S_SRCRULE_3);

		<span class="enscript-comment">/* Rule 4: Prefer home addresses */</span>
		<span class="enscript-comment">/*
		 * XXX: This is a TODO.  We should probably merge the MIP6
		 * case above.
		 */</span>

		<span class="enscript-comment">/* Rule 5: Prefer outgoing interface */</span>
		<span class="enscript-keyword">if</span> (ia_best-&gt;ia_ifp == ifp &amp;&amp; ia-&gt;ia_ifp != ifp)
			NEXTSRC(IP6S_SRCRULE_5);
		<span class="enscript-keyword">if</span> (ia_best-&gt;ia_ifp != ifp &amp;&amp; ia-&gt;ia_ifp == ifp)
			REPLACE(IP6S_SRCRULE_5);

		<span class="enscript-comment">/* Rule 5.5: Prefer addresses in a prefix advertised by the next hop. */</span>
		<span class="enscript-keyword">if</span> (ro != NULL &amp;&amp; ro-&gt;ro_rt != NULL &amp;&amp; ia_best-&gt;ia6_ndpr != NULL &amp;&amp;
		    ia-&gt;ia6_ndpr != NULL) {
			<span class="enscript-type">struct</span> rtentry *rta, *rtb;
			<span class="enscript-type">int</span> op;

			NDPR_LOCK(ia_best-&gt;ia6_ndpr);
			rta = ia_best-&gt;ia6_ndpr-&gt;ndpr_rt;
			<span class="enscript-keyword">if</span> (rta != NULL)
				RT_ADDREF(rta);
			NDPR_UNLOCK(ia_best-&gt;ia6_ndpr);

			NDPR_LOCK(ia-&gt;ia6_ndpr);
			rtb = ia-&gt;ia6_ndpr-&gt;ndpr_rt;
			<span class="enscript-keyword">if</span> (rtb != NULL)
				RT_ADDREF(rtb);
			NDPR_UNLOCK(ia-&gt;ia6_ndpr);

			<span class="enscript-keyword">if</span> (rta == NULL || rtb == NULL)
				op = 0;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rta == ro-&gt;ro_rt &amp;&amp; rtb != ro-&gt;ro_rt)
				op = 1;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rta != ro-&gt;ro_rt &amp;&amp; rtb == ro-&gt;ro_rt)
				op = 2;
			<span class="enscript-keyword">else</span>
				op = 0;

			<span class="enscript-keyword">if</span> (rta != NULL)
				RT_REMREF(rta);
			<span class="enscript-keyword">if</span> (rtb != NULL)
				RT_REMREF(rtb);

			<span class="enscript-keyword">switch</span> (op) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
				NEXTSRC(IP6S_SRCRULE_5_5);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
				REPLACE(IP6S_SRCRULE_5_5);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-comment">/*
		 * Rule 6: Prefer matching label
		 * Note that best_policy should be non-NULL here.
		 */</span>
		<span class="enscript-keyword">if</span> (dst_policy == NULL)
			dst_policy = in6_addrsel_lookup_policy(dstsock);
		<span class="enscript-keyword">if</span> (dst_policy-&gt;label != ADDR_LABEL_NOTAPP) {
			new_policy = in6_addrsel_lookup_policy(&amp;ia-&gt;ia_addr);
			<span class="enscript-keyword">if</span> (dst_policy-&gt;label == best_policy-&gt;label &amp;&amp;
			    dst_policy-&gt;label != new_policy-&gt;label)
				NEXTSRC(IP6S_SRCRULE_6);
			<span class="enscript-keyword">if</span> (dst_policy-&gt;label != best_policy-&gt;label &amp;&amp;
			    dst_policy-&gt;label == new_policy-&gt;label)
				REPLACE(IP6S_SRCRULE_6);
		}

		<span class="enscript-comment">/*
		 * Rule 7: Prefer temporary addresses.
		 * We allow users to reverse the logic by configuring
		 * a sysctl variable, so that transparency conscious users can
		 * always prefer stable addresses.
		 * Don't use temporary addresses for local destinations or
		 * for multicast addresses unless we were passed in an option.
		 */</span>
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;dst) ||
		    in6_matchlen(&amp;ia_best-&gt;ia_addr.sin6_addr, &amp;dst) &gt;=
		    ia_best-&gt;ia_plen)
			islocal = TRUE;
		<span class="enscript-keyword">if</span> (opts == NULL ||
		    opts-&gt;ip6po_prefer_tempaddr == IP6PO_TEMPADDR_SYSTEM) {
			prefer_tempaddr = islocal ? 0 : ip6_prefer_tempaddr;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (opts-&gt;ip6po_prefer_tempaddr ==
		    IP6PO_TEMPADDR_NOTPREFER) {
			prefer_tempaddr = 0;
		} <span class="enscript-keyword">else</span>
			prefer_tempaddr = 1;
		<span class="enscript-keyword">if</span> (!(ia_best-&gt;ia6_flags &amp; IN6_IFF_TEMPORARY) &amp;&amp;
		    (ia-&gt;ia6_flags &amp; IN6_IFF_TEMPORARY)) {
			<span class="enscript-keyword">if</span> (prefer_tempaddr)
				REPLACE(IP6S_SRCRULE_7);
			<span class="enscript-keyword">else</span>
				NEXTSRC(IP6S_SRCRULE_7);
		}
		<span class="enscript-keyword">if</span> ((ia_best-&gt;ia6_flags &amp; IN6_IFF_TEMPORARY) &amp;&amp;
		    !(ia-&gt;ia6_flags &amp; IN6_IFF_TEMPORARY)) {
			<span class="enscript-keyword">if</span> (prefer_tempaddr)
				NEXTSRC(IP6S_SRCRULE_7);
			<span class="enscript-keyword">else</span>
				REPLACE(IP6S_SRCRULE_7);
		}

		<span class="enscript-comment">/*
		 * Rule 7x: prefer addresses on alive interfaces.
		 * This is a KAME specific rule.
		 */</span>
		<span class="enscript-keyword">if</span> ((ia_best-&gt;ia_ifp-&gt;if_flags &amp; IFF_UP) &amp;&amp;
		    !(ia-&gt;ia_ifp-&gt;if_flags &amp; IFF_UP))
			NEXTSRC(IP6S_SRCRULE_7x);
		<span class="enscript-keyword">if</span> (!(ia_best-&gt;ia_ifp-&gt;if_flags &amp; IFF_UP) &amp;&amp;
		    (ia-&gt;ia_ifp-&gt;if_flags &amp; IFF_UP))
			REPLACE(IP6S_SRCRULE_7x);

		<span class="enscript-comment">/*
		 * Rule 8: Use longest matching prefix.
		 */</span>
		new_matchlen = in6_matchlen(&amp;ia-&gt;ia_addr.sin6_addr, &amp;dst);
		<span class="enscript-keyword">if</span> (best_matchlen &lt; new_matchlen)
			REPLACE(IP6S_SRCRULE_8);
		<span class="enscript-keyword">if</span> (new_matchlen &lt; best_matchlen)
			NEXTSRC(IP6S_SRCRULE_8);

		<span class="enscript-comment">/*
		 * Last resort: just keep the current candidate.
		 * Or, do we need more rules?
		 */</span>
		<span class="enscript-keyword">if</span> (ifp1 != ifp &amp;&amp; (ifp1-&gt;if_eflags &amp; IFEF_EXPENSIVE) &amp;&amp;
		    ip6_select_src_expensive_secondary_if == 0) {
			SASEL_LOG(<span class="enscript-string">&quot;NEXT ia %s ifp1 %s IFEF_EXPENSIVE\n&quot;</span>,
			    s_src, ifp1-&gt;if_xname);
		   	ip6stat.ip6s_sources_skip_expensive_secondary_if++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
		}
		SASEL_LOG(<span class="enscript-string">&quot;NEXT ia %s ifp1 %s last resort\n&quot;</span>,
		    s_src, ifp1-&gt;if_xname);
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">continue</span>;

<span class="enscript-reference">replace</span>:
		<span class="enscript-comment">/*
		 * Ignore addresses on secondary interfaces that are marked
		 * expensive
		 */</span>
		<span class="enscript-keyword">if</span> (ifp1 != ifp &amp;&amp; (ifp1-&gt;if_eflags &amp; IFEF_EXPENSIVE) &amp;&amp;
		    ip6_select_src_expensive_secondary_if == 0) {
			SASEL_LOG(<span class="enscript-string">&quot;NEXT ia %s ifp1 %s IFEF_EXPENSIVE\n&quot;</span>,
			    s_src, ifp1-&gt;if_xname);
		   	ip6stat.ip6s_sources_skip_expensive_secondary_if++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
		}
		bestrule = srcrule;
		best_scope = (new_scope &gt;= 0 ? new_scope :
		    in6_addrscope(&amp;ia-&gt;ia_addr.sin6_addr));
		best_policy = (new_policy ? new_policy :
		    in6_addrsel_lookup_policy(&amp;ia-&gt;ia_addr));
		best_matchlen = (new_matchlen &gt;= 0 ? new_matchlen :
		    in6_matchlen(&amp;ia-&gt;ia_addr.sin6_addr, &amp;dst));
		SASEL_LOG(<span class="enscript-string">&quot;NEXT ia %s ifp1 %s best_scope %d new_scope %d dst_scope %d\n&quot;</span>,
		    s_src, ifp1-&gt;if_xname, best_scope, new_scope, dst_scope);
		IFA_ADDREF_LOCKED(&amp;ia-&gt;ia_ifa);	<span class="enscript-comment">/* for ia_best */</span>
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (ia_best != NULL)
			IFA_REMREF(&amp;ia_best-&gt;ia_ifa);
		ia_best = ia;
		<span class="enscript-keyword">continue</span>;

<span class="enscript-reference">next</span>:
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">continue</span>;

<span class="enscript-reference">out</span>:
		IFA_ADDREF_LOCKED(&amp;ia-&gt;ia_ifa);	<span class="enscript-comment">/* for ia_best */</span>
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (ia_best != NULL)
			IFA_REMREF(&amp;ia_best-&gt;ia_ifa);
		ia_best = ia;
		<span class="enscript-keyword">break</span>;
	}

	lck_rw_done(&amp;in6_ifaddr_rwlock);

	<span class="enscript-keyword">if</span> (ia_best != NULL &amp;&amp; inp &amp;&amp; 
	    inp_restricted_send(inp, ia_best-&gt;ia_ifa.ifa_ifp)) {
		IFA_REMREF(&amp;ia_best-&gt;ia_ifa);
		ia_best = NULL;
		*errorp = EHOSTUNREACH;
	}

	<span class="enscript-keyword">if</span> ((ia = ia_best) == NULL) {
		<span class="enscript-keyword">if</span> (*errorp == 0)
			*errorp = EADDRNOTAVAIL;
		src_storage = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);
	<span class="enscript-keyword">if</span> (bestrule &lt; IP6S_SRCRULE_COUNT)
		ip6stat.ip6s_sources_rule[bestrule]++;
	*src_storage = satosin6(&amp;ia-&gt;ia_addr)-&gt;sin6_addr;
	IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
	IFA_REMREF(&amp;ia-&gt;ia_ifa);
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (SASEL_DO_DBG(inp)) {
		(<span class="enscript-type">void</span>) inet_ntop(AF_INET6, &amp;dst, s_dst, <span class="enscript-keyword">sizeof</span> (s_src));

		tmp = (src_storage != NULL) ? src_storage : &amp;in6addr_any;
		(<span class="enscript-type">void</span>) inet_ntop(AF_INET6, tmp, s_src, <span class="enscript-keyword">sizeof</span> (s_src));
	    
		printf(<span class="enscript-string">&quot;%s out src %s dst %s ifscope %d dst_scope %d best_scope %d\n&quot;</span>, 
		    __func__, s_src, s_dst, ifscope, dst_scope, best_scope);
	}
	<span class="enscript-keyword">if</span> (ifpp != NULL) {
		<span class="enscript-comment">/* if ifp is non-NULL, refcnt held in in6_selectif() */</span>
		*ifpp = ifp;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifp != NULL) {
		ifnet_release(ifp);
	}
	<span class="enscript-keyword">return</span> (src_storage);
}

<span class="enscript-comment">/*
 * Given a source IPv6 address (and route, if available), determine the best
 * interface to send the packet from.  Checking for (and updating) the
 * ROF_SRCIF_SELECTED flag in the pcb-supplied route placeholder is done
 * without any locks, based on the assumption that in the event this is
 * called from ip6_output(), the output operation is single-threaded per-pcb,
 * i.e. for any given pcb there can only be one thread performing output at
 * the IPv6 layer.
 *
 * This routine is analogous to in_selectsrcif() for IPv4.  Regardless of
 * error, it will return an ifp with a reference held if the caller provides
 * a non-NULL retifp.  The caller is responsible for checking if the
 * returned ifp is valid and release its reference at all times.
 *
 * clone - meaningful only for bsdi and freebsd
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">selectroute</span>(<span class="enscript-type">struct</span> sockaddr_in6 *srcsock, <span class="enscript-type">struct</span> sockaddr_in6 *dstsock,
    <span class="enscript-type">struct</span> ip6_pktopts *opts, <span class="enscript-type">struct</span> ip6_moptions *mopts,
    <span class="enscript-type">struct</span> in6_ifaddr **retsrcia, <span class="enscript-type">struct</span> route_in6 *ro,
    <span class="enscript-type">struct</span> ifnet **retifp, <span class="enscript-type">struct</span> rtentry **retrt, <span class="enscript-type">int</span> clone,
    <span class="enscript-type">int</span> norouteok, <span class="enscript-type">struct</span> ip6_out_args *ip6oa)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> ifnet *ifp = NULL, *ifp0 = NULL;
	<span class="enscript-type">struct</span> route_in6 *route = NULL;
	<span class="enscript-type">struct</span> sockaddr_in6 *sin6_next;
	<span class="enscript-type">struct</span> in6_pktinfo *pi = NULL;
	<span class="enscript-type">struct</span> in6_addr *dst = &amp;dstsock-&gt;sin6_addr;
	<span class="enscript-type">struct</span> ifaddr *ifa = NULL;
	<span class="enscript-type">char</span> s_src[MAX_IPv6_STR_LEN], s_dst[MAX_IPv6_STR_LEN];
	boolean_t select_srcif, proxied_ifa = FALSE, local_dst = FALSE;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope = ((ip6oa != NULL) ?
	    ip6oa-&gt;ip6oa_boundif : IFSCOPE_NONE);

#<span class="enscript-reference">if</span> 0
	<span class="enscript-type">char</span> ip6buf[INET6_ADDRSTRLEN];

	<span class="enscript-keyword">if</span> (dstsock-&gt;sin6_addr.s6_addr32[0] == 0 &amp;&amp;
	    dstsock-&gt;sin6_addr.s6_addr32[1] == 0 &amp;&amp;
	    !IN6_IS_ADDR_LOOPBACK(&amp;dstsock-&gt;sin6_addr)) {
		printf(<span class="enscript-string">&quot;in6_selectroute: strange destination %s\n&quot;</span>,
		    ip6_sprintf(ip6buf, &amp;dstsock-&gt;sin6_addr));
	} <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;in6_selectroute: destination = %s%%%d\n&quot;</span>,
		    ip6_sprintf(ip6buf, &amp;dstsock-&gt;sin6_addr),
		    dstsock-&gt;sin6_scope_id); <span class="enscript-comment">/* for debug */</span>
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (retifp != NULL)
		*retifp = NULL;

	<span class="enscript-keyword">if</span> (retrt != NULL)
		*retrt = NULL;

	<span class="enscript-keyword">if</span> (ip6_select_srcif_debug) {
		<span class="enscript-type">struct</span> in6_addr src;
		src = (srcsock != NULL) ? srcsock-&gt;sin6_addr : in6addr_any;
		(<span class="enscript-type">void</span>) inet_ntop(AF_INET6, &amp;src, s_src, <span class="enscript-keyword">sizeof</span> (s_src));
		(<span class="enscript-type">void</span>) inet_ntop(AF_INET6, dst, s_dst, <span class="enscript-keyword">sizeof</span> (s_dst));
	}

	<span class="enscript-comment">/*
	 * If the destination address is UNSPECIFIED addr, bail out.
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(dst)) {
		error = EHOSTUNREACH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Perform source interface selection only if Scoped Routing
	 * is enabled and a source address that isn't unspecified.
	 */</span>
	select_srcif = (ip6_doscopedroute &amp;&amp; srcsock != NULL &amp;&amp;
	    !IN6_IS_ADDR_UNSPECIFIED(&amp;srcsock-&gt;sin6_addr));

	<span class="enscript-keyword">if</span> (ip6_select_srcif_debug) {
		printf(<span class="enscript-string">&quot;%s src %s dst %s ifscope %d select_srcif %d\n&quot;</span>, 
		    __func__, s_src, s_dst, ifscope, select_srcif);
	}
	<span class="enscript-comment">/*
	 * If Scoped Routing is disabled, ignore the given ifscope.
	 * Otherwise even if source selection won't be performed,
	 * we still obey IPV6_BOUND_IF.
	 */</span>
	<span class="enscript-keyword">if</span> (!ip6_doscopedroute &amp;&amp; ifscope != IFSCOPE_NONE)
		ifscope = IFSCOPE_NONE;

	<span class="enscript-comment">/* If the caller specified the outgoing interface explicitly, use it */</span>
	<span class="enscript-keyword">if</span> (opts != NULL &amp;&amp; (pi = opts-&gt;ip6po_pktinfo) != NULL &amp;&amp;
	    pi-&gt;ipi6_ifindex != 0) {
		<span class="enscript-comment">/*
		 * If IPV6_PKTINFO takes precedence over IPV6_BOUND_IF.
		 */</span>
		ifscope = pi-&gt;ipi6_ifindex;
		ifnet_head_lock_shared();
		<span class="enscript-comment">/* ifp may be NULL if detached or out of range */</span>
		ifp = ifp0 =
		    ((ifscope &lt;= if_index) ? ifindex2ifnet[ifscope] : NULL);
		ifnet_head_done();
		<span class="enscript-keyword">if</span> (norouteok || retrt == NULL || IN6_IS_ADDR_MULTICAST(dst)) {
			<span class="enscript-comment">/*
			 * We do not have to check or get the route for
			 * multicast.  If the caller didn't ask/care for
			 * the route and we have no interface to use,
			 * it's an error.
			 */</span>
			<span class="enscript-keyword">if</span> (ifp == NULL)
				error = EHOSTUNREACH;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">getsrcif</span>;
		}
	}

	<span class="enscript-comment">/*
	 * If the destination address is a multicast address and the outgoing
	 * interface for the address is specified by the caller, use it.
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(dst) &amp;&amp; mopts != NULL) {
		IM6O_LOCK(mopts);
		<span class="enscript-keyword">if</span> ((ifp = ifp0 = mopts-&gt;im6o_multicast_ifp) != NULL) {
			IM6O_UNLOCK(mopts);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>; <span class="enscript-comment">/* we do not need a route for multicast. */</span>
		}
		IM6O_UNLOCK(mopts);
	}

<span class="enscript-reference">getsrcif</span>:
	<span class="enscript-comment">/*
	 * If the outgoing interface was not set via IPV6_BOUND_IF or
	 * IPV6_PKTINFO, use the scope ID in the destination address.
	 */</span>
	<span class="enscript-keyword">if</span> (ip6_doscopedroute &amp;&amp; ifscope == IFSCOPE_NONE)
		ifscope = dstsock-&gt;sin6_scope_id;

	<span class="enscript-comment">/*
	 * Perform source interface selection; the source IPv6 address
	 * must belong to one of the addresses of the interface used
	 * by the route.  For performance reasons, do this only if
	 * there is no route, or if the routing table has changed,
	 * or if we haven't done source interface selection on this
	 * route (for this PCB instance) before.
	 */</span>
	<span class="enscript-keyword">if</span> (!select_srcif) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">getroute</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!ROUTE_UNUSABLE(ro) &amp;&amp; ro-&gt;ro_srcia != NULL &amp;&amp;
	    (ro-&gt;ro_flags &amp; ROF_SRCIF_SELECTED)) {
		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt-&gt;rt_ifp-&gt;if_flags &amp; IFF_LOOPBACK)
			local_dst = TRUE;
		ifa = ro-&gt;ro_srcia;
		IFA_ADDREF(ifa);	<span class="enscript-comment">/* for caller */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">getroute</span>;
	}

	<span class="enscript-comment">/*
	 * Given the source IPv6 address, find a suitable source interface
	 * to use for transmission; if a scope ID has been specified,
	 * optimize the search by looking at the addresses only for that
	 * interface.  This is still suboptimal, however, as we need to
	 * traverse the per-interface list.
	 */</span>
	<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE || (ro != NULL &amp;&amp; ro-&gt;ro_rt != NULL)) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> scope = ifscope;
		<span class="enscript-type">struct</span> ifnet *rt_ifp;

		rt_ifp = (ro-&gt;ro_rt != NULL) ? ro-&gt;ro_rt-&gt;rt_ifp : NULL;

		<span class="enscript-comment">/*
		 * If no scope is specified and the route is stale (pointing
		 * to a defunct interface) use the current primary interface;
		 * this happens when switching between interfaces configured
		 * with the same IPv6 address.  Otherwise pick up the scope
		 * information from the route; the ULP may have looked up a
		 * correct route and we just need to verify it here and mark
		 * it with the ROF_SRCIF_SELECTED flag below.
		 */</span>
		<span class="enscript-keyword">if</span> (scope == IFSCOPE_NONE) {
			scope = rt_ifp-&gt;if_index;
			<span class="enscript-keyword">if</span> (scope != get_primary_ifscope(AF_INET6) &amp;&amp;
			    ROUTE_UNUSABLE(ro))
				scope = get_primary_ifscope(AF_INET6);
		}

		ifa = (<span class="enscript-type">struct</span> ifaddr *)
		    ifa_foraddr6_scoped(&amp;srcsock-&gt;sin6_addr, scope);

		<span class="enscript-comment">/*
		 * If we are forwarding and proxying prefix(es), see if the
		 * source address is one of ours and is a proxied address;
		 * if so, use it.
		 */</span>
		<span class="enscript-keyword">if</span> (ifa == NULL &amp;&amp; ip6_forwarding &amp;&amp; nd6_prproxy) {
			ifa = (<span class="enscript-type">struct</span> ifaddr *)
			    ifa_foraddr6(&amp;srcsock-&gt;sin6_addr);
			<span class="enscript-keyword">if</span> (ifa != NULL &amp;&amp; !(proxied_ifa =
			    nd6_prproxy_ifaddr((<span class="enscript-type">struct</span> in6_ifaddr *)ifa))) {
				IFA_REMREF(ifa);
				ifa = NULL;
			}
		}

		<span class="enscript-keyword">if</span> (ip6_select_srcif_debug &amp;&amp; ifa != NULL) {
			<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL) {
				printf(<span class="enscript-string">&quot;%s %s-&gt;%s ifscope %d-&gt;%d ifa_if %s &quot;</span>
				    <span class="enscript-string">&quot;ro_if %s\n&quot;</span>,
				    __func__, 
				    s_src, s_dst, ifscope,
				    scope, if_name(ifa-&gt;ifa_ifp),
				    if_name(rt_ifp));
			} <span class="enscript-keyword">else</span> {
				printf(<span class="enscript-string">&quot;%s %s-&gt;%s ifscope %d-&gt;%d ifa_if %s\n&quot;</span>,
				    __func__, 
				    s_src, s_dst, ifscope, scope,
				    if_name(ifa-&gt;ifa_ifp));
			}
		}
	}

	<span class="enscript-comment">/*
	 * Slow path; search for an interface having the corresponding source
	 * IPv6 address if the scope was not specified by the caller, and:
	 *
	 *   1) There currently isn't any route, or,
	 *   2) The interface used by the route does not own that source
	 *	IPv6 address; in this case, the route will get blown away
	 *	and we'll do a more specific scoped search using the newly
	 *	found interface.
	 */</span>
	<span class="enscript-keyword">if</span> (ifa == NULL &amp;&amp; ifscope == IFSCOPE_NONE) {
		<span class="enscript-type">struct</span> ifaddr *ifadst;

		<span class="enscript-comment">/* Check if the destination address is one of ours */</span>
		ifadst = (<span class="enscript-type">struct</span> ifaddr *)ifa_foraddr6(&amp;dstsock-&gt;sin6_addr);
		<span class="enscript-keyword">if</span> (ifadst != NULL) {
			local_dst = TRUE;
			IFA_REMREF(ifadst);
		}

		ifa = (<span class="enscript-type">struct</span> ifaddr *)ifa_foraddr6(&amp;srcsock-&gt;sin6_addr);

		<span class="enscript-keyword">if</span> (ip6_select_srcif_debug &amp;&amp; ifa != NULL) {
			printf(<span class="enscript-string">&quot;%s %s-&gt;%s ifscope %d ifa_if %s\n&quot;</span>,
			    __func__,
			    s_src, s_dst, ifscope, if_name(ifa-&gt;ifa_ifp));
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ip6_select_srcif_debug) {
			printf(<span class="enscript-string">&quot;%s %s-&gt;%s ifscope %d ifa_if NULL\n&quot;</span>,
			    __func__,
			    s_src, s_dst, ifscope);
		}
	}

<span class="enscript-reference">getroute</span>:
	<span class="enscript-keyword">if</span> (ifa != NULL &amp;&amp; !proxied_ifa &amp;&amp; !local_dst)
		ifscope = ifa-&gt;ifa_ifp-&gt;if_index;

	<span class="enscript-comment">/*
	 * If the next hop address for the packet is specified by the caller,
	 * use it as the gateway.
	 */</span>
	<span class="enscript-keyword">if</span> (opts != NULL &amp;&amp; opts-&gt;ip6po_nexthop != NULL) {
		<span class="enscript-type">struct</span> route_in6 *ron;

		sin6_next = satosin6(opts-&gt;ip6po_nexthop);

		<span class="enscript-comment">/* at this moment, we only support AF_INET6 next hops */</span>
		<span class="enscript-keyword">if</span> (sin6_next-&gt;sin6_family != AF_INET6) {
			error = EAFNOSUPPORT; <span class="enscript-comment">/* or should we proceed? */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		<span class="enscript-comment">/*
		 * If the next hop is an IPv6 address, then the node identified
		 * by that address must be a neighbor of the sending host.
		 */</span>
		ron = &amp;opts-&gt;ip6po_nextroute;
		<span class="enscript-keyword">if</span> (ron-&gt;ro_rt != NULL)
			RT_LOCK(ron-&gt;ro_rt);
		<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ron) || (ron-&gt;ro_rt != NULL &amp;&amp;
		    (!(ron-&gt;ro_rt-&gt;rt_flags &amp; RTF_LLINFO) ||
		    (select_srcif &amp;&amp; (ifa == NULL ||
		    (ifa-&gt;ifa_ifp != ron-&gt;ro_rt-&gt;rt_ifp &amp;&amp; !proxied_ifa))))) ||
		    !IN6_ARE_ADDR_EQUAL(&amp;satosin6(&amp;ron-&gt;ro_dst)-&gt;sin6_addr,
		    &amp;sin6_next-&gt;sin6_addr)) {
			<span class="enscript-keyword">if</span> (ron-&gt;ro_rt != NULL)
				RT_UNLOCK(ron-&gt;ro_rt);

			ROUTE_RELEASE(ron);
			*satosin6(&amp;ron-&gt;ro_dst) = *sin6_next;
		}
		<span class="enscript-keyword">if</span> (ron-&gt;ro_rt == NULL) {
			rtalloc_scoped((<span class="enscript-type">struct</span> route *)ron, ifscope);
			<span class="enscript-keyword">if</span> (ron-&gt;ro_rt != NULL)
				RT_LOCK(ron-&gt;ro_rt);
			<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ron) ||
			    !(ron-&gt;ro_rt-&gt;rt_flags &amp; RTF_LLINFO) ||
			    !IN6_ARE_ADDR_EQUAL(&amp;satosin6(rt_key(ron-&gt;ro_rt))-&gt;
			    sin6_addr, &amp;sin6_next-&gt;sin6_addr)) {
				<span class="enscript-keyword">if</span> (ron-&gt;ro_rt != NULL)
					RT_UNLOCK(ron-&gt;ro_rt);

				ROUTE_RELEASE(ron);
				error = EHOSTUNREACH;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
		}
		route = ron;
		ifp = ifp0 = ron-&gt;ro_rt-&gt;rt_ifp;

		<span class="enscript-comment">/*
		 * When cloning is required, try to allocate a route to the
		 * destination so that the caller can store path MTU
		 * information.
		 */</span>
		<span class="enscript-keyword">if</span> (!clone) {
			<span class="enscript-keyword">if</span> (select_srcif) {
				<span class="enscript-comment">/* Keep the route locked */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">validateroute</span>;
			}
			RT_UNLOCK(ron-&gt;ro_rt);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		RT_UNLOCK(ron-&gt;ro_rt);
	}

	<span class="enscript-comment">/*
	 * Use a cached route if it exists and is valid, else try to allocate
	 * a new one.  Note that we should check the address family of the
	 * cached destination, in case of sharing the cache with IPv4.
	 */</span>
	<span class="enscript-keyword">if</span> (ro == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
		RT_LOCK_SPIN(ro-&gt;ro_rt);
	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro) || (ro-&gt;ro_rt != NULL &amp;&amp;
	    (satosin6(&amp;ro-&gt;ro_dst)-&gt;sin6_family != AF_INET6 ||
	    !IN6_ARE_ADDR_EQUAL(&amp;satosin6(&amp;ro-&gt;ro_dst)-&gt;sin6_addr, dst) ||
	    (select_srcif &amp;&amp; (ifa == NULL ||
	    (ifa-&gt;ifa_ifp != ro-&gt;ro_rt-&gt;rt_ifp &amp;&amp; !proxied_ifa)))))) {
		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
			RT_UNLOCK(ro-&gt;ro_rt);

		ROUTE_RELEASE(ro);
	}
	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt == NULL) {
		<span class="enscript-type">struct</span> sockaddr_in6 *sa6;

		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
			RT_UNLOCK(ro-&gt;ro_rt);
		<span class="enscript-comment">/* No route yet, so try to acquire one */</span>
		bzero(&amp;ro-&gt;ro_dst, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6));
		sa6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;ro-&gt;ro_dst;
		sa6-&gt;sin6_family = AF_INET6;
		sa6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
		sa6-&gt;sin6_addr = *dst;
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(dst)) {
			ro-&gt;ro_rt = rtalloc1_scoped(
			    &amp;((<span class="enscript-type">struct</span> route *)ro)-&gt;ro_dst, 0, 0, ifscope);
		} <span class="enscript-keyword">else</span> {
			rtalloc_scoped((<span class="enscript-type">struct</span> route *)ro, ifscope);
		}
		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
			RT_LOCK_SPIN(ro-&gt;ro_rt);
	}

	<span class="enscript-comment">/*
	 * Do not care about the result if we have the nexthop
	 * explicitly specified (in case we're asked to clone.)
	 */</span>
	<span class="enscript-keyword">if</span> (opts != NULL &amp;&amp; opts-&gt;ip6po_nexthop != NULL) {
		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
			RT_UNLOCK(ro-&gt;ro_rt);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL) {
		RT_LOCK_ASSERT_HELD(ro-&gt;ro_rt);
		ifp = ifp0 = ro-&gt;ro_rt-&gt;rt_ifp;
	} <span class="enscript-keyword">else</span> {
		error = EHOSTUNREACH;
	}
	route = ro;

<span class="enscript-reference">validateroute</span>:
	<span class="enscript-keyword">if</span> (select_srcif) {
		boolean_t has_route = (route != NULL &amp;&amp; route-&gt;ro_rt != NULL);
		boolean_t srcif_selected = FALSE;

		<span class="enscript-keyword">if</span> (has_route)
			RT_LOCK_ASSERT_HELD(route-&gt;ro_rt);
		<span class="enscript-comment">/*
		 * If there is a non-loopback route with the wrong interface,
		 * or if there is no interface configured with such an address,
		 * blow it away.  Except for local/loopback, we look for one
		 * with a matching interface scope/index.
		 */</span>
		<span class="enscript-keyword">if</span> (has_route &amp;&amp; (ifa == NULL ||
		    (ifa-&gt;ifa_ifp != ifp &amp;&amp; ifp != lo_ifp) ||
		    !(route-&gt;ro_rt-&gt;rt_flags &amp; RTF_UP))) {
			<span class="enscript-comment">/*
			 * If the destination address belongs to a proxied
			 * prefix, relax the requirement and allow the packet
			 * to come out of the proxy interface with the source
			 * address of the real interface.
			 */</span>
			<span class="enscript-keyword">if</span> (ifa != NULL &amp;&amp; proxied_ifa &amp;&amp;
			    (route-&gt;ro_rt-&gt;rt_flags &amp; (RTF_UP|RTF_PROXY)) ==
			    (RTF_UP|RTF_PROXY)) {
				srcif_selected = TRUE;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (ip6_select_srcif_debug) {
					<span class="enscript-keyword">if</span> (ifa != NULL) {
						printf(<span class="enscript-string">&quot;%s-&gt;%s ifscope %d &quot;</span>
						    <span class="enscript-string">&quot;ro_if %s != ifa_if %s &quot;</span>
						    <span class="enscript-string">&quot;(cached route cleared)\n&quot;</span>,
						    s_src, s_dst,
						    ifscope, if_name(ifp),
						    if_name(ifa-&gt;ifa_ifp));
					} <span class="enscript-keyword">else</span> {
						printf(<span class="enscript-string">&quot;%s-&gt;%s ifscope %d &quot;</span>
						    <span class="enscript-string">&quot;ro_if %s (no ifa_if &quot;</span>
						    <span class="enscript-string">&quot;found)\n&quot;</span>, s_src, s_dst,
						    ifscope, if_name(ifp));
					}
				}
				RT_UNLOCK(route-&gt;ro_rt);
				ROUTE_RELEASE(route);
				error = EHOSTUNREACH;
				<span class="enscript-comment">/* Undo the settings done above */</span>
				route = NULL;
				ifp = NULL;	<span class="enscript-comment">/* ditch ifp; keep ifp0 */</span>
				has_route = FALSE;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (has_route) {
			srcif_selected = TRUE;
		}

		<span class="enscript-keyword">if</span> (srcif_selected) {
			VERIFY(has_route);
			<span class="enscript-keyword">if</span> (ifa != route-&gt;ro_srcia ||
			    !(route-&gt;ro_flags &amp; ROF_SRCIF_SELECTED)) {
				RT_CONVERT_LOCK(route-&gt;ro_rt);
				<span class="enscript-keyword">if</span> (ifa != NULL)
					IFA_ADDREF(ifa); <span class="enscript-comment">/* for route_in6 */</span>
				<span class="enscript-keyword">if</span> (route-&gt;ro_srcia != NULL)
					IFA_REMREF(route-&gt;ro_srcia);
				route-&gt;ro_srcia = ifa;
				route-&gt;ro_flags |= ROF_SRCIF_SELECTED;
				RT_GENID_SYNC(route-&gt;ro_rt);
			}
			RT_UNLOCK(route-&gt;ro_rt);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
			RT_UNLOCK(ro-&gt;ro_rt);
		<span class="enscript-keyword">if</span> (ifp != NULL &amp;&amp; opts != NULL &amp;&amp;
		    opts-&gt;ip6po_pktinfo != NULL &amp;&amp;
		    opts-&gt;ip6po_pktinfo-&gt;ipi6_ifindex != 0) {
			<span class="enscript-comment">/*
			 * Check if the outgoing interface conflicts with the
			 * interface specified by ipi6_ifindex (if specified).
			 * Note that loopback interface is always okay.
			 * (this may happen when we are sending a packet to
			 * one of our own addresses.)
			 */</span>
			<span class="enscript-keyword">if</span> (!(ifp-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp; ifp-&gt;if_index !=
			    opts-&gt;ip6po_pktinfo-&gt;ipi6_ifindex) {
				error = EHOSTUNREACH;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
		}
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-comment">/*
	 * Check for interface restrictions.
	 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">CHECK_RESTRICTIONS</span>(_ip6oa, _ifp)			\
	((((_ip6oa)-&gt;ip6oa_flags &amp; IP6OAF_NO_CELLULAR) &amp;&amp; 	\
	    IFNET_IS_CELLULAR(_ifp)) || 			\
	(((_ip6oa)-&gt;ip6oa_flags &amp; IP6OAF_NO_EXPENSIVE) &amp;&amp; 	\
	    IFNET_IS_EXPENSIVE(_ifp)) ||			\
	(!((_ip6oa)-&gt;ip6oa_flags &amp; IP6OAF_AWDL_UNRESTRICTED) &amp;&amp;	\
	    IFNET_IS_AWDL_RESTRICTED(_ifp))) 

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; ip6oa != NULL &amp;&amp;
	    ((ifp &amp;&amp; CHECK_RESTRICTIONS(ip6oa, ifp)) ||
	    (route &amp;&amp; route-&gt;ro_rt &amp;&amp; 
	    CHECK_RESTRICTIONS(ip6oa, route-&gt;ro_rt-&gt;rt_ifp)))) {
		<span class="enscript-keyword">if</span> (route != NULL &amp;&amp; route-&gt;ro_rt != NULL) {
			ROUTE_RELEASE(route);
			route = NULL;
		}
		ifp = NULL;	<span class="enscript-comment">/* ditch ifp; keep ifp0 */</span>
		error = EHOSTUNREACH;
		ip6oa-&gt;ip6oa_retflags |= IP6OARF_IFDENIED;
	}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">CHECK_RESTRICTIONS</span>

	<span class="enscript-comment">/*
	 * If the interface is disabled for IPv6, then ENETDOWN error.
	 */</span>
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp;
	    ifp != NULL &amp;&amp; (ifp-&gt;if_eflags &amp; IFEF_IPV6_DISABLED)) {
		error = ENETDOWN;
	}

	<span class="enscript-keyword">if</span> (ifp == NULL &amp;&amp; (route == NULL || route-&gt;ro_rt == NULL)) {
		<span class="enscript-comment">/*
		 * This can happen if the caller did not pass a cached route
		 * nor any other hints.  We treat this case an error.
		 */</span>
		error = EHOSTUNREACH;
	}
	<span class="enscript-keyword">if</span> (error == EHOSTUNREACH || error == ENETDOWN)
		ip6stat.ip6s_noroute++;

	<span class="enscript-comment">/*
	 * We'll return ifp regardless of error, so pick it up from ifp0
	 * in case it was nullified above.  Caller is responsible for
	 * releasing the ifp if it is non-NULL.
	 */</span>
	ifp = ifp0;
	<span class="enscript-keyword">if</span> (retifp != NULL) {
		<span class="enscript-keyword">if</span> (ifp != NULL)
			ifnet_reference(ifp);	<span class="enscript-comment">/* for caller */</span>
		*retifp = ifp;
	}

	<span class="enscript-keyword">if</span> (retsrcia != NULL) {
		<span class="enscript-keyword">if</span> (ifa != NULL)
			IFA_ADDREF(ifa);	<span class="enscript-comment">/* for caller */</span>
		*retsrcia = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;
	}

	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-keyword">if</span> (retrt != NULL &amp;&amp; route != NULL)
			*retrt = route-&gt;ro_rt;	<span class="enscript-comment">/* ro_rt may be NULL */</span>
	}  
	<span class="enscript-keyword">if</span> (ip6_select_srcif_debug) {
		printf(<span class="enscript-string">&quot;%s %s-&gt;%s ifscope %d ifa_if %s ro_if %s (error=%d)\n&quot;</span>,
		    __func__,
		    s_src, s_dst, ifscope,
		    (ifa != NULL) ? if_name(ifa-&gt;ifa_ifp) : <span class="enscript-string">&quot;NONE&quot;</span>,
		    (ifp != NULL) ? if_name(ifp) : <span class="enscript-string">&quot;NONE&quot;</span>, error);
	}

	<span class="enscript-keyword">if</span> (ifa != NULL)
		IFA_REMREF(ifa);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Regardless of error, it will return an ifp with a reference held if the
 * caller provides a non-NULL retifp.  The caller is responsible for checking
 * if the returned ifp is valid and release its reference at all times.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_selectif</span>(<span class="enscript-type">struct</span> sockaddr_in6 *dstsock, <span class="enscript-type">struct</span> ip6_pktopts *opts,
    <span class="enscript-type">struct</span> ip6_moptions *mopts, <span class="enscript-type">struct</span> route_in6 *ro,
    <span class="enscript-type">struct</span> ip6_out_args *ip6oa, <span class="enscript-type">struct</span> ifnet **retifp)
{
	<span class="enscript-type">int</span> err = 0;
	<span class="enscript-type">struct</span> route_in6 sro;
	<span class="enscript-type">struct</span> rtentry *rt = NULL;

	<span class="enscript-keyword">if</span> (ro == NULL) {
		bzero(&amp;sro, <span class="enscript-keyword">sizeof</span> (sro));
		ro = &amp;sro;
	}

	<span class="enscript-keyword">if</span> ((err = selectroute(NULL, dstsock, opts, mopts, NULL, ro, retifp,
	    &amp;rt, 0, 1, ip6oa)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-comment">/*
	 * do not use a rejected or black hole route.
	 * XXX: this check should be done in the L2 output routine.
	 * However, if we skipped this check here, we'd see the following
	 * scenario:
	 * - install a rejected route for a scoped address prefix
	 *   (like fe80::/10)
	 * - send a packet to a destination that matches the scoped prefix,
	 *   with ambiguity about the scope zone.
	 * - pick the outgoing interface from the route, and disambiguate the
	 *   scope zone with the interface.
	 * - ip6_output() would try to get another route with the &quot;new&quot;
	 *   destination, which may be valid.
	 * - we'd see no error on output.
	 * Although this may not be very harmful, it should still be confusing.
	 * We thus reject the case here.
	 */</span>
	<span class="enscript-keyword">if</span> (rt &amp;&amp; (rt-&gt;rt_flags &amp; (RTF_REJECT | RTF_BLACKHOLE))) {
		err = ((rt-&gt;rt_flags &amp; RTF_HOST) ? EHOSTUNREACH : ENETUNREACH);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Adjust the &quot;outgoing&quot; interface.  If we're going to loop the packet
	 * back to ourselves, the ifp would be the loopback interface.
	 * However, we'd rather know the interface associated to the
	 * destination address (which should probably be one of our own
	 * addresses.)
	 */</span>
	<span class="enscript-keyword">if</span> (rt != NULL &amp;&amp; rt-&gt;rt_ifa != NULL &amp;&amp; rt-&gt;rt_ifa-&gt;ifa_ifp != NULL &amp;&amp;
	    retifp != NULL) {
		ifnet_reference(rt-&gt;rt_ifa-&gt;ifa_ifp);
		<span class="enscript-keyword">if</span> (*retifp != NULL)
			ifnet_release(*retifp);
		*retifp = rt-&gt;rt_ifa-&gt;ifa_ifp;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (ro == &amp;sro) {
		VERIFY(rt == NULL || rt == ro-&gt;ro_rt);
		ROUTE_RELEASE(ro);
	}

	<span class="enscript-comment">/*
	 * retifp might point to a valid ifp with a reference held;
	 * caller is responsible for releasing it if non-NULL.
	 */</span>
	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-comment">/*
 * Regardless of error, it will return an ifp with a reference held if the
 * caller provides a non-NULL retifp.  The caller is responsible for checking
 * if the returned ifp is valid and release its reference at all times.
 *
 * clone - meaningful only for bsdi and freebsd
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_selectroute</span>(<span class="enscript-type">struct</span> sockaddr_in6 *srcsock, <span class="enscript-type">struct</span> sockaddr_in6 *dstsock,
    <span class="enscript-type">struct</span> ip6_pktopts *opts, <span class="enscript-type">struct</span> ip6_moptions *mopts,
    <span class="enscript-type">struct</span> in6_ifaddr **retsrcia, <span class="enscript-type">struct</span> route_in6 *ro, <span class="enscript-type">struct</span> ifnet **retifp,
    <span class="enscript-type">struct</span> rtentry **retrt, <span class="enscript-type">int</span> clone, <span class="enscript-type">struct</span> ip6_out_args *ip6oa)
{

	<span class="enscript-keyword">return</span> (selectroute(srcsock, dstsock, opts, mopts, retsrcia, ro, retifp,
	    retrt, clone, 0, ip6oa));
}

<span class="enscript-comment">/*
 * Default hop limit selection. The precedence is as follows:
 * 1. Hoplimit value specified via ioctl.
 * 2. (If the outgoing interface is detected) the current
 *     hop limit of the interface specified by router advertisement.
 * 3. The system default hoplimit.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_selecthlim</span>(<span class="enscript-type">struct</span> in6pcb *in6p, <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-keyword">if</span> (in6p &amp;&amp; in6p-&gt;in6p_hops &gt;= 0) {
		<span class="enscript-keyword">return</span> (in6p-&gt;in6p_hops);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (NULL != ifp) {
		u_int8_t chlim;
		<span class="enscript-type">struct</span> nd_ifinfo *ndi = ND_IFINFO(ifp);
		<span class="enscript-keyword">if</span> (ndi &amp;&amp; ndi-&gt;initialized) {
			<span class="enscript-comment">/* access chlim without lock, for performance */</span>
			chlim = ndi-&gt;chlim;
		} <span class="enscript-keyword">else</span> {
			chlim = ip6_defhlim;
		}
		<span class="enscript-keyword">return</span> (chlim);
	}

	<span class="enscript-keyword">return</span> (ip6_defhlim);
}

<span class="enscript-comment">/*
 * XXX: this is borrowed from in6_pcbbind(). If possible, we should
 * share this function by all *bsd*...
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_pcbsetport</span>(<span class="enscript-type">struct</span> in6_addr *laddr, <span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> proc *p,
    <span class="enscript-type">int</span> locked)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">laddr</span>)
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
	u_int16_t lport = 0, first, last, *lastport;
	<span class="enscript-type">int</span> count, error = 0, wild = 0;
	<span class="enscript-type">struct</span> inpcbinfo *pcbinfo = inp-&gt;inp_pcbinfo;
	kauth_cred_t cred;
	<span class="enscript-keyword">if</span> (!locked) { <span class="enscript-comment">/* Make sure we don't run into a deadlock: 4052373 */</span>
		<span class="enscript-keyword">if</span> (!lck_rw_try_lock_exclusive(pcbinfo-&gt;ipi_lock)) {
			socket_unlock(inp-&gt;inp_socket, 0);
			lck_rw_lock_exclusive(pcbinfo-&gt;ipi_lock);
			socket_lock(inp-&gt;inp_socket, 0);
		}

		<span class="enscript-comment">/*
		 * Check if a local port was assigned to the inp while
		 * this thread was waiting for the pcbinfo lock
		 */</span>
		<span class="enscript-keyword">if</span> (inp-&gt;inp_lport != 0) {
			VERIFY(inp-&gt;inp_flags2 &amp; INP2_INHASHLIST);
			lck_rw_done(pcbinfo-&gt;ipi_lock);

			<span class="enscript-comment">/*
			 * It is not an error if another thread allocated
			 * a port
			 */</span>
			<span class="enscript-keyword">return</span> (0);
		}
	}

	<span class="enscript-comment">/* XXX: this is redundant when called from in6_pcbbind */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_options &amp; (SO_REUSEADDR|SO_REUSEPORT)) == 0)
		wild = INPLOOKUP_WILDCARD;

	<span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_HIGHPORT) {
		first = ipport_hifirstauto;	<span class="enscript-comment">/* sysctl */</span>
		last  = ipport_hilastauto;
		lastport = &amp;pcbinfo-&gt;ipi_lasthi;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (inp-&gt;inp_flags &amp; INP_LOWPORT) {
		cred = kauth_cred_proc_ref(p);
		error = priv_check_cred(cred, PRIV_NETINET_RESERVEDPORT, 0);
		kauth_cred_unref(&amp;cred);
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-keyword">if</span> (!locked)
				lck_rw_done(pcbinfo-&gt;ipi_lock);
			<span class="enscript-keyword">return</span> (error);
		}
		first = ipport_lowfirstauto;	<span class="enscript-comment">/* 1023 */</span>
		last  = ipport_lowlastauto;	<span class="enscript-comment">/* 600 */</span>
		lastport = &amp;pcbinfo-&gt;ipi_lastlow;
	} <span class="enscript-keyword">else</span> {
		first = ipport_firstauto;	<span class="enscript-comment">/* sysctl */</span>
		last  = ipport_lastauto;
		lastport = &amp;pcbinfo-&gt;ipi_lastport;
	}
	<span class="enscript-comment">/*
	 * Simple check to ensure all ports are not used up causing
	 * a deadlock here.
	 *
	 * We split the two cases (up and down) so that the direction
	 * is not being tested on each round of the loop.
	 */</span>
	<span class="enscript-keyword">if</span> (first &gt; last) {
		<span class="enscript-comment">/*
		 * counting down
		 */</span>
		count = first - last;

		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> (count-- &lt; 0) {	<span class="enscript-comment">/* completely used? */</span>
				<span class="enscript-comment">/*
				 * Undo any address bind that may have
				 * occurred above.
				 */</span>
				inp-&gt;in6p_laddr = in6addr_any;
				inp-&gt;in6p_last_outifp = NULL;
				<span class="enscript-keyword">if</span> (!locked)
					lck_rw_done(pcbinfo-&gt;ipi_lock);
				<span class="enscript-keyword">return</span> (EAGAIN);
			}
			--*lastport;
			<span class="enscript-keyword">if</span> (*lastport &gt; first || *lastport &lt; last)
				*lastport = first;
			lport = htons(*lastport);
		} <span class="enscript-keyword">while</span> (in6_pcblookup_local(pcbinfo, &amp;inp-&gt;in6p_laddr, lport,
		    wild));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* counting up */</span>
		count = last - first;

		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> (count-- &lt; 0) {	<span class="enscript-comment">/* completely used? */</span>
				<span class="enscript-comment">/*
				 * Undo any address bind that may have
				 * occurred above.
				 */</span>
				inp-&gt;in6p_laddr = in6addr_any;
				inp-&gt;in6p_last_outifp = NULL;
				<span class="enscript-keyword">if</span> (!locked)
					lck_rw_done(pcbinfo-&gt;ipi_lock);
				<span class="enscript-keyword">return</span> (EAGAIN);
			}
			++*lastport;
			<span class="enscript-keyword">if</span> (*lastport &lt; first || *lastport &gt; last)
				*lastport = first;
			lport = htons(*lastport);
		} <span class="enscript-keyword">while</span> (in6_pcblookup_local(pcbinfo, &amp;inp-&gt;in6p_laddr, lport,
		    wild));
	}

	inp-&gt;inp_lport = lport;
	inp-&gt;inp_flags |= INP_ANONPORT;

	<span class="enscript-keyword">if</span> (in_pcbinshash(inp, 1) != 0) {
		inp-&gt;in6p_laddr = in6addr_any;
		inp-&gt;in6p_last_outifp = NULL;

		inp-&gt;inp_lport = 0;
		inp-&gt;inp_flags &amp;= ~INP_ANONPORT;
		<span class="enscript-keyword">if</span> (!locked)
			lck_rw_done(pcbinfo-&gt;ipi_lock);
		<span class="enscript-keyword">return</span> (EAGAIN);
	}

	<span class="enscript-keyword">if</span> (!locked)
		lck_rw_done(pcbinfo-&gt;ipi_lock);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * The followings are implementation of the policy table using a
 * simple tail queue.
 * XXX such details should be hidden.
 * XXX implementation using binary tree should be more efficient.
 */</span>
<span class="enscript-type">struct</span> addrsel_policyent {
	TAILQ_ENTRY(addrsel_policyent) ape_entry;
	<span class="enscript-type">struct</span> in6_addrpolicy ape_policy;
};

<span class="enscript-function-name">TAILQ_HEAD</span>(addrsel_policyhead, addrsel_policyent);

<span class="enscript-type">struct</span> addrsel_policyhead addrsel_policytab;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">init_policy_queue</span>(<span class="enscript-type">void</span>)
{
	TAILQ_INIT(&amp;addrsel_policytab);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">addrsel_policy_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 * Default address selection policy based on RFC 6724.
	 */</span>
	<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addrpolicy defaddrsel[] = {
		<span class="enscript-comment">/* Loopback -- prefix=::1/128, precedence=50, label=0 */</span>
		{
			.addr = {
				.sin6_family = AF_INET6,
				.sin6_addr   = IN6ADDR_LOOPBACK_INIT,
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.addrmask = {
				.sin6_family = AF_INET6,
				.sin6_addr   = IN6MASK128,
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.preced   = 50,
			.label    = 0
		},

		<span class="enscript-comment">/* Unspecified -- prefix=::/0, precedence=40, label=1 */</span>
		{
			.addr = {
				.sin6_family = AF_INET6,
				.sin6_addr   = IN6ADDR_ANY_INIT,
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.addrmask = {
				.sin6_family = AF_INET6,
				.sin6_addr   = IN6MASK0,
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.preced   = 40,
			.label    = 1
		},

		<span class="enscript-comment">/* IPv4 Mapped -- prefix=::ffff:0:0/96, precedence=35, label=4 */</span>
		{
			.addr = {
				.sin6_family = AF_INET6,
				.sin6_addr   = IN6ADDR_V4MAPPED_INIT,
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.addrmask = {
				.sin6_family = AF_INET6,
				.sin6_addr   = IN6MASK96,
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.preced   = 35,
			.label    = 4
		},

		<span class="enscript-comment">/* 6to4 -- prefix=2002::/16, precedence=30, label=2 */</span>
		{
			.addr = {
				.sin6_family = AF_INET6,
				.sin6_addr   = {{{ 0x20, 0x02 }}},
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.addrmask = {
				.sin6_family = AF_INET6,
				.sin6_addr   = IN6MASK16,
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.preced   = 30,
			.label    = 2
		},

		<span class="enscript-comment">/* Teredo -- prefix=2001::/32, precedence=5, label=5 */</span>
		{
			.addr = {
				.sin6_family = AF_INET6,
				.sin6_addr   = {{{ 0x20, 0x01 }}},
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.addrmask = {
				.sin6_family = AF_INET6,
				.sin6_addr   = IN6MASK32,
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.preced   = 5,
			.label    = 5
		},

		<span class="enscript-comment">/* Unique Local (ULA) -- prefix=fc00::/7, precedence=3, label=13 */</span>
		{
			.addr = {
				.sin6_family = AF_INET6,
				.sin6_addr   = {{{ 0xfc }}},
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.addrmask = {
				.sin6_family = AF_INET6,
				.sin6_addr   = IN6MASK7,
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.preced   = 3,
			.label    = 13
		},

		<span class="enscript-comment">/* IPv4 Compatible -- prefix=::/96, precedence=1, label=3 */</span>
		{
			.addr = {
				.sin6_family = AF_INET6,
				.sin6_addr = IN6ADDR_ANY_INIT,
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.addrmask = {
				.sin6_family = AF_INET6,
				.sin6_addr = IN6MASK96,
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.preced   = 1,
			.label    = 3
		},

		<span class="enscript-comment">/* Site-local (deprecated) -- prefix=fec0::/10, precedence=1, label=11 */</span>
		{
			.addr = {
				.sin6_family = AF_INET6,
				.sin6_addr = {{{ 0xfe, 0xc0 }}},
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.addrmask = {
				.sin6_family = AF_INET6,
				.sin6_addr = IN6MASK16,
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.preced   = 1,
			.label    = 11
		},

		<span class="enscript-comment">/* 6bone (deprecated) -- prefix=3ffe::/16, precedence=1, label=12 */</span>
		{
			.addr = {
				.sin6_family = AF_INET6,
				.sin6_addr = {{{ 0x3f, 0xfe }}},
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.addrmask = {
				.sin6_family = AF_INET6,
				.sin6_addr = IN6MASK16,
				.sin6_len    = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)
			},
			.preced   = 1,
			.label    = 12
		},
	};
	<span class="enscript-type">int</span> i;

	init_policy_queue();

	<span class="enscript-comment">/* initialize the &quot;last resort&quot; policy */</span>
	bzero(&amp;defaultaddrpolicy, <span class="enscript-keyword">sizeof</span> (defaultaddrpolicy));
	defaultaddrpolicy.label = ADDR_LABEL_NOTAPP;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; <span class="enscript-keyword">sizeof</span> (defaddrsel) / <span class="enscript-keyword">sizeof</span> (defaddrsel[0]); i++)
		add_addrsel_policyent(&amp;defaddrsel[i]);

}

<span class="enscript-type">struct</span> in6_addrpolicy *
<span class="enscript-function-name">in6_addrsel_lookup_policy</span>(<span class="enscript-type">struct</span> sockaddr_in6 *key)
{
	<span class="enscript-type">struct</span> in6_addrpolicy *match = NULL;

	ADDRSEL_LOCK();
	match = match_addrsel_policy(key);

	<span class="enscript-keyword">if</span> (match == NULL)
		match = &amp;defaultaddrpolicy;
	<span class="enscript-keyword">else</span>
		match-&gt;use++;
	ADDRSEL_UNLOCK();

	<span class="enscript-keyword">return</span> (match);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> in6_addrpolicy *
<span class="enscript-function-name">match_addrsel_policy</span>(<span class="enscript-type">struct</span> sockaddr_in6 *key)
{
	<span class="enscript-type">struct</span> addrsel_policyent *pent;
	<span class="enscript-type">struct</span> in6_addrpolicy *bestpol = NULL, *pol;
	<span class="enscript-type">int</span> matchlen, bestmatchlen = -1;
	u_char *mp, *ep, *k, *p, m;

	TAILQ_FOREACH(pent, &amp;addrsel_policytab, ape_entry) {
		matchlen = 0;

		pol = &amp;pent-&gt;ape_policy;
		mp = (u_char *)&amp;pol-&gt;addrmask.sin6_addr;
		ep = mp + 16;	<span class="enscript-comment">/* XXX: scope field? */</span>
		k = (u_char *)&amp;key-&gt;sin6_addr;
		p = (u_char *)&amp;pol-&gt;addr.sin6_addr;
		<span class="enscript-keyword">for</span> (; mp &lt; ep &amp;&amp; *mp; mp++, k++, p++) {
			m = *mp;
			<span class="enscript-keyword">if</span> ((*k &amp; m) != *p)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>; <span class="enscript-comment">/* not match */</span>
			<span class="enscript-keyword">if</span> (m == 0xff) <span class="enscript-comment">/* short cut for a typical case */</span>
				matchlen += 8;
			<span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">while</span> (m &gt;= 0x80) {
					matchlen++;
					m &lt;&lt;= 1;
				}
			}
		}

		<span class="enscript-comment">/* matched.  check if this is better than the current best. */</span>
		<span class="enscript-keyword">if</span> (bestpol == NULL ||
		    matchlen &gt; bestmatchlen) {
			bestpol = pol;
			bestmatchlen = matchlen;
		}

	<span class="enscript-reference">next</span>:
		<span class="enscript-keyword">continue</span>;
	}

	<span class="enscript-keyword">return</span> (bestpol);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">add_addrsel_policyent</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addrpolicy *newpolicy)
{
	<span class="enscript-type">struct</span> addrsel_policyent *new, *pol;

	MALLOC(new, <span class="enscript-type">struct</span> addrsel_policyent *, <span class="enscript-keyword">sizeof</span> (*new), M_IFADDR,
	    M_WAITOK);

	ADDRSEL_LOCK();

	<span class="enscript-comment">/* duplication check */</span>
	TAILQ_FOREACH(pol, &amp;addrsel_policytab, ape_entry) {
		<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(&amp;newpolicy-&gt;addr.sin6_addr,
		    &amp;pol-&gt;ape_policy.addr.sin6_addr) &amp;&amp;
		    IN6_ARE_ADDR_EQUAL(&amp;newpolicy-&gt;addrmask.sin6_addr,
		    &amp;pol-&gt;ape_policy.addrmask.sin6_addr)) {
			ADDRSEL_UNLOCK();
			FREE(new, M_IFADDR);
			<span class="enscript-keyword">return</span> (EEXIST);	<span class="enscript-comment">/* or override it? */</span>
		}
	}

	bzero(new, <span class="enscript-keyword">sizeof</span> (*new));

	<span class="enscript-comment">/* XXX: should validate entry */</span>
	new-&gt;ape_policy = *newpolicy;

	TAILQ_INSERT_TAIL(&amp;addrsel_policytab, new, ape_entry);
	ADDRSEL_UNLOCK();

	<span class="enscript-keyword">return</span> (0);
}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">ENABLE_ADDRSEL</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">delete_addrsel_policyent</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addrpolicy *key)
{
	<span class="enscript-type">struct</span> addrsel_policyent *pol;


	ADDRSEL_LOCK();

	<span class="enscript-comment">/* search for the entry in the table */</span>
	TAILQ_FOREACH(pol, &amp;addrsel_policytab, ape_entry) {
		<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(&amp;key-&gt;addr.sin6_addr,
		    &amp;pol-&gt;ape_policy.addr.sin6_addr) &amp;&amp;
		    IN6_ARE_ADDR_EQUAL(&amp;key-&gt;addrmask.sin6_addr,
		    &amp;pol-&gt;ape_policy.addrmask.sin6_addr)) {
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">if</span> (pol == NULL) {
		ADDRSEL_UNLOCK();
		<span class="enscript-keyword">return</span> (ESRCH);
	}

	TAILQ_REMOVE(&amp;addrsel_policytab, pol, ape_entry);
	FREE(pol, M_IFADDR);
	pol = NULL;
	ADDRSEL_UNLOCK();

	<span class="enscript-keyword">return</span> (0);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ENABLE_ADDRSEL */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">walk_addrsel_policy</span>(<span class="enscript-type">int</span> (*callback)(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addrpolicy *, <span class="enscript-type">void</span> *),
    <span class="enscript-type">void</span> *w)
{
	<span class="enscript-type">struct</span> addrsel_policyent *pol;
	<span class="enscript-type">int</span> error = 0;

	ADDRSEL_LOCK();
	TAILQ_FOREACH(pol, &amp;addrsel_policytab, ape_entry) {
		<span class="enscript-keyword">if</span> ((error = (*callback)(&amp;pol-&gt;ape_policy, w)) != 0) {
			ADDRSEL_UNLOCK();
			<span class="enscript-keyword">return</span> (error);
		}
	}
	ADDRSEL_UNLOCK();
	<span class="enscript-keyword">return</span> (error);
}
<span class="enscript-comment">/*
 * Subroutines to manage the address selection policy table via sysctl.
 */</span>
<span class="enscript-type">struct</span> walkarg {
	<span class="enscript-type">struct</span> sysctl_req *w_req;
};


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">dump_addrsel_policyent</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addrpolicy *pol, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> walkarg *w = arg;

	error = SYSCTL_OUT(w-&gt;w_req, pol, <span class="enscript-keyword">sizeof</span> (*pol));

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
in6_src_sysctl SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
<span class="enscript-type">struct</span> walkarg w;

	<span class="enscript-keyword">if</span> (req-&gt;newptr)
		<span class="enscript-keyword">return</span> (EPERM);
	bzero(&amp;w, <span class="enscript-keyword">sizeof</span> (w));
	w.w_req = req;

	<span class="enscript-keyword">return</span> (walk_addrsel_policy(dump_addrsel_policyent, &amp;w));
}


<span class="enscript-function-name">SYSCTL_NODE</span>(_net_inet6_ip6, IPV6CTL_ADDRCTLPOLICY, addrctlpolicy,
	CTLFLAG_RD | CTLFLAG_LOCKED, in6_src_sysctl, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_src_ioctl</span>(u_long cmd, caddr_t data)
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">struct</span> in6_addrpolicy ent0;

	<span class="enscript-keyword">if</span> (cmd != SIOCAADDRCTL_POLICY &amp;&amp; cmd != SIOCDADDRCTL_POLICY)
		<span class="enscript-keyword">return</span> (EOPNOTSUPP); <span class="enscript-comment">/* check for safety */</span>

	bcopy(data, &amp;ent0, <span class="enscript-keyword">sizeof</span> (ent0));

	<span class="enscript-keyword">if</span> (ent0.label == ADDR_LABEL_NOTAPP)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-comment">/* check if the prefix mask is consecutive. */</span>
	<span class="enscript-keyword">if</span> (in6_mask2len(&amp;ent0.addrmask.sin6_addr, NULL) &lt; 0)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-comment">/* clear trailing garbages (if any) of the prefix address. */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; 4; i++) {
		ent0.addr.sin6_addr.s6_addr32[i] &amp;=
			ent0.addrmask.sin6_addr.s6_addr32[i];
	}
	ent0.use = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAADDRCTL_POLICY</span>:
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">ENABLE_ADDRSEL</span>
		<span class="enscript-keyword">return</span> (add_addrsel_policyent(&amp;ent0));
#<span class="enscript-reference">else</span>
		<span class="enscript-keyword">return</span> (ENOTSUP);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDADDRCTL_POLICY</span>:
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">ENABLE_ADDRSEL</span>
		<span class="enscript-keyword">return</span> (delete_addrsel_policyent(&amp;ent0));
#<span class="enscript-reference">else</span>
		<span class="enscript-keyword">return</span> (ENOTSUP);
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-keyword">return</span> (0);		<span class="enscript-comment">/* XXX: compromise compilers */</span>
}

<span class="enscript-comment">/*
 * generate kernel-internal form (scopeid embedded into s6_addr16[1]).
 * If the address scope of is link-local, embed the interface index in the
 * address.  The routine determines our precedence
 * between advanced API scope/interface specification and basic API
 * specification.
 *
 * this function should be nuked in the future, when we get rid of
 * embedded scopeid thing.
 *
 * XXX actually, it is over-specification to return ifp against sin6_scope_id.
 * there can be multiple interfaces that belong to a particular scope zone
 * (in specification, we have 1:N mapping between a scope zone and interfaces).
 * we may want to change the function to return something other than ifp.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_embedscope</span>(<span class="enscript-type">struct</span> in6_addr *in6, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in6 *sin6,
    <span class="enscript-type">struct</span> in6pcb *in6p, <span class="enscript-type">struct</span> ifnet **ifpp, <span class="enscript-type">struct</span> ip6_pktopts *opt)
{
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;
	u_int32_t scopeid;
	<span class="enscript-type">struct</span> ip6_pktopts *optp = NULL;

	*in6 = sin6-&gt;sin6_addr;
	scopeid = sin6-&gt;sin6_scope_id;
	<span class="enscript-keyword">if</span> (ifpp != NULL)
		*ifpp = NULL;

	<span class="enscript-comment">/*
	 * don't try to read sin6-&gt;sin6_addr beyond here, since the caller may
	 * ask us to overwrite existing sockaddr_in6
	 */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">ENABLE_DEFAULT_SCOPE</span>
	<span class="enscript-keyword">if</span> (scopeid == 0)
		scopeid = scope6_addr2default(in6);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(in6) || IN6_IS_ADDR_MC_INTFACELOCAL(in6)) {
		<span class="enscript-type">struct</span> in6_pktinfo *pi;
		<span class="enscript-type">struct</span> ifnet *im6o_multicast_ifp = NULL;

		<span class="enscript-keyword">if</span> (in6p != NULL &amp;&amp; IN6_IS_ADDR_MULTICAST(in6) &amp;&amp;
		    in6p-&gt;in6p_moptions != NULL) {
			IM6O_LOCK(in6p-&gt;in6p_moptions);
			im6o_multicast_ifp =
			    in6p-&gt;in6p_moptions-&gt;im6o_multicast_ifp;
			IM6O_UNLOCK(in6p-&gt;in6p_moptions);
		}

		<span class="enscript-keyword">if</span> (opt != NULL)
			optp = opt;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (in6p != NULL)
			optp = in6p-&gt;in6p_outputopts;
		<span class="enscript-comment">/*
		 * KAME assumption: link id == interface id
		 */</span>
		<span class="enscript-keyword">if</span> (in6p != NULL &amp;&amp; optp != NULL &amp;&amp;
		    (pi = optp-&gt;ip6po_pktinfo) != NULL &amp;&amp;
		    pi-&gt;ipi6_ifindex != 0) {
			<span class="enscript-comment">/* ifp is needed here if only we're returning it */</span>
			<span class="enscript-keyword">if</span> (ifpp != NULL) {
				ifnet_head_lock_shared();
				ifp = ifindex2ifnet[pi-&gt;ipi6_ifindex];
				ifnet_head_done();
			}
			in6-&gt;s6_addr16[1] = htons(pi-&gt;ipi6_ifindex);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (in6p != NULL &amp;&amp; IN6_IS_ADDR_MULTICAST(in6) &amp;&amp;
		    in6p-&gt;in6p_moptions != NULL &amp;&amp; im6o_multicast_ifp != NULL) {
			ifp = im6o_multicast_ifp;
			in6-&gt;s6_addr16[1] = htons(ifp-&gt;if_index);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (scopeid != 0) {
			<span class="enscript-comment">/*
			 * Since scopeid is unsigned, we only have to check it
			 * against if_index (ifnet_head_lock not needed since
			 * if_index is an ever-increasing integer.)
			 */</span>
			<span class="enscript-keyword">if</span> (if_index &lt; scopeid)
				<span class="enscript-keyword">return</span> (ENXIO);  <span class="enscript-comment">/* XXX EINVAL? */</span>

			<span class="enscript-comment">/* ifp is needed here only if we're returning it */</span>
			<span class="enscript-keyword">if</span> (ifpp != NULL) {
				ifnet_head_lock_shared();
				ifp = ifindex2ifnet[scopeid];
				ifnet_head_done();
			}
			<span class="enscript-comment">/* XXX assignment to 16bit from 32bit variable */</span>
			in6-&gt;s6_addr16[1] = htons(scopeid &amp; 0xffff);
		}

		<span class="enscript-keyword">if</span> (ifpp != NULL) {
			<span class="enscript-keyword">if</span> (ifp != NULL)
				ifnet_reference(ifp);	<span class="enscript-comment">/* for caller */</span>
			*ifpp = ifp;
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * generate standard sockaddr_in6 from embedded form.
 * touches sin6_addr and sin6_scope_id only.
 *
 * this function should be nuked in the future, when we get rid of
 * embedded scopeid thing.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_recoverscope</span>(
	<span class="enscript-type">struct</span> sockaddr_in6 *sin6,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr *in6,
	<span class="enscript-type">struct</span> ifnet *ifp)
{
	u_int32_t scopeid;

	sin6-&gt;sin6_addr = *in6;

	<span class="enscript-comment">/*
	 * don't try to read *in6 beyond here, since the caller may
	 * ask us to overwrite existing sockaddr_in6
	 */</span>

	sin6-&gt;sin6_scope_id = 0;
	<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(in6) || IN6_IS_ADDR_MC_INTFACELOCAL(in6)) {
		<span class="enscript-comment">/*
		 * KAME assumption: link id == interface id
		 */</span>
		scopeid = ntohs(sin6-&gt;sin6_addr.s6_addr16[1]);
		<span class="enscript-keyword">if</span> (scopeid) {
			<span class="enscript-comment">/*
			 * sanity check
			 *
			 * Since scopeid is unsigned, we only have to check it
			 * against if_index
			 */</span>
			<span class="enscript-keyword">if</span> (if_index &lt; scopeid)
				<span class="enscript-keyword">return</span> (ENXIO);
			<span class="enscript-keyword">if</span> (ifp &amp;&amp; ifp-&gt;if_index != scopeid)
				<span class="enscript-keyword">return</span> (ENXIO);
			sin6-&gt;sin6_addr.s6_addr16[1] = 0;
			sin6-&gt;sin6_scope_id = scopeid;
		}
	}

	<span class="enscript-keyword">return</span> (0);
}
</pre>
<hr />
</body></html>