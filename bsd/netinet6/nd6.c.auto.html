<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nd6.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nd6.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

<span class="enscript-comment">/*
 * XXX
 * KAME 970409 note:
 * BSD/OS version heavily modifies this code, related to llinfo.
 * Since we don't have BSD/OS version of net/route.c in our hand,
 * I left the code mostly as it was in 970310.  -- itojun
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/random/randomdev.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_llreach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_arp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/if_ether.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/scope6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;loop.h&quot;</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ND6_SLOWTIMER_INTERVAL</span>		(60 * 60)	<span class="enscript-comment">/* 1 hour */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ND6_RECALC_REACHTM_INTERVAL</span>	(60 * 120)	<span class="enscript-comment">/* 2 hours */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">equal</span>(a1, a2) (bcmp((caddr_t)(a1), (caddr_t)(a2), (a1)-&gt;sa_len) == 0)

<span class="enscript-comment">/* timer values */</span>
<span class="enscript-type">int</span>	nd6_prune	= 1;	<span class="enscript-comment">/* walk list every 1 seconds */</span>
<span class="enscript-type">int</span>	nd6_prune_lazy	= 5;	<span class="enscript-comment">/* lazily walk list every 5 seconds */</span>
<span class="enscript-type">int</span>	nd6_delay	= 5;	<span class="enscript-comment">/* delay first probe time 5 second */</span>
<span class="enscript-type">int</span>	nd6_umaxtries	= 3;	<span class="enscript-comment">/* maximum unicast query */</span>
<span class="enscript-type">int</span>	nd6_mmaxtries	= 3;	<span class="enscript-comment">/* maximum multicast query */</span>
<span class="enscript-type">int</span>	nd6_useloopback = 1;	<span class="enscript-comment">/* use loopback interface for local traffic */</span>
<span class="enscript-type">int</span>	nd6_gctimer	= (60 * 60 * 24); <span class="enscript-comment">/* 1 day: garbage collection timer */</span>

<span class="enscript-comment">/* preventing too many loops in ND option parsing */</span>
<span class="enscript-type">int</span> nd6_maxndopt = 10;	<span class="enscript-comment">/* max # of ND options allowed */</span>

<span class="enscript-type">int</span> nd6_maxqueuelen = 1; <span class="enscript-comment">/* max # of packets cached in unresolved ND entries */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ND6_DEBUG</span>
<span class="enscript-type">int</span> nd6_debug = 1;
#<span class="enscript-reference">else</span>
<span class="enscript-type">int</span> nd6_debug = 0;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">int</span> nd6_optimistic_dad =
	(ND6_OPTIMISTIC_DAD_LINKLOCAL|ND6_OPTIMISTIC_DAD_AUTOCONF|
	ND6_OPTIMISTIC_DAD_TEMPORARY|ND6_OPTIMISTIC_DAD_DYNAMIC|
	ND6_OPTIMISTIC_DAD_SECURED|ND6_OPTIMISTIC_DAD_MANUAL);

<span class="enscript-comment">/* for debugging? */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> nd6_inuse, nd6_allocated;

<span class="enscript-comment">/*
 * Synchronization notes:
 *
 * The global list of ND entries are stored in llinfo_nd6; an entry
 * gets inserted into the list when the route is created and gets
 * removed from the list when it is deleted; this is done as part
 * of RTM_ADD/RTM_RESOLVE/RTM_DELETE in nd6_rtrequest().
 *
 * Because rnh_lock and rt_lock for the entry are held during those
 * operations, the same locks (and thus lock ordering) must be used
 * elsewhere to access the relevant data structure fields:
 *
 * ln_next, ln_prev, ln_rt
 *
 *	- Routing lock (rnh_lock)
 *
 * ln_hold, ln_asked, ln_expire, ln_state, ln_router, ln_flags,
 * ln_llreach, ln_lastused
 *
 *	- Routing entry lock (rt_lock)
 *
 * Due to the dependency on rt_lock, llinfo_nd6 has the same lifetime
 * as the route entry itself.  When a route is deleted (RTM_DELETE),
 * it is simply removed from the global list but the memory is not
 * freed until the route itself is freed.
 */</span>
<span class="enscript-type">struct</span> llinfo_nd6 llinfo_nd6 = {
	.ln_next = &amp;llinfo_nd6,
	.ln_prev = &amp;llinfo_nd6,
};

<span class="enscript-type">static</span> lck_grp_attr_t	*nd_if_lock_grp_attr = NULL;
<span class="enscript-type">static</span> lck_grp_t	*nd_if_lock_grp = NULL;
<span class="enscript-type">static</span> lck_attr_t	*nd_if_lock_attr = NULL;

<span class="enscript-comment">/* Protected by nd6_mutex */</span>
<span class="enscript-type">struct</span> nd_drhead nd_defrouter;
<span class="enscript-type">struct</span> nd_prhead nd_prefix = { 0 };

<span class="enscript-comment">/*
 * nd6_timeout() is scheduled on a demand basis.  nd6_timeout_run is used
 * to indicate whether or not a timeout has been scheduled.  The rnh_lock
 * mutex is used to protect this scheduling; it is a natural choice given
 * the work done in the timer callback.  Unfortunately, there are cases
 * when nd6_timeout() needs to be scheduled while rnh_lock cannot be easily
 * held, due to lock ordering.  In those cases, we utilize a &quot;demand&quot; counter
 * nd6_sched_timeout_want which can be atomically incremented without
 * having to hold rnh_lock.  On places where we acquire rnh_lock, such as
 * nd6_rtrequest(), we check this counter and schedule the timer if it is
 * non-zero.  The increment happens on various places when we allocate
 * new ND entries, default routers, prefixes and addresses.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> nd6_timeout_run;		<span class="enscript-comment">/* nd6_timeout is scheduled to run */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_timeout</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">int</span> nd6_sched_timeout_want;		<span class="enscript-comment">/* demand count for timer to be sched */</span>
<span class="enscript-type">static</span> boolean_t nd6_fast_timer_on = FALSE;

<span class="enscript-comment">/* Serialization variables for nd6_service(), protected by rnh_lock */</span>
<span class="enscript-type">static</span> boolean_t nd6_service_busy;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *nd6_service_wc = &amp;nd6_service_busy;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> nd6_service_waiters = 0;

<span class="enscript-type">int</span> nd6_recalc_reachtm_interval = ND6_RECALC_REACHTM_INTERVAL;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> sockaddr_in6 all1_sa;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">regen_tmpaddr</span>(<span class="enscript-type">struct</span> in6_ifaddr *);
<span class="enscript-type">extern</span> lck_mtx_t *nd6_mutex;

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> llinfo_nd6 *<span class="enscript-function-name">nd6_llinfo_alloc</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_llinfo_free</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_llinfo_purge</span>(<span class="enscript-type">struct</span> rtentry *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_llinfo_get_ri</span>(<span class="enscript-type">struct</span> rtentry *, <span class="enscript-type">struct</span> rt_reach_info *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_llinfo_get_iflri</span>(<span class="enscript-type">struct</span> rtentry *, <span class="enscript-type">struct</span> ifnet_llreach_info *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_llinfo_refresh</span>(<span class="enscript-type">struct</span> rtentry *);
<span class="enscript-type">static</span> uint64_t <span class="enscript-function-name">ln_getexpire</span>(<span class="enscript-type">struct</span> llinfo_nd6 *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_service</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_slowtimo</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">nd6_is_new_addr_neighbor</span>(<span class="enscript-type">struct</span> sockaddr_in6 *, <span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">nd6_siocgdrlst</span>(<span class="enscript-type">void</span> *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">nd6_siocgprlst</span>(<span class="enscript-type">void</span> *, <span class="enscript-type">int</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> nd6_sysctl_drlist SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> nd6_sysctl_prlist SYSCTL_HANDLER_ARGS;

<span class="enscript-comment">/*
 * Insertion and removal from llinfo_nd6 must be done with rnh_lock held.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LN_DEQUEUE</span>(_ln) do {						\
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);			\
	RT_LOCK_ASSERT_HELD((_ln)-&gt;ln_rt);				\
	(_ln)-&gt;ln_next-&gt;ln_prev = (_ln)-&gt;ln_prev;			\
	(_ln)-&gt;ln_prev-&gt;ln_next = (_ln)-&gt;ln_next;			\
	(_ln)-&gt;ln_prev = (_ln)-&gt;ln_next = NULL;				\
	(_ln)-&gt;ln_flags &amp;= ~ND6_LNF_IN_USE;				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LN_INSERTHEAD</span>(_ln) do {						\
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);			\
	RT_LOCK_ASSERT_HELD((_ln)-&gt;ln_rt);				\
	(_ln)-&gt;ln_next = llinfo_nd6.ln_next;				\
	llinfo_nd6.ln_next = (_ln);					\
	(_ln)-&gt;ln_prev = &amp;llinfo_nd6;					\
	(_ln)-&gt;ln_next-&gt;ln_prev = (_ln);				\
	(_ln)-&gt;ln_flags |= ND6_LNF_IN_USE;				\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *llinfo_nd6_zone;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LLINFO_ND6_ZONE_MAX</span>	256		<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LLINFO_ND6_ZONE_NAME</span>	<span class="enscript-string">&quot;llinfo_nd6&quot;</span>	<span class="enscript-comment">/* name for zone */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">tvtohz</span>(<span class="enscript-type">struct</span> timeval *);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> nd6_init_done;

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_inet6_icmp6);

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet6_icmp6, ICMPV6CTL_ND6_DRLIST, nd6_drlist,
	CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0,
	nd6_sysctl_drlist, <span class="enscript-string">&quot;S,in6_defrouter&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet6_icmp6, ICMPV6CTL_ND6_PRLIST, nd6_prlist,
	CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0,
	nd6_sysctl_prlist, <span class="enscript-string">&quot;S,in6_defrouter&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_inet6_ip6);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip6_maxchainsent = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ip6, OID_AUTO, maxchainsent,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip6_maxchainsent, 0,
	<span class="enscript-string">&quot;use dlil_output_list&quot;</span>);

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i;

	VERIFY(!nd6_init_done);

	all1_sa.sin6_family = AF_INET6;
	all1_sa.sin6_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; <span class="enscript-keyword">sizeof</span> (all1_sa.sin6_addr); i++)
		all1_sa.sin6_addr.s6_addr[i] = 0xff;

	<span class="enscript-comment">/* initialization of the default router list */</span>
	TAILQ_INIT(&amp;nd_defrouter);

	nd_if_lock_grp_attr = lck_grp_attr_alloc_init();
	nd_if_lock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;nd_if_lock&quot;</span>, nd_if_lock_grp_attr);
	nd_if_lock_attr = lck_attr_alloc_init();

	llinfo_nd6_zone = zinit(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> llinfo_nd6),
	    LLINFO_ND6_ZONE_MAX * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> llinfo_nd6), 0,
	    LLINFO_ND6_ZONE_NAME);
	<span class="enscript-keyword">if</span> (llinfo_nd6_zone == NULL)
		panic(<span class="enscript-string">&quot;%s: failed allocating llinfo_nd6_zone&quot;</span>, __func__);

	zone_change(llinfo_nd6_zone, Z_EXPAND, TRUE);
	zone_change(llinfo_nd6_zone, Z_CALLERACCT, FALSE);

	nd6_nbr_init();
	nd6_rtr_init();
	nd6_prproxy_init();

	nd6_init_done = 1;

	<span class="enscript-comment">/* start timer */</span>
	timeout(nd6_slowtimo, NULL, ND6_SLOWTIMER_INTERVAL * hz);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> llinfo_nd6 *
<span class="enscript-function-name">nd6_llinfo_alloc</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> llinfo_nd6 *ln;

	ln = (how == M_WAITOK) ? zalloc(llinfo_nd6_zone) :
	    zalloc_noblock(llinfo_nd6_zone);
	<span class="enscript-keyword">if</span> (ln != NULL)
		bzero(ln, <span class="enscript-keyword">sizeof</span> (*ln));

	<span class="enscript-keyword">return</span> (ln);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_llinfo_free</span>(<span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> llinfo_nd6 *ln = arg;

	<span class="enscript-keyword">if</span> (ln-&gt;ln_next != NULL || ln-&gt;ln_prev != NULL) {
		panic(<span class="enscript-string">&quot;%s: trying to free %p when it is in use&quot;</span>, __func__, ln);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/* Just in case there's anything there, free it */</span>
	<span class="enscript-keyword">if</span> (ln-&gt;ln_hold != NULL) {
		m_freem_list(ln-&gt;ln_hold);
		ln-&gt;ln_hold = NULL;
	}

	<span class="enscript-comment">/* Purge any link-layer info caching */</span>
	VERIFY(ln-&gt;ln_rt-&gt;rt_llinfo == ln);
	<span class="enscript-keyword">if</span> (ln-&gt;ln_rt-&gt;rt_llinfo_purge != NULL)
		ln-&gt;ln_rt-&gt;rt_llinfo_purge(ln-&gt;ln_rt);

	zfree(llinfo_nd6_zone, ln);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_llinfo_purge</span>(<span class="enscript-type">struct</span> rtentry *rt)
{
	<span class="enscript-type">struct</span> llinfo_nd6 *ln = rt-&gt;rt_llinfo;

	RT_LOCK_ASSERT_HELD(rt);
	VERIFY(rt-&gt;rt_llinfo_purge == nd6_llinfo_purge &amp;&amp; ln != NULL);

	<span class="enscript-keyword">if</span> (ln-&gt;ln_llreach != NULL) {
		RT_CONVERT_LOCK(rt);
		ifnet_llreach_free(ln-&gt;ln_llreach);
		ln-&gt;ln_llreach = NULL;
	}
	ln-&gt;ln_lastused = 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_llinfo_get_ri</span>(<span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">struct</span> rt_reach_info *ri)
{
	<span class="enscript-type">struct</span> llinfo_nd6 *ln = rt-&gt;rt_llinfo;
	<span class="enscript-type">struct</span> if_llreach *lr = ln-&gt;ln_llreach;

	<span class="enscript-keyword">if</span> (lr == NULL) {
		bzero(ri, <span class="enscript-keyword">sizeof</span> (*ri));
		ri-&gt;ri_rssi = IFNET_RSSI_UNKNOWN;
		ri-&gt;ri_lqm = IFNET_LQM_THRESH_OFF;
		ri-&gt;ri_npm = IFNET_NPM_THRESH_UNKNOWN;
	} <span class="enscript-keyword">else</span> {
		IFLR_LOCK(lr);
		<span class="enscript-comment">/* Export to rt_reach_info structure */</span>
		ifnet_lr2ri(lr, ri);
		<span class="enscript-comment">/* Export ND6 send expiration (calendar) time */</span>
		ri-&gt;ri_snd_expire =
		    ifnet_llreach_up2calexp(lr, ln-&gt;ln_lastused);
		IFLR_UNLOCK(lr);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_llinfo_get_iflri</span>(<span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">struct</span> ifnet_llreach_info *iflri)
{
	<span class="enscript-type">struct</span> llinfo_nd6 *ln = rt-&gt;rt_llinfo;
	<span class="enscript-type">struct</span> if_llreach *lr = ln-&gt;ln_llreach;

	<span class="enscript-keyword">if</span> (lr == NULL) {
		bzero(iflri, <span class="enscript-keyword">sizeof</span> (*iflri));
		iflri-&gt;iflri_rssi = IFNET_RSSI_UNKNOWN;
		iflri-&gt;iflri_lqm = IFNET_LQM_THRESH_OFF;
		iflri-&gt;iflri_npm = IFNET_NPM_THRESH_UNKNOWN;
	} <span class="enscript-keyword">else</span> {
		IFLR_LOCK(lr);
		<span class="enscript-comment">/* Export to ifnet_llreach_info structure */</span>
		ifnet_lr2iflri(lr, iflri);
		<span class="enscript-comment">/* Export ND6 send expiration (uptime) time */</span>
		iflri-&gt;iflri_snd_expire =
		    ifnet_llreach_up2upexp(lr, ln-&gt;ln_lastused);
		IFLR_UNLOCK(lr);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_llinfo_refresh</span>(<span class="enscript-type">struct</span> rtentry *rt)
{
	<span class="enscript-type">struct</span> llinfo_nd6 *ln = rt-&gt;rt_llinfo;
	uint64_t timenow = net_uptime();
	<span class="enscript-comment">/*
	 * Can't refresh permanent, static or entries that are
	 * not direct host entries
	 */</span>
	<span class="enscript-keyword">if</span> (!ln || ln-&gt;ln_expire == 0 ||
	    (rt-&gt;rt_flags &amp; RTF_STATIC) ||
	    !(rt-&gt;rt_flags &amp; RTF_LLINFO)) {
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> ((ln-&gt;ln_state &gt; ND6_LLINFO_INCOMPLETE) &amp;&amp;
	    (ln-&gt;ln_state &lt; ND6_LLINFO_PROBE)) {
		<span class="enscript-keyword">if</span> (ln-&gt;ln_expire &gt; timenow) {
			ln-&gt;ln_expire = timenow;
			ln-&gt;ln_state = ND6_LLINFO_PROBE;
		}
	}
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ln_setexpire</span>(<span class="enscript-type">struct</span> llinfo_nd6 *ln, uint64_t expiry)
{
	ln-&gt;ln_expire = expiry;
}

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">ln_getexpire</span>(<span class="enscript-type">struct</span> llinfo_nd6 *ln)
{
	<span class="enscript-type">struct</span> timeval caltime;
	uint64_t expiry;

	<span class="enscript-keyword">if</span> (ln-&gt;ln_expire != 0) {
		<span class="enscript-type">struct</span> rtentry *rt = ln-&gt;ln_rt;

		VERIFY(rt != NULL);
		<span class="enscript-comment">/* account for system time change */</span>
		getmicrotime(&amp;caltime);

		rt-&gt;base_calendartime +=
		    NET_CALCULATE_CLOCKSKEW(caltime,
		    rt-&gt;base_calendartime, net_uptime(), rt-&gt;base_uptime);

		expiry = rt-&gt;base_calendartime +
		    ln-&gt;ln_expire - rt-&gt;base_uptime;
	} <span class="enscript-keyword">else</span> {
		expiry = 0;
	}
	<span class="enscript-keyword">return</span> (expiry);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_ifreset</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> nd_ifinfo *ndi = ND_IFINFO(ifp);
	VERIFY(NULL != ndi);
	VERIFY(ndi-&gt;initialized);

	lck_mtx_assert(&amp;ndi-&gt;lock, LCK_MTX_ASSERT_OWNED);
	ndi-&gt;linkmtu = ifp-&gt;if_mtu;
	ndi-&gt;chlim = IPV6_DEFHLIM;
	ndi-&gt;basereachable = REACHABLE_TIME;
	ndi-&gt;reachable = ND_COMPUTE_RTIME(ndi-&gt;basereachable);
	ndi-&gt;retrans = RETRANS_TIMER;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_ifattach</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> nd_ifinfo *ndi = ND_IFINFO(ifp);

	VERIFY(NULL != ndi);
	<span class="enscript-keyword">if</span> (!ndi-&gt;initialized) {
		lck_mtx_init(&amp;ndi-&gt;lock, nd_if_lock_grp, nd_if_lock_attr);
		ndi-&gt;flags = ND6_IFF_PERFORMNUD;
		ndi-&gt;initialized = TRUE;
	}

	lck_mtx_lock(&amp;ndi-&gt;lock);

	<span class="enscript-keyword">if</span> (!(ifp-&gt;if_flags &amp; IFF_MULTICAST)) {
		ndi-&gt;flags |= ND6_IFF_IFDISABLED;
	}

	nd6_ifreset(ifp);
	lck_mtx_unlock(&amp;ndi-&gt;lock);
	nd6_setmtu(ifp);
	<span class="enscript-keyword">return</span>;
}

#<span class="enscript-reference">if</span> 0
<span class="enscript-comment">/*
 * XXX Look more into this. Especially since we recycle ifnets and do delayed
 * cleanup
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_ifdetach</span>(<span class="enscript-type">struct</span> nd_ifinfo *nd)
{
	<span class="enscript-comment">/* XXX destroy nd's lock? */</span>
	FREE(nd, M_IP6NDP);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_setmtu</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> nd_ifinfo *ndi = ND_IFINFO(ifp);
	u_int32_t oldmaxmtu, maxmtu;

	<span class="enscript-keyword">if</span> ((NULL == ndi) || (FALSE == ndi-&gt;initialized)) {
		<span class="enscript-keyword">return</span>;
	}

	lck_mtx_lock(&amp;ndi-&gt;lock);
	oldmaxmtu = ndi-&gt;maxmtu;

	<span class="enscript-comment">/*
	 * The ND level maxmtu is somewhat redundant to the interface MTU
	 * and is an implementation artifact of KAME.  Instead of hard-
	 * limiting the maxmtu based on the interface type here, we simply
	 * take the if_mtu value since SIOCSIFMTU would have taken care of
	 * the sanity checks related to the maximum MTU allowed for the
	 * interface (a value that is known only by the interface layer),
	 * by sending the request down via ifnet_ioctl().  The use of the
	 * ND level maxmtu and linkmtu are done via IN6_LINKMTU() which
	 * does further checking against if_mtu.
	 */</span>
	maxmtu = ndi-&gt;maxmtu = ifp-&gt;if_mtu;

	<span class="enscript-comment">/*
	 * Decreasing the interface MTU under IPV6 minimum MTU may cause
	 * undesirable situation.  We thus notify the operator of the change
	 * explicitly.  The check for oldmaxmtu is necessary to restrict the
	 * log to the case of changing the MTU, not initializing it.
	 */</span>
	<span class="enscript-keyword">if</span> (oldmaxmtu &gt;= IPV6_MMTU &amp;&amp; ndi-&gt;maxmtu &lt; IPV6_MMTU) {
		log(LOG_NOTICE, <span class="enscript-string">&quot;nd6_setmtu: &quot;</span>
		    <span class="enscript-string">&quot;new link MTU on %s (%u) is too small for IPv6\n&quot;</span>,
		    if_name(ifp), (uint32_t)ndi-&gt;maxmtu);
	}
	ndi-&gt;linkmtu = ifp-&gt;if_mtu;
	lck_mtx_unlock(&amp;ndi-&gt;lock);

	<span class="enscript-comment">/* also adjust in6_maxmtu if necessary. */</span>
	<span class="enscript-keyword">if</span> (maxmtu &gt; in6_maxmtu) {
		in6_setmaxmtu();
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_option_init</span>(<span class="enscript-type">void</span> *opt, <span class="enscript-type">int</span> icmp6len, <span class="enscript-type">union</span> nd_opts *ndopts)
{
	bzero(ndopts, <span class="enscript-keyword">sizeof</span> (*ndopts));
	ndopts-&gt;nd_opts_search = (<span class="enscript-type">struct</span> nd_opt_hdr *)opt;
	ndopts-&gt;nd_opts_last =
	    (<span class="enscript-type">struct</span> nd_opt_hdr *)(((u_char *)opt) + icmp6len);

	<span class="enscript-keyword">if</span> (icmp6len == 0) {
		ndopts-&gt;nd_opts_done = 1;
		ndopts-&gt;nd_opts_search = NULL;
	}
}

<span class="enscript-comment">/*
 * Take one ND option.
 */</span>
<span class="enscript-type">struct</span> nd_opt_hdr *
<span class="enscript-function-name">nd6_option</span>(<span class="enscript-type">union</span> nd_opts *ndopts)
{
	<span class="enscript-type">struct</span> nd_opt_hdr *nd_opt;
	<span class="enscript-type">int</span> olen;

	<span class="enscript-keyword">if</span> (!ndopts)
		panic(<span class="enscript-string">&quot;ndopts == NULL in nd6_option\n&quot;</span>);
	<span class="enscript-keyword">if</span> (!ndopts-&gt;nd_opts_last)
		panic(<span class="enscript-string">&quot;uninitialized ndopts in nd6_option\n&quot;</span>);
	<span class="enscript-keyword">if</span> (!ndopts-&gt;nd_opts_search)
		<span class="enscript-keyword">return</span> (NULL);
	<span class="enscript-keyword">if</span> (ndopts-&gt;nd_opts_done)
		<span class="enscript-keyword">return</span> (NULL);

	nd_opt = ndopts-&gt;nd_opts_search;

	<span class="enscript-comment">/* make sure nd_opt_len is inside the buffer */</span>
	<span class="enscript-keyword">if</span> ((caddr_t)&amp;nd_opt-&gt;nd_opt_len &gt;= (caddr_t)ndopts-&gt;nd_opts_last) {
		bzero(ndopts, <span class="enscript-keyword">sizeof</span> (*ndopts));
		<span class="enscript-keyword">return</span> (NULL);
	}

	olen = nd_opt-&gt;nd_opt_len &lt;&lt; 3;
	<span class="enscript-keyword">if</span> (olen == 0) {
		<span class="enscript-comment">/*
		 * Message validation requires that all included
		 * options have a length that is greater than zero.
		 */</span>
		bzero(ndopts, <span class="enscript-keyword">sizeof</span> (*ndopts));
		<span class="enscript-keyword">return</span> (NULL);
	}

	ndopts-&gt;nd_opts_search = (<span class="enscript-type">struct</span> nd_opt_hdr *)((caddr_t)nd_opt + olen);
	<span class="enscript-keyword">if</span> (ndopts-&gt;nd_opts_search &gt; ndopts-&gt;nd_opts_last) {
		<span class="enscript-comment">/* option overruns the end of buffer, invalid */</span>
		bzero(ndopts, <span class="enscript-keyword">sizeof</span> (*ndopts));
		<span class="enscript-keyword">return</span> (NULL);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ndopts-&gt;nd_opts_search == ndopts-&gt;nd_opts_last) {
		<span class="enscript-comment">/* reached the end of options chain */</span>
		ndopts-&gt;nd_opts_done = 1;
		ndopts-&gt;nd_opts_search = NULL;
	}
	<span class="enscript-keyword">return</span> (nd_opt);
}

<span class="enscript-comment">/*
 * Parse multiple ND options.
 * This function is much easier to use, for ND routines that do not need
 * multiple options of the same type.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_options</span>(<span class="enscript-type">union</span> nd_opts *ndopts)
{
	<span class="enscript-type">struct</span> nd_opt_hdr *nd_opt;
	<span class="enscript-type">int</span> i = 0;

	<span class="enscript-keyword">if</span> (ndopts == NULL)
		panic(<span class="enscript-string">&quot;ndopts == NULL in nd6_options&quot;</span>);
	<span class="enscript-keyword">if</span> (ndopts-&gt;nd_opts_last == NULL)
		panic(<span class="enscript-string">&quot;uninitialized ndopts in nd6_options&quot;</span>);
	<span class="enscript-keyword">if</span> (ndopts-&gt;nd_opts_search == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">while</span> (1) {
		nd_opt = nd6_option(ndopts);
		<span class="enscript-keyword">if</span> (nd_opt == NULL &amp;&amp; ndopts-&gt;nd_opts_last == NULL) {
			<span class="enscript-comment">/*
			 * Message validation requires that all included
			 * options have a length that is greater than zero.
			 */</span>
			icmp6stat.icp6s_nd_badopt++;
			bzero(ndopts, <span class="enscript-keyword">sizeof</span> (*ndopts));
			<span class="enscript-keyword">return</span> (-1);
		}

		<span class="enscript-keyword">if</span> (nd_opt == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip1</span>;

		<span class="enscript-keyword">switch</span> (nd_opt-&gt;nd_opt_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_OPT_SOURCE_LINKADDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_OPT_TARGET_LINKADDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_OPT_MTU</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_OPT_REDIRECTED_HEADER</span>:
			<span class="enscript-keyword">if</span> (ndopts-&gt;nd_opt_array[nd_opt-&gt;nd_opt_type]) {
				nd6log((LOG_INFO,
				    <span class="enscript-string">&quot;duplicated ND6 option found (type=%d)\n&quot;</span>,
				    nd_opt-&gt;nd_opt_type));
				<span class="enscript-comment">/* XXX bark? */</span>
			} <span class="enscript-keyword">else</span> {
				ndopts-&gt;nd_opt_array[nd_opt-&gt;nd_opt_type] =
				    nd_opt;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_OPT_PREFIX_INFORMATION</span>:
			<span class="enscript-keyword">if</span> (ndopts-&gt;nd_opt_array[nd_opt-&gt;nd_opt_type] == 0) {
				ndopts-&gt;nd_opt_array[nd_opt-&gt;nd_opt_type] =
				    nd_opt;
			}
			ndopts-&gt;nd_opts_pi_end =
			    (<span class="enscript-type">struct</span> nd_opt_prefix_info *)nd_opt;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_OPT_RDNSS</span>:
			<span class="enscript-comment">/* ignore */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/*
			 * Unknown options must be silently ignored,
			 * to accomodate future extension to the protocol.
			 */</span>
			nd6log((LOG_DEBUG,
			    <span class="enscript-string">&quot;nd6_options: unsupported option %d - &quot;</span>
			    <span class="enscript-string">&quot;option ignored\n&quot;</span>, nd_opt-&gt;nd_opt_type));
		}

<span class="enscript-reference">skip1</span>:
		i++;
		<span class="enscript-keyword">if</span> (i &gt; nd6_maxndopt) {
			icmp6stat.icp6s_nd_toomanyopt++;
			nd6log((LOG_INFO, <span class="enscript-string">&quot;too many loop in nd opt\n&quot;</span>));
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (ndopts-&gt;nd_opts_done)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">struct</span> nd6svc_arg {
	<span class="enscript-type">int</span> draining;
	uint32_t killed;
	uint32_t aging_lazy;
	uint32_t aging;
	uint32_t sticky;
	uint32_t found;
};

<span class="enscript-comment">/*
 * ND6 service routine to expire default route list and prefix list
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_service</span>(<span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> nd6svc_arg *ap = arg;
	<span class="enscript-type">struct</span> llinfo_nd6 *ln;
	<span class="enscript-type">struct</span> nd_defrouter *dr;
	<span class="enscript-type">struct</span> nd_prefix *pr;
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;
	<span class="enscript-type">struct</span> in6_ifaddr *ia6, *nia6;
	uint64_t timenow;
	bool send_nc_failure_kev = false;

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
	<span class="enscript-comment">/*
	 * Since we may drop rnh_lock and nd6_mutex below, we want
	 * to run this entire operation single threaded.
	 */</span>
	<span class="enscript-keyword">while</span> (nd6_service_busy) {
		nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s: %s is blocked by %d waiters\n&quot;</span>,
		    __func__, ap-&gt;draining ? <span class="enscript-string">&quot;drainer&quot;</span> : <span class="enscript-string">&quot;timer&quot;</span>,
		    nd6_service_waiters));
		nd6_service_waiters++;
		(<span class="enscript-type">void</span>) msleep(nd6_service_wc, rnh_lock, (PZERO-1),
		    __func__, NULL);
		lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
	}

	<span class="enscript-comment">/* We are busy now; tell everyone else to go away */</span>
	nd6_service_busy = TRUE;

	net_update_uptime();
	timenow = net_uptime();
<span class="enscript-reference">again</span>:
	<span class="enscript-comment">/*
	 * send_nc_failure_kev gets set when default router's IPv6 address
	 * can't be resolved.
	 * That can happen either:
	 * 1. When the entry has resolved once but can't be
	 * resolved later and the neighbor cache entry for gateway is deleted
	 * after max probe attempts.
	 *
	 * 2. When the entry is in ND6_LLINFO_INCOMPLETE but can not be resolved
	 * after max neighbor address resolution attempts.
	 *
	 * Both set send_nc_failure_kev to true. ifp is also set to the previous
	 * neighbor cache entry's route's ifp.
	 * Once we are done sending the notification, set send_nc_failure_kev
	 * to false to stop sending false notifications for non default router
	 * neighbors.
	 *
	 * We may to send more information like Gateway's IP that could not be
	 * resolved, however right now we do not install more than one default
	 * route per interface in the routing table.
	 */</span>
	<span class="enscript-keyword">if</span> (send_nc_failure_kev &amp;&amp; ifp-&gt;if_addrlen == IF_LLREACH_MAXLEN) {
		<span class="enscript-type">struct</span> kev_msg ev_msg;
		<span class="enscript-type">struct</span> kev_nd6_ndfailure nd6_ndfailure;
		bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span>(ev_msg));
		bzero(&amp;nd6_ndfailure, <span class="enscript-keyword">sizeof</span>(nd6_ndfailure));
		ev_msg.vendor_code      = KEV_VENDOR_APPLE;
		ev_msg.kev_class        = KEV_NETWORK_CLASS;
		ev_msg.kev_subclass     = KEV_ND6_SUBCLASS;
		ev_msg.event_code       = KEV_ND6_NDFAILURE;

		nd6_ndfailure.link_data.if_family = ifp-&gt;if_family;
		nd6_ndfailure.link_data.if_unit = ifp-&gt;if_unit;
		strlcpy(nd6_ndfailure.link_data.if_name,
		    ifp-&gt;if_name,
		    <span class="enscript-keyword">sizeof</span>(nd6_ndfailure.link_data.if_name));
		ev_msg.dv[0].data_ptr = &amp;nd6_ndfailure;
		ev_msg.dv[0].data_length =
			<span class="enscript-keyword">sizeof</span>(nd6_ndfailure);
		kev_post_msg(&amp;ev_msg);
	}

	send_nc_failure_kev = false;
	ifp = NULL;
	<span class="enscript-comment">/*
	 * The global list llinfo_nd6 is modified by nd6_request() and is
	 * therefore protected by rnh_lock.  For obvious reasons, we cannot
	 * hold rnh_lock across calls that might lead to code paths which
	 * attempt to acquire rnh_lock, else we deadlock.  Hence for such
	 * cases we drop rt_lock and rnh_lock, make the calls, and repeat the
	 * loop.  To ensure that we don't process the same entry more than
	 * once in a single timeout, we mark the &quot;already-seen&quot; entries with
	 * ND6_LNF_TIMER_SKIP flag.  At the end of the loop, we do a second
	 * pass thru the entries and clear the flag so they can be processed
	 * during the next timeout.
	 */</span>
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);

	ln = llinfo_nd6.ln_next;
	<span class="enscript-keyword">while</span> (ln != NULL &amp;&amp; ln != &amp;llinfo_nd6) {
		<span class="enscript-type">struct</span> rtentry *rt;
		<span class="enscript-type">struct</span> sockaddr_in6 *dst;
		<span class="enscript-type">struct</span> llinfo_nd6 *next;
		u_int32_t retrans, flags;
		<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;

		<span class="enscript-comment">/* ln_next/prev/rt is protected by rnh_lock */</span>
		next = ln-&gt;ln_next;
		rt = ln-&gt;ln_rt;
		RT_LOCK(rt);

		<span class="enscript-comment">/* We've seen this already; skip it */</span>
		<span class="enscript-keyword">if</span> (ln-&gt;ln_flags &amp; ND6_LNF_TIMER_SKIP) {
			RT_UNLOCK(rt);
			ln = next;
			<span class="enscript-keyword">continue</span>;
		}
		ap-&gt;found++;

		<span class="enscript-comment">/* rt-&gt;rt_ifp should never be NULL */</span>
		<span class="enscript-keyword">if</span> ((ifp = rt-&gt;rt_ifp) == NULL) {
			panic(<span class="enscript-string">&quot;%s: ln(%p) rt(%p) rt_ifp == NULL&quot;</span>, __func__,
			    ln, rt);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}

		<span class="enscript-comment">/* rt_llinfo must always be equal to ln */</span>
		<span class="enscript-keyword">if</span> ((<span class="enscript-type">struct</span> llinfo_nd6 *)rt-&gt;rt_llinfo != ln) {
			panic(<span class="enscript-string">&quot;%s: rt_llinfo(%p) is not equal to ln(%p)&quot;</span>,
			    __func__, rt-&gt;rt_llinfo, ln);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}

		<span class="enscript-comment">/* rt_key should never be NULL */</span>
		dst = SIN6(rt_key(rt));
		<span class="enscript-keyword">if</span> (dst == NULL) {
			panic(<span class="enscript-string">&quot;%s: rt(%p) key is NULL ln(%p)&quot;</span>, __func__,
			    rt, ln);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}

		<span class="enscript-comment">/* Set the flag in case we jump to &quot;again&quot; */</span>
		ln-&gt;ln_flags |= ND6_LNF_TIMER_SKIP;

		<span class="enscript-keyword">if</span> (ln-&gt;ln_expire == 0 || (rt-&gt;rt_flags &amp; RTF_STATIC)) {
			ap-&gt;sticky++;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ap-&gt;draining &amp;&amp; (rt-&gt;rt_refcnt == 0)) {
			<span class="enscript-comment">/*
			 * If we are draining, immediately purge non-static
			 * entries without oustanding route refcnt.
			 */</span>
			<span class="enscript-keyword">if</span> (ln-&gt;ln_state &gt; ND6_LLINFO_INCOMPLETE)
				ln-&gt;ln_state = ND6_LLINFO_STALE;
			<span class="enscript-keyword">else</span>
				ln-&gt;ln_state = ND6_LLINFO_PURGE;
			ln_setexpire(ln, timenow);
		}

		<span class="enscript-comment">/*
		 * If the entry has not expired, skip it.  Take note on the
		 * state, as entries that are in the STALE state are simply
		 * waiting to be garbage collected, in which case we can
		 * relax the callout scheduling (use nd6_prune_lazy).
		 */</span>
		<span class="enscript-keyword">if</span> (ln-&gt;ln_expire &gt; timenow) {
			<span class="enscript-keyword">switch</span> (ln-&gt;ln_state) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ND6_LLINFO_STALE</span>:
				ap-&gt;aging_lazy++;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				ap-&gt;aging++;
				<span class="enscript-keyword">break</span>;
			}
			RT_UNLOCK(rt);
			ln = next;
			<span class="enscript-keyword">continue</span>;
		}

		ndi = ND_IFINFO(ifp);
		VERIFY(ndi-&gt;initialized);
		retrans = ndi-&gt;retrans;
		flags = ndi-&gt;flags;

		RT_LOCK_ASSERT_HELD(rt);

		<span class="enscript-keyword">switch</span> (ln-&gt;ln_state) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ND6_LLINFO_INCOMPLETE</span>:
			<span class="enscript-keyword">if</span> (ln-&gt;ln_asked &lt; nd6_mmaxtries) {
				<span class="enscript-type">struct</span> ifnet *exclifp = ln-&gt;ln_exclifp;
				ln-&gt;ln_asked++;
				ln_setexpire(ln, timenow + retrans / 1000);
				RT_ADDREF_LOCKED(rt);
				RT_UNLOCK(rt);
				lck_mtx_unlock(rnh_lock);
				<span class="enscript-keyword">if</span> (ip6_forwarding) {
					nd6_prproxy_ns_output(ifp, exclifp,
					    NULL, &amp;dst-&gt;sin6_addr, ln);
				} <span class="enscript-keyword">else</span> {
					nd6_ns_output(ifp, NULL,
					    &amp;dst-&gt;sin6_addr, ln, 0);
				}
				RT_REMREF(rt);
				ap-&gt;aging++;
				lck_mtx_lock(rnh_lock);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-type">struct</span> mbuf *m = ln-&gt;ln_hold;
				ln-&gt;ln_hold = NULL;
				send_nc_failure_kev = (rt-&gt;rt_flags &amp; RTF_ROUTER) ? true : false;
				<span class="enscript-keyword">if</span> (m != NULL) {
					RT_ADDREF_LOCKED(rt);
					RT_UNLOCK(rt);
					lck_mtx_unlock(rnh_lock);

					<span class="enscript-type">struct</span> mbuf *mnext;
					<span class="enscript-keyword">while</span> (m) {
						mnext = m-&gt;m_nextpkt;
						m-&gt;m_nextpkt = NULL;
						m-&gt;m_pkthdr.rcvif = ifp;
						icmp6_error_flag(m, ICMP6_DST_UNREACH,
						    ICMP6_DST_UNREACH_ADDR, 0, 0);
						m = mnext;
					}
				} <span class="enscript-keyword">else</span> {
					RT_ADDREF_LOCKED(rt);
					RT_UNLOCK(rt);
					lck_mtx_unlock(rnh_lock);
				}
				nd6_free(rt);
				ap-&gt;killed++;
				lck_mtx_lock(rnh_lock);
				rtfree_locked(rt);
			}
			lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">ND6_LLINFO_REACHABLE</span>:
			<span class="enscript-keyword">if</span> (ln-&gt;ln_expire != 0) {
				ln-&gt;ln_state = ND6_LLINFO_STALE;
				ln_setexpire(ln, timenow + nd6_gctimer);
				ap-&gt;aging_lazy++;
			}
			RT_UNLOCK(rt);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">ND6_LLINFO_STALE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ND6_LLINFO_PURGE</span>:
			<span class="enscript-comment">/* Garbage Collection(RFC 4861 5.3) */</span>
			<span class="enscript-keyword">if</span> (ln-&gt;ln_expire != 0) {
				RT_ADDREF_LOCKED(rt);
				RT_UNLOCK(rt);
				lck_mtx_unlock(rnh_lock);
				nd6_free(rt);
				ap-&gt;killed++;
				lck_mtx_lock(rnh_lock);
				rtfree_locked(rt);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
			} <span class="enscript-keyword">else</span> {
				RT_UNLOCK(rt);
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">ND6_LLINFO_DELAY</span>:
			<span class="enscript-keyword">if</span> ((flags &amp; ND6_IFF_PERFORMNUD) != 0) {
				<span class="enscript-comment">/* We need NUD */</span>
				ln-&gt;ln_asked = 1;
				ln-&gt;ln_state = ND6_LLINFO_PROBE;
				ln_setexpire(ln, timenow + retrans / 1000);
				RT_ADDREF_LOCKED(rt);
				RT_UNLOCK(rt);
				lck_mtx_unlock(rnh_lock);
				nd6_ns_output(ifp, &amp;dst-&gt;sin6_addr,
				    &amp;dst-&gt;sin6_addr, ln, 0);
				RT_REMREF(rt);
				ap-&gt;aging++;
				lck_mtx_lock(rnh_lock);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
			}
			ln-&gt;ln_state = ND6_LLINFO_STALE; <span class="enscript-comment">/* XXX */</span>
			ln_setexpire(ln, timenow + nd6_gctimer);
			RT_UNLOCK(rt);
			ap-&gt;aging_lazy++;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">ND6_LLINFO_PROBE</span>:
			<span class="enscript-keyword">if</span> (ln-&gt;ln_asked &lt; nd6_umaxtries) {
				ln-&gt;ln_asked++;
				ln_setexpire(ln, timenow + retrans / 1000);
				RT_ADDREF_LOCKED(rt);
				RT_UNLOCK(rt);
				lck_mtx_unlock(rnh_lock);
				nd6_ns_output(ifp, &amp;dst-&gt;sin6_addr,
				    &amp;dst-&gt;sin6_addr, ln, 0);
				RT_REMREF(rt);
				ap-&gt;aging++;
				lck_mtx_lock(rnh_lock);
			} <span class="enscript-keyword">else</span> {
				send_nc_failure_kev = (rt-&gt;rt_flags &amp; RTF_ROUTER) ? true : false;
				RT_ADDREF_LOCKED(rt);
				RT_UNLOCK(rt);
				lck_mtx_unlock(rnh_lock);
				nd6_free(rt);
				ap-&gt;killed++;
				lck_mtx_lock(rnh_lock);
				rtfree_locked(rt);
			}
			lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;

		<span class="enscript-reference">default</span>:
			RT_UNLOCK(rt);
			<span class="enscript-keyword">break</span>;
		}
		ln = next;
	}
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* Now clear the flag from all entries */</span>
	ln = llinfo_nd6.ln_next;
	<span class="enscript-keyword">while</span> (ln != NULL &amp;&amp; ln != &amp;llinfo_nd6) {
		<span class="enscript-type">struct</span> rtentry *rt = ln-&gt;ln_rt;
		<span class="enscript-type">struct</span> llinfo_nd6 *next = ln-&gt;ln_next;

		RT_LOCK_SPIN(rt);
		<span class="enscript-keyword">if</span> (ln-&gt;ln_flags &amp; ND6_LNF_TIMER_SKIP)
			ln-&gt;ln_flags &amp;= ~ND6_LNF_TIMER_SKIP;
		RT_UNLOCK(rt);
		ln = next;
	}
	lck_mtx_unlock(rnh_lock);

	<span class="enscript-comment">/* expire default router list */</span>
	lck_mtx_lock(nd6_mutex);
	dr = TAILQ_FIRST(&amp;nd_defrouter);
	<span class="enscript-keyword">while</span> (dr) {
		ap-&gt;found++;
		<span class="enscript-keyword">if</span> (dr-&gt;expire != 0 &amp;&amp; dr-&gt;expire &lt; timenow) {
			<span class="enscript-type">struct</span> nd_defrouter *t;
			t = TAILQ_NEXT(dr, dr_entry);
			defrtrlist_del(dr);
			dr = t;
			ap-&gt;killed++;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (dr-&gt;expire == 0 || (dr-&gt;stateflags &amp; NDDRF_STATIC))
				ap-&gt;sticky++;
			<span class="enscript-keyword">else</span>
				ap-&gt;aging_lazy++;
			dr = TAILQ_NEXT(dr, dr_entry);
		}
	}
	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-comment">/*
	 * expire interface addresses.
	 * in the past the loop was inside prefix expiry processing.
	 * However, from a stricter speci-confrmance standpoint, we should
	 * rather separate address lifetimes and prefix lifetimes.
	 */</span>
<span class="enscript-reference">addrloop</span>:
	lck_rw_lock_exclusive(&amp;in6_ifaddr_rwlock);
	<span class="enscript-keyword">for</span> (ia6 = in6_ifaddrs; ia6; ia6 = nia6) {
		ap-&gt;found++;
		nia6 = ia6-&gt;ia_next;
		IFA_LOCK(&amp;ia6-&gt;ia_ifa);
		<span class="enscript-comment">/*
		 * Extra reference for ourselves; it's no-op if
		 * we don't have to regenerate temporary address,
		 * otherwise it protects the address from going
		 * away since we drop in6_ifaddr_rwlock below.
		 */</span>
		IFA_ADDREF_LOCKED(&amp;ia6-&gt;ia_ifa);
		<span class="enscript-comment">/* check address lifetime */</span>
		<span class="enscript-keyword">if</span> (IFA6_IS_INVALID(ia6, timenow)) {
			<span class="enscript-comment">/*
			 * If the expiring address is temporary, try
			 * regenerating a new one.  This would be useful when
			 * we suspended a laptop PC, then turned it on after a
			 * period that could invalidate all temporary
			 * addresses.  Although we may have to restart the
			 * loop (see below), it must be after purging the
			 * address.  Otherwise, we'd see an infinite loop of
			 * regeneration.
			 */</span>
			<span class="enscript-keyword">if</span> (ip6_use_tempaddr &amp;&amp;
			    (ia6-&gt;ia6_flags &amp; IN6_IFF_TEMPORARY) != 0) {
				<span class="enscript-comment">/*
				 * NOTE: We have to drop the lock here
				 * because regen_tmpaddr() eventually calls
				 * in6_update_ifa(), which must take the lock
				 * and would otherwise cause a hang.  This is
				 * safe because the goto addrloop leads to a
				 * re-evaluation of the in6_ifaddrs list
				 */</span>
				IFA_UNLOCK(&amp;ia6-&gt;ia_ifa);
				lck_rw_done(&amp;in6_ifaddr_rwlock);
				(<span class="enscript-type">void</span>) regen_tmpaddr(ia6);
			} <span class="enscript-keyword">else</span> {
				IFA_UNLOCK(&amp;ia6-&gt;ia_ifa);
				lck_rw_done(&amp;in6_ifaddr_rwlock);
			}

			<span class="enscript-comment">/*
			 * Purging the address would have caused
			 * in6_ifaddr_rwlock to be dropped and reacquired;
			 * therefore search again from the beginning
			 * of in6_ifaddrs list.
			 */</span>
			in6_purgeaddr(&amp;ia6-&gt;ia_ifa);
			ap-&gt;killed++;

			<span class="enscript-comment">/* Release extra reference taken above */</span>
			IFA_REMREF(&amp;ia6-&gt;ia_ifa);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">addrloop</span>;
		}
		<span class="enscript-comment">/*
		 * The lazy timer runs every nd6_prune_lazy seconds with at
		 * most &quot;2 * nd6_prune_lazy - 1&quot; leeway. We consider the worst
		 * case here and make sure we schedule the regular timer if an
		 * interface address is about to expire.
		 */</span>
		<span class="enscript-keyword">if</span> (IFA6_IS_INVALID(ia6, timenow + 3 * nd6_prune_lazy))
			ap-&gt;aging++;
		<span class="enscript-keyword">else</span>
			ap-&gt;aging_lazy++;
		IFA_LOCK_ASSERT_HELD(&amp;ia6-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (IFA6_IS_DEPRECATED(ia6, timenow)) {
			<span class="enscript-type">int</span> oldflags = ia6-&gt;ia6_flags;

			ia6-&gt;ia6_flags |= IN6_IFF_DEPRECATED;

			<span class="enscript-comment">/*
			 * If a temporary address has just become deprecated,
			 * regenerate a new one if possible.
			 */</span>
			<span class="enscript-keyword">if</span> (ip6_use_tempaddr &amp;&amp;
			    (ia6-&gt;ia6_flags &amp; IN6_IFF_TEMPORARY) != 0 &amp;&amp;
			    (oldflags &amp; IN6_IFF_DEPRECATED) == 0) {

				<span class="enscript-comment">/* see NOTE above */</span>
				IFA_UNLOCK(&amp;ia6-&gt;ia_ifa);
				lck_rw_done(&amp;in6_ifaddr_rwlock);
				<span class="enscript-keyword">if</span> (regen_tmpaddr(ia6) == 0) {
					<span class="enscript-comment">/*
					 * A new temporary address is
					 * generated.
					 * XXX: this means the address chain
					 * has changed while we are still in
					 * the loop.  Although the change
					 * would not cause disaster (because
					 * it's not a deletion, but an
					 * addition,) we'd rather restart the
					 * loop just for safety.  Or does this
					 * significantly reduce performance??
					 */</span>
					<span class="enscript-comment">/* Release extra reference */</span>
					IFA_REMREF(&amp;ia6-&gt;ia_ifa);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">addrloop</span>;
				}
				lck_rw_lock_exclusive(&amp;in6_ifaddr_rwlock);
			} <span class="enscript-keyword">else</span> {
				IFA_UNLOCK(&amp;ia6-&gt;ia_ifa);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * A new RA might have made a deprecated address
			 * preferred.
			 */</span>
			ia6-&gt;ia6_flags &amp;= ~IN6_IFF_DEPRECATED;
			IFA_UNLOCK(&amp;ia6-&gt;ia_ifa);
		}
		lck_rw_assert(&amp;in6_ifaddr_rwlock, LCK_RW_ASSERT_EXCLUSIVE);
		<span class="enscript-comment">/* Release extra reference taken above */</span>
		IFA_REMREF(&amp;ia6-&gt;ia_ifa);
	}
	lck_rw_done(&amp;in6_ifaddr_rwlock);

	lck_mtx_lock(nd6_mutex);
	<span class="enscript-comment">/* expire prefix list */</span>
	pr = nd_prefix.lh_first;
	<span class="enscript-keyword">while</span> (pr != NULL) {
		ap-&gt;found++;
		<span class="enscript-comment">/*
		 * check prefix lifetime.
		 * since pltime is just for autoconf, pltime processing for
		 * prefix is not necessary.
		 */</span>
		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_stateflags &amp; NDPRF_PROCESSED_SERVICE ||
		    pr-&gt;ndpr_stateflags &amp; NDPRF_DEFUNCT) {
			pr-&gt;ndpr_stateflags |= NDPRF_PROCESSED_SERVICE;
			NDPR_UNLOCK(pr);
			pr = pr-&gt;ndpr_next;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_expire != 0 &amp;&amp; pr-&gt;ndpr_expire &lt; timenow) {
			<span class="enscript-comment">/*
			 * address expiration and prefix expiration are
			 * separate.  NEVER perform in6_purgeaddr here.
			 */</span>
			pr-&gt;ndpr_stateflags |= NDPRF_PROCESSED_SERVICE;
			NDPR_ADDREF_LOCKED(pr);
			prelist_remove(pr);
			NDPR_UNLOCK(pr);
			NDPR_REMREF(pr);
			pfxlist_onlink_check();
			pr = nd_prefix.lh_first;
			ap-&gt;killed++;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (pr-&gt;ndpr_expire == 0 ||
			    (pr-&gt;ndpr_stateflags &amp; NDPRF_STATIC))
				ap-&gt;sticky++;
			<span class="enscript-keyword">else</span>
				ap-&gt;aging_lazy++;
			pr-&gt;ndpr_stateflags |= NDPRF_PROCESSED_SERVICE;
			NDPR_UNLOCK(pr);
			pr = pr-&gt;ndpr_next;
		}
	}
	LIST_FOREACH(pr, &amp;nd_prefix, ndpr_entry) {
		NDPR_LOCK(pr);
		pr-&gt;ndpr_stateflags &amp;= ~NDPRF_PROCESSED_SERVICE;
		NDPR_UNLOCK(pr);
	}
	lck_mtx_unlock(nd6_mutex);

	lck_mtx_lock(rnh_lock);
	<span class="enscript-comment">/* We're done; let others enter */</span>
	nd6_service_busy = FALSE;
	<span class="enscript-keyword">if</span> (nd6_service_waiters &gt; 0) {
		nd6_service_waiters = 0;
		wakeup(nd6_service_wc);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_drain</span>(<span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>)
	<span class="enscript-type">struct</span> nd6svc_arg sarg;

	nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s: draining ND6 entries\n&quot;</span>, __func__));

	lck_mtx_lock(rnh_lock);
	bzero(&amp;sarg, <span class="enscript-keyword">sizeof</span> (sarg));
	sarg.draining = 1;
	nd6_service(&amp;sarg);
	nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s: found %u, aging_lazy %u, aging %u, &quot;</span>
	    <span class="enscript-string">&quot;sticky %u, killed %u\n&quot;</span>, __func__, sarg.found, sarg.aging_lazy,
	    sarg.aging, sarg.sticky, sarg.killed));
	lck_mtx_unlock(rnh_lock);
}

<span class="enscript-comment">/*
 * We use the ``arg'' variable to decide whether or not the timer we're
 * running is the fast timer. We do this to reset the nd6_fast_timer_on
 * variable so that later we don't end up ignoring a ``fast timer'' 
 * request if the 5 second timer is running (see nd6_sched_timeout).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_timeout</span>(<span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> nd6svc_arg sarg;
	uint32_t buf;

	lck_mtx_lock(rnh_lock);
	bzero(&amp;sarg, <span class="enscript-keyword">sizeof</span> (sarg));
	nd6_service(&amp;sarg);
	nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s: found %u, aging_lazy %u, aging %u, &quot;</span>
	    <span class="enscript-string">&quot;sticky %u, killed %u\n&quot;</span>, __func__, sarg.found, sarg.aging_lazy,
	    sarg.aging, sarg.sticky, sarg.killed));
	<span class="enscript-comment">/* re-arm the timer if there's work to do */</span>
	nd6_timeout_run--;
	VERIFY(nd6_timeout_run &gt;= 0 &amp;&amp; nd6_timeout_run &lt; 2);
	<span class="enscript-keyword">if</span> (arg == &amp;nd6_fast_timer_on)
		nd6_fast_timer_on = FALSE;
	<span class="enscript-keyword">if</span> (sarg.aging_lazy &gt; 0 || sarg.aging &gt; 0 || nd6_sched_timeout_want) {
		<span class="enscript-type">struct</span> timeval atv, ltv, *leeway;
		<span class="enscript-type">int</span> lazy = nd6_prune_lazy;

		<span class="enscript-keyword">if</span> (sarg.aging &gt; 0 || lazy &lt; 1) {
			atv.tv_usec = 0;
			atv.tv_sec = nd6_prune;
			leeway = NULL;
		} <span class="enscript-keyword">else</span> {
			VERIFY(lazy &gt;= 1);
			atv.tv_usec = 0;
			atv.tv_sec = MAX(nd6_prune, lazy);
			ltv.tv_usec = 0;
			read_frandom(&amp;buf, <span class="enscript-keyword">sizeof</span>(buf));
			ltv.tv_sec = MAX(buf % lazy, 1) * 2;
			leeway = &amp;ltv;
		}
		nd6_sched_timeout(&amp;atv, leeway);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nd6_debug) {
		nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s: not rescheduling timer\n&quot;</span>, __func__));
	}
	lck_mtx_unlock(rnh_lock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_sched_timeout</span>(<span class="enscript-type">struct</span> timeval *atv, <span class="enscript-type">struct</span> timeval *ltv)
{
	<span class="enscript-type">struct</span> timeval tv;

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
	<span class="enscript-keyword">if</span> (atv == NULL) {
		tv.tv_usec = 0;
		tv.tv_sec = MAX(nd6_prune, 1);
		atv = &amp;tv;
		ltv = NULL;	<span class="enscript-comment">/* ignore leeway */</span>
	}
	<span class="enscript-comment">/* see comments on top of this file */</span>
	<span class="enscript-keyword">if</span> (nd6_timeout_run == 0) {
		<span class="enscript-keyword">if</span> (ltv == NULL) {
			nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s: timer scheduled in &quot;</span>
			    <span class="enscript-string">&quot;T+%llus.%lluu (demand %d)\n&quot;</span>, __func__,
			    (uint64_t)atv-&gt;tv_sec, (uint64_t)atv-&gt;tv_usec,
			    nd6_sched_timeout_want));
			nd6_fast_timer_on = TRUE;
			timeout(nd6_timeout, &amp;nd6_fast_timer_on, tvtohz(atv));
		} <span class="enscript-keyword">else</span> {
			nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s: timer scheduled in &quot;</span>
			    <span class="enscript-string">&quot;T+%llus.%lluu with %llus.%lluu leeway &quot;</span>
			    <span class="enscript-string">&quot;(demand %d)\n&quot;</span>, __func__, (uint64_t)atv-&gt;tv_sec,
			    (uint64_t)atv-&gt;tv_usec, (uint64_t)ltv-&gt;tv_sec,
			    (uint64_t)ltv-&gt;tv_usec, nd6_sched_timeout_want));
			nd6_fast_timer_on = FALSE;
			timeout_with_leeway(nd6_timeout, NULL,
			    tvtohz(atv), tvtohz(ltv));
		}
		nd6_timeout_run++;
		nd6_sched_timeout_want = 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nd6_timeout_run == 1 &amp;&amp; ltv == NULL &amp;&amp; 
	    nd6_fast_timer_on == FALSE) {
		nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s: fast timer scheduled in &quot;</span>
		    <span class="enscript-string">&quot;T+%llus.%lluu (demand %d)\n&quot;</span>, __func__,
		    (uint64_t)atv-&gt;tv_sec, (uint64_t)atv-&gt;tv_usec,
		    nd6_sched_timeout_want));
		nd6_fast_timer_on = TRUE;
		nd6_sched_timeout_want = 0;
		nd6_timeout_run++;
		timeout(nd6_timeout, &amp;nd6_fast_timer_on, tvtohz(atv));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (ltv == NULL) {
			nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s: not scheduling timer: &quot;</span>
			    <span class="enscript-string">&quot;timers %d, fast_timer %d, T+%llus.%lluu\n&quot;</span>,
			    __func__, nd6_timeout_run, nd6_fast_timer_on,
			    (uint64_t)atv-&gt;tv_sec, (uint64_t)atv-&gt;tv_usec));
		} <span class="enscript-keyword">else</span> {
			nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s: not scheduling timer: &quot;</span>
			    <span class="enscript-string">&quot;timers %d, fast_timer %d, T+%llus.%lluu &quot;</span>
			    <span class="enscript-string">&quot;with %llus.%lluu leeway\n&quot;</span>, __func__,
			    nd6_timeout_run, nd6_fast_timer_on,
			    (uint64_t)atv-&gt;tv_sec, (uint64_t)atv-&gt;tv_usec,
			    (uint64_t)ltv-&gt;tv_sec, (uint64_t)ltv-&gt;tv_usec));
		}
	}
}

<span class="enscript-comment">/*
 * ND6 router advertisement kernel notification
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_post_msg</span>(u_int32_t code, <span class="enscript-type">struct</span> nd_prefix_list *prefix_list,
    u_int32_t list_length, u_int32_t mtu, <span class="enscript-type">char</span> *dl_addr, u_int32_t dl_addr_len)
{
	<span class="enscript-type">struct</span> kev_msg ev_msg;
	<span class="enscript-type">struct</span> kev_nd6_ra_data nd6_ra_msg_data;
	<span class="enscript-type">struct</span> nd_prefix_list *itr = prefix_list;

	bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kev_msg));
	ev_msg.vendor_code	= KEV_VENDOR_APPLE;
	ev_msg.kev_class	= KEV_NETWORK_CLASS;
	ev_msg.kev_subclass	= KEV_ND6_SUBCLASS;
	ev_msg.event_code	= code;

	bzero(&amp;nd6_ra_msg_data, <span class="enscript-keyword">sizeof</span> (nd6_ra_msg_data));
	nd6_ra_msg_data.lladdrlen = (dl_addr_len &lt;= ND6_ROUTER_LL_SIZE) ?
	    dl_addr_len : ND6_ROUTER_LL_SIZE;
	bcopy(dl_addr, &amp;nd6_ra_msg_data.lladdr, nd6_ra_msg_data.lladdrlen);

	<span class="enscript-keyword">if</span> (mtu &gt; 0 &amp;&amp; mtu &gt;= IPV6_MMTU) {
		nd6_ra_msg_data.mtu = mtu;
		nd6_ra_msg_data.flags |= KEV_ND6_DATA_VALID_MTU;
	}

	<span class="enscript-keyword">if</span> (list_length &gt; 0 &amp;&amp; prefix_list != NULL) {
		nd6_ra_msg_data.list_length = list_length;
		nd6_ra_msg_data.flags |= KEV_ND6_DATA_VALID_PREFIX;
	}

	<span class="enscript-keyword">while</span> (itr != NULL &amp;&amp; nd6_ra_msg_data.list_index &lt; list_length) {
		bcopy(&amp;itr-&gt;pr.ndpr_prefix, &amp;nd6_ra_msg_data.prefix.prefix,
		    <span class="enscript-keyword">sizeof</span> (nd6_ra_msg_data.prefix.prefix));
		nd6_ra_msg_data.prefix.raflags = itr-&gt;pr.ndpr_raf;
		nd6_ra_msg_data.prefix.prefixlen = itr-&gt;pr.ndpr_plen;
		nd6_ra_msg_data.prefix.origin = PR_ORIG_RA;
		nd6_ra_msg_data.prefix.vltime = itr-&gt;pr.ndpr_vltime;
		nd6_ra_msg_data.prefix.pltime = itr-&gt;pr.ndpr_pltime;
		nd6_ra_msg_data.prefix.expire = ndpr_getexpire(&amp;itr-&gt;pr);
		nd6_ra_msg_data.prefix.flags = itr-&gt;pr.ndpr_stateflags;
		nd6_ra_msg_data.prefix.refcnt = itr-&gt;pr.ndpr_addrcnt;
		nd6_ra_msg_data.prefix.if_index = itr-&gt;pr.ndpr_ifp-&gt;if_index;

		<span class="enscript-comment">/* send the message up */</span>
		ev_msg.dv[0].data_ptr		= &amp;nd6_ra_msg_data;
		ev_msg.dv[0].data_length	= <span class="enscript-keyword">sizeof</span> (nd6_ra_msg_data);
		ev_msg.dv[1].data_length	= 0;
		kev_post_msg(&amp;ev_msg);

		<span class="enscript-comment">/* clean up for the next prefix */</span>
		bzero(&amp;nd6_ra_msg_data.prefix, <span class="enscript-keyword">sizeof</span> (nd6_ra_msg_data.prefix));
		itr = itr-&gt;next;
		nd6_ra_msg_data.list_index++;
	}
}

<span class="enscript-comment">/*
 * Regenerate deprecated/invalidated temporary address
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">regen_tmpaddr</span>(<span class="enscript-type">struct</span> in6_ifaddr *ia6)
{
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> in6_ifaddr *public_ifa6 = NULL;
	uint64_t timenow = net_uptime();

	ifp = ia6-&gt;ia_ifa.ifa_ifp;
	ifnet_lock_shared(ifp);
	TAILQ_FOREACH(ifa, &amp;ifp-&gt;if_addrlist, ifa_list) {
		<span class="enscript-type">struct</span> in6_ifaddr *it6;

		IFA_LOCK(ifa);
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}
		it6 = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;

		<span class="enscript-comment">/* ignore no autoconf addresses. */</span>
		<span class="enscript-keyword">if</span> ((it6-&gt;ia6_flags &amp; IN6_IFF_AUTOCONF) == 0) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/* ignore autoconf addresses with different prefixes. */</span>
		<span class="enscript-keyword">if</span> (it6-&gt;ia6_ndpr == NULL || it6-&gt;ia6_ndpr != ia6-&gt;ia6_ndpr) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * Now we are looking at an autoconf address with the same
		 * prefix as ours.  If the address is temporary and is still
		 * preferred, do not create another one.  It would be rare, but
		 * could happen, for example, when we resume a laptop PC after
		 * a long period.
		 */</span>
		<span class="enscript-keyword">if</span> ((it6-&gt;ia6_flags &amp; IN6_IFF_TEMPORARY) != 0 &amp;&amp;
		    !IFA6_IS_DEPRECATED(it6, timenow)) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">if</span> (public_ifa6 != NULL)
				IFA_REMREF(&amp;public_ifa6-&gt;ia_ifa);
			public_ifa6 = NULL;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * This is a public autoconf address that has the same prefix
		 * as ours.  If it is preferred, keep it.  We can't break the
		 * loop here, because there may be a still-preferred temporary
		 * address with the prefix.
		 */</span>
		<span class="enscript-keyword">if</span> (!IFA6_IS_DEPRECATED(it6, timenow)) {
			IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for public_ifa6 */</span>
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">if</span> (public_ifa6 != NULL)
				IFA_REMREF(&amp;public_ifa6-&gt;ia_ifa);
			public_ifa6 = it6;
		} <span class="enscript-keyword">else</span> {
			IFA_UNLOCK(ifa);
		}
	}
	ifnet_lock_done(ifp);

	<span class="enscript-keyword">if</span> (public_ifa6 != NULL) {
		<span class="enscript-type">int</span> e;

		<span class="enscript-keyword">if</span> ((e = in6_tmpifadd(public_ifa6, 0)) != 0) {
			log(LOG_NOTICE, <span class="enscript-string">&quot;regen_tmpaddr: failed to create a new&quot;</span>
			    <span class="enscript-string">&quot; tmp addr,errno=%d\n&quot;</span>, e);
			IFA_REMREF(&amp;public_ifa6-&gt;ia_ifa);
			<span class="enscript-keyword">return</span> (-1);
		}
		IFA_REMREF(&amp;public_ifa6-&gt;ia_ifa);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (-1);
}

<span class="enscript-comment">/*
 * Nuke neighbor cache/prefix/default router management table, right before
 * ifp goes away.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_purge</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> llinfo_nd6 *ln;
	<span class="enscript-type">struct</span> nd_defrouter *dr, *ndr;
	<span class="enscript-type">struct</span> nd_prefix *pr, *npr;
	boolean_t removed;

	<span class="enscript-comment">/* Nuke default router list entries toward ifp */</span>
	lck_mtx_lock(nd6_mutex);
	<span class="enscript-keyword">if</span> ((dr = TAILQ_FIRST(&amp;nd_defrouter)) != NULL) {
		<span class="enscript-comment">/*
		 * The first entry of the list may be stored in
		 * the routing table, so we'll delete it later.
		 */</span>
		<span class="enscript-keyword">for</span> (dr = TAILQ_NEXT(dr, dr_entry); dr; dr = ndr) {
			ndr = TAILQ_NEXT(dr, dr_entry);
			<span class="enscript-keyword">if</span> (dr-&gt;stateflags &amp; NDDRF_INSTALLED)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (dr-&gt;ifp == ifp)
				defrtrlist_del(dr);
		}
		dr = TAILQ_FIRST(&amp;nd_defrouter);
		<span class="enscript-keyword">if</span> (dr-&gt;ifp == ifp)
			defrtrlist_del(dr);
	}

	<span class="enscript-keyword">for</span> (dr = TAILQ_FIRST(&amp;nd_defrouter); dr; dr = ndr) {
		ndr = TAILQ_NEXT(dr, dr_entry);
		<span class="enscript-keyword">if</span> (!(dr-&gt;stateflags &amp; NDDRF_INSTALLED))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (dr-&gt;ifp == ifp)
			defrtrlist_del(dr);
	}

	<span class="enscript-comment">/* Nuke prefix list entries toward ifp */</span>
	removed = FALSE;
	<span class="enscript-keyword">for</span> (pr = nd_prefix.lh_first; pr; pr = npr) {
		NDPR_LOCK(pr);
		npr = pr-&gt;ndpr_next;
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_ifp == ifp &amp;&amp; 
		    !(pr-&gt;ndpr_stateflags &amp; NDPRF_DEFUNCT)) {
			<span class="enscript-comment">/*
			 * Because if_detach() does *not* release prefixes
			 * while purging addresses the reference count will
			 * still be above zero. We therefore reset it to
			 * make sure that the prefix really gets purged.
			 */</span>
			pr-&gt;ndpr_addrcnt = 0;

			<span class="enscript-comment">/*
			 * Previously, pr-&gt;ndpr_addr is removed as well,
			 * but I strongly believe we don't have to do it.
			 * nd6_purge() is only called from in6_ifdetach(),
			 * which removes all the associated interface addresses
			 * by itself.
			 * (<a href="mailto:jinmei@kame.net">jinmei@kame.net</a> 20010129)
			 */</span>
			NDPR_ADDREF_LOCKED(pr);
			prelist_remove(pr);
			NDPR_UNLOCK(pr);
			NDPR_REMREF(pr);
			removed = TRUE;
			npr = nd_prefix.lh_first;
		} <span class="enscript-keyword">else</span> {
			NDPR_UNLOCK(pr);
		}
	}
	<span class="enscript-keyword">if</span> (removed)
		pfxlist_onlink_check();
	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-comment">/* cancel default outgoing interface setting */</span>
	<span class="enscript-keyword">if</span> (nd6_defifindex == ifp-&gt;if_index) {
		nd6_setdefaultiface(0);
	}

	<span class="enscript-comment">/*
	 * Perform default router selection even when we are a router,
	 * if Scoped Routing is enabled.
	 */</span>
	<span class="enscript-keyword">if</span> (ip6_doscopedroute || !ip6_forwarding) {
		lck_mtx_lock(nd6_mutex);
		<span class="enscript-comment">/* refresh default router list */</span>
		defrouter_select(ifp);
		lck_mtx_unlock(nd6_mutex);
	}

	<span class="enscript-comment">/*
	 * Nuke neighbor cache entries for the ifp.
	 * Note that rt-&gt;rt_ifp may not be the same as ifp,
	 * due to KAME goto ours hack.  See RTM_RESOLVE case in
	 * nd6_rtrequest(), and ip6_input().
	 */</span>
<span class="enscript-reference">again</span>:
	lck_mtx_lock(rnh_lock);
	ln = llinfo_nd6.ln_next;
	<span class="enscript-keyword">while</span> (ln != NULL &amp;&amp; ln != &amp;llinfo_nd6) {
		<span class="enscript-type">struct</span> rtentry *rt;
		<span class="enscript-type">struct</span> llinfo_nd6 *nln;

		nln = ln-&gt;ln_next;
		rt = ln-&gt;ln_rt;
		RT_LOCK(rt);
		<span class="enscript-keyword">if</span> (rt-&gt;rt_gateway != NULL &amp;&amp;
		    rt-&gt;rt_gateway-&gt;sa_family == AF_LINK &amp;&amp;
		    SDL(rt-&gt;rt_gateway)-&gt;sdl_index == ifp-&gt;if_index) {
			RT_ADDREF_LOCKED(rt);
			RT_UNLOCK(rt);
			lck_mtx_unlock(rnh_lock);
			<span class="enscript-comment">/*
			 * See comments on nd6_service() for reasons why
			 * this loop is repeated; we bite the costs of
			 * going thru the same llinfo_nd6 more than once
			 * here, since this purge happens during detach,
			 * and that unlike the timer case, it's possible
			 * there's more than one purges happening at the
			 * same time (thus a flag wouldn't buy anything).
			 */</span>
			nd6_free(rt);
			RT_REMREF(rt);
			lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_NOTOWNED);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
		} <span class="enscript-keyword">else</span> {
			RT_UNLOCK(rt);
		}
		ln = nln;
	}
	lck_mtx_unlock(rnh_lock);
}

<span class="enscript-comment">/*
 * Upon success, the returned route will be locked and the caller is
 * responsible for releasing the reference and doing RT_UNLOCK(rt).
 * This routine does not require rnh_lock to be held by the caller,
 * although it needs to be indicated of such a case in order to call
 * the correct variant of the relevant routing routines.
 */</span>
<span class="enscript-type">struct</span> rtentry *
<span class="enscript-function-name">nd6_lookup</span>(<span class="enscript-type">struct</span> in6_addr *addr6, <span class="enscript-type">int</span> create, <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> rt_locked)
{
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">struct</span> sockaddr_in6 sin6;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope;

	bzero(&amp;sin6, <span class="enscript-keyword">sizeof</span> (sin6));
	sin6.sin6_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
	sin6.sin6_family = AF_INET6;
	sin6.sin6_addr = *addr6;

	ifscope = (ifp != NULL) ? ifp-&gt;if_index : IFSCOPE_NONE;
	<span class="enscript-keyword">if</span> (rt_locked) {
		lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
		rt = rtalloc1_scoped_locked(SA(&amp;sin6), create, 0, ifscope);
	} <span class="enscript-keyword">else</span> {
		rt = rtalloc1_scoped(SA(&amp;sin6), create, 0, ifscope);
	}

	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK(rt);
		<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; RTF_LLINFO) == 0) {
			<span class="enscript-comment">/*
			 * This is the case for the default route.
			 * If we want to create a neighbor cache for the
			 * address, we should free the route for the
			 * destination and allocate an interface route.
			 */</span>
			<span class="enscript-keyword">if</span> (create) {
				RT_UNLOCK(rt);
				<span class="enscript-keyword">if</span> (rt_locked)
					rtfree_locked(rt);
				<span class="enscript-keyword">else</span>
					rtfree(rt);
				rt = NULL;
			}
		}
	}
	<span class="enscript-keyword">if</span> (rt == NULL) {
		<span class="enscript-keyword">if</span> (create &amp;&amp; ifp) {
			<span class="enscript-type">struct</span> ifaddr *ifa;
			u_int32_t ifa_flags;
			<span class="enscript-type">int</span> e;

			<span class="enscript-comment">/*
			 * If no route is available and create is set,
			 * we allocate a host route for the destination
			 * and treat it like an interface route.
			 * This hack is necessary for a neighbor which can't
			 * be covered by our own prefix.
			 */</span>
			ifa = ifaof_ifpforaddr(SA(&amp;sin6), ifp);
			<span class="enscript-keyword">if</span> (ifa == NULL)
				<span class="enscript-keyword">return</span> (NULL);

			<span class="enscript-comment">/*
			 * Create a new route.  RTF_LLINFO is necessary
			 * to create a Neighbor Cache entry for the
			 * destination in nd6_rtrequest which will be
			 * called in rtrequest via ifa-&gt;ifa_rtrequest.
			 */</span>
			<span class="enscript-keyword">if</span> (!rt_locked)
				lck_mtx_lock(rnh_lock);
			IFA_LOCK_SPIN(ifa);
			ifa_flags = ifa-&gt;ifa_flags;
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">if</span> ((e = rtrequest_scoped_locked(RTM_ADD,
			    SA(&amp;sin6), ifa-&gt;ifa_addr, SA(&amp;all1_sa),
			    (ifa_flags | RTF_HOST | RTF_LLINFO) &amp;
			    ~RTF_CLONING, &amp;rt, ifscope)) != 0) {
				<span class="enscript-keyword">if</span> (e != EEXIST)
					log(LOG_ERR, <span class="enscript-string">&quot;%s: failed to add route &quot;</span>
					    <span class="enscript-string">&quot;for a neighbor(%s), errno=%d\n&quot;</span>,
					    __func__, ip6_sprintf(addr6), e);
			}
			<span class="enscript-keyword">if</span> (!rt_locked)
				lck_mtx_unlock(rnh_lock);
			IFA_REMREF(ifa);
			<span class="enscript-keyword">if</span> (rt == NULL)
				<span class="enscript-keyword">return</span> (NULL);

			RT_LOCK(rt);
			<span class="enscript-keyword">if</span> (rt-&gt;rt_llinfo) {
				<span class="enscript-type">struct</span> llinfo_nd6 *ln = rt-&gt;rt_llinfo;
				ln-&gt;ln_state = ND6_LLINFO_NOSTATE;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">return</span> (NULL);
		}
	}
	RT_LOCK_ASSERT_HELD(rt);
	<span class="enscript-comment">/*
	 * Validation for the entry.
	 * Note that the check for rt_llinfo is necessary because a cloned
	 * route from a parent route that has the L flag (e.g. the default
	 * route to a p2p interface) may have the flag, too, while the
	 * destination is not actually a neighbor.
	 * XXX: we can't use rt-&gt;rt_ifp to check for the interface, since
	 *	it might be the loopback interface if the entry is for our
	 *	own address on a non-loopback interface. Instead, we should
	 *	use rt-&gt;rt_ifa-&gt;ifa_ifp, which would specify the REAL
	 *	interface.
	 * Note also that ifa_ifp and ifp may differ when we connect two
	 * interfaces to a same link, install a link prefix to an interface,
	 * and try to install a neighbor cache on an interface that does not
	 * have a route to the prefix.
	 *
	 * If the address is from a proxied prefix, the ifa_ifp and ifp might
	 * not match, because nd6_na_input() could have modified the ifp
	 * of the route to point to the interface where the NA arrived on,
	 * hence the test for RTF_PROXY.
	 */</span>
	<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; RTF_GATEWAY) || (rt-&gt;rt_flags &amp; RTF_LLINFO) == 0 ||
	    rt-&gt;rt_gateway-&gt;sa_family != AF_LINK || rt-&gt;rt_llinfo == NULL ||
	    (ifp &amp;&amp; rt-&gt;rt_ifa-&gt;ifa_ifp != ifp &amp;&amp;
	    !(rt-&gt;rt_flags &amp; RTF_PROXY))) {
		RT_REMREF_LOCKED(rt);
		RT_UNLOCK(rt);
		<span class="enscript-keyword">if</span> (create) {
			log(LOG_DEBUG, <span class="enscript-string">&quot;%s: failed to lookup %s &quot;</span>
			    <span class="enscript-string">&quot;(if = %s)\n&quot;</span>, __func__, ip6_sprintf(addr6),
			    ifp ? if_name(ifp) : <span class="enscript-string">&quot;unspec&quot;</span>);
			<span class="enscript-comment">/* xxx more logs... kazu */</span>
		}
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-comment">/*
	 * Caller needs to release reference and call RT_UNLOCK(rt).
	 */</span>
	<span class="enscript-keyword">return</span> (rt);
}

<span class="enscript-comment">/*
 * Test whether a given IPv6 address is a neighbor or not, ignoring
 * the actual neighbor cache.  The neighbor cache is ignored in order
 * to not reenter the routing code from within itself.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_is_new_addr_neighbor</span>(<span class="enscript-type">struct</span> sockaddr_in6 *addr, <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> nd_prefix *pr;
	<span class="enscript-type">struct</span> ifaddr *dstaddr;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/*
	 * A link-local address is always a neighbor.
	 * XXX: a link does not necessarily specify a single interface.
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;addr-&gt;sin6_addr)) {
		<span class="enscript-type">struct</span> sockaddr_in6 sin6_copy;
		u_int32_t zone;

		<span class="enscript-comment">/*
		 * We need sin6_copy since sa6_recoverscope() may modify the
		 * content (XXX).
		 */</span>
		sin6_copy = *addr;
		<span class="enscript-keyword">if</span> (sa6_recoverscope(&amp;sin6_copy, FALSE))
			<span class="enscript-keyword">return</span> (0); <span class="enscript-comment">/* XXX: should be impossible */</span>
		<span class="enscript-keyword">if</span> (in6_setscope(&amp;sin6_copy.sin6_addr, ifp, &amp;zone))
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-keyword">if</span> (sin6_copy.sin6_scope_id == zone)
			<span class="enscript-keyword">return</span> (1);
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * If the address matches one of our addresses,
	 * it should be a neighbor.
	 * If the address matches one of our on-link prefixes, it should be a
	 * neighbor.
	 */</span>
	<span class="enscript-keyword">for</span> (pr = nd_prefix.lh_first; pr; pr = pr-&gt;ndpr_next) {
		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_ifp != ifp) {
			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (!(pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK)) {
			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (IN6_ARE_MASKED_ADDR_EQUAL(&amp;pr-&gt;ndpr_prefix.sin6_addr,
		    &amp;addr-&gt;sin6_addr, &amp;pr-&gt;ndpr_mask)) {
			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">return</span> (1);
		}
		NDPR_UNLOCK(pr);
	}

	<span class="enscript-comment">/*
	 * If the address is assigned on the node of the other side of
	 * a p2p interface, the address should be a neighbor.
	 */</span>
	dstaddr = ifa_ifwithdstaddr(SA(addr));
	<span class="enscript-keyword">if</span> (dstaddr != NULL) {
		<span class="enscript-keyword">if</span> (dstaddr-&gt;ifa_ifp == ifp) {
			IFA_REMREF(dstaddr);
			<span class="enscript-keyword">return</span> (1);
		}
		IFA_REMREF(dstaddr);
		dstaddr = NULL;
	}

	<span class="enscript-comment">/*
	 * If the default router list is empty, all addresses are regarded
	 * as on-link, and thus, as a neighbor.
	 * XXX: we restrict the condition to hosts, because routers usually do
	 * not have the &quot;default router list&quot;.
	 * XXX: this block should eventually be removed (it is disabled when
	 * Scoped Routing is in effect); treating all destinations as on-link
	 * in the absence of a router is rather harmful.
	 */</span>
	<span class="enscript-keyword">if</span> (!ip6_doscopedroute &amp;&amp; !ip6_forwarding &amp;&amp;
	    TAILQ_FIRST(&amp;nd_defrouter) == NULL &amp;&amp;
	    nd6_defifindex == ifp-&gt;if_index) {
		<span class="enscript-keyword">return</span> (1);
	}

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Detect if a given IPv6 address identifies a neighbor on a given link.
 * XXX: should take care of the destination of a p2p link?
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_is_addr_neighbor</span>(<span class="enscript-type">struct</span> sockaddr_in6 *addr, <span class="enscript-type">struct</span> ifnet *ifp,
    <span class="enscript-type">int</span> rt_locked)
{
	<span class="enscript-type">struct</span> rtentry *rt;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_NOTOWNED);
	lck_mtx_lock(nd6_mutex);
	<span class="enscript-keyword">if</span> (nd6_is_new_addr_neighbor(addr, ifp)) {
		lck_mtx_unlock(nd6_mutex);
		<span class="enscript-keyword">return</span> (1);
	}
	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-comment">/*
	 * Even if the address matches none of our addresses, it might be
	 * in the neighbor cache.
	 */</span>
	<span class="enscript-keyword">if</span> ((rt = nd6_lookup(&amp;addr-&gt;sin6_addr, 0, ifp, rt_locked)) != NULL) {
		RT_LOCK_ASSERT_HELD(rt);
		RT_REMREF_LOCKED(rt);
		RT_UNLOCK(rt);
		<span class="enscript-keyword">return</span> (1);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Free an nd6 llinfo entry.
 * Since the function would cause significant changes in the kernel, DO NOT
 * make it global, unless you have a strong reason for the change, and are sure
 * that the change is safe.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_free</span>(<span class="enscript-type">struct</span> rtentry *rt)
{
	<span class="enscript-type">struct</span> llinfo_nd6 *ln;
	<span class="enscript-type">struct</span> in6_addr in6;
	<span class="enscript-type">struct</span> nd_defrouter *dr;

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_NOTOWNED);
	RT_LOCK_ASSERT_NOTHELD(rt);
	lck_mtx_lock(nd6_mutex);

	RT_LOCK(rt);
	RT_ADDREF_LOCKED(rt);	<span class="enscript-comment">/* Extra ref */</span>
	ln = rt-&gt;rt_llinfo;
	in6 = SIN6(rt_key(rt))-&gt;sin6_addr;

	<span class="enscript-comment">/*
	 * Prevent another thread from modifying rt_key, rt_gateway
	 * via rt_setgate() after the rt_lock is dropped by marking
	 * the route as defunct.
	 */</span>
	rt-&gt;rt_flags |= RTF_CONDEMNED;

	<span class="enscript-comment">/*
	 * We used to have pfctlinput(PRC_HOSTDEAD) here.  Even though it is
	 * not harmful, it was not really necessary.  Perform default router
	 * selection even when we are a router, if Scoped Routing is enabled.
	 */</span>
	<span class="enscript-keyword">if</span> (ip6_doscopedroute || !ip6_forwarding) {
		dr = defrouter_lookup(&amp;SIN6(rt_key(rt))-&gt;sin6_addr, rt-&gt;rt_ifp);

		<span class="enscript-keyword">if</span> ((ln &amp;&amp; ln-&gt;ln_router) || dr) {
			<span class="enscript-comment">/*
			 * rt6_flush must be called whether or not the neighbor
			 * is in the Default Router List.
			 * See a corresponding comment in nd6_na_input().
			 */</span>
			RT_UNLOCK(rt);
			lck_mtx_unlock(nd6_mutex);
			rt6_flush(&amp;in6, rt-&gt;rt_ifp);
			lck_mtx_lock(nd6_mutex);
		} <span class="enscript-keyword">else</span> {
			RT_UNLOCK(rt);
		}

		<span class="enscript-keyword">if</span> (dr) {
			NDDR_REMREF(dr);
			<span class="enscript-comment">/*
			 * Unreachablity of a router might affect the default
			 * router selection and on-link detection of advertised
			 * prefixes.
			 */</span>

			<span class="enscript-comment">/*
			 * Temporarily fake the state to choose a new default
			 * router and to perform on-link determination of
			 * prefixes correctly.
			 * Below the state will be set correctly,
			 * or the entry itself will be deleted.
			 */</span>
			RT_LOCK_SPIN(rt);
			ln-&gt;ln_state = ND6_LLINFO_INCOMPLETE;

			<span class="enscript-comment">/*
			 * Since defrouter_select() does not affect the
			 * on-link determination and MIP6 needs the check
			 * before the default router selection, we perform
			 * the check now.
			 */</span>
			RT_UNLOCK(rt);
			pfxlist_onlink_check();

			<span class="enscript-comment">/*
			 * refresh default router list
			 */</span>
			defrouter_select(rt-&gt;rt_ifp);
		}
		RT_LOCK_ASSERT_NOTHELD(rt);
	} <span class="enscript-keyword">else</span> {
		RT_UNLOCK(rt);
	}

	lck_mtx_unlock(nd6_mutex);
	<span class="enscript-comment">/*
	 * Detach the route from the routing tree and the list of neighbor
	 * caches, and disable the route entry not to be used in already
	 * cached routes.
	 */</span>
	(<span class="enscript-type">void</span>) rtrequest(RTM_DELETE, rt_key(rt), NULL, rt_mask(rt), 0, NULL);

	<span class="enscript-comment">/* Extra ref held above; now free it */</span>
	rtfree(rt);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_rtrequest</span>(<span class="enscript-type">int</span> req, <span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">struct</span> sockaddr *sa)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">sa</span>)
	<span class="enscript-type">struct</span> sockaddr *gate = rt-&gt;rt_gateway;
	<span class="enscript-type">struct</span> llinfo_nd6 *ln = rt-&gt;rt_llinfo;
	<span class="enscript-type">static</span> <span class="enscript-type">struct</span> sockaddr_dl null_sdl =
	    { .sdl_len = <span class="enscript-keyword">sizeof</span> (null_sdl), .sdl_family = AF_LINK };
	<span class="enscript-type">struct</span> ifnet *ifp = rt-&gt;rt_ifp;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	uint64_t timenow;
	<span class="enscript-type">char</span> buf[MAX_IPv6_STR_LEN];

	VERIFY(nd6_init_done);
	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);
	RT_LOCK_ASSERT_HELD(rt);

	<span class="enscript-comment">/*
	 * We have rnh_lock held, see if we need to schedule the timer;
	 * we might do this again below during RTM_RESOLVE, but doing it
	 * now handles all other cases.
	 */</span>
	<span class="enscript-keyword">if</span> (nd6_sched_timeout_want)
		nd6_sched_timeout(NULL, NULL);

	<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_GATEWAY)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (!nd6_need_cache(ifp) &amp;&amp; !(rt-&gt;rt_flags &amp; RTF_HOST)) {
		<span class="enscript-comment">/*
		 * This is probably an interface direct route for a link
		 * which does not need neighbor caches (e.g. fe80::%lo0/64).
		 * We do not need special treatment below for such a route.
		 * Moreover, the RTF_LLINFO flag which would be set below
		 * would annoy the ndp(8) command.
		 */</span>
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (req == RTM_RESOLVE) {
		<span class="enscript-type">int</span> no_nd_cache;

		<span class="enscript-keyword">if</span> (!nd6_need_cache(ifp)) {	<span class="enscript-comment">/* stf case */</span>
			no_nd_cache = 1;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> sockaddr_in6 sin6;

			rtkey_to_sa6(rt, &amp;sin6);
			<span class="enscript-comment">/*
			 * nd6_is_addr_neighbor() may call nd6_lookup(),
			 * therefore we drop rt_lock to avoid deadlock
			 * during the lookup.
			 */</span>
			RT_ADDREF_LOCKED(rt);
			RT_UNLOCK(rt);
			no_nd_cache = !nd6_is_addr_neighbor(&amp;sin6, ifp, 1);
			RT_LOCK(rt);
			RT_REMREF_LOCKED(rt);
		}

		<span class="enscript-comment">/*
		 * FreeBSD and BSD/OS often make a cloned host route based
		 * on a less-specific route (e.g. the default route).
		 * If the less specific route does not have a &quot;gateway&quot;
		 * (this is the case when the route just goes to a p2p or an
		 * stf interface), we'll mistakenly make a neighbor cache for
		 * the host route, and will see strange neighbor solicitation
		 * for the corresponding destination.  In order to avoid the
		 * confusion, we check if the destination of the route is
		 * a neighbor in terms of neighbor discovery, and stop the
		 * process if not.  Additionally, we remove the LLINFO flag
		 * so that ndp(8) will not try to get the neighbor information
		 * of the destination.
		 */</span>
		<span class="enscript-keyword">if</span> (no_nd_cache) {
			rt-&gt;rt_flags &amp;= ~RTF_LLINFO;
			<span class="enscript-keyword">return</span>;
		}
	}

	timenow = net_uptime();

	<span class="enscript-keyword">switch</span> (req) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_ADD</span>:
		<span class="enscript-comment">/*
		 * There is no backward compatibility :)
		 *
		 * if ((rt-&gt;rt_flags &amp; RTF_HOST) == 0 &amp;&amp;
		 * 	SIN(rt_mask(rt))-&gt;sin_addr.s_addr != 0xffffffff)
		 * 		rt-&gt;rt_flags |= RTF_CLONING;
		 */</span>
		<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; RTF_CLONING) ||
		    ((rt-&gt;rt_flags &amp; RTF_LLINFO) &amp;&amp; ln == NULL)) {
			<span class="enscript-comment">/*
			 * Case 1: This route should come from a route to
			 * interface (RTF_CLONING case) or the route should be
			 * treated as on-link but is currently not
			 * (RTF_LLINFO &amp;&amp; ln == NULL case).
			 */</span>
			<span class="enscript-keyword">if</span> (rt_setgate(rt, rt_key(rt), SA(&amp;null_sdl)) == 0) {
				gate = rt-&gt;rt_gateway;
				SDL(gate)-&gt;sdl_type = ifp-&gt;if_type;
				SDL(gate)-&gt;sdl_index = ifp-&gt;if_index;
				<span class="enscript-comment">/*
				 * In case we're called before 1.0 sec.
				 * has elapsed.
				 */</span>
				<span class="enscript-keyword">if</span> (ln != NULL) {
					ln_setexpire(ln,
					    (ifp-&gt;if_eflags &amp; IFEF_IPV6_ND6ALT)
					    ? 0 : MAX(timenow, 1));
				}
			}
			<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_CLONING)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		 * In IPv4 code, we try to annonuce new RTF_ANNOUNCE entry here.
		 * We don't do that here since llinfo is not ready yet.
		 *
		 * There are also couple of other things to be discussed:
		 * - unsolicited NA code needs improvement beforehand
		 * - RFC4861 says we MAY send multicast unsolicited NA
		 *   (7.2.6 paragraph 4), however, it also says that we
		 *   SHOULD provide a mechanism to prevent multicast NA storm.
		 *   we don't have anything like it right now.
		 *   note that the mechanism needs a mutual agreement
		 *   between proxies, which means that we need to implement
		 *   a new protocol, or a new kludge.
		 * - from RFC4861 6.2.4, host MUST NOT send an unsolicited RA.
		 *   we need to check ip6forwarding before sending it.
		 *   (or should we allow proxy ND configuration only for
		 *   routers?  there's no mention about proxy ND from hosts)
		 */</span>
		<span class="enscript-comment">/* FALLTHROUGH */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_RESOLVE</span>:
		<span class="enscript-keyword">if</span> (!(ifp-&gt;if_flags &amp; (IFF_POINTOPOINT | IFF_LOOPBACK))) {
			<span class="enscript-comment">/*
			 * Address resolution isn't necessary for a point to
			 * point link, so we can skip this test for a p2p link.
			 */</span>
			<span class="enscript-keyword">if</span> (gate-&gt;sa_family != AF_LINK ||
			    gate-&gt;sa_len &lt; <span class="enscript-keyword">sizeof</span> (null_sdl)) {
				<span class="enscript-comment">/* Don't complain in case of RTM_ADD */</span>
				<span class="enscript-keyword">if</span> (req == RTM_RESOLVE) {
					log(LOG_ERR, <span class="enscript-string">&quot;%s: route to %s has bad &quot;</span>
					    <span class="enscript-string">&quot;gateway address (sa_family %u &quot;</span>
					    <span class="enscript-string">&quot;sa_len %u) on %s\n&quot;</span>, __func__,
					    inet_ntop(AF_INET6,
					    &amp;SIN6(rt_key(rt))-&gt;sin6_addr, buf,
					    <span class="enscript-keyword">sizeof</span> (buf)), gate-&gt;sa_family,
					    gate-&gt;sa_len, if_name(ifp));
				}
				<span class="enscript-keyword">break</span>;
			}
			SDL(gate)-&gt;sdl_type = ifp-&gt;if_type;
			SDL(gate)-&gt;sdl_index = ifp-&gt;if_index;
		}
		<span class="enscript-keyword">if</span> (ln != NULL)
			<span class="enscript-keyword">break</span>;	<span class="enscript-comment">/* This happens on a route change */</span>
		<span class="enscript-comment">/*
		 * Case 2: This route may come from cloning, or a manual route
		 * add with a LL address.
		 */</span>
		rt-&gt;rt_llinfo = ln = nd6_llinfo_alloc(M_WAITOK);
		<span class="enscript-keyword">if</span> (ln == NULL)
			<span class="enscript-keyword">break</span>;

		nd6_allocated++;
		rt-&gt;rt_llinfo_get_ri	= nd6_llinfo_get_ri;
		rt-&gt;rt_llinfo_get_iflri	= nd6_llinfo_get_iflri;
		rt-&gt;rt_llinfo_purge	= nd6_llinfo_purge;
		rt-&gt;rt_llinfo_free	= nd6_llinfo_free;
		rt-&gt;rt_llinfo_refresh   = nd6_llinfo_refresh;
		rt-&gt;rt_flags |= RTF_LLINFO;
		ln-&gt;ln_rt = rt;
		<span class="enscript-comment">/* this is required for &quot;ndp&quot; command. - shin */</span>
		<span class="enscript-keyword">if</span> (req == RTM_ADD) {
			<span class="enscript-comment">/*
			 * gate should have some valid AF_LINK entry,
			 * and ln-&gt;ln_expire should have some lifetime
			 * which is specified by ndp command.
			 */</span>
			ln-&gt;ln_state = ND6_LLINFO_REACHABLE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * When req == RTM_RESOLVE, rt is created and
			 * initialized in rtrequest(), so rt_expire is 0.
			 */</span>
			ln-&gt;ln_state = ND6_LLINFO_NOSTATE;

			<span class="enscript-comment">/* In case we're called before 1.0 sec. has elapsed */</span>
			ln_setexpire(ln, (ifp-&gt;if_eflags &amp; IFEF_IPV6_ND6ALT) ?
			    0 : MAX(timenow, 1));
		}
		LN_INSERTHEAD(ln);
		nd6_inuse++;

		<span class="enscript-comment">/* We have at least one entry; arm the timer if not already */</span>
		nd6_sched_timeout(NULL, NULL);

		<span class="enscript-comment">/*
		 * If we have too many cache entries, initiate immediate
		 * purging for some &quot;less recently used&quot; entries.  Note that
		 * we cannot directly call nd6_free() here because it would
		 * cause re-entering rtable related routines triggering an LOR
		 * problem.
		 */</span>
		<span class="enscript-keyword">if</span> (ip6_neighborgcthresh &gt; 0 &amp;&amp;
		    nd6_inuse &gt;= ip6_neighborgcthresh) {
			<span class="enscript-type">int</span> i;

			<span class="enscript-keyword">for</span> (i = 0; i &lt; 10 &amp;&amp; llinfo_nd6.ln_prev != ln; i++) {
				<span class="enscript-type">struct</span> llinfo_nd6 *ln_end = llinfo_nd6.ln_prev;
				<span class="enscript-type">struct</span> rtentry *rt_end = ln_end-&gt;ln_rt;

				<span class="enscript-comment">/* Move this entry to the head */</span>
				RT_LOCK(rt_end);
				LN_DEQUEUE(ln_end);
				LN_INSERTHEAD(ln_end);

				<span class="enscript-keyword">if</span> (ln_end-&gt;ln_expire == 0) {
					RT_UNLOCK(rt_end);
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">if</span> (ln_end-&gt;ln_state &gt; ND6_LLINFO_INCOMPLETE)
					ln_end-&gt;ln_state = ND6_LLINFO_STALE;
				<span class="enscript-keyword">else</span>
					ln_end-&gt;ln_state = ND6_LLINFO_PURGE;
				ln_setexpire(ln_end, timenow);
				RT_UNLOCK(rt_end);
			}
		}

		<span class="enscript-comment">/*
		 * check if rt_key(rt) is one of my address assigned
		 * to the interface.
		 */</span>
		ifa = (<span class="enscript-type">struct</span> ifaddr *)in6ifa_ifpwithaddr(rt-&gt;rt_ifp,
		    &amp;SIN6(rt_key(rt))-&gt;sin6_addr);
		<span class="enscript-keyword">if</span> (ifa != NULL) {
			caddr_t macp = nd6_ifptomac(ifp);
			ln_setexpire(ln, 0);
			ln-&gt;ln_state = ND6_LLINFO_REACHABLE;
			<span class="enscript-keyword">if</span> (macp != NULL) {
				Bcopy(macp, LLADDR(SDL(gate)), ifp-&gt;if_addrlen);
				SDL(gate)-&gt;sdl_alen = ifp-&gt;if_addrlen;
			}
			<span class="enscript-keyword">if</span> (nd6_useloopback) {
				<span class="enscript-keyword">if</span> (rt-&gt;rt_ifp != lo_ifp) {
					<span class="enscript-comment">/*
					 * Purge any link-layer info caching.
					 */</span>
					<span class="enscript-keyword">if</span> (rt-&gt;rt_llinfo_purge != NULL)
						rt-&gt;rt_llinfo_purge(rt);

					<span class="enscript-comment">/*
					 * Adjust route ref count for the
					 * interfaces.
					 */</span>
					<span class="enscript-keyword">if</span> (rt-&gt;rt_if_ref_fn != NULL) {
						rt-&gt;rt_if_ref_fn(lo_ifp, 1);
						rt-&gt;rt_if_ref_fn(rt-&gt;rt_ifp,
						    -1);
					}
				}
				rt-&gt;rt_ifp = lo_ifp;
				<span class="enscript-comment">/*
				 * If rmx_mtu is not locked, update it
				 * to the MTU used by the new interface.
				 */</span>
				<span class="enscript-keyword">if</span> (!(rt-&gt;rt_rmx.rmx_locks &amp; RTV_MTU))
					rt-&gt;rt_rmx.rmx_mtu = rt-&gt;rt_ifp-&gt;if_mtu;
				<span class="enscript-comment">/*
				 * Make sure rt_ifa be equal to the ifaddr
				 * corresponding to the address.
				 * We need this because when we refer
				 * rt_ifa-&gt;ia6_flags in ip6_input, we assume
				 * that the rt_ifa points to the address instead
				 * of the loopback address.
				 */</span>
				<span class="enscript-keyword">if</span> (ifa != rt-&gt;rt_ifa) {
					rtsetifa(rt, ifa);
				}
			}
			IFA_REMREF(ifa);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_ANNOUNCE) {
			ln_setexpire(ln, 0);
			ln-&gt;ln_state = ND6_LLINFO_REACHABLE;

			<span class="enscript-comment">/* join solicited node multicast for proxy ND */</span>
			<span class="enscript-keyword">if</span> (ifp-&gt;if_flags &amp; IFF_MULTICAST) {
				<span class="enscript-type">struct</span> in6_addr llsol;
				<span class="enscript-type">struct</span> in6_multi *in6m;
				<span class="enscript-type">int</span> error;

				llsol = SIN6(rt_key(rt))-&gt;sin6_addr;
				llsol.s6_addr32[0] = IPV6_ADDR_INT32_MLL;
				llsol.s6_addr32[1] = 0;
				llsol.s6_addr32[2] = htonl(1);
				llsol.s6_addr8[12] = 0xff;
				<span class="enscript-keyword">if</span> (in6_setscope(&amp;llsol, ifp, NULL))
					<span class="enscript-keyword">break</span>;
				error = in6_mc_join(ifp, &amp;llsol,
				    NULL, &amp;in6m, 0);
				<span class="enscript-keyword">if</span> (error) {
					nd6log((LOG_ERR, <span class="enscript-string">&quot;%s: failed to join &quot;</span>
					    <span class="enscript-string">&quot;%s (errno=%d)\n&quot;</span>, if_name(ifp),
					    ip6_sprintf(&amp;llsol), error));
				} <span class="enscript-keyword">else</span> {
					IN6M_REMREF(in6m);
				}
			}
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RTM_DELETE</span>:
		<span class="enscript-keyword">if</span> (ln == NULL)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* leave from solicited node multicast for proxy ND */</span>
		<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; RTF_ANNOUNCE) &amp;&amp;
		    (ifp-&gt;if_flags &amp; IFF_MULTICAST)) {
			<span class="enscript-type">struct</span> in6_addr llsol;
			<span class="enscript-type">struct</span> in6_multi *in6m;

			llsol = SIN6(rt_key(rt))-&gt;sin6_addr;
			llsol.s6_addr32[0] = IPV6_ADDR_INT32_MLL;
			llsol.s6_addr32[1] = 0;
			llsol.s6_addr32[2] = htonl(1);
			llsol.s6_addr8[12] = 0xff;
			<span class="enscript-keyword">if</span> (in6_setscope(&amp;llsol, ifp, NULL) == 0) {
				in6_multihead_lock_shared();
				IN6_LOOKUP_MULTI(&amp;llsol, ifp, in6m);
				in6_multihead_lock_done();
				<span class="enscript-keyword">if</span> (in6m != NULL) {
					in6_mc_leave(in6m, NULL);
					IN6M_REMREF(in6m);
				}
			}
		}
		nd6_inuse--;
		<span class="enscript-comment">/*
		 * Unchain it but defer the actual freeing until the route
		 * itself is to be freed.  rt-&gt;rt_llinfo still points to
		 * llinfo_nd6, and likewise, ln-&gt;ln_rt stil points to this
		 * route entry, except that RTF_LLINFO is now cleared.
		 */</span>
		<span class="enscript-keyword">if</span> (ln-&gt;ln_flags &amp; ND6_LNF_IN_USE)
			LN_DEQUEUE(ln);

		<span class="enscript-comment">/*
		 * Purge any link-layer info caching.
		 */</span>
		<span class="enscript-keyword">if</span> (rt-&gt;rt_llinfo_purge != NULL)
			rt-&gt;rt_llinfo_purge(rt);

		rt-&gt;rt_flags &amp;= ~RTF_LLINFO;
		<span class="enscript-keyword">if</span> (ln-&gt;ln_hold != NULL) {
			m_freem_list(ln-&gt;ln_hold);
			ln-&gt;ln_hold = NULL;
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_siocgdrlst</span>(<span class="enscript-type">void</span> *data, <span class="enscript-type">int</span> data_is_64)
{
	<span class="enscript-type">struct</span> in6_drlist_32 *drl_32;
	<span class="enscript-type">struct</span> nd_defrouter *dr;
	<span class="enscript-type">int</span> i = 0;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);

	dr = TAILQ_FIRST(&amp;nd_defrouter);

	<span class="enscript-comment">/* For 64-bit process */</span>
	<span class="enscript-keyword">if</span> (data_is_64) {
		<span class="enscript-type">struct</span> in6_drlist_64 *drl_64;

		drl_64 = _MALLOC(<span class="enscript-keyword">sizeof</span> (*drl_64), M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (drl_64 == NULL)
			<span class="enscript-keyword">return</span> (ENOMEM);

		<span class="enscript-comment">/* preserve the interface name */</span>
		bcopy(data, drl_64, <span class="enscript-keyword">sizeof</span> (drl_64-&gt;ifname));

		<span class="enscript-keyword">while</span> (dr &amp;&amp; i &lt; DRLSTSIZ) {
			drl_64-&gt;defrouter[i].rtaddr = dr-&gt;rtaddr;
			<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(
			    &amp;drl_64-&gt;defrouter[i].rtaddr)) {
				<span class="enscript-comment">/* XXX: need to this hack for KAME stack */</span>
				drl_64-&gt;defrouter[i].rtaddr.s6_addr16[1] = 0;
			} <span class="enscript-keyword">else</span> {
				log(LOG_ERR,
				    <span class="enscript-string">&quot;default router list contains a &quot;</span>
				    <span class="enscript-string">&quot;non-linklocal address(%s)\n&quot;</span>,
				    ip6_sprintf(&amp;drl_64-&gt;defrouter[i].rtaddr));
			}
			drl_64-&gt;defrouter[i].flags = dr-&gt;flags;
			drl_64-&gt;defrouter[i].rtlifetime = dr-&gt;rtlifetime;
			drl_64-&gt;defrouter[i].expire = nddr_getexpire(dr);
			drl_64-&gt;defrouter[i].if_index = dr-&gt;ifp-&gt;if_index;
			i++;
			dr = TAILQ_NEXT(dr, dr_entry);
		}
		bcopy(drl_64, data, <span class="enscript-keyword">sizeof</span> (*drl_64));
		_FREE(drl_64, M_TEMP);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* For 32-bit process */</span>
	drl_32 = _MALLOC(<span class="enscript-keyword">sizeof</span> (*drl_32), M_TEMP, M_WAITOK|M_ZERO);
	<span class="enscript-keyword">if</span> (drl_32 == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	<span class="enscript-comment">/* preserve the interface name */</span>
	bcopy(data, drl_32, <span class="enscript-keyword">sizeof</span> (drl_32-&gt;ifname));

	<span class="enscript-keyword">while</span> (dr != NULL &amp;&amp; i &lt; DRLSTSIZ) {
		drl_32-&gt;defrouter[i].rtaddr = dr-&gt;rtaddr;
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;drl_32-&gt;defrouter[i].rtaddr)) {
			<span class="enscript-comment">/* XXX: need to this hack for KAME stack */</span>
			drl_32-&gt;defrouter[i].rtaddr.s6_addr16[1] = 0;
		} <span class="enscript-keyword">else</span> {
			log(LOG_ERR,
			    <span class="enscript-string">&quot;default router list contains a &quot;</span>
			    <span class="enscript-string">&quot;non-linklocal address(%s)\n&quot;</span>,
			    ip6_sprintf(&amp;drl_32-&gt;defrouter[i].rtaddr));
		}
		drl_32-&gt;defrouter[i].flags = dr-&gt;flags;
		drl_32-&gt;defrouter[i].rtlifetime = dr-&gt;rtlifetime;
		drl_32-&gt;defrouter[i].expire = nddr_getexpire(dr);
		drl_32-&gt;defrouter[i].if_index = dr-&gt;ifp-&gt;if_index;
		i++;
		dr = TAILQ_NEXT(dr, dr_entry);
	}
	bcopy(drl_32, data, <span class="enscript-keyword">sizeof</span> (*drl_32));
	_FREE(drl_32, M_TEMP);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * XXX meaning of fields, especialy &quot;raflags&quot;, is very
 * differnet between RA prefix list and RR/static prefix list.
 * how about separating ioctls into two?
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_siocgprlst</span>(<span class="enscript-type">void</span> *data, <span class="enscript-type">int</span> data_is_64)
{
	<span class="enscript-type">struct</span> in6_prlist_32 *prl_32;
	<span class="enscript-type">struct</span> nd_prefix *pr;
	<span class="enscript-type">int</span> i = 0;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);

	pr = nd_prefix.lh_first;

	<span class="enscript-comment">/* For 64-bit process */</span>
	<span class="enscript-keyword">if</span> (data_is_64) {
		<span class="enscript-type">struct</span> in6_prlist_64 *prl_64;

		prl_64 = _MALLOC(<span class="enscript-keyword">sizeof</span> (*prl_64), M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (prl_64 == NULL)
			<span class="enscript-keyword">return</span> (ENOMEM);

		<span class="enscript-comment">/* preserve the interface name */</span>
		bcopy(data, prl_64, <span class="enscript-keyword">sizeof</span> (prl_64-&gt;ifname));

		<span class="enscript-keyword">while</span> (pr &amp;&amp; i &lt; PRLSTSIZ) {
			<span class="enscript-type">struct</span> nd_pfxrouter *pfr;
			<span class="enscript-type">int</span> j;

			NDPR_LOCK(pr);
			(<span class="enscript-type">void</span>) in6_embedscope(&amp;prl_64-&gt;prefix[i].prefix,
			    &amp;pr-&gt;ndpr_prefix, NULL, NULL, NULL);
			prl_64-&gt;prefix[i].raflags = pr-&gt;ndpr_raf;
			prl_64-&gt;prefix[i].prefixlen = pr-&gt;ndpr_plen;
			prl_64-&gt;prefix[i].vltime = pr-&gt;ndpr_vltime;
			prl_64-&gt;prefix[i].pltime = pr-&gt;ndpr_pltime;
			prl_64-&gt;prefix[i].if_index = pr-&gt;ndpr_ifp-&gt;if_index;
			prl_64-&gt;prefix[i].expire = ndpr_getexpire(pr);

			pfr = pr-&gt;ndpr_advrtrs.lh_first;
			j = 0;
			<span class="enscript-keyword">while</span> (pfr) {
				<span class="enscript-keyword">if</span> (j &lt; DRLSTSIZ) {
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTRADDR</span> prl_64-&gt;prefix[i].advrtr[j]
					RTRADDR = pfr-&gt;router-&gt;rtaddr;
					<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;RTRADDR)) {
						<span class="enscript-comment">/* XXX: hack for KAME */</span>
						RTRADDR.s6_addr16[1] = 0;
					} <span class="enscript-keyword">else</span> {
						log(LOG_ERR,
						    <span class="enscript-string">&quot;a router(%s) advertises &quot;</span>
						    <span class="enscript-string">&quot;a prefix with &quot;</span>
						    <span class="enscript-string">&quot;non-link local address\n&quot;</span>,
						    ip6_sprintf(&amp;RTRADDR));
					}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">RTRADDR</span>
				}
				j++;
				pfr = pfr-&gt;pfr_next;
			}
			prl_64-&gt;prefix[i].advrtrs = j;
			prl_64-&gt;prefix[i].origin = PR_ORIG_RA;
			NDPR_UNLOCK(pr);

			i++;
			pr = pr-&gt;ndpr_next;
		}
		bcopy(prl_64, data, <span class="enscript-keyword">sizeof</span> (*prl_64));
		_FREE(prl_64, M_TEMP);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* For 32-bit process */</span>
	prl_32 = _MALLOC(<span class="enscript-keyword">sizeof</span> (*prl_32), M_TEMP, M_WAITOK|M_ZERO);
	<span class="enscript-keyword">if</span> (prl_32 == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	<span class="enscript-comment">/* preserve the interface name */</span>
	bcopy(data, prl_32, <span class="enscript-keyword">sizeof</span> (prl_32-&gt;ifname));

	<span class="enscript-keyword">while</span> (pr &amp;&amp; i &lt; PRLSTSIZ) {
		<span class="enscript-type">struct</span> nd_pfxrouter *pfr;
		<span class="enscript-type">int</span> j;

		NDPR_LOCK(pr);
		(<span class="enscript-type">void</span>) in6_embedscope(&amp;prl_32-&gt;prefix[i].prefix,
		    &amp;pr-&gt;ndpr_prefix, NULL, NULL, NULL);
		prl_32-&gt;prefix[i].raflags = pr-&gt;ndpr_raf;
		prl_32-&gt;prefix[i].prefixlen = pr-&gt;ndpr_plen;
		prl_32-&gt;prefix[i].vltime = pr-&gt;ndpr_vltime;
		prl_32-&gt;prefix[i].pltime = pr-&gt;ndpr_pltime;
		prl_32-&gt;prefix[i].if_index = pr-&gt;ndpr_ifp-&gt;if_index;
		prl_32-&gt;prefix[i].expire = ndpr_getexpire(pr);

		pfr = pr-&gt;ndpr_advrtrs.lh_first;
		j = 0;
		<span class="enscript-keyword">while</span> (pfr) {
			<span class="enscript-keyword">if</span> (j &lt; DRLSTSIZ) {
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTRADDR</span> prl_32-&gt;prefix[i].advrtr[j]
				RTRADDR = pfr-&gt;router-&gt;rtaddr;
				<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;RTRADDR)) {
					<span class="enscript-comment">/* XXX: hack for KAME */</span>
					RTRADDR.s6_addr16[1] = 0;
				} <span class="enscript-keyword">else</span> {
					log(LOG_ERR,
					    <span class="enscript-string">&quot;a router(%s) advertises &quot;</span>
					    <span class="enscript-string">&quot;a prefix with &quot;</span>
					    <span class="enscript-string">&quot;non-link local address\n&quot;</span>,
					    ip6_sprintf(&amp;RTRADDR));
				}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">RTRADDR</span>
			}
			j++;
			pfr = pfr-&gt;pfr_next;
		}
		prl_32-&gt;prefix[i].advrtrs = j;
		prl_32-&gt;prefix[i].origin = PR_ORIG_RA;
		NDPR_UNLOCK(pr);

		i++;
		pr = pr-&gt;ndpr_next;
	}
	bcopy(prl_32, data, <span class="enscript-keyword">sizeof</span> (*prl_32));
	_FREE(prl_32, M_TEMP);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_ioctl</span>(u_long cmd, caddr_t data, <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> nd_defrouter *dr;
	<span class="enscript-type">struct</span> nd_prefix *pr;
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">int</span> error = 0;

	VERIFY(ifp != NULL);

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDRLST_IN6_32</span>:		<span class="enscript-comment">/* struct in6_drlist_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDRLST_IN6_64</span>:		<span class="enscript-comment">/* struct in6_drlist_64 */</span>
		<span class="enscript-comment">/*
		 * obsolete API, use sysctl under net.inet6.icmp6
		 */</span>
		lck_mtx_lock(nd6_mutex);
		error = nd6_siocgdrlst(data, cmd == SIOCGDRLST_IN6_64);
		lck_mtx_unlock(nd6_mutex);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGPRLST_IN6_32</span>:		<span class="enscript-comment">/* struct in6_prlist_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGPRLST_IN6_64</span>:		<span class="enscript-comment">/* struct in6_prlist_64 */</span>
		<span class="enscript-comment">/*
		 * obsolete API, use sysctl under net.inet6.icmp6
		 */</span>
		lck_mtx_lock(nd6_mutex);
		error = nd6_siocgprlst(data, cmd == SIOCGPRLST_IN6_64);
		lck_mtx_unlock(nd6_mutex);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFINFO_IN6</span>:		<span class="enscript-comment">/* struct in6_ondireq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFINFO_IN6</span>: {		<span class="enscript-comment">/* struct in6_ondireq */</span>
		u_int32_t linkmtu;
		<span class="enscript-type">struct</span> in6_ondireq *ondi = (<span class="enscript-type">struct</span> in6_ondireq *)(<span class="enscript-type">void</span> *)data;
		<span class="enscript-type">struct</span> nd_ifinfo *ndi;
		<span class="enscript-comment">/*
		 * SIOCGIFINFO_IN6 ioctl is encoded with in6_ondireq
		 * instead of in6_ndireq, so we treat it as such.
		 */</span>
		ndi = ND_IFINFO(ifp);
		<span class="enscript-keyword">if</span> ((NULL == ndi) || (FALSE == ndi-&gt;initialized)){
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		lck_mtx_lock(&amp;ndi-&gt;lock);
		linkmtu = IN6_LINKMTU(ifp);
		bcopy(&amp;linkmtu, &amp;ondi-&gt;ndi.linkmtu, <span class="enscript-keyword">sizeof</span> (linkmtu));
		bcopy(&amp;ndi-&gt;maxmtu, &amp;ondi-&gt;ndi.maxmtu,
		    <span class="enscript-keyword">sizeof</span> (u_int32_t));
		bcopy(&amp;ndi-&gt;basereachable, &amp;ondi-&gt;ndi.basereachable,
		    <span class="enscript-keyword">sizeof</span> (u_int32_t));
		bcopy(&amp;ndi-&gt;reachable, &amp;ondi-&gt;ndi.reachable,
		    <span class="enscript-keyword">sizeof</span> (u_int32_t));
		bcopy(&amp;ndi-&gt;retrans, &amp;ondi-&gt;ndi.retrans,
		    <span class="enscript-keyword">sizeof</span> (u_int32_t));
		bcopy(&amp;ndi-&gt;flags, &amp;ondi-&gt;ndi.flags,
		    <span class="enscript-keyword">sizeof</span> (u_int32_t));
		bcopy(&amp;ndi-&gt;recalctm, &amp;ondi-&gt;ndi.recalctm,
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>));
		ondi-&gt;ndi.chlim = ndi-&gt;chlim;
		ondi-&gt;ndi.receivedra = 0;
		lck_mtx_unlock(&amp;ndi-&gt;lock);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFINFO_FLAGS</span>:	{	<span class="enscript-comment">/* struct in6_ndireq */</span>
		<span class="enscript-comment">/*
		 * XXX BSD has a bunch of checks here to ensure
		 * that interface disabled flag is not reset if
		 * link local address has failed DAD.
		 * Investigate that part.
		 */</span>
		<span class="enscript-type">struct</span> in6_ndireq *cndi = (<span class="enscript-type">struct</span> in6_ndireq *)(<span class="enscript-type">void</span> *)data;
		u_int32_t oflags, flags;
		<span class="enscript-type">struct</span> nd_ifinfo *ndi = ND_IFINFO(ifp);

		<span class="enscript-comment">/* XXX: almost all other fields of cndi-&gt;ndi is unused */</span>
		<span class="enscript-keyword">if</span> ((NULL == ndi) || !ndi-&gt;initialized) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}

		lck_mtx_lock(&amp;ndi-&gt;lock);
		oflags = ndi-&gt;flags;
		bcopy(&amp;cndi-&gt;ndi.flags, &amp;(ndi-&gt;flags), <span class="enscript-keyword">sizeof</span> (flags));
		flags = ndi-&gt;flags;
		lck_mtx_unlock(&amp;ndi-&gt;lock);

		<span class="enscript-keyword">if</span> (oflags == flags) {
			<span class="enscript-keyword">break</span>;
		}

		error = nd6_setifinfo(ifp, oflags, flags);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSNDFLUSH_IN6</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-comment">/* flush default router list */</span>
		<span class="enscript-comment">/*
		 * xxx sumikawa: should not delete route if default
		 * route equals to the top of default router list
		 */</span>
		lck_mtx_lock(nd6_mutex);
		defrouter_reset();
		defrouter_select(ifp);
		lck_mtx_unlock(nd6_mutex);
		<span class="enscript-comment">/* xxx sumikawa: flush prefix list */</span>
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSPFXFLUSH_IN6</span>: {	<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-comment">/* flush all the prefix advertised by routers */</span>
		<span class="enscript-type">struct</span> nd_prefix *next;

		lck_mtx_lock(nd6_mutex);
		<span class="enscript-keyword">for</span> (pr = nd_prefix.lh_first; pr; pr = next) {
			<span class="enscript-type">struct</span> in6_ifaddr *ia;

			next = pr-&gt;ndpr_next;

			NDPR_LOCK(pr);
			<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;pr-&gt;ndpr_prefix.sin6_addr)) {
				NDPR_UNLOCK(pr);
				<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* XXX */</span>
			}
			<span class="enscript-keyword">if</span> (ifp != lo_ifp &amp;&amp; pr-&gt;ndpr_ifp != ifp) {
				NDPR_UNLOCK(pr);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-comment">/* do we really have to remove addresses as well? */</span>
			NDPR_ADDREF_LOCKED(pr);
			NDPR_UNLOCK(pr);
			lck_rw_lock_exclusive(&amp;in6_ifaddr_rwlock);
			ia = in6_ifaddrs;
			<span class="enscript-keyword">while</span> (ia != NULL) {
				IFA_LOCK(&amp;ia-&gt;ia_ifa);
				<span class="enscript-keyword">if</span> ((ia-&gt;ia6_flags &amp; IN6_IFF_AUTOCONF) == 0) {
					IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
					ia = ia-&gt;ia_next;
					<span class="enscript-keyword">continue</span>;
				}

				<span class="enscript-keyword">if</span> (ia-&gt;ia6_ndpr == pr) {
					IFA_ADDREF_LOCKED(&amp;ia-&gt;ia_ifa);
					IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
					lck_rw_done(&amp;in6_ifaddr_rwlock);
					lck_mtx_unlock(nd6_mutex);
					in6_purgeaddr(&amp;ia-&gt;ia_ifa);
					IFA_REMREF(&amp;ia-&gt;ia_ifa);
					lck_mtx_lock(nd6_mutex);
					lck_rw_lock_exclusive(
					    &amp;in6_ifaddr_rwlock);
					<span class="enscript-comment">/*
					 * Purging the address caused
					 * in6_ifaddr_rwlock to be
					 * dropped and
					 * reacquired; therefore search again
					 * from the beginning of in6_ifaddrs.
					 * The same applies for the prefix list.
					 */</span>
					ia = in6_ifaddrs;
					next = nd_prefix.lh_first;
					<span class="enscript-keyword">continue</span>;

				}
				IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
				ia = ia-&gt;ia_next;
			}
			lck_rw_done(&amp;in6_ifaddr_rwlock);
			NDPR_LOCK(pr);
			prelist_remove(pr);
			NDPR_UNLOCK(pr);
			pfxlist_onlink_check();
			<span class="enscript-comment">/*
			 * If we were trying to restart this loop
			 * above by changing the value of 'next', we might
			 * end up freeing the only element on the list
			 * when we call NDPR_REMREF().
			 * When this happens, we also have get out of this
			 * loop because we have nothing else to do.
			 */</span>
			<span class="enscript-keyword">if</span> (pr == next)
				next = NULL;
			NDPR_REMREF(pr);
		}
		lck_mtx_unlock(nd6_mutex);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSRTRFLUSH_IN6</span>: {	<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-comment">/* flush all the default routers */</span>
		<span class="enscript-type">struct</span> nd_defrouter *next;

		lck_mtx_lock(nd6_mutex);
		<span class="enscript-keyword">if</span> ((dr = TAILQ_FIRST(&amp;nd_defrouter)) != NULL) {
			<span class="enscript-comment">/*
			 * The first entry of the list may be stored in
			 * the routing table, so we'll delete it later.
			 */</span>
			<span class="enscript-keyword">for</span> (dr = TAILQ_NEXT(dr, dr_entry); dr; dr = next) {
				next = TAILQ_NEXT(dr, dr_entry);
				<span class="enscript-keyword">if</span> (ifp == lo_ifp || dr-&gt;ifp == ifp)
					defrtrlist_del(dr);
			}
			<span class="enscript-keyword">if</span> (ifp == lo_ifp ||
			    TAILQ_FIRST(&amp;nd_defrouter)-&gt;ifp == ifp)
				defrtrlist_del(TAILQ_FIRST(&amp;nd_defrouter));
		}
		lck_mtx_unlock(nd6_mutex);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGNBRINFO_IN6_32</span>: {	<span class="enscript-comment">/* struct in6_nbrinfo_32 */</span>
		<span class="enscript-type">struct</span> llinfo_nd6 *ln;
		<span class="enscript-type">struct</span> in6_nbrinfo_32 nbi_32;
		<span class="enscript-type">struct</span> in6_addr nb_addr; <span class="enscript-comment">/* make local for safety */</span>

		bcopy(data, &amp;nbi_32, <span class="enscript-keyword">sizeof</span> (nbi_32));
		nb_addr = nbi_32.addr;
		<span class="enscript-comment">/*
		 * XXX: KAME specific hack for scoped addresses
		 * 	XXXX: for other scopes than link-local?
		 */</span>
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;nbi_32.addr) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(&amp;nbi_32.addr)) {
			u_int16_t *idp =
			    (u_int16_t *)(<span class="enscript-type">void</span> *)&amp;nb_addr.s6_addr[2];

			<span class="enscript-keyword">if</span> (*idp == 0)
				*idp = htons(ifp-&gt;if_index);
		}

		<span class="enscript-comment">/* Callee returns a locked route upon success */</span>
		<span class="enscript-keyword">if</span> ((rt = nd6_lookup(&amp;nb_addr, 0, ifp, 0)) == NULL) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		RT_LOCK_ASSERT_HELD(rt);
		ln = rt-&gt;rt_llinfo;
		nbi_32.state = ln-&gt;ln_state;
		nbi_32.asked = ln-&gt;ln_asked;
		nbi_32.isrouter = ln-&gt;ln_router;
		nbi_32.expire = ln_getexpire(ln);
		RT_REMREF_LOCKED(rt);
		RT_UNLOCK(rt);
		bcopy(&amp;nbi_32, data, <span class="enscript-keyword">sizeof</span> (nbi_32));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGNBRINFO_IN6_64</span>: {	<span class="enscript-comment">/* struct in6_nbrinfo_64 */</span>
		<span class="enscript-type">struct</span> llinfo_nd6 *ln;
		<span class="enscript-type">struct</span> in6_nbrinfo_64 nbi_64;
		<span class="enscript-type">struct</span> in6_addr nb_addr; <span class="enscript-comment">/* make local for safety */</span>

		bcopy(data, &amp;nbi_64, <span class="enscript-keyword">sizeof</span> (nbi_64));
		nb_addr = nbi_64.addr;
		<span class="enscript-comment">/*
		 * XXX: KAME specific hack for scoped addresses
		 * 	XXXX: for other scopes than link-local?
		 */</span>
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;nbi_64.addr) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(&amp;nbi_64.addr)) {
			u_int16_t *idp =
			    (u_int16_t *)(<span class="enscript-type">void</span> *)&amp;nb_addr.s6_addr[2];

			<span class="enscript-keyword">if</span> (*idp == 0)
				*idp = htons(ifp-&gt;if_index);
		}

		<span class="enscript-comment">/* Callee returns a locked route upon success */</span>
		<span class="enscript-keyword">if</span> ((rt = nd6_lookup(&amp;nb_addr, 0, ifp, 0)) == NULL) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		RT_LOCK_ASSERT_HELD(rt);
		ln = rt-&gt;rt_llinfo;
		nbi_64.state = ln-&gt;ln_state;
		nbi_64.asked = ln-&gt;ln_asked;
		nbi_64.isrouter = ln-&gt;ln_router;
		nbi_64.expire = ln_getexpire(ln);
		RT_REMREF_LOCKED(rt);
		RT_UNLOCK(rt);
		bcopy(&amp;nbi_64, data, <span class="enscript-keyword">sizeof</span> (nbi_64));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDEFIFACE_IN6_32</span>:	<span class="enscript-comment">/* struct in6_ndifreq_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDEFIFACE_IN6_64</span>: {	<span class="enscript-comment">/* struct in6_ndifreq_64 */</span>
		<span class="enscript-type">struct</span> in6_ndifreq_64 *ndif_64 =
		    (<span class="enscript-type">struct</span> in6_ndifreq_64 *)(<span class="enscript-type">void</span> *)data;
		<span class="enscript-type">struct</span> in6_ndifreq_32 *ndif_32 =
		    (<span class="enscript-type">struct</span> in6_ndifreq_32 *)(<span class="enscript-type">void</span> *)data;

		<span class="enscript-keyword">if</span> (cmd == SIOCGDEFIFACE_IN6_64) {
			u_int64_t j = nd6_defifindex;
			bcopy(&amp;j, &amp;ndif_64-&gt;ifindex, <span class="enscript-keyword">sizeof</span> (j));
		} <span class="enscript-keyword">else</span> {
			bcopy(&amp;nd6_defifindex, &amp;ndif_32-&gt;ifindex,
			    <span class="enscript-keyword">sizeof</span> (u_int32_t));
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSDEFIFACE_IN6_32</span>:	<span class="enscript-comment">/* struct in6_ndifreq_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSDEFIFACE_IN6_64</span>: {	<span class="enscript-comment">/* struct in6_ndifreq_64 */</span>
		<span class="enscript-type">struct</span> in6_ndifreq_64 *ndif_64 =
		    (<span class="enscript-type">struct</span> in6_ndifreq_64 *)(<span class="enscript-type">void</span> *)data;
		<span class="enscript-type">struct</span> in6_ndifreq_32 *ndif_32 =
		    (<span class="enscript-type">struct</span> in6_ndifreq_32 *)(<span class="enscript-type">void</span> *)data;
		u_int32_t idx;

		<span class="enscript-keyword">if</span> (cmd == SIOCSDEFIFACE_IN6_64) {
			u_int64_t j;
			bcopy(&amp;ndif_64-&gt;ifindex, &amp;j, <span class="enscript-keyword">sizeof</span> (j));
			idx = (u_int32_t)j;
		} <span class="enscript-keyword">else</span> {
			bcopy(&amp;ndif_32-&gt;ifindex, &amp;idx, <span class="enscript-keyword">sizeof</span> (idx));
		}

		error = nd6_setdefaultiface(idx);
		<span class="enscript-keyword">return</span> (error);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Create neighbor cache entry and cache link-layer address,
 * on reception of inbound ND6 packets. (RS/RA/NS/redirect)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_cache_lladdr</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> in6_addr *from, <span class="enscript-type">char</span> *lladdr,
    <span class="enscript-type">int</span> lladdrlen, <span class="enscript-type">int</span> type, <span class="enscript-type">int</span> code)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">lladdrlen</span>)
	<span class="enscript-type">struct</span> rtentry *rt = NULL;
	<span class="enscript-type">struct</span> llinfo_nd6 *ln = NULL;
	<span class="enscript-type">int</span> is_newentry;
	<span class="enscript-type">struct</span> sockaddr_dl *sdl = NULL;
	<span class="enscript-type">int</span> do_update;
	<span class="enscript-type">int</span> olladdr;
	<span class="enscript-type">int</span> llchange;
	<span class="enscript-type">int</span> newstate = 0;
	uint64_t timenow;
	boolean_t sched_timeout = FALSE;

	<span class="enscript-keyword">if</span> (ifp == NULL)
		panic(<span class="enscript-string">&quot;ifp == NULL in nd6_cache_lladdr&quot;</span>);
	<span class="enscript-keyword">if</span> (from == NULL)
		panic(<span class="enscript-string">&quot;from == NULL in nd6_cache_lladdr&quot;</span>);

	<span class="enscript-comment">/* nothing must be updated for unspecified address */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(from))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * Validation about ifp-&gt;if_addrlen and lladdrlen must be done in
	 * the caller.
	 */</span>
	timenow = net_uptime();

	rt = nd6_lookup(from, 0, ifp, 0);
	<span class="enscript-keyword">if</span> (rt == NULL) {
		<span class="enscript-keyword">if</span> ((rt = nd6_lookup(from, 1, ifp, 0)) == NULL)
			<span class="enscript-keyword">return</span>;
		RT_LOCK_ASSERT_HELD(rt);
		is_newentry = 1;
	} <span class="enscript-keyword">else</span> {
		RT_LOCK_ASSERT_HELD(rt);
		<span class="enscript-comment">/* do nothing if static ndp is set */</span>
		<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_STATIC) {
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
			<span class="enscript-keyword">return</span>;
		}
		is_newentry = 0;
	}

	<span class="enscript-keyword">if</span> (rt == NULL)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; (RTF_GATEWAY | RTF_LLINFO)) != RTF_LLINFO) {
<span class="enscript-reference">fail</span>:
		RT_UNLOCK(rt);
		nd6_free(rt);
		rtfree(rt);
		<span class="enscript-keyword">return</span>;
	}
	ln = (<span class="enscript-type">struct</span> llinfo_nd6 *)rt-&gt;rt_llinfo;
	<span class="enscript-keyword">if</span> (ln == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	<span class="enscript-keyword">if</span> (rt-&gt;rt_gateway == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	<span class="enscript-keyword">if</span> (rt-&gt;rt_gateway-&gt;sa_family != AF_LINK)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	sdl = SDL(rt-&gt;rt_gateway);

	olladdr = (sdl-&gt;sdl_alen) ? 1 : 0;
	<span class="enscript-keyword">if</span> (olladdr &amp;&amp; lladdr) {
		<span class="enscript-keyword">if</span> (bcmp(lladdr, LLADDR(sdl), ifp-&gt;if_addrlen))
			llchange = 1;
		<span class="enscript-keyword">else</span>
			llchange = 0;
	} <span class="enscript-keyword">else</span>
		llchange = 0;

	<span class="enscript-comment">/*
	 * newentry olladdr  lladdr  llchange	(*=record)
	 *	0	n	n	--	(1)
	 *	0	y	n	--	(2)
	 *	0	n	y	--	(3) * STALE
	 *	0	y	y	n	(4) *
	 *	0	y	y	y	(5) * STALE
	 *	1	--	n	--	(6)   NOSTATE(= PASSIVE)
	 *	1	--	y	--	(7) * STALE
	 */</span>

	<span class="enscript-keyword">if</span> (lladdr) {		<span class="enscript-comment">/* (3-5) and (7) */</span>
		<span class="enscript-comment">/*
		 * Record source link-layer address
		 * XXX is it dependent to ifp-&gt;if_type?
		 */</span>
		sdl-&gt;sdl_alen = ifp-&gt;if_addrlen;
		bcopy(lladdr, LLADDR(sdl), ifp-&gt;if_addrlen);

		<span class="enscript-comment">/* cache the gateway (sender HW) address */</span>
		nd6_llreach_alloc(rt, ifp, LLADDR(sdl), sdl-&gt;sdl_alen, FALSE);
	}

	<span class="enscript-keyword">if</span> (!is_newentry) {
		<span class="enscript-keyword">if</span> ((!olladdr &amp;&amp; lladdr != NULL) ||	<span class="enscript-comment">/* (3) */</span>
		    (olladdr &amp;&amp; lladdr != NULL &amp;&amp; llchange)) {	<span class="enscript-comment">/* (5) */</span>
			do_update = 1;
			newstate = ND6_LLINFO_STALE;
		} <span class="enscript-keyword">else</span>					<span class="enscript-comment">/* (1-2,4) */</span>
			do_update = 0;
	} <span class="enscript-keyword">else</span> {
		do_update = 1;
		<span class="enscript-keyword">if</span> (lladdr == NULL)			<span class="enscript-comment">/* (6) */</span>
			newstate = ND6_LLINFO_NOSTATE;
		<span class="enscript-keyword">else</span>					<span class="enscript-comment">/* (7) */</span>
			newstate = ND6_LLINFO_STALE;
	}

	<span class="enscript-keyword">if</span> (do_update) {
		<span class="enscript-comment">/*
		 * Update the state of the neighbor cache.
		 */</span>
		ln-&gt;ln_state = newstate;

		<span class="enscript-keyword">if</span> (ln-&gt;ln_state == ND6_LLINFO_STALE) {
			<span class="enscript-type">struct</span> mbuf *m = ln-&gt;ln_hold;
			<span class="enscript-comment">/*
			 * XXX: since nd6_output() below will cause
			 * state tansition to DELAY and reset the timer,
			 * we must set the timer now, although it is actually
			 * meaningless.
			 */</span>
			ln_setexpire(ln, timenow + nd6_gctimer);
			ln-&gt;ln_hold = NULL;

			<span class="enscript-keyword">if</span> (m != NULL) {
				<span class="enscript-type">struct</span> sockaddr_in6 sin6;

				rtkey_to_sa6(rt, &amp;sin6);
				<span class="enscript-comment">/*
				 * we assume ifp is not a p2p here, so just
				 * set the 2nd argument as the 1st one.
				 */</span>
				RT_UNLOCK(rt);
				nd6_output_list(ifp, ifp, m, &amp;sin6, rt, NULL);
				RT_LOCK(rt);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ln-&gt;ln_state == ND6_LLINFO_INCOMPLETE) {
			<span class="enscript-comment">/* probe right away */</span>
			ln_setexpire(ln, timenow);
			sched_timeout = TRUE;
		}
	}

	<span class="enscript-comment">/*
	 * ICMP6 type dependent behavior.
	 *
	 * NS: clear IsRouter if new entry
	 * RS: clear IsRouter
	 * RA: set IsRouter if there's lladdr
	 * redir: clear IsRouter if new entry
	 *
	 * RA case, (1):
	 * The spec says that we must set IsRouter in the following cases:
	 * - If lladdr exist, set IsRouter.  This means (1-5).
	 * - If it is old entry (!newentry), set IsRouter.  This means (7).
	 * So, based on the spec, in (1-5) and (7) cases we must set IsRouter.
	 * A quetion arises for (1) case.  (1) case has no lladdr in the
	 * neighbor cache, this is similar to (6).
	 * This case is rare but we figured that we MUST NOT set IsRouter.
	 *
	 * newentry olladdr  lladdr  llchange	    NS  RS	RA	redir
	 *								D R
	 *	0	n	n	--	(1)	c	?	s
	 *	0	y	n	--	(2)	c	s	s
	 *	0	n	y	--	(3)	c	s	s
	 *	0	y	y	n	(4)	c	s	s
	 *	0	y	y	y	(5)	c	s	s
	 *	1	--	n	--	(6) c	c		c s
	 *	1	--	y	--	(7) c	c	s	c s
	 *
	 *					(c=clear s=set)
	 */</span>
	<span class="enscript-keyword">switch</span> (type &amp; 0xff) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_NEIGHBOR_SOLICIT</span>:
		<span class="enscript-comment">/*
		 * New entry must have is_router flag cleared.
		 */</span>
		<span class="enscript-keyword">if</span> (is_newentry)	<span class="enscript-comment">/* (6-7) */</span>
			ln-&gt;ln_router = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_REDIRECT</span>:
		<span class="enscript-comment">/*
		 * If the ICMP message is a Redirect to a better router, always
		 * set the is_router flag.  Otherwise, if the entry is newly
		 * created, then clear the flag.  [RFC 4861, sec 8.3]
		 */</span>
		<span class="enscript-keyword">if</span> (code == ND_REDIRECT_ROUTER)
			ln-&gt;ln_router = 1;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (is_newentry) <span class="enscript-comment">/* (6-7) */</span>
			ln-&gt;ln_router = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_ROUTER_SOLICIT</span>:
		<span class="enscript-comment">/*
		 * is_router flag must always be cleared.
		 */</span>
		ln-&gt;ln_router = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_ROUTER_ADVERT</span>:
		<span class="enscript-comment">/*
		 * Mark an entry with lladdr as a router.
		 */</span>
		<span class="enscript-keyword">if</span> ((!is_newentry &amp;&amp; (olladdr || lladdr)) ||	<span class="enscript-comment">/* (2-5) */</span>
		    (is_newentry &amp;&amp; lladdr)) {			<span class="enscript-comment">/* (7) */</span>
			ln-&gt;ln_router = 1;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * When the link-layer address of a router changes, select the
	 * best router again.  In particular, when the neighbor entry is newly
	 * created, it might affect the selection policy.
	 * Question: can we restrict the first condition to the &quot;is_newentry&quot;
	 * case?
	 *
	 * Note: Perform default router selection even when we are a router,
	 * if Scoped Routing is enabled.
	 */</span>
	<span class="enscript-keyword">if</span> (do_update &amp;&amp; ln-&gt;ln_router &amp;&amp;
	    (ip6_doscopedroute || !ip6_forwarding)) {
		RT_REMREF_LOCKED(rt);
		RT_UNLOCK(rt);
		lck_mtx_lock(nd6_mutex);
		defrouter_select(ifp);
		lck_mtx_unlock(nd6_mutex);
	} <span class="enscript-keyword">else</span> {
		RT_REMREF_LOCKED(rt);
		RT_UNLOCK(rt);
	}
	<span class="enscript-keyword">if</span> (sched_timeout) {
		lck_mtx_lock(rnh_lock);
		nd6_sched_timeout(NULL, NULL);
		lck_mtx_unlock(rnh_lock);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_slowtimo</span>(<span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>)
	<span class="enscript-type">struct</span> nd_ifinfo *nd6if = NULL;
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;

	ifnet_head_lock_shared();
	<span class="enscript-keyword">for</span> (ifp = ifnet_head.tqh_first; ifp;
	    ifp = ifp-&gt;if_link.tqe_next) {
		nd6if = ND_IFINFO(ifp);
		<span class="enscript-keyword">if</span> ((NULL == nd6if) || (FALSE == nd6if-&gt;initialized)) {
			<span class="enscript-keyword">continue</span>;
		}

		lck_mtx_lock(&amp;nd6if-&gt;lock);
		<span class="enscript-keyword">if</span> (nd6if-&gt;basereachable &amp;&amp; <span class="enscript-comment">/* already initialized */</span>
		    (nd6if-&gt;recalctm -= ND6_SLOWTIMER_INTERVAL) &lt;= 0) {
			<span class="enscript-comment">/*
			 * Since reachable time rarely changes by router
			 * advertisements, we SHOULD insure that a new random
			 * value gets recomputed at least once every few hours.
			 * (RFC 4861, 6.3.4)
			 */</span>
			nd6if-&gt;recalctm = nd6_recalc_reachtm_interval;
			nd6if-&gt;reachable =
			    ND_COMPUTE_RTIME(nd6if-&gt;basereachable);
		}
		lck_mtx_unlock(&amp;nd6if-&gt;lock);
	}
	ifnet_head_done();
	timeout(nd6_slowtimo, NULL, ND6_SLOWTIMER_INTERVAL * hz);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_output</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifnet *origifp, <span class="enscript-type">struct</span> mbuf *m0,
    <span class="enscript-type">struct</span> sockaddr_in6 *dst, <span class="enscript-type">struct</span> rtentry *hint0, <span class="enscript-type">struct</span> flowadv *adv)
{
	<span class="enscript-keyword">return</span> nd6_output_list(ifp, origifp, m0, dst, hint0, adv);
}

<span class="enscript-comment">/*
 * nd6_output_list()
 *
 * Assumption: route determination for first packet can be correctly applied to
 * all packets in the chain.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">senderr</span>(e) { error = (e); goto bad; }
<span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_output_list</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifnet *origifp, <span class="enscript-type">struct</span> mbuf *m0,
    <span class="enscript-type">struct</span> sockaddr_in6 *dst, <span class="enscript-type">struct</span> rtentry *hint0, <span class="enscript-type">struct</span> flowadv *adv)
{
	<span class="enscript-type">struct</span> rtentry *rt = hint0, *hint = hint0;
	<span class="enscript-type">struct</span> llinfo_nd6 *ln = NULL;
	<span class="enscript-type">int</span> error = 0;
	uint64_t timenow;
	<span class="enscript-type">struct</span> rtentry *rtrele = NULL;
	<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;

	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK_SPIN(rt);
		RT_ADDREF_LOCKED(rt);
	}

	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;dst-&gt;sin6_addr) || !nd6_need_cache(ifp)) {
		<span class="enscript-keyword">if</span> (rt != NULL)
			RT_UNLOCK(rt);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">sendpkt</span>;
	}

	<span class="enscript-comment">/*
	 * Next hop determination.  Because we may involve the gateway route
	 * in addition to the original route, locking is rather complicated.
	 * The general concept is that regardless of whether the route points
	 * to the original route or to the gateway route, this routine takes
	 * an extra reference on such a route.  This extra reference will be
	 * released at the end.
	 *
	 * Care must be taken to ensure that the &quot;hint0&quot; route never gets freed
	 * via rtfree(), since the caller may have stored it inside a struct
	 * route with a reference held for that placeholder.
	 *
	 * This logic is similar to, though not exactly the same as the one
	 * used by route_to_gwroute().
	 */</span>
	<span class="enscript-keyword">if</span> (rt != NULL) {
		<span class="enscript-comment">/*
		 * We have a reference to &quot;rt&quot; by now (or below via rtalloc1),
		 * which will either be released or freed at the end of this
		 * routine.
		 */</span>
		RT_LOCK_ASSERT_HELD(rt);
		<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; RTF_UP)) {
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
			<span class="enscript-keyword">if</span> ((hint = rt = rtalloc1_scoped(SA(dst), 1, 0,
			    ifp-&gt;if_index)) != NULL) {
				RT_LOCK_SPIN(rt);
				<span class="enscript-keyword">if</span> (rt-&gt;rt_ifp != ifp) {
					<span class="enscript-comment">/* XXX: loop care? */</span>
					RT_UNLOCK(rt);
					error = nd6_output_list(ifp, origifp, m0,
					    dst, rt, adv);
					rtfree(rt);
					<span class="enscript-keyword">return</span> (error);
				}
			} <span class="enscript-keyword">else</span> {
				senderr(EHOSTUNREACH);
			}
		}

		<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_GATEWAY) {
			<span class="enscript-type">struct</span> rtentry *gwrt;
			<span class="enscript-type">struct</span> in6_ifaddr *ia6 = NULL;
			<span class="enscript-type">struct</span> sockaddr_in6 gw6;

			rtgw_to_sa6(rt, &amp;gw6);
			<span class="enscript-comment">/*
			 * Must drop rt_lock since nd6_is_addr_neighbor()
			 * calls nd6_lookup() and acquires rnh_lock.
			 */</span>
			RT_UNLOCK(rt);

			<span class="enscript-comment">/*
			 * We skip link-layer address resolution and NUD
			 * if the gateway is not a neighbor from ND point
			 * of view, regardless of the value of nd_ifinfo.flags.
			 * The second condition is a bit tricky; we skip
			 * if the gateway is our own address, which is
			 * sometimes used to install a route to a p2p link.
			 */</span>
			<span class="enscript-keyword">if</span> (!nd6_is_addr_neighbor(&amp;gw6, ifp, 0) ||
			    (ia6 = in6ifa_ifpwithaddr(ifp, &amp;gw6.sin6_addr))) {
				<span class="enscript-comment">/*
				 * We allow this kind of tricky route only
				 * when the outgoing interface is p2p.
				 * XXX: we may need a more generic rule here.
				 */</span>
				<span class="enscript-keyword">if</span> (ia6 != NULL)
					IFA_REMREF(&amp;ia6-&gt;ia_ifa);
				<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_POINTOPOINT) == 0)
					senderr(EHOSTUNREACH);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">sendpkt</span>;
			}

			RT_LOCK_SPIN(rt);
			gw6 = *(SIN6(rt-&gt;rt_gateway));

			<span class="enscript-comment">/* If hint is now down, give up */</span>
			<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; RTF_UP)) {
				RT_UNLOCK(rt);
				senderr(EHOSTUNREACH);
			}

			<span class="enscript-comment">/* If there's no gateway route, look it up */</span>
			<span class="enscript-keyword">if</span> ((gwrt = rt-&gt;rt_gwroute) == NULL) {
				RT_UNLOCK(rt);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">lookup</span>;
			}
			<span class="enscript-comment">/* Become a regular mutex */</span>
			RT_CONVERT_LOCK(rt);

			<span class="enscript-comment">/*
			 * Take gwrt's lock while holding route's lock;
			 * this is okay since gwrt never points back
			 * to rt, so no lock ordering issues.
			 */</span>
			RT_LOCK_SPIN(gwrt);
			<span class="enscript-keyword">if</span> (!(gwrt-&gt;rt_flags &amp; RTF_UP)) {
				rt-&gt;rt_gwroute = NULL;
				RT_UNLOCK(gwrt);
				RT_UNLOCK(rt);
				rtfree(gwrt);
<span class="enscript-reference">lookup</span>:
				lck_mtx_lock(rnh_lock);
				gwrt = rtalloc1_scoped_locked(SA(&amp;gw6), 1, 0,
				    ifp-&gt;if_index);

				RT_LOCK(rt);
				<span class="enscript-comment">/*
				 * Bail out if the route is down, no route
				 * to gateway, circular route, or if the
				 * gateway portion of &quot;rt&quot; has changed.
				 */</span>
				<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; RTF_UP) ||
				    gwrt == NULL || gwrt == rt ||
				    !equal(SA(&amp;gw6), rt-&gt;rt_gateway)) {
					<span class="enscript-keyword">if</span> (gwrt == rt) {
						RT_REMREF_LOCKED(gwrt);
						gwrt = NULL;
					}
					RT_UNLOCK(rt);
					<span class="enscript-keyword">if</span> (gwrt != NULL)
						rtfree_locked(gwrt);
					lck_mtx_unlock(rnh_lock);
					senderr(EHOSTUNREACH);
				}
				VERIFY(gwrt != NULL);
				<span class="enscript-comment">/*
				 * Set gateway route; callee adds ref to gwrt;
				 * gwrt has an extra ref from rtalloc1() for
				 * this routine.
				 */</span>
				rt_set_gwroute(rt, rt_key(rt), gwrt);
				RT_UNLOCK(rt);
				lck_mtx_unlock(rnh_lock);
				<span class="enscript-comment">/* Remember to release/free &quot;rt&quot; at the end */</span>
				rtrele = rt;
				rt = gwrt;
			} <span class="enscript-keyword">else</span> {
				RT_ADDREF_LOCKED(gwrt);
				RT_UNLOCK(gwrt);
				RT_UNLOCK(rt);
				<span class="enscript-comment">/* Remember to release/free &quot;rt&quot; at the end */</span>
				rtrele = rt;
				rt = gwrt;
			}
			VERIFY(rt == gwrt);

			<span class="enscript-comment">/*
			 * This is an opportunity to revalidate the parent
			 * route's gwroute, in case it now points to a dead
			 * route entry.  Parent route won't go away since the
			 * clone (hint) holds a reference to it.  rt == gwrt.
			 */</span>
			RT_LOCK_SPIN(hint);
			<span class="enscript-keyword">if</span> ((hint-&gt;rt_flags &amp; (RTF_WASCLONED | RTF_UP)) ==
			    (RTF_WASCLONED | RTF_UP)) {
				<span class="enscript-type">struct</span> rtentry *prt = hint-&gt;rt_parent;
				VERIFY(prt != NULL);

				RT_CONVERT_LOCK(hint);
				RT_ADDREF(prt);
				RT_UNLOCK(hint);
				rt_revalidate_gwroute(prt, rt);
				RT_REMREF(prt);
			} <span class="enscript-keyword">else</span> {
				RT_UNLOCK(hint);
			}

			RT_LOCK_SPIN(rt);
			<span class="enscript-comment">/* rt == gwrt; if it is now down, give up */</span>
			<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; RTF_UP)) {
				RT_UNLOCK(rt);
				rtfree(rt);
				rt = NULL;
				<span class="enscript-comment">/* &quot;rtrele&quot; == original &quot;rt&quot; */</span>
				senderr(EHOSTUNREACH);
			}
		}

		<span class="enscript-comment">/* Become a regular mutex */</span>
		RT_CONVERT_LOCK(rt);
	}

	<span class="enscript-comment">/*
	 * Address resolution or Neighbor Unreachability Detection
	 * for the next hop.
	 * At this point, the destination of the packet must be a unicast
	 * or an anycast address(i.e. not a multicast).
	 */</span>

	<span class="enscript-comment">/* Look up the neighbor cache for the nexthop */</span>
	<span class="enscript-keyword">if</span> (rt &amp;&amp; (rt-&gt;rt_flags &amp; RTF_LLINFO) != 0) {
		ln = rt-&gt;rt_llinfo;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> sockaddr_in6 sin6;
		<span class="enscript-comment">/*
		 * Clear out Scope ID field in case it is set.
		 */</span>
		sin6 = *dst;
		sin6.sin6_scope_id = 0;
		<span class="enscript-comment">/*
		 * Since nd6_is_addr_neighbor() internally calls nd6_lookup(),
		 * the condition below is not very efficient.  But we believe
		 * it is tolerable, because this should be a rare case.
		 * Must drop rt_lock since nd6_is_addr_neighbor() calls
		 * nd6_lookup() and acquires rnh_lock.
		 */</span>
		<span class="enscript-keyword">if</span> (rt != NULL)
			RT_UNLOCK(rt);
		<span class="enscript-keyword">if</span> (nd6_is_addr_neighbor(&amp;sin6, ifp, 0)) {
			<span class="enscript-comment">/* &quot;rtrele&quot; may have been used, so clean up &quot;rt&quot; now */</span>
			<span class="enscript-keyword">if</span> (rt != NULL) {
				<span class="enscript-comment">/* Don't free &quot;hint0&quot; */</span>
				<span class="enscript-keyword">if</span> (rt == hint0)
					RT_REMREF(rt);
				<span class="enscript-keyword">else</span>
					rtfree(rt);
			}
			<span class="enscript-comment">/* Callee returns a locked route upon success */</span>
			rt = nd6_lookup(&amp;dst-&gt;sin6_addr, 1, ifp, 0);
			<span class="enscript-keyword">if</span> (rt != NULL) {
				RT_LOCK_ASSERT_HELD(rt);
				ln = rt-&gt;rt_llinfo;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rt != NULL) {
			RT_LOCK(rt);
		}
	}

	<span class="enscript-keyword">if</span> (!ln || !rt) {
		<span class="enscript-keyword">if</span> (rt != NULL) {
			RT_UNLOCK(rt);
		}
		ndi = ND_IFINFO(ifp);
		VERIFY(ndi != NULL &amp;&amp; ndi-&gt;initialized);
		lck_mtx_lock(&amp;ndi-&gt;lock);
		<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_POINTOPOINT) == 0 &amp;&amp;
		    !(ndi-&gt;flags &amp; ND6_IFF_PERFORMNUD)) {
			lck_mtx_unlock(&amp;ndi-&gt;lock);
			log(LOG_DEBUG,
			    <span class="enscript-string">&quot;nd6_output: can't allocate llinfo for %s &quot;</span>
			    <span class="enscript-string">&quot;(ln=0x%llx, rt=0x%llx)\n&quot;</span>,
			    ip6_sprintf(&amp;dst-&gt;sin6_addr),
			    (uint64_t)VM_KERNEL_ADDRPERM(ln),
			    (uint64_t)VM_KERNEL_ADDRPERM(rt));
			senderr(EIO);	<span class="enscript-comment">/* XXX: good error? */</span>
		}
		lck_mtx_unlock(&amp;ndi-&gt;lock);

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">sendpkt</span>;	<span class="enscript-comment">/* send anyway */</span>
	}

	net_update_uptime();
	timenow = net_uptime();

	<span class="enscript-comment">/* We don't have to do link-layer address resolution on a p2p link. */</span>
	<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_POINTOPOINT) != 0 &amp;&amp;
	    ln-&gt;ln_state &lt; ND6_LLINFO_REACHABLE) {
		ln-&gt;ln_state = ND6_LLINFO_STALE;
		ln_setexpire(ln, timenow + nd6_gctimer);
	}

	<span class="enscript-comment">/*
	 * The first time we send a packet to a neighbor whose entry is
	 * STALE, we have to change the state to DELAY and a sets a timer to
	 * expire in DELAY_FIRST_PROBE_TIME seconds to ensure do
	 * neighbor unreachability detection on expiration.
	 * (RFC 4861 7.3.3)
	 */</span>
	<span class="enscript-keyword">if</span> (ln-&gt;ln_state == ND6_LLINFO_STALE) {
		ln-&gt;ln_asked = 0;
		ln-&gt;ln_state = ND6_LLINFO_DELAY;
		ln_setexpire(ln, timenow + nd6_delay);
		<span class="enscript-comment">/* N.B.: we will re-arm the timer below. */</span>
		_CASSERT(ND6_LLINFO_DELAY &gt; ND6_LLINFO_INCOMPLETE);
	}

	<span class="enscript-comment">/*
	 * If the neighbor cache entry has a state other than INCOMPLETE
	 * (i.e. its link-layer address is already resolved), just
	 * send the packet.
	 */</span>
	<span class="enscript-keyword">if</span> (ln-&gt;ln_state &gt; ND6_LLINFO_INCOMPLETE) {
		RT_UNLOCK(rt);
		<span class="enscript-comment">/*
		 * Move this entry to the head of the queue so that it is
		 * less likely for this entry to be a target of forced
		 * garbage collection (see nd6_rtrequest()).  Do this only
		 * if the entry is non-permanent (as permanent ones will
		 * never be purged), and if the number of active entries
		 * is at least half of the threshold.
		 */</span>
		<span class="enscript-keyword">if</span> (ln-&gt;ln_state == ND6_LLINFO_DELAY ||
		    (ln-&gt;ln_expire != 0 &amp;&amp; ip6_neighborgcthresh &gt; 0 &amp;&amp;
		    nd6_inuse &gt;= (ip6_neighborgcthresh &gt;&gt; 1))) {
			lck_mtx_lock(rnh_lock);
			<span class="enscript-keyword">if</span> (ln-&gt;ln_state == ND6_LLINFO_DELAY)
				nd6_sched_timeout(NULL, NULL);
			<span class="enscript-keyword">if</span> (ln-&gt;ln_expire != 0 &amp;&amp; ip6_neighborgcthresh &gt; 0 &amp;&amp;
			    nd6_inuse &gt;= (ip6_neighborgcthresh &gt;&gt; 1)) {
				RT_LOCK_SPIN(rt);
				<span class="enscript-keyword">if</span> (ln-&gt;ln_flags &amp; ND6_LNF_IN_USE) {
					LN_DEQUEUE(ln);
					LN_INSERTHEAD(ln);
				}
				RT_UNLOCK(rt);
			}
			lck_mtx_unlock(rnh_lock);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">sendpkt</span>;
	}

	<span class="enscript-comment">/*
	 * If this is a prefix proxy route, record the inbound interface
	 * so that it can be excluded from the list of interfaces eligible
	 * for forwarding the proxied NS in nd6_prproxy_ns_output().
	 */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_PROXY)
		ln-&gt;ln_exclifp = ((origifp == ifp) ? NULL : origifp);

	<span class="enscript-comment">/*
	 * There is a neighbor cache entry, but no ethernet address
	 * response yet.  Replace the held mbuf (if any) with this
	 * latest one.
	 *
	 * This code conforms to the rate-limiting rule described in Section
	 * 7.2.2 of RFC 4861, because the timer is set correctly after sending
	 * an NS below.
	 */</span>
	<span class="enscript-keyword">if</span> (ln-&gt;ln_state == ND6_LLINFO_NOSTATE)
		ln-&gt;ln_state = ND6_LLINFO_INCOMPLETE;
	<span class="enscript-keyword">if</span> (ln-&gt;ln_hold)
		m_freem_list(ln-&gt;ln_hold);
	ln-&gt;ln_hold = m0;
	<span class="enscript-keyword">if</span> (ln-&gt;ln_expire != 0 &amp;&amp; ln-&gt;ln_asked &lt; nd6_mmaxtries &amp;&amp;
	    ln-&gt;ln_expire &lt;= timenow) {
		ln-&gt;ln_asked++;
		ndi = ND_IFINFO(ifp);
		VERIFY(ndi != NULL &amp;&amp; ndi-&gt;initialized);
		lck_mtx_lock(&amp;ndi-&gt;lock);
		ln_setexpire(ln, timenow + ndi-&gt;retrans / 1000);
		lck_mtx_unlock(&amp;ndi-&gt;lock);
		RT_UNLOCK(rt);
		<span class="enscript-comment">/* We still have a reference on rt (for ln) */</span>
		<span class="enscript-keyword">if</span> (ip6_forwarding)
			nd6_prproxy_ns_output(ifp, origifp, NULL,
			    &amp;dst-&gt;sin6_addr, ln);
		<span class="enscript-keyword">else</span>
			nd6_ns_output(ifp, NULL, &amp;dst-&gt;sin6_addr, ln, 0);
		lck_mtx_lock(rnh_lock);
		nd6_sched_timeout(NULL, NULL);
		lck_mtx_unlock(rnh_lock);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span>(ln-&gt;ln_state == ND6_LLINFO_INCOMPLETE) {
			ln-&gt;ln_expire = timenow;
		}
		RT_UNLOCK(rt);
	}
	<span class="enscript-comment">/*
	 * Move this entry to the head of the queue so that it is
	 * less likely for this entry to be a target of forced
	 * garbage collection (see nd6_rtrequest()).  Do this only
	 * if the entry is non-permanent (as permanent ones will
	 * never be purged), and if the number of active entries
	 * is at least half of the threshold.
	 */</span>
	<span class="enscript-keyword">if</span> (ln-&gt;ln_expire != 0 &amp;&amp; ip6_neighborgcthresh &gt; 0 &amp;&amp;
	    nd6_inuse &gt;= (ip6_neighborgcthresh &gt;&gt; 1)) {
		lck_mtx_lock(rnh_lock);
		RT_LOCK_SPIN(rt);
		<span class="enscript-keyword">if</span> (ln-&gt;ln_flags &amp; ND6_LNF_IN_USE) {
			LN_DEQUEUE(ln);
			LN_INSERTHEAD(ln);
		}
		<span class="enscript-comment">/* Clean up &quot;rt&quot; now while we can */</span>
		<span class="enscript-keyword">if</span> (rt == hint0) {
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
		} <span class="enscript-keyword">else</span> {
			RT_UNLOCK(rt);
			rtfree_locked(rt);
		}
		rt = NULL;	<span class="enscript-comment">/* &quot;rt&quot; has been taken care of */</span>
		lck_mtx_unlock(rnh_lock);
	}
	error = 0;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;

<span class="enscript-reference">sendpkt</span>:
	<span class="enscript-keyword">if</span> (rt != NULL)
		RT_LOCK_ASSERT_NOTHELD(rt);

	<span class="enscript-comment">/* discard the packet if IPv6 operation is disabled on the interface */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_IPV6_DISABLED) {
		error = ENETDOWN; <span class="enscript-comment">/* better error? */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> (ifp-&gt;if_flags &amp; IFF_LOOPBACK) {
		<span class="enscript-comment">/* forwarding rules require the original scope_id */</span>
		m0-&gt;m_pkthdr.rcvif = origifp;
		error = dlil_output(origifp, PF_INET6, m0, (caddr_t)rt,
		    SA(dst), 0, adv);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Do not allow loopback address to wind up on a wire */</span>
		<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(m0, <span class="enscript-type">struct</span> ip6_hdr *);

		<span class="enscript-keyword">if</span> ((IN6_IS_ADDR_LOOPBACK(&amp;ip6-&gt;ip6_src) ||
		    IN6_IS_ADDR_LOOPBACK(&amp;ip6-&gt;ip6_dst))) {
			ip6stat.ip6s_badscope++;
			error = EADDRNOTAVAIL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK_SPIN(rt);
		<span class="enscript-comment">/* Mark use timestamp */</span>
		<span class="enscript-keyword">if</span> (rt-&gt;rt_llinfo != NULL)
			nd6_llreach_use(rt-&gt;rt_llinfo);
		RT_UNLOCK(rt);
	}

	<span class="enscript-type">struct</span> mbuf *mcur = m0;
	uint32_t pktcnt = 0;

	<span class="enscript-keyword">while</span> (mcur) {
		<span class="enscript-keyword">if</span> (hint != NULL &amp;&amp; nstat_collect) {
			<span class="enscript-type">int</span> scnt;

			<span class="enscript-keyword">if</span> ((mcur-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO_IPV6) &amp;&amp;
					(mcur-&gt;m_pkthdr.tso_segsz &gt; 0))
				scnt = mcur-&gt;m_pkthdr.len / mcur-&gt;m_pkthdr.tso_segsz;
			<span class="enscript-keyword">else</span>
				scnt = 1;

			nstat_route_tx(hint, scnt, mcur-&gt;m_pkthdr.len, 0);
		}
		pktcnt++;

		mcur-&gt;m_pkthdr.rcvif = NULL;
		mcur = mcur-&gt;m_nextpkt;
	}
	<span class="enscript-keyword">if</span> (pktcnt &gt; ip6_maxchainsent)
		ip6_maxchainsent = pktcnt;
	error = dlil_output(ifp, PF_INET6, m0, (caddr_t)rt, SA(dst), 0, adv);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;

<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">if</span> (m0 != NULL)
		m_freem_list(m0);

<span class="enscript-reference">release</span>:
	<span class="enscript-comment">/* Clean up &quot;rt&quot; unless it's already been done */</span>
	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK_SPIN(rt);
		<span class="enscript-keyword">if</span> (rt == hint0) {
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
		} <span class="enscript-keyword">else</span> {
			RT_UNLOCK(rt);
			rtfree(rt);
		}
	}
	<span class="enscript-comment">/* And now clean up &quot;rtrele&quot; if there is any */</span>
	<span class="enscript-keyword">if</span> (rtrele != NULL) {
		RT_LOCK_SPIN(rtrele);
		<span class="enscript-keyword">if</span> (rtrele == hint0) {
			RT_REMREF_LOCKED(rtrele);
			RT_UNLOCK(rtrele);
		} <span class="enscript-keyword">else</span> {
			RT_UNLOCK(rtrele);
			rtfree(rtrele);
		}
	}
	<span class="enscript-keyword">return</span> (error);
}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">senderr</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_need_cache</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-comment">/*
	 * XXX: we currently do not make neighbor cache on any interface
	 * other than ARCnet, Ethernet, FDDI and GIF.
	 *
	 * RFC2893 says:
	 * - unidirectional tunnels needs no ND
	 */</span>
	<span class="enscript-keyword">switch</span> (ifp-&gt;if_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ARCNET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ETHER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_FDDI</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE1394</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_L2VLAN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE8023ADLAG</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IFT_IEEE80211</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE80211</span>:
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_GIF</span>:		<span class="enscript-comment">/* XXX need more cases? */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_PPP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IFT_TUNNEL</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_TUNNEL</span>:
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_BRIDGE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_CELLULAR</span>:
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (0);
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_storelladdr</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">struct</span> mbuf *m,
    <span class="enscript-type">struct</span> sockaddr *dst, u_char *desten)
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">struct</span> sockaddr_dl *sdl;

	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_MCAST) {
		<span class="enscript-keyword">switch</span> (ifp-&gt;if_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ETHER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_FDDI</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_L2VLAN</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE8023ADLAG</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IFT_IEEE80211</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE80211</span>:
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_BRIDGE</span>:
			ETHER_MAP_IPV6_MULTICAST(&amp;SIN6(dst)-&gt;sin6_addr, desten);
			<span class="enscript-keyword">return</span> (1);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE1394</span>:
			<span class="enscript-keyword">for</span> (i = 0; i &lt; ifp-&gt;if_addrlen; i++)
				desten[i] = ~0;
			<span class="enscript-keyword">return</span> (1);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ARCNET</span>:
			*desten = 0;
			<span class="enscript-keyword">return</span> (1);
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (0); <span class="enscript-comment">/* caller will free mbuf */</span>
		}
	}

	<span class="enscript-keyword">if</span> (rt == NULL) {
		<span class="enscript-comment">/* this could happen, if we could not allocate memory */</span>
		<span class="enscript-keyword">return</span> (0); <span class="enscript-comment">/* caller will free mbuf */</span>
	}
	RT_LOCK(rt);
	<span class="enscript-keyword">if</span> (rt-&gt;rt_gateway-&gt;sa_family != AF_LINK) {
		printf(<span class="enscript-string">&quot;nd6_storelladdr: something odd happens\n&quot;</span>);
		RT_UNLOCK(rt);
		<span class="enscript-keyword">return</span> (0); <span class="enscript-comment">/* caller will free mbuf */</span>
	}
	sdl = SDL(rt-&gt;rt_gateway);
	<span class="enscript-keyword">if</span> (sdl-&gt;sdl_alen == 0) {
		<span class="enscript-comment">/* this should be impossible, but we bark here for debugging */</span>
		printf(<span class="enscript-string">&quot;nd6_storelladdr: sdl_alen == 0\n&quot;</span>);
		RT_UNLOCK(rt);
		<span class="enscript-keyword">return</span> (0); <span class="enscript-comment">/* caller will free mbuf */</span>
	}

	bcopy(LLADDR(sdl), desten, sdl-&gt;sdl_alen);
	RT_UNLOCK(rt);
	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * This is the ND pre-output routine; care must be taken to ensure that
 * the &quot;hint&quot; route never gets freed via rtfree(), since the caller may
 * have stored it inside a struct route with a reference held for that
 * placeholder.
 */</span>
errno_t
<span class="enscript-function-name">nd6_lookup_ipv6</span>(ifnet_t	 ifp, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in6	*ip6_dest,
    <span class="enscript-type">struct</span> sockaddr_dl *ll_dest, size_t	ll_dest_len, route_t hint,
    mbuf_t packet)
{
	route_t	route = hint;
	errno_t	result = 0;
	<span class="enscript-type">struct</span> sockaddr_dl *sdl = NULL;
	size_t	copy_len;

	<span class="enscript-keyword">if</span> (ip6_dest-&gt;sin6_family != AF_INET6)
		<span class="enscript-keyword">return</span> (EAFNOSUPPORT);

	<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING))
		<span class="enscript-keyword">return</span> (ENETDOWN);

	<span class="enscript-keyword">if</span> (hint != NULL) {
		<span class="enscript-comment">/*
		 * Callee holds a reference on the route and returns
		 * with the route entry locked, upon success.
		 */</span>
		result = route_to_gwroute((<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *)ip6_dest,
		    hint, &amp;route);
		<span class="enscript-keyword">if</span> (result != 0)
			<span class="enscript-keyword">return</span> (result);
		<span class="enscript-keyword">if</span> (route != NULL)
			RT_LOCK_ASSERT_HELD(route);
	}

	<span class="enscript-keyword">if</span> ((packet-&gt;m_flags &amp; M_MCAST) != 0) {
		<span class="enscript-keyword">if</span> (route != NULL)
			RT_UNLOCK(route);
		result = dlil_resolve_multi(ifp,
		    (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *)ip6_dest,
		    SA(ll_dest), ll_dest_len);
		<span class="enscript-keyword">if</span> (route != NULL)
			RT_LOCK(route);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
	}

	<span class="enscript-keyword">if</span> (route == NULL) {
		<span class="enscript-comment">/*
		 * This could happen, if we could not allocate memory or
		 * if route_to_gwroute() didn't return a route.
		 */</span>
		result = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
	}

	<span class="enscript-keyword">if</span> (route-&gt;rt_gateway-&gt;sa_family != AF_LINK) {
		printf(<span class="enscript-string">&quot;%s: route %s on %s%d gateway address not AF_LINK\n&quot;</span>,
		    __func__, ip6_sprintf(&amp;ip6_dest-&gt;sin6_addr),
		    route-&gt;rt_ifp-&gt;if_name, route-&gt;rt_ifp-&gt;if_unit);
		result = EADDRNOTAVAIL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
	}

	sdl = SDL(route-&gt;rt_gateway);
	<span class="enscript-keyword">if</span> (sdl-&gt;sdl_alen == 0) {
		<span class="enscript-comment">/* this should be impossible, but we bark here for debugging */</span>
		printf(<span class="enscript-string">&quot;%s: route %s on %s%d sdl_alen == 0\n&quot;</span>, __func__,
		    ip6_sprintf(&amp;ip6_dest-&gt;sin6_addr), route-&gt;rt_ifp-&gt;if_name,
		    route-&gt;rt_ifp-&gt;if_unit);
		result = EHOSTUNREACH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
	}

	copy_len = sdl-&gt;sdl_len &lt;= ll_dest_len ? sdl-&gt;sdl_len : ll_dest_len;
	bcopy(sdl, ll_dest, copy_len);

<span class="enscript-reference">release</span>:
	<span class="enscript-keyword">if</span> (route != NULL) {
		<span class="enscript-keyword">if</span> (route == hint) {
			RT_REMREF_LOCKED(route);
			RT_UNLOCK(route);
		} <span class="enscript-keyword">else</span> {
			RT_UNLOCK(route);
			rtfree(route);
		}
	}
	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_setifinfo</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t before, u_int32_t after)
{
	uint32_t b, a;
	<span class="enscript-type">int</span> err = 0;

	<span class="enscript-comment">/*
	 * Handle ND6_IFF_IFDISABLED
	 */</span>
	<span class="enscript-keyword">if</span> ((before &amp; ND6_IFF_IFDISABLED) ||
	    (after &amp; ND6_IFF_IFDISABLED)) {
		b = (before &amp; ND6_IFF_IFDISABLED);
		a = (after &amp; ND6_IFF_IFDISABLED);

		<span class="enscript-keyword">if</span> (b != a &amp;&amp; (err = nd6_if_disable(ifp,
		     ((int32_t)(a - b) &gt; 0))) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Handle ND6_IFF_PROXY_PREFIXES
	 */</span>
	<span class="enscript-keyword">if</span> ((before &amp; ND6_IFF_PROXY_PREFIXES) ||
	    (after &amp; ND6_IFF_PROXY_PREFIXES)) {
		b = (before &amp; ND6_IFF_PROXY_PREFIXES);
		a = (after &amp; ND6_IFF_PROXY_PREFIXES);

		<span class="enscript-keyword">if</span> (b != a &amp;&amp; (err = nd6_if_prproxy(ifp,
		     ((int32_t)(a - b) &gt; 0))) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-comment">/*
 * Enable/disable IPv6 on an interface, called as part of
 * setting/clearing ND6_IFF_IFDISABLED, or during DAD failure.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_if_disable</span>(<span class="enscript-type">struct</span> ifnet *ifp, boolean_t enable)
{
	ifnet_lock_shared(ifp);
	<span class="enscript-keyword">if</span> (enable)
		ifp-&gt;if_eflags |= IFEF_IPV6_DISABLED;
	<span class="enscript-keyword">else</span>
		ifp-&gt;if_eflags &amp;= ~IFEF_IPV6_DISABLED;
	ifnet_lock_done(ifp);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
nd6_sysctl_drlist SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">char</span> pbuf[MAX_IPv6_STR_LEN];
	<span class="enscript-type">struct</span> nd_defrouter *dr;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (EPERM);

	lck_mtx_lock(nd6_mutex);
	<span class="enscript-keyword">if</span> (proc_is64bit(req-&gt;p)) {
		<span class="enscript-type">struct</span> in6_defrouter_64 d;

		bzero(&amp;d, <span class="enscript-keyword">sizeof</span> (d));
		d.rtaddr.sin6_family = AF_INET6;
		d.rtaddr.sin6_len = <span class="enscript-keyword">sizeof</span> (d.rtaddr);

		TAILQ_FOREACH(dr, &amp;nd_defrouter, dr_entry) {
			d.rtaddr.sin6_addr = dr-&gt;rtaddr;
			<span class="enscript-keyword">if</span> (in6_recoverscope(&amp;d.rtaddr,
			    &amp;dr-&gt;rtaddr, dr-&gt;ifp) != 0)
				log(LOG_ERR, <span class="enscript-string">&quot;scope error in default router &quot;</span>
				    <span class="enscript-string">&quot;list (%s)\n&quot;</span>, inet_ntop(AF_INET6,
				    &amp;dr-&gt;rtaddr, pbuf, <span class="enscript-keyword">sizeof</span> (pbuf)));
			d.flags = dr-&gt;flags;
			d.stateflags = dr-&gt;stateflags;
			d.stateflags &amp;= ~NDDRF_PROCESSED;
			d.rtlifetime = dr-&gt;rtlifetime;
			d.expire = nddr_getexpire(dr);
			d.if_index = dr-&gt;ifp-&gt;if_index;
			error = SYSCTL_OUT(req, &amp;d, <span class="enscript-keyword">sizeof</span> (d));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">break</span>;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> in6_defrouter_32 d;

		bzero(&amp;d, <span class="enscript-keyword">sizeof</span> (d));
		d.rtaddr.sin6_family = AF_INET6;
		d.rtaddr.sin6_len = <span class="enscript-keyword">sizeof</span> (d.rtaddr);

		TAILQ_FOREACH(dr, &amp;nd_defrouter, dr_entry) {
			d.rtaddr.sin6_addr = dr-&gt;rtaddr;
			<span class="enscript-keyword">if</span> (in6_recoverscope(&amp;d.rtaddr,
			    &amp;dr-&gt;rtaddr, dr-&gt;ifp) != 0)
				log(LOG_ERR, <span class="enscript-string">&quot;scope error in default router &quot;</span>
				    <span class="enscript-string">&quot;list (%s)\n&quot;</span>, inet_ntop(AF_INET6,
				    &amp;dr-&gt;rtaddr, pbuf, <span class="enscript-keyword">sizeof</span> (pbuf)));
			d.flags = dr-&gt;flags;
			d.stateflags = dr-&gt;stateflags;
			d.stateflags &amp;= ~NDDRF_PROCESSED;
			d.rtlifetime = dr-&gt;rtlifetime;
			d.expire = nddr_getexpire(dr);
			d.if_index = dr-&gt;ifp-&gt;if_index;
			error = SYSCTL_OUT(req, &amp;d, <span class="enscript-keyword">sizeof</span> (d));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">break</span>;
		}
	}
	lck_mtx_unlock(nd6_mutex);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
nd6_sysctl_prlist SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">char</span> pbuf[MAX_IPv6_STR_LEN];
	<span class="enscript-type">struct</span> nd_pfxrouter *pfr;
	<span class="enscript-type">struct</span> sockaddr_in6 s6;
	<span class="enscript-type">struct</span> nd_prefix *pr;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (EPERM);

	bzero(&amp;s6, <span class="enscript-keyword">sizeof</span> (s6));
	s6.sin6_family = AF_INET6;
	s6.sin6_len = <span class="enscript-keyword">sizeof</span> (s6);

	lck_mtx_lock(nd6_mutex);
	<span class="enscript-keyword">if</span> (proc_is64bit(req-&gt;p)) {
		<span class="enscript-type">struct</span> in6_prefix_64 p;

		bzero(&amp;p, <span class="enscript-keyword">sizeof</span> (p));
		p.origin = PR_ORIG_RA;

		LIST_FOREACH(pr, &amp;nd_prefix, ndpr_entry) {
			NDPR_LOCK(pr);
			p.prefix = pr-&gt;ndpr_prefix;
			<span class="enscript-keyword">if</span> (in6_recoverscope(&amp;p.prefix,
			    &amp;pr-&gt;ndpr_prefix.sin6_addr, pr-&gt;ndpr_ifp) != 0)
				log(LOG_ERR, <span class="enscript-string">&quot;scope error in &quot;</span>
				    <span class="enscript-string">&quot;prefix list (%s)\n&quot;</span>, inet_ntop(AF_INET6,
				    &amp;p.prefix.sin6_addr, pbuf, <span class="enscript-keyword">sizeof</span> (pbuf)));
			p.raflags = pr-&gt;ndpr_raf;
			p.prefixlen = pr-&gt;ndpr_plen;
			p.vltime = pr-&gt;ndpr_vltime;
			p.pltime = pr-&gt;ndpr_pltime;
			p.if_index = pr-&gt;ndpr_ifp-&gt;if_index;
			p.expire = ndpr_getexpire(pr);
			p.refcnt = pr-&gt;ndpr_addrcnt;
			p.flags = pr-&gt;ndpr_stateflags;
			p.advrtrs = 0;
			LIST_FOREACH(pfr, &amp;pr-&gt;ndpr_advrtrs, pfr_entry)
				p.advrtrs++;
			error = SYSCTL_OUT(req, &amp;p, <span class="enscript-keyword">sizeof</span> (p));
			<span class="enscript-keyword">if</span> (error != 0) {
				NDPR_UNLOCK(pr);
				<span class="enscript-keyword">break</span>;
			}
			LIST_FOREACH(pfr, &amp;pr-&gt;ndpr_advrtrs, pfr_entry) {
				s6.sin6_addr = pfr-&gt;router-&gt;rtaddr;
				<span class="enscript-keyword">if</span> (in6_recoverscope(&amp;s6, &amp;pfr-&gt;router-&gt;rtaddr,
				    pfr-&gt;router-&gt;ifp) != 0)
					log(LOG_ERR,
					    <span class="enscript-string">&quot;scope error in prefix list (%s)\n&quot;</span>,
					    inet_ntop(AF_INET6, &amp;s6.sin6_addr,
					    pbuf, <span class="enscript-keyword">sizeof</span> (pbuf)));
				error = SYSCTL_OUT(req, &amp;s6, <span class="enscript-keyword">sizeof</span> (s6));
				<span class="enscript-keyword">if</span> (error != 0)
					<span class="enscript-keyword">break</span>;
			}
			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">break</span>;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> in6_prefix_32 p;

		bzero(&amp;p, <span class="enscript-keyword">sizeof</span> (p));
		p.origin = PR_ORIG_RA;

		LIST_FOREACH(pr, &amp;nd_prefix, ndpr_entry) {
			NDPR_LOCK(pr);
			p.prefix = pr-&gt;ndpr_prefix;
			<span class="enscript-keyword">if</span> (in6_recoverscope(&amp;p.prefix,
			    &amp;pr-&gt;ndpr_prefix.sin6_addr, pr-&gt;ndpr_ifp) != 0)
				log(LOG_ERR,
				    <span class="enscript-string">&quot;scope error in prefix list (%s)\n&quot;</span>,
				    inet_ntop(AF_INET6, &amp;p.prefix.sin6_addr,
				    pbuf, <span class="enscript-keyword">sizeof</span> (pbuf)));
			p.raflags = pr-&gt;ndpr_raf;
			p.prefixlen = pr-&gt;ndpr_plen;
			p.vltime = pr-&gt;ndpr_vltime;
			p.pltime = pr-&gt;ndpr_pltime;
			p.if_index = pr-&gt;ndpr_ifp-&gt;if_index;
			p.expire = ndpr_getexpire(pr);
			p.refcnt = pr-&gt;ndpr_addrcnt;
			p.flags = pr-&gt;ndpr_stateflags;
			p.advrtrs = 0;
			LIST_FOREACH(pfr, &amp;pr-&gt;ndpr_advrtrs, pfr_entry)
				p.advrtrs++;
			error = SYSCTL_OUT(req, &amp;p, <span class="enscript-keyword">sizeof</span> (p));
			<span class="enscript-keyword">if</span> (error != 0) {
				NDPR_UNLOCK(pr);
				<span class="enscript-keyword">break</span>;
			}
			LIST_FOREACH(pfr, &amp;pr-&gt;ndpr_advrtrs, pfr_entry) {
				s6.sin6_addr = pfr-&gt;router-&gt;rtaddr;
				<span class="enscript-keyword">if</span> (in6_recoverscope(&amp;s6, &amp;pfr-&gt;router-&gt;rtaddr,
				    pfr-&gt;router-&gt;ifp) != 0)
					log(LOG_ERR,
					    <span class="enscript-string">&quot;scope error in prefix list (%s)\n&quot;</span>,
					    inet_ntop(AF_INET6, &amp;s6.sin6_addr,
					    pbuf, <span class="enscript-keyword">sizeof</span> (pbuf)));
				error = SYSCTL_OUT(req, &amp;s6, <span class="enscript-keyword">sizeof</span> (s6));
				<span class="enscript-keyword">if</span> (error != 0)
					<span class="enscript-keyword">break</span>;
			}
			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">break</span>;
		}
	}
	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-keyword">return</span> (error);
}
</pre>
<hr />
</body></html>