<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>in6.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">in6.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)in.c	8.2 (Berkeley) 11/15/93
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_protocol.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/if_ether.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_seq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/mld6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_ifattach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/scope6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pfvar.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

<span class="enscript-comment">/*
 * Definitions of some costant IP6 addresses.
 */</span>
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr in6addr_any = IN6ADDR_ANY_INIT;
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr in6addr_nodelocal_allnodes =
	IN6ADDR_NODELOCAL_ALLNODES_INIT;
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr in6addr_linklocal_allnodes =
	IN6ADDR_LINKLOCAL_ALLNODES_INIT;
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr in6addr_linklocal_allrouters =
	IN6ADDR_LINKLOCAL_ALLROUTERS_INIT;
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr in6addr_linklocal_allv2routers =
	IN6ADDR_LINKLOCAL_ALLV2ROUTERS_INIT;

<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr in6mask0 = IN6MASK0;
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr in6mask7 = IN6MASK7;
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr in6mask16 = IN6MASK16;
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr in6mask32 = IN6MASK32;
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr in6mask64 = IN6MASK64;
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr in6mask96 = IN6MASK96;
<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr in6mask128 = IN6MASK128;

<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in6 sa6_any = {
	<span class="enscript-keyword">sizeof</span> (sa6_any), AF_INET6, 0, 0, IN6ADDR_ANY_INIT, 0
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6ctl_associd</span>(<span class="enscript-type">struct</span> socket *, u_long, caddr_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6ctl_connid</span>(<span class="enscript-type">struct</span> socket *, u_long, caddr_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6ctl_conninfo</span>(<span class="enscript-type">struct</span> socket *, u_long, caddr_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6ctl_llstart</span>(<span class="enscript-type">struct</span> ifnet *, u_long, caddr_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6ctl_llstop</span>(<span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6ctl_cgastart</span>(<span class="enscript-type">struct</span> ifnet *, u_long, caddr_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6ctl_gifaddr</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> in6_ifaddr *, u_long,
    <span class="enscript-type">struct</span> in6_ifreq *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6ctl_gifstat</span>(<span class="enscript-type">struct</span> ifnet *, u_long, <span class="enscript-type">struct</span> in6_ifreq *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6ctl_alifetime</span>(<span class="enscript-type">struct</span> in6_ifaddr *, u_long, <span class="enscript-type">struct</span> in6_ifreq *,
    boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6ctl_aifaddr</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> in6_aliasreq *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in6ctl_difaddr</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> in6_ifaddr *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6_autoconf</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6_setrouter</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6_ifinit</span>(<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> in6_ifaddr *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6_ifaupdate_aux</span>(<span class="enscript-type">struct</span> in6_ifaddr *, <span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in6_unlink_ifa</span>(<span class="enscript-type">struct</span> in6_ifaddr *, <span class="enscript-type">struct</span> ifnet *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> in6_ifaddr *<span class="enscript-function-name">in6_ifaddr_alloc</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in6_ifaddr_attached</span>(<span class="enscript-type">struct</span> ifaddr *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in6_ifaddr_detached</span>(<span class="enscript-type">struct</span> ifaddr *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in6_ifaddr_free</span>(<span class="enscript-type">struct</span> ifaddr *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in6_ifaddr_trace</span>(<span class="enscript-type">struct</span> ifaddr *, <span class="enscript-type">int</span>);
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in6_llstartreq_32_to_64</span>(<span class="enscript-type">struct</span> in6_llstartreq_32 *,
    <span class="enscript-type">struct</span> in6_llstartreq_64 *);
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in6_llstartreq_64_to_32</span>(<span class="enscript-type">struct</span> in6_llstartreq_64 *,
    <span class="enscript-type">struct</span> in6_llstartreq_32 *);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> in6_aliasreq *<span class="enscript-function-name">in6_aliasreq_to_native</span>(<span class="enscript-type">void</span> *, <span class="enscript-type">int</span>,
    <span class="enscript-type">struct</span> in6_aliasreq *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> in6_llstartreq *<span class="enscript-function-name">in6_llstartreq_to_native</span>(<span class="enscript-type">void</span> *, <span class="enscript-type">int</span>,
    <span class="enscript-type">struct</span> in6_llstartreq *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6_to_kamescope</span>(<span class="enscript-type">struct</span> sockaddr_in6 *, <span class="enscript-type">struct</span> ifnet *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in6_ifaddr_set_dadprogress</span>(<span class="enscript-type">struct</span> in6_ifaddr *);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6_getassocids</span>(<span class="enscript-type">struct</span> socket *, uint32_t *, user_addr_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6_getconnids</span>(<span class="enscript-type">struct</span> socket *, sae_associd_t, uint32_t *,
    user_addr_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">in6_getconninfo</span>(<span class="enscript-type">struct</span> socket *, sae_connid_t, uint32_t *,
    uint32_t *, int32_t *, user_addr_t, socklen_t *, user_addr_t, socklen_t *,
    uint32_t *, user_addr_t, uint32_t *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in6_if_up_dad_start</span>(<span class="enscript-type">struct</span> ifnet *);

<span class="enscript-type">extern</span> lck_mtx_t *nd6_mutex;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IN6IFA_TRACE_HIST_SIZE</span>	32	<span class="enscript-comment">/* size of trace history */</span>

<span class="enscript-comment">/* For gdb */</span>
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> in6ifa_trace_hist_size = IN6IFA_TRACE_HIST_SIZE;

<span class="enscript-type">struct</span> in6_ifaddr_dbg {
	<span class="enscript-type">struct</span> in6_ifaddr	in6ifa;			<span class="enscript-comment">/* in6_ifaddr */</span>
	<span class="enscript-type">struct</span> in6_ifaddr	in6ifa_old;		<span class="enscript-comment">/* saved in6_ifaddr */</span>
	u_int16_t		in6ifa_refhold_cnt;	<span class="enscript-comment">/* # of IFA_ADDREF */</span>
	u_int16_t		in6ifa_refrele_cnt;	<span class="enscript-comment">/* # of IFA_REMREF */</span>
	<span class="enscript-comment">/*
	 * Alloc and free callers.
	 */</span>
	ctrace_t		in6ifa_alloc;
	ctrace_t		in6ifa_free;
	<span class="enscript-comment">/*
	 * Circular lists of IFA_ADDREF and IFA_REMREF callers.
	 */</span>
	ctrace_t		in6ifa_refhold[IN6IFA_TRACE_HIST_SIZE];
	ctrace_t		in6ifa_refrele[IN6IFA_TRACE_HIST_SIZE];
	<span class="enscript-comment">/*
	 * Trash list linkage
	 */</span>
	TAILQ_ENTRY(in6_ifaddr_dbg) in6ifa_trash_link;
};

<span class="enscript-comment">/* List of trash in6_ifaddr entries protected by in6ifa_trash_lock */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(, in6_ifaddr_dbg) in6ifa_trash_head;
<span class="enscript-type">static</span> <span class="enscript-function-name">decl_lck_mtx_data</span>(, in6ifa_trash_lock);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> in6ifa_debug = 1;		<span class="enscript-comment">/* debugging (enabled) */</span>
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> in6ifa_debug;		<span class="enscript-comment">/* debugging (disabled) */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !DEBUG */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> in6ifa_size;		<span class="enscript-comment">/* size of zone element */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *in6ifa_zone;		<span class="enscript-comment">/* zone for in6_ifaddr */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IN6IFA_ZONE_MAX</span>		64		<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IN6IFA_ZONE_NAME</span>	<span class="enscript-string">&quot;in6_ifaddr&quot;</span>	<span class="enscript-comment">/* zone name */</span>

<span class="enscript-comment">/*
 * Subroutine for in6_ifaddloop() and in6_ifremloop().
 * This routine does actual work.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in6_ifloop_request</span>(<span class="enscript-type">int</span> cmd, <span class="enscript-type">struct</span> ifaddr *ifa)
{
	<span class="enscript-type">struct</span> sockaddr_in6 all1_sa;
	<span class="enscript-type">struct</span> rtentry *nrt = NULL;
	<span class="enscript-type">int</span> e;

	bzero(&amp;all1_sa, <span class="enscript-keyword">sizeof</span> (all1_sa));
	all1_sa.sin6_family = AF_INET6;
	all1_sa.sin6_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
	all1_sa.sin6_addr = in6mask128;

	<span class="enscript-comment">/*
	 * We specify the address itself as the gateway, and set the
	 * RTF_LLINFO flag, so that the corresponding host route would have
	 * the flag, and thus applications that assume traditional behavior
	 * would be happy.  Note that we assume the caller of the function
	 * (probably implicitly) set nd6_rtrequest() to ifa-&gt;ifa_rtrequest,
	 * which changes the outgoing interface to the loopback interface.
	 * ifa_addr for INET6 is set once during init; no need to hold lock.
	 */</span>
	lck_mtx_lock(rnh_lock);
	e = rtrequest_locked(cmd, ifa-&gt;ifa_addr, ifa-&gt;ifa_addr,
	    (<span class="enscript-type">struct</span> sockaddr *)&amp;all1_sa, RTF_UP|RTF_HOST|RTF_LLINFO, &amp;nrt);
	<span class="enscript-keyword">if</span> (e != 0) {
		log(LOG_ERR, <span class="enscript-string">&quot;in6_ifloop_request: &quot;</span>
		    <span class="enscript-string">&quot;%s operation failed for %s (errno=%d)\n&quot;</span>,
		    cmd == RTM_ADD ? <span class="enscript-string">&quot;ADD&quot;</span> : <span class="enscript-string">&quot;DELETE&quot;</span>,
		    ip6_sprintf(&amp;((<span class="enscript-type">struct</span> in6_ifaddr *)ifa)-&gt;ia_addr.sin6_addr),
		    e);
	}

	<span class="enscript-keyword">if</span> (nrt != NULL)
		RT_LOCK(nrt);
	<span class="enscript-comment">/*
	 * Make sure rt_ifa be equal to IFA, the second argument of the
	 * function.
	 * We need this because when we refer to rt_ifa-&gt;ia6_flags in
	 * ip6_input, we assume that the rt_ifa points to the address instead
	 * of the loopback address.
	 */</span>
	<span class="enscript-keyword">if</span> (cmd == RTM_ADD &amp;&amp; nrt &amp;&amp; ifa != nrt-&gt;rt_ifa) {
		rtsetifa(nrt, ifa);
	}

	<span class="enscript-comment">/*
	 * Report the addition/removal of the address to the routing socket.
	 * XXX: since we called rtinit for a p2p interface with a destination,
	 *   we end up reporting twice in such a case.  Should we rather
	 *   omit the second report?
	 */</span>
	<span class="enscript-keyword">if</span> (nrt != NULL) {
		rt_newaddrmsg(cmd, ifa, e, nrt);
		<span class="enscript-keyword">if</span> (cmd == RTM_DELETE) {
			RT_UNLOCK(nrt);
			rtfree_locked(nrt);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* the cmd must be RTM_ADD here */</span>
			RT_REMREF_LOCKED(nrt);
			RT_UNLOCK(nrt);
		}
	}
	lck_mtx_unlock(rnh_lock);
}

<span class="enscript-comment">/*
 * Add ownaddr as loopback rtentry.  We previously add the route only if
 * necessary (ex. on a p2p link).  However, since we now manage addresses
 * separately from prefixes, we should always add the route.  We can't
 * rely on the cloning mechanism from the corresponding interface route
 * any more.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in6_ifaddloop</span>(<span class="enscript-type">struct</span> ifaddr *ifa)
{
	<span class="enscript-type">struct</span> rtentry *rt;

	<span class="enscript-comment">/*
	 * If there is no loopback entry, allocate one.  ifa_addr for
	 * INET6 is set once during init; no need to hold lock.
	 */</span>
	rt = rtalloc1(ifa-&gt;ifa_addr, 0, 0);
	<span class="enscript-keyword">if</span> (rt != NULL)
		RT_LOCK(rt);
	<span class="enscript-keyword">if</span> (rt == NULL || (rt-&gt;rt_flags &amp; RTF_HOST) == 0 ||
	    (rt-&gt;rt_ifp-&gt;if_flags &amp; IFF_LOOPBACK) == 0) {
		<span class="enscript-keyword">if</span> (rt != NULL) {
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
		}
		in6_ifloop_request(RTM_ADD, ifa);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rt != NULL) {
		RT_REMREF_LOCKED(rt);
		RT_UNLOCK(rt);
	}
}

<span class="enscript-comment">/*
 * Remove loopback rtentry of ownaddr generated by in6_ifaddloop(),
 * if it exists.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in6_ifremloop</span>(<span class="enscript-type">struct</span> ifaddr *ifa)
{
	<span class="enscript-type">struct</span> in6_ifaddr *ia;
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">int</span> ia_count = 0;

	<span class="enscript-comment">/*
	 * Some of BSD variants do not remove cloned routes
	 * from an interface direct route, when removing the direct route
	 * (see comments in net/net_osdep.h).  Even for variants that do remove
	 * cloned routes, they could fail to remove the cloned routes when
	 * we handle multple addresses that share a common prefix.
	 * So, we should remove the route corresponding to the deleted address
	 * regardless of the result of in6_is_ifloop_auto().
	 */</span>

	<span class="enscript-comment">/*
	 * Delete the entry only if exact one ifa exists.  More than one ifa
	 * can exist if we assign a same single address to multiple
	 * (probably p2p) interfaces.
	 * XXX: we should avoid such a configuration in IPv6...
	 */</span>
	lck_rw_lock_exclusive(&amp;in6_ifaddr_rwlock);
	<span class="enscript-keyword">for</span> (ia = in6_ifaddrs; ia; ia = ia-&gt;ia_next) {
		IFA_LOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(IFA_IN6(ifa), &amp;ia-&gt;ia_addr.sin6_addr)) {
			ia_count++;
			<span class="enscript-keyword">if</span> (ia_count &gt; 1) {
				IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
				<span class="enscript-keyword">break</span>;
			}
		}
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
	}
	lck_rw_done(&amp;in6_ifaddr_rwlock);

	<span class="enscript-keyword">if</span> (ia_count == 1) {
		<span class="enscript-comment">/*
		 * Before deleting, check if a corresponding loopbacked host
		 * route surely exists.  With this check, we can avoid to
		 * delete an interface direct route whose destination is same
		 * as the address being removed.  This can happen when removing
		 * a subnet-router anycast address on an interface attahced
		 * to a shared medium.  ifa_addr for INET6 is set once during
		 * init; no need to hold lock.
		 */</span>
		rt = rtalloc1(ifa-&gt;ifa_addr, 0, 0);
		<span class="enscript-keyword">if</span> (rt != NULL) {
			RT_LOCK(rt);
			<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; RTF_HOST) != 0 &amp;&amp;
			    (rt-&gt;rt_ifp-&gt;if_flags &amp; IFF_LOOPBACK) != 0) {
				RT_REMREF_LOCKED(rt);
				RT_UNLOCK(rt);
				in6_ifloop_request(RTM_DELETE, ifa);
			} <span class="enscript-keyword">else</span> {
				RT_UNLOCK(rt);
			}
		}
	}
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_mask2len</span>(mask, lim0)
	<span class="enscript-type">struct</span> in6_addr *mask;
	u_char *lim0;
{
	<span class="enscript-type">int</span> x = 0, y;
	u_char *lim = lim0, *p;

	<span class="enscript-comment">/* ignore the scope_id part */</span>
	<span class="enscript-keyword">if</span> (lim0 == NULL || lim0 - (u_char *)mask &gt; <span class="enscript-keyword">sizeof</span> (*mask))
		lim = (u_char *)mask + <span class="enscript-keyword">sizeof</span> (*mask);
	<span class="enscript-keyword">for</span> (p = (u_char *)mask; p &lt; lim; x++, p++) {
		<span class="enscript-keyword">if</span> (*p != 0xff)
			<span class="enscript-keyword">break</span>;
	}
	y = 0;
	<span class="enscript-keyword">if</span> (p &lt; lim) {
		<span class="enscript-keyword">for</span> (y = 0; y &lt; 8; y++) {
			<span class="enscript-keyword">if</span> ((*p &amp; (0x80 &gt;&gt; y)) == 0)
				<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-comment">/*
	 * when the limit pointer is given, do a stricter check on the
	 * remaining bits.
	 */</span>
	<span class="enscript-keyword">if</span> (p &lt; lim) {
		<span class="enscript-keyword">if</span> (y != 0 &amp;&amp; (*p &amp; (0x00ff &gt;&gt; y)) != 0)
			<span class="enscript-keyword">return</span> (-1);
		<span class="enscript-keyword">for</span> (p = p + 1; p &lt; lim; p++)
			<span class="enscript-keyword">if</span> (*p != 0)
				<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">return</span> (x * 8 + y);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_len2mask</span>(mask, len)
	<span class="enscript-type">struct</span> in6_addr *mask;
	<span class="enscript-type">int</span> len;
{
	<span class="enscript-type">int</span> i;

	bzero(mask, <span class="enscript-keyword">sizeof</span> (*mask));
	<span class="enscript-keyword">for</span> (i = 0; i &lt; len / 8; i++)
		mask-&gt;s6_addr8[i] = 0xff;
	<span class="enscript-keyword">if</span> (len % 8)
		mask-&gt;s6_addr8[i] = (0xff00 &gt;&gt; (len % 8)) &amp; 0xff;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_aliasreq_64_to_32</span>(<span class="enscript-type">struct</span> in6_aliasreq_64 *src, <span class="enscript-type">struct</span> in6_aliasreq_32 *dst)
{
	bzero(dst, <span class="enscript-keyword">sizeof</span> (*dst));
	bcopy(src-&gt;ifra_name, dst-&gt;ifra_name, <span class="enscript-keyword">sizeof</span> (dst-&gt;ifra_name));
	dst-&gt;ifra_addr = src-&gt;ifra_addr;
	dst-&gt;ifra_dstaddr = src-&gt;ifra_dstaddr;
	dst-&gt;ifra_prefixmask = src-&gt;ifra_prefixmask;
	dst-&gt;ifra_flags = src-&gt;ifra_flags;
	dst-&gt;ifra_lifetime.ia6t_expire = src-&gt;ifra_lifetime.ia6t_expire;
	dst-&gt;ifra_lifetime.ia6t_preferred = src-&gt;ifra_lifetime.ia6t_preferred;
	dst-&gt;ifra_lifetime.ia6t_vltime = src-&gt;ifra_lifetime.ia6t_vltime;
	dst-&gt;ifra_lifetime.ia6t_pltime = src-&gt;ifra_lifetime.ia6t_pltime;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_aliasreq_32_to_64</span>(<span class="enscript-type">struct</span> in6_aliasreq_32 *src, <span class="enscript-type">struct</span> in6_aliasreq_64 *dst)
{
	bzero(dst, <span class="enscript-keyword">sizeof</span> (*dst));
	bcopy(src-&gt;ifra_name, dst-&gt;ifra_name, <span class="enscript-keyword">sizeof</span> (dst-&gt;ifra_name));
	dst-&gt;ifra_addr = src-&gt;ifra_addr;
	dst-&gt;ifra_dstaddr = src-&gt;ifra_dstaddr;
	dst-&gt;ifra_prefixmask = src-&gt;ifra_prefixmask;
	dst-&gt;ifra_flags = src-&gt;ifra_flags;
	dst-&gt;ifra_lifetime.ia6t_expire = src-&gt;ifra_lifetime.ia6t_expire;
	dst-&gt;ifra_lifetime.ia6t_preferred = src-&gt;ifra_lifetime.ia6t_preferred;
	dst-&gt;ifra_lifetime.ia6t_vltime = src-&gt;ifra_lifetime.ia6t_vltime;
	dst-&gt;ifra_lifetime.ia6t_pltime = src-&gt;ifra_lifetime.ia6t_pltime;
}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_llstartreq_32_to_64</span>(<span class="enscript-type">struct</span> in6_llstartreq_32 *src,
    <span class="enscript-type">struct</span> in6_llstartreq_64 *dst)
{
	bzero(dst, <span class="enscript-keyword">sizeof</span> (*dst));
	bcopy(src-&gt;llsr_name, dst-&gt;llsr_name, <span class="enscript-keyword">sizeof</span> (dst-&gt;llsr_name));
	dst-&gt;llsr_flags = src-&gt;llsr_flags;
	bcopy(src-&gt;llsr_cgaprep.cga_modifier.octets,
	    dst-&gt;llsr_cgaprep.cga_modifier.octets,
	    <span class="enscript-keyword">sizeof</span> (dst-&gt;llsr_cgaprep.cga_modifier.octets));
	dst-&gt;llsr_cgaprep.cga_security_level =
	    src-&gt;llsr_cgaprep.cga_security_level;
	dst-&gt;llsr_lifetime.ia6t_expire = src-&gt;llsr_lifetime.ia6t_expire;
	dst-&gt;llsr_lifetime.ia6t_preferred = src-&gt;llsr_lifetime.ia6t_preferred;
	dst-&gt;llsr_lifetime.ia6t_vltime = src-&gt;llsr_lifetime.ia6t_vltime;
	dst-&gt;llsr_lifetime.ia6t_pltime = src-&gt;llsr_lifetime.ia6t_pltime;
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_llstartreq_64_to_32</span>(<span class="enscript-type">struct</span> in6_llstartreq_64 *src,
    <span class="enscript-type">struct</span> in6_llstartreq_32 *dst)
{
	bzero(dst, <span class="enscript-keyword">sizeof</span> (*dst));
	bcopy(src-&gt;llsr_name, dst-&gt;llsr_name, <span class="enscript-keyword">sizeof</span> (dst-&gt;llsr_name));
	dst-&gt;llsr_flags = src-&gt;llsr_flags;
	bcopy(src-&gt;llsr_cgaprep.cga_modifier.octets,
	    dst-&gt;llsr_cgaprep.cga_modifier.octets,
	    <span class="enscript-keyword">sizeof</span> (dst-&gt;llsr_cgaprep.cga_modifier.octets));
	dst-&gt;llsr_cgaprep.cga_security_level =
	    src-&gt;llsr_cgaprep.cga_security_level;
	dst-&gt;llsr_lifetime.ia6t_expire = src-&gt;llsr_lifetime.ia6t_expire;
	dst-&gt;llsr_lifetime.ia6t_preferred = src-&gt;llsr_lifetime.ia6t_preferred;
	dst-&gt;llsr_lifetime.ia6t_vltime = src-&gt;llsr_lifetime.ia6t_vltime;
	dst-&gt;llsr_lifetime.ia6t_pltime = src-&gt;llsr_lifetime.ia6t_pltime;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> in6_aliasreq *
<span class="enscript-function-name">in6_aliasreq_to_native</span>(<span class="enscript-type">void</span> *data, <span class="enscript-type">int</span> data_is_64, <span class="enscript-type">struct</span> in6_aliasreq *dst)
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
	<span class="enscript-keyword">if</span> (data_is_64)
		bcopy(data, dst, <span class="enscript-keyword">sizeof</span> (*dst));
	<span class="enscript-keyword">else</span>
		in6_aliasreq_32_to_64((<span class="enscript-type">struct</span> in6_aliasreq_32 *)data,
		    (<span class="enscript-type">struct</span> in6_aliasreq_64 *)dst);
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (data_is_64)
		in6_aliasreq_64_to_32((<span class="enscript-type">struct</span> in6_aliasreq_64 *)data,
		    (<span class="enscript-type">struct</span> in6_aliasreq_32 *)dst);
	<span class="enscript-keyword">else</span>
		bcopy(data, dst, <span class="enscript-keyword">sizeof</span> (*dst));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __LP64__ */</span>
	<span class="enscript-keyword">return</span> (dst);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> in6_llstartreq *
<span class="enscript-function-name">in6_llstartreq_to_native</span>(<span class="enscript-type">void</span> *data, <span class="enscript-type">int</span> is64, <span class="enscript-type">struct</span> in6_llstartreq *dst)
{
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
	<span class="enscript-keyword">if</span> (is64)
		bcopy(data, dst, <span class="enscript-keyword">sizeof</span> (*dst));
	<span class="enscript-keyword">else</span>
		in6_llstartreq_32_to_64((<span class="enscript-type">struct</span> in6_llstartreq_32 *)data,
		    (<span class="enscript-type">struct</span> in6_llstartreq_64 *)dst);
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (is64)
		in6_llstartreq_64_to_32((<span class="enscript-type">struct</span> in6_llstartreq_64 *)data,
		    (<span class="enscript-type">struct</span> in6_llstartreq_32 *)dst);
	<span class="enscript-keyword">else</span>
		bcopy(data, dst, <span class="enscript-keyword">sizeof</span> (*dst));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __LP64__ */</span>
	<span class="enscript-keyword">return</span> (dst);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">in6ctl_associd</span>(<span class="enscript-type">struct</span> socket *so, u_long cmd, caddr_t data)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> so_aidreq32 a32;
		<span class="enscript-type">struct</span> so_aidreq64 a64;
	} u;

	VERIFY(so != NULL);

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGASSOCIDS32</span>: {		<span class="enscript-comment">/* struct so_aidreq32 */</span>
		bcopy(data, &amp;u.a32, <span class="enscript-keyword">sizeof</span> (u.a32));
		error = in6_getassocids(so, &amp;u.a32.sar_cnt, u.a32.sar_aidp);
		<span class="enscript-keyword">if</span> (error == 0)
			bcopy(&amp;u.a32, data, <span class="enscript-keyword">sizeof</span> (u.a32));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGASSOCIDS64</span>: {		<span class="enscript-comment">/* struct so_aidreq64 */</span>
		bcopy(data, &amp;u.a64, <span class="enscript-keyword">sizeof</span> (u.a64));
		error = in6_getassocids(so, &amp;u.a64.sar_cnt, u.a64.sar_aidp);
		<span class="enscript-keyword">if</span> (error == 0)
			bcopy(&amp;u.a64, data, <span class="enscript-keyword">sizeof</span> (u.a64));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">in6ctl_connid</span>(<span class="enscript-type">struct</span> socket *so, u_long cmd, caddr_t data)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> so_cidreq32 c32;
		<span class="enscript-type">struct</span> so_cidreq64 c64;
	} u;

	VERIFY(so != NULL);

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNIDS32</span>: {		<span class="enscript-comment">/* struct so_cidreq32 */</span>
		bcopy(data, &amp;u.c32, <span class="enscript-keyword">sizeof</span> (u.c32));
		error = in6_getconnids(so, u.c32.scr_aid, &amp;u.c32.scr_cnt,
		    u.c32.scr_cidp);
		<span class="enscript-keyword">if</span> (error == 0)
			bcopy(&amp;u.c32, data, <span class="enscript-keyword">sizeof</span> (u.c32));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNIDS64</span>: {		<span class="enscript-comment">/* struct so_cidreq64 */</span>
		bcopy(data, &amp;u.c64, <span class="enscript-keyword">sizeof</span> (u.c64));
		error = in6_getconnids(so, u.c64.scr_aid, &amp;u.c64.scr_cnt,
		    u.c64.scr_cidp);
		<span class="enscript-keyword">if</span> (error == 0)
			bcopy(&amp;u.c64, data, <span class="enscript-keyword">sizeof</span> (u.c64));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">in6ctl_conninfo</span>(<span class="enscript-type">struct</span> socket *so, u_long cmd, caddr_t data)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> so_cinforeq32 ci32;
		<span class="enscript-type">struct</span> so_cinforeq64 ci64;
	} u;

	VERIFY(so != NULL);

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNINFO32</span>: {		<span class="enscript-comment">/* struct so_cinforeq32 */</span>
		bcopy(data, &amp;u.ci32, <span class="enscript-keyword">sizeof</span> (u.ci32));
		error = in6_getconninfo(so, u.ci32.scir_cid, &amp;u.ci32.scir_flags,
		    &amp;u.ci32.scir_ifindex, &amp;u.ci32.scir_error, u.ci32.scir_src,
		    &amp;u.ci32.scir_src_len, u.ci32.scir_dst, &amp;u.ci32.scir_dst_len,
		    &amp;u.ci32.scir_aux_type, u.ci32.scir_aux_data,
		    &amp;u.ci32.scir_aux_len);
		<span class="enscript-keyword">if</span> (error == 0)
			bcopy(&amp;u.ci32, data, <span class="enscript-keyword">sizeof</span> (u.ci32));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNINFO64</span>: {		<span class="enscript-comment">/* struct so_cinforeq64 */</span>
		bcopy(data, &amp;u.ci64, <span class="enscript-keyword">sizeof</span> (u.ci64));
		error = in6_getconninfo(so, u.ci64.scir_cid, &amp;u.ci64.scir_flags,
		    &amp;u.ci64.scir_ifindex, &amp;u.ci64.scir_error, u.ci64.scir_src,
		    &amp;u.ci64.scir_src_len, u.ci64.scir_dst, &amp;u.ci64.scir_dst_len,
		    &amp;u.ci64.scir_aux_type, u.ci64.scir_aux_data,
		    &amp;u.ci64.scir_aux_len);
		<span class="enscript-keyword">if</span> (error == 0)
			bcopy(&amp;u.ci64, data, <span class="enscript-keyword">sizeof</span> (u.ci64));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">in6ctl_llstart</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_long cmd, caddr_t data)
{
	<span class="enscript-type">struct</span> in6_aliasreq sifra, *ifra = NULL;
	boolean_t is64;
	<span class="enscript-type">int</span> error = 0;

	VERIFY(ifp != NULL);

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCLL_START_32</span>:		<span class="enscript-comment">/* struct in6_aliasreq_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCLL_START_64</span>:		<span class="enscript-comment">/* struct in6_aliasreq_64 */</span>
		is64 = (cmd == SIOCLL_START_64);
		<span class="enscript-comment">/*
		 * Convert user ifra to the kernel form, when appropriate.
		 * This allows the conversion between different data models
		 * to be centralized, so that it can be passed around to other
		 * routines that are expecting the kernel form.
		 */</span>
		ifra = in6_aliasreq_to_native(data, is64, &amp;sifra);

		<span class="enscript-comment">/*
		 * NOTE: All the interface specific DLIL attachements should
		 * be done here.  They are currently done in in6_ifattach_aux()
		 * for the interfaces that need it.
		 */</span>
		<span class="enscript-keyword">if</span> ((ifp-&gt;if_eflags &amp; IFEF_NOAUTOIPV6LL) != 0 &amp;&amp;
		    ifra-&gt;ifra_addr.sin6_family == AF_INET6 &amp;&amp;
		    <span class="enscript-comment">/* Only check ifra_dstaddr if valid */</span>
		    (ifra-&gt;ifra_dstaddr.sin6_len == 0 ||
		    ifra-&gt;ifra_dstaddr.sin6_family == AF_INET6)) {
		    <span class="enscript-comment">/* some interfaces may provide LinkLocal addresses */</span>
			error = in6_ifattach_aliasreq(ifp, NULL, ifra);
		} <span class="enscript-keyword">else</span> {
			error = in6_ifattach_aliasreq(ifp, NULL, NULL);
		}
		<span class="enscript-keyword">if</span> (error == 0)
			in6_if_up_dad_start(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">in6ctl_llstop</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> in6_ifaddr *ia;
	<span class="enscript-type">struct</span> nd_prefix pr0, *pr;

	VERIFY(ifp != NULL);

	<span class="enscript-comment">/* Remove link local addresses from interface */</span>
	lck_rw_lock_exclusive(&amp;in6_ifaddr_rwlock);
	ia = in6_ifaddrs;
	<span class="enscript-keyword">while</span> (ia != NULL) {
		<span class="enscript-keyword">if</span> (ia-&gt;ia_ifa.ifa_ifp != ifp) {
			ia = ia-&gt;ia_next;
			<span class="enscript-keyword">continue</span>;
		}
		IFA_LOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;ia-&gt;ia_addr.sin6_addr)) {
			IFA_ADDREF_LOCKED(&amp;ia-&gt;ia_ifa);	<span class="enscript-comment">/* for us */</span>
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			lck_rw_done(&amp;in6_ifaddr_rwlock);
			in6_purgeaddr(&amp;ia-&gt;ia_ifa);
			IFA_REMREF(&amp;ia-&gt;ia_ifa);	<span class="enscript-comment">/* for us */</span>
			lck_rw_lock_exclusive(&amp;in6_ifaddr_rwlock);
			<span class="enscript-comment">/*
			 * Purging the address caused in6_ifaddr_rwlock
			 * to be dropped and reacquired;
			 * therefore search again from the beginning
			 * of in6_ifaddrs list.
			 */</span>
			ia = in6_ifaddrs;
			<span class="enscript-keyword">continue</span>;
		}
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		ia = ia-&gt;ia_next;
	}
	lck_rw_done(&amp;in6_ifaddr_rwlock);

	<span class="enscript-comment">/* Delete the link local prefix */</span>
	bzero(&amp;pr0, <span class="enscript-keyword">sizeof</span>(pr0));
	pr0.ndpr_plen = 64;
	pr0.ndpr_ifp = ifp;
	pr0.ndpr_prefix.sin6_addr.s6_addr16[0] = IPV6_ADDR_INT16_ULL;
	in6_setscope(&amp;pr0.ndpr_prefix.sin6_addr, ifp, NULL);
	pr = nd6_prefix_lookup(&amp;pr0, ND6_PREFIX_EXPIRY_UNSPEC);
	<span class="enscript-keyword">if</span> (pr) {
		lck_mtx_lock(nd6_mutex);
		NDPR_LOCK(pr);
		prelist_remove(pr);
		NDPR_UNLOCK(pr);
		NDPR_REMREF(pr); <span class="enscript-comment">/* Drop the reference from lookup */</span>
		lck_mtx_unlock(nd6_mutex);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">in6ctl_cgastart</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_long cmd, caddr_t data)
{
	<span class="enscript-type">struct</span> in6_llstartreq llsr;
	<span class="enscript-type">int</span> is64, error = 0;

	VERIFY(ifp != NULL);

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCLL_CGASTART_32</span>:	<span class="enscript-comment">/* struct in6_llstartreq_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCLL_CGASTART_64</span>:	<span class="enscript-comment">/* struct in6_llstartreq_64 */</span>
		is64 = (cmd == SIOCLL_CGASTART_64);
		<span class="enscript-comment">/*
		 * Convert user llstartreq to the kernel form, when appropriate.
		 * This allows the conversion between different data models
		 * to be centralized, so that it can be passed around to other
		 * routines that are expecting the kernel form.
		 */</span>
		in6_llstartreq_to_native(data, is64, &amp;llsr);

		<span class="enscript-comment">/*
		 * NOTE: All the interface specific DLIL attachements
		 * should be done here.  They are currently done in
		 * in6_ifattach_llstartreq() for the interfaces that
		 * need it.
		 */</span>
		error = in6_ifattach_llstartreq(ifp, &amp;llsr);
		<span class="enscript-keyword">if</span> (error == 0)
			in6_if_up_dad_start(ifp);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Caller passes in the ioctl data pointer directly via &quot;ifr&quot;, with the
 * expectation that this routine always uses bcopy() or other byte-aligned
 * memory accesses.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">in6ctl_gifaddr</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> in6_ifaddr *ia, u_long cmd,
    <span class="enscript-type">struct</span> in6_ifreq *ifr)
{
	<span class="enscript-type">struct</span> sockaddr_in6 addr;
	<span class="enscript-type">int</span> error = 0;

	VERIFY(ifp != NULL);

	<span class="enscript-keyword">if</span> (ia == NULL)
		<span class="enscript-keyword">return</span> (EADDRNOTAVAIL);

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFADDR_IN6</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
		IFA_LOCK(&amp;ia-&gt;ia_ifa);
		bcopy(&amp;ia-&gt;ia_addr, &amp;addr, <span class="enscript-keyword">sizeof</span> (addr));
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> ((error = sa6_recoverscope(&amp;addr, TRUE)) != 0)
			<span class="enscript-keyword">break</span>;
		bcopy(&amp;addr, &amp;ifr-&gt;ifr_addr, <span class="enscript-keyword">sizeof</span> (addr));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDSTADDR_IN6</span>:	<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-keyword">if</span> (!(ifp-&gt;if_flags &amp; IFF_POINTOPOINT)) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		 * XXX: should we check if ifa_dstaddr is NULL and return
		 * an error?
		 */</span>
		IFA_LOCK(&amp;ia-&gt;ia_ifa);
		bcopy(&amp;ia-&gt;ia_dstaddr, &amp;addr, <span class="enscript-keyword">sizeof</span> (addr));
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> ((error = sa6_recoverscope(&amp;addr, TRUE)) != 0)
			<span class="enscript-keyword">break</span>;
		bcopy(&amp;addr, &amp;ifr-&gt;ifr_dstaddr, <span class="enscript-keyword">sizeof</span> (addr));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Caller passes in the ioctl data pointer directly via &quot;ifr&quot;, with the
 * expectation that this routine always uses bcopy() or other byte-aligned
 * memory accesses.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">in6ctl_gifstat</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_long cmd, <span class="enscript-type">struct</span> in6_ifreq *ifr)
{
	<span class="enscript-type">int</span> error = 0, index;

	VERIFY(ifp != NULL);
	index = ifp-&gt;if_index;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFSTAT_IN6</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-comment">/* N.B.: if_inet6data is never freed once set. */</span>
		<span class="enscript-keyword">if</span> (IN6_IFEXTRA(ifp) == NULL) {
			<span class="enscript-comment">/* return (EAFNOSUPPORT)? */</span>
			bzero(&amp;ifr-&gt;ifr_ifru.ifru_stat,
			    <span class="enscript-keyword">sizeof</span> (ifr-&gt;ifr_ifru.ifru_stat));
		} <span class="enscript-keyword">else</span> {
			bcopy(&amp;IN6_IFEXTRA(ifp)-&gt;in6_ifstat,
			    &amp;ifr-&gt;ifr_ifru.ifru_stat,
			    <span class="enscript-keyword">sizeof</span> (ifr-&gt;ifr_ifru.ifru_stat));
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFSTAT_ICMP6</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-comment">/* N.B.: if_inet6data is never freed once set. */</span>
		<span class="enscript-keyword">if</span> (IN6_IFEXTRA(ifp) == NULL) {
			<span class="enscript-comment">/* return (EAFNOSUPPORT)? */</span>
			bzero(&amp;ifr-&gt;ifr_ifru.ifru_stat,
			    <span class="enscript-keyword">sizeof</span> (ifr-&gt;ifr_ifru.ifru_icmp6stat));
		} <span class="enscript-keyword">else</span> {
			bcopy(&amp;IN6_IFEXTRA(ifp)-&gt;icmp6_ifstat,
			    &amp;ifr-&gt;ifr_ifru.ifru_icmp6stat,
			    <span class="enscript-keyword">sizeof</span> (ifr-&gt;ifr_ifru.ifru_icmp6stat));
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Caller passes in the ioctl data pointer directly via &quot;ifr&quot;, with the
 * expectation that this routine always uses bcopy() or other byte-aligned
 * memory accesses.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">in6ctl_alifetime</span>(<span class="enscript-type">struct</span> in6_ifaddr *ia, u_long cmd, <span class="enscript-type">struct</span> in6_ifreq *ifr,
    boolean_t p64)
{
	uint64_t timenow = net_uptime();
	<span class="enscript-type">struct</span> in6_addrlifetime ia6_lt;
	<span class="enscript-type">struct</span> timeval caltime;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (ia == NULL)
		<span class="enscript-keyword">return</span> (EADDRNOTAVAIL);

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFALIFETIME_IN6</span>:	<span class="enscript-comment">/* struct in6_ifreq */</span>
		IFA_LOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-comment">/* retrieve time as calendar time (last arg is 1) */</span>
		in6ifa_getlifetime(ia, &amp;ia6_lt, 1);
		<span class="enscript-keyword">if</span> (p64) {
			<span class="enscript-type">struct</span> in6_addrlifetime_64 lt;

			bzero(&amp;lt, <span class="enscript-keyword">sizeof</span> (lt));
			lt.ia6t_expire = ia6_lt.ia6t_expire;
			lt.ia6t_preferred = ia6_lt.ia6t_preferred;
			lt.ia6t_vltime = ia6_lt.ia6t_vltime;
			lt.ia6t_pltime = ia6_lt.ia6t_pltime;
			bcopy(&amp;lt, &amp;ifr-&gt;ifr_ifru.ifru_lifetime, <span class="enscript-keyword">sizeof</span> (lt));
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> in6_addrlifetime_32 lt;

			bzero(&amp;lt, <span class="enscript-keyword">sizeof</span> (lt));
			lt.ia6t_expire = (uint32_t)ia6_lt.ia6t_expire;
			lt.ia6t_preferred = (uint32_t)ia6_lt.ia6t_preferred;
			lt.ia6t_vltime = (uint32_t)ia6_lt.ia6t_vltime;
			lt.ia6t_pltime = (uint32_t)ia6_lt.ia6t_pltime;
			bcopy(&amp;lt, &amp;ifr-&gt;ifr_ifru.ifru_lifetime, <span class="enscript-keyword">sizeof</span> (lt));
		}
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFALIFETIME_IN6</span>:	<span class="enscript-comment">/* struct in6_ifreq */</span>
		getmicrotime(&amp;caltime);

		<span class="enscript-comment">/* sanity for overflow - beware unsigned */</span>
		<span class="enscript-keyword">if</span> (p64) {
			<span class="enscript-type">struct</span> in6_addrlifetime_64 lt;

			bcopy(&amp;ifr-&gt;ifr_ifru.ifru_lifetime, &amp;lt, <span class="enscript-keyword">sizeof</span> (lt));
			<span class="enscript-keyword">if</span> (lt.ia6t_vltime != ND6_INFINITE_LIFETIME &amp;&amp;
			    lt.ia6t_vltime + caltime.tv_sec &lt; caltime.tv_sec) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (lt.ia6t_pltime != ND6_INFINITE_LIFETIME &amp;&amp;
			    lt.ia6t_pltime + caltime.tv_sec &lt; caltime.tv_sec) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> in6_addrlifetime_32 lt;

			bcopy(&amp;ifr-&gt;ifr_ifru.ifru_lifetime, &amp;lt, <span class="enscript-keyword">sizeof</span> (lt));
			<span class="enscript-keyword">if</span> (lt.ia6t_vltime != ND6_INFINITE_LIFETIME &amp;&amp;
			    lt.ia6t_vltime + caltime.tv_sec &lt; caltime.tv_sec) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (lt.ia6t_pltime != ND6_INFINITE_LIFETIME &amp;&amp;
			    lt.ia6t_pltime + caltime.tv_sec &lt; caltime.tv_sec) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
		}

		IFA_LOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (p64) {
			<span class="enscript-type">struct</span> in6_addrlifetime_64 lt;

			bcopy(&amp;ifr-&gt;ifr_ifru.ifru_lifetime, &amp;lt, <span class="enscript-keyword">sizeof</span> (lt));
			ia6_lt.ia6t_expire = lt.ia6t_expire;
			ia6_lt.ia6t_preferred = lt.ia6t_preferred;
			ia6_lt.ia6t_vltime = lt.ia6t_vltime;
			ia6_lt.ia6t_pltime = lt.ia6t_pltime;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> in6_addrlifetime_32 lt;

			bcopy(&amp;ifr-&gt;ifr_ifru.ifru_lifetime, &amp;lt, <span class="enscript-keyword">sizeof</span> (lt));
			ia6_lt.ia6t_expire = (uint32_t)lt.ia6t_expire;
			ia6_lt.ia6t_preferred = (uint32_t)lt.ia6t_preferred;
			ia6_lt.ia6t_vltime = lt.ia6t_vltime;
			ia6_lt.ia6t_pltime = lt.ia6t_pltime;
		}
		<span class="enscript-comment">/* for sanity */</span>
		<span class="enscript-keyword">if</span> (ia6_lt.ia6t_vltime != ND6_INFINITE_LIFETIME)
			ia6_lt.ia6t_expire = timenow + ia6_lt.ia6t_vltime;
		<span class="enscript-keyword">else</span>
			ia6_lt.ia6t_expire = 0;

		<span class="enscript-keyword">if</span> (ia6_lt.ia6t_pltime != ND6_INFINITE_LIFETIME)
			ia6_lt.ia6t_preferred = timenow + ia6_lt.ia6t_pltime;
		<span class="enscript-keyword">else</span>
			ia6_lt.ia6t_preferred = 0;

		in6ifa_setlifetime(ia, &amp;ia6_lt);
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ifa2ia6</span>(ifa)	((struct in6_ifaddr *)(void *)(ifa))

<span class="enscript-comment">/*
 * Generic INET6 control operations (ioctl's).
 *
 * ifp is NULL if not an interface-specific ioctl.
 *
 * Most of the routines called to handle the ioctls would end up being
 * tail-call optimized, which unfortunately causes this routine to
 * consume too much stack space; this is the reason for the &quot;noinline&quot;
 * attribute used on those routines.
 *
 * If called directly from within the networking stack (as opposed to via
 * pru_control), the socket parameter may be NULL.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_control</span>(<span class="enscript-type">struct</span> socket *so, u_long cmd, caddr_t data, <span class="enscript-type">struct</span> ifnet *ifp,
    <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> in6_ifreq *ifr = (<span class="enscript-type">struct</span> in6_ifreq *)(<span class="enscript-type">void</span> *)data;
	<span class="enscript-type">struct</span> in6_aliasreq sifra, *ifra = NULL;
	<span class="enscript-type">struct</span> in6_ifaddr *ia = NULL;
	<span class="enscript-type">struct</span> sockaddr_in6 sin6, *sa6 = NULL;
	boolean_t privileged = (proc_suser(p) == 0);
	boolean_t p64 = proc_is64bit(p);
	boolean_t so_unlocked = FALSE;
	<span class="enscript-type">int</span> intval, error = 0;

	<span class="enscript-comment">/* In case it's NULL, make sure it came from the kernel */</span>
	VERIFY(so != NULL || p == kernproc);

	<span class="enscript-comment">/*
	 * ioctls which don't require ifp, may require socket.
	 */</span>
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAADDRCTL_POLICY</span>:	<span class="enscript-comment">/* struct in6_addrpolicy */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDADDRCTL_POLICY</span>:	<span class="enscript-comment">/* struct in6_addrpolicy */</span>
		<span class="enscript-keyword">if</span> (!privileged)
			<span class="enscript-keyword">return</span> (EPERM);
		<span class="enscript-keyword">return</span> (in6_src_ioctl(cmd, data));
		<span class="enscript-comment">/* NOTREACHED */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDRADD_IN6_32</span>:		<span class="enscript-comment">/* struct in6_defrouter_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDRADD_IN6_64</span>:		<span class="enscript-comment">/* struct in6_defrouter_64 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDRDEL_IN6_32</span>:		<span class="enscript-comment">/* struct in6_defrouter_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDRDEL_IN6_64</span>:		<span class="enscript-comment">/* struct in6_defrouter_64 */</span>
		<span class="enscript-keyword">if</span> (!privileged)
			<span class="enscript-keyword">return</span> (EPERM);
		<span class="enscript-keyword">return</span> (defrtrlist_ioctl(cmd, data));
		<span class="enscript-comment">/* NOTREACHED */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGASSOCIDS32</span>:		<span class="enscript-comment">/* struct so_aidreq32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGASSOCIDS64</span>:		<span class="enscript-comment">/* struct so_aidreq64 */</span>
		<span class="enscript-keyword">return</span> (in6ctl_associd(so, cmd, data));
		<span class="enscript-comment">/* NOTREACHED */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNIDS32</span>:		<span class="enscript-comment">/* struct so_cidreq32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNIDS64</span>:		<span class="enscript-comment">/* struct so_cidreq64 */</span>
		<span class="enscript-keyword">return</span> (in6ctl_connid(so, cmd, data));
		<span class="enscript-comment">/* NOTREACHED */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNINFO32</span>:		<span class="enscript-comment">/* struct so_cinforeq32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNINFO64</span>:		<span class="enscript-comment">/* struct so_cinforeq64 */</span>
		<span class="enscript-keyword">return</span> (in6ctl_conninfo(so, cmd, data));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/*
	 * The rest of ioctls require ifp; reject if we don't have one;
	 * return ENXIO to be consistent with ifioctl().
	 */</span>
	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-comment">/*
	 * Unlock the socket since ifnet_ioctl() may be invoked by
	 * one of the ioctl handlers below.  Socket will be re-locked
	 * prior to returning.
	 */</span>
	<span class="enscript-keyword">if</span> (so != NULL) {
		socket_unlock(so, 0);
		so_unlocked = TRUE;
	}

	<span class="enscript-comment">/*
	 * ioctls which require ifp but not interface address.
	 */</span>
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAUTOCONF_START</span>:	<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-keyword">if</span> (!privileged) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		error = in6_autoconf(ifp, TRUE);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAUTOCONF_STOP</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-keyword">if</span> (!privileged) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		error = in6_autoconf(ifp, FALSE);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCLL_START_32</span>:		<span class="enscript-comment">/* struct in6_aliasreq_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCLL_START_64</span>:		<span class="enscript-comment">/* struct in6_aliasreq_64 */</span>
		<span class="enscript-keyword">if</span> (!privileged) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		error = in6ctl_llstart(ifp, cmd, data);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCLL_STOP</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-keyword">if</span> (!privileged) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		error = in6ctl_llstop(ifp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSETROUTERMODE_IN6</span>:	<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-keyword">if</span> (!privileged) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		bcopy(&amp;((<span class="enscript-type">struct</span> in6_ifreq *)(<span class="enscript-type">void</span> *)data)-&gt;ifr_intval,
		    &amp;intval, <span class="enscript-keyword">sizeof</span> (intval));

		error = in6_setrouter(ifp, intval);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCPROTOATTACH_IN6_32</span>:	<span class="enscript-comment">/* struct in6_aliasreq_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCPROTOATTACH_IN6_64</span>:	<span class="enscript-comment">/* struct in6_aliasreq_64 */</span>
		<span class="enscript-keyword">if</span> (!privileged) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		error = in6_domifattach(ifp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCPROTODETACH_IN6</span>:	<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-keyword">if</span> (!privileged) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/* Cleanup interface routes and addresses */</span>
		in6_purgeif(ifp);

		<span class="enscript-keyword">if</span> ((error = proto_unplumb(PF_INET6, ifp)))
			log(LOG_ERR, <span class="enscript-string">&quot;SIOCPROTODETACH_IN6: %s error=%d\n&quot;</span>,
			    if_name(ifp), error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSNDFLUSH_IN6</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSPFXFLUSH_IN6</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSRTRFLUSH_IN6</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSDEFIFACE_IN6_32</span>:	<span class="enscript-comment">/* struct in6_ndifreq_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSDEFIFACE_IN6_64</span>:	<span class="enscript-comment">/* struct in6_ndifreq_64 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFINFO_FLAGS</span>:		<span class="enscript-comment">/* struct in6_ndireq */</span>
		<span class="enscript-keyword">if</span> (!privileged) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">OSIOCGIFINFO_IN6</span>:		<span class="enscript-comment">/* struct in6_ondireq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFINFO_IN6</span>:		<span class="enscript-comment">/* struct in6_ondireq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDRLST_IN6_32</span>:		<span class="enscript-comment">/* struct in6_drlist_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDRLST_IN6_64</span>:		<span class="enscript-comment">/* struct in6_drlist_64 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGPRLST_IN6_32</span>:		<span class="enscript-comment">/* struct in6_prlist_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGPRLST_IN6_64</span>:		<span class="enscript-comment">/* struct in6_prlist_64 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGNBRINFO_IN6_32</span>:	<span class="enscript-comment">/* struct in6_nbrinfo_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGNBRINFO_IN6_64</span>:	<span class="enscript-comment">/* struct in6_nbrinfo_64 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDEFIFACE_IN6_32</span>:	<span class="enscript-comment">/* struct in6_ndifreq_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGDEFIFACE_IN6_64</span>:	<span class="enscript-comment">/* struct in6_ndifreq_64 */</span>
		error = nd6_ioctl(cmd, data, ifp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFPREFIX_IN6</span>:		<span class="enscript-comment">/* struct in6_prefixreq (deprecated) */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDIFPREFIX_IN6</span>:		<span class="enscript-comment">/* struct in6_prefixreq (deprecated) */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFPREFIX_IN6</span>:		<span class="enscript-comment">/* struct in6_rrenumreq (deprecated) */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCCIFPREFIX_IN6</span>:		<span class="enscript-comment">/* struct in6_rrenumreq (deprecated) */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSGIFPREFIX_IN6</span>:	<span class="enscript-comment">/* struct in6_rrenumreq (deprecated) */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFPREFIX_IN6</span>:		<span class="enscript-comment">/* struct in6_prefixreq (deprecated) */</span>
		log(LOG_NOTICE,
		    <span class="enscript-string">&quot;prefix ioctls are now invalidated. &quot;</span>
		    <span class="enscript-string">&quot;please use ifconfig.\n&quot;</span>);
		error = EOPNOTSUPP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSSCOPE6</span>:		<span class="enscript-comment">/* struct in6_ifreq (deprecated) */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGSCOPE6</span>:		<span class="enscript-comment">/* struct in6_ifreq (deprecated) */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGSCOPE6DEF</span>:		<span class="enscript-comment">/* struct in6_ifreq (deprecated) */</span>
		error = EOPNOTSUPP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCLL_CGASTART_32</span>:	<span class="enscript-comment">/* struct in6_llstartreq_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCLL_CGASTART_64</span>:	<span class="enscript-comment">/* struct in6_llstartreq_64 */</span>
		<span class="enscript-keyword">if</span> (!privileged)
			error = EPERM;
		<span class="enscript-keyword">else</span>
			error = in6ctl_cgastart(ifp, cmd, data);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFSTAT_IN6</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFSTAT_ICMP6</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
		error = in6ctl_gifstat(ifp, cmd, ifr);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * ioctls which require interface address; obtain sockaddr_in6.
	 */</span>
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFADDR_IN6</span>:		<span class="enscript-comment">/* struct in6_ifreq (deprecated) */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFDSTADDR_IN6</span>:	<span class="enscript-comment">/* struct in6_ifreq (deprecated) */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFNETMASK_IN6</span>:	<span class="enscript-comment">/* struct in6_ifreq (deprecated) */</span>
		<span class="enscript-comment">/*
		 * Since IPv6 allows a node to assign multiple addresses
		 * on a single interface, SIOCSIFxxx ioctls are deprecated.
		 */</span>
		<span class="enscript-comment">/* we decided to obsolete this command (20000704) */</span>
		error = EOPNOTSUPP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFADDR_IN6_32</span>:	<span class="enscript-comment">/* struct in6_aliasreq_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFADDR_IN6_64</span>:	<span class="enscript-comment">/* struct in6_aliasreq_64 */</span>
		<span class="enscript-keyword">if</span> (!privileged) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		} 
		<span class="enscript-comment">/*
		 * Convert user ifra to the kernel form, when appropriate.
		 * This allows the conversion between different data models
		 * to be centralized, so that it can be passed around to other
		 * routines that are expecting the kernel form.
		 */</span>
		ifra = in6_aliasreq_to_native(data,
		    (cmd == SIOCAIFADDR_IN6_64), &amp;sifra);
		bcopy(&amp;ifra-&gt;ifra_addr, &amp;sin6, <span class="enscript-keyword">sizeof</span> (sin6));
		sa6 = &amp;sin6;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDIFADDR_IN6</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFALIFETIME_IN6</span>:	<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-keyword">if</span> (!privileged) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFADDR_IN6</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDSTADDR_IN6</span>:	<span class="enscript-comment">/* struct in6_ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFNETMASK_IN6</span>:	<span class="enscript-comment">/* struct in6_ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAFLAG_IN6</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFALIFETIME_IN6</span>:	<span class="enscript-comment">/* struct in6_ifreq */</span>
		bcopy(&amp;ifr-&gt;ifr_addr, &amp;sin6, <span class="enscript-keyword">sizeof</span> (sin6));
		sa6 = &amp;sin6;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * Find address for this interface, if it exists.
	 *
	 * In netinet code, we have checked ifra_addr in SIOCSIF*ADDR operation
	 * only, and used the first interface address as the target of other
	 * operations (without checking ifra_addr).  This was because netinet
	 * code/API assumed at most 1 interface address per interface.
	 * Since IPv6 allows a node to assign multiple addresses
	 * on a single interface, we almost always look and check the
	 * presence of ifra_addr, and reject invalid ones here.
	 * It also decreases duplicated code among SIOC*_IN6 operations.
	 */</span>
	VERIFY(ia == NULL);
	<span class="enscript-keyword">if</span> (sa6 != NULL &amp;&amp; sa6-&gt;sin6_family == AF_INET6) {
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;sa6-&gt;sin6_addr)) {
			<span class="enscript-keyword">if</span> (sa6-&gt;sin6_addr.s6_addr16[1] == 0) {
				<span class="enscript-comment">/* link ID is not embedded by the user */</span>
				sa6-&gt;sin6_addr.s6_addr16[1] =
				    htons(ifp-&gt;if_index);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa6-&gt;sin6_addr.s6_addr16[1] !=
			    htons(ifp-&gt;if_index)) {
				error = EINVAL; <span class="enscript-comment">/* link ID contradicts */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">if</span> (sa6-&gt;sin6_scope_id) {
				<span class="enscript-keyword">if</span> (sa6-&gt;sin6_scope_id !=
				    (u_int32_t)ifp-&gt;if_index) {
					error = EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				}
				sa6-&gt;sin6_scope_id = 0; <span class="enscript-comment">/* XXX: good way? */</span>
			}
		}
		<span class="enscript-comment">/*
		 * Any failures from this point on must take into account
		 * a non-NULL &quot;ia&quot; with an outstanding reference count, and
		 * therefore requires IFA_REMREF.  Jump to &quot;done&quot; label
		 * instead of calling return if &quot;ia&quot; is valid.
		 */</span>
		ia = in6ifa_ifpwithaddr(ifp, &amp;sa6-&gt;sin6_addr);
	}

	<span class="enscript-comment">/*
	 * SIOCDIFADDR_IN6/SIOCAIFADDR_IN6 specific tests.
	 */</span>
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDIFADDR_IN6</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-keyword">if</span> (ia == NULL) {
			error = EADDRNOTAVAIL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/* FALLTHROUGH */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFADDR_IN6_32</span>:	<span class="enscript-comment">/* struct in6_aliasreq_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFADDR_IN6_64</span>:	<span class="enscript-comment">/* struct in6_aliasreq_64 */</span>
		VERIFY(sa6 != NULL);
		<span class="enscript-comment">/*
		 * We always require users to specify a valid IPv6 address for
		 * the corresponding operation.  Use &quot;sa6&quot; instead of &quot;ifra&quot;
		 * since SIOCDIFADDR_IN6 falls thru above.
		 */</span>
		<span class="enscript-keyword">if</span> (sa6-&gt;sin6_family != AF_INET6 ||
		    sa6-&gt;sin6_len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)) {
			error = EAFNOSUPPORT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * And finally process address-related ioctls.
	 */</span>
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFADDR_IN6</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-comment">/* This interface is basically deprecated. use SIOCGIFCONF. */</span>
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFDSTADDR_IN6</span>:	<span class="enscript-comment">/* struct in6_ifreq */</span>
		error = in6ctl_gifaddr(ifp, ia, cmd, ifr);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFNETMASK_IN6</span>:	<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-keyword">if</span> (ia != NULL) {
			IFA_LOCK(&amp;ia-&gt;ia_ifa);
			bcopy(&amp;ia-&gt;ia_prefixmask, &amp;ifr-&gt;ifr_addr,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6));
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		} <span class="enscript-keyword">else</span> {
			error = EADDRNOTAVAIL;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFAFLAG_IN6</span>:		<span class="enscript-comment">/* struct in6_ifreq */</span>
		<span class="enscript-keyword">if</span> (ia != NULL) {
			IFA_LOCK(&amp;ia-&gt;ia_ifa);
			bcopy(&amp;ia-&gt;ia6_flags, &amp;ifr-&gt;ifr_ifru.ifru_flags6,
			    <span class="enscript-keyword">sizeof</span> (ifr-&gt;ifr_ifru.ifru_flags6));
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		} <span class="enscript-keyword">else</span> {
			error = EADDRNOTAVAIL;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGIFALIFETIME_IN6</span>:	<span class="enscript-comment">/* struct in6_ifreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSIFALIFETIME_IN6</span>:	<span class="enscript-comment">/* struct in6_ifreq */</span>
		error = in6ctl_alifetime(ia, cmd, ifr, p64);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFADDR_IN6_32</span>:	<span class="enscript-comment">/* struct in6_aliasreq_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAIFADDR_IN6_64</span>:	<span class="enscript-comment">/* struct in6_aliasreq_64 */</span>
		error = in6ctl_aifaddr(ifp, ifra);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDIFADDR_IN6</span>:
		in6ctl_difaddr(ifp, ia);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = ifnet_ioctl(ifp, PF_INET6, cmd, data);
		<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (ia != NULL)
		IFA_REMREF(&amp;ia-&gt;ia_ifa);
	<span class="enscript-keyword">if</span> (so_unlocked)
		socket_lock(so, 0);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">in6ctl_aifaddr</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> in6_aliasreq *ifra)
{
	<span class="enscript-type">int</span> i, error, addtmp, plen;
	<span class="enscript-type">struct</span> nd_prefix pr0, *pr;
	<span class="enscript-type">struct</span> in6_ifaddr *ia;

	VERIFY(ifp != NULL &amp;&amp; ifra != NULL);
	ia = NULL;

	<span class="enscript-comment">/* Attempt to attach the protocol, in case it isn't attached */</span>
	error = in6_domifattach(ifp);
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-comment">/* PF_INET6 wasn't previously attached */</span>
		error = in6_ifattach_aliasreq(ifp, NULL, NULL);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

		in6_if_up_dad_start(ifp);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error != EEXIST) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * First, make or update the interface address structure, and link it
	 * to the list.
	 */</span>
	error = in6_update_ifa(ifp, ifra, 0, &amp;ia);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	VERIFY(ia != NULL);

	<span class="enscript-comment">/* Now, make the prefix on-link on the interface. */</span>
	plen = in6_mask2len(&amp;ifra-&gt;ifra_prefixmask.sin6_addr, NULL);
	<span class="enscript-keyword">if</span> (plen == 128)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-comment">/*
	 * NOTE: We'd rather create the prefix before the address, but we need
	 * at least one address to install the corresponding interface route,
	 * so we configure the address first.
	 */</span>

	<span class="enscript-comment">/*
	 * Convert mask to prefix length (prefixmask has already been validated
	 * in in6_update_ifa().
	 */</span>
	bzero(&amp;pr0, <span class="enscript-keyword">sizeof</span> (pr0));
	pr0.ndpr_plen = plen;
	pr0.ndpr_ifp = ifp;
	pr0.ndpr_prefix = ifra-&gt;ifra_addr;
	pr0.ndpr_mask = ifra-&gt;ifra_prefixmask.sin6_addr;

	<span class="enscript-comment">/* apply the mask for safety. */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; 4; i++) {
		pr0.ndpr_prefix.sin6_addr.s6_addr32[i] &amp;=
		    ifra-&gt;ifra_prefixmask.sin6_addr.s6_addr32[i];
	}

	<span class="enscript-comment">/*
	 * Since we don't have an API to set prefix (not address) lifetimes, we
	 * just use the same lifetimes as addresses. The (temporarily)
	 * installed lifetimes can be overridden by later advertised RAs (when
	 * accept_rtadv is non 0), which is an intended behavior.
	 */</span>
	pr0.ndpr_raf_onlink = 1; <span class="enscript-comment">/* should be configurable? */</span>
	pr0.ndpr_raf_auto = !!(ifra-&gt;ifra_flags &amp; IN6_IFF_AUTOCONF);
	pr0.ndpr_vltime = ifra-&gt;ifra_lifetime.ia6t_vltime;
	pr0.ndpr_pltime = ifra-&gt;ifra_lifetime.ia6t_pltime;
	pr0.ndpr_stateflags |= NDPRF_STATIC;
	lck_mtx_init(&amp;pr0.ndpr_lock, ifa_mtx_grp, ifa_mtx_attr);

	<span class="enscript-comment">/* add the prefix if there's none. */</span>
	<span class="enscript-keyword">if</span> ((pr = nd6_prefix_lookup(&amp;pr0, ND6_PREFIX_EXPIRY_NEVER)) == NULL) {
		<span class="enscript-comment">/*
		 * nd6_prelist_add will install the corresponding interface
		 * route.
		 */</span>
		error = nd6_prelist_add(&amp;pr0, NULL, &amp;pr, FALSE);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

		<span class="enscript-keyword">if</span> (pr == NULL) {
			log(LOG_ERR, <span class="enscript-string">&quot;%s: nd6_prelist_add okay, but&quot;</span>
			    <span class="enscript-string">&quot; no prefix.\n&quot;</span>, __func__);
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	IFA_LOCK(&amp;ia-&gt;ia_ifa);

	<span class="enscript-comment">/* if this is a new autoconfed addr */</span>
	addtmp = FALSE;
	<span class="enscript-keyword">if</span> (ia-&gt;ia6_ndpr == NULL) {
		NDPR_LOCK(pr);
		++pr-&gt;ndpr_addrcnt;
		VERIFY(pr-&gt;ndpr_addrcnt != 0);
		ia-&gt;ia6_ndpr = pr;
		NDPR_ADDREF_LOCKED(pr);	<span class="enscript-comment">/* for addr reference */</span>

		<span class="enscript-comment">/*
		 * If this is the first autoconf address from the prefix,
		 * create a temporary address as well (when specified).
		 */</span>
		<span class="enscript-keyword">if</span> ((ia-&gt;ia6_flags &amp; IN6_IFF_AUTOCONF) != 0 &amp;&amp;
		    ip6_use_tempaddr &amp;&amp;
		    pr-&gt;ndpr_addrcnt == 1) {
			addtmp = true;
		}
		NDPR_UNLOCK(pr);
	}

	IFA_UNLOCK(&amp;ia-&gt;ia_ifa);

	<span class="enscript-keyword">if</span> (addtmp) {
		<span class="enscript-type">int</span> e;
		e = in6_tmpifadd(ia, 1);
		<span class="enscript-keyword">if</span> (e != 0)
			log(LOG_NOTICE, <span class="enscript-string">&quot;%s: failed to create a&quot;</span>
			    <span class="enscript-string">&quot; temporary address, error=%d\n&quot;</span>,
			    __func__, e);
	}

	<span class="enscript-comment">/*
	 * This might affect the status of autoconfigured addresses, that is,
	 * this address might make other addresses detached.
	 */</span>
	lck_mtx_lock(nd6_mutex);
	pfxlist_onlink_check();
	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-comment">/* Drop use count held above during lookup/add */</span>
	NDPR_REMREF(pr);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (ia != NULL)
		IFA_REMREF(&amp;ia-&gt;ia_ifa);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">void</span>
<span class="enscript-function-name">in6ctl_difaddr</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> in6_ifaddr *ia)
{
	<span class="enscript-type">int</span> i = 0;
	<span class="enscript-type">struct</span> nd_prefix pr0, *pr;

	VERIFY(ifp != NULL &amp;&amp; ia != NULL);

	<span class="enscript-comment">/*
	 * If the address being deleted is the only one that owns
	 * the corresponding prefix, expire the prefix as well.
	 * XXX: theoretically, we don't have to worry about such
	 * relationship, since we separate the address management
	 * and the prefix management.  We do this, however, to provide
	 * as much backward compatibility as possible in terms of
	 * the ioctl operation.
	 * Note that in6_purgeaddr() will decrement ndpr_addrcnt.
	 */</span>
	IFA_LOCK(&amp;ia-&gt;ia_ifa);
	bzero(&amp;pr0, <span class="enscript-keyword">sizeof</span> (pr0));
	pr0.ndpr_ifp = ifp;
	pr0.ndpr_plen = in6_mask2len(&amp;ia-&gt;ia_prefixmask.sin6_addr, NULL);
	<span class="enscript-keyword">if</span> (pr0.ndpr_plen == 128) {
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">purgeaddr</span>;
	}
	pr0.ndpr_prefix = ia-&gt;ia_addr;
	pr0.ndpr_mask = ia-&gt;ia_prefixmask.sin6_addr;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; 4; i++) {
		pr0.ndpr_prefix.sin6_addr.s6_addr32[i] &amp;=
		    ia-&gt;ia_prefixmask.sin6_addr.s6_addr32[i];
	}
	IFA_UNLOCK(&amp;ia-&gt;ia_ifa);

	<span class="enscript-keyword">if</span> ((pr = nd6_prefix_lookup(&amp;pr0, ND6_PREFIX_EXPIRY_UNSPEC)) != NULL) {
		IFA_LOCK(&amp;ia-&gt;ia_ifa);
		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_addrcnt == 1) {
			<span class="enscript-comment">/* XXX: just for expiration */</span>
			pr-&gt;ndpr_expire = 1;
		}
		NDPR_UNLOCK(pr);
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);

		<span class="enscript-comment">/* Drop use count held above during lookup */</span>
		NDPR_REMREF(pr);
	}

<span class="enscript-reference">purgeaddr</span>:
	in6_purgeaddr(&amp;ia-&gt;ia_ifa);
}

<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">in6_autoconf</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> enable)
{
	<span class="enscript-type">int</span> error = 0;

	VERIFY(ifp != NULL);

	<span class="enscript-keyword">if</span> (ifp-&gt;if_flags &amp; IFF_LOOPBACK)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (enable) {
		<span class="enscript-comment">/*
		 * An interface in IPv6 router mode implies that it
		 * is either configured with a static IP address or
		 * autoconfigured via a locally-generated RA.  Prevent
		 * SIOCAUTOCONF_START from being set in that mode.
		 */</span>
		ifnet_lock_exclusive(ifp);
		<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_IPV6_ROUTER) {
			ifp-&gt;if_eflags &amp;= ~IFEF_ACCEPT_RTADV;
			error = EBUSY;
		} <span class="enscript-keyword">else</span> {
			ifp-&gt;if_eflags |= IFEF_ACCEPT_RTADV;
		}
		ifnet_lock_done(ifp);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> in6_ifaddr *ia = NULL;

		ifnet_lock_exclusive(ifp);
		ifp-&gt;if_eflags &amp;= ~IFEF_ACCEPT_RTADV;
		ifnet_lock_done(ifp);

		<span class="enscript-comment">/* Remove autoconfigured address from interface */</span>
		lck_rw_lock_exclusive(&amp;in6_ifaddr_rwlock);
		ia = in6_ifaddrs;
		<span class="enscript-keyword">while</span> (ia != NULL) {
			<span class="enscript-keyword">if</span> (ia-&gt;ia_ifa.ifa_ifp != ifp) {
				ia = ia-&gt;ia_next;
				<span class="enscript-keyword">continue</span>;
			}
			IFA_LOCK(&amp;ia-&gt;ia_ifa);
			<span class="enscript-keyword">if</span> (ia-&gt;ia6_flags &amp; IN6_IFF_AUTOCONF) {
				IFA_ADDREF_LOCKED(&amp;ia-&gt;ia_ifa);	<span class="enscript-comment">/* for us */</span>
				IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
				lck_rw_done(&amp;in6_ifaddr_rwlock);
				in6_purgeaddr(&amp;ia-&gt;ia_ifa);
				IFA_REMREF(&amp;ia-&gt;ia_ifa);	<span class="enscript-comment">/* for us */</span>
				lck_rw_lock_exclusive(&amp;in6_ifaddr_rwlock);
				<span class="enscript-comment">/*
				 * Purging the address caused in6_ifaddr_rwlock
				 * to be dropped and reacquired;
				 * therefore search again from the beginning
				 * of in6_ifaddrs list.
				 */</span>
				ia = in6_ifaddrs;
				<span class="enscript-keyword">continue</span>;
			}
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			ia = ia-&gt;ia_next;
		}
		lck_rw_done(&amp;in6_ifaddr_rwlock);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Handle SIOCSETROUTERMODE_IN6 to set or clear the IPv6 router mode flag on
 * the interface.  Entering or exiting this mode will result in the removal of
 * autoconfigured IPv6 addresses on the interface.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span>
<span class="enscript-function-name">in6_setrouter</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> enable)
{
	VERIFY(ifp != NULL);

	<span class="enscript-keyword">if</span> (ifp-&gt;if_flags &amp; IFF_LOOPBACK)
		<span class="enscript-keyword">return</span> (ENODEV);

	<span class="enscript-keyword">if</span> (enable) {
		<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;

		ndi = ND_IFINFO(ifp);
		<span class="enscript-keyword">if</span> (ndi != NULL &amp;&amp; ndi-&gt;initialized) {
			lck_mtx_lock(&amp;ndi-&gt;lock);
			<span class="enscript-keyword">if</span> (ndi-&gt;flags &amp; ND6_IFF_PROXY_PREFIXES) {
				<span class="enscript-comment">/* No proxy if we are an advertising router */</span>
				ndi-&gt;flags &amp;= ~ND6_IFF_PROXY_PREFIXES;
				lck_mtx_unlock(&amp;ndi-&gt;lock);
				(<span class="enscript-type">void</span>) nd6_if_prproxy(ifp, FALSE);
			} <span class="enscript-keyword">else</span> {
				lck_mtx_unlock(&amp;ndi-&gt;lock);
			}
		}
	}

	ifnet_lock_exclusive(ifp);
	<span class="enscript-keyword">if</span> (enable) {
		ifp-&gt;if_eflags |= IFEF_IPV6_ROUTER;
	} <span class="enscript-keyword">else</span> {
		ifp-&gt;if_eflags &amp;= ~IFEF_IPV6_ROUTER;
	}
	ifnet_lock_done(ifp);

	lck_mtx_lock(nd6_mutex);
	defrouter_select(ifp);
	lck_mtx_unlock(nd6_mutex);

	if_allmulti(ifp, enable);

	<span class="enscript-keyword">return</span> (in6_autoconf(ifp, FALSE));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">in6_to_kamescope</span>(<span class="enscript-type">struct</span> sockaddr_in6 *sin6, <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> sockaddr_in6 tmp;
	<span class="enscript-type">int</span> error, id;

	VERIFY(sin6 != NULL);
	tmp = *sin6;

	error = in6_recoverscope(&amp;tmp, &amp;sin6-&gt;sin6_addr, ifp);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (error);

	id = in6_addr2scopeid(ifp, &amp;tmp.sin6_addr);
	<span class="enscript-keyword">if</span> (tmp.sin6_scope_id == 0)
		tmp.sin6_scope_id = id;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tmp.sin6_scope_id != id)
		<span class="enscript-keyword">return</span> (EINVAL); <span class="enscript-comment">/* scope ID mismatch. */</span>

	error = in6_embedscope(&amp;tmp.sin6_addr, &amp;tmp, NULL, NULL, NULL);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (error);

	tmp.sin6_scope_id = 0;
	*sin6 = tmp;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">in6_ifaupdate_aux</span>(<span class="enscript-type">struct</span> in6_ifaddr *ia, <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">int</span> ifaupflags)
{
	<span class="enscript-type">struct</span> sockaddr_in6 mltaddr, mltmask;
	<span class="enscript-type">struct</span> in6_addr llsol;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span> in6_multi *in6m_sol;
	<span class="enscript-type">struct</span> in6_multi_mship *imm;
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">int</span> delay, error = 0;

	VERIFY(ifp != NULL &amp;&amp; ia != NULL);
	ifa = &amp;ia-&gt;ia_ifa;
	in6m_sol = NULL;

	nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s - %s ifp %s ia6_flags 0x%x ifaupflags 0x%x\n&quot;</span>,
	    __func__,
	    ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr),
	    if_name(ia-&gt;ia_ifp),
	    ia-&gt;ia6_flags,
	    ifaupflags));

	<span class="enscript-comment">/*
	 * Mark the address as tentative before joining multicast addresses,
	 * so that corresponding MLD responses would not have a tentative
	 * source address.
	 */</span>
	ia-&gt;ia6_flags &amp;= ~IN6_IFF_DUPLICATED;	<span class="enscript-comment">/* safety */</span>
	<span class="enscript-keyword">if</span> (in6if_do_dad(ifp))
		in6_ifaddr_set_dadprogress(ia);

	<span class="enscript-comment">/* Join necessary multicast groups */</span>
	<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_MULTICAST) != 0) {

		<span class="enscript-comment">/* join solicited multicast addr for new host id */</span>
		bzero(&amp;llsol, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr));
		llsol.s6_addr32[0] = IPV6_ADDR_INT32_MLL;
		llsol.s6_addr32[1] = 0;
		llsol.s6_addr32[2] = htonl(1);
		llsol.s6_addr32[3] = ia-&gt;ia_addr.sin6_addr.s6_addr32[3];
		llsol.s6_addr8[12] = 0xff;
		<span class="enscript-keyword">if</span> ((error = in6_setscope(&amp;llsol, ifp, NULL)) != 0) {
			<span class="enscript-comment">/* XXX: should not happen */</span>
			log(LOG_ERR, <span class="enscript-string">&quot;%s: in6_setscope failed\n&quot;</span>, __func__);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
		}
		delay = 0;
		<span class="enscript-keyword">if</span> ((ifaupflags &amp; IN6_IFAUPDATE_DADDELAY)) {
			<span class="enscript-comment">/*
			 * We need a random delay for DAD on the address
			 * being configured.  It also means delaying
			 * transmission of the corresponding MLD report to
			 * avoid report collision. [RFC 4862]
			 */</span>
			delay = random() % MAX_RTR_SOLICITATION_DELAY;
		}
		imm = in6_joingroup(ifp, &amp;llsol, &amp;error, delay);
		<span class="enscript-keyword">if</span> (imm == NULL) {
			nd6log((LOG_WARNING,
			    <span class="enscript-string">&quot;%s: addmulti failed for %s on %s (errno=%d)\n&quot;</span>,
			    __func__, ip6_sprintf(&amp;llsol), if_name(ifp),
			    error));
			VERIFY(error != 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
		}
		in6m_sol = imm-&gt;i6mm_maddr;
		<span class="enscript-comment">/* take a refcount for this routine */</span>
		IN6M_ADDREF(in6m_sol);

		IFA_LOCK_SPIN(ifa);
		LIST_INSERT_HEAD(&amp;ia-&gt;ia6_memberships, imm, i6mm_chain);
		IFA_UNLOCK(ifa);

		bzero(&amp;mltmask, <span class="enscript-keyword">sizeof</span> (mltmask));
		mltmask.sin6_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
		mltmask.sin6_family = AF_INET6;
		mltmask.sin6_addr = in6mask32;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MLTMASK_LEN</span>  4	<span class="enscript-comment">/* mltmask's masklen (=32bit=4octet) */</span>

		<span class="enscript-comment">/*
		 * join link-local all-nodes address
		 */</span>
		bzero(&amp;mltaddr, <span class="enscript-keyword">sizeof</span> (mltaddr));
		mltaddr.sin6_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
		mltaddr.sin6_family = AF_INET6;
		mltaddr.sin6_addr = in6addr_linklocal_allnodes;
		<span class="enscript-keyword">if</span> ((error = in6_setscope(&amp;mltaddr.sin6_addr, ifp, NULL)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>; <span class="enscript-comment">/* XXX: should not fail */</span>

		<span class="enscript-comment">/*
		 * XXX: do we really need this automatic routes?
		 * We should probably reconsider this stuff.  Most applications
		 * actually do not need the routes, since they usually specify
		 * the outgoing interface.
		 */</span>
		rt = rtalloc1_scoped((<span class="enscript-type">struct</span> sockaddr *)&amp;mltaddr, 0, 0UL,
		    ia-&gt;ia_ifp-&gt;if_index);
		<span class="enscript-keyword">if</span> (rt) {
			<span class="enscript-keyword">if</span> (memcmp(&amp;mltaddr.sin6_addr, &amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)
			    (<span class="enscript-type">void</span> *)rt_key(rt))-&gt;sin6_addr, MLTMASK_LEN)) {
				rtfree(rt);
				rt = NULL;
			}
		}
		<span class="enscript-keyword">if</span> (!rt) {
			error = rtrequest_scoped(RTM_ADD,
			    (<span class="enscript-type">struct</span> sockaddr *)&amp;mltaddr,
			    (<span class="enscript-type">struct</span> sockaddr *)&amp;ia-&gt;ia_addr,
			    (<span class="enscript-type">struct</span> sockaddr *)&amp;mltmask, RTF_UP | RTF_CLONING,
			    NULL, ia-&gt;ia_ifp-&gt;if_index);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
		} <span class="enscript-keyword">else</span> {
			rtfree(rt);
		}

		imm = in6_joingroup(ifp, &amp;mltaddr.sin6_addr, &amp;error, 0);
		<span class="enscript-keyword">if</span> (!imm) {
			nd6log((LOG_WARNING,
			    <span class="enscript-string">&quot;%s: addmulti failed for %s on %s (errno=%d)\n&quot;</span>,
			    __func__, ip6_sprintf(&amp;mltaddr.sin6_addr),
			    if_name(ifp), error));
			VERIFY(error != 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
		}
		IFA_LOCK_SPIN(ifa);
		LIST_INSERT_HEAD(&amp;ia-&gt;ia6_memberships, imm, i6mm_chain);
		IFA_UNLOCK(ifa);

		<span class="enscript-comment">/*
		 * join node information group address
		 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">hostnamelen</span>	strlen(hostname)
		delay = 0;
		<span class="enscript-keyword">if</span> ((ifaupflags &amp; IN6_IFAUPDATE_DADDELAY)) {
			<span class="enscript-comment">/*
			 * The spec doesn't say anything about delay for this
			 * group, but the same logic should apply.
			 */</span>
			delay = random() % MAX_RTR_SOLICITATION_DELAY;
		}
		<span class="enscript-keyword">if</span> (in6_nigroup(ifp, hostname, hostnamelen, &amp;mltaddr.sin6_addr)
		    == 0) {
			imm = in6_joingroup(ifp, &amp;mltaddr.sin6_addr, &amp;error,
			    delay); <span class="enscript-comment">/* XXX jinmei */</span>
			<span class="enscript-keyword">if</span> (!imm) {
				nd6log((LOG_WARNING,
				    <span class="enscript-string">&quot;%s: addmulti failed for %s on %s &quot;</span>
				    <span class="enscript-string">&quot;(errno=%d)\n&quot;</span>,
				    __func__, ip6_sprintf(&amp;mltaddr.sin6_addr),
				    if_name(ifp), error));
				<span class="enscript-comment">/* XXX not very fatal, go on... */</span>
				error = 0;
			} <span class="enscript-keyword">else</span> {
				IFA_LOCK_SPIN(ifa);
				LIST_INSERT_HEAD(&amp;ia-&gt;ia6_memberships,
				    imm, i6mm_chain);
				IFA_UNLOCK(ifa);
			}
		}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">hostnamelen</span>

		<span class="enscript-comment">/*
		 * join interface-local all-nodes address.
		 * (ff01::1%ifN, and ff01::%ifN/32)
		 */</span>
		mltaddr.sin6_addr = in6addr_nodelocal_allnodes;
		<span class="enscript-keyword">if</span> ((error = in6_setscope(&amp;mltaddr.sin6_addr, ifp, NULL)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>; <span class="enscript-comment">/* XXX: should not fail */</span>
		<span class="enscript-comment">/* XXX: again, do we really need the route? */</span>
		rt = rtalloc1_scoped((<span class="enscript-type">struct</span> sockaddr *)&amp;mltaddr, 0, 0UL,
		    ia-&gt;ia_ifp-&gt;if_index);
		<span class="enscript-keyword">if</span> (rt) {
			<span class="enscript-keyword">if</span> (memcmp(&amp;mltaddr.sin6_addr, &amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)
			    (<span class="enscript-type">void</span> *)rt_key(rt))-&gt;sin6_addr, MLTMASK_LEN)) {
				rtfree(rt);
				rt = NULL;
			}
		}
		<span class="enscript-keyword">if</span> (!rt) {
			error = rtrequest_scoped(RTM_ADD,
			    (<span class="enscript-type">struct</span> sockaddr *)&amp;mltaddr,
			    (<span class="enscript-type">struct</span> sockaddr *)&amp;ia-&gt;ia_addr,
			    (<span class="enscript-type">struct</span> sockaddr *)&amp;mltmask, RTF_UP | RTF_CLONING,
			    NULL, ia-&gt;ia_ifp-&gt;if_index);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
		} <span class="enscript-keyword">else</span>
			rtfree(rt);

		imm = in6_joingroup(ifp, &amp;mltaddr.sin6_addr, &amp;error, 0);
		<span class="enscript-keyword">if</span> (!imm) {
			nd6log((LOG_WARNING,
			    <span class="enscript-string">&quot;%s: addmulti failed for %s on %s (errno=%d)\n&quot;</span>,
			    __func__, ip6_sprintf(&amp;mltaddr.sin6_addr),
			    if_name(ifp), error));
			VERIFY(error != 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
		}
		IFA_LOCK(ifa);
		LIST_INSERT_HEAD(&amp;ia-&gt;ia6_memberships, imm, i6mm_chain);
		IFA_UNLOCK(ifa);
	}
#<span class="enscript-reference">undef</span>	<span class="enscript-variable-name">MLTMASK_LEN</span>

	<span class="enscript-comment">/* Ensure nd6_service() is scheduled as soon as it's convenient */</span>
	++nd6_sched_timeout_want;

	<span class="enscript-comment">/*
	 * Perform DAD, if needed.
	 * XXX It may be of use, if we can administratively
	 * disable DAD.
	 */</span>
	IFA_LOCK_SPIN(ifa);
	<span class="enscript-keyword">if</span> (in6if_do_dad(ifp) &amp;&amp; ((ifa-&gt;ifa_flags &amp; IN6_IFF_NODAD) == 0) &amp;&amp;
	    (ia-&gt;ia6_flags &amp; IN6_IFF_DADPROGRESS)) {
		<span class="enscript-type">int</span> mindelay, maxdelay;
		<span class="enscript-type">int</span> *delayptr, delayval;

		IFA_UNLOCK(ifa);
		delayptr = NULL;
		<span class="enscript-comment">/*
		 * Avoid the DAD delay if the caller wants us to skip it.
		 * This is not compliant with RFC 2461, but it's only being
		 * used for signalling and not for actual DAD.
		 */</span>
		<span class="enscript-keyword">if</span> ((ifaupflags &amp; IN6_IFAUPDATE_DADDELAY) &amp;&amp;
		    !(ia-&gt;ia6_flags &amp; IN6_IFF_SWIFTDAD)) {
			<span class="enscript-comment">/*
			 * We need to impose a delay before sending an NS
			 * for DAD.  Check if we also needed a delay for the
			 * corresponding MLD message.  If we did, the delay
			 * should be larger than the MLD delay (this could be
			 * relaxed a bit, but this simple logic is at least
			 * safe).
			 */</span>
			mindelay = 0;
			<span class="enscript-keyword">if</span> (in6m_sol != NULL) {
				IN6M_LOCK(in6m_sol);
				<span class="enscript-keyword">if</span> (in6m_sol-&gt;in6m_state ==
				    MLD_REPORTING_MEMBER)
					mindelay = in6m_sol-&gt;in6m_timer;
				IN6M_UNLOCK(in6m_sol);
			}
			maxdelay = MAX_RTR_SOLICITATION_DELAY * hz;
			<span class="enscript-keyword">if</span> (maxdelay - mindelay == 0)
				delayval = 0;
			<span class="enscript-keyword">else</span> {
				delayval =
				    (random() % (maxdelay - mindelay)) +
				    mindelay;
			}
			delayptr = &amp;delayval;
		}

		nd6_dad_start((<span class="enscript-type">struct</span> ifaddr *)ia, delayptr);
	} <span class="enscript-keyword">else</span> {
		IFA_UNLOCK(ifa);
	}

	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

<span class="enscript-reference">unwind</span>:
	VERIFY(error != 0);
	in6_purgeaddr(&amp;ia-&gt;ia_ifa);

<span class="enscript-reference">done</span>:
	<span class="enscript-comment">/* release reference held for this routine */</span>
	<span class="enscript-keyword">if</span> (in6m_sol != NULL)
		IN6M_REMREF(in6m_sol);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Request an IPv6 interface address.  If the address is new, then it will be
 * constructed and appended to the interface address chains.  The interface
 * address structure is optionally returned with a reference for the caller.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_update_ifa</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> in6_aliasreq *ifra, <span class="enscript-type">int</span> ifaupflags,
    <span class="enscript-type">struct</span> in6_ifaddr **iar)
{
	<span class="enscript-type">struct</span> in6_addrlifetime ia6_lt;
	<span class="enscript-type">struct</span> in6_ifaddr *ia;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span> ifaddr *xifa;
	<span class="enscript-type">struct</span> in6_addrlifetime *lt;
	uint64_t timenow;
	<span class="enscript-type">int</span> plen, error;

	<span class="enscript-comment">/* Sanity check parameters and initialize locals */</span>
	VERIFY(ifp != NULL &amp;&amp; ifra != NULL &amp;&amp; iar != NULL);
	ia = NULL;
	ifa = NULL;
	error = 0;

	<span class="enscript-comment">/*
	 * We always require users to specify a valid IPv6 address for
	 * the corresponding operation.
	 */</span>
	<span class="enscript-keyword">if</span> (ifra-&gt;ifra_addr.sin6_family != AF_INET6 ||
	    ifra-&gt;ifra_addr.sin6_len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)) {
		error = EAFNOSUPPORT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
	}

	<span class="enscript-comment">/* Validate ifra_prefixmask.sin6_len is properly bounded. */</span>
	<span class="enscript-keyword">if</span> (ifra-&gt;ifra_prefixmask.sin6_len == 0 ||
	    ifra-&gt;ifra_prefixmask.sin6_len &gt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
	}

	<span class="enscript-comment">/* Validate prefix length extracted from ifra_prefixmask structure. */</span>
	plen = in6_mask2len(&amp;ifra-&gt;ifra_prefixmask.sin6_addr,
	    (u_char *)&amp;ifra-&gt;ifra_prefixmask + ifra-&gt;ifra_prefixmask.sin6_len);
	<span class="enscript-keyword">if</span> (plen &lt;= 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
	}

	<span class="enscript-comment">/* Validate lifetimes */</span>
	lt = &amp;ifra-&gt;ifra_lifetime;
	<span class="enscript-keyword">if</span> (lt-&gt;ia6t_pltime &gt; lt-&gt;ia6t_vltime) {
		log(LOG_INFO,
		    <span class="enscript-string">&quot;%s: pltime 0x%x &gt; vltime 0x%x for %s\n&quot;</span>, __func__,
		    lt-&gt;ia6t_pltime, lt-&gt;ia6t_vltime,
		    ip6_sprintf(&amp;ifra-&gt;ifra_addr.sin6_addr));
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
	}
	<span class="enscript-keyword">if</span> (lt-&gt;ia6t_vltime == 0) {
		<span class="enscript-comment">/*
		 * the following log might be noisy, but this is a typical
		 * configuration mistake or a tool's bug.
		 */</span>
		log(LOG_INFO, <span class="enscript-string">&quot;%s: valid lifetime is 0 for %s\n&quot;</span>, __func__,
		    ip6_sprintf(&amp;ifra-&gt;ifra_addr.sin6_addr));
	}

	<span class="enscript-comment">/*
	 * Before we lock the ifnet structure, we first check to see if the
	 * address already exists. If so, then we don't allocate and link a
	 * new one here.
	 */</span>
	ia = in6ifa_ifpwithaddr(ifp, &amp;ifra-&gt;ifra_addr.sin6_addr);
	<span class="enscript-keyword">if</span> (ia != NULL)
		ifa = &amp;ia-&gt;ia_ifa;

	<span class="enscript-comment">/*
	 * Validate destination address on interface types that require it.
	 */</span>
	<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; (IFF_LOOPBACK|IFF_POINTOPOINT)) != 0) {
		<span class="enscript-keyword">switch</span> (ifra-&gt;ifra_dstaddr.sin6_family) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
			<span class="enscript-keyword">if</span> (plen != 128) {
				<span class="enscript-comment">/* noisy message for diagnostic purposes */</span>
				log(LOG_INFO,
				    <span class="enscript-string">&quot;%s: prefix length &lt; 128 with&quot;</span>
				    <span class="enscript-string">&quot; explicit dstaddr.\n&quot;</span>, __func__);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_UNSPEC</span>:
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = EAFNOSUPPORT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifra-&gt;ifra_dstaddr.sin6_family != AF_UNSPEC) {
		log(LOG_INFO,
		    <span class="enscript-string">&quot;%s: dstaddr valid only on p2p and loopback interfaces.\n&quot;</span>,
		    __func__);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
	}

	timenow = net_uptime();

	<span class="enscript-keyword">if</span> (ia == NULL) {
		<span class="enscript-type">int</span> how;

		<span class="enscript-comment">/* Is this the first new IPv6 address for the interface? */</span>
		ifaupflags |= IN6_IFAUPDATE_NEWADDR;

		<span class="enscript-comment">/* Allocate memory for IPv6 interface address structure. */</span>
		how = !(ifaupflags &amp; IN6_IFAUPDATE_NOWAIT) ? M_WAITOK : 0;
		ia = in6_ifaddr_alloc(how);
		<span class="enscript-keyword">if</span> (ia == NULL) {
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
		}

		ifa = &amp;ia-&gt;ia_ifa;

		<span class="enscript-comment">/*
		 * Initialize interface address structure.
		 *
		 * Note well: none of these sockaddr_in6 structures contain a
		 * valid sin6_port, sin6_flowinfo or even a sin6_scope_id field.
		 * We still embed link-local scope identifiers at the end of an
		 * arbitrary fe80::/32 prefix, for historical reasons. Also, the
		 * ifa_dstaddr field is always non-NULL on point-to-point and
		 * loopback interfaces, and conventionally points to a socket
		 * address of AF_UNSPEC family when there is no destination.
		 *
		 * Please enjoy the dancing sea turtle.
		 */</span>
		IFA_ADDREF(ifa); <span class="enscript-comment">/* for this and optionally for caller */</span>
		ifa-&gt;ifa_addr = (<span class="enscript-type">struct</span> sockaddr *)&amp;ia-&gt;ia_addr;
		<span class="enscript-keyword">if</span> (ifra-&gt;ifra_dstaddr.sin6_family == AF_INET6 ||
		    (ifp-&gt;if_flags &amp; (IFF_POINTOPOINT | IFF_LOOPBACK)) != 0)
			ifa-&gt;ifa_dstaddr = (<span class="enscript-type">struct</span> sockaddr *)&amp;ia-&gt;ia_dstaddr;
		ifa-&gt;ifa_netmask = (<span class="enscript-type">struct</span> sockaddr *)&amp;ia-&gt;ia_prefixmask;
		ifa-&gt;ifa_ifp = ifp;
		ifa-&gt;ifa_metric = ifp-&gt;if_metric;
		ifa-&gt;ifa_rtrequest = nd6_rtrequest;

		LIST_INIT(&amp;ia-&gt;ia6_memberships);
		ia-&gt;ia_addr.sin6_family = AF_INET6;
		ia-&gt;ia_addr.sin6_len = <span class="enscript-keyword">sizeof</span> (ia-&gt;ia_addr);
		ia-&gt;ia_addr.sin6_addr = ifra-&gt;ifra_addr.sin6_addr;
		ia-&gt;ia_prefixmask.sin6_family = AF_INET6;
		ia-&gt;ia_prefixmask.sin6_len = <span class="enscript-keyword">sizeof</span> (ia-&gt;ia_prefixmask);
		ia-&gt;ia_prefixmask.sin6_addr = ifra-&gt;ifra_prefixmask.sin6_addr;
		error = in6_to_kamescope(&amp;ia-&gt;ia_addr, ifp);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_dstaddr != NULL) {
			ia-&gt;ia_dstaddr = ifra-&gt;ifra_dstaddr;
			error = in6_to_kamescope(&amp;ia-&gt;ia_dstaddr, ifp);
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;
		}

		<span class="enscript-comment">/* Append to address chains */</span>
		ifnet_lock_exclusive(ifp);
		ifaupflags |= IN6_IFAUPDATE_1STADDR;
		TAILQ_FOREACH(xifa, &amp;ifp-&gt;if_addrlist, ifa_list) {
			IFA_LOCK_SPIN(xifa);
			<span class="enscript-keyword">if</span> (xifa-&gt;ifa_addr-&gt;sa_family != AF_INET6) {
				IFA_UNLOCK(xifa);
				ifaupflags &amp;= ~IN6_IFAUPDATE_1STADDR;
				<span class="enscript-keyword">break</span>;
			}
			IFA_UNLOCK(xifa);
		}

		IFA_LOCK_SPIN(ifa);
		if_attach_ifa(ifp, ifa); <span class="enscript-comment">/* holds reference for ifnet link */</span>
		IFA_UNLOCK(ifa);
		ifnet_lock_done(ifp);

		lck_rw_lock_exclusive(&amp;in6_ifaddr_rwlock);
		<span class="enscript-keyword">if</span> (in6_ifaddrs != NULL) {
			<span class="enscript-type">struct</span> in6_ifaddr *iac;
			<span class="enscript-keyword">for</span> (iac = in6_ifaddrs; iac-&gt;ia_next != NULL;
			    iac = iac-&gt;ia_next)
				<span class="enscript-keyword">continue</span>;
			iac-&gt;ia_next = ia;
		} <span class="enscript-keyword">else</span> {
			in6_ifaddrs = ia;
		}
		IFA_ADDREF(ifa); <span class="enscript-comment">/* hold for in6_ifaddrs link */</span>
		lck_rw_done(&amp;in6_ifaddr_rwlock);
	} <span class="enscript-keyword">else</span> {
		ifa = &amp;ia-&gt;ia_ifa;
		ifaupflags &amp;= ~(IN6_IFAUPDATE_NEWADDR|IN6_IFAUPDATE_1STADDR);
	}

	VERIFY(ia != NULL &amp;&amp; ifa == &amp;ia-&gt;ia_ifa);
	IFA_LOCK(ifa);

	<span class="enscript-comment">/*
	 * Set lifetimes.  We do not refer to ia6t_expire and ia6t_preferred
	 * to see if the address is deprecated or invalidated, but initialize
	 * these members for applications.
	 */</span>
	ia-&gt;ia6_updatetime = ia-&gt;ia6_createtime = timenow;
	ia6_lt = *lt;
	<span class="enscript-keyword">if</span> (ia6_lt.ia6t_vltime != ND6_INFINITE_LIFETIME)
		ia6_lt.ia6t_expire = timenow + ia6_lt.ia6t_vltime;
	<span class="enscript-keyword">else</span>
		ia6_lt.ia6t_expire = 0;
	<span class="enscript-keyword">if</span> (ia6_lt.ia6t_pltime != ND6_INFINITE_LIFETIME)
		ia6_lt.ia6t_preferred = timenow + ia6_lt.ia6t_pltime;
	<span class="enscript-keyword">else</span>
		ia6_lt.ia6t_preferred = 0;
	in6ifa_setlifetime(ia, &amp;ia6_lt);

	<span class="enscript-comment">/*
	 * Backward compatibility - if IN6_IFF_DEPRECATED is set from the
	 * userland, make it deprecated.
	 */</span>
	<span class="enscript-keyword">if</span> ((ia-&gt;ia6_flags &amp; IN6_IFF_DEPRECATED) != 0) {
		ia-&gt;ia6_lifetime.ia6ti_pltime = 0;
		ia-&gt;ia6_lifetime.ia6ti_preferred = timenow;
	}

	<span class="enscript-comment">/*
	 * Do not delay sending neighbor solicitations when using optimistic
	 * duplicate address detection, c.f. RFC 4429.
	 */</span>
	<span class="enscript-keyword">if</span> ((ia-&gt;ia6_flags &amp; IN6_IFF_OPTIMISTIC) == 0)
		ifaupflags |= IN6_IFAUPDATE_DADDELAY;

	<span class="enscript-comment">/*
	 * Update flag or prefix length
	 */</span>
	ia-&gt;ia_plen = plen;
	ia-&gt;ia6_flags = ifra-&gt;ifra_flags;

	<span class="enscript-comment">/* Release locks (new address available to concurrent tasks) */</span>
	IFA_UNLOCK(ifa);

	<span class="enscript-comment">/* Further initialization of the interface address */</span>
	error = in6_ifinit(ifp, ia, ifaupflags);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;

	<span class="enscript-comment">/* Finish updating the address while other tasks are working with it */</span>
	error = in6_ifaupdate_aux(ia, ifp, ifaupflags);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">unwind</span>;

	<span class="enscript-comment">/* Return success (optionally w/ address for caller). */</span>
	VERIFY(error == 0);
	(<span class="enscript-type">void</span>) ifnet_notify_address(ifp, AF_INET6);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

<span class="enscript-reference">unwind</span>:
	VERIFY(error != 0);
	<span class="enscript-keyword">if</span> (ia != NULL) {
		VERIFY(ifa == &amp;ia-&gt;ia_ifa);
		IFA_REMREF(ifa);
		ia = NULL;
	}

<span class="enscript-reference">done</span>:
	*iar = ia;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_purgeaddr</span>(<span class="enscript-type">struct</span> ifaddr *ifa)
{
	<span class="enscript-type">struct</span> ifnet *ifp = ifa-&gt;ifa_ifp;
	<span class="enscript-type">struct</span> in6_ifaddr *ia = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;
	<span class="enscript-type">struct</span> in6_multi_mship *imm;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_NOTOWNED);

	<span class="enscript-comment">/* stop DAD processing */</span>
	nd6_dad_stop(ifa);

	<span class="enscript-comment">/*
	 * delete route to the destination of the address being purged.
	 * The interface must be p2p or loopback in this case.
	 */</span>
	IFA_LOCK(ifa);
	<span class="enscript-keyword">if</span> ((ia-&gt;ia_flags &amp; IFA_ROUTE) &amp;&amp; ia-&gt;ia_plen == 128) {
		<span class="enscript-type">int</span> error, rtf;

		IFA_UNLOCK(ifa);
		rtf = (ia-&gt;ia_dstaddr.sin6_family == AF_INET6) ? RTF_HOST : 0;
		error = rtinit(&amp;(ia-&gt;ia_ifa), RTM_DELETE, rtf);
		<span class="enscript-keyword">if</span> (error != 0) {
			log(LOG_ERR, <span class="enscript-string">&quot;in6_purgeaddr: failed to remove &quot;</span>
			    <span class="enscript-string">&quot;a route to the p2p destination: %s on %s, &quot;</span>
			    <span class="enscript-string">&quot;errno=%d\n&quot;</span>,
			    ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr), if_name(ifp),
			    error);
			<span class="enscript-comment">/* proceed anyway... */</span>
		}
		IFA_LOCK_SPIN(ifa);
		ia-&gt;ia_flags &amp;= ~IFA_ROUTE;
	}
	IFA_UNLOCK(ifa);

	<span class="enscript-comment">/* Remove ownaddr's loopback rtentry, if it exists. */</span>
	in6_ifremloop(&amp;(ia-&gt;ia_ifa));

	<span class="enscript-comment">/*
	 * leave from multicast groups we have joined for the interface
	 */</span>
	IFA_LOCK(ifa);
	<span class="enscript-keyword">while</span> ((imm = ia-&gt;ia6_memberships.lh_first) != NULL) {
		LIST_REMOVE(imm, i6mm_chain);
		IFA_UNLOCK(ifa);
		in6_leavegroup(imm);
		IFA_LOCK(ifa);
	}
	IFA_UNLOCK(ifa);

	<span class="enscript-comment">/* in6_unlink_ifa() will need exclusive access */</span>
	in6_unlink_ifa(ia, ifp);
	in6_post_msg(ifp, KEV_INET6_ADDR_DELETED, ia, NULL);

	(<span class="enscript-type">void</span>) ifnet_notify_address(ifp, AF_INET6);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in6_unlink_ifa</span>(<span class="enscript-type">struct</span> in6_ifaddr *ia, <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> in6_ifaddr *oia;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">int</span> unlinked;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_NOTOWNED);

	ifa = &amp;ia-&gt;ia_ifa;
	IFA_ADDREF(ifa);

	ifnet_lock_exclusive(ifp);
	IFA_LOCK(ifa);
	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_debug &amp; IFD_ATTACHED)
		if_detach_ifa(ifp, ifa);
	IFA_UNLOCK(ifa);
	ifnet_lock_done(ifp);

	unlinked = 1;
	lck_rw_lock_exclusive(&amp;in6_ifaddr_rwlock);
	oia = ia;
	<span class="enscript-keyword">if</span> (oia == (ia = in6_ifaddrs)) {
		in6_ifaddrs = ia-&gt;ia_next;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">while</span> (ia-&gt;ia_next &amp;&amp; (ia-&gt;ia_next != oia))
			ia = ia-&gt;ia_next;
		<span class="enscript-keyword">if</span> (ia-&gt;ia_next) {
			ia-&gt;ia_next = oia-&gt;ia_next;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* search failed */</span>
			log(LOG_NOTICE, <span class="enscript-string">&quot;%s: search failed.\n&quot;</span>, __func__);
			unlinked = 0;
		}
	}

	<span class="enscript-comment">/*
	 * When IPv6 address is being removed, release the
	 * reference to the base prefix.
	 * Also, since the release might, affect the status
	 * of other (detached) addresses, call
	 * pfxlist_onlink_check().
	 */</span>
	ifa = &amp;oia-&gt;ia_ifa;
	IFA_LOCK(ifa);
	<span class="enscript-keyword">if</span> (oia-&gt;ia6_ndpr == NULL) {
		log(LOG_NOTICE, <span class="enscript-string">&quot;in6_unlink_ifa: IPv6 address &quot;</span>
		    <span class="enscript-string">&quot;0x%llx has no prefix\n&quot;</span>,
		    (uint64_t)VM_KERNEL_ADDRPERM(oia));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> nd_prefix *pr = oia-&gt;ia6_ndpr;
		oia-&gt;ia6_flags &amp;= ~IN6_IFF_AUTOCONF;
		oia-&gt;ia6_ndpr = NULL;
		NDPR_LOCK(pr);
		VERIFY(pr-&gt;ndpr_addrcnt != 0);
		pr-&gt;ndpr_addrcnt--;
		NDPR_UNLOCK(pr);
		NDPR_REMREF(pr);	<span class="enscript-comment">/* release addr reference */</span>
	}
	IFA_UNLOCK(ifa);
	lck_rw_done(&amp;in6_ifaddr_rwlock);

	<span class="enscript-keyword">if</span> ((oia-&gt;ia6_flags &amp; IN6_IFF_AUTOCONF) != 0) {
		lck_mtx_lock(nd6_mutex);
		pfxlist_onlink_check();
		lck_mtx_unlock(nd6_mutex);
	}
	<span class="enscript-comment">/*
	 * release another refcnt for the link from in6_ifaddrs.
	 * Do this only if it's not already unlinked in the event that we lost
	 * the race, since in6_ifaddr_rwlock was momentarily dropped above.
	 */</span>
	<span class="enscript-keyword">if</span> (unlinked)
		IFA_REMREF(ifa);

	<span class="enscript-comment">/* release reference held for this routine */</span>
	IFA_REMREF(ifa);

	<span class="enscript-comment">/* invalidate route caches */</span>
	routegenid_inet6_update();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_purgeif</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> in6_ifaddr *ia;

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span>;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_NOTOWNED);

	lck_rw_lock_exclusive(&amp;in6_ifaddr_rwlock);
	ia = in6_ifaddrs;
	<span class="enscript-keyword">while</span> (ia != NULL) {
		<span class="enscript-keyword">if</span> (ia-&gt;ia_ifa.ifa_ifp != ifp) {
			ia = ia-&gt;ia_next;
			<span class="enscript-keyword">continue</span>;
		}
		IFA_ADDREF(&amp;ia-&gt;ia_ifa);	<span class="enscript-comment">/* for us */</span>
		lck_rw_done(&amp;in6_ifaddr_rwlock);
		in6_purgeaddr(&amp;ia-&gt;ia_ifa);
		IFA_REMREF(&amp;ia-&gt;ia_ifa);	<span class="enscript-comment">/* for us */</span>
		lck_rw_lock_exclusive(&amp;in6_ifaddr_rwlock);
		<span class="enscript-comment">/*
		 * Purging the address would have caused
		 * in6_ifaddr_rwlock to be dropped and reacquired;
		 * therefore search again from the beginning
		 * of in6_ifaddrs list.
		 */</span>
		ia = in6_ifaddrs;
	}
	lck_rw_done(&amp;in6_ifaddr_rwlock);

	in6_ifdetach(ifp);
}

<span class="enscript-comment">/*
 * Initialize an interface's internet6 address and routing table entry.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">in6_ifinit</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> in6_ifaddr *ia, <span class="enscript-type">int</span> ifaupflags)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> ifaddr *ifa;

	error = 0;
	ifa = &amp;ia-&gt;ia_ifa;

	<span class="enscript-comment">/*
	 * NOTE: SIOCSIFADDR is defined with struct ifreq as parameter,
	 * but here we are sending it down to the interface with a pointer
	 * to struct ifaddr, for legacy reasons.
	 */</span>
	<span class="enscript-keyword">if</span> ((ifaupflags &amp; IN6_IFAUPDATE_1STADDR) != 0) {
		error = ifnet_ioctl(ifp, PF_INET6, SIOCSIFADDR, ia);
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-keyword">if</span> (error != EOPNOTSUPP)
				<span class="enscript-keyword">return</span> (error);
			error = 0;
		}
	}

	IFA_LOCK(ifa);

	<span class="enscript-comment">/*
	 * Special case:
	 * If the destination address is specified for a point-to-point
	 * interface, install a route to the destination as an interface
	 * direct route.
	 */</span>
	<span class="enscript-keyword">if</span> (!(ia-&gt;ia_flags &amp; IFA_ROUTE) &amp;&amp; ia-&gt;ia_plen == 128 &amp;&amp;
	    ia-&gt;ia_dstaddr.sin6_family == AF_INET6) {
		IFA_UNLOCK(ifa);
		error = rtinit(ifa, RTM_ADD, RTF_UP | RTF_HOST);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">return</span> (error);
		IFA_LOCK(ifa);
		ia-&gt;ia_flags |= IFA_ROUTE;
	}
	IFA_LOCK_ASSERT_HELD(ifa);
	<span class="enscript-keyword">if</span> (ia-&gt;ia_plen &lt; 128) {
		<span class="enscript-comment">/*
		 * The RTF_CLONING flag is necessary for in6_is_ifloop_auto().
		 */</span>
		ia-&gt;ia_flags |= RTF_CLONING;
	}

	IFA_UNLOCK(ifa);

	<span class="enscript-comment">/* Add ownaddr as loopback rtentry, if necessary (ex. on p2p link). */</span>
	<span class="enscript-keyword">if</span> ((ifaupflags &amp; IN6_IFAUPDATE_NEWADDR) != 0)
		in6_ifaddloop(ifa);

	<span class="enscript-comment">/* invalidate route caches */</span>
	routegenid_inet6_update();

	VERIFY(error == 0);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_purgeaddrs</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	in6_purgeif(ifp);
}

<span class="enscript-comment">/*
 * Find an IPv6 interface link-local address specific to an interface.
 */</span>
<span class="enscript-type">struct</span> in6_ifaddr *
<span class="enscript-function-name">in6ifa_ifpforlinklocal</span>(ifp, ignoreflags)
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">int</span> ignoreflags;
{
	<span class="enscript-type">struct</span> ifaddr *ifa;

	ifnet_lock_shared(ifp);
	TAILQ_FOREACH(ifa, &amp;ifp-&gt;if_addrlist, ifa_list)
	{
		IFA_LOCK_SPIN(ifa);
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(IFA_IN6(ifa))) {
			<span class="enscript-keyword">if</span> ((((<span class="enscript-type">struct</span> in6_ifaddr *)ifa)-&gt;ia6_flags &amp;
			    ignoreflags) != 0) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}
			IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for caller */</span>
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">break</span>;
		}
		IFA_UNLOCK(ifa);
	}
	ifnet_lock_done(ifp);

	<span class="enscript-keyword">return</span> ((<span class="enscript-type">struct</span> in6_ifaddr *)ifa);
}

<span class="enscript-comment">/*
 * find the internet address corresponding to a given interface and address.
 */</span>
<span class="enscript-type">struct</span> in6_ifaddr *
<span class="enscript-function-name">in6ifa_ifpwithaddr</span>(ifp, addr)
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> in6_addr *addr;
{
	<span class="enscript-type">struct</span> ifaddr *ifa;

	ifnet_lock_shared(ifp);
	TAILQ_FOREACH(ifa, &amp;ifp-&gt;if_addrlist, ifa_list)
	{
		IFA_LOCK_SPIN(ifa);
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(addr, IFA_IN6(ifa))) {
			IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for caller */</span>
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">break</span>;
		}
		IFA_UNLOCK(ifa);
	}
	ifnet_lock_done(ifp);

	<span class="enscript-keyword">return</span> ((<span class="enscript-type">struct</span> in6_ifaddr *)ifa);
}

<span class="enscript-type">struct</span> in6_ifaddr *
<span class="enscript-function-name">in6ifa_prproxyaddr</span>(<span class="enscript-type">struct</span> in6_addr *addr)
{
	<span class="enscript-type">struct</span> in6_ifaddr *ia;

	lck_rw_lock_shared(&amp;in6_ifaddr_rwlock);
	<span class="enscript-keyword">for</span> (ia = in6_ifaddrs; ia; ia = ia-&gt;ia_next) {
		IFA_LOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(addr, IFA_IN6(&amp;ia-&gt;ia_ifa))) {
			IFA_ADDREF_LOCKED(&amp;ia-&gt;ia_ifa);	<span class="enscript-comment">/* for caller */</span>
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			<span class="enscript-keyword">break</span>;
		}
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
	}
	lck_rw_done(&amp;in6_ifaddr_rwlock);

	<span class="enscript-keyword">if</span> (ia != NULL &amp;&amp; !nd6_prproxy_ifaddr(ia)) {
		IFA_REMREF(&amp;ia-&gt;ia_ifa);
		ia = NULL;
	}

	<span class="enscript-keyword">return</span> (ia);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in6ifa_getlifetime</span>(<span class="enscript-type">struct</span> in6_ifaddr *ia6, <span class="enscript-type">struct</span> in6_addrlifetime *t_dst,
    <span class="enscript-type">int</span> iscalendar)
{
	<span class="enscript-type">struct</span> in6_addrlifetime_i *t_src = &amp;ia6-&gt;ia6_lifetime;
	<span class="enscript-type">struct</span> timeval caltime;

	t_dst-&gt;ia6t_vltime = t_src-&gt;ia6ti_vltime;
	t_dst-&gt;ia6t_pltime = t_src-&gt;ia6ti_pltime;
	t_dst-&gt;ia6t_expire = 0;
	t_dst-&gt;ia6t_preferred = 0;

	<span class="enscript-comment">/* account for system time change */</span>
	getmicrotime(&amp;caltime);
	t_src-&gt;ia6ti_base_calendartime +=
	    NET_CALCULATE_CLOCKSKEW(caltime,
	    t_src-&gt;ia6ti_base_calendartime, net_uptime(),
	    t_src-&gt;ia6ti_base_uptime);

	<span class="enscript-keyword">if</span> (iscalendar) {
		<span class="enscript-keyword">if</span> (t_src-&gt;ia6ti_expire != 0 &amp;&amp;
		    t_src-&gt;ia6ti_vltime != ND6_INFINITE_LIFETIME)
			t_dst-&gt;ia6t_expire = t_src-&gt;ia6ti_base_calendartime +
			    t_src-&gt;ia6ti_expire - t_src-&gt;ia6ti_base_uptime;

		<span class="enscript-keyword">if</span> (t_src-&gt;ia6ti_preferred != 0 &amp;&amp;
		    t_src-&gt;ia6ti_pltime != ND6_INFINITE_LIFETIME)
			t_dst-&gt;ia6t_preferred = t_src-&gt;ia6ti_base_calendartime +
			    t_src-&gt;ia6ti_preferred - t_src-&gt;ia6ti_base_uptime;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (t_src-&gt;ia6ti_expire != 0 &amp;&amp;
		    t_src-&gt;ia6ti_vltime != ND6_INFINITE_LIFETIME)
			t_dst-&gt;ia6t_expire = t_src-&gt;ia6ti_expire;

		<span class="enscript-keyword">if</span> (t_src-&gt;ia6ti_preferred != 0 &amp;&amp;
		    t_src-&gt;ia6ti_pltime != ND6_INFINITE_LIFETIME)
			t_dst-&gt;ia6t_preferred = t_src-&gt;ia6ti_preferred;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in6ifa_setlifetime</span>(<span class="enscript-type">struct</span> in6_ifaddr *ia6, <span class="enscript-type">struct</span> in6_addrlifetime *t_src)
{
	<span class="enscript-type">struct</span> in6_addrlifetime_i *t_dst = &amp;ia6-&gt;ia6_lifetime;
	<span class="enscript-type">struct</span> timeval caltime;

	<span class="enscript-comment">/* account for system time change */</span>
	getmicrotime(&amp;caltime);
	t_dst-&gt;ia6ti_base_calendartime +=
	    NET_CALCULATE_CLOCKSKEW(caltime,
	    t_dst-&gt;ia6ti_base_calendartime, net_uptime(),
	    t_dst-&gt;ia6ti_base_uptime);

	<span class="enscript-comment">/* trust the caller for the values */</span>
	t_dst-&gt;ia6ti_expire = t_src-&gt;ia6t_expire;
	t_dst-&gt;ia6ti_preferred = t_src-&gt;ia6t_preferred;
	t_dst-&gt;ia6ti_vltime = t_src-&gt;ia6t_vltime;
	t_dst-&gt;ia6ti_pltime = t_src-&gt;ia6t_pltime;
}

<span class="enscript-comment">/*
 * Convert IP6 address to printable (loggable) representation.
 */</span>
<span class="enscript-type">char</span> *
<span class="enscript-function-name">ip6_sprintf</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr *addr)
{
	<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> digits[] = <span class="enscript-string">&quot;0123456789abcdef&quot;</span>;
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip6round = 0;
	<span class="enscript-type">static</span> <span class="enscript-type">char</span> ip6buf[8][48];

	<span class="enscript-type">int</span> i;
	<span class="enscript-type">char</span> *cp;
	<span class="enscript-type">const</span> u_short *a = (<span class="enscript-type">const</span> u_short *)addr;
	<span class="enscript-type">const</span> u_char *d;
	u_char n;
	<span class="enscript-type">int</span> dcolon = 0;
	<span class="enscript-type">int</span> zpad = 0;

	ip6round = (ip6round + 1) &amp; 7;
	cp = ip6buf[ip6round];

	<span class="enscript-keyword">for</span> (i = 0; i &lt; 8; i++) {
		<span class="enscript-keyword">if</span> (dcolon == 1) {
			<span class="enscript-keyword">if</span> (*a == 0) {
				<span class="enscript-keyword">if</span> (i == 7)
					*cp++ = <span class="enscript-string">':'</span>;
				a++;
				<span class="enscript-keyword">continue</span>;
			} <span class="enscript-keyword">else</span>
				dcolon = 2;
		}
		<span class="enscript-keyword">if</span> (*a == 0) {
			<span class="enscript-keyword">if</span> (dcolon == 0 &amp;&amp; *(a + 1) == 0) {
				<span class="enscript-keyword">if</span> (i == 0)
					*cp++ = <span class="enscript-string">':'</span>;
				*cp++ = <span class="enscript-string">':'</span>;
				dcolon = 1;
			} <span class="enscript-keyword">else</span> {
				*cp++ = <span class="enscript-string">'0'</span>;
				*cp++ = <span class="enscript-string">':'</span>;
			}
			a++;
			<span class="enscript-keyword">continue</span>;
		}
		d = (<span class="enscript-type">const</span> u_char *)a;
		zpad = 0;
		<span class="enscript-keyword">if</span> ((n = *d &gt;&gt; 4) != 0) {
			*cp++ = digits[n];
			zpad = 1;
		}
		<span class="enscript-keyword">if</span> ((n = *d++ &amp; 0xf) != 0 || zpad) {
			*cp++ = digits[n];
			zpad = 1;
		}
		<span class="enscript-keyword">if</span> ((n = *d &gt;&gt; 4) != 0 || zpad) {
			*cp++ = digits[n];
			zpad = 1;
		}
		<span class="enscript-keyword">if</span> ((n = *d &amp; 0xf) != 0 || zpad)
			*cp++ = digits[n];
		*cp++ = <span class="enscript-string">':'</span>;
		a++;
	}
	*--cp = 0;
	<span class="enscript-keyword">return</span> (ip6buf[ip6round]);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">in6addr_local</span>(<span class="enscript-type">struct</span> in6_addr *in6)
{
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">struct</span> sockaddr_in6 sin6;
	<span class="enscript-type">int</span> local = 0;

	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LOOPBACK(in6) || IN6_IS_SCOPE_LINKLOCAL(in6))
		<span class="enscript-keyword">return</span> (1);

	sin6.sin6_family = AF_INET6;
	sin6.sin6_len = <span class="enscript-keyword">sizeof</span> (sin6);
	bcopy(in6, &amp;sin6.sin6_addr, <span class="enscript-keyword">sizeof</span> (*in6));
	rt = rtalloc1((<span class="enscript-type">struct</span> sockaddr *)&amp;sin6, 0, 0);

	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK_SPIN(rt);
		<span class="enscript-keyword">if</span> (rt-&gt;rt_gateway-&gt;sa_family == AF_LINK)
			local = 1;
		RT_UNLOCK(rt);
		rtfree(rt);
	} <span class="enscript-keyword">else</span> {
		local = in6_localaddr(in6);
	}
	<span class="enscript-keyword">return</span> (local);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_localaddr</span>(<span class="enscript-type">struct</span> in6_addr *in6)
{
	<span class="enscript-type">struct</span> in6_ifaddr *ia;

	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LOOPBACK(in6) || IN6_IS_ADDR_LINKLOCAL(in6))
		<span class="enscript-keyword">return</span> (1);

	lck_rw_lock_shared(&amp;in6_ifaddr_rwlock);
	<span class="enscript-keyword">for</span> (ia = in6_ifaddrs; ia; ia = ia-&gt;ia_next) {
		IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (IN6_ARE_MASKED_ADDR_EQUAL(in6, &amp;ia-&gt;ia_addr.sin6_addr,
		    &amp;ia-&gt;ia_prefixmask.sin6_addr)) {
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			lck_rw_done(&amp;in6_ifaddr_rwlock);
			<span class="enscript-keyword">return</span> (1);
		}
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
	}
	lck_rw_done(&amp;in6_ifaddr_rwlock);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_is_addr_deprecated</span>(<span class="enscript-type">struct</span> sockaddr_in6 *sa6)
{
	<span class="enscript-type">struct</span> in6_ifaddr *ia;

	lck_rw_lock_shared(&amp;in6_ifaddr_rwlock);
	<span class="enscript-keyword">for</span> (ia = in6_ifaddrs; ia; ia = ia-&gt;ia_next) {
		IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(&amp;ia-&gt;ia_addr.sin6_addr,
		    &amp;sa6-&gt;sin6_addr) &amp;&amp;
		    (ia-&gt;ia6_flags &amp; IN6_IFF_DEPRECATED) != 0) {
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			lck_rw_done(&amp;in6_ifaddr_rwlock);
			<span class="enscript-keyword">return</span> (1); <span class="enscript-comment">/* true */</span>
		}
		<span class="enscript-comment">/* XXX: do we still have to go thru the rest of the list? */</span>
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
	}

	lck_rw_done(&amp;in6_ifaddr_rwlock);
	<span class="enscript-keyword">return</span> (0);		<span class="enscript-comment">/* false */</span>
}

<span class="enscript-comment">/*
 * return length of part which dst and src are equal
 * hard coding...
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_matchlen</span>(src, dst)
<span class="enscript-type">struct</span> in6_addr *src, *dst;
{
	<span class="enscript-type">int</span> match = 0;
	u_char *s = (u_char *)src, *d = (u_char *)dst;
	u_char *lim = s + 16, r;

	<span class="enscript-keyword">while</span> (s &lt; lim)
		<span class="enscript-keyword">if</span> ((r = (*d++ ^ *s++)) != 0) {
			<span class="enscript-keyword">while</span> (r &lt; 128) {
				match++;
				r &lt;&lt;= 1;
			}
			<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span>
			match += 8;
	<span class="enscript-keyword">return</span> (match);
}

<span class="enscript-comment">/* XXX: to be scope conscious */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_are_prefix_equal</span>(p1, p2, len)
	<span class="enscript-type">struct</span> in6_addr *p1, *p2;
	<span class="enscript-type">int</span> len;
{
	<span class="enscript-type">int</span> bytelen, bitlen;

	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (0 &gt; len || len &gt; 128) {
		log(LOG_ERR, <span class="enscript-string">&quot;%s: invalid prefix length(%d)\n&quot;</span>, __func__, len);
		<span class="enscript-keyword">return</span> (0);
	}

	bytelen = len / 8;
	bitlen = len % 8;

	<span class="enscript-keyword">if</span> (bcmp(&amp;p1-&gt;s6_addr, &amp;p2-&gt;s6_addr, bytelen))
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> (bitlen != 0 &amp;&amp;
	    p1-&gt;s6_addr[bytelen] &gt;&gt; (8 - bitlen) !=
	    p2-&gt;s6_addr[bytelen] &gt;&gt; (8 - bitlen))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_prefixlen2mask</span>(maskp, len)
	<span class="enscript-type">struct</span> in6_addr *maskp;
	<span class="enscript-type">int</span> len;
{
	u_char maskarray[8] = {0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff};
	<span class="enscript-type">int</span> bytelen, bitlen, i;

	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (0 &gt; len || len &gt; 128) {
		log(LOG_ERR, <span class="enscript-string">&quot;%s: invalid prefix length(%d)\n&quot;</span>, __func__, len);
		<span class="enscript-keyword">return</span>;
	}

	bzero(maskp, <span class="enscript-keyword">sizeof</span> (*maskp));
	bytelen = len / 8;
	bitlen = len % 8;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; bytelen; i++)
		maskp-&gt;s6_addr[i] = 0xff;
	<span class="enscript-keyword">if</span> (bitlen)
		maskp-&gt;s6_addr[bytelen] = maskarray[bitlen - 1];
}

<span class="enscript-comment">/*
 * return the best address out of the same scope
 */</span>
<span class="enscript-type">struct</span> in6_ifaddr *
<span class="enscript-function-name">in6_ifawithscope</span>(<span class="enscript-type">struct</span> ifnet *oifp, <span class="enscript-type">struct</span> in6_addr *dst)
{
	<span class="enscript-type">int</span> dst_scope =	in6_addrscope(dst), src_scope, best_scope = 0;
	<span class="enscript-type">int</span> blen = -1;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> in6_ifaddr *ifa_best = NULL;

	<span class="enscript-keyword">if</span> (oifp == NULL) {
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-comment">/*
	 * We search for all addresses on all interfaces from the beginning.
	 * Comparing an interface with the outgoing interface will be done
	 * only at the final stage of tiebreaking.
	 */</span>
	ifnet_head_lock_shared();
	TAILQ_FOREACH(ifp, &amp;ifnet_head, if_list) {
		<span class="enscript-comment">/*
		 * We can never take an address that breaks the scope zone
		 * of the destination.
		 */</span>
		<span class="enscript-keyword">if</span> (in6_addr2scopeid(ifp, dst) != in6_addr2scopeid(oifp, dst))
			<span class="enscript-keyword">continue</span>;

		ifnet_lock_shared(ifp);
		TAILQ_FOREACH(ifa, &amp;ifp-&gt;if_addrlist, ifa_list) {
			<span class="enscript-type">int</span> tlen = -1, dscopecmp, bscopecmp, matchcmp;

			IFA_LOCK(ifa);
			<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}
			src_scope = in6_addrscope(IFA_IN6(ifa));

			<span class="enscript-comment">/*
			 * Don't use an address before completing DAD
			 * nor a duplicated address.
			 */</span>
			<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> in6_ifaddr *)ifa)-&gt;ia6_flags &amp;
			    IN6_IFF_NOTREADY) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-comment">/* XXX: is there any case to allow anycasts? */</span>
			<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> in6_ifaddr *)ifa)-&gt;ia6_flags &amp;
			    IN6_IFF_ANYCAST) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> in6_ifaddr *)ifa)-&gt;ia6_flags &amp;
			    IN6_IFF_DETACHED) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-comment">/*
			 * If this is the first address we find,
			 * keep it anyway.
			 */</span>
			<span class="enscript-keyword">if</span> (ifa_best == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">replace</span>;

			<span class="enscript-comment">/*
			 * ifa_best is never NULL beyond this line except
			 * within the block labeled &quot;replace&quot;.
			 */</span>

			<span class="enscript-comment">/*
			 * If ifa_best has a smaller scope than dst and
			 * the current address has a larger one than
			 * (or equal to) dst, always replace ifa_best.
			 * Also, if the current address has a smaller scope
			 * than dst, ignore it unless ifa_best also has a
			 * smaller scope.
			 * Consequently, after the two if-clause below,
			 * the followings must be satisfied:
			 * (scope(src) &lt; scope(dst) &amp;&amp;
			 *  scope(best) &lt; scope(dst))
			 *  OR
			 * (scope(best) &gt;= scope(dst) &amp;&amp;
			 *  scope(src) &gt;= scope(dst))
			 */</span>
			<span class="enscript-keyword">if</span> (IN6_ARE_SCOPE_CMP(best_scope, dst_scope) &lt; 0 &amp;&amp;
			    IN6_ARE_SCOPE_CMP(src_scope, dst_scope) &gt;= 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">replace</span>; <span class="enscript-comment">/* (A) */</span>
			<span class="enscript-keyword">if</span> (IN6_ARE_SCOPE_CMP(src_scope, dst_scope) &lt; 0 &amp;&amp;
			    IN6_ARE_SCOPE_CMP(best_scope, dst_scope) &gt;= 0) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* (B) */</span>
			}
			<span class="enscript-comment">/*
			 * A deprecated address SHOULD NOT be used in new
			 * communications if an alternate (non-deprecated)
			 * address is available and has sufficient scope.
			 * RFC 4862, Section 5.5.4.
			 */</span>
			<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> in6_ifaddr *)ifa)-&gt;ia6_flags &amp;
			    IN6_IFF_DEPRECATED) {
				<span class="enscript-comment">/*
				 * Ignore any deprecated addresses if
				 * specified by configuration.
				 */</span>
				<span class="enscript-keyword">if</span> (!ip6_use_deprecated) {
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-comment">/*
				 * If we have already found a non-deprecated
				 * candidate, just ignore deprecated addresses.
				 */</span>
				<span class="enscript-keyword">if</span> ((ifa_best-&gt;ia6_flags &amp; IN6_IFF_DEPRECATED)
				    == 0) {
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">continue</span>;
				}
			}

			<span class="enscript-comment">/*
			 * A non-deprecated address is always preferred
			 * to a deprecated one regardless of scopes and
			 * address matching (Note invariants ensured by the
			 * conditions (A) and (B) above.)
			 */</span>
			<span class="enscript-keyword">if</span> ((ifa_best-&gt;ia6_flags &amp; IN6_IFF_DEPRECATED) &amp;&amp;
			    (((<span class="enscript-type">struct</span> in6_ifaddr *)ifa)-&gt;ia6_flags &amp;
			    IN6_IFF_DEPRECATED) == 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">replace</span>;

			<span class="enscript-comment">/*
			 * When we use temporary addresses described in
			 * RFC 4941, we prefer temporary addresses to
			 * public autoconf addresses.  Again, note the
			 * invariants from (A) and (B).  Also note that we
			 * don't have any preference between static addresses
			 * and autoconf addresses (despite of whether or not
			 * the latter is temporary or public.)
			 */</span>
			<span class="enscript-keyword">if</span> (ip6_use_tempaddr) {
				<span class="enscript-type">struct</span> in6_ifaddr *ifat;

				ifat = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;
				<span class="enscript-keyword">if</span> ((ifa_best-&gt;ia6_flags &amp;
				    (IN6_IFF_AUTOCONF|IN6_IFF_TEMPORARY))
				    == IN6_IFF_AUTOCONF &amp;&amp;
				    (ifat-&gt;ia6_flags &amp;
				    (IN6_IFF_AUTOCONF|IN6_IFF_TEMPORARY))
				    == (IN6_IFF_AUTOCONF|IN6_IFF_TEMPORARY)) {
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">replace</span>;
				}
				<span class="enscript-keyword">if</span> ((ifa_best-&gt;ia6_flags &amp;
				    (IN6_IFF_AUTOCONF|IN6_IFF_TEMPORARY))
				    == (IN6_IFF_AUTOCONF|IN6_IFF_TEMPORARY) &amp;&amp;
				    (ifat-&gt;ia6_flags &amp;
				    (IN6_IFF_AUTOCONF|IN6_IFF_TEMPORARY))
				    == IN6_IFF_AUTOCONF) {
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">continue</span>;
				}
			}

			<span class="enscript-comment">/*
			 * At this point, we have two cases:
			 * 1. we are looking at a non-deprecated address,
			 *    and ifa_best is also non-deprecated.
			 * 2. we are looking at a deprecated address,
			 *    and ifa_best is also deprecated.
			 * Also, we do not have to consider a case where
			 * the scope of if_best is larger(smaller) than dst and
			 * the scope of the current address is smaller(larger)
			 * than dst. Such a case has already been covered.
			 * Tiebreaking is done according to the following
			 * items:
			 * - the scope comparison between the address and
			 *   dst (dscopecmp)
			 * - the scope comparison between the address and
			 *   ifa_best (bscopecmp)
			 * - if the address match dst longer than ifa_best
			 *   (matchcmp)
			 * - if the address is on the outgoing I/F (outI/F)
			 *
			 * Roughly speaking, the selection policy is
			 * - the most important item is scope. The same scope
			 *   is best. Then search for a larger scope.
			 *   Smaller scopes are the last resort.
			 * - A deprecated address is chosen only when we have
			 *   no address that has an enough scope, but is
			 *   prefered to any addresses of smaller scopes
			 *   (this must be already done above.)
			 * - addresses on the outgoing I/F are preferred to
			 *   ones on other interfaces if none of above
			 *   tiebreaks.  In the table below, the column &quot;bI&quot;
			 *   means if the best_ifa is on the outgoing
			 *   interface, and the column &quot;sI&quot; means if the ifa
			 *   is on the outgoing interface.
			 * - If there is no other reasons to choose one,
			 *   longest address match against dst is considered.
			 *
			 * The precise decision table is as follows:
			 * dscopecmp bscopecmp  match   bI oI | replace?
			 *   N/A       equal    N/A     Y   N |   No (1)
			 *   N/A       equal    N/A     N   Y |  Yes (2)
			 *   N/A       equal    larger   N/A  |  Yes (3)
			 *   N/A       equal    !larger  N/A  |   No (4)
			 *   larger    larger   N/A      N/A  |   No (5)
			 *   larger    smaller  N/A      N/A  |  Yes (6)
			 *   smaller   larger   N/A      N/A  |  Yes (7)
			 *   smaller   smaller  N/A      N/A  |   No (8)
			 *   equal     smaller  N/A      N/A  |  Yes (9)
			 *   equal     larger   (already done at A above)
			 */</span>
			dscopecmp = IN6_ARE_SCOPE_CMP(src_scope, dst_scope);
			bscopecmp = IN6_ARE_SCOPE_CMP(src_scope, best_scope);

			<span class="enscript-keyword">if</span> (bscopecmp == 0) {
				<span class="enscript-type">struct</span> ifnet *bifp = ifa_best-&gt;ia_ifp;

				<span class="enscript-keyword">if</span> (bifp == oifp &amp;&amp; ifp != oifp) { <span class="enscript-comment">/* (1) */</span>
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">if</span> (bifp != oifp &amp;&amp; ifp == oifp) <span class="enscript-comment">/* (2) */</span>
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">replace</span>;

				<span class="enscript-comment">/*
				 * Both bifp and ifp are on the outgoing
				 * interface, or both two are on a different
				 * interface from the outgoing I/F.
				 * now we need address matching against dst
				 * for tiebreaking.
				 */</span>
				tlen = in6_matchlen(IFA_IN6(ifa), dst);
				matchcmp = tlen - blen;
				<span class="enscript-keyword">if</span> (matchcmp &gt; 0) <span class="enscript-comment">/* (3) */</span>
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">replace</span>;
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* (4) */</span>
			}
			<span class="enscript-keyword">if</span> (dscopecmp &gt; 0) {
				<span class="enscript-keyword">if</span> (bscopecmp &gt; 0) { <span class="enscript-comment">/* (5) */</span>
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">replace</span>; <span class="enscript-comment">/* (6) */</span>
			}
			<span class="enscript-keyword">if</span> (dscopecmp &lt; 0) {
				<span class="enscript-keyword">if</span> (bscopecmp &gt; 0) <span class="enscript-comment">/* (7) */</span>
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">replace</span>;
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* (8) */</span>
			}

			<span class="enscript-comment">/* now dscopecmp must be 0 */</span>
			<span class="enscript-keyword">if</span> (bscopecmp &lt; 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">replace</span>; <span class="enscript-comment">/* (9) */</span>

<span class="enscript-reference">replace</span>:
			IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for ifa_best */</span>
			blen = tlen &gt;= 0 ? tlen :
			    in6_matchlen(IFA_IN6(ifa), dst);
			best_scope =
			    in6_addrscope(&amp;ifa2ia6(ifa)-&gt;ia_addr.sin6_addr);
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">if</span> (ifa_best)
				IFA_REMREF(&amp;ifa_best-&gt;ia_ifa);
			ifa_best = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;
		}
		ifnet_lock_done(ifp);
	}
	ifnet_head_done();

	<span class="enscript-comment">/* count statistics for future improvements */</span>
	<span class="enscript-keyword">if</span> (ifa_best == NULL)
		ip6stat.ip6s_sources_none++;
	<span class="enscript-keyword">else</span> {
		IFA_LOCK_SPIN(&amp;ifa_best-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (oifp == ifa_best-&gt;ia_ifp)
			ip6stat.ip6s_sources_sameif[best_scope]++;
		<span class="enscript-keyword">else</span>
			ip6stat.ip6s_sources_otherif[best_scope]++;

		<span class="enscript-keyword">if</span> (best_scope == dst_scope)
			ip6stat.ip6s_sources_samescope[best_scope]++;
		<span class="enscript-keyword">else</span>
			ip6stat.ip6s_sources_otherscope[best_scope]++;

		<span class="enscript-keyword">if</span> ((ifa_best-&gt;ia6_flags &amp; IN6_IFF_DEPRECATED) != 0)
			ip6stat.ip6s_sources_deprecated[best_scope]++;
		IFA_UNLOCK(&amp;ifa_best-&gt;ia_ifa);
	}

	<span class="enscript-keyword">return</span> (ifa_best);
}

<span class="enscript-comment">/*
 * return the best address out of the same scope. if no address was
 * found, return the first valid address from designated IF.
 */</span>
<span class="enscript-type">struct</span> in6_ifaddr *
<span class="enscript-function-name">in6_ifawithifp</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> in6_addr *dst)
{
	<span class="enscript-type">int</span> dst_scope =	in6_addrscope(dst), blen = -1, tlen;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span> in6_ifaddr *besta = NULL;
	<span class="enscript-type">struct</span> in6_ifaddr *dep[2];	<span class="enscript-comment">/* last-resort: deprecated */</span>

	dep[0] = dep[1] = NULL;

	<span class="enscript-comment">/*
	 * We first look for addresses in the same scope.
	 * If there is one, return it.
	 * If two or more, return one which matches the dst longest.
	 * If none, return one of global addresses assigned other ifs.
	 */</span>
	ifnet_lock_shared(ifp);
	TAILQ_FOREACH(ifa, &amp;ifp-&gt;if_addrlist, ifa_list) {
		IFA_LOCK(ifa);
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (ifa2ia6(ifa)-&gt;ia6_flags &amp; IN6_IFF_ANYCAST) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* XXX: is there any case to allow anycast? */</span>
		}
		<span class="enscript-keyword">if</span> (ifa2ia6(ifa)-&gt;ia6_flags &amp; IN6_IFF_NOTREADY) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* don't use this interface */</span>
		}
		<span class="enscript-keyword">if</span> (ifa2ia6(ifa)-&gt;ia6_flags &amp; IN6_IFF_DETACHED) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (ifa2ia6(ifa)-&gt;ia6_flags &amp; IN6_IFF_DEPRECATED) {
			<span class="enscript-keyword">if</span> (ip6_use_deprecated) {
				IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for dep[0] */</span>
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">if</span> (dep[0] != NULL)
					IFA_REMREF(&amp;dep[0]-&gt;ia_ifa);
				dep[0] = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;
			} <span class="enscript-keyword">else</span> {
				IFA_UNLOCK(ifa);
			}
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (dst_scope == in6_addrscope(IFA_IN6(ifa))) {
			<span class="enscript-comment">/*
			 * call in6_matchlen() as few as possible
			 */</span>
			<span class="enscript-keyword">if</span> (besta) {
				<span class="enscript-keyword">if</span> (blen == -1) {
					IFA_UNLOCK(ifa);
					IFA_LOCK(&amp;besta-&gt;ia_ifa);
					blen = in6_matchlen(
					    &amp;besta-&gt;ia_addr.sin6_addr, dst);
					IFA_UNLOCK(&amp;besta-&gt;ia_ifa);
					IFA_LOCK(ifa);
				}
				tlen = in6_matchlen(IFA_IN6(ifa), dst);
				<span class="enscript-keyword">if</span> (tlen &gt; blen) {
					blen = tlen;
					IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for besta */</span>
					IFA_UNLOCK(ifa);
					IFA_REMREF(&amp;besta-&gt;ia_ifa);
					besta = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;
				} <span class="enscript-keyword">else</span> {
					IFA_UNLOCK(ifa);
				}
			} <span class="enscript-keyword">else</span> {
				besta = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;
				IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for besta */</span>
				IFA_UNLOCK(ifa);
			}
		} <span class="enscript-keyword">else</span> {
			IFA_UNLOCK(ifa);
		}
	}
	<span class="enscript-keyword">if</span> (besta) {
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">if</span> (dep[0] != NULL)
			IFA_REMREF(&amp;dep[0]-&gt;ia_ifa);
		<span class="enscript-keyword">return</span> (besta);
	}

	TAILQ_FOREACH(ifa, &amp;ifp-&gt;if_addrlist, ifa_list) {
		IFA_LOCK(ifa);
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (ifa2ia6(ifa)-&gt;ia6_flags &amp; IN6_IFF_ANYCAST) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* XXX: is there any case to allow anycast? */</span>
		}
		<span class="enscript-keyword">if</span> (ifa2ia6(ifa)-&gt;ia6_flags &amp; IN6_IFF_NOTREADY) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* don't use this interface */</span>
		}
		<span class="enscript-keyword">if</span> (ifa2ia6(ifa)-&gt;ia6_flags &amp; IN6_IFF_DETACHED) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (ifa2ia6(ifa)-&gt;ia6_flags &amp; IN6_IFF_DEPRECATED) {
			<span class="enscript-keyword">if</span> (ip6_use_deprecated) {
				IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for dep[1] */</span>
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">if</span> (dep[1] != NULL)
					IFA_REMREF(&amp;dep[1]-&gt;ia_ifa);
				dep[1] = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;
			} <span class="enscript-keyword">else</span> {
				IFA_UNLOCK(ifa);
			}
			<span class="enscript-keyword">continue</span>;
		}
		IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for caller */</span>
		IFA_UNLOCK(ifa);
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">if</span> (dep[0] != NULL)
			IFA_REMREF(&amp;dep[0]-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (dep[1] != NULL)
			IFA_REMREF(&amp;dep[1]-&gt;ia_ifa);
		<span class="enscript-keyword">return</span> ((<span class="enscript-type">struct</span> in6_ifaddr *)ifa);
	}
	ifnet_lock_done(ifp);

	<span class="enscript-comment">/* use the last-resort values, that are, deprecated addresses */</span>
	<span class="enscript-keyword">if</span> (dep[0]) {
		<span class="enscript-keyword">if</span> (dep[1] != NULL)
			IFA_REMREF(&amp;dep[1]-&gt;ia_ifa);
		<span class="enscript-keyword">return</span> (dep[0]);
	}
	<span class="enscript-keyword">if</span> (dep[1])
		<span class="enscript-keyword">return</span> (dep[1]);

	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * perform DAD when interface becomes IFF_UP.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in6_if_up_dad_start</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> ifaddr *ifa;

	<span class="enscript-comment">/* start DAD on all the interface addresses */</span>
	ifnet_lock_exclusive(ifp);
	TAILQ_FOREACH(ifa, &amp;ifp-&gt;if_addrlist, ifa_list) {
		<span class="enscript-type">struct</span> in6_ifaddr *ia6;

		IFA_LOCK_SPIN(ifa);
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}
		ia6 = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;
		<span class="enscript-keyword">if</span> (ia6-&gt;ia6_flags &amp; IN6_IFF_DADPROGRESS) {
			<span class="enscript-type">int</span> delay = 0;	<span class="enscript-comment">/* delay ticks before DAD output */</span>
			IFA_UNLOCK(ifa);
			nd6_dad_start(ifa, &amp;delay);
		} <span class="enscript-keyword">else</span> {
			IFA_UNLOCK(ifa);
		}
	}
	ifnet_lock_done(ifp);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">in6if_do_dad</span>(
	<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_LOOPBACK) != 0)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/*
	 * If we are using the alternative neighbor discovery
	 * interface on this interface, then skip DAD.
	 *
	 * Also, skip it for interfaces marked &quot;local private&quot;
	 * for now, even when not marked as using the alternative
	 * interface.  This is for historical reasons.
	 */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; 
	    (IFEF_IPV6_ND6ALT|IFEF_LOCALNET_PRIVATE|IFEF_DIRECTLINK))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">switch</span> (ifp-&gt;if_type) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IFT_DUMMY</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_DUMMY</span>:
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_FAITH</span>:
		<span class="enscript-comment">/*
		 * These interfaces do not have the IFF_LOOPBACK flag,
		 * but loop packets back.  We do not have to do DAD on such
		 * interfaces.  We should even omit it, because loop-backed
		 * NS would confuse the DAD procedure.
		 */</span>
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/*
		 * Our DAD routine requires the interface up and running.
		 * However, some interfaces can be up before the RUNNING
		 * status.  Additionaly, users may try to assign addresses
		 * before the interface becomes up (or running).
		 * We simply skip DAD in such a case as a work around.
		 * XXX: we should rather mark &quot;tentative&quot; on such addresses,
		 * and do DAD after the interface becomes ready.
		 */</span>
		<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; (IFF_UP|IFF_RUNNING)) !=
		    (IFF_UP|IFF_RUNNING))
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-keyword">return</span> (1);
	}
}

<span class="enscript-comment">/*
 * Calculate max IPv6 MTU through all the interfaces and store it
 * to in6_maxmtu.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_setmaxmtu</span>(<span class="enscript-type">void</span>)
{
	u_int32_t maxmtu = 0;
	<span class="enscript-type">struct</span> ifnet *ifp;

	ifnet_head_lock_shared();
	TAILQ_FOREACH(ifp, &amp;ifnet_head, if_list) {
		<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;

		<span class="enscript-keyword">if</span> ((ndi = ND_IFINFO(ifp)) != NULL &amp;&amp; !ndi-&gt;initialized)
			ndi = NULL;
		<span class="enscript-keyword">if</span> (ndi != NULL)
			lck_mtx_lock(&amp;ndi-&gt;lock);
		<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_LOOPBACK) == 0 &amp;&amp;
		    IN6_LINKMTU(ifp) &gt; maxmtu)
			maxmtu = IN6_LINKMTU(ifp);
		<span class="enscript-keyword">if</span> (ndi != NULL)
			lck_mtx_unlock(&amp;ndi-&gt;lock);
	}
	ifnet_head_done();
	<span class="enscript-keyword">if</span> (maxmtu)	<span class="enscript-comment">/* update only when maxmtu is positive */</span>
		in6_maxmtu = maxmtu;
}
<span class="enscript-comment">/*
 * Provide the length of interface identifiers to be used for the link attached
 * to the given interface.  The length should be defined in &quot;IPv6 over
 * xxx-link&quot; document.  Note that address architecture might also define
 * the length for a particular set of address prefixes, regardless of the
 * link type.  Also see RFC 4862 for additional background.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_if2idlen</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-keyword">switch</span> (ifp-&gt;if_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ETHER</span>:		<span class="enscript-comment">/* RFC2464 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE8023ADLAG</span>:	<span class="enscript-comment">/* IEEE802.3ad Link Aggregate */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IFT_PROPVIRTUAL</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_PROPVIRTUAL</span>:	<span class="enscript-comment">/* XXX: no RFC. treat it as ether */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IFT_L2VLAN</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_L2VLAN</span>:	<span class="enscript-comment">/* ditto */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IFT_IEEE80211</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE80211</span>:	<span class="enscript-comment">/* ditto */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IFT_MIP</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_MIP</span>:	<span class="enscript-comment">/* ditto */</span>
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span> (64);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_FDDI</span>:		<span class="enscript-comment">/* RFC2467 */</span>
		<span class="enscript-keyword">return</span> (64);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ISO88025</span>:	<span class="enscript-comment">/* RFC2470 (IPv6 over Token Ring) */</span>
		<span class="enscript-keyword">return</span> (64);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_PPP</span>:		<span class="enscript-comment">/* RFC2472 */</span>
		<span class="enscript-keyword">return</span> (64);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ARCNET</span>:	<span class="enscript-comment">/* RFC2497 */</span>
		<span class="enscript-keyword">return</span> (64);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_FRELAY</span>:	<span class="enscript-comment">/* RFC2590 */</span>
		<span class="enscript-keyword">return</span> (64);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE1394</span>:	<span class="enscript-comment">/* RFC3146 */</span>
		<span class="enscript-keyword">return</span> (64);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_GIF</span>:
		<span class="enscript-keyword">return</span> (64);	<span class="enscript-comment">/* draft-ietf-v6ops-mech-v2-07 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_LOOP</span>:
		<span class="enscript-keyword">return</span> (64);	<span class="enscript-comment">/* XXX: is this really correct? */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_OTHER</span>:
		<span class="enscript-keyword">return</span> (64);	<span class="enscript-comment">/* for utun interfaces */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_CELLULAR</span>:
		<span class="enscript-keyword">return</span> (64);	<span class="enscript-comment">/* Packet Data over Cellular */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_BRIDGE</span>:
		<span class="enscript-keyword">return</span> (64);	<span class="enscript-comment">/* Transparent bridge interface */</span>
	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/*
		 * Unknown link type:
		 * It might be controversial to use the today's common constant
		 * of 64 for these cases unconditionally.  For full compliance,
		 * we should return an error in this case.  On the other hand,
		 * if we simply miss the standard for the link type or a new
		 * standard is defined for a new link type, the IFID length
		 * is very likely to be the common constant.  As a compromise,
		 * we always use the constant, but make an explicit notice
		 * indicating the &quot;unknown&quot; case.
		 */</span>
		log(LOG_NOTICE, <span class="enscript-string">&quot;%s: unknown link type (%d)\n&quot;</span>, __func__,
		    ifp-&gt;if_type);
		<span class="enscript-keyword">return</span> (64);
	}
}
<span class="enscript-comment">/*
 * Convert sockaddr_in6 to sockaddr_in.  Original sockaddr_in6 must be
 * v4 mapped addr or v4 compat addr
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_sin6_2_sin</span>(<span class="enscript-type">struct</span> sockaddr_in *sin, <span class="enscript-type">struct</span> sockaddr_in6 *sin6)
{
	bzero(sin, <span class="enscript-keyword">sizeof</span> (*sin));
	sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in);
	sin-&gt;sin_family = AF_INET;
	sin-&gt;sin_port = sin6-&gt;sin6_port;
	sin-&gt;sin_addr.s_addr = sin6-&gt;sin6_addr.s6_addr32[3];
}

<span class="enscript-comment">/* Convert sockaddr_in to sockaddr_in6 in v4 mapped addr format. */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_sin_2_v4mapsin6</span>(<span class="enscript-type">struct</span> sockaddr_in *sin, <span class="enscript-type">struct</span> sockaddr_in6 *sin6)
{
	bzero(sin6, <span class="enscript-keyword">sizeof</span> (*sin6));
	sin6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
	sin6-&gt;sin6_family = AF_INET6;
	sin6-&gt;sin6_port = sin-&gt;sin_port;
	sin6-&gt;sin6_addr.s6_addr32[0] = 0;
	sin6-&gt;sin6_addr.s6_addr32[1] = 0;
	<span class="enscript-keyword">if</span> (sin-&gt;sin_addr.s_addr) {
		sin6-&gt;sin6_addr.s6_addr32[2] = IPV6_ADDR_INT32_SMP;
		sin6-&gt;sin6_addr.s6_addr32[3] = sin-&gt;sin_addr.s_addr;
	} <span class="enscript-keyword">else</span> {
		sin6-&gt;sin6_addr.s6_addr32[2] = 0;
		sin6-&gt;sin6_addr.s6_addr32[3] = 0;
	}
}

<span class="enscript-comment">/* Convert sockaddr_in6 into sockaddr_in. */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_sin6_2_sin_in_sock</span>(<span class="enscript-type">struct</span> sockaddr *nam)
{
	<span class="enscript-type">struct</span> sockaddr_in *sin_p;
	<span class="enscript-type">struct</span> sockaddr_in6 sin6;

	<span class="enscript-comment">/*
	 * Save original sockaddr_in6 addr and convert it
	 * to sockaddr_in.
	 */</span>
	sin6 = *(<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)nam;
	sin_p = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)nam;
	in6_sin6_2_sin(sin_p, &amp;sin6);
}

<span class="enscript-comment">/* Convert sockaddr_in into sockaddr_in6 in v4 mapped addr format. */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_sin_2_v4mapsin6_in_sock</span>(<span class="enscript-type">struct</span> sockaddr **nam)
{
	<span class="enscript-type">struct</span> sockaddr_in *sin_p;
	<span class="enscript-type">struct</span> sockaddr_in6 *sin6_p;

	MALLOC(sin6_p, <span class="enscript-type">struct</span> sockaddr_in6 *, <span class="enscript-keyword">sizeof</span> (*sin6_p), M_SONAME,
	    M_WAITOK);
	<span class="enscript-keyword">if</span> (sin6_p == NULL)
		<span class="enscript-keyword">return</span> (ENOBUFS);
	sin_p = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)*nam;
	in6_sin_2_v4mapsin6(sin_p, sin6_p);
	FREE(*nam, M_SONAME);
	*nam = (<span class="enscript-type">struct</span> sockaddr *)sin6_p;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Posts in6_event_data message kernel events.
 *
 * To get the same size of kev_in6_data between ILP32 and LP64 data models
 * we are using a special version of the in6_addrlifetime structure that
 * uses only 32 bits fields to be compatible with Leopard, and that
 * are large enough to span 68 years.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_post_msg</span>(<span class="enscript-type">struct</span> ifnet *ifp, u_int32_t event_code, <span class="enscript-type">struct</span> in6_ifaddr *ifa,
    uint8_t *mac)
{
	<span class="enscript-type">struct</span> kev_msg ev_msg;
	<span class="enscript-type">struct</span> kev_in6_data in6_event_data;
	<span class="enscript-type">struct</span> in6_addrlifetime ia6_lt;

	bzero(&amp;in6_event_data, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kev_in6_data));
	bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kev_msg));
	ev_msg.vendor_code	= KEV_VENDOR_APPLE;
	ev_msg.kev_class	= KEV_NETWORK_CLASS;
	ev_msg.kev_subclass	= KEV_INET6_SUBCLASS;
	ev_msg.event_code	= event_code;

	IFA_LOCK(&amp;ifa-&gt;ia_ifa);
	in6_event_data.ia_addr		= ifa-&gt;ia_addr;
	in6_event_data.ia_net		= ifa-&gt;ia_net;
	in6_event_data.ia_dstaddr	= ifa-&gt;ia_dstaddr;
	in6_event_data.ia_prefixmask	= ifa-&gt;ia_prefixmask;
	in6_event_data.ia_plen		= ifa-&gt;ia_plen;
	in6_event_data.ia6_flags	= (u_int32_t)ifa-&gt;ia6_flags;

	<span class="enscript-comment">/* retrieve time as calendar time (last arg is 1) */</span>
	in6ifa_getlifetime(ifa, &amp;ia6_lt, 1);
	in6_event_data.ia_lifetime.ia6t_expire = ia6_lt.ia6t_expire;
	in6_event_data.ia_lifetime.ia6t_preferred = ia6_lt.ia6t_preferred;
	in6_event_data.ia_lifetime.ia6t_vltime = ia6_lt.ia6t_vltime;
	in6_event_data.ia_lifetime.ia6t_pltime = ia6_lt.ia6t_pltime;
	IFA_UNLOCK(&amp;ifa-&gt;ia_ifa);

	<span class="enscript-keyword">if</span> (ifp != NULL) {
		(<span class="enscript-type">void</span>) strlcpy(&amp;in6_event_data.link_data.if_name[0],
		    ifp-&gt;if_name, IFNAMSIZ);
		in6_event_data.link_data.if_family = ifp-&gt;if_family;
		in6_event_data.link_data.if_unit  = (u_int32_t)ifp-&gt;if_unit;
	}

	<span class="enscript-keyword">if</span> (mac != NULL)
		memcpy(&amp;in6_event_data.ia_mac, mac, 
		    <span class="enscript-keyword">sizeof</span>(in6_event_data.ia_mac));

	ev_msg.dv[0].data_ptr    = &amp;in6_event_data;
	ev_msg.dv[0].data_length = <span class="enscript-keyword">sizeof</span> (in6_event_data);
	ev_msg.dv[1].data_length = 0;

	kev_post_msg(&amp;ev_msg);
}

<span class="enscript-comment">/*
 * Called as part of ip6_init
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_ifaddr_init</span>(<span class="enscript-type">void</span>)
{
	in6_cga_init();
	in6_multi_init();

	PE_parse_boot_argn(<span class="enscript-string">&quot;ifa_debug&quot;</span>, &amp;in6ifa_debug, <span class="enscript-keyword">sizeof</span> (in6ifa_debug));

	in6ifa_size = (in6ifa_debug == 0) ? <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_ifaddr) :
	    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_ifaddr_dbg);

	in6ifa_zone = zinit(in6ifa_size, IN6IFA_ZONE_MAX * in6ifa_size,
	    0, IN6IFA_ZONE_NAME);
	<span class="enscript-keyword">if</span> (in6ifa_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__, IN6IFA_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(in6ifa_zone, Z_EXPAND, TRUE);
	zone_change(in6ifa_zone, Z_CALLERACCT, FALSE);

	lck_mtx_init(&amp;in6ifa_trash_lock, ifa_mtx_grp, ifa_mtx_attr);
	TAILQ_INIT(&amp;in6ifa_trash_head);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> in6_ifaddr *
<span class="enscript-function-name">in6_ifaddr_alloc</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> in6_ifaddr *in6ifa;

	in6ifa = (how == M_WAITOK) ? zalloc(in6ifa_zone) :
	    zalloc_noblock(in6ifa_zone);
	<span class="enscript-keyword">if</span> (in6ifa != NULL) {
		bzero(in6ifa, in6ifa_size);
		in6ifa-&gt;ia_ifa.ifa_free = in6_ifaddr_free;
		in6ifa-&gt;ia_ifa.ifa_debug |= IFD_ALLOC;
		ifa_lock_init(&amp;in6ifa-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (in6ifa_debug != 0) {
			<span class="enscript-type">struct</span> in6_ifaddr_dbg *in6ifa_dbg =
			    (<span class="enscript-type">struct</span> in6_ifaddr_dbg *)in6ifa;
			in6ifa-&gt;ia_ifa.ifa_debug |= IFD_DEBUG;
			in6ifa-&gt;ia_ifa.ifa_trace = in6_ifaddr_trace;
			in6ifa-&gt;ia_ifa.ifa_attached = in6_ifaddr_attached;
			in6ifa-&gt;ia_ifa.ifa_detached = in6_ifaddr_detached;
			ctrace_record(&amp;in6ifa_dbg-&gt;in6ifa_alloc);
		}
	}

	<span class="enscript-keyword">return</span> (in6ifa);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in6_ifaddr_free</span>(<span class="enscript-type">struct</span> ifaddr *ifa)
{
	IFA_LOCK_ASSERT_HELD(ifa);

	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_refcnt != 0) {
		panic(<span class="enscript-string">&quot;%s: ifa %p bad ref cnt&quot;</span>, __func__, ifa);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(ifa-&gt;ifa_debug &amp; IFD_ALLOC)) {
		panic(<span class="enscript-string">&quot;%s: ifa %p cannot be freed&quot;</span>, __func__, ifa);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_debug &amp; IFD_DEBUG) {
		<span class="enscript-type">struct</span> in6_ifaddr_dbg *in6ifa_dbg =
		    (<span class="enscript-type">struct</span> in6_ifaddr_dbg *)ifa;
		ctrace_record(&amp;in6ifa_dbg-&gt;in6ifa_free);
		bcopy(&amp;in6ifa_dbg-&gt;in6ifa, &amp;in6ifa_dbg-&gt;in6ifa_old,
		    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_ifaddr));
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_debug &amp; IFD_TRASHED) {
			<span class="enscript-comment">/* Become a regular mutex, just in case */</span>
			IFA_CONVERT_LOCK(ifa);
			lck_mtx_lock(&amp;in6ifa_trash_lock);
			TAILQ_REMOVE(&amp;in6ifa_trash_head, in6ifa_dbg,
			    in6ifa_trash_link);
			lck_mtx_unlock(&amp;in6ifa_trash_lock);
			ifa-&gt;ifa_debug &amp;= ~IFD_TRASHED;
		}
	}
	IFA_UNLOCK(ifa);
	ifa_lock_destroy(ifa);
	bzero(ifa, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_ifaddr));
	zfree(in6ifa_zone, ifa);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in6_ifaddr_attached</span>(<span class="enscript-type">struct</span> ifaddr *ifa)
{
	<span class="enscript-type">struct</span> in6_ifaddr_dbg *in6ifa_dbg = (<span class="enscript-type">struct</span> in6_ifaddr_dbg *)ifa;

	IFA_LOCK_ASSERT_HELD(ifa);

	<span class="enscript-keyword">if</span> (!(ifa-&gt;ifa_debug &amp; IFD_DEBUG)) {
		panic(<span class="enscript-string">&quot;%s: ifa %p has no debug structure&quot;</span>, __func__, ifa);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_debug &amp; IFD_TRASHED) {
		<span class="enscript-comment">/* Become a regular mutex, just in case */</span>
		IFA_CONVERT_LOCK(ifa);
		lck_mtx_lock(&amp;in6ifa_trash_lock);
		TAILQ_REMOVE(&amp;in6ifa_trash_head, in6ifa_dbg, in6ifa_trash_link);
		lck_mtx_unlock(&amp;in6ifa_trash_lock);
		ifa-&gt;ifa_debug &amp;= ~IFD_TRASHED;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in6_ifaddr_detached</span>(<span class="enscript-type">struct</span> ifaddr *ifa)
{
	<span class="enscript-type">struct</span> in6_ifaddr_dbg *in6ifa_dbg = (<span class="enscript-type">struct</span> in6_ifaddr_dbg *)ifa;

	IFA_LOCK_ASSERT_HELD(ifa);

	<span class="enscript-keyword">if</span> (!(ifa-&gt;ifa_debug &amp; IFD_DEBUG)) {
		panic(<span class="enscript-string">&quot;%s: ifa %p has no debug structure&quot;</span>, __func__, ifa);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifa-&gt;ifa_debug &amp; IFD_TRASHED) {
		panic(<span class="enscript-string">&quot;%s: ifa %p is already in trash list&quot;</span>, __func__, ifa);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	ifa-&gt;ifa_debug |= IFD_TRASHED;
	<span class="enscript-comment">/* Become a regular mutex, just in case */</span>
	IFA_CONVERT_LOCK(ifa);
	lck_mtx_lock(&amp;in6ifa_trash_lock);
	TAILQ_INSERT_TAIL(&amp;in6ifa_trash_head, in6ifa_dbg, in6ifa_trash_link);
	lck_mtx_unlock(&amp;in6ifa_trash_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in6_ifaddr_trace</span>(<span class="enscript-type">struct</span> ifaddr *ifa, <span class="enscript-type">int</span> refhold)
{
	<span class="enscript-type">struct</span> in6_ifaddr_dbg *in6ifa_dbg = (<span class="enscript-type">struct</span> in6_ifaddr_dbg *)ifa;
	ctrace_t *tr;
	u_int32_t idx;
	u_int16_t *cnt;

	<span class="enscript-keyword">if</span> (!(ifa-&gt;ifa_debug &amp; IFD_DEBUG)) {
		panic(<span class="enscript-string">&quot;%s: ifa %p has no debug structure&quot;</span>, __func__, ifa);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (refhold) {
		cnt = &amp;in6ifa_dbg-&gt;in6ifa_refhold_cnt;
		tr = in6ifa_dbg-&gt;in6ifa_refhold;
	} <span class="enscript-keyword">else</span> {
		cnt = &amp;in6ifa_dbg-&gt;in6ifa_refrele_cnt;
		tr = in6ifa_dbg-&gt;in6ifa_refrele;
	}

	idx = atomic_add_16_ov(cnt, 1) % IN6IFA_TRACE_HIST_SIZE;
	ctrace_record(&amp;tr[idx]);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in6_ifaddr_set_dadprogress</span>(<span class="enscript-type">struct</span> in6_ifaddr *ia)
{
	<span class="enscript-type">struct</span> ifnet* ifp = ia-&gt;ia_ifp;
	uint32_t flags = IN6_IFF_TENTATIVE;
	uint32_t optdad = nd6_optimistic_dad;

	<span class="enscript-keyword">if</span> (optdad) {
		<span class="enscript-keyword">if</span> ((ifp-&gt;if_eflags &amp; IFEF_IPV6_ROUTER) != 0) {
			optdad = 0;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;

			ndi = ND_IFINFO(ifp);
			VERIFY (ndi != NULL &amp;&amp; ndi-&gt;initialized);
			lck_mtx_lock(&amp;ndi-&gt;lock);
			<span class="enscript-keyword">if</span> ((ndi-&gt;flags &amp; ND6_IFF_REPLICATED) != 0) {
				optdad = 0;
			}
			lck_mtx_unlock(&amp;ndi-&gt;lock);
		}
	}

	<span class="enscript-keyword">if</span> (optdad) {
		<span class="enscript-keyword">if</span> ((optdad &amp; ND6_OPTIMISTIC_DAD_LINKLOCAL) &amp;&amp;
		    IN6_IS_ADDR_LINKLOCAL(&amp;ia-&gt;ia_addr.sin6_addr))
			flags = IN6_IFF_OPTIMISTIC;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((optdad &amp; ND6_OPTIMISTIC_DAD_AUTOCONF) &amp;&amp;
		    (ia-&gt;ia6_flags &amp; IN6_IFF_AUTOCONF)) {
			<span class="enscript-keyword">if</span> (ia-&gt;ia6_flags &amp; IN6_IFF_TEMPORARY) {
				<span class="enscript-keyword">if</span> (optdad &amp; ND6_OPTIMISTIC_DAD_TEMPORARY)
					flags = IN6_IFF_OPTIMISTIC;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ia-&gt;ia6_flags &amp; IN6_IFF_SECURED) {
				<span class="enscript-keyword">if</span> (optdad &amp; ND6_OPTIMISTIC_DAD_SECURED)
					flags = IN6_IFF_OPTIMISTIC;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * Keeping the behavior for temp and CGA
				 * SLAAC addresses to have a knob for optimistic
				 * DAD.
				 * Other than that if ND6_OPTIMISTIC_DAD_AUTOCONF
				 * is set, we should default to optimistic
				 * DAD.
				 * For now this means SLAAC addresses with interface
				 * identifier derived from modified EUI-64 bit
				 * identifiers.
				 */</span>
				flags = IN6_IFF_OPTIMISTIC;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((optdad &amp; ND6_OPTIMISTIC_DAD_DYNAMIC) &amp;&amp;
		    (ia-&gt;ia6_flags &amp; IN6_IFF_DYNAMIC)) {
			<span class="enscript-keyword">if</span> (ia-&gt;ia6_flags &amp; IN6_IFF_TEMPORARY) {
				<span class="enscript-keyword">if</span> (optdad &amp; ND6_OPTIMISTIC_DAD_TEMPORARY)
					flags = IN6_IFF_OPTIMISTIC;
			} <span class="enscript-keyword">else</span> {
				flags = IN6_IFF_OPTIMISTIC;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((optdad &amp; ND6_OPTIMISTIC_DAD_MANUAL) &amp;&amp;
		    (ia-&gt;ia6_flags &amp; IN6_IFF_OPTIMISTIC)) {
		    	<span class="enscript-comment">/*
		    	 * rdar://17483438
		    	 * Bypass tentative for address assignments
		    	 * not covered above (e.g. manual) upon request
		    	 */</span>
			<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_LINKLOCAL(&amp;ia-&gt;ia_addr.sin6_addr) &amp;&amp;
			    !(ia-&gt;ia6_flags &amp; IN6_IFF_AUTOCONF) &amp;&amp;
			    !(ia-&gt;ia6_flags &amp; IN6_IFF_DYNAMIC))
				flags = IN6_IFF_OPTIMISTIC;
		}
	}

	ia-&gt;ia6_flags &amp;= ~(IN6_IFF_DUPLICATED | IN6_IFF_DADPROGRESS);
	ia-&gt;ia6_flags |= flags;
	
	nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s - %s ifp %s ia6_flags 0x%x\n&quot;</span>,
	    __func__,
	    ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr),
	    if_name(ia-&gt;ia_ifp),
	    ia-&gt;ia6_flags));
}

<span class="enscript-comment">/*
 * Handle SIOCGASSOCIDS ioctl for PF_INET6 domain.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">in6_getassocids</span>(<span class="enscript-type">struct</span> socket *so, uint32_t *cnt, user_addr_t aidp)
{
	<span class="enscript-type">struct</span> in6pcb *in6p = sotoin6pcb(so);
	sae_associd_t aid;

	<span class="enscript-keyword">if</span> (in6p == NULL || in6p-&gt;inp_state == INPCB_STATE_DEAD)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* IN6PCB has no concept of association */</span>
	aid = SAE_ASSOCID_ANY;
	*cnt = 0;

	<span class="enscript-comment">/* just asking how many there are? */</span>
	<span class="enscript-keyword">if</span> (aidp == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">return</span> (copyout(&amp;aid, aidp, <span class="enscript-keyword">sizeof</span> (aid)));
}

<span class="enscript-comment">/*
 * Handle SIOCGCONNIDS ioctl for PF_INET6 domain.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">in6_getconnids</span>(<span class="enscript-type">struct</span> socket *so, sae_associd_t aid, uint32_t *cnt,
    user_addr_t cidp)
{
	<span class="enscript-type">struct</span> in6pcb *in6p = sotoin6pcb(so);
	sae_connid_t cid;

	<span class="enscript-keyword">if</span> (in6p == NULL || in6p-&gt;inp_state == INPCB_STATE_DEAD)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (aid != SAE_ASSOCID_ANY &amp;&amp; aid != SAE_ASSOCID_ALL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* if connected, return 1 connection count */</span>
	*cnt = ((so-&gt;so_state &amp; SS_ISCONNECTED) ? 1 : 0);

	<span class="enscript-comment">/* just asking how many there are? */</span>
	<span class="enscript-keyword">if</span> (cidp == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/* if IN6PCB is connected, assign it connid 1 */</span>
	cid = ((*cnt != 0) ? 1 : SAE_CONNID_ANY);

	<span class="enscript-keyword">return</span> (copyout(&amp;cid, cidp, <span class="enscript-keyword">sizeof</span> (cid)));
}

<span class="enscript-comment">/*
 * Handle SIOCGCONNINFO ioctl for PF_INET6 domain.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">in6_getconninfo</span>(<span class="enscript-type">struct</span> socket *so, sae_connid_t cid, uint32_t *flags,
    uint32_t *ifindex, int32_t *soerror, user_addr_t src, socklen_t *src_len,
    user_addr_t dst, socklen_t *dst_len, uint32_t *aux_type,
    user_addr_t aux_data, uint32_t *aux_len)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">aux_data</span>)
	<span class="enscript-type">struct</span> in6pcb *in6p = sotoin6pcb(so);
	<span class="enscript-type">struct</span> sockaddr_in6 sin6;
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;
	<span class="enscript-type">int</span> error = 0;
	u_int32_t copy_len = 0;

	<span class="enscript-comment">/*
	 * Don't test for INPCB_STATE_DEAD since this may be called
	 * after SOF_PCBCLEARING is set, e.g. after tcp_close().
	 */</span>
	<span class="enscript-keyword">if</span> (in6p == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (cid != SAE_CONNID_ANY &amp;&amp; cid != SAE_CONNID_ALL &amp;&amp; cid != 1) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	ifp = in6p-&gt;in6p_last_outifp;
	*ifindex = ((ifp != NULL) ? ifp-&gt;if_index : 0);
	*soerror = so-&gt;so_error;
	*flags = 0;
	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_ISCONNECTED)
		*flags |= (CIF_CONNECTED | CIF_PREFERRED);
	<span class="enscript-keyword">if</span> (in6p-&gt;in6p_flags &amp; INP_BOUND_IF)
		*flags |= CIF_BOUND_IF;
	<span class="enscript-keyword">if</span> (!(in6p-&gt;in6p_flags &amp; INP_IN6ADDR_ANY))
		*flags |= CIF_BOUND_IP;
	<span class="enscript-keyword">if</span> (!(in6p-&gt;in6p_flags &amp; INP_ANONPORT))
		*flags |= CIF_BOUND_PORT;

	bzero(&amp;sin6, <span class="enscript-keyword">sizeof</span> (sin6));
	sin6.sin6_len = <span class="enscript-keyword">sizeof</span> (sin6);
	sin6.sin6_family = AF_INET6;

	<span class="enscript-comment">/* source address and port */</span>
	sin6.sin6_port = in6p-&gt;in6p_lport;
	in6_recoverscope(&amp;sin6, &amp;in6p-&gt;in6p_laddr, NULL);
	<span class="enscript-keyword">if</span> (*src_len == 0) {
		*src_len = sin6.sin6_len;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (src != USER_ADDR_NULL) {
			copy_len = min(*src_len, <span class="enscript-keyword">sizeof</span> (sin6));
			error = copyout(&amp;sin6, src, copy_len);
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			*src_len = copy_len;
		}
	}

	<span class="enscript-comment">/* destination address and port */</span>
	sin6.sin6_port = in6p-&gt;in6p_fport;
	in6_recoverscope(&amp;sin6, &amp;in6p-&gt;in6p_faddr, NULL);
	<span class="enscript-keyword">if</span> (*dst_len == 0) {
		*dst_len = sin6.sin6_len;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (dst != USER_ADDR_NULL) {
			copy_len = min(*dst_len, <span class="enscript-keyword">sizeof</span> (sin6));
			error = copyout(&amp;sin6, dst, copy_len);
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			*dst_len = copy_len;
		}
	}

	*aux_type = 0;
	*aux_len = 0;
	<span class="enscript-keyword">if</span> (SOCK_PROTO(so) == IPPROTO_TCP) {
		<span class="enscript-type">struct</span> conninfo_tcp tcp_ci;

		*aux_type = CIAUX_TCP;
		<span class="enscript-keyword">if</span> (*aux_len == 0) {
			*aux_len = <span class="enscript-keyword">sizeof</span> (tcp_ci);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (aux_data != USER_ADDR_NULL) {
				copy_len = min(*aux_len, <span class="enscript-keyword">sizeof</span> (tcp_ci));
				bzero(&amp;tcp_ci, <span class="enscript-keyword">sizeof</span> (tcp_ci));
				tcp_getconninfo(so, &amp;tcp_ci);
				error = copyout(&amp;tcp_ci, aux_data, copy_len);
				<span class="enscript-keyword">if</span> (error != 0)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				*aux_len = copy_len;
			}
		}
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * 'u' group ioctls.
 *
 * The switch statement below does nothing at runtime, as it serves as a
 * compile time check to ensure that all of the socket 'u' ioctls (those
 * in the 'u' group going thru soo_ioctl) that are made available by the
 * networking stack is unique.  This works as long as this routine gets
 * updated each time a new interface ioctl gets added.
 *
 * Any failures at compile time indicates duplicated ioctl values.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((unused)) <span class="enscript-type">void</span>
<span class="enscript-function-name">in6ioctl_cassert</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 * This is equivalent to _CASSERT() and the compiler wouldn't
	 * generate any instructions, thus for compile time only.
	 */</span>
	<span class="enscript-keyword">switch</span> ((u_long)0) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:

	<span class="enscript-comment">/* bsd/netinet6/in6_var.h */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCAADDRCTL_POLICY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDADDRCTL_POLICY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDRADD_IN6_32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDRADD_IN6_64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDRDEL_IN6_32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDRDEL_IN6_64</span>:
		;
	}
}
</pre>
<hr />
</body></html>