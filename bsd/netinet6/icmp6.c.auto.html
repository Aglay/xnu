<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>icmp6.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">icmp6.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$FreeBSD: src/sys/netinet6/icmp6.c,v 1.6.2.6 2001/07/10 09:44:16 ume Exp $	*/</span>
<span class="enscript-comment">/*	$KAME: icmp6.c,v 1.211 2001/04/04 05:56:20 itojun Exp $	*/</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ip_icmp.c	8.2 (Berkeley) 1/4/94
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/mld6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_ifattach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/scope6_var.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/necp.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> ip6protosw *ip6_protox[];

<span class="enscript-type">extern</span> uint32_t rip_sendspace;
<span class="enscript-type">extern</span> uint32_t rip_recvspace;

<span class="enscript-type">struct</span> icmp6stat icmp6stat;

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> inpcbhead ripcb;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> icmp6errppslim;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> icmp6rappslim;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> icmp6errpps_count = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> icmp6rapps_count = 0;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> timeval icmp6errppslim_last;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> timeval icmp6rappslim_last;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> icmp6_nodeinfo;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> inpcbinfo ripcbinfo;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">icmp6_errcount</span>(<span class="enscript-type">struct</span> icmp6errstat *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">icmp6_rip6_input</span>(<span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">icmp6_ratelimit</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr *, <span class="enscript-type">const</span> <span class="enscript-type">int</span>, <span class="enscript-type">const</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">icmp6_redirect_diag</span>(<span class="enscript-type">struct</span> in6_addr *,
	<span class="enscript-type">struct</span> in6_addr *, <span class="enscript-type">struct</span> in6_addr *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">ni6_input</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">ni6_nametodns</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ni6_dnsmatch</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ni6_addrs</span>(<span class="enscript-type">struct</span> icmp6_nodeinfo *, 
			  <span class="enscript-type">struct</span> ifnet **, <span class="enscript-type">char</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ni6_store_addrs</span>(<span class="enscript-type">struct</span> icmp6_nodeinfo *, <span class="enscript-type">struct</span> icmp6_nodeinfo *,
				<span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">icmp6_notify_error</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);



<span class="enscript-type">void</span>
<span class="enscript-function-name">icmp6_init</span>(<span class="enscript-type">struct</span> ip6protosw *pp, <span class="enscript-type">struct</span> domain *dp)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dp</span>)
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> icmp6_initialized = 0;

	<span class="enscript-comment">/* Also called from ip6_init() without pp */</span>
	VERIFY(pp == NULL ||
	    (pp-&gt;pr_flags &amp; (PR_INITIALIZED|PR_ATTACHED)) == PR_ATTACHED);

	<span class="enscript-comment">/* This gets called by more than one protocols, so initialize once */</span>
	<span class="enscript-keyword">if</span> (!icmp6_initialized) {
		icmp6_initialized = 1;
		mld_init();
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">icmp6_errcount</span>(stat, type, code)
	<span class="enscript-type">struct</span> icmp6errstat *stat;
	<span class="enscript-type">int</span> type, code;
{
	<span class="enscript-keyword">switch</span> (type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH</span>:
		<span class="enscript-keyword">switch</span> (code) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH_NOROUTE</span>:
			stat-&gt;icp6errs_dst_unreach_noroute++;
			<span class="enscript-keyword">return</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH_ADMIN</span>:
			stat-&gt;icp6errs_dst_unreach_admin++;
			<span class="enscript-keyword">return</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH_BEYONDSCOPE</span>:
			stat-&gt;icp6errs_dst_unreach_beyondscope++;
			<span class="enscript-keyword">return</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH_ADDR</span>:
			stat-&gt;icp6errs_dst_unreach_addr++;
			<span class="enscript-keyword">return</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH_NOPORT</span>:
			stat-&gt;icp6errs_dst_unreach_noport++;
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_PACKET_TOO_BIG</span>:
		stat-&gt;icp6errs_packet_too_big++;
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_TIME_EXCEEDED</span>:
		<span class="enscript-keyword">switch</span> (code) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_TIME_EXCEED_TRANSIT</span>:
			stat-&gt;icp6errs_time_exceed_transit++;
			<span class="enscript-keyword">return</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_TIME_EXCEED_REASSEMBLY</span>:
			stat-&gt;icp6errs_time_exceed_reassembly++;
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_PARAM_PROB</span>:
		<span class="enscript-keyword">switch</span> (code) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_PARAMPROB_HEADER</span>:
			stat-&gt;icp6errs_paramprob_header++;
			<span class="enscript-keyword">return</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_PARAMPROB_NEXTHEADER</span>:
			stat-&gt;icp6errs_paramprob_nextheader++;
			<span class="enscript-keyword">return</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_PARAMPROB_OPTION</span>:
			stat-&gt;icp6errs_paramprob_option++;
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_REDIRECT</span>:
		stat-&gt;icp6errs_redirect++;
		<span class="enscript-keyword">return</span>;
	}
	stat-&gt;icp6errs_unknown++;
}

<span class="enscript-comment">/*
 * A wrapper function for icmp6_error() necessary when the erroneous packet
 * may not contain enough scope zone information.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">icmp6_error2</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> type, <span class="enscript-type">int</span> code, <span class="enscript-type">int</span> param,
    <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6;

	<span class="enscript-keyword">if</span> (ifp == NULL)
		<span class="enscript-keyword">return</span>;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PULLDOWN_TEST</span>
	IP6_EXTHDR_CHECK(m, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr),<span class="enscript-keyword">return</span> );
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr)) {
		m = m_pullup(m, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span>;
	}
#<span class="enscript-reference">endif</span>

	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

	<span class="enscript-keyword">if</span> (in6_setscope(&amp;ip6-&gt;ip6_src, ifp, NULL) != 0)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> (in6_setscope(&amp;ip6-&gt;ip6_dst, ifp, NULL) != 0)
		<span class="enscript-keyword">return</span>;

	icmp6_error(m, type, code, param);
}

<span class="enscript-comment">/*
 * Generate an error packet of type error in response to bad IP6 packet.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">icmp6_error</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> type, <span class="enscript-type">int</span> code, <span class="enscript-type">int</span> param) {
	icmp6_error_flag(m, type, code, param, ICMP6_ERROR_RST_MRCVIF);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">icmp6_error_flag</span> (<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> type, <span class="enscript-type">int</span> code, <span class="enscript-type">int</span> param, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> ip6_hdr *oip6, *nip6;
	<span class="enscript-type">struct</span> icmp6_hdr *icmp6;
	u_int preplen;
	<span class="enscript-type">int</span> off;
	<span class="enscript-type">int</span> nxt;

	icmp6stat.icp6s_error++;

	<span class="enscript-comment">/* count per-type-code statistics */</span>
	icmp6_errcount(&amp;icmp6stat.icp6s_outerrhist, type, code);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">M_DECRYPTED</span>	<span class="enscript-comment">/*not openbsd*/</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_DECRYPTED) {
		icmp6stat.icp6s_canterror++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PULLDOWN_TEST</span>
	IP6_EXTHDR_CHECK(m, 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr), <span class="enscript-keyword">return</span>);
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr)) {
		m = m_pullup(m, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">return</span>;
	}
#<span class="enscript-reference">endif</span>
	oip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

	<span class="enscript-comment">/*
	 * If the destination address of the erroneous packet is a multicast
	 * address, or the packet was sent using link-layer multicast,
	 * we should basically suppress sending an error (RFC 2463, Section
	 * 2.4).
	 * We have two exceptions (the item e.2 in that section):
	 * - the Pakcet Too Big message can be sent for path MTU discovery.
	 * - the Parameter Problem Message that can be allowed an icmp6 error
	 *   in the option type field.  This check has been done in
	 *   ip6_unknown_opt(), so we can just check the type and code.
	 */</span>
	<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; (M_BCAST|M_MCAST) ||
	     IN6_IS_ADDR_MULTICAST(&amp;oip6-&gt;ip6_dst)) &amp;&amp;
	    (type != ICMP6_PACKET_TOO_BIG &amp;&amp;
	     (type != ICMP6_PARAM_PROB ||
	      code != ICMP6_PARAMPROB_OPTION)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;

	<span class="enscript-comment">/*
	 * RFC 2463, 2.4 (e.5): source address check.
	 * XXX: the case of anycast source?
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;oip6-&gt;ip6_src) ||
	    IN6_IS_ADDR_MULTICAST(&amp;oip6-&gt;ip6_src))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;

	<span class="enscript-comment">/*
	 * If we are about to send ICMPv6 against ICMPv6 error/redirect,
	 * don't do it.
	 */</span>
	nxt = -1;
	off = ip6_lasthdr(m, 0, IPPROTO_IPV6, &amp;nxt);
	<span class="enscript-keyword">if</span> (off &gt;= 0 &amp;&amp; nxt == IPPROTO_ICMPV6) {
		<span class="enscript-type">struct</span> icmp6_hdr *icp;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PULLDOWN_TEST</span>
		IP6_EXTHDR_CHECK(m, 0, off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr), <span class="enscript-keyword">return</span>);
		icp = (<span class="enscript-type">struct</span> icmp6_hdr *)(mtod(m, caddr_t) + off);
#<span class="enscript-reference">else</span>
		IP6_EXTHDR_GET(icp, <span class="enscript-type">struct</span> icmp6_hdr *, m, off,
			<span class="enscript-keyword">sizeof</span>(*icp));
		<span class="enscript-keyword">if</span> (icp == NULL) {
			icmp6stat.icp6s_tooshort++;
			<span class="enscript-keyword">return</span>;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (icp-&gt;icmp6_type &lt; ICMP6_ECHO_REQUEST ||
		    icp-&gt;icmp6_type == ND_REDIRECT) {
			<span class="enscript-comment">/*
			 * ICMPv6 error
			 * Special case: for redirect (which is
			 * informational) we must not send icmp6 error.
			 */</span>
			icmp6stat.icp6s_canterror++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* ICMPv6 informational - send the error */</span>
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* non-ICMPv6 - send the error */</span>
	}

	oip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *); <span class="enscript-comment">/* adjust pointer */</span>

	<span class="enscript-comment">/* Finally, do rate limitation check. */</span>
	<span class="enscript-keyword">if</span> (icmp6_ratelimit(&amp;oip6-&gt;ip6_src, type, code)) {
		icmp6stat.icp6s_toofreq++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}

	<span class="enscript-comment">/*
	 * OK, ICMP6 can be generated.
	 */</span>

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &gt;= ICMPV6_PLD_MAXLEN)
		m_adj(m, ICMPV6_PLD_MAXLEN - m-&gt;m_pkthdr.len);

	preplen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr);
	M_PREPEND(m, preplen, M_DONTWAIT, 1);
	<span class="enscript-keyword">if</span> (m &amp;&amp; m-&gt;m_len &lt; preplen)
		m = m_pullup(m, preplen);
	<span class="enscript-keyword">if</span> (m == NULL) {
		nd6log((LOG_DEBUG, <span class="enscript-string">&quot;ENOBUFS in icmp6_error %d\n&quot;</span>, __LINE__));
		<span class="enscript-keyword">return</span>;
	}

	nip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	nip6-&gt;ip6_src  = oip6-&gt;ip6_src;
	nip6-&gt;ip6_dst  = oip6-&gt;ip6_dst;

	in6_clearscope(&amp;oip6-&gt;ip6_src);
	in6_clearscope(&amp;oip6-&gt;ip6_dst);

	icmp6 = (<span class="enscript-type">struct</span> icmp6_hdr *)(nip6 + 1);
	icmp6-&gt;icmp6_type = type;
	icmp6-&gt;icmp6_code = code;
	icmp6-&gt;icmp6_pptr = htonl((u_int32_t)param);

	<span class="enscript-comment">/*
	 * icmp6_reflect() is designed to be in the input path.
	 * icmp6_error() can be called from both input and output path,
	 * and if we are in output path rcvif could contain bogus value.
	 * clear m-&gt;m_pkthdr.rcvif for safety, we should have enough scope
	 * information in ip header (nip6).
	 */</span>
	<span class="enscript-keyword">if</span> (flags &amp; ICMP6_ERROR_RST_MRCVIF) {
		m-&gt;m_pkthdr.rcvif = NULL;
	}

	icmp6stat.icp6s_outhist[type]++;
	icmp6_reflect(m, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr)); <span class="enscript-comment">/* header order: IPv6 - ICMPv6 */</span>

	<span class="enscript-keyword">return</span>;

  <span class="enscript-reference">freeit</span>:
	<span class="enscript-comment">/*
	 * If we can't tell whether or not we can generate ICMP6, free it.
	 */</span>
	m_freem(m);
}

<span class="enscript-comment">/*
 * Process a received ICMP6 message.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">icmp6_input</span>(<span class="enscript-type">struct</span> mbuf **mp, <span class="enscript-type">int</span> *offp, <span class="enscript-type">int</span> proto)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">proto</span>)
	<span class="enscript-type">struct</span> mbuf *m = *mp, *n;
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> ip6_hdr *ip6, *nip6;
	<span class="enscript-type">struct</span> icmp6_hdr *icmp6, *nicmp6;
	<span class="enscript-type">int</span> off = *offp;
	<span class="enscript-type">int</span> icmp6len = m-&gt;m_pkthdr.len - *offp;
	<span class="enscript-type">int</span> code, sum, noff, proxy = 0;

	ifp = m-&gt;m_pkthdr.rcvif;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PULLDOWN_TEST</span>
	IP6_EXTHDR_CHECK(m, off, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr), <span class="enscript-keyword">return</span> IPPROTO_DONE);
	<span class="enscript-comment">/* m might change if M_LOOP.  So, call mtod after this */</span>
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Expect 32-bit aligned data pointer on strict-align platforms */</span>
	MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

	<span class="enscript-comment">/*
	 * Locate icmp6 structure in mbuf, and check
	 * that not corrupted and of at least minimum length
	 */</span>
	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	<span class="enscript-keyword">if</span> (icmp6len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr)) {
		icmp6stat.icp6s_tooshort++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PULLDOWN_TEST</span>
	icmp6 = (<span class="enscript-type">struct</span> icmp6_hdr *)((caddr_t)ip6 + off);
#<span class="enscript-reference">else</span>
	IP6_EXTHDR_GET(icmp6, <span class="enscript-type">struct</span> icmp6_hdr *, m, off, <span class="enscript-keyword">sizeof</span>(*icmp6));
	<span class="enscript-keyword">if</span> (icmp6 == NULL) {
		icmp6stat.icp6s_tooshort++;
		<span class="enscript-keyword">return</span> IPPROTO_DONE;
	}
#<span class="enscript-reference">endif</span>
	code = icmp6-&gt;icmp6_code;

	<span class="enscript-comment">/* Apply rate limit before checksum validation. */</span>
	<span class="enscript-keyword">if</span> (icmp6_ratelimit(&amp;ip6-&gt;ip6_dst, icmp6-&gt;icmp6_type, code)) {
		icmp6stat.icp6s_toofreq++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}

	<span class="enscript-comment">/*
	 * Check multicast group membership.
	 * Note: SSM filters are not applied for ICMPv6 traffic.
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst)) {
		<span class="enscript-type">struct</span> in6_multi	*inm;

		in6_multihead_lock_shared();
		IN6_LOOKUP_MULTI(&amp;ip6-&gt;ip6_dst, ifp, inm);
		in6_multihead_lock_done();

		<span class="enscript-keyword">if</span> (inm == NULL) {
			<span class="enscript-comment">/*
			 * Don't discard if this is a Neighbor Solicitation
			 * that needs to be proxied (see check down below.)
			 */</span>
			<span class="enscript-keyword">if</span> (!(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_PROXY_DST)) {
				ip6stat.ip6s_notmember++;
				in6_ifstat_inc(m-&gt;m_pkthdr.rcvif,
				    ifs6_in_discard);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
			}
		} <span class="enscript-keyword">else</span> {
			IN6M_REMREF(inm);
		}
	}

	<span class="enscript-comment">/*
	 * calculate the checksum
	 */</span>
	<span class="enscript-keyword">if</span> ((sum = in6_cksum(m, IPPROTO_ICMPV6, off, icmp6len)) != 0) {
		nd6log((LOG_ERR,
		    <span class="enscript-string">&quot;ICMP6 checksum error(%d|%x) %s\n&quot;</span>,
		    icmp6-&gt;icmp6_type, sum, ip6_sprintf(&amp;ip6-&gt;ip6_src)));
		icmp6stat.icp6s_checksum++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_PROXY_DST) {
		<span class="enscript-comment">/*
		 * This is the special case of proxying NS (dst is either
		 * solicited-node multicast or unicast); process it locally
		 * but don't deliver it to sockets.  It practically lets us
		 * steer the packet to nd6_prproxy_ns_input, where more
		 * specific tests and actions will be taken.
		 */</span>
		<span class="enscript-keyword">switch</span> (icmp6-&gt;icmp6_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_NEIGHBOR_SOLICIT</span>:
			proxy = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
		}
	}

	icmp6stat.icp6s_inhist[icmp6-&gt;icmp6_type]++;
	icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_msg);
	<span class="enscript-keyword">if</span> (icmp6-&gt;icmp6_type &lt; ICMP6_INFOMSG_MASK)
		icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_error);

	<span class="enscript-keyword">switch</span> (icmp6-&gt;icmp6_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH</span>:
		icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_dstunreach);
		<span class="enscript-keyword">switch</span> (code) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH_NOROUTE</span>:
			code = PRC_UNREACH_NET;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH_ADMIN</span>:
			icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_adminprohib);
			code = PRC_UNREACH_PROTOCOL; <span class="enscript-comment">/* is this a good code? */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH_ADDR</span>:
			code = PRC_HOSTDEAD;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH_BEYONDSCOPE</span>:
			<span class="enscript-comment">/* I mean &quot;source address was incorrect.&quot; */</span>
			code = PRC_PARAMPROB;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_DST_UNREACH_NOPORT</span>:
			code = PRC_UNREACH_PORT;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badcode</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">deliver</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_PACKET_TOO_BIG</span>:
		icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_pkttoobig);

		code = PRC_MSGSIZE;

		<span class="enscript-comment">/*
		 * Updating the path MTU will be done after examining
		 * intermediate extension headers.
		 */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">deliver</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_TIME_EXCEEDED</span>:
		icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_timeexceed);
		<span class="enscript-keyword">switch</span> (code) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_TIME_EXCEED_TRANSIT</span>:
			code = PRC_TIMXCEED_INTRANS;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_TIME_EXCEED_REASSEMBLY</span>:
			code = PRC_TIMXCEED_REASS;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badcode</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">deliver</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_PARAM_PROB</span>:
		icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_paramprob);
		<span class="enscript-keyword">switch</span> (code) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_PARAMPROB_NEXTHEADER</span>:
			code = PRC_UNREACH_PROTOCOL;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_PARAMPROB_HEADER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_PARAMPROB_OPTION</span>:
			code = PRC_PARAMPROB;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badcode</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">deliver</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_ECHO_REQUEST</span>:
		icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_echo);
		<span class="enscript-keyword">if</span> (code != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badcode</span>;

		<span class="enscript-keyword">if</span> ((n = m_copy(m, 0, M_COPYALL)) == NULL) {
			<span class="enscript-comment">/* Give up remote */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">rate_limit_checked</span>;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> ((n-&gt;m_flags &amp; M_EXT) != 0
		 || n-&gt;m_len &lt; off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr)) {
			<span class="enscript-type">struct</span> mbuf *n0 = n;
			<span class="enscript-type">const</span> <span class="enscript-type">int</span> maxlen = <span class="enscript-keyword">sizeof</span>(*nip6) + <span class="enscript-keyword">sizeof</span>(*nicmp6);

			<span class="enscript-comment">/*
			 * Prepare an internal mbuf. m_pullup() doesn't
			 * always copy the length we specified.
			 */</span>
			<span class="enscript-keyword">if</span> (maxlen &gt;= MCLBYTES) {
				<span class="enscript-comment">/* Give up remote */</span>
				m_freem(n0);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">rate_limit_checked</span>;
				<span class="enscript-keyword">break</span>;
			}
			MGETHDR(n, M_DONTWAIT, n0-&gt;m_type);	<span class="enscript-comment">/* MAC-OK */</span>
			<span class="enscript-keyword">if</span> (n &amp;&amp; maxlen &gt;= MHLEN) {
				MCLGET(n, M_DONTWAIT);
				<span class="enscript-keyword">if</span> ((n-&gt;m_flags &amp; M_EXT) == 0) {
					m_free(n);
					n = NULL;
				}
			}
			<span class="enscript-keyword">if</span> (n == NULL) {
				<span class="enscript-comment">/* Give up remote */</span>
				m_freem(n0);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">rate_limit_checked</span>;
				<span class="enscript-keyword">break</span>;
			}
			M_COPY_PKTHDR(n, n0);
			<span class="enscript-comment">/*
			 * Copy IPv6 and ICMPv6 only.
			 */</span>
			nip6 = mtod(n, <span class="enscript-type">struct</span> ip6_hdr *);
			bcopy(ip6, nip6, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));
			nicmp6 = (<span class="enscript-type">struct</span> icmp6_hdr *)(nip6 + 1);
			bcopy(icmp6, nicmp6, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr));
			noff = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
			n-&gt;m_pkthdr.len = n-&gt;m_len =
				noff + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr);
			<span class="enscript-comment">/*
			 * Adjust mbuf. ip6_plen will be adjusted in
			 * ip6_output().
			 */</span>
			m_adj(n0, off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr));
			n-&gt;m_pkthdr.len += n0-&gt;m_pkthdr.len;
			n-&gt;m_next = n0;
			n0-&gt;m_flags &amp;= ~M_PKTHDR;
		} <span class="enscript-keyword">else</span> {
			nip6 = mtod(n, <span class="enscript-type">struct</span> ip6_hdr *);
			IP6_EXTHDR_GET(nicmp6, <span class="enscript-type">struct</span> icmp6_hdr *, n, off,
				<span class="enscript-keyword">sizeof</span>(*nicmp6));
			noff = off;
		}
		<span class="enscript-keyword">if</span>(nicmp6 == NULL)
			panic(<span class="enscript-string">&quot;nicmp6 is NULL in %s, which isn't good!\n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">else</span> {
			nicmp6-&gt;icmp6_type = ICMP6_ECHO_REPLY;
			nicmp6-&gt;icmp6_code = 0;
		}
		<span class="enscript-keyword">if</span> (n) {
			icmp6stat.icp6s_reflect++;
			icmp6stat.icp6s_outhist[ICMP6_ECHO_REPLY]++;
			icmp6_reflect(n, noff);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">rate_limit_checked</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_ECHO_REPLY</span>:
		icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_echoreply);
		<span class="enscript-keyword">if</span> (code != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badcode</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MLD_LISTENER_QUERY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MLD_LISTENER_REPORT</span>:

		<span class="enscript-keyword">if</span> (icmp6len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mld_hdr))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badlen</span>;
		<span class="enscript-keyword">if</span> (icmp6-&gt;icmp6_type == MLD_LISTENER_QUERY) <span class="enscript-comment">/* XXX: ugly... */</span>
			icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_mldquery);
		<span class="enscript-keyword">else</span>
			icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_mldreport);

		<span class="enscript-keyword">if</span> ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			<span class="enscript-comment">/* give up local */</span>
			<span class="enscript-keyword">if</span> (mld_input(m, off, icmp6len) == IPPROTO_DONE)
				m = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
		}
		<span class="enscript-keyword">if</span> (mld_input(n, off, icmp6len) != IPPROTO_DONE)
			m_freem(n);
		<span class="enscript-comment">/* m stays. */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">rate_limit_checked</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MLD_LISTENER_DONE</span>:
		icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_mlddone);
		<span class="enscript-keyword">if</span> (icmp6len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mld_hdr))	<span class="enscript-comment">/* necessary? */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badlen</span>;
		<span class="enscript-keyword">break</span>;		<span class="enscript-comment">/* nothing to be done in kernel */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MLD_MTRACE_RESP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MLD_MTRACE</span>:
		<span class="enscript-comment">/* XXX: these two are experimental.  not officially defined. */</span>
		<span class="enscript-comment">/* XXX: per-interface statistics? */</span>
		<span class="enscript-keyword">break</span>;		<span class="enscript-comment">/* just pass it to applications */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_NI_QUERY</span>:
		<span class="enscript-keyword">if</span> (!icmp6_nodeinfo)
			<span class="enscript-keyword">break</span>;
<span class="enscript-comment">//### LD 10/20 Check fbsd differences here. Not sure we're more advanced or not.
</span>		<span class="enscript-comment">/* By RFC 4620 refuse to answer queries from global scope addresses */</span> 
		<span class="enscript-keyword">if</span> ((icmp6_nodeinfo &amp; 8) != 8 &amp;&amp; in6_addrscope(&amp;ip6-&gt;ip6_src) == IPV6_ADDR_SCOPE_GLOBAL)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> (icmp6len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_nodeinfo))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badlen</span>;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PULLDOWN_TEST</span>
		IP6_EXTHDR_CHECK(m, off, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_nodeinfo),
				 <span class="enscript-keyword">return</span> IPPROTO_DONE);
#<span class="enscript-reference">endif</span>

		n = m_copy(m, 0, M_COPYALL);
		<span class="enscript-keyword">if</span> (n)
			n = ni6_input(n, off);
		<span class="enscript-keyword">if</span> (n) {
			noff = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
			icmp6stat.icp6s_reflect++;
			icmp6stat.icp6s_outhist[ICMP6_WRUREPLY]++;
			icmp6_reflect(n, noff);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">rate_limit_checked</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_WRUREPLY</span>:
		<span class="enscript-keyword">if</span> (code != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badcode</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_ROUTER_SOLICIT</span>:
		icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_routersolicit);
		<span class="enscript-keyword">if</span> (code != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badcode</span>;
		<span class="enscript-keyword">if</span> (icmp6len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nd_router_solicit))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badlen</span>;

		<span class="enscript-keyword">if</span> ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			<span class="enscript-comment">/* give up local */</span>
			nd6_rs_input(m, off, icmp6len);
			m = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
		}
		nd6_rs_input(n, off, icmp6len);
		<span class="enscript-comment">/* m stays. */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">rate_limit_checked</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_ROUTER_ADVERT</span>:
		icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_routeradvert);
		<span class="enscript-keyword">if</span> (code != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badcode</span>;
		<span class="enscript-keyword">if</span> (icmp6len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nd_router_advert))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badlen</span>;

		<span class="enscript-keyword">if</span> ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			<span class="enscript-comment">/* give up local */</span>
			nd6_ra_input(m, off, icmp6len);
			m = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
		}
		nd6_ra_input(n, off, icmp6len);
		<span class="enscript-comment">/* m stays. */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">rate_limit_checked</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_NEIGHBOR_SOLICIT</span>:
		icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_neighborsolicit);
		<span class="enscript-keyword">if</span> (code != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badcode</span>;
		<span class="enscript-keyword">if</span> (icmp6len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nd_neighbor_solicit))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badlen</span>;

		<span class="enscript-keyword">if</span> ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			<span class="enscript-comment">/* give up local */</span>
			nd6_ns_input(m, off, icmp6len);
			m = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
		}
		nd6_ns_input(n, off, icmp6len);
		<span class="enscript-comment">/* m stays. */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">rate_limit_checked</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_NEIGHBOR_ADVERT</span>:
		icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_neighboradvert);
		<span class="enscript-keyword">if</span> (code != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badcode</span>;
		<span class="enscript-keyword">if</span> (icmp6len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nd_neighbor_advert))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badlen</span>;

		<span class="enscript-keyword">if</span> ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			<span class="enscript-comment">/* give up local */</span>
			nd6_na_input(m, off, icmp6len);
			m = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
		}
		nd6_na_input(n, off, icmp6len);
		<span class="enscript-comment">/* m stays. */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">rate_limit_checked</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_REDIRECT</span>:
		icmp6_ifstat_inc(m-&gt;m_pkthdr.rcvif, ifs6_in_redirect);
		<span class="enscript-keyword">if</span> (code != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badcode</span>;
		<span class="enscript-keyword">if</span> (icmp6len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nd_redirect))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badlen</span>;

		<span class="enscript-keyword">if</span> ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			<span class="enscript-comment">/* give up local */</span>
			icmp6_redirect_input(m, off);
			m = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
		}
		icmp6_redirect_input(n, off);
		<span class="enscript-comment">/* m stays. */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">rate_limit_checked</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_ROUTER_RENUMBERING</span>:
		<span class="enscript-keyword">if</span> (code != ICMP6_ROUTER_RENUMBERING_COMMAND &amp;&amp;
		    code != ICMP6_ROUTER_RENUMBERING_RESULT)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badcode</span>;
		<span class="enscript-keyword">if</span> (icmp6len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_router_renum))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badlen</span>;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		nd6log((LOG_DEBUG,
		    <span class="enscript-string">&quot;icmp6_input: unknown type %d(src=%s, dst=%s, ifid=%d)\n&quot;</span>,
		    icmp6-&gt;icmp6_type, ip6_sprintf(&amp;ip6-&gt;ip6_src),
		    ip6_sprintf(&amp;ip6-&gt;ip6_dst),
		    m-&gt;m_pkthdr.rcvif ? m-&gt;m_pkthdr.rcvif-&gt;if_index : 0));
		<span class="enscript-keyword">if</span> (icmp6-&gt;icmp6_type &lt; ICMP6_ECHO_REQUEST) {
			<span class="enscript-comment">/* ICMPv6 error: MUST deliver it by spec... */</span>
			code = PRC_NCMDS;
			<span class="enscript-comment">/* deliver */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* ICMPv6 informational: MUST not deliver */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">rate_limit_checked</span>;
			<span class="enscript-keyword">break</span>;
		}
	<span class="enscript-reference">deliver</span>:
		<span class="enscript-keyword">if</span> (icmp6_notify_error(m, off, icmp6len, code)) {
			<span class="enscript-comment">/* In this case, m should've been freed. */</span>
			<span class="enscript-keyword">return</span>(IPPROTO_DONE);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">badcode</span>:
		icmp6stat.icp6s_badcode++;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">badlen</span>:
		icmp6stat.icp6s_badlen++;
		<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">rate_limit_checked</span>:
	<span class="enscript-comment">/* deliver the packet to appropriate sockets (unless proxying) */</span>
	<span class="enscript-keyword">if</span> (!proxy) {
		icmp6_rip6_input(&amp;m, *offp);
		<span class="enscript-keyword">return</span> IPPROTO_DONE;
	}

<span class="enscript-reference">freeit</span>:
	m_freem(m);
	<span class="enscript-keyword">return</span> IPPROTO_DONE;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">icmp6_notify_error</span>(m, off, icmp6len, code)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> off, icmp6len, code;
{
	<span class="enscript-type">struct</span> icmp6_hdr *icmp6;
	<span class="enscript-type">struct</span> ip6_hdr *eip6;
	u_int32_t notifymtu;
	<span class="enscript-type">struct</span> sockaddr_in6 icmp6src, icmp6dst;

	<span class="enscript-keyword">if</span> (icmp6len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr)) {
		icmp6stat.icp6s_tooshort++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PULLDOWN_TEST</span>
	IP6_EXTHDR_CHECK(m, off,
			 <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr),
			 <span class="enscript-keyword">return</span> -1);
	icmp6 = (<span class="enscript-type">struct</span> icmp6_hdr *)(mtod(m, caddr_t) + off);
#<span class="enscript-reference">else</span>
	IP6_EXTHDR_GET(icmp6, <span class="enscript-type">struct</span> icmp6_hdr *, m, off,
		       <span class="enscript-keyword">sizeof</span>(*icmp6) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));
	<span class="enscript-keyword">if</span> (icmp6 == NULL) {
		icmp6stat.icp6s_tooshort++;
		<span class="enscript-keyword">return</span>(-1);
	}
#<span class="enscript-reference">endif</span>
	eip6 = (<span class="enscript-type">struct</span> ip6_hdr *)(icmp6 + 1);

	<span class="enscript-comment">/* Detect the upper level protocol */</span>
	{
		<span class="enscript-type">void</span> (*ctlfunc)(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">void</span> *);
		u_int8_t nxt = eip6-&gt;ip6_nxt;
		<span class="enscript-type">int</span> eoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr) +
			<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
		<span class="enscript-type">struct</span> ip6ctlparam ip6cp;
		<span class="enscript-type">struct</span> in6_addr *finaldst = NULL;
		<span class="enscript-type">int</span> icmp6type = icmp6-&gt;icmp6_type;
		<span class="enscript-type">struct</span> ip6_frag *fh;
		<span class="enscript-type">struct</span> ip6_rthdr *rth;
		<span class="enscript-type">struct</span> ip6_rthdr0 *rth0;
		<span class="enscript-type">int</span> rthlen;

		<span class="enscript-keyword">while</span> (1) { <span class="enscript-comment">/* XXX: should avoid infinite loop explicitly? */</span>
			<span class="enscript-type">struct</span> ip6_ext *eh;

			<span class="enscript-keyword">switch</span> (nxt) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_HOPOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_DSTOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PULLDOWN_TEST</span>
				IP6_EXTHDR_CHECK(m, 0, eoff +
						 <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_ext),
						 <span class="enscript-keyword">return</span> -1);
				eh = (<span class="enscript-type">struct</span> ip6_ext *)(mtod(m, caddr_t)
							+ eoff);
#<span class="enscript-reference">else</span>
				IP6_EXTHDR_GET(eh, <span class="enscript-type">struct</span> ip6_ext *, m,
					       eoff, <span class="enscript-keyword">sizeof</span>(*eh));
				<span class="enscript-keyword">if</span> (eh == NULL) {
					icmp6stat.icp6s_tooshort++;
					<span class="enscript-keyword">return</span>(-1);
				}
#<span class="enscript-reference">endif</span>

				<span class="enscript-keyword">if</span> (nxt == IPPROTO_AH)
					eoff += (eh-&gt;ip6e_len + 2) &lt;&lt; 2;
				<span class="enscript-keyword">else</span>
					eoff += (eh-&gt;ip6e_len + 1) &lt;&lt; 3;
				nxt = eh-&gt;ip6e_nxt;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ROUTING</span>:
				<span class="enscript-comment">/*
				 * When the erroneous packet contains a
				 * routing header, we should examine the
				 * header to determine the final destination.
				 * Otherwise, we can't properly update
				 * information that depends on the final
				 * destination (e.g. path MTU).
				 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PULLDOWN_TEST</span>
				IP6_EXTHDR_CHECK(m, 0, eoff + <span class="enscript-keyword">sizeof</span>(*rth),
						 <span class="enscript-keyword">return</span> -1);
				rth = (<span class="enscript-type">struct</span> ip6_rthdr *)(mtod(m, caddr_t)
							   + eoff);
#<span class="enscript-reference">else</span>
				IP6_EXTHDR_GET(rth, <span class="enscript-type">struct</span> ip6_rthdr *, m,
					       eoff, <span class="enscript-keyword">sizeof</span>(*rth));
				<span class="enscript-keyword">if</span> (rth == NULL) {
					icmp6stat.icp6s_tooshort++;
					<span class="enscript-keyword">return</span>(-1);
				}
#<span class="enscript-reference">endif</span>
				rthlen = (rth-&gt;ip6r_len + 1) &lt;&lt; 3;
				<span class="enscript-comment">/*
				 * XXX: currently there is no
				 * officially defined type other
				 * than type-0.
				 * Note that if the segment left field
				 * is 0, all intermediate hops must
				 * have been passed.
				 */</span>
				<span class="enscript-keyword">if</span> (rth-&gt;ip6r_segleft &amp;&amp;
				    rth-&gt;ip6r_type == IPV6_RTHDR_TYPE_0) {
					<span class="enscript-type">int</span> hops;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PULLDOWN_TEST</span>
					IP6_EXTHDR_CHECK(m, 0, eoff + rthlen,
							 <span class="enscript-keyword">return</span> -1);
					rth0 = (<span class="enscript-type">struct</span> ip6_rthdr0 *)(mtod(m, caddr_t) + eoff);
#<span class="enscript-reference">else</span>
					IP6_EXTHDR_GET(rth0,
						       <span class="enscript-type">struct</span> ip6_rthdr0 *, m,
						       eoff, rthlen);
					<span class="enscript-keyword">if</span> (rth0 == NULL) {
						icmp6stat.icp6s_tooshort++;
						<span class="enscript-keyword">return</span>(-1);
					}
#<span class="enscript-reference">endif</span>
					<span class="enscript-comment">/* just ignore a bogus header */</span>
					<span class="enscript-keyword">if</span> ((rth0-&gt;ip6r0_len % 2) == 0 &amp;&amp;
					    (hops = rth0-&gt;ip6r0_len/2))
						finaldst = (<span class="enscript-type">struct</span> in6_addr *)(<span class="enscript-type">void</span> *)(rth0 + 1) + (hops - 1);
				}
				eoff += rthlen;
				nxt = rth-&gt;ip6r_nxt;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_FRAGMENT</span>:
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PULLDOWN_TEST</span>
				IP6_EXTHDR_CHECK(m, 0, eoff +
						 <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_frag),
						 <span class="enscript-keyword">return</span> -1);
				fh = (<span class="enscript-type">struct</span> ip6_frag *)(mtod(m, caddr_t)
							 + eoff);
#<span class="enscript-reference">else</span>
				IP6_EXTHDR_GET(fh, <span class="enscript-type">struct</span> ip6_frag *, m,
					       eoff, <span class="enscript-keyword">sizeof</span>(*fh));
				<span class="enscript-keyword">if</span> (fh == NULL) {
					icmp6stat.icp6s_tooshort++;
					<span class="enscript-keyword">return</span> (-1);
				}
#<span class="enscript-reference">endif</span>
				<span class="enscript-comment">/*
				 * Data after a fragment header is meaningless
				 * unless it is the first fragment, but
				 * we'll go to the notify label for path MTU
				 * discovery.
				 */</span>
				<span class="enscript-keyword">if</span> (fh-&gt;ip6f_offlg &amp; IP6F_OFF_MASK)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">notify</span>;

				eoff += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_frag);
				nxt = fh-&gt;ip6f_nxt;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-comment">/*
				 * This case includes ESP and the No Next
				 * Header.  In such cases going to the notify
				 * label does not have any meaning
				 * (i.e. ctlfunc will be NULL), but we go
				 * anyway since we might have to update
				 * path MTU information.
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">notify</span>;
			}
		}
	  <span class="enscript-reference">notify</span>:
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PULLDOWN_TEST</span>
		icmp6 = (<span class="enscript-type">struct</span> icmp6_hdr *)(mtod(m, caddr_t) + off);
#<span class="enscript-reference">else</span>
		IP6_EXTHDR_GET(icmp6, <span class="enscript-type">struct</span> icmp6_hdr *, m, off,
		    <span class="enscript-keyword">sizeof</span>(*icmp6) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));
		<span class="enscript-keyword">if</span> (icmp6 == NULL) {
			icmp6stat.icp6s_tooshort++;
			<span class="enscript-keyword">return</span> (-1);
		}
#<span class="enscript-reference">endif</span>

		<span class="enscript-comment">/*
		 * retrieve parameters from the inner IPv6 header, and convert
		 * them into sockaddr structures.
		 * XXX: there is no guarantee that the source or destination
		 * addresses of the inner packet are in the same scope as
		 * the addresses of the icmp packet.  But there is no other
		 * way to determine the zone.
		 */</span>
		eip6 = (<span class="enscript-type">struct</span> ip6_hdr *)(icmp6 + 1);

		bzero(&amp;icmp6dst, <span class="enscript-keyword">sizeof</span>(icmp6dst));
		icmp6dst.sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
		icmp6dst.sin6_family = AF_INET6;
		<span class="enscript-keyword">if</span> (finaldst == NULL)
			icmp6dst.sin6_addr = eip6-&gt;ip6_dst;
		<span class="enscript-keyword">else</span>
			icmp6dst.sin6_addr = *finaldst;
		<span class="enscript-keyword">if</span> (in6_setscope(&amp;icmp6dst.sin6_addr, m-&gt;m_pkthdr.rcvif, NULL))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
		bzero(&amp;icmp6src, <span class="enscript-keyword">sizeof</span>(icmp6src));
		icmp6src.sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
		icmp6src.sin6_family = AF_INET6;
		icmp6src.sin6_addr = eip6-&gt;ip6_src;
		<span class="enscript-keyword">if</span> (in6_setscope(&amp;icmp6src.sin6_addr, m-&gt;m_pkthdr.rcvif, NULL))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
		icmp6src.sin6_flowinfo =
		    (eip6-&gt;ip6_flow &amp; IPV6_FLOWLABEL_MASK);

		<span class="enscript-keyword">if</span> (finaldst == NULL)
			finaldst = &amp;eip6-&gt;ip6_dst;
		ip6cp.ip6c_m = m;
		ip6cp.ip6c_icmp6 = icmp6;
		ip6cp.ip6c_ip6 = (<span class="enscript-type">struct</span> ip6_hdr *)(icmp6 + 1);
		ip6cp.ip6c_off = eoff;
		ip6cp.ip6c_finaldst = finaldst;
		ip6cp.ip6c_src = &amp;icmp6src;
		ip6cp.ip6c_nxt = nxt;

		<span class="enscript-keyword">if</span> (icmp6type == ICMP6_PACKET_TOO_BIG) {
			notifymtu = ntohl(icmp6-&gt;icmp6_mtu);
			ip6cp.ip6c_cmdarg = (<span class="enscript-type">void</span> *)&amp;notifymtu;
			icmp6_mtudisc_update(&amp;ip6cp, 1);	<span class="enscript-comment">/*XXX*/</span>
		}

		ctlfunc = (<span class="enscript-type">void</span> (*)(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">void</span> *))
			(ip6_protox[nxt]-&gt;pr_ctlinput);
		<span class="enscript-keyword">if</span> (ctlfunc) {
			(<span class="enscript-type">void</span>) (*ctlfunc)(code, (<span class="enscript-type">struct</span> sockaddr *)&amp;icmp6dst,
					  &amp;ip6cp);
		}
	}
	<span class="enscript-keyword">return</span>(0);

<span class="enscript-reference">freeit</span>:
	m_freem(m);
	<span class="enscript-keyword">return</span>(-1);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">icmp6_mtudisc_update</span>(ip6cp, validated)
	<span class="enscript-type">struct</span> ip6ctlparam *ip6cp;
	<span class="enscript-type">int</span> validated;
{
	<span class="enscript-type">struct</span> in6_addr *dst = ip6cp-&gt;ip6c_finaldst;
	<span class="enscript-type">struct</span> icmp6_hdr *icmp6 = ip6cp-&gt;ip6c_icmp6;
	<span class="enscript-type">struct</span> mbuf *m = ip6cp-&gt;ip6c_m;	<span class="enscript-comment">/* will be necessary for scope issue */</span>
	u_int mtu = ntohl(icmp6-&gt;icmp6_mtu);
	<span class="enscript-type">struct</span> rtentry *rt = NULL;
	<span class="enscript-type">struct</span> sockaddr_in6 sin6;
	<span class="enscript-comment">/*
	 * we reject ICMPv6 too big with abnormally small value.
	 * XXX what is the good definition of &quot;abnormally small&quot;?
	 */</span>
	<span class="enscript-keyword">if</span> (mtu &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_frag) + 8)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (!validated)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * In case the suggested mtu is less than IPV6_MMTU, we
	 * only need to remember that it was for above mentioned
	 * &quot;alwaysfrag&quot; case.
	 * Try to be as close to the spec as possible.
	 */</span>
	<span class="enscript-keyword">if</span> (mtu &lt; IPV6_MMTU)
		mtu = IPV6_MMTU - 8;

	bzero(&amp;sin6, <span class="enscript-keyword">sizeof</span>(sin6));
	sin6.sin6_family = PF_INET6;
	sin6.sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
	sin6.sin6_addr = *dst;
	<span class="enscript-comment">/* XXX normally, this won't happen */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(dst)) {
		sin6.sin6_addr.s6_addr16[1] =
		    htons(m-&gt;m_pkthdr.rcvif-&gt;if_index);
	}
	<span class="enscript-comment">/* sin6.sin6_scope_id = XXX: should be set if DST is a scoped addr */</span>
	rt = rtalloc1_scoped((<span class="enscript-type">struct</span> sockaddr *)&amp;sin6, 0,
	    RTF_CLONING | RTF_PRCLONING, m-&gt;m_pkthdr.rcvif-&gt;if_index);
	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK(rt);
		<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; RTF_HOST) &amp;&amp;
		    !(rt-&gt;rt_rmx.rmx_locks &amp; RTV_MTU) &amp;&amp;
		    mtu &lt; IN6_LINKMTU(rt-&gt;rt_ifp) &amp;&amp;
		    rt-&gt;rt_rmx.rmx_mtu &gt; mtu) {
			icmp6stat.icp6s_pmtuchg++;
			rt-&gt;rt_rmx.rmx_mtu = mtu;
		}
		RT_UNLOCK(rt);
		rtfree(rt);
	}
}

<span class="enscript-comment">/*
 * Process a Node Information Query packet, based on
 * draft-ietf-ipngwg-icmp-name-lookups-07.
 *
 * Spec incompatibilities:
 * - IPv6 Subject address handling
 * - IPv4 Subject address handling support missing
 * - Proxy reply (answer even if it's not for me)
 * - joins NI group address at in6_ifattach() time only, does not cope
 *   with hostname changes by sethostname(3)
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">hostnamelen</span>	strlen(hostname)
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">ni6_input</span>(m, off)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> off;
{
	<span class="enscript-type">struct</span> icmp6_nodeinfo *ni6, *nni6;
	<span class="enscript-type">struct</span> mbuf *n = NULL;
	u_int16_t qtype;
	<span class="enscript-type">int</span> subjlen;
	<span class="enscript-type">int</span> replylen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_nodeinfo);
	<span class="enscript-type">struct</span> ni_reply_fqdn *fqdn;
	<span class="enscript-type">int</span> addrs;		<span class="enscript-comment">/* for NI_QTYPE_NODEADDR */</span>
	<span class="enscript-type">struct</span> ifnet *ifp = NULL; <span class="enscript-comment">/* for NI_QTYPE_NODEADDR */</span>
	<span class="enscript-type">struct</span> sockaddr_in6 sin6; <span class="enscript-comment">/* double meaning; ip6_dst and subjectaddr */</span>
	<span class="enscript-type">struct</span> sockaddr_in6 sin6_d; <span class="enscript-comment">/* XXX: we should retrieve this from m_aux */</span>
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">int</span> oldfqdn = 0;	<span class="enscript-comment">/* if 1, return pascal string (03 draft) */</span>
	<span class="enscript-type">char</span> *subj = NULL;

	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PULLDOWN_TEST</span>
	ni6 = (<span class="enscript-type">struct</span> icmp6_nodeinfo *)(mtod(m, caddr_t) + off);
#<span class="enscript-reference">else</span>
	IP6_EXTHDR_GET(ni6, <span class="enscript-type">struct</span> icmp6_nodeinfo *, m, off, <span class="enscript-keyword">sizeof</span>(*ni6));
	<span class="enscript-keyword">if</span> (ni6 == NULL) {
		<span class="enscript-comment">/* m is already reclaimed */</span>
		<span class="enscript-keyword">return</span> (NULL);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Validate IPv6 source address.
	 * The default configuration MUST be to refuse answering queries from
	 * global-scope addresses according to RFC4602.
	 * Notes:
	 *  - it's not very clear what &quot;refuse&quot; means; this implementation
	 *    simply drops it.
	 *  - it's not very easy to identify global-scope (unicast) addresses
	 *    since there are many prefixes for them.  It should be safer
	 *    and in practice sufficient to check &quot;all&quot; but loopback and
	 *    link-local (note that site-local unicast was deprecated and
	 *    ULA is defined as global scope-wise)
	 */</span>
	<span class="enscript-keyword">if</span> ((icmp6_nodeinfo &amp; ICMP6_NODEINFO_GLOBALOK) == 0 &amp;&amp;
	    !IN6_IS_ADDR_LOOPBACK(&amp;ip6-&gt;ip6_src) &amp;&amp;
	    !IN6_IS_ADDR_LINKLOCAL(&amp;ip6-&gt;ip6_src))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-comment">/*
	 * Validate IPv6 destination address.
	 *
	 * The Responder must discard the Query without further processing
	 * unless it is one of the Responder's unicast or anycast addresses, or
	 * a link-local scope multicast address which the Responder has joined.
	 * [RFC4602, Section 5.]
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst)) {
		<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_MC_LINKLOCAL(&amp;ip6-&gt;ip6_dst))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		<span class="enscript-comment">/* else it's a link-local multicast, fine */</span>
	} <span class="enscript-keyword">else</span> {		<span class="enscript-comment">/* unicast or anycast */</span>
		uint32_t ia6_flags;

		<span class="enscript-keyword">if</span> (ip6_getdstifaddr_info(m, NULL, &amp;ia6_flags) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>; <span class="enscript-comment">/* XXX impossible */</span>

		<span class="enscript-keyword">if</span> ((ia6_flags &amp; IN6_IFF_TEMPORARY) &amp;&amp;
		    !(icmp6_nodeinfo &amp; ICMP6_NODEINFO_TMPADDROK)) {
			nd6log((LOG_DEBUG, <span class="enscript-string">&quot;ni6_input: ignore node info to &quot;</span>
				<span class="enscript-string">&quot;a temporary address in %s:%d&quot;</span>,
			       __FILE__, __LINE__));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

	<span class="enscript-comment">/* validate query Subject field. */</span>
	qtype = ntohs(ni6-&gt;ni_qtype);
	subjlen = m-&gt;m_pkthdr.len - off - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_nodeinfo);
	<span class="enscript-keyword">switch</span> (qtype) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_NOOP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_SUPTYPES</span>:
		<span class="enscript-comment">/* 07 draft */</span>
		<span class="enscript-keyword">if</span> (ni6-&gt;ni_code == ICMP6_NI_SUBJ_FQDN &amp;&amp; subjlen == 0)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* FALLTHROUGH */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_FQDN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_NODEADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_IPV4ADDR</span>:
		<span class="enscript-keyword">switch</span> (ni6-&gt;ni_code) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_NI_SUBJ_IPV6</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ICMP6_NI_SUBJ_IPV6</span> != 0
		<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
#<span class="enscript-reference">endif</span>
			<span class="enscript-comment">/*
			 * backward compatibility - try to accept 03 draft
			 * format, where no Subject is present.
			 */</span>
			<span class="enscript-keyword">if</span> (qtype == NI_QTYPE_FQDN &amp;&amp; ni6-&gt;ni_code == 0 &amp;&amp;
			    subjlen == 0) {
				oldfqdn++;
				<span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ICMP6_NI_SUBJ_IPV6</span> != 0
			<span class="enscript-keyword">if</span> (ni6-&gt;ni_code != ICMP6_NI_SUBJ_IPV6)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
#<span class="enscript-reference">endif</span>

			<span class="enscript-keyword">if</span> (subjlen != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

			<span class="enscript-comment">/*
			 * Validate Subject address.
			 *
			 * Not sure what exactly &quot;address belongs to the node&quot;
			 * means in the spec, is it just unicast, or what?
			 *
			 * At this moment we consider Subject address as
			 * &quot;belong to the node&quot; if the Subject address equals
			 * to the IPv6 destination address; validation for
			 * IPv6 destination address should have done enough
			 * check for us.
			 *
			 * We do not do proxy at this moment.
			 */</span>
			<span class="enscript-comment">/* m_pulldown instead of copy? */</span>
			m_copydata(m, off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_nodeinfo),
			    subjlen, (caddr_t)&amp;sin6.sin6_addr);
			sin6.sin6_scope_id = in6_addr2scopeid(m-&gt;m_pkthdr.rcvif,
							      &amp;sin6.sin6_addr);
			in6_embedscope(&amp;sin6.sin6_addr, &amp;sin6, NULL, NULL,
			    NULL);
			bzero(&amp;sin6_d, <span class="enscript-keyword">sizeof</span>(sin6_d));
			sin6_d.sin6_family = AF_INET6; <span class="enscript-comment">/* not used, actually */</span>
			sin6_d.sin6_len = <span class="enscript-keyword">sizeof</span>(sin6_d); <span class="enscript-comment">/* ditto */</span>
			sin6_d.sin6_addr = ip6-&gt;ip6_dst;
			sin6_d.sin6_scope_id = in6_addr2scopeid(m-&gt;m_pkthdr.rcvif,
								&amp;ip6-&gt;ip6_dst);
			in6_embedscope(&amp;sin6_d.sin6_addr, &amp;sin6_d, NULL, NULL,
			    NULL);
			subj = (<span class="enscript-type">char</span> *)&amp;sin6;
			<span class="enscript-keyword">if</span> (SA6_ARE_ADDR_EQUAL(&amp;sin6, &amp;sin6_d))
				<span class="enscript-keyword">break</span>;

			<span class="enscript-comment">/*
			 * XXX if we are to allow other cases, we should really
			 * be careful about scope here.
			 * basically, we should disallow queries toward IPv6
			 * destination X with subject Y,
			 * if scope(X) &gt; scope(Y).
			 * if we allow scope(X) &gt; scope(Y), it will result in
			 * information leakage across scope boundary.
			 */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_NI_SUBJ_FQDN</span>:
			<span class="enscript-comment">/*
			 * Validate Subject name with gethostname(3).
			 *
			 * The behavior may need some debate, since:
			 * - we are not sure if the node has FQDN as
			 *   hostname (returned by gethostname(3)).
			 * - the code does wildcard match for truncated names.
			 *   however, we are not sure if we want to perform
			 *   wildcard match, if gethostname(3) side has
			 *   truncated hostname.
			 */</span>
			n = ni6_nametodns(hostname, hostnamelen, 0);
			<span class="enscript-keyword">if</span> (!n || n-&gt;m_next || n-&gt;m_len == 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			IP6_EXTHDR_GET(subj, <span class="enscript-type">char</span> *, m,
			    off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_nodeinfo), subjlen);
			<span class="enscript-keyword">if</span> (subj == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			<span class="enscript-keyword">if</span> (!ni6_dnsmatch(subj, subjlen, mtod(n, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *),
					n-&gt;m_len)) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			m_freem(n);
			n = NULL;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_NI_SUBJ_IPV4</span>:	<span class="enscript-comment">/* XXX: to be implemented? */</span>
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* refuse based on configuration.  XXX ICMP6_NI_REFUSED? */</span>
	<span class="enscript-keyword">switch</span> (qtype) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_FQDN</span>:
		<span class="enscript-keyword">if</span> ((icmp6_nodeinfo &amp; ICMP6_NODEINFO_FQDNOK) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_NODEADDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_IPV4ADDR</span>:
		<span class="enscript-keyword">if</span> ((icmp6_nodeinfo &amp; ICMP6_NODEINFO_NODEADDROK) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* guess reply length */</span>
	<span class="enscript-keyword">switch</span> (qtype) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_NOOP</span>:
		<span class="enscript-keyword">break</span>;		<span class="enscript-comment">/* no reply data */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_SUPTYPES</span>:
		replylen += <span class="enscript-keyword">sizeof</span>(u_int32_t);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_FQDN</span>:
		<span class="enscript-comment">/* XXX will append an mbuf */</span>
		replylen += offsetof(<span class="enscript-type">struct</span> ni_reply_fqdn, ni_fqdn_namelen);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_NODEADDR</span>:
		addrs = ni6_addrs(ni6, &amp;ifp, subj);
		<span class="enscript-keyword">if</span> ((replylen += addrs * (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr) +
		    <span class="enscript-keyword">sizeof</span>(u_int32_t))) &gt; MCLBYTES)
			replylen = MCLBYTES; <span class="enscript-comment">/* XXX: will truncate pkt later */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_IPV4ADDR</span>:
		<span class="enscript-comment">/* unsupported - should respond with unknown Qtype? */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/*
		 * XXX: We must return a reply with the ICMP6 code
		 * `unknown Qtype' in this case.  However we regard the case
		 * as an FQDN query for backward compatibility.
		 * Older versions set a random value to this field,
		 * so it rarely varies in the defined qtypes.
		 * But the mechanism is not reliable...
		 * maybe we should obsolete older versions.
		 */</span>
		qtype = NI_QTYPE_FQDN;
		<span class="enscript-comment">/* XXX will append an mbuf */</span>
		replylen += offsetof(<span class="enscript-type">struct</span> ni_reply_fqdn, ni_fqdn_namelen);
		oldfqdn++;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* allocate an mbuf to reply. */</span>
	MGETHDR(n, M_DONTWAIT, m-&gt;m_type);	<span class="enscript-comment">/* MAC-OK */</span>
	<span class="enscript-keyword">if</span> (n == NULL) {
		m_freem(m);
		<span class="enscript-keyword">if</span> (ifp != NULL)
			ifnet_release(ifp);
		<span class="enscript-keyword">return</span> (NULL);
	}
	M_COPY_PKTHDR(n, m); <span class="enscript-comment">/* just for recvif */</span>
	<span class="enscript-keyword">if</span> (replylen &gt; MHLEN) {
		<span class="enscript-keyword">if</span> (replylen &gt; MCLBYTES) {
			<span class="enscript-comment">/*
			 * XXX: should we try to allocate more? But MCLBYTES
			 * is probably much larger than IPV6_MMTU...
			 */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		MCLGET(n, M_DONTWAIT);
		<span class="enscript-keyword">if</span> ((n-&gt;m_flags &amp; M_EXT) == 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}
	n-&gt;m_pkthdr.len = n-&gt;m_len = replylen;

	<span class="enscript-comment">/* copy mbuf header and IPv6 + Node Information base headers */</span>
	bcopy(mtod(m, caddr_t), mtod(n, caddr_t), <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));
	nni6 = (<span class="enscript-type">struct</span> icmp6_nodeinfo *)(mtod(n, <span class="enscript-type">struct</span> ip6_hdr *) + 1);
	bcopy((caddr_t)ni6, (caddr_t)nni6, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_nodeinfo));

	<span class="enscript-comment">/* qtype dependent procedure */</span>
	<span class="enscript-keyword">switch</span> (qtype) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_NOOP</span>:
		nni6-&gt;ni_code = ICMP6_NI_SUCCESS;
		nni6-&gt;ni_flags = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_SUPTYPES</span>:
	{
		u_int32_t v;
		nni6-&gt;ni_code = ICMP6_NI_SUCCESS;
		nni6-&gt;ni_flags = htons(0x0000);	<span class="enscript-comment">/* raw bitmap */</span>
		<span class="enscript-comment">/* supports NOOP, SUPTYPES, FQDN, and NODEADDR */</span>
		v = (u_int32_t)htonl(0x0000000f);
		bcopy(&amp;v, nni6 + 1, <span class="enscript-keyword">sizeof</span>(u_int32_t));
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_FQDN</span>:
		nni6-&gt;ni_code = ICMP6_NI_SUCCESS;
		fqdn = (<span class="enscript-type">struct</span> ni_reply_fqdn *)(mtod(n, caddr_t) +
						<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) +
						<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_nodeinfo));
		nni6-&gt;ni_flags = 0; <span class="enscript-comment">/* XXX: meaningless TTL */</span>
		fqdn-&gt;ni_fqdn_ttl = 0;	<span class="enscript-comment">/* ditto. */</span>
		<span class="enscript-comment">/*
		 * XXX do we really have FQDN in variable &quot;hostname&quot;?
		 */</span>
		n-&gt;m_next = ni6_nametodns(hostname, hostnamelen, oldfqdn);
		<span class="enscript-keyword">if</span> (n-&gt;m_next == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		<span class="enscript-comment">/* XXX we assume that n-&gt;m_next is not a chain */</span>
		<span class="enscript-keyword">if</span> (n-&gt;m_next-&gt;m_next != NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		n-&gt;m_pkthdr.len += n-&gt;m_next-&gt;m_len;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NI_QTYPE_NODEADDR</span>:
	{
		<span class="enscript-type">int</span> lenlim, copied;

		nni6-&gt;ni_code = ICMP6_NI_SUCCESS;
		n-&gt;m_pkthdr.len = n-&gt;m_len =
		    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_nodeinfo);
		lenlim = M_TRAILINGSPACE(n);
		copied = ni6_store_addrs(ni6, nni6, ifp, lenlim);
		<span class="enscript-comment">/* XXX: reset mbuf length */</span>
		n-&gt;m_pkthdr.len = n-&gt;m_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) +
			<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_nodeinfo) + copied;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;		<span class="enscript-comment">/* XXX impossible! */</span>
	}

	nni6-&gt;ni_type = ICMP6_NI_REPLY;
	m_freem(m);
	<span class="enscript-keyword">if</span> (ifp != NULL)
		ifnet_release(ifp);
	<span class="enscript-keyword">return</span> (n);

<span class="enscript-reference">bad</span>:
	m_freem(m);
	<span class="enscript-keyword">if</span> (n)
		m_freem(n);
	<span class="enscript-keyword">if</span> (ifp != NULL)
		ifnet_release(ifp);
	<span class="enscript-keyword">return</span> (NULL);
}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">hostnamelen</span>

<span class="enscript-comment">/*
 * make a mbuf with DNS-encoded string.  no compression support.
 *
 * XXX names with less than 2 dots (like &quot;foo&quot; or &quot;foo.section&quot;) will be
 * treated as truncated name (two \0 at the end).  this is a wild guess.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">ni6_nametodns</span>(name, namelen, old)
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name;
	<span class="enscript-type">int</span> namelen;
	<span class="enscript-type">int</span> old;	<span class="enscript-comment">/* return pascal string if non-zero */</span>
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">char</span> *cp, *ep;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *p, *q;
	<span class="enscript-type">int</span> i, len, nterm;

	<span class="enscript-keyword">if</span> (old)
		len = namelen + 1;
	<span class="enscript-keyword">else</span>
		len = MCLBYTES;

	<span class="enscript-comment">/* because MAXHOSTNAMELEN is usually 256, we use cluster mbuf */</span>
	MGET(m, M_DONTWAIT, MT_DATA);
	<span class="enscript-keyword">if</span> (m &amp;&amp; len &gt; MLEN) {
		MCLGET(m, M_DONTWAIT);
		<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_EXT) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	<span class="enscript-keyword">if</span> (!m)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	m-&gt;m_next = NULL;

	<span class="enscript-keyword">if</span> (old) {
		m-&gt;m_len = len;
		*mtod(m, <span class="enscript-type">char</span> *) = namelen;
		bcopy(name, mtod(m, <span class="enscript-type">char</span> *) + 1, namelen);
		<span class="enscript-keyword">return</span> m;
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_len = 0;
		cp = mtod(m, <span class="enscript-type">char</span> *);
		ep = mtod(m, <span class="enscript-type">char</span> *) + M_TRAILINGSPACE(m);

		<span class="enscript-comment">/* if not certain about my name, return empty buffer */</span>
		<span class="enscript-keyword">if</span> (namelen == 0)
			<span class="enscript-keyword">return</span> m;

		<span class="enscript-comment">/*
		 * guess if it looks like shortened hostname, or FQDN.
		 * shortened hostname needs two trailing &quot;\0&quot;.
		 */</span>
		i = 0;
		<span class="enscript-keyword">for</span> (p = name; p &lt; name + namelen; p++) {
			<span class="enscript-keyword">if</span> (*p &amp;&amp; *p == <span class="enscript-string">'.'</span>)
				i++;
		}
		<span class="enscript-keyword">if</span> (i &lt; 2)
			nterm = 2;
		<span class="enscript-keyword">else</span>
			nterm = 1;

		p = name;
		<span class="enscript-keyword">while</span> (cp &lt; ep &amp;&amp; p &lt; name + namelen) {
			i = 0;
			<span class="enscript-keyword">for</span> (q = p; q &lt; name + namelen &amp;&amp; *q &amp;&amp; *q != <span class="enscript-string">'.'</span>; q++)
				i++;
			<span class="enscript-comment">/* result does not fit into mbuf */</span>
			<span class="enscript-keyword">if</span> (cp + i + 1 &gt;= ep)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			<span class="enscript-comment">/*
			 * DNS label length restriction, RFC1035 page 8.
			 * &quot;i == 0&quot; case is included here to avoid returning
			 * 0-length label on &quot;foo..bar&quot;.
			 */</span>
			<span class="enscript-keyword">if</span> (i &lt;= 0 || i &gt;= 64)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
			*cp++ = i;
			bcopy(p, cp, i);
			cp += i;
			p = q;
			<span class="enscript-keyword">if</span> (p &lt; name + namelen &amp;&amp; *p == <span class="enscript-string">'.'</span>)
				p++;
		}
		<span class="enscript-comment">/* termination */</span>
		<span class="enscript-keyword">if</span> (cp + nterm &gt;= ep)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		<span class="enscript-keyword">while</span> (nterm-- &gt; 0)
			*cp++ = <span class="enscript-string">'\0'</span>;
		m-&gt;m_len = cp - mtod(m, <span class="enscript-type">char</span> *);
		<span class="enscript-keyword">return</span> m;
	}

	panic(<span class="enscript-string">&quot;should not reach here&quot;</span>);
	<span class="enscript-comment">/* NOTREACHED */</span>

 <span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">if</span> (m)
		m_freem(m);
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/*
 * check if two DNS-encoded string matches.  takes care of truncated
 * form (with \0\0 at the end).  no compression support.
 * XXX upper/lowercase match (see RFC2065)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ni6_dnsmatch</span>(a, alen, b, blen)
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *a;
	<span class="enscript-type">int</span> alen;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *b;
	<span class="enscript-type">int</span> blen;
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *a0, *b0;
	<span class="enscript-type">int</span> l;

	<span class="enscript-comment">/* simplest case - need validation? */</span>
	<span class="enscript-keyword">if</span> (alen == blen &amp;&amp; bcmp(a, b, alen) == 0)
		<span class="enscript-keyword">return</span> 1;

	a0 = a;
	b0 = b;

	<span class="enscript-comment">/* termination is mandatory */</span>
	<span class="enscript-keyword">if</span> (alen &lt; 2 || blen &lt; 2)
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">if</span> (a0[alen - 1] != <span class="enscript-string">'\0'</span> || b0[blen - 1] != <span class="enscript-string">'\0'</span>)
		<span class="enscript-keyword">return</span> 0;
	alen--;
	blen--;

	<span class="enscript-keyword">while</span> (a - a0 &lt; alen &amp;&amp; b - b0 &lt; blen) {
		<span class="enscript-keyword">if</span> (a - a0 + 1 &gt; alen || b - b0 + 1 &gt; blen)
			<span class="enscript-keyword">return</span> 0;

		<span class="enscript-keyword">if</span> ((<span class="enscript-type">signed</span> <span class="enscript-type">char</span>)a[0] &lt; 0 || (<span class="enscript-type">signed</span> <span class="enscript-type">char</span>)b[0] &lt; 0)
			<span class="enscript-keyword">return</span> 0;
		<span class="enscript-comment">/* we don't support compression yet */</span>
		<span class="enscript-keyword">if</span> (a[0] &gt;= 64 || b[0] &gt;= 64)
			<span class="enscript-keyword">return</span> 0;

		<span class="enscript-comment">/* truncated case */</span>
		<span class="enscript-keyword">if</span> (a[0] == 0 &amp;&amp; a - a0 == alen - 1)
			<span class="enscript-keyword">return</span> 1;
		<span class="enscript-keyword">if</span> (b[0] == 0 &amp;&amp; b - b0 == blen - 1)
			<span class="enscript-keyword">return</span> 1;
		<span class="enscript-keyword">if</span> (a[0] == 0 || b[0] == 0)
			<span class="enscript-keyword">return</span> 0;

		<span class="enscript-keyword">if</span> (a[0] != b[0])
			<span class="enscript-keyword">return</span> 0;
		l = a[0];
		<span class="enscript-keyword">if</span> (a - a0 + 1 + l &gt; alen || b - b0 + 1 + l &gt; blen)
			<span class="enscript-keyword">return</span> 0;
		<span class="enscript-keyword">if</span> (bcmp(a + 1, b + 1, l) != 0)
			<span class="enscript-keyword">return</span> 0;

		a += 1 + l;
		b += 1 + l;
	}

	<span class="enscript-keyword">if</span> (a - a0 == alen &amp;&amp; b - b0 == blen)
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * calculate the number of addresses to be returned in the node info reply.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ni6_addrs</span>(ni6, ifpp, subj)
	<span class="enscript-type">struct</span> icmp6_nodeinfo *ni6;
	<span class="enscript-type">struct</span> ifnet **ifpp;
	<span class="enscript-type">char</span> *subj;
{
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> in6_ifaddr *ifa6;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span> sockaddr_in6 *subj_ip6 = NULL; <span class="enscript-comment">/* XXX pedant */</span>
	<span class="enscript-type">int</span> addrs = 0, addrsofif, iffound = 0;
	<span class="enscript-type">int</span> niflags = ni6-&gt;ni_flags;

	<span class="enscript-keyword">if</span> (ifpp != NULL)
		*ifpp = NULL;

	<span class="enscript-keyword">if</span> ((niflags &amp; NI_NODEADDR_FLAG_ALL) == 0) {
		<span class="enscript-keyword">switch</span> (ni6-&gt;ni_code) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_NI_SUBJ_IPV6</span>:
			<span class="enscript-keyword">if</span> (subj == NULL) <span class="enscript-comment">/* must be impossible... */</span>
				<span class="enscript-keyword">return</span>(0);
			subj_ip6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)subj;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/*
			 * XXX: we only support IPv6 subject address for
			 * this Qtype.
			 */</span>
			<span class="enscript-keyword">return</span> (0);
		}
	}

	ifnet_head_lock_shared();
	TAILQ_FOREACH(ifp, &amp;ifnet_head, if_list) {
		addrsofif = 0;
		ifnet_lock_shared(ifp);
		TAILQ_FOREACH(ifa, &amp;ifp-&gt;if_addrlist, ifa_list)
		{
			IFA_LOCK(ifa);
			<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}
			ifa6 = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;

			<span class="enscript-keyword">if</span> ((niflags &amp; NI_NODEADDR_FLAG_ALL) == 0 &amp;&amp;
			    IN6_ARE_ADDR_EQUAL(&amp;subj_ip6-&gt;sin6_addr,
					       &amp;ifa6-&gt;ia_addr.sin6_addr))
				iffound = 1;

			<span class="enscript-comment">/*
			 * IPv4-mapped addresses can only be returned by a
			 * Node Information proxy, since they represent
			 * addresses of IPv4-only nodes, which perforce do
			 * not implement this protocol.
			 * [icmp-name-lookups-07, Section 5.4]
			 * So we don't support NI_NODEADDR_FLAG_COMPAT in
			 * this function at this moment.
			 */</span>

			<span class="enscript-comment">/* What do we have to do about ::1? */</span>
			<span class="enscript-keyword">switch</span> (in6_addrscope(&amp;ifa6-&gt;ia_addr.sin6_addr)) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_ADDR_SCOPE_LINKLOCAL</span>:
				<span class="enscript-keyword">if</span> ((niflags &amp; NI_NODEADDR_FLAG_LINKLOCAL) == 0) {
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_ADDR_SCOPE_SITELOCAL</span>:
				<span class="enscript-keyword">if</span> ((niflags &amp; NI_NODEADDR_FLAG_SITELOCAL) == 0) {
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_ADDR_SCOPE_GLOBAL</span>:
				<span class="enscript-keyword">if</span> ((niflags &amp; NI_NODEADDR_FLAG_GLOBAL) == 0) {
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/*
			 * check if anycast is okay.
			 * XXX: just experimental.  not in the spec.
			 */</span>
			<span class="enscript-keyword">if</span> ((ifa6-&gt;ia6_flags &amp; IN6_IFF_ANYCAST) != 0 &amp;&amp;
			    (niflags &amp; NI_NODEADDR_FLAG_ANYCAST) == 0) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* we need only unicast addresses */</span>
			}
			<span class="enscript-keyword">if</span> ((ifa6-&gt;ia6_flags &amp; IN6_IFF_TEMPORARY) != 0 &amp;&amp;
			    (icmp6_nodeinfo &amp; ICMP6_NODEINFO_TMPADDROK) == 0) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}
			addrsofif++; <span class="enscript-comment">/* count the address */</span>
			IFA_UNLOCK(ifa);
		}
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">if</span> (iffound) {
			<span class="enscript-keyword">if</span> (ifpp != NULL) {
				*ifpp = ifp;
				ifnet_reference(ifp);
			}
			ifnet_head_done();
			<span class="enscript-keyword">return</span>(addrsofif);
		}

		addrs += addrsofif;
	}
	ifnet_head_done();

	<span class="enscript-keyword">return</span> (addrs);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ni6_store_addrs</span>(ni6, nni6, ifp0, resid)
	<span class="enscript-type">struct</span> icmp6_nodeinfo *ni6, *nni6;
	<span class="enscript-type">struct</span> ifnet *ifp0;
	<span class="enscript-type">int</span> resid;
{
	<span class="enscript-type">struct</span> ifnet *ifp = ifp0;
	<span class="enscript-type">struct</span> in6_ifaddr *ifa6;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span> ifnet *ifp_dep = NULL;
	<span class="enscript-type">int</span> copied = 0, allow_deprecated = 0;
	u_char *cp = (u_char *)(nni6 + 1);
	<span class="enscript-type">int</span> niflags = ni6-&gt;ni_flags;
	u_int32_t ltime;
	uint64_t now = net_uptime();

	<span class="enscript-keyword">if</span> (ifp0 == NULL &amp;&amp; !(niflags &amp; NI_NODEADDR_FLAG_ALL))
		<span class="enscript-keyword">return</span> (0);	<span class="enscript-comment">/* needless to copy */</span>

  <span class="enscript-reference">again</span>:

	ifnet_head_lock_shared();
	<span class="enscript-keyword">if</span> (ifp == NULL)
		ifp = TAILQ_FIRST(&amp;ifnet_head);

	<span class="enscript-keyword">for</span> (; ifp; ifp = TAILQ_NEXT(ifp, if_list)) {
		ifnet_lock_shared(ifp);
		<span class="enscript-keyword">for</span> (ifa = ifp-&gt;if_addrlist.tqh_first; ifa;
		     ifa = ifa-&gt;ifa_list.tqe_next) {
			<span class="enscript-type">struct</span> in6_addrlifetime_i *lt;

			IFA_LOCK(ifa);
			<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}
			ifa6 = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;

			<span class="enscript-keyword">if</span> ((ifa6-&gt;ia6_flags &amp; IN6_IFF_DEPRECATED) != 0 &amp;&amp;
			    allow_deprecated == 0) {
				<span class="enscript-comment">/*
				 * prefererred address should be put before
				 * deprecated addresses.
				 */</span>

				<span class="enscript-comment">/* record the interface for later search */</span>
				<span class="enscript-keyword">if</span> (ifp_dep == NULL)
					ifp_dep = ifp;

				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ifa6-&gt;ia6_flags &amp; IN6_IFF_DEPRECATED) == 0 &amp;&amp;
			    allow_deprecated != 0) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* we now collect deprecated addrs */</span>
			}
			<span class="enscript-comment">/* What do we have to do about ::1? */</span>
			<span class="enscript-keyword">switch</span> (in6_addrscope(&amp;ifa6-&gt;ia_addr.sin6_addr)) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_ADDR_SCOPE_LINKLOCAL</span>:
				<span class="enscript-keyword">if</span> ((niflags &amp; NI_NODEADDR_FLAG_LINKLOCAL) == 0) {
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_ADDR_SCOPE_SITELOCAL</span>:
				<span class="enscript-keyword">if</span> ((niflags &amp; NI_NODEADDR_FLAG_SITELOCAL) == 0) {
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_ADDR_SCOPE_GLOBAL</span>:
				<span class="enscript-keyword">if</span> ((niflags &amp; NI_NODEADDR_FLAG_GLOBAL) == 0) {
					IFA_UNLOCK(ifa);
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/*
			 * check if anycast is okay.
			 * XXX: just experimental.  not in the spec.
			 */</span>
			<span class="enscript-keyword">if</span> ((ifa6-&gt;ia6_flags &amp; IN6_IFF_ANYCAST) != 0 &amp;&amp;
			    (niflags &amp; NI_NODEADDR_FLAG_ANYCAST) == 0) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> ((ifa6-&gt;ia6_flags &amp; IN6_IFF_TEMPORARY) != 0 &amp;&amp;
			    (icmp6_nodeinfo &amp; ICMP6_NODEINFO_TMPADDROK) == 0) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/* now we can copy the address */</span>
			<span class="enscript-keyword">if</span> (resid &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr) +
			    <span class="enscript-keyword">sizeof</span>(u_int32_t)) {
				IFA_UNLOCK(ifa);
				<span class="enscript-comment">/*
				 * We give up much more copy.
				 * Set the truncate flag and return.
				 */</span>
				nni6-&gt;ni_flags |=
					NI_NODEADDR_FLAG_TRUNCATE;
				ifnet_lock_done(ifp);
				ifnet_head_done();
				<span class="enscript-keyword">return</span>(copied);
			}

			<span class="enscript-comment">/*
			 * Set the TTL of the address.
			 * The TTL value should be one of the following
			 * according to the specification:
			 *
			 * 1. The remaining lifetime of a DHCP lease on the
			 *    address, or
			 * 2. The remaining Valid Lifetime of a prefix from
			 *    which the address was derived through Stateless
			 *    Autoconfiguration.
			 *
			 * Note that we currently do not support stateful
			 * address configuration by DHCPv6, so the former
			 * case can't happen.
			 */</span>
			lt = &amp;ifa6-&gt;ia6_lifetime;
			<span class="enscript-keyword">if</span> (lt-&gt;ia6ti_expire == 0) {
				ltime = ND6_INFINITE_LIFETIME;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (lt-&gt;ia6ti_expire &gt; now)
					ltime = htonl(lt-&gt;ia6ti_expire - now);
				<span class="enscript-keyword">else</span>
					ltime = 0;
			}

			bcopy(&amp;ltime, cp, <span class="enscript-keyword">sizeof</span>(u_int32_t));
			cp += <span class="enscript-keyword">sizeof</span>(u_int32_t);

			<span class="enscript-comment">/* copy the address itself */</span>
			bcopy(&amp;ifa6-&gt;ia_addr.sin6_addr, cp,
			      <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
			<span class="enscript-comment">/* XXX: KAME link-local hack; remove ifindex */</span>
			<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;ifa6-&gt;ia_addr.sin6_addr))
				((<span class="enscript-type">struct</span> in6_addr *)(<span class="enscript-type">void</span> *)cp)-&gt;s6_addr16[1] = 0;
			cp += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr);

			resid -= (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr) + <span class="enscript-keyword">sizeof</span>(u_int32_t));
			copied += (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr) +
				   <span class="enscript-keyword">sizeof</span>(u_int32_t));
			IFA_UNLOCK(ifa);
		}
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">if</span> (ifp0)	<span class="enscript-comment">/* we need search only on the specified IF */</span>
			<span class="enscript-keyword">break</span>;
	}
	ifnet_head_done();

	<span class="enscript-keyword">if</span> (allow_deprecated == 0 &amp;&amp; ifp_dep != NULL) {
		ifp = ifp_dep;
		allow_deprecated = 1;

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}

	<span class="enscript-keyword">return</span>(copied);
}

<span class="enscript-comment">/*
 * XXX almost dup'ed code with rip6_input.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">icmp6_rip6_input</span>(mp, off)
	<span class="enscript-type">struct</span>	mbuf **mp;
	<span class="enscript-type">int</span>	off;
{
	<span class="enscript-type">struct</span> mbuf *m = *mp;
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	<span class="enscript-type">struct</span> in6pcb *in6p;
	<span class="enscript-type">struct</span> in6pcb *last = NULL;
	<span class="enscript-type">struct</span> sockaddr_in6 rip6src;
	<span class="enscript-type">struct</span> icmp6_hdr *icmp6;
	<span class="enscript-type">struct</span> mbuf *opts = NULL;
	<span class="enscript-type">int</span> ret = 0;
	<span class="enscript-type">struct</span> ifnet *ifp = m-&gt;m_pkthdr.rcvif;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PULLDOWN_TEST</span>
	<span class="enscript-comment">/* this is assumed to be safe. */</span>
	icmp6 = (<span class="enscript-type">struct</span> icmp6_hdr *)((caddr_t)ip6 + off);
#<span class="enscript-reference">else</span>
	IP6_EXTHDR_GET(icmp6, <span class="enscript-type">struct</span> icmp6_hdr *, m, off, <span class="enscript-keyword">sizeof</span>(*icmp6));
	<span class="enscript-keyword">if</span> (icmp6 == NULL) {
		<span class="enscript-comment">/* m is already reclaimed */</span>
		<span class="enscript-keyword">return</span> IPPROTO_DONE;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * XXX: the address may have embedded scope zone ID, which should be
	 * hidden from applications.
	 */</span>
	bzero(&amp;rip6src, <span class="enscript-keyword">sizeof</span>(rip6src));
	rip6src.sin6_family = AF_INET6;
	rip6src.sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
	rip6src.sin6_addr = ip6-&gt;ip6_src;
	<span class="enscript-keyword">if</span> (sa6_recoverscope(&amp;rip6src, TRUE)) 
		<span class="enscript-keyword">return</span> (IPPROTO_DONE);

	lck_rw_lock_shared(ripcbinfo.ipi_lock);
	LIST_FOREACH(in6p, &amp;ripcb, inp_list)
	{
		<span class="enscript-keyword">if</span> ((in6p-&gt;inp_vflag &amp; INP_IPV6) == 0)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (in6p-&gt;in6p_ip6_nxt != IPPROTO_ICMPV6)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_UNSPECIFIED(&amp;in6p-&gt;in6p_laddr) &amp;&amp;
		   !IN6_ARE_ADDR_EQUAL(&amp;in6p-&gt;in6p_laddr, &amp;ip6-&gt;ip6_dst))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_UNSPECIFIED(&amp;in6p-&gt;in6p_faddr) &amp;&amp;
		   !IN6_ARE_ADDR_EQUAL(&amp;in6p-&gt;in6p_faddr, &amp;ip6-&gt;ip6_src))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (in6p-&gt;in6p_icmp6filt
		    &amp;&amp; ICMP6_FILTER_WILLBLOCK(icmp6-&gt;icmp6_type,
				 in6p-&gt;in6p_icmp6filt))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (inp_restricted_recv(in6p, ifp))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (last) {
			<span class="enscript-type">struct</span>	mbuf *n;
			<span class="enscript-keyword">if</span> ((n = m_copy(m, 0, (<span class="enscript-type">int</span>)M_COPYALL)) != NULL) {
				<span class="enscript-keyword">if</span> ((last-&gt;in6p_flags &amp; INP_CONTROLOPTS) != 0 ||
				    (last-&gt;in6p_socket-&gt;so_options &amp; SO_TIMESTAMP) != 0 ||
				    (last-&gt;in6p_socket-&gt;so_options &amp; SO_TIMESTAMP_MONOTONIC) != 0) {
					ret = ip6_savecontrol(last, n, &amp;opts);
					<span class="enscript-keyword">if</span> (ret != 0) {
						m_freem(n);
						m_freem(opts);
						last = in6p;
						<span class="enscript-keyword">continue</span>;
					}
				}
				<span class="enscript-comment">/* strip intermediate headers */</span>
				m_adj(n, off);
				so_recv_data_stat(last-&gt;in6p_socket, m, 0);
				<span class="enscript-keyword">if</span> (sbappendaddr(&amp;last-&gt;in6p_socket-&gt;so_rcv,
						 (<span class="enscript-type">struct</span> sockaddr *)&amp;rip6src,
						 n, opts, NULL) != 0) {
					sorwakeup(last-&gt;in6p_socket);
				}
				opts = NULL;
			}
		}
		last = in6p;
	}
	<span class="enscript-keyword">if</span> (last) {
		<span class="enscript-keyword">if</span> ((last-&gt;in6p_flags &amp; INP_CONTROLOPTS) != 0 ||
		    (last-&gt;in6p_socket-&gt;so_options &amp; SO_TIMESTAMP) != 0 ||
		    (last-&gt;in6p_socket-&gt;so_options &amp; SO_TIMESTAMP_MONOTONIC) != 0) {
			ret = ip6_savecontrol(last, m, &amp;opts);
			<span class="enscript-keyword">if</span> (ret != 0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
			}
		}
		<span class="enscript-comment">/* strip intermediate headers */</span>
		m_adj(m, off);
		so_recv_data_stat(last-&gt;in6p_socket, m, 0);
		<span class="enscript-keyword">if</span> (sbappendaddr(&amp;last-&gt;in6p_socket-&gt;so_rcv,
				 (<span class="enscript-type">struct</span> sockaddr *)&amp;rip6src, m, opts, NULL) != 0) {
			sorwakeup(last-&gt;in6p_socket);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error</span>;
	}
	lck_rw_done(ripcbinfo.ipi_lock);
	<span class="enscript-keyword">return</span> IPPROTO_DONE;

<span class="enscript-reference">error</span>:
	lck_rw_done(ripcbinfo.ipi_lock);
	m_freem(m);
	m_freem(opts);
	ip6stat.ip6s_delivered--;
	<span class="enscript-keyword">return</span> IPPROTO_DONE;
}

<span class="enscript-comment">/*
 * Reflect the ip6 packet back to the source.
 * OFF points to the icmp6 header, counted from the top of the mbuf.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">icmp6_reflect</span>(m, off)
	<span class="enscript-type">struct</span>	mbuf *m;
	size_t off;
{
	<span class="enscript-type">struct</span> mbuf *m_ip6hdr = m;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">struct</span> icmp6_hdr *icmp6;
	<span class="enscript-type">struct</span> in6_ifaddr *ia;
	<span class="enscript-type">struct</span> in6_addr t, src_storage, *src = 0;
	<span class="enscript-type">int</span> plen;
	<span class="enscript-type">int</span> type, code;
	<span class="enscript-type">struct</span> ifnet *outif = NULL;
	<span class="enscript-type">struct</span> sockaddr_in6 sa6_src, sa6_dst;
	<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;
	u_int32_t oflow;
	<span class="enscript-type">struct</span> ip6_out_args ip6oa = { IFSCOPE_NONE, { 0 },
	    IP6OAF_SELECT_SRCIF | IP6OAF_BOUND_SRCADDR, 0 };

	<span class="enscript-keyword">if</span> (!(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP) &amp;&amp; m-&gt;m_pkthdr.rcvif != NULL) {
		ip6oa.ip6oa_boundif = m-&gt;m_pkthdr.rcvif-&gt;if_index;
		ip6oa.ip6oa_flags |= IP6OAF_BOUND_IF;
	}

	<span class="enscript-comment">/* too short to reflect */</span>
	<span class="enscript-keyword">if</span> (off &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr)) {
		nd6log((LOG_DEBUG,
		    <span class="enscript-string">&quot;sanity fail: off=%lx, sizeof(ip6)=%lx in %s:%d\n&quot;</span>,
		    (u_int32_t)off, (u_int32_t)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr),
		    __FILE__, __LINE__));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/*
	 * If there are extra headers between IPv6 and ICMPv6, strip
	 * off that header first.
	 */</span>
	<span class="enscript-keyword">if</span> (off &gt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr)) {
		size_t l;
		<span class="enscript-type">struct</span> ip6_hdr nip6;

		l = off - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
		m_copydata(m, 0, <span class="enscript-keyword">sizeof</span>(nip6), (caddr_t)&amp;nip6);
		m_adj(m, l);
		l = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr);
		<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; l) {
			<span class="enscript-keyword">if</span> ((m_ip6hdr = m_pulldown(m, 0, l, NULL)) == NULL)
				<span class="enscript-keyword">return</span>;
		}
		bcopy((caddr_t)&amp;nip6, mtod(m, caddr_t), <span class="enscript-keyword">sizeof</span>(nip6));
	} <span class="enscript-keyword">else</span> <span class="enscript-comment">/* off == sizeof(struct ip6_hdr) */</span> {
		size_t l;
		l = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr);
		<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; l) {
			<span class="enscript-keyword">if</span> ((m_ip6hdr = m_pulldown(m, 0, l, NULL)) == NULL)
				<span class="enscript-keyword">return</span>;
		}
	}
	plen = m-&gt;m_pkthdr.len - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
	ip6 = mtod(m_ip6hdr, <span class="enscript-type">struct</span> ip6_hdr *);
	ip6-&gt;ip6_nxt = IPPROTO_ICMPV6;
	icmp6 = (<span class="enscript-type">struct</span> icmp6_hdr *)(ip6 + 1);
	type = icmp6-&gt;icmp6_type; <span class="enscript-comment">/* keep type for statistics */</span>
	code = icmp6-&gt;icmp6_code; <span class="enscript-comment">/* ditto. */</span>

	t = ip6-&gt;ip6_dst;
	<span class="enscript-comment">/*
	 * ip6_input() drops a packet if its src is multicast.
	 * So, the src is never multicast.
	 */</span>
	ip6-&gt;ip6_dst = ip6-&gt;ip6_src;

	<span class="enscript-comment">/*
	 * XXX: make sure to embed scope zone information, using
	 * already embedded IDs or the received interface (if any).
	 * Note that rcvif may be NULL.
	 */</span>
	bzero(&amp;sa6_src, <span class="enscript-keyword">sizeof</span>(sa6_src));
	sa6_src.sin6_family = AF_INET6;
	sa6_src.sin6_len = <span class="enscript-keyword">sizeof</span>(sa6_src);
	sa6_src.sin6_addr = ip6-&gt;ip6_dst;
	in6_recoverscope(&amp;sa6_src, &amp;ip6-&gt;ip6_dst, m-&gt;m_pkthdr.rcvif);
	in6_embedscope(&amp;ip6-&gt;ip6_dst, &amp;sa6_src, NULL, NULL, NULL);
	bzero(&amp;sa6_dst, <span class="enscript-keyword">sizeof</span>(sa6_dst));
	sa6_dst.sin6_family = AF_INET6;
	sa6_dst.sin6_len = <span class="enscript-keyword">sizeof</span>(sa6_dst);
	sa6_dst.sin6_addr = t;
	in6_recoverscope(&amp;sa6_dst, &amp;t, m-&gt;m_pkthdr.rcvif);
	in6_embedscope(&amp;t, &amp;sa6_dst, NULL, NULL, NULL);

	<span class="enscript-comment">/*
	 * If the incoming packet was addressed directly to us(i.e. unicast),
	 * use dst as the src for the reply.
	 * The IN6_IFF_NOTREADY case should be VERY rare, but is possible
	 * (for example) when we encounter an error while forwarding procedure
	 * destined to a duplicated address of ours.
	 * Note that ip6_getdstifaddr() may fail if we are in an error handling
	 * procedure of an outgoing packet of our own, in which case we need
	 * to search in the ifaddr list.
	 */</span>
	lck_rw_lock_shared(&amp;in6_ifaddr_rwlock);
	<span class="enscript-keyword">for</span> (ia = in6_ifaddrs; ia; ia = ia-&gt;ia_next) {
		IFA_LOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(&amp;t, &amp;ia-&gt;ia_addr.sin6_addr) &amp;&amp;
		    (ia-&gt;ia6_flags &amp; (IN6_IFF_ANYCAST|IN6_IFF_NOTREADY)) == 0) {
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
			src = &amp;t;
			<span class="enscript-keyword">break</span>;
		}
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
	}
	lck_rw_done(&amp;in6_ifaddr_rwlock);
	<span class="enscript-keyword">if</span> (ia == NULL &amp;&amp; IN6_IS_ADDR_LINKLOCAL(&amp;t) &amp;&amp;
	    ((m-&gt;m_flags &amp; M_LOOP) || (m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP))) {
		<span class="enscript-comment">/*
		 * This is the case if the dst is our link-local address
		 * and the sender is also ourselves.  Here we test for both
		 * M_LOOP and PKTF_LOOP, since the former may have been set
		 * in ip6_output() and that we get here as part of callling
		 * ip6_process_hopopts().  See comments in &lt;sys/mbuf.h&gt;
		 */</span>
		src = &amp;t;
	}

	<span class="enscript-keyword">if</span> (src == NULL) {
		<span class="enscript-type">int</span> e;
		<span class="enscript-type">struct</span> sockaddr_in6 sin6;
		<span class="enscript-type">struct</span> route_in6 ro;

		<span class="enscript-comment">/*
		 * This case matches to multicasts, our anycast, or unicasts
		 * that we do not own.  Select a source address based on the
		 * source address of the erroneous packet.
		 */</span>
		bzero(&amp;sin6, <span class="enscript-keyword">sizeof</span>(sin6));
		sin6.sin6_family = AF_INET6;
		sin6.sin6_len = <span class="enscript-keyword">sizeof</span>(sin6);
		sin6.sin6_addr = ip6-&gt;ip6_dst; <span class="enscript-comment">/* zone ID should be embedded */</span>

		bzero(&amp;ro, <span class="enscript-keyword">sizeof</span>(ro));
		<span class="enscript-comment">/*
		 * in6_selectsrc() might return outif with its reference held
		 * even in the error case, so we always need to release it
		 * if non-NULL.
		 */</span>
		src = in6_selectsrc(&amp;sin6, NULL, NULL, &amp;ro, &amp;outif,
		    &amp;src_storage, ip6oa.ip6oa_boundif, &amp;e);
		ROUTE_RELEASE(&amp;ro);
		<span class="enscript-keyword">if</span> (src == NULL) {
			nd6log((LOG_DEBUG,
			    <span class="enscript-string">&quot;icmp6_reflect: source can't be determined: &quot;</span>
			    <span class="enscript-string">&quot;dst=%s, error=%d\n&quot;</span>,
			    ip6_sprintf(&amp;sa6_src.sin6_addr), e));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}
	oflow = ip6-&gt;ip6_flow; <span class="enscript-comment">/* Save for later */</span>
	ip6-&gt;ip6_src = *src;
	ip6-&gt;ip6_flow = 0;
	ip6-&gt;ip6_vfc &amp;= ~IPV6_VERSION_MASK;
	ip6-&gt;ip6_vfc |= IPV6_VERSION;
	<span class="enscript-keyword">if</span> (icmp6-&gt;icmp6_type == ICMP6_ECHO_REPLY &amp;&amp; icmp6-&gt;icmp6_code == 0) {
		ip6-&gt;ip6_flow |= (oflow &amp; htonl(0x0ff00000));
	}
	ip6-&gt;ip6_nxt = IPPROTO_ICMPV6;
	<span class="enscript-keyword">if</span> (outif != NULL &amp;&amp; (ndi = ND_IFINFO(outif)) != NULL &amp;&amp;
	    ndi-&gt;initialized) {
		lck_mtx_lock(&amp;ndi-&gt;lock);
		ip6-&gt;ip6_hlim = ndi-&gt;chlim;
		lck_mtx_unlock(&amp;ndi-&gt;lock);
	}
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.rcvif != NULL &amp;&amp;
	    (ndi = ND_IFINFO(m-&gt;m_pkthdr.rcvif)) != NULL &amp;&amp;
	    ndi-&gt;initialized) {
		<span class="enscript-comment">/* XXX: This may not be the outgoing interface */</span>
		lck_mtx_lock(&amp;ndi-&gt;lock);
		ip6-&gt;ip6_hlim = ndi-&gt;chlim;
		lck_mtx_unlock(&amp;ndi-&gt;lock);
	} <span class="enscript-keyword">else</span> {
		ip6-&gt;ip6_hlim = ip6_defhlim;
	}
	<span class="enscript-comment">/* Use the same traffic class as in the request to match IPv4 */</span>
	icmp6-&gt;icmp6_cksum = 0;
	icmp6-&gt;icmp6_cksum = in6_cksum(m, IPPROTO_ICMPV6,
	    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr), plen);

	<span class="enscript-comment">/*
	 * XXX option handling
	 */</span>
	m-&gt;m_flags &amp;= ~(M_BCAST|M_MCAST);

	<span class="enscript-keyword">if</span> (outif != NULL) {
		ifnet_release(outif);
		outif = NULL;
	}

	m-&gt;m_pkthdr.csum_data = 0;
	m-&gt;m_pkthdr.csum_flags = 0;
	ip6_output(m, NULL, NULL, IPV6_OUTARGS, NULL, &amp;outif, &amp;ip6oa);
	<span class="enscript-keyword">if</span> (outif != NULL) {
		icmp6_ifoutstat_inc(outif, type, code);
		ifnet_release(outif);
	}
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">bad</span>:
	m_freem(m);
	<span class="enscript-keyword">if</span> (outif != NULL)
		ifnet_release(outif);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">icmp6_redirect_diag</span>(src6, dst6, tgt6)
	<span class="enscript-type">struct</span> in6_addr *src6;
	<span class="enscript-type">struct</span> in6_addr *dst6;
	<span class="enscript-type">struct</span> in6_addr *tgt6;
{
	<span class="enscript-type">static</span> <span class="enscript-type">char</span> buf[1024];
	snprintf(buf, <span class="enscript-keyword">sizeof</span>(buf), <span class="enscript-string">&quot;(src=%s dst=%s tgt=%s)&quot;</span>,
		ip6_sprintf(src6), ip6_sprintf(dst6), ip6_sprintf(tgt6));
	<span class="enscript-keyword">return</span> buf;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">icmp6_redirect_input</span>(m, off)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> off;
{
	<span class="enscript-type">struct</span> ifnet *ifp = m-&gt;m_pkthdr.rcvif;
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	<span class="enscript-type">struct</span> nd_redirect *nd_rd;
	<span class="enscript-type">int</span> icmp6len = ntohs(ip6-&gt;ip6_plen);
	<span class="enscript-type">char</span> *lladdr = NULL;
	<span class="enscript-type">int</span> lladdrlen = 0;
	u_char *redirhdr = NULL;
	<span class="enscript-type">int</span> redirhdrlen = 0;
	<span class="enscript-type">struct</span> rtentry *rt = NULL;
	<span class="enscript-type">int</span> is_router;
	<span class="enscript-type">int</span> is_onlink;
	<span class="enscript-type">struct</span> in6_addr src6 = ip6-&gt;ip6_src;
	<span class="enscript-type">struct</span> in6_addr redtgt6;
	<span class="enscript-type">struct</span> in6_addr reddst6;
	<span class="enscript-type">union</span> nd_opts ndopts;

	<span class="enscript-keyword">if</span> (!m || !ifp)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * If we are an advertising router on this interface,
	 * don't update route by icmp6 redirect.
	 */</span>
	<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_IPV6_ROUTER)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	<span class="enscript-keyword">if</span> (!icmp6_rediraccept)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">PULLDOWN_TEST</span>
	IP6_EXTHDR_CHECK(m, off, icmp6len, <span class="enscript-keyword">return</span>);
	nd_rd = (<span class="enscript-type">struct</span> nd_redirect *)((caddr_t)ip6 + off);
#<span class="enscript-reference">else</span>
	IP6_EXTHDR_GET(nd_rd, <span class="enscript-type">struct</span> nd_redirect *, m, off, icmp6len);
	<span class="enscript-keyword">if</span> (nd_rd == NULL) {
		icmp6stat.icp6s_tooshort++;
		<span class="enscript-keyword">return</span>;
	}
#<span class="enscript-reference">endif</span>
	redtgt6 = nd_rd-&gt;nd_rd_target;
	reddst6 = nd_rd-&gt;nd_rd_dst;

	<span class="enscript-keyword">if</span> (in6_setscope(&amp;redtgt6, m-&gt;m_pkthdr.rcvif, NULL) ||
	    in6_setscope(&amp;reddst6, m-&gt;m_pkthdr.rcvif, NULL)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}

	<span class="enscript-comment">/* validation */</span>
	<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_LINKLOCAL(&amp;src6)) {
		nd6log((LOG_ERR,
			<span class="enscript-string">&quot;ICMP6 redirect sent from %s rejected; &quot;</span>
			<span class="enscript-string">&quot;must be from linklocal\n&quot;</span>, ip6_sprintf(&amp;src6)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	<span class="enscript-keyword">if</span> (ip6-&gt;ip6_hlim != 255) {
		nd6log((LOG_ERR,
			<span class="enscript-string">&quot;ICMP6 redirect sent from %s rejected; &quot;</span>
			<span class="enscript-string">&quot;hlim=%d (must be 255)\n&quot;</span>,
			ip6_sprintf(&amp;src6), ip6-&gt;ip6_hlim));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
    {
	<span class="enscript-comment">/* ip6-&gt;ip6_src must be equal to gw for icmp6-&gt;icmp6_reddst */</span>
	<span class="enscript-type">struct</span> sockaddr_in6 sin6;
	<span class="enscript-type">struct</span> in6_addr *gw6;

	bzero(&amp;sin6, <span class="enscript-keyword">sizeof</span>(sin6));
	sin6.sin6_family = AF_INET6;
	sin6.sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
	bcopy(&amp;reddst6, &amp;sin6.sin6_addr, <span class="enscript-keyword">sizeof</span>(reddst6));
	rt = rtalloc1_scoped((<span class="enscript-type">struct</span> sockaddr *)&amp;sin6, 0, 0, ifp-&gt;if_index);
	<span class="enscript-keyword">if</span> (rt) {
		RT_LOCK(rt);
		<span class="enscript-keyword">if</span> (rt-&gt;rt_gateway == NULL ||
		    rt-&gt;rt_gateway-&gt;sa_family != AF_INET6) {
			nd6log((LOG_ERR,
			    <span class="enscript-string">&quot;ICMP6 redirect rejected; no route &quot;</span>
			    <span class="enscript-string">&quot;with inet6 gateway found for redirect dst: %s\n&quot;</span>,
			    icmp6_redirect_diag(&amp;src6, &amp;reddst6, &amp;redtgt6)));
			RT_UNLOCK(rt);
			rtfree(rt);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

		gw6 = &amp;(((<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)
		    rt-&gt;rt_gateway)-&gt;sin6_addr);
		<span class="enscript-keyword">if</span> (bcmp(&amp;src6, gw6, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr)) != 0) {
			nd6log((LOG_ERR,
				<span class="enscript-string">&quot;ICMP6 redirect rejected; &quot;</span>
				<span class="enscript-string">&quot;not equal to gw-for-src=%s (must be same): &quot;</span>
				<span class="enscript-string">&quot;%s\n&quot;</span>,
				ip6_sprintf(gw6),
				icmp6_redirect_diag(&amp;src6, &amp;reddst6, &amp;redtgt6)));
			RT_UNLOCK(rt);
			rtfree(rt);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	} <span class="enscript-keyword">else</span> {
		nd6log((LOG_ERR,
			<span class="enscript-string">&quot;ICMP6 redirect rejected; &quot;</span>
			<span class="enscript-string">&quot;no route found for redirect dst: %s\n&quot;</span>,
			icmp6_redirect_diag(&amp;src6, &amp;reddst6, &amp;redtgt6)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	RT_UNLOCK(rt);
	rtfree(rt);
	rt = NULL;
    }
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;reddst6)) {
		nd6log((LOG_ERR,
			<span class="enscript-string">&quot;ICMP6 redirect rejected; &quot;</span>
			<span class="enscript-string">&quot;redirect dst must be unicast: %s\n&quot;</span>,
			icmp6_redirect_diag(&amp;src6, &amp;reddst6, &amp;redtgt6)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	is_router = is_onlink = 0;
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;redtgt6))
		is_router = 1;	<span class="enscript-comment">/* router case */</span>
	<span class="enscript-keyword">if</span> (bcmp(&amp;redtgt6, &amp;reddst6, <span class="enscript-keyword">sizeof</span>(redtgt6)) == 0)
		is_onlink = 1;	<span class="enscript-comment">/* on-link destination case */</span>
	<span class="enscript-keyword">if</span> (!is_router &amp;&amp; !is_onlink) {
		nd6log((LOG_ERR,
			<span class="enscript-string">&quot;ICMP6 redirect rejected; &quot;</span>
			<span class="enscript-string">&quot;neither router case nor onlink case: %s\n&quot;</span>,
			icmp6_redirect_diag(&amp;src6, &amp;reddst6, &amp;redtgt6)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	<span class="enscript-comment">/* validation passed */</span>

	icmp6len -= <span class="enscript-keyword">sizeof</span>(*nd_rd);
	nd6_option_init(nd_rd + 1, icmp6len, &amp;ndopts);
	<span class="enscript-keyword">if</span> (nd6_options(&amp;ndopts) &lt; 0) {
		nd6log((LOG_INFO, <span class="enscript-string">&quot;icmp6_redirect_input: &quot;</span>
			<span class="enscript-string">&quot;invalid ND option, rejected: %s\n&quot;</span>,
			icmp6_redirect_diag(&amp;src6, &amp;reddst6, &amp;redtgt6)));
		<span class="enscript-comment">/* nd6_options have incremented stats */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}

	<span class="enscript-keyword">if</span> (ndopts.nd_opts_tgt_lladdr) {
		lladdr = (<span class="enscript-type">char</span> *)(ndopts.nd_opts_tgt_lladdr + 1);
		lladdrlen = ndopts.nd_opts_tgt_lladdr-&gt;nd_opt_len &lt;&lt; 3;
	}

	<span class="enscript-keyword">if</span> (ndopts.nd_opts_rh) {
		redirhdrlen = ndopts.nd_opts_rh-&gt;nd_opt_rh_len;
		redirhdr = (u_char *)(ndopts.nd_opts_rh + 1); <span class="enscript-comment">/* xxx */</span>
	}

	<span class="enscript-keyword">if</span> (lladdr &amp;&amp; ((ifp-&gt;if_addrlen + 2 + 7) &amp; ~7) != lladdrlen) {
		nd6log((LOG_INFO,
			<span class="enscript-string">&quot;icmp6_redirect_input: lladdrlen mismatch for %s &quot;</span>
			<span class="enscript-string">&quot;(if %d, icmp6 packet %d): %s\n&quot;</span>,
			ip6_sprintf(&amp;redtgt6), ifp-&gt;if_addrlen, lladdrlen - 2,
			icmp6_redirect_diag(&amp;src6, &amp;reddst6, &amp;redtgt6)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* RFC 2461 8.3 */</span>
	nd6_cache_lladdr(ifp, &amp;redtgt6, lladdr, lladdrlen, ND_REDIRECT,
			 is_onlink ? ND_REDIRECT_ONLINK : ND_REDIRECT_ROUTER);

	<span class="enscript-keyword">if</span> (!is_onlink) {	<span class="enscript-comment">/* better router case.  perform rtredirect. */</span>
		<span class="enscript-comment">/* perform rtredirect */</span>
		<span class="enscript-type">struct</span> sockaddr_in6 sdst;
		<span class="enscript-type">struct</span> sockaddr_in6 sgw;
		<span class="enscript-type">struct</span> sockaddr_in6 ssrc;

		bzero(&amp;sdst, <span class="enscript-keyword">sizeof</span>(sdst));
		bzero(&amp;sgw, <span class="enscript-keyword">sizeof</span>(sgw));
		bzero(&amp;ssrc, <span class="enscript-keyword">sizeof</span>(ssrc));
		sdst.sin6_family = sgw.sin6_family = ssrc.sin6_family = AF_INET6;
		sdst.sin6_len = sgw.sin6_len = ssrc.sin6_len =
			<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
		bcopy(&amp;redtgt6, &amp;sgw.sin6_addr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
		bcopy(&amp;reddst6, &amp;sdst.sin6_addr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
		bcopy(&amp;src6, &amp;ssrc.sin6_addr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
		rtredirect(ifp, (<span class="enscript-type">struct</span> sockaddr *)&amp;sdst,
		    (<span class="enscript-type">struct</span> sockaddr *)&amp;sgw, NULL, RTF_GATEWAY | RTF_HOST,
		    (<span class="enscript-type">struct</span> sockaddr *)&amp;ssrc, NULL);
	}
	<span class="enscript-comment">/* finally update cached route in each socket via pfctlinput */</span>
    {
	<span class="enscript-type">struct</span> sockaddr_in6 sdst;

	bzero(&amp;sdst, <span class="enscript-keyword">sizeof</span>(sdst));
	sdst.sin6_family = AF_INET6;
	sdst.sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
	bcopy(&amp;reddst6, &amp;sdst.sin6_addr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));

	pfctlinput(PRC_REDIRECT_HOST, (<span class="enscript-type">struct</span> sockaddr *)&amp;sdst);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	key_sa_routechange((<span class="enscript-type">struct</span> sockaddr *)&amp;sdst);
#<span class="enscript-reference">endif</span>
    }

 <span class="enscript-reference">freeit</span>:
	m_freem(m);
	<span class="enscript-keyword">return</span>;

 <span class="enscript-reference">bad</span>:
	icmp6stat.icp6s_badredirect++;
	m_freem(m);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">icmp6_redirect_output</span>(m0, rt)
	<span class="enscript-type">struct</span> mbuf *m0;
	<span class="enscript-type">struct</span> rtentry *rt;
{
	<span class="enscript-type">struct</span> ifnet *ifp;	<span class="enscript-comment">/* my outgoing interface */</span>
	<span class="enscript-type">struct</span> in6_addr ifp_ll6;
	<span class="enscript-type">struct</span> in6_addr *router_ll6;
	<span class="enscript-type">struct</span> ip6_hdr *sip6;	<span class="enscript-comment">/* m0 as struct ip6_hdr */</span>
	<span class="enscript-type">struct</span> mbuf *m = NULL;	<span class="enscript-comment">/* newly allocated one */</span>
	<span class="enscript-type">struct</span> ip6_hdr *ip6;	<span class="enscript-comment">/* m as struct ip6_hdr */</span>
	<span class="enscript-type">struct</span> nd_redirect *nd_rd;
	size_t maxlen;
	u_char *p;
	<span class="enscript-type">struct</span> ifnet *outif = NULL;
	<span class="enscript-type">struct</span> sockaddr_in6 src_sa;
	<span class="enscript-type">struct</span> ip6_out_args ip6oa = { IFSCOPE_NONE, { 0 },
	    IP6OAF_SELECT_SRCIF | IP6OAF_BOUND_SRCADDR, 0 };

	icmp6_errcount(&amp;icmp6stat.icp6s_outerrhist, ND_REDIRECT, 0);

	<span class="enscript-keyword">if</span> (rt != NULL)
		RT_LOCK(rt);

	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (!m0 || !rt || !(rt-&gt;rt_flags &amp; RTF_UP) || !(ifp = rt-&gt;rt_ifp))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;

	<span class="enscript-comment">/*
	 * If we are not a router to begin with, or not an advertising
	 * router on this interface, don't send icmp6 redirect.
	 */</span>
	<span class="enscript-keyword">if</span> (!ip6_forwarding || !(ifp-&gt;if_eflags &amp; IFEF_IPV6_ROUTER))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;

	<span class="enscript-comment">/*
	 * Address check:
	 *  the source address must identify a neighbor, and
	 *  the destination address must not be a multicast address
	 *  [RFC 2461, sec 8.2]
	 */</span>
	sip6 = mtod(m0, <span class="enscript-type">struct</span> ip6_hdr *);
	bzero(&amp;src_sa, <span class="enscript-keyword">sizeof</span>(src_sa));
	src_sa.sin6_family = AF_INET6;
	src_sa.sin6_len = <span class="enscript-keyword">sizeof</span>(src_sa);
	src_sa.sin6_addr = sip6-&gt;ip6_src;
	<span class="enscript-comment">/* we don't currently use sin6_scope_id, but eventually use it */</span>
	src_sa.sin6_scope_id = in6_addr2scopeid(ifp, &amp;sip6-&gt;ip6_src);
	RT_UNLOCK(rt);
	<span class="enscript-keyword">if</span> (nd6_is_addr_neighbor(&amp;src_sa, ifp, 0) == 0) {
		<span class="enscript-comment">/* already unlocked */</span>
		rt = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	RT_LOCK(rt);
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;sip6-&gt;ip6_dst))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;	<span class="enscript-comment">/* what should we do here? */</span>

	<span class="enscript-comment">/* rate limit */</span>
	<span class="enscript-keyword">if</span> (icmp6_ratelimit(&amp;sip6-&gt;ip6_src, ND_REDIRECT, 0))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;

	<span class="enscript-comment">/*
	 * Since we are going to append up to 1280 bytes (= IPV6_MMTU),
	 * we almost always ask for an mbuf cluster for simplicity.
	 * (MHLEN &lt; IPV6_MMTU is almost always true)
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPV6_MMTU</span> &gt;= <span class="enscript-variable-name">MCLBYTES</span>
# <span class="enscript-reference">error</span> <span class="enscript-variable-name">assumption</span> <span class="enscript-variable-name">failed</span> <span class="enscript-variable-name">about</span> <span class="enscript-variable-name">IPV6_MMTU</span> <span class="enscript-variable-name">and</span> <span class="enscript-variable-name">MCLBYTES</span>
#<span class="enscript-reference">endif</span>
	MGETHDR(m, M_DONTWAIT, MT_HEADER);	<span class="enscript-comment">/* MAC-OK */</span>
	<span class="enscript-keyword">if</span> (m &amp;&amp; IPV6_MMTU &gt;= MHLEN)
		MCLGET(m, M_DONTWAIT);
	<span class="enscript-keyword">if</span> (!m)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	m-&gt;m_pkthdr.rcvif = NULL;
	m-&gt;m_len = 0;
	maxlen = M_TRAILINGSPACE(m);
	maxlen = min(IPV6_MMTU, maxlen);
	<span class="enscript-comment">/* just for safety */</span>
	<span class="enscript-keyword">if</span> (maxlen &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr) +
	    ((<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nd_opt_hdr) + ifp-&gt;if_addrlen + 7) &amp; ~7)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	{
		<span class="enscript-comment">/* get ip6 linklocal address for ifp(my outgoing interface). */</span>
		<span class="enscript-type">struct</span> in6_ifaddr *ia;
		<span class="enscript-keyword">if</span> ((ia = in6ifa_ifpforlinklocal(ifp,
						 IN6_IFF_NOTREADY|
						 IN6_IFF_ANYCAST)) == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		IFA_LOCK(&amp;ia-&gt;ia_ifa);
		ifp_ll6 = ia-&gt;ia_addr.sin6_addr;
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		IFA_REMREF(&amp;ia-&gt;ia_ifa);
	}

	<span class="enscript-comment">/* get ip6 linklocal address for the router. */</span>
	<span class="enscript-keyword">if</span> (rt-&gt;rt_gateway &amp;&amp; (rt-&gt;rt_flags &amp; RTF_GATEWAY)) {
		<span class="enscript-type">struct</span> sockaddr_in6 *sin6;
		sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)rt-&gt;rt_gateway;
		router_ll6 = &amp;sin6-&gt;sin6_addr;
		<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_LINKLOCAL(router_ll6))
			router_ll6 = (<span class="enscript-type">struct</span> in6_addr *)NULL;
	} <span class="enscript-keyword">else</span>
		router_ll6 = (<span class="enscript-type">struct</span> in6_addr *)NULL;

	<span class="enscript-comment">/* ip6 */</span>
	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	ip6-&gt;ip6_flow = 0;
	ip6-&gt;ip6_vfc &amp;= ~IPV6_VERSION_MASK;
	ip6-&gt;ip6_vfc |= IPV6_VERSION;
	<span class="enscript-comment">/* ip6-&gt;ip6_plen will be set later */</span>
	ip6-&gt;ip6_nxt = IPPROTO_ICMPV6;
	ip6-&gt;ip6_hlim = 255;
	<span class="enscript-comment">/* ip6-&gt;ip6_src must be linklocal addr for my outgoing if. */</span>
	bcopy(&amp;ifp_ll6, &amp;ip6-&gt;ip6_src, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
	bcopy(&amp;sip6-&gt;ip6_src, &amp;ip6-&gt;ip6_dst, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));

	<span class="enscript-comment">/* ND Redirect */</span>
	nd_rd = (<span class="enscript-type">struct</span> nd_redirect *)(ip6 + 1);
	nd_rd-&gt;nd_rd_type = ND_REDIRECT;
	nd_rd-&gt;nd_rd_code = 0;
	nd_rd-&gt;nd_rd_reserved = 0;
	<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_GATEWAY) {
		<span class="enscript-comment">/*
		 * nd_rd-&gt;nd_rd_target must be a link-local address in
		 * better router cases.
		 */</span>
		<span class="enscript-keyword">if</span> (!router_ll6)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		bcopy(router_ll6, &amp;nd_rd-&gt;nd_rd_target,
		      <span class="enscript-keyword">sizeof</span>(nd_rd-&gt;nd_rd_target));
		bcopy(&amp;sip6-&gt;ip6_dst, &amp;nd_rd-&gt;nd_rd_dst,
		      <span class="enscript-keyword">sizeof</span>(nd_rd-&gt;nd_rd_dst));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* make sure redtgt == reddst */</span>
		bcopy(&amp;sip6-&gt;ip6_dst, &amp;nd_rd-&gt;nd_rd_target,
		      <span class="enscript-keyword">sizeof</span>(nd_rd-&gt;nd_rd_target));
		bcopy(&amp;sip6-&gt;ip6_dst, &amp;nd_rd-&gt;nd_rd_dst,
		      <span class="enscript-keyword">sizeof</span>(nd_rd-&gt;nd_rd_dst));
	}
	RT_UNLOCK(rt);
	rt = NULL;

	p = (u_char *)(nd_rd + 1);

	<span class="enscript-keyword">if</span> (!router_ll6)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nolladdropt</span>;

	{
		<span class="enscript-comment">/* target lladdr option */</span>
		<span class="enscript-type">struct</span> rtentry *rt_router = NULL;
		<span class="enscript-type">int</span> len;
		<span class="enscript-type">struct</span> sockaddr_dl *sdl;
		<span class="enscript-type">struct</span> nd_opt_hdr *nd_opt;
		<span class="enscript-type">char</span> *lladdr;

		<span class="enscript-comment">/* Callee returns a locked route upon success */</span>
		rt_router = nd6_lookup(router_ll6, 0, ifp, 0);
		<span class="enscript-keyword">if</span> (!rt_router)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nolladdropt</span>;
		RT_LOCK_ASSERT_HELD(rt_router);
		len = <span class="enscript-keyword">sizeof</span>(*nd_opt) + ifp-&gt;if_addrlen;
		len = (len + 7) &amp; ~7;	<span class="enscript-comment">/* round by 8 */</span>
		<span class="enscript-comment">/* safety check */</span>
		<span class="enscript-keyword">if</span> (len + (p - (u_char *)ip6) &gt; maxlen) {
			RT_REMREF_LOCKED(rt_router);
			RT_UNLOCK(rt_router);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nolladdropt</span>;
		}

		<span class="enscript-keyword">if</span> (!(rt_router-&gt;rt_flags &amp; RTF_GATEWAY) &amp;&amp;
			(rt_router-&gt;rt_flags &amp; RTF_LLINFO) &amp;&amp;
			(rt_router-&gt;rt_gateway-&gt;sa_family == AF_LINK) &amp;&amp;
			(sdl = (<span class="enscript-type">struct</span> sockaddr_dl *)(<span class="enscript-type">void</span> *)
			rt_router-&gt;rt_gateway) &amp;&amp; sdl-&gt;sdl_alen) {
				nd_opt = (<span class="enscript-type">struct</span> nd_opt_hdr *)p;
				nd_opt-&gt;nd_opt_type = ND_OPT_TARGET_LINKADDR;
				nd_opt-&gt;nd_opt_len = len &gt;&gt; 3;
				lladdr = (<span class="enscript-type">char</span> *)(nd_opt + 1);
				bcopy(LLADDR(sdl), lladdr, ifp-&gt;if_addrlen);
				p += len;
		}
		RT_REMREF_LOCKED(rt_router);
		RT_UNLOCK(rt_router);
	}

<span class="enscript-reference">nolladdropt</span>:;

	m-&gt;m_pkthdr.len = m-&gt;m_len = p - (u_char *)ip6;

	<span class="enscript-comment">/* just to be safe */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">M_DECRYPTED</span>	<span class="enscript-comment">/*not openbsd*/</span>
	<span class="enscript-keyword">if</span> (m0-&gt;m_flags &amp; M_DECRYPTED)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">noredhdropt</span>;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (p - (u_char *)ip6 &gt; maxlen)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">noredhdropt</span>;

    {
	<span class="enscript-comment">/* redirected header option */</span>
	<span class="enscript-type">int</span> len;
	<span class="enscript-type">struct</span> nd_opt_rd_hdr *nd_opt_rh;

	<span class="enscript-comment">/*
	 * compute the maximum size for icmp6 redirect header option.
	 * XXX room for auth header?
	 */</span>
	len = maxlen - (p - (u_char *)ip6);
	len &amp;= ~7;

	<span class="enscript-comment">/* This is just for simplicity. */</span>
	<span class="enscript-keyword">if</span> (m0-&gt;m_pkthdr.len != m0-&gt;m_len) {
		<span class="enscript-keyword">if</span> (m0-&gt;m_next) {
			m_freem(m0-&gt;m_next);
			m0-&gt;m_next = NULL;
		}
		m0-&gt;m_pkthdr.len = m0-&gt;m_len;
	}

	<span class="enscript-comment">/*
	 * Redirected header option spec (RFC2461 4.6.3) talks nothing
	 * about padding/truncate rule for the original IP packet.
	 * From the discussion on IPv6imp in Feb 1999, the consensus was:
	 * - &quot;attach as much as possible&quot; is the goal
	 * - pad if not aligned (original size can be guessed by original
	 *   ip6 header)
	 * Following code adds the padding if it is simple enough,
	 * and truncates if not.
	 */</span>
	<span class="enscript-keyword">if</span> (m0-&gt;m_next || m0-&gt;m_pkthdr.len != m0-&gt;m_len)
		panic(<span class="enscript-string">&quot;assumption failed in %s:%d\n&quot;</span>, __FILE__, __LINE__);

	<span class="enscript-keyword">if</span> (len - <span class="enscript-keyword">sizeof</span>(*nd_opt_rh) &lt; m0-&gt;m_pkthdr.len) {
		<span class="enscript-comment">/* not enough room, truncate */</span>
		m0-&gt;m_pkthdr.len = m0-&gt;m_len = len - <span class="enscript-keyword">sizeof</span>(*nd_opt_rh);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* enough room, pad or truncate */</span>
		size_t extra;

		extra = m0-&gt;m_pkthdr.len % 8;
		<span class="enscript-keyword">if</span> (extra) {
			<span class="enscript-comment">/* pad if easy enough, truncate if not */</span>
			<span class="enscript-keyword">if</span> (8 - extra &lt;= M_TRAILINGSPACE(m0)) {
				<span class="enscript-comment">/* pad */</span>
				m0-&gt;m_len += (8 - extra);
				m0-&gt;m_pkthdr.len += (8 - extra);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* truncate */</span>
				m0-&gt;m_pkthdr.len -= extra;
				m0-&gt;m_len -= extra;
			}
		}
		len = m0-&gt;m_pkthdr.len + <span class="enscript-keyword">sizeof</span>(*nd_opt_rh);
		m0-&gt;m_pkthdr.len = m0-&gt;m_len = len - <span class="enscript-keyword">sizeof</span>(*nd_opt_rh);
	}

	nd_opt_rh = (<span class="enscript-type">struct</span> nd_opt_rd_hdr *)p;
	bzero(nd_opt_rh, <span class="enscript-keyword">sizeof</span>(*nd_opt_rh));
	nd_opt_rh-&gt;nd_opt_rh_type = ND_OPT_REDIRECTED_HEADER;
	nd_opt_rh-&gt;nd_opt_rh_len = len &gt;&gt; 3;
	p += <span class="enscript-keyword">sizeof</span>(*nd_opt_rh);
	m-&gt;m_pkthdr.len = m-&gt;m_len = p - (u_char *)ip6;

	<span class="enscript-comment">/* connect m0 to m */</span>
	m-&gt;m_next = m0;
	m-&gt;m_pkthdr.len = m-&gt;m_len + m0-&gt;m_len;
    }
<span class="enscript-reference">noredhdropt</span>:;

	<span class="enscript-comment">/* XXX: clear embedded link IDs in the inner header */</span>
	in6_clearscope(&amp;sip6-&gt;ip6_src);
	in6_clearscope(&amp;sip6-&gt;ip6_dst);
	in6_clearscope(&amp;nd_rd-&gt;nd_rd_target);
	in6_clearscope(&amp;nd_rd-&gt;nd_rd_dst);

	ip6-&gt;ip6_plen = htons(m-&gt;m_pkthdr.len - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));

	nd_rd-&gt;nd_rd_cksum = 0;
	nd_rd-&gt;nd_rd_cksum
		= in6_cksum(m, IPPROTO_ICMPV6, <span class="enscript-keyword">sizeof</span>(*ip6), ntohs(ip6-&gt;ip6_plen));

	<span class="enscript-comment">/* send the packet to outside... */</span>
	ip6oa.ip6oa_boundif = ifp-&gt;if_index;
	ip6oa.ip6oa_flags |= IP6OAF_BOUND_IF;

	ip6_output(m, NULL, NULL, IPV6_OUTARGS, NULL, &amp;outif, &amp;ip6oa);
	<span class="enscript-keyword">if</span> (outif) {
		icmp6_ifstat_inc(outif, ifs6_out_msg);
		icmp6_ifstat_inc(outif, ifs6_out_redirect);
		ifnet_release(outif);
	}
	icmp6stat.icp6s_outhist[ND_REDIRECT]++;

	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">if</span> (rt != NULL)
		RT_UNLOCK(rt);
	<span class="enscript-keyword">if</span> (m)
		m_freem(m);
	<span class="enscript-keyword">if</span> (m0)
		m_freem(m0);
}

<span class="enscript-comment">/*
 * ICMPv6 socket option processing.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">icmp6_ctloutput</span>(so, sopt)
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">struct</span> sockopt *sopt;
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> optlen;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">int</span> level, op, optname;

	<span class="enscript-keyword">if</span> (sopt) {
		level = sopt-&gt;sopt_level;
		op = sopt-&gt;sopt_dir;
		optname = sopt-&gt;sopt_name;
		optlen = sopt-&gt;sopt_valsize;
	} <span class="enscript-keyword">else</span>
		level = op = optname = optlen = 0;

	<span class="enscript-keyword">if</span> (level != IPPROTO_ICMPV6) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">switch</span> (op) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRCO_SETOPT</span>:
		<span class="enscript-keyword">switch</span> (optname) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_FILTER</span>:
		    {
			<span class="enscript-type">struct</span> icmp6_filter *p;

			<span class="enscript-keyword">if</span> (optlen != 0 &amp;&amp; optlen != <span class="enscript-keyword">sizeof</span>(*p)) {
				error = EMSGSIZE;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (inp-&gt;in6p_icmp6filt == NULL) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">if</span> (optlen == 0) {
				<span class="enscript-comment">/* According to RFC 3542, an installed filter can be 
				 * cleared by issuing a setsockopt for ICMP6_FILTER
				 * with a zero length.
				 */</span>
				ICMP6_FILTER_SETPASSALL(inp-&gt;in6p_icmp6filt);
			} <span class="enscript-keyword">else</span> {
				error = sooptcopyin(sopt, inp-&gt;in6p_icmp6filt, optlen,
					optlen);
			}
			<span class="enscript-keyword">break</span>;
		    }

		<span class="enscript-reference">default</span>:
			error = ENOPROTOOPT;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRCO_GETOPT</span>:
		<span class="enscript-keyword">switch</span> (optname) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_FILTER</span>:
		    {
			<span class="enscript-keyword">if</span> (inp-&gt;in6p_icmp6filt == NULL) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			error = sooptcopyout(sopt, inp-&gt;in6p_icmp6filt,
					min(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_filter), optlen));
			<span class="enscript-keyword">break</span>;
		    }

		<span class="enscript-reference">default</span>:
			error = ENOPROTOOPT;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * ICMPv6 socket datagram option processing.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">icmp6_dgram_ctloutput</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-keyword">if</span> (kauth_cred_issuser(so-&gt;so_cred))
		<span class="enscript-keyword">return</span> icmp6_ctloutput(so, sopt);

	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_level == IPPROTO_ICMPV6) {
		<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ICMP6_FILTER</span>:
				<span class="enscript-keyword">return</span> icmp6_ctloutput(so, sopt);
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">return</span> EPERM;
		}
	}

	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_level != IPPROTO_IPV6)
		<span class="enscript-keyword">return</span> EINVAL;

	<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_UNICAST_HOPS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_CHECKSUM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_V6ONLY</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_USE_MIN_MTU</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVRTHDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVPKTINFO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVHOPLIMIT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PATHMTU</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PKTINFO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_HOPLIMIT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_HOPOPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_DSTOPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_MULTICAST_IF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_MULTICAST_HOPS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_MULTICAST_LOOP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_JOIN_GROUP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_LEAVE_GROUP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PORTRANGE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_IPSEC_POLICY</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVTCLASS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_TCLASS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292PKTOPTIONS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292PKTINFO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292HOPLIMIT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292HOPOPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292DSTOPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292RTHDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_BOUND_IF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_NO_IFT_CELLULAR</span>:

			<span class="enscript-keyword">return</span> ip6_ctloutput(so, sopt);

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> EPERM;
	}
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">icmp6_dgram_send</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> mbuf *m,
    <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> mbuf *control, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">flags</span>, <span class="enscript-variable-name">p</span>)
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">struct</span> sockaddr_in6 tmp;
	<span class="enscript-type">struct</span> sockaddr_in6 *dst = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)nam;
	<span class="enscript-type">struct</span> icmp6_hdr *icmp6;

	<span class="enscript-keyword">if</span> (inp == NULL
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		|| (necp_socket_should_use_flow_divert(inp))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
		) {
		error = (inp == NULL ? EINVAL : EPROTOTYPE);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> (kauth_cred_issuser(so-&gt;so_cred))
		<span class="enscript-keyword">return</span> (rip6_output(m, so, SIN6(nam), control, 0));

	<span class="enscript-comment">/* always copy sockaddr to avoid overwrites */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_ISCONNECTED) {
		<span class="enscript-keyword">if</span> (nam != NULL) {
			error = EISCONN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-comment">/* XXX */</span>
		bzero(&amp;tmp, <span class="enscript-keyword">sizeof</span>(tmp));
		tmp.sin6_family = AF_INET6;
		tmp.sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
		bcopy(&amp;inp-&gt;in6p_faddr, &amp;tmp.sin6_addr,
			  <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
		dst = &amp;tmp;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (nam == NULL) {
			error = ENOTCONN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		tmp = *(<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)nam;
		dst = &amp;tmp;
	}

	<span class="enscript-comment">/*
	 * For an ICMPv6 packet, we should know its type and code
	 */</span>
	<span class="enscript-keyword">if</span> (SOCK_PROTO(so) == IPPROTO_ICMPV6) {
		<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr) &amp;&amp;
			(m = m_pullup(m, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_hdr))) == NULL) {
				error = ENOBUFS;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		icmp6 = mtod(m, <span class="enscript-type">struct</span> icmp6_hdr *);

		<span class="enscript-comment">/*
		 * Allow only to send echo request and node information request
		 * See RFC 2463 for Echo Request Message format
		 */</span>
		<span class="enscript-keyword">if</span> ((icmp6-&gt;icmp6_type == ICMP6_ECHO_REQUEST &amp;&amp;
		    icmp6-&gt;icmp6_code == 0) ||
		    (icmp6-&gt;icmp6_type == ICMP6_NI_QUERY &amp;&amp;
		    (icmp6-&gt;icmp6_code == ICMP6_NI_SUBJ_IPV6 ||
		    icmp6-&gt;icmp6_code == ICMP6_NI_SUBJ_FQDN))) {
			<span class="enscript-comment">/* Good */</span>
			;
		} <span class="enscript-keyword">else</span> {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">ENABLE_DEFAULT_SCOPE</span>
	<span class="enscript-keyword">if</span> (dst-&gt;sin6_scope_id == 0) {  <span class="enscript-comment">/* not change if specified  */</span>
		dst-&gt;sin6_scope_id = scope6_addr2default(&amp;dst-&gt;sin6_addr);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> (rip6_output(m, so, dst, control, 0));
<span class="enscript-reference">bad</span>:
	VERIFY(error != 0);

	<span class="enscript-keyword">if</span> (m != NULL)
		m_freem(m);
	<span class="enscript-keyword">if</span> (control != NULL)
		m_freem(control);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* Like rip6_attach but without root privilege enforcement */</span>
__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">icmp6_dgram_attach</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> proto, <span class="enscript-type">struct</span> proc *p)
{
        <span class="enscript-type">struct</span> inpcb *inp;
        <span class="enscript-type">int</span> error;

        inp = sotoinpcb(so);
        <span class="enscript-keyword">if</span> (inp)
                panic(<span class="enscript-string">&quot;icmp6_dgram_attach&quot;</span>);

		<span class="enscript-keyword">if</span> (proto != IPPROTO_ICMPV6)
			<span class="enscript-keyword">return</span> EINVAL;

        error = soreserve(so, rip_sendspace, rip_recvspace);
        <span class="enscript-keyword">if</span> (error)
                <span class="enscript-keyword">return</span> error;
        error = in_pcballoc(so, &amp;ripcbinfo, p);
        <span class="enscript-keyword">if</span> (error)
                <span class="enscript-keyword">return</span> error;
        inp = (<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb;
        inp-&gt;inp_vflag |= INP_IPV6;
        inp-&gt;in6p_ip6_nxt = IPPROTO_ICMPV6;
        inp-&gt;in6p_hops = -1;    <span class="enscript-comment">/* use kernel default */</span>
        inp-&gt;in6p_cksum = -1;
        MALLOC(inp-&gt;in6p_icmp6filt, <span class="enscript-type">struct</span> icmp6_filter *,
               <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> icmp6_filter), M_PCB, M_WAITOK);
        <span class="enscript-keyword">if</span> (inp-&gt;in6p_icmp6filt == NULL)
                <span class="enscript-keyword">return</span> (ENOMEM);
        ICMP6_FILTER_SETPASSALL(inp-&gt;in6p_icmp6filt);
        <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/*
 * Perform rate limit check.
 * Returns 0 if it is okay to send the icmp6 packet.
 * Returns 1 if the router SHOULD NOT send this icmp6 packet due to rate
 * limitation.
 *
 * XXX per-destination check necessary?
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">icmp6_ratelimit</span>(
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr *dst,	<span class="enscript-comment">/* not used at this moment */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">int</span> type,
	__unused <span class="enscript-type">const</span> <span class="enscript-type">int</span> code)
{
	<span class="enscript-type">int</span> ret;

	ret = 0;	<span class="enscript-comment">/* okay to send */</span>

	<span class="enscript-comment">/* PPS limit */</span>
	<span class="enscript-keyword">if</span> (type == ND_ROUTER_ADVERT) {
		<span class="enscript-keyword">if</span> (!ppsratecheck(&amp;icmp6rappslim_last, &amp;icmp6rapps_count,
		    icmp6rappslim))
			ret++;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!ppsratecheck(&amp;icmp6errppslim_last, &amp;icmp6errpps_count,
	    icmp6errppslim)) {
		<span class="enscript-comment">/* The packet is subject to rate limit */</span>
		ret++;
	}

	<span class="enscript-keyword">return</span> ret;
}
</pre>
<hr />
</body></html>