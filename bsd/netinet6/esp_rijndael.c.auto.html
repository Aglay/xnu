<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>esp_rijndael.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">esp_rijndael.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$FreeBSD: src/sys/netinet6/esp_rijndael.c,v 1.1.2.1 2001/07/03 11:01:50 ume Exp $	*/</span>
<span class="enscript-comment">/*	$KAME: esp_rijndael.c,v 1.4 2001/03/02 05:53:05 itojun Exp $	*/</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp_rijndael.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/crypto/aes.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_REALIGN_LEN</span> 2000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AES_BLOCKLEN</span> 16
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ESP_GCM_SALT_LEN</span> 4   // RFC 4106 Section 4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ESP_GCM_IVLEN</span> 8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ESP_GCM_ALIGN</span> 16

<span class="enscript-type">extern</span> lck_mtx_t *sadb_mutex;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
        ccgcm_ctx *decrypt;
        ccgcm_ctx *encrypt;
        ccgcm_ctx ctxt[0];
} aes_gcm_ctx;

<span class="enscript-type">int</span>
<span class="enscript-function-name">esp_aes_schedlen</span>(
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo)
{

	<span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span>(aes_ctx);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">esp_aes_schedule</span>(
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo,
	<span class="enscript-type">struct</span> secasvar *sav)
{

	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	aes_ctx *ctx = (aes_ctx*)sav-&gt;sched;
	
	aes_decrypt_key((<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) _KEYBUF(sav-&gt;key_enc), _KEYLEN(sav-&gt;key_enc), &amp;ctx-&gt;decrypt);
	aes_encrypt_key((<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) _KEYBUF(sav-&gt;key_enc), _KEYLEN(sav-&gt;key_enc), &amp;ctx-&gt;encrypt);
	
	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/* The following 2 functions decrypt or encrypt the contents of
 * the mbuf chain passed in keeping the IP and ESP header's in place,
 * along with the IV.
 * The code attempts to call the crypto code with the largest chunk
 * of data it can based on the amount of source data in
 * the current source mbuf and the space remaining in the current
 * destination mbuf.  The crypto code requires data to be a multiples
 * of 16 bytes.  A separate buffer is used when a 16 byte block spans
 * mbufs.
 *
 * m = mbuf chain
 * off = offset to ESP header
 * 
 * local vars for source:
 * soff = offset from beginning of the chain to the head of the
 *			current mbuf.
 * scut = last mbuf that contains headers to be retained
 * scutoff = offset to end of the headers in scut
 * s = the current mbuf
 * sn = current offset to data in s (next source data to process)
 *
 * local vars for dest:
 * d0 = head of chain
 * d = current mbuf
 * dn = current offset in d (next location to store result)
 */</span>
 
 
<span class="enscript-type">int</span>
<span class="enscript-function-name">esp_cbc_decrypt_aes</span>(m, off, sav, algo, ivlen)
	<span class="enscript-type">struct</span> mbuf *m;
	size_t off;
	<span class="enscript-type">struct</span> secasvar *sav;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo;
	<span class="enscript-type">int</span> ivlen;
{
	<span class="enscript-type">struct</span> mbuf *s;
	<span class="enscript-type">struct</span> mbuf *d, *d0, *dp;
	<span class="enscript-type">int</span> soff;	<span class="enscript-comment">/* offset from the head of chain, to head of this mbuf */</span>
	<span class="enscript-type">int</span> sn, dn;	<span class="enscript-comment">/* offset from the head of the mbuf, to meat */</span>
	size_t ivoff, bodyoff;
	u_int8_t iv[AES_BLOCKLEN] __attribute__((aligned(4))), *dptr;
	u_int8_t sbuf[AES_BLOCKLEN] __attribute__((aligned(4))), *sp, *sp_unaligned, *sp_aligned = NULL;
	<span class="enscript-type">struct</span> mbuf *scut;
	<span class="enscript-type">int</span> scutoff;
	<span class="enscript-type">int</span>	i, len;

		
	<span class="enscript-keyword">if</span> (ivlen != AES_BLOCKLEN) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_decrypt %s: &quot;</span>
		    <span class="enscript-string">&quot;unsupported ivlen %d\n&quot;</span>, algo-&gt;name, ivlen));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_OLD) {
		<span class="enscript-comment">/* RFC 1827 */</span>
		ivoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp);
		bodyoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp) + ivlen;
	} <span class="enscript-keyword">else</span> {
		ivoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newesp);
		bodyoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newesp) + ivlen;
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; bodyoff) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_decrypt %s: bad len %d/%lu\n&quot;</span>,
		    algo-&gt;name, m-&gt;m_pkthdr.len, (u_int32_t)bodyoff));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.len - bodyoff) % AES_BLOCKLEN) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_decrypt %s: &quot;</span>
		    <span class="enscript-string">&quot;payload length must be multiple of %d\n&quot;</span>,
		    algo-&gt;name, AES_BLOCKLEN));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* grab iv */</span>
	m_copydata(m, ivoff, ivlen, (caddr_t) iv);

	s = m;
	soff = sn = dn = 0;
	d = d0 = dp = NULL;
	sp = dptr = NULL;
	
	<span class="enscript-comment">/* skip header/IV offset */</span>
	<span class="enscript-keyword">while</span> (soff &lt; bodyoff) {
		<span class="enscript-keyword">if</span> (soff + s-&gt;m_len &gt; bodyoff) {
			sn = bodyoff - soff;
			<span class="enscript-keyword">break</span>;
		}

		soff += s-&gt;m_len;
		s = s-&gt;m_next;
	}
	scut = s;
	scutoff = sn;

	<span class="enscript-comment">/* skip over empty mbuf */</span>
	<span class="enscript-keyword">while</span> (s &amp;&amp; s-&gt;m_len == 0)
		s = s-&gt;m_next;
	
	<span class="enscript-keyword">while</span> (soff &lt; m-&gt;m_pkthdr.len) {
		<span class="enscript-comment">/* source */</span>
		<span class="enscript-keyword">if</span> (sn + AES_BLOCKLEN &lt;= s-&gt;m_len) {
			<span class="enscript-comment">/* body is continuous */</span>
			sp = mtod(s, u_int8_t *) + sn;
			len = s-&gt;m_len - sn;
			len -= len % AES_BLOCKLEN;	<span class="enscript-comment">// full blocks only
</span>		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* body is non-continuous */</span>
			m_copydata(s, sn, AES_BLOCKLEN, (caddr_t) sbuf);
			sp = sbuf;
			len = AES_BLOCKLEN;			<span class="enscript-comment">// 1 block only in sbuf
</span>		}

		<span class="enscript-comment">/* destination */</span>
		<span class="enscript-keyword">if</span> (!d || dn + AES_BLOCKLEN &gt; d-&gt;m_len) {
			<span class="enscript-keyword">if</span> (d)
				dp = d;
			MGET(d, M_DONTWAIT, MT_DATA);
			i = m-&gt;m_pkthdr.len - (soff + sn);
			<span class="enscript-keyword">if</span> (d &amp;&amp; i &gt; MLEN) {
				MCLGET(d, M_DONTWAIT);
				<span class="enscript-keyword">if</span> ((d-&gt;m_flags &amp; M_EXT) == 0) {
					d = m_mbigget(d, M_DONTWAIT);
					<span class="enscript-keyword">if</span> ((d-&gt;m_flags &amp; M_EXT) == 0) {
						m_free(d);
						d = NULL;
					}
				}
			}
			<span class="enscript-keyword">if</span> (!d) {
				m_freem(m);
				<span class="enscript-keyword">if</span> (d0)
					m_freem(d0);
				<span class="enscript-keyword">return</span> ENOBUFS;
			}
			<span class="enscript-keyword">if</span> (!d0)
				d0 = d;
			<span class="enscript-keyword">if</span> (dp)
				dp-&gt;m_next = d;

			<span class="enscript-comment">// try to make mbuf data aligned
</span>			<span class="enscript-keyword">if</span> (!IPSEC_IS_P2ALIGNED(d-&gt;m_data)) {
				m_adj(d, IPSEC_GET_P2UNALIGNED_OFS(d-&gt;m_data));
			}

			d-&gt;m_len = M_TRAILINGSPACE(d);
			d-&gt;m_len -= d-&gt;m_len % AES_BLOCKLEN;
			<span class="enscript-keyword">if</span> (d-&gt;m_len &gt; i)
				d-&gt;m_len = i;
			dptr = mtod(d, u_int8_t *);	
			dn = 0;
		}

		<span class="enscript-comment">/* adjust len if greater than space available in dest */</span>
		<span class="enscript-keyword">if</span> (len &gt; d-&gt;m_len - dn)
			len = d-&gt;m_len - dn;

		<span class="enscript-comment">/* decrypt */</span>
		<span class="enscript-comment">// check input pointer alignment and use a separate aligned buffer (if sp is unaligned on 4-byte boundary).
</span>		<span class="enscript-keyword">if</span> (IPSEC_IS_P2ALIGNED(sp)) {
			sp_unaligned = NULL;
		} <span class="enscript-keyword">else</span> {
			sp_unaligned = sp;
			<span class="enscript-keyword">if</span> (len &gt; MAX_REALIGN_LEN) {
				<span class="enscript-keyword">return</span> ENOBUFS;
			}
			<span class="enscript-keyword">if</span> (sp_aligned == NULL) {
				sp_aligned = (u_int8_t *)_MALLOC(MAX_REALIGN_LEN, M_SECA, M_DONTWAIT);
				<span class="enscript-keyword">if</span> (sp_aligned == NULL)
					<span class="enscript-keyword">return</span> ENOMEM;
			}
			sp = sp_aligned;
			memcpy(sp, sp_unaligned, len);
		}
		<span class="enscript-comment">// no need to check output pointer alignment
</span>		aes_decrypt_cbc(sp, iv, len &gt;&gt; 4, dptr + dn, 
				(aes_decrypt_ctx*)(&amp;(((aes_ctx*)sav-&gt;sched)-&gt;decrypt)));
		
		<span class="enscript-comment">// update unaligned pointers
</span>		<span class="enscript-keyword">if</span> (!IPSEC_IS_P2ALIGNED(sp_unaligned)) {
			sp = sp_unaligned;
		}

		<span class="enscript-comment">/* udpate offsets */</span>
		sn += len;
		dn += len;
		
		<span class="enscript-comment">// next iv
</span>		bcopy(sp + len - AES_BLOCKLEN, iv, AES_BLOCKLEN);

		<span class="enscript-comment">/* find the next source block */</span>
		<span class="enscript-keyword">while</span> (s &amp;&amp; sn &gt;= s-&gt;m_len) {
			sn -= s-&gt;m_len;
			soff += s-&gt;m_len;
			s = s-&gt;m_next;
		}

	}

	<span class="enscript-comment">/* free un-needed source mbufs and add dest mbufs to chain */</span>
	m_freem(scut-&gt;m_next);
	scut-&gt;m_len = scutoff;
	scut-&gt;m_next = d0;

	<span class="enscript-comment">// free memory
</span>	<span class="enscript-keyword">if</span> (sp_aligned != NULL) {
		FREE(sp_aligned, M_SECA);
		sp_aligned = NULL;
	}
	
	<span class="enscript-comment">/* just in case */</span>
	bzero(iv, <span class="enscript-keyword">sizeof</span>(iv));
	bzero(sbuf, <span class="enscript-keyword">sizeof</span>(sbuf));

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">esp_cbc_encrypt_aes</span>(
	<span class="enscript-type">struct</span> mbuf *m,
	size_t off,
	__unused size_t plen,
	<span class="enscript-type">struct</span> secasvar *sav,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo,
	<span class="enscript-type">int</span> ivlen)
{
	<span class="enscript-type">struct</span> mbuf *s;
	<span class="enscript-type">struct</span> mbuf *d, *d0, *dp;
	<span class="enscript-type">int</span> soff;	<span class="enscript-comment">/* offset from the head of chain, to head of this mbuf */</span>
	<span class="enscript-type">int</span> sn, dn;	<span class="enscript-comment">/* offset from the head of the mbuf, to meat */</span>
	size_t ivoff, bodyoff;
	u_int8_t *ivp, *dptr, *ivp_unaligned;
	u_int8_t sbuf[AES_BLOCKLEN] __attribute__((aligned(4))), *sp, *sp_unaligned, *sp_aligned = NULL;
	u_int8_t ivp_aligned_buf[AES_BLOCKLEN] __attribute__((aligned(4)));
	<span class="enscript-type">struct</span> mbuf *scut;
	<span class="enscript-type">int</span> scutoff;
	<span class="enscript-type">int</span> i, len;

	<span class="enscript-keyword">if</span> (ivlen != AES_BLOCKLEN) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_encrypt %s: &quot;</span>
		    <span class="enscript-string">&quot;unsupported ivlen %d\n&quot;</span>, algo-&gt;name, ivlen));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_OLD) {
		<span class="enscript-comment">/* RFC 1827 */</span>
		ivoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp);
		bodyoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp) + ivlen;
	} <span class="enscript-keyword">else</span> {
		ivoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newesp);
		bodyoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newesp) + ivlen;
	}

	<span class="enscript-comment">/* put iv into the packet */</span>
	m_copyback(m, ivoff, ivlen, sav-&gt;iv);
	ivp = (u_int8_t *) sav-&gt;iv;

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; bodyoff) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_encrypt %s: bad len %d/%lu\n&quot;</span>,
		    algo-&gt;name, m-&gt;m_pkthdr.len, (u_int32_t)bodyoff));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.len - bodyoff) % AES_BLOCKLEN) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_encrypt %s: &quot;</span>
		    <span class="enscript-string">&quot;payload length must be multiple of %lu\n&quot;</span>,
		    algo-&gt;name, AES_BLOCKLEN));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	s = m;
	soff = sn = dn = 0;
	d = d0 = dp = NULL;
	sp = dptr = NULL;
	
	<span class="enscript-comment">/* skip headers/IV */</span>
	<span class="enscript-keyword">while</span> (soff &lt; bodyoff) {
		<span class="enscript-keyword">if</span> (soff + s-&gt;m_len &gt; bodyoff) {
			sn = bodyoff - soff;
			<span class="enscript-keyword">break</span>;
		}

		soff += s-&gt;m_len;
		s = s-&gt;m_next;
	}
	scut = s;
	scutoff = sn;

	<span class="enscript-comment">/* skip over empty mbuf */</span>
	<span class="enscript-keyword">while</span> (s &amp;&amp; s-&gt;m_len == 0)
		s = s-&gt;m_next;
	
	<span class="enscript-keyword">while</span> (soff &lt; m-&gt;m_pkthdr.len) {
		<span class="enscript-comment">/* source */</span>
		<span class="enscript-keyword">if</span> (sn + AES_BLOCKLEN &lt;= s-&gt;m_len) {
			<span class="enscript-comment">/* body is continuous */</span>
			sp = mtod(s, u_int8_t *) + sn;
			len = s-&gt;m_len - sn;
			len -= len % AES_BLOCKLEN;	<span class="enscript-comment">// full blocks only
</span>		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* body is non-continuous */</span>
			m_copydata(s, sn, AES_BLOCKLEN, (caddr_t) sbuf);
			sp = sbuf;
			len = AES_BLOCKLEN;			<span class="enscript-comment">// 1 block only in sbuf
</span>		}

		<span class="enscript-comment">/* destination */</span>
		<span class="enscript-keyword">if</span> (!d || dn + AES_BLOCKLEN &gt; d-&gt;m_len) {
			<span class="enscript-keyword">if</span> (d)
				dp = d;
			MGET(d, M_DONTWAIT, MT_DATA);
			i = m-&gt;m_pkthdr.len - (soff + sn);
			<span class="enscript-keyword">if</span> (d &amp;&amp; i &gt; MLEN) {
				MCLGET(d, M_DONTWAIT);
				<span class="enscript-keyword">if</span> ((d-&gt;m_flags &amp; M_EXT) == 0) {
					d = m_mbigget(d, M_DONTWAIT);
					<span class="enscript-keyword">if</span> ((d-&gt;m_flags &amp; M_EXT) == 0) {
						m_free(d);
						d = NULL;
					}
				}
			}
			<span class="enscript-keyword">if</span> (!d) {
				m_freem(m);
				<span class="enscript-keyword">if</span> (d0)
					m_freem(d0);
				<span class="enscript-keyword">return</span> ENOBUFS;
			}
			<span class="enscript-keyword">if</span> (!d0)
				d0 = d;
			<span class="enscript-keyword">if</span> (dp)
				dp-&gt;m_next = d;

			<span class="enscript-comment">// try to make mbuf data aligned
</span>			<span class="enscript-keyword">if</span> (!IPSEC_IS_P2ALIGNED(d-&gt;m_data)) {
				m_adj(d, IPSEC_GET_P2UNALIGNED_OFS(d-&gt;m_data));
			}

			d-&gt;m_len = M_TRAILINGSPACE(d);
			d-&gt;m_len -= d-&gt;m_len % AES_BLOCKLEN;
			<span class="enscript-keyword">if</span> (d-&gt;m_len &gt; i)
				d-&gt;m_len = i;
			dptr = mtod(d, u_int8_t *);
			dn = 0;
		}
		
		<span class="enscript-comment">/* adjust len if greater than space available */</span>
		<span class="enscript-keyword">if</span> (len &gt; d-&gt;m_len - dn)
			len = d-&gt;m_len - dn;
		
		<span class="enscript-comment">/* encrypt */</span>
		<span class="enscript-comment">// check input pointer alignment and use a separate aligned buffer (if sp is not aligned on 4-byte boundary).
</span>		<span class="enscript-keyword">if</span> (IPSEC_IS_P2ALIGNED(sp)) {
			sp_unaligned = NULL;
		} <span class="enscript-keyword">else</span> {
			sp_unaligned = sp;
			<span class="enscript-keyword">if</span> (len &gt; MAX_REALIGN_LEN) {
				<span class="enscript-keyword">return</span> ENOBUFS;
			}
			<span class="enscript-keyword">if</span> (sp_aligned == NULL) {
				sp_aligned = (u_int8_t *)_MALLOC(MAX_REALIGN_LEN, M_SECA, M_DONTWAIT);
				<span class="enscript-keyword">if</span> (sp_aligned == NULL)
					<span class="enscript-keyword">return</span> ENOMEM;
			}
			sp = sp_aligned;
			memcpy(sp, sp_unaligned, len);
		}
		<span class="enscript-comment">// check ivp pointer alignment and use a separate aligned buffer (if ivp is not aligned on 4-byte boundary).
</span>		<span class="enscript-keyword">if</span> (IPSEC_IS_P2ALIGNED(ivp)) {
			ivp_unaligned = NULL;
		} <span class="enscript-keyword">else</span> {
			ivp_unaligned = ivp;
			ivp = ivp_aligned_buf;
			memcpy(ivp, ivp_unaligned, AES_BLOCKLEN);
		}
		<span class="enscript-comment">// no need to check output pointer alignment
</span>		aes_encrypt_cbc(sp, ivp, len &gt;&gt; 4, dptr + dn, 
			(aes_encrypt_ctx*)(&amp;(((aes_ctx*)sav-&gt;sched)-&gt;encrypt)));

		<span class="enscript-comment">// update unaligned pointers
</span>		<span class="enscript-keyword">if</span> (!IPSEC_IS_P2ALIGNED(sp_unaligned)) {
			sp = sp_unaligned;
		}
		<span class="enscript-keyword">if</span> (!IPSEC_IS_P2ALIGNED(ivp_unaligned)) {
			ivp = ivp_unaligned;
		}

		<span class="enscript-comment">/* update offsets */</span>
		sn += len;
		dn += len;

		<span class="enscript-comment">/* next iv */</span>
		ivp = dptr + dn - AES_BLOCKLEN;	<span class="enscript-comment">// last block encrypted
</span>		
		<span class="enscript-comment">/* find the next source block and skip empty mbufs */</span>
		<span class="enscript-keyword">while</span> (s &amp;&amp; sn &gt;= s-&gt;m_len) {
			sn -= s-&gt;m_len;
			soff += s-&gt;m_len;
			s = s-&gt;m_next;
		}
	}

	<span class="enscript-comment">/* free un-needed source mbufs and add dest mbufs to chain */</span>
	m_freem(scut-&gt;m_next);
	scut-&gt;m_len = scutoff;
	scut-&gt;m_next = d0;
	
	<span class="enscript-comment">// free memory
</span>	<span class="enscript-keyword">if</span> (sp_aligned != NULL) {
		FREE(sp_aligned, M_SECA);
		sp_aligned = NULL;
	}

	<span class="enscript-comment">/* just in case */</span>
	bzero(sbuf, <span class="enscript-keyword">sizeof</span>(sbuf));
	key_sa_stir_iv(sav);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">esp_gcm_schedlen</span>(
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo)
{
        <span class="enscript-keyword">return</span> (<span class="enscript-keyword">sizeof</span>(aes_gcm_ctx) + aes_decrypt_get_ctx_size_gcm() + aes_encrypt_get_ctx_size_gcm() + ESP_GCM_ALIGN);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">esp_gcm_schedule</span>( __unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo,
		 <span class="enscript-type">struct</span> secasvar *sav)
{
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	aes_gcm_ctx *ctx = (aes_gcm_ctx*)P2ROUNDUP(sav-&gt;sched, ESP_GCM_ALIGN);
	<span class="enscript-type">int</span> rc;

	ctx-&gt;decrypt = &amp;ctx-&gt;ctxt[0];
	ctx-&gt;encrypt = &amp;ctx-&gt;ctxt[aes_decrypt_get_ctx_size_gcm() / <span class="enscript-keyword">sizeof</span>(ccgcm_ctx)];

	rc = aes_decrypt_key_gcm((<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) _KEYBUF(sav-&gt;key_enc), _KEYLEN(sav-&gt;key_enc)-ESP_GCM_SALT_LEN, ctx-&gt;decrypt);
	<span class="enscript-keyword">if</span> (rc) {
	        <span class="enscript-keyword">return</span> (rc);
	}

	rc = aes_encrypt_key_gcm((<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) _KEYBUF(sav-&gt;key_enc), _KEYLEN(sav-&gt;key_enc)-ESP_GCM_SALT_LEN, ctx-&gt;encrypt);
	<span class="enscript-keyword">if</span> (rc) {
	        <span class="enscript-keyword">return</span> (rc);
	}
	<span class="enscript-keyword">return</span> (rc);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">esp_gcm_encrypt_finalize</span>(<span class="enscript-type">struct</span> secasvar *sav,
			 <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *tag, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> tag_bytes)
{
	aes_gcm_ctx *ctx = (aes_gcm_ctx*)P2ROUNDUP(sav-&gt;sched, ESP_GCM_ALIGN);
	<span class="enscript-keyword">return</span> (aes_encrypt_finalize_gcm(tag, tag_bytes, ctx-&gt;encrypt));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">esp_gcm_decrypt_finalize</span>(<span class="enscript-type">struct</span> secasvar *sav,
			 <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *tag, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> tag_bytes)
{
	aes_gcm_ctx *ctx = (aes_gcm_ctx*)P2ROUNDUP(sav-&gt;sched, ESP_GCM_ALIGN);
	<span class="enscript-keyword">return</span> (aes_decrypt_finalize_gcm(tag, tag_bytes, ctx-&gt;decrypt));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">esp_gcm_encrypt_aes</span>(
	<span class="enscript-type">struct</span> mbuf *m,
	size_t off,
	__unused size_t plen,
	<span class="enscript-type">struct</span> secasvar *sav,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo __unused,
	<span class="enscript-type">int</span> ivlen)
{
	<span class="enscript-type">struct</span> mbuf *s;
	<span class="enscript-type">struct</span> mbuf *d, *d0, *dp;
	<span class="enscript-type">int</span> soff;	<span class="enscript-comment">/* offset from the head of chain, to head of this mbuf */</span>
	<span class="enscript-type">int</span> sn, dn;	<span class="enscript-comment">/* offset from the head of the mbuf, to meat */</span>
	size_t ivoff, bodyoff;
	u_int8_t *dptr, *sp, *sp_unaligned, *sp_aligned = NULL;
	aes_gcm_ctx *ctx;
	<span class="enscript-type">struct</span> mbuf *scut;
	<span class="enscript-type">int</span> scutoff;
	<span class="enscript-type">int</span> i, len;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> nonce[ESP_GCM_SALT_LEN+ivlen];
	
	<span class="enscript-keyword">if</span> (ivlen != ESP_GCM_IVLEN) {
	        ipseclog((LOG_ERR, <span class="enscript-string">&quot;%s: unsupported ivlen %d\n&quot;</span>, __FUNCTION__, ivlen));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_OLD) {
		<span class="enscript-comment">/* RFC 1827 */</span>
		ivoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp);
		bodyoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp) + ivlen;
	} <span class="enscript-keyword">else</span> {
		ivoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newesp);
		bodyoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newesp) + ivlen;
	}

	m_copyback(m, ivoff, ivlen, sav-&gt;iv);

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; bodyoff) {
	        ipseclog((LOG_ERR, <span class="enscript-string">&quot;%s: bad len %d/%lu\n&quot;</span>, __FUNCTION__,
		    m-&gt;m_pkthdr.len, (u_int32_t)bodyoff));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* Set IV */</span>
	memcpy(nonce, _KEYBUF(sav-&gt;key_enc)+_KEYLEN(sav-&gt;key_enc)-ESP_GCM_SALT_LEN, ESP_GCM_SALT_LEN);
	memcpy(nonce+ESP_GCM_SALT_LEN, sav-&gt;iv, ivlen);

	ctx = (aes_gcm_ctx *)P2ROUNDUP(sav-&gt;sched, ESP_GCM_ALIGN);
	<span class="enscript-keyword">if</span> (aes_encrypt_set_iv_gcm(nonce, <span class="enscript-keyword">sizeof</span>(nonce), ctx-&gt;encrypt)) {
	        ipseclog((LOG_ERR, <span class="enscript-string">&quot;%s: failed to set IV\n&quot;</span>, __FUNCTION__));
		m_freem(m);
		bzero(nonce, <span class="enscript-keyword">sizeof</span>(nonce));
		<span class="enscript-keyword">return</span> EINVAL;
	}
	bzero(nonce, <span class="enscript-keyword">sizeof</span>(nonce));

	<span class="enscript-comment">/* Set Additional Authentication Data */</span>
	<span class="enscript-keyword">if</span> (!(sav-&gt;flags &amp; SADB_X_EXT_OLD)) {
	        <span class="enscript-type">struct</span> newesp esp;
		m_copydata(m, off, <span class="enscript-keyword">sizeof</span>(esp), (caddr_t) &amp;esp);
		<span class="enscript-keyword">if</span> (aes_encrypt_aad_gcm((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>*)&amp;esp, <span class="enscript-keyword">sizeof</span>(esp), ctx-&gt;encrypt)) {
		        ipseclog((LOG_ERR, <span class="enscript-string">&quot;%s: packet decryption AAD failure\n&quot;</span>, __FUNCTION__));
			m_freem(m);
			<span class="enscript-keyword">return</span> EINVAL;
		}
	}

	s = m;
	soff = sn = dn = 0;
	d = d0 = dp = NULL;
	sp = dptr = NULL;
	
	<span class="enscript-comment">/* skip headers/IV */</span>
	<span class="enscript-keyword">while</span> (soff &lt; bodyoff) {
		<span class="enscript-keyword">if</span> (soff + s-&gt;m_len &gt; bodyoff) {
			sn = bodyoff - soff;
			<span class="enscript-keyword">break</span>;
		}

		soff += s-&gt;m_len;
		s = s-&gt;m_next;
	}
	scut = s;
	scutoff = sn;

	<span class="enscript-comment">/* skip over empty mbuf */</span>
	<span class="enscript-keyword">while</span> (s &amp;&amp; s-&gt;m_len == 0)
		s = s-&gt;m_next;
	
	<span class="enscript-keyword">while</span> (soff &lt; m-&gt;m_pkthdr.len) {
	        <span class="enscript-comment">/* source */</span>
	        sp = mtod(s, u_int8_t *) + sn;
		len = s-&gt;m_len - sn;

		<span class="enscript-comment">/* destination */</span>
		<span class="enscript-keyword">if</span> (!d || (dn + len &gt; d-&gt;m_len)) {
			<span class="enscript-keyword">if</span> (d)
				dp = d;
			MGET(d, M_DONTWAIT, MT_DATA);
			i = m-&gt;m_pkthdr.len - (soff + sn);
			<span class="enscript-keyword">if</span> (d &amp;&amp; i &gt; MLEN) {
				MCLGET(d, M_DONTWAIT);
				<span class="enscript-keyword">if</span> ((d-&gt;m_flags &amp; M_EXT) == 0) {
					d = m_mbigget(d, M_DONTWAIT);
					<span class="enscript-keyword">if</span> ((d-&gt;m_flags &amp; M_EXT) == 0) {
						m_free(d);
						d = NULL;
					}
				}
			}
			<span class="enscript-keyword">if</span> (!d) {
				m_freem(m);
				<span class="enscript-keyword">if</span> (d0)
					m_freem(d0);
				<span class="enscript-keyword">return</span> ENOBUFS;
			}
			<span class="enscript-keyword">if</span> (!d0)
				d0 = d;
			<span class="enscript-keyword">if</span> (dp)
				dp-&gt;m_next = d;

			<span class="enscript-comment">// try to make mbuf data aligned
</span>			<span class="enscript-keyword">if</span> (!IPSEC_IS_P2ALIGNED(d-&gt;m_data)) {
				m_adj(d, IPSEC_GET_P2UNALIGNED_OFS(d-&gt;m_data));
			}

			d-&gt;m_len = M_TRAILINGSPACE(d);

			<span class="enscript-keyword">if</span> (d-&gt;m_len &gt; i)
				d-&gt;m_len = i;

			dptr = mtod(d, u_int8_t *);
			dn = 0;
		}
		
		<span class="enscript-comment">/* adjust len if greater than space available */</span>
		<span class="enscript-keyword">if</span> (len &gt; d-&gt;m_len - dn)
			len = d-&gt;m_len - dn;
		
		<span class="enscript-comment">/* encrypt */</span>
		<span class="enscript-comment">// check input pointer alignment and use a separate aligned buffer (if sp is not aligned on 4-byte boundary).
</span>		<span class="enscript-keyword">if</span> (IPSEC_IS_P2ALIGNED(sp)) {
			sp_unaligned = NULL;
		} <span class="enscript-keyword">else</span> {
			sp_unaligned = sp;
			<span class="enscript-keyword">if</span> (len &gt; MAX_REALIGN_LEN) {
				<span class="enscript-keyword">return</span> ENOBUFS;
			}
			<span class="enscript-keyword">if</span> (sp_aligned == NULL) {
				sp_aligned = (u_int8_t *)_MALLOC(MAX_REALIGN_LEN, M_SECA, M_DONTWAIT);
				<span class="enscript-keyword">if</span> (sp_aligned == NULL)
					<span class="enscript-keyword">return</span> ENOMEM;
			}
			sp = sp_aligned;
			memcpy(sp, sp_unaligned, len);
		}

		<span class="enscript-keyword">if</span> (aes_encrypt_gcm(sp, len, dptr+dn, ctx-&gt;encrypt)) {
		        ipseclog((LOG_ERR, <span class="enscript-string">&quot;%s: failed to encrypt\n&quot;</span>, __FUNCTION__));
			m_freem(m);
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-comment">// update unaligned pointers
</span>		<span class="enscript-keyword">if</span> (!IPSEC_IS_P2ALIGNED(sp_unaligned)) {
			sp = sp_unaligned;
		}

		<span class="enscript-comment">/* update offsets */</span>
		sn += len;
		dn += len;

		<span class="enscript-comment">/* find the next source block and skip empty mbufs */</span>
		<span class="enscript-keyword">while</span> (s &amp;&amp; sn &gt;= s-&gt;m_len) {
			sn -= s-&gt;m_len;
			soff += s-&gt;m_len;
			s = s-&gt;m_next;
		}
	}

	<span class="enscript-comment">/* free un-needed source mbufs and add dest mbufs to chain */</span>
	m_freem(scut-&gt;m_next);
	scut-&gt;m_len = scutoff;
	scut-&gt;m_next = d0;
	
	<span class="enscript-comment">// free memory
</span>	<span class="enscript-keyword">if</span> (sp_aligned != NULL) {
		FREE(sp_aligned, M_SECA);
		sp_aligned = NULL;
	}

	<span class="enscript-comment">/* generate new iv */</span>
	key_sa_stir_iv(sav);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">esp_gcm_decrypt_aes</span>(m, off, sav, algo, ivlen)
	<span class="enscript-type">struct</span> mbuf *m;
	size_t off;
	<span class="enscript-type">struct</span> secasvar *sav;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo __unused;
	<span class="enscript-type">int</span> ivlen;
{
	<span class="enscript-type">struct</span> mbuf *s;
	<span class="enscript-type">struct</span> mbuf *d, *d0, *dp;
	<span class="enscript-type">int</span> soff;	<span class="enscript-comment">/* offset from the head of chain, to head of this mbuf */</span>
	<span class="enscript-type">int</span> sn, dn;	<span class="enscript-comment">/* offset from the head of the mbuf, to meat */</span>
	size_t ivoff, bodyoff;
	u_int8_t iv[ESP_GCM_IVLEN] __attribute__((aligned(4))), *dptr;
	u_int8_t *sp, *sp_unaligned, *sp_aligned = NULL;
	aes_gcm_ctx *ctx;
	<span class="enscript-type">struct</span> mbuf *scut;
	<span class="enscript-type">int</span> scutoff;
	<span class="enscript-type">int</span>	i, len;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> nonce[ESP_GCM_SALT_LEN+ivlen];

	<span class="enscript-keyword">if</span> (ivlen != ESP_GCM_IVLEN) {
	        ipseclog((LOG_ERR, <span class="enscript-string">&quot;%s: unsupported ivlen %d\n&quot;</span>, __FUNCTION__, ivlen));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_OLD) {
		<span class="enscript-comment">/* RFC 1827 */</span>
		ivoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp);
		bodyoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp) + ivlen;
	} <span class="enscript-keyword">else</span> {
		ivoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newesp);
		bodyoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newesp) + ivlen;
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; bodyoff) {
	        ipseclog((LOG_ERR, <span class="enscript-string">&quot;%s: bad len %d/%lu\n&quot;</span>, __FUNCTION__, 
		    m-&gt;m_pkthdr.len, (u_int32_t)bodyoff));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* grab iv */</span>
	m_copydata(m, ivoff, ivlen, (caddr_t) iv);

	<span class="enscript-comment">/* Set IV */</span>
	memcpy(nonce, _KEYBUF(sav-&gt;key_enc)+_KEYLEN(sav-&gt;key_enc)-ESP_GCM_SALT_LEN, ESP_GCM_SALT_LEN);
	memcpy(nonce+ESP_GCM_SALT_LEN, iv, ivlen);

	ctx = (aes_gcm_ctx *)P2ROUNDUP(sav-&gt;sched, ESP_GCM_ALIGN);
	<span class="enscript-keyword">if</span> (aes_decrypt_set_iv_gcm(nonce, <span class="enscript-keyword">sizeof</span>(nonce), ctx-&gt;decrypt)) {
	        ipseclog((LOG_ERR, <span class="enscript-string">&quot;%s: failed to set IV\n&quot;</span>, __FUNCTION__));
		m_freem(m);
		bzero(nonce, <span class="enscript-keyword">sizeof</span>(nonce));
		<span class="enscript-keyword">return</span> EINVAL;
	}
	bzero(nonce, <span class="enscript-keyword">sizeof</span>(nonce));

	<span class="enscript-comment">/* Set Additional Authentication Data */</span>
	<span class="enscript-keyword">if</span> (!(sav-&gt;flags &amp; SADB_X_EXT_OLD)) {
	        <span class="enscript-type">struct</span> newesp esp;
		m_copydata(m, off, <span class="enscript-keyword">sizeof</span>(esp), (caddr_t) &amp;esp);
		<span class="enscript-keyword">if</span> (aes_decrypt_aad_gcm((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>*)&amp;esp, <span class="enscript-keyword">sizeof</span>(esp), ctx-&gt;decrypt)) {
		        ipseclog((LOG_ERR, <span class="enscript-string">&quot;%s: packet decryption AAD failure\n&quot;</span>, __FUNCTION__));
			<span class="enscript-keyword">return</span> EINVAL;
		}
	}

	s = m;
	soff = sn = dn = 0;
	d = d0 = dp = NULL;
	sp = dptr = NULL;
	
	<span class="enscript-comment">/* skip header/IV offset */</span>
	<span class="enscript-keyword">while</span> (soff &lt; bodyoff) {
		<span class="enscript-keyword">if</span> (soff + s-&gt;m_len &gt; bodyoff) {
			sn = bodyoff - soff;
			<span class="enscript-keyword">break</span>;
		}

		soff += s-&gt;m_len;
		s = s-&gt;m_next;
	}
	scut = s;
	scutoff = sn;

	<span class="enscript-comment">/* skip over empty mbuf */</span>
	<span class="enscript-keyword">while</span> (s &amp;&amp; s-&gt;m_len == 0)
		s = s-&gt;m_next;
	
	<span class="enscript-keyword">while</span> (soff &lt; m-&gt;m_pkthdr.len) {
		<span class="enscript-comment">/* source */</span>
	        sp = mtod(s, u_int8_t *) + sn;
		len = s-&gt;m_len - sn;

		<span class="enscript-comment">/* destination */</span>
		<span class="enscript-keyword">if</span> (!d || (dn + len &gt; d-&gt;m_len)) {
			<span class="enscript-keyword">if</span> (d)
				dp = d;
			MGET(d, M_DONTWAIT, MT_DATA);
			i = m-&gt;m_pkthdr.len - (soff + sn);
			<span class="enscript-keyword">if</span> (d &amp;&amp; i &gt; MLEN) {
				MCLGET(d, M_DONTWAIT);
				<span class="enscript-keyword">if</span> ((d-&gt;m_flags &amp; M_EXT) == 0) {
					d = m_mbigget(d, M_DONTWAIT);
					<span class="enscript-keyword">if</span> ((d-&gt;m_flags &amp; M_EXT) == 0) {
						m_free(d);
						d = NULL;
					}
				}
			}
			<span class="enscript-keyword">if</span> (!d) {
				m_freem(m);
				<span class="enscript-keyword">if</span> (d0)
					m_freem(d0);
				<span class="enscript-keyword">return</span> ENOBUFS;
			}
			<span class="enscript-keyword">if</span> (!d0)
				d0 = d;
			<span class="enscript-keyword">if</span> (dp)
				dp-&gt;m_next = d;

			<span class="enscript-comment">// try to make mbuf data aligned
</span>			<span class="enscript-keyword">if</span> (!IPSEC_IS_P2ALIGNED(d-&gt;m_data)) {
				m_adj(d, IPSEC_GET_P2UNALIGNED_OFS(d-&gt;m_data));
			}

			d-&gt;m_len = M_TRAILINGSPACE(d);

			<span class="enscript-keyword">if</span> (d-&gt;m_len &gt; i)
				d-&gt;m_len = i;

			dptr = mtod(d, u_int8_t *);	
			dn = 0;
		}

		<span class="enscript-comment">/* adjust len if greater than space available in dest */</span>
		<span class="enscript-keyword">if</span> (len &gt; d-&gt;m_len - dn)
			len = d-&gt;m_len - dn;

		<span class="enscript-comment">/* Decrypt */</span>
		<span class="enscript-comment">// check input pointer alignment and use a separate aligned buffer (if sp is unaligned on 4-byte boundary).
</span>		<span class="enscript-keyword">if</span> (IPSEC_IS_P2ALIGNED(sp)) {
			sp_unaligned = NULL;
		} <span class="enscript-keyword">else</span> {
			sp_unaligned = sp;
			<span class="enscript-keyword">if</span> (len &gt; MAX_REALIGN_LEN) {
				<span class="enscript-keyword">return</span> ENOBUFS;
			}
			<span class="enscript-keyword">if</span> (sp_aligned == NULL) {
				sp_aligned = (u_int8_t *)_MALLOC(MAX_REALIGN_LEN, M_SECA, M_DONTWAIT);
				<span class="enscript-keyword">if</span> (sp_aligned == NULL)
					<span class="enscript-keyword">return</span> ENOMEM;
			}
			sp = sp_aligned;
			memcpy(sp, sp_unaligned, len);
		}
		<span class="enscript-comment">// no need to check output pointer alignment
</span>
		<span class="enscript-keyword">if</span> (aes_decrypt_gcm(sp, len, dptr + dn, ctx-&gt;decrypt)) {
		        ipseclog((LOG_ERR, <span class="enscript-string">&quot;%s: failed to decrypt\n&quot;</span>, __FUNCTION__));
			m_freem(m);
			<span class="enscript-keyword">return</span> EINVAL;
		}
		
		<span class="enscript-comment">// update unaligned pointers
</span>		<span class="enscript-keyword">if</span> (!IPSEC_IS_P2ALIGNED(sp_unaligned)) {
			sp = sp_unaligned;
		}

		<span class="enscript-comment">/* udpate offsets */</span>
		sn += len;
		dn += len;
		
		<span class="enscript-comment">/* find the next source block */</span>
		<span class="enscript-keyword">while</span> (s &amp;&amp; sn &gt;= s-&gt;m_len) {
			sn -= s-&gt;m_len;
			soff += s-&gt;m_len;
			s = s-&gt;m_next;
		}
	}

	<span class="enscript-comment">/* free un-needed source mbufs and add dest mbufs to chain */</span>
	m_freem(scut-&gt;m_next);
	scut-&gt;m_len = scutoff;
	scut-&gt;m_next = d0;

	<span class="enscript-comment">// free memory
</span>	<span class="enscript-keyword">if</span> (sp_aligned != NULL) {
		FREE(sp_aligned, M_SECA);
		sp_aligned = NULL;
	}
	
	<span class="enscript-comment">/* just in case */</span>
	bzero(iv, <span class="enscript-keyword">sizeof</span>(iv));

	<span class="enscript-keyword">return</span> 0;
}
</pre>
<hr />
</body></html>