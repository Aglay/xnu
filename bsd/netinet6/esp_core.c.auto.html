<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>esp_core.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">esp_core.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$FreeBSD: src/sys/netinet6/esp_core.c,v 1.1.2.4 2002/03/26 10:12:29 ume Exp $	*/</span>
<span class="enscript-comment">/*	$KAME: esp_core.c,v 1.50 2000/11/02 12:27:38 itojun Exp $	*/</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_IP_VHL</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ah.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ah6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp_rijndael.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pfkeyv2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/keydb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/crypto/des.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_LAYER_BEG</span>		NETDBG_CODE(DBG_NETIPSEC, 1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_LAYER_END</span>		NETDBG_CODE(DBG_NETIPSEC, 3)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_FNC_ESPAUTH</span>		NETDBG_CODE(DBG_NETIPSEC, (8 &lt;&lt; 8))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_SBUF_LEN</span>            2000

<span class="enscript-type">extern</span> lck_mtx_t *sadb_mutex;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_null_mature</span>(<span class="enscript-type">struct</span> secasvar *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_null_decrypt</span>(<span class="enscript-type">struct</span> mbuf *, size_t,
	<span class="enscript-type">struct</span> secasvar *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_null_encrypt</span>(<span class="enscript-type">struct</span> mbuf *, size_t, size_t,
	<span class="enscript-type">struct</span> secasvar *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_descbc_mature</span>(<span class="enscript-type">struct</span> secasvar *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_descbc_ivlen</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *,
	<span class="enscript-type">struct</span> secasvar *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_des_schedule</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *,
	<span class="enscript-type">struct</span> secasvar *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_des_schedlen</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_des_blockdecrypt</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *,
	<span class="enscript-type">struct</span> secasvar *, u_int8_t *, u_int8_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_des_blockencrypt</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *,
	<span class="enscript-type">struct</span> secasvar *, u_int8_t *, u_int8_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_cbc_mature</span>(<span class="enscript-type">struct</span> secasvar *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_3des_schedule</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *,
	<span class="enscript-type">struct</span> secasvar *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_3des_schedlen</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_3des_blockdecrypt</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *,
	<span class="enscript-type">struct</span> secasvar *, u_int8_t *, u_int8_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_3des_blockencrypt</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *,
	<span class="enscript-type">struct</span> secasvar *, u_int8_t *, u_int8_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_common_ivlen</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *,
	<span class="enscript-type">struct</span> secasvar *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_cbc_decrypt</span>(<span class="enscript-type">struct</span> mbuf *, size_t,
	<span class="enscript-type">struct</span> secasvar *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_cbc_encrypt</span>(<span class="enscript-type">struct</span> mbuf *, size_t, size_t,
	<span class="enscript-type">struct</span> secasvar *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">esp_gcm_mature</span>(<span class="enscript-type">struct</span> secasvar *);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAXIVLEN</span>	16

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ESP_AESGCM_KEYLEN128</span> 160 // 16-bytes key + 4 bytes salt
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ESP_AESGCM_KEYLEN192</span> 224 // 24-bytes key + 4 bytes salt
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ESP_AESGCM_KEYLEN256</span> 288 // 32-bytes key + 4 bytes salt

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm des_cbc =
	{ 8, -1, esp_descbc_mature, 64, 64, esp_des_schedlen,
		<span class="enscript-string">&quot;des-cbc&quot;</span>,
		esp_descbc_ivlen, esp_cbc_decrypt,
		esp_cbc_encrypt, esp_des_schedule,
		esp_des_blockdecrypt, esp_des_blockencrypt,
	        0, 0, 0 };
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm des3_cbc =
	{ 8, 8, esp_cbc_mature, 192, 192, esp_3des_schedlen,
		<span class="enscript-string">&quot;3des-cbc&quot;</span>,
		esp_common_ivlen, esp_cbc_decrypt,
		esp_cbc_encrypt, esp_3des_schedule,
	        esp_3des_blockdecrypt, esp_3des_blockencrypt,
	        0, 0, 0 };
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm null_esp =
	{ 1, 0, esp_null_mature, 0, 2048, 0, <span class="enscript-string">&quot;null&quot;</span>,
		esp_common_ivlen, esp_null_decrypt,
	        esp_null_encrypt, NULL, NULL, NULL,
	        0, 0, 0 };
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm aes_cbc =
	{ 16, 16, esp_cbc_mature, 128, 256, esp_aes_schedlen,
		<span class="enscript-string">&quot;aes-cbc&quot;</span>,
		esp_common_ivlen, esp_cbc_decrypt_aes,
		esp_cbc_encrypt_aes, esp_aes_schedule,
	        0, 0,
	        0, 0, 0 };
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm aes_gcm =
	{ 4, 8, esp_gcm_mature, ESP_AESGCM_KEYLEN128, ESP_AESGCM_KEYLEN256, esp_gcm_schedlen,
		<span class="enscript-string">&quot;aes-gcm&quot;</span>,
		esp_common_ivlen, esp_gcm_decrypt_aes,
		esp_gcm_encrypt_aes, esp_gcm_schedule,
	        0, 0,
	        16, esp_gcm_decrypt_finalize, esp_gcm_encrypt_finalize};

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *esp_algorithms[] = {
	&amp;des_cbc,
	&amp;des3_cbc,
	&amp;null_esp,
	&amp;aes_cbc,
	&amp;aes_gcm,
};

<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *
<span class="enscript-function-name">esp_algorithm_lookup</span>(idx)
	<span class="enscript-type">int</span> idx;
{
	<span class="enscript-keyword">switch</span> (idx) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EALG_DESCBC</span>:
		<span class="enscript-keyword">return</span> &amp;des_cbc;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EALG_3DESCBC</span>:
		<span class="enscript-keyword">return</span> &amp;des3_cbc;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EALG_NULL</span>:
		<span class="enscript-keyword">return</span> &amp;null_esp;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EALG_RIJNDAELCBC</span>:
		<span class="enscript-keyword">return</span> &amp;aes_cbc;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EALG_AES_GCM</span>:
		<span class="enscript-keyword">return</span> &amp;aes_gcm;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> NULL;
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">esp_max_ivlen</span>()
{
	<span class="enscript-type">int</span> idx;
	<span class="enscript-type">int</span> ivlen;

	ivlen = 0;
	<span class="enscript-keyword">for</span> (idx = 0; idx &lt; <span class="enscript-keyword">sizeof</span>(esp_algorithms)/<span class="enscript-keyword">sizeof</span>(esp_algorithms[0]);
	     idx++) {
		<span class="enscript-keyword">if</span> (esp_algorithms[idx]-&gt;ivlenval &gt; ivlen)
			ivlen = esp_algorithms[idx]-&gt;ivlenval;
	}

	<span class="enscript-keyword">return</span> ivlen;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">esp_schedule</span>(algo, sav)
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo;
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* check for key length */</span>
	<span class="enscript-keyword">if</span> (_KEYBITS(sav-&gt;key_enc) &lt; algo-&gt;keymin ||
	    _KEYBITS(sav-&gt;key_enc) &gt; algo-&gt;keymax) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;esp_schedule %s: unsupported key length %d: &quot;</span>
		    <span class="enscript-string">&quot;needs %d to %d bits\n&quot;</span>, algo-&gt;name, _KEYBITS(sav-&gt;key_enc),
		    algo-&gt;keymin, algo-&gt;keymax));
		<span class="enscript-keyword">return</span> EINVAL;
	}

	lck_mtx_lock(sadb_mutex);
	<span class="enscript-comment">/* already allocated */</span>
	<span class="enscript-keyword">if</span> (sav-&gt;sched &amp;&amp; sav-&gt;schedlen != 0) {
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-comment">/* no schedule necessary */</span>
	<span class="enscript-keyword">if</span> (!algo-&gt;schedule || !algo-&gt;schedlen) {
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> 0;
	}
        
	sav-&gt;schedlen = (*algo-&gt;schedlen)(algo);
	<span class="enscript-keyword">if</span> ((<span class="enscript-type">signed</span>) sav-&gt;schedlen &lt; 0) {
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> EINVAL;
	}

<span class="enscript-comment">//#### that malloc should be replaced by a saved buffer...
</span>	sav-&gt;sched = _MALLOC(sav-&gt;schedlen, M_SECA, M_DONTWAIT);
	<span class="enscript-keyword">if</span> (!sav-&gt;sched) {
		sav-&gt;schedlen = 0;
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> ENOBUFS;
	}

	error = (*algo-&gt;schedule)(algo, sav);
	<span class="enscript-keyword">if</span> (error) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_schedule %s: error %d\n&quot;</span>,
		    algo-&gt;name, error));
		bzero(sav-&gt;sched, sav-&gt;schedlen);
		FREE(sav-&gt;sched, M_SECA);
		sav-&gt;sched = NULL;
		sav-&gt;schedlen = 0;
	}
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_null_mature</span>(
	__unused <span class="enscript-type">struct</span> secasvar *sav)
{

	<span class="enscript-comment">/* anything is okay */</span>
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_null_decrypt</span>(
	__unused <span class="enscript-type">struct</span> mbuf *m,
	__unused size_t off,		<span class="enscript-comment">/* offset to ESP header */</span>
	__unused <span class="enscript-type">struct</span> secasvar *sav,
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo,
	__unused <span class="enscript-type">int</span> ivlen)
{

	<span class="enscript-keyword">return</span> 0; <span class="enscript-comment">/* do nothing */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_null_encrypt</span>(
	__unused <span class="enscript-type">struct</span> mbuf *m,
	__unused size_t off,	<span class="enscript-comment">/* offset to ESP header */</span>
	__unused size_t plen,	<span class="enscript-comment">/* payload length (to be encrypted) */</span>
	__unused <span class="enscript-type">struct</span> secasvar *sav,
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo,
	__unused <span class="enscript-type">int</span> ivlen)
{

	<span class="enscript-keyword">return</span> 0; <span class="enscript-comment">/* do nothing */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_descbc_mature</span>(sav)
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo;

	<span class="enscript-keyword">if</span> (!(sav-&gt;flags &amp; SADB_X_EXT_OLD) &amp;&amp; (sav-&gt;flags &amp; SADB_X_EXT_IV4B)) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_mature: &quot;</span>
		    <span class="enscript-string">&quot;algorithm incompatible with 4 octets IV length\n&quot;</span>));
		<span class="enscript-keyword">return</span> 1;
	}

	<span class="enscript-keyword">if</span> (!sav-&gt;key_enc) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_descbc_mature: no key is given.\n&quot;</span>));
		<span class="enscript-keyword">return</span> 1;
	}

	algo = esp_algorithm_lookup(sav-&gt;alg_enc);
	<span class="enscript-keyword">if</span> (!algo) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;esp_descbc_mature: unsupported algorithm.\n&quot;</span>));
		<span class="enscript-keyword">return</span> 1;
	}

	<span class="enscript-keyword">if</span> (_KEYBITS(sav-&gt;key_enc) &lt; algo-&gt;keymin ||
	    _KEYBITS(sav-&gt;key_enc) &gt; algo-&gt;keymax) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;esp_descbc_mature: invalid key length %d.\n&quot;</span>,
		    _KEYBITS(sav-&gt;key_enc)));
		<span class="enscript-keyword">return</span> 1;
	}

	<span class="enscript-comment">/* weak key check */</span>
	<span class="enscript-keyword">if</span> (des_is_weak_key((des_cblock *)_KEYBUF(sav-&gt;key_enc))) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;esp_descbc_mature: weak key was passed.\n&quot;</span>));
		<span class="enscript-keyword">return</span> 1;
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_descbc_ivlen</span>(
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo,
	<span class="enscript-type">struct</span> secasvar *sav)
{

	<span class="enscript-keyword">if</span> (!sav)
		<span class="enscript-keyword">return</span> 8;
	<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_OLD) &amp;&amp; (sav-&gt;flags &amp; SADB_X_EXT_IV4B))
		<span class="enscript-keyword">return</span> 4;
	<span class="enscript-keyword">if</span> (!(sav-&gt;flags &amp; SADB_X_EXT_OLD) &amp;&amp; (sav-&gt;flags &amp; SADB_X_EXT_DERIV))
		<span class="enscript-keyword">return</span> 4;
	<span class="enscript-keyword">return</span> 8;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_des_schedlen</span>(
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo)
{
	<span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span>(des_ecb_key_schedule);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_des_schedule</span>(
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo,
	<span class="enscript-type">struct</span> secasvar *sav)
{

	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);
	<span class="enscript-keyword">if</span> (des_ecb_key_sched((des_cblock *)_KEYBUF(sav-&gt;key_enc),
	    (des_ecb_key_schedule *)sav-&gt;sched))
		<span class="enscript-keyword">return</span> EINVAL;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_des_blockdecrypt</span>(
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo,
	<span class="enscript-type">struct</span> secasvar *sav,
	u_int8_t *s,
	u_int8_t *d)
{
	<span class="enscript-comment">/* assumption: d has a good alignment */</span>
	bcopy(s, d, <span class="enscript-keyword">sizeof</span>(DES_LONG) * 2);
	des_ecb_encrypt((des_cblock *)d, (des_cblock *)d,
	    (des_ecb_key_schedule *)sav-&gt;sched, DES_DECRYPT);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_des_blockencrypt</span>(
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo,
	<span class="enscript-type">struct</span> secasvar *sav,
	u_int8_t *s,
	u_int8_t *d)
{
	<span class="enscript-comment">/* assumption: d has a good alignment */</span>
	bcopy(s, d, <span class="enscript-keyword">sizeof</span>(DES_LONG) * 2);
	des_ecb_encrypt((des_cblock *)d, (des_cblock *)d,
	    (des_ecb_key_schedule *)sav-&gt;sched, DES_ENCRYPT);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_cbc_mature</span>(sav)
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">int</span> keylen;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo;

	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_OLD) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;esp_cbc_mature: algorithm incompatible with esp-old\n&quot;</span>));
		<span class="enscript-keyword">return</span> 1;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_DERIV) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;esp_cbc_mature: algorithm incompatible with derived\n&quot;</span>));
		<span class="enscript-keyword">return</span> 1;
	}

	<span class="enscript-keyword">if</span> (!sav-&gt;key_enc) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_mature: no key is given.\n&quot;</span>));
		<span class="enscript-keyword">return</span> 1;
	}

	algo = esp_algorithm_lookup(sav-&gt;alg_enc);
	<span class="enscript-keyword">if</span> (!algo) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;esp_cbc_mature: unsupported algorithm.\n&quot;</span>));
		<span class="enscript-keyword">return</span> 1;
	}

	keylen = sav-&gt;key_enc-&gt;sadb_key_bits;
	<span class="enscript-keyword">if</span> (keylen &lt; algo-&gt;keymin || algo-&gt;keymax &lt; keylen) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;esp_cbc_mature %s: invalid key length %d.\n&quot;</span>,
		    algo-&gt;name, sav-&gt;key_enc-&gt;sadb_key_bits));
		<span class="enscript-keyword">return</span> 1;
	}
	<span class="enscript-keyword">switch</span> (sav-&gt;alg_enc) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_EALG_3DESCBC</span>:
		<span class="enscript-comment">/* weak key check */</span>
		<span class="enscript-keyword">if</span> (des_is_weak_key((des_cblock *)_KEYBUF(sav-&gt;key_enc)) ||
		    des_is_weak_key((des_cblock *)(_KEYBUF(sav-&gt;key_enc) + 8)) ||
		    des_is_weak_key((des_cblock *)(_KEYBUF(sav-&gt;key_enc) + 16))) {
			ipseclog((LOG_ERR,
			    <span class="enscript-string">&quot;esp_cbc_mature %s: weak key was passed.\n&quot;</span>,
			    algo-&gt;name));
			<span class="enscript-keyword">return</span> 1;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EALG_RIJNDAELCBC</span>:
		<span class="enscript-comment">/* allows specific key sizes only */</span>
		<span class="enscript-keyword">if</span> (!(keylen == 128 || keylen == 192 || keylen == 256)) {
			ipseclog((LOG_ERR,
			    <span class="enscript-string">&quot;esp_cbc_mature %s: invalid key length %d.\n&quot;</span>,
			    algo-&gt;name, keylen));
			<span class="enscript-keyword">return</span> 1;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_gcm_mature</span>(sav)
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">int</span> keylen;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo;

	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_OLD) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;esp_gcm_mature: algorithm incompatible with esp-old\n&quot;</span>));
		<span class="enscript-keyword">return</span> 1;
	}
	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_DERIV) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;esp_gcm_mature: algorithm incompatible with derived\n&quot;</span>));
		<span class="enscript-keyword">return</span> 1;
	}

	<span class="enscript-keyword">if</span> (!sav-&gt;key_enc) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_gcm_mature: no key is given.\n&quot;</span>));
		<span class="enscript-keyword">return</span> 1;
	}

	algo = esp_algorithm_lookup(sav-&gt;alg_enc);
	<span class="enscript-keyword">if</span> (!algo) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;esp_gcm_mature: unsupported algorithm.\n&quot;</span>));
		<span class="enscript-keyword">return</span> 1;
	}

	keylen = sav-&gt;key_enc-&gt;sadb_key_bits;
	<span class="enscript-keyword">if</span> (keylen &lt; algo-&gt;keymin || algo-&gt;keymax &lt; keylen) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;esp_gcm_mature %s: invalid key length %d.\n&quot;</span>,
		    algo-&gt;name, sav-&gt;key_enc-&gt;sadb_key_bits));
		<span class="enscript-keyword">return</span> 1;
	}
	<span class="enscript-keyword">switch</span> (sav-&gt;alg_enc) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SADB_X_EALG_AES_GCM</span>:
		<span class="enscript-comment">/* allows specific key sizes only */</span>
		<span class="enscript-keyword">if</span> (!(keylen == ESP_AESGCM_KEYLEN128 || keylen == ESP_AESGCM_KEYLEN192 || keylen == ESP_AESGCM_KEYLEN256)) {
			ipseclog((LOG_ERR,
			    <span class="enscript-string">&quot;esp_gcm_mature %s: invalid key length %d.\n&quot;</span>,
			    algo-&gt;name, keylen));
			<span class="enscript-keyword">return</span> 1;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		ipseclog((LOG_ERR,
			  <span class="enscript-string">&quot;esp_gcm_mature %s: invalid algo %d.\n&quot;</span>, sav-&gt;alg_enc));
		<span class="enscript-keyword">return</span> 1;
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_3des_schedlen</span>(
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo)
{

	<span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span>(des3_ecb_key_schedule);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_3des_schedule</span>(
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo,
	<span class="enscript-type">struct</span> secasvar *sav)
{
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (des3_ecb_key_sched((des_cblock *)_KEYBUF(sav-&gt;key_enc),
	    (des3_ecb_key_schedule *)sav-&gt;sched))
		<span class="enscript-keyword">return</span> EINVAL;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_3des_blockdecrypt</span>(
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo,
	<span class="enscript-type">struct</span> secasvar *sav,
	u_int8_t *s,
	u_int8_t *d)
{
	<span class="enscript-comment">/* assumption: d has a good alignment */</span>
	bcopy(s, d, <span class="enscript-keyword">sizeof</span>(DES_LONG) * 2);
	des3_ecb_encrypt((des_cblock *)d, (des_cblock *)d,
			 (des3_ecb_key_schedule *)sav-&gt;sched, DES_DECRYPT);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_3des_blockencrypt</span>(
	__unused <span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo,
	<span class="enscript-type">struct</span> secasvar *sav,
	u_int8_t *s,
	u_int8_t *d)
{
	<span class="enscript-comment">/* assumption: d has a good alignment */</span>
	bcopy(s, d, <span class="enscript-keyword">sizeof</span>(DES_LONG) * 2);
	des3_ecb_encrypt((des_cblock *)d, (des_cblock *)d,
			 (des3_ecb_key_schedule *)sav-&gt;sched, DES_ENCRYPT);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_common_ivlen</span>(
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo,
	__unused <span class="enscript-type">struct</span> secasvar *sav)
{

	<span class="enscript-keyword">if</span> (!algo)
		panic(<span class="enscript-string">&quot;esp_common_ivlen: unknown algorithm&quot;</span>);
	<span class="enscript-keyword">return</span> algo-&gt;ivlenval;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_cbc_decrypt</span>(m, off, sav, algo, ivlen)
	<span class="enscript-type">struct</span> mbuf *m;
	size_t off;
	<span class="enscript-type">struct</span> secasvar *sav;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo;
	<span class="enscript-type">int</span> ivlen;
{
	<span class="enscript-type">struct</span> mbuf *s;
	<span class="enscript-type">struct</span> mbuf *d, *d0, *dp;
	<span class="enscript-type">int</span> soff, doff;	<span class="enscript-comment">/* offset from the head of chain, to head of this mbuf */</span>
	<span class="enscript-type">int</span> sn, dn;	<span class="enscript-comment">/* offset from the head of the mbuf, to meat */</span>
	size_t ivoff, bodyoff;
	u_int8_t iv[MAXIVLEN] __attribute__((aligned(4))), *ivp;
	u_int8_t *sbuf = NULL, *sp, *sp_unaligned;
	u_int8_t *p, *q;
	<span class="enscript-type">struct</span> mbuf *scut;
	<span class="enscript-type">int</span> scutoff;
	<span class="enscript-type">int</span> i, result = 0;
	<span class="enscript-type">int</span> blocklen;
	<span class="enscript-type">int</span> derived;

	<span class="enscript-keyword">if</span> (ivlen != sav-&gt;ivlen || ivlen &gt; <span class="enscript-keyword">sizeof</span>(iv)) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_decrypt %s: &quot;</span>
		    <span class="enscript-string">&quot;unsupported ivlen %d\n&quot;</span>, algo-&gt;name, ivlen));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* assumes blocklen == padbound */</span>
	blocklen = algo-&gt;padbound;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (blocklen &gt; <span class="enscript-keyword">sizeof</span>(iv)) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_decrypt %s: &quot;</span>
		    <span class="enscript-string">&quot;unsupported blocklen %d\n&quot;</span>, algo-&gt;name, blocklen));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_OLD) {
		<span class="enscript-comment">/* RFC 1827 */</span>
		ivoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp);
		bodyoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp) + ivlen;
		derived = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* RFC 2406 */</span>
		<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_DERIV) {
			<span class="enscript-comment">/*
			 * draft-ietf-ipsec-ciph-des-derived-00.txt
			 * uses sequence number field as IV field.
			 */</span>
			ivoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp);
			bodyoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp) + <span class="enscript-keyword">sizeof</span>(u_int32_t);
			ivlen = <span class="enscript-keyword">sizeof</span>(u_int32_t);
			derived = 1;
		} <span class="enscript-keyword">else</span> {
			ivoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newesp);
			bodyoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newesp) + ivlen;
			derived = 0;
		}
	}

	<span class="enscript-comment">/* grab iv */</span>
	m_copydata(m, ivoff, ivlen, (caddr_t) iv);

	<span class="enscript-comment">/* extend iv */</span>
	<span class="enscript-keyword">if</span> (ivlen == blocklen)
		;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ivlen == 4 &amp;&amp; blocklen == 8) {
		bcopy(&amp;iv[0], &amp;iv[4], 4);
		iv[4] ^= 0xff;
		iv[5] ^= 0xff;
		iv[6] ^= 0xff;
		iv[7] ^= 0xff;
	} <span class="enscript-keyword">else</span> {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_encrypt %s: &quot;</span>
		    <span class="enscript-string">&quot;unsupported ivlen/blocklen: %d %d\n&quot;</span>,
		    algo-&gt;name, ivlen, blocklen));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; bodyoff) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_decrypt %s: bad len %d/%lu\n&quot;</span>,
		    algo-&gt;name, m-&gt;m_pkthdr.len, (u_int32_t)bodyoff));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.len - bodyoff) % blocklen) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_decrypt %s: &quot;</span>
		    <span class="enscript-string">&quot;payload length must be multiple of %d\n&quot;</span>,
		    algo-&gt;name, blocklen));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	s = m;
	d = d0 = dp = NULL;
	soff = doff = sn = dn = 0;
	ivp = sp = NULL;

	<span class="enscript-comment">/* skip bodyoff */</span>
	<span class="enscript-keyword">while</span> (soff &lt; bodyoff) {
		<span class="enscript-keyword">if</span> (soff + s-&gt;m_len &gt; bodyoff) {
			sn = bodyoff - soff;
			<span class="enscript-keyword">break</span>;
		}

		soff += s-&gt;m_len;
		s = s-&gt;m_next;
	}
	scut = s;
	scutoff = sn;

	<span class="enscript-comment">/* skip over empty mbuf */</span>
	<span class="enscript-keyword">while</span> (s &amp;&amp; s-&gt;m_len == 0)
		s = s-&gt;m_next;

	<span class="enscript-comment">// Allocate blocksized buffer for unaligned or non-contiguous access
</span>	sbuf = (u_int8_t *)_MALLOC(blocklen, M_SECA, M_DONTWAIT);
	<span class="enscript-keyword">if</span> (sbuf == NULL)
		<span class="enscript-keyword">return</span> ENOBUFS;
	<span class="enscript-keyword">while</span> (soff &lt; m-&gt;m_pkthdr.len) {
		<span class="enscript-comment">/* source */</span>
		<span class="enscript-keyword">if</span> (sn + blocklen &lt;= s-&gt;m_len) {
			<span class="enscript-comment">/* body is continuous */</span>
			sp = mtod(s, u_int8_t *) + sn;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* body is non-continuous */</span>
			m_copydata(s, sn, blocklen, (caddr_t) sbuf);
			sp = sbuf;
		}

		<span class="enscript-comment">/* destination */</span>
		<span class="enscript-keyword">if</span> (!d || dn + blocklen &gt; d-&gt;m_len) {
			<span class="enscript-keyword">if</span> (d)
				dp = d;
			MGET(d, M_DONTWAIT, MT_DATA);
			i = m-&gt;m_pkthdr.len - (soff + sn);
			<span class="enscript-keyword">if</span> (d &amp;&amp; i &gt; MLEN) {
				MCLGET(d, M_DONTWAIT);
				<span class="enscript-keyword">if</span> ((d-&gt;m_flags &amp; M_EXT) == 0) {
					m_free(d);
					d = NULL;
				}
			}
			<span class="enscript-keyword">if</span> (!d) {
				m_freem(m);
				<span class="enscript-keyword">if</span> (d0)
					m_freem(d0);
				result = ENOBUFS;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
			}
			<span class="enscript-keyword">if</span> (!d0)
				d0 = d;
			<span class="enscript-keyword">if</span> (dp)
				dp-&gt;m_next = d;

			<span class="enscript-comment">// try to make mbuf data aligned
</span>			<span class="enscript-keyword">if</span> (!IPSEC_IS_P2ALIGNED(d-&gt;m_data)) {
				m_adj(d, IPSEC_GET_P2UNALIGNED_OFS(d-&gt;m_data));
			}

			d-&gt;m_len = 0;
			d-&gt;m_len = (M_TRAILINGSPACE(d) / blocklen) * blocklen;
			<span class="enscript-keyword">if</span> (d-&gt;m_len &gt; i)
				d-&gt;m_len = i;
			dn = 0;
		}

		<span class="enscript-comment">/* decrypt */</span>
		<span class="enscript-comment">// check input pointer alignment and use a separate aligned buffer (if sp is unaligned on 4-byte boundary).
</span>		<span class="enscript-keyword">if</span> (IPSEC_IS_P2ALIGNED(sp)) {
			sp_unaligned = NULL;
		} <span class="enscript-keyword">else</span> {
			sp_unaligned = sp;
			sp = sbuf;
			memcpy(sp, sp_unaligned, blocklen);
		}
		<span class="enscript-comment">// no need to check output pointer alignment
</span>		(*algo-&gt;blockdecrypt)(algo, sav, sp, mtod(d, u_int8_t *) + dn);

		<span class="enscript-comment">// update unaligned pointers
</span>		<span class="enscript-keyword">if</span> (!IPSEC_IS_P2ALIGNED(sp_unaligned)) {
			sp = sp_unaligned;
		}

		<span class="enscript-comment">/* xor */</span>
		p = ivp ? ivp : iv;
		q = mtod(d, u_int8_t *) + dn;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; blocklen; i++)
			q[i] ^= p[i];

		<span class="enscript-comment">/* next iv */</span>
		<span class="enscript-keyword">if</span> (sp == sbuf) {
			bcopy(sbuf, iv, blocklen);
			ivp = NULL;
		} <span class="enscript-keyword">else</span>
			ivp = sp;

		sn += blocklen;
		dn += blocklen;

		<span class="enscript-comment">/* find the next source block */</span>
		<span class="enscript-keyword">while</span> (s &amp;&amp; sn &gt;= s-&gt;m_len) {
			sn -= s-&gt;m_len;
			soff += s-&gt;m_len;
			s = s-&gt;m_next;
		}
	}

	m_freem(scut-&gt;m_next);
	scut-&gt;m_len = scutoff;
	scut-&gt;m_next = d0;

	<span class="enscript-comment">/* just in case */</span>
	bzero(iv, <span class="enscript-keyword">sizeof</span>(iv));
	bzero(sbuf, blocklen);
<span class="enscript-reference">end</span>:
	<span class="enscript-keyword">if</span> (sbuf != NULL)
		FREE(sbuf, M_SECA);
	<span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">esp_cbc_encrypt</span>(
	<span class="enscript-type">struct</span> mbuf *m,
	size_t off,
	__unused size_t plen,
	<span class="enscript-type">struct</span> secasvar *sav,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> esp_algorithm *algo,
	<span class="enscript-type">int</span> ivlen)
{
	<span class="enscript-type">struct</span> mbuf *s;
	<span class="enscript-type">struct</span> mbuf *d, *d0, *dp;
	<span class="enscript-type">int</span> soff, doff;	<span class="enscript-comment">/* offset from the head of chain, to head of this mbuf */</span>
	<span class="enscript-type">int</span> sn, dn;	<span class="enscript-comment">/* offset from the head of the mbuf, to meat */</span>
	size_t ivoff, bodyoff;
	u_int8_t iv[MAXIVLEN] __attribute__((aligned(4))), *ivp;
	u_int8_t *sbuf = NULL, *sp, *sp_unaligned;
	u_int8_t *p, *q;
	<span class="enscript-type">struct</span> mbuf *scut;
	<span class="enscript-type">int</span> scutoff;
	<span class="enscript-type">int</span> i, result = 0;
	<span class="enscript-type">int</span> blocklen;
	<span class="enscript-type">int</span> derived;

	<span class="enscript-keyword">if</span> (ivlen != sav-&gt;ivlen || ivlen &gt; <span class="enscript-keyword">sizeof</span>(iv)) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_encrypt %s: &quot;</span>
		    <span class="enscript-string">&quot;unsupported ivlen %d\n&quot;</span>, algo-&gt;name, ivlen));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* assumes blocklen == padbound */</span>
	blocklen = algo-&gt;padbound;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (blocklen &gt; <span class="enscript-keyword">sizeof</span>(iv)) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_encrypt %s: &quot;</span>
		    <span class="enscript-string">&quot;unsupported blocklen %d\n&quot;</span>, algo-&gt;name, blocklen));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_OLD) {
		<span class="enscript-comment">/* RFC 1827 */</span>
		ivoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp);
		bodyoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp) + ivlen;
		derived = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* RFC 2406 */</span>
		<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_DERIV) {
			<span class="enscript-comment">/*
			 * draft-ietf-ipsec-ciph-des-derived-00.txt
			 * uses sequence number field as IV field.
			 */</span>
			ivoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp);
			bodyoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> esp) + <span class="enscript-keyword">sizeof</span>(u_int32_t);
			ivlen = <span class="enscript-keyword">sizeof</span>(u_int32_t);
			derived = 1;
		} <span class="enscript-keyword">else</span> {
			ivoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newesp);
			bodyoff = off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newesp) + ivlen;
			derived = 0;
		}
	}

	<span class="enscript-comment">/* put iv into the packet.  if we are in derived mode, use seqno. */</span>
	<span class="enscript-keyword">if</span> (derived)
		m_copydata(m, ivoff, ivlen, (caddr_t) iv);
	<span class="enscript-keyword">else</span> {
		bcopy(sav-&gt;iv, iv, ivlen);
		<span class="enscript-comment">/* maybe it is better to overwrite dest, not source */</span>
		m_copyback(m, ivoff, ivlen, (caddr_t) iv);
	}

	<span class="enscript-comment">/* extend iv */</span>
	<span class="enscript-keyword">if</span> (ivlen == blocklen)
		;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ivlen == 4 &amp;&amp; blocklen == 8) {
		bcopy(&amp;iv[0], &amp;iv[4], 4);
		iv[4] ^= 0xff;
		iv[5] ^= 0xff;
		iv[6] ^= 0xff;
		iv[7] ^= 0xff;
	} <span class="enscript-keyword">else</span> {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_encrypt %s: &quot;</span>
		    <span class="enscript-string">&quot;unsupported ivlen/blocklen: %d %d\n&quot;</span>,
		    algo-&gt;name, ivlen, blocklen));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; bodyoff) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_encrypt %s: bad len %d/%lu\n&quot;</span>,
		    algo-&gt;name, m-&gt;m_pkthdr.len, (u_int32_t)bodyoff));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.len - bodyoff) % blocklen) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_cbc_encrypt %s: &quot;</span>
		    <span class="enscript-string">&quot;payload length must be multiple of %lu\n&quot;</span>,
		    algo-&gt;name, (u_int32_t)algo-&gt;padbound));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	s = m;
	d = d0 = dp = NULL;
	soff = doff = sn = dn = 0;
	ivp = sp = NULL;

	<span class="enscript-comment">/* skip bodyoff */</span>
	<span class="enscript-keyword">while</span> (soff &lt; bodyoff) {
		<span class="enscript-keyword">if</span> (soff + s-&gt;m_len &gt; bodyoff) {
			sn = bodyoff - soff;
			<span class="enscript-keyword">break</span>;
		}

		soff += s-&gt;m_len;
		s = s-&gt;m_next;
	}
	scut = s;
	scutoff = sn;

	<span class="enscript-comment">/* skip over empty mbuf */</span>
	<span class="enscript-keyword">while</span> (s &amp;&amp; s-&gt;m_len == 0)
		s = s-&gt;m_next;

	<span class="enscript-comment">// Allocate blocksized buffer for unaligned or non-contiguous access
</span>        sbuf = (u_int8_t *)_MALLOC(blocklen, M_SECA, M_DONTWAIT);
        <span class="enscript-keyword">if</span> (sbuf == NULL)
                <span class="enscript-keyword">return</span> ENOBUFS;
	<span class="enscript-keyword">while</span> (soff &lt; m-&gt;m_pkthdr.len) {
		<span class="enscript-comment">/* source */</span>
		<span class="enscript-keyword">if</span> (sn + blocklen &lt;= s-&gt;m_len) {
			<span class="enscript-comment">/* body is continuous */</span>
			sp = mtod(s, u_int8_t *) + sn;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* body is non-continuous */</span>
			m_copydata(s, sn, blocklen, (caddr_t) sbuf);
			sp = sbuf;
		}

		<span class="enscript-comment">/* destination */</span>
		<span class="enscript-keyword">if</span> (!d || dn + blocklen &gt; d-&gt;m_len) {
			<span class="enscript-keyword">if</span> (d)
				dp = d;
			MGET(d, M_DONTWAIT, MT_DATA);
			i = m-&gt;m_pkthdr.len - (soff + sn);
			<span class="enscript-keyword">if</span> (d &amp;&amp; i &gt; MLEN) {
				MCLGET(d, M_DONTWAIT);
				<span class="enscript-keyword">if</span> ((d-&gt;m_flags &amp; M_EXT) == 0) {
					m_free(d);
					d = NULL;
				}
			}
			<span class="enscript-keyword">if</span> (!d) {
				m_freem(m);
				<span class="enscript-keyword">if</span> (d0)
					m_freem(d0);
				result = ENOBUFS;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
			}
			<span class="enscript-keyword">if</span> (!d0)
				d0 = d;
			<span class="enscript-keyword">if</span> (dp)
				dp-&gt;m_next = d;

			<span class="enscript-comment">// try to make mbuf data aligned
</span>			<span class="enscript-keyword">if</span> (!IPSEC_IS_P2ALIGNED(d-&gt;m_data)) {
				m_adj(d, IPSEC_GET_P2UNALIGNED_OFS(d-&gt;m_data));
			}

			d-&gt;m_len = 0;
			d-&gt;m_len = (M_TRAILINGSPACE(d) / blocklen) * blocklen;
			<span class="enscript-keyword">if</span> (d-&gt;m_len &gt; i)
				d-&gt;m_len = i;
			dn = 0;
		}

		<span class="enscript-comment">/* xor */</span>
		p = ivp ? ivp : iv;
		q = sp;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; blocklen; i++)
			q[i] ^= p[i];

		<span class="enscript-comment">/* encrypt */</span>
		<span class="enscript-comment">// check input pointer alignment and use a separate aligned buffer (if sp is not aligned on 4-byte boundary).
</span>		<span class="enscript-keyword">if</span> (IPSEC_IS_P2ALIGNED(sp)) {
			sp_unaligned = NULL;
		} <span class="enscript-keyword">else</span> {
			sp_unaligned = sp;
			sp = sbuf;
			memcpy(sp, sp_unaligned, blocklen);
		}
		<span class="enscript-comment">// no need to check output pointer alignment
</span>		(*algo-&gt;blockencrypt)(algo, sav, sp, mtod(d, u_int8_t *) + dn);

		<span class="enscript-comment">// update unaligned pointers
</span>		<span class="enscript-keyword">if</span> (!IPSEC_IS_P2ALIGNED(sp_unaligned)) {
			sp = sp_unaligned;
		}

		<span class="enscript-comment">/* next iv */</span>
		ivp = mtod(d, u_int8_t *) + dn;

		sn += blocklen;
		dn += blocklen;

		<span class="enscript-comment">/* find the next source block */</span>
		<span class="enscript-keyword">while</span> (s &amp;&amp; sn &gt;= s-&gt;m_len) {
			sn -= s-&gt;m_len;
			soff += s-&gt;m_len;
			s = s-&gt;m_next;
		}
	}

	m_freem(scut-&gt;m_next);
	scut-&gt;m_len = scutoff;
	scut-&gt;m_next = d0;

	<span class="enscript-comment">/* just in case */</span>
	bzero(iv, <span class="enscript-keyword">sizeof</span>(iv));
	bzero(sbuf, blocklen);

	key_sa_stir_iv(sav);
<span class="enscript-reference">end</span>:
	<span class="enscript-keyword">if</span> (sbuf != NULL)
		FREE(sbuf, M_SECA);
	<span class="enscript-keyword">return</span> result;
}

<span class="enscript-comment">/*------------------------------------------------------------*/</span>

<span class="enscript-comment">/* does not free m0 on error */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">esp_auth</span>(m0, skip, length, sav, sum)
	<span class="enscript-type">struct</span> mbuf *m0;
	size_t skip;	<span class="enscript-comment">/* offset to ESP header */</span>
	size_t length;	<span class="enscript-comment">/* payload length */</span>
	<span class="enscript-type">struct</span> secasvar *sav;
	u_char *sum;
{
	<span class="enscript-type">struct</span> mbuf *m;
	size_t off;
	<span class="enscript-type">struct</span> ah_algorithm_state s;
	u_char sumbuf[AH_MAXSUMSIZE] __attribute__((aligned(4)));
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ah_algorithm *algo;
	size_t siz;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* sanity checks */</span>
	<span class="enscript-keyword">if</span> (m0-&gt;m_pkthdr.len &lt; skip) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;esp_auth: mbuf length &lt; skip\n&quot;</span>));
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> (m0-&gt;m_pkthdr.len &lt; skip + length) {
		ipseclog((LOG_DEBUG,
		    <span class="enscript-string">&quot;esp_auth: mbuf length &lt; skip + length\n&quot;</span>));
		<span class="enscript-keyword">return</span> EINVAL;
	}

	KERNEL_DEBUG(DBG_FNC_ESPAUTH | DBG_FUNC_START, skip,length,0,0,0);
	<span class="enscript-comment">/*
	 * length of esp part (excluding authentication data) must be 4n,
	 * since nexthdr must be at offset 4n+3.
	 */</span>
	<span class="enscript-keyword">if</span> (length % 4) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;esp_auth: length is not multiple of 4\n&quot;</span>));
		KERNEL_DEBUG(DBG_FNC_ESPAUTH | DBG_FUNC_END, 1,0,0,0,0);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> (!sav) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;esp_auth: NULL SA passed\n&quot;</span>));
		KERNEL_DEBUG(DBG_FNC_ESPAUTH | DBG_FUNC_END, 2,0,0,0,0);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	algo = ah_algorithm_lookup(sav-&gt;alg_auth);
	<span class="enscript-keyword">if</span> (!algo) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;esp_auth: bad ESP auth algorithm passed: %d\n&quot;</span>,
		    sav-&gt;alg_auth));
		KERNEL_DEBUG(DBG_FNC_ESPAUTH | DBG_FUNC_END, 3,0,0,0,0);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	m = m0;
	off = 0;

	siz = (((*algo-&gt;sumsiz)(sav) + 3) &amp; ~(4 - 1));
	<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(sumbuf) &lt; siz) {
		ipseclog((LOG_DEBUG,
		    <span class="enscript-string">&quot;esp_auth: AH_MAXSUMSIZE is too small: siz=%lu\n&quot;</span>,
		    (u_int32_t)siz));
		KERNEL_DEBUG(DBG_FNC_ESPAUTH | DBG_FUNC_END, 4,0,0,0,0);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* skip the header */</span>
	<span class="enscript-keyword">while</span> (skip) {
		<span class="enscript-keyword">if</span> (!m)
			panic(<span class="enscript-string">&quot;mbuf chain?&quot;</span>);
		<span class="enscript-keyword">if</span> (m-&gt;m_len &lt;= skip) {
			skip -= m-&gt;m_len;
			m = m-&gt;m_next;
			off = 0;
		} <span class="enscript-keyword">else</span> {
			off = skip;
			skip = 0;
		}
	}

	error = (*algo-&gt;init)(&amp;s, sav);
	<span class="enscript-keyword">if</span> (error) {
		KERNEL_DEBUG(DBG_FNC_ESPAUTH | DBG_FUNC_END, 5,0,0,0,0);
		<span class="enscript-keyword">return</span> error;
	}
	<span class="enscript-keyword">while</span> (0 &lt; length) {
		<span class="enscript-keyword">if</span> (!m)
			panic(<span class="enscript-string">&quot;mbuf chain?&quot;</span>);

		<span class="enscript-keyword">if</span> (m-&gt;m_len - off &lt; length) {
			(*algo-&gt;update)(&amp;s, (caddr_t)(mtod(m, u_char *) + off),
				m-&gt;m_len - off);
			length -= m-&gt;m_len - off;
			m = m-&gt;m_next;
			off = 0;
		} <span class="enscript-keyword">else</span> {
			(*algo-&gt;update)(&amp;s, (caddr_t)(mtod(m, u_char *) + off), length);
			<span class="enscript-keyword">break</span>;
		}
	}
	(*algo-&gt;result)(&amp;s, (caddr_t) sumbuf, <span class="enscript-keyword">sizeof</span>(sumbuf));
	bcopy(sumbuf, sum, siz);	<span class="enscript-comment">/*XXX*/</span>
	KERNEL_DEBUG(DBG_FNC_ESPAUTH | DBG_FUNC_END, 6,0,0,0,0);
	<span class="enscript-keyword">return</span> 0;
}
</pre>
<hr />
</body></html>