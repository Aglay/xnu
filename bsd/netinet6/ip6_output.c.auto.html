<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ip6_output.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ip6_output.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ip_output.c	8.3 (Berkeley) 1/21/94
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSByteOrder.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sdt.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_perf.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/kpi_ipfilter_var.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/scope6_var.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key.h&gt;</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> ipsec_bypass;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/necp.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_fw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_fw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_dummynet.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/pfvar.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_reset_ip6_output_stats SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_ip6_output_measure_bins SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_ip6_output_getperf SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip6_copyexthdr</span>(<span class="enscript-type">struct</span> mbuf **, caddr_t, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ip6_out_cksum_stats</span>(<span class="enscript-type">int</span>, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip6_insert_jumboopt</span>(<span class="enscript-type">struct</span> ip6_exthdrs *, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip6_insertfraghdr</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>,
    <span class="enscript-type">struct</span> ip6_frag **);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip6_getpmtu</span>(<span class="enscript-type">struct</span> route_in6 *, <span class="enscript-type">struct</span> route_in6 *,
    <span class="enscript-type">struct</span> ifnet *, <span class="enscript-type">struct</span> in6_addr *, u_int32_t *, boolean_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip6_pcbopts</span>(<span class="enscript-type">struct</span> ip6_pktopts **, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> socket *,
    <span class="enscript-type">struct</span> sockopt *sopt);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip6_pcbopt</span>(<span class="enscript-type">int</span>, u_char *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> ip6_pktopts **, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip6_getpcbopt</span>(<span class="enscript-type">struct</span> ip6_pktopts *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> sockopt *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">copypktopts</span>(<span class="enscript-type">struct</span> ip6_pktopts *, <span class="enscript-type">struct</span> ip6_pktopts *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">im6o_trace</span>(<span class="enscript-type">struct</span> ip6_moptions *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip6_setpktopt</span>(<span class="enscript-type">int</span>, u_char *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> ip6_pktopts *, <span class="enscript-type">int</span>,
    <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip6_splithdr</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> ip6_exthdrs *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ip6_output_checksum</span>(<span class="enscript-type">struct</span> ifnet *, uint32_t, <span class="enscript-type">struct</span> mbuf *,
    <span class="enscript-type">int</span>, uint32_t, uint32_t);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">udp_ctloutput</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockopt *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip6_do_fragmentation</span>(<span class="enscript-type">struct</span> mbuf **morig,
    uint32_t optlen, <span class="enscript-type">struct</span> ifnet *ifp, uint32_t unfragpartlen,
    <span class="enscript-type">struct</span> ip6_hdr *ip6, <span class="enscript-type">struct</span> ip6_exthdrs *exthdrsp, uint32_t mtu,
    <span class="enscript-type">int</span> nxt0);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ip6_fragment_packet</span>(<span class="enscript-type">struct</span> mbuf **m,
    <span class="enscript-type">struct</span> ip6_pktopts *opt, <span class="enscript-type">struct</span> ip6_exthdrs *exthdrsp, <span class="enscript-type">struct</span> ifnet *ifp,
    uint32_t mtu, boolean_t alwaysfrag, uint32_t unfragpartlen,
    <span class="enscript-type">struct</span> route_in6 *ro_pmtu, <span class="enscript-type">int</span> nxt0, uint32_t optlen);

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_inet6_ip6);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ip6_output_measure = 0;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet6_ip6, OID_AUTO, output_perf,
	CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ip6_output_measure, 0, sysctl_reset_ip6_output_stats, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Do time measurement&quot;</span>);

<span class="enscript-type">static</span> uint64_t ip6_output_measure_bins = 0;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet6_ip6, OID_AUTO, output_perf_bins,
	CTLTYPE_QUAD | CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip6_output_measure_bins, 0,
	sysctl_ip6_output_measure_bins, <span class="enscript-string">&quot;I&quot;</span>,
	<span class="enscript-string">&quot;bins for chaining performance data histogram&quot;</span>);

<span class="enscript-type">static</span> net_perf_t net_perf;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet6_ip6, OID_AUTO, output_perf_data,
	CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED,
	0, 0, sysctl_ip6_output_getperf, <span class="enscript-string">&quot;S,net_perf&quot;</span>,
	<span class="enscript-string">&quot;IP6 output performance data (struct net_perf, net/net_perf.h)&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IM6O_TRACE_HIST_SIZE</span>	32	<span class="enscript-comment">/* size of trace history */</span>

<span class="enscript-comment">/* For gdb */</span>
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> im6o_trace_hist_size = IM6O_TRACE_HIST_SIZE;

<span class="enscript-type">struct</span> ip6_moptions_dbg {
	<span class="enscript-type">struct</span> ip6_moptions	im6o;			<span class="enscript-comment">/* ip6_moptions */</span>
	u_int16_t		im6o_refhold_cnt;	<span class="enscript-comment">/* # of IM6O_ADDREF */</span>
	u_int16_t		im6o_refrele_cnt;	<span class="enscript-comment">/* # of IM6O_REMREF */</span>
	<span class="enscript-comment">/*
	 * Alloc and free callers.
	 */</span>
	ctrace_t		im6o_alloc;
	ctrace_t		im6o_free;
	<span class="enscript-comment">/*
	 * Circular lists of IM6O_ADDREF and IM6O_REMREF callers.
	 */</span>
	ctrace_t		im6o_refhold[IM6O_TRACE_HIST_SIZE];
	ctrace_t		im6o_refrele[IM6O_TRACE_HIST_SIZE];
};

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> im6o_debug = 1;	<span class="enscript-comment">/* debugging (enabled) */</span>
#<span class="enscript-reference">else</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> im6o_debug;		<span class="enscript-comment">/* debugging (disabled) */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !DEBUG */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> im6o_size;		<span class="enscript-comment">/* size of zone element */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *im6o_zone;		<span class="enscript-comment">/* zone for ip6_moptions */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IM6O_ZONE_MAX</span>		64		<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IM6O_ZONE_NAME</span>		<span class="enscript-string">&quot;ip6_moptions&quot;</span>	<span class="enscript-comment">/* zone name */</span>

<span class="enscript-comment">/*
 * ip6_output() calls ip6_output_list() to do the work
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_output</span>(<span class="enscript-type">struct</span> mbuf *m0, <span class="enscript-type">struct</span> ip6_pktopts *opt,
    <span class="enscript-type">struct</span> route_in6 *ro, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> ip6_moptions *im6o,
    <span class="enscript-type">struct</span> ifnet **ifpp, <span class="enscript-type">struct</span> ip6_out_args *ip6oa)
{
	<span class="enscript-keyword">return</span> ip6_output_list(m0, 0, opt, ro, flags, im6o, ifpp, ip6oa);
}

<span class="enscript-comment">/*
 * IP6 output. Each packet in mbuf chain m contains a skeletal IP6
 * header (with pri, len, nxt, hlim, src, dst).
 * This function may modify ver and hlim only.
 * The mbuf chain containing the packet will be freed.
 * The mbuf opt, if present, will not be freed.
 *
 * If ro is non-NULL and has valid ro-&gt;ro_rt, route lookup would be
 * skipped and ro-&gt;ro_rt would be used.  Otherwise the result of route
 * lookup is stored in ro-&gt;ro_rt.
 *
 * type of &quot;mtu&quot;: rt_rmx.rmx_mtu is u_int32_t, ifnet.ifr_mtu is int, and
 * nd_ifinfo.linkmtu is u_int32_t.  so we use u_int32_t to hold largest one,
 * which is rt_rmx.rmx_mtu.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_output_list</span>(<span class="enscript-type">struct</span> mbuf *m0, <span class="enscript-type">int</span> packetchain, <span class="enscript-type">struct</span> ip6_pktopts *opt,
    <span class="enscript-type">struct</span> route_in6 *ro, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> ip6_moptions *im6o,
    <span class="enscript-type">struct</span> ifnet **ifpp, <span class="enscript-type">struct</span> ip6_out_args *ip6oa)
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	u_char *nexthdrp;
	<span class="enscript-type">struct</span> ifnet *ifp = NULL, *origifp = NULL;	<span class="enscript-comment">/* refcnt'd */</span>
	<span class="enscript-type">struct</span> ifnet **ifpp_save = ifpp;
	<span class="enscript-type">struct</span> mbuf *m, *mprev;
	<span class="enscript-type">struct</span> mbuf *sendchain = NULL, *sendchain_last = NULL;
	<span class="enscript-type">struct</span> mbuf *inputchain = NULL;
	<span class="enscript-type">int</span> nxt0;
	<span class="enscript-type">struct</span> route_in6 *ro_pmtu = NULL;
	<span class="enscript-type">struct</span> rtentry *rt = NULL;
	<span class="enscript-type">struct</span> sockaddr_in6 *dst, src_sa, dst_sa;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> in6_ifaddr *ia = NULL, *src_ia = NULL;
	u_int32_t mtu;
	boolean_t alwaysfrag = FALSE;
	u_int32_t optlen = 0, plen = 0, unfragpartlen = 0;
	<span class="enscript-type">struct</span> ip6_rthdr *rh;
	<span class="enscript-type">struct</span> in6_addr finaldst;
	ipfilter_t inject_filter_ref;
	<span class="enscript-type">struct</span> ipf_pktopts *ippo = NULL;
	<span class="enscript-type">struct</span> flowadv *adv = NULL;
	uint32_t pktcnt = 0;
	uint32_t packets_processed = 0;
	<span class="enscript-type">struct</span> timeval start_tv;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-type">struct</span> m_tag *tag;
	<span class="enscript-type">struct</span> ip6_out_args saved_ip6oa;
	<span class="enscript-type">struct</span> sockaddr_in6 dst_buf;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-type">struct</span> socket *so = NULL;
	<span class="enscript-type">struct</span> secpolicy *sp = NULL;
	<span class="enscript-type">struct</span> route_in6 *ipsec_saved_route = NULL;
	boolean_t needipsectun = FALSE;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	necp_kernel_policy_result necp_result = 0;
	necp_kernel_policy_result_parameter necp_result_parameter;
	necp_kernel_policy_id necp_matched_policy_id = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
	<span class="enscript-type">struct</span> {
		<span class="enscript-type">struct</span> ipf_pktopts ipf_pktopts;
		<span class="enscript-type">struct</span> ip6_exthdrs exthdrs;
		<span class="enscript-type">struct</span> route_in6 ip6route;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
		<span class="enscript-type">struct</span> ipsec_output_state ipsec_state;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		<span class="enscript-type">struct</span> route_in6 necp_route;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
		<span class="enscript-type">struct</span> route_in6 saved_route;
		<span class="enscript-type">struct</span> route_in6 saved_ro_pmtu;
		<span class="enscript-type">struct</span> ip_fw_args args;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
	} ip6obz;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ipf_pktopts</span>	ip6obz.ipf_pktopts
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">exthdrs</span>		ip6obz.exthdrs
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ip6route</span>	ip6obz.ip6route
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ipsec_state</span>	ip6obz.ipsec_state
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">necp_route</span>	ip6obz.necp_route
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">saved_route</span>	ip6obz.saved_route
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">saved_ro_pmtu</span>	ip6obz.saved_ro_pmtu
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">args</span>		ip6obz.args
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> {
			boolean_t select_srcif : 1;
			boolean_t hdrsplit : 1;
			boolean_t route_selected : 1;
			boolean_t dontfrag : 1;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
			boolean_t needipsec : 1;
			boolean_t noipsec : 1;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
		};
		uint32_t raw;
	} ip6obf = { .raw = 0 };

	<span class="enscript-keyword">if</span> (ip6_output_measure)
		net_perf_start_time(&amp;net_perf, &amp;start_tv);

	VERIFY(m0-&gt;m_flags &amp; M_PKTHDR);

	<span class="enscript-comment">/* zero out {saved_route, saved_ro_pmtu, ip6route, exthdrs, args} */</span>
	bzero(&amp;ip6obz, <span class="enscript-keyword">sizeof</span> (ip6obz));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-keyword">if</span> (SLIST_EMPTY(&amp;m0-&gt;m_pkthdr.tags))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">tags_done</span>;

	<span class="enscript-comment">/* Grab info from mtags prepended to the chain */</span>
	<span class="enscript-keyword">if</span> ((tag = m_tag_locate(m0, KERNEL_MODULE_TAG_ID,
	    KERNEL_TAG_TYPE_DUMMYNET, NULL)) != NULL) {
		<span class="enscript-type">struct</span> dn_pkt_tag	*dn_tag;

		<span class="enscript-comment">/*
		 * ip6_output_list() cannot handle chains of packets reinjected
		 * by dummynet. The same restriction applies to
		 * ip_output_list().
		 */</span>
		VERIFY(0 == packetchain);

		dn_tag = (<span class="enscript-type">struct</span> dn_pkt_tag *)(tag+1);
		args.fwa_pf_rule = dn_tag-&gt;dn_pf_rule;

		bcopy(&amp;dn_tag-&gt;dn_dst6, &amp;dst_buf, <span class="enscript-keyword">sizeof</span> (dst_buf));
		dst = &amp;dst_buf;
		ifp = dn_tag-&gt;dn_ifp;
		<span class="enscript-keyword">if</span> (ifp != NULL)
			ifnet_reference(ifp);
		flags = dn_tag-&gt;dn_flags;
		<span class="enscript-keyword">if</span> (dn_tag-&gt;dn_flags &amp; IPV6_OUTARGS) {
			saved_ip6oa = dn_tag-&gt;dn_ip6oa;
			ip6oa = &amp;saved_ip6oa;
		}

		saved_route = dn_tag-&gt;dn_ro6;
		ro = &amp;saved_route;
		saved_ro_pmtu = dn_tag-&gt;dn_ro6_pmtu;
		ro_pmtu = &amp;saved_ro_pmtu;
		origifp = dn_tag-&gt;dn_origifp;
		<span class="enscript-keyword">if</span> (origifp != NULL)
			ifnet_reference(origifp);
		mtu = dn_tag-&gt;dn_mtu;
		alwaysfrag = (dn_tag-&gt;dn_alwaysfrag != 0);
		unfragpartlen = dn_tag-&gt;dn_unfragpartlen;

		bcopy(&amp;dn_tag-&gt;dn_exthdrs, &amp;exthdrs, <span class="enscript-keyword">sizeof</span> (exthdrs));

		m_tag_delete(m0, tag);
	}

<span class="enscript-reference">tags_done</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

	m = m0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass == 0) {
		so = ipsec_getsocket(m);
		<span class="enscript-keyword">if</span> (so != NULL) {
			(<span class="enscript-type">void</span>) ipsec_setsocket(m, NULL);
		}
		<span class="enscript-comment">/* If packet is bound to an interface, check bound policies */</span>
		<span class="enscript-keyword">if</span> ((flags &amp; IPV6_OUTARGS) &amp;&amp;
			(ip6oa-&gt;ip6oa_flags &amp; IPOAF_BOUND_IF) &amp;&amp;
			ip6oa-&gt;ip6oa_boundif != IFSCOPE_NONE) {
			<span class="enscript-comment">/* ip6obf.noipsec is a bitfield, use temp integer */</span>
			<span class="enscript-type">int</span> noipsec = 0;

			<span class="enscript-keyword">if</span> (ipsec6_getpolicybyinterface(m, IPSEC_DIR_OUTBOUND,
				flags, ip6oa, &amp;noipsec, &amp;sp) != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

			ip6obf.noipsec = (noipsec != 0);
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
	
	ippo = &amp;ipf_pktopts;

	<span class="enscript-keyword">if</span> (ip6_doscopedroute &amp;&amp; (flags &amp; IPV6_OUTARGS)) {
		<span class="enscript-comment">/*
		 * In the forwarding case, only the ifscope value is used,
		 * as source interface selection doesn't take place.
		 */</span>
		<span class="enscript-keyword">if</span> ((ip6obf.select_srcif = (!(flags &amp; (IPV6_FORWARDING |
		    IPV6_UNSPECSRC | IPV6_FLAG_NOSRCIFSEL)) &amp;&amp;
		    (ip6oa-&gt;ip6oa_flags &amp; IP6OAF_SELECT_SRCIF))))
			ipf_pktopts.ippo_flags |= IPPOF_SELECT_SRCIF;

		<span class="enscript-keyword">if</span> ((ip6oa-&gt;ip6oa_flags &amp; IP6OAF_BOUND_IF) &amp;&amp;
		    ip6oa-&gt;ip6oa_boundif != IFSCOPE_NONE) {
			ipf_pktopts.ippo_flags |= (IPPOF_BOUND_IF |
			    (ip6oa-&gt;ip6oa_boundif &lt;&lt; IPPOF_SHIFT_IFSCOPE));
		}

		<span class="enscript-keyword">if</span> (ip6oa-&gt;ip6oa_flags &amp; IP6OAF_BOUND_SRCADDR)
			ipf_pktopts.ippo_flags |= IPPOF_BOUND_SRCADDR;
	} <span class="enscript-keyword">else</span> {
		ip6obf.select_srcif = FALSE;
		<span class="enscript-keyword">if</span> (flags &amp; IPV6_OUTARGS) {
			ip6oa-&gt;ip6oa_boundif = IFSCOPE_NONE;
			ip6oa-&gt;ip6oa_flags &amp;= ~(IP6OAF_SELECT_SRCIF |
			    IP6OAF_BOUND_IF | IP6OAF_BOUND_SRCADDR);
		}
	}

	<span class="enscript-keyword">if</span> (flags &amp; IPV6_OUTARGS) {
		<span class="enscript-keyword">if</span> (ip6oa-&gt;ip6oa_flags &amp; IP6OAF_NO_CELLULAR)
			ipf_pktopts.ippo_flags |= IPPOF_NO_IFT_CELLULAR;
		<span class="enscript-keyword">if</span> (ip6oa-&gt;ip6oa_flags &amp; IP6OAF_NO_EXPENSIVE)
			ipf_pktopts.ippo_flags |= IPPOF_NO_IFF_EXPENSIVE;
		adv = &amp;ip6oa-&gt;ip6oa_flowadv;
		adv-&gt;code = FADV_SUCCESS;
		ip6oa-&gt;ip6oa_retflags = 0;
	}

	<span class="enscript-comment">/*
	 * Clear out ifpp to be filled in after determining route. ifpp_save is
	 * used to keep old value to release reference properly and dtrace
	 * ipsec tunnel traffic properly.
	 */</span>
	<span class="enscript-keyword">if</span> (ifpp != NULL &amp;&amp; *ifpp != NULL)
		*ifpp = NULL;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	<span class="enscript-keyword">if</span> (args.fwa_pf_rule) {
		ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
		VERIFY(ro != NULL);	<span class="enscript-comment">/* ro == saved_route */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">check_with_pf</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	<span class="enscript-comment">/*
	 * Since all packets are assumed to come from same socket, necp lookup
	 * only needs to happen once per function entry.
	 */</span>
	necp_matched_policy_id = necp_ip6_output_find_policy_match(m, flags,
	    (flags &amp; IPV6_OUTARGS) ? ip6oa : NULL, &amp;necp_result,
	    &amp;necp_result_parameter);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	<span class="enscript-comment">/*
	 * If a chain was passed in, prepare for ther first iteration. For all
	 * other iterations, this work will be done at evaluateloop: label.
	 */</span>
	<span class="enscript-keyword">if</span> (packetchain) {
		<span class="enscript-comment">/*
		 * Remove m from the chain during processing to avoid
		 * accidental frees on entire list.
		 */</span>
		inputchain = m-&gt;m_nextpkt;
		m-&gt;m_nextpkt = NULL;
	}

<span class="enscript-reference">loopit</span>:
	packets_processed++;
	m-&gt;m_pkthdr.pkt_flags &amp;= ~(PKTF_LOOP|PKTF_IFAINFO);
	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	nxt0 = ip6-&gt;ip6_nxt;
	finaldst = ip6-&gt;ip6_dst;
	ip6obf.hdrsplit = FALSE;
	ro_pmtu = NULL;

	<span class="enscript-keyword">if</span> (!SLIST_EMPTY(&amp;m-&gt;m_pkthdr.tags))
		inject_filter_ref = ipf_get_inject_filter(m);
	<span class="enscript-keyword">else</span>
		inject_filter_ref = NULL;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MAKE_EXTHDR</span>(hp, mp) do {					\
	<span class="enscript-keyword">if</span> (hp != NULL) {						\
		<span class="enscript-type">struct</span> ip6_ext *eh = (<span class="enscript-type">struct</span> ip6_ext *)(hp);		\
		error = ip6_copyexthdr((mp), (caddr_t)(hp),		\
		    ((eh)-&gt;ip6e_len + 1) &lt;&lt; 3);				\
		<span class="enscript-keyword">if</span> (error)						\
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freehdrs</span>;					\
	}								\
} <span class="enscript-keyword">while</span> (0)

	<span class="enscript-keyword">if</span> (opt != NULL) {
		<span class="enscript-comment">/* Hop-by-Hop options header */</span>
		MAKE_EXTHDR(opt-&gt;ip6po_hbh, &amp;exthdrs.ip6e_hbh);
		<span class="enscript-comment">/* Destination options header(1st part) */</span>
		<span class="enscript-keyword">if</span> (opt-&gt;ip6po_rthdr) {
			<span class="enscript-comment">/*
			 * Destination options header(1st part)
			 * This only makes sense with a routing header.
			 * See Section 9.2 of RFC 3542.
			 * Disabling this part just for MIP6 convenience is
			 * a bad idea.  We need to think carefully about a
			 * way to make the advanced API coexist with MIP6
			 * options, which might automatically be inserted in
			 * the kernel.
			 */</span>
			MAKE_EXTHDR(opt-&gt;ip6po_dest1, &amp;exthdrs.ip6e_dest1);
		}
		<span class="enscript-comment">/* Routing header */</span>
		MAKE_EXTHDR(opt-&gt;ip6po_rthdr, &amp;exthdrs.ip6e_rthdr);
		<span class="enscript-comment">/* Destination options header(2nd part) */</span>
		MAKE_EXTHDR(opt-&gt;ip6po_dest2, &amp;exthdrs.ip6e_dest2);
	}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">MAKE_EXTHDR</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	<span class="enscript-keyword">if</span> (necp_matched_policy_id) {
		necp_mark_packet_from_ip(m, necp_matched_policy_id);

		<span class="enscript-keyword">switch</span> (necp_result) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_PASS</span>:
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_DROP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_SOCKET_DIVERT</span>:
			<span class="enscript-comment">/*
			 * Flow divert packets should be blocked at the IP
			 * layer.
			 */</span>
			error = EHOSTUNREACH;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freehdrs</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NECP_KERNEL_POLICY_RESULT_IP_TUNNEL</span>: {
			<span class="enscript-comment">/*
			 * Verify that the packet is being routed to the tunnel
			 */</span>
			<span class="enscript-type">struct</span> ifnet *policy_ifp =
			    necp_get_ifnet_from_result_parameter(
				&amp;necp_result_parameter);

			<span class="enscript-keyword">if</span> (policy_ifp == ifp) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (necp_packet_can_rebind_to_ifnet(m,
				    policy_ifp, (<span class="enscript-type">struct</span> route *)&amp;necp_route,
				    AF_INET6)) {
					<span class="enscript-comment">/*
					 * Set scoped index to the tunnel
					 * interface, since it is compatible
					 * with the packet. This will only work
					 * for callers who pass IPV6_OUTARGS,
					 * but that covers all of the clients
					 * we care about today.
					 */</span>
					<span class="enscript-keyword">if</span> (flags &amp; IPV6_OUTARGS) {
						ip6oa-&gt;ip6oa_boundif =
						    policy_ifp-&gt;if_index;
						ip6oa-&gt;ip6oa_flags |=
						    IP6OAF_BOUND_IF;
					}
					<span class="enscript-keyword">if</span> (opt != NULL
					    &amp;&amp; opt-&gt;ip6po_pktinfo != NULL) {
						opt-&gt;ip6po_pktinfo-&gt;
						    ipi6_ifindex =
							policy_ifp-&gt;if_index;
					}
					ro = &amp;necp_route;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;
				} <span class="enscript-keyword">else</span> {
					error = ENETUNREACH;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">freehdrs</span>;
				}
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass != 0 || ip6obf.noipsec)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;

	<span class="enscript-keyword">if</span> (sp == NULL) {
		<span class="enscript-comment">/* get a security policy for this packet */</span>
		<span class="enscript-keyword">if</span> (so != NULL) {
			sp = ipsec6_getpolicybysock(m, IPSEC_DIR_OUTBOUND,
				so, &amp;error);
		} <span class="enscript-keyword">else</span> {
			sp = ipsec6_getpolicybyaddr(m, IPSEC_DIR_OUTBOUND,
				0, &amp;error);
		}
		<span class="enscript-keyword">if</span> (sp == NULL) {
			IPSEC_STAT_INCREMENT(ipsec6stat.out_inval);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freehdrs</span>;
		}
	}

	error = 0;

	<span class="enscript-comment">/* check policy */</span>
	<span class="enscript-keyword">switch</span> (sp-&gt;policy) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_DISCARD</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_GENERATE</span>:
		<span class="enscript-comment">/*
		 * This packet is just discarded.
		 */</span>
		IPSEC_STAT_INCREMENT(ipsec6stat.out_polvio);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freehdrs</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_BYPASS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_NONE</span>:
		<span class="enscript-comment">/* no need to do IPsec. */</span>
		ip6obf.needipsec = FALSE;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_IPSEC</span>:
		<span class="enscript-keyword">if</span> (sp-&gt;req == NULL) {
			<span class="enscript-comment">/* acquire a policy */</span>
			error = key_spdacquire(sp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freehdrs</span>;
		}
		<span class="enscript-keyword">if</span> (sp-&gt;ipsec_if) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip_ipsec</span>;
		} <span class="enscript-keyword">else</span> {
			ip6obf.needipsec = TRUE;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_ENTRUST</span>:
	<span class="enscript-reference">default</span>:
		printf(<span class="enscript-string">&quot;%s: Invalid policy found: %d\n&quot;</span>, __func__, sp-&gt;policy);
		<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">skip_ipsec</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

	<span class="enscript-comment">/*
	 * Calculate the total length of the extension header chain.
	 * Keep the length of the unfragmentable part for fragmentation.
	 */</span>
	optlen = 0;
	<span class="enscript-keyword">if</span> (exthdrs.ip6e_hbh != NULL)
		optlen += exthdrs.ip6e_hbh-&gt;m_len;
	<span class="enscript-keyword">if</span> (exthdrs.ip6e_dest1 != NULL)
		optlen += exthdrs.ip6e_dest1-&gt;m_len;
	<span class="enscript-keyword">if</span> (exthdrs.ip6e_rthdr != NULL)
		optlen += exthdrs.ip6e_rthdr-&gt;m_len;
	unfragpartlen = optlen + <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr);

	<span class="enscript-comment">/* NOTE: we don't add AH/ESP length here. do that later. */</span>
	<span class="enscript-keyword">if</span> (exthdrs.ip6e_dest2 != NULL)
		optlen += exthdrs.ip6e_dest2-&gt;m_len;

	<span class="enscript-comment">/*
	 * If we need IPsec, or there is at least one extension header,
	 * separate IP6 header from the payload.
	 */</span>
	<span class="enscript-keyword">if</span> ((
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	    ip6obf.needipsec ||
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
	    optlen) &amp;&amp; !ip6obf.hdrsplit) {
		<span class="enscript-keyword">if</span> ((error = ip6_splithdr(m, &amp;exthdrs)) != 0) {
			m = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freehdrs</span>;
		}
		m = exthdrs.ip6e_ip6;
		ip6obf.hdrsplit = TRUE;
	}

	<span class="enscript-comment">/* adjust pointer */</span>
	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

	<span class="enscript-comment">/* adjust mbuf packet header length */</span>
	m-&gt;m_pkthdr.len += optlen;
	plen = m-&gt;m_pkthdr.len - <span class="enscript-keyword">sizeof</span> (*ip6);

	<span class="enscript-comment">/* If this is a jumbo payload, insert a jumbo payload option. */</span>
	<span class="enscript-keyword">if</span> (plen &gt; IPV6_MAXPACKET) {
		<span class="enscript-keyword">if</span> (!ip6obf.hdrsplit) {
			<span class="enscript-keyword">if</span> ((error = ip6_splithdr(m, &amp;exthdrs)) != 0) {
				m = NULL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">freehdrs</span>;
			}
			m = exthdrs.ip6e_ip6;
			ip6obf.hdrsplit = TRUE;
		}
		<span class="enscript-comment">/* adjust pointer */</span>
		ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
		<span class="enscript-keyword">if</span> ((error = ip6_insert_jumboopt(&amp;exthdrs, plen)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freehdrs</span>;
		ip6-&gt;ip6_plen = 0;
	} <span class="enscript-keyword">else</span> {
		ip6-&gt;ip6_plen = htons(plen);
	}
	<span class="enscript-comment">/*
	 * Concatenate headers and fill in next header fields.
	 * Here we have, on &quot;m&quot;
	 *	IPv6 payload
	 * and we insert headers accordingly.  Finally, we should be getting:
	 *	IPv6 hbh dest1 rthdr ah* [esp* dest2 payload]
	 *
	 * during the header composing process, &quot;m&quot; points to IPv6 header.
	 * &quot;mprev&quot; points to an extension header prior to esp.
	 */</span>
	nexthdrp = &amp;ip6-&gt;ip6_nxt;
	mprev = m;

	<span class="enscript-comment">/*
	 * we treat dest2 specially.  this makes IPsec processing
	 * much easier.  the goal here is to make mprev point the
	 * mbuf prior to dest2.
	 *
	 * result: IPv6 dest2 payload
	 * m and mprev will point to IPv6 header.
	 */</span>
	<span class="enscript-keyword">if</span> (exthdrs.ip6e_dest2 != NULL) {
		<span class="enscript-keyword">if</span> (!ip6obf.hdrsplit) {
			panic(<span class="enscript-string">&quot;assumption failed: hdr not split&quot;</span>);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		exthdrs.ip6e_dest2-&gt;m_next = m-&gt;m_next;
		m-&gt;m_next = exthdrs.ip6e_dest2;
		*mtod(exthdrs.ip6e_dest2, u_char *) = ip6-&gt;ip6_nxt;
		ip6-&gt;ip6_nxt = IPPROTO_DSTOPTS;
	}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MAKE_CHAIN</span>(m, mp, p, i)	do {					\
	<span class="enscript-keyword">if</span> (m != NULL) {						\
		<span class="enscript-keyword">if</span> (!ip6obf.hdrsplit) {					\
			panic(<span class="enscript-string">&quot;assumption failed: hdr not split&quot;</span>);	\
			<span class="enscript-comment">/* NOTREACHED */</span>				\
		}							\
		*mtod((m), u_char *) = *(p);				\
		*(p) = (i);						\
		p = mtod((m), u_char *);				\
		(m)-&gt;m_next = (mp)-&gt;m_next;				\
		(mp)-&gt;m_next = (m);					\
		(mp) = (m);						\
	}								\
} <span class="enscript-keyword">while</span> (0)
	<span class="enscript-comment">/*
	 * result: IPv6 hbh dest1 rthdr dest2 payload
	 * m will point to IPv6 header.  mprev will point to the
	 * extension header prior to dest2 (rthdr in the above case).
	 */</span>
	MAKE_CHAIN(exthdrs.ip6e_hbh, mprev, nexthdrp, IPPROTO_HOPOPTS);
	MAKE_CHAIN(exthdrs.ip6e_dest1, mprev, nexthdrp, IPPROTO_DSTOPTS);
	MAKE_CHAIN(exthdrs.ip6e_rthdr, mprev, nexthdrp, IPPROTO_ROUTING);

	<span class="enscript-comment">/* It is no longer safe to free the pointers in exthdrs. */</span>
	exthdrs.merged = TRUE;

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">MAKE_CHAIN</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (ip6obf.needipsec &amp;&amp; (m-&gt;m_pkthdr.csum_flags &amp; CSUM_DELAY_IPV6_DATA))
		in6_delayed_cksum_offset(m, 0, optlen, nxt0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

	<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;ipv6_filters)) {
		<span class="enscript-type">struct</span> ipfilter	*filter;
		<span class="enscript-type">int</span> seen = (inject_filter_ref == NULL);
		<span class="enscript-type">int</span> fixscope = 0;

		<span class="enscript-keyword">if</span> (im6o != NULL &amp;&amp; IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst)) {
			ippo-&gt;ippo_flags |= IPPOF_MCAST_OPTS;
			IM6O_LOCK(im6o);
			ippo-&gt;ippo_mcast_ifnet = im6o-&gt;im6o_multicast_ifp;
			ippo-&gt;ippo_mcast_ttl = im6o-&gt;im6o_multicast_hlim;
			ippo-&gt;ippo_mcast_loop = im6o-&gt;im6o_multicast_loop;
			IM6O_UNLOCK(im6o);
		}

		<span class="enscript-comment">/* Hack: embed the scope_id in the destination */</span>
		<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;ip6-&gt;ip6_dst) &amp;&amp;
		    (ip6-&gt;ip6_dst.s6_addr16[1] == 0) &amp;&amp; (ro != NULL)) {
			fixscope = 1;
			ip6-&gt;ip6_dst.s6_addr16[1] =
			    htons(ro-&gt;ro_dst.sin6_scope_id);
		}

		ipf_ref();
		TAILQ_FOREACH(filter, &amp;ipv6_filters, ipf_link) {
			<span class="enscript-comment">/*
			 * Don't process packet twice if we've already seen it.
			 */</span>
			<span class="enscript-keyword">if</span> (seen == 0) {
				<span class="enscript-keyword">if</span> ((<span class="enscript-type">struct</span> ipfilter *)inject_filter_ref ==
				    filter)
					seen = 1;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (filter-&gt;ipf_filter.ipf_output != NULL) {
				errno_t result;

				result = filter-&gt;ipf_filter.ipf_output(
				    filter-&gt;ipf_filter.cookie,
				    (mbuf_t *)&amp;m, ippo);
				<span class="enscript-keyword">if</span> (result == EJUSTRETURN) {
					ipf_unref();
					<span class="enscript-keyword">if</span> (m != NULL)
						m_freem(m);
					m = NULL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">evaluateloop</span>;
				}
				<span class="enscript-keyword">if</span> (result != 0) {
					ipf_unref();
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
				}
			}
		}
		ipf_unref();

		ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
		<span class="enscript-comment">/* Hack: cleanup embedded scope_id if we put it there */</span>
		<span class="enscript-keyword">if</span> (fixscope)
			ip6-&gt;ip6_dst.s6_addr16[1] = 0;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (ip6obf.needipsec) {
		<span class="enscript-type">int</span> segleft_org;

		<span class="enscript-comment">/*
		 * pointers after IPsec headers are not valid any more.
		 * other pointers need a great care too.
		 * (IPsec routines should not mangle mbufs prior to AH/ESP)
		 */</span>
		exthdrs.ip6e_dest2 = NULL;

		<span class="enscript-keyword">if</span> (exthdrs.ip6e_rthdr != NULL) {
			rh = mtod(exthdrs.ip6e_rthdr, <span class="enscript-type">struct</span> ip6_rthdr *);
			segleft_org = rh-&gt;ip6r_segleft;
			rh-&gt;ip6r_segleft = 0;
		} <span class="enscript-keyword">else</span> {
			rh = NULL;
			segleft_org = 0;
		}

		ipsec_state.m = m;
		error = ipsec6_output_trans(&amp;ipsec_state, nexthdrp, mprev,
		    sp, flags, &amp;needipsectun);
		m = ipsec_state.m;
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/* mbuf is already reclaimed in ipsec6_output_trans. */</span>
			m = NULL;
			<span class="enscript-keyword">switch</span> (error) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTUNREACH</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETUNREACH</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">EMSGSIZE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOBUFS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOMEM</span>:
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				printf(<span class="enscript-string">&quot;ip6_output (ipsec): error code %d\n&quot;</span>,
				    error);
				<span class="enscript-comment">/* FALLTHRU */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOENT</span>:
				<span class="enscript-comment">/* don't show these error codes to the user */</span>
				error = 0;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-keyword">if</span> (exthdrs.ip6e_rthdr != NULL) {
			<span class="enscript-comment">/* ah6_output doesn't modify mbuf chain */</span>
			rh-&gt;ip6r_segleft = segleft_org;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

	<span class="enscript-comment">/*
	 * If there is a routing header, replace the destination address field
	 * with the first hop of the routing header.
	 */</span>
	<span class="enscript-keyword">if</span> (exthdrs.ip6e_rthdr != NULL) {
		<span class="enscript-type">struct</span> ip6_rthdr0 *rh0;
		<span class="enscript-type">struct</span> in6_addr *addr;
		<span class="enscript-type">struct</span> sockaddr_in6 sa;

		rh = (<span class="enscript-type">struct</span> ip6_rthdr *)
		    (mtod(exthdrs.ip6e_rthdr, <span class="enscript-type">struct</span> ip6_rthdr *));
		<span class="enscript-keyword">switch</span> (rh-&gt;ip6r_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RTHDR_TYPE_0</span>:
			rh0 = (<span class="enscript-type">struct</span> ip6_rthdr0 *)rh;
			addr = (<span class="enscript-type">struct</span> in6_addr *)(<span class="enscript-type">void</span> *)(rh0 + 1);

			<span class="enscript-comment">/*
			 * construct a sockaddr_in6 form of
			 * the first hop.
			 *
			 * XXX: we may not have enough
			 * information about its scope zone;
			 * there is no standard API to pass
			 * the information from the
			 * application.
			 */</span>
			bzero(&amp;sa, <span class="enscript-keyword">sizeof</span> (sa));
			sa.sin6_family = AF_INET6;
			sa.sin6_len = <span class="enscript-keyword">sizeof</span> (sa);
			sa.sin6_addr = addr[0];
			<span class="enscript-keyword">if</span> ((error = sa6_embedscope(&amp;sa,
			    ip6_use_defzone)) != 0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			ip6-&gt;ip6_dst = sa.sin6_addr;
			bcopy(&amp;addr[1], &amp;addr[0], <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr) *
			    (rh0-&gt;ip6r0_segleft - 1));
			addr[rh0-&gt;ip6r0_segleft - 1] = finaldst;
			<span class="enscript-comment">/* XXX */</span>
			in6_clearscope(addr + rh0-&gt;ip6r0_segleft - 1);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:	<span class="enscript-comment">/* is it possible? */</span>
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

	<span class="enscript-comment">/* Source address validation */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;ip6-&gt;ip6_src) &amp;&amp;
	    !(flags &amp; IPV6_UNSPECSRC)) {
		error = EOPNOTSUPP;
		ip6stat.ip6s_badscope++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_src)) {
		error = EOPNOTSUPP;
		ip6stat.ip6s_badscope++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	ip6stat.ip6s_localout++;

	<span class="enscript-comment">/*
	 * Route packet.
	 */</span>
	<span class="enscript-keyword">if</span> (ro == NULL) {
		ro = &amp;ip6route;
		bzero((caddr_t)ro, <span class="enscript-keyword">sizeof</span> (*ro));
	}
	ro_pmtu = ro;
	<span class="enscript-keyword">if</span> (opt != NULL &amp;&amp; opt-&gt;ip6po_rthdr)
		ro = &amp;opt-&gt;ip6po_route;
	dst = SIN6(&amp;ro-&gt;ro_dst);

	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt != NULL)
		RT_LOCK_ASSERT_NOTHELD(ro-&gt;ro_rt);
	<span class="enscript-comment">/*
	 * if specified, try to fill in the traffic class field.
	 * do not override if a non-zero value is already set.
	 * we check the diffserv field and the ecn field separately.
	 */</span>
	<span class="enscript-keyword">if</span> (opt != NULL &amp;&amp; opt-&gt;ip6po_tclass &gt;= 0) {
		<span class="enscript-type">int</span> mask = 0;

		<span class="enscript-keyword">if</span> ((ip6-&gt;ip6_flow &amp; htonl(0xfc &lt;&lt; 20)) == 0)
			mask |= 0xfc;
		<span class="enscript-keyword">if</span> ((ip6-&gt;ip6_flow &amp; htonl(0x03 &lt;&lt; 20)) == 0)
			mask |= 0x03;
		<span class="enscript-keyword">if</span> (mask != 0) {
			ip6-&gt;ip6_flow |=
			    htonl((opt-&gt;ip6po_tclass &amp; mask) &lt;&lt; 20);
		}
	}

	<span class="enscript-comment">/* fill in or override the hop limit field, if necessary. */</span>
	<span class="enscript-keyword">if</span> (opt &amp;&amp; opt-&gt;ip6po_hlim != -1) {
		ip6-&gt;ip6_hlim = opt-&gt;ip6po_hlim &amp; 0xff;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst)) {
		<span class="enscript-keyword">if</span> (im6o != NULL) {
			IM6O_LOCK(im6o);
			ip6-&gt;ip6_hlim = im6o-&gt;im6o_multicast_hlim;
			IM6O_UNLOCK(im6o);
		} <span class="enscript-keyword">else</span> {
			ip6-&gt;ip6_hlim = ip6_defmcasthlim;
		}
	}

	<span class="enscript-comment">/*
	 * If there is a cached route, check that it is to the same
	 * destination and is still up. If not, free it and try again.
	 * Test rt_flags without holding rt_lock for performance reasons;
	 * if the route is down it will hopefully be caught by the layer
	 * below (since it uses this route as a hint) or during the
	 * next transmit.
	 */</span>
	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro) || dst-&gt;sin6_family != AF_INET6 ||
	    !IN6_ARE_ADDR_EQUAL(&amp;dst-&gt;sin6_addr, &amp;ip6-&gt;ip6_dst))
		ROUTE_RELEASE(ro);

	<span class="enscript-keyword">if</span> (ro-&gt;ro_rt == NULL) {
		bzero(dst, <span class="enscript-keyword">sizeof</span> (*dst));
		dst-&gt;sin6_family = AF_INET6;
		dst-&gt;sin6_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
		dst-&gt;sin6_addr = ip6-&gt;ip6_dst;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (ip6obf.needipsec &amp;&amp; needipsectun) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-type">struct</span> ifnet *trace_ifp = (ifpp_save != NULL) ? (*ifpp_save) : NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_DTRACE */</span>
		<span class="enscript-comment">/*
		 * All the extension headers will become inaccessible
		 * (since they can be encrypted).
		 * Don't panic, we need no more updates to extension headers
		 * on inner IPv6 packet (since they are now encapsulated).
		 *
		 * IPv6 [ESP|AH] IPv6 [extension headers] payload
		 */</span>
		bzero(&amp;exthdrs, <span class="enscript-keyword">sizeof</span> (exthdrs));
		exthdrs.ip6e_ip6 = m;

		ipsec_state.m = m;
		route_copyout(&amp;ipsec_state.ro, (<span class="enscript-type">struct</span> route *)ro,
		    <span class="enscript-keyword">sizeof</span> (ipsec_state.ro));
		ipsec_state.dst = SA(dst);

		<span class="enscript-comment">/* So that we can see packets inside the tunnel */</span>
		DTRACE_IP6(send, <span class="enscript-type">struct</span> mbuf *, m, <span class="enscript-type">struct</span> inpcb *, NULL,
		    <span class="enscript-type">struct</span> ip6_hdr *, ip6, <span class="enscript-type">struct</span> ifnet *, trace_ifp,
		    <span class="enscript-type">struct</span> ip *, NULL, <span class="enscript-type">struct</span> ip6_hdr *, ip6);

		error = ipsec6_output_tunnel(&amp;ipsec_state, sp, flags);
		<span class="enscript-comment">/* tunneled in IPv4? packet is gone */</span>
		<span class="enscript-keyword">if</span> (ipsec_state.tunneled == 4) {
			m = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">evaluateloop</span>;
		}
		m = ipsec_state.m;
		ipsec_saved_route = ro;
		ro = (<span class="enscript-type">struct</span> route_in6 *)&amp;ipsec_state.ro;
		dst = SIN6(ipsec_state.dst);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/* mbuf is already reclaimed in ipsec6_output_tunnel. */</span>
			m = NULL;
			<span class="enscript-keyword">switch</span> (error) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTUNREACH</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETUNREACH</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">EMSGSIZE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOBUFS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOMEM</span>:
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				printf(<span class="enscript-string">&quot;ip6_output (ipsec): error code %d\n&quot;</span>,
				    error);
				<span class="enscript-comment">/* FALLTHRU */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOENT</span>:
				<span class="enscript-comment">/* don't show these error codes to the user */</span>
				error = 0;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-comment">/*
		 * The packet has been encapsulated so the ifscope
		 * is no longer valid since it does not apply to the
		 * outer address: ignore the ifscope.
		 */</span>
		<span class="enscript-keyword">if</span> (flags &amp; IPV6_OUTARGS) {
			ip6oa-&gt;ip6oa_boundif = IFSCOPE_NONE;
			ip6oa-&gt;ip6oa_flags &amp;= ~IP6OAF_BOUND_IF;
		}
		<span class="enscript-keyword">if</span> (opt != NULL &amp;&amp; opt-&gt;ip6po_pktinfo != NULL) {
			<span class="enscript-keyword">if</span> (opt-&gt;ip6po_pktinfo-&gt;ipi6_ifindex != IFSCOPE_NONE)
				opt-&gt;ip6po_pktinfo-&gt;ipi6_ifindex = IFSCOPE_NONE;
		}
		exthdrs.ip6e_ip6 = m;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

	<span class="enscript-comment">/*
	 * ifp should only be filled in for dummy net packets which will jump
	 * to check_with_pf label.
	 */</span>
	<span class="enscript-keyword">if</span> (ifp != NULL) {
		VERIFY(ip6obf.route_selected);
	}

	<span class="enscript-comment">/* adjust pointer */</span>
	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);

	<span class="enscript-keyword">if</span> (ip6obf.select_srcif) {
		bzero(&amp;src_sa, <span class="enscript-keyword">sizeof</span> (src_sa));
		src_sa.sin6_family = AF_INET6;
		src_sa.sin6_len = <span class="enscript-keyword">sizeof</span> (src_sa);
		src_sa.sin6_addr = ip6-&gt;ip6_src;
	}
	bzero(&amp;dst_sa, <span class="enscript-keyword">sizeof</span> (dst_sa));
	dst_sa.sin6_family = AF_INET6;
	dst_sa.sin6_len = <span class="enscript-keyword">sizeof</span> (dst_sa);
	dst_sa.sin6_addr = ip6-&gt;ip6_dst;

	<span class="enscript-comment">/*
	 * Only call in6_selectroute() on first iteration to avoid taking
	 * multiple references on ifp and rt.
	 *
	 * in6_selectroute() might return an ifp with its reference held
	 * even in the error case, so make sure to release its reference.
	 * ip6oa may be NULL if IPV6_OUTARGS isn't set.
	 */</span>
	<span class="enscript-keyword">if</span> (!ip6obf.route_selected) {
		error = in6_selectroute( ip6obf.select_srcif ? &amp;src_sa : NULL,
		    &amp;dst_sa, opt, im6o, &amp;src_ia, ro, &amp;ifp, &amp;rt, 0, ip6oa);

		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-keyword">switch</span> (error) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTUNREACH</span>:
				ip6stat.ip6s_noroute++;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">EADDRNOTAVAIL</span>:
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>; <span class="enscript-comment">/* XXX statistics? */</span>
			}
			<span class="enscript-keyword">if</span> (ifp != NULL)
				in6_ifstat_inc(ifp, ifs6_out_discard);
			<span class="enscript-comment">/* ifp (if non-NULL) will be released at the end */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		ip6obf.route_selected = TRUE;
	}
	<span class="enscript-keyword">if</span> (rt == NULL) {
		<span class="enscript-comment">/*
		 * If in6_selectroute() does not return a route entry,
		 * dst may not have been updated.
		 */</span>
		*dst = dst_sa;	<span class="enscript-comment">/* XXX */</span>
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	<span class="enscript-comment">/* Catch-all to check if the interface is allowed */</span>
	<span class="enscript-keyword">if</span> (!necp_packet_is_allowed_over_interface(m, ifp)) {
		error = EHOSTUNREACH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	<span class="enscript-comment">/*
	 * then rt (for unicast) and ifp must be non-NULL valid values.
	 */</span>
	<span class="enscript-keyword">if</span> (!(flags &amp; IPV6_FORWARDING)) {
		in6_ifstat_inc_na(ifp, ifs6_out_request);
	}
	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK(rt);
		<span class="enscript-keyword">if</span> (ia == NULL) {
			ia = (<span class="enscript-type">struct</span> in6_ifaddr *)(rt-&gt;rt_ifa);
			<span class="enscript-keyword">if</span> (ia != NULL)
				IFA_ADDREF(&amp;ia-&gt;ia_ifa);
		}
		rt-&gt;rt_use++;
		RT_UNLOCK(rt);
	}

	<span class="enscript-comment">/*
	 * The outgoing interface must be in the zone of source and
	 * destination addresses (except local/loopback).  We should
	 * use ia_ifp to support the case of sending packets to an
	 * address of our own.
	 */</span>
	<span class="enscript-keyword">if</span> (ia != NULL &amp;&amp; ia-&gt;ia_ifp) {
		ifnet_reference(ia-&gt;ia_ifp);	<span class="enscript-comment">/* for origifp */</span>
		<span class="enscript-keyword">if</span> (origifp != NULL)
			ifnet_release(origifp);
		origifp = ia-&gt;ia_ifp;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (ifp != NULL)
			ifnet_reference(ifp);	<span class="enscript-comment">/* for origifp */</span>
		<span class="enscript-keyword">if</span> (origifp != NULL)
			ifnet_release(origifp);
		origifp = ifp;
	}

	<span class="enscript-comment">/* skip scope enforcements for local/loopback route */</span>
	<span class="enscript-keyword">if</span> (rt == NULL || !(rt-&gt;rt_ifp-&gt;if_flags &amp; IFF_LOOPBACK)) {
		<span class="enscript-type">struct</span> in6_addr src0, dst0;
		u_int32_t zone;

		src0 = ip6-&gt;ip6_src;
		<span class="enscript-keyword">if</span> (in6_setscope(&amp;src0, origifp, &amp;zone))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badscope</span>;
		bzero(&amp;src_sa, <span class="enscript-keyword">sizeof</span> (src_sa));
		src_sa.sin6_family = AF_INET6;
		src_sa.sin6_len = <span class="enscript-keyword">sizeof</span> (src_sa);
		src_sa.sin6_addr = ip6-&gt;ip6_src;
		<span class="enscript-keyword">if</span> ((sa6_recoverscope(&amp;src_sa, TRUE) ||
		    zone != src_sa.sin6_scope_id))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badscope</span>;

		dst0 = ip6-&gt;ip6_dst;
		<span class="enscript-keyword">if</span> ((in6_setscope(&amp;dst0, origifp, &amp;zone)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badscope</span>;
		<span class="enscript-comment">/* re-initialize to be sure */</span>
		bzero(&amp;dst_sa, <span class="enscript-keyword">sizeof</span> (dst_sa));
		dst_sa.sin6_family = AF_INET6;
		dst_sa.sin6_len = <span class="enscript-keyword">sizeof</span> (dst_sa);
		dst_sa.sin6_addr = ip6-&gt;ip6_dst;
		<span class="enscript-keyword">if</span> ((sa6_recoverscope(&amp;dst_sa, TRUE) ||
		    zone != dst_sa.sin6_scope_id))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badscope</span>;

		<span class="enscript-comment">/* scope check is done. */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">routefound</span>;

<span class="enscript-reference">badscope</span>:
		ip6stat.ip6s_badscope++;
		in6_ifstat_inc(origifp, ifs6_out_discard);
		<span class="enscript-keyword">if</span> (error == 0)
			error = EHOSTUNREACH; <span class="enscript-comment">/* XXX */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

<span class="enscript-reference">routefound</span>:
	<span class="enscript-keyword">if</span> (rt != NULL &amp;&amp; !IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst)) {
		<span class="enscript-keyword">if</span> (opt != NULL &amp;&amp; opt-&gt;ip6po_nextroute.ro_rt) {
			<span class="enscript-comment">/*
			 * The nexthop is explicitly specified by the
			 * application.  We assume the next hop is an IPv6
			 * address.
			 */</span>
			dst = SIN6(opt-&gt;ip6po_nexthop);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; RTF_GATEWAY)) {
			dst = SIN6(rt-&gt;rt_gateway);
		}
		<span class="enscript-comment">/*
		 * For packets destined to local/loopback, record the
		 * source the source interface (which owns the source
		 * address), as well as the output interface.  This is
		 * needed to reconstruct the embedded zone for the
		 * link-local address case in ip6_input().
		 */</span>
		<span class="enscript-keyword">if</span> (ia != NULL &amp;&amp; (ifp-&gt;if_flags &amp; IFF_LOOPBACK)) {
			uint32_t srcidx;

			<span class="enscript-keyword">if</span> (src_ia != NULL)
				srcidx = src_ia-&gt;ia_ifp-&gt;if_index;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ro-&gt;ro_srcia != NULL)
				srcidx = ro-&gt;ro_srcia-&gt;ifa_ifp-&gt;if_index;
			<span class="enscript-keyword">else</span>
				srcidx = 0;

			ip6_setsrcifaddr_info(m, srcidx, NULL);
			ip6_setdstifaddr_info(m, 0, ia);
		}
	}

	<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst)) {
		m-&gt;m_flags &amp;= ~(M_BCAST | M_MCAST); <span class="enscript-comment">/* just in case */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span>	in6_multi *in6m;

		m-&gt;m_flags = (m-&gt;m_flags &amp; ~M_BCAST) | M_MCAST;
		in6_ifstat_inc_na(ifp, ifs6_out_mcast);

		<span class="enscript-comment">/*
		 * Confirm that the outgoing interface supports multicast.
		 */</span>
		<span class="enscript-keyword">if</span> (!(ifp-&gt;if_flags &amp; IFF_MULTICAST)) {
			ip6stat.ip6s_noroute++;
			in6_ifstat_inc(ifp, ifs6_out_discard);
			error = ENETUNREACH;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		in6_multihead_lock_shared();
		IN6_LOOKUP_MULTI(&amp;ip6-&gt;ip6_dst, ifp, in6m);
		in6_multihead_lock_done();
		<span class="enscript-keyword">if</span> (im6o != NULL)
			IM6O_LOCK(im6o);
		<span class="enscript-keyword">if</span> (in6m != NULL &amp;&amp;
		    (im6o == NULL || im6o-&gt;im6o_multicast_loop)) {
			<span class="enscript-keyword">if</span> (im6o != NULL)
				IM6O_UNLOCK(im6o);
			<span class="enscript-comment">/*
			 * If we belong to the destination multicast group
			 * on the outgoing interface, and the caller did not
			 * forbid loopback, loop back a copy.
			 */</span>
			ip6_mloopback(NULL, ifp, m, dst, optlen, nxt0);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (im6o != NULL) 
			IM6O_UNLOCK(im6o);
		<span class="enscript-keyword">if</span> (in6m != NULL)
			IN6M_REMREF(in6m);
		<span class="enscript-comment">/*
		 * Multicasts with a hoplimit of zero may be looped back,
		 * above, but must not be transmitted on a network.
		 * Also, multicasts addressed to the loopback interface
		 * are not sent -- the above call to ip6_mloopback() will
		 * loop back a copy if this host actually belongs to the
		 * destination group on the loopback interface.
		 */</span>
		<span class="enscript-keyword">if</span> (ip6-&gt;ip6_hlim == 0 || (ifp-&gt;if_flags &amp; IFF_LOOPBACK) ||
		    IN6_IS_ADDR_MC_INTFACELOCAL(&amp;ip6-&gt;ip6_dst)) {
			<span class="enscript-comment">/* remove m from the packetchain and continue looping */</span>
			<span class="enscript-keyword">if</span> (m != NULL)
				m_freem(m);
			m = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">evaluateloop</span>;
		}
	}

	<span class="enscript-comment">/*
	 * Fill the outgoing inteface to tell the upper layer
	 * to increment per-interface statistics.
	 */</span>
	<span class="enscript-keyword">if</span> (ifpp != NULL &amp;&amp; *ifpp == NULL) {
		ifnet_reference(ifp);	<span class="enscript-comment">/* for caller */</span>
		*ifpp = ifp;
	}

	<span class="enscript-comment">/* Determine path MTU. */</span>
	<span class="enscript-keyword">if</span> ((error = ip6_getpmtu(ro_pmtu, ro, ifp, &amp;finaldst, &amp;mtu,
	    &amp;alwaysfrag)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-comment">/*
	 * The caller of this function may specify to use the minimum MTU
	 * in some cases.
	 * An advanced API option (IPV6_USE_MIN_MTU) can also override MTU
	 * setting.  The logic is a bit complicated; by default, unicast
	 * packets will follow path MTU while multicast packets will be sent at
	 * the minimum MTU.  If IP6PO_MINMTU_ALL is specified, all packets
	 * including unicast ones will be sent at the minimum MTU.  Multicast
	 * packets will always be sent at the minimum MTU unless
	 * IP6PO_MINMTU_DISABLE is explicitly specified.
	 * See RFC 3542 for more details.
	 */</span>
	<span class="enscript-keyword">if</span> (mtu &gt; IPV6_MMTU) {
		<span class="enscript-keyword">if</span> ((flags &amp; IPV6_MINMTU)) {
			mtu = IPV6_MMTU;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (opt &amp;&amp; opt-&gt;ip6po_minmtu == IP6PO_MINMTU_ALL) {
			mtu = IPV6_MMTU;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst) &amp;&amp;
		    (opt == NULL ||
		    opt-&gt;ip6po_minmtu != IP6PO_MINMTU_DISABLE)) {
			mtu = IPV6_MMTU;
		}
	}

	<span class="enscript-comment">/*
	 * clear embedded scope identifiers if necessary.
	 * in6_clearscope will touch the addresses only when necessary.
	 */</span>
	in6_clearscope(&amp;ip6-&gt;ip6_src);
	in6_clearscope(&amp;ip6-&gt;ip6_dst);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFW2</span>
	<span class="enscript-comment">/*
	 * Check with the firewall...
	 */</span>
	<span class="enscript-keyword">if</span> (ip6_fw_enable &amp;&amp; ip6_fw_chk_ptr) {
		u_short port = 0;
		m-&gt;m_pkthdr.rcvif = NULL;	<span class="enscript-comment">/* XXX */</span>
		<span class="enscript-comment">/* If ipfw says divert, we have to just drop packet */</span>
		<span class="enscript-keyword">if</span> (ip6_fw_chk_ptr(&amp;ip6, ifp, &amp;port, &amp;m) || m == NULL) {
			<span class="enscript-keyword">if</span> (m != NULL) {
				m_freem(m);
				m = NULL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">evaluateloop</span>;
			} <span class="enscript-keyword">else</span> {
				error = EACCES;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFW2 */</span>

	<span class="enscript-comment">/*
	 * If the outgoing packet contains a hop-by-hop options header,
	 * it must be examined and processed even by the source node.
	 * (RFC 2460, section 4.)
	 */</span>
	<span class="enscript-keyword">if</span> (exthdrs.ip6e_hbh != NULL) {
		<span class="enscript-type">struct</span> ip6_hbh *hbh = mtod(exthdrs.ip6e_hbh, <span class="enscript-type">struct</span> ip6_hbh *);
		u_int32_t dummy; <span class="enscript-comment">/* XXX unused */</span>
		uint32_t oplen = 0; <span class="enscript-comment">/* for ip6_process_hopopts() */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		<span class="enscript-keyword">if</span> ((hbh-&gt;ip6h_len + 1) &lt;&lt; 3 &gt; exthdrs.ip6e_hbh-&gt;m_len)
			panic(<span class="enscript-string">&quot;ip6e_hbh is not continuous&quot;</span>);
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/*
		 * XXX: If we have to send an ICMPv6 error to the sender,
		 * we need the M_LOOP flag since icmp6_error() expects
		 * the IPv6 and the hop-by-hop options header are
		 * continuous unless the flag is set.
		 */</span>
		m-&gt;m_flags |= M_LOOP;
		m-&gt;m_pkthdr.rcvif = ifp;
		<span class="enscript-keyword">if</span> (ip6_process_hopopts(m, (u_int8_t *)(hbh + 1),
		    ((hbh-&gt;ip6h_len + 1) &lt;&lt; 3) - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hbh),
		    &amp;dummy, &amp;oplen) &lt; 0) {
			<span class="enscript-comment">/*
			 * m was already freed at this point. Set to NULL so it
 			 * is not re-freed at end of ip6_output_list.
			 */</span>
			m = NULL;
			error = EINVAL;	<span class="enscript-comment">/* better error? */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		m-&gt;m_flags &amp;= ~M_LOOP; <span class="enscript-comment">/* XXX */</span>
		m-&gt;m_pkthdr.rcvif = NULL;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
<span class="enscript-reference">check_with_pf</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF</span>
	<span class="enscript-keyword">if</span> (PF_IS_ENABLED) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>

		<span class="enscript-comment">/*
		 * TODO: Need to save opt-&gt;ip6po_flags for reinjection
		 * rdar://10434993
		 */</span>
		args.fwa_m = m;
		args.fwa_oif = ifp;
		args.fwa_oflags = flags;
		<span class="enscript-keyword">if</span> (flags &amp; IPV6_OUTARGS)
			args.fwa_ip6oa = ip6oa;
		args.fwa_ro6 = ro;
		args.fwa_dst6 = dst;
		args.fwa_ro6_pmtu = ro_pmtu;
		args.fwa_origifp = origifp;
		args.fwa_mtu = mtu;
		args.fwa_alwaysfrag = alwaysfrag;
		args.fwa_unfragpartlen = unfragpartlen;
		args.fwa_exthdrs = &amp;exthdrs;
		<span class="enscript-comment">/* Invoke outbound packet filter */</span>
		error = pf_af_hook(ifp, NULL, &amp;m, AF_INET6, FALSE, &amp;args);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !DUMMYNET */</span>
		error = pf_af_hook(ifp, NULL, &amp;m, AF_INET6, FALSE, NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !DUMMYNET */</span>

		<span class="enscript-keyword">if</span> (error != 0 || m == NULL) {
			<span class="enscript-keyword">if</span> (m != NULL) {
				panic(<span class="enscript-string">&quot;%s: unexpected packet %p\n&quot;</span>,
				    __func__, m);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}
			<span class="enscript-comment">/* m was already freed by callee and is now NULL.  */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">evaluateloop</span>;
		}
		ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-comment">/* clean ipsec history before fragmentation */</span>
	ipsec_delaux(m);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

	<span class="enscript-comment">/*
	 * Determine whether fragmentation is necessary. If so, m is passed
	 * back as a chain of packets and original mbuf is freed. Otherwise, m
	 * is unchanged.
	 */</span>
	error = ip6_fragment_packet(&amp;m, opt,
	    &amp;exthdrs, ifp, mtu, alwaysfrag, unfragpartlen, ro_pmtu, nxt0,
	    optlen);

	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

<span class="enscript-comment">/*
 * The evaluateloop label is where we decide whether to continue looping over
 * packets or call into nd code to send.
 */</span>
<span class="enscript-reference">evaluateloop</span>:

	<span class="enscript-comment">/*
	 * m may be NULL when we jump to the evaluateloop label from PF or
	 * other code that can drop packets.
	 */</span>
	<span class="enscript-keyword">if</span> (m != NULL) {
		<span class="enscript-comment">/*
		 * If we already have a chain to send, tack m onto the end.
		 * Otherwise make m the start and end of the to-be-sent chain.
		 */</span>
		<span class="enscript-keyword">if</span> (sendchain != NULL) {
			sendchain_last-&gt;m_nextpkt = m;
		} <span class="enscript-keyword">else</span> {
			sendchain = m;
		}

		<span class="enscript-comment">/* Fragmentation may mean m is a chain. Find the last packet. */</span>
		<span class="enscript-keyword">while</span> (m-&gt;m_nextpkt)
			m = m-&gt;m_nextpkt;
		sendchain_last = m;
		pktcnt++;
	}

	<span class="enscript-comment">/* Fill in next m from inputchain as appropriate. */</span>
	m = inputchain;
	<span class="enscript-keyword">if</span> (m != NULL) {
		<span class="enscript-comment">/* Isolate m from rest of input chain. */</span>
		inputchain = m-&gt;m_nextpkt;
		m-&gt;m_nextpkt = NULL;

		<span class="enscript-comment">/*
		 * Clear exthdrs and ipsec_state so stale contents are not
		 * reused. Note this also clears the exthdrs.merged flag.
		 */</span>
		bzero(&amp;exthdrs, <span class="enscript-keyword">sizeof</span>(exthdrs));
		bzero(&amp;ipsec_state, <span class="enscript-keyword">sizeof</span>(ipsec_state));

		<span class="enscript-comment">/* Continue looping. */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">loopit</span>;
	}

	<span class="enscript-comment">/*
	 * If we get here, there's no more mbufs in inputchain, so send the
	 * sendchain if there is one.
	 */</span>
	<span class="enscript-keyword">if</span> (pktcnt &gt; 0) {
		error = nd6_output_list(ifp, origifp, sendchain, dst,
		    ro-&gt;ro_rt, adv);
		<span class="enscript-comment">/*
		 * Fall through to done label even in error case because
		 * nd6_output_list frees packetchain in both success and
		 * failure cases.
		 */</span>
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (ifpp_save != NULL &amp;&amp; *ifpp_save != NULL) {
		ifnet_release(*ifpp_save);
		*ifpp_save = NULL;
	}
	ROUTE_RELEASE(&amp;ip6route);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	ROUTE_RELEASE(&amp;ipsec_state.ro);
	<span class="enscript-keyword">if</span> (sp != NULL)
		key_freesp(sp, KEY_SADB_UNLOCKED);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	ROUTE_RELEASE(&amp;necp_route);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DUMMYNET</span>
	ROUTE_RELEASE(&amp;saved_route);
	ROUTE_RELEASE(&amp;saved_ro_pmtu);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DUMMYNET */</span>

	<span class="enscript-keyword">if</span> (ia != NULL)
		IFA_REMREF(&amp;ia-&gt;ia_ifa);
	<span class="enscript-keyword">if</span> (src_ia != NULL)
		IFA_REMREF(&amp;src_ia-&gt;ia_ifa);
	<span class="enscript-keyword">if</span> (ifp != NULL)
		ifnet_release(ifp);
	<span class="enscript-keyword">if</span> (origifp != NULL)
		ifnet_release(origifp);
	<span class="enscript-keyword">if</span> (ip6_output_measure) {
		net_perf_measure_time(&amp;net_perf, &amp;start_tv, packets_processed);
		net_perf_histogram(&amp;net_perf, packets_processed);
	}
	<span class="enscript-keyword">return</span> (error);

<span class="enscript-reference">freehdrs</span>:
	<span class="enscript-keyword">if</span> (exthdrs.ip6e_hbh != NULL) {
		<span class="enscript-keyword">if</span> (exthdrs.merged)
			panic(<span class="enscript-string">&quot;Double free of ip6e_hbh&quot;</span>);
		m_freem(exthdrs.ip6e_hbh);
	}
	<span class="enscript-keyword">if</span> (exthdrs.ip6e_dest1 != NULL) {
		<span class="enscript-keyword">if</span> (exthdrs.merged)
			panic(<span class="enscript-string">&quot;Double free of ip6e_dest1&quot;</span>);
		m_freem(exthdrs.ip6e_dest1);
	}
	<span class="enscript-keyword">if</span> (exthdrs.ip6e_rthdr != NULL) {
		<span class="enscript-keyword">if</span> (exthdrs.merged)
			panic(<span class="enscript-string">&quot;Double free of ip6e_rthdr&quot;</span>);
		m_freem(exthdrs.ip6e_rthdr);
	}
	<span class="enscript-keyword">if</span> (exthdrs.ip6e_dest2 != NULL) {
		<span class="enscript-keyword">if</span> (exthdrs.merged)
			panic(<span class="enscript-string">&quot;Double free of ip6e_dest2&quot;</span>);
		m_freem(exthdrs.ip6e_dest2);
	}
	<span class="enscript-comment">/* FALLTHRU */</span>
<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">if</span> (inputchain != NULL)
		m_freem_list(inputchain);
	<span class="enscript-keyword">if</span> (sendchain != NULL)
		m_freem_list(sendchain);
	<span class="enscript-keyword">if</span> (m != NULL)
		m_freem(m);

	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">ipf_pktopts</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">exthdrs</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">ip6route</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">ipsec_state</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">saved_route</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">saved_ro_pmtu</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">args</span>
}

<span class="enscript-comment">/* ip6_fragment_packet
 *
 * The fragmentation logic is rather complex:
 * 1: normal case (dontfrag == 0, alwaysfrag == 0)
 * 1-a:	send as is if tlen &lt;= path mtu
 * 1-b:	fragment if tlen &gt; path mtu
 *
 * 2: if user asks us not to fragment (dontfrag == 1)
 * 2-a:	send as is if tlen &lt;= interface mtu
 * 2-b:	error if tlen &gt; interface mtu
 *
 * 3: if we always need to attach fragment header (alwaysfrag == 1)
 *	always fragment
 *
 * 4: if dontfrag == 1 &amp;&amp; alwaysfrag == 1
 *	error, as we cannot handle this conflicting request
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_fragment_packet</span>(<span class="enscript-type">struct</span> mbuf **mptr, <span class="enscript-type">struct</span> ip6_pktopts *opt,
     <span class="enscript-type">struct</span> ip6_exthdrs *exthdrsp, <span class="enscript-type">struct</span> ifnet *ifp, uint32_t mtu,
     boolean_t alwaysfrag, uint32_t unfragpartlen, <span class="enscript-type">struct</span> route_in6 *ro_pmtu,
     <span class="enscript-type">int</span> nxt0, uint32_t optlen)
{
	VERIFY(NULL != mptr);
	<span class="enscript-type">struct</span> mbuf *m = *mptr;
	<span class="enscript-type">int</span> error = 0;
	size_t tlen = m-&gt;m_pkthdr.len;
	boolean_t dontfrag = (opt != NULL &amp;&amp; (opt-&gt;ip6po_flags &amp; IP6PO_DONTFRAG));

	<span class="enscript-keyword">if</span> (dontfrag &amp;&amp; alwaysfrag) {	<span class="enscript-comment">/* case 4 */</span>
		<span class="enscript-comment">/* conflicting request - can't transmit */</span>
		<span class="enscript-keyword">return</span> EMSGSIZE;
	}

	<span class="enscript-comment">/* Access without acquiring nd_ifinfo lock for performance */</span>
	<span class="enscript-keyword">if</span> (dontfrag &amp;&amp; tlen &gt; IN6_LINKMTU(ifp)) {	<span class="enscript-comment">/* case 2-b */</span>
		<span class="enscript-comment">/*
		 * Even if the DONTFRAG option is specified, we cannot send the
		 * packet when the data length is larger than the MTU of the
		 * outgoing interface.
		 * Notify the error by sending IPV6_PATHMTU ancillary data as
		 * well as returning an error code (the latter is not described
		 * in the API spec.)
		 */</span>
		u_int32_t mtu32;
		<span class="enscript-type">struct</span> ip6ctlparam ip6cp;

		mtu32 = (u_int32_t)mtu;
		bzero(&amp;ip6cp, <span class="enscript-keyword">sizeof</span> (ip6cp));
		ip6cp.ip6c_cmdarg = (<span class="enscript-type">void</span> *)&amp;mtu32;
		pfctlinput2(PRC_MSGSIZE, SA(&amp;ro_pmtu-&gt;ro_dst), (<span class="enscript-type">void</span> *)&amp;ip6cp);
		<span class="enscript-keyword">return</span> EMSGSIZE;
	}

	<span class="enscript-comment">/*
	 * transmit packet without fragmentation
	 */</span>
	<span class="enscript-keyword">if</span> (dontfrag || (!alwaysfrag &amp;&amp;		<span class="enscript-comment">/* case 1-a and 2-a */</span>
	    (tlen &lt;= mtu || TSO_IPV6_OK(ifp, m) ||
	    (ifp-&gt;if_hwassist &amp; CSUM_FRAGMENT_IPV6)))) {
		<span class="enscript-comment">/*
		 * mppn not updated in this case because no new chain is formed
		 * and inserted
		 */</span>
		ip6_output_checksum(ifp, mtu, m, nxt0, tlen, optlen);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * time to fragment - cases 1-b and 3 are handled inside
		 * ip6_do_fragmentation().
		 * mppn is passed down to be updated to point at fragment chain.
		 */</span>
		error = ip6_do_fragmentation(mptr, optlen, ifp,
		    unfragpartlen, mtod(m, <span class="enscript-type">struct</span> ip6_hdr *), exthdrsp, mtu, nxt0);
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * ip6_do_fragmentation() is called by ip6_fragment_packet() after determining
 * the packet needs to be fragmented. on success, morig is freed and a chain
 * of fragments is linked into the packet chain where morig existed. Otherwise,
 * an errno is returned.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_do_fragmentation</span>(<span class="enscript-type">struct</span> mbuf **mptr, uint32_t optlen, <span class="enscript-type">struct</span> ifnet *ifp,
    uint32_t unfragpartlen, <span class="enscript-type">struct</span> ip6_hdr *ip6, <span class="enscript-type">struct</span> ip6_exthdrs *exthdrsp,
    uint32_t mtu, <span class="enscript-type">int</span> nxt0)
{
	VERIFY(NULL != mptr);
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-type">struct</span> mbuf *morig = *mptr;
	<span class="enscript-type">struct</span> mbuf *first_mbufp = NULL;
	<span class="enscript-type">struct</span> mbuf *last_mbufp = NULL;

	size_t tlen = morig-&gt;m_pkthdr.len;

	<span class="enscript-comment">/*
	 * try to fragment the packet.  case 1-b and 3
	 */</span>
	<span class="enscript-keyword">if</span> ((morig-&gt;m_pkthdr.csum_flags &amp; CSUM_TSO_IPV6)) {
		<span class="enscript-comment">/* TSO and fragment aren't compatible */</span>
		in6_ifstat_inc(ifp, ifs6_out_fragfail);
		<span class="enscript-keyword">return</span> EMSGSIZE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mtu &lt; IPV6_MMTU) {
		<span class="enscript-comment">/* path MTU cannot be less than IPV6_MMTU */</span>
		in6_ifstat_inc(ifp, ifs6_out_fragfail);
		<span class="enscript-keyword">return</span> EMSGSIZE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ip6-&gt;ip6_plen == 0) {
		<span class="enscript-comment">/* jumbo payload cannot be fragmented */</span>
		in6_ifstat_inc(ifp, ifs6_out_fragfail);
		<span class="enscript-keyword">return</span> EMSGSIZE;
	} <span class="enscript-keyword">else</span> {
		size_t hlen, len, off;
		<span class="enscript-type">struct</span> mbuf **mnext = NULL;
		<span class="enscript-type">struct</span> ip6_frag *ip6f;
		u_int32_t id = htonl(ip6_randomid());
		u_char nextproto;

		<span class="enscript-comment">/*
		 * Too large for the destination or interface;
		 * fragment if possible.
		 * Must be able to put at least 8 bytes per fragment.
		 */</span>
		hlen = unfragpartlen;
		<span class="enscript-keyword">if</span> (mtu &gt; IPV6_MAXPACKET)
			mtu = IPV6_MAXPACKET;

		len = (mtu - hlen - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_frag)) &amp; ~7;
		<span class="enscript-keyword">if</span> (len &lt; 8) {
			in6_ifstat_inc(ifp, ifs6_out_fragfail);
			<span class="enscript-keyword">return</span> EMSGSIZE;
		}

		<span class="enscript-comment">/*
		 * Change the next header field of the last header in the
		 * unfragmentable part.
		 */</span>
		<span class="enscript-keyword">if</span> (exthdrsp-&gt;ip6e_rthdr != NULL) {
			nextproto = *mtod(exthdrsp-&gt;ip6e_rthdr, u_char *);
			*mtod(exthdrsp-&gt;ip6e_rthdr, u_char *) = IPPROTO_FRAGMENT;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (exthdrsp-&gt;ip6e_dest1 != NULL) {
			nextproto = *mtod(exthdrsp-&gt;ip6e_dest1, u_char *);
			*mtod(exthdrsp-&gt;ip6e_dest1, u_char *) = IPPROTO_FRAGMENT;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (exthdrsp-&gt;ip6e_hbh != NULL) {
			nextproto = *mtod(exthdrsp-&gt;ip6e_hbh, u_char *);
			*mtod(exthdrsp-&gt;ip6e_hbh, u_char *) = IPPROTO_FRAGMENT;
		} <span class="enscript-keyword">else</span> {
			nextproto = ip6-&gt;ip6_nxt;
			ip6-&gt;ip6_nxt = IPPROTO_FRAGMENT;
		}

		<span class="enscript-keyword">if</span> (morig-&gt;m_pkthdr.csum_flags &amp; CSUM_DELAY_IPV6_DATA)
			in6_delayed_cksum_offset(morig, 0, optlen, nxt0);

		<span class="enscript-comment">/*
		 * Loop through length of segment after first fragment,
		 * make new header and copy data of each part and link onto
		 * chain.
		 */</span>
		<span class="enscript-keyword">for</span> (off = hlen; off &lt; tlen; off += len) {
			<span class="enscript-type">struct</span> ip6_hdr *new_mhip6;
			<span class="enscript-type">struct</span> mbuf *new_m;
			<span class="enscript-type">struct</span> mbuf *m_frgpart;

			MGETHDR(new_m, M_DONTWAIT, MT_HEADER);	<span class="enscript-comment">/* MAC-OK */</span>
			<span class="enscript-keyword">if</span> (new_m == NULL) {
				error = ENOBUFS;
				ip6stat.ip6s_odropped++;
				<span class="enscript-keyword">break</span>;
			}
			new_m-&gt;m_pkthdr.rcvif = NULL;
			new_m-&gt;m_flags = morig-&gt;m_flags &amp; M_COPYFLAGS;

			<span class="enscript-keyword">if</span> (first_mbufp != NULL) {
				<span class="enscript-comment">/* Every pass through loop but first */</span>
				*mnext = new_m;
				last_mbufp = new_m;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* This is the first element of the fragment chain */</span>
				first_mbufp = new_m;
				last_mbufp = new_m;
			}
			mnext = &amp;new_m-&gt;m_nextpkt;

			new_m-&gt;m_data += max_linkhdr;
			new_mhip6 = mtod(new_m, <span class="enscript-type">struct</span> ip6_hdr *);
			*new_mhip6 = *ip6;
			new_m-&gt;m_len = <span class="enscript-keyword">sizeof</span> (*new_mhip6);

			error = ip6_insertfraghdr(morig, new_m, hlen, &amp;ip6f);
			<span class="enscript-keyword">if</span> (error) {
				ip6stat.ip6s_odropped++;
				<span class="enscript-keyword">break</span>;
			}

			ip6f-&gt;ip6f_offlg = htons((u_short)((off - hlen) &amp; ~7));
			<span class="enscript-keyword">if</span> (off + len &gt;= tlen)
				len = tlen - off;
			<span class="enscript-keyword">else</span>
				ip6f-&gt;ip6f_offlg |= IP6F_MORE_FRAG;
			new_mhip6-&gt;ip6_plen = htons((u_short)(len + hlen +
			    <span class="enscript-keyword">sizeof</span> (*ip6f) - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr)));

			<span class="enscript-keyword">if</span> ((m_frgpart = m_copy(morig, off, len)) == NULL) {
				error = ENOBUFS;
				ip6stat.ip6s_odropped++;
				<span class="enscript-keyword">break</span>;
			}
			m_cat(new_m, m_frgpart);
			new_m-&gt;m_pkthdr.len = len + hlen + <span class="enscript-keyword">sizeof</span> (*ip6f);
			new_m-&gt;m_pkthdr.rcvif = NULL;

			M_COPY_CLASSIFIER(new_m, morig);
			M_COPY_PFTAG(new_m, morig);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">notyet</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
			mac_create_fragment(morig, new_m);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_NET */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* notyet */</span>

			ip6f-&gt;ip6f_reserved = 0;
			ip6f-&gt;ip6f_ident = id;
			ip6f-&gt;ip6f_nxt = nextproto;
			ip6stat.ip6s_ofragments++;
			in6_ifstat_inc(ifp, ifs6_out_fragcreat);
		}

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/* free all the fragments created */</span>
			<span class="enscript-keyword">if</span> (first_mbufp != NULL) {
				m_freem_list(first_mbufp);
				first_mbufp = NULL;
			}
			last_mbufp = NULL;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* successful fragmenting */</span>
			m_freem(morig);
			*mptr = first_mbufp;
			last_mbufp-&gt;m_nextpkt = NULL;
			ip6stat.ip6s_fragmented++;
			in6_ifstat_inc(ifp, ifs6_out_fragok);
		}
	}
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_copyexthdr</span>(<span class="enscript-type">struct</span> mbuf **mp, caddr_t hdr, <span class="enscript-type">int</span> hlen)
{
	<span class="enscript-type">struct</span> mbuf *m;

	<span class="enscript-keyword">if</span> (hlen &gt; MCLBYTES)
		<span class="enscript-keyword">return</span> (ENOBUFS); <span class="enscript-comment">/* XXX */</span>

	MGET(m, M_DONTWAIT, MT_DATA);
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span> (ENOBUFS);

	<span class="enscript-keyword">if</span> (hlen &gt; MLEN) {
		MCLGET(m, M_DONTWAIT);
		<span class="enscript-keyword">if</span> (!(m-&gt;m_flags &amp; M_EXT)) {
			m_free(m);
			<span class="enscript-keyword">return</span> (ENOBUFS);
		}
	}
	m-&gt;m_len = hlen;
	<span class="enscript-keyword">if</span> (hdr != NULL)
		bcopy(hdr, mtod(m, caddr_t), hlen);

	*mp = m;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_out_cksum_stats</span>(<span class="enscript-type">int</span> proto, u_int32_t len)
{
	<span class="enscript-keyword">switch</span> (proto) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
		tcp_out6_cksum_stats(len);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
		udp_out6_cksum_stats(len);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/* keep only TCP or UDP stats for now */</span>
		<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-comment">/*
 * Process a delayed payload checksum calculation (outbound path.)
 *
 * hoff is the number of bytes beyond the mbuf data pointer which
 * points to the IPv6 header.  optlen is the number of bytes, if any,
 * between the end of IPv6 header and the beginning of the ULP payload
 * header, which represents the extension headers.  If optlen is less
 * than zero, this routine will bail when it detects extension headers.
 *
 * Returns a bitmask representing all the work done in software.
 */</span>
uint32_t
<span class="enscript-function-name">in6_finalize_cksum</span>(<span class="enscript-type">struct</span> mbuf *m, uint32_t hoff, int32_t optlen,
    int32_t nxt0, uint32_t csum_flags)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> buf[<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr)] __attribute__((aligned(8)));
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	uint32_t offset, mlen, hlen, olen, sw_csum;
	uint16_t csum, ulpoff, plen;
	uint8_t nxt;

	_CASSERT(<span class="enscript-keyword">sizeof</span> (csum) == <span class="enscript-keyword">sizeof</span> (uint16_t));
	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	sw_csum = (csum_flags &amp; m-&gt;m_pkthdr.csum_flags);

	<span class="enscript-keyword">if</span> ((sw_csum &amp;= CSUM_DELAY_IPV6_DATA) == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	mlen = m-&gt;m_pkthdr.len;				<span class="enscript-comment">/* total mbuf len */</span>
	hlen = <span class="enscript-keyword">sizeof</span> (*ip6);				<span class="enscript-comment">/* IPv6 header len */</span>

	<span class="enscript-comment">/* sanity check (need at least IPv6 header) */</span>
	<span class="enscript-keyword">if</span> (mlen &lt; (hoff + hlen)) {
		panic(<span class="enscript-string">&quot;%s: mbuf %p pkt len (%u) &lt; hoff+ip6_hdr &quot;</span>
		    <span class="enscript-string">&quot;(%u+%u)\n&quot;</span>, __func__, m, mlen, hoff, hlen);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/*
	 * In case the IPv6 header is not contiguous, or not 32-bit
	 * aligned, copy it to a local buffer.
	 */</span>
	<span class="enscript-keyword">if</span> ((hoff + hlen) &gt; m-&gt;m_len ||
	    !IP6_HDR_ALIGNED_P(mtod(m, caddr_t) + hoff)) {
		m_copydata(m, hoff, hlen, (caddr_t)buf);
		ip6 = (<span class="enscript-type">struct</span> ip6_hdr *)(<span class="enscript-type">void</span> *)buf;
	} <span class="enscript-keyword">else</span> {
		ip6 = (<span class="enscript-type">struct</span> ip6_hdr *)(<span class="enscript-type">void</span> *)(m-&gt;m_data + hoff);
	}

	nxt = ip6-&gt;ip6_nxt;
	plen = ntohs(ip6-&gt;ip6_plen);
	<span class="enscript-keyword">if</span> (plen != (mlen - (hoff + hlen))) {
		plen = OSSwapInt16(plen);
		<span class="enscript-keyword">if</span> (plen != (mlen - (hoff + hlen))) {
			<span class="enscript-comment">/* Don't complain for jumbograms */</span>
			<span class="enscript-keyword">if</span> (plen != 0 || nxt != IPPROTO_HOPOPTS) {
				printf(<span class="enscript-string">&quot;%s: mbuf 0x%llx proto %d IPv6 &quot;</span>
				    <span class="enscript-string">&quot;plen %d (%x) [swapped %d (%x)] doesn't &quot;</span>
				    <span class="enscript-string">&quot;match actual packet length; %d is used &quot;</span>
				    <span class="enscript-string">&quot;instead\n&quot;</span>, __func__,
				    (uint64_t)VM_KERNEL_ADDRPERM(m), nxt,
				    ip6-&gt;ip6_plen, ip6-&gt;ip6_plen, plen, plen,
				    (mlen - (hoff + hlen)));
			}
			plen = mlen - (hoff + hlen);
		}
	}

	<span class="enscript-keyword">if</span> (optlen &lt; 0) {
		<span class="enscript-comment">/* next header isn't TCP/UDP and we don't know optlen, bail */</span>
		<span class="enscript-keyword">if</span> (nxt != IPPROTO_TCP &amp;&amp; nxt != IPPROTO_UDP) {
			sw_csum = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		olen = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* caller supplied the original transport number; use it */</span>
		<span class="enscript-keyword">if</span> (nxt0 &gt;= 0)
			nxt = nxt0;
		olen = optlen;
	}

	offset = hoff + hlen + olen;			<span class="enscript-comment">/* ULP header */</span>

	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (mlen &lt; offset) {
		panic(<span class="enscript-string">&quot;%s: mbuf %p pkt len (%u) &lt; hoff+ip6_hdr+ext_hdr &quot;</span>
		    <span class="enscript-string">&quot;(%u+%u+%u)\n&quot;</span>, __func__, m, mlen, hoff, hlen, olen);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/*
	 * offset is added to the lower 16-bit value of csum_data,
	 * which is expected to contain the ULP offset; therefore
	 * CSUM_PARTIAL offset adjustment must be undone.
	 */</span>
	<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.csum_flags &amp; (CSUM_PARTIAL|CSUM_DATA_VALID)) ==
	    (CSUM_PARTIAL|CSUM_DATA_VALID)) {
		<span class="enscript-comment">/*
		 * Get back the original ULP offset (this will
		 * undo the CSUM_PARTIAL logic in ip6_output.)
		 */</span>
		m-&gt;m_pkthdr.csum_data = (m-&gt;m_pkthdr.csum_tx_stuff -
		    m-&gt;m_pkthdr.csum_tx_start);
	}

	ulpoff = (m-&gt;m_pkthdr.csum_data &amp; 0xffff);	<span class="enscript-comment">/* ULP csum offset */</span>

	<span class="enscript-keyword">if</span> (mlen &lt; (ulpoff + <span class="enscript-keyword">sizeof</span> (csum))) {
		panic(<span class="enscript-string">&quot;%s: mbuf %p pkt len (%u) proto %d invalid ULP &quot;</span>
		    <span class="enscript-string">&quot;cksum offset (%u) cksum flags 0x%x\n&quot;</span>, __func__,
		    m, mlen, nxt, ulpoff, m-&gt;m_pkthdr.csum_flags);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	csum = inet6_cksum(m, 0, offset, plen - olen);

	<span class="enscript-comment">/* Update stats */</span>
	ip6_out_cksum_stats(nxt, plen - olen);

	<span class="enscript-comment">/* RFC1122 4.1.3.4 */</span>
	<span class="enscript-keyword">if</span> (csum == 0 &amp;&amp; (m-&gt;m_pkthdr.csum_flags &amp; CSUM_UDPIPV6))
		csum = 0xffff;

	<span class="enscript-comment">/* Insert the checksum in the ULP csum field */</span>
	offset += ulpoff;
	<span class="enscript-keyword">if</span> ((offset + <span class="enscript-keyword">sizeof</span> (csum)) &gt; m-&gt;m_len) {
		m_copyback(m, offset, <span class="enscript-keyword">sizeof</span> (csum), &amp;csum);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IP6_HDR_ALIGNED_P(mtod(m, <span class="enscript-type">char</span> *) + hoff)) {
		*(uint16_t *)(<span class="enscript-type">void</span> *)(mtod(m, <span class="enscript-type">char</span> *) + offset) = csum;
	} <span class="enscript-keyword">else</span> {
		bcopy(&amp;csum, (mtod(m, <span class="enscript-type">char</span> *) + offset), <span class="enscript-keyword">sizeof</span> (csum));
	}
	m-&gt;m_pkthdr.csum_flags &amp;=
	    ~(CSUM_DELAY_IPV6_DATA | CSUM_DATA_VALID | CSUM_PARTIAL);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (sw_csum);
}

<span class="enscript-comment">/*
 * Insert jumbo payload option.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_insert_jumboopt</span>(<span class="enscript-type">struct</span> ip6_exthdrs *exthdrs, u_int32_t plen)
{
	<span class="enscript-type">struct</span> mbuf *mopt;
	u_char *optbuf;
	u_int32_t v;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">JUMBOOPTLEN</span>	8	<span class="enscript-comment">/* length of jumbo payload option and padding */</span>

	<span class="enscript-comment">/*
	 * If there is no hop-by-hop options header, allocate new one.
	 * If there is one but it doesn't have enough space to store the
	 * jumbo payload option, allocate a cluster to store the whole options.
	 * Otherwise, use it to store the options.
	 */</span>
	<span class="enscript-keyword">if</span> (exthdrs-&gt;ip6e_hbh == NULL) {
		MGET(mopt, M_DONTWAIT, MT_DATA);
		<span class="enscript-keyword">if</span> (mopt == NULL)
			<span class="enscript-keyword">return</span> (ENOBUFS);
		mopt-&gt;m_len = JUMBOOPTLEN;
		optbuf = mtod(mopt, u_char *);
		optbuf[1] = 0;	<span class="enscript-comment">/* = ((JUMBOOPTLEN) &gt;&gt; 3) - 1 */</span>
		exthdrs-&gt;ip6e_hbh = mopt;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> ip6_hbh *hbh;

		mopt = exthdrs-&gt;ip6e_hbh;
		<span class="enscript-keyword">if</span> (M_TRAILINGSPACE(mopt) &lt; JUMBOOPTLEN) {
			<span class="enscript-comment">/*
			 * XXX assumption:
			 * - exthdrs-&gt;ip6e_hbh is not referenced from places
			 *   other than exthdrs.
			 * - exthdrs-&gt;ip6e_hbh is not an mbuf chain.
			 */</span>
			u_int32_t oldoptlen = mopt-&gt;m_len;
			<span class="enscript-type">struct</span> mbuf *n;

			<span class="enscript-comment">/*
			 * XXX: give up if the whole (new) hbh header does
			 * not fit even in an mbuf cluster.
			 */</span>
			<span class="enscript-keyword">if</span> (oldoptlen + JUMBOOPTLEN &gt; MCLBYTES)
				<span class="enscript-keyword">return</span> (ENOBUFS);

			<span class="enscript-comment">/*
			 * As a consequence, we must always prepare a cluster
			 * at this point.
			 */</span>
			MGET(n, M_DONTWAIT, MT_DATA);
			<span class="enscript-keyword">if</span> (n != NULL) {
				MCLGET(n, M_DONTWAIT);
				<span class="enscript-keyword">if</span> (!(n-&gt;m_flags &amp; M_EXT)) {
					m_freem(n);
					n = NULL;
				}
			}
			<span class="enscript-keyword">if</span> (n == NULL)
				<span class="enscript-keyword">return</span> (ENOBUFS);
			n-&gt;m_len = oldoptlen + JUMBOOPTLEN;
			bcopy(mtod(mopt, caddr_t), mtod(n, caddr_t),
			    oldoptlen);
			optbuf = mtod(n, u_char *) + oldoptlen;
			m_freem(mopt);
			mopt = exthdrs-&gt;ip6e_hbh = n;
		} <span class="enscript-keyword">else</span> {
			optbuf = mtod(mopt, u_char *) + mopt-&gt;m_len;
			mopt-&gt;m_len += JUMBOOPTLEN;
		}
		optbuf[0] = IP6OPT_PADN;
		optbuf[1] = 1;

		<span class="enscript-comment">/*
		 * Adjust the header length according to the pad and
		 * the jumbo payload option.
		 */</span>
		hbh = mtod(mopt, <span class="enscript-type">struct</span> ip6_hbh *);
		hbh-&gt;ip6h_len += (JUMBOOPTLEN &gt;&gt; 3);
	}

	<span class="enscript-comment">/* fill in the option. */</span>
	optbuf[2] = IP6OPT_JUMBO;
	optbuf[3] = 4;
	v = (u_int32_t)htonl(plen + JUMBOOPTLEN);
	bcopy(&amp;v, &amp;optbuf[4], <span class="enscript-keyword">sizeof</span> (u_int32_t));

	<span class="enscript-comment">/* finally, adjust the packet header length */</span>
	exthdrs-&gt;ip6e_ip6-&gt;m_pkthdr.len += JUMBOOPTLEN;

	<span class="enscript-keyword">return</span> (0);
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">JUMBOOPTLEN</span>
}

<span class="enscript-comment">/*
 * Insert fragment header and copy unfragmentable header portions.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_insertfraghdr</span>(<span class="enscript-type">struct</span> mbuf *m0, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> hlen,
    <span class="enscript-type">struct</span> ip6_frag **frghdrp)
{
	<span class="enscript-type">struct</span> mbuf *n, *mlast;

	<span class="enscript-keyword">if</span> (hlen &gt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr)) {
		n = m_copym(m0, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr),
		    hlen - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr), M_DONTWAIT);
		<span class="enscript-keyword">if</span> (n == NULL)
			<span class="enscript-keyword">return</span> (ENOBUFS);
		m-&gt;m_next = n;
	} <span class="enscript-keyword">else</span>
		n = m;

	<span class="enscript-comment">/* Search for the last mbuf of unfragmentable part. */</span>
	<span class="enscript-keyword">for</span> (mlast = n; mlast-&gt;m_next; mlast = mlast-&gt;m_next)
		;

	<span class="enscript-keyword">if</span> (!(mlast-&gt;m_flags &amp; M_EXT) &amp;&amp;
	    M_TRAILINGSPACE(mlast) &gt;= <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_frag)) {
		<span class="enscript-comment">/* use the trailing space of the last mbuf for the frag hdr */</span>
		*frghdrp = (<span class="enscript-type">struct</span> ip6_frag *)(mtod(mlast, caddr_t) +
		    mlast-&gt;m_len);
		mlast-&gt;m_len += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_frag);
		m-&gt;m_pkthdr.len += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_frag);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* allocate a new mbuf for the fragment header */</span>
		<span class="enscript-type">struct</span> mbuf *mfrg;

		MGET(mfrg, M_DONTWAIT, MT_DATA);
		<span class="enscript-keyword">if</span> (mfrg == NULL)
			<span class="enscript-keyword">return</span> (ENOBUFS);
		mfrg-&gt;m_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_frag);
		*frghdrp = mtod(mfrg, <span class="enscript-type">struct</span> ip6_frag *);
		mlast-&gt;m_next = mfrg;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_getpmtu</span>(<span class="enscript-type">struct</span> route_in6 *ro_pmtu, <span class="enscript-type">struct</span> route_in6 *ro,
    <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> in6_addr *dst, u_int32_t *mtup,
    boolean_t *alwaysfragp)
{
	u_int32_t mtu = 0;
	boolean_t alwaysfrag = FALSE;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (ro_pmtu != ro) {
		<span class="enscript-comment">/* The first hop and the final destination may differ. */</span>
		<span class="enscript-type">struct</span> sockaddr_in6 *sa6_dst = SIN6(&amp;ro_pmtu-&gt;ro_dst);
		<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro_pmtu) ||
		    !IN6_ARE_ADDR_EQUAL(&amp;sa6_dst-&gt;sin6_addr, dst))
			ROUTE_RELEASE(ro_pmtu);

		<span class="enscript-keyword">if</span> (ro_pmtu-&gt;ro_rt == NULL) {
			bzero(sa6_dst, <span class="enscript-keyword">sizeof</span> (*sa6_dst));
			sa6_dst-&gt;sin6_family = AF_INET6;
			sa6_dst-&gt;sin6_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
			sa6_dst-&gt;sin6_addr = *dst;

			rtalloc_scoped((<span class="enscript-type">struct</span> route *)ro_pmtu,
			    ifp != NULL ? ifp-&gt;if_index : IFSCOPE_NONE);
		}
	}

	<span class="enscript-keyword">if</span> (ro_pmtu-&gt;ro_rt != NULL) {
		u_int32_t ifmtu;

		<span class="enscript-keyword">if</span> (ifp == NULL)
			ifp = ro_pmtu-&gt;ro_rt-&gt;rt_ifp;
		<span class="enscript-comment">/* Access without acquiring nd_ifinfo lock for performance */</span>
		ifmtu = IN6_LINKMTU(ifp);

		<span class="enscript-comment">/*
		 * Access rmx_mtu without holding the route entry lock,
		 * for performance; this isn't something that changes
		 * often, so optimize.
		 */</span>
		mtu = ro_pmtu-&gt;ro_rt-&gt;rt_rmx.rmx_mtu;
		<span class="enscript-keyword">if</span> (mtu &gt; ifmtu || mtu == 0) {
			<span class="enscript-comment">/*
			 * The MTU on the route is larger than the MTU on
			 * the interface!  This shouldn't happen, unless the
			 * MTU of the interface has been changed after the
			 * interface was brought up.  Change the MTU in the
			 * route to match the interface MTU (as long as the
			 * field isn't locked).
			 *
			 * if MTU on the route is 0, we need to fix the MTU.
			 * this case happens with path MTU discovery timeouts.
			 */</span>
			mtu = ifmtu;
			<span class="enscript-keyword">if</span> (!(ro_pmtu-&gt;ro_rt-&gt;rt_rmx.rmx_locks &amp; RTV_MTU))
				ro_pmtu-&gt;ro_rt-&gt;rt_rmx.rmx_mtu = mtu; <span class="enscript-comment">/* XXX */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mtu &lt; IPV6_MMTU) {
			<span class="enscript-comment">/*
			 * RFC2460 section 5, last paragraph:
			 * if we record ICMPv6 too big message with
			 * mtu &lt; IPV6_MMTU, transmit packets sized IPV6_MMTU
			 * or smaller, with framgent header attached.
			 * (fragment header is needed regardless from the
			 * packet size, for translators to identify packets)
			 */</span>
			alwaysfrag = TRUE;
			mtu = IPV6_MMTU;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (ifp) {
			<span class="enscript-comment">/* Don't hold nd_ifinfo lock for performance */</span>
			mtu = IN6_LINKMTU(ifp);
		} <span class="enscript-keyword">else</span> {
			error = EHOSTUNREACH; <span class="enscript-comment">/* XXX */</span>
		}
	}

	*mtup = mtu;
	<span class="enscript-keyword">if</span> (alwaysfragp != NULL)
		*alwaysfragp = alwaysfrag;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * IP6 socket option processing.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_ctloutput</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-type">int</span> optdatalen, uproto;
	<span class="enscript-type">void</span> *optdata;
	<span class="enscript-type">int</span> privileged;
	<span class="enscript-type">struct</span> inpcb *in6p = sotoinpcb(so);
	<span class="enscript-type">int</span> error = 0, optval = 0;
	<span class="enscript-type">int</span> level, op = -1, optname = 0;
	<span class="enscript-type">int</span> optlen = 0;
	<span class="enscript-type">struct</span> proc *p;

	VERIFY(sopt != NULL);

	level = sopt-&gt;sopt_level;
	op = sopt-&gt;sopt_dir;
	optname = sopt-&gt;sopt_name;
	optlen = sopt-&gt;sopt_valsize;
	p = sopt-&gt;sopt_p;
	uproto = (<span class="enscript-type">int</span>)SOCK_PROTO(so);

	privileged = (proc_suser(p) == 0);

	<span class="enscript-keyword">if</span> (level == IPPROTO_IPV6) {
		<span class="enscript-keyword">switch</span> (op) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_SET</span>:
			<span class="enscript-keyword">switch</span> (optname) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292PKTOPTIONS</span>: {
				<span class="enscript-type">struct</span> mbuf *m;

				error = soopt_getm(sopt, &amp;m);
				<span class="enscript-keyword">if</span> (error != 0)
					<span class="enscript-keyword">break</span>;
				error = soopt_mcopyin(sopt, m);
				<span class="enscript-keyword">if</span> (error != 0)
					<span class="enscript-keyword">break</span>;
				error = ip6_pcbopts(&amp;in6p-&gt;in6p_outputopts,
				    m, so, sopt);
				m_freem(m);
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/*
			 * Use of some Hop-by-Hop options or some
			 * Destination options, might require special
			 * privilege.  That is, normal applications
			 * (without special privilege) might be forbidden
			 * from setting certain options in outgoing packets,
			 * and might never see certain options in received
			 * packets. [RFC 2292 Section 6]
			 * KAME specific note:
			 *  KAME prevents non-privileged users from sending or
			 *  receiving ANY hbh/dst options in order to avoid
			 *  overhead of parsing options in the kernel.
			 */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVHOPOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVDSTOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVRTHDRDSTOPTS</span>:
				<span class="enscript-keyword">if</span> (!privileged)
					<span class="enscript-keyword">break</span>;
				<span class="enscript-comment">/* FALLTHROUGH */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_UNICAST_HOPS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_HOPLIMIT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVPKTINFO</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVHOPLIMIT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVRTHDR</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVPATHMTU</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVTCLASS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_V6ONLY</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_AUTOFLOWLABEL</span>:
				<span class="enscript-keyword">if</span> (optlen != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>)) {
					error = EINVAL;
					<span class="enscript-keyword">break</span>;
				}
				error = sooptcopyin(sopt, &amp;optval,
				    <span class="enscript-keyword">sizeof</span> (optval), <span class="enscript-keyword">sizeof</span> (optval));
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">switch</span> (optname) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_UNICAST_HOPS</span>:
					<span class="enscript-keyword">if</span> (optval &lt; -1 || optval &gt;= 256) {
						error = EINVAL;
					} <span class="enscript-keyword">else</span> {
						<span class="enscript-comment">/* -1 = kernel default */</span>
						in6p-&gt;in6p_hops = optval;
						<span class="enscript-keyword">if</span> (in6p-&gt;inp_vflag &amp;
						    INP_IPV4) {
							in6p-&gt;inp_ip_ttl =
							    optval;
						}
					}
					<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">OPTSET</span>(bit) do {						\
	<span class="enscript-keyword">if</span> (optval)							\
		in6p-&gt;inp_flags |= (bit);				\
	<span class="enscript-keyword">else</span>								\
		in6p-&gt;inp_flags &amp;= ~(bit);				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">OPTSET2292</span>(bit) do {						\
	in6p-&gt;inp_flags |= IN6P_RFC2292;				\
	<span class="enscript-keyword">if</span> (optval)							\
		in6p-&gt;inp_flags |= (bit);				\
	<span class="enscript-keyword">else</span>								\
		in6p-&gt;inp_flags &amp;= ~(bit);				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">OPTBIT</span>(bit) (in6p-&gt;inp_flags &amp; (bit) ? 1 : 0)

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVPKTINFO</span>:
					<span class="enscript-comment">/* cannot mix with RFC2292 */</span>
					<span class="enscript-keyword">if</span> (OPTBIT(IN6P_RFC2292)) {
						error = EINVAL;
						<span class="enscript-keyword">break</span>;
					}
					OPTSET(IN6P_PKTINFO);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_HOPLIMIT</span>: {
					<span class="enscript-type">struct</span> ip6_pktopts **optp;

					<span class="enscript-comment">/* cannot mix with RFC2292 */</span>
					<span class="enscript-keyword">if</span> (OPTBIT(IN6P_RFC2292)) {
						error = EINVAL;
						<span class="enscript-keyword">break</span>;
					}
					optp = &amp;in6p-&gt;in6p_outputopts;
					error = ip6_pcbopt(IPV6_HOPLIMIT,
					    (u_char *)&amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
					    optp, uproto);
					<span class="enscript-keyword">break</span>;
				}

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVHOPLIMIT</span>:
					<span class="enscript-comment">/* cannot mix with RFC2292 */</span>
					<span class="enscript-keyword">if</span> (OPTBIT(IN6P_RFC2292)) {
						error = EINVAL;
						<span class="enscript-keyword">break</span>;
					}
					OPTSET(IN6P_HOPLIMIT);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVHOPOPTS</span>:
					<span class="enscript-comment">/* cannot mix with RFC2292 */</span>
					<span class="enscript-keyword">if</span> (OPTBIT(IN6P_RFC2292)) {
						error = EINVAL;
						<span class="enscript-keyword">break</span>;
					}
					OPTSET(IN6P_HOPOPTS);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVDSTOPTS</span>:
					<span class="enscript-comment">/* cannot mix with RFC2292 */</span>
					<span class="enscript-keyword">if</span> (OPTBIT(IN6P_RFC2292)) {
						error = EINVAL;
						<span class="enscript-keyword">break</span>;
					}
					OPTSET(IN6P_DSTOPTS);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVRTHDRDSTOPTS</span>:
					<span class="enscript-comment">/* cannot mix with RFC2292 */</span>
					<span class="enscript-keyword">if</span> (OPTBIT(IN6P_RFC2292)) {
						error = EINVAL;
						<span class="enscript-keyword">break</span>;
					}
					OPTSET(IN6P_RTHDRDSTOPTS);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVRTHDR</span>:
					<span class="enscript-comment">/* cannot mix with RFC2292 */</span>
					<span class="enscript-keyword">if</span> (OPTBIT(IN6P_RFC2292)) {
						error = EINVAL;
						<span class="enscript-keyword">break</span>;
					}
					OPTSET(IN6P_RTHDR);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVPATHMTU</span>:
					<span class="enscript-comment">/*
					 * We ignore this option for TCP
					 * sockets.
					 * (RFC3542 leaves this case
					 * unspecified.)
					 */</span>
					<span class="enscript-keyword">if</span> (uproto != IPPROTO_TCP)
						OPTSET(IN6P_MTU);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_V6ONLY</span>:
					<span class="enscript-comment">/*
					 * make setsockopt(IPV6_V6ONLY)
					 * available only prior to bind(2).
					 * see ipng mailing list, Jun 22 2001.
					 */</span>
					<span class="enscript-keyword">if</span> (in6p-&gt;inp_lport ||
					    !IN6_IS_ADDR_UNSPECIFIED(
					    &amp;in6p-&gt;in6p_laddr)) {
						error = EINVAL;
						<span class="enscript-keyword">break</span>;
					}
					OPTSET(IN6P_IPV6_V6ONLY);
					<span class="enscript-keyword">if</span> (optval)
						in6p-&gt;inp_vflag &amp;= ~INP_IPV4;
					<span class="enscript-keyword">else</span>
						in6p-&gt;inp_vflag |= INP_IPV4;
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVTCLASS</span>:
					<span class="enscript-comment">/* we can mix with RFC2292 */</span>
					OPTSET(IN6P_TCLASS);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_AUTOFLOWLABEL</span>:
					OPTSET(IN6P_AUTOFLOWLABEL);
					<span class="enscript-keyword">break</span>;

				}
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_TCLASS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_DONTFRAG</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_USE_MIN_MTU</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PREFER_TEMPADDR</span>: {
				<span class="enscript-type">struct</span> ip6_pktopts **optp;

				<span class="enscript-keyword">if</span> (optlen != <span class="enscript-keyword">sizeof</span> (optval)) {
					error = EINVAL;
					<span class="enscript-keyword">break</span>;
				}
				error = sooptcopyin(sopt, &amp;optval,
				    <span class="enscript-keyword">sizeof</span> (optval), <span class="enscript-keyword">sizeof</span> (optval));
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">break</span>;

				optp = &amp;in6p-&gt;in6p_outputopts;
				error = ip6_pcbopt(optname, (u_char *)&amp;optval,
				    <span class="enscript-keyword">sizeof</span> (optval), optp, uproto);
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292PKTINFO</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292HOPLIMIT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292HOPOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292DSTOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292RTHDR</span>:
				<span class="enscript-comment">/* RFC 2292 */</span>
				<span class="enscript-keyword">if</span> (optlen != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>)) {
					error = EINVAL;
					<span class="enscript-keyword">break</span>;
				}
				error = sooptcopyin(sopt, &amp;optval,
				    <span class="enscript-keyword">sizeof</span> (optval), <span class="enscript-keyword">sizeof</span> (optval));
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">switch</span> (optname) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292PKTINFO</span>:
					OPTSET2292(IN6P_PKTINFO);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292HOPLIMIT</span>:
					OPTSET2292(IN6P_HOPLIMIT);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292HOPOPTS</span>:
					<span class="enscript-comment">/*
					 * Check super-user privilege.
					 * See comments for IPV6_RECVHOPOPTS.
					 */</span>
					<span class="enscript-keyword">if</span> (!privileged)
						<span class="enscript-keyword">return</span> (EPERM);
					OPTSET2292(IN6P_HOPOPTS);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292DSTOPTS</span>:
					<span class="enscript-keyword">if</span> (!privileged)
						<span class="enscript-keyword">return</span> (EPERM);
					OPTSET2292(IN6P_DSTOPTS|
					    IN6P_RTHDRDSTOPTS); <span class="enscript-comment">/* XXX */</span>
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292RTHDR</span>:
					OPTSET2292(IN6P_RTHDR);
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_3542PKTINFO</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_3542HOPOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_3542RTHDR</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_3542DSTOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RTHDRDSTOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_3542NEXTHOP</span>: {
				<span class="enscript-type">struct</span> ip6_pktopts **optp;
				<span class="enscript-comment">/* new advanced API (RFC3542) */</span>
				<span class="enscript-type">struct</span> mbuf *m;

				<span class="enscript-comment">/* cannot mix with RFC2292 */</span>
				<span class="enscript-keyword">if</span> (OPTBIT(IN6P_RFC2292)) {
					error = EINVAL;
					<span class="enscript-keyword">break</span>;
				}
				error = soopt_getm(sopt, &amp;m);
				<span class="enscript-keyword">if</span> (error != 0)
					<span class="enscript-keyword">break</span>;
				error = soopt_mcopyin(sopt, m);
				<span class="enscript-keyword">if</span> (error != 0)
					<span class="enscript-keyword">break</span>;

				optp = &amp;in6p-&gt;in6p_outputopts;
				error = ip6_pcbopt(optname, mtod(m, u_char *),
				    m-&gt;m_len, optp, uproto);
				m_freem(m);
				<span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">OPTSET</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_MULTICAST_IF</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_MULTICAST_HOPS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_MULTICAST_LOOP</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_JOIN_GROUP</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_LEAVE_GROUP</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_MSFILTER</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">MCAST_BLOCK_SOURCE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">MCAST_UNBLOCK_SOURCE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">MCAST_JOIN_GROUP</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">MCAST_LEAVE_GROUP</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">MCAST_JOIN_SOURCE_GROUP</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">MCAST_LEAVE_SOURCE_GROUP</span>:
				error = ip6_setmoptions(in6p, sopt);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PORTRANGE</span>:
				error = sooptcopyin(sopt, &amp;optval,
				    <span class="enscript-keyword">sizeof</span> (optval), <span class="enscript-keyword">sizeof</span> (optval));
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">switch</span> (optval) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PORTRANGE_DEFAULT</span>:
					in6p-&gt;inp_flags &amp;= ~(INP_LOWPORT);
					in6p-&gt;inp_flags &amp;= ~(INP_HIGHPORT);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PORTRANGE_HIGH</span>:
					in6p-&gt;inp_flags &amp;= ~(INP_LOWPORT);
					in6p-&gt;inp_flags |= INP_HIGHPORT;
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PORTRANGE_LOW</span>:
					in6p-&gt;inp_flags &amp;= ~(INP_HIGHPORT);
					in6p-&gt;inp_flags |= INP_LOWPORT;
					<span class="enscript-keyword">break</span>;

				<span class="enscript-reference">default</span>:
					error = EINVAL;
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_IPSEC_POLICY</span>: {
				caddr_t req = NULL;
				size_t len = 0;
				<span class="enscript-type">struct</span> mbuf *m;
				
				<span class="enscript-keyword">if</span> ((error = soopt_getm(sopt, &amp;m)) != 0)
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">if</span> ((error = soopt_mcopyin(sopt, m)) != 0)
					<span class="enscript-keyword">break</span>;
				
				req = mtod(m, caddr_t);
				len = m-&gt;m_len;
				error = ipsec6_set_policy(in6p, optname, req,
					len, privileged);
				m_freem(m);
				<span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_ADD</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_DEL</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_FLUSH</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_ZERO</span>: {
				<span class="enscript-keyword">if</span> (ip6_fw_ctl_ptr == NULL)
					load_ip6fw();
				<span class="enscript-keyword">if</span> (ip6_fw_ctl_ptr != NULL)
					error = (*ip6_fw_ctl_ptr)(sopt);
				<span class="enscript-keyword">else</span>
					error = ENOPROTOOPT;
				<span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>
			<span class="enscript-comment">/*
			 * IPv6 variant of IP_BOUND_IF; for details see
			 * comments on IP_BOUND_IF in ip_ctloutput().
			 */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_BOUND_IF</span>:
				<span class="enscript-comment">/* This option is settable only on IPv6 */</span>
				<span class="enscript-keyword">if</span> (!(in6p-&gt;inp_vflag &amp; INP_IPV6)) {
					error = EINVAL;
					<span class="enscript-keyword">break</span>;
				}

				error = sooptcopyin(sopt, &amp;optval,
				    <span class="enscript-keyword">sizeof</span> (optval), <span class="enscript-keyword">sizeof</span> (optval));

				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">break</span>;

				error = inp_bindif(in6p, optval, NULL);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_NO_IFT_CELLULAR</span>:
				<span class="enscript-comment">/* This option is settable only for IPv6 */</span>
				<span class="enscript-keyword">if</span> (!(in6p-&gt;inp_vflag &amp; INP_IPV6)) {
					error = EINVAL;
					<span class="enscript-keyword">break</span>;
				}

				error = sooptcopyin(sopt, &amp;optval,
				    <span class="enscript-keyword">sizeof</span> (optval), <span class="enscript-keyword">sizeof</span> (optval));

				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">break</span>;

				<span class="enscript-comment">/* once set, it cannot be unset */</span>
				<span class="enscript-keyword">if</span> (!optval &amp;&amp; INP_NO_CELLULAR(in6p)) {
					error = EINVAL;
					<span class="enscript-keyword">break</span>;
				}

				error = so_set_restrictions(so,
				    SO_RESTRICT_DENY_CELLULAR);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_OUT_IF</span>:
				<span class="enscript-comment">/* This option is not settable */</span>
				error = EINVAL;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-reference">default</span>:
				error = ENOPROTOOPT;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_GET</span>:
			<span class="enscript-keyword">switch</span> (optname) {

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292PKTOPTIONS</span>:
				<span class="enscript-comment">/*
				 * RFC3542 (effectively) deprecated the
				 * semantics of the 2292-style pktoptions.
				 * Since it was not reliable in nature (i.e.,
				 * applications had to expect the lack of some
				 * information after all), it would make sense
				 * to simplify this part by always returning
				 * empty data.
				 */</span>
				sopt-&gt;sopt_valsize = 0;
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVHOPOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVDSTOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVRTHDRDSTOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_UNICAST_HOPS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVPKTINFO</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVHOPLIMIT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVRTHDR</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVPATHMTU</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_V6ONLY</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PORTRANGE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVTCLASS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_AUTOFLOWLABEL</span>:
				<span class="enscript-keyword">switch</span> (optname) {

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVHOPOPTS</span>:
					optval = OPTBIT(IN6P_HOPOPTS);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVDSTOPTS</span>:
					optval = OPTBIT(IN6P_DSTOPTS);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVRTHDRDSTOPTS</span>:
					optval = OPTBIT(IN6P_RTHDRDSTOPTS);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_UNICAST_HOPS</span>:
					optval = in6p-&gt;in6p_hops;
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVPKTINFO</span>:
					optval = OPTBIT(IN6P_PKTINFO);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVHOPLIMIT</span>:
					optval = OPTBIT(IN6P_HOPLIMIT);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVRTHDR</span>:
					optval = OPTBIT(IN6P_RTHDR);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVPATHMTU</span>:
					optval = OPTBIT(IN6P_MTU);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_V6ONLY</span>:
					optval = OPTBIT(IN6P_IPV6_V6ONLY);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PORTRANGE</span>: {
					<span class="enscript-type">int</span> flags;
					flags = in6p-&gt;inp_flags;
					<span class="enscript-keyword">if</span> (flags &amp; INP_HIGHPORT)
						optval = IPV6_PORTRANGE_HIGH;
					<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; INP_LOWPORT)
						optval = IPV6_PORTRANGE_LOW;
					<span class="enscript-keyword">else</span>
						optval = 0;
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RECVTCLASS</span>:
					optval = OPTBIT(IN6P_TCLASS);
					<span class="enscript-keyword">break</span>;

				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_AUTOFLOWLABEL</span>:
					optval = OPTBIT(IN6P_AUTOFLOWLABEL);
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">break</span>;
				error = sooptcopyout(sopt, &amp;optval,
				    <span class="enscript-keyword">sizeof</span> (optval));
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PATHMTU</span>: {
				u_int32_t pmtu = 0;
				<span class="enscript-type">struct</span> ip6_mtuinfo mtuinfo;
				<span class="enscript-type">struct</span> route_in6 sro;

				bzero(&amp;sro, <span class="enscript-keyword">sizeof</span> (sro));

				<span class="enscript-keyword">if</span> (!(so-&gt;so_state &amp; SS_ISCONNECTED))
					<span class="enscript-keyword">return</span> (ENOTCONN);
				<span class="enscript-comment">/*
				 * XXX: we dot not consider the case of source
				 * routing, or optional information to specify
				 * the outgoing interface.
				 */</span>
				error = ip6_getpmtu(&amp;sro, NULL, NULL,
				    &amp;in6p-&gt;in6p_faddr, &amp;pmtu, NULL);
				ROUTE_RELEASE(&amp;sro);
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">if</span> (pmtu &gt; IPV6_MAXPACKET)
					pmtu = IPV6_MAXPACKET;

				bzero(&amp;mtuinfo, <span class="enscript-keyword">sizeof</span> (mtuinfo));
				mtuinfo.ip6m_mtu = (u_int32_t)pmtu;
				optdata = (<span class="enscript-type">void</span> *)&amp;mtuinfo;
				optdatalen = <span class="enscript-keyword">sizeof</span> (mtuinfo);
				error = sooptcopyout(sopt, optdata,
				    optdatalen);
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292PKTINFO</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292HOPLIMIT</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292HOPOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292RTHDR</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292DSTOPTS</span>:
				<span class="enscript-keyword">switch</span> (optname) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292PKTINFO</span>:
					optval = OPTBIT(IN6P_PKTINFO);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292HOPLIMIT</span>:
					optval = OPTBIT(IN6P_HOPLIMIT);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292HOPOPTS</span>:
					optval = OPTBIT(IN6P_HOPOPTS);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292RTHDR</span>:
					optval = OPTBIT(IN6P_RTHDR);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292DSTOPTS</span>:
					optval = OPTBIT(IN6P_DSTOPTS|
					    IN6P_RTHDRDSTOPTS);
					<span class="enscript-keyword">break</span>;
				}
				error = sooptcopyout(sopt, &amp;optval,
				    <span class="enscript-keyword">sizeof</span> (optval));
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PKTINFO</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_HOPOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RTHDR</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_DSTOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RTHDRDSTOPTS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_NEXTHOP</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_TCLASS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_DONTFRAG</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_USE_MIN_MTU</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PREFER_TEMPADDR</span>:
				error = ip6_getpcbopt(in6p-&gt;in6p_outputopts,
				    optname, sopt);
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_MULTICAST_IF</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_MULTICAST_HOPS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_MULTICAST_LOOP</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_MSFILTER</span>:
				error = ip6_getmoptions(in6p, sopt);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_IPSEC_POLICY</span>: {
				error = 0; <span class="enscript-comment">/* This option is no longer supported */</span>
				<span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPFIREWALL</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_FW_GET</span>: {
				<span class="enscript-keyword">if</span> (ip6_fw_ctl_ptr == NULL)
					load_ip6fw();
				<span class="enscript-keyword">if</span> (ip6_fw_ctl_ptr != NULL)
					error = (*ip6_fw_ctl_ptr)(sopt);
				<span class="enscript-keyword">else</span>
					error = ENOPROTOOPT;
				<span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPFIREWALL */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_BOUND_IF</span>:
				<span class="enscript-keyword">if</span> (in6p-&gt;inp_flags &amp; INP_BOUND_IF)
					optval = in6p-&gt;inp_boundifp-&gt;if_index;
				error = sooptcopyout(sopt, &amp;optval,
				    <span class="enscript-keyword">sizeof</span> (optval));
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_NO_IFT_CELLULAR</span>:
				optval = INP_NO_CELLULAR(in6p) ? 1 : 0;
				error = sooptcopyout(sopt, &amp;optval,
				    <span class="enscript-keyword">sizeof</span> (optval));
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_OUT_IF</span>:
				optval = (in6p-&gt;in6p_last_outifp != NULL) ?
				    in6p-&gt;in6p_last_outifp-&gt;if_index : 0;
				error = sooptcopyout(sopt, &amp;optval,
				    <span class="enscript-keyword">sizeof</span> (optval));
				<span class="enscript-keyword">break</span>;

			<span class="enscript-reference">default</span>:
				error = ENOPROTOOPT;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">break</span>;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (level == IPPROTO_UDP) {
		error = udp_ctloutput(so, sopt);
	} <span class="enscript-keyword">else</span> {
		error = EINVAL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_raw_ctloutput</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-type">int</span> error = 0, optval, optlen;
	<span class="enscript-type">const</span> <span class="enscript-type">int</span> icmp6off = offsetof(<span class="enscript-type">struct</span> icmp6_hdr, icmp6_cksum);
	<span class="enscript-type">struct</span> inpcb *in6p = sotoinpcb(so);
	<span class="enscript-type">int</span> level, op, optname;

	level = sopt-&gt;sopt_level;
	op = sopt-&gt;sopt_dir;
	optname = sopt-&gt;sopt_name;
	optlen = sopt-&gt;sopt_valsize;

	<span class="enscript-keyword">if</span> (level != IPPROTO_IPV6)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">switch</span> (optname) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_CHECKSUM</span>:
		<span class="enscript-comment">/*
		 * For ICMPv6 sockets, no modification allowed for checksum
		 * offset, permit &quot;no change&quot; values to help existing apps.
		 *
		 * RFC3542 says: &quot;An attempt to set IPV6_CHECKSUM
		 * for an ICMPv6 socket will fail.&quot;
		 * The current behavior does not meet RFC3542.
		 */</span>
		<span class="enscript-keyword">switch</span> (op) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_SET</span>:
			<span class="enscript-keyword">if</span> (optlen != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>)) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> ((optval % 2) != 0) {
				<span class="enscript-comment">/* the API assumes even offset values */</span>
				error = EINVAL;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SOCK_PROTO(so) == IPPROTO_ICMPV6) {
				<span class="enscript-keyword">if</span> (optval != icmp6off)
					error = EINVAL;
			} <span class="enscript-keyword">else</span> {
				in6p-&gt;in6p_cksum = optval;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_GET</span>:
			<span class="enscript-keyword">if</span> (SOCK_PROTO(so) == IPPROTO_ICMPV6)
				optval = icmp6off;
			<span class="enscript-keyword">else</span>
				optval = in6p-&gt;in6p_cksum;

			error = sooptcopyout(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = ENOPROTOOPT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Set up IP6 options in pcb for insertion in output packets or
 * specifying behavior of outgoing packets.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_pcbopts</span>(<span class="enscript-type">struct</span> ip6_pktopts **pktopt, <span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> socket *so,
    <span class="enscript-type">struct</span> sockopt *sopt)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">sopt</span>)
	<span class="enscript-type">struct</span> ip6_pktopts *opt = *pktopt;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/* turn off any old options. */</span>
	<span class="enscript-keyword">if</span> (opt != NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		<span class="enscript-keyword">if</span> (opt-&gt;ip6po_pktinfo || opt-&gt;ip6po_nexthop ||
		    opt-&gt;ip6po_hbh || opt-&gt;ip6po_dest1 || opt-&gt;ip6po_dest2 ||
		    opt-&gt;ip6po_rhinfo.ip6po_rhi_rthdr)
			printf(<span class="enscript-string">&quot;%s: all specified options are cleared.\n&quot;</span>,
			    __func__);
#<span class="enscript-reference">endif</span>
		ip6_clearpktopts(opt, -1);
	} <span class="enscript-keyword">else</span> {
		opt = _MALLOC(<span class="enscript-keyword">sizeof</span> (*opt), M_IP6OPT, M_WAITOK);
		<span class="enscript-keyword">if</span> (opt == NULL)
			<span class="enscript-keyword">return</span> (ENOBUFS);
	}
	*pktopt = NULL;

	<span class="enscript-keyword">if</span> (m == NULL || m-&gt;m_len == 0) {
		<span class="enscript-comment">/*
		 * Only turning off any previous options, regardless of
		 * whether the opt is just created or given.
		 */</span>
		<span class="enscript-keyword">if</span> (opt != NULL)
			FREE(opt, M_IP6OPT);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*  set options specified by user. */</span>
	<span class="enscript-keyword">if</span> ((error = ip6_setpktopts(m, opt, NULL, SOCK_PROTO(so))) != 0) {
		ip6_clearpktopts(opt, -1); <span class="enscript-comment">/* XXX: discard all options */</span>
		FREE(opt, M_IP6OPT);
		<span class="enscript-keyword">return</span> (error);
	}
	*pktopt = opt;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * initialize ip6_pktopts.  beware that there are non-zero default values in
 * the struct.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_initpktopts</span>(<span class="enscript-type">struct</span> ip6_pktopts *opt)
{

	bzero(opt, <span class="enscript-keyword">sizeof</span> (*opt));
	opt-&gt;ip6po_hlim = -1;	<span class="enscript-comment">/* -1 means default hop limit */</span>
	opt-&gt;ip6po_tclass = -1;	<span class="enscript-comment">/* -1 means default traffic class */</span>
	opt-&gt;ip6po_minmtu = IP6PO_MINMTU_MCASTONLY;
	opt-&gt;ip6po_prefer_tempaddr = IP6PO_TEMPADDR_SYSTEM;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_pcbopt</span>(<span class="enscript-type">int</span> optname, u_char *buf, <span class="enscript-type">int</span> len, <span class="enscript-type">struct</span> ip6_pktopts **pktopt,
    <span class="enscript-type">int</span> uproto)
{
	<span class="enscript-type">struct</span> ip6_pktopts *opt;

	opt = *pktopt;
	<span class="enscript-keyword">if</span> (opt == NULL) {
		opt = _MALLOC(<span class="enscript-keyword">sizeof</span> (*opt), M_IP6OPT, M_WAITOK);
		<span class="enscript-keyword">if</span> (opt == NULL)
			<span class="enscript-keyword">return</span> (ENOBUFS);
		ip6_initpktopts(opt);
		*pktopt = opt;
	}

	<span class="enscript-keyword">return</span> (ip6_setpktopt(optname, buf, len, opt, 1, 0, uproto));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_getpcbopt</span>(<span class="enscript-type">struct</span> ip6_pktopts *pktopt, <span class="enscript-type">int</span> optname, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-type">void</span> *optdata = NULL;
	<span class="enscript-type">int</span> optdatalen = 0;
	<span class="enscript-type">struct</span> ip6_ext *ip6e;
	<span class="enscript-type">struct</span> in6_pktinfo null_pktinfo;
	<span class="enscript-type">int</span> deftclass = 0, on;
	<span class="enscript-type">int</span> defminmtu = IP6PO_MINMTU_MCASTONLY;
	<span class="enscript-type">int</span> defpreftemp = IP6PO_TEMPADDR_SYSTEM;


	<span class="enscript-keyword">switch</span> (optname) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PKTINFO</span>:
		<span class="enscript-keyword">if</span> (pktopt &amp;&amp; pktopt-&gt;ip6po_pktinfo)
			optdata = (<span class="enscript-type">void</span> *)pktopt-&gt;ip6po_pktinfo;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* XXX: we don't have to do this every time... */</span>
			bzero(&amp;null_pktinfo, <span class="enscript-keyword">sizeof</span> (null_pktinfo));
			optdata = (<span class="enscript-type">void</span> *)&amp;null_pktinfo;
		}
		optdatalen = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_pktinfo);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_TCLASS</span>:
		<span class="enscript-keyword">if</span> (pktopt &amp;&amp; pktopt-&gt;ip6po_tclass &gt;= 0)
			optdata = (<span class="enscript-type">void</span> *)&amp;pktopt-&gt;ip6po_tclass;
		<span class="enscript-keyword">else</span>
			optdata = (<span class="enscript-type">void</span> *)&amp;deftclass;
		optdatalen = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_HOPOPTS</span>:
		<span class="enscript-keyword">if</span> (pktopt &amp;&amp; pktopt-&gt;ip6po_hbh) {
			optdata = (<span class="enscript-type">void</span> *)pktopt-&gt;ip6po_hbh;
			ip6e = (<span class="enscript-type">struct</span> ip6_ext *)pktopt-&gt;ip6po_hbh;
			optdatalen = (ip6e-&gt;ip6e_len + 1) &lt;&lt; 3;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RTHDR</span>:
		<span class="enscript-keyword">if</span> (pktopt &amp;&amp; pktopt-&gt;ip6po_rthdr) {
			optdata = (<span class="enscript-type">void</span> *)pktopt-&gt;ip6po_rthdr;
			ip6e = (<span class="enscript-type">struct</span> ip6_ext *)pktopt-&gt;ip6po_rthdr;
			optdatalen = (ip6e-&gt;ip6e_len + 1) &lt;&lt; 3;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RTHDRDSTOPTS</span>:
		<span class="enscript-keyword">if</span> (pktopt &amp;&amp; pktopt-&gt;ip6po_dest1) {
			optdata = (<span class="enscript-type">void</span> *)pktopt-&gt;ip6po_dest1;
			ip6e = (<span class="enscript-type">struct</span> ip6_ext *)pktopt-&gt;ip6po_dest1;
			optdatalen = (ip6e-&gt;ip6e_len + 1) &lt;&lt; 3;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_DSTOPTS</span>:
		<span class="enscript-keyword">if</span> (pktopt &amp;&amp; pktopt-&gt;ip6po_dest2) {
			optdata = (<span class="enscript-type">void</span> *)pktopt-&gt;ip6po_dest2;
			ip6e = (<span class="enscript-type">struct</span> ip6_ext *)pktopt-&gt;ip6po_dest2;
			optdatalen = (ip6e-&gt;ip6e_len + 1) &lt;&lt; 3;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_NEXTHOP</span>:
		<span class="enscript-keyword">if</span> (pktopt &amp;&amp; pktopt-&gt;ip6po_nexthop) {
			optdata = (<span class="enscript-type">void</span> *)pktopt-&gt;ip6po_nexthop;
			optdatalen = pktopt-&gt;ip6po_nexthop-&gt;sa_len;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_USE_MIN_MTU</span>:
		<span class="enscript-keyword">if</span> (pktopt)
			optdata = (<span class="enscript-type">void</span> *)&amp;pktopt-&gt;ip6po_minmtu;
		<span class="enscript-keyword">else</span>
			optdata = (<span class="enscript-type">void</span> *)&amp;defminmtu;
		optdatalen = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_DONTFRAG</span>:
		<span class="enscript-keyword">if</span> (pktopt &amp;&amp; ((pktopt-&gt;ip6po_flags) &amp; IP6PO_DONTFRAG))
			on = 1;
		<span class="enscript-keyword">else</span>
			on = 0;
		optdata = (<span class="enscript-type">void</span> *)&amp;on;
		optdatalen = <span class="enscript-keyword">sizeof</span> (on);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PREFER_TEMPADDR</span>:
		<span class="enscript-keyword">if</span> (pktopt)
			optdata = (<span class="enscript-type">void</span> *)&amp;pktopt-&gt;ip6po_prefer_tempaddr;
		<span class="enscript-keyword">else</span>
			optdata = (<span class="enscript-type">void</span> *)&amp;defpreftemp;
		optdatalen = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:		<span class="enscript-comment">/* should not happen */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		panic(<span class="enscript-string">&quot;ip6_getpcbopt: unexpected option\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span> (ENOPROTOOPT);
	}

	<span class="enscript-keyword">return</span> (sooptcopyout(sopt, optdata, optdatalen));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_clearpktopts</span>(<span class="enscript-type">struct</span> ip6_pktopts *pktopt, <span class="enscript-type">int</span> optname)
{
	<span class="enscript-keyword">if</span> (pktopt == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (optname == -1 || optname == IPV6_PKTINFO) {
		<span class="enscript-keyword">if</span> (pktopt-&gt;ip6po_pktinfo)
			FREE(pktopt-&gt;ip6po_pktinfo, M_IP6OPT);
		pktopt-&gt;ip6po_pktinfo = NULL;
	}
	<span class="enscript-keyword">if</span> (optname == -1 || optname == IPV6_HOPLIMIT)
		pktopt-&gt;ip6po_hlim = -1;
	<span class="enscript-keyword">if</span> (optname == -1 || optname == IPV6_TCLASS)
		pktopt-&gt;ip6po_tclass = -1;
	<span class="enscript-keyword">if</span> (optname == -1 || optname == IPV6_NEXTHOP) {
		ROUTE_RELEASE(&amp;pktopt-&gt;ip6po_nextroute);
		<span class="enscript-keyword">if</span> (pktopt-&gt;ip6po_nexthop)
			FREE(pktopt-&gt;ip6po_nexthop, M_IP6OPT);
		pktopt-&gt;ip6po_nexthop = NULL;
	}
	<span class="enscript-keyword">if</span> (optname == -1 || optname == IPV6_HOPOPTS) {
		<span class="enscript-keyword">if</span> (pktopt-&gt;ip6po_hbh)
			FREE(pktopt-&gt;ip6po_hbh, M_IP6OPT);
		pktopt-&gt;ip6po_hbh = NULL;
	}
	<span class="enscript-keyword">if</span> (optname == -1 || optname == IPV6_RTHDRDSTOPTS) {
		<span class="enscript-keyword">if</span> (pktopt-&gt;ip6po_dest1)
			FREE(pktopt-&gt;ip6po_dest1, M_IP6OPT);
		pktopt-&gt;ip6po_dest1 = NULL;
	}
	<span class="enscript-keyword">if</span> (optname == -1 || optname == IPV6_RTHDR) {
		<span class="enscript-keyword">if</span> (pktopt-&gt;ip6po_rhinfo.ip6po_rhi_rthdr)
			FREE(pktopt-&gt;ip6po_rhinfo.ip6po_rhi_rthdr, M_IP6OPT);
		pktopt-&gt;ip6po_rhinfo.ip6po_rhi_rthdr = NULL;
		ROUTE_RELEASE(&amp;pktopt-&gt;ip6po_route);
	}
	<span class="enscript-keyword">if</span> (optname == -1 || optname == IPV6_DSTOPTS) {
		<span class="enscript-keyword">if</span> (pktopt-&gt;ip6po_dest2)
			FREE(pktopt-&gt;ip6po_dest2, M_IP6OPT);
		pktopt-&gt;ip6po_dest2 = NULL;
	}
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PKTOPT_EXTHDRCPY</span>(type) do {					\
	<span class="enscript-keyword">if</span> (src-&gt;type) {						\
		<span class="enscript-type">int</span> hlen =						\
		    (((<span class="enscript-type">struct</span> ip6_ext *)src-&gt;type)-&gt;ip6e_len + 1) &lt;&lt; 3;	\
		dst-&gt;type = _MALLOC(hlen, M_IP6OPT, canwait);		\
		<span class="enscript-keyword">if</span> (dst-&gt;type == NULL &amp;&amp; canwait == M_NOWAIT)		\
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;					\
		bcopy(src-&gt;type, dst-&gt;type, hlen);			\
	}								\
} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">copypktopts</span>(<span class="enscript-type">struct</span> ip6_pktopts *dst, <span class="enscript-type">struct</span> ip6_pktopts *src, <span class="enscript-type">int</span> canwait)
{
	<span class="enscript-keyword">if</span> (dst == NULL || src == NULL)  {
		printf(<span class="enscript-string">&quot;copypktopts: invalid argument\n&quot;</span>);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	dst-&gt;ip6po_hlim = src-&gt;ip6po_hlim;
	dst-&gt;ip6po_tclass = src-&gt;ip6po_tclass;
	dst-&gt;ip6po_flags = src-&gt;ip6po_flags;
	<span class="enscript-keyword">if</span> (src-&gt;ip6po_pktinfo) {
		dst-&gt;ip6po_pktinfo = _MALLOC(<span class="enscript-keyword">sizeof</span> (*dst-&gt;ip6po_pktinfo),
		    M_IP6OPT, canwait);
		<span class="enscript-keyword">if</span> (dst-&gt;ip6po_pktinfo == NULL &amp;&amp; canwait == M_NOWAIT)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		*dst-&gt;ip6po_pktinfo = *src-&gt;ip6po_pktinfo;
	}
	<span class="enscript-keyword">if</span> (src-&gt;ip6po_nexthop) {
		dst-&gt;ip6po_nexthop = _MALLOC(src-&gt;ip6po_nexthop-&gt;sa_len,
		    M_IP6OPT, canwait);
		<span class="enscript-keyword">if</span> (dst-&gt;ip6po_nexthop == NULL &amp;&amp; canwait == M_NOWAIT)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		bcopy(src-&gt;ip6po_nexthop, dst-&gt;ip6po_nexthop,
		    src-&gt;ip6po_nexthop-&gt;sa_len);
	}
	PKTOPT_EXTHDRCPY(ip6po_hbh);
	PKTOPT_EXTHDRCPY(ip6po_dest1);
	PKTOPT_EXTHDRCPY(ip6po_dest2);
	PKTOPT_EXTHDRCPY(ip6po_rthdr); <span class="enscript-comment">/* not copy the cached route */</span>
	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">bad</span>:
	ip6_clearpktopts(dst, -1);
	<span class="enscript-keyword">return</span> (ENOBUFS);
}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">PKTOPT_EXTHDRCPY</span>

<span class="enscript-type">struct</span> ip6_pktopts *
<span class="enscript-function-name">ip6_copypktopts</span>(<span class="enscript-type">struct</span> ip6_pktopts *src, <span class="enscript-type">int</span> canwait)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> ip6_pktopts *dst;

	dst = _MALLOC(<span class="enscript-keyword">sizeof</span> (*dst), M_IP6OPT, canwait);
	<span class="enscript-keyword">if</span> (dst == NULL)
		<span class="enscript-keyword">return</span> (NULL);
	ip6_initpktopts(dst);

	<span class="enscript-keyword">if</span> ((error = copypktopts(dst, src, canwait)) != 0) {
		FREE(dst, M_IP6OPT);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">return</span> (dst);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_freepcbopts</span>(<span class="enscript-type">struct</span> ip6_pktopts *pktopt)
{
	<span class="enscript-keyword">if</span> (pktopt == NULL)
		<span class="enscript-keyword">return</span>;

	ip6_clearpktopts(pktopt, -1);

	FREE(pktopt, M_IP6OPT);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_moptions_init</span>(<span class="enscript-type">void</span>)
{
	PE_parse_boot_argn(<span class="enscript-string">&quot;ifa_debug&quot;</span>, &amp;im6o_debug, <span class="enscript-keyword">sizeof</span> (im6o_debug));

	im6o_size = (im6o_debug == 0) ? <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_moptions) :
	    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_moptions_dbg);

	im6o_zone = zinit(im6o_size, IM6O_ZONE_MAX * im6o_size, 0,
	    IM6O_ZONE_NAME);
	<span class="enscript-keyword">if</span> (im6o_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__, IM6O_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(im6o_zone, Z_EXPAND, TRUE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">im6o_addref</span>(<span class="enscript-type">struct</span> ip6_moptions *im6o, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-keyword">if</span> (!locked)
		IM6O_LOCK(im6o);
	<span class="enscript-keyword">else</span>
		IM6O_LOCK_ASSERT_HELD(im6o);

	<span class="enscript-keyword">if</span> (++im6o-&gt;im6o_refcnt == 0) {
		panic(<span class="enscript-string">&quot;%s: im6o %p wraparound refcnt\n&quot;</span>, __func__, im6o);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (im6o-&gt;im6o_trace != NULL) {
		(*im6o-&gt;im6o_trace)(im6o, TRUE);
	}

	<span class="enscript-keyword">if</span> (!locked)
		IM6O_UNLOCK(im6o);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">im6o_remref</span>(<span class="enscript-type">struct</span> ip6_moptions *im6o)
{
	<span class="enscript-type">int</span> i;

	IM6O_LOCK(im6o);
	<span class="enscript-keyword">if</span> (im6o-&gt;im6o_refcnt == 0) {
		panic(<span class="enscript-string">&quot;%s: im6o %p negative refcnt&quot;</span>, __func__, im6o);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (im6o-&gt;im6o_trace != NULL) {
		(*im6o-&gt;im6o_trace)(im6o, FALSE);
	}

	--im6o-&gt;im6o_refcnt;
	<span class="enscript-keyword">if</span> (im6o-&gt;im6o_refcnt &gt; 0) {
		IM6O_UNLOCK(im6o);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">for</span> (i = 0; i &lt; im6o-&gt;im6o_num_memberships; ++i) {
		<span class="enscript-type">struct</span> in6_mfilter *imf;

		imf = im6o-&gt;im6o_mfilters ? &amp;im6o-&gt;im6o_mfilters[i] : NULL;
		<span class="enscript-keyword">if</span> (imf != NULL)
			im6f_leave(imf);

		(<span class="enscript-type">void</span>) in6_mc_leave(im6o-&gt;im6o_membership[i], imf);

		<span class="enscript-keyword">if</span> (imf != NULL)
			im6f_purge(imf);

		IN6M_REMREF(im6o-&gt;im6o_membership[i]);
		im6o-&gt;im6o_membership[i] = NULL;
	}
	im6o-&gt;im6o_num_memberships = 0;
	<span class="enscript-keyword">if</span> (im6o-&gt;im6o_mfilters != NULL) {
		FREE(im6o-&gt;im6o_mfilters, M_IN6MFILTER);
		im6o-&gt;im6o_mfilters = NULL;
	}
	<span class="enscript-keyword">if</span> (im6o-&gt;im6o_membership != NULL) {
		FREE(im6o-&gt;im6o_membership, M_IP6MOPTS);
		im6o-&gt;im6o_membership = NULL;
	}
	IM6O_UNLOCK(im6o);

	lck_mtx_destroy(&amp;im6o-&gt;im6o_lock, ifa_mtx_grp);

	<span class="enscript-keyword">if</span> (!(im6o-&gt;im6o_debug &amp; IFD_ALLOC)) {
		panic(<span class="enscript-string">&quot;%s: im6o %p cannot be freed&quot;</span>, __func__, im6o);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zfree(im6o_zone, im6o);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">im6o_trace</span>(<span class="enscript-type">struct</span> ip6_moptions *im6o, <span class="enscript-type">int</span> refhold)
{
	<span class="enscript-type">struct</span> ip6_moptions_dbg *im6o_dbg = (<span class="enscript-type">struct</span> ip6_moptions_dbg *)im6o;
	ctrace_t *tr;
	u_int32_t idx;
	u_int16_t *cnt;

	<span class="enscript-keyword">if</span> (!(im6o-&gt;im6o_debug &amp; IFD_DEBUG)) {
		panic(<span class="enscript-string">&quot;%s: im6o %p has no debug structure&quot;</span>, __func__, im6o);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (refhold) {
		cnt = &amp;im6o_dbg-&gt;im6o_refhold_cnt;
		tr = im6o_dbg-&gt;im6o_refhold;
	} <span class="enscript-keyword">else</span> {
		cnt = &amp;im6o_dbg-&gt;im6o_refrele_cnt;
		tr = im6o_dbg-&gt;im6o_refrele;
	}

	idx = atomic_add_16_ov(cnt, 1) % IM6O_TRACE_HIST_SIZE;
	ctrace_record(&amp;tr[idx]);
}

<span class="enscript-type">struct</span> ip6_moptions *
<span class="enscript-function-name">ip6_allocmoptions</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> ip6_moptions *im6o;

	im6o = (how == M_WAITOK) ?
	    zalloc(im6o_zone) : zalloc_noblock(im6o_zone);
	<span class="enscript-keyword">if</span> (im6o != NULL) {
		bzero(im6o, im6o_size);
		lck_mtx_init(&amp;im6o-&gt;im6o_lock, ifa_mtx_grp, ifa_mtx_attr);
		im6o-&gt;im6o_debug |= IFD_ALLOC;
		<span class="enscript-keyword">if</span> (im6o_debug != 0) {
			im6o-&gt;im6o_debug |= IFD_DEBUG;
			im6o-&gt;im6o_trace = im6o_trace;
		}
		IM6O_ADDREF(im6o);
	}

	<span class="enscript-keyword">return</span> (im6o);
}

<span class="enscript-comment">/*
 * Set IPv6 outgoing packet options based on advanced API.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_setpktopts</span>(<span class="enscript-type">struct</span> mbuf *control, <span class="enscript-type">struct</span> ip6_pktopts *opt,
    <span class="enscript-type">struct</span> ip6_pktopts *stickyopt, <span class="enscript-type">int</span> uproto)
{
	<span class="enscript-type">struct</span> cmsghdr *cm = NULL;

	<span class="enscript-keyword">if</span> (control == NULL || opt == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	ip6_initpktopts(opt);
	<span class="enscript-keyword">if</span> (stickyopt) {
		<span class="enscript-type">int</span> error;

		<span class="enscript-comment">/*
		 * If stickyopt is provided, make a local copy of the options
		 * for this particular packet, then override them by ancillary
		 * objects.
		 * XXX: copypktopts() does not copy the cached route to a next
		 * hop (if any).  This is not very good in terms of efficiency,
		 * but we can allow this since this option should be rarely
		 * used.
		 */</span>
		<span class="enscript-keyword">if</span> ((error = copypktopts(opt, stickyopt, M_NOWAIT)) != 0)
			<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/*
	 * XXX: Currently, we assume all the optional information is stored
	 * in a single mbuf.
	 */</span>
	<span class="enscript-keyword">if</span> (control-&gt;m_next)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (control-&gt;m_len &lt; CMSG_LEN(0))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">for</span> (cm = M_FIRST_CMSGHDR(control); cm != NULL;
	    cm = M_NXT_CMSGHDR(control, cm)) {
		<span class="enscript-type">int</span> error;

		<span class="enscript-keyword">if</span> (cm-&gt;cmsg_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> cmsghdr) ||
		    cm-&gt;cmsg_len &gt; control-&gt;m_len)
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-keyword">if</span> (cm-&gt;cmsg_level != IPPROTO_IPV6)
			<span class="enscript-keyword">continue</span>;

		error = ip6_setpktopt(cm-&gt;cmsg_type, CMSG_DATA(cm),
		    cm-&gt;cmsg_len - CMSG_LEN(0), opt, 0, 1, uproto);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">return</span> (0);
}
<span class="enscript-comment">/*
 * Set a particular packet option, as a sticky option or an ancillary data
 * item.  &quot;len&quot; can be 0 only when it's a sticky option.
 * We have 4 cases of combination of &quot;sticky&quot; and &quot;cmsg&quot;:
 * &quot;sticky=0, cmsg=0&quot;: impossible
 * &quot;sticky=0, cmsg=1&quot;: RFC2292 or RFC3542 ancillary data
 * &quot;sticky=1, cmsg=0&quot;: RFC3542 socket option
 * &quot;sticky=1, cmsg=1&quot;: RFC2292 socket option
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_setpktopt</span>(<span class="enscript-type">int</span> optname, u_char *buf, <span class="enscript-type">int</span> len, <span class="enscript-type">struct</span> ip6_pktopts *opt,
    <span class="enscript-type">int</span> sticky, <span class="enscript-type">int</span> cmsg, <span class="enscript-type">int</span> uproto)
{
	<span class="enscript-type">int</span> minmtupolicy, preftemp;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (!sticky &amp;&amp; !cmsg) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		printf(<span class="enscript-string">&quot;ip6_setpktopt: impossible case\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/*
	 * Caller must have ensured that the buffer is at least
	 * aligned on 32-bit boundary.
	 */</span>
	VERIFY(IS_P2ALIGNED(buf, <span class="enscript-keyword">sizeof</span> (u_int32_t)));

	<span class="enscript-comment">/*
	 * IPV6_2292xxx is for backward compatibility to RFC2292, and should
	 * not be specified in the context of RFC3542.  Conversely,
	 * RFC3542 types should not be specified in the context of RFC2292.
	 */</span>
	<span class="enscript-keyword">if</span> (!cmsg) {
		<span class="enscript-keyword">switch</span> (optname) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292PKTINFO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292HOPLIMIT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292NEXTHOP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292HOPOPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292DSTOPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292RTHDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292PKTOPTIONS</span>:
			<span class="enscript-keyword">return</span> (ENOPROTOOPT);
		}
	}
	<span class="enscript-keyword">if</span> (sticky &amp;&amp; cmsg) {
		<span class="enscript-keyword">switch</span> (optname) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PKTINFO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_HOPLIMIT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_NEXTHOP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_HOPOPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_DSTOPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RTHDRDSTOPTS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RTHDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_USE_MIN_MTU</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_DONTFRAG</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_TCLASS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PREFER_TEMPADDR</span>: <span class="enscript-comment">/* XXX: not an RFC3542 option */</span>
			<span class="enscript-keyword">return</span> (ENOPROTOOPT);
		}
	}

	<span class="enscript-keyword">switch</span> (optname) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292PKTINFO</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PKTINFO</span>: {
		<span class="enscript-type">struct</span> ifnet *ifp = NULL;
		<span class="enscript-type">struct</span> in6_pktinfo *pktinfo;

		<span class="enscript-keyword">if</span> (len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_pktinfo))
			<span class="enscript-keyword">return</span> (EINVAL);

		pktinfo = (<span class="enscript-type">struct</span> in6_pktinfo *)(<span class="enscript-type">void</span> *)buf;

		<span class="enscript-comment">/*
		 * An application can clear any sticky IPV6_PKTINFO option by
		 * doing a &quot;regular&quot; setsockopt with ipi6_addr being
		 * in6addr_any and ipi6_ifindex being zero.
		 * [RFC 3542, Section 6]
		 */</span>
		<span class="enscript-keyword">if</span> (optname == IPV6_PKTINFO &amp;&amp; opt-&gt;ip6po_pktinfo &amp;&amp;
		    pktinfo-&gt;ipi6_ifindex == 0 &amp;&amp;
		    IN6_IS_ADDR_UNSPECIFIED(&amp;pktinfo-&gt;ipi6_addr)) {
			ip6_clearpktopts(opt, optname);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (uproto == IPPROTO_TCP &amp;&amp; optname == IPV6_PKTINFO &amp;&amp;
		    sticky &amp;&amp; !IN6_IS_ADDR_UNSPECIFIED(&amp;pktinfo-&gt;ipi6_addr)) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		<span class="enscript-comment">/* validate the interface index if specified. */</span>
		ifnet_head_lock_shared();

		<span class="enscript-keyword">if</span> (pktinfo-&gt;ipi6_ifindex &gt; if_index) {
			ifnet_head_done();
			<span class="enscript-keyword">return</span> (ENXIO);
		}

		<span class="enscript-keyword">if</span> (pktinfo-&gt;ipi6_ifindex) {
			ifp = ifindex2ifnet[pktinfo-&gt;ipi6_ifindex];
			<span class="enscript-keyword">if</span> (ifp == NULL) {
				ifnet_head_done();
				<span class="enscript-keyword">return</span> (ENXIO);
			}
		}

		ifnet_head_done();

		<span class="enscript-comment">/*
		 * We store the address anyway, and let in6_selectsrc()
		 * validate the specified address.  This is because ipi6_addr
		 * may not have enough information about its scope zone, and
		 * we may need additional information (such as outgoing
		 * interface or the scope zone of a destination address) to
		 * disambiguate the scope.
		 * XXX: the delay of the validation may confuse the
		 * application when it is used as a sticky option.
		 */</span>
		<span class="enscript-keyword">if</span> (opt-&gt;ip6po_pktinfo == NULL) {
			opt-&gt;ip6po_pktinfo = _MALLOC(<span class="enscript-keyword">sizeof</span> (*pktinfo),
			    M_IP6OPT, M_NOWAIT);
			<span class="enscript-keyword">if</span> (opt-&gt;ip6po_pktinfo == NULL)
				<span class="enscript-keyword">return</span> (ENOBUFS);
		}
		bcopy(pktinfo, opt-&gt;ip6po_pktinfo, <span class="enscript-keyword">sizeof</span> (*pktinfo));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292HOPLIMIT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_HOPLIMIT</span>: {
		<span class="enscript-type">int</span> *hlimp;

		<span class="enscript-comment">/*
		 * RFC 3542 deprecated the usage of sticky IPV6_HOPLIMIT
		 * to simplify the ordering among hoplimit options.
		 */</span>
		<span class="enscript-keyword">if</span> (optname == IPV6_HOPLIMIT &amp;&amp; sticky)
			<span class="enscript-keyword">return</span> (ENOPROTOOPT);

		<span class="enscript-keyword">if</span> (len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>))
			<span class="enscript-keyword">return</span> (EINVAL);
		hlimp = (<span class="enscript-type">int</span> *)(<span class="enscript-type">void</span> *)buf;
		<span class="enscript-keyword">if</span> (*hlimp &lt; -1 || *hlimp &gt; 255)
			<span class="enscript-keyword">return</span> (EINVAL);

		opt-&gt;ip6po_hlim = *hlimp;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_TCLASS</span>: {
		<span class="enscript-type">int</span> tclass;

		<span class="enscript-keyword">if</span> (len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>))
			<span class="enscript-keyword">return</span> (EINVAL);
		tclass = *(<span class="enscript-type">int</span> *)(<span class="enscript-type">void</span> *)buf;
		<span class="enscript-keyword">if</span> (tclass &lt; -1 || tclass &gt; 255)
			<span class="enscript-keyword">return</span> (EINVAL);

		opt-&gt;ip6po_tclass = tclass;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292NEXTHOP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_NEXTHOP</span>:
		error = suser(kauth_cred_get(), 0);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (EACCES);

		<span class="enscript-keyword">if</span> (len == 0) {	<span class="enscript-comment">/* just remove the option */</span>
			ip6_clearpktopts(opt, IPV6_NEXTHOP);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* check if cmsg_len is large enough for sa_len */</span>
		<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr) || len &lt; *buf)
			<span class="enscript-keyword">return</span> (EINVAL);

		<span class="enscript-keyword">switch</span> (SA(buf)-&gt;sa_family) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>: {
			<span class="enscript-type">struct</span> sockaddr_in6 *sa6 = SIN6(buf);

			<span class="enscript-keyword">if</span> (sa6-&gt;sin6_len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6))
				<span class="enscript-keyword">return</span> (EINVAL);

			<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;sa6-&gt;sin6_addr) ||
			    IN6_IS_ADDR_MULTICAST(&amp;sa6-&gt;sin6_addr)) {
				<span class="enscript-keyword">return</span> (EINVAL);
			}
			<span class="enscript-keyword">if</span> ((error = sa6_embedscope(sa6, ip6_use_defzone))
			    != 0) {
				<span class="enscript-keyword">return</span> (error);
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_LINK</span>:	<span class="enscript-comment">/* should eventually be supported */</span>
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (EAFNOSUPPORT);
		}

		<span class="enscript-comment">/* turn off the previous option, then set the new option. */</span>
		ip6_clearpktopts(opt, IPV6_NEXTHOP);
		opt-&gt;ip6po_nexthop = _MALLOC(*buf, M_IP6OPT, M_NOWAIT);
		<span class="enscript-keyword">if</span> (opt-&gt;ip6po_nexthop == NULL)
			<span class="enscript-keyword">return</span> (ENOBUFS);
		bcopy(buf, opt-&gt;ip6po_nexthop, *buf);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292HOPOPTS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_HOPOPTS</span>: {
		<span class="enscript-type">struct</span> ip6_hbh *hbh;
		<span class="enscript-type">int</span> hbhlen;

		<span class="enscript-comment">/*
		 * XXX: We don't allow a non-privileged user to set ANY HbH
		 * options, since per-option restriction has too much
		 * overhead.
		 */</span>
		error = suser(kauth_cred_get(), 0);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (EACCES);

		<span class="enscript-keyword">if</span> (len == 0) {
			ip6_clearpktopts(opt, IPV6_HOPOPTS);
			<span class="enscript-keyword">break</span>;	<span class="enscript-comment">/* just remove the option */</span>
		}

		<span class="enscript-comment">/* message length validation */</span>
		<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hbh))
			<span class="enscript-keyword">return</span> (EINVAL);
		hbh = (<span class="enscript-type">struct</span> ip6_hbh *)(<span class="enscript-type">void</span> *)buf;
		hbhlen = (hbh-&gt;ip6h_len + 1) &lt;&lt; 3;
		<span class="enscript-keyword">if</span> (len != hbhlen)
			<span class="enscript-keyword">return</span> (EINVAL);

		<span class="enscript-comment">/* turn off the previous option, then set the new option. */</span>
		ip6_clearpktopts(opt, IPV6_HOPOPTS);
		opt-&gt;ip6po_hbh = _MALLOC(hbhlen, M_IP6OPT, M_NOWAIT);
		<span class="enscript-keyword">if</span> (opt-&gt;ip6po_hbh == NULL)
			<span class="enscript-keyword">return</span> (ENOBUFS);
		bcopy(hbh, opt-&gt;ip6po_hbh, hbhlen);

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292DSTOPTS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_DSTOPTS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RTHDRDSTOPTS</span>: {
		<span class="enscript-type">struct</span> ip6_dest *dest, **newdest = NULL;
		<span class="enscript-type">int</span> destlen;

		error = suser(kauth_cred_get(), 0);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (EACCES);

		<span class="enscript-keyword">if</span> (len == 0) {
			ip6_clearpktopts(opt, optname);
			<span class="enscript-keyword">break</span>;	<span class="enscript-comment">/* just remove the option */</span>
		}

		<span class="enscript-comment">/* message length validation */</span>
		<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_dest))
			<span class="enscript-keyword">return</span> (EINVAL);
		dest = (<span class="enscript-type">struct</span> ip6_dest *)(<span class="enscript-type">void</span> *)buf;
		destlen = (dest-&gt;ip6d_len + 1) &lt;&lt; 3;
		<span class="enscript-keyword">if</span> (len != destlen)
			<span class="enscript-keyword">return</span> (EINVAL);

		<span class="enscript-comment">/*
		 * Determine the position that the destination options header
		 * should be inserted; before or after the routing header.
		 */</span>
		<span class="enscript-keyword">switch</span> (optname) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292DSTOPTS</span>:
			<span class="enscript-comment">/*
			 * The old advacned API is ambiguous on this point.
			 * Our approach is to determine the position based
			 * according to the existence of a routing header.
			 * Note, however, that this depends on the order of the
			 * extension headers in the ancillary data; the 1st
			 * part of the destination options header must appear
			 * before the routing header in the ancillary data,
			 * too.
			 * RFC3542 solved the ambiguity by introducing
			 * separate ancillary data or option types.
			 */</span>
			<span class="enscript-keyword">if</span> (opt-&gt;ip6po_rthdr == NULL)
				newdest = &amp;opt-&gt;ip6po_dest1;
			<span class="enscript-keyword">else</span>
				newdest = &amp;opt-&gt;ip6po_dest2;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RTHDRDSTOPTS</span>:
			newdest = &amp;opt-&gt;ip6po_dest1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_DSTOPTS</span>:
			newdest = &amp;opt-&gt;ip6po_dest2;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* turn off the previous option, then set the new option. */</span>
		ip6_clearpktopts(opt, optname);
		*newdest = _MALLOC(destlen, M_IP6OPT, M_NOWAIT);
		<span class="enscript-keyword">if</span> (*newdest == NULL)
			<span class="enscript-keyword">return</span> (ENOBUFS);
		bcopy(dest, *newdest, destlen);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_2292RTHDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RTHDR</span>: {
		<span class="enscript-type">struct</span> ip6_rthdr *rth;
		<span class="enscript-type">int</span> rthlen;

		<span class="enscript-keyword">if</span> (len == 0) {
			ip6_clearpktopts(opt, IPV6_RTHDR);
			<span class="enscript-keyword">break</span>;	<span class="enscript-comment">/* just remove the option */</span>
		}

		<span class="enscript-comment">/* message length validation */</span>
		<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_rthdr))
			<span class="enscript-keyword">return</span> (EINVAL);
		rth = (<span class="enscript-type">struct</span> ip6_rthdr *)(<span class="enscript-type">void</span> *)buf;
		rthlen = (rth-&gt;ip6r_len + 1) &lt;&lt; 3;
		<span class="enscript-keyword">if</span> (len != rthlen)
			<span class="enscript-keyword">return</span> (EINVAL);

		<span class="enscript-keyword">switch</span> (rth-&gt;ip6r_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_RTHDR_TYPE_0</span>:
			<span class="enscript-keyword">if</span> (rth-&gt;ip6r_len == 0)	<span class="enscript-comment">/* must contain one addr */</span>
				<span class="enscript-keyword">return</span> (EINVAL);
			<span class="enscript-keyword">if</span> (rth-&gt;ip6r_len % 2) <span class="enscript-comment">/* length must be even */</span>
				<span class="enscript-keyword">return</span> (EINVAL);
			<span class="enscript-keyword">if</span> (rth-&gt;ip6r_len / 2 != rth-&gt;ip6r_segleft)
				<span class="enscript-keyword">return</span> (EINVAL);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (EINVAL);	<span class="enscript-comment">/* not supported */</span>
		}

		<span class="enscript-comment">/* turn off the previous option */</span>
		ip6_clearpktopts(opt, IPV6_RTHDR);
		opt-&gt;ip6po_rthdr = _MALLOC(rthlen, M_IP6OPT, M_NOWAIT);
		<span class="enscript-keyword">if</span> (opt-&gt;ip6po_rthdr == NULL)
			<span class="enscript-keyword">return</span> (ENOBUFS);
		bcopy(rth, opt-&gt;ip6po_rthdr, rthlen);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_USE_MIN_MTU</span>:
		<span class="enscript-keyword">if</span> (len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>))
			<span class="enscript-keyword">return</span> (EINVAL);
		minmtupolicy = *(<span class="enscript-type">int</span> *)(<span class="enscript-type">void</span> *)buf;
		<span class="enscript-keyword">if</span> (minmtupolicy != IP6PO_MINMTU_MCASTONLY &amp;&amp;
		    minmtupolicy != IP6PO_MINMTU_DISABLE &amp;&amp;
		    minmtupolicy != IP6PO_MINMTU_ALL) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		opt-&gt;ip6po_minmtu = minmtupolicy;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_DONTFRAG</span>:
		<span class="enscript-keyword">if</span> (len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>))
			<span class="enscript-keyword">return</span> (EINVAL);

		<span class="enscript-keyword">if</span> (uproto == IPPROTO_TCP || *(<span class="enscript-type">int</span> *)(<span class="enscript-type">void</span> *)buf == 0) {
			<span class="enscript-comment">/*
			 * we ignore this option for TCP sockets.
			 * (RFC3542 leaves this case unspecified.)
			 */</span>
			opt-&gt;ip6po_flags &amp;= ~IP6PO_DONTFRAG;
		} <span class="enscript-keyword">else</span> {
			opt-&gt;ip6po_flags |= IP6PO_DONTFRAG;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPV6_PREFER_TEMPADDR</span>:
		<span class="enscript-keyword">if</span> (len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>))
			<span class="enscript-keyword">return</span> (EINVAL);
		preftemp = *(<span class="enscript-type">int</span> *)(<span class="enscript-type">void</span> *)buf;
		<span class="enscript-keyword">if</span> (preftemp != IP6PO_TEMPADDR_SYSTEM &amp;&amp;
		    preftemp != IP6PO_TEMPADDR_NOTPREFER &amp;&amp;
		    preftemp != IP6PO_TEMPADDR_PREFER) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		opt-&gt;ip6po_prefer_tempaddr = preftemp;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (ENOPROTOOPT);
	} <span class="enscript-comment">/* end of switch */</span>

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Routine called from ip6_output() to loop back a copy of an IP6 multicast
 * packet to the input queue of a specified interface.  Note that this
 * calls the output routine of the loopback &quot;driver&quot;, but with an interface
 * pointer that might NOT be &amp;loif -- easier than replicating that code here.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_mloopback</span>(<span class="enscript-type">struct</span> ifnet *srcifp, <span class="enscript-type">struct</span> ifnet *origifp, <span class="enscript-type">struct</span> mbuf *m,
    <span class="enscript-type">struct</span> sockaddr_in6 *dst, uint32_t optlen, int32_t nxt0)
{
	<span class="enscript-type">struct</span> mbuf *copym;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">struct</span> in6_addr src;

	<span class="enscript-keyword">if</span> (lo_ifp == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * Copy the packet header as it's needed for the checksum.
	 * Make sure to deep-copy IPv6 header portion in case the data
	 * is in an mbuf cluster, so that we can safely override the IPv6
	 * header portion later.
	 */</span>
	copym = m_copym_mode(m, 0, M_COPYALL, M_DONTWAIT, M_COPYM_COPY_HDR);
	<span class="enscript-keyword">if</span> (copym != NULL &amp;&amp; ((copym-&gt;m_flags &amp; M_EXT) ||
	    copym-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr)))
		copym = m_pullup(copym, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr));

	<span class="enscript-keyword">if</span> (copym == NULL)
		<span class="enscript-keyword">return</span>;

	ip6 = mtod(copym, <span class="enscript-type">struct</span> ip6_hdr *);
	src = ip6-&gt;ip6_src;
	<span class="enscript-comment">/*
	 * clear embedded scope identifiers if necessary.
	 * in6_clearscope will touch the addresses only when necessary.
	 */</span>
	in6_clearscope(&amp;ip6-&gt;ip6_src);
	in6_clearscope(&amp;ip6-&gt;ip6_dst);

	<span class="enscript-keyword">if</span> (copym-&gt;m_pkthdr.csum_flags &amp; CSUM_DELAY_IPV6_DATA)
		in6_delayed_cksum_offset(copym, 0, optlen, nxt0);

	<span class="enscript-comment">/*
	 * Stuff the 'real' ifp into the pkthdr, to be used in matching
	 * in ip6_input(); we need the loopback ifp/dl_tag passed as args
	 * to make the loopback driver compliant with the data link
	 * requirements.
	 */</span>
	copym-&gt;m_pkthdr.rcvif = origifp;

	<span class="enscript-comment">/*
	 * Also record the source interface (which owns the source address).
	 * This is basically a stripped down version of ifa_foraddr6().
	 */</span>
	<span class="enscript-keyword">if</span> (srcifp == NULL) {
		<span class="enscript-type">struct</span> in6_ifaddr *ia;

		lck_rw_lock_shared(&amp;in6_ifaddr_rwlock);
		<span class="enscript-keyword">for</span> (ia = in6_ifaddrs; ia != NULL; ia = ia-&gt;ia_next) {
			IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);
			<span class="enscript-comment">/* compare against src addr with embedded scope */</span>
			<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(&amp;ia-&gt;ia_addr.sin6_addr, &amp;src)) {
				srcifp = ia-&gt;ia_ifp;
				IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
				<span class="enscript-keyword">break</span>;
			}
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		}
		lck_rw_done(&amp;in6_ifaddr_rwlock);
	}
	<span class="enscript-keyword">if</span> (srcifp != NULL)
		ip6_setsrcifaddr_info(copym, srcifp-&gt;if_index, NULL);
	ip6_setdstifaddr_info(copym, origifp-&gt;if_index, NULL);

	dlil_output(lo_ifp, PF_INET6, copym, NULL, SA(dst), 0, NULL);
}

<span class="enscript-comment">/*
 * Chop IPv6 header off from the payload.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_splithdr</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> ip6_exthdrs *exthdrs)
{
	<span class="enscript-type">struct</span> mbuf *mh;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;

	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	<span class="enscript-keyword">if</span> (m-&gt;m_len &gt; <span class="enscript-keyword">sizeof</span> (*ip6)) {
		MGETHDR(mh, M_DONTWAIT, MT_HEADER);	<span class="enscript-comment">/* MAC-OK */</span>
		<span class="enscript-keyword">if</span> (mh == NULL) {
			m_freem(m);
			<span class="enscript-keyword">return</span> (ENOBUFS);
		}
		M_COPY_PKTHDR(mh, m);
		MH_ALIGN(mh, <span class="enscript-keyword">sizeof</span> (*ip6));
		m-&gt;m_flags &amp;= ~M_PKTHDR;
		m-&gt;m_len -= <span class="enscript-keyword">sizeof</span> (*ip6);
		m-&gt;m_data += <span class="enscript-keyword">sizeof</span> (*ip6);
		mh-&gt;m_next = m;
		m = mh;
		m-&gt;m_len = <span class="enscript-keyword">sizeof</span> (*ip6);
		bcopy((caddr_t)ip6, mtod(m, caddr_t), <span class="enscript-keyword">sizeof</span> (*ip6));
	}
	exthdrs-&gt;ip6e_ip6 = m;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ip6_output_checksum</span>(<span class="enscript-type">struct</span> ifnet *ifp, uint32_t mtu, <span class="enscript-type">struct</span> mbuf *m,
    <span class="enscript-type">int</span> nxt0, uint32_t tlen, uint32_t optlen)
{
	uint32_t sw_csum, hwcap = ifp-&gt;if_hwassist;
	<span class="enscript-type">int</span> tso = TSO_IPV6_OK(ifp, m);

	<span class="enscript-keyword">if</span> (!hwcksum_tx) {
		<span class="enscript-comment">/* do all in software; checksum offload is disabled */</span>
		sw_csum = CSUM_DELAY_IPV6_DATA &amp; m-&gt;m_pkthdr.csum_flags;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* do in software what the hardware cannot */</span>
		sw_csum = m-&gt;m_pkthdr.csum_flags &amp;
		    ~IF_HWASSIST_CSUM_FLAGS(hwcap);
	}

	<span class="enscript-keyword">if</span> (optlen != 0) {
		sw_csum |= (CSUM_DELAY_IPV6_DATA &amp;
		    m-&gt;m_pkthdr.csum_flags);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(sw_csum &amp; CSUM_DELAY_IPV6_DATA) &amp;&amp;
	    (hwcap &amp; CSUM_PARTIAL)) {
		<span class="enscript-comment">/*
		 * Partial checksum offload, ere), if no extension
		 * headers, and TCP only (no UDP support, as the
		 * hardware may not be able to convert +0 to
		 * -0 (0xffff) per RFC1122 4.1.3.4.)
		 */</span>
		<span class="enscript-keyword">if</span> (hwcksum_tx &amp;&amp; !tso &amp;&amp;
		    (m-&gt;m_pkthdr.csum_flags &amp; CSUM_TCPIPV6) &amp;&amp;
		    tlen &lt;= mtu) {
			uint16_t start = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ip6_hdr);
			uint16_t ulpoff =
			    m-&gt;m_pkthdr.csum_data &amp; 0xffff;
			m-&gt;m_pkthdr.csum_flags |=
			    (CSUM_DATA_VALID | CSUM_PARTIAL);
			m-&gt;m_pkthdr.csum_tx_stuff = (ulpoff + start);
			m-&gt;m_pkthdr.csum_tx_start = start;
			sw_csum = 0;
		} <span class="enscript-keyword">else</span> {
			sw_csum |= (CSUM_DELAY_IPV6_DATA &amp;
			    m-&gt;m_pkthdr.csum_flags);
		}
	}

	<span class="enscript-keyword">if</span> (sw_csum &amp; CSUM_DELAY_IPV6_DATA) {
		in6_delayed_cksum_offset(m, 0, optlen, nxt0);
		sw_csum &amp;= ~CSUM_DELAY_IPV6_DATA;
	}

	<span class="enscript-keyword">if</span> (hwcksum_tx) {
		<span class="enscript-comment">/*
		 * Drop off bits that aren't supported by hardware;
		 * also make sure to preserve non-checksum related bits.
		 */</span>
		m-&gt;m_pkthdr.csum_flags =
		    ((m-&gt;m_pkthdr.csum_flags &amp;
		    (IF_HWASSIST_CSUM_FLAGS(hwcap) | CSUM_DATA_VALID)) |
		    (m-&gt;m_pkthdr.csum_flags &amp; ~IF_HWASSIST_CSUM_MASK));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* drop all bits; checksum offload is disabled */</span>
		m-&gt;m_pkthdr.csum_flags = 0;
	}
}

<span class="enscript-comment">/*
 * Compute IPv6 extension header length.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ip6_optlen</span>(<span class="enscript-type">struct</span> in6pcb *in6p)
{
	<span class="enscript-type">int</span> len;

	<span class="enscript-keyword">if</span> (!in6p-&gt;in6p_outputopts)
		<span class="enscript-keyword">return</span> (0);

	len = 0;
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">elen</span>(x)								\
	(((<span class="enscript-type">struct</span> ip6_ext *)(x)) ?					\
	(((<span class="enscript-type">struct</span> ip6_ext *)(x))-&gt;ip6e_len + 1) &lt;&lt; 3 : 0)

	len += elen(in6p-&gt;in6p_outputopts-&gt;ip6po_hbh);
	<span class="enscript-keyword">if</span> (in6p-&gt;in6p_outputopts-&gt;ip6po_rthdr) {
		<span class="enscript-comment">/* dest1 is valid with rthdr only */</span>
		len += elen(in6p-&gt;in6p_outputopts-&gt;ip6po_dest1);
	}
	len += elen(in6p-&gt;in6p_outputopts-&gt;ip6po_rthdr);
	len += elen(in6p-&gt;in6p_outputopts-&gt;ip6po_dest2);
	<span class="enscript-keyword">return</span> (len);
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">elen</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_reset_ip6_output_stats SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, i;

	i = ip6_output_measure;
	error = sysctl_handle_int(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (error || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	<span class="enscript-comment">/* impose bounds */</span>
	<span class="enscript-keyword">if</span> (i &lt; 0 || i &gt; 1) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (ip6_output_measure != i &amp;&amp; i == 1) {
		net_perf_initialize(&amp;net_perf, ip6_output_measure_bins);
	}
	ip6_output_measure = i;
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_ip6_output_measure_bins SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error;
	uint64_t i;

	i = ip6_output_measure_bins;
	error = sysctl_handle_quad(oidp, &amp;i, 0, req);
	<span class="enscript-keyword">if</span> (error || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	<span class="enscript-comment">/* validate data */</span>
	<span class="enscript-keyword">if</span> (!net_perf_validate_bins(i)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	ip6_output_measure_bins = i;
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_ip6_output_getperf SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL)
		req-&gt;oldlen = (size_t)<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ipstat);

	<span class="enscript-keyword">return</span> (SYSCTL_OUT(req, &amp;net_perf, MIN(<span class="enscript-keyword">sizeof</span> (net_perf), req-&gt;oldlen)));
}

</pre>
<hr />
</body></html>