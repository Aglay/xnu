<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nd6_prproxy.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nd6_prproxy.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2011-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * Prefix-based Neighbor Discovery Proxy
 *
 * When an interface is marked with the ND6_IFF_PROXY_PREFIXES flag, all
 * of current and future non-scoped on-link prefixes configured on the
 * interface will be shared with the scoped variant of such prefixes on
 * other interfaces.  This allows for one or more prefixes to be shared
 * across multiple links, with full support for Duplicate Addres Detection,
 * Address Resolution and Neighbor Unreachability Detection.
 *
 * A non-scoped prefix may be configured statically, or dynamically via
 * Router Advertisement.  An interface is said to be an &quot;upstream&quot; interface
 * when it is marked with ND6_IFF_PROXY_PREFIXES and has at least one prefix
 * that is non-scoped (global, not scoped.)  Such prefixes are marked with
 * the NDPRF_PRPROXY flag.
 *
 * A scoped prefix typically gets configured by way of adding an address
 * to a &quot;downstream&quot; interface, when the added address is part of an existing
 * prefix that is allowed to be shared (i.e. NDPRF_PRPROXY prefixes.)  Unlike
 * non-scoped prefixes, however, scoped prefixes will never be marked with
 * the NDPRF_PRPROXY flag.
 *
 * The setting of NDPRF_PRPROXY depends on whether the prefix is on-link;
 * an off-link prefix on an interface marked with ND6_IFF_PROXY_PREFIXES
 * will not cause NDPRF_PRPROXY to be set (it will only happen when that
 * prefix goes on-link.)  Likewise, a previously on-link prefix that has
 * transitioned to off-link will cause its NDPRF_PRPROXY flag to be cleared.
 *
 * Prefix proxying relies on IPv6 Scoped Routing to be in effect, as it would
 * otherwise be impossible to install scoped prefix route entries in the
 * routing table.  By default, such cloning prefix routes will generate cloned
 * routes that are scoped according to their interfaces.  Because prefix
 * proxying is essentially creating a larger network comprised of multiple
 * links sharing a prefix, we need to treat the cloned routes as if they
 * weren't scoped route entries.  This requires marking such cloning prefix
 * routes with the RTF_PROXY flag, which serves as an indication that the
 * route entry (and its clones) are part of a proxied prefix, and that the
 * entries are non-scoped.
 *
 * In order to handle solicited-node destined ND packets (Address Resolution,
 * Neighbor Unreachability Detection), prefix proxying also requires that the
 * &quot;upstream&quot; and &quot;downstream&quot; interfaces be configured for all-multicast mode.
 *
 * The setting and clearing of RTF_PROXY flag, as well as the entering and
 * exiting of all-multicast mode on those interfaces happen when a prefix
 * transitions between on-link and off-link (vice versa.)
 *
 * Note that this is not a strict implementation of RFC 4389, but rather a
 * derivative based on similar concept.  In particular, we only proxy NS and
 * NA packets; RA packets are never proxied.  Care should be taken to enable
 * prefix proxying only on non-looping network topology.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/scope6_var.h&gt;</span>

<span class="enscript-type">struct</span> nd6_prproxy_prelist {
	SLIST_ENTRY(nd6_prproxy_prelist) ndprl_le;
	<span class="enscript-type">struct</span> nd_prefix *ndprl_pr;		<span class="enscript-comment">/* prefix */</span>
	<span class="enscript-type">struct</span> nd_prefix *ndprl_up;		<span class="enscript-comment">/* non-NULL for upstream */</span>
	<span class="enscript-type">struct</span> ifnet	*ndprl_fwd_ifp;		<span class="enscript-comment">/* outgoing interface */</span>
	boolean_t	ndprl_sol;		<span class="enscript-comment">/* unicast solicitor? */</span>
	<span class="enscript-type">struct</span> in6_addr	ndprl_sol_saddr;	<span class="enscript-comment">/* solicitor's address */</span>
};

<span class="enscript-comment">/*
 * Soliciting node (source) record.
 */</span>
<span class="enscript-type">struct</span> nd6_prproxy_solsrc {
	TAILQ_ENTRY(nd6_prproxy_solsrc) solsrc_tqe;
	<span class="enscript-type">struct</span> in6_addr solsrc_saddr;		<span class="enscript-comment">/* soliciting (src) address */</span>
	<span class="enscript-type">struct</span> ifnet	*solsrc_ifp;		<span class="enscript-comment">/* iface where NS arrived on */</span>
};

<span class="enscript-comment">/*
 * Solicited node (target) record.
 */</span>
<span class="enscript-type">struct</span> nd6_prproxy_soltgt {
	RB_ENTRY(nd6_prproxy_soltgt) soltgt_link; <span class="enscript-comment">/* RB tree links */</span>
	<span class="enscript-type">struct</span> soltgt_key_s {
		<span class="enscript-type">struct</span> in6_addr taddr;		<span class="enscript-comment">/* solicited (tgt) address */</span>
	} soltgt_key;
	u_int64_t	soltgt_expire;		<span class="enscript-comment">/* expiration time */</span>
	u_int32_t	soltgt_cnt;		<span class="enscript-comment">/* total # of solicitors */</span>
	TAILQ_HEAD(, nd6_prproxy_solsrc) soltgt_q;
};

<span class="enscript-function-name">SLIST_HEAD</span>(nd6_prproxy_prelist_head, nd6_prproxy_prelist);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_prproxy_prelist_setroute</span>(boolean_t enable,
    <span class="enscript-type">struct</span> nd6_prproxy_prelist_head *, <span class="enscript-type">struct</span> nd6_prproxy_prelist_head *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd6_prproxy_prelist *<span class="enscript-function-name">nd6_ndprl_alloc</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_ndprl_free</span>(<span class="enscript-type">struct</span> nd6_prproxy_prelist *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd6_prproxy_solsrc *<span class="enscript-function-name">nd6_solsrc_alloc</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_solsrc_free</span>(<span class="enscript-type">struct</span> nd6_prproxy_solsrc *);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">nd6_solsrc_enq</span>(<span class="enscript-type">struct</span> nd_prefix *, <span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">struct</span> in6_addr *, <span class="enscript-type">struct</span> in6_addr *);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">nd6_solsrc_deq</span>(<span class="enscript-type">struct</span> nd_prefix *, <span class="enscript-type">struct</span> in6_addr *,
    <span class="enscript-type">struct</span> in6_addr *, <span class="enscript-type">struct</span> ifnet **);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd6_prproxy_soltgt *<span class="enscript-function-name">nd6_soltgt_alloc</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_soltgt_free</span>(<span class="enscript-type">struct</span> nd6_prproxy_soltgt *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_soltgt_prune</span>(<span class="enscript-type">struct</span> nd6_prproxy_soltgt *, u_int32_t);
<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span> <span class="enscript-function-name">soltgt_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> nd6_prproxy_soltgt *,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> nd6_prproxy_soltgt *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_prproxy_sols_purge</span>(<span class="enscript-type">struct</span> nd_prefix *, u_int64_t);

<span class="enscript-function-name">RB_PROTOTYPE_SC_PREV</span>(__private_extern__, prproxy_sols_tree, nd6_prproxy_soltgt,
    soltgt_link, soltgt_cmp);

<span class="enscript-comment">/*
 * Time (in seconds) before a target record expires (is idle).
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ND6_TGT_SOLS_EXPIRE</span>			5

<span class="enscript-comment">/*
 * Maximum number of queued soliciting (source) records per target.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ND6_MAX_SRC_SOLS_DEFAULT</span>		4

<span class="enscript-comment">/*
 * Maximum number of queued solicited (target) records per prefix.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ND6_MAX_TGT_SOLS_DEFAULT</span>		8

<span class="enscript-type">static</span> u_int32_t nd6_max_tgt_sols = ND6_MAX_TGT_SOLS_DEFAULT;
<span class="enscript-type">static</span> u_int32_t nd6_max_src_sols = ND6_MAX_SRC_SOLS_DEFAULT;

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ndprl_size;			<span class="enscript-comment">/* size of zone element */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *ndprl_zone;			<span class="enscript-comment">/* nd6_prproxy_prelist zone */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NDPRL_ZONE_MAX</span>	256			<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NDPRL_ZONE_NAME</span>	<span class="enscript-string">&quot;nd6_prproxy_prelist&quot;</span>	<span class="enscript-comment">/* name for zone */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> solsrc_size;		<span class="enscript-comment">/* size of zone element */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *solsrc_zone;		<span class="enscript-comment">/* nd6_prproxy_solsrc zone */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SOLSRC_ZONE_MAX</span>	 256			<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SOLSRC_ZONE_NAME</span> <span class="enscript-string">&quot;nd6_prproxy_solsrc&quot;</span>	<span class="enscript-comment">/* name for zone */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> soltgt_size;		<span class="enscript-comment">/* size of zone element */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *soltgt_zone;		<span class="enscript-comment">/* nd6_prproxy_soltgt zone */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SOLTGT_ZONE_MAX</span>	 256			<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SOLTGT_ZONE_NAME</span> <span class="enscript-string">&quot;nd6_prproxy_soltgt&quot;</span>	<span class="enscript-comment">/* name for zone */</span>

<span class="enscript-comment">/* The following is protected by ndpr_lock */</span>
<span class="enscript-function-name">RB_GENERATE_PREV</span>(prproxy_sols_tree, nd6_prproxy_soltgt,
    soltgt_link, soltgt_cmp);

<span class="enscript-comment">/* The following is protected by proxy6_lock (for updates) */</span>
u_int32_t nd6_prproxy;

<span class="enscript-type">extern</span> lck_mtx_t *nd6_mutex;

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_inet6_icmp6);

<span class="enscript-function-name">SYSCTL_UINT</span>(_net_inet6_icmp6, OID_AUTO, nd6_maxsolstgt,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nd6_max_tgt_sols, ND6_MAX_TGT_SOLS_DEFAULT,
    <span class="enscript-string">&quot;maximum number of outstanding solicited targets per prefix&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_net_inet6_icmp6, OID_AUTO, nd6_maxproxiedsol,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nd6_max_src_sols, ND6_MAX_SRC_SOLS_DEFAULT,
    <span class="enscript-string">&quot;maximum number of outstanding solicitations per target&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_net_inet6_icmp6, OID_AUTO, prproxy_cnt,
    CTLFLAG_RD | CTLFLAG_LOCKED, &amp;nd6_prproxy, 0,
    <span class="enscript-string">&quot;total number of proxied prefixes&quot;</span>);

<span class="enscript-comment">/*
 * Called by nd6_init() during initialization time.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_prproxy_init</span>(<span class="enscript-type">void</span>)
{
	ndprl_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nd6_prproxy_prelist);
	ndprl_zone = zinit(ndprl_size, NDPRL_ZONE_MAX * ndprl_size, 0,
	    NDPRL_ZONE_NAME);
	<span class="enscript-keyword">if</span> (ndprl_zone == NULL)
		panic(<span class="enscript-string">&quot;%s: failed allocating ndprl_zone&quot;</span>, __func__);

	zone_change(ndprl_zone, Z_EXPAND, TRUE);
	zone_change(ndprl_zone, Z_CALLERACCT, FALSE);

	solsrc_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nd6_prproxy_solsrc);
	solsrc_zone = zinit(solsrc_size, SOLSRC_ZONE_MAX * solsrc_size, 0,
	    SOLSRC_ZONE_NAME);
	<span class="enscript-keyword">if</span> (solsrc_zone == NULL)
		panic(<span class="enscript-string">&quot;%s: failed allocating solsrc_zone&quot;</span>, __func__);

	zone_change(solsrc_zone, Z_EXPAND, TRUE);
	zone_change(solsrc_zone, Z_CALLERACCT, FALSE);

	soltgt_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nd6_prproxy_soltgt);
	soltgt_zone = zinit(soltgt_size, SOLTGT_ZONE_MAX * soltgt_size, 0,
	    SOLTGT_ZONE_NAME);
	<span class="enscript-keyword">if</span> (soltgt_zone == NULL)
		panic(<span class="enscript-string">&quot;%s: failed allocating soltgt_zone&quot;</span>, __func__);

	zone_change(soltgt_zone, Z_EXPAND, TRUE);
	zone_change(soltgt_zone, Z_CALLERACCT, FALSE);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd6_prproxy_prelist *
<span class="enscript-function-name">nd6_ndprl_alloc</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> nd6_prproxy_prelist *ndprl;

	ndprl = (how == M_WAITOK) ? zalloc(ndprl_zone) :
	    zalloc_noblock(ndprl_zone);
	<span class="enscript-keyword">if</span> (ndprl != NULL)
		bzero(ndprl, ndprl_size);

	<span class="enscript-keyword">return</span> (ndprl);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_ndprl_free</span>(<span class="enscript-type">struct</span> nd6_prproxy_prelist *ndprl)
{
	zfree(ndprl_zone, ndprl);
}

<span class="enscript-comment">/*
 * Apply routing function on the affected upstream and downstream prefixes,
 * i.e. either set or clear RTF_PROXY on the cloning prefix route; all route
 * entries that were cloned off these prefixes will be blown away.  Caller
 * must have acquried proxy6_lock and must not be holding nd6_mutex.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_prproxy_prelist_setroute</span>(boolean_t enable,
    <span class="enscript-type">struct</span> nd6_prproxy_prelist_head *up_head,
    <span class="enscript-type">struct</span> nd6_prproxy_prelist_head *down_head)
{
	<span class="enscript-type">struct</span> nd6_prproxy_prelist *up, *down, *ndprl_tmp;
	<span class="enscript-type">struct</span> nd_prefix *pr;

	lck_mtx_assert(&amp;proxy6_lock, LCK_MTX_ASSERT_OWNED);
	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_NOTOWNED);

	SLIST_FOREACH_SAFE(up, up_head, ndprl_le, ndprl_tmp) {
		<span class="enscript-type">struct</span> rtentry *rt;
		boolean_t prproxy, set_allmulti = FALSE;
		<span class="enscript-type">int</span> allmulti_sw;
		<span class="enscript-type">struct</span> ifnet *ifp = NULL;

		SLIST_REMOVE(up_head, up, nd6_prproxy_prelist, ndprl_le);
		pr = up-&gt;ndprl_pr;
		VERIFY(up-&gt;ndprl_up == NULL);

		NDPR_LOCK(pr);
		ifp = pr-&gt;ndpr_ifp;
		prproxy = (pr-&gt;ndpr_stateflags &amp; NDPRF_PRPROXY);
		VERIFY(!prproxy || ((pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) &amp;&amp;
		    !(pr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE)));

		nd6_prproxy_sols_reap(pr);
		VERIFY(pr-&gt;ndpr_prproxy_sols_cnt == 0);
		VERIFY(RB_EMPTY(&amp;pr-&gt;ndpr_prproxy_sols));

		<span class="enscript-keyword">if</span> (enable &amp;&amp; pr-&gt;ndpr_allmulti_cnt == 0) {
			nd6_prproxy++;
			pr-&gt;ndpr_allmulti_cnt++;
			set_allmulti = TRUE;
			allmulti_sw = TRUE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!enable &amp;&amp; pr-&gt;ndpr_allmulti_cnt &gt; 0) {
			nd6_prproxy--;
			pr-&gt;ndpr_allmulti_cnt--;
			set_allmulti = TRUE;
			allmulti_sw = FALSE;
		}

		<span class="enscript-keyword">if</span> ((rt = pr-&gt;ndpr_rt) != NULL) {
			<span class="enscript-keyword">if</span> ((enable &amp;&amp; prproxy) || (!enable &amp;&amp; !prproxy))
				RT_ADDREF(rt);
			<span class="enscript-keyword">else</span>
				rt = NULL;
			NDPR_UNLOCK(pr);
		} <span class="enscript-keyword">else</span> {
			NDPR_UNLOCK(pr);
		}

		<span class="enscript-comment">/* Call the following ioctl after releasing NDPR lock */</span> 
		<span class="enscript-keyword">if</span> (set_allmulti &amp;&amp; ifp != NULL)
			if_allmulti(ifp, allmulti_sw);

		
		NDPR_REMREF(pr);
		<span class="enscript-keyword">if</span> (rt != NULL) {
			rt_set_proxy(rt, enable);
			rtfree(rt);
		}
		nd6_ndprl_free(up);
	}

	SLIST_FOREACH_SAFE(down, down_head, ndprl_le, ndprl_tmp) {
		<span class="enscript-type">struct</span> nd_prefix *pr_up;
		<span class="enscript-type">struct</span> rtentry *rt;
		boolean_t prproxy, set_allmulti = FALSE;
		<span class="enscript-type">int</span> allmulti_sw;
		<span class="enscript-type">struct</span> ifnet *ifp = NULL;

		SLIST_REMOVE(down_head, down, nd6_prproxy_prelist, ndprl_le);
		pr = down-&gt;ndprl_pr;
		pr_up = down-&gt;ndprl_up;
		VERIFY(pr_up != NULL);

		NDPR_LOCK(pr_up);
		ifp = pr-&gt;ndpr_ifp;
		prproxy = (pr_up-&gt;ndpr_stateflags &amp; NDPRF_PRPROXY);
		VERIFY(!prproxy || ((pr_up-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) &amp;&amp;
		    !(pr_up-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE)));
		NDPR_UNLOCK(pr_up);

		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (enable &amp;&amp; pr-&gt;ndpr_allmulti_cnt == 0) {
			pr-&gt;ndpr_allmulti_cnt++;
			set_allmulti = TRUE;
			allmulti_sw = TRUE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!enable &amp;&amp; pr-&gt;ndpr_allmulti_cnt &gt; 0) {
			pr-&gt;ndpr_allmulti_cnt--;
			set_allmulti = TRUE;
			allmulti_sw = FALSE;
		}

		<span class="enscript-keyword">if</span> ((rt = pr-&gt;ndpr_rt) != NULL) {
			<span class="enscript-keyword">if</span> ((enable &amp;&amp; prproxy) || (!enable &amp;&amp; !prproxy))
				RT_ADDREF(rt);
			<span class="enscript-keyword">else</span>
				rt = NULL;
			NDPR_UNLOCK(pr);
		} <span class="enscript-keyword">else</span> {
			NDPR_UNLOCK(pr);
		}
		<span class="enscript-keyword">if</span> (set_allmulti &amp;&amp; ifp != NULL)
			if_allmulti(ifp, allmulti_sw);

		NDPR_REMREF(pr);
		NDPR_REMREF(pr_up);
		<span class="enscript-keyword">if</span> (rt != NULL) {
			rt_set_proxy(rt, enable);
			rtfree(rt);
		}
		nd6_ndprl_free(down);
	}
}

<span class="enscript-comment">/*
 * Enable/disable prefix proxying on an interface; typically called
 * as part of handling SIOCSIFINFO_FLAGS[IFEF_IPV6_ROUTER].
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_if_prproxy</span>(<span class="enscript-type">struct</span> ifnet *ifp, boolean_t enable)
{
	SLIST_HEAD(, nd6_prproxy_prelist) up_head;
	SLIST_HEAD(, nd6_prproxy_prelist) down_head;
	<span class="enscript-type">struct</span> nd6_prproxy_prelist *up, *down;
	<span class="enscript-type">struct</span> nd_prefix *pr;

	<span class="enscript-comment">/* Can't be enabled if we are an advertising router on the interface */</span>
	ifnet_lock_shared(ifp);
	<span class="enscript-keyword">if</span> (enable &amp;&amp; (ifp-&gt;if_eflags &amp; IFEF_IPV6_ROUTER)) {
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">return</span> (EBUSY);
	}
	ifnet_lock_done(ifp);

	SLIST_INIT(&amp;up_head);
	SLIST_INIT(&amp;down_head);

	<span class="enscript-comment">/*
	 * Serialize the clearing/setting of NDPRF_PRPROXY.
	 */</span>
	lck_mtx_lock(&amp;proxy6_lock);

	<span class="enscript-comment">/*
	 * First build a list of upstream prefixes on this interface for
	 * which we need to enable/disable prefix proxy functionality.
	 */</span>
	lck_mtx_lock(nd6_mutex);
	<span class="enscript-keyword">for</span> (pr = nd_prefix.lh_first; pr; pr = pr-&gt;ndpr_next) {
		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;pr-&gt;ndpr_prefix.sin6_addr) ||
		    (!enable &amp;&amp; !(pr-&gt;ndpr_stateflags &amp; NDPRF_PRPROXY)) ||
		    (enable &amp;&amp; (pr-&gt;ndpr_stateflags &amp; NDPRF_PRPROXY)) ||
		    (pr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE) ||
		    pr-&gt;ndpr_ifp != ifp) {
			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * At present, in order for the prefix to be eligible
		 * as a proxying/proxied prefix, we require that the
		 * prefix route entry be marked as a cloning route with
		 * RTF_PROXY; i.e. nd6_need_cache() needs to return
		 * true for the interface type.
		 */</span>
		<span class="enscript-keyword">if</span> (enable &amp;&amp; (pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) &amp;&amp;
		    nd6_need_cache(ifp)) {
			pr-&gt;ndpr_stateflags |= NDPRF_PRPROXY;
			NDPR_ADDREF_LOCKED(pr);
			NDPR_UNLOCK(pr);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!enable) {
			pr-&gt;ndpr_stateflags &amp;= ~NDPRF_PRPROXY;
			NDPR_ADDREF_LOCKED(pr);
			NDPR_UNLOCK(pr);
		} <span class="enscript-keyword">else</span> {
			NDPR_UNLOCK(pr);
			pr = NULL;	<span class="enscript-comment">/* don't go further */</span>
		}

		<span class="enscript-keyword">if</span> (pr == NULL)
			<span class="enscript-keyword">break</span>;

		up = nd6_ndprl_alloc(M_WAITOK);
		<span class="enscript-keyword">if</span> (up == NULL) {
			NDPR_REMREF(pr);
			<span class="enscript-keyword">continue</span>;
		}

		up-&gt;ndprl_pr = pr;	<span class="enscript-comment">/* keep reference from above */</span>
		SLIST_INSERT_HEAD(&amp;up_head, up, ndprl_le);
	}

	<span class="enscript-comment">/*
	 * Now build a list of matching (scoped) downstream prefixes on other
	 * interfaces which need to be enabled/disabled accordingly.  Note that
	 * the NDPRF_PRPROXY is never set/cleared on the downstream prefixes.
	 */</span>
	SLIST_FOREACH(up, &amp;up_head, ndprl_le) {
		<span class="enscript-type">struct</span> nd_prefix *fwd;
		<span class="enscript-type">struct</span> in6_addr pr_addr;
		u_char pr_len;

		pr = up-&gt;ndprl_pr;

		NDPR_LOCK(pr);
		bcopy(&amp;pr-&gt;ndpr_prefix.sin6_addr, &amp;pr_addr, <span class="enscript-keyword">sizeof</span> (pr_addr));
		pr_len = pr-&gt;ndpr_plen;
		NDPR_UNLOCK(pr);

		<span class="enscript-keyword">for</span> (fwd = nd_prefix.lh_first; fwd; fwd = fwd-&gt;ndpr_next) {
			NDPR_LOCK(fwd);
			<span class="enscript-keyword">if</span> (!(fwd-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) ||
			    !(fwd-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE) ||
			    fwd-&gt;ndpr_plen != pr_len ||
			    !in6_are_prefix_equal(&amp;fwd-&gt;ndpr_prefix.sin6_addr,
			    &amp;pr_addr, pr_len)) {
				NDPR_UNLOCK(fwd);
				<span class="enscript-keyword">continue</span>;
			}
			NDPR_UNLOCK(fwd);

			down = nd6_ndprl_alloc(M_WAITOK);
			<span class="enscript-keyword">if</span> (down == NULL)
				<span class="enscript-keyword">continue</span>;

			NDPR_ADDREF(fwd);
			down-&gt;ndprl_pr = fwd;
			NDPR_ADDREF(pr);
			down-&gt;ndprl_up = pr;
			SLIST_INSERT_HEAD(&amp;down_head, down, ndprl_le);
		}
	}
	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-comment">/*
	 * Apply routing function on prefixes; callee will free resources.
	 */</span>
	nd6_prproxy_prelist_setroute(enable,
	    (<span class="enscript-type">struct</span> nd6_prproxy_prelist_head *)&amp;up_head,
	    (<span class="enscript-type">struct</span> nd6_prproxy_prelist_head *)&amp;down_head);

	VERIFY(SLIST_EMPTY(&amp;up_head));
	VERIFY(SLIST_EMPTY(&amp;down_head));

	lck_mtx_unlock(&amp;proxy6_lock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Called from the input path to determine whether the packet is destined
 * to a proxied node; if so, mark the mbuf with PKTFF_PROXY_DST so that
 * icmp6_input() knows that this is not to be delivered to socket(s).
 */</span>
boolean_t
<span class="enscript-function-name">nd6_prproxy_isours</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> ip6_hdr *ip6, <span class="enscript-type">struct</span> route_in6 *ro6,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-type">struct</span> rtentry *rt;
	boolean_t ours = FALSE;

	<span class="enscript-keyword">if</span> (ip6-&gt;ip6_hlim != IPV6_MAXHLIM || ip6-&gt;ip6_nxt != IPPROTO_ICMPV6)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MC_NODELOCAL(&amp;ip6-&gt;ip6_dst) ||
	    IN6_IS_ADDR_MC_LINKLOCAL(&amp;ip6-&gt;ip6_dst)) {
		VERIFY(ro6 == NULL);
		ours = TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (ro6 == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	<span class="enscript-keyword">if</span> ((rt = ro6-&gt;ro_rt) != NULL)
		RT_LOCK(rt);

	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro6)) {
		<span class="enscript-keyword">if</span> (rt != NULL)
			RT_UNLOCK(rt);

		ROUTE_RELEASE(ro6);

		<span class="enscript-comment">/* Caller must have ensured this condition (not srcrt) */</span>
		VERIFY(IN6_ARE_ADDR_EQUAL(&amp;ip6-&gt;ip6_dst,
		    &amp;ro6-&gt;ro_dst.sin6_addr));

		rtalloc_scoped_ign((<span class="enscript-type">struct</span> route *)ro6, RTF_PRCLONING, ifscope);
		<span class="enscript-keyword">if</span> ((rt = ro6-&gt;ro_rt) == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

		RT_LOCK(rt);
	}

	ours = (rt-&gt;rt_flags &amp; RTF_PROXY) ? TRUE : FALSE;
	RT_UNLOCK(rt);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (ours)
		m-&gt;m_pkthdr.pkt_flags |= PKTF_PROXY_DST;

	<span class="enscript-keyword">return</span> (ours);
}

<span class="enscript-comment">/*
 * Called from the input path to determine whether or not the proxy
 * route entry is pointing to the correct interface, and to perform
 * the necessary route fixups otherwise.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_proxy_find_fwdroute</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> route_in6 *ro6)
{
	<span class="enscript-type">struct</span> in6_addr *dst6 = &amp;ro6-&gt;ro_dst.sin6_addr;
	<span class="enscript-type">struct</span> ifnet *fwd_ifp = NULL;
	<span class="enscript-type">struct</span> nd_prefix *pr;
	<span class="enscript-type">struct</span> rtentry *rt;

	<span class="enscript-keyword">if</span> ((rt = ro6-&gt;ro_rt) != NULL) {
		RT_LOCK(rt);
		<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; RTF_PROXY) || rt-&gt;rt_ifp == ifp) {
			nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s: found incorrect prefix &quot;</span>
			    <span class="enscript-string">&quot;proxy route for dst %s on %s\n&quot;</span>, if_name(ifp),
			    ip6_sprintf(dst6),
			    if_name(rt-&gt;rt_ifp)));
			RT_UNLOCK(rt);
			<span class="enscript-comment">/* look it up below */</span>
		} <span class="enscript-keyword">else</span> {
			RT_UNLOCK(rt);
			<span class="enscript-comment">/*
			 * The route is already marked with RTF_PRPROXY and
			 * it isn't pointing back to the inbound interface;
			 * optimistically return (see notes below).
			 */</span>
			<span class="enscript-keyword">return</span>;
		}
	}

	<span class="enscript-comment">/*
	 * Find out where we should forward this packet to, by searching
	 * for another interface that is proxying for the prefix.  Our
	 * current implementation assumes that the proxied prefix is shared
	 * to no more than one downstream interfaces (typically a bridge
	 * interface).
	 */</span>
	lck_mtx_lock(nd6_mutex);
	<span class="enscript-keyword">for</span> (pr = nd_prefix.lh_first; pr; pr = pr-&gt;ndpr_next) {
		<span class="enscript-type">struct</span> in6_addr pr_addr;
		<span class="enscript-type">struct</span> nd_prefix *fwd;
		u_char pr_len;

		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (!(pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) ||
		    !(pr-&gt;ndpr_stateflags &amp; NDPRF_PRPROXY) ||
		    !IN6_ARE_MASKED_ADDR_EQUAL(&amp;pr-&gt;ndpr_prefix.sin6_addr,
		    dst6, &amp;pr-&gt;ndpr_mask)) {
			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">continue</span>;
		}

		VERIFY(!(pr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE));
		bcopy(&amp;pr-&gt;ndpr_prefix.sin6_addr, &amp;pr_addr, <span class="enscript-keyword">sizeof</span> (pr_addr));
		pr_len = pr-&gt;ndpr_plen;
		NDPR_UNLOCK(pr);

		<span class="enscript-keyword">for</span> (fwd = nd_prefix.lh_first; fwd; fwd = fwd-&gt;ndpr_next) {
			NDPR_LOCK(fwd);
			<span class="enscript-keyword">if</span> (!(fwd-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) ||
			    fwd-&gt;ndpr_ifp == ifp ||
			    fwd-&gt;ndpr_plen != pr_len ||
			    !in6_are_prefix_equal(&amp;fwd-&gt;ndpr_prefix.sin6_addr,
			    &amp;pr_addr, pr_len)) {
				NDPR_UNLOCK(fwd);
				<span class="enscript-keyword">continue</span>;
			}

			fwd_ifp = fwd-&gt;ndpr_ifp;
			NDPR_UNLOCK(fwd);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	}
	lck_mtx_unlock(nd6_mutex);

	lck_mtx_lock(rnh_lock);
	ROUTE_RELEASE_LOCKED(ro6);

	<span class="enscript-comment">/*
	 * Lookup a forwarding route; delete the route if it's incorrect,
	 * or return to caller if the correct one got created prior to
	 * our acquiring the rnh_lock.
	 */</span>
	<span class="enscript-keyword">if</span> ((rt = rtalloc1_scoped_locked(SA(&amp;ro6-&gt;ro_dst), 0,
	    RTF_CLONING | RTF_PRCLONING, IFSCOPE_NONE)) != NULL) {
		RT_LOCK(rt);
		<span class="enscript-keyword">if</span> (rt-&gt;rt_ifp != fwd_ifp || !(rt-&gt;rt_flags &amp; RTF_PROXY)) {
			rt-&gt;rt_flags |= RTF_CONDEMNED;
			RT_UNLOCK(rt);
			(<span class="enscript-type">void</span>) rtrequest_locked(RTM_DELETE, rt_key(rt),
			    rt-&gt;rt_gateway, rt_mask(rt), rt-&gt;rt_flags, NULL);
			rtfree_locked(rt);
			rt = NULL;
		} <span class="enscript-keyword">else</span> {
			nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s: found prefix proxy route &quot;</span>
			    <span class="enscript-string">&quot;for dst %s\n&quot;</span>, if_name(rt-&gt;rt_ifp),
			    ip6_sprintf(dst6)));
			RT_UNLOCK(rt);
			ro6-&gt;ro_rt = rt;	<span class="enscript-comment">/* refcnt held by rtalloc1 */</span>
			lck_mtx_unlock(rnh_lock);
			<span class="enscript-keyword">return</span>;
		}
	}
	VERIFY(rt == NULL &amp;&amp; ro6-&gt;ro_rt == NULL);

	<span class="enscript-comment">/*
	 * Clone a route from the correct parent prefix route and return it.
	 */</span>
	<span class="enscript-keyword">if</span> (fwd_ifp != NULL &amp;&amp; (rt = rtalloc1_scoped_locked(SA(&amp;ro6-&gt;ro_dst), 1,
	    RTF_PRCLONING, fwd_ifp-&gt;if_index)) != NULL) {
		RT_LOCK(rt);
		<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; RTF_PROXY)) {
			RT_UNLOCK(rt);
			rtfree_locked(rt);
			rt = NULL;
		} <span class="enscript-keyword">else</span> {
			nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s: allocated prefix proxy &quot;</span>
			    <span class="enscript-string">&quot;route for dst %s\n&quot;</span>, if_name(rt-&gt;rt_ifp),
			    ip6_sprintf(dst6)));
			RT_UNLOCK(rt);
			ro6-&gt;ro_rt = rt;	<span class="enscript-comment">/* refcnt held by rtalloc1 */</span>
		}
	}
	VERIFY(rt != NULL || ro6-&gt;ro_rt == NULL);

	<span class="enscript-keyword">if</span> (fwd_ifp == NULL || rt == NULL) {
		nd6log2((LOG_ERR, <span class="enscript-string">&quot;%s: failed to find forwarding prefix &quot;</span>
		    <span class="enscript-string">&quot;proxy entry for dst %s\n&quot;</span>, if_name(ifp),
		    ip6_sprintf(dst6)));
	}
	lck_mtx_unlock(rnh_lock);
}

<span class="enscript-comment">/*
 * Called when a prefix transitions between on-link and off-link.  Perform
 * routing (RTF_PROXY) and interface (all-multicast) related operations on
 * the affected prefixes.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_prproxy_prelist_update</span>(<span class="enscript-type">struct</span> nd_prefix *pr_cur, <span class="enscript-type">struct</span> nd_prefix *pr_up)
{
	SLIST_HEAD(, nd6_prproxy_prelist) up_head;
	SLIST_HEAD(, nd6_prproxy_prelist) down_head;
	<span class="enscript-type">struct</span> nd6_prproxy_prelist *up, *down;
	<span class="enscript-type">struct</span> nd_prefix *pr;
	<span class="enscript-type">struct</span> in6_addr pr_addr;
	boolean_t enable;
	u_char pr_len;

	SLIST_INIT(&amp;up_head);
	SLIST_INIT(&amp;down_head);
	VERIFY(pr_cur != NULL);

	lck_mtx_assert(&amp;proxy6_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/*
	 * Upstream prefix.  If caller did not specify one, search for one
	 * based on the information in current prefix.  Caller is expected
	 * to have held an extra reference for the passed-in prefixes.
	 */</span>
	lck_mtx_lock(nd6_mutex);
	<span class="enscript-keyword">if</span> (pr_up == NULL) {
		NDPR_LOCK(pr_cur);
		bcopy(&amp;pr_cur-&gt;ndpr_prefix.sin6_addr, &amp;pr_addr,
		    <span class="enscript-keyword">sizeof</span> (pr_addr));
		pr_len = pr_cur-&gt;ndpr_plen;
		NDPR_UNLOCK(pr_cur);

		<span class="enscript-keyword">for</span> (pr = nd_prefix.lh_first; pr; pr = pr-&gt;ndpr_next) {
			NDPR_LOCK(pr);
			<span class="enscript-keyword">if</span> (!(pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) ||
			    !(pr-&gt;ndpr_stateflags &amp; NDPRF_PRPROXY) ||
			    pr-&gt;ndpr_plen != pr_len ||
			    !in6_are_prefix_equal(&amp;pr-&gt;ndpr_prefix.sin6_addr,
			    &amp;pr_addr, pr_len)) {
				NDPR_UNLOCK(pr);
				<span class="enscript-keyword">continue</span>;
			}
			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> ((pr_up = pr) == NULL) {
			lck_mtx_unlock(nd6_mutex);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		NDPR_LOCK(pr_up);
	} <span class="enscript-keyword">else</span> {
		NDPR_LOCK(pr_up);
		bcopy(&amp;pr_up-&gt;ndpr_prefix.sin6_addr, &amp;pr_addr,
		    <span class="enscript-keyword">sizeof</span> (pr_addr));
		pr_len = pr_up-&gt;ndpr_plen;
	}
	NDPR_LOCK_ASSERT_HELD(pr_up);
	<span class="enscript-comment">/*
	 * Upstream prefix could be offlink by now; therefore we cannot
	 * assert that NDPRF_PRPROXY is set; however, we can insist that
	 * it must not be a scoped prefix.
	 */</span>
	VERIFY(!(pr_up-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE));
	enable = (pr_up-&gt;ndpr_stateflags &amp; NDPRF_PRPROXY);
	NDPR_UNLOCK(pr_up);

	up = nd6_ndprl_alloc(M_WAITOK);
	<span class="enscript-keyword">if</span> (up == NULL) {
		lck_mtx_unlock(nd6_mutex);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	NDPR_ADDREF(pr_up);
	up-&gt;ndprl_pr = pr_up;
	SLIST_INSERT_HEAD(&amp;up_head, up, ndprl_le);

	<span class="enscript-comment">/*
	 * Now build a list of matching (scoped) downstream prefixes on other
	 * interfaces which need to be enabled/disabled accordingly.  Note that
	 * the NDPRF_PRPROXY is never set/cleared on the downstream prefixes.
	 */</span>
	<span class="enscript-keyword">for</span> (pr = nd_prefix.lh_first; pr; pr = pr-&gt;ndpr_next) {
		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (!(pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) ||
		    !(pr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE) ||
		    pr-&gt;ndpr_plen != pr_len ||
		    !in6_are_prefix_equal(&amp;pr-&gt;ndpr_prefix.sin6_addr,
		    &amp;pr_addr, pr_len)) {
			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">continue</span>;
		}
		NDPR_UNLOCK(pr);

		down = nd6_ndprl_alloc(M_WAITOK);
		<span class="enscript-keyword">if</span> (down == NULL)
			<span class="enscript-keyword">continue</span>;

		NDPR_ADDREF(pr);
		down-&gt;ndprl_pr = pr;
		NDPR_ADDREF(pr_up);
		down-&gt;ndprl_up = pr_up;
		SLIST_INSERT_HEAD(&amp;down_head, down, ndprl_le);
	}
	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-comment">/*
	 * Apply routing function on prefixes; callee will free resources.
	 */</span>
	nd6_prproxy_prelist_setroute(enable,
	    (<span class="enscript-type">struct</span> nd6_prproxy_prelist_head *)&amp;up_head,
	    (<span class="enscript-type">struct</span> nd6_prproxy_prelist_head *)&amp;down_head);

<span class="enscript-reference">done</span>:
	VERIFY(SLIST_EMPTY(&amp;up_head));
	VERIFY(SLIST_EMPTY(&amp;down_head));
}

<span class="enscript-comment">/*
 * Given an interface address, determine whether or not the address
 * is part of of a proxied prefix.
 */</span>
boolean_t
<span class="enscript-function-name">nd6_prproxy_ifaddr</span>(<span class="enscript-type">struct</span> in6_ifaddr *ia)
{
	<span class="enscript-type">struct</span> nd_prefix *pr;
	<span class="enscript-type">struct</span> in6_addr addr, pr_mask;
	u_int32_t pr_len;
	boolean_t proxied = FALSE;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_NOTOWNED);

	IFA_LOCK(&amp;ia-&gt;ia_ifa);
	bcopy(&amp;ia-&gt;ia_addr.sin6_addr, &amp;addr, <span class="enscript-keyword">sizeof</span> (addr));
	bcopy(&amp;ia-&gt;ia_prefixmask.sin6_addr, &amp;pr_mask, <span class="enscript-keyword">sizeof</span> (pr_mask));
	pr_len = ia-&gt;ia_plen;
	IFA_UNLOCK(&amp;ia-&gt;ia_ifa);

	lck_mtx_lock(nd6_mutex);
	<span class="enscript-keyword">for</span> (pr = nd_prefix.lh_first; pr; pr = pr-&gt;ndpr_next) {
		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> ((pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) &amp;&amp;
		    (pr-&gt;ndpr_stateflags &amp; NDPRF_PRPROXY) &amp;&amp;
		    in6_are_prefix_equal(&amp;pr-&gt;ndpr_prefix.sin6_addr,
		    &amp;addr, pr_len)) {
			NDPR_UNLOCK(pr);
			proxied = TRUE;
			<span class="enscript-keyword">break</span>;
		}
		NDPR_UNLOCK(pr);
	}
	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-keyword">return</span> (proxied);
}

<span class="enscript-comment">/*
 * Perform automatic proxy function with NS output.
 *
 * If the target address matches a global prefix obtained from a router
 * advertisement received on an interface with the ND6_IFF_PROXY_PREFIXES
 * flag set, then we send solicitations for the target address to all other
 * interfaces where a matching prefix is currently on-link, in addition to
 * the original interface.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_prproxy_ns_output</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> ifnet *exclifp,
    <span class="enscript-type">struct</span> in6_addr *daddr, <span class="enscript-type">struct</span> in6_addr *taddr, <span class="enscript-type">struct</span> llinfo_nd6 *ln)
{
	SLIST_HEAD(, nd6_prproxy_prelist) ndprl_head;
	<span class="enscript-type">struct</span> nd6_prproxy_prelist *ndprl, *ndprl_tmp;
	<span class="enscript-type">struct</span> nd_prefix *pr, *fwd;
	<span class="enscript-type">struct</span> ifnet *fwd_ifp;
	<span class="enscript-type">struct</span> in6_addr pr_addr;
	u_char pr_len;

	<span class="enscript-comment">/*
	 * Ignore excluded interface if it's the same as the original;
	 * we always send a NS on the original interface down below.
	 */</span>
	<span class="enscript-keyword">if</span> (exclifp != NULL &amp;&amp; exclifp == ifp)
		exclifp = NULL;

	<span class="enscript-keyword">if</span> (exclifp == NULL)
		nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s: sending NS who has %s on ALL\n&quot;</span>,
		    if_name(ifp), ip6_sprintf(taddr)));
	<span class="enscript-keyword">else</span>
		nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s: sending NS who has %s on ALL &quot;</span>
		    <span class="enscript-string">&quot;(except %s)\n&quot;</span>, if_name(ifp),
		    ip6_sprintf(taddr), if_name(exclifp)));

	SLIST_INIT(&amp;ndprl_head);

	lck_mtx_lock(nd6_mutex);

	<span class="enscript-keyword">for</span> (pr = nd_prefix.lh_first; pr; pr = pr-&gt;ndpr_next) {
		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (!(pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) ||
		    !(pr-&gt;ndpr_stateflags &amp; NDPRF_PRPROXY) ||
		    !IN6_ARE_MASKED_ADDR_EQUAL(&amp;pr-&gt;ndpr_prefix.sin6_addr,
		    taddr, &amp;pr-&gt;ndpr_mask)) {
			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">continue</span>;
		}

		VERIFY(!(pr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE));
		bcopy(&amp;pr-&gt;ndpr_prefix.sin6_addr, &amp;pr_addr, <span class="enscript-keyword">sizeof</span> (pr_addr));
		pr_len = pr-&gt;ndpr_plen;
		NDPR_UNLOCK(pr);

		<span class="enscript-keyword">for</span> (fwd = nd_prefix.lh_first; fwd; fwd = fwd-&gt;ndpr_next) {
			NDPR_LOCK(fwd);
			<span class="enscript-keyword">if</span> (!(fwd-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) ||
			    fwd-&gt;ndpr_ifp == ifp || fwd-&gt;ndpr_ifp == exclifp ||
			    fwd-&gt;ndpr_plen != pr_len ||
			    !in6_are_prefix_equal(&amp;fwd-&gt;ndpr_prefix.sin6_addr,
			    &amp;pr_addr, pr_len)) {
				NDPR_UNLOCK(fwd);
				<span class="enscript-keyword">continue</span>;
			}

			fwd_ifp = fwd-&gt;ndpr_ifp;
			NDPR_UNLOCK(fwd);

			ndprl = nd6_ndprl_alloc(M_WAITOK);
			<span class="enscript-keyword">if</span> (ndprl == NULL)
				<span class="enscript-keyword">continue</span>;

			NDPR_ADDREF(fwd);
			ndprl-&gt;ndprl_pr = fwd;
			ndprl-&gt;ndprl_fwd_ifp = fwd_ifp;

			SLIST_INSERT_HEAD(&amp;ndprl_head, ndprl, ndprl_le);
		}
		<span class="enscript-keyword">break</span>;
	}

	lck_mtx_unlock(nd6_mutex);

	SLIST_FOREACH_SAFE(ndprl, &amp;ndprl_head, ndprl_le, ndprl_tmp) {
		SLIST_REMOVE(&amp;ndprl_head, ndprl, nd6_prproxy_prelist, ndprl_le);

		pr = ndprl-&gt;ndprl_pr;
		fwd_ifp = ndprl-&gt;ndprl_fwd_ifp;

		<span class="enscript-keyword">if</span> ((fwd_ifp-&gt;if_eflags &amp; IFEF_IPV6_ND6ALT) != 0) {
			NDPR_REMREF(pr);
			nd6_ndprl_free(ndprl);
			<span class="enscript-keyword">continue</span>;
		}

		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) {
			NDPR_UNLOCK(pr);
			nd6log2((LOG_DEBUG,
			    <span class="enscript-string">&quot;%s: Sending cloned NS who has %s, originally &quot;</span>
			    <span class="enscript-string">&quot;on %s\n&quot;</span>, if_name(fwd_ifp),
			    ip6_sprintf(taddr), if_name(ifp)));

			nd6_ns_output(fwd_ifp, daddr, taddr, NULL, 0);
		} <span class="enscript-keyword">else</span> {
			NDPR_UNLOCK(pr);
		}
		NDPR_REMREF(pr);

		nd6_ndprl_free(ndprl);
	}
	VERIFY(SLIST_EMPTY(&amp;ndprl_head));

	nd6_ns_output(ifp, daddr, taddr, ln, 0);
}

<span class="enscript-comment">/*
 * Perform automatic proxy function with NS input.
 *
 * If the target address matches a global prefix obtained from a router
 * advertisement received on an interface with the ND6_IFF_PROXY_PREFIXES
 * flag set, then we send solicitations for the target address to all other
 * interfaces where a matching prefix is currently on-link.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_prproxy_ns_input</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> in6_addr *saddr,
    <span class="enscript-type">char</span> *lladdr, <span class="enscript-type">int</span> lladdrlen, <span class="enscript-type">struct</span> in6_addr *daddr, <span class="enscript-type">struct</span> in6_addr *taddr)
{
	SLIST_HEAD(, nd6_prproxy_prelist) ndprl_head;
	<span class="enscript-type">struct</span> nd6_prproxy_prelist *ndprl, *ndprl_tmp;
	<span class="enscript-type">struct</span> nd_prefix *pr, *fwd;
	<span class="enscript-type">struct</span> ifnet *fwd_ifp;
	<span class="enscript-type">struct</span> in6_addr pr_addr;
	u_char pr_len;
	boolean_t solrec = FALSE;

	SLIST_INIT(&amp;ndprl_head);

	lck_mtx_lock(nd6_mutex);

	<span class="enscript-keyword">for</span> (pr = nd_prefix.lh_first; pr; pr = pr-&gt;ndpr_next) {
		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (!(pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) ||
		    !(pr-&gt;ndpr_stateflags &amp; NDPRF_PRPROXY) ||
		    !IN6_ARE_MASKED_ADDR_EQUAL(&amp;pr-&gt;ndpr_prefix.sin6_addr,
		    taddr, &amp;pr-&gt;ndpr_mask)) {
			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">continue</span>;
		}

		VERIFY(!(pr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE));
		bcopy(&amp;pr-&gt;ndpr_prefix.sin6_addr, &amp;pr_addr, <span class="enscript-keyword">sizeof</span> (pr_addr));
		pr_len = pr-&gt;ndpr_plen;

		<span class="enscript-comment">/*
		 * If this is a NS for NUD/AR, record it so that we know
		 * how to forward the NA reply later on (if/when it arrives.)
		 * Give up if we fail to save the NS info.
		 */</span>
		<span class="enscript-keyword">if</span> ((solrec = !IN6_IS_ADDR_UNSPECIFIED(saddr)) &amp;&amp;
		    !nd6_solsrc_enq(pr, ifp, saddr, taddr)) {
			NDPR_UNLOCK(pr);
			solrec = FALSE;
			<span class="enscript-keyword">break</span>;			<span class="enscript-comment">/* bail out */</span>
		} <span class="enscript-keyword">else</span> {
			NDPR_UNLOCK(pr);
		}

		<span class="enscript-keyword">for</span> (fwd = nd_prefix.lh_first; fwd; fwd = fwd-&gt;ndpr_next) {
			NDPR_LOCK(fwd);
			<span class="enscript-keyword">if</span> (!(fwd-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) ||
			    fwd-&gt;ndpr_ifp == ifp ||
			    fwd-&gt;ndpr_plen != pr_len ||
			    !in6_are_prefix_equal(&amp;fwd-&gt;ndpr_prefix.sin6_addr,
			    &amp;pr_addr, pr_len)) {
				NDPR_UNLOCK(fwd);
				<span class="enscript-keyword">continue</span>;
			}

			fwd_ifp = fwd-&gt;ndpr_ifp;
			NDPR_UNLOCK(fwd);

			ndprl = nd6_ndprl_alloc(M_WAITOK);
			<span class="enscript-keyword">if</span> (ndprl == NULL)
				<span class="enscript-keyword">continue</span>;

			NDPR_ADDREF(fwd);
			ndprl-&gt;ndprl_pr = fwd;
			ndprl-&gt;ndprl_fwd_ifp = fwd_ifp;
			ndprl-&gt;ndprl_sol = solrec;

			SLIST_INSERT_HEAD(&amp;ndprl_head, ndprl, ndprl_le);
		}
		<span class="enscript-keyword">break</span>;
	}

	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-comment">/*
	 * If this is a recorded solicitation (NS for NUD/AR), create
	 * or update the neighbor cache entry for the soliciting node.
	 * Later on, when the NA reply arrives, we will need this cache
	 * entry in order to send the NA back to the original solicitor.
	 * Without a neighbor cache entry, we'd end up with an endless
	 * cycle of NS ping-pong between the us (the proxy) and the node
	 * which is soliciting for the address.
	 */</span>
	<span class="enscript-keyword">if</span> (solrec) {
		VERIFY(!IN6_IS_ADDR_UNSPECIFIED(saddr));
		nd6_cache_lladdr(ifp, saddr, lladdr, lladdrlen,
		    ND_NEIGHBOR_SOLICIT, 0);
	}

	SLIST_FOREACH_SAFE(ndprl, &amp;ndprl_head, ndprl_le, ndprl_tmp) {
		SLIST_REMOVE(&amp;ndprl_head, ndprl, nd6_prproxy_prelist, ndprl_le);

		pr = ndprl-&gt;ndprl_pr;
		fwd_ifp = ndprl-&gt;ndprl_fwd_ifp;

		<span class="enscript-keyword">if</span> ((fwd_ifp-&gt;if_eflags &amp; IFEF_IPV6_ND6ALT) != 0) {
			NDPR_REMREF(pr);
			nd6_ndprl_free(ndprl);
			<span class="enscript-keyword">continue</span>;
		}

		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) {
			NDPR_UNLOCK(pr);
			nd6log2((LOG_DEBUG,
			    <span class="enscript-string">&quot;%s: Forwarding NS (%s) from %s to %s who &quot;</span>
			    <span class="enscript-string">&quot;has %s, originally on %s\n&quot;</span>, if_name(fwd_ifp),
			    ndprl-&gt;ndprl_sol ? <span class="enscript-string">&quot;NUD/AR&quot;</span> :
			    <span class="enscript-string">&quot;DAD&quot;</span>, ip6_sprintf(saddr), ip6_sprintf(daddr),
			    ip6_sprintf(taddr), if_name(ifp)));

			nd6_ns_output(fwd_ifp, ndprl-&gt;ndprl_sol ? taddr : NULL,
			    taddr, NULL, !ndprl-&gt;ndprl_sol);
		} <span class="enscript-keyword">else</span> {
			NDPR_UNLOCK(pr);
		}
		NDPR_REMREF(pr);

		nd6_ndprl_free(ndprl);
	}
	VERIFY(SLIST_EMPTY(&amp;ndprl_head));
}

<span class="enscript-comment">/*
 * Perform automatic proxy function with NA input.
 *
 * If the target address matches a global prefix obtained from a router
 * advertisement received on an interface with the ND6_IFF_PROXY_PREFIXES flag
 * set, then we send neighbor advertisements for the target address on all
 * other interfaces where a matching prefix is currently on link.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_prproxy_na_input</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> in6_addr *saddr,
    <span class="enscript-type">struct</span> in6_addr *daddr0, <span class="enscript-type">struct</span> in6_addr *taddr, <span class="enscript-type">int</span> flags)
{
	SLIST_HEAD(, nd6_prproxy_prelist) ndprl_head;
	<span class="enscript-type">struct</span> nd6_prproxy_prelist *ndprl, *ndprl_tmp;
	<span class="enscript-type">struct</span> nd_prefix *pr;
	<span class="enscript-type">struct</span> ifnet *fwd_ifp;
	<span class="enscript-type">struct</span> in6_addr daddr;

	SLIST_INIT(&amp;ndprl_head);


	lck_mtx_lock(nd6_mutex);

	<span class="enscript-keyword">for</span> (pr = nd_prefix.lh_first; pr; pr = pr-&gt;ndpr_next) {
		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (!(pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) ||
		    !(pr-&gt;ndpr_stateflags &amp; NDPRF_PRPROXY) ||
		    !IN6_ARE_MASKED_ADDR_EQUAL(&amp;pr-&gt;ndpr_prefix.sin6_addr,
		    taddr, &amp;pr-&gt;ndpr_mask)) {
			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">continue</span>;
		}

		VERIFY(!(pr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE));
		<span class="enscript-comment">/*
		 * If this is a NA for NUD, see if there is a record created
		 * for the corresponding NS; upon success, we get back the
		 * interface where the NS originally arrived on, as well as
		 * the soliciting node's address.  Give up if we can't find it.
		 */</span>
		<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_MULTICAST(daddr0)) {
			fwd_ifp = NULL;
			bzero(&amp;daddr, <span class="enscript-keyword">sizeof</span> (daddr));
			<span class="enscript-keyword">if</span> (!nd6_solsrc_deq(pr, taddr, &amp;daddr, &amp;fwd_ifp)) {
				NDPR_UNLOCK(pr);
				<span class="enscript-keyword">break</span>;		<span class="enscript-comment">/* bail out */</span>
			}
			VERIFY(!IN6_IS_ADDR_UNSPECIFIED(&amp;daddr) &amp;&amp; fwd_ifp);
			NDPR_UNLOCK(pr);

			ndprl = nd6_ndprl_alloc(M_WAITOK);
			<span class="enscript-keyword">if</span> (ndprl == NULL)
				<span class="enscript-keyword">break</span>;		<span class="enscript-comment">/* bail out */</span>

			ndprl-&gt;ndprl_fwd_ifp = fwd_ifp;
			ndprl-&gt;ndprl_sol = TRUE;
			ndprl-&gt;ndprl_sol_saddr = *(&amp;daddr);

			SLIST_INSERT_HEAD(&amp;ndprl_head, ndprl, ndprl_le);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> nd_prefix *fwd;
			<span class="enscript-type">struct</span> in6_addr pr_addr;
			u_char pr_len;

			bcopy(&amp;pr-&gt;ndpr_prefix.sin6_addr, &amp;pr_addr,
			    <span class="enscript-keyword">sizeof</span> (pr_addr));
			pr_len = pr-&gt;ndpr_plen;
			NDPR_UNLOCK(pr);

			<span class="enscript-keyword">for</span> (fwd = nd_prefix.lh_first; fwd;
			    fwd = fwd-&gt;ndpr_next) {
				NDPR_LOCK(fwd);
				<span class="enscript-keyword">if</span> (!(fwd-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) ||
				    fwd-&gt;ndpr_ifp == ifp ||
				    fwd-&gt;ndpr_plen != pr_len ||
				    !in6_are_prefix_equal(
				    &amp;fwd-&gt;ndpr_prefix.sin6_addr,
				    &amp;pr_addr, pr_len)) {
					NDPR_UNLOCK(fwd);
					<span class="enscript-keyword">continue</span>;
				}

				fwd_ifp = fwd-&gt;ndpr_ifp;
				NDPR_UNLOCK(fwd);

				ndprl = nd6_ndprl_alloc(M_WAITOK);
				<span class="enscript-keyword">if</span> (ndprl == NULL)
					<span class="enscript-keyword">continue</span>;

				NDPR_ADDREF(fwd);
				ndprl-&gt;ndprl_pr = fwd;
				ndprl-&gt;ndprl_fwd_ifp = fwd_ifp;

				SLIST_INSERT_HEAD(&amp;ndprl_head, ndprl, ndprl_le);
			}
		}
		<span class="enscript-keyword">break</span>;
	}

	lck_mtx_unlock(nd6_mutex);

	SLIST_FOREACH_SAFE(ndprl, &amp;ndprl_head, ndprl_le, ndprl_tmp) {
		boolean_t send_na;

		SLIST_REMOVE(&amp;ndprl_head, ndprl, nd6_prproxy_prelist, ndprl_le);

		pr = ndprl-&gt;ndprl_pr;
		fwd_ifp = ndprl-&gt;ndprl_fwd_ifp;

		<span class="enscript-keyword">if</span> (ndprl-&gt;ndprl_sol) {
			VERIFY(pr == NULL);
			daddr = *(&amp;ndprl-&gt;ndprl_sol_saddr);
			VERIFY(!IN6_IS_ADDR_UNSPECIFIED(&amp;daddr));
			send_na = (in6_setscope(&amp;daddr, fwd_ifp, NULL) == 0);
		} <span class="enscript-keyword">else</span> {
			VERIFY(pr != NULL);
			daddr = *daddr0;
			NDPR_LOCK(pr);
			send_na = ((pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) &amp;&amp;
			    in6_setscope(&amp;daddr, fwd_ifp, NULL) == 0);
			NDPR_UNLOCK(pr);
		}

		<span class="enscript-keyword">if</span> (send_na) {
			<span class="enscript-keyword">if</span> (!ndprl-&gt;ndprl_sol) {
				nd6log2((LOG_DEBUG,
				    <span class="enscript-string">&quot;%s: Forwarding NA (DAD) from %s to %s &quot;</span>
				    <span class="enscript-string">&quot;tgt is %s, originally on %s\n&quot;</span>,
				    if_name(fwd_ifp),
				    ip6_sprintf(saddr), ip6_sprintf(&amp;daddr),
				    ip6_sprintf(taddr), if_name(ifp)));
			} <span class="enscript-keyword">else</span> {
				nd6log2((LOG_DEBUG,
				    <span class="enscript-string">&quot;%s: Forwarding NA (NUD/AR) from %s to &quot;</span>
				    <span class="enscript-string">&quot;%s (was %s) tgt is %s, originally on &quot;</span>
				    <span class="enscript-string">&quot;%s\n&quot;</span>, if_name(fwd_ifp),
				    ip6_sprintf(saddr),
				    ip6_sprintf(&amp;daddr), ip6_sprintf(daddr0),
				    ip6_sprintf(taddr), if_name(ifp)));
			}

			nd6_na_output(fwd_ifp, &amp;daddr, taddr, flags, 1, NULL);
		}

		<span class="enscript-keyword">if</span> (pr != NULL)
			NDPR_REMREF(pr);

		nd6_ndprl_free(ndprl);
	}
	VERIFY(SLIST_EMPTY(&amp;ndprl_head));
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd6_prproxy_solsrc *
<span class="enscript-function-name">nd6_solsrc_alloc</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> nd6_prproxy_solsrc *ssrc;

	ssrc = (how == M_WAITOK) ? zalloc(solsrc_zone) :
	    zalloc_noblock(solsrc_zone);
	<span class="enscript-keyword">if</span> (ssrc != NULL)
		bzero(ssrc, solsrc_size);

	<span class="enscript-keyword">return</span> (ssrc);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_solsrc_free</span>(<span class="enscript-type">struct</span> nd6_prproxy_solsrc *ssrc)
{
	zfree(solsrc_zone, ssrc);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_prproxy_sols_purge</span>(<span class="enscript-type">struct</span> nd_prefix *pr, u_int64_t max_stgt)
{
	<span class="enscript-type">struct</span> nd6_prproxy_soltgt *soltgt, *tmp;
	u_int64_t expire = (max_stgt &gt; 0) ? net_uptime() : 0;

	NDPR_LOCK_ASSERT_HELD(pr);

	<span class="enscript-comment">/* Either trim all or those that have expired or are idle */</span>
	RB_FOREACH_SAFE(soltgt, prproxy_sols_tree,
	    &amp;pr-&gt;ndpr_prproxy_sols, tmp) {
		VERIFY(pr-&gt;ndpr_prproxy_sols_cnt &gt; 0);
		<span class="enscript-keyword">if</span> (expire == 0 || soltgt-&gt;soltgt_expire &lt;= expire ||
		    soltgt-&gt;soltgt_cnt == 0) {
			pr-&gt;ndpr_prproxy_sols_cnt--;
			RB_REMOVE(prproxy_sols_tree,
			    &amp;pr-&gt;ndpr_prproxy_sols, soltgt);
			nd6_soltgt_free(soltgt);
		}
	}

	<span class="enscript-keyword">if</span> (max_stgt == 0 || pr-&gt;ndpr_prproxy_sols_cnt &lt; max_stgt) {
		VERIFY(max_stgt != 0 || (pr-&gt;ndpr_prproxy_sols_cnt == 0 &amp;&amp;
		    RB_EMPTY(&amp;pr-&gt;ndpr_prproxy_sols)));
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* Brute force; mercilessly evict entries until we are under limit */</span>
	RB_FOREACH_SAFE(soltgt, prproxy_sols_tree,
	    &amp;pr-&gt;ndpr_prproxy_sols, tmp) {
		VERIFY(pr-&gt;ndpr_prproxy_sols_cnt &gt; 0);
		pr-&gt;ndpr_prproxy_sols_cnt--;
		RB_REMOVE(prproxy_sols_tree, &amp;pr-&gt;ndpr_prproxy_sols, soltgt);
		nd6_soltgt_free(soltgt);
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_prproxy_sols_cnt &lt; max_stgt)
			<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-comment">/*
 * Purges all solicitation records on a given prefix.
 * Caller is responsible for holding prefix lock.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_prproxy_sols_reap</span>(<span class="enscript-type">struct</span> nd_prefix *pr)
{
	nd6_prproxy_sols_purge(pr, 0);
}

<span class="enscript-comment">/*
 * Purges expired or idle solicitation records on a given prefix.
 * Caller is responsible for holding prefix lock.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_prproxy_sols_prune</span>(<span class="enscript-type">struct</span> nd_prefix *pr, u_int32_t max_stgt)
{
	nd6_prproxy_sols_purge(pr, max_stgt);
}

<span class="enscript-comment">/*
 * Enqueue a soliciation record in the target record of a prefix.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">nd6_solsrc_enq</span>(<span class="enscript-type">struct</span> nd_prefix *pr, <span class="enscript-type">struct</span> ifnet *ifp,
    <span class="enscript-type">struct</span> in6_addr *saddr, <span class="enscript-type">struct</span> in6_addr *taddr)
{
	<span class="enscript-type">struct</span> nd6_prproxy_soltgt find, *soltgt;
	<span class="enscript-type">struct</span> nd6_prproxy_solsrc *ssrc;
	u_int32_t max_stgt = nd6_max_tgt_sols;
	u_int32_t max_ssrc = nd6_max_src_sols;

	NDPR_LOCK_ASSERT_HELD(pr);
	VERIFY(!(pr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE));
	VERIFY((pr-&gt;ndpr_stateflags &amp; (NDPRF_ONLINK|NDPRF_PRPROXY)) ==
	    (NDPRF_ONLINK|NDPRF_PRPROXY));
	VERIFY(!IN6_IS_ADDR_UNSPECIFIED(saddr));

	ssrc = nd6_solsrc_alloc(M_WAITOK);
	<span class="enscript-keyword">if</span> (ssrc == NULL)
		<span class="enscript-keyword">return</span> (FALSE);

	ssrc-&gt;solsrc_saddr = *saddr;
	ssrc-&gt;solsrc_ifp = ifp;

	find.soltgt_key.taddr = *taddr;		<span class="enscript-comment">/* search key */</span>

	soltgt = RB_FIND(prproxy_sols_tree, &amp;pr-&gt;ndpr_prproxy_sols, &amp;find);
	<span class="enscript-keyword">if</span> (soltgt == NULL) {
		<span class="enscript-keyword">if</span> (max_stgt != 0 &amp;&amp; pr-&gt;ndpr_prproxy_sols_cnt &gt;= max_stgt) {
			VERIFY(!RB_EMPTY(&amp;pr-&gt;ndpr_prproxy_sols));
			nd6_prproxy_sols_prune(pr, max_stgt);
			VERIFY(pr-&gt;ndpr_prproxy_sols_cnt &lt; max_stgt);
		}

		soltgt = nd6_soltgt_alloc(M_WAITOK);
		<span class="enscript-keyword">if</span> (soltgt == NULL) {
			nd6_solsrc_free(ssrc);
			<span class="enscript-keyword">return</span> (FALSE);
		}

		soltgt-&gt;soltgt_key.taddr = *taddr;
		VERIFY(soltgt-&gt;soltgt_cnt == 0);
		VERIFY(TAILQ_EMPTY(&amp;soltgt-&gt;soltgt_q));

		pr-&gt;ndpr_prproxy_sols_cnt++;
		VERIFY(pr-&gt;ndpr_prproxy_sols_cnt != 0);
		RB_INSERT(prproxy_sols_tree, &amp;pr-&gt;ndpr_prproxy_sols, soltgt);
	}

	<span class="enscript-keyword">if</span> (max_ssrc != 0 &amp;&amp; soltgt-&gt;soltgt_cnt &gt;= max_ssrc) {
		VERIFY(!TAILQ_EMPTY(&amp;soltgt-&gt;soltgt_q));
		nd6_soltgt_prune(soltgt, max_ssrc);
		VERIFY(soltgt-&gt;soltgt_cnt &lt; max_ssrc);
	}

	soltgt-&gt;soltgt_cnt++;
	VERIFY(soltgt-&gt;soltgt_cnt != 0);
	TAILQ_INSERT_TAIL(&amp;soltgt-&gt;soltgt_q, ssrc, solsrc_tqe);
	<span class="enscript-keyword">if</span> (soltgt-&gt;soltgt_cnt == 1)
		soltgt-&gt;soltgt_expire = net_uptime() + ND6_TGT_SOLS_EXPIRE;

	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-comment">/*
 * Dequeue a solicitation record from a target record of a prefix.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">nd6_solsrc_deq</span>(<span class="enscript-type">struct</span> nd_prefix *pr, <span class="enscript-type">struct</span> in6_addr *taddr,
    <span class="enscript-type">struct</span> in6_addr *daddr, <span class="enscript-type">struct</span> ifnet **ifp)
{
	<span class="enscript-type">struct</span> nd6_prproxy_soltgt find, *soltgt;
	<span class="enscript-type">struct</span> nd6_prproxy_solsrc *ssrc;

	NDPR_LOCK_ASSERT_HELD(pr);
	VERIFY(!(pr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE));
	VERIFY((pr-&gt;ndpr_stateflags &amp; (NDPRF_ONLINK|NDPRF_PRPROXY)) ==
	    (NDPRF_ONLINK|NDPRF_PRPROXY));

	bzero(daddr, <span class="enscript-keyword">sizeof</span> (*daddr));
	*ifp = NULL;

	find.soltgt_key.taddr = *taddr;		<span class="enscript-comment">/* search key */</span>

	soltgt = RB_FIND(prproxy_sols_tree, &amp;pr-&gt;ndpr_prproxy_sols, &amp;find);
	<span class="enscript-keyword">if</span> (soltgt == NULL || soltgt-&gt;soltgt_cnt == 0) {
		VERIFY(soltgt == NULL || TAILQ_EMPTY(&amp;soltgt-&gt;soltgt_q));
		<span class="enscript-keyword">return</span> (FALSE);
	}

	VERIFY(soltgt-&gt;soltgt_cnt != 0);
	--soltgt-&gt;soltgt_cnt;
	ssrc = TAILQ_FIRST(&amp;soltgt-&gt;soltgt_q);
	VERIFY(ssrc != NULL);
	TAILQ_REMOVE(&amp;soltgt-&gt;soltgt_q, ssrc, solsrc_tqe);
	*daddr = *(&amp;ssrc-&gt;solsrc_saddr);
	*ifp = ssrc-&gt;solsrc_ifp;
	nd6_solsrc_free(ssrc);

	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd6_prproxy_soltgt *
<span class="enscript-function-name">nd6_soltgt_alloc</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> nd6_prproxy_soltgt *soltgt;

	soltgt = (how == M_WAITOK) ? zalloc(soltgt_zone) :
	    zalloc_noblock(soltgt_zone);
	<span class="enscript-keyword">if</span> (soltgt != NULL) {
		bzero(soltgt, soltgt_size);
		TAILQ_INIT(&amp;soltgt-&gt;soltgt_q);
	}
	<span class="enscript-keyword">return</span> (soltgt);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_soltgt_free</span>(<span class="enscript-type">struct</span> nd6_prproxy_soltgt *soltgt)
{
	<span class="enscript-type">struct</span> nd6_prproxy_solsrc *ssrc, *tssrc;

	TAILQ_FOREACH_SAFE(ssrc, &amp;soltgt-&gt;soltgt_q, solsrc_tqe, tssrc) {
		VERIFY(soltgt-&gt;soltgt_cnt &gt; 0);
		soltgt-&gt;soltgt_cnt--;
		TAILQ_REMOVE(&amp;soltgt-&gt;soltgt_q, ssrc, solsrc_tqe);
		nd6_solsrc_free(ssrc);
	}

	VERIFY(soltgt-&gt;soltgt_cnt == 0);
	VERIFY(TAILQ_EMPTY(&amp;soltgt-&gt;soltgt_q));

	zfree(soltgt_zone, soltgt);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_soltgt_prune</span>(<span class="enscript-type">struct</span> nd6_prproxy_soltgt *soltgt, u_int32_t max_ssrc)
{
	<span class="enscript-keyword">while</span> (soltgt-&gt;soltgt_cnt &gt;= max_ssrc) {
		<span class="enscript-type">struct</span> nd6_prproxy_solsrc *ssrc;

		VERIFY(soltgt-&gt;soltgt_cnt != 0);
		--soltgt-&gt;soltgt_cnt;
		ssrc = TAILQ_FIRST(&amp;soltgt-&gt;soltgt_q);
		VERIFY(ssrc != NULL);
		TAILQ_REMOVE(&amp;soltgt-&gt;soltgt_q, ssrc, solsrc_tqe);
		nd6_solsrc_free(ssrc);
	}
}

<span class="enscript-comment">/*
 * Solicited target tree comparison function.
 *
 * An ordered predicate is necessary; bcmp() is not documented to return
 * an indication of order, memcmp() is, and is an ISO C99 requirement.
 */</span>
<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span>
<span class="enscript-function-name">soltgt_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> nd6_prproxy_soltgt *a,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> nd6_prproxy_soltgt *b)
{
	<span class="enscript-keyword">return</span> (memcmp(&amp;a-&gt;soltgt_key, &amp;b-&gt;soltgt_key, <span class="enscript-keyword">sizeof</span> (a-&gt;soltgt_key)));
}
</pre>
<hr />
</body></html>