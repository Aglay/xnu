<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nd6_nbr.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nd6_nbr.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_llreach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_ifattach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/scope6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span> dadq;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> dadq *<span class="enscript-function-name">nd6_dad_find</span>(<span class="enscript-type">struct</span> ifaddr *);
<span class="enscript-type">void</span> <span class="enscript-function-name">nd6_dad_stoptimer</span>(<span class="enscript-type">struct</span> ifaddr *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_dad_timer</span>(<span class="enscript-type">struct</span> ifaddr *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_dad_ns_output</span>(<span class="enscript-type">struct</span> dadq *, <span class="enscript-type">struct</span> ifaddr *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_dad_ns_input</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> ifaddr *, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">nd6_dad_na_input</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> ifnet *,
    <span class="enscript-type">struct</span> in6_addr *, caddr_t, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dad_addref</span>(<span class="enscript-type">struct</span> dadq *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dad_remref</span>(<span class="enscript-type">struct</span> dadq *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> dadq *<span class="enscript-function-name">nd6_dad_attach</span>(<span class="enscript-type">struct</span> dadq *, <span class="enscript-type">struct</span> ifaddr *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_dad_detach</span>(<span class="enscript-type">struct</span> dadq *, <span class="enscript-type">struct</span> ifaddr *);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> dad_maxtry = 15;	<span class="enscript-comment">/* max # of *tries* to transmit DAD packet */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> dad_size;			<span class="enscript-comment">/* size of zone element */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *dad_zone;			<span class="enscript-comment">/* zone for dadq */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DAD_ZONE_MAX</span>	64			<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DAD_ZONE_NAME</span>	<span class="enscript-string">&quot;nd6_dad&quot;</span>		<span class="enscript-comment">/* zone name */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DAD_LOCK_ASSERT_HELD</span>(_dp)					\
	lck_mtx_assert(&amp;(_dp)-&gt;dad_lock, LCK_MTX_ASSERT_OWNED)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DAD_LOCK_ASSERT_NOTHELD</span>(_dp)					\
	lck_mtx_assert(&amp;(_dp)-&gt;dad_lock, LCK_MTX_ASSERT_NOTOWNED)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DAD_LOCK</span>(_dp)							\
	lck_mtx_lock(&amp;(_dp)-&gt;dad_lock)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DAD_LOCK_SPIN</span>(_dp)						\
	lck_mtx_lock_spin(&amp;(_dp)-&gt;dad_lock)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DAD_CONVERT_LOCK</span>(_dp) do {					\
	DAD_LOCK_ASSERT_HELD(_dp);					\
	lck_mtx_convert_spin(&amp;(_dp)-&gt;dad_lock);				\
} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DAD_UNLOCK</span>(_dp)							\
	lck_mtx_unlock(&amp;(_dp)-&gt;dad_lock)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DAD_ADDREF</span>(_dp)							\
	dad_addref(_dp, 0)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DAD_ADDREF_LOCKED</span>(_dp)						\
	dad_addref(_dp, 1)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DAD_REMREF</span>(_dp)							\
	dad_remref(_dp)

<span class="enscript-type">extern</span> lck_mtx_t *dad6_mutex;
<span class="enscript-type">extern</span> lck_mtx_t *nd6_mutex;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> nd6_llreach_base = (LL_BASE_REACHABLE / 1000); <span class="enscript-comment">/* seconds */</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> sockaddr_in6 hostrtmask;

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_inet6_icmp6);

<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_icmp6, OID_AUTO, nd6_llreach_base,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nd6_llreach_base, LL_BASE_REACHABLE,
    <span class="enscript-string">&quot;default ND6 link-layer reachability max lifetime (in seconds)&quot;</span>);

<span class="enscript-comment">/*
 * Obtain a link-layer source cache entry for the sender.
 *
 * NOTE: This is currently only for ND6/Ethernet.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_llreach_alloc</span>(<span class="enscript-type">struct</span> rtentry *rt, <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">void</span> *addr,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> alen, boolean_t solicited)
{
	<span class="enscript-type">struct</span> llinfo_nd6 *ln = rt-&gt;rt_llinfo;

	<span class="enscript-keyword">if</span> (nd6_llreach_base != 0 &amp;&amp;
	    (ln-&gt;ln_expire != 0 || (ifp-&gt;if_eflags &amp; IFEF_IPV6_ND6ALT) != 0) &amp;&amp;
	    !(rt-&gt;rt_ifp-&gt;if_flags &amp; IFF_LOOPBACK) &amp;&amp;
	    ifp-&gt;if_addrlen == IF_LLREACH_MAXLEN &amp;&amp;	<span class="enscript-comment">/* Ethernet */</span>
	    alen == ifp-&gt;if_addrlen) {
		<span class="enscript-type">struct</span> if_llreach *lr;
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *why = NULL, *type = <span class="enscript-string">&quot;&quot;</span>;

		<span class="enscript-comment">/* Become a regular mutex, just in case */</span>
		RT_CONVERT_LOCK(rt);

		<span class="enscript-keyword">if</span> ((lr = ln-&gt;ln_llreach) != NULL) {
			type = (solicited ? <span class="enscript-string">&quot;ND6 advertisement&quot;</span> :
			    <span class="enscript-string">&quot;ND6 unsolicited announcement&quot;</span>);
			<span class="enscript-comment">/*
			 * If target has changed, create a new record;
			 * otherwise keep existing record.
			 */</span>
			IFLR_LOCK(lr);
			<span class="enscript-keyword">if</span> (bcmp(addr, lr-&gt;lr_key.addr, alen) != 0) {
				IFLR_UNLOCK(lr);
				<span class="enscript-comment">/* Purge any link-layer info caching */</span>
				VERIFY(rt-&gt;rt_llinfo_purge != NULL);
				rt-&gt;rt_llinfo_purge(rt);
				lr = NULL;
				why = <span class="enscript-string">&quot; for different target HW address; &quot;</span>
				    <span class="enscript-string">&quot;using new llreach record&quot;</span>;
			} <span class="enscript-keyword">else</span> {
				lr-&gt;lr_probes = 0;	<span class="enscript-comment">/* reset probe count */</span>
				IFLR_UNLOCK(lr);
				<span class="enscript-keyword">if</span> (solicited) {
					why = <span class="enscript-string">&quot; for same target HW address; &quot;</span>
					    <span class="enscript-string">&quot;keeping existing llreach record&quot;</span>;
				}
			}
		}

		<span class="enscript-keyword">if</span> (lr == NULL) {
			lr = ln-&gt;ln_llreach = ifnet_llreach_alloc(ifp,
			    ETHERTYPE_IPV6, addr, alen, nd6_llreach_base);
			<span class="enscript-keyword">if</span> (lr != NULL) {
				lr-&gt;lr_probes = 0;	<span class="enscript-comment">/* reset probe count */</span>
				<span class="enscript-keyword">if</span> (why == NULL)
					why = <span class="enscript-string">&quot;creating new llreach record&quot;</span>;
			}
		}

		<span class="enscript-keyword">if</span> (nd6_debug &amp;&amp; lr != NULL &amp;&amp; why != NULL) {
			<span class="enscript-type">char</span> tmp[MAX_IPv6_STR_LEN];

			nd6log((LOG_DEBUG, <span class="enscript-string">&quot;%s: %s%s for %s\n&quot;</span>, if_name(ifp),
			    type, why, inet_ntop(AF_INET6,
			    &amp;SIN6(rt_key(rt))-&gt;sin6_addr, tmp, <span class="enscript-keyword">sizeof</span> (tmp))));
		}
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_llreach_use</span>(<span class="enscript-type">struct</span> llinfo_nd6 *ln)
{
	<span class="enscript-keyword">if</span> (ln-&gt;ln_llreach != NULL)
		ln-&gt;ln_lastused = net_uptime();
}

<span class="enscript-comment">/*
 * Input a Neighbor Solicitation Message.
 *
 * Based on RFC 4861
 * Based on RFC 4862 (duplicate address detection)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_ns_input</span>(
	<span class="enscript-type">struct</span> mbuf *m,
	<span class="enscript-type">int</span> off,
	<span class="enscript-type">int</span> icmp6len)
{
	<span class="enscript-type">struct</span> ifnet *ifp = m-&gt;m_pkthdr.rcvif;
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	<span class="enscript-type">struct</span> nd_neighbor_solicit *nd_ns;
	<span class="enscript-type">struct</span> in6_addr saddr6 = ip6-&gt;ip6_src;
	<span class="enscript-type">struct</span> in6_addr daddr6 = ip6-&gt;ip6_dst;
	<span class="enscript-type">struct</span> in6_addr taddr6;
	<span class="enscript-type">struct</span> in6_addr myaddr6;
	<span class="enscript-type">char</span> *lladdr = NULL;
	<span class="enscript-type">struct</span> ifaddr *ifa = NULL;
	<span class="enscript-type">int</span> lladdrlen = 0;
	<span class="enscript-type">int</span> anycast = 0, proxy = 0, dadprogress = 0;
	<span class="enscript-type">int</span> tlladdr;
	<span class="enscript-type">union</span> nd_opts ndopts;
	<span class="enscript-type">struct</span> sockaddr_dl proxydl;
	boolean_t advrouter;
	boolean_t is_dad_probe;
	<span class="enscript-type">int</span> oflgclr = 0;

	<span class="enscript-keyword">if</span> ((ifp-&gt;if_eflags &amp; IFEF_IPV6_ND6ALT) != 0) {
		nd6log((LOG_INFO, <span class="enscript-string">&quot;nd6_ns_input: on ND6ALT interface!\n&quot;</span>));
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* Expect 32-bit aligned data pointer on strict-align platforms */</span>
	MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

	IP6_EXTHDR_CHECK(m, off, icmp6len, <span class="enscript-keyword">return</span>);
	nd_ns = (<span class="enscript-type">struct</span> nd_neighbor_solicit *)((caddr_t)ip6 + off);
	m-&gt;m_pkthdr.pkt_flags |= PKTF_INET6_RESOLVE;

	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *); <span class="enscript-comment">/* adjust pointer for safety */</span>
	taddr6 = nd_ns-&gt;nd_ns_target;
	<span class="enscript-keyword">if</span> (in6_setscope(&amp;taddr6, ifp, NULL) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (ip6-&gt;ip6_hlim != IPV6_MAXHLIM) {
		nd6log((LOG_ERR,
		    <span class="enscript-string">&quot;nd6_ns_input: invalid hlim (%d) from %s to %s on %s\n&quot;</span>,
		    ip6-&gt;ip6_hlim, ip6_sprintf(&amp;ip6-&gt;ip6_src),
		    ip6_sprintf(&amp;ip6-&gt;ip6_dst), if_name(ifp)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	is_dad_probe = IN6_IS_ADDR_UNSPECIFIED(&amp;saddr6);
	<span class="enscript-keyword">if</span> (is_dad_probe) {
		<span class="enscript-comment">/* dst has to be a solicited node multicast address. */</span>
		<span class="enscript-keyword">if</span> (daddr6.s6_addr16[0] == IPV6_ADDR_INT16_MLL &amp;&amp;
		    <span class="enscript-comment">/* don't check ifindex portion */</span>
		    daddr6.s6_addr32[1] == 0 &amp;&amp;
		    daddr6.s6_addr32[2] == IPV6_ADDR_INT32_ONE &amp;&amp;
		    daddr6.s6_addr8[12] == 0xff) {
			; <span class="enscript-comment">/* good */</span>
		} <span class="enscript-keyword">else</span> {
			nd6log((LOG_INFO, <span class="enscript-string">&quot;nd6_ns_input: bad DAD packet &quot;</span>
				<span class="enscript-string">&quot;(wrong ip6 dst)\n&quot;</span>));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!nd6_onlink_ns_rfc4861) {
		<span class="enscript-type">struct</span> sockaddr_in6 src_sa6;

		<span class="enscript-comment">/*
		 * According to recent IETF discussions, it is not a good idea
		 * to accept a NS from an address which would not be deemed
		 * to be a neighbor otherwise.  This point is expected to be
		 * clarified in future revisions of the specification.
		 */</span>
		bzero(&amp;src_sa6, <span class="enscript-keyword">sizeof</span>(src_sa6));
		src_sa6.sin6_family = AF_INET6;
		src_sa6.sin6_len = <span class="enscript-keyword">sizeof</span>(src_sa6);
		src_sa6.sin6_addr = saddr6;
		<span class="enscript-keyword">if</span> (!nd6_is_addr_neighbor(&amp;src_sa6, ifp, 0)) {
			nd6log((LOG_INFO, <span class="enscript-string">&quot;nd6_ns_input: &quot;</span>
				<span class="enscript-string">&quot;NS packet from non-neighbor\n&quot;</span>));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;taddr6)) {
		nd6log((LOG_INFO, <span class="enscript-string">&quot;nd6_ns_input: bad NS target (multicast)\n&quot;</span>));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	icmp6len -= <span class="enscript-keyword">sizeof</span>(*nd_ns);
	nd6_option_init(nd_ns + 1, icmp6len, &amp;ndopts);
	<span class="enscript-keyword">if</span> (nd6_options(&amp;ndopts) &lt; 0) {
		nd6log((LOG_INFO,
		    <span class="enscript-string">&quot;nd6_ns_input: invalid ND option, ignored\n&quot;</span>));
		<span class="enscript-comment">/* nd6_options have incremented stats */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}

	<span class="enscript-keyword">if</span> (ndopts.nd_opts_src_lladdr) {
		lladdr = (<span class="enscript-type">char</span> *)(ndopts.nd_opts_src_lladdr + 1);
		lladdrlen = ndopts.nd_opts_src_lladdr-&gt;nd_opt_len &lt;&lt; 3;
	}

	<span class="enscript-keyword">if</span> (is_dad_probe &amp;&amp; lladdr) {
		nd6log((LOG_INFO, <span class="enscript-string">&quot;nd6_ns_input: bad DAD packet &quot;</span>
		    <span class="enscript-string">&quot;(link-layer address option)\n&quot;</span>));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/*
	 * Attaching target link-layer address to the NA?
	 * (RFC 2461 7.2.4)
	 *
	 * NS IP dst is unicast/anycast			MUST NOT add
	 * NS IP dst is solicited-node multicast	MUST add
	 *
	 * In implementation, we add target link-layer address by default.
	 * We do not add one in MUST NOT cases.
	 */</span>
	<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_MULTICAST(&amp;daddr6))
		tlladdr = 0;
	<span class="enscript-keyword">else</span>
		tlladdr = 1;

	<span class="enscript-comment">/*
	 * Target address (taddr6) must be either:
	 * (1) Valid unicast/anycast address for my receiving interface,
	 * (2) Unicast address for which I'm offering proxy service, or
	 * (3) &quot;tentative&quot; or &quot;optimistic&quot; address [DAD is in progress].
	 */</span>
	<span class="enscript-comment">/* (1) and (3) check. */</span>
	ifa = (<span class="enscript-type">struct</span> ifaddr *)in6ifa_ifpwithaddr(ifp, &amp;taddr6);

	<span class="enscript-comment">/* (2) check. */</span>
	<span class="enscript-keyword">if</span> (ifa == NULL) {
		<span class="enscript-type">struct</span> rtentry *rt;
		<span class="enscript-type">struct</span> sockaddr_in6 tsin6;

		bzero(&amp;tsin6, <span class="enscript-keyword">sizeof</span> tsin6);
		tsin6.sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
		tsin6.sin6_family = AF_INET6;
		tsin6.sin6_addr = taddr6;

		rt = rtalloc1_scoped((<span class="enscript-type">struct</span> sockaddr *)&amp;tsin6, 0, 0,
		    ifp-&gt;if_index);

		<span class="enscript-keyword">if</span> (rt != NULL) {
			RT_LOCK(rt);
			<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; RTF_ANNOUNCE) != 0 &amp;&amp;
			    rt-&gt;rt_gateway-&gt;sa_family == AF_LINK) {
				<span class="enscript-comment">/*
				 * proxy NDP for single entry
				 */</span>
				ifa = (<span class="enscript-type">struct</span> ifaddr *)in6ifa_ifpforlinklocal(
				    ifp, IN6_IFF_NOTREADY|IN6_IFF_ANYCAST);
				<span class="enscript-keyword">if</span> (ifa) {
					proxy = 1;
					proxydl = *SDL(rt-&gt;rt_gateway);
				}
			}
			RT_UNLOCK(rt);
			rtfree(rt);
		}
	}
	<span class="enscript-keyword">if</span> (ifa == NULL &amp;&amp; ip6_forwarding &amp;&amp; nd6_prproxy) {
		<span class="enscript-comment">/*
		 * Is the target address part of the prefix that is being
		 * proxied and installed on another interface?
		 */</span>
		ifa = (<span class="enscript-type">struct</span> ifaddr *)in6ifa_prproxyaddr(&amp;taddr6);
	}
	<span class="enscript-keyword">if</span> (ifa == NULL) {
		<span class="enscript-comment">/*
		 * We've got an NS packet, and we don't have that address
		 * assigned for us.  We MUST silently ignore it on this
		 * interface, c.f. RFC 4861 7.2.3.
		 *
		 * Forwarding associated with NDPRF_PRPROXY may apply.
		 */</span>
		<span class="enscript-keyword">if</span> (ip6_forwarding &amp;&amp; nd6_prproxy)
			nd6_prproxy_ns_input(ifp, &amp;saddr6, lladdr,
			    lladdrlen, &amp;daddr6, &amp;taddr6);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}
	IFA_LOCK(ifa);
	myaddr6 = *IFA_IN6(ifa);
	anycast = ((<span class="enscript-type">struct</span> in6_ifaddr *)ifa)-&gt;ia6_flags &amp; IN6_IFF_ANYCAST;
	dadprogress =
	    ((<span class="enscript-type">struct</span> in6_ifaddr *)ifa)-&gt;ia6_flags &amp; IN6_IFF_DADPROGRESS;
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> in6_ifaddr *)ifa)-&gt;ia6_flags &amp; IN6_IFF_DUPLICATED) {
		IFA_UNLOCK(ifa);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}
	IFA_UNLOCK(ifa);

	<span class="enscript-keyword">if</span> (lladdr &amp;&amp; ((ifp-&gt;if_addrlen + 2 + 7) &amp; ~7) != lladdrlen) {
		nd6log((LOG_INFO,
		    <span class="enscript-string">&quot;nd6_ns_input: lladdrlen mismatch for %s &quot;</span>
		    <span class="enscript-string">&quot;(if %d, NS packet %d)\n&quot;</span>,
			ip6_sprintf(&amp;taddr6), ifp-&gt;if_addrlen, lladdrlen - 2));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(&amp;myaddr6, &amp;saddr6)) {
		nd6log((LOG_INFO,
			<span class="enscript-string">&quot;nd6_ns_input: duplicate IP6 address %s\n&quot;</span>,
			ip6_sprintf(&amp;saddr6)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}

	<span class="enscript-comment">/*
	 * We have neighbor solicitation packet, with target address equals to
	 * one of my DAD in-progress addresses.
	 *
	 * src addr	how to process?
	 * ---		---
	 * multicast	of course, invalid (rejected in ip6_input)
	 * unicast	somebody is doing address resolution
	 * unspec	dup address detection
	 *
	 * The processing is defined in the &quot;draft standard&quot; RFC 4862 (and by
	 * RFC 4429, which is a &quot;proposed standard&quot; update to its obsolete
	 * predecessor, RFC 2462)  The reason optimistic DAD is not included
	 * in RFC 4862 is entirely due to IETF procedural considerations.
	 */</span>
	<span class="enscript-keyword">if</span> (dadprogress) {
		<span class="enscript-comment">/*
		 * If source address is unspecified address, it is for
		 * duplicate address detection.
		 *
		 * If not, the packet is for addess resolution;
		 * silently ignore it when not optimistic
		 *
		 * Per RFC 4429 the reply for an optimistic address must
		 * have the Override flag cleared
		 */</span>
		<span class="enscript-keyword">if</span> (!is_dad_probe &amp;&amp; (dadprogress &amp; IN6_IFF_OPTIMISTIC) != 0) {
			oflgclr = 1;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (is_dad_probe)
				nd6_dad_ns_input(m, ifa, lladdr, lladdrlen);

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
		}
	}

	<span class="enscript-comment">/* Are we an advertising router on this interface? */</span>
	advrouter = (ifp-&gt;if_eflags &amp; IFEF_IPV6_ROUTER);

	<span class="enscript-comment">/*
	 * If the source address is unspecified address, entries must not
	 * be created or updated.
	 * It looks that sender is performing DAD.  If I'm using the address,
	 * and it's a &quot;preferred&quot; address, i.e. not optimistic, then output NA
	 * toward all-node multicast address, to tell the sender that I'm using
	 * the address.
	 * S bit (&quot;solicited&quot;) must be zero.
	 */</span>
	<span class="enscript-keyword">if</span> (is_dad_probe) {
		saddr6 = in6addr_linklocal_allnodes;
		<span class="enscript-keyword">if</span> (in6_setscope(&amp;saddr6, ifp, NULL) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		<span class="enscript-keyword">if</span> ((dadprogress &amp; IN6_IFF_OPTIMISTIC) == 0)
			nd6_na_output(ifp, &amp;saddr6, &amp;taddr6,
			    ((anycast || proxy || !tlladdr) ? 0 :
			    ND_NA_FLAG_OVERRIDE) | (advrouter ?
			    ND_NA_FLAG_ROUTER : 0), tlladdr, proxy ?
			    (<span class="enscript-type">struct</span> sockaddr *)&amp;proxydl : NULL);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}

	nd6_cache_lladdr(ifp, &amp;saddr6, lladdr, lladdrlen,
	    ND_NEIGHBOR_SOLICIT, 0);

	nd6_na_output(ifp, &amp;saddr6, &amp;taddr6,
	    ((anycast || proxy || !tlladdr || oflgclr) ? 0 : ND_NA_FLAG_OVERRIDE) |
	    (advrouter ? ND_NA_FLAG_ROUTER : 0) | ND_NA_FLAG_SOLICITED,
	    tlladdr, proxy ? (<span class="enscript-type">struct</span> sockaddr *)&amp;proxydl : NULL);
 <span class="enscript-reference">freeit</span>:
	m_freem(m);
	<span class="enscript-keyword">if</span> (ifa != NULL)
		IFA_REMREF(ifa);
	<span class="enscript-keyword">return</span>;

 <span class="enscript-reference">bad</span>:
	nd6log((LOG_ERR, <span class="enscript-string">&quot;nd6_ns_input: src=%s\n&quot;</span>, ip6_sprintf(&amp;saddr6)));
	nd6log((LOG_ERR, <span class="enscript-string">&quot;nd6_ns_input: dst=%s\n&quot;</span>, ip6_sprintf(&amp;daddr6)));
	nd6log((LOG_ERR, <span class="enscript-string">&quot;nd6_ns_input: tgt=%s\n&quot;</span>, ip6_sprintf(&amp;taddr6)));
	icmp6stat.icp6s_badns++;
	m_freem(m);
	<span class="enscript-keyword">if</span> (ifa != NULL)
		IFA_REMREF(ifa);
}

<span class="enscript-comment">/*
 * Output a Neighbor Solicitation Message. Caller specifies:
 *	- ICMP6 header source IP6 address
 *	- ND6 header target IP6 address
 *	- ND6 header source datalink address
 *
 * Based on RFC 4861
 * Based on RFC 4862 (duplicate address detection)
 * Based on RFC 4429 (optimistic duplicate address detection)
 *
 * Caller must bump up ln-&gt;ln_rt refcnt to make sure 'ln' doesn't go
 * away if there is a llinfo_nd6 passed in.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_ns_output</span>(
	<span class="enscript-type">struct</span> ifnet *ifp,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr *daddr6,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr *taddr6,
	<span class="enscript-type">struct</span> llinfo_nd6 *ln,	<span class="enscript-comment">/* for source address determination */</span>
	<span class="enscript-type">int</span> dad)	<span class="enscript-comment">/* duplicated address detection */</span>
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">struct</span> nd_neighbor_solicit *nd_ns;
	<span class="enscript-type">struct</span> in6_ifaddr *ia = NULL;
	<span class="enscript-type">struct</span> in6_addr *src, src_in, src_storage;
	<span class="enscript-type">struct</span> ip6_moptions *im6o = NULL;
        <span class="enscript-type">struct</span> ifnet *outif = NULL;
	<span class="enscript-type">int</span> icmp6len;
	<span class="enscript-type">int</span> maxlen;
	<span class="enscript-type">int</span> flags;
	caddr_t mac;
	<span class="enscript-type">struct</span> route_in6 ro;
	<span class="enscript-type">struct</span> ip6_out_args ip6oa = { IFSCOPE_NONE, { 0 },
	    IP6OAF_SELECT_SRCIF | IP6OAF_BOUND_SRCADDR, 0 };
	u_int32_t rtflags = 0;

	<span class="enscript-keyword">if</span> ((ifp-&gt;if_eflags &amp; IFEF_IPV6_ND6ALT) || IN6_IS_ADDR_MULTICAST(taddr6))
		<span class="enscript-keyword">return</span>;

	bzero(&amp;ro, <span class="enscript-keyword">sizeof</span>(ro));

	ip6oa.ip6oa_boundif = ifp-&gt;if_index;
	ip6oa.ip6oa_flags |= IP6OAF_BOUND_IF;

	<span class="enscript-comment">/* estimate the size of message */</span>
	maxlen = <span class="enscript-keyword">sizeof</span>(*ip6) + <span class="enscript-keyword">sizeof</span>(*nd_ns);
	maxlen += (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nd_opt_hdr) + ifp-&gt;if_addrlen + 7) &amp; ~7;
	<span class="enscript-keyword">if</span> (max_linkhdr + maxlen &gt;= MCLBYTES) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		printf(<span class="enscript-string">&quot;nd6_ns_output: max_linkhdr + maxlen &gt;= MCLBYTES &quot;</span>
		    <span class="enscript-string">&quot;(%d + %d &gt; %d)\n&quot;</span>, max_linkhdr, maxlen, MCLBYTES);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span>;
	}

	MGETHDR(m, M_DONTWAIT, MT_DATA);	<span class="enscript-comment">/* XXXMAC: mac_create_mbuf_linklayer() probably */</span>
	<span class="enscript-keyword">if</span> (m &amp;&amp; max_linkhdr + maxlen &gt;= MHLEN) {
		MCLGET(m, M_DONTWAIT);
		<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_EXT) == 0) {
			m_free(m);
			m = NULL;
		}
	}
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span>;
	m-&gt;m_pkthdr.rcvif = NULL;

	<span class="enscript-keyword">if</span> (daddr6 == NULL || IN6_IS_ADDR_MULTICAST(daddr6)) {
		m-&gt;m_flags |= M_MCAST;

		im6o = ip6_allocmoptions(M_DONTWAIT);
		<span class="enscript-keyword">if</span> (im6o == NULL) {
			m_freem(m);
			<span class="enscript-keyword">return</span>;
		}

		im6o-&gt;im6o_multicast_ifp = ifp;
		im6o-&gt;im6o_multicast_hlim = IPV6_MAXHLIM;
		im6o-&gt;im6o_multicast_loop = 0;
	}

	icmp6len = <span class="enscript-keyword">sizeof</span>(*nd_ns);
	m-&gt;m_pkthdr.len = m-&gt;m_len = <span class="enscript-keyword">sizeof</span>(*ip6) + icmp6len;
	m-&gt;m_data += max_linkhdr;	<span class="enscript-comment">/* or MH_ALIGN() equivalent? */</span>

	<span class="enscript-comment">/* fill neighbor solicitation packet */</span>
	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	ip6-&gt;ip6_flow = 0;
	ip6-&gt;ip6_vfc &amp;= ~IPV6_VERSION_MASK;
	ip6-&gt;ip6_vfc |= IPV6_VERSION;
	<span class="enscript-comment">/* ip6-&gt;ip6_plen will be set later */</span>
	ip6-&gt;ip6_nxt = IPPROTO_ICMPV6;
	ip6-&gt;ip6_hlim = IPV6_MAXHLIM;
	<span class="enscript-keyword">if</span> (daddr6)
		ip6-&gt;ip6_dst = *daddr6;
	<span class="enscript-keyword">else</span> {
		ip6-&gt;ip6_dst.s6_addr16[0] = IPV6_ADDR_INT16_MLL;
		ip6-&gt;ip6_dst.s6_addr16[1] = 0;
		ip6-&gt;ip6_dst.s6_addr32[1] = 0;
		ip6-&gt;ip6_dst.s6_addr32[2] = IPV6_ADDR_INT32_ONE;
		ip6-&gt;ip6_dst.s6_addr32[3] = taddr6-&gt;s6_addr32[3];
		ip6-&gt;ip6_dst.s6_addr8[12] = 0xff;
		<span class="enscript-keyword">if</span> (in6_setscope(&amp;ip6-&gt;ip6_dst, ifp, NULL) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	<span class="enscript-keyword">if</span> (!dad) {
		<span class="enscript-comment">/*
		 * RFC2461 7.2.2:
		 * &quot;If the source address of the packet prompting the
		 * solicitation is the same as one of the addresses assigned
		 * to the outgoing interface, that address SHOULD be placed
		 * in the IP Source Address of the outgoing solicitation.
		 * Otherwise, any one of the addresses assigned to the
		 * interface should be used.&quot;
		 *
		 * We use the source address for the prompting packet
		 * (saddr6), if:
		 * - saddr6 is given from the caller (by giving &quot;ln&quot;), and
		 * - saddr6 belongs to the outgoing interface.
		 * Otherwise, we perform the source address selection as usual.
		 */</span>
		<span class="enscript-type">struct</span> ip6_hdr *hip6;		<span class="enscript-comment">/* hold ip6 */</span>
		<span class="enscript-type">struct</span> in6_addr *hsrc = NULL;

		<span class="enscript-comment">/* Caller holds ref on this route */</span>
		<span class="enscript-keyword">if</span> (ln != NULL) {
			RT_LOCK(ln-&gt;ln_rt);
			<span class="enscript-comment">/*
			 * assuming every packet in ln_hold has the same IP
			 * header
			 */</span>
			<span class="enscript-keyword">if</span> (ln-&gt;ln_hold != NULL) {
				hip6 = mtod(ln-&gt;ln_hold, <span class="enscript-type">struct</span> ip6_hdr *);
				<span class="enscript-comment">/* XXX pullup? */</span>
				<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span> (*hip6) &lt; ln-&gt;ln_hold-&gt;m_len)
					hsrc = &amp;hip6-&gt;ip6_src;
				<span class="enscript-keyword">else</span>
					hsrc = NULL;
			}
			<span class="enscript-comment">/* Update probe count, if applicable */</span>
			<span class="enscript-keyword">if</span> (ln-&gt;ln_llreach != NULL) {
				IFLR_LOCK_SPIN(ln-&gt;ln_llreach);
				ln-&gt;ln_llreach-&gt;lr_probes++;
				IFLR_UNLOCK(ln-&gt;ln_llreach);
			}
			rtflags = ln-&gt;ln_rt-&gt;rt_flags;
			RT_UNLOCK(ln-&gt;ln_rt);
		}
		<span class="enscript-keyword">if</span> (hsrc != NULL &amp;&amp; (ia = in6ifa_ifpwithaddr(ifp, hsrc)) &amp;&amp;
		    (ia-&gt;ia6_flags &amp; IN6_IFF_OPTIMISTIC) == 0) {
			src = hsrc;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">int</span> error;
			<span class="enscript-type">struct</span> sockaddr_in6 dst_sa;

			bzero(&amp;dst_sa, <span class="enscript-keyword">sizeof</span>(dst_sa));
			dst_sa.sin6_family = AF_INET6;
			dst_sa.sin6_len = <span class="enscript-keyword">sizeof</span>(dst_sa);
			dst_sa.sin6_addr = ip6-&gt;ip6_dst;

			src = in6_selectsrc(&amp;dst_sa, NULL,
			    NULL, &amp;ro, NULL, &amp;src_storage, ip6oa.ip6oa_boundif,
			    &amp;error);
			<span class="enscript-keyword">if</span> (src == NULL) {
				nd6log((LOG_DEBUG,
				    <span class="enscript-string">&quot;nd6_ns_output: source can't be &quot;</span>
				    <span class="enscript-string">&quot;determined: dst=%s, error=%d\n&quot;</span>,
				    ip6_sprintf(&amp;dst_sa.sin6_addr),
				    error));
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}

			<span class="enscript-keyword">if</span> (ia != NULL) {
				IFA_REMREF(&amp;ia-&gt;ia_ifa);
				ia = NULL;
			}
			<span class="enscript-comment">/*
			 * RFC 4429 section 3.2:
			 * When a node has a unicast packet to send
			 * from an Optimistic Address to a neighbor, 
			 * but does not know the neighbor's link-layer 
			 * address, it MUST NOT perform Address
			 * Resolution.
			 */</span>
			ia = in6ifa_ifpwithaddr(ifp, src);
			<span class="enscript-keyword">if</span> (!ia || (ia-&gt;ia6_flags &amp; IN6_IFF_OPTIMISTIC)) {
				nd6log((LOG_DEBUG,
				    <span class="enscript-string">&quot;nd6_ns_output: no preferred source &quot;</span>
				    <span class="enscript-string">&quot;available: dst=%s\n&quot;</span>,
				    ip6_sprintf(&amp;dst_sa.sin6_addr)));
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Source address for DAD packet must always be IPv6
		 * unspecified address. (0::0)
		 * We actually don't have to 0-clear the address (we did it
		 * above), but we do so here explicitly to make the intention
		 * clearer.
		 */</span>
		bzero(&amp;src_in, <span class="enscript-keyword">sizeof</span>(src_in));
		src = &amp;src_in;
		ip6oa.ip6oa_flags &amp;= ~IP6OAF_BOUND_SRCADDR;
	}
	ip6-&gt;ip6_src = *src;
	nd_ns = (<span class="enscript-type">struct</span> nd_neighbor_solicit *)(ip6 + 1);
	nd_ns-&gt;nd_ns_type = ND_NEIGHBOR_SOLICIT;
	nd_ns-&gt;nd_ns_code = 0;
	nd_ns-&gt;nd_ns_reserved = 0;
	nd_ns-&gt;nd_ns_target = *taddr6;
	in6_clearscope(&amp;nd_ns-&gt;nd_ns_target); <span class="enscript-comment">/* XXX */</span>

	<span class="enscript-comment">/*
	 * Add source link-layer address option.
	 *
	 *				spec		implementation
	 *				---		---
	 * DAD packet			MUST NOT	do not add the option
	 * there's no link layer address:
	 *				impossible	do not add the option
	 * there's link layer address:
	 *	Multicast NS		MUST add one	add the option
	 *	Unicast NS		SHOULD add one	add the option
	 */</span>
	<span class="enscript-keyword">if</span> (!dad &amp;&amp; (mac = nd6_ifptomac(ifp))) {
		<span class="enscript-type">int</span> optlen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nd_opt_hdr) + ifp-&gt;if_addrlen;
		<span class="enscript-type">struct</span> nd_opt_hdr *nd_opt = (<span class="enscript-type">struct</span> nd_opt_hdr *)(nd_ns + 1);
		<span class="enscript-comment">/* 8 byte alignments... */</span>
		optlen = (optlen + 7) &amp; ~7;

		m-&gt;m_pkthdr.len += optlen;
		m-&gt;m_len += optlen;
		icmp6len += optlen;
		bzero((caddr_t)nd_opt, optlen);
		nd_opt-&gt;nd_opt_type = ND_OPT_SOURCE_LINKADDR;
		nd_opt-&gt;nd_opt_len = optlen &gt;&gt; 3;
		bcopy(mac, (caddr_t)(nd_opt + 1), ifp-&gt;if_addrlen);
	}

	ip6-&gt;ip6_plen = htons((u_short)icmp6len);
	nd_ns-&gt;nd_ns_cksum = 0;
	nd_ns-&gt;nd_ns_cksum
		= in6_cksum(m, IPPROTO_ICMPV6, <span class="enscript-keyword">sizeof</span>(*ip6), icmp6len);

	flags = dad ? IPV6_UNSPECSRC : 0;
	flags |= IPV6_OUTARGS;

	<span class="enscript-comment">/*
	 * PKTF_{INET,INET6}_RESOLVE_RTR are mutually exclusive, so make
	 * sure only one of them is set (just in case.)
	 */</span>
	m-&gt;m_pkthdr.pkt_flags &amp;= ~(PKTF_INET_RESOLVE | PKTF_RESOLVE_RTR);
	m-&gt;m_pkthdr.pkt_flags |= PKTF_INET6_RESOLVE;
	<span class="enscript-comment">/*
	 * If this is a NS for resolving the (default) router, mark
	 * the packet accordingly so that the driver can find out,
	 * in case it needs to perform driver-specific action(s).
	 */</span>
	<span class="enscript-keyword">if</span> (rtflags &amp; RTF_ROUTER)
		m-&gt;m_pkthdr.pkt_flags |= PKTF_RESOLVE_RTR;

	<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_TXSTART) {
		<span class="enscript-comment">/*
		 * Use control service class if the interface
		 * supports transmit-start model
		 */</span>
		(<span class="enscript-type">void</span>) m_set_service_class(m, MBUF_SC_CTL);
	}

	ip6_output(m, NULL, NULL, flags, im6o, &amp;outif, &amp;ip6oa);
	<span class="enscript-keyword">if</span> (outif) {
		icmp6_ifstat_inc(outif, ifs6_out_msg);
		icmp6_ifstat_inc(outif, ifs6_out_neighborsolicit);
		ifnet_release(outif);
	}
	icmp6stat.icp6s_outhist[ND_NEIGHBOR_SOLICIT]++;

<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">if</span> (im6o != NULL)
		IM6O_REMREF(im6o);

	ROUTE_RELEASE(&amp;ro);	<span class="enscript-comment">/* we don't cache this route. */</span>

	<span class="enscript-keyword">if</span> (ia != NULL)
		IFA_REMREF(&amp;ia-&gt;ia_ifa);
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">bad</span>:
	m_freem(m);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
}

<span class="enscript-comment">/*
 * Neighbor advertisement input handling.
 *
 * Based on RFC 4861
 * Based on RFC 4862 (duplicate address detection)
 *
 * the following items are not implemented yet:
 * - anycast advertisement delay rule (RFC 4861 7.2.7, SHOULD)
 * - proxy advertisement delay rule (RFC 4861 7.2.8, last paragraph, &quot;should&quot;)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_na_input</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, <span class="enscript-type">int</span> icmp6len)
{
	<span class="enscript-type">struct</span> ifnet *ifp = m-&gt;m_pkthdr.rcvif;
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	<span class="enscript-type">struct</span> nd_neighbor_advert *nd_na;
	<span class="enscript-type">struct</span> in6_addr saddr6 = ip6-&gt;ip6_src;
	<span class="enscript-type">struct</span> in6_addr daddr6 = ip6-&gt;ip6_dst;
	<span class="enscript-type">struct</span> in6_addr taddr6;
	<span class="enscript-type">int</span> flags;
	<span class="enscript-type">int</span> is_router;
	<span class="enscript-type">int</span> is_solicited;
	<span class="enscript-type">int</span> is_override;
	<span class="enscript-type">char</span> *lladdr = NULL;
	<span class="enscript-type">int</span> lladdrlen = 0;
	<span class="enscript-type">struct</span> llinfo_nd6 *ln;
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">struct</span> sockaddr_dl *sdl;
	<span class="enscript-type">union</span> nd_opts ndopts;
	uint64_t timenow;
	bool send_nc_alive_kev = false;

	<span class="enscript-keyword">if</span> ((ifp-&gt;if_eflags &amp; IFEF_IPV6_ND6ALT) != 0) {
		nd6log((LOG_INFO, <span class="enscript-string">&quot;nd6_na_input: on ND6ALT interface!\n&quot;</span>));
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* Expect 32-bit aligned data pointer on strict-align platforms */</span>
	MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

	<span class="enscript-keyword">if</span> (ip6-&gt;ip6_hlim != IPV6_MAXHLIM) {
		nd6log((LOG_ERR,
		    <span class="enscript-string">&quot;nd6_na_input: invalid hlim (%d) from %s to %s on %s\n&quot;</span>,
		    ip6-&gt;ip6_hlim, ip6_sprintf(&amp;ip6-&gt;ip6_src),
		    ip6_sprintf(&amp;ip6-&gt;ip6_dst), if_name(ifp)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	IP6_EXTHDR_CHECK(m, off, icmp6len, <span class="enscript-keyword">return</span>);
	nd_na = (<span class="enscript-type">struct</span> nd_neighbor_advert *)((caddr_t)ip6 + off);
	m-&gt;m_pkthdr.pkt_flags |= PKTF_INET6_RESOLVE;

	flags = nd_na-&gt;nd_na_flags_reserved;
	is_router = ((flags &amp; ND_NA_FLAG_ROUTER) != 0);
	is_solicited = ((flags &amp; ND_NA_FLAG_SOLICITED) != 0);
	is_override = ((flags &amp; ND_NA_FLAG_OVERRIDE) != 0);

	taddr6 = nd_na-&gt;nd_na_target;
	<span class="enscript-keyword">if</span> (in6_setscope(&amp;taddr6, ifp, NULL))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;	<span class="enscript-comment">/* XXX: impossible */</span>

	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;taddr6)) {
		nd6log((LOG_ERR,
		    <span class="enscript-string">&quot;nd6_na_input: invalid target address %s\n&quot;</span>,
		    ip6_sprintf(&amp;taddr6)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;daddr6))
		<span class="enscript-keyword">if</span> (is_solicited) {
			nd6log((LOG_ERR,
			    <span class="enscript-string">&quot;nd6_na_input: a solicited adv is multicasted\n&quot;</span>));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

	icmp6len -= <span class="enscript-keyword">sizeof</span>(*nd_na);
	nd6_option_init(nd_na + 1, icmp6len, &amp;ndopts);
	<span class="enscript-keyword">if</span> (nd6_options(&amp;ndopts) &lt; 0) {
		nd6log((LOG_INFO,
		    <span class="enscript-string">&quot;nd6_na_input: invalid ND option, ignored\n&quot;</span>));
		<span class="enscript-comment">/* nd6_options have incremented stats */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}

	<span class="enscript-keyword">if</span> (ndopts.nd_opts_tgt_lladdr) {
		lladdr = (<span class="enscript-type">char</span> *)(ndopts.nd_opts_tgt_lladdr + 1);
		lladdrlen = ndopts.nd_opts_tgt_lladdr-&gt;nd_opt_len &lt;&lt; 3;

		<span class="enscript-keyword">if</span> (((ifp-&gt;if_addrlen + 2 + 7) &amp; ~7) != lladdrlen) {
			nd6log((LOG_INFO,
			    <span class="enscript-string">&quot;nd6_na_input: lladdrlen mismatch for %s &quot;</span>
			    <span class="enscript-string">&quot;(if %d, NA packet %d)\n&quot;</span>,
				ip6_sprintf(&amp;taddr6), ifp-&gt;if_addrlen,
				    lladdrlen - 2));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

	m = nd6_dad_na_input(m, ifp, &amp;taddr6, lladdr, lladdrlen);
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* Forwarding associated with NDPRF_PRPROXY may apply. */</span>
	<span class="enscript-keyword">if</span> (ip6_forwarding &amp;&amp; nd6_prproxy)
		nd6_prproxy_na_input(ifp, &amp;saddr6, &amp;daddr6, &amp;taddr6, flags);

	<span class="enscript-comment">/*
	 * If no neighbor cache entry is found, NA SHOULD silently be
	 * discarded.  If we are forwarding (and Scoped Routing is in
	 * effect), try to see if there is a neighbor cache entry on
	 * another interface (in case we are doing prefix proxying.)
	 */</span>
	<span class="enscript-keyword">if</span> ((rt = nd6_lookup(&amp;taddr6, 0, ifp, 0)) == NULL) {
		<span class="enscript-keyword">if</span> (!ip6_forwarding || !ip6_doscopedroute || !nd6_prproxy)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;

		<span class="enscript-keyword">if</span> ((rt = nd6_lookup(&amp;taddr6, 0, NULL, 0)) == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;

		RT_LOCK_ASSERT_HELD(rt);
		<span class="enscript-keyword">if</span> (rt-&gt;rt_ifp != ifp) {
			<span class="enscript-comment">/*
			 * Purge any link-layer info caching.
			 */</span>
			<span class="enscript-keyword">if</span> (rt-&gt;rt_llinfo_purge != NULL)
				rt-&gt;rt_llinfo_purge(rt);

			<span class="enscript-comment">/* Adjust route ref count for the interfaces */</span>
			<span class="enscript-keyword">if</span> (rt-&gt;rt_if_ref_fn != NULL) {
				rt-&gt;rt_if_ref_fn(ifp, 1);
				rt-&gt;rt_if_ref_fn(rt-&gt;rt_ifp, -1);
			}

			<span class="enscript-comment">/* Change the interface when the existing route is on */</span>
			rt-&gt;rt_ifp = ifp;

			<span class="enscript-comment">/*
			 * If rmx_mtu is not locked, update it
			 * to the MTU used by the new interface.
			 */</span>
			<span class="enscript-keyword">if</span> (!(rt-&gt;rt_rmx.rmx_locks &amp; RTV_MTU))
				rt-&gt;rt_rmx.rmx_mtu = rt-&gt;rt_ifp-&gt;if_mtu;
		}
	}

	RT_LOCK_ASSERT_HELD(rt);
	<span class="enscript-keyword">if</span> ((ln = rt-&gt;rt_llinfo) == NULL ||
	    (sdl = SDL(rt-&gt;rt_gateway)) == NULL) {
		RT_REMREF_LOCKED(rt);
		RT_UNLOCK(rt);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}

	timenow = net_uptime();

	<span class="enscript-keyword">if</span> (ln-&gt;ln_state == ND6_LLINFO_INCOMPLETE) {
		<span class="enscript-comment">/*
		 * If the link-layer has address, and no lladdr option came,
		 * discard the packet.
		 */</span>
		<span class="enscript-keyword">if</span> (ifp-&gt;if_addrlen &amp;&amp; !lladdr) {
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
		}

		<span class="enscript-comment">/*
		 * Record link-layer address, and update the state.
		 */</span>
		sdl-&gt;sdl_alen = ifp-&gt;if_addrlen;
		bcopy(lladdr, LLADDR(sdl), ifp-&gt;if_addrlen);
		<span class="enscript-keyword">if</span> (is_solicited) {
			send_nc_alive_kev = (rt-&gt;rt_flags &amp; RTF_ROUTER) ? true : false;
			ln-&gt;ln_state = ND6_LLINFO_REACHABLE;
			<span class="enscript-keyword">if</span> (ln-&gt;ln_expire != 0) {
				<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;

				ndi = ND_IFINFO(rt-&gt;rt_ifp);
				VERIFY(ndi != NULL &amp;&amp; ndi-&gt;initialized);
				lck_mtx_lock(&amp;ndi-&gt;lock);
				ln_setexpire(ln, timenow + ndi-&gt;reachable);
				lck_mtx_unlock(&amp;ndi-&gt;lock);
				RT_UNLOCK(rt);
				lck_mtx_lock(rnh_lock);
				nd6_sched_timeout(NULL, NULL);
				lck_mtx_unlock(rnh_lock);
				RT_LOCK(rt);
			}
		} <span class="enscript-keyword">else</span> {
			ln-&gt;ln_state = ND6_LLINFO_STALE;
			ln_setexpire(ln, timenow + nd6_gctimer);
		}
		<span class="enscript-keyword">if</span> ((ln-&gt;ln_router = is_router) != 0) {
			<span class="enscript-comment">/*
			 * This means a router's state has changed from
			 * non-reachable to probably reachable, and might
			 * affect the status of associated prefixes..
			 */</span>
			RT_UNLOCK(rt);
			lck_mtx_lock(nd6_mutex);
			pfxlist_onlink_check();
			lck_mtx_unlock(nd6_mutex);
			RT_LOCK(rt);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span> llchange;

		<span class="enscript-comment">/*
		 * Check if the link-layer address has changed or not.
		 */</span>
		<span class="enscript-keyword">if</span> (!lladdr)
			llchange = 0;
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (sdl-&gt;sdl_alen) {
				<span class="enscript-keyword">if</span> (bcmp(lladdr, LLADDR(sdl), ifp-&gt;if_addrlen))
					llchange = 1;
				<span class="enscript-keyword">else</span>
					llchange = 0;
			} <span class="enscript-keyword">else</span>
				llchange = 1;
		}

		<span class="enscript-comment">/*
		 * This is VERY complex.  Look at it with care.
		 *
		 * override solicit lladdr llchange	action
		 *					(L: record lladdr)
		 *
		 *	0	0	n	--	(2c)
		 *	0	0	y	n	(2b) L
		 *	0	0	y	y	(1)    REACHABLE-&gt;STALE
		 *	0	1	n	--	(2c)   *-&gt;REACHABLE
		 *	0	1	y	n	(2b) L *-&gt;REACHABLE
		 *	0	1	y	y	(1)    REACHABLE-&gt;STALE
		 *	1	0	n	--	(2a)
		 *	1	0	y	n	(2a) L
		 *	1	0	y	y	(2a) L *-&gt;STALE
		 *	1	1	n	--	(2a)   *-&gt;REACHABLE
		 *	1	1	y	n	(2a) L *-&gt;REACHABLE
		 *	1	1	y	y	(2a) L *-&gt;REACHABLE
		 */</span>
		<span class="enscript-keyword">if</span> (!is_override &amp;&amp; (lladdr != NULL &amp;&amp; llchange)) {  <span class="enscript-comment">/* (1) */</span>
			<span class="enscript-comment">/*
			 * If state is REACHABLE, make it STALE.
			 * no other updates should be done.
			 */</span>
			<span class="enscript-keyword">if</span> (ln-&gt;ln_state == ND6_LLINFO_REACHABLE) {
				ln-&gt;ln_state = ND6_LLINFO_STALE;
				ln_setexpire(ln, timenow + nd6_gctimer);
			}
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (is_override				   <span class="enscript-comment">/* (2a) */</span>
			|| (!is_override &amp;&amp; (lladdr &amp;&amp; !llchange)) <span class="enscript-comment">/* (2b) */</span>
			|| !lladdr) {				   <span class="enscript-comment">/* (2c) */</span>
			<span class="enscript-comment">/*
			 * Update link-local address, if any.
			 */</span>
			<span class="enscript-keyword">if</span> (lladdr) {
				sdl-&gt;sdl_alen = ifp-&gt;if_addrlen;
				bcopy(lladdr, LLADDR(sdl), ifp-&gt;if_addrlen);
			}

			<span class="enscript-comment">/*
			 * If solicited, make the state REACHABLE.
			 * If not solicited and the link-layer address was
			 * changed, make it STALE.
			 */</span>
			<span class="enscript-keyword">if</span> (is_solicited) {
				ln-&gt;ln_state = ND6_LLINFO_REACHABLE;
				<span class="enscript-keyword">if</span> (ln-&gt;ln_expire != 0) {
					<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;

					ndi = ND_IFINFO(ifp);
					VERIFY(ndi != NULL &amp;&amp; ndi-&gt;initialized);
					lck_mtx_lock(&amp;ndi-&gt;lock);
					ln_setexpire(ln,
					    timenow + ndi-&gt;reachable);
					lck_mtx_unlock(&amp;ndi-&gt;lock);
					RT_UNLOCK(rt);
					lck_mtx_lock(rnh_lock);
					nd6_sched_timeout(NULL, NULL);
					lck_mtx_unlock(rnh_lock);
					RT_LOCK(rt);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (lladdr &amp;&amp; llchange) {
					ln-&gt;ln_state = ND6_LLINFO_STALE;
					ln_setexpire(ln, timenow + nd6_gctimer);
				}
			}
		}

		<span class="enscript-keyword">if</span> (ln-&gt;ln_router &amp;&amp; !is_router) {
			<span class="enscript-comment">/*
			 * The peer dropped the router flag.
			 * Remove the sender from the Default Router List and
			 * update the Destination Cache entries.
			 */</span>
			<span class="enscript-type">struct</span> nd_defrouter *dr;
			<span class="enscript-type">struct</span> in6_addr *in6;
			<span class="enscript-type">struct</span> ifnet *rt_ifp = rt-&gt;rt_ifp;

			in6 = &amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)
			    (<span class="enscript-type">void</span> *)rt_key(rt))-&gt;sin6_addr;

			RT_UNLOCK(rt);
			lck_mtx_lock(nd6_mutex);
			dr = defrouter_lookup(in6, rt_ifp);
			<span class="enscript-keyword">if</span> (dr) {
				defrtrlist_del(dr);
				NDDR_REMREF(dr);
				lck_mtx_unlock(nd6_mutex);
			} <span class="enscript-keyword">else</span> {
				lck_mtx_unlock(nd6_mutex);
				<span class="enscript-keyword">if</span> (ip6_doscopedroute || !ip6_forwarding) {
					<span class="enscript-comment">/*
					 * Even if the neighbor is not in the
					 * default router list, the neighbor
					 * may be used as a next hop for some
					 * destinations (e.g. redirect case).
					 * So we must call rt6_flush explicitly.
					 */</span>
					rt6_flush(&amp;ip6-&gt;ip6_src, rt_ifp);
				}
			}
			RT_LOCK(rt);
		}
		ln-&gt;ln_router = is_router;
	}

	<span class="enscript-keyword">if</span> (send_nc_alive_kev &amp;&amp; (ifp-&gt;if_addrlen == IF_LLREACH_MAXLEN)) {
		<span class="enscript-type">struct</span> kev_msg ev_msg;
		<span class="enscript-type">struct</span> kev_nd6_ndalive nd6_ndalive;
		bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span>(ev_msg));
		bzero(&amp;nd6_ndalive, <span class="enscript-keyword">sizeof</span>(nd6_ndalive));
		ev_msg.vendor_code      = KEV_VENDOR_APPLE;
		ev_msg.kev_class        = KEV_NETWORK_CLASS;
		ev_msg.kev_subclass     = KEV_ND6_SUBCLASS;
		ev_msg.event_code       = KEV_ND6_NDALIVE;

		nd6_ndalive.link_data.if_family = ifp-&gt;if_family;
		nd6_ndalive.link_data.if_unit = ifp-&gt;if_unit;
		strlcpy(nd6_ndalive.link_data.if_name,
		    ifp-&gt;if_name,
		    <span class="enscript-keyword">sizeof</span>(nd6_ndalive.link_data.if_name));
		ev_msg.dv[0].data_ptr = &amp;nd6_ndalive;
		ev_msg.dv[0].data_length =
			<span class="enscript-keyword">sizeof</span>(nd6_ndalive);
		kev_post_msg(&amp;ev_msg);
	}

	RT_LOCK_ASSERT_HELD(rt);
	rt-&gt;rt_flags &amp;= ~RTF_REJECT;

	<span class="enscript-comment">/* cache the gateway (sender HW) address */</span>
	nd6_llreach_alloc(rt, ifp, LLADDR(sdl), sdl-&gt;sdl_alen, TRUE);

	<span class="enscript-comment">/* update the llinfo, send a queued packet if there is one */</span>
	ln-&gt;ln_asked = 0;
	<span class="enscript-keyword">if</span> (ln-&gt;ln_hold != NULL) {
		<span class="enscript-type">struct</span> mbuf *m_hold, *m_hold_next;
		<span class="enscript-type">struct</span> sockaddr_in6 sin6;

		rtkey_to_sa6(rt, &amp;sin6);
		<span class="enscript-comment">/*
		 * reset the ln_hold in advance, to explicitly
		 * prevent a ln_hold lookup in nd6_output()
		 * (wouldn't happen, though...)
		 */</span>
		m_hold = ln-&gt;ln_hold;
		ln-&gt;ln_hold = NULL;
		<span class="enscript-keyword">for</span> ( ; m_hold; m_hold = m_hold_next) {
			m_hold_next = m_hold-&gt;m_nextpkt;
			m_hold-&gt;m_nextpkt = NULL;
			<span class="enscript-comment">/*
			 * we assume ifp is not a loopback here, so just set
			 * the 2nd argument as the 1st one.
			 */</span>
			RT_UNLOCK(rt);
			nd6_output(ifp, ifp, m_hold, &amp;sin6, rt, NULL);
			RT_LOCK_SPIN(rt);
		}
	}
	RT_REMREF_LOCKED(rt);
	RT_UNLOCK(rt);

<span class="enscript-reference">bad</span>:
	icmp6stat.icp6s_badna++;
	<span class="enscript-comment">/* fall through */</span>

<span class="enscript-reference">freeit</span>:
	m_freem(m);
}

<span class="enscript-comment">/*
 * Neighbor advertisement output handling.
 *
 * Based on RFC 2461
 *
 * the following items are not implemented yet:
 * - proxy advertisement delay rule (RFC2461 7.2.8, last paragraph, SHOULD)
 * - anycast advertisement delay rule (RFC2461 7.2.7, SHOULD)
 *
 * tlladdr - 1 if include target link-layer address
 * sdl0 - sockaddr_dl (= proxy NA) or NULL
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_na_output</span>(
	<span class="enscript-type">struct</span> ifnet *ifp,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr *daddr6_0,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_addr *taddr6,
	uint32_t flags,
	<span class="enscript-type">int</span> tlladdr,		<span class="enscript-comment">/* 1 if include target link-layer address */</span>
	<span class="enscript-type">struct</span> sockaddr *sdl0)	<span class="enscript-comment">/* sockaddr_dl (= proxy NA) or NULL */</span>
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">struct</span> nd_neighbor_advert *nd_na;
	<span class="enscript-type">struct</span> ip6_moptions *im6o = NULL;
	caddr_t mac = NULL;
	<span class="enscript-type">struct</span> route_in6 ro;
	<span class="enscript-type">struct</span> in6_addr *src, src_storage, daddr6;
	<span class="enscript-type">struct</span> in6_ifaddr *ia;
	<span class="enscript-type">struct</span> sockaddr_in6 dst_sa;
	<span class="enscript-type">int</span> icmp6len, maxlen, error;
        <span class="enscript-type">struct</span> ifnet *outif = NULL;
	<span class="enscript-type">struct</span> ip6_out_args ip6oa = { IFSCOPE_NONE, { 0 },
	    IP6OAF_SELECT_SRCIF | IP6OAF_BOUND_SRCADDR, 0 };

	bzero(&amp;ro, <span class="enscript-keyword">sizeof</span>(ro));

	daddr6 = *daddr6_0;	<span class="enscript-comment">/* make a local copy for modification */</span>

	ip6oa.ip6oa_boundif = ifp-&gt;if_index;
	ip6oa.ip6oa_flags |= IP6OAF_BOUND_IF;

	<span class="enscript-comment">/* estimate the size of message */</span>
	maxlen = <span class="enscript-keyword">sizeof</span>(*ip6) + <span class="enscript-keyword">sizeof</span>(*nd_na);
	maxlen += (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nd_opt_hdr) + ifp-&gt;if_addrlen + 7) &amp; ~7;
	<span class="enscript-keyword">if</span> (max_linkhdr + maxlen &gt;= MCLBYTES) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		printf(<span class="enscript-string">&quot;nd6_na_output: max_linkhdr + maxlen &gt;= MCLBYTES &quot;</span>
		    <span class="enscript-string">&quot;(%d + %d &gt; %d)\n&quot;</span>, max_linkhdr, maxlen, MCLBYTES);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span>;
	}

	MGETHDR(m, M_DONTWAIT, MT_DATA);	<span class="enscript-comment">/* XXXMAC: mac_create_mbuf_linklayer() probably */</span>
	<span class="enscript-keyword">if</span> (m &amp;&amp; max_linkhdr + maxlen &gt;= MHLEN) {
		MCLGET(m, M_DONTWAIT);
		<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_EXT) == 0) {
			m_free(m);
			m = NULL;
		}
	}
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span>;
	m-&gt;m_pkthdr.rcvif = NULL;

	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;daddr6)) {
		m-&gt;m_flags |= M_MCAST;

		im6o = ip6_allocmoptions(M_DONTWAIT);
		<span class="enscript-keyword">if</span> (im6o == NULL) {
			m_freem(m);
			<span class="enscript-keyword">return</span>;
		}

		im6o-&gt;im6o_multicast_ifp = ifp;
		im6o-&gt;im6o_multicast_hlim = IPV6_MAXHLIM;
		im6o-&gt;im6o_multicast_loop = 0;
	}

	icmp6len = <span class="enscript-keyword">sizeof</span>(*nd_na);
	m-&gt;m_pkthdr.len = m-&gt;m_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) + icmp6len;
	m-&gt;m_data += max_linkhdr;	<span class="enscript-comment">/* or MH_ALIGN() equivalent? */</span>

	<span class="enscript-comment">/* fill neighbor advertisement packet */</span>
	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	ip6-&gt;ip6_flow = 0;
	ip6-&gt;ip6_vfc &amp;= ~IPV6_VERSION_MASK;
	ip6-&gt;ip6_vfc |= IPV6_VERSION;
	ip6-&gt;ip6_nxt = IPPROTO_ICMPV6;
	ip6-&gt;ip6_hlim = IPV6_MAXHLIM;
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;daddr6)) {
		<span class="enscript-comment">/* reply to DAD */</span>
		daddr6.s6_addr16[0] = IPV6_ADDR_INT16_MLL;
		daddr6.s6_addr16[1] = 0;
		daddr6.s6_addr32[1] = 0;
		daddr6.s6_addr32[2] = 0;
		daddr6.s6_addr32[3] = IPV6_ADDR_INT32_ONE;
		<span class="enscript-keyword">if</span> (in6_setscope(&amp;daddr6, ifp, NULL))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

		flags &amp;= ~ND_NA_FLAG_SOLICITED;
	} <span class="enscript-keyword">else</span>
		ip6-&gt;ip6_dst = daddr6;

	bzero(&amp;dst_sa, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6));
	dst_sa.sin6_family = AF_INET6;
	dst_sa.sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
	dst_sa.sin6_addr = daddr6;

	<span class="enscript-comment">/*
	 * Select a source whose scope is the same as that of the dest.
	 */</span>
	bcopy(&amp;dst_sa, &amp;ro.ro_dst, <span class="enscript-keyword">sizeof</span>(dst_sa));
	src = in6_selectsrc(&amp;dst_sa, NULL, NULL, &amp;ro, NULL, &amp;src_storage,
	    ip6oa.ip6oa_boundif, &amp;error);
	<span class="enscript-keyword">if</span> (src == NULL) {
		nd6log((LOG_DEBUG, <span class="enscript-string">&quot;nd6_na_output: source can't be &quot;</span>
		    <span class="enscript-string">&quot;determined: dst=%s, error=%d\n&quot;</span>,
		    ip6_sprintf(&amp;dst_sa.sin6_addr), error));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	ip6-&gt;ip6_src = *src;

	<span class="enscript-comment">/*
	 * RFC 4429 requires not setting &quot;override&quot; flag on NA packets sent
	 * from optimistic addresses.
	 */</span>
	ia = in6ifa_ifpwithaddr(ifp, src);
	<span class="enscript-keyword">if</span> (ia != NULL) {
		<span class="enscript-keyword">if</span> (ia-&gt;ia6_flags &amp; IN6_IFF_OPTIMISTIC)
			flags &amp;= ~ND_NA_FLAG_OVERRIDE;
		IFA_REMREF(&amp;ia-&gt;ia_ifa);
	}

	nd_na = (<span class="enscript-type">struct</span> nd_neighbor_advert *)(ip6 + 1);
	nd_na-&gt;nd_na_type = ND_NEIGHBOR_ADVERT;
	nd_na-&gt;nd_na_code = 0;
	nd_na-&gt;nd_na_target = *taddr6;
	in6_clearscope(&amp;nd_na-&gt;nd_na_target); <span class="enscript-comment">/* XXX */</span>

	<span class="enscript-comment">/*
	 * &quot;tlladdr&quot; indicates NS's condition for adding tlladdr or not.
	 * see nd6_ns_input() for details.
	 * Basically, if NS packet is sent to unicast/anycast addr,
	 * target lladdr option SHOULD NOT be included.
	 */</span>
	<span class="enscript-keyword">if</span> (tlladdr) {
		<span class="enscript-comment">/*
		 * sdl0 != NULL indicates proxy NA.  If we do proxy, use
		 * lladdr in sdl0.  If we are not proxying (sending NA for
		 * my address) use lladdr configured for the interface.
		 */</span>
		<span class="enscript-keyword">if</span> (sdl0 == NULL)
			mac = nd6_ifptomac(ifp);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sdl0-&gt;sa_family == AF_LINK) {
			<span class="enscript-type">struct</span> sockaddr_dl *sdl;
			sdl = (<span class="enscript-type">struct</span> sockaddr_dl *)(<span class="enscript-type">void</span> *)sdl0;
			<span class="enscript-keyword">if</span> (sdl-&gt;sdl_alen == ifp-&gt;if_addrlen)
				mac = LLADDR(sdl);
		}
	}
	<span class="enscript-keyword">if</span> (tlladdr &amp;&amp; mac) {
		<span class="enscript-type">int</span> optlen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nd_opt_hdr) + ifp-&gt;if_addrlen;
		<span class="enscript-type">struct</span> nd_opt_hdr *nd_opt = (<span class="enscript-type">struct</span> nd_opt_hdr *)(nd_na + 1);

		<span class="enscript-comment">/* roundup to 8 bytes alignment! */</span>
		optlen = (optlen + 7) &amp; ~7;

		m-&gt;m_pkthdr.len += optlen;
		m-&gt;m_len += optlen;
		icmp6len += optlen;
		bzero((caddr_t)nd_opt, optlen);
		nd_opt-&gt;nd_opt_type = ND_OPT_TARGET_LINKADDR;
		nd_opt-&gt;nd_opt_len = optlen &gt;&gt; 3;
		bcopy(mac, (caddr_t)(nd_opt + 1), ifp-&gt;if_addrlen);
	} <span class="enscript-keyword">else</span>
		flags &amp;= ~ND_NA_FLAG_OVERRIDE;

	ip6-&gt;ip6_plen = htons((u_short)icmp6len);
	nd_na-&gt;nd_na_flags_reserved = flags;
	nd_na-&gt;nd_na_cksum = 0;
	nd_na-&gt;nd_na_cksum =
		in6_cksum(m, IPPROTO_ICMPV6, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr), icmp6len);

	m-&gt;m_pkthdr.pkt_flags |= PKTF_INET6_RESOLVE;

	<span class="enscript-keyword">if</span> (ifp-&gt;if_eflags &amp; IFEF_TXSTART) {
		<span class="enscript-comment">/* Use control service class if the interface supports
		 * transmit-start model.
		 */</span>
		(<span class="enscript-type">void</span>) m_set_service_class(m, MBUF_SC_CTL);
	}

	ip6_output(m, NULL, NULL, IPV6_OUTARGS, im6o, &amp;outif, &amp;ip6oa);
	<span class="enscript-keyword">if</span> (outif) {
		icmp6_ifstat_inc(outif, ifs6_out_msg);
		icmp6_ifstat_inc(outif, ifs6_out_neighboradvert);
		ifnet_release(outif);
	}
	icmp6stat.icp6s_outhist[ND_NEIGHBOR_ADVERT]++;

<span class="enscript-reference">exit</span>:
	<span class="enscript-keyword">if</span> (im6o != NULL)
		IM6O_REMREF(im6o);

	ROUTE_RELEASE(&amp;ro);
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">bad</span>:
	m_freem(m);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
}

caddr_t
<span class="enscript-function-name">nd6_ifptomac</span>(
	<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-keyword">switch</span> (ifp-&gt;if_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ARCNET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ETHER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE8023ADLAG</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_FDDI</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE1394</span>:
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IFT_L2VLAN</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_L2VLAN</span>:
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IFT_IEEE80211</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE80211</span>:
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IFT_CARP</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_CARP</span>:
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_BRIDGE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ISO88025</span>:
		<span class="enscript-keyword">return</span> ((caddr_t)IF_LLADDR(ifp));
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> NULL;
	}
}

<span class="enscript-function-name">TAILQ_HEAD</span>(dadq_head, dadq);
<span class="enscript-type">struct</span> dadq {
	decl_lck_mtx_data(, dad_lock);
	u_int32_t dad_refcount;	<span class="enscript-comment">/* reference count */</span>
	<span class="enscript-type">int</span> dad_attached;
	TAILQ_ENTRY(dadq) dad_list;
	<span class="enscript-type">struct</span> ifaddr *dad_ifa;
	<span class="enscript-type">int</span> dad_count;		<span class="enscript-comment">/* max NS to send */</span>
	<span class="enscript-type">int</span> dad_ns_tcount;	<span class="enscript-comment">/* # of trials to send NS */</span>
	<span class="enscript-type">int</span> dad_ns_ocount;	<span class="enscript-comment">/* NS sent so far */</span>
	<span class="enscript-type">int</span> dad_ns_icount;
	<span class="enscript-type">int</span> dad_na_icount;
	<span class="enscript-type">int</span> dad_nd_ixcount;	<span class="enscript-comment">/* Count of IFDISABLED eligible ND rx'd */</span>
	uint8_t dad_ehsrc[ETHER_ADDR_LEN];
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> dadq_head dadq;

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_nbr_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i;
	
	TAILQ_INIT(&amp;dadq);

	dad_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> dadq);
	dad_zone = zinit(dad_size, DAD_ZONE_MAX * dad_size, 0, DAD_ZONE_NAME);
	<span class="enscript-keyword">if</span> (dad_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__, DAD_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(dad_zone, Z_EXPAND, TRUE);
	zone_change(dad_zone, Z_CALLERACCT, FALSE);

	bzero(&amp;hostrtmask, <span class="enscript-keyword">sizeof</span> hostrtmask);
	hostrtmask.sin6_family = AF_INET6;
	hostrtmask.sin6_len = <span class="enscript-keyword">sizeof</span> hostrtmask;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; <span class="enscript-keyword">sizeof</span> hostrtmask.sin6_addr; ++i)
		hostrtmask.sin6_addr.s6_addr[i] = 0xff;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> dadq *
<span class="enscript-function-name">nd6_dad_find</span>(<span class="enscript-type">struct</span> ifaddr *ifa)
{
	<span class="enscript-type">struct</span> dadq *dp;

	lck_mtx_lock(dad6_mutex);
	<span class="enscript-keyword">for</span> (dp = dadq.tqh_first; dp; dp = dp-&gt;dad_list.tqe_next) {
		DAD_LOCK_SPIN(dp);
		<span class="enscript-keyword">if</span> (dp-&gt;dad_ifa == ifa) {
			DAD_ADDREF_LOCKED(dp);
			DAD_UNLOCK(dp);
			lck_mtx_unlock(dad6_mutex);
			<span class="enscript-keyword">return</span> (dp);
		}
		DAD_UNLOCK(dp);
	}
	lck_mtx_unlock(dad6_mutex);
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_dad_stoptimer</span>(
	<span class="enscript-type">struct</span> ifaddr *ifa)
{

	untimeout((<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *))nd6_dad_timer, (<span class="enscript-type">void</span> *)ifa);
}

<span class="enscript-comment">/*
 * Start Duplicate Address Detection (DAD) for specified interface address.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_dad_start</span>(
	<span class="enscript-type">struct</span> ifaddr *ifa,
	<span class="enscript-type">int</span> *tick_delay)	<span class="enscript-comment">/* minimum delay ticks for IFF_UP event */</span>
{
	<span class="enscript-type">struct</span> in6_ifaddr *ia = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;
	<span class="enscript-type">struct</span> dadq *dp;

	nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s - %s ifp %s ia6_flags 0x%x\n&quot;</span>,
	    __func__,
	    ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr),
	    if_name(ia-&gt;ia_ifp),
	    ia-&gt;ia6_flags));

	<span class="enscript-comment">/*
	 * If we don't need DAD, don't do it.
	 * There are several cases:
	 * - DAD is disabled (ip6_dad_count == 0)
	 * - the interface address is anycast
	 */</span>
	IFA_LOCK(&amp;ia-&gt;ia_ifa);
	<span class="enscript-keyword">if</span> (!(ia-&gt;ia6_flags &amp; IN6_IFF_DADPROGRESS)) {
		log(LOG_DEBUG,
			<span class="enscript-string">&quot;nd6_dad_start: not a tentative or optimistic address &quot;</span>
			<span class="enscript-string">&quot;%s(%s)\n&quot;</span>,
			ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr),
			ifa-&gt;ifa_ifp ? if_name(ifa-&gt;ifa_ifp) : <span class="enscript-string">&quot;???&quot;</span>);
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (!ip6_dad_count || (ia-&gt;ia6_flags &amp; IN6_IFF_ANYCAST) != 0) {
		ia-&gt;ia6_flags &amp;= ~IN6_IFF_DADPROGRESS;
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">return</span>;
	}
	IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
	<span class="enscript-keyword">if</span> (ifa-&gt;ifa_ifp == NULL)
		panic(<span class="enscript-string">&quot;nd6_dad_start: ifa-&gt;ifa_ifp == NULL&quot;</span>);
	<span class="enscript-keyword">if</span> (!(ifa-&gt;ifa_ifp-&gt;if_flags &amp; IFF_UP) ||
	    (ifa-&gt;ifa_ifp-&gt;if_eflags &amp; IFEF_IPV6_ND6ALT)) {
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> ((dp = nd6_dad_find(ifa)) != NULL) {
		DAD_REMREF(dp);
		<span class="enscript-comment">/* DAD already in progress */</span>
		<span class="enscript-keyword">return</span>;
	}

	dp = zalloc(dad_zone);
	<span class="enscript-keyword">if</span> (dp == NULL) {
		log(LOG_ERR, <span class="enscript-string">&quot;nd6_dad_start: memory allocation failed for &quot;</span>
			<span class="enscript-string">&quot;%s(%s)\n&quot;</span>,
			ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr),
			ifa-&gt;ifa_ifp ? if_name(ifa-&gt;ifa_ifp) : <span class="enscript-string">&quot;???&quot;</span>);
		<span class="enscript-keyword">return</span>;
	}
	bzero(dp, dad_size);
	lck_mtx_init(&amp;dp-&gt;dad_lock, ifa_mtx_grp, ifa_mtx_attr);

	<span class="enscript-comment">/* Callee adds one reference for us */</span>
	dp = nd6_dad_attach(dp, ifa);

	nd6log((LOG_DEBUG, <span class="enscript-string">&quot;%s: starting %sDAD for %s\n&quot;</span>,
	    if_name(ifa-&gt;ifa_ifp),
	    (ia-&gt;ia6_flags &amp; IN6_IFF_OPTIMISTIC) ? <span class="enscript-string">&quot;optimistic &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
	    ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr)));

	<span class="enscript-comment">/*
	 * Send NS packet for DAD, ip6_dad_count times.
	 * Note that we must delay the first transmission, if this is the
	 * first packet to be sent from the interface after interface
	 * (re)initialization.
	 */</span>
	<span class="enscript-keyword">if</span> (tick_delay == NULL) {
		u_int32_t retrans;
		<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;

		nd6_dad_ns_output(dp, ifa);
		ndi = ND_IFINFO(ifa-&gt;ifa_ifp);
		VERIFY(ndi != NULL &amp;&amp; ndi-&gt;initialized);
		lck_mtx_lock(&amp;ndi-&gt;lock);
		retrans = ndi-&gt;retrans * hz / 1000;
		lck_mtx_unlock(&amp;ndi-&gt;lock);
		timeout((<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *))nd6_dad_timer, (<span class="enscript-type">void</span> *)ifa, retrans);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span> ntick;

		<span class="enscript-keyword">if</span> (*tick_delay == 0)
			ntick = random() % (MAX_RTR_SOLICITATION_DELAY * hz);
		<span class="enscript-keyword">else</span>
			ntick = *tick_delay + random() % (hz / 2);
		*tick_delay = ntick;
		timeout((<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *))nd6_dad_timer, (<span class="enscript-type">void</span> *)ifa,
			ntick);
	}

	DAD_REMREF(dp);		<span class="enscript-comment">/* drop our reference */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> dadq *
<span class="enscript-function-name">nd6_dad_attach</span>(<span class="enscript-type">struct</span> dadq *dp, <span class="enscript-type">struct</span> ifaddr *ifa)
{
	lck_mtx_lock(dad6_mutex);
	DAD_LOCK(dp);
	dp-&gt;dad_ifa = ifa;
	IFA_ADDREF(ifa);	<span class="enscript-comment">/* for dad_ifa */</span>
	dp-&gt;dad_count = ip6_dad_count;
	dp-&gt;dad_ns_icount = dp-&gt;dad_na_icount = 0;
	dp-&gt;dad_ns_ocount = dp-&gt;dad_ns_tcount = 0;
	dp-&gt;dad_nd_ixcount = 0;
	VERIFY(!dp-&gt;dad_attached);
	dp-&gt;dad_attached = 1;
	DAD_ADDREF_LOCKED(dp);	<span class="enscript-comment">/* for caller */</span>
	DAD_ADDREF_LOCKED(dp);	<span class="enscript-comment">/* for dadq_head list */</span>
	TAILQ_INSERT_TAIL(&amp;dadq, (<span class="enscript-type">struct</span> dadq *)dp, dad_list);
	DAD_UNLOCK(dp);
	lck_mtx_unlock(dad6_mutex);

	<span class="enscript-keyword">return</span> (dp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_dad_detach</span>(<span class="enscript-type">struct</span> dadq *dp, <span class="enscript-type">struct</span> ifaddr *ifa)
{
	<span class="enscript-type">int</span> detached;

	lck_mtx_lock(dad6_mutex);
	DAD_LOCK(dp);
	<span class="enscript-keyword">if</span> ((detached = dp-&gt;dad_attached)) {
		VERIFY(dp-&gt;dad_ifa == ifa);
		TAILQ_REMOVE(&amp;dadq, (<span class="enscript-type">struct</span> dadq *)dp, dad_list);
		dp-&gt;dad_list.tqe_next = NULL;
		dp-&gt;dad_list.tqe_prev = NULL;
		dp-&gt;dad_attached = 0;
	}
	DAD_UNLOCK(dp);
	lck_mtx_unlock(dad6_mutex);
	<span class="enscript-keyword">if</span> (detached) {
		DAD_REMREF(dp);		<span class="enscript-comment">/* drop dadq_head reference */</span>
	}
}

<span class="enscript-comment">/*
 * terminate DAD unconditionally.  used for address removals.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_dad_stop</span>(<span class="enscript-type">struct</span> ifaddr *ifa)
{
	<span class="enscript-type">struct</span> dadq *dp;

	dp = nd6_dad_find(ifa);
	<span class="enscript-keyword">if</span> (!dp) {
		<span class="enscript-comment">/* DAD wasn't started yet */</span>
		<span class="enscript-keyword">return</span>;
	}

	untimeout((<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *))nd6_dad_timer, (<span class="enscript-type">void</span> *)ifa);

	nd6_dad_detach(dp, ifa);
	DAD_REMREF(dp);		<span class="enscript-comment">/* drop our reference */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_unsol_na_output</span>(<span class="enscript-type">struct</span> ifaddr *ifa)
{
	<span class="enscript-type">struct</span> in6_ifaddr *ia = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;
	<span class="enscript-type">struct</span> ifnet *ifp = ifa-&gt;ifa_ifp;
	<span class="enscript-type">struct</span> in6_addr saddr6, taddr6;

	<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_UP) == 0 ||
	    (ifp-&gt;if_flags &amp; IFF_RUNNING) == 0 ||
	    (ifp-&gt;if_eflags &amp; IFEF_IPV6_ND6ALT) != 0)
		<span class="enscript-keyword">return</span>;

	IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);
	taddr6 = ia-&gt;ia_addr.sin6_addr;
	IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
	<span class="enscript-keyword">if</span> (in6_setscope(&amp;taddr6, ifp, NULL) != 0)
		<span class="enscript-keyword">return</span>;
	saddr6 = in6addr_linklocal_allnodes;
	<span class="enscript-keyword">if</span> (in6_setscope(&amp;saddr6, ifp, NULL) != 0)
		<span class="enscript-keyword">return</span>;

	nd6log((LOG_INFO, <span class="enscript-string">&quot;%s: sending unsolicited NA\n&quot;</span>,
	    if_name(ifa-&gt;ifa_ifp)));

	nd6_na_output(ifp, &amp;saddr6, &amp;taddr6, ND_NA_FLAG_OVERRIDE, 1, NULL);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_dad_timer</span>(<span class="enscript-type">struct</span> ifaddr *ifa)
{
	<span class="enscript-type">struct</span> in6_ifaddr *ia = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;
	<span class="enscript-type">struct</span> dadq *dp = NULL;
	<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;

	<span class="enscript-comment">/* Sanity check */</span>
	<span class="enscript-keyword">if</span> (ia == NULL) {
		log(LOG_ERR, <span class="enscript-string">&quot;nd6_dad_timer: called with null parameter\n&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	nd6log2((LOG_DEBUG, <span class="enscript-string">&quot;%s - %s ifp %s ia6_flags 0x%x\n&quot;</span>,
	    __func__,
	    ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr),
	    if_name(ia-&gt;ia_ifp),
	    ia-&gt;ia6_flags));

	dp = nd6_dad_find(ifa);
	<span class="enscript-keyword">if</span> (dp == NULL) {
		log(LOG_ERR, <span class="enscript-string">&quot;nd6_dad_timer: DAD structure not found\n&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	IFA_LOCK(&amp;ia-&gt;ia_ifa);
	<span class="enscript-keyword">if</span> (ia-&gt;ia6_flags &amp; IN6_IFF_DUPLICATED) {
		log(LOG_ERR, <span class="enscript-string">&quot;nd6_dad_timer: called with duplicated address &quot;</span>
			<span class="enscript-string">&quot;%s(%s)\n&quot;</span>,
			ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr),
			ifa-&gt;ifa_ifp ? if_name(ifa-&gt;ifa_ifp) : <span class="enscript-string">&quot;???&quot;</span>);
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> ((ia-&gt;ia6_flags &amp; IN6_IFF_DADPROGRESS) == 0) {
		log(LOG_ERR, <span class="enscript-string">&quot;nd6_dad_timer: not a tentative or optimistic &quot;</span>
			<span class="enscript-string">&quot;address %s(%s)\n&quot;</span>,
			ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr),
			ifa-&gt;ifa_ifp ? if_name(ifa-&gt;ifa_ifp) : <span class="enscript-string">&quot;???&quot;</span>);
		IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	IFA_UNLOCK(&amp;ia-&gt;ia_ifa);

	<span class="enscript-comment">/* timeouted with IFF_{RUNNING,UP} check */</span>
	DAD_LOCK(dp);
	<span class="enscript-keyword">if</span> (dp-&gt;dad_ns_tcount &gt; dad_maxtry) {
		DAD_UNLOCK(dp);
		nd6log((LOG_INFO, <span class="enscript-string">&quot;%s: could not run DAD, driver problem?\n&quot;</span>,
			if_name(ifa-&gt;ifa_ifp)));

		nd6_dad_detach(dp, ifa);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* Need more checks? */</span>
	<span class="enscript-keyword">if</span> (dp-&gt;dad_ns_ocount &lt; dp-&gt;dad_count) {
		u_int32_t retrans;

		DAD_UNLOCK(dp);
		<span class="enscript-comment">/*
		 * We have more NS to go.  Send NS packet for DAD.
		 */</span>
		nd6_dad_ns_output(dp, ifa);
		ndi = ND_IFINFO(ifa-&gt;ifa_ifp);
		VERIFY(ndi != NULL &amp;&amp; ndi-&gt;initialized);
		lck_mtx_lock(&amp;ndi-&gt;lock);
		retrans = ndi-&gt;retrans * hz / 1000;
		lck_mtx_unlock(&amp;ndi-&gt;lock);
		timeout((<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *))nd6_dad_timer, (<span class="enscript-type">void</span> *)ifa, retrans);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * We have transmitted sufficient number of DAD packets.
		 * See what we've got.
		 */</span>
		<span class="enscript-type">int</span> duplicate;
		boolean_t candisable;

		duplicate = 0;
		candisable = dp-&gt;dad_nd_ixcount &gt; 0;

		<span class="enscript-keyword">if</span> (dp-&gt;dad_na_icount) {
			<span class="enscript-comment">/*
			 * the check is in nd6_dad_na_input(),
			 * but just in case
			 */</span>
			duplicate++;
		}

		<span class="enscript-keyword">if</span> (dp-&gt;dad_ns_icount) {
			<span class="enscript-comment">/* We've seen NS, means DAD has failed. */</span>
			duplicate++;
		}
		DAD_UNLOCK(dp);

		<span class="enscript-keyword">if</span> (duplicate) {
			nd6log((LOG_INFO,
			    <span class="enscript-string">&quot;%s: duplicate IPv6 address %s [timer]\n&quot;</span>,
			    __func__, ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr),
			    if_name(ia-&gt;ia_ifp)));
			nd6_dad_duplicated(ifa);
			<span class="enscript-comment">/* (*dp) will be freed in nd6_dad_duplicated() */</span>
		} <span class="enscript-keyword">else</span> {
			boolean_t txunsolna;

			<span class="enscript-comment">/*
			 * We are done with DAD.  No NA came, no NS came.
			 * No duplicate address found.
			 */</span>
			IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);
			ia-&gt;ia6_flags &amp;= ~IN6_IFF_DADPROGRESS;
			IFA_UNLOCK(&amp;ia-&gt;ia_ifa);

			ndi = ND_IFINFO(ifa-&gt;ifa_ifp);
			VERIFY(ndi != NULL &amp;&amp; ndi-&gt;initialized);
			lck_mtx_lock(&amp;ndi-&gt;lock);
			txunsolna = (ndi-&gt;flags &amp; ND6_IFF_REPLICATED) != 0;
			lck_mtx_unlock(&amp;ndi-&gt;lock);

			<span class="enscript-keyword">if</span> (txunsolna) {
				nd6_unsol_na_output(ifa);
			}

			nd6log((LOG_DEBUG,
			    <span class="enscript-string">&quot;%s: DAD complete for %s - no duplicates found%s\n&quot;</span>,
			    if_name(ifa-&gt;ifa_ifp),
			    ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr),
			    txunsolna ? <span class="enscript-string">&quot;, tx unsolicited NA with O=1&quot;</span> : <span class="enscript-string">&quot;.&quot;</span>));
			in6_post_msg(ia-&gt;ia_ifp, KEV_INET6_NEW_USER_ADDR, ia, 
			    dp-&gt;dad_ehsrc);
			nd6_dad_detach(dp, ifa);
		}
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (dp != NULL)
		DAD_REMREF(dp);		<span class="enscript-comment">/* drop our reference */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_dad_duplicated</span>(<span class="enscript-type">struct</span> ifaddr *ifa)
{
	<span class="enscript-type">struct</span> in6_ifaddr *ia = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;
	<span class="enscript-type">struct</span> dadq *dp;
	<span class="enscript-type">struct</span> ifnet *ifp = ifa-&gt;ifa_ifp;
	boolean_t disable;

	dp = nd6_dad_find(ifa);
	<span class="enscript-keyword">if</span> (dp == NULL) {
		log(LOG_ERR, <span class="enscript-string">&quot;%s: DAD structure not found.\n&quot;</span>, __func__);
		<span class="enscript-keyword">return</span>;
	}
	IFA_LOCK(&amp;ia-&gt;ia_ifa);
	DAD_LOCK(dp);
	nd6log((LOG_ERR, <span class="enscript-string">&quot;%s: NS in/out=%d/%d, NA in=%d, ND x=%d\n&quot;</span>,
	    __func__, dp-&gt;dad_ns_icount, dp-&gt;dad_ns_ocount, dp-&gt;dad_na_icount,
	    dp-&gt;dad_nd_ixcount));
	disable = dp-&gt;dad_nd_ixcount &gt; 0;
	DAD_UNLOCK(dp);
	ia-&gt;ia6_flags &amp;= ~IN6_IFF_DADPROGRESS;
	ia-&gt;ia6_flags |= IN6_IFF_DUPLICATED;
	IFA_UNLOCK(&amp;ia-&gt;ia_ifa);

	<span class="enscript-comment">/* increment DAD collision counter */</span>
	++ip6stat.ip6s_dad_collide;

	<span class="enscript-comment">/* We are done with DAD, with duplicated address found. (failure) */</span>
	untimeout((<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *))nd6_dad_timer, (<span class="enscript-type">void</span> *)ifa);

	IFA_LOCK(&amp;ia-&gt;ia_ifa);
	log(LOG_ERR, <span class="enscript-string">&quot;%s: DAD complete for %s - duplicate found.\n&quot;</span>,
	    if_name(ifp), ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr));
	IFA_UNLOCK(&amp;ia-&gt;ia_ifa);

	<span class="enscript-keyword">if</span> (disable) {
		<span class="enscript-type">struct</span> nd_ifinfo *ndi =  ND_IFINFO(ifp);
		log(LOG_ERR, <span class="enscript-string">&quot;%s: possible hardware address duplication &quot;</span>
		    <span class="enscript-string">&quot;detected, disabling IPv6 for interface.\n&quot;</span>, if_name(ifp));

		VERIFY((NULL != ndi) &amp;&amp; (TRUE == ndi-&gt;initialized));
		ndi-&gt;flags |= ND6_IFF_IFDISABLED;
		<span class="enscript-comment">/* Make sure to set IFEF_IPV6_DISABLED too */</span>
		nd6_if_disable(ifp, TRUE);
	}

	log(LOG_ERR, <span class="enscript-string">&quot;%s: manual intervention required!\n&quot;</span>, if_name(ifp));

	<span class="enscript-comment">/* Send an event to the configuration agent so that the
	 * duplicate address will be notified to the user and will
	 * be removed.
	 */</span>
	in6_post_msg(ifp, KEV_INET6_NEW_USER_ADDR, ia, dp-&gt;dad_ehsrc);
	nd6_dad_detach(dp, ifa);
	DAD_REMREF(dp);		<span class="enscript-comment">/* drop our reference */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_dad_ns_output</span>(<span class="enscript-type">struct</span> dadq *dp, <span class="enscript-type">struct</span> ifaddr *ifa)
{
	<span class="enscript-type">struct</span> in6_ifaddr *ia = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;
	<span class="enscript-type">struct</span> ifnet *ifp = ifa-&gt;ifa_ifp;
	<span class="enscript-type">struct</span> in6_addr taddr6;

	DAD_LOCK(dp);
	dp-&gt;dad_ns_tcount++;
	<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_UP) == 0) {
		DAD_UNLOCK(dp);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; IFF_RUNNING) == 0) {
		DAD_UNLOCK(dp);
		<span class="enscript-keyword">return</span>;
	}

	dp-&gt;dad_ns_ocount++;
	DAD_UNLOCK(dp);
	IFA_LOCK_SPIN(&amp;ia-&gt;ia_ifa);
	taddr6 = ia-&gt;ia_addr.sin6_addr;
	IFA_UNLOCK(&amp;ia-&gt;ia_ifa);
	nd6_ns_output(ifp, NULL, &amp;taddr6, NULL, 1);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_dad_ns_input</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> ifaddr *ifa, <span class="enscript-type">char</span> *lladdr,
    <span class="enscript-type">int</span> lladdrlen)
{
	<span class="enscript-type">struct</span> dadq *dp;
	<span class="enscript-type">struct</span> in6_ifaddr *ia;
	boolean_t candisable, dadstarted;
	<span class="enscript-type">struct</span> ip6aux *ip6a;

	VERIFY(ifa != NULL);
	candisable = FALSE;
	IFA_LOCK(ifa);
	ia = (<span class="enscript-type">struct</span> in6_ifaddr *) ifa;
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;ia-&gt;ia_addr.sin6_addr)) {
		ip6a = ip6_findaux(m);
		candisable = TRUE;
		<span class="enscript-keyword">if</span> (ip6a &amp;&amp; (ip6a-&gt;ip6a_flags &amp; IP6A_HASEEN) != 0) {
			<span class="enscript-type">struct</span> in6_addr in6 = ia-&gt;ia_addr.sin6_addr;

			nd6log((LOG_INFO,
			    <span class="enscript-string">&quot;%s: eh_src=%02x:%02x:%02x:%02x:%02x:%02x -&gt; %s\n&quot;</span>,
			    __func__,
			    ip6a-&gt;ip6a_ehsrc[0], ip6a-&gt;ip6a_ehsrc[1],
			    ip6a-&gt;ip6a_ehsrc[2], ip6a-&gt;ip6a_ehsrc[3],
			    ip6a-&gt;ip6a_ehsrc[4], ip6a-&gt;ip6a_ehsrc[5],
			    if_name(ifa-&gt;ifa_ifp)));

			in6.s6_addr8[8] = ip6a-&gt;ip6a_ehsrc[0] ^ ND6_EUI64_UBIT;
			in6.s6_addr8[9] = ip6a-&gt;ip6a_ehsrc[1];
			in6.s6_addr8[10] = ip6a-&gt;ip6a_ehsrc[2];
			in6.s6_addr8[11] = 0xff;
			in6.s6_addr8[12] = 0xfe;
			in6.s6_addr8[13] = ip6a-&gt;ip6a_ehsrc[3];
			in6.s6_addr8[14] = ip6a-&gt;ip6a_ehsrc[4];
			in6.s6_addr8[15] = ip6a-&gt;ip6a_ehsrc[5];

			<span class="enscript-keyword">if</span> (!IN6_ARE_ADDR_EQUAL(&amp;in6, &amp;ia-&gt;ia_addr.sin6_addr)) {
				nd6log((LOG_ERR, <span class="enscript-string">&quot;%s: DAD NS for %s on %s &quot;</span>
				    <span class="enscript-string">&quot;is from another MAC address.\n&quot;</span>, __func__,
				    ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr),
				    if_name(ifa-&gt;ifa_ifp)));
				candisable = FALSE;
			}
		} <span class="enscript-keyword">else</span> {
			nd6log((LOG_INFO,
			    <span class="enscript-string">&quot;%s: no eh_src for DAD NS %s at %s.\n&quot;</span>, __func__,
			    ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr),
			    if_name(ifa-&gt;ifa_ifp)));
		}
	}
	IFA_UNLOCK(ifa);

	<span class="enscript-comment">/* If DAD has not yet started, then this DAD NS probe is proof that
	 * another node has started first. Otherwise, it could be a multicast
	 * loopback, in which case it should be counted and handled later in
	 * the DAD timer callback.
	 */</span>
	dadstarted = FALSE;
	dp = nd6_dad_find(ifa);
	<span class="enscript-keyword">if</span> (dp != NULL) {
		DAD_LOCK(dp);
		++dp-&gt;dad_ns_icount;
		<span class="enscript-keyword">if</span> (candisable)
			++dp-&gt;dad_nd_ixcount;
		<span class="enscript-keyword">if</span> (dp-&gt;dad_ns_ocount &gt; 0)
			dadstarted = TRUE;
		<span class="enscript-keyword">if</span> (lladdr &amp;&amp; lladdrlen &gt;= ETHER_ADDR_LEN)
			memcpy(dp-&gt;dad_ehsrc, lladdr, ETHER_ADDR_LEN);
		DAD_UNLOCK(dp);
		DAD_REMREF(dp);
		dp = NULL;
	}

	nd6log((LOG_INFO, <span class="enscript-string">&quot;%s: dadstarted=%d candisable=%d\n&quot;</span>,
	    __func__, dadstarted, candisable));

	<span class="enscript-keyword">if</span> (!dadstarted) {
		nd6log((LOG_INFO,
		    <span class="enscript-string">&quot;%s: duplicate IPv6 address %s [processing NS on %s]\n&quot;</span>,
		    __func__, ip6_sprintf(&amp;ia-&gt;ia_addr.sin6_addr),
		    if_name(ifa-&gt;ifa_ifp)));
		nd6_dad_duplicated(ifa);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">nd6_dad_na_input</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> in6_addr *taddr,
    caddr_t lladdr, <span class="enscript-type">int</span> lladdrlen)
{
	<span class="enscript-type">struct</span> ifaddr *ifa = NULL;
	<span class="enscript-type">struct</span> in6_ifaddr *ia = NULL;
	<span class="enscript-type">struct</span> dadq *dp = NULL;
	<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;
	boolean_t candisable, replicated;

	ifa = (<span class="enscript-type">struct</span> ifaddr *) in6ifa_ifpwithaddr(ifp, taddr);
	<span class="enscript-keyword">if</span> (ifa == NULL)
		<span class="enscript-keyword">return</span> m;

	candisable = FALSE;
	replicated = FALSE;

	<span class="enscript-comment">/* Get the ND6_IFF_REPLICATED flag. */</span>
	ndi = ND_IFINFO(ifp);
	<span class="enscript-keyword">if</span> (ndi != NULL &amp;&amp; ndi-&gt;initialized) {
		lck_mtx_lock(&amp;ndi-&gt;lock);
		replicated = !!(ndi-&gt;flags &amp; ND6_IFF_REPLICATED);
		lck_mtx_unlock(&amp;ndi-&gt;lock);
	}

	<span class="enscript-keyword">if</span> (replicated) {
		nd6log((LOG_INFO, <span class="enscript-string">&quot;%s: ignoring duplicate NA on &quot;</span>
		    <span class="enscript-string">&quot;replicated interface %s\n&quot;</span>, __func__, if_name(ifp)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* Lock the interface address until done (see label below). */</span>
	IFA_LOCK(ifa);
	ia = (<span class="enscript-type">struct</span> in6_ifaddr *) ifa;

	<span class="enscript-comment">/*
	 * If the address is a link-local address formed from an interface
	 * identifier based on the hardware address which is supposed to be
	 * uniquely assigned (e.g., EUI-64 for an Ethernet interface), IP
	 * operation on the interface SHOULD be disabled according to RFC 4862,
	 * section 5.4.5, but here we decide not to disable if the target
	 * hardware address is not also ours, which is a transitory possibility
	 * in the presence of network-resident sleep proxies on the local link.
	 */</span>
	<span class="enscript-keyword">if</span> (!(ia-&gt;ia6_flags &amp; IN6_IFF_DADPROGRESS)) {
		IFA_UNLOCK(ifa);
		nd6log((LOG_INFO, <span class="enscript-string">&quot;%s: ignoring duplicate NA on &quot;</span>
		    <span class="enscript-string">&quot;%s [DAD not in progress]\n&quot;</span>, __func__,
		    if_name(ifp)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* Some sleep proxies improperly send the client's Ethernet address in
	 * the target link-layer address option, so detect this by comparing
	 * the L2-header source address, if we have seen it, with the target
	 * address, and ignoring the NA if they don't match.
	 */</span>
	<span class="enscript-keyword">if</span> (lladdr != NULL &amp;&amp; lladdrlen &gt;= ETHER_ADDR_LEN) {
		<span class="enscript-type">struct</span> ip6aux *ip6a = ip6_findaux(m);
		<span class="enscript-keyword">if</span> (ip6a &amp;&amp; (ip6a-&gt;ip6a_flags &amp; IP6A_HASEEN) != 0 &amp;&amp;
		    bcmp(ip6a-&gt;ip6a_ehsrc, lladdr, ETHER_ADDR_LEN) != 0) {
			IFA_UNLOCK(ifa);
			nd6log((LOG_ERR, <span class="enscript-string">&quot;%s: ignoring duplicate NA on %s &quot;</span>
			    <span class="enscript-string">&quot;[eh_src != tgtlladdr]\n&quot;</span>, __func__, if_name(ifp)));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	IFA_UNLOCK(ifa);

	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_LINKLOCAL(&amp;ia-&gt;ia_addr.sin6_addr) &amp;&amp;
	    !(ia-&gt;ia6_flags &amp; IN6_IFF_SECURED)) {
		<span class="enscript-type">struct</span> in6_addr in6;

		<span class="enscript-comment">/*
		 * To avoid over-reaction, we only apply this logic when we are
		 * very sure that hardware addresses are supposed to be unique.
		 */</span>
		<span class="enscript-keyword">switch</span> (ifp-&gt;if_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_BRIDGE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ETHER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_FDDI</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_ATM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE1394</span>:
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">IFT_IEEE80211</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IFT_IEEE80211</span>:
#<span class="enscript-reference">endif</span>
			<span class="enscript-comment">/* Check if our hardware address matches the target */</span>
			<span class="enscript-keyword">if</span> (lladdr != NULL &amp;&amp; lladdrlen &gt; 0) {
				<span class="enscript-type">struct</span> ifaddr *llifa;
				<span class="enscript-type">struct</span> sockaddr_dl *sdl;

				llifa = ifp-&gt;if_lladdr;
				IFA_LOCK(llifa);
				sdl = (<span class="enscript-type">struct</span> sockaddr_dl *)(<span class="enscript-type">void</span> *)
				    llifa-&gt;ifa_addr;
				<span class="enscript-keyword">if</span> (lladdrlen == sdl-&gt;sdl_alen &amp;&amp;
				    bcmp(lladdr, LLADDR(sdl), lladdrlen) == 0)
					candisable = TRUE;
				IFA_UNLOCK(llifa);
			}
			in6 = ia-&gt;ia_addr.sin6_addr;
			<span class="enscript-keyword">if</span> (in6_iid_from_hw(ifp, &amp;in6) != 0)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-comment">/* Refine decision about whether IPv6 can be disabled */</span>
			IFA_LOCK(ifa);
			<span class="enscript-keyword">if</span> (candisable &amp;&amp;
			    !IN6_ARE_ADDR_EQUAL(&amp;ia-&gt;ia_addr.sin6_addr, &amp;in6)) {
				<span class="enscript-comment">/*
				 * Apply this logic only to the embedded MAC
				 * address form of link-local IPv6 address.
				 */</span>
				candisable = FALSE;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lladdr == NULL &amp;&amp;
			    IN6_ARE_ADDR_EQUAL(&amp;ia-&gt;ia_addr.sin6_addr, &amp;in6)) {
				<span class="enscript-comment">/*
				 * We received a NA with no target link-layer
				 * address option. This means that someone else
				 * has our address. Mark it as a hardware
				 * duplicate so we disable IPv6 later on.
				 */</span>
				candisable = TRUE;
			}
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}
	}

	dp = nd6_dad_find(ifa);
	<span class="enscript-keyword">if</span> (dp == NULL) {
		nd6log((LOG_INFO, <span class="enscript-string">&quot;%s: no DAD structure for %s on %s.\n&quot;</span>,
		    __func__, ip6_sprintf(taddr), if_name(ifp)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	DAD_LOCK_SPIN(dp);
	<span class="enscript-keyword">if</span> (lladdr != NULL &amp;&amp; lladdrlen &gt;= ETHER_ADDR_LEN)
		memcpy(dp-&gt;dad_ehsrc, lladdr, ETHER_ADDR_LEN);
	dp-&gt;dad_na_icount++;
	<span class="enscript-keyword">if</span> (candisable)
		dp-&gt;dad_nd_ixcount++;
	DAD_UNLOCK(dp);
	DAD_REMREF(dp);

	<span class="enscript-comment">/* remove the address. */</span>
	nd6log((LOG_INFO,
	    <span class="enscript-string">&quot;%s: duplicate IPv6 address %s [processing NA on %s]\n&quot;</span>, __func__,
	    ip6_sprintf(taddr), if_name(ifp)));
	nd6_dad_duplicated(ifa);

<span class="enscript-reference">done</span>:
	IFA_LOCK_ASSERT_NOTHELD(ifa);
	IFA_REMREF(ifa);
	m_freem(m);
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dad_addref</span>(<span class="enscript-type">struct</span> dadq *dp, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-keyword">if</span> (!locked)
		DAD_LOCK_SPIN(dp);
	<span class="enscript-keyword">else</span>
		DAD_LOCK_ASSERT_HELD(dp);

	<span class="enscript-keyword">if</span> (++dp-&gt;dad_refcount == 0) {
		panic(<span class="enscript-string">&quot;%s: dad %p wraparound refcnt\n&quot;</span>, __func__, dp);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (!locked)
		DAD_UNLOCK(dp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dad_remref</span>(<span class="enscript-type">struct</span> dadq *dp)
{
	<span class="enscript-type">struct</span> ifaddr *ifa;

	DAD_LOCK_SPIN(dp);
	<span class="enscript-keyword">if</span> (dp-&gt;dad_refcount == 0)
		panic(<span class="enscript-string">&quot;%s: dad %p negative refcnt\n&quot;</span>, __func__, dp);
	--dp-&gt;dad_refcount;
	<span class="enscript-keyword">if</span> (dp-&gt;dad_refcount &gt; 0) {
		DAD_UNLOCK(dp);
		<span class="enscript-keyword">return</span>;
	}
	DAD_UNLOCK(dp);

	<span class="enscript-keyword">if</span> (dp-&gt;dad_attached ||
	    dp-&gt;dad_list.tqe_next != NULL || dp-&gt;dad_list.tqe_prev != NULL) {
		panic(<span class="enscript-string">&quot;%s: attached dad=%p is being freed&quot;</span>, __func__, dp);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> ((ifa = dp-&gt;dad_ifa) != NULL) {
		IFA_REMREF(ifa);	<span class="enscript-comment">/* drop dad_ifa reference */</span>
		dp-&gt;dad_ifa = NULL;
	}

	lck_mtx_destroy(&amp;dp-&gt;dad_lock, ifa_mtx_grp);
	zfree(dad_zone, dp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_llreach_set_reachable</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">void</span> *addr, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> alen)
{
	<span class="enscript-comment">/* Nothing more to do if it's disabled */</span>
	<span class="enscript-keyword">if</span> (nd6_llreach_base == 0)
		<span class="enscript-keyword">return</span>;

	ifnet_llreach_set_reachable(ifp, ETHERTYPE_IPV6, addr, alen);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_alt_node_addr_decompose</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> sockaddr *sa,
    <span class="enscript-type">struct</span> sockaddr_dl* sdl, <span class="enscript-type">struct</span> sockaddr_in6 *sin6)
{
	<span class="enscript-type">static</span> <span class="enscript-type">const</span> size_t EUI64_LENGTH = 8;

	VERIFY(nd6_need_cache(ifp));
	VERIFY(sa);
	VERIFY(sdl &amp;&amp; (<span class="enscript-type">void</span> *)sa != (<span class="enscript-type">void</span> *)sdl);
	VERIFY(sin6 &amp;&amp; (<span class="enscript-type">void</span> *)sa != (<span class="enscript-type">void</span> *)sin6);

	bzero(sin6, <span class="enscript-keyword">sizeof</span> *sin6);
	sin6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span> *sin6;
	sin6-&gt;sin6_family = AF_INET6;

	bzero(sdl, <span class="enscript-keyword">sizeof</span> *sdl);
	sdl-&gt;sdl_len = <span class="enscript-keyword">sizeof</span> *sdl;
	sdl-&gt;sdl_family = AF_LINK;
	sdl-&gt;sdl_type = ifp-&gt;if_type;
	sdl-&gt;sdl_index = ifp-&gt;if_index;

	<span class="enscript-keyword">switch</span> (sa-&gt;sa_family) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>: {
		<span class="enscript-type">struct</span> sockaddr_in6 *sin6a = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)sa;
		<span class="enscript-type">struct</span> in6_addr *in6 = &amp;sin6a-&gt;sin6_addr;

		VERIFY(sa-&gt;sa_len == <span class="enscript-keyword">sizeof</span> *sin6);

		sdl-&gt;sdl_nlen = strlen(ifp-&gt;if_name);
		bcopy(ifp-&gt;if_name, sdl-&gt;sdl_data, sdl-&gt;sdl_nlen);
		<span class="enscript-keyword">if</span> (in6-&gt;s6_addr[11] == 0xff &amp;&amp; in6-&gt;s6_addr[12] == 0xfe) {
			sdl-&gt;sdl_alen = ETHER_ADDR_LEN;
			LLADDR(sdl)[0] = (in6-&gt;s6_addr[8] ^ ND6_EUI64_UBIT);
			LLADDR(sdl)[1] = in6-&gt;s6_addr[9];
			LLADDR(sdl)[2] = in6-&gt;s6_addr[10];
			LLADDR(sdl)[3] = in6-&gt;s6_addr[13];
			LLADDR(sdl)[4] = in6-&gt;s6_addr[14];
			LLADDR(sdl)[5] = in6-&gt;s6_addr[15];
		} <span class="enscript-keyword">else</span> {
			sdl-&gt;sdl_alen = EUI64_LENGTH;
			bcopy(&amp;in6-&gt;s6_addr[8], LLADDR(sdl), EUI64_LENGTH);
		}

		sdl-&gt;sdl_slen = 0;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_LINK</span>: {
		<span class="enscript-type">struct</span> sockaddr_dl *sdla = (<span class="enscript-type">struct</span> sockaddr_dl *)(<span class="enscript-type">void</span> *)sa;
		<span class="enscript-type">struct</span> in6_addr *in6 = &amp;sin6-&gt;sin6_addr;
		caddr_t lla = LLADDR(sdla);

		VERIFY(sa-&gt;sa_len &lt;= <span class="enscript-keyword">sizeof</span> *sdl);
		bcopy(sa, sdl, sa-&gt;sa_len);

		sin6-&gt;sin6_scope_id = sdla-&gt;sdl_index;
		<span class="enscript-keyword">if</span> (sin6-&gt;sin6_scope_id == 0)
			sin6-&gt;sin6_scope_id = ifp-&gt;if_index;
		in6-&gt;s6_addr[0] = 0xfe;
		in6-&gt;s6_addr[1] = 0x80;
		<span class="enscript-keyword">if</span> (sdla-&gt;sdl_alen == EUI64_LENGTH)
			bcopy(lla, &amp;in6-&gt;s6_addr[8], EUI64_LENGTH);
		<span class="enscript-keyword">else</span> {
			VERIFY(sdla-&gt;sdl_alen == ETHER_ADDR_LEN);

			in6-&gt;s6_addr[8] = ((uint8_t) lla[0] ^ ND6_EUI64_UBIT);
			in6-&gt;s6_addr[9] = (uint8_t) lla[1];
			in6-&gt;s6_addr[10] = (uint8_t) lla[2];
			in6-&gt;s6_addr[11] = 0xff;
			in6-&gt;s6_addr[12] = 0xfe;
			in6-&gt;s6_addr[13] = (uint8_t) lla[3];
			in6-&gt;s6_addr[14] = (uint8_t) lla[4];
			in6-&gt;s6_addr[15] = (uint8_t) lla[5];
		}

		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-reference">default</span>:
		VERIFY(false);
		<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_alt_node_present</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> sockaddr_in6 *sin6,
    <span class="enscript-type">struct</span> sockaddr_dl *sdl, int32_t rssi, <span class="enscript-type">int</span> lqm, <span class="enscript-type">int</span> npm)
{
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">struct</span> llinfo_nd6 *ln;
	<span class="enscript-type">struct</span>	if_llreach *lr;

	nd6_cache_lladdr(ifp, &amp;sin6-&gt;sin6_addr, LLADDR(sdl), sdl-&gt;sdl_alen,
	    ND_NEIGHBOR_ADVERT, 0);

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_NOTOWNED);
	lck_mtx_lock(rnh_lock);

	rt = rtalloc1_scoped_locked((<span class="enscript-type">struct</span> sockaddr *)sin6, 1, 0,
	    ifp-&gt;if_index);
	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK(rt);
		VERIFY(rt-&gt;rt_flags &amp; RTF_LLINFO);
		VERIFY(rt-&gt;rt_llinfo);

		ln = rt-&gt;rt_llinfo;
		ln-&gt;ln_state = ND6_LLINFO_REACHABLE;
		ln_setexpire(ln, 0);

		lr = ln-&gt;ln_llreach;
		<span class="enscript-keyword">if</span> (lr) {
			IFLR_LOCK(lr);
			lr-&gt;lr_rssi = rssi;
			lr-&gt;lr_lqm = (int32_t) lqm;
			lr-&gt;lr_npm = (int32_t) npm;
			IFLR_UNLOCK(lr);
		}

		RT_UNLOCK(rt);
		RT_REMREF(rt);
	}

	lck_mtx_unlock(rnh_lock);

	<span class="enscript-keyword">if</span> (rt == NULL) {
		log(LOG_ERR, <span class="enscript-string">&quot;%s: failed to add/update host route to %s.\n&quot;</span>,
		    __func__, ip6_sprintf(&amp;sin6-&gt;sin6_addr));
	} <span class="enscript-keyword">else</span> {
		nd6log((LOG_DEBUG, <span class="enscript-string">&quot;%s: host route to %s [lr=0x%llx]\n&quot;</span>,
		    __func__, ip6_sprintf(&amp;sin6-&gt;sin6_addr),
		    (uint64_t)VM_KERNEL_ADDRPERM(lr)));
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_alt_node_absent</span>(<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> sockaddr_in6 *sin6)
{
	<span class="enscript-type">struct</span> rtentry *rt;

	nd6log((LOG_DEBUG, <span class="enscript-string">&quot;%s: host route to %s\n&quot;</span>, __func__,
	    ip6_sprintf(&amp;sin6-&gt;sin6_addr)));

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_NOTOWNED);
	lck_mtx_lock(rnh_lock);

	rt = rtalloc1_scoped_locked((<span class="enscript-type">struct</span> sockaddr *)sin6, 0, 0,
	    ifp-&gt;if_index);
	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK(rt);

		<span class="enscript-keyword">if</span> (!(rt-&gt;rt_flags &amp; (RTF_CLONING|RTF_PRCLONING)) &amp;&amp;
		    (rt-&gt;rt_flags &amp; (RTF_HOST|RTF_LLINFO|RTF_WASCLONED)) ==
		      (RTF_HOST|RTF_LLINFO|RTF_WASCLONED)) {
			rt-&gt;rt_flags |= RTF_CONDEMNED;
			RT_UNLOCK(rt);

			(<span class="enscript-type">void</span>) rtrequest_locked(RTM_DELETE, rt_key(rt),
			    (<span class="enscript-type">struct</span> sockaddr *)NULL, rt_mask(rt), 0,
			    (<span class="enscript-type">struct</span> rtentry **)NULL);

			rtfree_locked(rt);
		} <span class="enscript-keyword">else</span> {
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
		}
	}

	lck_mtx_unlock(rnh_lock);
}
</pre>
<hr />
</body></html>