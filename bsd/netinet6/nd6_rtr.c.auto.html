<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nd6_rtr.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nd6_rtr.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/random/randomdev.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/radix.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_ifattach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/scope6_var.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">defrouter_addreq</span>(<span class="enscript-type">struct</span> nd_defrouter *, boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">defrouter_delreq</span>(<span class="enscript-type">struct</span> nd_defrouter *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd_defrouter *<span class="enscript-function-name">defrtrlist_update_common</span>(<span class="enscript-type">struct</span> nd_defrouter *,
    boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd_defrouter *<span class="enscript-function-name">defrtrlist_update</span>(<span class="enscript-type">struct</span> nd_defrouter *);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> in6_ifaddr *<span class="enscript-function-name">in6_pfx_newpersistaddr</span>(<span class="enscript-type">struct</span> nd_prefix *, <span class="enscript-type">int</span>,
    <span class="enscript-type">int</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">defrtrlist_sync</span>(<span class="enscript-type">struct</span> ifnet *);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd_pfxrouter *<span class="enscript-function-name">pfxrtr_lookup</span>(<span class="enscript-type">struct</span> nd_prefix *,
	<span class="enscript-type">struct</span> nd_defrouter *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pfxrtr_add</span>(<span class="enscript-type">struct</span> nd_prefix *, <span class="enscript-type">struct</span> nd_defrouter *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pfxrtr_del</span>(<span class="enscript-type">struct</span> nd_pfxrouter *, <span class="enscript-type">struct</span> nd_prefix *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd_pfxrouter *<span class="enscript-function-name">find_pfxlist_reachable_router</span>(<span class="enscript-type">struct</span> nd_prefix *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_rtmsg</span>(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> rtentry *);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">nd6_prefix_onlink_common</span>(<span class="enscript-type">struct</span> nd_prefix *, boolean_t,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd_prefix *<span class="enscript-function-name">nd6_prefix_equal_lookup</span>(<span class="enscript-type">struct</span> nd_prefix *, boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nd6_prefix_sync</span>(<span class="enscript-type">struct</span> ifnet *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">in6_init_address_ltimes</span>(<span class="enscript-type">struct</span> nd_prefix *,
    <span class="enscript-type">struct</span> in6_addrlifetime *);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">rt6_deleteroute</span>(<span class="enscript-type">struct</span> radix_node *, <span class="enscript-type">void</span> *);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd_defrouter *<span class="enscript-function-name">nddr_alloc</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nddr_free</span>(<span class="enscript-type">struct</span> nd_defrouter *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">nddr_trace</span>(<span class="enscript-type">struct</span> nd_defrouter *, <span class="enscript-type">int</span>);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd_prefix *<span class="enscript-function-name">ndpr_alloc</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ndpr_free</span>(<span class="enscript-type">struct</span> nd_prefix *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ndpr_trace</span>(<span class="enscript-type">struct</span> nd_prefix *, <span class="enscript-type">int</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nd6_recalc_reachtm_interval;

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifnet *nd6_defifp;
<span class="enscript-type">int</span> nd6_defifindex;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> nd6_defrouter_genid;

<span class="enscript-type">int</span> ip6_use_tempaddr = 1; <span class="enscript-comment">/* use temp addr by default for testing now */</span>

<span class="enscript-type">int</span> nd6_accept_6to4 = 1;

<span class="enscript-type">int</span> ip6_desync_factor;
u_int32_t ip6_temp_preferred_lifetime = DEF_TEMP_PREFERRED_LIFETIME;
u_int32_t ip6_temp_valid_lifetime = DEF_TEMP_VALID_LIFETIME;
<span class="enscript-comment">/*
 * shorter lifetimes for debugging purposes.
 *	u_int32_t ip6_temp_preferred_lifetime = 800;
 *	static u_int32_t ip6_temp_valid_lifetime = 1800;
 */</span>
<span class="enscript-type">int</span> ip6_temp_regen_advance = TEMPADDR_REGEN_ADVANCE;

<span class="enscript-type">extern</span> lck_mtx_t *nd6_mutex;

<span class="enscript-comment">/* Serialization variables for single thread access to nd_prefix */</span>
<span class="enscript-type">static</span> boolean_t nd_prefix_busy;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *nd_prefix_waitchan = &amp;nd_prefix_busy;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> nd_prefix_waiters = 0;

<span class="enscript-comment">/* Serialization variables for single thread access to nd_defrouter */</span>
<span class="enscript-type">static</span> boolean_t nd_defrouter_busy;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *nd_defrouter_waitchan = &amp;nd_defrouter_busy;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> nd_defrouter_waiters = 0;

<span class="enscript-comment">/* RTPREF_MEDIUM has to be 0! */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTPREF_HIGH</span>	1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTPREF_MEDIUM</span>	0
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTPREF_LOW</span>	(-1)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTPREF_RESERVED</span>	(-2)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">RTPREF_INVALID</span>	(-3)	<span class="enscript-comment">/* internal */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NDPR_TRACE_HIST_SIZE</span>	32		<span class="enscript-comment">/* size of trace history */</span>

<span class="enscript-comment">/* For gdb */</span>
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ndpr_trace_hist_size = NDPR_TRACE_HIST_SIZE;

<span class="enscript-type">struct</span> nd_prefix_dbg {
	<span class="enscript-type">struct</span> nd_prefix	ndpr_pr;		<span class="enscript-comment">/* nd_prefix */</span>
	u_int16_t		ndpr_refhold_cnt;	<span class="enscript-comment">/* # of ref */</span>
	u_int16_t		ndpr_refrele_cnt;	<span class="enscript-comment">/* # of rele */</span>
	<span class="enscript-comment">/*
	 * Circular lists of ndpr_addref and ndpr_remref callers.
	 */</span>
	ctrace_t		ndpr_refhold[NDPR_TRACE_HIST_SIZE];
	ctrace_t		ndpr_refrele[NDPR_TRACE_HIST_SIZE];
};

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ndpr_debug;			<span class="enscript-comment">/* debug flags */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ndpr_size;			<span class="enscript-comment">/* size of zone element */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *ndpr_zone;			<span class="enscript-comment">/* zone for nd_prefix */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NDPR_ZONE_MAX</span>	64			<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NDPR_ZONE_NAME</span>	<span class="enscript-string">&quot;nd6_prefix&quot;</span>		<span class="enscript-comment">/* zone name */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NDDR_TRACE_HIST_SIZE</span>	32		<span class="enscript-comment">/* size of trace history */</span>

<span class="enscript-comment">/* For gdb */</span>
__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> nddr_trace_hist_size = NDDR_TRACE_HIST_SIZE;

<span class="enscript-type">struct</span> nd_defrouter_dbg {
	<span class="enscript-type">struct</span> nd_defrouter	nddr_dr;		<span class="enscript-comment">/* nd_defrouter */</span>
	uint16_t		nddr_refhold_cnt;	<span class="enscript-comment">/* # of ref */</span>
	uint16_t		nddr_refrele_cnt;	<span class="enscript-comment">/* # of rele */</span>
	<span class="enscript-comment">/*
	 * Circular lists of ndpr_addref and ndpr_remref callers.
	 */</span>
	ctrace_t		nddr_refhold[NDDR_TRACE_HIST_SIZE];
	ctrace_t		nddr_refrele[NDDR_TRACE_HIST_SIZE];
};

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> nddr_debug;			<span class="enscript-comment">/* debug flags */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> nddr_size;			<span class="enscript-comment">/* size of zone element */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *nddr_zone;			<span class="enscript-comment">/* zone for nd_defrouter */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NDDR_ZONE_MAX</span>	64			<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NDDR_ZONE_NAME</span>	<span class="enscript-string">&quot;nd6_defrouter&quot;</span>		<span class="enscript-comment">/* zone name */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ndprtr_size;		<span class="enscript-comment">/* size of zone element */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *ndprtr_zone;		<span class="enscript-comment">/* zone for nd_pfxrouter */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NDPRTR_ZONE_MAX</span>	64			<span class="enscript-comment">/* maximum elements in zone */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NDPRTR_ZONE_NAME</span> <span class="enscript-string">&quot;nd6_pfxrouter&quot;</span>	<span class="enscript-comment">/* zone name */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_rtr_init</span>(<span class="enscript-type">void</span>)
{
	PE_parse_boot_argn(<span class="enscript-string">&quot;ifa_debug&quot;</span>, &amp;ndpr_debug, <span class="enscript-keyword">sizeof</span> (ndpr_debug));
	PE_parse_boot_argn(<span class="enscript-string">&quot;ifa_debug&quot;</span>, &amp;nddr_debug, <span class="enscript-keyword">sizeof</span> (nddr_debug));

	ndpr_size = (ndpr_debug == 0) ? <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nd_prefix) :
	    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nd_prefix_dbg);
	ndpr_zone = zinit(ndpr_size, NDPR_ZONE_MAX * ndpr_size, 0,
	    NDPR_ZONE_NAME);
	<span class="enscript-keyword">if</span> (ndpr_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__, NDPR_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(ndpr_zone, Z_EXPAND, TRUE);
	zone_change(ndpr_zone, Z_CALLERACCT, FALSE);

	nddr_size = (nddr_debug == 0) ? <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nd_defrouter) :
	    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nd_defrouter_dbg);
	nddr_zone = zinit(nddr_size, NDDR_ZONE_MAX * nddr_size, 0,
	    NDDR_ZONE_NAME);
	<span class="enscript-keyword">if</span> (nddr_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__, NDDR_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(nddr_zone, Z_EXPAND, TRUE);
	zone_change(nddr_zone, Z_CALLERACCT, FALSE);

	ndprtr_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nd_pfxrouter);
	ndprtr_zone = zinit(ndprtr_size, NDPRTR_ZONE_MAX * ndprtr_size, 0,
	    NDPRTR_ZONE_NAME);
	<span class="enscript-keyword">if</span> (ndprtr_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: failed allocating %s&quot;</span>, __func__, NDPRTR_ZONE_NAME);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(ndprtr_zone, Z_EXPAND, TRUE);
	zone_change(ndprtr_zone, Z_CALLERACCT, FALSE);
}

<span class="enscript-comment">/*
 * Receive Router Solicitation Message - just for routers.
 * Router solicitation/advertisement is mostly managed by userland program
 * (rtadvd) so here we have no function like nd6_ra_output().
 *
 * Based on RFC 2461
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_rs_input</span>(
	<span class="enscript-type">struct</span>	mbuf *m,
	<span class="enscript-type">int</span> off,
	<span class="enscript-type">int</span> icmp6len)
{
	<span class="enscript-type">struct</span> ifnet *ifp = m-&gt;m_pkthdr.rcvif;
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	<span class="enscript-type">struct</span> nd_router_solicit *nd_rs;
	<span class="enscript-type">struct</span> in6_addr saddr6 = ip6-&gt;ip6_src;
	<span class="enscript-type">char</span> *lladdr = NULL;
	<span class="enscript-type">int</span> lladdrlen = 0;
	<span class="enscript-type">union</span> nd_opts ndopts;

	<span class="enscript-comment">/* Expect 32-bit aligned data pointer on strict-align platforms */</span>
	MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

	<span class="enscript-comment">/* If I'm not a router, ignore it. */</span>
	<span class="enscript-keyword">if</span> (!ip6_forwarding || !(ifp-&gt;if_eflags &amp; IFEF_IPV6_ROUTER))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;

	<span class="enscript-comment">/* Sanity checks */</span>
	<span class="enscript-keyword">if</span> (ip6-&gt;ip6_hlim != 255) {
		nd6log((LOG_ERR,
		    <span class="enscript-string">&quot;nd6_rs_input: invalid hlim (%d) from %s to %s on %s\n&quot;</span>,
		    ip6-&gt;ip6_hlim, ip6_sprintf(&amp;ip6-&gt;ip6_src),
		    ip6_sprintf(&amp;ip6-&gt;ip6_dst), if_name(ifp)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/*
	 * Don't update the neighbor cache, if src = :: or a non-neighbor.
	 * The former case indicates that the src has no IP address assigned
	 * yet.  See nd6_ns_input() for the latter case.
	 */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;ip6-&gt;ip6_src)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> sockaddr_in6 src_sa6;

		bzero(&amp;src_sa6, <span class="enscript-keyword">sizeof</span> (src_sa6));
		src_sa6.sin6_family = AF_INET6;
		src_sa6.sin6_len = <span class="enscript-keyword">sizeof</span> (src_sa6);
		src_sa6.sin6_addr = ip6-&gt;ip6_src;
		<span class="enscript-keyword">if</span> (!nd6_is_addr_neighbor(&amp;src_sa6, ifp, 0)) {
			nd6log((LOG_INFO, <span class="enscript-string">&quot;nd6_rs_input: &quot;</span>
				<span class="enscript-string">&quot;RS packet from non-neighbor\n&quot;</span>));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
		}
	}

	IP6_EXTHDR_CHECK(m, off, icmp6len, <span class="enscript-keyword">return</span>);
	nd_rs = (<span class="enscript-type">struct</span> nd_router_solicit *)((caddr_t)ip6 + off);
	icmp6len -= <span class="enscript-keyword">sizeof</span> (*nd_rs);
	nd6_option_init(nd_rs + 1, icmp6len, &amp;ndopts);
	<span class="enscript-keyword">if</span> (nd6_options(&amp;ndopts) &lt; 0) {
		nd6log((LOG_INFO,
		    <span class="enscript-string">&quot;nd6_rs_input: invalid ND option, ignored\n&quot;</span>));
		<span class="enscript-comment">/* nd6_options have incremented stats */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}

	<span class="enscript-keyword">if</span> (ndopts.nd_opts_src_lladdr) {
		lladdr = (<span class="enscript-type">char</span> *)(ndopts.nd_opts_src_lladdr + 1);
		lladdrlen = ndopts.nd_opts_src_lladdr-&gt;nd_opt_len &lt;&lt; 3;
	}

	<span class="enscript-keyword">if</span> (lladdr &amp;&amp; ((ifp-&gt;if_addrlen + 2 + 7) &amp; ~7) != lladdrlen) {
		nd6log((LOG_INFO,
		    <span class="enscript-string">&quot;nd6_rs_input: lladdrlen mismatch for %s &quot;</span>
		    <span class="enscript-string">&quot;(if %d, RS packet %d)\n&quot;</span>,
			ip6_sprintf(&amp;saddr6), ifp-&gt;if_addrlen, lladdrlen - 2));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	nd6_cache_lladdr(ifp, &amp;saddr6, lladdr, lladdrlen, ND_ROUTER_SOLICIT, 0);

<span class="enscript-reference">freeit</span>:
	m_freem(m);
	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">bad</span>:
	icmp6stat.icp6s_badrs++;
	m_freem(m);
}

<span class="enscript-comment">/*
 * Receive Router Advertisement Message.
 *
 * Based on RFC 2461
 * TODO: on-link bit on prefix information
 * TODO: ND_RA_FLAG_{OTHER,MANAGED} processing
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_ra_input</span>(
	<span class="enscript-type">struct</span>	mbuf *m,
	<span class="enscript-type">int</span> off,
	<span class="enscript-type">int</span> icmp6len)
{
	<span class="enscript-type">struct</span> ifnet *ifp = m-&gt;m_pkthdr.rcvif;
	<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	<span class="enscript-type">struct</span> nd_router_advert *nd_ra;
	<span class="enscript-type">struct</span> in6_addr saddr6 = ip6-&gt;ip6_src;
	<span class="enscript-type">int</span> mcast = 0;
	<span class="enscript-type">union</span> nd_opts ndopts;
	<span class="enscript-type">struct</span> nd_defrouter *dr = NULL;
	u_int32_t mtu = 0;
	<span class="enscript-type">char</span> *lladdr = NULL;
	u_int32_t lladdrlen = 0;
	<span class="enscript-type">struct</span> nd_prefix_list *nd_prefix_list_head = NULL;
	u_int32_t nd_prefix_list_length = 0;
	<span class="enscript-type">struct</span> in6_ifaddr *ia6 = NULL;
	<span class="enscript-type">struct</span> nd_prefix_list *prfl;
	<span class="enscript-type">struct</span> nd_defrouter dr0;
	u_int32_t advreachable;


	<span class="enscript-comment">/* Expect 32-bit aligned data pointer on strict-align platforms */</span>
	MBUF_STRICT_DATA_ALIGNMENT_CHECK_32(m);

	<span class="enscript-comment">/*
	 * Discard RA unless IFEF_ACCEPT_RTADV is set (as host), or when
	 * IFEF_IPV6_ROUTER is set (as router) but the RA is not locally
	 * generated.  For convenience, we allow locally generated (rtadvd)
	 * RAs to be processed on the advertising interface, as a router.
	 *
	 * Note that we don't test against ip6_forwarding as we could be
	 * both a host and a router on different interfaces, hence the
	 * check against the per-interface flags.
	 */</span>
	<span class="enscript-keyword">if</span> (!(ifp-&gt;if_eflags &amp; (IFEF_ACCEPT_RTADV | IFEF_IPV6_ROUTER)) ||
	    ((ifp-&gt;if_eflags &amp; IFEF_IPV6_ROUTER) &amp;&amp;
	    (ia6 = ifa_foraddr6(&amp;saddr6)) == NULL))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;

	<span class="enscript-keyword">if</span> (ia6 != NULL) {
		IFA_REMREF(&amp;ia6-&gt;ia_ifa);
		ia6 = NULL;
	}

	<span class="enscript-keyword">if</span> (ip6-&gt;ip6_hlim != 255) {
		nd6log((LOG_ERR,
		    <span class="enscript-string">&quot;nd6_ra_input: invalid hlim (%d) from %s to %s on %s\n&quot;</span>,
		    ip6-&gt;ip6_hlim, ip6_sprintf(&amp;ip6-&gt;ip6_src),
		    ip6_sprintf(&amp;ip6-&gt;ip6_dst), if_name(ifp)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_LINKLOCAL(&amp;saddr6)) {
		nd6log((LOG_ERR,
		    <span class="enscript-string">&quot;nd6_ra_input: src %s is not link-local\n&quot;</span>,
		    ip6_sprintf(&amp;saddr6)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	IP6_EXTHDR_CHECK(m, off, icmp6len, <span class="enscript-keyword">return</span>);
	nd_ra = (<span class="enscript-type">struct</span> nd_router_advert *)((caddr_t)ip6 + off);

	icmp6len -= <span class="enscript-keyword">sizeof</span> (*nd_ra);
	nd6_option_init(nd_ra + 1, icmp6len, &amp;ndopts);
	<span class="enscript-keyword">if</span> (nd6_options(&amp;ndopts) &lt; 0) {
		nd6log((LOG_INFO,
		    <span class="enscript-string">&quot;nd6_ra_input: invalid ND option, ignored\n&quot;</span>));
		<span class="enscript-comment">/* nd6_options have incremented stats */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
	}

	advreachable = nd_ra-&gt;nd_ra_reachable;

	<span class="enscript-comment">/* remember if this is a multicasted advertisement */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;ip6-&gt;ip6_dst))
		mcast = 1;

	ndi = ND_IFINFO(ifp);
	VERIFY((NULL != ndi) &amp;&amp; (TRUE == ndi-&gt;initialized));
	lck_mtx_lock(&amp;ndi-&gt;lock);
	bzero(&amp;dr0, <span class="enscript-keyword">sizeof</span> (dr0));
	dr0.rtaddr = saddr6;
	dr0.flags  = nd_ra-&gt;nd_ra_flags_reserved;
	dr0.rtlifetime = ntohs(nd_ra-&gt;nd_ra_router_lifetime);
	dr0.expire = net_uptime() + dr0.rtlifetime;
	dr0.ifp = ifp;
	<span class="enscript-comment">/* unspecified or not? (RFC 2461 6.3.4) */</span>
	<span class="enscript-keyword">if</span> (advreachable) {
		advreachable = ntohl(advreachable);
		<span class="enscript-keyword">if</span> (advreachable &lt;= MAX_REACHABLE_TIME &amp;&amp;
		    ndi-&gt;basereachable != advreachable) {
			ndi-&gt;basereachable = advreachable;
			ndi-&gt;reachable = ND_COMPUTE_RTIME(ndi-&gt;basereachable);
			ndi-&gt;recalctm = nd6_recalc_reachtm_interval; <span class="enscript-comment">/* reset */</span>
		}
	}
	<span class="enscript-keyword">if</span> (nd_ra-&gt;nd_ra_retransmit)
		ndi-&gt;retrans = ntohl(nd_ra-&gt;nd_ra_retransmit);
	<span class="enscript-keyword">if</span> (nd_ra-&gt;nd_ra_curhoplimit) {
		<span class="enscript-keyword">if</span> (ndi-&gt;chlim &lt; nd_ra-&gt;nd_ra_curhoplimit) {
			ndi-&gt;chlim = nd_ra-&gt;nd_ra_curhoplimit;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ndi-&gt;chlim != nd_ra-&gt;nd_ra_curhoplimit) {
			nd6log((LOG_ERR,
			    <span class="enscript-string">&quot;RA with a lower CurHopLimit sent from &quot;</span>
			    <span class="enscript-string">&quot;%s on %s (current = %d, received = %d). &quot;</span>
			    <span class="enscript-string">&quot;Ignored.\n&quot;</span>, ip6_sprintf(&amp;ip6-&gt;ip6_src),
			    if_name(ifp), ndi-&gt;chlim,
			    nd_ra-&gt;nd_ra_curhoplimit));
		}
	}
	lck_mtx_unlock(&amp;ndi-&gt;lock);
	lck_mtx_lock(nd6_mutex);
	dr = defrtrlist_update(&amp;dr0);
	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-comment">/*
	 * prefix
	 */</span>
	<span class="enscript-keyword">if</span> (ndopts.nd_opts_pi) {
		<span class="enscript-type">struct</span> nd_opt_hdr *pt;
		<span class="enscript-type">struct</span> nd_opt_prefix_info *pi = NULL;
		<span class="enscript-type">struct</span> nd_prefix pr;

		<span class="enscript-keyword">for</span> (pt = (<span class="enscript-type">struct</span> nd_opt_hdr *)ndopts.nd_opts_pi;
		    pt &lt;= (<span class="enscript-type">struct</span> nd_opt_hdr *)ndopts.nd_opts_pi_end;
		    pt = (<span class="enscript-type">struct</span> nd_opt_hdr *)((caddr_t)pt +
		    (pt-&gt;nd_opt_len &lt;&lt; 3))) {
			<span class="enscript-keyword">if</span> (pt-&gt;nd_opt_type != ND_OPT_PREFIX_INFORMATION)
				<span class="enscript-keyword">continue</span>;
			pi = (<span class="enscript-type">struct</span> nd_opt_prefix_info *)pt;

			<span class="enscript-keyword">if</span> (pi-&gt;nd_opt_pi_len != 4) {
				nd6log((LOG_INFO,
				    <span class="enscript-string">&quot;nd6_ra_input: invalid option &quot;</span>
				    <span class="enscript-string">&quot;len %d for prefix information option, &quot;</span>
				    <span class="enscript-string">&quot;ignored\n&quot;</span>, pi-&gt;nd_opt_pi_len));
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">if</span> (128 &lt; pi-&gt;nd_opt_pi_prefix_len) {
				nd6log((LOG_INFO,
				    <span class="enscript-string">&quot;nd6_ra_input: invalid prefix &quot;</span>
				    <span class="enscript-string">&quot;len %d for prefix information option, &quot;</span>
				    <span class="enscript-string">&quot;ignored\n&quot;</span>, pi-&gt;nd_opt_pi_prefix_len));
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;pi-&gt;nd_opt_pi_prefix) ||
			    IN6_IS_ADDR_LINKLOCAL(&amp;pi-&gt;nd_opt_pi_prefix)) {
				nd6log((LOG_INFO,
				    <span class="enscript-string">&quot;%s: invalid prefix %s, ignored\n&quot;</span>,
				    __func__,
				    ip6_sprintf(&amp;pi-&gt;nd_opt_pi_prefix)));
				<span class="enscript-keyword">continue</span>;
			}

			bzero(&amp;pr, <span class="enscript-keyword">sizeof</span> (pr));
			lck_mtx_init(&amp;pr.ndpr_lock, ifa_mtx_grp, ifa_mtx_attr);
			NDPR_LOCK(&amp;pr);
			pr.ndpr_prefix.sin6_family = AF_INET6;
			pr.ndpr_prefix.sin6_len = <span class="enscript-keyword">sizeof</span> (pr.ndpr_prefix);
			pr.ndpr_prefix.sin6_addr = pi-&gt;nd_opt_pi_prefix;
			pr.ndpr_ifp = m-&gt;m_pkthdr.rcvif;

			pr.ndpr_raf_onlink = (pi-&gt;nd_opt_pi_flags_reserved &amp;
			    ND_OPT_PI_FLAG_ONLINK) ? 1 : 0;
			pr.ndpr_raf_auto = (pi-&gt;nd_opt_pi_flags_reserved &amp;
			    ND_OPT_PI_FLAG_AUTO) ? 1 : 0;
			pr.ndpr_plen = pi-&gt;nd_opt_pi_prefix_len;
			pr.ndpr_vltime = ntohl(pi-&gt;nd_opt_pi_valid_time);
			pr.ndpr_pltime =
				ntohl(pi-&gt;nd_opt_pi_preferred_time);

			<span class="enscript-comment">/*
			 * Exceptions to stateless autoconfiguration processing:
			 * + nd6_accept_6to4 == 0 &amp;&amp; address has 6to4 prefix
			 * + ip6_only_allow_rfc4193_prefix != 0 &amp;&amp;
			 * address not RFC 4193
			 */</span>
			<span class="enscript-keyword">if</span> (ip6_only_allow_rfc4193_prefix &amp;&amp;
			    !IN6_IS_ADDR_UNIQUE_LOCAL(&amp;pi-&gt;nd_opt_pi_prefix)) {
				nd6log((LOG_INFO,
				    <span class="enscript-string">&quot;nd6_ra_input: no SLAAC on prefix %s &quot;</span>
				    <span class="enscript-string">&quot;[not RFC 4193]\n&quot;</span>,
				    ip6_sprintf(&amp;pi-&gt;nd_opt_pi_prefix)));
				pr.ndpr_raf_auto = 0;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!nd6_accept_6to4 &amp;&amp;
			    IN6_IS_ADDR_6TO4(&amp;pi-&gt;nd_opt_pi_prefix)) {
				nd6log((LOG_INFO,
				    <span class="enscript-string">&quot;%s: no SLAAC on prefix %s &quot;</span>
				    <span class="enscript-string">&quot;[6to4]\n&quot;</span>, __func__,
				    ip6_sprintf(&amp;pi-&gt;nd_opt_pi_prefix)));
				pr.ndpr_raf_auto = 0;
			}

			<span class="enscript-keyword">if</span> (in6_init_prefix_ltimes(&amp;pr)) {
				NDPR_UNLOCK(&amp;pr);
				lck_mtx_destroy(&amp;pr.ndpr_lock, ifa_mtx_grp);
				<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* prefix lifetime init failed */</span>
			} <span class="enscript-keyword">else</span> {
				NDPR_UNLOCK(&amp;pr);
			}
			(<span class="enscript-type">void</span>) prelist_update(&amp;pr, dr, m, mcast);
			lck_mtx_destroy(&amp;pr.ndpr_lock, ifa_mtx_grp);

			<span class="enscript-comment">/*
			 * We have to copy the values out after the
			 * prelist_update call since some of these values won't
			 * be properly set until after the router advertisement
			 * updating can vet the values.
			 */</span>
			prfl = NULL;
			MALLOC(prfl, <span class="enscript-type">struct</span> nd_prefix_list *, <span class="enscript-keyword">sizeof</span> (*prfl),
			    M_TEMP, M_WAITOK | M_ZERO);

			<span class="enscript-keyword">if</span> (prfl == NULL) {
				log(LOG_DEBUG, <span class="enscript-string">&quot;%s: unable to MALLOC RA prefix &quot;</span>
				    <span class="enscript-string">&quot;structure\n&quot;</span>, __func__);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/* this is only for nd6_post_msg(), otherwise unused */</span>
			bcopy(&amp;pr.ndpr_prefix, &amp;prfl-&gt;pr.ndpr_prefix,
			    <span class="enscript-keyword">sizeof</span> (prfl-&gt;pr.ndpr_prefix));
			prfl-&gt;pr.ndpr_raf = pr.ndpr_raf;
			prfl-&gt;pr.ndpr_plen = pr.ndpr_plen;
			prfl-&gt;pr.ndpr_vltime = pr.ndpr_vltime;
			prfl-&gt;pr.ndpr_pltime = pr.ndpr_pltime;
			prfl-&gt;pr.ndpr_expire = pr.ndpr_expire;
			prfl-&gt;pr.ndpr_base_calendartime =
			    pr.ndpr_base_calendartime;
			prfl-&gt;pr.ndpr_base_uptime = pr.ndpr_base_uptime;
			prfl-&gt;pr.ndpr_stateflags = pr.ndpr_stateflags;
			prfl-&gt;pr.ndpr_addrcnt = pr.ndpr_addrcnt;
			prfl-&gt;pr.ndpr_ifp = pr.ndpr_ifp;

			prfl-&gt;next = nd_prefix_list_head;
			nd_prefix_list_head = prfl;
			nd_prefix_list_length++;
		}
	}

	<span class="enscript-comment">/*
	 * MTU
	 */</span>
	<span class="enscript-keyword">if</span> (ndopts.nd_opts_mtu &amp;&amp; ndopts.nd_opts_mtu-&gt;nd_opt_mtu_len == 1) {
		mtu = ntohl(ndopts.nd_opts_mtu-&gt;nd_opt_mtu_mtu);

		<span class="enscript-comment">/* lower bound */</span>
		<span class="enscript-keyword">if</span> (mtu &lt; IPV6_MMTU) {
			nd6log((LOG_INFO, <span class="enscript-string">&quot;nd6_ra_input: bogus mtu option &quot;</span>
			    <span class="enscript-string">&quot;mtu=%d sent from %s, ignoring\n&quot;</span>,
			    mtu, ip6_sprintf(&amp;ip6-&gt;ip6_src)));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip</span>;
		}

		lck_mtx_lock(&amp;ndi-&gt;lock);
		<span class="enscript-comment">/* upper bound */</span>
		<span class="enscript-keyword">if</span> (ndi-&gt;maxmtu) {
			<span class="enscript-keyword">if</span> (mtu &lt;= ndi-&gt;maxmtu) {
				<span class="enscript-type">int</span> change = (ndi-&gt;linkmtu != mtu);

				ndi-&gt;linkmtu = mtu;
				lck_mtx_unlock(&amp;ndi-&gt;lock);
				<span class="enscript-keyword">if</span> (change) <span class="enscript-comment">/* in6_maxmtu may change */</span>
					in6_setmaxmtu();
			} <span class="enscript-keyword">else</span> {
				nd6log((LOG_INFO, <span class="enscript-string">&quot;nd6_ra_input: bogus mtu &quot;</span>
				    <span class="enscript-string">&quot;mtu=%d sent from %s; &quot;</span>
				    <span class="enscript-string">&quot;exceeds maxmtu %d, ignoring\n&quot;</span>,
				    mtu, ip6_sprintf(&amp;ip6-&gt;ip6_src),
				    ndi-&gt;maxmtu));
				lck_mtx_unlock(&amp;ndi-&gt;lock);
			}
		} <span class="enscript-keyword">else</span> {
			lck_mtx_unlock(&amp;ndi-&gt;lock);
			nd6log((LOG_INFO, <span class="enscript-string">&quot;nd6_ra_input: mtu option &quot;</span>
			    <span class="enscript-string">&quot;mtu=%d sent from %s; maxmtu unknown, &quot;</span>
			    <span class="enscript-string">&quot;ignoring\n&quot;</span>,
			    mtu, ip6_sprintf(&amp;ip6-&gt;ip6_src)));
		}
	}

<span class="enscript-reference">skip</span>:

	<span class="enscript-comment">/*
	 * Source link layer address
	 */</span>
	<span class="enscript-keyword">if</span> (ndopts.nd_opts_src_lladdr) {
		lladdr = (<span class="enscript-type">char</span> *)(ndopts.nd_opts_src_lladdr + 1);
		lladdrlen = ndopts.nd_opts_src_lladdr-&gt;nd_opt_len &lt;&lt; 3;
	}

	<span class="enscript-keyword">if</span> (lladdr &amp;&amp; ((ifp-&gt;if_addrlen + 2 + 7) &amp; ~7) != lladdrlen) {
		nd6log((LOG_INFO,
		    <span class="enscript-string">&quot;nd6_ra_input: lladdrlen mismatch for %s &quot;</span>
		    <span class="enscript-string">&quot;(if %d, RA packet %d)\n&quot;</span>,
			ip6_sprintf(&amp;saddr6), ifp-&gt;if_addrlen, lladdrlen - 2));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	nd6_cache_lladdr(ifp, &amp;saddr6, lladdr, (<span class="enscript-type">int</span>)lladdrlen,
	    ND_ROUTER_ADVERT, 0);

	<span class="enscript-comment">/* Post message */</span>
	nd6_post_msg(KEV_ND6_RA, nd_prefix_list_head, nd_prefix_list_length,
	    mtu, lladdr, lladdrlen);

	<span class="enscript-comment">/*
	 * Installing a link-layer address might change the state of the
	 * router's neighbor cache, which might also affect our on-link
	 * detection of adveritsed prefixes.
	 */</span>
	lck_mtx_lock(nd6_mutex);
	pfxlist_onlink_check();
	lck_mtx_unlock(nd6_mutex);

<span class="enscript-reference">freeit</span>:
	m_freem(m);
	<span class="enscript-keyword">if</span> (dr)
		NDDR_REMREF(dr);

	prfl = NULL;
	<span class="enscript-keyword">while</span> ((prfl = nd_prefix_list_head) != NULL) {
		nd_prefix_list_head = prfl-&gt;next;
		FREE(prfl, M_TEMP);
	}

	<span class="enscript-keyword">return</span>;

<span class="enscript-reference">bad</span>:
	icmp6stat.icp6s_badra++;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">freeit</span>;
}

<span class="enscript-comment">/*
 * default router list proccessing sub routines
 */</span>

<span class="enscript-comment">/* tell the change to user processes watching the routing socket. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_rtmsg</span>(cmd, rt)
	<span class="enscript-type">int</span> cmd;
	<span class="enscript-type">struct</span> rtentry *rt;
{
	<span class="enscript-type">struct</span> rt_addrinfo info;
	<span class="enscript-type">struct</span> ifnet *ifp = rt-&gt;rt_ifp;

	RT_LOCK_ASSERT_HELD(rt);

	bzero((caddr_t)&amp;info, <span class="enscript-keyword">sizeof</span> (info));
	<span class="enscript-comment">/* It's not necessary to lock ifp for if_lladdr */</span>
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_GATEWAY] = rt-&gt;rt_gateway;
	info.rti_info[RTAX_NETMASK] = rt_mask(rt);
	<span class="enscript-comment">/*
	 * ifa_addr pointers for both should always be valid
	 * in this context; no need to hold locks.
	 */</span>
	info.rti_info[RTAX_IFP] = ifp-&gt;if_lladdr-&gt;ifa_addr;
	info.rti_info[RTAX_IFA] = rt-&gt;rt_ifa-&gt;ifa_addr;

	rt_missmsg(cmd, &amp;info, rt-&gt;rt_flags, 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">defrouter_addreq</span>(<span class="enscript-type">struct</span> nd_defrouter *new, boolean_t scoped)
{
	<span class="enscript-type">struct</span> sockaddr_in6 def, mask, gate;
	<span class="enscript-type">struct</span> rtentry *newrt = NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope;
	<span class="enscript-type">int</span> err;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_NOTOWNED);
	NDDR_LOCK_ASSERT_NOTHELD(new);
	<span class="enscript-comment">/*
	 * We're free to lock and unlock NDDR because our callers 
	 * are holding an extra reference for us.
	 */</span>

	NDDR_LOCK(new);
	<span class="enscript-keyword">if</span> (new-&gt;stateflags &amp; NDDRF_INSTALLED)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (new-&gt;ifp-&gt;if_eflags &amp; IFEF_IPV6_ROUTER) {
		nd6log2((LOG_INFO, <span class="enscript-string">&quot;%s: ignoring router %s, scoped=%d, &quot;</span>
		    <span class="enscript-string">&quot;static=%d on advertising interface\n&quot;</span>, if_name(new-&gt;ifp),
		    ip6_sprintf(&amp;new-&gt;rtaddr), scoped,
		    (new-&gt;stateflags &amp; NDDRF_STATIC) ? 1 : 0));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	nd6log2((LOG_INFO, <span class="enscript-string">&quot;%s: adding default router %s, scoped=%d, &quot;</span>
	    <span class="enscript-string">&quot;static=%d\n&quot;</span>, if_name(new-&gt;ifp), ip6_sprintf(&amp;new-&gt;rtaddr),
	    scoped, (new-&gt;stateflags &amp; NDDRF_STATIC) ? 1 : 0));

	Bzero(&amp;def, <span class="enscript-keyword">sizeof</span> (def));
	Bzero(&amp;mask, <span class="enscript-keyword">sizeof</span> (mask));
	Bzero(&amp;gate, <span class="enscript-keyword">sizeof</span> (gate));

	def.sin6_len = mask.sin6_len = gate.sin6_len
		= <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
	def.sin6_family = mask.sin6_family = gate.sin6_family = AF_INET6;
	gate.sin6_addr = new-&gt;rtaddr;

	ifscope = scoped ? new-&gt;ifp-&gt;if_index : IFSCOPE_NONE;
	NDDR_UNLOCK(new);

	err = rtrequest_scoped(RTM_ADD, (<span class="enscript-type">struct</span> sockaddr *)&amp;def,
	    (<span class="enscript-type">struct</span> sockaddr *)&amp;gate, (<span class="enscript-type">struct</span> sockaddr *)&amp;mask,
	    RTF_GATEWAY, &amp;newrt, ifscope);

	<span class="enscript-keyword">if</span> (newrt) {
		RT_LOCK(newrt);
		nd6_rtmsg(RTM_ADD, newrt); <span class="enscript-comment">/* tell user process */</span>
		RT_REMREF_LOCKED(newrt);
		RT_UNLOCK(newrt);
		NDDR_LOCK(new);
		new-&gt;stateflags |= NDDRF_INSTALLED;
		<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE)
			new-&gt;stateflags |= NDDRF_IFSCOPE;
		new-&gt;genid = nd6_defrouter_genid;
	} <span class="enscript-keyword">else</span> {
		nd6log((LOG_ERR, <span class="enscript-string">&quot;%s: failed to add default router &quot;</span>
		    <span class="enscript-string">&quot;%s on %s scoped %d (errno = %d)\n&quot;</span>, __func__,
		    ip6_sprintf(&amp;gate.sin6_addr), if_name(new-&gt;ifp),
		    (ifscope != IFSCOPE_NONE), err));
		NDDR_LOCK(new);
	}
	new-&gt;err = err;

<span class="enscript-reference">out</span>:
	NDDR_UNLOCK(new);
}

<span class="enscript-type">struct</span> nd_defrouter *
<span class="enscript-function-name">defrouter_lookup</span>(
	<span class="enscript-type">struct</span> in6_addr *addr,
	<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> nd_defrouter *dr;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">for</span> (dr = TAILQ_FIRST(&amp;nd_defrouter); dr;
	    dr = TAILQ_NEXT(dr, dr_entry)) {
		NDDR_LOCK(dr);
		<span class="enscript-keyword">if</span> (dr-&gt;ifp == ifp &amp;&amp; IN6_ARE_ADDR_EQUAL(addr, &amp;dr-&gt;rtaddr)) {
			NDDR_ADDREF_LOCKED(dr);
			NDDR_UNLOCK(dr);
			<span class="enscript-keyword">return</span> (dr);
		}
		NDDR_UNLOCK(dr);
	}

	<span class="enscript-keyword">return</span> (NULL);		<span class="enscript-comment">/* search failed */</span>
}

<span class="enscript-comment">/*
 * Remove the default route for a given router.
 * This is just a subroutine function for defrouter_select(), and should
 * not be called from anywhere else.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">defrouter_delreq</span>(<span class="enscript-type">struct</span> nd_defrouter *dr)
{
	<span class="enscript-type">struct</span> sockaddr_in6 def, mask, gate;
	<span class="enscript-type">struct</span> rtentry *oldrt = NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope;
	<span class="enscript-type">int</span> err;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_NOTOWNED);
	NDDR_LOCK_ASSERT_NOTHELD(dr);
	<span class="enscript-comment">/*
	 * We're free to lock and unlock NDDR because our callers 
	 * are holding an extra reference for us.
	 */</span>
	NDDR_LOCK(dr);
	<span class="enscript-comment">/* ifp would be NULL for the &quot;drany&quot; case */</span>
	<span class="enscript-keyword">if</span> (dr-&gt;ifp != NULL &amp;&amp; !(dr-&gt;stateflags &amp; NDDRF_INSTALLED))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	nd6log2((LOG_INFO, <span class="enscript-string">&quot;%s: removing default router %s, scoped=%d, &quot;</span>
	    <span class="enscript-string">&quot;static=%d\n&quot;</span>, dr-&gt;ifp != NULL ? if_name(dr-&gt;ifp) : <span class="enscript-string">&quot;ANY&quot;</span>,
	    ip6_sprintf(&amp;dr-&gt;rtaddr), (dr-&gt;stateflags &amp; NDDRF_IFSCOPE) ? 1 : 0,
	    (dr-&gt;stateflags &amp; NDDRF_STATIC) ? 1 : 0));

	Bzero(&amp;def, <span class="enscript-keyword">sizeof</span> (def));
	Bzero(&amp;mask, <span class="enscript-keyword">sizeof</span> (mask));
	Bzero(&amp;gate, <span class="enscript-keyword">sizeof</span> (gate));

	def.sin6_len = mask.sin6_len = gate.sin6_len
		= <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
	def.sin6_family = mask.sin6_family = gate.sin6_family = AF_INET6;
	gate.sin6_addr = dr-&gt;rtaddr;

	<span class="enscript-keyword">if</span> (dr-&gt;ifp != NULL) {
		ifscope = (dr-&gt;stateflags &amp; NDDRF_IFSCOPE) ?
		    dr-&gt;ifp-&gt;if_index : IFSCOPE_NONE;
	} <span class="enscript-keyword">else</span> {
		ifscope = IFSCOPE_NONE;
	}
	NDDR_UNLOCK(dr);
	err = rtrequest_scoped(RTM_DELETE,
	    (<span class="enscript-type">struct</span> sockaddr *)&amp;def, (<span class="enscript-type">struct</span> sockaddr *)&amp;gate,
	    (<span class="enscript-type">struct</span> sockaddr *)&amp;mask, RTF_GATEWAY, &amp;oldrt, ifscope);

	<span class="enscript-keyword">if</span> (oldrt) {
		RT_LOCK(oldrt);
		nd6_rtmsg(RTM_DELETE, oldrt);
		RT_UNLOCK(oldrt);
		rtfree(oldrt);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (err != ESRCH) {
		nd6log((LOG_ERR, <span class="enscript-string">&quot;%s: failed to delete default router &quot;</span>
		    <span class="enscript-string">&quot;%s on %s scoped %d (errno = %d)\n&quot;</span>, __func__,
		    ip6_sprintf(&amp;gate.sin6_addr), dr-&gt;ifp != NULL ?
		    if_name(dr-&gt;ifp) : <span class="enscript-string">&quot;ANY&quot;</span>, (ifscope != IFSCOPE_NONE), err));
	}
	NDDR_LOCK(dr);
	<span class="enscript-comment">/* ESRCH means it's no longer in the routing table; ignore it */</span>
	<span class="enscript-keyword">if</span> (oldrt != NULL || err == ESRCH) {
		dr-&gt;stateflags &amp;= ~NDDRF_INSTALLED;
		<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE)
			dr-&gt;stateflags &amp;= ~NDDRF_IFSCOPE;
	}
	dr-&gt;err = 0;
<span class="enscript-reference">out</span>:
	NDDR_UNLOCK(dr);
}


<span class="enscript-comment">/*
 * remove all default routes from default router list
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">defrouter_reset</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> nd_defrouter *dr, drany;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);

	dr = TAILQ_FIRST(&amp;nd_defrouter);
	<span class="enscript-keyword">while</span> (dr) {
		NDDR_LOCK(dr);
		<span class="enscript-keyword">if</span> (dr-&gt;stateflags &amp; NDDRF_INSTALLED) {
			NDDR_ADDREF_LOCKED(dr);
			NDDR_UNLOCK(dr);
			lck_mtx_unlock(nd6_mutex);
			defrouter_delreq(dr);
			lck_mtx_lock(nd6_mutex);
			NDDR_REMREF(dr);
			dr = TAILQ_FIRST(&amp;nd_defrouter);
		} <span class="enscript-keyword">else</span> {
			NDDR_UNLOCK(dr);
			dr = TAILQ_NEXT(dr, dr_entry);
		}
	}

	<span class="enscript-comment">/* Nuke primary (non-scoped) default router */</span>
	<span class="enscript-keyword">if</span> (ip6_doscopedroute) {
		bzero(&amp;drany, <span class="enscript-keyword">sizeof</span> (drany));
		lck_mtx_init(&amp;drany.nddr_lock, ifa_mtx_grp, ifa_mtx_attr);
		lck_mtx_unlock(nd6_mutex);
		defrouter_delreq(&amp;drany);
		lck_mtx_destroy(&amp;drany.nddr_lock, ifa_mtx_grp);
		lck_mtx_lock(nd6_mutex);
	}

}

<span class="enscript-type">int</span>
<span class="enscript-function-name">defrtrlist_ioctl</span>(u_long cmd, caddr_t data)
{
	<span class="enscript-type">struct</span> nd_defrouter dr0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifindex;
	<span class="enscript-type">struct</span> ifnet *dr_ifp;
	<span class="enscript-type">int</span> error = 0, add = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDRADD_IN6_32</span>:		<span class="enscript-comment">/* struct in6_defrouter_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDRADD_IN6_64</span>:		<span class="enscript-comment">/* struct in6_defrouter_64 */</span>
		++add;
		<span class="enscript-comment">/* FALLTHRU */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDRDEL_IN6_32</span>:		<span class="enscript-comment">/* struct in6_defrouter_32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCDRDEL_IN6_64</span>:		<span class="enscript-comment">/* struct in6_defrouter_64 */</span>
		bzero(&amp;dr0, <span class="enscript-keyword">sizeof</span> (dr0));
		<span class="enscript-keyword">if</span> (cmd == SIOCDRADD_IN6_64 || cmd == SIOCDRDEL_IN6_64) {
			<span class="enscript-type">struct</span> in6_defrouter_64 *r_64 =
			    (<span class="enscript-type">struct</span> in6_defrouter_64 *)(<span class="enscript-type">void</span> *)data;
			u_int16_t i;

			bcopy(&amp;r_64-&gt;rtaddr.sin6_addr, &amp;dr0.rtaddr,
			    <span class="enscript-keyword">sizeof</span> (dr0.rtaddr));
			dr0.flags = r_64-&gt;flags;
			bcopy(&amp;r_64-&gt;if_index, &amp;i, <span class="enscript-keyword">sizeof</span> (i));
			ifindex = i;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> in6_defrouter_32 *r_32 =
			    (<span class="enscript-type">struct</span> in6_defrouter_32 *)(<span class="enscript-type">void</span> *)data;
			u_int16_t i;

			bcopy(&amp;r_32-&gt;rtaddr.sin6_addr, &amp;dr0.rtaddr,
			    <span class="enscript-keyword">sizeof</span> (dr0.rtaddr));
			dr0.flags = r_32-&gt;flags;
			bcopy(&amp;r_32-&gt;if_index, &amp;i, <span class="enscript-keyword">sizeof</span> (i));
			ifindex = i;
		}
		ifnet_head_lock_shared();
		<span class="enscript-comment">/* Don't need to check is ifindex is &lt; 0 since it's unsigned */</span>
		<span class="enscript-keyword">if</span> (if_index &lt; ifindex ||
		    (dr_ifp = ifindex2ifnet[ifindex]) == NULL) {
			ifnet_head_done();
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		dr0.ifp = dr_ifp;
		ifnet_head_done();

		<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_EMBED(&amp;dr0.rtaddr)) {
			uint16_t *scope = &amp;dr0.rtaddr.s6_addr16[1];

			<span class="enscript-keyword">if</span> (*scope == 0) {
				*scope = htons(dr_ifp-&gt;if_index);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*scope != htons(dr_ifp-&gt;if_index)) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> (add)
			error = defrtrlist_add_static(&amp;dr0);
		<span class="enscript-keyword">if</span> (!add || error != 0) {
			<span class="enscript-type">int</span> err = defrtrlist_del_static(&amp;dr0);
			<span class="enscript-keyword">if</span> (!add)
				error = err;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = EOPNOTSUPP; <span class="enscript-comment">/* check for safety */</span>
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">defrtrlist_del</span>(<span class="enscript-type">struct</span> nd_defrouter *dr)
{
	<span class="enscript-type">struct</span> nd_defrouter *deldr = NULL;
	<span class="enscript-type">struct</span> nd_prefix *pr;
	<span class="enscript-type">struct</span> ifnet *ifp = dr-&gt;ifp;
	<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;
	boolean_t resetmtu;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (!ip6_doscopedroute &amp;&amp; dr == TAILQ_FIRST(&amp;nd_defrouter))
		deldr = dr;	<span class="enscript-comment">/* The router is primary. */</span>

	TAILQ_REMOVE(&amp;nd_defrouter, dr, dr_entry);
	++nd6_defrouter_genid;
	<span class="enscript-comment">/*
	 * Flush all the routing table entries that use the router
	 * as a next hop.
	 */</span>
	<span class="enscript-keyword">if</span> (ip6_doscopedroute || !ip6_forwarding) {
		<span class="enscript-comment">/* above is a good condition? */</span>
		NDDR_ADDREF(dr);
		lck_mtx_unlock(nd6_mutex);
		rt6_flush(&amp;dr-&gt;rtaddr, ifp);
		lck_mtx_lock(nd6_mutex);
		NDDR_REMREF(dr);
	}
	nd6log2((LOG_INFO, <span class="enscript-string">&quot;%s: freeing defrouter %s\n&quot;</span>, if_name(dr-&gt;ifp),
	    ip6_sprintf(&amp;dr-&gt;rtaddr)));
	<span class="enscript-comment">/*
	 * Delete it from the routing table.
	 */</span>
	NDDR_ADDREF(dr);
	lck_mtx_unlock(nd6_mutex);
	defrouter_delreq(dr);
	lck_mtx_lock(nd6_mutex);
	NDDR_REMREF(dr);

	<span class="enscript-comment">/*
	 * Also delete all the pointers to the router in each prefix lists.
	 */</span>
	<span class="enscript-keyword">for</span> (pr = nd_prefix.lh_first; pr; pr = pr-&gt;ndpr_next) {
		<span class="enscript-type">struct</span> nd_pfxrouter *pfxrtr;

		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> ((pfxrtr = pfxrtr_lookup(pr, dr)) != NULL)
			pfxrtr_del(pfxrtr, pr);
		NDPR_UNLOCK(pr);
	}

	pfxlist_onlink_check();

	<span class="enscript-comment">/*
	 * If the router is the primary one, choose a new one.  If Scoped
	 * Routing is enabled, always try to pick another eligible router
	 * on this interface.
	 */</span>
	<span class="enscript-keyword">if</span> (deldr || ip6_doscopedroute)
		defrouter_select(ifp);

	resetmtu = FALSE;
	ndi = ND_IFINFO(ifp);
	VERIFY((NULL != ndi) &amp;&amp; (TRUE == ndi-&gt;initialized));
	lck_mtx_lock(&amp;ndi-&gt;lock);
	VERIFY(ndi-&gt;ndefrouters &gt;= 0);
	<span class="enscript-keyword">if</span> (ndi-&gt;ndefrouters &gt; 0 &amp;&amp; --ndi-&gt;ndefrouters == 0) {
		nd6_ifreset(ifp);
		resetmtu = TRUE;
	}
	lck_mtx_unlock(&amp;ndi-&gt;lock);

	<span class="enscript-keyword">if</span> (resetmtu)
		nd6_setmtu(ifp);

	NDDR_REMREF(dr);	<span class="enscript-comment">/* remove list reference */</span>
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">defrtrlist_add_static</span>(<span class="enscript-type">struct</span> nd_defrouter *new)
{
	<span class="enscript-type">struct</span> nd_defrouter *dr;
	<span class="enscript-type">int</span> err = 0;

	new-&gt;rtlifetime = -1;
	new-&gt;stateflags |= NDDRF_STATIC;

	<span class="enscript-comment">/* we only want the preference level */</span>
	new-&gt;flags &amp;= ND_RA_FLAG_RTPREF_MASK;

	lck_mtx_lock(nd6_mutex);
	dr = defrouter_lookup(&amp;new-&gt;rtaddr, new-&gt;ifp);
	<span class="enscript-keyword">if</span> (dr != NULL &amp;&amp; !(dr-&gt;stateflags &amp; NDDRF_STATIC)) {
		err = EINVAL;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (dr != NULL)
			NDDR_REMREF(dr);
		dr = defrtrlist_update(new);
		<span class="enscript-keyword">if</span> (dr != NULL)
			err = dr-&gt;err;
		<span class="enscript-keyword">else</span>
			err = ENOMEM;
	}
	<span class="enscript-keyword">if</span> (dr != NULL)
		NDDR_REMREF(dr);
	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">defrtrlist_del_static</span>(<span class="enscript-type">struct</span> nd_defrouter *new)
{
	<span class="enscript-type">struct</span> nd_defrouter *dr;

	lck_mtx_lock(nd6_mutex);
	dr = defrouter_lookup(&amp;new-&gt;rtaddr, new-&gt;ifp);
	<span class="enscript-keyword">if</span> (dr == NULL || !(dr-&gt;stateflags &amp; NDDRF_STATIC)) {
		<span class="enscript-keyword">if</span> (dr != NULL)
			NDDR_REMREF(dr);
		dr = NULL;
	} <span class="enscript-keyword">else</span> {
		defrtrlist_del(dr);
		NDDR_REMREF(dr);
	}
	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-keyword">return</span> (dr != NULL ? 0 : EINVAL);
}

<span class="enscript-comment">/*
 * for default router selection
 * regards router-preference field as a 2-bit signed integer
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rtpref</span>(<span class="enscript-type">struct</span> nd_defrouter *dr)
{
	<span class="enscript-keyword">switch</span> (dr-&gt;flags &amp; ND_RA_FLAG_RTPREF_MASK) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_RA_FLAG_RTPREF_HIGH</span>:
		<span class="enscript-keyword">return</span> (RTPREF_HIGH);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_RA_FLAG_RTPREF_MEDIUM</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_RA_FLAG_RTPREF_RSV</span>:
		<span class="enscript-keyword">return</span> (RTPREF_MEDIUM);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ND_RA_FLAG_RTPREF_LOW</span>:
		<span class="enscript-keyword">return</span> (RTPREF_LOW);
	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/*
		 * This case should never happen.  If it did, it would mean a
		 * serious bug of kernel internal.  We thus always bark here.
		 * Or, can we even panic?
		 */</span>
		log(LOG_ERR, <span class="enscript-string">&quot;rtpref: impossible RA flag %x\n&quot;</span>, dr-&gt;flags);
		<span class="enscript-keyword">return</span> (RTPREF_INVALID);
	}
	<span class="enscript-comment">/* NOTREACHED */</span>
}

<span class="enscript-comment">/*
 * Default Router Selection according to Section 6.3.6 of RFC 2461 and RFC 4191:
 *
 * 1) Routers that are reachable or probably reachable should be preferred.
 *    If we have more than one (probably) reachable router, prefer ones
 *    with the highest router preference.
 * 2) When no routers on the list are known to be reachable or
 *    probably reachable, routers SHOULD be selected in a round-robin
 *    fashion, regardless of router preference values.
 * 3) If the Default Router List is empty, assume that all
 *    destinations are on-link.
 *
 * When Scoped Routing is enabled, the selection logic is amended as follows:
 *
 * a) When a default interface is specified, the primary/non-scoped default
 *    router will be set to the reachable router on that link (if any) with
 *    the highest router preference.
 * b) When there are more than one routers on the same link, the one with
 *    the highest router preference will be installed, either as scoped or
 *    non-scoped route entry.  If they all share the same preference value,
 *    the one installed will be the static or the first encountered reachable
 *    router, i.e. static one wins over dynamic.
 * c) When no routers on the list are known to be reachable, or probably
 *    reachable, no round-robin selection will take place when the default
 *    interface is set.
 *
 * We assume nd_defrouter is sorted by router preference value.
 * Since the code below covers both with and without router preference cases,
 * we do not need to classify the cases by ifdef.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">defrouter_select</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ifp</span>)
	<span class="enscript-type">struct</span> nd_defrouter *dr, *selected_dr = NULL, *installed_dr = NULL;
	<span class="enscript-type">struct</span> nd_defrouter *installed_dr0 = NULL;
	<span class="enscript-type">struct</span> rtentry *rt = NULL;
	<span class="enscript-type">struct</span> llinfo_nd6 *ln = NULL;
	<span class="enscript-type">int</span>  update = 0;
	boolean_t found_installedrt = FALSE;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/*
	 * We no longer install (default) interface route; only prefix routes
	 * are installed as interface routes.  Therefore, there is no harm in
	 * going through this routine even if a default interface is specified,
	 * which happens when Scoped Routing is enabled.  But for efficiency,
	 * we fall back to the original KAME logic when Scoped Routing is
	 * not in effect.
	 */</span>
	<span class="enscript-keyword">if</span> (ip6_forwarding &amp;&amp; !ip6_doscopedroute) {
		nd6log((LOG_WARNING,
		    <span class="enscript-string">&quot;defrouter_select: called unexpectedly (forwarding=%d)\n&quot;</span>,
		    ip6_forwarding));
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * Let's handle easy case (3) first:
	 * If default router list is empty, there's nothing to be done.
	 */</span>
	<span class="enscript-keyword">if</span> (!TAILQ_FIRST(&amp;nd_defrouter))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * Due to the number of times we drop nd6_mutex, we need to
	 * serialize this function.
	 */</span>
	<span class="enscript-keyword">while</span> (nd_defrouter_busy) {
		nd_defrouter_waiters++;
		msleep(nd_defrouter_waitchan, nd6_mutex, (PZERO-1),
		    __func__, NULL);
		lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);
	}
	nd_defrouter_busy = TRUE;

	<span class="enscript-comment">/*
	 * Search for a (probably) reachable router from the list.
	 * We just pick up the first reachable one (if any), assuming that
	 * the ordering rule of the list described in defrtrlist_update().
	 *
	 * For all intents and purposes of Scoped Routing:
	 *	selected_dr	= candidate for primary router
	 *	installed_dr	= currently installed primary router
	 */</span>
	<span class="enscript-keyword">for</span> (dr = TAILQ_FIRST(&amp;nd_defrouter); dr;
	    dr = TAILQ_NEXT(dr, dr_entry)) {
		boolean_t reachable, advrouter;
		<span class="enscript-type">struct</span> in6_addr rtaddr;
		<span class="enscript-type">struct</span> ifnet *drifp;
		<span class="enscript-type">struct</span> nd_defrouter *drrele;

		drrele = NULL;
		reachable = FALSE;
		NDDR_LOCK(dr);
		rtaddr = *(&amp;dr-&gt;rtaddr);
		drifp = dr-&gt;ifp;
		advrouter = (drifp != NULL &amp;&amp;
		    (drifp-&gt;if_eflags &amp; IFEF_IPV6_ROUTER));
		NDDR_ADDREF_LOCKED(dr);	<span class="enscript-comment">/* for this for loop */</span>
		NDDR_UNLOCK(dr);

		lck_mtx_unlock(nd6_mutex);
		<span class="enscript-comment">/* Callee returns a locked route upon success */</span>
		<span class="enscript-keyword">if</span> ((rt = nd6_lookup(&amp;rtaddr, 0, drifp, 0)) != NULL) {
			RT_LOCK_ASSERT_HELD(rt);
			<span class="enscript-keyword">if</span> ((ln = rt-&gt;rt_llinfo) != NULL &amp;&amp;
			    ND6_IS_LLINFO_PROBREACH(ln)) {
				reachable = TRUE;
				<span class="enscript-keyword">if</span> (selected_dr == NULL &amp;&amp;
				    (!ip6_doscopedroute ||
				    (drifp == nd6_defifp &amp;&amp; !advrouter))) {
					selected_dr = dr;
					NDDR_ADDREF(selected_dr);
				}
			}
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
			rt = NULL;
		}
		lck_mtx_lock(nd6_mutex);

		<span class="enscript-comment">/* Handle case (b) */</span>
		NDDR_LOCK(dr);
		<span class="enscript-keyword">if</span> (ip6_doscopedroute &amp;&amp; drifp == nd6_defifp &amp;&amp; !advrouter &amp;&amp;
		    (selected_dr == NULL || rtpref(dr) &gt; rtpref(selected_dr) ||
		    (rtpref(dr) == rtpref(selected_dr) &amp;&amp;
		    (dr-&gt;stateflags &amp; NDDRF_STATIC) &amp;&amp;
		    !(selected_dr-&gt;stateflags &amp; NDDRF_STATIC)))) {
			<span class="enscript-keyword">if</span> (selected_dr) {
				<span class="enscript-comment">/* Release it later on */</span>
				VERIFY(drrele == NULL);
				drrele = selected_dr;
			}
			selected_dr = dr;
			NDDR_ADDREF_LOCKED(selected_dr);
		}

		<span class="enscript-keyword">if</span> (!(dr-&gt;stateflags &amp; NDDRF_INSTALLED)) {
			<span class="enscript-comment">/*
			 * If the router hasn't been installed and it is
			 * reachable, try to install it later on below.
			 * If it's static, try to install it anyway.
			 */</span>
			<span class="enscript-keyword">if</span> (!advrouter &amp;&amp; (reachable ||
			    (dr-&gt;stateflags &amp; NDDRF_STATIC))) {
				dr-&gt;genid = -1;
				++update;
				nd6log2((LOG_INFO, <span class="enscript-string">&quot;%s: possible router %s, &quot;</span>
				    <span class="enscript-string">&quot;scoped=%d, static=%d\n&quot;</span>, if_name(drifp),
				    ip6_sprintf(&amp;rtaddr),
				    (dr-&gt;stateflags &amp; NDDRF_IFSCOPE) ? 1 : 0,
				    (dr-&gt;stateflags &amp; NDDRF_STATIC) ? 1 : 0));
			}
			NDDR_UNLOCK(dr);
			NDDR_REMREF(dr);	<span class="enscript-comment">/* for this for loop */</span>
			<span class="enscript-keyword">if</span> (drrele != NULL)
				NDDR_REMREF(drrele);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/* Record the currently installed primary/non-scoped router */</span>
		<span class="enscript-keyword">if</span> (!ip6_doscopedroute || !(dr-&gt;stateflags &amp; NDDRF_IFSCOPE)) {
			<span class="enscript-keyword">if</span> (installed_dr == NULL) {
				installed_dr = dr;
				NDDR_ADDREF_LOCKED(installed_dr);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* this should not happen; warn for diagnosis */</span>
				log(LOG_ERR, <span class="enscript-string">&quot;defrouter_select: more than one &quot;</span>
				    <span class="enscript-string">&quot;%s default router is installed\n&quot;</span>,
				    ip6_doscopedroute ? <span class="enscript-string">&quot;non-scoped&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
			}
		}
		NDDR_UNLOCK(dr);
		NDDR_REMREF(dr);	<span class="enscript-comment">/* for this for loop */</span>
		<span class="enscript-keyword">if</span> (drrele != NULL)
			NDDR_REMREF(drrele);
	}

	<span class="enscript-comment">/* If none was selected, use the currently installed one */</span>
	<span class="enscript-keyword">if</span> (ip6_doscopedroute &amp;&amp; selected_dr == NULL &amp;&amp; installed_dr != NULL) {
		selected_dr = installed_dr;
		NDDR_ADDREF(selected_dr);
	}

	<span class="enscript-comment">/*
	 * Install the unreachable one(s) if necesssary.
	 */</span>
	<span class="enscript-keyword">for</span> (dr = TAILQ_FIRST(&amp;nd_defrouter); dr;
	    dr = TAILQ_NEXT(dr, dr_entry)) {
		<span class="enscript-type">struct</span> nd_defrouter *_dr;

		<span class="enscript-keyword">if</span> (!ip6_doscopedroute)
			<span class="enscript-keyword">break</span>;

		NDDR_LOCK(dr);

		<span class="enscript-comment">/* If already (or will be) installed, skip */</span>
		<span class="enscript-keyword">if</span> ((dr-&gt;stateflags &amp; NDDRF_INSTALLED) || dr-&gt;genid == -1) {
			NDDR_UNLOCK(dr);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/* See if there is already a default router for the link */</span>
		<span class="enscript-keyword">for</span> (_dr = TAILQ_FIRST(&amp;nd_defrouter); _dr;
		    _dr = TAILQ_NEXT(_dr, dr_entry)) {
			<span class="enscript-keyword">if</span> (_dr != dr)
				NDDR_LOCK(_dr);
			<span class="enscript-keyword">if</span> (_dr == dr || _dr-&gt;ifp != dr-&gt;ifp) {
				<span class="enscript-keyword">if</span> (_dr != dr)
					NDDR_UNLOCK(_dr);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">if</span> ((_dr-&gt;stateflags &amp; NDDRF_INSTALLED) ||
			    _dr-&gt;genid == -1) {
				<span class="enscript-keyword">if</span> (_dr != dr)
					NDDR_UNLOCK(_dr);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (_dr != dr)
				NDDR_UNLOCK(_dr);
		}

		<span class="enscript-comment">/* If none so far, schedule it to be installed below */</span>
		<span class="enscript-keyword">if</span> (_dr == NULL &amp;&amp; dr-&gt;ifp != NULL &amp;&amp;
		    !(dr-&gt;ifp-&gt;if_eflags &amp; IFEF_IPV6_ROUTER)) {
			dr-&gt;genid = -1;
			++update;
			nd6log2((LOG_INFO, <span class="enscript-string">&quot;%s: possible router %s, &quot;</span>
			    <span class="enscript-string">&quot;static=%d (unreachable)\n&quot;</span>, if_name(dr-&gt;ifp),
			    ip6_sprintf(&amp;dr-&gt;rtaddr),
			    (dr-&gt;stateflags &amp; NDDRF_STATIC) ? 1 : 0));
		}
		NDDR_UNLOCK(dr);
	}

	dr = selected_dr;
	<span class="enscript-keyword">if</span> (dr != NULL) {
		nd6log2((LOG_INFO, <span class="enscript-string">&quot;%s: considering primary default router %s, &quot;</span>
		    <span class="enscript-string">&quot;static=%d [round 1]\n&quot;</span>, if_name(dr-&gt;ifp),
		    ip6_sprintf(&amp;dr-&gt;rtaddr),
		    (dr-&gt;stateflags &amp; NDDRF_STATIC) ? 1 : 0));
	}

	<span class="enscript-comment">/*
	 * If none of the default routers was found to be reachable,
	 * round-robin the list regardless of preference, except when
	 * Scoped Routing is enabled per case (c).
	 *
	 * Otherwise, if we have an installed router, check if the selected
	 * (reachable) router should really be preferred to the installed one.
	 * We only prefer the new router when the old one is not reachable
	 * or when the new one has a really higher preference value.
	 */</span>
	<span class="enscript-keyword">if</span> (!ip6_doscopedroute &amp;&amp; selected_dr == NULL) {
		<span class="enscript-keyword">if</span> (installed_dr == NULL ||
		    !TAILQ_NEXT(installed_dr, dr_entry)) {
			selected_dr = TAILQ_FIRST(&amp;nd_defrouter);
			<span class="enscript-keyword">if</span> (selected_dr)
				NDDR_ADDREF(selected_dr);
		} <span class="enscript-keyword">else</span> {
			selected_dr = TAILQ_NEXT(installed_dr, dr_entry);
			<span class="enscript-keyword">if</span> (selected_dr)
				NDDR_ADDREF(selected_dr);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (selected_dr != NULL &amp;&amp; installed_dr != NULL) {
		lck_mtx_unlock(nd6_mutex);
		rt = nd6_lookup(&amp;installed_dr-&gt;rtaddr, 0, installed_dr-&gt;ifp, 0);
		<span class="enscript-keyword">if</span> (rt) {
			RT_LOCK_ASSERT_HELD(rt);
			<span class="enscript-keyword">if</span> ((ln = (<span class="enscript-type">struct</span> llinfo_nd6 *)rt-&gt;rt_llinfo) &amp;&amp;
			    ND6_IS_LLINFO_PROBREACH(ln) &amp;&amp;
			    (!ip6_doscopedroute ||
				installed_dr-&gt;ifp == nd6_defifp) &amp;&amp;
			    rtpref(selected_dr) &lt;= rtpref(installed_dr)) {
				NDDR_REMREF(selected_dr);
				selected_dr = installed_dr;
				NDDR_ADDREF(selected_dr);
			}
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
			rt = NULL;
			found_installedrt = TRUE;
		}
		lck_mtx_lock(nd6_mutex);
	}

	<span class="enscript-keyword">if</span> (ip6_doscopedroute) {
		<span class="enscript-comment">/*
		 * If the installed primary router is not on the current
		 * IPv6 default interface, demote it to a scoped entry.
		 */</span>
		<span class="enscript-keyword">if</span> (installed_dr != NULL &amp;&amp; installed_dr-&gt;ifp != nd6_defifp &amp;&amp;
		    !(installed_dr-&gt;stateflags &amp; NDDRF_IFSCOPE)) {
			<span class="enscript-keyword">if</span> (selected_dr != NULL &amp;&amp;
			    selected_dr-&gt;ifp != nd6_defifp) {
				NDDR_REMREF(selected_dr);
				selected_dr = NULL;
			}
			++update;
		}

		<span class="enscript-comment">/*
		 * If the selected router is currently scoped, make sure
		 * we update (it needs to be promoted to primary.)
		 */</span>
		<span class="enscript-keyword">if</span> (selected_dr != NULL &amp;&amp;
		    (selected_dr-&gt;stateflags &amp; NDDRF_IFSCOPE))
			++update;

		<span class="enscript-comment">/*
		 * If the installed router is no longer reachable, remove
		 * it and install the selected router instead.
		 */</span>
		<span class="enscript-keyword">if</span> (installed_dr != NULL
		    &amp;&amp; selected_dr != NULL 
		    &amp;&amp; installed_dr != selected_dr 
		    &amp;&amp; found_installedrt == FALSE
		    &amp;&amp; installed_dr-&gt;ifp == selected_dr-&gt;ifp) {
			<span class="enscript-comment">/* skip it below */</span>
			installed_dr0 = installed_dr;
			<span class="enscript-comment">/* NB: we previousled referenced installed_dr */</span>
			installed_dr = NULL;
			selected_dr-&gt;genid = -1;
			++update;
		}
	}

	<span class="enscript-comment">/*
	 * If Scoped Routing is enabled and there's nothing to update,
	 * just return.  Otherwise, if Scoped Routing is disabled and if
	 * the selected router is different than the installed one,
	 * remove the installed router and install the selected one.
	 */</span>
	dr = selected_dr;
	VERIFY(dr != NULL || ip6_doscopedroute);
	<span class="enscript-keyword">if</span> (!ip6_doscopedroute || !update) {
		<span class="enscript-keyword">if</span> (dr == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		<span class="enscript-keyword">if</span> (dr != installed_dr) {
			nd6log2((LOG_INFO, <span class="enscript-string">&quot;%s: no update, selected router %s, &quot;</span>
			    <span class="enscript-string">&quot;installed router %s\n&quot;</span>, if_name(dr-&gt;ifp),
			    ip6_sprintf(&amp;dr-&gt;rtaddr), installed_dr != NULL ?
			    ip6_sprintf(&amp;installed_dr-&gt;rtaddr) : <span class="enscript-string">&quot;NONE&quot;</span>));
		} <span class="enscript-keyword">else</span> {
			nd6log2((LOG_INFO, <span class="enscript-string">&quot;%s: no update, router is %s\n&quot;</span>,
			    if_name(dr-&gt;ifp), ip6_sprintf(&amp;dr-&gt;rtaddr)));
		}
		<span class="enscript-keyword">if</span> (!ip6_doscopedroute &amp;&amp; installed_dr != dr) {
			<span class="enscript-comment">/*
			 * No need to ADDREF dr because at this point
			 * dr points to selected_dr, which already holds
			 * a reference.
			 */</span>
			lck_mtx_unlock(nd6_mutex);
			<span class="enscript-keyword">if</span> (installed_dr) {
				defrouter_delreq(installed_dr);
			}
			defrouter_addreq(dr, FALSE);
			lck_mtx_lock(nd6_mutex);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Scoped Routing is enabled and we need to update.  The selected
	 * router needs to be installed as primary/non-scoped entry.  If
	 * there is any existing entry that is non-scoped, remove it from
	 * the routing table and reinstall it as scoped entry.
	 */</span>
	<span class="enscript-keyword">if</span> (dr != NULL) {
		nd6log2((LOG_INFO, <span class="enscript-string">&quot;%s: considering primary default router %s, &quot;</span>
		    <span class="enscript-string">&quot;static=%d [round 2]\n&quot;</span>, if_name(dr-&gt;ifp),
		    ip6_sprintf(&amp;dr-&gt;rtaddr),
		    (dr-&gt;stateflags &amp; NDDRF_STATIC) ? 1 : 0));
	}

	<span class="enscript-comment">/*
	 * On the following while loops we use two flags:
	 *   dr-&gt;genid
	 *   NDDRF_PROCESSED
	 *
	 * genid is used to skip entries that are not to be added/removed on the
	 * second while loop.
	 * NDDRF_PROCESSED is used to skip entries that were already
	 * processed.
	 * This is necessary because we drop the nd6_mutex and start the while
	 * loop again.
	 */</span>
	TAILQ_FOREACH(dr, &amp;nd_defrouter, dr_entry) {
		NDDR_LOCK(dr);
		VERIFY((dr-&gt;stateflags &amp; NDDRF_PROCESSED) == 0);
		NDDR_UNLOCK(dr);
	}
	<span class="enscript-comment">/* Remove conflicting entries */</span>
	dr = TAILQ_FIRST(&amp;nd_defrouter);
	<span class="enscript-keyword">while</span> (dr) {
		NDDR_LOCK(dr);
		<span class="enscript-keyword">if</span> (!(dr-&gt;stateflags &amp; NDDRF_INSTALLED) ||
		    dr-&gt;stateflags &amp; NDDRF_PROCESSED) {
			NDDR_UNLOCK(dr);
			dr = TAILQ_NEXT(dr, dr_entry);
			<span class="enscript-keyword">continue</span>;
		}
		dr-&gt;stateflags |= NDDRF_PROCESSED;

		<span class="enscript-comment">/* A NULL selected_dr will remove primary default route */</span>
		<span class="enscript-keyword">if</span> ((dr == selected_dr &amp;&amp; (dr-&gt;stateflags &amp; NDDRF_IFSCOPE)) ||
		    (dr != selected_dr &amp;&amp; !(dr-&gt;stateflags &amp; NDDRF_IFSCOPE))) {
			NDDR_ADDREF_LOCKED(dr);
			NDDR_UNLOCK(dr);
			lck_mtx_unlock(nd6_mutex);
			defrouter_delreq(dr);
			lck_mtx_lock(nd6_mutex);
			NDDR_LOCK(dr);
			<span class="enscript-keyword">if</span> (dr &amp;&amp; dr != installed_dr0)
				dr-&gt;genid = -1;
			NDDR_UNLOCK(dr);
			NDDR_REMREF(dr);
			<span class="enscript-comment">/*
			 * Since we lost nd6_mutex, we have to start over.
			 */</span>
			dr = TAILQ_FIRST(&amp;nd_defrouter);
			<span class="enscript-keyword">continue</span>;
		}
		NDDR_UNLOCK(dr);
		dr = TAILQ_NEXT(dr, dr_entry);
	}

	<span class="enscript-comment">/* -1 is a special number, make sure we don't use it for genid */</span>
	<span class="enscript-keyword">if</span> (++nd6_defrouter_genid == -1)
		nd6_defrouter_genid = 1;

	TAILQ_FOREACH(dr, &amp;nd_defrouter, dr_entry) {
		NDDR_LOCK(dr);
		dr-&gt;stateflags &amp;= ~NDDRF_PROCESSED;
		NDDR_UNLOCK(dr);
	}
	<span class="enscript-comment">/* Add the entries back */</span>
	dr = TAILQ_FIRST(&amp;nd_defrouter);
	<span class="enscript-keyword">while</span> (dr) {
		<span class="enscript-type">struct</span> nd_defrouter *_dr;

		NDDR_LOCK(dr);
		<span class="enscript-keyword">if</span> (dr-&gt;stateflags &amp; NDDRF_PROCESSED ||
		    dr-&gt;genid != -1) {
			NDDR_UNLOCK(dr);
			dr = TAILQ_NEXT(dr, dr_entry);
			<span class="enscript-keyword">continue</span>;
		}
		dr-&gt;stateflags |= NDDRF_PROCESSED;

		<span class="enscript-comment">/* Handle case (b) */</span>
		<span class="enscript-keyword">for</span> (_dr = TAILQ_FIRST(&amp;nd_defrouter); _dr;
		    _dr = TAILQ_NEXT(_dr, dr_entry)) {
			<span class="enscript-keyword">if</span> (_dr == dr)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-comment">/*
			 * This is safe because we previously checked if
			 * _dr == dr.
			 */</span>
			NDDR_LOCK(_dr);
			<span class="enscript-keyword">if</span> (_dr-&gt;ifp == dr-&gt;ifp &amp;&amp; rtpref(_dr) &gt;= rtpref(dr) &amp;&amp;
			    (_dr-&gt;stateflags &amp; NDDRF_INSTALLED)) {
				NDDR_ADDREF_LOCKED(_dr);
				NDDR_UNLOCK(_dr);
				<span class="enscript-keyword">break</span>;
			}
			NDDR_UNLOCK(_dr);
		}

		<span class="enscript-comment">/* If same preference and i/f, static entry takes precedence */</span>
		<span class="enscript-keyword">if</span> (_dr != NULL &amp;&amp; rtpref(_dr) == rtpref(dr) &amp;&amp;
		    !(_dr-&gt;stateflags &amp; NDDRF_STATIC) &amp;&amp;
		    (dr-&gt;stateflags &amp; NDDRF_STATIC)) {
			lck_mtx_unlock(nd6_mutex);
			defrouter_delreq(_dr);
			lck_mtx_lock(nd6_mutex);
			NDDR_REMREF(_dr);
			_dr = NULL;
		}

		<span class="enscript-keyword">if</span> (_dr == NULL &amp;&amp; !(dr-&gt;stateflags &amp; NDDRF_INSTALLED)) {
			NDDR_ADDREF_LOCKED(dr);
			NDDR_UNLOCK(dr);
			lck_mtx_unlock(nd6_mutex);
			defrouter_addreq(dr, (selected_dr == NULL ||
			    dr-&gt;ifp != selected_dr-&gt;ifp));
			dr-&gt;genid = nd6_defrouter_genid;
			lck_mtx_lock(nd6_mutex);
			NDDR_REMREF(dr);
			<span class="enscript-comment">/*
			 * Since we lost nd6_mutex, we have to start over.
			 */</span>
			dr = TAILQ_FIRST(&amp;nd_defrouter);
			<span class="enscript-keyword">continue</span>;
		}
		NDDR_UNLOCK(dr);
		dr = TAILQ_NEXT(dr, dr_entry);
	}
<span class="enscript-reference">out</span>:
	TAILQ_FOREACH(dr, &amp;nd_defrouter, dr_entry) {
		NDDR_LOCK(dr);
		dr-&gt;stateflags &amp;= ~NDDRF_PROCESSED;
		NDDR_UNLOCK(dr);
	}
	<span class="enscript-keyword">if</span> (selected_dr)
		NDDR_REMREF(selected_dr);
	<span class="enscript-keyword">if</span> (installed_dr)
		NDDR_REMREF(installed_dr);
	<span class="enscript-keyword">if</span> (installed_dr0)
		NDDR_REMREF(installed_dr0);
	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);
	VERIFY(nd_defrouter_busy);
	nd_defrouter_busy = FALSE;
	<span class="enscript-keyword">if</span> (nd_defrouter_waiters &gt; 0) {
		nd_defrouter_waiters = 0;
		wakeup(nd_defrouter_waitchan);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd_defrouter *
<span class="enscript-function-name">defrtrlist_update_common</span>(<span class="enscript-type">struct</span> nd_defrouter *new, boolean_t scoped)
{
	<span class="enscript-type">struct</span> nd_defrouter *dr, *n;
	<span class="enscript-type">struct</span> ifnet *ifp = new-&gt;ifp;
	<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;
	<span class="enscript-type">struct</span> timeval caltime;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> ((dr = defrouter_lookup(&amp;new-&gt;rtaddr, ifp)) != NULL) {
		<span class="enscript-comment">/* entry exists */</span>
		<span class="enscript-keyword">if</span> (new-&gt;rtlifetime == 0) {
			defrtrlist_del(dr);
			NDDR_REMREF(dr);
			dr = NULL;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">int</span> oldpref = rtpref(dr);

			<span class="enscript-comment">/* override */</span>
			dr-&gt;flags = new-&gt;flags; <span class="enscript-comment">/* xxx flag check */</span>
			dr-&gt;rtlifetime = new-&gt;rtlifetime;
			dr-&gt;expire = new-&gt;expire;

			<span class="enscript-comment">/*
			 * If the preference does not change, there's no need
			 * to sort the entries.  If Scoped Routing is enabled,
			 * put the primary/non-scoped router at the top of the
			 * list of routers in the same preference band, unless
			 * it's already at that position.
			 */</span>
			<span class="enscript-keyword">if</span> (ip6_doscopedroute) {
				<span class="enscript-type">struct</span> nd_defrouter *p = NULL;

				<span class="enscript-comment">/* same preference and scoped; just return */</span>
				<span class="enscript-keyword">if</span> (rtpref(new) == oldpref &amp;&amp; scoped)
					<span class="enscript-keyword">return</span> (dr);

				n = TAILQ_FIRST(&amp;nd_defrouter);
				<span class="enscript-keyword">while</span> (n != NULL) {
					<span class="enscript-comment">/* preference changed; sort it */</span>
					<span class="enscript-keyword">if</span> (rtpref(new) != oldpref)
						<span class="enscript-keyword">break</span>;

					<span class="enscript-comment">/* not at the top of band; sort it */</span>
					<span class="enscript-keyword">if</span> (n != dr &amp;&amp; rtpref(n) == oldpref &amp;&amp;
					    (!p || rtpref(p) &gt; rtpref(n)))
						<span class="enscript-keyword">break</span>;

					p = n;
					n = TAILQ_NEXT(n, dr_entry);
				}

				<span class="enscript-comment">/* nothing has changed, just return */</span>
				<span class="enscript-keyword">if</span> (n == NULL &amp;&amp; (scoped ||
				    !(dr-&gt;stateflags &amp; NDDRF_IFSCOPE)))
					<span class="enscript-keyword">return</span> (dr);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rtpref(new) == oldpref) {
				<span class="enscript-keyword">return</span> (dr);
			}

			<span class="enscript-comment">/*
			 * preferred router may be changed, so relocate
			 * this router.
			 * XXX: calling TAILQ_REMOVE directly is a bad manner.
			 * However, since defrtrlist_del() has many side
			 * effects, we intentionally do so here.
			 * defrouter_select() below will handle routing
			 * changes later.
			 */</span>
			TAILQ_REMOVE(&amp;nd_defrouter, dr, dr_entry);
			new-&gt;stateflags = dr-&gt;stateflags;
			new-&gt;stateflags &amp;= ~NDDRF_PROCESSED;

			n = dr;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">insert</span>;
		}
		<span class="enscript-keyword">return</span> (dr);
	}

	VERIFY(dr == NULL);

	<span class="enscript-comment">/* entry does not exist */</span>
	<span class="enscript-keyword">if</span> (new-&gt;rtlifetime == 0) {
		<span class="enscript-keyword">return</span> (NULL);
	}

	n = nddr_alloc(M_WAITOK);
	<span class="enscript-keyword">if</span> (n == NULL) {
		<span class="enscript-keyword">return</span> (NULL);
	}

	ndi = ND_IFINFO(ifp);
	VERIFY((NULL != ndi) &amp;&amp; (TRUE == ndi-&gt;initialized));
	lck_mtx_lock(&amp;ndi-&gt;lock);
	<span class="enscript-keyword">if</span> (ip6_maxifdefrouters &gt;= 0 &amp;&amp;
	    ndi-&gt;ndefrouters &gt;= ip6_maxifdefrouters) {
		lck_mtx_unlock(&amp;ndi-&gt;lock);
		nddr_free(n);
		<span class="enscript-keyword">return</span> (NULL);
	}

	NDDR_ADDREF(n);	<span class="enscript-comment">/* for the nd_defrouter list */</span>
	NDDR_ADDREF(n);	<span class="enscript-comment">/* for the caller */</span>

	++nd6_defrouter_genid;
	ndi-&gt;ndefrouters++;
	VERIFY(ndi-&gt;ndefrouters != 0);
	lck_mtx_unlock(&amp;ndi-&gt;lock);

	nd6log2((LOG_INFO, <span class="enscript-string">&quot;%s: allocating defrouter %s\n&quot;</span>, if_name(ifp),
	    ip6_sprintf(&amp;new-&gt;rtaddr)));

	getmicrotime(&amp;caltime);
	NDDR_LOCK(n);
	memcpy(&amp;n-&gt;rtaddr, &amp;new-&gt;rtaddr, <span class="enscript-keyword">sizeof</span> (n-&gt;rtaddr));
	n-&gt;flags = new-&gt;flags;
	n-&gt;stateflags = new-&gt;stateflags;
	n-&gt;stateflags &amp;= ~NDDRF_PROCESSED;
	n-&gt;rtlifetime = new-&gt;rtlifetime;
	n-&gt;expire = new-&gt;expire;
	n-&gt;base_calendartime = caltime.tv_sec;
	n-&gt;base_uptime = net_uptime();
	n-&gt;ifp = new-&gt;ifp;
	n-&gt;genid = new-&gt;genid;
	n-&gt;err = new-&gt;err;
	NDDR_UNLOCK(n);
<span class="enscript-reference">insert</span>:
	<span class="enscript-comment">/* get nd6_service() to be scheduled as soon as it's convenient */</span>
	++nd6_sched_timeout_want;

	<span class="enscript-comment">/*
	 * Insert the new router in the Default Router List;
	 * The Default Router List should be in the descending order
	 * of router-preferece.  When Scoped Routing is disabled, routers
	 * with the same preference are sorted in the arriving time order;
	 * otherwise, the first entry in the list of routers having the same
	 * preference is the primary default router, when the interface used
	 * by the entry is the default interface.
	 */</span>

	<span class="enscript-comment">/* insert at the end of the group */</span>
	<span class="enscript-keyword">for</span> (dr = TAILQ_FIRST(&amp;nd_defrouter); dr;
	    dr = TAILQ_NEXT(dr, dr_entry)) {
		<span class="enscript-keyword">if</span> (rtpref(n) &gt; rtpref(dr) ||
		    (ip6_doscopedroute &amp;&amp; !scoped &amp;&amp; rtpref(n) == rtpref(dr)))
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (dr)
		TAILQ_INSERT_BEFORE(dr, n, dr_entry);
	<span class="enscript-keyword">else</span>
		TAILQ_INSERT_TAIL(&amp;nd_defrouter, n, dr_entry);

	defrouter_select(ifp);

	<span class="enscript-keyword">return</span> (n);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd_defrouter *
<span class="enscript-function-name">defrtrlist_update</span>(<span class="enscript-type">struct</span> nd_defrouter *new)
{
	<span class="enscript-type">struct</span> nd_defrouter *dr;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);
	dr = defrtrlist_update_common(new,
	    (nd6_defifp != NULL &amp;&amp; new-&gt;ifp != nd6_defifp));

	<span class="enscript-keyword">return</span> (dr);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">defrtrlist_sync</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> nd_defrouter *dr, new;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (!ip6_doscopedroute) {
		defrouter_select(ifp);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">for</span> (dr = TAILQ_FIRST(&amp;nd_defrouter); dr;
	    dr = TAILQ_NEXT(dr, dr_entry)) {
		NDDR_LOCK(dr);
		<span class="enscript-keyword">if</span> (dr-&gt;ifp == ifp &amp;&amp; (dr-&gt;stateflags &amp; NDDRF_INSTALLED))
			<span class="enscript-keyword">break</span>;
		NDDR_UNLOCK(dr);
	}

	<span class="enscript-keyword">if</span> (dr == NULL) {
		defrouter_select(ifp);
	} <span class="enscript-keyword">else</span> {
		memcpy(&amp;new.rtaddr, &amp;dr-&gt;rtaddr, <span class="enscript-keyword">sizeof</span> (new.rtaddr));
		new.flags = dr-&gt;flags;
		new.stateflags = dr-&gt;stateflags;
		new.stateflags &amp;= ~NDDRF_PROCESSED;
		new.rtlifetime = dr-&gt;rtlifetime;
		new.expire = dr-&gt;expire;
		new.ifp = dr-&gt;ifp;
		new.genid = dr-&gt;genid;
		new.err = dr-&gt;err;
		NDDR_UNLOCK(dr);
		dr = defrtrlist_update_common(&amp;new, FALSE);
		<span class="enscript-keyword">if</span> (dr)
			NDDR_REMREF(dr);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd_pfxrouter *
<span class="enscript-function-name">pfxrtr_lookup</span>(<span class="enscript-type">struct</span> nd_prefix *pr, <span class="enscript-type">struct</span> nd_defrouter *dr)
{
	<span class="enscript-type">struct</span> nd_pfxrouter *search;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);
	NDPR_LOCK_ASSERT_HELD(pr);

	<span class="enscript-keyword">for</span> (search = pr-&gt;ndpr_advrtrs.lh_first; search;
	    search = search-&gt;pfr_next) {
		<span class="enscript-keyword">if</span> (search-&gt;router == dr)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (search);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pfxrtr_add</span>(<span class="enscript-type">struct</span> nd_prefix *pr, <span class="enscript-type">struct</span> nd_defrouter *dr)
{
	<span class="enscript-type">struct</span> nd_pfxrouter *new;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);
	NDPR_LOCK_ASSERT_NOTHELD(pr);

	new = zalloc(ndprtr_zone);
	<span class="enscript-keyword">if</span> (new == NULL)
		<span class="enscript-keyword">return</span>;
	bzero(new, <span class="enscript-keyword">sizeof</span> (*new));
	new-&gt;router = dr;

	NDPR_LOCK(pr);
	LIST_INSERT_HEAD(&amp;pr-&gt;ndpr_advrtrs, new, pfr_entry);
	pr-&gt;ndpr_genid++;
	NDPR_UNLOCK(pr);

	pfxlist_onlink_check();
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pfxrtr_del</span>(<span class="enscript-type">struct</span> nd_pfxrouter *pfr, <span class="enscript-type">struct</span> nd_prefix *pr)
{
	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);
	NDPR_LOCK_ASSERT_HELD(pr);
	pr-&gt;ndpr_genid++;
	LIST_REMOVE(pfr, pfr_entry);
	zfree(ndprtr_zone, pfr);
}

<span class="enscript-comment">/*
 * The routine has been modified to atomically refresh expiry
 * time for nd6 prefix as the part of lookup.
 * rdar://20339655 explains the corner case where a system going
 * in sleep gets rid of manual addresses configured in the system
 * and then schedules the prefix for deletion.
 * However before the prefix gets deleted, if system comes out
 * from sleep and configures same address before prefix deletion
 * , the later prefix deletion will remove the prefix route and
 * the system will not be able to communicate with other IPv6
 * neighbor nodes in the same subnet.
 */</span>
<span class="enscript-type">struct</span> nd_prefix *
<span class="enscript-function-name">nd6_prefix_lookup</span>(<span class="enscript-type">struct</span> nd_prefix *pr, <span class="enscript-type">int</span> nd6_prefix_expiry)
{
	<span class="enscript-type">struct</span> nd_prefix *search;

	lck_mtx_lock(nd6_mutex);
	<span class="enscript-keyword">for</span> (search = nd_prefix.lh_first; search; search = search-&gt;ndpr_next) {
		NDPR_LOCK(search);
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_ifp == search-&gt;ndpr_ifp &amp;&amp;
		    pr-&gt;ndpr_plen == search-&gt;ndpr_plen &amp;&amp;
		    in6_are_prefix_equal(&amp;pr-&gt;ndpr_prefix.sin6_addr,
		    &amp;search-&gt;ndpr_prefix.sin6_addr, pr-&gt;ndpr_plen)) {
			<span class="enscript-keyword">if</span> (nd6_prefix_expiry != ND6_PREFIX_EXPIRY_UNSPEC) {
				search-&gt;ndpr_expire = nd6_prefix_expiry;
			}
			NDPR_ADDREF_LOCKED(search);
			NDPR_UNLOCK(search);
			<span class="enscript-keyword">break</span>;
		}
		NDPR_UNLOCK(search);
	}
	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-keyword">return</span> (search);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">purge_detached</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> nd_prefix *pr, *pr_next;
	<span class="enscript-type">struct</span> in6_ifaddr *ia;
	<span class="enscript-type">struct</span> ifaddr *ifa, *ifa_next;
	boolean_t removed = FALSE;

	lck_mtx_lock(nd6_mutex);

	pr = nd_prefix.lh_first;
<span class="enscript-reference">repeat</span>:
	<span class="enscript-keyword">while</span> (pr) {
		NDPR_LOCK(pr);
		pr_next = pr-&gt;ndpr_next;
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_ifp != ifp ||
		    IN6_IS_ADDR_LINKLOCAL(&amp;pr-&gt;ndpr_prefix.sin6_addr) ||
		    ((pr-&gt;ndpr_stateflags &amp; NDPRF_DETACHED) == 0 &amp;&amp;
		    !LIST_EMPTY(&amp;pr-&gt;ndpr_advrtrs))) {
			NDPR_UNLOCK(pr);
			pr = pr_next;
			<span class="enscript-keyword">continue</span>;
		}
		NDPR_ADDREF_LOCKED(pr);
		NDPR_UNLOCK(pr);
		ifnet_lock_shared(ifp);
		<span class="enscript-keyword">for</span> (ifa = ifp-&gt;if_addrlist.tqh_first; ifa; ifa = ifa_next) {
			IFA_LOCK(ifa);
			ifa_next = ifa-&gt;ifa_list.tqe_next;
			<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6) {
				IFA_UNLOCK(ifa);
				<span class="enscript-keyword">continue</span>;
			}
			ia = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;
			<span class="enscript-keyword">if</span> ((ia-&gt;ia6_flags &amp; IN6_IFF_AUTOCONF) ==
			    IN6_IFF_AUTOCONF &amp;&amp; ia-&gt;ia6_ndpr == pr) {
				IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for us */</span>
				IFA_UNLOCK(ifa);
				<span class="enscript-comment">/*
				 * Purging the address requires writer access
				 * to the address list, so drop the ifnet lock
				 * now and repeat from beginning.
				 */</span>
				ifnet_lock_done(ifp);
				lck_mtx_unlock(nd6_mutex);
				in6_purgeaddr(ifa);
				IFA_REMREF(ifa); <span class="enscript-comment">/* drop ours */</span>
				lck_mtx_lock(nd6_mutex);
				NDPR_REMREF(pr);
				pr = nd_prefix.lh_first;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">repeat</span>;
			}
			IFA_UNLOCK(ifa);
		}
		ifnet_lock_done(ifp);
		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_addrcnt == 0 &amp;&amp;
		    !(pr-&gt;ndpr_stateflags &amp; NDPRF_DEFUNCT)) {
			prelist_remove(pr);
			NDPR_UNLOCK(pr);
			removed = TRUE;
			<span class="enscript-comment">/*
			 * Reset the search from the beginning because
			 * nd6_mutex may have been dropped in
			 * prelist_remove().
			 */</span>
			pr_next = nd_prefix.lh_first;
		} <span class="enscript-keyword">else</span> {
			NDPR_UNLOCK(pr);
		}
		NDPR_REMREF(pr);
		pr = pr_next;
	}
	<span class="enscript-keyword">if</span> (removed)
		pfxlist_onlink_check();
	lck_mtx_unlock(nd6_mutex);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_prelist_add</span>(<span class="enscript-type">struct</span> nd_prefix *pr, <span class="enscript-type">struct</span> nd_defrouter *dr,
    <span class="enscript-type">struct</span> nd_prefix **newp, boolean_t force_scoped)
{
	<span class="enscript-type">struct</span> nd_prefix *new = NULL;
	<span class="enscript-type">struct</span> ifnet *ifp = pr-&gt;ndpr_ifp;
	<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;
	<span class="enscript-type">int</span> i, error;

	<span class="enscript-keyword">if</span> (ip6_maxifprefixes &gt;= 0) {
		ndi = ND_IFINFO(ifp);
		VERIFY((NULL != ndi) &amp;&amp; (TRUE == ndi-&gt;initialized));
		lck_mtx_lock(&amp;ndi-&gt;lock);
		<span class="enscript-keyword">if</span> (ndi-&gt;nprefixes &gt;= ip6_maxifprefixes / 2) {
			lck_mtx_unlock(&amp;ndi-&gt;lock);
			purge_detached(ifp);
			lck_mtx_lock(&amp;ndi-&gt;lock);
		}
		<span class="enscript-keyword">if</span> (ndi-&gt;nprefixes &gt;= ip6_maxifprefixes) {
			lck_mtx_unlock(&amp;ndi-&gt;lock);
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
		lck_mtx_unlock(&amp;ndi-&gt;lock);
	}

	new = ndpr_alloc(M_WAITOK);
	<span class="enscript-keyword">if</span> (new == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	NDPR_LOCK(new);
	NDPR_LOCK(pr);
	new-&gt;ndpr_ifp = pr-&gt;ndpr_ifp;
	new-&gt;ndpr_prefix = pr-&gt;ndpr_prefix;
	new-&gt;ndpr_plen = pr-&gt;ndpr_plen;
	new-&gt;ndpr_vltime = pr-&gt;ndpr_vltime;
	new-&gt;ndpr_pltime = pr-&gt;ndpr_pltime;
	new-&gt;ndpr_flags = pr-&gt;ndpr_flags;
	<span class="enscript-keyword">if</span> (pr-&gt;ndpr_stateflags &amp; NDPRF_STATIC)
		new-&gt;ndpr_stateflags |= NDPRF_STATIC;
	NDPR_UNLOCK(pr);
	<span class="enscript-keyword">if</span> ((error = in6_init_prefix_ltimes(new)) != 0) {
		NDPR_UNLOCK(new);
		ndpr_free(new);
		<span class="enscript-keyword">return</span> (error);
	}
	new-&gt;ndpr_lastupdate = net_uptime();
	<span class="enscript-keyword">if</span> (newp != NULL) {
		*newp = new;
		NDPR_ADDREF_LOCKED(new);	<span class="enscript-comment">/* for caller */</span>
	}
	<span class="enscript-comment">/* initialization */</span>
	LIST_INIT(&amp;new-&gt;ndpr_advrtrs);
	in6_prefixlen2mask(&amp;new-&gt;ndpr_mask, new-&gt;ndpr_plen);
	<span class="enscript-comment">/* make prefix in the canonical form */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; 4; i++)
		new-&gt;ndpr_prefix.sin6_addr.s6_addr32[i] &amp;=
			new-&gt;ndpr_mask.s6_addr32[i];

	NDPR_UNLOCK(new);

	<span class="enscript-comment">/* get nd6_service() to be scheduled as soon as it's convenient */</span>
	++nd6_sched_timeout_want;

	lck_mtx_lock(nd6_mutex);
	<span class="enscript-comment">/* link ndpr_entry to nd_prefix list */</span>
	LIST_INSERT_HEAD(&amp;nd_prefix, new, ndpr_entry);
	new-&gt;ndpr_debug |= IFD_ATTACHED;
	NDPR_ADDREF(new);	<span class="enscript-comment">/* for nd_prefix list */</span>

	<span class="enscript-comment">/* ND_OPT_PI_FLAG_ONLINK processing */</span>
	<span class="enscript-keyword">if</span> (new-&gt;ndpr_raf_onlink) {
		<span class="enscript-type">int</span> e;

		<span class="enscript-keyword">if</span> ((e = nd6_prefix_onlink_common(new, force_scoped,
		    new-&gt;ndpr_ifp-&gt;if_index)) != 0) {
			nd6log((LOG_ERR, <span class="enscript-string">&quot;nd6_prelist_add: failed to make &quot;</span>
			    <span class="enscript-string">&quot;the prefix %s/%d on-link %s on %s (errno=%d)\n&quot;</span>,
			    ip6_sprintf(&amp;new-&gt;ndpr_prefix.sin6_addr),
			    new-&gt;ndpr_plen, force_scoped ? <span class="enscript-string">&quot;scoped&quot;</span> :
			    <span class="enscript-string">&quot;non-scoped&quot;</span>, if_name(ifp), e));
			<span class="enscript-comment">/* proceed anyway. XXX: is it correct? */</span>
		}
	}

	<span class="enscript-keyword">if</span> (dr) {
		pfxrtr_add(new, dr);
	}

	lck_mtx_lock(&amp;ndi-&gt;lock);
	ndi-&gt;nprefixes++;
	VERIFY(ndi-&gt;nprefixes != 0);
	lck_mtx_unlock(&amp;ndi-&gt;lock);

	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Caller must have held an extra reference on nd_prefix.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">prelist_remove</span>(<span class="enscript-type">struct</span> nd_prefix *pr)
{
	<span class="enscript-type">struct</span> nd_pfxrouter *pfr, *next;
	<span class="enscript-type">struct</span> ifnet *ifp = pr-&gt;ndpr_ifp;
	<span class="enscript-type">int</span> e;
	<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);
	NDPR_LOCK_ASSERT_HELD(pr);

	<span class="enscript-keyword">if</span> (pr-&gt;ndpr_stateflags &amp; NDPRF_DEFUNCT)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * If there are no more addresses, defunct the prefix.  This is needed
	 * because we don't want multiple threads calling prelist_remove() for
	 * the same prefix and this might happen because we unlock nd6_mutex
	 * down below.
	 */</span>
	<span class="enscript-keyword">if</span> (pr-&gt;ndpr_addrcnt == 0)
		pr-&gt;ndpr_stateflags |= NDPRF_DEFUNCT;

	<span class="enscript-comment">/* make sure to invalidate the prefix until it is really freed. */</span>
	pr-&gt;ndpr_vltime = 0;
	pr-&gt;ndpr_pltime = 0;

	<span class="enscript-comment">/*
	 * Though these flags are now meaningless, we'd rather keep the value
	 * of pr-&gt;ndpr_raf_onlink and pr-&gt;ndpr_raf_auto not to confuse users
	 * when executing &quot;ndp -p&quot;.
	 */</span>
	<span class="enscript-keyword">if</span> (pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) {
		NDPR_ADDREF_LOCKED(pr);
		NDPR_UNLOCK(pr);
		lck_mtx_unlock(nd6_mutex);
		<span class="enscript-keyword">if</span> ((e = nd6_prefix_offlink(pr)) != 0) {
			nd6log((LOG_ERR, <span class="enscript-string">&quot;prelist_remove: failed to make &quot;</span>
			    <span class="enscript-string">&quot;%s/%d offlink on %s, errno=%d\n&quot;</span>,
			    ip6_sprintf(&amp;pr-&gt;ndpr_prefix.sin6_addr),
			    pr-&gt;ndpr_plen, if_name(ifp), e));
			<span class="enscript-comment">/* what should we do? */</span>
		}
		lck_mtx_lock(nd6_mutex);
		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (NDPR_REMREF_LOCKED(pr) == NULL)
			<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (pr-&gt;ndpr_addrcnt &gt; 0) {
		<span class="enscript-comment">/*
		 * The state might have changed if we called
		 * nd6_prefix_offlink().
		 */</span>
		pr-&gt;ndpr_stateflags &amp;= ~NDPRF_DEFUNCT;
		<span class="enscript-keyword">return</span>; <span class="enscript-comment">/* notice here? */</span>
	}

	<span class="enscript-comment">/* unlink ndpr_entry from nd_prefix list */</span>
	LIST_REMOVE(pr, ndpr_entry);
	pr-&gt;ndpr_debug &amp;= ~IFD_ATTACHED;

	<span class="enscript-comment">/* free list of routers that adversed the prefix */</span>
	<span class="enscript-keyword">for</span> (pfr = pr-&gt;ndpr_advrtrs.lh_first; pfr; pfr = next) {
		next = pfr-&gt;pfr_next;
		pfxrtr_del(pfr, pr);
	}

	ndi = ND_IFINFO(ifp);
	VERIFY((NULL != ndi) &amp;&amp; (TRUE == ndi-&gt;initialized));
	lck_mtx_lock(&amp;ndi-&gt;lock);
	VERIFY(ndi-&gt;nprefixes &gt; 0);
	ndi-&gt;nprefixes--;
	lck_mtx_unlock(&amp;ndi-&gt;lock);

	<span class="enscript-comment">/* This must not be the last reference to the nd_prefix */</span>
	<span class="enscript-keyword">if</span> (NDPR_REMREF_LOCKED(pr) == NULL) {
		panic(<span class="enscript-string">&quot;%s: unexpected (missing) refcnt ndpr=%p&quot;</span>, __func__, pr);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/*
	 * Don't call pfxlist_onlink_check() here because we are
	 * holding the NDPR lock and this could cause a deadlock when
	 * there are multiple threads executing pfxlist_onlink_check().
	 */</span>
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">prelist_update</span>(
	<span class="enscript-type">struct</span> nd_prefix *new,
	<span class="enscript-type">struct</span> nd_defrouter *dr, <span class="enscript-comment">/* may be NULL */</span>
	<span class="enscript-type">struct</span> mbuf *m,
	<span class="enscript-type">int</span> mcast)
{
	<span class="enscript-type">struct</span> in6_ifaddr *ia6 = NULL, *ia6_match = NULL;
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span> ifnet *ifp = new-&gt;ndpr_ifp;
	<span class="enscript-type">struct</span> nd_prefix *pr;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> newprefix = 0;
	<span class="enscript-type">int</span> auth;
	<span class="enscript-type">struct</span> in6_addrlifetime lt6_tmp;
	uint64_t timenow = net_uptime();

	<span class="enscript-comment">/* no need to lock &quot;new&quot; here, as it is local to the caller */</span>
	NDPR_LOCK_ASSERT_NOTHELD(new);

	auth = 0;
	<span class="enscript-keyword">if</span> (m) {
		<span class="enscript-comment">/*
		 * Authenticity for NA consists authentication for
		 * both IP header and IP datagrams, doesn't it ?
		 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">M_AUTHIPHDR</span>) &amp;&amp; <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">M_AUTHIPDGM</span>)
		auth = (m-&gt;m_flags &amp; M_AUTHIPHDR) &amp;&amp; (m-&gt;m_flags &amp; M_AUTHIPDGM);
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-keyword">if</span> ((pr = nd6_prefix_lookup(new, ND6_PREFIX_EXPIRY_UNSPEC)) != NULL) {
		<span class="enscript-comment">/*
		 * nd6_prefix_lookup() ensures that pr and new have the same
		 * prefix on a same interface.
		 */</span>

		<span class="enscript-comment">/*
		 * Update prefix information.  Note that the on-link (L) bit
		 * and the autonomous (A) bit should NOT be changed from 1
		 * to 0.
		 */</span>
		lck_mtx_lock(nd6_mutex);
		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (new-&gt;ndpr_raf_onlink == 1)
			pr-&gt;ndpr_raf_onlink = 1;
		<span class="enscript-keyword">if</span> (new-&gt;ndpr_raf_auto == 1)
			pr-&gt;ndpr_raf_auto = 1;
		<span class="enscript-keyword">if</span> (new-&gt;ndpr_raf_onlink) {
			pr-&gt;ndpr_vltime = new-&gt;ndpr_vltime;
			pr-&gt;ndpr_pltime = new-&gt;ndpr_pltime;
			(<span class="enscript-type">void</span>) in6_init_prefix_ltimes(pr); <span class="enscript-comment">/* XXX error case? */</span>
			pr-&gt;ndpr_lastupdate = net_uptime();
		}

		NDPR_ADDREF_LOCKED(pr);
		<span class="enscript-keyword">if</span> (new-&gt;ndpr_raf_onlink &amp;&amp;
		    (pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) == 0) {
			<span class="enscript-type">int</span> e;

			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">if</span> ((e = nd6_prefix_onlink(pr)) != 0) {
				nd6log((LOG_ERR,
				    <span class="enscript-string">&quot;prelist_update: failed to make &quot;</span>
				    <span class="enscript-string">&quot;the prefix %s/%d on-link on %s &quot;</span>
				    <span class="enscript-string">&quot;(errno=%d)\n&quot;</span>,
				    ip6_sprintf(&amp;pr-&gt;ndpr_prefix.sin6_addr),
				    pr-&gt;ndpr_plen, if_name(pr-&gt;ndpr_ifp), e));
				<span class="enscript-comment">/* proceed anyway. XXX: is it correct? */</span>
			}
			NDPR_LOCK(pr);
		}

		<span class="enscript-keyword">if</span> (dr &amp;&amp; pfxrtr_lookup(pr, dr) == NULL) {
			NDPR_UNLOCK(pr);
			pfxrtr_add(pr, dr);
		} <span class="enscript-keyword">else</span> {
			NDPR_UNLOCK(pr);
		}
		NDPR_REMREF(pr);
		lck_mtx_unlock(nd6_mutex);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> nd_prefix *newpr = NULL;

		newprefix = 1;

		<span class="enscript-keyword">if</span> (new-&gt;ndpr_vltime == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
		<span class="enscript-keyword">if</span> (new-&gt;ndpr_raf_onlink == 0 &amp;&amp; new-&gt;ndpr_raf_auto == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;

		bzero(&amp;new-&gt;ndpr_addr, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr));

		error = nd6_prelist_add(new, dr, &amp;newpr, FALSE);
		<span class="enscript-keyword">if</span> (error != 0 || newpr == NULL) {
			nd6log((LOG_NOTICE, <span class="enscript-string">&quot;prelist_update: &quot;</span>
			    <span class="enscript-string">&quot;nd6_prelist_add failed for %s/%d on %s &quot;</span>
			    <span class="enscript-string">&quot;errno=%d, returnpr=0x%llx\n&quot;</span>,
			    ip6_sprintf(&amp;new-&gt;ndpr_prefix.sin6_addr),
			    new-&gt;ndpr_plen, if_name(new-&gt;ndpr_ifp),
			    error, (uint64_t)VM_KERNEL_ADDRPERM(newpr)));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>; <span class="enscript-comment">/* we should just give up in this case. */</span>
		}

		<span class="enscript-comment">/*
		 * XXX: from the ND point of view, we can ignore a prefix
		 * with the on-link bit being zero.  However, we need a
		 * prefix structure for references from autoconfigured
		 * addresses.  Thus, we explicitly make sure that the prefix
		 * itself expires now.
		 */</span>
		NDPR_LOCK(newpr);
		<span class="enscript-keyword">if</span> (newpr-&gt;ndpr_raf_onlink == 0) {
			newpr-&gt;ndpr_vltime = 0;
			newpr-&gt;ndpr_pltime = 0;
			in6_init_prefix_ltimes(newpr);
		}

		pr = newpr;
		NDPR_UNLOCK(newpr);
	}

	<span class="enscript-comment">/*
	 * Address autoconfiguration based on Section 5.5.3 of RFC 4862.
	 * Note that pr must be non NULL at this point.
	 */</span>

	<span class="enscript-comment">/* 5.5.3 (a). Ignore the prefix without the A bit set. */</span>
	<span class="enscript-keyword">if</span> (!new-&gt;ndpr_raf_auto)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">afteraddrconf</span>;

	<span class="enscript-comment">/*
	 * 5.5.3 (b). the link-local prefix should have been ignored in
	 * nd6_ra_input.
	 */</span>

	<span class="enscript-comment">/* 5.5.3 (c). Consistency check on lifetimes: pltime &lt;= vltime. */</span>
	<span class="enscript-keyword">if</span> (new-&gt;ndpr_pltime &gt; new-&gt;ndpr_vltime) {
		error = EINVAL;	<span class="enscript-comment">/* XXX: won't be used */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;
	}

	<span class="enscript-comment">/*
	 * 5.5.3 (d).  If the prefix advertised is not equal to the prefix of
	 * an address configured by stateless autoconfiguration already in the
	 * list of addresses associated with the interface, and the Valid
	 * Lifetime is not 0, form an address.  We first check if we have
	 * a matching prefix.
	 */</span>
	ifnet_lock_shared(ifp);
	TAILQ_FOREACH(ifa, &amp;ifp-&gt;if_addrlist, ifa_list) {
		<span class="enscript-type">struct</span> in6_ifaddr *ifa6;
		u_int32_t remaininglifetime;

		IFA_LOCK(ifa);
		<span class="enscript-keyword">if</span> (ifa-&gt;ifa_addr-&gt;sa_family != AF_INET6) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}
		ifa6 = (<span class="enscript-type">struct</span> in6_ifaddr *)ifa;

		<span class="enscript-comment">/*
		 * We only consider autoconfigured addresses as per RFC 4862.
		 */</span>
		<span class="enscript-keyword">if</span> (!(ifa6-&gt;ia6_flags &amp; IN6_IFF_AUTOCONF)) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * Spec is not clear here, but I believe we should concentrate
		 * on unicast (i.e. not anycast) addresses.
		 * XXX: other ia6_flags? detached or duplicated?
		 */</span>
		<span class="enscript-keyword">if</span> ((ifa6-&gt;ia6_flags &amp; IN6_IFF_ANYCAST) != 0) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * Ignore the address if it is not associated with a prefix
		 * or is associated with a prefix that is different from this
		 * one.  (pr is never NULL here)
		 */</span>
		<span class="enscript-keyword">if</span> (ifa6-&gt;ia6_ndpr != pr) {
			IFA_UNLOCK(ifa);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> (ia6_match == NULL) { <span class="enscript-comment">/* remember the first one */</span>
			ia6_match = ifa6;
			IFA_ADDREF_LOCKED(ifa);	<span class="enscript-comment">/* for ia6_match */</span>
		}

		<span class="enscript-comment">/*
		 * An already autoconfigured address matched.  Now that we
		 * are sure there is at least one matched address, we can
		 * proceed to 5.5.3. (e): update the lifetimes according to the
		 * &quot;two hours&quot; rule and the privacy extension.
		 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TWOHOUR</span>		(120*60)

		<span class="enscript-comment">/* retrieve time as uptime (last arg is 0) */</span>
		in6ifa_getlifetime(ifa6, &amp;lt6_tmp, 0);

		<span class="enscript-keyword">if</span> (lt6_tmp.ia6t_vltime == ND6_INFINITE_LIFETIME)
			remaininglifetime = ND6_INFINITE_LIFETIME;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (timenow - ifa6-&gt;ia6_updatetime &gt; lt6_tmp.ia6t_vltime) {
			<span class="enscript-comment">/*
			 * The case of &quot;invalid&quot; address.  We should usually
			 * not see this case.
			 */</span>
			remaininglifetime = 0;
		} <span class="enscript-keyword">else</span> {
			remaininglifetime = lt6_tmp.ia6t_vltime -
			    (timenow - ifa6-&gt;ia6_updatetime);
		}
		<span class="enscript-comment">/* when not updating, keep the current stored lifetime. */</span>
		lt6_tmp.ia6t_vltime = remaininglifetime;

		<span class="enscript-keyword">if</span> (TWOHOUR &lt; new-&gt;ndpr_vltime ||
		    remaininglifetime &lt; new-&gt;ndpr_vltime) {
			lt6_tmp.ia6t_vltime = new-&gt;ndpr_vltime;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (remaininglifetime &lt;= TWOHOUR) {
			<span class="enscript-keyword">if</span> (auth) {
				lt6_tmp.ia6t_vltime = new-&gt;ndpr_vltime;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * new-&gt;ndpr_vltime &lt;= TWOHOUR &amp;&amp;
			 * TWOHOUR &lt; remaininglifetime
			 */</span>
			lt6_tmp.ia6t_vltime = TWOHOUR;
		}

		<span class="enscript-comment">/* The 2 hour rule is not imposed for preferred lifetime. */</span>
		lt6_tmp.ia6t_pltime = new-&gt;ndpr_pltime;

		<span class="enscript-comment">/* Special handling for lifetimes of temporary addresses. */</span>
		<span class="enscript-keyword">if</span> ((ifa6-&gt;ia6_flags &amp; IN6_IFF_TEMPORARY) != 0) {
			u_int32_t maxvltime, maxpltime;

			<span class="enscript-comment">/* Constrain lifetimes to system limits. */</span>
			<span class="enscript-keyword">if</span> (lt6_tmp.ia6t_vltime &gt; ip6_temp_valid_lifetime)
				lt6_tmp.ia6t_vltime = ip6_temp_valid_lifetime;
			<span class="enscript-keyword">if</span> (lt6_tmp.ia6t_pltime &gt; ip6_temp_preferred_lifetime)
				lt6_tmp.ia6t_pltime =
				    ip6_temp_preferred_lifetime -
				    ip6_desync_factor;

			<span class="enscript-comment">/*
			 * According to RFC 4941, section 3.3 (1), we only
			 * update the lifetimes when they are in the maximum
			 * intervals.
			 */</span>
			<span class="enscript-keyword">if</span> (ip6_temp_valid_lifetime &gt;
			    (u_int32_t)((timenow - ifa6-&gt;ia6_createtime) +
			    ip6_desync_factor)) {
				maxvltime = ip6_temp_valid_lifetime -
				    (timenow - ifa6-&gt;ia6_createtime) -
				    ip6_desync_factor;
			} <span class="enscript-keyword">else</span>
				maxvltime = 0;
			<span class="enscript-keyword">if</span> (ip6_temp_preferred_lifetime &gt;
			    (u_int32_t)((timenow - ifa6-&gt;ia6_createtime) +
			    ip6_desync_factor)) {
				maxpltime = ip6_temp_preferred_lifetime -
				    (timenow - ifa6-&gt;ia6_createtime) -
				    ip6_desync_factor;
			} <span class="enscript-keyword">else</span>
				maxpltime = 0;

			<span class="enscript-keyword">if</span> (lt6_tmp.ia6t_vltime == ND6_INFINITE_LIFETIME ||
			    lt6_tmp.ia6t_vltime &gt; maxvltime)
				lt6_tmp.ia6t_vltime = maxvltime;

			<span class="enscript-keyword">if</span> (lt6_tmp.ia6t_pltime == ND6_INFINITE_LIFETIME ||
			    lt6_tmp.ia6t_pltime &gt; maxpltime)
				lt6_tmp.ia6t_pltime = maxpltime;
		}

		in6_init_address_ltimes(pr, &amp;lt6_tmp);

		in6ifa_setlifetime(ifa6, &amp;lt6_tmp);
		ifa6-&gt;ia6_updatetime = timenow;
		IFA_UNLOCK(ifa);
	}
	ifnet_lock_done(ifp);
	<span class="enscript-keyword">if</span> (ia6_match == NULL &amp;&amp; new-&gt;ndpr_vltime) {
		<span class="enscript-comment">/*
		 * 5.5.3 (d) (continued)
		 * No address matched and the valid lifetime is non-zero.
		 * Create a new address.
		 */</span>

		<span class="enscript-keyword">if</span> ((ia6 = in6_pfx_newpersistaddr(new, mcast, &amp;error))
		    != NULL) {
			<span class="enscript-comment">/*
			 * note that we should use pr (not new) for reference.
			 */</span>
			IFA_LOCK(&amp;ia6-&gt;ia_ifa);
			NDPR_LOCK(pr);
			ia6-&gt;ia6_ndpr = pr;
			NDPR_ADDREF_LOCKED(pr);	<span class="enscript-comment">/* for addr reference */</span>
			pr-&gt;ndpr_addrcnt++;
			VERIFY(pr-&gt;ndpr_addrcnt != 0);
			NDPR_UNLOCK(pr);
			IFA_UNLOCK(&amp;ia6-&gt;ia_ifa);

			<span class="enscript-comment">/*
			 * RFC 4941 3.3 (2).
			 * When a new public address is created as described
			 * in RFC 4862, also create a new temporary address.
			 *
			 * RFC 4941 3.5.
			 * When an interface connects to a new link, a new
			 * randomized interface identifier should be generated
			 * immediately together with a new set of temporary
			 * addresses.  Thus, we specifiy 1 as the 2nd arg of
			 * in6_tmpifadd().
			 */</span>
			<span class="enscript-keyword">if</span> (ip6_use_tempaddr) {
				<span class="enscript-type">int</span> e;
				<span class="enscript-keyword">if</span> ((e = in6_tmpifadd(ia6, 1)) != 0) {
					nd6log((LOG_NOTICE, <span class="enscript-string">&quot;prelist_update: &quot;</span>
					    <span class="enscript-string">&quot;failed to create a temporary &quot;</span>
					    <span class="enscript-string">&quot;address, errno=%d\n&quot;</span>,
					    e));
				}
			}
			IFA_REMREF(&amp;ia6-&gt;ia_ifa);
			ia6 = NULL;

			<span class="enscript-comment">/*
			 * A newly added address might affect the status
			 * of other addresses, so we check and update it.
			 * XXX: what if address duplication happens?
			 */</span>
			lck_mtx_lock(nd6_mutex);
			pfxlist_onlink_check();
			lck_mtx_unlock(nd6_mutex);
		}
	}

<span class="enscript-reference">afteraddrconf</span>:

<span class="enscript-reference">end</span>:
	<span class="enscript-keyword">if</span> (pr != NULL)
		NDPR_REMREF(pr);
	<span class="enscript-keyword">if</span> (ia6_match != NULL)
		IFA_REMREF(&amp;ia6_match-&gt;ia_ifa);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Neighbor Discover Default Router structure reference counting routines.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd_defrouter *
<span class="enscript-function-name">nddr_alloc</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> nd_defrouter *dr;

	dr = (how == M_WAITOK) ? zalloc(nddr_zone) : zalloc_noblock(nddr_zone);
	<span class="enscript-keyword">if</span> (dr != NULL) {
		bzero(dr, nddr_size);
		lck_mtx_init(&amp;dr-&gt;nddr_lock, ifa_mtx_grp, ifa_mtx_attr);
		dr-&gt;nddr_debug |= IFD_ALLOC;
		<span class="enscript-keyword">if</span> (nddr_debug != 0) {
			dr-&gt;nddr_debug |= IFD_DEBUG;
			dr-&gt;nddr_trace = nddr_trace;
		}
	}
	<span class="enscript-keyword">return</span> (dr);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nddr_free</span>(<span class="enscript-type">struct</span> nd_defrouter *dr)
{
	NDDR_LOCK(dr);
	<span class="enscript-keyword">if</span> (dr-&gt;nddr_debug &amp; IFD_ATTACHED) {
		panic(<span class="enscript-string">&quot;%s: attached nddr %p is being freed&quot;</span>, __func__, dr);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(dr-&gt;nddr_debug &amp; IFD_ALLOC)) {
		panic(<span class="enscript-string">&quot;%s: nddr %p cannot be freed&quot;</span>, __func__, dr);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	dr-&gt;nddr_debug &amp;= ~IFD_ALLOC;
	NDDR_UNLOCK(dr);

	lck_mtx_destroy(&amp;dr-&gt;nddr_lock, ifa_mtx_grp);
	zfree(nddr_zone, dr);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nddr_trace</span>(<span class="enscript-type">struct</span> nd_defrouter *dr, <span class="enscript-type">int</span> refhold)
{
	<span class="enscript-type">struct</span> nd_defrouter_dbg *dr_dbg = (<span class="enscript-type">struct</span> nd_defrouter_dbg *)dr;
	ctrace_t *tr;
	uint32_t idx;
	uint16_t *cnt;

	<span class="enscript-keyword">if</span> (!(dr-&gt;nddr_debug &amp; IFD_DEBUG)) {
		panic(<span class="enscript-string">&quot;%s: nddr %p has no debug structure&quot;</span>, __func__, dr);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (refhold) {
		cnt = &amp;dr_dbg-&gt;nddr_refhold_cnt;
		tr = dr_dbg-&gt;nddr_refhold;
	} <span class="enscript-keyword">else</span> {
		cnt = &amp;dr_dbg-&gt;nddr_refrele_cnt;
		tr = dr_dbg-&gt;nddr_refrele;
	}

	idx = atomic_add_16_ov(cnt, 1) % NDDR_TRACE_HIST_SIZE;
	ctrace_record(&amp;tr[idx]);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nddr_addref</span>(<span class="enscript-type">struct</span> nd_defrouter *nddr, <span class="enscript-type">int</span> locked)
{

	<span class="enscript-keyword">if</span> (!locked)
		NDDR_LOCK_SPIN(nddr);
	<span class="enscript-keyword">else</span>
		NDDR_LOCK_ASSERT_HELD(nddr);

	<span class="enscript-keyword">if</span> (++nddr-&gt;nddr_refcount == 0) {
		panic(<span class="enscript-string">&quot;%s: nddr %p wraparound refcnt\n&quot;</span>, __func__, nddr);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nddr-&gt;nddr_trace != NULL) {
		(*nddr-&gt;nddr_trace)(nddr, TRUE);
	}

	<span class="enscript-keyword">if</span> (!locked)
		NDDR_UNLOCK(nddr);
}

<span class="enscript-type">struct</span> nd_defrouter *
<span class="enscript-function-name">nddr_remref</span>(<span class="enscript-type">struct</span> nd_defrouter *nddr, <span class="enscript-type">int</span> locked)
{

	<span class="enscript-keyword">if</span> (!locked)
		NDDR_LOCK_SPIN(nddr);
	<span class="enscript-keyword">else</span>
		NDDR_LOCK_ASSERT_HELD(nddr);

	<span class="enscript-keyword">if</span> (nddr-&gt;nddr_refcount == 0) {
		panic(<span class="enscript-string">&quot;%s: nddr %p negative refcnt\n&quot;</span>, __func__, nddr);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nddr-&gt;nddr_trace != NULL) {
		(*nddr-&gt;nddr_trace)(nddr, FALSE);
	}

	<span class="enscript-keyword">if</span> (--nddr-&gt;nddr_refcount == 0) {
		NDDR_UNLOCK(nddr);
		nddr_free(nddr);
		nddr = NULL;
	}

	<span class="enscript-keyword">if</span> (!locked &amp;&amp; nddr != NULL)
		NDDR_UNLOCK(nddr);

	<span class="enscript-keyword">return</span> (nddr);
}

uint64_t
<span class="enscript-function-name">nddr_getexpire</span>(<span class="enscript-type">struct</span> nd_defrouter *dr)
{
	<span class="enscript-type">struct</span> timeval caltime;
	uint64_t expiry;

	<span class="enscript-keyword">if</span> (dr-&gt;expire != 0) {
		<span class="enscript-comment">/* account for system time change */</span>
		getmicrotime(&amp;caltime);

		dr-&gt;base_calendartime +=
		    NET_CALCULATE_CLOCKSKEW(caltime,
		    dr-&gt;base_calendartime, net_uptime(), dr-&gt;base_uptime);

		expiry = dr-&gt;base_calendartime +
		    dr-&gt;expire - dr-&gt;base_uptime;
	} <span class="enscript-keyword">else</span> {
		expiry = 0;
	}
	<span class="enscript-keyword">return</span> (expiry);
}

<span class="enscript-comment">/*
 * Neighbor Discover Prefix structure reference counting routines.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd_prefix *
<span class="enscript-function-name">ndpr_alloc</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> nd_prefix *pr;

	pr = (how == M_WAITOK) ? zalloc(ndpr_zone) : zalloc_noblock(ndpr_zone);
	<span class="enscript-keyword">if</span> (pr != NULL) {
		bzero(pr, ndpr_size);
		lck_mtx_init(&amp;pr-&gt;ndpr_lock, ifa_mtx_grp, ifa_mtx_attr);
		RB_INIT(&amp;pr-&gt;ndpr_prproxy_sols);
		pr-&gt;ndpr_debug |= IFD_ALLOC;
		<span class="enscript-keyword">if</span> (ndpr_debug != 0) {
			pr-&gt;ndpr_debug |= IFD_DEBUG;
			pr-&gt;ndpr_trace = ndpr_trace;
		}
	}
	<span class="enscript-keyword">return</span> (pr);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ndpr_free</span>(<span class="enscript-type">struct</span> nd_prefix *pr)
{
	NDPR_LOCK(pr);
	<span class="enscript-keyword">if</span> (pr-&gt;ndpr_debug &amp; IFD_ATTACHED) {
		panic(<span class="enscript-string">&quot;%s: attached ndpr %p is being freed&quot;</span>, __func__, pr);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(pr-&gt;ndpr_debug &amp; IFD_ALLOC)) {
		panic(<span class="enscript-string">&quot;%s: ndpr %p cannot be freed&quot;</span>, __func__, pr);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pr-&gt;ndpr_rt != NULL) {
		panic(<span class="enscript-string">&quot;%s: ndpr %p route %p not freed&quot;</span>, __func__, pr,
		    pr-&gt;ndpr_rt);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pr-&gt;ndpr_prproxy_sols_cnt != 0) {
		panic(<span class="enscript-string">&quot;%s: ndpr %p non-zero solicitors count (%d)&quot;</span>,
		    __func__, pr, pr-&gt;ndpr_prproxy_sols_cnt);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!RB_EMPTY(&amp;pr-&gt;ndpr_prproxy_sols)) {
		panic(<span class="enscript-string">&quot;%s: ndpr %p non-empty solicitors tree&quot;</span>, __func__, pr);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	pr-&gt;ndpr_debug &amp;= ~IFD_ALLOC;
	NDPR_UNLOCK(pr);

	lck_mtx_destroy(&amp;pr-&gt;ndpr_lock, ifa_mtx_grp);
	zfree(ndpr_zone, pr);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ndpr_trace</span>(<span class="enscript-type">struct</span> nd_prefix *pr, <span class="enscript-type">int</span> refhold)
{
	<span class="enscript-type">struct</span> nd_prefix_dbg *pr_dbg = (<span class="enscript-type">struct</span> nd_prefix_dbg *)pr;
	ctrace_t *tr;
	u_int32_t idx;
	u_int16_t *cnt;

	<span class="enscript-keyword">if</span> (!(pr-&gt;ndpr_debug &amp; IFD_DEBUG)) {
		panic(<span class="enscript-string">&quot;%s: ndpr %p has no debug structure&quot;</span>, __func__, pr);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (refhold) {
		cnt = &amp;pr_dbg-&gt;ndpr_refhold_cnt;
		tr = pr_dbg-&gt;ndpr_refhold;
	} <span class="enscript-keyword">else</span> {
		cnt = &amp;pr_dbg-&gt;ndpr_refrele_cnt;
		tr = pr_dbg-&gt;ndpr_refrele;
	}

	idx = atomic_add_16_ov(cnt, 1) % NDPR_TRACE_HIST_SIZE;
	ctrace_record(&amp;tr[idx]);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ndpr_addref</span>(<span class="enscript-type">struct</span> nd_prefix *ndpr, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-keyword">if</span> (!locked)
		NDPR_LOCK_SPIN(ndpr);
	<span class="enscript-keyword">else</span>
		NDPR_LOCK_ASSERT_HELD(ndpr);

	<span class="enscript-keyword">if</span> (++ndpr-&gt;ndpr_refcount == 0) {
		panic(<span class="enscript-string">&quot;%s: ndpr %p wraparound refcnt\n&quot;</span>, __func__, ndpr);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ndpr-&gt;ndpr_trace != NULL) {
		(*ndpr-&gt;ndpr_trace)(ndpr, TRUE);
	}

	<span class="enscript-keyword">if</span> (!locked)
		NDPR_UNLOCK(ndpr);
}

<span class="enscript-type">struct</span> nd_prefix *
<span class="enscript-function-name">ndpr_remref</span>(<span class="enscript-type">struct</span> nd_prefix *ndpr, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-keyword">if</span> (!locked)
		NDPR_LOCK_SPIN(ndpr);
	<span class="enscript-keyword">else</span>
		NDPR_LOCK_ASSERT_HELD(ndpr);

	<span class="enscript-keyword">if</span> (ndpr-&gt;ndpr_refcount == 0) {
		panic(<span class="enscript-string">&quot;%s: ndpr %p negative refcnt\n&quot;</span>, __func__, ndpr);
		<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ndpr-&gt;ndpr_trace != NULL) {
		(*ndpr-&gt;ndpr_trace)(ndpr, FALSE);
	}

	<span class="enscript-keyword">if</span> (--ndpr-&gt;ndpr_refcount == 0) {
		<span class="enscript-keyword">if</span> (ndpr-&gt;ndpr_addrcnt != 0) {
			panic(<span class="enscript-string">&quot;%s: freeing ndpr %p with outstanding address &quot;</span>
			    <span class="enscript-string">&quot;reference (%d)&quot;</span>, __func__, ndpr,
			    ndpr-&gt;ndpr_addrcnt);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		NDPR_UNLOCK(ndpr);
		ndpr_free(ndpr);
		ndpr = NULL;
	}

	<span class="enscript-keyword">if</span> (!locked &amp;&amp; ndpr != NULL)
		NDPR_UNLOCK(ndpr);

	<span class="enscript-keyword">return</span> (ndpr);
}

uint64_t
<span class="enscript-function-name">ndpr_getexpire</span>(<span class="enscript-type">struct</span> nd_prefix *pr)
{
	<span class="enscript-type">struct</span> timeval caltime;
	uint64_t expiry;

	<span class="enscript-keyword">if</span> (pr-&gt;ndpr_expire != 0 &amp;&amp; pr-&gt;ndpr_vltime != ND6_INFINITE_LIFETIME) {
		<span class="enscript-comment">/* account for system time change */</span>
		getmicrotime(&amp;caltime);

		pr-&gt;ndpr_base_calendartime +=
		    NET_CALCULATE_CLOCKSKEW(caltime,
		    pr-&gt;ndpr_base_calendartime, net_uptime(),
		    pr-&gt;ndpr_base_uptime);

		expiry = pr-&gt;ndpr_base_calendartime +
		    pr-&gt;ndpr_expire - pr-&gt;ndpr_base_uptime;
	} <span class="enscript-keyword">else</span> {
		expiry = 0;
	}
	<span class="enscript-keyword">return</span> (expiry);
}

<span class="enscript-comment">/*
 * A supplement function used in the on-link detection below;
 * detect if a given prefix has a (probably) reachable advertising router.
 * XXX: lengthy function name...
 *
 * Callers *must* increase the reference count of nd_prefix.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd_pfxrouter *
<span class="enscript-function-name">find_pfxlist_reachable_router</span>(<span class="enscript-type">struct</span> nd_prefix *pr)
{
	<span class="enscript-type">struct</span> nd_pfxrouter *pfxrtr;
	<span class="enscript-type">struct</span> rtentry *rt;
	<span class="enscript-type">struct</span> llinfo_nd6 *ln;
	<span class="enscript-type">struct</span> ifnet *ifp;
	<span class="enscript-type">struct</span> in6_addr rtaddr;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> genid;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);
	NDPR_LOCK_ASSERT_HELD(pr);

	genid = pr-&gt;ndpr_genid;
	pfxrtr = LIST_FIRST(&amp;pr-&gt;ndpr_advrtrs);
	<span class="enscript-keyword">while</span> (pfxrtr) {
		ifp = pfxrtr-&gt;router-&gt;ifp;
		rtaddr = pfxrtr-&gt;router-&gt;rtaddr;
		NDPR_UNLOCK(pr);
		lck_mtx_unlock(nd6_mutex);
		<span class="enscript-comment">/* Callee returns a locked route upon success */</span>
		<span class="enscript-keyword">if</span> ((rt = nd6_lookup(&amp;rtaddr, 0, ifp, 0)) != NULL) {
			RT_LOCK_ASSERT_HELD(rt);
			<span class="enscript-keyword">if</span> ((ln = rt-&gt;rt_llinfo) != NULL &amp;&amp;
			    ND6_IS_LLINFO_PROBREACH(ln)) {
				RT_REMREF_LOCKED(rt);
				RT_UNLOCK(rt);
				lck_mtx_lock(nd6_mutex);
				NDPR_LOCK(pr);
				<span class="enscript-keyword">break</span>;	<span class="enscript-comment">/* found */</span>
			}
			RT_REMREF_LOCKED(rt);
			RT_UNLOCK(rt);
		}
		lck_mtx_lock(nd6_mutex);
		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_genid != genid) {
			pfxrtr = LIST_FIRST(&amp;pr-&gt;ndpr_advrtrs);
			genid = pr-&gt;ndpr_genid;
		} <span class="enscript-keyword">else</span>
			pfxrtr = LIST_NEXT(pfxrtr, pfr_entry);
	}
	NDPR_LOCK_ASSERT_HELD(pr);

	<span class="enscript-keyword">return</span> (pfxrtr);

}

<span class="enscript-comment">/*
 * Check if each prefix in the prefix list has at least one available router
 * that advertised the prefix (a router is &quot;available&quot; if its neighbor cache
 * entry is reachable or probably reachable).
 * If the check fails, the prefix may be off-link, because, for example,
 * we have moved from the network but the lifetime of the prefix has not
 * expired yet.  So we should not use the prefix if there is another prefix
 * that has an available router.
 * But, if there is no prefix that has an available router, we still regards
 * all the prefixes as on-link.  This is because we can't tell if all the
 * routers are simply dead or if we really moved from the network and there
 * is no router around us.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pfxlist_onlink_check</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> nd_prefix *pr, *prclear;
	<span class="enscript-type">struct</span> in6_ifaddr *ifa;
	<span class="enscript-type">struct</span> nd_defrouter *dr;
	<span class="enscript-type">struct</span> nd_pfxrouter *pfxrtr = NULL;
	<span class="enscript-type">int</span> err, i, found = 0;
	<span class="enscript-type">struct</span> ifaddr **ifap = NULL;
	<span class="enscript-type">struct</span> nd_prefix *ndpr;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">while</span> (nd_prefix_busy) {
		nd_prefix_waiters++;
		msleep(nd_prefix_waitchan, nd6_mutex, (PZERO-1),
		    __func__, NULL);
		lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);
	}
	nd_prefix_busy = TRUE;

	<span class="enscript-comment">/*
	 * Check if there is a prefix that has a reachable advertising
	 * router.
	 */</span>
	pr = nd_prefix.lh_first;
	<span class="enscript-keyword">while</span> (pr) {
		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_stateflags &amp; NDPRF_PROCESSED_ONLINK) {
			NDPR_UNLOCK(pr);
			pr = pr-&gt;ndpr_next;
			<span class="enscript-keyword">continue</span>;
		}
		NDPR_ADDREF_LOCKED(pr);
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_raf_onlink &amp;&amp; find_pfxlist_reachable_router(pr) &amp;&amp;
		    (pr-&gt;ndpr_debug &amp; IFD_ATTACHED)) {
			<span class="enscript-keyword">if</span> (NDPR_REMREF_LOCKED(pr) == NULL)
				pr = NULL;
			<span class="enscript-keyword">else</span>
				NDPR_UNLOCK(pr);
			<span class="enscript-keyword">break</span>;
		}
		pr-&gt;ndpr_stateflags |= NDPRF_PROCESSED_ONLINK;
		NDPR_UNLOCK(pr);
		NDPR_REMREF(pr);
		<span class="enscript-comment">/*
		 * Since find_pfxlist_reachable_router() drops the nd6_mutex, we
		 * have to start over, but the NDPRF_PROCESSED_ONLINK flag will
		 * stop us from checking the same prefix twice.
		 */</span>
		pr = nd_prefix.lh_first;
	}
	LIST_FOREACH(prclear, &amp;nd_prefix, ndpr_entry) {
		NDPR_LOCK(prclear);
		prclear-&gt;ndpr_stateflags &amp;= ~NDPRF_PROCESSED_ONLINK;
		NDPR_UNLOCK(prclear);
	}
	<span class="enscript-comment">/*
	 * If we have no such prefix, check whether we still have a router
	 * that does not advertise any prefixes.
	 */</span>
	<span class="enscript-keyword">if</span> (pr == NULL) {
		<span class="enscript-keyword">for</span> (dr = TAILQ_FIRST(&amp;nd_defrouter); dr;
		    dr = TAILQ_NEXT(dr, dr_entry)) {
			<span class="enscript-type">struct</span> nd_prefix *pr0;

			<span class="enscript-keyword">for</span> (pr0 = nd_prefix.lh_first; pr0;
			    pr0 = pr0-&gt;ndpr_next) {
				NDPR_LOCK(pr0);
				<span class="enscript-keyword">if</span> ((pfxrtr = pfxrtr_lookup(pr0, dr)) != NULL) {
					NDPR_UNLOCK(pr0);
					<span class="enscript-keyword">break</span>;
				}
				NDPR_UNLOCK(pr0);
			}
			<span class="enscript-keyword">if</span> (pfxrtr != NULL)
				<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">if</span> (pr != NULL || (TAILQ_FIRST(&amp;nd_defrouter) &amp;&amp; pfxrtr == NULL)) {
		<span class="enscript-comment">/*
		 * There is at least one prefix that has a reachable router,
		 * or at least a router which probably does not advertise
		 * any prefixes.  The latter would be the case when we move
		 * to a new link where we have a router that does not provide
		 * prefixes and we configure an address by hand.
		 * Detach prefixes which have no reachable advertising
		 * router, and attach other prefixes.
		 */</span>
		pr = nd_prefix.lh_first;
		<span class="enscript-keyword">while</span> (pr) {
			NDPR_LOCK(pr);
			<span class="enscript-comment">/*
			 * We aren't interested prefixes already processed,
			 * nor in prefixes without the L bit
			 * set nor in static prefixes
			 */</span>
			<span class="enscript-keyword">if</span> (pr-&gt;ndpr_raf_onlink == 0 ||
			    pr-&gt;ndpr_stateflags &amp; NDPRF_PROCESSED_ONLINK ||
			    pr-&gt;ndpr_stateflags &amp; NDPRF_STATIC) {
				NDPR_UNLOCK(pr);
				pr = pr-&gt;ndpr_next;
				<span class="enscript-keyword">continue</span>;
			}
			NDPR_ADDREF_LOCKED(pr);
			<span class="enscript-keyword">if</span> ((pr-&gt;ndpr_stateflags &amp; NDPRF_DETACHED) == 0 &amp;&amp;
			    find_pfxlist_reachable_router(pr) == NULL &amp;&amp;
			    (pr-&gt;ndpr_debug &amp; IFD_ATTACHED))
				pr-&gt;ndpr_stateflags |= NDPRF_DETACHED;
			<span class="enscript-keyword">if</span> ((pr-&gt;ndpr_stateflags &amp; NDPRF_DETACHED) != 0 &amp;&amp;
			    find_pfxlist_reachable_router(pr) != NULL &amp;&amp;
			    (pr-&gt;ndpr_debug &amp; IFD_ATTACHED))
				pr-&gt;ndpr_stateflags &amp;= ~NDPRF_DETACHED;
			pr-&gt;ndpr_stateflags |= NDPRF_PROCESSED_ONLINK;
			NDPR_UNLOCK(pr);
			NDPR_REMREF(pr);
			<span class="enscript-comment">/*
			 * Since find_pfxlist_reachable_router() drops the
			 * nd6_mutex, we have to start over, but the
			 * NDPRF_PROCESSED_ONLINK flag will stop us from
			 * checking the same prefix twice.
			 */</span>
			pr = nd_prefix.lh_first;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* there is no prefix that has a reachable router */</span>
		<span class="enscript-keyword">for</span> (pr = nd_prefix.lh_first; pr; pr = pr-&gt;ndpr_next) {
			NDPR_LOCK(pr);
			<span class="enscript-keyword">if</span> (pr-&gt;ndpr_raf_onlink == 0 ||
			    pr-&gt;ndpr_stateflags &amp; NDPRF_STATIC) {
				NDPR_UNLOCK(pr);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> ((pr-&gt;ndpr_stateflags &amp; NDPRF_DETACHED) != 0)
				pr-&gt;ndpr_stateflags &amp;= ~NDPRF_DETACHED;
			NDPR_UNLOCK(pr);
		}
	}
	LIST_FOREACH(prclear, &amp;nd_prefix, ndpr_entry) {
		NDPR_LOCK(prclear);
		prclear-&gt;ndpr_stateflags &amp;= ~NDPRF_PROCESSED_ONLINK;
		NDPR_UNLOCK(prclear);
	}
	<span class="enscript-comment">/*
	 * Remove each interface route associated with a (just) detached
	 * prefix, and reinstall the interface route for a (just) attached
	 * prefix.  Note that all attempt of reinstallation does not
	 * necessarily success, when a same prefix is shared among multiple
	 * interfaces.  Such cases will be handled in nd6_prefix_onlink,
	 * so we don't have to care about them.
	 */</span>
	pr = nd_prefix.lh_first;
	<span class="enscript-keyword">while</span> (pr) {
		<span class="enscript-type">int</span> e;

		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_raf_onlink == 0 ||
		    pr-&gt;ndpr_stateflags &amp; NDPRF_STATIC ||
		    pr-&gt;ndpr_stateflags &amp; NDPRF_PROCESSED_ONLINK ||
		    pr-&gt;ndpr_stateflags &amp; NDPRF_DEFUNCT) {
			NDPR_UNLOCK(pr);
			pr = pr-&gt;ndpr_next;
			<span class="enscript-keyword">continue</span>;
		}
		pr-&gt;ndpr_stateflags |= NDPRF_PROCESSED_ONLINK;
		NDPR_ADDREF_LOCKED(pr);
		<span class="enscript-keyword">if</span> ((pr-&gt;ndpr_stateflags &amp; NDPRF_DETACHED) != 0 &amp;&amp;
		    (pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) != 0) {
			NDPR_UNLOCK(pr);
			lck_mtx_unlock(nd6_mutex);
			<span class="enscript-keyword">if</span> ((e = nd6_prefix_offlink(pr)) != 0) {
				nd6log((LOG_ERR,
				    <span class="enscript-string">&quot;pfxlist_onlink_check: failed to &quot;</span>
				    <span class="enscript-string">&quot;make %s/%d offlink, errno=%d\n&quot;</span>,
				    ip6_sprintf(&amp;pr-&gt;ndpr_prefix.sin6_addr),
				    pr-&gt;ndpr_plen, e));
			}
			lck_mtx_lock(nd6_mutex);
			NDPR_REMREF(pr);
			pr = nd_prefix.lh_first;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> ((pr-&gt;ndpr_stateflags &amp; NDPRF_DETACHED) == 0 &amp;&amp;
		    (pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) == 0 &amp;&amp;
		    pr-&gt;ndpr_raf_onlink) {
			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">if</span> ((e = nd6_prefix_onlink(pr)) != 0) {
				nd6log((LOG_ERR,
				    <span class="enscript-string">&quot;pfxlist_onlink_check: failed to &quot;</span>
				    <span class="enscript-string">&quot;make %s/%d offlink, errno=%d\n&quot;</span>,
				    ip6_sprintf(&amp;pr-&gt;ndpr_prefix.sin6_addr),
				    pr-&gt;ndpr_plen, e));
			}
			NDPR_REMREF(pr);
			pr = nd_prefix.lh_first;
			<span class="enscript-keyword">continue</span>;
		} <span class="enscript-keyword">else</span> {
			NDPR_UNLOCK(pr);
		}
		NDPR_REMREF(pr);
		pr = pr-&gt;ndpr_next;
	}
	LIST_FOREACH(prclear, &amp;nd_prefix, ndpr_entry) {
		NDPR_LOCK(prclear);
		prclear-&gt;ndpr_stateflags &amp;= ~NDPRF_PROCESSED_ONLINK;
		NDPR_UNLOCK(prclear);
	}
	VERIFY(nd_prefix_busy);
	nd_prefix_busy = FALSE;
	<span class="enscript-keyword">if</span> (nd_prefix_waiters &gt; 0) {
		nd_prefix_waiters = 0;
		wakeup(nd_prefix_waitchan);
	}

	<span class="enscript-comment">/*
	 * Changes on the prefix status might affect address status as well.
	 * Make sure that all addresses derived from an attached prefix are
	 * attached, and that all addresses derived from a detached prefix are
	 * detached.  Note, however, that a manually configured address should
	 * always be attached.
	 * The precise detection logic is same as the one for prefixes.
	 *
	 * ifnet_get_address_list_family_internal() may fail due to memory
	 * pressure, but we will eventually be called again when we receive
	 * another NA, RA, or when the link status changes.
	 */</span>
	err = ifnet_get_address_list_family_internal(NULL, &amp;ifap, AF_INET6, 0,
	    M_NOWAIT, 0);
	<span class="enscript-keyword">if</span> (err != 0 || ifap == NULL) {
		nd6log((LOG_ERR, <span class="enscript-string">&quot;%s: ifnet_get_address_list_family_internal &quot;</span>
		    <span class="enscript-string">&quot;failed&quot;</span>, __func__));
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">for</span> (i = 0; ifap[i]; i++) {
		ifa = ifatoia6(ifap[i]);
		IFA_LOCK(&amp;ifa-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> ((ifa-&gt;ia6_flags &amp; IN6_IFF_AUTOCONF) == 0 ||
		    (ifap[i]-&gt;ifa_debug &amp; IFD_ATTACHED) == 0) {
			IFA_UNLOCK(&amp;ifa-&gt;ia_ifa);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> ((ndpr = ifa-&gt;ia6_ndpr) == NULL) {
			<span class="enscript-comment">/*
			 * This can happen when we first configure the address
			 * (i.e. the address exists, but the prefix does not).
			 * XXX: complicated relationships...
			 */</span>
			IFA_UNLOCK(&amp;ifa-&gt;ia_ifa);
			<span class="enscript-keyword">continue</span>;
		}
		IFA_UNLOCK(&amp;ifa-&gt;ia_ifa);

		NDPR_LOCK(ndpr);
		NDPR_ADDREF_LOCKED(ndpr);
		<span class="enscript-keyword">if</span> (find_pfxlist_reachable_router(ndpr)) {
			<span class="enscript-keyword">if</span> (NDPR_REMREF_LOCKED(ndpr) == NULL) {
				found = 0;
			} <span class="enscript-keyword">else</span> {
				NDPR_UNLOCK(ndpr);
				found = 1;
			}
			<span class="enscript-keyword">break</span>;
		}
		NDPR_UNLOCK(ndpr);
		NDPR_REMREF(ndpr);
	}
	<span class="enscript-keyword">if</span> (found) {
		<span class="enscript-keyword">for</span> (i = 0; ifap[i]; i++) {
			ifa = ifatoia6(ifap[i]);
			IFA_LOCK(&amp;ifa-&gt;ia_ifa);
			<span class="enscript-keyword">if</span> ((ifa-&gt;ia6_flags &amp; IN6_IFF_AUTOCONF) == 0 ||
			    (ifap[i]-&gt;ifa_debug &amp; IFD_ATTACHED) == 0) {
				IFA_UNLOCK(&amp;ifa-&gt;ia_ifa);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> ((ndpr = ifa-&gt;ia6_ndpr) == NULL) {
				<span class="enscript-comment">/* XXX: see above. */</span>
				IFA_UNLOCK(&amp;ifa-&gt;ia_ifa);
				<span class="enscript-keyword">continue</span>;
			}
			IFA_UNLOCK(&amp;ifa-&gt;ia_ifa);
			NDPR_LOCK(ndpr);
			NDPR_ADDREF_LOCKED(ndpr);
			<span class="enscript-keyword">if</span> (find_pfxlist_reachable_router(ndpr)) {
				NDPR_UNLOCK(ndpr);
				IFA_LOCK(&amp;ifa-&gt;ia_ifa);
				<span class="enscript-keyword">if</span> (ifa-&gt;ia6_flags &amp; IN6_IFF_DETACHED) {
					ifa-&gt;ia6_flags &amp;= ~IN6_IFF_DETACHED;
					ifa-&gt;ia6_flags |= IN6_IFF_TENTATIVE;
					IFA_UNLOCK(&amp;ifa-&gt;ia_ifa);
					nd6_dad_start((<span class="enscript-type">struct</span> ifaddr *)ifa, 0);
				} <span class="enscript-keyword">else</span> {
					IFA_UNLOCK(&amp;ifa-&gt;ia_ifa);
				}
			} <span class="enscript-keyword">else</span> {
				NDPR_UNLOCK(ndpr);
				IFA_LOCK(&amp;ifa-&gt;ia_ifa);
				ifa-&gt;ia6_flags |= IN6_IFF_DETACHED;
				IFA_UNLOCK(&amp;ifa-&gt;ia_ifa);
			}
			NDPR_REMREF(ndpr);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">for</span> (i = 0; ifap[i]; i++) {
			ifa = ifatoia6(ifap[i]);
			IFA_LOCK(&amp;ifa-&gt;ia_ifa);
			<span class="enscript-keyword">if</span> ((ifa-&gt;ia6_flags &amp; IN6_IFF_AUTOCONF) == 0) {
				IFA_UNLOCK(&amp;ifa-&gt;ia_ifa);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (ifa-&gt;ia6_flags &amp; IN6_IFF_DETACHED) {
				ifa-&gt;ia6_flags &amp;= ~IN6_IFF_DETACHED;
				ifa-&gt;ia6_flags |= IN6_IFF_TENTATIVE;
				IFA_UNLOCK(&amp;ifa-&gt;ia_ifa);
				<span class="enscript-comment">/* Do we need a delay in this case? */</span>
				nd6_dad_start((<span class="enscript-type">struct</span> ifaddr *)ifa, 0);
			} <span class="enscript-keyword">else</span> {
				IFA_UNLOCK(&amp;ifa-&gt;ia_ifa);
			}
		}
	}
	ifnet_free_address_list(ifap);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nd_prefix *
<span class="enscript-function-name">nd6_prefix_equal_lookup</span>(<span class="enscript-type">struct</span> nd_prefix *pr, boolean_t primary_only)
{
	<span class="enscript-type">struct</span> nd_prefix *opr;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">for</span> (opr = nd_prefix.lh_first; opr; opr = opr-&gt;ndpr_next) {
		<span class="enscript-keyword">if</span> (opr == pr)
			<span class="enscript-keyword">continue</span>;

		NDPR_LOCK(opr);
		<span class="enscript-keyword">if</span> ((opr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) == 0) {
			NDPR_UNLOCK(opr);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (opr-&gt;ndpr_plen == pr-&gt;ndpr_plen &amp;&amp;
		    in6_are_prefix_equal(&amp;pr-&gt;ndpr_prefix.sin6_addr,
		    &amp;opr-&gt;ndpr_prefix.sin6_addr, pr-&gt;ndpr_plen) &amp;&amp;
		    (!primary_only ||
		    !(opr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE))) {
			NDPR_ADDREF_LOCKED(opr);
			NDPR_UNLOCK(opr);
			<span class="enscript-keyword">return</span> (opr);
		}
		NDPR_UNLOCK(opr);
	}
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * Synchronize the interface routes of similar prefixes on different
 * interfaces; the one using the default interface would be (re)installed
 * as a primary/non-scoped entry, and the rest as scoped entri(es).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_prefix_sync</span>(<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> nd_prefix *pr, *opr;
	<span class="enscript-type">int</span> err = 0;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (!ip6_doscopedroute || ifp == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">for</span> (pr = nd_prefix.lh_first; pr; pr = pr-&gt;ndpr_next) {
		NDPR_LOCK(pr);
		<span class="enscript-keyword">if</span> (!(pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK)) {
			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (pr-&gt;ndpr_ifp == ifp &amp;&amp;
		    (pr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE) &amp;&amp;
		    !IN6_IS_ADDR_LINKLOCAL(&amp;pr-&gt;ndpr_prefix.sin6_addr)) {
			NDPR_UNLOCK(pr);
			<span class="enscript-keyword">break</span>;
		}
		NDPR_UNLOCK(pr);
	}

	<span class="enscript-keyword">if</span> (pr == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* Remove conflicting entries */</span>
	opr = nd6_prefix_equal_lookup(pr, TRUE);
	<span class="enscript-keyword">if</span> (opr != NULL) {
		lck_mtx_unlock(nd6_mutex);
		err = nd6_prefix_offlink(opr);
		lck_mtx_lock(nd6_mutex);
		<span class="enscript-keyword">if</span> (err != 0) {
			nd6log((LOG_ERR,
			    <span class="enscript-string">&quot;%s: failed to make %s/%d offlink on %s, &quot;</span>
			    <span class="enscript-string">&quot;errno=%d\n&quot;</span>, __func__,
			    ip6_sprintf(&amp;opr-&gt;ndpr_prefix.sin6_addr),
			    opr-&gt;ndpr_plen, if_name(opr-&gt;ndpr_ifp), err));
		}
	} <span class="enscript-keyword">else</span> {
		nd6log((LOG_ERR,
		    <span class="enscript-string">&quot;%s: scoped %s/%d on %s has no matching unscoped prefix\n&quot;</span>,
		    __func__, ip6_sprintf(&amp;pr-&gt;ndpr_prefix.sin6_addr),
		    pr-&gt;ndpr_plen, if_name(pr-&gt;ndpr_ifp)));
	}

	lck_mtx_unlock(nd6_mutex);
	err = nd6_prefix_offlink(pr);
	lck_mtx_lock(nd6_mutex);
	<span class="enscript-keyword">if</span> (err != 0) {
		nd6log((LOG_ERR,
		    <span class="enscript-string">&quot;%s: failed to make %s/%d offlink on %s, errno=%d\n&quot;</span>,
		    __func__, ip6_sprintf(&amp;pr-&gt;ndpr_prefix.sin6_addr),
		    pr-&gt;ndpr_plen, if_name(pr-&gt;ndpr_ifp), err));
	}

	<span class="enscript-comment">/* Add the entries back */</span>
	<span class="enscript-keyword">if</span> (opr != NULL) {
		err = nd6_prefix_onlink_scoped(opr, opr-&gt;ndpr_ifp-&gt;if_index);
		<span class="enscript-keyword">if</span> (err != 0) {
			nd6log((LOG_ERR,
			    <span class="enscript-string">&quot;%s: failed to make %s/%d scoped onlink on %s, &quot;</span>
			    <span class="enscript-string">&quot;errno=%d\n&quot;</span>, __func__,
			    ip6_sprintf(&amp;opr-&gt;ndpr_prefix.sin6_addr),
			    opr-&gt;ndpr_plen, if_name(opr-&gt;ndpr_ifp), err));
		}
	}

	err = nd6_prefix_onlink_scoped(pr, IFSCOPE_NONE);
	<span class="enscript-keyword">if</span> (err != 0) {
		nd6log((LOG_ERR,
		    <span class="enscript-string">&quot;%s: failed to make %s/%d onlink on %s, errno=%d\n&quot;</span>,
		    __func__, ip6_sprintf(&amp;pr-&gt;ndpr_prefix.sin6_addr),
		    pr-&gt;ndpr_plen, if_name(pr-&gt;ndpr_ifp), err));
	}

	<span class="enscript-keyword">if</span> (err != 0) {
		nd6log((LOG_ERR,
		    <span class="enscript-string">&quot;%s: error promoting %s/%d to %s from %s\n&quot;</span>,
		    __func__, ip6_sprintf(&amp;pr-&gt;ndpr_prefix.sin6_addr),
		    pr-&gt;ndpr_plen, if_name(pr-&gt;ndpr_ifp),
		    (opr != NULL) ? if_name(opr-&gt;ndpr_ifp) : <span class="enscript-string">&quot;NONE&quot;</span>));
	} <span class="enscript-keyword">else</span> {
		nd6log2((LOG_INFO,
		    <span class="enscript-string">&quot;%s: %s/%d promoted, previously on %s\n&quot;</span>,
		    if_name(pr-&gt;ndpr_ifp),
		    ip6_sprintf(&amp;pr-&gt;ndpr_prefix.sin6_addr), pr-&gt;ndpr_plen,
		    (opr != NULL) ? if_name(opr-&gt;ndpr_ifp) : <span class="enscript-string">&quot;NONE&quot;</span>));
	}

	<span class="enscript-keyword">if</span> (opr != NULL)
		NDPR_REMREF(opr);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_prefix_onlink_common</span>(<span class="enscript-type">struct</span> nd_prefix *pr, boolean_t force_scoped,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-type">struct</span> ifaddr *ifa;
	<span class="enscript-type">struct</span> ifnet *ifp = pr-&gt;ndpr_ifp;
	<span class="enscript-type">struct</span> sockaddr_in6 mask6, prefix;
	<span class="enscript-type">struct</span> nd_prefix *opr;
	u_int32_t rtflags;
	<span class="enscript-type">int</span> error = 0, prproxy = 0;
	<span class="enscript-type">struct</span> rtentry *rt = NULL;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* sanity check */</span>
	NDPR_LOCK(pr);
	<span class="enscript-keyword">if</span> ((pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) != 0) {
		nd6log((LOG_ERR,
		    <span class="enscript-string">&quot;%s: %s/%d on %s scoped=%d is already on-link\n&quot;</span>,
		    __func__, ip6_sprintf(&amp;pr-&gt;ndpr_prefix.sin6_addr),
		    pr-&gt;ndpr_plen, if_name(pr-&gt;ndpr_ifp),
		    (pr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE) ? 1 : 0);
		NDPR_UNLOCK(pr);
		<span class="enscript-keyword">return</span> (EEXIST));
	}
	NDPR_UNLOCK(pr);

	<span class="enscript-comment">/*
	 * Add the interface route associated with the prefix.  Before
	 * installing the route, check if there's the same prefix on another
	 * interface, and the prefix has already installed the interface route.
	 */</span>
	opr = nd6_prefix_equal_lookup(pr, FALSE);
	<span class="enscript-keyword">if</span> (opr != NULL)
		NDPR_REMREF(opr);

	<span class="enscript-keyword">if</span> (!ip6_doscopedroute) {
		<span class="enscript-comment">/* if an interface route already exists, just return */</span>
		<span class="enscript-keyword">if</span> (opr != NULL)
			<span class="enscript-keyword">return</span> (0);
		ifscope = IFSCOPE_NONE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!force_scoped) {
		<span class="enscript-comment">/*
		 * If a primary/non-scoped interface route already exists,
		 * install the new one as a scoped entry.  If the existing
		 * interface route is scoped, install new as non-scoped.
		 */</span>
		ifscope = (opr != NULL) ? ifp-&gt;if_index : IFSCOPE_NONE;
		opr = nd6_prefix_equal_lookup(pr, TRUE);
		<span class="enscript-keyword">if</span> (opr != NULL)
			NDPR_REMREF(opr);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE)
			ifscope = IFSCOPE_NONE;
	}

	<span class="enscript-comment">/*
	 * We prefer link-local addresses as the associated interface address.
	 */</span>
	<span class="enscript-comment">/* search for a link-local addr */</span>
	ifa = (<span class="enscript-type">struct</span> ifaddr *)in6ifa_ifpforlinklocal(ifp,
	    IN6_IFF_NOTREADY | IN6_IFF_ANYCAST);
	<span class="enscript-keyword">if</span> (ifa == NULL) {
		<span class="enscript-type">struct</span> in6_ifaddr *ia6;
		ifnet_lock_shared(ifp);
		IFP_TO_IA6(ifp, ia6);
		ifnet_lock_done(ifp);
		<span class="enscript-keyword">if</span> (ia6 != NULL)
			ifa = &amp;ia6-&gt;ia_ifa;
		<span class="enscript-comment">/* should we care about ia6_flags? */</span>
	}
	NDPR_LOCK(pr);
	<span class="enscript-keyword">if</span> (ifa == NULL) {
		<span class="enscript-comment">/*
		 * This can still happen, when, for example, we receive an RA
		 * containing a prefix with the L bit set and the A bit clear,
		 * after removing all IPv6 addresses on the receiving
		 * interface.  This should, of course, be rare though.
		 */</span>
		nd6log((LOG_NOTICE,
		    <span class="enscript-string">&quot;nd6_prefix_onlink: failed to find any ifaddr&quot;</span>
		    <span class="enscript-string">&quot; to add route for a prefix(%s/%d) on %s\n&quot;</span>,
		    ip6_sprintf(&amp;pr-&gt;ndpr_prefix.sin6_addr),
		    pr-&gt;ndpr_plen, if_name(ifp)));
		NDPR_UNLOCK(pr);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * in6_ifinit() sets nd6_rtrequest to ifa_rtrequest for all ifaddrs.
	 * ifa-&gt;ifa_rtrequest = nd6_rtrequest;
	 */</span>
	bzero(&amp;mask6, <span class="enscript-keyword">sizeof</span> (mask6));
	mask6.sin6_len = <span class="enscript-keyword">sizeof</span> (mask6);
	mask6.sin6_addr = pr-&gt;ndpr_mask;
	prefix = pr-&gt;ndpr_prefix;
	<span class="enscript-keyword">if</span> ((rt = pr-&gt;ndpr_rt) != NULL)
		pr-&gt;ndpr_rt = NULL;
	NDPR_ADDREF_LOCKED(pr);		<span class="enscript-comment">/* keep reference for this routine */</span>
	NDPR_UNLOCK(pr);

	IFA_LOCK_SPIN(ifa);
	rtflags = ifa-&gt;ifa_flags | RTF_CLONING | RTF_UP;
	IFA_UNLOCK(ifa);
	<span class="enscript-keyword">if</span> (nd6_need_cache(ifp)) {
		<span class="enscript-comment">/* explicitly set in case ifa_flags does not set the flag. */</span>
		rtflags |= RTF_CLONING;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * explicitly clear the cloning bit in case ifa_flags sets it.
		 */</span>
		rtflags &amp;= ~RTF_CLONING;
	}

	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-keyword">if</span> (rt != NULL) {
		rtfree(rt);
		rt = NULL;
	}

	error = rtrequest_scoped(RTM_ADD, (<span class="enscript-type">struct</span> sockaddr *)&amp;prefix,
	    ifa-&gt;ifa_addr, (<span class="enscript-type">struct</span> sockaddr *)&amp;mask6, rtflags, &amp;rt,
	    ifscope);

	<span class="enscript-comment">/*
	 * Serialize the setting of NDPRF_PRPROXY.
	 */</span>
	lck_mtx_lock(&amp;proxy6_lock);

	<span class="enscript-keyword">if</span> (rt != NULL) {
		RT_LOCK(rt);
		nd6_rtmsg(RTM_ADD, rt);
		RT_UNLOCK(rt);
		NDPR_LOCK(pr);
	} <span class="enscript-keyword">else</span> {
		NDPR_LOCK(pr);
		nd6log((LOG_ERR, <span class="enscript-string">&quot;nd6_prefix_onlink: failed to add route for a&quot;</span>
		    <span class="enscript-string">&quot; prefix (%s/%d) on %s, gw=%s, mask=%s, flags=%lx,&quot;</span>
		    <span class="enscript-string">&quot; scoped=%d, errno = %d\n&quot;</span>,
		    ip6_sprintf(&amp;pr-&gt;ndpr_prefix.sin6_addr),
		    pr-&gt;ndpr_plen, if_name(ifp),
		    ip6_sprintf(&amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)
		    (<span class="enscript-type">void</span> *)ifa-&gt;ifa_addr)-&gt;sin6_addr),
		    ip6_sprintf(&amp;mask6.sin6_addr), rtflags,
		    (ifscope != IFSCOPE_NONE), error));
	}
	NDPR_LOCK_ASSERT_HELD(pr);

	pr-&gt;ndpr_stateflags &amp;= ~(NDPRF_IFSCOPE | NDPRF_PRPROXY);

	<span class="enscript-comment">/*
	 * TODO: If the prefix route exists, we should really find it and
	 * refer the prefix to it; otherwise ndpr_rt is NULL.
	 */</span>
	<span class="enscript-keyword">if</span> (!(pr-&gt;ndpr_stateflags &amp; NDPRF_DEFUNCT) &amp;&amp;
	    (rt != NULL || error == EEXIST)) {
		<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;

		VERIFY(pr-&gt;ndpr_prproxy_sols_cnt == 0);
		VERIFY(RB_EMPTY(&amp;pr-&gt;ndpr_prproxy_sols));

		ndi = ND_IFINFO(ifp);
		VERIFY((NULL != ndi)  &amp;&amp; (TRUE == ndi-&gt;initialized));
		lck_mtx_lock(&amp;ndi-&gt;lock);

		pr-&gt;ndpr_rt = rt;	<span class="enscript-comment">/* keep reference from rtrequest */</span>
		pr-&gt;ndpr_stateflags |= NDPRF_ONLINK;
		<span class="enscript-keyword">if</span> (ifscope != IFSCOPE_NONE) {
			pr-&gt;ndpr_stateflags |= NDPRF_IFSCOPE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((rtflags &amp; RTF_CLONING) &amp;&amp;
		    (ndi-&gt;flags &amp; ND6_IFF_PROXY_PREFIXES) &amp;&amp;
		    !IN6_IS_ADDR_LINKLOCAL(&amp;pr-&gt;ndpr_prefix.sin6_addr)) {
			<span class="enscript-comment">/*
			 * At present, in order for the prefix to be eligible
			 * as a proxying/proxied prefix, we require that the
			 * prefix route entry be marked as a cloning route with
			 * RTF_PROXY; i.e. nd6_need_cache() needs to return
			 * true for the interface type, hence the test for
			 * RTF_CLONING above.
			 */</span>
			pr-&gt;ndpr_stateflags |= NDPRF_PRPROXY;
		}

		lck_mtx_unlock(&amp;ndi-&gt;lock);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rt != NULL &amp;&amp; pr-&gt;ndpr_stateflags &amp; NDPRF_DEFUNCT)
		rtfree(rt);

	prproxy = (pr-&gt;ndpr_stateflags &amp; NDPRF_PRPROXY);
	VERIFY(!prproxy || !(pr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE));
	NDPR_UNLOCK(pr);

	IFA_REMREF(ifa);

	<span class="enscript-comment">/*
	 * If this is an upstream prefix, find the downstream ones (if any)
	 * and re-configure their prefix routes accordingly.  Otherwise,
	 * this could be potentially be a downstream prefix, and so find the
	 * upstream prefix, if any.
	 */</span>
	nd6_prproxy_prelist_update(pr, prproxy ? pr : NULL);

	NDPR_REMREF(pr);	<span class="enscript-comment">/* release reference for this routine */</span>
	lck_mtx_unlock(&amp;proxy6_lock);

	lck_mtx_lock(nd6_mutex);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_prefix_onlink</span>(<span class="enscript-type">struct</span> nd_prefix *pr)
{
	<span class="enscript-keyword">return</span> (nd6_prefix_onlink_common(pr, FALSE, IFSCOPE_NONE));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_prefix_onlink_scoped</span>(<span class="enscript-type">struct</span> nd_prefix *pr, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
	<span class="enscript-keyword">return</span> (nd6_prefix_onlink_common(pr, TRUE, ifscope));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_prefix_offlink</span>(<span class="enscript-type">struct</span> nd_prefix *pr)
{
	<span class="enscript-type">int</span> plen, error = 0, prproxy;
	<span class="enscript-type">struct</span> ifnet *ifp = pr-&gt;ndpr_ifp;
	<span class="enscript-type">struct</span> nd_prefix *opr;
	<span class="enscript-type">struct</span> sockaddr_in6 sa6, mask6, prefix;
	<span class="enscript-type">struct</span> rtentry *rt = NULL, *ndpr_rt = NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_NOTOWNED);

	<span class="enscript-comment">/* sanity check */</span>
	NDPR_LOCK(pr);
	<span class="enscript-keyword">if</span> ((pr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) == 0) {
		nd6log((LOG_ERR,
		    <span class="enscript-string">&quot;nd6_prefix_offlink: %s/%d on %s scoped=%d is already &quot;</span>
		    <span class="enscript-string">&quot;off-link\n&quot;</span>, ip6_sprintf(&amp;pr-&gt;ndpr_prefix.sin6_addr),
		    pr-&gt;ndpr_plen, if_name(pr-&gt;ndpr_ifp),
		    (pr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE) ? 1 : 0));
		NDPR_UNLOCK(pr);
		<span class="enscript-keyword">return</span> (EEXIST);
	}

	bzero(&amp;sa6, <span class="enscript-keyword">sizeof</span> (sa6));
	sa6.sin6_family = AF_INET6;
	sa6.sin6_len = <span class="enscript-keyword">sizeof</span> (sa6);
	bcopy(&amp;pr-&gt;ndpr_prefix.sin6_addr, &amp;sa6.sin6_addr,
	    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr));
	bzero(&amp;mask6, <span class="enscript-keyword">sizeof</span> (mask6));
	mask6.sin6_family = AF_INET6;
	mask6.sin6_len = <span class="enscript-keyword">sizeof</span> (sa6);
	bcopy(&amp;pr-&gt;ndpr_mask, &amp;mask6.sin6_addr, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> in6_addr));
	prefix = pr-&gt;ndpr_prefix;
	plen = pr-&gt;ndpr_plen;
	<span class="enscript-keyword">if</span> ((ndpr_rt = pr-&gt;ndpr_rt) != NULL)
		pr-&gt;ndpr_rt = NULL;
	NDPR_ADDREF_LOCKED(pr);		<span class="enscript-comment">/* keep reference for this routine */</span>
	NDPR_UNLOCK(pr);

	ifscope = (pr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE) ?
	    ifp-&gt;if_index : IFSCOPE_NONE;

	error = rtrequest_scoped(RTM_DELETE, (<span class="enscript-type">struct</span> sockaddr *)&amp;sa6,
	    NULL, (<span class="enscript-type">struct</span> sockaddr *)&amp;mask6, 0, &amp;rt, ifscope);

	<span class="enscript-keyword">if</span> (rt != NULL) {
		<span class="enscript-comment">/* report the route deletion to the routing socket. */</span>
		RT_LOCK(rt);
		nd6_rtmsg(RTM_DELETE, rt);
		RT_UNLOCK(rt);
		rtfree(rt);

		<span class="enscript-comment">/*
		 * The following check takes place only when Scoped Routing
		 * is not enabled.  There might be the same prefix on another
		 * interface, the prefix which could not be on-link just
		 * because we have the interface route (see comments in
		 * nd6_prefix_onlink).  If there's one, try to make the prefix
		 * on-link on the interface.
		 */</span>
		lck_mtx_lock(nd6_mutex);
		opr = nd_prefix.lh_first;
		<span class="enscript-keyword">while</span> (opr) {
			<span class="enscript-comment">/* does not apply in the Scoped Routing case */</span>
			<span class="enscript-keyword">if</span> (ip6_doscopedroute)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (opr == pr) {
				opr = opr-&gt;ndpr_next;
				<span class="enscript-keyword">continue</span>;
			}

			NDPR_LOCK(opr);
			<span class="enscript-keyword">if</span> ((opr-&gt;ndpr_stateflags &amp; NDPRF_ONLINK) != 0) {
				NDPR_UNLOCK(opr);
				opr = opr-&gt;ndpr_next;
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-comment">/*
			 * KAME specific: detached prefixes should not be
			 * on-link.
			 */</span>
			<span class="enscript-keyword">if</span> ((opr-&gt;ndpr_stateflags &amp; NDPRF_DETACHED) != 0) {
				NDPR_UNLOCK(opr);
				opr = opr-&gt;ndpr_next;
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (opr-&gt;ndpr_plen == plen &amp;&amp;
			    in6_are_prefix_equal(&amp;prefix.sin6_addr,
			    &amp;opr-&gt;ndpr_prefix.sin6_addr, plen)) {
				<span class="enscript-type">int</span> e;

				NDPR_ADDREF_LOCKED(opr);
				NDPR_UNLOCK(opr);
				<span class="enscript-keyword">if</span> ((e = nd6_prefix_onlink(opr)) != 0) {
					nd6log((LOG_ERR,
					    <span class="enscript-string">&quot;nd6_prefix_offlink: failed to &quot;</span>
					    <span class="enscript-string">&quot;recover a prefix %s/%d from %s &quot;</span>
					    <span class="enscript-string">&quot;to %s (errno = %d)\n&quot;</span>,
					    ip6_sprintf(
					    &amp;opr-&gt;ndpr_prefix.sin6_addr),
					    opr-&gt;ndpr_plen, if_name(ifp),
					    if_name(opr-&gt;ndpr_ifp), e));
				}
				NDPR_REMREF(opr);
				opr = nd_prefix.lh_first;
			} <span class="enscript-keyword">else</span> {
				NDPR_UNLOCK(opr);
				opr = opr-&gt;ndpr_next;
			}
		}
		lck_mtx_unlock(nd6_mutex);
	} <span class="enscript-keyword">else</span> {
		nd6log((LOG_ERR,
		    <span class="enscript-string">&quot;nd6_prefix_offlink: failed to delete route: &quot;</span>
		    <span class="enscript-string">&quot;%s/%d on %s, scoped %d, (errno = %d)\n&quot;</span>,
		    ip6_sprintf(&amp;sa6.sin6_addr), plen, if_name(ifp),
		    (ifscope != IFSCOPE_NONE), error));
	}

	<span class="enscript-keyword">if</span> (ndpr_rt != NULL)
		rtfree(ndpr_rt);

	lck_mtx_lock(&amp;proxy6_lock);

	NDPR_LOCK(pr);
	prproxy = (pr-&gt;ndpr_stateflags &amp; NDPRF_PRPROXY);
	VERIFY(!prproxy || !(pr-&gt;ndpr_stateflags &amp; NDPRF_IFSCOPE));
	pr-&gt;ndpr_stateflags &amp;= ~(NDPRF_ONLINK | NDPRF_IFSCOPE | NDPRF_PRPROXY);
	<span class="enscript-keyword">if</span> (pr-&gt;ndpr_prproxy_sols_cnt &gt; 0) {
		VERIFY(prproxy);
		nd6_prproxy_sols_reap(pr);
		VERIFY(pr-&gt;ndpr_prproxy_sols_cnt == 0);
		VERIFY(RB_EMPTY(&amp;pr-&gt;ndpr_prproxy_sols));
	}
	NDPR_UNLOCK(pr);

	<span class="enscript-comment">/*
	 * If this was an upstream prefix, find the downstream ones and do
	 * some cleanups.  If this was a downstream prefix, the prefix route
	 * has been removed from the routing table above, but there may be
	 * other tasks to perform.
	 */</span>
	nd6_prproxy_prelist_update(pr, prproxy ? pr : NULL);

	NDPR_REMREF(pr);	<span class="enscript-comment">/* release reference for this routine */</span>
	lck_mtx_unlock(&amp;proxy6_lock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> in6_ifaddr *
<span class="enscript-function-name">in6_pfx_newpersistaddr</span>(<span class="enscript-type">struct</span> nd_prefix *pr, <span class="enscript-type">int</span> mcast, <span class="enscript-type">int</span> *errorp)
{
	<span class="enscript-type">struct</span> in6_ifaddr *ia6 = NULL;
	<span class="enscript-type">struct</span> ifnet *ifp = NULL;
	<span class="enscript-type">struct</span> nd_ifinfo *ndi = NULL;
	<span class="enscript-type">struct</span> in6_addr mask;
	<span class="enscript-type">struct</span> in6_aliasreq ifra;
	<span class="enscript-type">int</span> error, ifaupdate, iidlen, notcga;

	VERIFY(pr != NULL);
	VERIFY(errorp != NULL);

	NDPR_LOCK(pr);
	ifp = pr-&gt;ndpr_ifp;
	ia6 = NULL;
	error = 0;

	<span class="enscript-comment">/*
	 * Prefix Length check:
	 * If the sum of the prefix length and interface identifier
	 * length does not equal 128 bits, the Prefix Information
	 * option MUST be ignored.  The length of the interface
	 * identifier is defined in a separate link-type specific
	 * document.
	 */</span>
	iidlen = in6_if2idlen(ifp);
	<span class="enscript-keyword">if</span> (iidlen &lt; 0) {
		error = EADDRNOTAVAIL;
		<span class="enscript-comment">/* this should not happen, so we always log it. */</span>
		log(LOG_ERR, <span class="enscript-string">&quot;%s: IID length undefined (%s)\n&quot;</span>,
		    __func__, if_name(ifp));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock1</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (iidlen != 64) {
		error = EADDRNOTAVAIL;
		<span class="enscript-comment">/*
		 * stateless autoconfiguration not yet well-defined for IID
		 * lengths other than 64 octets. Just give up for now.
		 */</span>
		nd6log((LOG_INFO, <span class="enscript-string">&quot;%s: IID length not 64 octets (%s)\n&quot;</span>,
		    __func__, if_name(ifp)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock1</span>;
	}

	<span class="enscript-keyword">if</span> (iidlen + pr-&gt;ndpr_plen != 128) {
		error = EADDRNOTAVAIL;
		nd6log((LOG_INFO,
		    <span class="enscript-string">&quot;%s: invalid prefix length %d for %s, ignored\n&quot;</span>,
		    __func__, pr-&gt;ndpr_plen, if_name(ifp)));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock1</span>;
	}

	bzero(&amp;ifra, <span class="enscript-keyword">sizeof</span> (ifra));
	strlcpy(ifra.ifra_name, if_name(ifp), <span class="enscript-keyword">sizeof</span> (ifra.ifra_name));
	ifra.ifra_addr.sin6_family = AF_INET6;
	ifra.ifra_addr.sin6_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);

	<span class="enscript-comment">/* prefix */</span>
	bcopy(&amp;pr-&gt;ndpr_prefix.sin6_addr, &amp;ifra.ifra_addr.sin6_addr,
	    <span class="enscript-keyword">sizeof</span> (ifra.ifra_addr.sin6_addr));
	in6_len2mask(&amp;mask, pr-&gt;ndpr_plen);
	ifra.ifra_addr.sin6_addr.s6_addr32[0] &amp;= mask.s6_addr32[0];
	ifra.ifra_addr.sin6_addr.s6_addr32[1] &amp;= mask.s6_addr32[1];
	ifra.ifra_addr.sin6_addr.s6_addr32[2] &amp;= mask.s6_addr32[2];
	ifra.ifra_addr.sin6_addr.s6_addr32[3] &amp;= mask.s6_addr32[3];

	ndi = ND_IFINFO(ifp);
	VERIFY(ndi-&gt;initialized);
	lck_mtx_lock(&amp;ndi-&gt;lock);

	notcga = nd6_send_opstate == ND6_SEND_OPMODE_DISABLED ||
	    (ndi-&gt;flags &amp; ND6_IFF_INSECURE) != 0;

	lck_mtx_unlock(&amp;ndi-&gt;lock);
	NDPR_UNLOCK(pr);

	<span class="enscript-keyword">if</span> (notcga) {
		ia6 = in6ifa_ifpforlinklocal(ifp, 0);
		<span class="enscript-keyword">if</span> (ia6 == NULL) {
			error = EADDRNOTAVAIL;
			nd6log((LOG_INFO, <span class="enscript-string">&quot;%s: no link-local address (%s)\n&quot;</span>,
			    __func__, if_name(ifp)));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		IFA_LOCK(&amp;ia6-&gt;ia_ifa);
		ifra.ifra_addr.sin6_addr.s6_addr32[0] |=
		    (ia6-&gt;ia_addr.sin6_addr.s6_addr32[0] &amp; ~mask.s6_addr32[0]);
		ifra.ifra_addr.sin6_addr.s6_addr32[1] |=
		    (ia6-&gt;ia_addr.sin6_addr.s6_addr32[1] &amp; ~mask.s6_addr32[1]);
		ifra.ifra_addr.sin6_addr.s6_addr32[2] |=
		    (ia6-&gt;ia_addr.sin6_addr.s6_addr32[2] &amp; ~mask.s6_addr32[2]);
		ifra.ifra_addr.sin6_addr.s6_addr32[3] |=
		    (ia6-&gt;ia_addr.sin6_addr.s6_addr32[3] &amp; ~mask.s6_addr32[3]);
		IFA_UNLOCK(&amp;ia6-&gt;ia_ifa);
		IFA_REMREF(&amp;ia6-&gt;ia_ifa);
		ia6 = NULL;
	} <span class="enscript-keyword">else</span> {
		in6_cga_node_lock();
		error = in6_cga_generate(NULL, 0, &amp;ifra.ifra_addr.sin6_addr);
		in6_cga_node_unlock();
		<span class="enscript-keyword">if</span> (error == 0)
			ifra.ifra_flags |= IN6_IFF_SECURED;
		<span class="enscript-keyword">else</span> {
			nd6log((LOG_ERR, <span class="enscript-string">&quot;%s: no CGA available (%s)\n&quot;</span>,
			    __func__, if_name(ifp)));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	VERIFY(ia6 == NULL);

	<span class="enscript-comment">/* new prefix mask. */</span>
	ifra.ifra_prefixmask.sin6_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6);
	ifra.ifra_prefixmask.sin6_family = AF_INET6;
	bcopy(&amp;mask, &amp;ifra.ifra_prefixmask.sin6_addr,
	    <span class="enscript-keyword">sizeof</span> (ifra.ifra_prefixmask.sin6_addr));

	<span class="enscript-comment">/* lifetimes. */</span>
	ifra.ifra_lifetime.ia6t_vltime = pr-&gt;ndpr_vltime;
	ifra.ifra_lifetime.ia6t_pltime = pr-&gt;ndpr_pltime;

	<span class="enscript-comment">/* address flags */</span>
	ifra.ifra_flags |= IN6_IFF_AUTOCONF; <span class="enscript-comment">/* obey autoconf */</span>

	<span class="enscript-comment">/*
	 * Make sure that we do not have this address already.  This should
	 * usually not happen, but we can still see this case, e.g., if we
	 * have manually configured the exact address to be configured.
	 */</span>
	<span class="enscript-keyword">if</span> ((ia6 = in6ifa_ifpwithaddr(ifp, &amp;ifra.ifra_addr.sin6_addr))
	    != NULL) {
		error = EADDRNOTAVAIL;
		IFA_REMREF(&amp;ia6-&gt;ia_ifa);
		ia6 = NULL;

		<span class="enscript-comment">/* this should be rare enough to make an explicit log */</span>
		log(LOG_INFO, <span class="enscript-string">&quot;%s: %s is already configured!\n&quot;</span>,
		    __func__, ip6_sprintf(&amp;ifra.ifra_addr.sin6_addr));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Allocate ifaddr structure, link into chain, etc.
	 * If we are going to create a new address upon receiving a multicasted
	 * RA, we need to impose a random delay before starting DAD.
	 * [RFC 4862, Section 5.4.2]
	 */</span>
	ifaupdate = IN6_IFAUPDATE_NOWAIT;
	<span class="enscript-keyword">if</span> (mcast)
		ifaupdate |= IN6_IFAUPDATE_DADDELAY;
	error = in6_update_ifa(ifp, &amp;ifra, ifaupdate, &amp;ia6);
	<span class="enscript-keyword">if</span> (error != 0) {
		nd6log((LOG_ERR,
		    <span class="enscript-string">&quot;%s: failed to make ifaddr %s on %s (errno=%d)\n&quot;</span>,
		    __func__, ip6_sprintf(&amp;ifra.ifra_addr.sin6_addr),
		    if_name(ifp), error));
		error = EADDRNOTAVAIL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	VERIFY(ia6 != NULL);
	in6_post_msg(ifp, KEV_INET6_NEW_RTADV_ADDR, ia6, NULL);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

<span class="enscript-reference">unlock1</span>:
	NDPR_UNLOCK(pr);

<span class="enscript-reference">done</span>:
	*errorp = error;
	<span class="enscript-keyword">return</span> (ia6);
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">IA6_NONCONST</span>(i) ((struct in6_ifaddr *)(uintptr_t)(i))

<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_tmpifadd</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in6_ifaddr *ia0, <span class="enscript-type">int</span> forcegen)
{
	<span class="enscript-type">struct</span> ifnet *ifp = ia0-&gt;ia_ifa.ifa_ifp;
	<span class="enscript-type">struct</span> in6_ifaddr *ia, *newia;
	<span class="enscript-type">struct</span> in6_aliasreq ifra;
	<span class="enscript-type">int</span> i, error, ifaupdate;
	<span class="enscript-type">int</span> trylimit = 3;	<span class="enscript-comment">/* XXX: adhoc value */</span>
	u_int32_t randid[2];
	time_t vltime0, pltime0;
	uint64_t timenow = net_uptime();
	<span class="enscript-type">struct</span> in6_addr addr;
	<span class="enscript-type">struct</span> nd_prefix *ndpr;

	bzero(&amp;ifra, <span class="enscript-keyword">sizeof</span> (ifra));
	strlcpy(ifra.ifra_name, if_name(ifp), <span class="enscript-keyword">sizeof</span> (ifra.ifra_name));
	IFA_LOCK(&amp;IA6_NONCONST(ia0)-&gt;ia_ifa);
	ifra.ifra_addr = ia0-&gt;ia_addr;
	<span class="enscript-comment">/* copy prefix mask */</span>
	ifra.ifra_prefixmask = ia0-&gt;ia_prefixmask;
	<span class="enscript-comment">/* clear the old IFID */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; 4; i++) {
		ifra.ifra_addr.sin6_addr.s6_addr32[i]
			&amp;= ifra.ifra_prefixmask.sin6_addr.s6_addr32[i];
	}
	addr = ia0-&gt;ia_addr.sin6_addr;
	IFA_UNLOCK(&amp;IA6_NONCONST(ia0)-&gt;ia_ifa);

<span class="enscript-reference">again</span>:
	in6_iid_mktmp(ifp, (u_int8_t *)randid,
	    (<span class="enscript-type">const</span> u_int8_t *)&amp;addr.s6_addr[8], forcegen);

	ifra.ifra_addr.sin6_addr.s6_addr32[2] |=
	    (randid[0] &amp; ~(ifra.ifra_prefixmask.sin6_addr.s6_addr32[2]));
	ifra.ifra_addr.sin6_addr.s6_addr32[3] |=
	    (randid[1] &amp; ~(ifra.ifra_prefixmask.sin6_addr.s6_addr32[3]));

	<span class="enscript-comment">/*
	 * in6_iid_mktmp() quite likely provided a unique interface ID.
	 * However, we may still have a chance to see collision, because
	 * there may be a time lag between generation of the ID and generation
	 * of the address.  So, we'll do one more sanity check.
	 */</span>
	<span class="enscript-keyword">if</span> ((ia = in6ifa_ifpwithaddr(ifp, &amp;ifra.ifra_addr.sin6_addr)) != NULL) {
		IFA_REMREF(&amp;ia-&gt;ia_ifa);
		<span class="enscript-keyword">if</span> (trylimit-- == 0) {
			nd6log((LOG_NOTICE, <span class="enscript-string">&quot;in6_tmpifadd: failed to find &quot;</span>
			    <span class="enscript-string">&quot;a unique random IFID\n&quot;</span>));
			<span class="enscript-keyword">return</span> (EEXIST);
		}
		forcegen = 1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}

	<span class="enscript-comment">/*
	 * The Valid Lifetime is the lower of the Valid Lifetime of the
	 * public address or TEMP_VALID_LIFETIME.
	 * The Preferred Lifetime is the lower of the Preferred Lifetime
	 * of the public address or TEMP_PREFERRED_LIFETIME -
	 * DESYNC_FACTOR.
	 */</span>
	IFA_LOCK(&amp;IA6_NONCONST(ia0)-&gt;ia_ifa);
	<span class="enscript-keyword">if</span> (ia0-&gt;ia6_lifetime.ia6ti_vltime != ND6_INFINITE_LIFETIME) {
		vltime0 = IFA6_IS_INVALID(ia0, timenow) ? 0 :
		    (ia0-&gt;ia6_lifetime.ia6ti_vltime -
		    (timenow - ia0-&gt;ia6_updatetime));
		<span class="enscript-keyword">if</span> (vltime0 &gt; ip6_temp_valid_lifetime)
			vltime0 = ip6_temp_valid_lifetime;
	} <span class="enscript-keyword">else</span> {
		vltime0 = ip6_temp_valid_lifetime;
	}
	<span class="enscript-keyword">if</span> (ia0-&gt;ia6_lifetime.ia6ti_pltime != ND6_INFINITE_LIFETIME) {
		pltime0 = IFA6_IS_DEPRECATED(ia0, timenow) ? 0 :
		    (ia0-&gt;ia6_lifetime.ia6ti_pltime -
		    (timenow - ia0-&gt;ia6_updatetime));
		<span class="enscript-keyword">if</span> (pltime0 &gt; ip6_temp_preferred_lifetime - ip6_desync_factor)
			pltime0 = ip6_temp_preferred_lifetime -
			    ip6_desync_factor;
	} <span class="enscript-keyword">else</span> {
		pltime0 = ip6_temp_preferred_lifetime - ip6_desync_factor;
	}
	ifra.ifra_lifetime.ia6t_vltime = vltime0;
	ifra.ifra_lifetime.ia6t_pltime = pltime0;
	IFA_UNLOCK(&amp;IA6_NONCONST(ia0)-&gt;ia_ifa);
	<span class="enscript-comment">/*
	 * A temporary address is created only if this calculated Preferred
	 * Lifetime is greater than REGEN_ADVANCE time units.
	 */</span>
	<span class="enscript-keyword">if</span> (ifra.ifra_lifetime.ia6t_pltime &lt;= ip6_temp_regen_advance)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/* XXX: scope zone ID? */</span>

	ifra.ifra_flags |= (IN6_IFF_AUTOCONF|IN6_IFF_TEMPORARY);

	<span class="enscript-comment">/* allocate ifaddr structure, link into chain, etc. */</span>
	ifaupdate = IN6_IFAUPDATE_NOWAIT | IN6_IFAUPDATE_DADDELAY;
	error = in6_update_ifa(ifp, &amp;ifra, ifaupdate, &amp;newia);
	<span class="enscript-keyword">if</span> (error != 0) {
		nd6log((LOG_ERR, <span class="enscript-string">&quot;in6_tmpifadd: failed to add address.\n&quot;</span>));
		<span class="enscript-keyword">return</span> (error);
	}
	VERIFY(newia != NULL);

	IFA_LOCK(&amp;IA6_NONCONST(ia0)-&gt;ia_ifa);
	ndpr = ia0-&gt;ia6_ndpr;
	<span class="enscript-keyword">if</span> (ndpr == NULL) {
		<span class="enscript-comment">/*
		 * We lost the race with another thread that has purged
		 * ia0 address; in this case, purge the tmp addr as well.
		 */</span>
		nd6log((LOG_ERR, <span class="enscript-string">&quot;in6_tmpifadd: no public address\n&quot;</span>));
		VERIFY(!(ia0-&gt;ia6_flags &amp; IN6_IFF_AUTOCONF));
		IFA_UNLOCK(&amp;IA6_NONCONST(ia0)-&gt;ia_ifa);
		in6_purgeaddr(&amp;newia-&gt;ia_ifa);
		IFA_REMREF(&amp;newia-&gt;ia_ifa);
		<span class="enscript-keyword">return</span> (EADDRNOTAVAIL);
	}
	NDPR_ADDREF(ndpr);	<span class="enscript-comment">/* for us */</span>
	IFA_UNLOCK(&amp;IA6_NONCONST(ia0)-&gt;ia_ifa);
	IFA_LOCK(&amp;newia-&gt;ia_ifa);
	<span class="enscript-keyword">if</span> (newia-&gt;ia6_ndpr != NULL) {
		NDPR_LOCK(newia-&gt;ia6_ndpr);
		VERIFY(newia-&gt;ia6_ndpr-&gt;ndpr_addrcnt != 0);
		newia-&gt;ia6_ndpr-&gt;ndpr_addrcnt--;
		NDPR_UNLOCK(newia-&gt;ia6_ndpr);
		NDPR_REMREF(newia-&gt;ia6_ndpr);	<span class="enscript-comment">/* release addr reference */</span>
	}
	newia-&gt;ia6_ndpr = ndpr;
	NDPR_LOCK(newia-&gt;ia6_ndpr);
	newia-&gt;ia6_ndpr-&gt;ndpr_addrcnt++;
	VERIFY(newia-&gt;ia6_ndpr-&gt;ndpr_addrcnt != 0);
	NDPR_ADDREF_LOCKED(newia-&gt;ia6_ndpr);	<span class="enscript-comment">/* for addr reference */</span>
	NDPR_UNLOCK(newia-&gt;ia6_ndpr);
	IFA_UNLOCK(&amp;newia-&gt;ia_ifa);
	<span class="enscript-comment">/*
	 * A newly added address might affect the status of other addresses.
	 * XXX: when the temporary address is generated with a new public
	 * address, the onlink check is redundant.  However, it would be safe
	 * to do the check explicitly everywhere a new address is generated,
	 * and, in fact, we surely need the check when we create a new
	 * temporary address due to deprecation of an old temporary address.
	 */</span>
	lck_mtx_lock(nd6_mutex);
	pfxlist_onlink_check();
	lck_mtx_unlock(nd6_mutex);
	IFA_REMREF(&amp;newia-&gt;ia_ifa);

	<span class="enscript-comment">/* remove our reference */</span>
	NDPR_REMREF(ndpr);

	<span class="enscript-keyword">return</span> (0);
}
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">IA6_NONCONST</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_init_prefix_ltimes</span>(<span class="enscript-type">struct</span> nd_prefix *ndpr)
{
	<span class="enscript-type">struct</span> timeval caltime;
	u_int64_t timenow = net_uptime();

	NDPR_LOCK_ASSERT_HELD(ndpr);

	getmicrotime(&amp;caltime);
	ndpr-&gt;ndpr_base_calendartime = caltime.tv_sec;
	ndpr-&gt;ndpr_base_uptime = timenow;

	<span class="enscript-comment">/* check if preferred lifetime &gt; valid lifetime.  RFC 4862 5.5.3 (c) */</span>
	<span class="enscript-keyword">if</span> (ndpr-&gt;ndpr_pltime &gt; ndpr-&gt;ndpr_vltime) {
		nd6log((LOG_INFO, <span class="enscript-string">&quot;in6_init_prefix_ltimes: preferred lifetime&quot;</span>
		    <span class="enscript-string">&quot;(%d) is greater than valid lifetime(%d)\n&quot;</span>,
		    (u_int)ndpr-&gt;ndpr_pltime, (u_int)ndpr-&gt;ndpr_vltime));
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> (ndpr-&gt;ndpr_pltime == ND6_INFINITE_LIFETIME)
		ndpr-&gt;ndpr_preferred = 0;
	<span class="enscript-keyword">else</span>
		ndpr-&gt;ndpr_preferred = timenow + ndpr-&gt;ndpr_pltime;
	<span class="enscript-keyword">if</span> (ndpr-&gt;ndpr_vltime == ND6_INFINITE_LIFETIME)
		ndpr-&gt;ndpr_expire = 0;
	<span class="enscript-keyword">else</span>
		ndpr-&gt;ndpr_expire = timenow + ndpr-&gt;ndpr_vltime;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">in6_init_address_ltimes</span>(<span class="enscript-type">struct</span> nd_prefix *new, <span class="enscript-type">struct</span> in6_addrlifetime *lt6)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">new</span>)
	uint64_t timenow = net_uptime();

	<span class="enscript-comment">/* Valid lifetime must not be updated unless explicitly specified. */</span>
	<span class="enscript-comment">/* init ia6t_expire */</span>
	<span class="enscript-keyword">if</span> (lt6-&gt;ia6t_vltime == ND6_INFINITE_LIFETIME) {
		lt6-&gt;ia6t_expire = 0;
	} <span class="enscript-keyword">else</span> {
		lt6-&gt;ia6t_expire = timenow;
		lt6-&gt;ia6t_expire += lt6-&gt;ia6t_vltime;
	}

	<span class="enscript-comment">/* init ia6t_preferred */</span>
	<span class="enscript-keyword">if</span> (lt6-&gt;ia6t_pltime == ND6_INFINITE_LIFETIME) {
		lt6-&gt;ia6t_preferred = 0;
	} <span class="enscript-keyword">else</span> {
		lt6-&gt;ia6t_preferred = timenow;
		lt6-&gt;ia6t_preferred += lt6-&gt;ia6t_pltime;
	}
}

<span class="enscript-comment">/*
 * Delete all the routing table entries that use the specified gateway.
 * XXX: this function causes search through all entries of routing table, so
 * it shouldn't be called when acting as a router.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">rt6_flush</span>(
	<span class="enscript-type">struct</span> in6_addr *gateway,
	<span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> radix_node_head *rnh = rt_tables[AF_INET6];

	<span class="enscript-comment">/* We'll care only link-local addresses */</span>
	<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_LINKLOCAL(gateway)) {
		<span class="enscript-keyword">return</span>;
	}
	lck_mtx_lock(rnh_lock);
	<span class="enscript-comment">/* XXX: hack for KAME's link-local address kludge */</span>
	gateway-&gt;s6_addr16[1] = htons(ifp-&gt;if_index);

	rnh-&gt;rnh_walktree(rnh, rt6_deleteroute, (<span class="enscript-type">void</span> *)gateway);
	lck_mtx_unlock(rnh_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">rt6_deleteroute</span>(
	<span class="enscript-type">struct</span> radix_node *rn,
	<span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> rtentry *rt = (<span class="enscript-type">struct</span> rtentry *)rn;
	<span class="enscript-type">struct</span> in6_addr *gate = (<span class="enscript-type">struct</span> in6_addr *)arg;

	lck_mtx_assert(rnh_lock, LCK_MTX_ASSERT_OWNED);

	RT_LOCK(rt);
	<span class="enscript-keyword">if</span> (rt-&gt;rt_gateway == NULL || rt-&gt;rt_gateway-&gt;sa_family != AF_INET6) {
		RT_UNLOCK(rt);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (!IN6_ARE_ADDR_EQUAL(gate, &amp;SIN6(rt-&gt;rt_gateway)-&gt;sin6_addr)) {
		RT_UNLOCK(rt);
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-comment">/*
	 * Do not delete a static route.
	 * XXX: this seems to be a bit ad-hoc. Should we consider the
	 * 'cloned' bit instead?
	 */</span>
	<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; RTF_STATIC) != 0) {
		RT_UNLOCK(rt);
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-comment">/*
	 * We delete only host route. This means, in particular, we don't
	 * delete default route.
	 */</span>
	<span class="enscript-keyword">if</span> ((rt-&gt;rt_flags &amp; RTF_HOST) == 0) {
		RT_UNLOCK(rt);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * Safe to drop rt_lock and use rt_key, rt_gateway, since holding
	 * rnh_lock here prevents another thread from calling rt_setgate()
	 * on this route.
	 */</span>
	RT_UNLOCK(rt);
	<span class="enscript-keyword">return</span> (rtrequest_locked(RTM_DELETE, rt_key(rt), rt-&gt;rt_gateway,
	    rt_mask(rt), rt-&gt;rt_flags, 0));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nd6_setdefaultiface</span>(
	<span class="enscript-type">int</span> ifindex)
{
	<span class="enscript-type">int</span> error = 0;
	ifnet_t def_ifp = NULL;

	lck_mtx_assert(nd6_mutex, LCK_MTX_ASSERT_NOTOWNED);

	ifnet_head_lock_shared();
	<span class="enscript-keyword">if</span> (ifindex &lt; 0 || if_index &lt; ifindex) {
		ifnet_head_done();
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	def_ifp = ifindex2ifnet[ifindex];
	ifnet_head_done();

	lck_mtx_lock(nd6_mutex);
	<span class="enscript-keyword">if</span> (nd6_defifindex != ifindex) {
		<span class="enscript-type">struct</span> ifnet *odef_ifp = nd6_defifp;

		nd6_defifindex = ifindex;
		<span class="enscript-keyword">if</span> (nd6_defifindex &gt; 0)
			nd6_defifp = def_ifp;
		<span class="enscript-keyword">else</span>
			nd6_defifp = NULL;

		<span class="enscript-keyword">if</span> (nd6_defifp != NULL)
			nd6log((LOG_INFO, <span class="enscript-string">&quot;%s: is now the default &quot;</span>
			    <span class="enscript-string">&quot;interface (was %s)\n&quot;</span>, if_name(nd6_defifp),
			    odef_ifp != NULL ? if_name(odef_ifp) : <span class="enscript-string">&quot;NONE&quot;</span>));
		<span class="enscript-keyword">else</span>
			nd6log((LOG_INFO, <span class="enscript-string">&quot;No default interface set\n&quot;</span>));

		<span class="enscript-comment">/*
		 * If the Default Router List is empty, install a route
		 * to the specified interface as default or remove the default
		 * route when the default interface becomes canceled.
		 * The check for the queue is actually redundant, but
		 * we do this here to avoid re-install the default route
		 * if the list is NOT empty.
		 */</span>
		<span class="enscript-keyword">if</span> (ip6_doscopedroute || TAILQ_FIRST(&amp;nd_defrouter) == NULL) {
			defrtrlist_sync(nd6_defifp);
			nd6_prefix_sync(nd6_defifp);
		}

		<span class="enscript-comment">/*
		 * Our current implementation assumes one-to-one mapping between
		 * interfaces and links, so it would be natural to use the
		 * default interface as the default link.
		 */</span>
		scope6_setdefault(nd6_defifp);
	}
	lck_mtx_unlock(nd6_mutex);

	<span class="enscript-keyword">return</span> (error);
}
</pre>
<hr />
</body></html>