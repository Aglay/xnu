<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ipsec.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ipsec.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$FreeBSD: src/sys/netinet6/ipsec.c,v 1.3.2.7 2001/07/19 06:37:23 kris Exp $	*/</span>
<span class="enscript-comment">/*	$KAME: ipsec.c,v 1.103 2001/05/24 07:14:18 sakane Exp $	*/</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

<span class="enscript-comment">/*
 * IPsec controller part.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_ipsec.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_ecn.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_ecn.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ah.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ah6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/esp6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipcomp.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipcomp6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/keydb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key_debug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_DEBUG</span>
<span class="enscript-type">int</span> ipsec_debug = 1;
#<span class="enscript-reference">else</span>
<span class="enscript-type">int</span> ipsec_debug = 0;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_LAYER_BEG</span>			NETDBG_CODE(DBG_NETIPSEC, 1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_LAYER_END</span>			NETDBG_CODE(DBG_NETIPSEC, 3)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_FNC_GETPOL_SOCK</span>		NETDBG_CODE(DBG_NETIPSEC, (1 &lt;&lt; 8))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_FNC_GETPOL_ADDR</span>		NETDBG_CODE(DBG_NETIPSEC, (2 &lt;&lt; 8))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DBG_FNC_IPSEC_OUT</span>		NETDBG_CODE(DBG_NETIPSEC, (3 &lt;&lt; 8))

<span class="enscript-type">extern</span> lck_mtx_t *sadb_mutex;

<span class="enscript-type">struct</span> ipsecstat ipsecstat;
<span class="enscript-type">int</span> ip4_ah_cleartos = 1;
<span class="enscript-type">int</span> ip4_ah_offsetmask = 0;	<span class="enscript-comment">/* maybe IP_DF? */</span>
<span class="enscript-type">int</span> ip4_ipsec_dfbit = 0;	<span class="enscript-comment">/* DF bit on encap. 0: clear 1: set 2: copy */</span>
<span class="enscript-type">int</span> ip4_esp_trans_deflev = IPSEC_LEVEL_USE;
<span class="enscript-type">int</span> ip4_esp_net_deflev = IPSEC_LEVEL_USE;
<span class="enscript-type">int</span> ip4_ah_trans_deflev = IPSEC_LEVEL_USE;
<span class="enscript-type">int</span> ip4_ah_net_deflev = IPSEC_LEVEL_USE;
<span class="enscript-type">struct</span> secpolicy ip4_def_policy;
<span class="enscript-type">int</span> ip4_ipsec_ecn = ECN_COMPATIBILITY;		<span class="enscript-comment">/* ECN ignore(-1)/compatibility(0)/normal(1) */</span>
<span class="enscript-type">int</span> ip4_esp_randpad = -1;
<span class="enscript-type">int</span>	esp_udp_encap_port = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_def_policy SYSCTL_HANDLER_ARGS;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> natt_keepalive_interval;
<span class="enscript-type">extern</span> u_int32_t natt_now;

<span class="enscript-type">struct</span> ipsec_tag;

<span class="enscript-function-name">SYSCTL_DECL</span>(_net_inet_ipsec);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-function-name">SYSCTL_DECL</span>(_net_inet6_ipsec6);
#<span class="enscript-reference">endif</span>
<span class="enscript-comment">/* net.inet.ipsec */</span>
<span class="enscript-function-name">SYSCTL_STRUCT</span>(_net_inet_ipsec, IPSECCTL_STATS,
	stats, CTLFLAG_RD | CTLFLAG_LOCKED,	&amp;ipsecstat,	ipsecstat, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_inet_ipsec, IPSECCTL_DEF_POLICY, def_policy, CTLTYPE_INT|CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;ip4_def_policy.policy,	0, &amp;sysctl_def_policy, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ipsec, IPSECCTL_DEF_ESP_TRANSLEV, esp_trans_deflev,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip4_esp_trans_deflev,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ipsec, IPSECCTL_DEF_ESP_NETLEV, esp_net_deflev,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip4_esp_net_deflev,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ipsec, IPSECCTL_DEF_AH_TRANSLEV, ah_trans_deflev,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip4_ah_trans_deflev,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ipsec, IPSECCTL_DEF_AH_NETLEV, ah_net_deflev,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip4_ah_net_deflev,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ipsec, IPSECCTL_AH_CLEARTOS,
	ah_cleartos, CTLFLAG_RW | CTLFLAG_LOCKED,	&amp;ip4_ah_cleartos,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ipsec, IPSECCTL_AH_OFFSETMASK,
	ah_offsetmask, CTLFLAG_RW | CTLFLAG_LOCKED,	&amp;ip4_ah_offsetmask,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ipsec, IPSECCTL_DFBIT,
	dfbit, CTLFLAG_RW | CTLFLAG_LOCKED,	&amp;ip4_ipsec_dfbit,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ipsec, IPSECCTL_ECN,
	ecn, CTLFLAG_RW | CTLFLAG_LOCKED,	&amp;ip4_ipsec_ecn,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ipsec, IPSECCTL_DEBUG,
	debug, CTLFLAG_RW | CTLFLAG_LOCKED,	&amp;ipsec_debug,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ipsec, IPSECCTL_ESP_RANDPAD,
	esp_randpad, CTLFLAG_RW | CTLFLAG_LOCKED,	&amp;ip4_esp_randpad,	0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* for performance, we bypass ipsec until a security policy is set */</span>
<span class="enscript-type">int</span> ipsec_bypass = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ipsec, OID_AUTO, bypass, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;ipsec_bypass,0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/*
 * NAT Traversal requires a UDP port for encapsulation,
 * esp_udp_encap_port controls which port is used. Racoon
 * must set this port to the port racoon is using locally
 * for nat traversal.
 */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet_ipsec, OID_AUTO, esp_port,
		   CTLFLAG_RW | CTLFLAG_LOCKED, &amp;esp_udp_encap_port, 0, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">struct</span> ipsecstat ipsec6stat;
<span class="enscript-type">int</span> ip6_esp_trans_deflev = IPSEC_LEVEL_USE;
<span class="enscript-type">int</span> ip6_esp_net_deflev = IPSEC_LEVEL_USE;
<span class="enscript-type">int</span> ip6_ah_trans_deflev = IPSEC_LEVEL_USE;
<span class="enscript-type">int</span> ip6_ah_net_deflev = IPSEC_LEVEL_USE;
<span class="enscript-type">struct</span> secpolicy ip6_def_policy;
<span class="enscript-type">int</span> ip6_ipsec_ecn = ECN_COMPATIBILITY;		<span class="enscript-comment">/* ECN ignore(-1)/compatibility(0)/normal(1) */</span>
<span class="enscript-type">int</span> ip6_esp_randpad = -1;

<span class="enscript-comment">/* net.inet6.ipsec6 */</span>
<span class="enscript-function-name">SYSCTL_STRUCT</span>(_net_inet6_ipsec6, IPSECCTL_STATS,
	stats, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;ipsec6stat, ipsecstat, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ipsec6, IPSECCTL_DEF_POLICY,
	def_policy, CTLFLAG_RW | CTLFLAG_LOCKED,	&amp;ip6_def_policy.policy,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ipsec6, IPSECCTL_DEF_ESP_TRANSLEV, esp_trans_deflev,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip6_esp_trans_deflev,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ipsec6, IPSECCTL_DEF_ESP_NETLEV, esp_net_deflev,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip6_esp_net_deflev,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ipsec6, IPSECCTL_DEF_AH_TRANSLEV, ah_trans_deflev,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip6_ah_trans_deflev,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ipsec6, IPSECCTL_DEF_AH_NETLEV, ah_net_deflev,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ip6_ah_net_deflev,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ipsec6, IPSECCTL_ECN,
	ecn, CTLFLAG_RW | CTLFLAG_LOCKED,	&amp;ip6_ipsec_ecn,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ipsec6, IPSECCTL_DEBUG,
	debug, CTLFLAG_RW | CTLFLAG_LOCKED,	&amp;ipsec_debug,	0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_net_inet6_ipsec6, IPSECCTL_ESP_RANDPAD,
	esp_randpad, CTLFLAG_RW | CTLFLAG_LOCKED,	&amp;ip6_esp_randpad,	0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ipsec_setspidx_interface</span>(<span class="enscript-type">struct</span> secpolicyindex *, u_int, <span class="enscript-type">struct</span> mbuf *,
                         <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ipsec_setspidx_mbuf</span>(<span class="enscript-type">struct</span> secpolicyindex *, u_int, u_int,
	<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ipsec4_setspidx_inpcb</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> inpcb *pcb);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ipsec6_setspidx_in6pcb</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> in6pcb *pcb);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ipsec_setspidx</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> secpolicyindex *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipsec4_get_ulp</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> secpolicyindex *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ipsec4_setspidx_ipaddr</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> secpolicyindex *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipsec6_get_ulp</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> secpolicyindex *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ipsec6_setspidx_ipaddr</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> secpolicyindex *);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> inpcbpolicy *<span class="enscript-function-name">ipsec_newpcbpolicy</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipsec_delpcbpolicy</span>(<span class="enscript-type">struct</span> inpcbpolicy *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secpolicy *<span class="enscript-function-name">ipsec_deepcopy_policy</span>(<span class="enscript-type">struct</span> secpolicy *src);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ipsec_set_policy</span>(<span class="enscript-type">struct</span> secpolicy **pcb_sp,
							<span class="enscript-type">int</span> optname, caddr_t request, size_t len, <span class="enscript-type">int</span> priv);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vshiftl</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ipsec_in_reject</span>(<span class="enscript-type">struct</span> secpolicy *, <span class="enscript-type">struct</span> mbuf *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ipsec64_encapsulate</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> secasvar *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ipsec6_update_routecache_and_output</span>(<span class="enscript-type">struct</span> ipsec_output_state *state, <span class="enscript-type">struct</span> secasvar *sav);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ipsec46_encapsulate</span>(<span class="enscript-type">struct</span> ipsec_output_state *state, <span class="enscript-type">struct</span> secasvar *sav);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ipsec_tag *<span class="enscript-function-name">ipsec_addaux</span>(<span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ipsec_tag *<span class="enscript-function-name">ipsec_findaux</span>(<span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipsec_optaux</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> ipsec_tag *);
<span class="enscript-type">int</span> <span class="enscript-function-name">ipsec_send_natt_keepalive</span>(<span class="enscript-type">struct</span> secasvar *sav);
bool <span class="enscript-function-name">ipsec_fill_offload_frame</span>(ifnet_t ifp, <span class="enscript-type">struct</span> secasvar *sav, <span class="enscript-type">struct</span> ifnet_keepalive_offload_frame *frame, size_t frame_data_offset);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_def_policy SYSCTL_HANDLER_ARGS
{
	<span class="enscript-type">int</span> old_policy = ip4_def_policy.policy;
	<span class="enscript-type">int</span> error = sysctl_handle_int(oidp, oidp-&gt;oid_arg1, oidp-&gt;oid_arg2, req);

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)

	<span class="enscript-keyword">if</span> (ip4_def_policy.policy != IPSEC_POLICY_NONE &amp;&amp;
		ip4_def_policy.policy != IPSEC_POLICY_DISCARD) {
		ip4_def_policy.policy = old_policy;
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* Turn off the bypass if the default security policy changes */</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass != 0 &amp;&amp; ip4_def_policy.policy != IPSEC_POLICY_NONE)
		ipsec_bypass = 0;

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * For OUTBOUND packet having a socket. Searching SPD for packet,
 * and return a pointer to SP.
 * OUT:	NULL:	no apropreate SP found, the following value is set to error.
 *		0	: bypass
 *		EACCES	: discard packet.
 *		ENOENT	: ipsec_acquire() in progress, maybe.
 *		others	: error occurred.
 *	others:	a pointer to SP
 *
 * NOTE: IPv6 mapped adddress concern is implemented here.
 */</span>
<span class="enscript-type">struct</span> secpolicy *
<span class="enscript-function-name">ipsec4_getpolicybysock</span>(<span class="enscript-type">struct</span> mbuf *m,
					   u_int dir,
					   <span class="enscript-type">struct</span> socket *so,
					   <span class="enscript-type">int</span> *error)
{
	<span class="enscript-type">struct</span> inpcbpolicy *pcbsp = NULL;
	<span class="enscript-type">struct</span> secpolicy *currsp = NULL;	<span class="enscript-comment">/* policy on socket */</span>
	<span class="enscript-type">struct</span> secpolicy *kernsp = NULL;	<span class="enscript-comment">/* policy on kernel */</span>
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL || so == NULL || error == NULL)
		panic(<span class="enscript-string">&quot;ipsec4_getpolicybysock: NULL pointer was passed.\n&quot;</span>);
		
		<span class="enscript-keyword">if</span> (so-&gt;so_pcb == NULL) {
			printf(<span class="enscript-string">&quot;ipsec4_getpolicybysock: so-&gt;so_pcb == NULL\n&quot;</span>);
			<span class="enscript-keyword">return</span> ipsec4_getpolicybyaddr(m, dir, 0, error);
		}
	
	<span class="enscript-keyword">switch</span> (SOCK_DOM(so)) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET</span>:
			pcbsp = sotoinpcb(so)-&gt;inp_sp;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET6</span>:
			pcbsp = sotoin6pcb(so)-&gt;in6p_sp;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
	}
	
	<span class="enscript-keyword">if</span> (!pcbsp){
		<span class="enscript-comment">/* Socket has not specified an IPSEC policy */</span>
		<span class="enscript-keyword">return</span> ipsec4_getpolicybyaddr(m, dir, 0, error);
	}
	
	KERNEL_DEBUG(DBG_FNC_GETPOL_SOCK | DBG_FUNC_START, 0,0,0,0,0);
	
	<span class="enscript-keyword">switch</span> (SOCK_DOM(so)) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET</span>:
			<span class="enscript-comment">/* set spidx in pcb */</span>
			*error = ipsec4_setspidx_inpcb(m, sotoinpcb(so));
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET6</span>:
			<span class="enscript-comment">/* set spidx in pcb */</span>
			*error = ipsec6_setspidx_in6pcb(m, sotoin6pcb(so));
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;ipsec4_getpolicybysock: unsupported address family\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (*error) {
		KERNEL_DEBUG(DBG_FNC_GETPOL_SOCK | DBG_FUNC_END, 1,*error,0,0,0);
		<span class="enscript-keyword">return</span> NULL;
	}
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (pcbsp == NULL)
		panic(<span class="enscript-string">&quot;ipsec4_getpolicybysock: pcbsp is NULL.\n&quot;</span>);
		
		<span class="enscript-keyword">switch</span> (dir) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_DIR_INBOUND</span>:
				currsp = pcbsp-&gt;sp_in;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_DIR_OUTBOUND</span>:
				currsp = pcbsp-&gt;sp_out;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				panic(<span class="enscript-string">&quot;ipsec4_getpolicybysock: illegal direction.\n&quot;</span>);
		}
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (currsp == NULL)
		panic(<span class="enscript-string">&quot;ipsec4_getpolicybysock: currsp is NULL.\n&quot;</span>);
		
	<span class="enscript-comment">/* when privilieged socket */</span>
		<span class="enscript-keyword">if</span> (pcbsp-&gt;priv) {
			<span class="enscript-keyword">switch</span> (currsp-&gt;policy) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_BYPASS</span>:
					lck_mtx_lock(sadb_mutex);
					currsp-&gt;refcnt++;
					lck_mtx_unlock(sadb_mutex);
					*error = 0;
					KERNEL_DEBUG(DBG_FNC_GETPOL_SOCK | DBG_FUNC_END, 2,*error,0,0,0);
					<span class="enscript-keyword">return</span> currsp;
					
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_ENTRUST</span>:
					<span class="enscript-comment">/* look for a policy in SPD */</span>
					kernsp = key_allocsp(&amp;currsp-&gt;spidx, dir);
					
					<span class="enscript-comment">/* SP found */</span>
					<span class="enscript-keyword">if</span> (kernsp != NULL) {
						KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
								 printf(<span class="enscript-string">&quot;DP ipsec4_getpolicybysock called &quot;</span>
										<span class="enscript-string">&quot;to allocate SP:0x%llx\n&quot;</span>,
										(uint64_t)VM_KERNEL_ADDRPERM(kernsp)));
						*error = 0;
						KERNEL_DEBUG(DBG_FNC_GETPOL_SOCK | DBG_FUNC_END, 3,*error,0,0,0);
						<span class="enscript-keyword">return</span> kernsp;
					}
					
					<span class="enscript-comment">/* no SP found */</span>
					lck_mtx_lock(sadb_mutex);
					<span class="enscript-keyword">if</span> (ip4_def_policy.policy != IPSEC_POLICY_DISCARD
						&amp;&amp; ip4_def_policy.policy != IPSEC_POLICY_NONE) {
						ipseclog((LOG_INFO,
								  <span class="enscript-string">&quot;fixed system default policy: %d-&gt;%d\n&quot;</span>,
								  ip4_def_policy.policy, IPSEC_POLICY_NONE));
						ip4_def_policy.policy = IPSEC_POLICY_NONE;
					}
					ip4_def_policy.refcnt++;
					lck_mtx_unlock(sadb_mutex);
					*error = 0;
					KERNEL_DEBUG(DBG_FNC_GETPOL_SOCK | DBG_FUNC_END, 4,*error,0,0,0);
					<span class="enscript-keyword">return</span> &amp;ip4_def_policy;
					
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_IPSEC</span>:
					lck_mtx_lock(sadb_mutex);
					currsp-&gt;refcnt++;
					lck_mtx_unlock(sadb_mutex);
					*error = 0;
					KERNEL_DEBUG(DBG_FNC_GETPOL_SOCK | DBG_FUNC_END, 5,*error,0,0,0);
					<span class="enscript-keyword">return</span> currsp;
					
				<span class="enscript-reference">default</span>:
					ipseclog((LOG_ERR, <span class="enscript-string">&quot;ipsec4_getpolicybysock: &quot;</span>
			      <span class="enscript-string">&quot;Invalid policy for PCB %d\n&quot;</span>, currsp-&gt;policy));
					*error = EINVAL;
					KERNEL_DEBUG(DBG_FNC_GETPOL_SOCK | DBG_FUNC_END, 6,*error,0,0,0);
					<span class="enscript-keyword">return</span> NULL;
			}
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
	
	<span class="enscript-comment">/* when non-privilieged socket */</span>
	<span class="enscript-comment">/* look for a policy in SPD */</span>
	kernsp = key_allocsp(&amp;currsp-&gt;spidx, dir);
	
	<span class="enscript-comment">/* SP found */</span>
	<span class="enscript-keyword">if</span> (kernsp != NULL) {
		KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
				 printf(<span class="enscript-string">&quot;DP ipsec4_getpolicybysock called &quot;</span>
		    <span class="enscript-string">&quot;to allocate SP:0x%llx\n&quot;</span>,
		    (uint64_t)VM_KERNEL_ADDRPERM(kernsp)));
		*error = 0;
		KERNEL_DEBUG(DBG_FNC_GETPOL_SOCK | DBG_FUNC_END, 7,*error,0,0,0);
		<span class="enscript-keyword">return</span> kernsp;
	}
	
	<span class="enscript-comment">/* no SP found */</span>
	<span class="enscript-keyword">switch</span> (currsp-&gt;policy) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_BYPASS</span>:
			ipseclog((LOG_ERR, <span class="enscript-string">&quot;ipsec4_getpolicybysock: &quot;</span>
					  <span class="enscript-string">&quot;Illegal policy for non-priviliged defined %d\n&quot;</span>,
					  currsp-&gt;policy));
			*error = EINVAL;
			KERNEL_DEBUG(DBG_FNC_GETPOL_SOCK | DBG_FUNC_END, 8,*error,0,0,0);
			<span class="enscript-keyword">return</span> NULL;
			
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_ENTRUST</span>:
			lck_mtx_lock(sadb_mutex);
			<span class="enscript-keyword">if</span> (ip4_def_policy.policy != IPSEC_POLICY_DISCARD
				&amp;&amp; ip4_def_policy.policy != IPSEC_POLICY_NONE) {
				ipseclog((LOG_INFO,
						  <span class="enscript-string">&quot;fixed system default policy: %d-&gt;%d\n&quot;</span>,
						  ip4_def_policy.policy, IPSEC_POLICY_NONE));
				ip4_def_policy.policy = IPSEC_POLICY_NONE;
			}
			ip4_def_policy.refcnt++;
			lck_mtx_unlock(sadb_mutex);
			*error = 0;
			KERNEL_DEBUG(DBG_FNC_GETPOL_SOCK | DBG_FUNC_END, 9,*error,0,0,0);
			<span class="enscript-keyword">return</span> &amp;ip4_def_policy;
			
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_IPSEC</span>:
			lck_mtx_lock(sadb_mutex);
			currsp-&gt;refcnt++;
			lck_mtx_unlock(sadb_mutex);
			*error = 0;
			KERNEL_DEBUG(DBG_FNC_GETPOL_SOCK | DBG_FUNC_END, 10,*error,0,0,0);
			<span class="enscript-keyword">return</span> currsp;
			
		<span class="enscript-reference">default</span>:
			ipseclog((LOG_ERR, <span class="enscript-string">&quot;ipsec4_getpolicybysock: &quot;</span>
					  <span class="enscript-string">&quot;Invalid policy for PCB %d\n&quot;</span>, currsp-&gt;policy));
			*error = EINVAL;
			KERNEL_DEBUG(DBG_FNC_GETPOL_SOCK | DBG_FUNC_END, 11,*error,0,0,0);
			<span class="enscript-keyword">return</span> NULL;
	}
	<span class="enscript-comment">/* NOTREACHED */</span>
}

<span class="enscript-comment">/*
 * For FORWADING packet or OUTBOUND without a socket. Searching SPD for packet,
 * and return a pointer to SP.
 * OUT:	positive: a pointer to the entry for security policy leaf matched.
 *	NULL:	no apropreate SP found, the following value is set to error.
 *		0	: bypass
 *		EACCES	: discard packet.
 *		ENOENT	: ipsec_acquire() in progress, maybe.
 *		others	: error occurred.
 */</span>
<span class="enscript-type">struct</span> secpolicy *
<span class="enscript-function-name">ipsec4_getpolicybyaddr</span>(<span class="enscript-type">struct</span> mbuf *m,
                       u_int dir,
                       <span class="enscript-type">int</span> flag,
                       <span class="enscript-type">int</span> *error)
{
	<span class="enscript-type">struct</span> secpolicy *sp = NULL;
    
	<span class="enscript-keyword">if</span> (ipsec_bypass != 0)
		<span class="enscript-keyword">return</span> 0;

	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL || error == NULL)
		panic(<span class="enscript-string">&quot;ipsec4_getpolicybyaddr: NULL pointer was passed.\n&quot;</span>);
	{
		<span class="enscript-type">struct</span> secpolicyindex spidx;

		KERNEL_DEBUG(DBG_FNC_GETPOL_ADDR | DBG_FUNC_START, 0,0,0,0,0);
		bzero(&amp;spidx, <span class="enscript-keyword">sizeof</span>(spidx));

		<span class="enscript-comment">/* make a index to look for a policy */</span>
		*error = ipsec_setspidx_mbuf(&amp;spidx, dir, AF_INET, m,
			(flag &amp; IP_FORWARDING) ? 0 : 1);

		<span class="enscript-keyword">if</span> (*error != 0) {
			KERNEL_DEBUG(DBG_FNC_GETPOL_ADDR | DBG_FUNC_END, 1,*error,0,0,0);
			<span class="enscript-keyword">return</span> NULL;
		}

		sp = key_allocsp(&amp;spidx, dir);
	}

	<span class="enscript-comment">/* SP found */</span>
	<span class="enscript-keyword">if</span> (sp != NULL) {
		KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
		    printf(<span class="enscript-string">&quot;DP ipsec4_getpolicybyaddr called &quot;</span>
		    <span class="enscript-string">&quot;to allocate SP:0x%llx\n&quot;</span>,
		    (uint64_t)VM_KERNEL_ADDRPERM(sp)));
		*error = 0;
		KERNEL_DEBUG(DBG_FNC_GETPOL_ADDR | DBG_FUNC_END, 2,*error,0,0,0);
		<span class="enscript-keyword">return</span> sp;
	}

	<span class="enscript-comment">/* no SP found */</span>
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">if</span> (ip4_def_policy.policy != IPSEC_POLICY_DISCARD
	 &amp;&amp; ip4_def_policy.policy != IPSEC_POLICY_NONE) {
		ipseclog((LOG_INFO, <span class="enscript-string">&quot;fixed system default policy:%d-&gt;%d\n&quot;</span>,
			ip4_def_policy.policy,
			IPSEC_POLICY_NONE));
		ip4_def_policy.policy = IPSEC_POLICY_NONE;
	}
	ip4_def_policy.refcnt++;
	lck_mtx_unlock(sadb_mutex);
	*error = 0;
	KERNEL_DEBUG(DBG_FNC_GETPOL_ADDR | DBG_FUNC_END, 3,*error,0,0,0);
	<span class="enscript-keyword">return</span> &amp;ip4_def_policy;
}

<span class="enscript-comment">/* Match with bound interface rather than src addr.
 * Unlike getpolicybyaddr, do not set the default policy.
 * Return 0 if should continue processing, or -1 if packet
 * should be dropped.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec4_getpolicybyinterface</span>(<span class="enscript-type">struct</span> mbuf *m,
                            u_int dir,
                            <span class="enscript-type">int</span> *flags,
                            <span class="enscript-type">struct</span> ip_out_args *ipoa,
                            <span class="enscript-type">struct</span> secpolicy **sp)
{
	<span class="enscript-type">struct</span> secpolicyindex spidx;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (ipsec_bypass != 0)
		<span class="enscript-keyword">return</span> 0;
    
	<span class="enscript-comment">/* Sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL || ipoa == NULL || sp == NULL)
		panic(<span class="enscript-string">&quot;ipsec4_getpolicybyinterface: NULL pointer was passed.\n&quot;</span>);
    
	<span class="enscript-keyword">if</span> (ipoa-&gt;ipoa_boundif == IFSCOPE_NONE)
		<span class="enscript-keyword">return</span> 0;
 
	KERNEL_DEBUG(DBG_FNC_GETPOL_ADDR | DBG_FUNC_START, 0,0,0,0,0);
	bzero(&amp;spidx, <span class="enscript-keyword">sizeof</span>(spidx));
    
	<span class="enscript-comment">/* make a index to look for a policy */</span>
	error = ipsec_setspidx_interface(&amp;spidx, dir, m, (*flags &amp; IP_FORWARDING) ? 0 : 1,
					ipoa-&gt;ipoa_boundif, 4);
    
	<span class="enscript-keyword">if</span> (error != 0) {
		KERNEL_DEBUG(DBG_FNC_GETPOL_ADDR | DBG_FUNC_END, 1,error,0,0,0);
		<span class="enscript-keyword">return</span> 0;
	}
    
	*sp = key_allocsp(&amp;spidx, dir);

	<span class="enscript-comment">/* Return SP, whether NULL or not */</span>
	<span class="enscript-keyword">if</span> (*sp != NULL &amp;&amp; (*sp)-&gt;policy == IPSEC_POLICY_IPSEC) {
		<span class="enscript-keyword">if</span> ((*sp)-&gt;ipsec_if == NULL) {
			<span class="enscript-comment">/* Invalid to capture on an interface without redirect */</span>
			key_freesp(*sp, KEY_SADB_UNLOCKED);
			*sp = NULL;
			<span class="enscript-keyword">return</span> -1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((*sp)-&gt;disabled) {
			<span class="enscript-comment">/* Disabled policies go in the clear */</span>
			key_freesp(*sp, KEY_SADB_UNLOCKED);
			*sp = NULL;
			*flags |= IP_NOIPSEC; <span class="enscript-comment">/* Avoid later IPSec check */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* If policy is enabled, redirect to ipsec interface */</span>
			ipoa-&gt;ipoa_boundif = (*sp)-&gt;ipsec_if-&gt;if_index;
		}
	}
    
	KERNEL_DEBUG(DBG_FNC_GETPOL_ADDR | DBG_FUNC_END, 2,error,0,0,0);
    
	<span class="enscript-keyword">return</span> 0;
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-comment">/*
 * For OUTBOUND packet having a socket. Searching SPD for packet,
 * and return a pointer to SP.
 * OUT:	NULL:	no apropreate SP found, the following value is set to error.
 *		0	: bypass
 *		EACCES	: discard packet.
 *		ENOENT	: ipsec_acquire() in progress, maybe.
 *		others	: error occurred.
 *	others:	a pointer to SP
 */</span>
<span class="enscript-type">struct</span> secpolicy *
<span class="enscript-function-name">ipsec6_getpolicybysock</span>(<span class="enscript-type">struct</span> mbuf *m,
					   u_int dir,
					   <span class="enscript-type">struct</span> socket *so,
					   <span class="enscript-type">int</span> *error)
{
	<span class="enscript-type">struct</span> inpcbpolicy *pcbsp = NULL;
	<span class="enscript-type">struct</span> secpolicy *currsp = NULL;	<span class="enscript-comment">/* policy on socket */</span>
	<span class="enscript-type">struct</span> secpolicy *kernsp = NULL;	<span class="enscript-comment">/* policy on kernel */</span>
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL || so == NULL || error == NULL)
		panic(<span class="enscript-string">&quot;ipsec6_getpolicybysock: NULL pointer was passed.\n&quot;</span>);
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		<span class="enscript-keyword">if</span> (SOCK_DOM(so) != PF_INET6)
			panic(<span class="enscript-string">&quot;ipsec6_getpolicybysock: socket domain != inet6\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			
			pcbsp = sotoin6pcb(so)-&gt;in6p_sp;
			
			<span class="enscript-keyword">if</span> (!pcbsp){
				<span class="enscript-keyword">return</span> ipsec6_getpolicybyaddr(m, dir, 0, error);
			}
	
	<span class="enscript-comment">/* set spidx in pcb */</span>
	ipsec6_setspidx_in6pcb(m, sotoin6pcb(so));
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (pcbsp == NULL)
		panic(<span class="enscript-string">&quot;ipsec6_getpolicybysock: pcbsp is NULL.\n&quot;</span>);
		
		<span class="enscript-keyword">switch</span> (dir) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_DIR_INBOUND</span>:
				currsp = pcbsp-&gt;sp_in;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_DIR_OUTBOUND</span>:
				currsp = pcbsp-&gt;sp_out;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				panic(<span class="enscript-string">&quot;ipsec6_getpolicybysock: illegal direction.\n&quot;</span>);
		}
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (currsp == NULL)
		panic(<span class="enscript-string">&quot;ipsec6_getpolicybysock: currsp is NULL.\n&quot;</span>);
		
	<span class="enscript-comment">/* when privilieged socket */</span>
		<span class="enscript-keyword">if</span> (pcbsp-&gt;priv) {
			<span class="enscript-keyword">switch</span> (currsp-&gt;policy) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_BYPASS</span>:
					lck_mtx_lock(sadb_mutex);
					currsp-&gt;refcnt++;
					lck_mtx_unlock(sadb_mutex);
					*error = 0;
					<span class="enscript-keyword">return</span> currsp;
					
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_ENTRUST</span>:
					<span class="enscript-comment">/* look for a policy in SPD */</span>
					kernsp = key_allocsp(&amp;currsp-&gt;spidx, dir);
					
					<span class="enscript-comment">/* SP found */</span>
					<span class="enscript-keyword">if</span> (kernsp != NULL) {
						KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
								 printf(<span class="enscript-string">&quot;DP ipsec6_getpolicybysock called &quot;</span>
										<span class="enscript-string">&quot;to allocate SP:0x%llx\n&quot;</span>,
										(uint64_t)VM_KERNEL_ADDRPERM(kernsp)));
						*error = 0;
						<span class="enscript-keyword">return</span> kernsp;
					}
					
					<span class="enscript-comment">/* no SP found */</span>
					lck_mtx_lock(sadb_mutex);
					<span class="enscript-keyword">if</span> (ip6_def_policy.policy != IPSEC_POLICY_DISCARD
						&amp;&amp; ip6_def_policy.policy != IPSEC_POLICY_NONE) {
						ipseclog((LOG_INFO,
								  <span class="enscript-string">&quot;fixed system default policy: %d-&gt;%d\n&quot;</span>,
								  ip6_def_policy.policy, IPSEC_POLICY_NONE));
						ip6_def_policy.policy = IPSEC_POLICY_NONE;
					}
					ip6_def_policy.refcnt++;
					lck_mtx_unlock(sadb_mutex);
					*error = 0;
					<span class="enscript-keyword">return</span> &amp;ip6_def_policy;
					
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_IPSEC</span>:
					lck_mtx_lock(sadb_mutex);
					currsp-&gt;refcnt++;
					lck_mtx_unlock(sadb_mutex);
					*error = 0;
					<span class="enscript-keyword">return</span> currsp;
					
				<span class="enscript-reference">default</span>:
					ipseclog((LOG_ERR, <span class="enscript-string">&quot;ipsec6_getpolicybysock: &quot;</span>
							  <span class="enscript-string">&quot;Invalid policy for PCB %d\n&quot;</span>, currsp-&gt;policy));
					*error = EINVAL;
					<span class="enscript-keyword">return</span> NULL;
			}
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
	
	<span class="enscript-comment">/* when non-privilieged socket */</span>
	<span class="enscript-comment">/* look for a policy in SPD */</span>
	kernsp = key_allocsp(&amp;currsp-&gt;spidx, dir);
	
	<span class="enscript-comment">/* SP found */</span>
	<span class="enscript-keyword">if</span> (kernsp != NULL) {
		KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
				 printf(<span class="enscript-string">&quot;DP ipsec6_getpolicybysock called &quot;</span>
		    <span class="enscript-string">&quot;to allocate SP:0x%llx\n&quot;</span>,
		    (uint64_t)VM_KERNEL_ADDRPERM(kernsp)));
		*error = 0;
		<span class="enscript-keyword">return</span> kernsp;
	}
	
	<span class="enscript-comment">/* no SP found */</span>
	<span class="enscript-keyword">switch</span> (currsp-&gt;policy) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_BYPASS</span>:
			ipseclog((LOG_ERR, <span class="enscript-string">&quot;ipsec6_getpolicybysock: &quot;</span>
					  <span class="enscript-string">&quot;Illegal policy for non-priviliged defined %d\n&quot;</span>,
					  currsp-&gt;policy));
			*error = EINVAL;
			<span class="enscript-keyword">return</span> NULL;
			
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_ENTRUST</span>:
			lck_mtx_lock(sadb_mutex);
			<span class="enscript-keyword">if</span> (ip6_def_policy.policy != IPSEC_POLICY_DISCARD
				&amp;&amp; ip6_def_policy.policy != IPSEC_POLICY_NONE) {
				ipseclog((LOG_INFO,
						  <span class="enscript-string">&quot;fixed system default policy: %d-&gt;%d\n&quot;</span>,
						  ip6_def_policy.policy, IPSEC_POLICY_NONE));
				ip6_def_policy.policy = IPSEC_POLICY_NONE;
			}
			ip6_def_policy.refcnt++;
			lck_mtx_unlock(sadb_mutex);
			*error = 0;
			<span class="enscript-keyword">return</span> &amp;ip6_def_policy;
			
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_IPSEC</span>:
			lck_mtx_lock(sadb_mutex);
			currsp-&gt;refcnt++;
			lck_mtx_unlock(sadb_mutex);
			*error = 0;
			<span class="enscript-keyword">return</span> currsp;
			
		<span class="enscript-reference">default</span>:
			ipseclog((LOG_ERR,
					  <span class="enscript-string">&quot;ipsec6_policybysock: Invalid policy for PCB %d\n&quot;</span>,
					  currsp-&gt;policy));
			*error = EINVAL;
			<span class="enscript-keyword">return</span> NULL;
	}
	<span class="enscript-comment">/* NOTREACHED */</span>
}

<span class="enscript-comment">/*
 * For FORWADING packet or OUTBOUND without a socket. Searching SPD for packet,
 * and return a pointer to SP.
 * `flag' means that packet is to be forwarded whether or not.
 *	flag = 1: forwad
 * OUT:	positive: a pointer to the entry for security policy leaf matched.
 *	NULL:	no apropreate SP found, the following value is set to error.
 *		0	: bypass
 *		EACCES	: discard packet.
 *		ENOENT	: ipsec_acquire() in progress, maybe.
 *		others	: error occurred.
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IP_FORWARDING</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IP_FORWARDING</span> 1
#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span> secpolicy *
<span class="enscript-function-name">ipsec6_getpolicybyaddr</span>(<span class="enscript-type">struct</span> mbuf *m,
                        u_int dir,
                        <span class="enscript-type">int</span> flag,
                        <span class="enscript-type">int</span> *error)
{
	<span class="enscript-type">struct</span> secpolicy *sp = NULL;

	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL || error == NULL)
		panic(<span class="enscript-string">&quot;ipsec6_getpolicybyaddr: NULL pointer was passed.\n&quot;</span>);

    {
	<span class="enscript-type">struct</span> secpolicyindex spidx;

	bzero(&amp;spidx, <span class="enscript-keyword">sizeof</span>(spidx));

	<span class="enscript-comment">/* make a index to look for a policy */</span>
	*error = ipsec_setspidx_mbuf(&amp;spidx, dir, AF_INET6, m,
	    (flag &amp; IP_FORWARDING) ? 0 : 1);

	<span class="enscript-keyword">if</span> (*error != 0)
		<span class="enscript-keyword">return</span> NULL;

	sp = key_allocsp(&amp;spidx, dir);
    }

	<span class="enscript-comment">/* SP found */</span>
	<span class="enscript-keyword">if</span> (sp != NULL) {
		KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
		    printf(<span class="enscript-string">&quot;DP ipsec6_getpolicybyaddr called &quot;</span>
		    <span class="enscript-string">&quot;to allocate SP:0x%llx\n&quot;</span>,
		    (uint64_t)VM_KERNEL_ADDRPERM(sp)));
		*error = 0;
		<span class="enscript-keyword">return</span> sp;
	}

	<span class="enscript-comment">/* no SP found */</span>
	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">if</span> (ip6_def_policy.policy != IPSEC_POLICY_DISCARD
	 &amp;&amp; ip6_def_policy.policy != IPSEC_POLICY_NONE) {
		ipseclog((LOG_INFO, <span class="enscript-string">&quot;fixed system default policy: %d-&gt;%d\n&quot;</span>,
		    ip6_def_policy.policy, IPSEC_POLICY_NONE));
		ip6_def_policy.policy = IPSEC_POLICY_NONE;
	}
	ip6_def_policy.refcnt++;
	lck_mtx_unlock(sadb_mutex);
	*error = 0;
	<span class="enscript-keyword">return</span> &amp;ip6_def_policy;
}

<span class="enscript-comment">/* Match with bound interface rather than src addr.
 * Unlike getpolicybyaddr, do not set the default policy.
 * Return 0 if should continue processing, or -1 if packet
 * should be dropped.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_getpolicybyinterface</span>(<span class="enscript-type">struct</span> mbuf *m,
                            u_int dir,
                            <span class="enscript-type">int</span> flag,
                            <span class="enscript-type">struct</span> ip6_out_args *ip6oap,
                            <span class="enscript-type">int</span> *noipsec,
                            <span class="enscript-type">struct</span> secpolicy **sp)
{
	<span class="enscript-type">struct</span> secpolicyindex spidx;
	<span class="enscript-type">int</span> error = 0;
    
	<span class="enscript-keyword">if</span> (ipsec_bypass != 0)
		<span class="enscript-keyword">return</span> 0;
    
	<span class="enscript-comment">/* Sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL || sp == NULL || noipsec == NULL || ip6oap == NULL)
		panic(<span class="enscript-string">&quot;ipsec6_getpolicybyinterface: NULL pointer was passed.\n&quot;</span>);
    
	*noipsec = 0;
    
	<span class="enscript-keyword">if</span> (ip6oap-&gt;ip6oa_boundif == IFSCOPE_NONE)
		<span class="enscript-keyword">return</span> 0;
    
	KERNEL_DEBUG(DBG_FNC_GETPOL_ADDR | DBG_FUNC_START, 0,0,0,0,0);
	bzero(&amp;spidx, <span class="enscript-keyword">sizeof</span>(spidx));
    
	<span class="enscript-comment">/* make a index to look for a policy */</span>
	error = ipsec_setspidx_interface(&amp;spidx, dir, m, (flag &amp; IP_FORWARDING) ? 0 : 1,
					ip6oap-&gt;ip6oa_boundif, 6);
    
	<span class="enscript-keyword">if</span> (error != 0) {
		KERNEL_DEBUG(DBG_FNC_GETPOL_ADDR | DBG_FUNC_END, 1,error,0,0,0);
		<span class="enscript-keyword">return</span> 0;
	}
    
	*sp = key_allocsp(&amp;spidx, dir);
    
	<span class="enscript-comment">/* Return SP, whether NULL or not */</span>
	<span class="enscript-keyword">if</span> (*sp != NULL &amp;&amp; (*sp)-&gt;policy == IPSEC_POLICY_IPSEC) {
		<span class="enscript-keyword">if</span> ((*sp)-&gt;ipsec_if == NULL) {
			<span class="enscript-comment">/* Invalid to capture on an interface without redirect */</span>
			key_freesp(*sp, KEY_SADB_UNLOCKED);
			*sp = NULL;
			<span class="enscript-keyword">return</span> -1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((*sp)-&gt;disabled) {
			<span class="enscript-comment">/* Disabled policies go in the clear */</span>
			key_freesp(*sp, KEY_SADB_UNLOCKED);
			*sp = NULL;
			*noipsec = 1; <span class="enscript-comment">/* Avoid later IPSec check */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* If policy is enabled, redirect to ipsec interface */</span>
			ip6oap-&gt;ip6oa_boundif = (*sp)-&gt;ipsec_if-&gt;if_index;
		}
	}
    
	KERNEL_DEBUG(DBG_FNC_GETPOL_ADDR | DBG_FUNC_END, 2,*error,0,0,0);
    
	<span class="enscript-keyword">return</span> 0;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-comment">/*
 * set IP address into spidx from mbuf.
 * When Forwarding packet and ICMP echo reply, this function is used.
 *
 * IN:	get the followings from mbuf.
 *	protocol family, src, dst, next protocol
 * OUT:
 *	0:	success.
 *	other:	failure, and set errno.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec_setspidx_mbuf</span>(
	<span class="enscript-type">struct</span> secpolicyindex *spidx,
	u_int dir,
	__unused u_int family,
	<span class="enscript-type">struct</span> mbuf *m,
	<span class="enscript-type">int</span> needport)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (spidx == NULL || m == NULL)
		panic(<span class="enscript-string">&quot;ipsec_setspidx_mbuf: NULL pointer was passed.\n&quot;</span>);

	bzero(spidx, <span class="enscript-keyword">sizeof</span>(*spidx));

	error = ipsec_setspidx(m, spidx, needport, 0);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	spidx-&gt;dir = dir;

	<span class="enscript-keyword">return</span> 0;

    <span class="enscript-reference">bad</span>:
	<span class="enscript-comment">/* XXX initialize */</span>
	bzero(spidx, <span class="enscript-keyword">sizeof</span>(*spidx));
	<span class="enscript-keyword">return</span> EINVAL;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec_setspidx_interface</span>(
                    <span class="enscript-type">struct</span> secpolicyindex *spidx,
                    u_int dir,
                    <span class="enscript-type">struct</span> mbuf *m,
                    <span class="enscript-type">int</span> needport,
                    <span class="enscript-type">int</span> ifindex,
                    <span class="enscript-type">int</span> ip_version)
{
	<span class="enscript-type">int</span> error;
    
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (spidx == NULL || m == NULL)
		panic(<span class="enscript-string">&quot;ipsec_setspidx_interface: NULL pointer was passed.\n&quot;</span>);
    
	bzero(spidx, <span class="enscript-keyword">sizeof</span>(*spidx));
    
	error = ipsec_setspidx(m, spidx, needport, ip_version);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	spidx-&gt;dir = dir;
    
	<span class="enscript-keyword">if</span> (ifindex != 0) {
		ifnet_head_lock_shared();
		spidx-&gt;internal_if = ifindex2ifnet[ifindex];
		ifnet_head_done();
	} <span class="enscript-keyword">else</span> {
		spidx-&gt;internal_if = NULL;
	}
    
	<span class="enscript-keyword">return</span> 0;
    
<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">return</span> EINVAL;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec4_setspidx_inpcb</span>(m, pcb)
<span class="enscript-type">struct</span> mbuf *m;
<span class="enscript-type">struct</span> inpcb *pcb;
{
	<span class="enscript-type">struct</span> secpolicyindex *spidx;
	<span class="enscript-type">int</span> error;
	
	<span class="enscript-keyword">if</span> (ipsec_bypass != 0)
		<span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (pcb == NULL)
		panic(<span class="enscript-string">&quot;ipsec4_setspidx_inpcb: no PCB found.\n&quot;</span>);
		<span class="enscript-keyword">if</span> (pcb-&gt;inp_sp == NULL)
			panic(<span class="enscript-string">&quot;ipsec4_setspidx_inpcb: no inp_sp found.\n&quot;</span>);
			<span class="enscript-keyword">if</span> (pcb-&gt;inp_sp-&gt;sp_out == NULL || pcb-&gt;inp_sp-&gt;sp_in == NULL)
				panic(<span class="enscript-string">&quot;ipsec4_setspidx_inpcb: no sp_in/out found.\n&quot;</span>);
				
				bzero(&amp;pcb-&gt;inp_sp-&gt;sp_in-&gt;spidx, <span class="enscript-keyword">sizeof</span>(*spidx));
				bzero(&amp;pcb-&gt;inp_sp-&gt;sp_out-&gt;spidx, <span class="enscript-keyword">sizeof</span>(*spidx));
				
				spidx = &amp;pcb-&gt;inp_sp-&gt;sp_in-&gt;spidx;
				error = ipsec_setspidx(m, spidx, 1, 0);
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	spidx-&gt;dir = IPSEC_DIR_INBOUND;
	
	spidx = &amp;pcb-&gt;inp_sp-&gt;sp_out-&gt;spidx;
	error = ipsec_setspidx(m, spidx, 1, 0);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	spidx-&gt;dir = IPSEC_DIR_OUTBOUND;
	
	<span class="enscript-keyword">return</span> 0;
	
<span class="enscript-reference">bad</span>:
	bzero(&amp;pcb-&gt;inp_sp-&gt;sp_in-&gt;spidx, <span class="enscript-keyword">sizeof</span>(*spidx));
	bzero(&amp;pcb-&gt;inp_sp-&gt;sp_out-&gt;spidx, <span class="enscript-keyword">sizeof</span>(*spidx));
	<span class="enscript-keyword">return</span> error;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_setspidx_in6pcb</span>(m, pcb)
<span class="enscript-type">struct</span> mbuf *m;
<span class="enscript-type">struct</span> in6pcb *pcb;
{
	<span class="enscript-type">struct</span> secpolicyindex *spidx;
	<span class="enscript-type">int</span> error;
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (pcb == NULL)
		panic(<span class="enscript-string">&quot;ipsec6_setspidx_in6pcb: no PCB found.\n&quot;</span>);
		<span class="enscript-keyword">if</span> (pcb-&gt;in6p_sp == NULL)
			panic(<span class="enscript-string">&quot;ipsec6_setspidx_in6pcb: no in6p_sp found.\n&quot;</span>);
			<span class="enscript-keyword">if</span> (pcb-&gt;in6p_sp-&gt;sp_out == NULL || pcb-&gt;in6p_sp-&gt;sp_in == NULL)
				panic(<span class="enscript-string">&quot;ipsec6_setspidx_in6pcb: no sp_in/out found.\n&quot;</span>);
				
				bzero(&amp;pcb-&gt;in6p_sp-&gt;sp_in-&gt;spidx, <span class="enscript-keyword">sizeof</span>(*spidx));
				bzero(&amp;pcb-&gt;in6p_sp-&gt;sp_out-&gt;spidx, <span class="enscript-keyword">sizeof</span>(*spidx));
				
				spidx = &amp;pcb-&gt;in6p_sp-&gt;sp_in-&gt;spidx;
				error = ipsec_setspidx(m, spidx, 1, 0);
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	spidx-&gt;dir = IPSEC_DIR_INBOUND;
	
	spidx = &amp;pcb-&gt;in6p_sp-&gt;sp_out-&gt;spidx;
	error = ipsec_setspidx(m, spidx, 1, 0);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	spidx-&gt;dir = IPSEC_DIR_OUTBOUND;
	
	<span class="enscript-keyword">return</span> 0;
	
<span class="enscript-reference">bad</span>:
	bzero(&amp;pcb-&gt;in6p_sp-&gt;sp_in-&gt;spidx, <span class="enscript-keyword">sizeof</span>(*spidx));
	bzero(&amp;pcb-&gt;in6p_sp-&gt;sp_out-&gt;spidx, <span class="enscript-keyword">sizeof</span>(*spidx));
	<span class="enscript-keyword">return</span> error;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * configure security policy index (src/dst/proto/sport/dport)
 * by looking at the content of mbuf.
 * the caller is responsible for error recovery (like clearing up spidx).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec_setspidx</span>(<span class="enscript-type">struct</span> mbuf *m,
               <span class="enscript-type">struct</span> secpolicyindex *spidx,
               <span class="enscript-type">int</span> needport,
               <span class="enscript-type">int</span> force_ip_version)
{
	<span class="enscript-type">struct</span> ip *ip = NULL;
	<span class="enscript-type">struct</span> ip ipbuf;
	u_int v;
	<span class="enscript-type">struct</span> mbuf *n;
	<span class="enscript-type">int</span> len;
	<span class="enscript-type">int</span> error;
    
	<span class="enscript-keyword">if</span> (m == NULL)
		panic(<span class="enscript-string">&quot;ipsec_setspidx: m == 0 passed.\n&quot;</span>);
    
	<span class="enscript-comment">/*
	 * validate m-&gt;m_pkthdr.len.  we see incorrect length if we
	 * mistakenly call this function with inconsistent mbuf chain
	 * (like 4.4BSD tcp/udp processing).  XXX should we panic here?
	 */</span>
	len = 0;
	<span class="enscript-keyword">for</span> (n = m; n; n = n-&gt;m_next)
		len += n-&gt;m_len;
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len != len) {
		KEYDEBUG(KEYDEBUG_IPSEC_DUMP,
			printf(<span class="enscript-string">&quot;ipsec_setspidx: &quot;</span>
			       <span class="enscript-string">&quot;total of m_len(%d) != pkthdr.len(%d), &quot;</span>
			       <span class="enscript-string">&quot;ignored.\n&quot;</span>,
				len, m-&gt;m_pkthdr.len));
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip)) {
		KEYDEBUG(KEYDEBUG_IPSEC_DUMP,
			printf(<span class="enscript-string">&quot;ipsec_setspidx: &quot;</span>
			    <span class="enscript-string">&quot;pkthdr.len(%d) &lt; sizeof(struct ip), ignored.\n&quot;</span>,
			    m-&gt;m_pkthdr.len));
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_len &gt;= <span class="enscript-keyword">sizeof</span>(*ip))
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	<span class="enscript-keyword">else</span> {
		m_copydata(m, 0, <span class="enscript-keyword">sizeof</span>(ipbuf), (caddr_t)&amp;ipbuf);
		ip = &amp;ipbuf;
	}
    
	<span class="enscript-keyword">if</span> (force_ip_version) {
		v = force_ip_version;
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
		v = _IP_VHL_V(ip-&gt;ip_vhl);
#<span class="enscript-reference">else</span>
		v = ip-&gt;ip_v;
#<span class="enscript-reference">endif</span>
	}
	<span class="enscript-keyword">switch</span> (v) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
		error = ipsec4_setspidx_ipaddr(m, spidx);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> error;
		ipsec4_get_ulp(m, spidx, needport);
		<span class="enscript-keyword">return</span> 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>:
		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr)) {
			KEYDEBUG(KEYDEBUG_IPSEC_DUMP,
				printf(<span class="enscript-string">&quot;ipsec_setspidx: &quot;</span>
				    <span class="enscript-string">&quot;pkthdr.len(%d) &lt; sizeof(struct ip6_hdr), &quot;</span>
				    <span class="enscript-string">&quot;ignored.\n&quot;</span>, m-&gt;m_pkthdr.len));
			<span class="enscript-keyword">return</span> EINVAL;
		}
		error = ipsec6_setspidx_ipaddr(m, spidx);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> error;
		ipsec6_get_ulp(m, spidx, needport);
		<span class="enscript-keyword">return</span> 0;
#<span class="enscript-reference">endif</span>
	<span class="enscript-reference">default</span>:
		KEYDEBUG(KEYDEBUG_IPSEC_DUMP,
			printf(<span class="enscript-string">&quot;ipsec_setspidx: &quot;</span>
			    <span class="enscript-string">&quot;unknown IP version %u, ignored.\n&quot;</span>, v));
		<span class="enscript-keyword">return</span> EINVAL;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipsec4_get_ulp</span>(m, spidx, needport)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> secpolicyindex *spidx;
	<span class="enscript-type">int</span> needport;
{
	<span class="enscript-type">struct</span> ip ip;
	<span class="enscript-type">struct</span> ip6_ext ip6e;
	u_int8_t nxt;
	<span class="enscript-type">int</span> off;
	<span class="enscript-type">struct</span> tcphdr th;
	<span class="enscript-type">struct</span> udphdr uh;

	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL)
		panic(<span class="enscript-string">&quot;ipsec4_get_ulp: NULL pointer was passed.\n&quot;</span>);
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; <span class="enscript-keyword">sizeof</span>(ip))
		panic(<span class="enscript-string">&quot;ipsec4_get_ulp: too short\n&quot;</span>);

	<span class="enscript-comment">/* set default */</span>
	spidx-&gt;ul_proto = IPSEC_ULPROTO_ANY;
	((<span class="enscript-type">struct</span> sockaddr_in *)&amp;spidx-&gt;src)-&gt;sin_port = IPSEC_PORT_ANY;
	((<span class="enscript-type">struct</span> sockaddr_in *)&amp;spidx-&gt;dst)-&gt;sin_port = IPSEC_PORT_ANY;

	m_copydata(m, 0, <span class="enscript-keyword">sizeof</span>(ip), (caddr_t)&amp;ip);
	<span class="enscript-comment">/* ip_input() flips it into host endian XXX need more checking */</span>
	<span class="enscript-keyword">if</span> (ip.ip_off &amp; (IP_MF | IP_OFFMASK))
		<span class="enscript-keyword">return</span>;

	nxt = ip.ip_p;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
	off = _IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
#<span class="enscript-reference">else</span>
	off = ip.ip_hl &lt;&lt; 2;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">while</span> (off &lt; m-&gt;m_pkthdr.len) {
		<span class="enscript-keyword">switch</span> (nxt) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
			spidx-&gt;ul_proto = nxt;
			<span class="enscript-keyword">if</span> (!needport)
				<span class="enscript-keyword">return</span>;
			<span class="enscript-keyword">if</span> (off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcphdr) &gt; m-&gt;m_pkthdr.len)
				<span class="enscript-keyword">return</span>;
			m_copydata(m, off, <span class="enscript-keyword">sizeof</span>(th), (caddr_t)&amp;th);
			((<span class="enscript-type">struct</span> sockaddr_in *)&amp;spidx-&gt;src)-&gt;sin_port =
			    th.th_sport;
			((<span class="enscript-type">struct</span> sockaddr_in *)&amp;spidx-&gt;dst)-&gt;sin_port =
			    th.th_dport;
			<span class="enscript-keyword">return</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
			spidx-&gt;ul_proto = nxt;
			<span class="enscript-keyword">if</span> (!needport)
				<span class="enscript-keyword">return</span>;
			<span class="enscript-keyword">if</span> (off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr) &gt; m-&gt;m_pkthdr.len)
				<span class="enscript-keyword">return</span>;
			m_copydata(m, off, <span class="enscript-keyword">sizeof</span>(uh), (caddr_t)&amp;uh);
			((<span class="enscript-type">struct</span> sockaddr_in *)&amp;spidx-&gt;src)-&gt;sin_port =
			    uh.uh_sport;
			((<span class="enscript-type">struct</span> sockaddr_in *)&amp;spidx-&gt;dst)-&gt;sin_port =
			    uh.uh_dport;
			<span class="enscript-keyword">return</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
			<span class="enscript-keyword">if</span> (off + <span class="enscript-keyword">sizeof</span>(ip6e) &gt; m-&gt;m_pkthdr.len)
				<span class="enscript-keyword">return</span>;
			m_copydata(m, off, <span class="enscript-keyword">sizeof</span>(ip6e), (caddr_t)&amp;ip6e);
			off += (ip6e.ip6e_len + 2) &lt;&lt; 2;
			nxt = ip6e.ip6e_nxt;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMP</span>:
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* XXX intermediate headers??? */</span>
			spidx-&gt;ul_proto = nxt;
			<span class="enscript-keyword">return</span>;
		}
	}
}

<span class="enscript-comment">/* assumes that m is sane */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec4_setspidx_ipaddr</span>(m, spidx)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> secpolicyindex *spidx;
{
	<span class="enscript-type">struct</span> ip *ip = NULL;
	<span class="enscript-type">struct</span> ip ipbuf;
	<span class="enscript-type">struct</span> sockaddr_in *sin;

	<span class="enscript-keyword">if</span> (m-&gt;m_len &gt;= <span class="enscript-keyword">sizeof</span>(*ip))
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	<span class="enscript-keyword">else</span> {
		m_copydata(m, 0, <span class="enscript-keyword">sizeof</span>(ipbuf), (caddr_t)&amp;ipbuf);
		ip = &amp;ipbuf;
	}

	sin = (<span class="enscript-type">struct</span> sockaddr_in *)&amp;spidx-&gt;src;
	bzero(sin, <span class="enscript-keyword">sizeof</span>(*sin));
	sin-&gt;sin_family = AF_INET;
	sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
	bcopy(&amp;ip-&gt;ip_src, &amp;sin-&gt;sin_addr, <span class="enscript-keyword">sizeof</span>(ip-&gt;ip_src));
	spidx-&gt;prefs = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr) &lt;&lt; 3;

	sin = (<span class="enscript-type">struct</span> sockaddr_in *)&amp;spidx-&gt;dst;
	bzero(sin, <span class="enscript-keyword">sizeof</span>(*sin));
	sin-&gt;sin_family = AF_INET;
	sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
	bcopy(&amp;ip-&gt;ip_dst, &amp;sin-&gt;sin_addr, <span class="enscript-keyword">sizeof</span>(ip-&gt;ip_dst));
	spidx-&gt;prefd = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr) &lt;&lt; 3;
    
	<span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipsec6_get_ulp</span>(<span class="enscript-type">struct</span> mbuf *m,
			   <span class="enscript-type">struct</span> secpolicyindex *spidx,
			   <span class="enscript-type">int</span> needport)
{
	<span class="enscript-type">int</span> off, nxt;
	<span class="enscript-type">struct</span> tcphdr th;
	<span class="enscript-type">struct</span> udphdr uh;

	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL)
		panic(<span class="enscript-string">&quot;ipsec6_get_ulp: NULL pointer was passed.\n&quot;</span>);

	KEYDEBUG(KEYDEBUG_IPSEC_DUMP,
		printf(<span class="enscript-string">&quot;ipsec6_get_ulp:\n&quot;</span>); kdebug_mbuf(m));

	<span class="enscript-comment">/* set default */</span>
	spidx-&gt;ul_proto = IPSEC_ULPROTO_ANY;
	((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;spidx-&gt;src)-&gt;sin6_port = IPSEC_PORT_ANY;
	((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;spidx-&gt;dst)-&gt;sin6_port = IPSEC_PORT_ANY;

	nxt = -1;
	off = ip6_lasthdr(m, 0, IPPROTO_IPV6, &amp;nxt);
	<span class="enscript-keyword">if</span> (off &lt; 0 || m-&gt;m_pkthdr.len &lt; off)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">switch</span> (nxt) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_TCP</span>:
		spidx-&gt;ul_proto = nxt;
		<span class="enscript-keyword">if</span> (!needport)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> tcphdr) &gt; m-&gt;m_pkthdr.len)
			<span class="enscript-keyword">break</span>;
		m_copydata(m, off, <span class="enscript-keyword">sizeof</span>(th), (caddr_t)&amp;th);
		((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;spidx-&gt;src)-&gt;sin6_port = th.th_sport;
		((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;spidx-&gt;dst)-&gt;sin6_port = th.th_dport;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_UDP</span>:
		spidx-&gt;ul_proto = nxt;
		<span class="enscript-keyword">if</span> (!needport)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr) &gt; m-&gt;m_pkthdr.len)
			<span class="enscript-keyword">break</span>;
		m_copydata(m, off, <span class="enscript-keyword">sizeof</span>(uh), (caddr_t)&amp;uh);
		((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;spidx-&gt;src)-&gt;sin6_port = uh.uh_sport;
		((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;spidx-&gt;dst)-&gt;sin6_port = uh.uh_dport;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ICMPV6</span>:
	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/* XXX intermediate headers??? */</span>
		spidx-&gt;ul_proto = nxt;
		<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-comment">/* assumes that m is sane */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_setspidx_ipaddr</span>(<span class="enscript-type">struct</span> mbuf *m,
					   <span class="enscript-type">struct</span> secpolicyindex *spidx)
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6 = NULL;
	<span class="enscript-type">struct</span> ip6_hdr ip6buf;
	<span class="enscript-type">struct</span> sockaddr_in6 *sin6;

	<span class="enscript-keyword">if</span> (m-&gt;m_len &gt;= <span class="enscript-keyword">sizeof</span>(*ip6))
		ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	<span class="enscript-keyword">else</span> {
		m_copydata(m, 0, <span class="enscript-keyword">sizeof</span>(ip6buf), (caddr_t)&amp;ip6buf);
		ip6 = &amp;ip6buf;
	}

	sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;spidx-&gt;src;
	bzero(sin6, <span class="enscript-keyword">sizeof</span>(*sin6));
	sin6-&gt;sin6_family = AF_INET6;
	sin6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
	bcopy(&amp;ip6-&gt;ip6_src, &amp;sin6-&gt;sin6_addr, <span class="enscript-keyword">sizeof</span>(ip6-&gt;ip6_src));
	<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;ip6-&gt;ip6_src)) {
		sin6-&gt;sin6_addr.s6_addr16[1] = 0;
		sin6-&gt;sin6_scope_id = ntohs(ip6-&gt;ip6_src.s6_addr16[1]);
	}
	spidx-&gt;prefs = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr) &lt;&lt; 3;

	sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;spidx-&gt;dst;
	bzero(sin6, <span class="enscript-keyword">sizeof</span>(*sin6));
	sin6-&gt;sin6_family = AF_INET6;
	sin6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
	bcopy(&amp;ip6-&gt;ip6_dst, &amp;sin6-&gt;sin6_addr, <span class="enscript-keyword">sizeof</span>(ip6-&gt;ip6_dst));
	<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;ip6-&gt;ip6_dst)) {
		sin6-&gt;sin6_addr.s6_addr16[1] = 0;
		sin6-&gt;sin6_scope_id = ntohs(ip6-&gt;ip6_dst.s6_addr16[1]);
	}
	spidx-&gt;prefd = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr) &lt;&lt; 3;

	<span class="enscript-keyword">return</span> 0;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> inpcbpolicy *
<span class="enscript-function-name">ipsec_newpcbpolicy</span>()
{
	<span class="enscript-type">struct</span> inpcbpolicy *p;
	
	p = (<span class="enscript-type">struct</span> inpcbpolicy *)_MALLOC(<span class="enscript-keyword">sizeof</span>(*p), M_SECA, M_WAITOK);
	<span class="enscript-keyword">return</span> p;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipsec_delpcbpolicy</span>(<span class="enscript-type">struct</span> inpcbpolicy *p)
{
	FREE(p, M_SECA);
}

<span class="enscript-comment">/* initialize policy in PCB */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec_init_policy</span>(<span class="enscript-type">struct</span> socket *so,
				  <span class="enscript-type">struct</span> inpcbpolicy **pcb_sp)
{
	<span class="enscript-type">struct</span> inpcbpolicy *new;
	
	<span class="enscript-comment">/* sanity check. */</span>
	<span class="enscript-keyword">if</span> (so == NULL || pcb_sp == NULL)
		panic(<span class="enscript-string">&quot;ipsec_init_policy: NULL pointer was passed.\n&quot;</span>);
		
		new = ipsec_newpcbpolicy();
		<span class="enscript-keyword">if</span> (new == NULL) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;ipsec_init_policy: No more memory.\n&quot;</span>));
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
	bzero(new, <span class="enscript-keyword">sizeof</span>(*new));
	
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE__</span>
	<span class="enscript-keyword">if</span> (kauth_cred_issuser(so-&gt;so_cred))
#<span class="enscript-reference">else</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_cred != 0 &amp;&amp; !suser(so-&gt;so_cred-&gt;pc_ucred, NULL))
#<span class="enscript-reference">endif</span>
			new-&gt;priv = 1;
			<span class="enscript-keyword">else</span>
				new-&gt;priv = 0;
				
				<span class="enscript-keyword">if</span> ((new-&gt;sp_in = key_newsp()) == NULL) {
					ipsec_delpcbpolicy(new);
					<span class="enscript-keyword">return</span> ENOBUFS;
				}
	new-&gt;sp_in-&gt;state = IPSEC_SPSTATE_ALIVE;
	new-&gt;sp_in-&gt;policy = IPSEC_POLICY_ENTRUST;
	
	<span class="enscript-keyword">if</span> ((new-&gt;sp_out = key_newsp()) == NULL) {
		key_freesp(new-&gt;sp_in, KEY_SADB_UNLOCKED);
		ipsec_delpcbpolicy(new);
		<span class="enscript-keyword">return</span> ENOBUFS;
	}
	new-&gt;sp_out-&gt;state = IPSEC_SPSTATE_ALIVE;
	new-&gt;sp_out-&gt;policy = IPSEC_POLICY_ENTRUST;
	
	*pcb_sp = new;
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/* copy old ipsec policy into new */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec_copy_policy</span>(<span class="enscript-type">struct</span> inpcbpolicy *old,
				  <span class="enscript-type">struct</span> inpcbpolicy *new)
{
	<span class="enscript-type">struct</span> secpolicy *sp;
	
	<span class="enscript-keyword">if</span> (ipsec_bypass != 0)
		<span class="enscript-keyword">return</span> 0;
	
	sp = ipsec_deepcopy_policy(old-&gt;sp_in);
	<span class="enscript-keyword">if</span> (sp) {
		key_freesp(new-&gt;sp_in, KEY_SADB_UNLOCKED);
		new-&gt;sp_in = sp;
	} <span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> ENOBUFS;
	
	sp = ipsec_deepcopy_policy(old-&gt;sp_out);
	<span class="enscript-keyword">if</span> (sp) {
		key_freesp(new-&gt;sp_out, KEY_SADB_UNLOCKED);
		new-&gt;sp_out = sp;
	} <span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> ENOBUFS;
	
	new-&gt;priv = old-&gt;priv;
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/* deep-copy a policy in PCB */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> secpolicy *
<span class="enscript-function-name">ipsec_deepcopy_policy</span>(<span class="enscript-type">struct</span> secpolicy *src)
{
	<span class="enscript-type">struct</span> ipsecrequest *newchain = NULL;
	<span class="enscript-type">struct</span> ipsecrequest *p;
	<span class="enscript-type">struct</span> ipsecrequest **q;
	<span class="enscript-type">struct</span> ipsecrequest *r;
	<span class="enscript-type">struct</span> secpolicy *dst;
	
	<span class="enscript-keyword">if</span> (src == NULL)
		<span class="enscript-keyword">return</span> NULL;
	dst = key_newsp();
	<span class="enscript-keyword">if</span> (dst == NULL)
		<span class="enscript-keyword">return</span> NULL;
	
	<span class="enscript-comment">/*
	 * deep-copy IPsec request chain.  This is required since struct
	 * ipsecrequest is not reference counted.
	 */</span>
	q = &amp;newchain;
	<span class="enscript-keyword">for</span> (p = src-&gt;req; p; p = p-&gt;next) {
		*q = (<span class="enscript-type">struct</span> ipsecrequest *)_MALLOC(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ipsecrequest),
		    M_SECA, M_WAITOK | M_ZERO);
		<span class="enscript-keyword">if</span> (*q == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		(*q)-&gt;next = NULL;
		
		(*q)-&gt;saidx.proto = p-&gt;saidx.proto;
		(*q)-&gt;saidx.mode = p-&gt;saidx.mode;
		(*q)-&gt;level = p-&gt;level;
		(*q)-&gt;saidx.reqid = p-&gt;saidx.reqid;
		
		bcopy(&amp;p-&gt;saidx.src, &amp;(*q)-&gt;saidx.src, <span class="enscript-keyword">sizeof</span>((*q)-&gt;saidx.src));
		bcopy(&amp;p-&gt;saidx.dst, &amp;(*q)-&gt;saidx.dst, <span class="enscript-keyword">sizeof</span>((*q)-&gt;saidx.dst));
		
		(*q)-&gt;sp = dst;
		
		q = &amp;((*q)-&gt;next);
	}
	
	dst-&gt;req = newchain;
	dst-&gt;state = src-&gt;state;
	dst-&gt;policy = src-&gt;policy;
	<span class="enscript-comment">/* do not touch the refcnt fields */</span>
	
	<span class="enscript-keyword">return</span> dst;
	
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">for</span> (p = newchain; p; p = r) {
		r = p-&gt;next;
		FREE(p, M_SECA);
		p = NULL;
	}
	key_freesp(dst, KEY_SADB_UNLOCKED);
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-comment">/* set policy and ipsec request if present. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec_set_policy</span>(<span class="enscript-type">struct</span> secpolicy **pcb_sp,
				 __unused <span class="enscript-type">int</span> optname,
				 caddr_t request,
				 size_t len,
				 <span class="enscript-type">int</span> priv)
{
	<span class="enscript-type">struct</span> sadb_x_policy *xpl;
	<span class="enscript-type">struct</span> secpolicy *newsp = NULL;
	<span class="enscript-type">int</span> error;
	
	<span class="enscript-comment">/* sanity check. */</span>
	<span class="enscript-keyword">if</span> (pcb_sp == NULL || *pcb_sp == NULL || request == NULL)
		<span class="enscript-keyword">return</span> EINVAL;
	<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(*xpl))
		<span class="enscript-keyword">return</span> EINVAL;
	xpl = (<span class="enscript-type">struct</span> sadb_x_policy *)(<span class="enscript-type">void</span> *)request;
	
	KEYDEBUG(KEYDEBUG_IPSEC_DUMP,
			 printf(<span class="enscript-string">&quot;ipsec_set_policy: passed policy\n&quot;</span>);
			 kdebug_sadb_x_policy((<span class="enscript-type">struct</span> sadb_ext *)xpl));
	
	<span class="enscript-comment">/* check policy type */</span>
	<span class="enscript-comment">/* ipsec_set_policy() accepts IPSEC, ENTRUST and BYPASS. */</span>
	<span class="enscript-keyword">if</span> (xpl-&gt;sadb_x_policy_type == IPSEC_POLICY_DISCARD
	 || xpl-&gt;sadb_x_policy_type == IPSEC_POLICY_NONE)
		<span class="enscript-keyword">return</span> EINVAL;
	
	<span class="enscript-comment">/* check privileged socket */</span>
	<span class="enscript-keyword">if</span> (priv == 0 &amp;&amp; xpl-&gt;sadb_x_policy_type == IPSEC_POLICY_BYPASS)
		<span class="enscript-keyword">return</span> EACCES;
	
	<span class="enscript-comment">/* allocation new SP entry */</span>
	<span class="enscript-keyword">if</span> ((newsp = key_msg2sp(xpl, len, &amp;error)) == NULL)
		<span class="enscript-keyword">return</span> error;
	
	newsp-&gt;state = IPSEC_SPSTATE_ALIVE;
	
	<span class="enscript-comment">/* clear old SP and set new SP */</span>
	key_freesp(*pcb_sp, KEY_SADB_UNLOCKED);
	*pcb_sp = newsp;
	KEYDEBUG(KEYDEBUG_IPSEC_DUMP,
			 printf(<span class="enscript-string">&quot;ipsec_set_policy: new policy\n&quot;</span>);
			 kdebug_secpolicy(newsp));
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec4_set_policy</span>(<span class="enscript-type">struct</span> inpcb *inp,
				  <span class="enscript-type">int</span> optname,
				  caddr_t request,
				  size_t len,
				  <span class="enscript-type">int</span> priv)
{
	<span class="enscript-type">struct</span> sadb_x_policy *xpl;
	<span class="enscript-type">struct</span> secpolicy **pcb_sp;
	<span class="enscript-type">int</span>	error = 0;
	<span class="enscript-type">struct</span> sadb_x_policy xpl_aligned_buf;
	u_int8_t             *xpl_unaligned;
	
	<span class="enscript-comment">/* sanity check. */</span>
	<span class="enscript-keyword">if</span> (inp == NULL || request == NULL)
		<span class="enscript-keyword">return</span> EINVAL;
	<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(*xpl))
		<span class="enscript-keyword">return</span> EINVAL;
	xpl = (<span class="enscript-type">struct</span> sadb_x_policy *)(<span class="enscript-type">void</span> *)request;
	
	<span class="enscript-comment">/* This is a new mbuf allocated by soopt_getm() */</span>
	<span class="enscript-keyword">if</span> (IPSEC_IS_P2ALIGNED(xpl)) {
		xpl_unaligned = NULL;
	} <span class="enscript-keyword">else</span> {
		xpl_unaligned = (__typeof__(xpl_unaligned))xpl;
		memcpy(&amp;xpl_aligned_buf, xpl, <span class="enscript-keyword">sizeof</span>(xpl_aligned_buf));
		xpl = (__typeof__(xpl))&amp;xpl_aligned_buf;
	}
	
	<span class="enscript-keyword">if</span> (inp-&gt;inp_sp == NULL) {
		error = ipsec_init_policy(inp-&gt;inp_socket, &amp;inp-&gt;inp_sp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> error;
	}
	
	<span class="enscript-comment">/* select direction */</span>
	<span class="enscript-keyword">switch</span> (xpl-&gt;sadb_x_policy_dir) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_DIR_INBOUND</span>:
			pcb_sp = &amp;inp-&gt;inp_sp-&gt;sp_in;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_DIR_OUTBOUND</span>:
			pcb_sp = &amp;inp-&gt;inp_sp-&gt;sp_out;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			ipseclog((LOG_ERR, <span class="enscript-string">&quot;ipsec4_set_policy: invalid direction=%u\n&quot;</span>,
					  xpl-&gt;sadb_x_policy_dir));
			<span class="enscript-keyword">return</span> EINVAL;
	}
	
	<span class="enscript-comment">/* turn bypass off */</span>
	<span class="enscript-keyword">if</span> (ipsec_bypass != 0)
		ipsec_bypass = 0;
		
	<span class="enscript-keyword">return</span> ipsec_set_policy(pcb_sp, optname, request, len, priv);
}

<span class="enscript-comment">/* delete policy in PCB */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec4_delete_pcbpolicy</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	
	<span class="enscript-comment">/* sanity check. */</span>
	<span class="enscript-keyword">if</span> (inp == NULL)
		panic(<span class="enscript-string">&quot;ipsec4_delete_pcbpolicy: NULL pointer was passed.\n&quot;</span>);
		
		<span class="enscript-keyword">if</span> (inp-&gt;inp_sp == NULL)
			<span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-keyword">if</span> (inp-&gt;inp_sp-&gt;sp_in != NULL) {
		key_freesp(inp-&gt;inp_sp-&gt;sp_in, KEY_SADB_UNLOCKED);
		inp-&gt;inp_sp-&gt;sp_in = NULL;
	}
	
	<span class="enscript-keyword">if</span> (inp-&gt;inp_sp-&gt;sp_out != NULL) {
		key_freesp(inp-&gt;inp_sp-&gt;sp_out, KEY_SADB_UNLOCKED);
		inp-&gt;inp_sp-&gt;sp_out = NULL;
	}
	
	ipsec_delpcbpolicy(inp-&gt;inp_sp);
	inp-&gt;inp_sp = NULL;
	
	<span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_set_policy</span>(<span class="enscript-type">struct</span> in6pcb *in6p,
				  <span class="enscript-type">int</span> optname,
				  caddr_t request,
				  size_t len,
				  <span class="enscript-type">int</span> priv)
{
	<span class="enscript-type">struct</span> sadb_x_policy *xpl;
	<span class="enscript-type">struct</span> secpolicy **pcb_sp;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> sadb_x_policy xpl_aligned_buf;
	u_int8_t *xpl_unaligned;
	
	<span class="enscript-comment">/* sanity check. */</span>
	<span class="enscript-keyword">if</span> (in6p == NULL || request == NULL)
		<span class="enscript-keyword">return</span> EINVAL;
	<span class="enscript-keyword">if</span> (len &lt; <span class="enscript-keyword">sizeof</span>(*xpl))
		<span class="enscript-keyword">return</span> EINVAL;
	xpl = (<span class="enscript-type">struct</span> sadb_x_policy *)(<span class="enscript-type">void</span> *)request;
	
	<span class="enscript-comment">/* This is a new mbuf allocated by soopt_getm() */</span>
	<span class="enscript-keyword">if</span> (IPSEC_IS_P2ALIGNED(xpl)) {
		xpl_unaligned = NULL;
	} <span class="enscript-keyword">else</span> {
		xpl_unaligned = (__typeof__(xpl_unaligned))xpl;
		memcpy(&amp;xpl_aligned_buf, xpl, <span class="enscript-keyword">sizeof</span>(xpl_aligned_buf));
		xpl = (__typeof__(xpl))&amp;xpl_aligned_buf;
	}
	
	<span class="enscript-keyword">if</span> (in6p-&gt;in6p_sp == NULL) {
		error = ipsec_init_policy(in6p-&gt;inp_socket, &amp;in6p-&gt;in6p_sp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> error;
	}
	
	<span class="enscript-comment">/* select direction */</span>
	<span class="enscript-keyword">switch</span> (xpl-&gt;sadb_x_policy_dir) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_DIR_INBOUND</span>:
			pcb_sp = &amp;in6p-&gt;in6p_sp-&gt;sp_in;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_DIR_OUTBOUND</span>:
			pcb_sp = &amp;in6p-&gt;in6p_sp-&gt;sp_out;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			ipseclog((LOG_ERR, <span class="enscript-string">&quot;ipsec6_set_policy: invalid direction=%u\n&quot;</span>,
					  xpl-&gt;sadb_x_policy_dir));
			<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">return</span> ipsec_set_policy(pcb_sp, optname, request, len, priv);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_delete_pcbpolicy</span>(<span class="enscript-type">struct</span> in6pcb *in6p)
{
	
	<span class="enscript-comment">/* sanity check. */</span>
	<span class="enscript-keyword">if</span> (in6p == NULL)
		panic(<span class="enscript-string">&quot;ipsec6_delete_pcbpolicy: NULL pointer was passed.\n&quot;</span>);
		
		<span class="enscript-keyword">if</span> (in6p-&gt;in6p_sp == NULL)
			<span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-keyword">if</span> (in6p-&gt;in6p_sp-&gt;sp_in != NULL) {
		key_freesp(in6p-&gt;in6p_sp-&gt;sp_in, KEY_SADB_UNLOCKED);
		in6p-&gt;in6p_sp-&gt;sp_in = NULL;
	}
	
	<span class="enscript-keyword">if</span> (in6p-&gt;in6p_sp-&gt;sp_out != NULL) {
		key_freesp(in6p-&gt;in6p_sp-&gt;sp_out, KEY_SADB_UNLOCKED);
		in6p-&gt;in6p_sp-&gt;sp_out = NULL;
	}
	
	ipsec_delpcbpolicy(in6p-&gt;in6p_sp);
	in6p-&gt;in6p_sp = NULL;
	
	<span class="enscript-keyword">return</span> 0;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * return current level.
 * Either IPSEC_LEVEL_USE or IPSEC_LEVEL_REQUIRE are always returned.
 */</span>
u_int
<span class="enscript-function-name">ipsec_get_reqlevel</span>(isr)
	<span class="enscript-type">struct</span> ipsecrequest *isr;
{
	u_int level = 0;
	u_int esp_trans_deflev = 0, esp_net_deflev = 0, ah_trans_deflev = 0, ah_net_deflev = 0;

	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (isr == NULL || isr-&gt;sp == NULL)
		panic(<span class="enscript-string">&quot;ipsec_get_reqlevel: NULL pointer is passed.\n&quot;</span>);
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;isr-&gt;sp-&gt;spidx.src)-&gt;sa_family
			!= ((<span class="enscript-type">struct</span> sockaddr *)&amp;isr-&gt;sp-&gt;spidx.dst)-&gt;sa_family)
		panic(<span class="enscript-string">&quot;ipsec_get_reqlevel: family mismatched.\n&quot;</span>);

<span class="enscript-comment">/* XXX note that we have ipseclog() expanded here - code sync issue */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IPSEC_CHECK_DEFAULT</span>(lev) \
	(((lev) != IPSEC_LEVEL_USE &amp;&amp; (lev) != IPSEC_LEVEL_REQUIRE	      \
			&amp;&amp; (lev) != IPSEC_LEVEL_UNIQUE)			      \
		? (ipsec_debug						      \
			? log(LOG_INFO, <span class="enscript-string">&quot;fixed system default level &quot;</span> #lev <span class="enscript-string">&quot;:%d-&gt;%d\n&quot;</span>,\
				(lev), IPSEC_LEVEL_REQUIRE)		      \
			: (<span class="enscript-type">void</span>)0),									  \
			(lev) = IPSEC_LEVEL_REQUIRE,			      \
			(lev)						      \
		: (lev))

	<span class="enscript-comment">/* set default level */</span>
	<span class="enscript-keyword">switch</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;isr-&gt;sp-&gt;spidx.src)-&gt;sa_family) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
		esp_trans_deflev = IPSEC_CHECK_DEFAULT(ip4_esp_trans_deflev);
		esp_net_deflev = IPSEC_CHECK_DEFAULT(ip4_esp_net_deflev);
		ah_trans_deflev = IPSEC_CHECK_DEFAULT(ip4_ah_trans_deflev);
		ah_net_deflev = IPSEC_CHECK_DEFAULT(ip4_ah_net_deflev);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
		esp_trans_deflev = IPSEC_CHECK_DEFAULT(ip6_esp_trans_deflev);
		esp_net_deflev = IPSEC_CHECK_DEFAULT(ip6_esp_net_deflev);
		ah_trans_deflev = IPSEC_CHECK_DEFAULT(ip6_ah_trans_deflev);
		ah_net_deflev = IPSEC_CHECK_DEFAULT(ip6_ah_net_deflev);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;key_get_reqlevel: Unknown family. %d\n&quot;</span>,
			((<span class="enscript-type">struct</span> sockaddr *)&amp;isr-&gt;sp-&gt;spidx.src)-&gt;sa_family);
	}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">IPSEC_CHECK_DEFAULT</span>

	<span class="enscript-comment">/* set level */</span>
	<span class="enscript-keyword">switch</span> (isr-&gt;level) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_LEVEL_DEFAULT</span>:
		<span class="enscript-keyword">switch</span> (isr-&gt;saidx.proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
			<span class="enscript-keyword">if</span> (isr-&gt;saidx.mode == IPSEC_MODE_TUNNEL)
				level = esp_net_deflev;
			<span class="enscript-keyword">else</span>
				level = esp_trans_deflev;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
			<span class="enscript-keyword">if</span> (isr-&gt;saidx.mode == IPSEC_MODE_TUNNEL)
				level = ah_net_deflev;
			<span class="enscript-keyword">else</span>
				level = ah_trans_deflev;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_IPCOMP</span>:
			<span class="enscript-comment">/*
			 * we don't really care, as IPcomp document says that
			 * we shouldn't compress small packets
			 */</span>
			level = IPSEC_LEVEL_USE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;ipsec_get_reqlevel: &quot;</span>
				<span class="enscript-string">&quot;Illegal protocol defined %u\n&quot;</span>,
				isr-&gt;saidx.proto);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_LEVEL_USE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_LEVEL_REQUIRE</span>:
		level = isr-&gt;level;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_LEVEL_UNIQUE</span>:
		level = IPSEC_LEVEL_REQUIRE;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;ipsec_get_reqlevel: Illegal IPsec level %u\n&quot;</span>,
			isr-&gt;level);
	}

	<span class="enscript-keyword">return</span> level;
}

<span class="enscript-comment">/*
 * Check AH/ESP integrity.
 * OUT:
 *	0: valid
 *	1: invalid
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec_in_reject</span>(sp, m)
	<span class="enscript-type">struct</span> secpolicy *sp;
	<span class="enscript-type">struct</span> mbuf *m;
{
	<span class="enscript-type">struct</span> ipsecrequest *isr;
	u_int level;
	<span class="enscript-type">int</span> need_auth, need_conf, need_icv;

	KEYDEBUG(KEYDEBUG_IPSEC_DATA,
		printf(<span class="enscript-string">&quot;ipsec_in_reject: using SP\n&quot;</span>);
		kdebug_secpolicy(sp));

	<span class="enscript-comment">/* check policy */</span>
	<span class="enscript-keyword">switch</span> (sp-&gt;policy) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_DISCARD</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_GENERATE</span>:
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_BYPASS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_NONE</span>:
		<span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_IPSEC</span>:
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_ENTRUST</span>:
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;ipsec_hdrsiz: Invalid policy found. %d\n&quot;</span>, sp-&gt;policy);
	}

	need_auth = 0;
	need_conf = 0;
	need_icv = 0;

	<span class="enscript-comment">/* XXX should compare policy against ipsec header history */</span>

	<span class="enscript-keyword">for</span> (isr = sp-&gt;req; isr != NULL; isr = isr-&gt;next) {

		<span class="enscript-comment">/* get current level */</span>
		level = ipsec_get_reqlevel(isr);

		<span class="enscript-keyword">switch</span> (isr-&gt;saidx.proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
			<span class="enscript-keyword">if</span> (level == IPSEC_LEVEL_REQUIRE) {
				need_conf++;

#<span class="enscript-reference">if</span> 0
		<span class="enscript-comment">/* this won't work with multiple input threads - isr-&gt;sav would change 
		 * with every packet and is not necessarily related to the current packet 
		 * being processed.  If ESP processing is required - the esp code should
		 * make sure that the integrity check is present and correct.  I don't see
		 * why it would be necessary to check for the presence of the integrity
		 * check value here.  I think this is just wrong.
		 * isr-&gt;sav has been removed.
		 * %%%%%% this needs to be re-worked at some point but I think the code below can 
		 * be ignored for now.
		 */</span>
				<span class="enscript-keyword">if</span> (isr-&gt;sav != NULL
				 &amp;&amp; isr-&gt;sav-&gt;flags == SADB_X_EXT_NONE
				 &amp;&amp; isr-&gt;sav-&gt;alg_auth != SADB_AALG_NONE)
					need_icv++;
#<span class="enscript-reference">endif</span>
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
			<span class="enscript-keyword">if</span> (level == IPSEC_LEVEL_REQUIRE) {
				need_auth++;
				need_icv++;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_IPCOMP</span>:
			<span class="enscript-comment">/*
			 * we don't really care, as IPcomp document says that
			 * we shouldn't compress small packets, IPComp policy
			 * should always be treated as being in &quot;use&quot; level.
			 */</span>
			<span class="enscript-keyword">break</span>;
		}
	}

	KEYDEBUG(KEYDEBUG_IPSEC_DUMP,
		printf(<span class="enscript-string">&quot;ipsec_in_reject: auth:%d conf:%d icv:%d m_flags:%x\n&quot;</span>,
			need_auth, need_conf, need_icv, m-&gt;m_flags));

	<span class="enscript-keyword">if</span> ((need_conf &amp;&amp; !(m-&gt;m_flags &amp; M_DECRYPTED))
	 || (!need_auth &amp;&amp; need_icv &amp;&amp; !(m-&gt;m_flags &amp; M_AUTHIPDGM))
	 || (need_auth &amp;&amp; !(m-&gt;m_flags &amp; M_AUTHIPHDR)))
		<span class="enscript-keyword">return</span> 1;

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Check AH/ESP integrity.
 * This function is called from tcp_input(), udp_input(),
 * and {ah,esp}4_input for tunnel mode
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec4_in_reject_so</span>(m, so)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> socket *so;
{
	<span class="enscript-type">struct</span> secpolicy *sp = NULL;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> result;

	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span> 0;	<span class="enscript-comment">/* XXX should be panic ? */</span>

	<span class="enscript-comment">/* get SP for this packet.
	 * When we are called from ip_forward(), we call
	 * ipsec4_getpolicybyaddr() with IP_FORWARDING flag.
	 */</span>
	<span class="enscript-keyword">if</span> (so == NULL)
		sp = ipsec4_getpolicybyaddr(m, IPSEC_DIR_INBOUND, IP_FORWARDING, &amp;error);
	<span class="enscript-keyword">else</span>
		sp = ipsec4_getpolicybyaddr(m, IPSEC_DIR_INBOUND, 0, &amp;error);

	<span class="enscript-keyword">if</span> (sp == NULL)
		<span class="enscript-keyword">return</span> 0;	<span class="enscript-comment">/* XXX should be panic ?
				 * -&gt; No, there may be error. */</span>

	result = ipsec_in_reject(sp, m);
	KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
	    printf(<span class="enscript-string">&quot;DP ipsec4_in_reject_so call free SP:0x%llx\n&quot;</span>,
	    (uint64_t)VM_KERNEL_ADDRPERM(sp)));
	key_freesp(sp, KEY_SADB_UNLOCKED);

	<span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec4_in_reject</span>(m, inp)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> inpcb *inp;
{
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	<span class="enscript-keyword">if</span> (inp == NULL)
		<span class="enscript-keyword">return</span> ipsec4_in_reject_so(m, NULL);
	<span class="enscript-keyword">if</span> (inp-&gt;inp_socket)
		<span class="enscript-keyword">return</span> ipsec4_in_reject_so(m, inp-&gt;inp_socket);
	<span class="enscript-keyword">else</span>
		panic(<span class="enscript-string">&quot;ipsec4_in_reject: invalid inpcb/socket&quot;</span>);

	<span class="enscript-comment">/* NOTREACHED */</span>
	<span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-comment">/*
 * Check AH/ESP integrity.
 * This function is called from tcp6_input(), udp6_input(),
 * and {ah,esp}6_input for tunnel mode
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_in_reject_so</span>(m, so)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> socket *so;
{
	<span class="enscript-type">struct</span> secpolicy *sp = NULL;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> result;

	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span> 0;	<span class="enscript-comment">/* XXX should be panic ? */</span>

	<span class="enscript-comment">/* get SP for this packet.
	 * When we are called from ip_forward(), we call
	 * ipsec6_getpolicybyaddr() with IP_FORWARDING flag.
	 */</span>
	<span class="enscript-keyword">if</span> (so == NULL)
		sp = ipsec6_getpolicybyaddr(m, IPSEC_DIR_INBOUND, IP_FORWARDING, &amp;error);
	<span class="enscript-keyword">else</span>
		sp = ipsec6_getpolicybyaddr(m, IPSEC_DIR_INBOUND, 0, &amp;error);

	<span class="enscript-keyword">if</span> (sp == NULL)
		<span class="enscript-keyword">return</span> 0;	<span class="enscript-comment">/* XXX should be panic ? */</span>

	result = ipsec_in_reject(sp, m);
	KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
	    printf(<span class="enscript-string">&quot;DP ipsec6_in_reject_so call free SP:0x%llx\n&quot;</span>,
	    (uint64_t)VM_KERNEL_ADDRPERM(sp)));
	key_freesp(sp, KEY_SADB_UNLOCKED);

	<span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_in_reject</span>(m, in6p)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> in6pcb *in6p;
{

	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	<span class="enscript-keyword">if</span> (in6p == NULL)
		<span class="enscript-keyword">return</span> ipsec6_in_reject_so(m, NULL);
	<span class="enscript-keyword">if</span> (in6p-&gt;in6p_socket)
		<span class="enscript-keyword">return</span> ipsec6_in_reject_so(m, in6p-&gt;in6p_socket);
	<span class="enscript-keyword">else</span>
		panic(<span class="enscript-string">&quot;ipsec6_in_reject: invalid in6p/socket&quot;</span>);

	<span class="enscript-comment">/* NOTREACHED */</span>
	<span class="enscript-keyword">return</span> 0;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * compute the byte size to be occupied by IPsec header.
 * in case it is tunneled, it includes the size of outer IP header.
 * NOTE: SP passed is free in this function.
 */</span>
size_t
<span class="enscript-function-name">ipsec_hdrsiz</span>(sp)
	<span class="enscript-type">struct</span> secpolicy *sp;
{
	<span class="enscript-type">struct</span> ipsecrequest *isr;
	size_t siz, clen;

	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	KEYDEBUG(KEYDEBUG_IPSEC_DATA,
		printf(<span class="enscript-string">&quot;ipsec_hdrsiz: using SP\n&quot;</span>);
		kdebug_secpolicy(sp));

	<span class="enscript-comment">/* check policy */</span>
	<span class="enscript-keyword">switch</span> (sp-&gt;policy) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_DISCARD</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_GENERATE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_BYPASS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_NONE</span>:
		<span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_IPSEC</span>:
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_POLICY_ENTRUST</span>:
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;ipsec_hdrsiz: Invalid policy found. %d\n&quot;</span>, sp-&gt;policy);
	}

	siz = 0;

	<span class="enscript-keyword">for</span> (isr = sp-&gt;req; isr != NULL; isr = isr-&gt;next) {

		clen = 0;

		<span class="enscript-keyword">switch</span> (isr-&gt;saidx.proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
			clen = esp_hdrsiz(isr);
#<span class="enscript-reference">else</span>
			clen = 0;	<span class="enscript-comment">/*XXX*/</span>
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
			clen = ah_hdrsiz(isr);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_IPCOMP</span>:
			clen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ipcomp);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (isr-&gt;saidx.mode == IPSEC_MODE_TUNNEL) {
			<span class="enscript-keyword">switch</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;isr-&gt;saidx.dst)-&gt;sa_family) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET</span>:
				clen += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">AF_INET6</span>:
				clen += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
			<span class="enscript-reference">default</span>:
				ipseclog((LOG_ERR, <span class="enscript-string">&quot;ipsec_hdrsiz: &quot;</span>
				    <span class="enscript-string">&quot;unknown AF %d in IPsec tunnel SA\n&quot;</span>,
				    ((<span class="enscript-type">struct</span> sockaddr *)&amp;isr-&gt;saidx.dst)-&gt;sa_family));
				<span class="enscript-keyword">break</span>;
			}
		}
		siz += clen;
	}

	<span class="enscript-keyword">return</span> siz;
}

<span class="enscript-comment">/* This function is called from ip_forward() and ipsec4_hdrsize_tcp(). */</span>
size_t
<span class="enscript-function-name">ipsec4_hdrsiz</span>(m, dir, inp)
	<span class="enscript-type">struct</span> mbuf *m;
	u_int dir;
	<span class="enscript-type">struct</span> inpcb *inp;
{
	<span class="enscript-type">struct</span> secpolicy *sp = NULL;
	<span class="enscript-type">int</span> error;
	size_t size;

	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span> 0;	<span class="enscript-comment">/* XXX should be panic ? */</span>
	<span class="enscript-keyword">if</span> (inp != NULL &amp;&amp; inp-&gt;inp_socket == NULL)
		panic(<span class="enscript-string">&quot;ipsec4_hdrsize: why is socket NULL but there is PCB.&quot;</span>);

	<span class="enscript-comment">/* get SP for this packet.
	 * When we are called from ip_forward(), we call
	 * ipsec4_getpolicybyaddr() with IP_FORWARDING flag.
	 */</span>
	<span class="enscript-keyword">if</span> (inp == NULL)
		sp = ipsec4_getpolicybyaddr(m, dir, IP_FORWARDING, &amp;error);
	<span class="enscript-keyword">else</span>
		sp = ipsec4_getpolicybyaddr(m, dir, 0, &amp;error);

	<span class="enscript-keyword">if</span> (sp == NULL)
		<span class="enscript-keyword">return</span> 0;	<span class="enscript-comment">/* XXX should be panic ? */</span>

	size = ipsec_hdrsiz(sp);
	KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
	    printf(<span class="enscript-string">&quot;DP ipsec4_hdrsiz call free SP:0x%llx\n&quot;</span>,
	    (uint64_t)VM_KERNEL_ADDRPERM(sp)));
	KEYDEBUG(KEYDEBUG_IPSEC_DATA,
		printf(<span class="enscript-string">&quot;ipsec4_hdrsiz: size:%lu.\n&quot;</span>, (u_int32_t)size));
	key_freesp(sp, KEY_SADB_UNLOCKED);

	<span class="enscript-keyword">return</span> size;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-comment">/* This function is called from ipsec6_hdrsize_tcp(),
 * and maybe from ip6_forward.()
 */</span>
size_t
<span class="enscript-function-name">ipsec6_hdrsiz</span>(m, dir, in6p)
	<span class="enscript-type">struct</span> mbuf *m;
	u_int dir;
	<span class="enscript-type">struct</span> in6pcb *in6p;
{
	<span class="enscript-type">struct</span> secpolicy *sp = NULL;
	<span class="enscript-type">int</span> error;
	size_t size;

	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span> 0;	<span class="enscript-comment">/* XXX shoud be panic ? */</span>
	<span class="enscript-keyword">if</span> (in6p != NULL &amp;&amp; in6p-&gt;in6p_socket == NULL)
		panic(<span class="enscript-string">&quot;ipsec6_hdrsize: why is socket NULL but there is PCB.&quot;</span>);

	<span class="enscript-comment">/* get SP for this packet */</span>
	<span class="enscript-comment">/* XXX Is it right to call with IP_FORWARDING. */</span>
	<span class="enscript-keyword">if</span> (in6p == NULL)
		sp = ipsec6_getpolicybyaddr(m, dir, IP_FORWARDING, &amp;error);
	<span class="enscript-keyword">else</span>
		sp = ipsec6_getpolicybyaddr(m, dir, 0, &amp;error);

	<span class="enscript-keyword">if</span> (sp == NULL)
		<span class="enscript-keyword">return</span> 0;
	size = ipsec_hdrsiz(sp);
	KEYDEBUG(KEYDEBUG_IPSEC_STAMP,
	    printf(<span class="enscript-string">&quot;DP ipsec6_hdrsiz call free SP:0x%llx\n&quot;</span>,
	    (uint64_t)VM_KERNEL_ADDRPERM(sp)));
	KEYDEBUG(KEYDEBUG_IPSEC_DATA,
		printf(<span class="enscript-string">&quot;ipsec6_hdrsiz: size:%lu.\n&quot;</span>, (u_int32_t)size));
	key_freesp(sp, KEY_SADB_UNLOCKED);

	<span class="enscript-keyword">return</span> size;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*INET6*/</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
<span class="enscript-comment">/*
 * encapsulate for ipsec tunnel.
 * ip-&gt;ip_src must be fixed later on.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec4_encapsulate</span>(m, sav)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">struct</span> ip *oip;
	<span class="enscript-type">struct</span> ip *ip;
	size_t hlen;
	size_t plen;

	<span class="enscript-comment">/* can't tunnel between different AFs */</span>
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family
		!= ((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sa_family
	 || ((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family != AF_INET) {
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/* XXX if the dst is myself, perform nothing. */</span>
	<span class="enscript-keyword">if</span> (key_ismyaddr((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst)) {
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(*ip))
		panic(<span class="enscript-string">&quot;ipsec4_encapsulate: assumption failed (first mbuf length)&quot;</span>);

	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
	hlen = _IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
#<span class="enscript-reference">else</span>
	hlen = ip-&gt;ip_hl &lt;&lt; 2;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (m-&gt;m_len != hlen)
		panic(<span class="enscript-string">&quot;ipsec4_encapsulate: assumption failed (first mbuf length)&quot;</span>);

	<span class="enscript-comment">/* generate header checksum */</span>
	ip-&gt;ip_sum = 0;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
	ip-&gt;ip_sum = in_cksum(m, hlen);
#<span class="enscript-reference">else</span>
	ip-&gt;ip_sum = in_cksum(m, hlen);
#<span class="enscript-reference">endif</span>

	plen = m-&gt;m_pkthdr.len;

	<span class="enscript-comment">/*
	 * grow the mbuf to accomodate the new IPv4 header.
	 * NOTE: IPv4 options will never be copied.
	 */</span>
	<span class="enscript-keyword">if</span> (M_LEADINGSPACE(m-&gt;m_next) &lt; hlen) {
		<span class="enscript-type">struct</span> mbuf *n;
		MGET(n, M_DONTWAIT, MT_DATA);
		<span class="enscript-keyword">if</span> (!n) {
			m_freem(m);
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		n-&gt;m_len = hlen;
		n-&gt;m_next = m-&gt;m_next;
		m-&gt;m_next = n;
		m-&gt;m_pkthdr.len += hlen;
		oip = mtod(n, <span class="enscript-type">struct</span> ip *);
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_next-&gt;m_len += hlen;
		m-&gt;m_next-&gt;m_data -= hlen;
		m-&gt;m_pkthdr.len += hlen;
		oip = mtod(m-&gt;m_next, <span class="enscript-type">struct</span> ip *);
	}
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	ovbcopy((caddr_t)ip, (caddr_t)oip, hlen);
	m-&gt;m_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);
	m-&gt;m_pkthdr.len -= (hlen - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip));

	<span class="enscript-comment">/* construct new IPv4 header. see RFC 2401 5.1.2.1 */</span>
	<span class="enscript-comment">/* ECN consideration. */</span>
	ip_ecn_ingress(ip4_ipsec_ecn, &amp;ip-&gt;ip_tos, &amp;oip-&gt;ip_tos);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
	ip-&gt;ip_vhl = IP_MAKE_VHL(IPVERSION, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) &gt;&gt; 2);
#<span class="enscript-reference">else</span>
	ip-&gt;ip_hl = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) &gt;&gt; 2;
#<span class="enscript-reference">endif</span>
	ip-&gt;ip_off &amp;= htons(~IP_OFFMASK);
	ip-&gt;ip_off &amp;= htons(~IP_MF);
	<span class="enscript-keyword">switch</span> (ip4_ipsec_dfbit) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:	<span class="enscript-comment">/* clear DF bit */</span>
		ip-&gt;ip_off &amp;= htons(~IP_DF);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:	<span class="enscript-comment">/* set DF bit */</span>
		ip-&gt;ip_off |= htons(IP_DF);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:	<span class="enscript-comment">/* copy DF bit */</span>
		<span class="enscript-keyword">break</span>;
	}
	ip-&gt;ip_p = IPPROTO_IPIP;
	<span class="enscript-keyword">if</span> (plen + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) &lt; IP_MAXPACKET)
		ip-&gt;ip_len = htons(plen + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip));
	<span class="enscript-keyword">else</span> {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;IPv4 ipsec: size exceeds limit: &quot;</span>
			<span class="enscript-string">&quot;leave ip_len as is (invalid packet)\n&quot;</span>));
	}
	ip-&gt;ip_id = ip_randomid();
	bcopy(&amp;((<span class="enscript-type">struct</span> sockaddr_in *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sin_addr,
		&amp;ip-&gt;ip_src, <span class="enscript-keyword">sizeof</span>(ip-&gt;ip_src));
	bcopy(&amp;((<span class="enscript-type">struct</span> sockaddr_in *)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sin_addr,
		&amp;ip-&gt;ip_dst, <span class="enscript-keyword">sizeof</span>(ip-&gt;ip_dst));
	ip-&gt;ip_ttl = IPDEFTTL;

	<span class="enscript-comment">/* XXX Should ip_src be updated later ? */</span>

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * encapsulate for ipsec tunnel.
 * ip-&gt;ip_src must be fixed later on.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec4_encapsulate_utun_esp_keepalive</span>(m_ptr, sav)
	<span class="enscript-type">struct</span> mbuf **m_ptr;
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">struct</span> ip *ip;
	size_t plen;
	<span class="enscript-type">struct</span> mbuf *m = *m_ptr;

	<span class="enscript-comment">/* can't tunnel between different AFs */</span>
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family
		!= ((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sa_family
	 || ((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family != AF_INET) {
		m_freem(m);
		*m_ptr = NULL;
		<span class="enscript-keyword">return</span> EINVAL;
	}

	plen = m-&gt;m_pkthdr.len;

	<span class="enscript-comment">/*
	 * grow the mbuf to accomodate the new IPv4 header.
	 * NOTE: IPv4 options will never be copied.
	 */</span>
	{
		<span class="enscript-type">struct</span> mbuf *n;
		MGETHDR(n, M_DONTWAIT, MT_HEADER);     <span class="enscript-comment">/* MAC-OK */</span>
		<span class="enscript-keyword">if</span> (!n) {
			m_freem(m);
			*m_ptr = NULL;
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR) {
			M_COPY_PKTHDR(n, m);
			m-&gt;m_flags &amp;= ~M_PKTHDR;
		}
		MH_ALIGN(n, <span class="enscript-keyword">sizeof</span>(*ip));
		n-&gt;m_len = <span class="enscript-keyword">sizeof</span>(*ip);
		n-&gt;m_next = m;
		n-&gt;m_pkthdr.len = (plen + n-&gt;m_len);
		m_fixhdr(m);
		m = n;
		*m_ptr = m;
		plen = m-&gt;m_pkthdr.len;
	}
	ip = mtod(m, __typeof__(ip));

	<span class="enscript-comment">/* construct new IPv4 header. see RFC 2401 5.1.2.1 */</span>
	<span class="enscript-comment">// ip_ecn_ingress(ip4_ipsec_ecn, &amp;ip-&gt;ip_tos, &amp;oip-&gt;ip_tos);
</span>#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
	ip-&gt;ip_vhl = IP_MAKE_VHL(IPVERSION, <span class="enscript-keyword">sizeof</span>(*ip) &gt;&gt; 2);
#<span class="enscript-reference">else</span>
	ip-&gt;ip_hl = <span class="enscript-keyword">sizeof</span>(*ip) &gt;&gt; 2;
#<span class="enscript-reference">endif</span>
	ip-&gt;ip_off &amp;= htons(~IP_OFFMASK);
	ip-&gt;ip_off &amp;= htons(~IP_MF);
	<span class="enscript-keyword">switch</span> (ip4_ipsec_dfbit) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:	<span class="enscript-comment">/* clear DF bit */</span>
		ip-&gt;ip_off &amp;= htons(~IP_DF);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:	<span class="enscript-comment">/* set DF bit */</span>
		ip-&gt;ip_off |= htons(IP_DF);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:	<span class="enscript-comment">/* copy DF bit */</span>
		<span class="enscript-keyword">break</span>;
	}
	ip-&gt;ip_p = IPPROTO_IPIP;
	<span class="enscript-keyword">if</span> (plen &lt; IP_MAXPACKET)
		ip-&gt;ip_len = htons(plen);
	<span class="enscript-keyword">else</span> {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;IPv4 ipsec: size exceeds limit: &quot;</span>
			<span class="enscript-string">&quot;leave ip_len as is (invalid packet)\n&quot;</span>));
	}
	ip-&gt;ip_id = ip_randomid();
	bcopy(&amp;((<span class="enscript-type">struct</span> sockaddr_in *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sin_addr,
		&amp;ip-&gt;ip_src, <span class="enscript-keyword">sizeof</span>(ip-&gt;ip_src));
	bcopy(&amp;((<span class="enscript-type">struct</span> sockaddr_in *)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sin_addr,
		&amp;ip-&gt;ip_dst, <span class="enscript-keyword">sizeof</span>(ip-&gt;ip_dst));
	ip-&gt;ip_ttl = IPDEFTTL;

	<span class="enscript-comment">/* XXX Should ip_src be updated later ? */</span>

	<span class="enscript-keyword">return</span> 0;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*INET*/</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_encapsulate</span>(m, sav)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">struct</span> ip6_hdr *oip6;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	size_t plen;

	<span class="enscript-comment">/* can't tunnel between different AFs */</span>
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family
		!= ((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sa_family
	 || ((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family != AF_INET6) {
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/* XXX if the dst is myself, perform nothing. */</span>
	<span class="enscript-keyword">if</span> (key_ismyaddr((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst)) {
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
#<span class="enscript-reference">endif</span>

	plen = m-&gt;m_pkthdr.len;

	<span class="enscript-comment">/*
	 * grow the mbuf to accomodate the new IPv6 header.
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_len != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr))
		panic(<span class="enscript-string">&quot;ipsec6_encapsulate: assumption failed (first mbuf length)&quot;</span>);
	<span class="enscript-keyword">if</span> (M_LEADINGSPACE(m-&gt;m_next) &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr)) {
		<span class="enscript-type">struct</span> mbuf *n;
		MGET(n, M_DONTWAIT, MT_DATA);
		<span class="enscript-keyword">if</span> (!n) {
			m_freem(m);
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		n-&gt;m_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
		n-&gt;m_next = m-&gt;m_next;
		m-&gt;m_next = n;
		m-&gt;m_pkthdr.len += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
		oip6 = mtod(n, <span class="enscript-type">struct</span> ip6_hdr *);
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_next-&gt;m_len += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
		m-&gt;m_next-&gt;m_data -= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
		m-&gt;m_pkthdr.len += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
		oip6 = mtod(m-&gt;m_next, <span class="enscript-type">struct</span> ip6_hdr *);
	}
	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	ovbcopy((caddr_t)ip6, (caddr_t)oip6, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));

	<span class="enscript-comment">/* Fake link-local scope-class addresses */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;oip6-&gt;ip6_src))
		oip6-&gt;ip6_src.s6_addr16[1] = 0;
	<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;oip6-&gt;ip6_dst))
		oip6-&gt;ip6_dst.s6_addr16[1] = 0;

	<span class="enscript-comment">/* construct new IPv6 header. see RFC 2401 5.1.2.2 */</span>
	<span class="enscript-comment">/* ECN consideration. */</span>
	ip6_ecn_ingress(ip6_ipsec_ecn, &amp;ip6-&gt;ip6_flow, &amp;oip6-&gt;ip6_flow);
	<span class="enscript-keyword">if</span> (plen &lt; IPV6_MAXPACKET - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr))
		ip6-&gt;ip6_plen = htons(plen);
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* ip6-&gt;ip6_plen will be updated in ip6_output() */</span>
	}
	ip6-&gt;ip6_nxt = IPPROTO_IPV6;
	bcopy(&amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sin6_addr,
		&amp;ip6-&gt;ip6_src, <span class="enscript-keyword">sizeof</span>(ip6-&gt;ip6_src));
	bcopy(&amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sin6_addr,
		&amp;ip6-&gt;ip6_dst, <span class="enscript-keyword">sizeof</span>(ip6-&gt;ip6_dst));
	ip6-&gt;ip6_hlim = IPV6_DEFHLIM;

	<span class="enscript-comment">/* XXX Should ip6_src be updated later ? */</span>

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec64_encapsulate</span>(m, sav)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6, *ip6i;
	<span class="enscript-type">struct</span> ip *ip;
	size_t plen;
	u_int8_t hlim;

	<span class="enscript-comment">/* tunneling over IPv4 */</span>
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family
		!= ((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sa_family
	 || ((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family != AF_INET) {
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/* XXX if the dst is myself, perform nothing. */</span>
	<span class="enscript-keyword">if</span> (key_ismyaddr((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst)) {
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
#<span class="enscript-reference">endif</span>

	plen = m-&gt;m_pkthdr.len;
	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	hlim = ip6-&gt;ip6_hlim; 
	<span class="enscript-comment">/*
	 * grow the mbuf to accomodate the new IPv4 header.
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_len != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr))
		panic(<span class="enscript-string">&quot;ipsec6_encapsulate: assumption failed (first mbuf length)&quot;</span>);
	<span class="enscript-keyword">if</span> (M_LEADINGSPACE(m-&gt;m_next) &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr)) {
		<span class="enscript-type">struct</span> mbuf *n;
		MGET(n, M_DONTWAIT, MT_DATA);
		<span class="enscript-keyword">if</span> (!n) {
			m_freem(m);
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		n-&gt;m_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
		n-&gt;m_next = m-&gt;m_next;
		m-&gt;m_next = n;
		m-&gt;m_pkthdr.len += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);
		ip6i = mtod(n, <span class="enscript-type">struct</span> ip6_hdr *);
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_next-&gt;m_len += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
		m-&gt;m_next-&gt;m_data -= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
		m-&gt;m_pkthdr.len += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);
		ip6i = mtod(m-&gt;m_next, <span class="enscript-type">struct</span> ip6_hdr *);
	}

	bcopy(ip6, ip6i, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	m-&gt;m_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);
	<span class="enscript-comment">/* 
	 * Fill in some of the IPv4 fields - we don't need all of them
	 * because the rest will be filled in by ip_output
	 */</span>
	ip-&gt;ip_v = IPVERSION;
	ip-&gt;ip_hl = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) &gt;&gt; 2;
	ip-&gt;ip_id = 0;
	ip-&gt;ip_sum = 0;
	ip-&gt;ip_tos = 0; 
	ip-&gt;ip_off = 0;
	ip-&gt;ip_ttl = hlim;
	ip-&gt;ip_p = IPPROTO_IPV6;

	<span class="enscript-comment">/* construct new IPv4 header. see RFC 2401 5.1.2.1 */</span>
	<span class="enscript-comment">/* ECN consideration. */</span>
	ip64_ecn_ingress(ip4_ipsec_ecn, &amp;ip-&gt;ip_tos, &amp;ip6-&gt;ip6_flow);

	<span class="enscript-keyword">if</span> (plen + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) &lt; IP_MAXPACKET)
		ip-&gt;ip_len = htons(plen + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip));
	<span class="enscript-keyword">else</span> {
		ip-&gt;ip_len = htons(plen);
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;IPv4 ipsec: size exceeds limit: &quot;</span>
			<span class="enscript-string">&quot;leave ip_len as is (invalid packet)\n&quot;</span>));
	}
	bcopy(&amp;((<span class="enscript-type">struct</span> sockaddr_in *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sin_addr,
		&amp;ip-&gt;ip_src, <span class="enscript-keyword">sizeof</span>(ip-&gt;ip_src));
	bcopy(&amp;((<span class="enscript-type">struct</span> sockaddr_in *)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sin_addr,
		&amp;ip-&gt;ip_dst, <span class="enscript-keyword">sizeof</span>(ip-&gt;ip_dst));

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_encapsulate_utun_esp_keepalive</span>(m_ptr, sav)
	<span class="enscript-type">struct</span> mbuf **m_ptr;
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	size_t plen;
	<span class="enscript-type">struct</span> mbuf *m = *m_ptr;

	<span class="enscript-comment">/* can't tunnel between different AFs */</span>
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family
		!= ((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sa_family
	 || ((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family != AF_INET6) {
		m_freem(m);
		*m_ptr = NULL;
		<span class="enscript-keyword">return</span> EINVAL;
	}

	plen = m-&gt;m_pkthdr.len;

	<span class="enscript-comment">/*
	 * grow the mbuf to accomodate the new IPv6 header.
	 */</span>
	{
		<span class="enscript-type">struct</span> mbuf *n;
		MGETHDR(n, M_DONTWAIT, MT_HEADER);     <span class="enscript-comment">/* MAC-OK */</span>
		<span class="enscript-keyword">if</span> (!n) {
			m_freem(m);
			*m_ptr = NULL;
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR) {
			M_COPY_PKTHDR(n, m);
			m-&gt;m_flags &amp;= ~M_PKTHDR;
		}
		MH_ALIGN(n, <span class="enscript-keyword">sizeof</span>(*ip6));
		n-&gt;m_len = <span class="enscript-keyword">sizeof</span>(*ip6);
		n-&gt;m_next = m;
		n-&gt;m_pkthdr.len = (plen + n-&gt;m_len);
		m_fixhdr(m);
		m = n;
		*m_ptr = m;
		plen = m-&gt;m_pkthdr.len;
	}
	ip6 = mtod(m, __typeof__(ip6));

	<span class="enscript-comment">/* construct new IPv6 header. see RFC 2401 5.1.2.2 */</span>
	<span class="enscript-keyword">if</span> (plen &lt; IPV6_MAXPACKET)
		ip6-&gt;ip6_plen = htons(plen);
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* ip6-&gt;ip6_plen will be updated in ip6_output() */</span>
	}
	ip6-&gt;ip6_nxt = IPPROTO_IPV6;
	bcopy(&amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sin6_addr,
		&amp;ip6-&gt;ip6_src, <span class="enscript-keyword">sizeof</span>(ip6-&gt;ip6_src));
	bcopy(&amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sin6_addr,
		&amp;ip6-&gt;ip6_dst, <span class="enscript-keyword">sizeof</span>(ip6-&gt;ip6_dst));
	ip6-&gt;ip6_hlim = IPV6_DEFHLIM;

	<span class="enscript-comment">/* XXX Should ip6_src be updated later ? */</span>

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_update_routecache_and_output</span>(state, sav)
	<span class="enscript-type">struct</span> ipsec_output_state *state;
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">struct</span> sockaddr_in6* dst6;
	<span class="enscript-type">struct</span> route *ro6;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	errno_t error = 0;

	<span class="enscript-type">int</span> plen;
	<span class="enscript-type">struct</span> ip6_out_args ip6oa;
	<span class="enscript-type">struct</span> route_in6 ro6_new;
	<span class="enscript-type">struct</span> flowadv *adv = NULL;

	<span class="enscript-keyword">if</span> (!state-&gt;m) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	ip6 = mtod(state-&gt;m, <span class="enscript-type">struct</span> ip6_hdr *);

	<span class="enscript-comment">// grab sadb_mutex, before updating sah's route cache
</span>	lck_mtx_lock(sadb_mutex);
	ro6 = &amp;sav-&gt;sah-&gt;sa_route;
	dst6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)&amp;ro6-&gt;ro_dst;
	<span class="enscript-keyword">if</span> (ro6-&gt;ro_rt) {
	        RT_LOCK(ro6-&gt;ro_rt);
	}
	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro6) ||
	    !IN6_ARE_ADDR_EQUAL(&amp;dst6-&gt;sin6_addr, &amp;ip6-&gt;ip6_dst)) {
	        <span class="enscript-keyword">if</span> (ro6-&gt;ro_rt != NULL)
		        RT_UNLOCK(ro6-&gt;ro_rt);
		ROUTE_RELEASE(ro6);
	}
	<span class="enscript-keyword">if</span> (ro6-&gt;ro_rt == 0) {
		bzero(dst6, <span class="enscript-keyword">sizeof</span>(*dst6));
		dst6-&gt;sin6_family = AF_INET6;
		dst6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(*dst6);
		dst6-&gt;sin6_addr = ip6-&gt;ip6_dst;
		rtalloc(ro6);
		<span class="enscript-keyword">if</span> (ro6-&gt;ro_rt) {
		        RT_LOCK(ro6-&gt;ro_rt);
		}
	}
	<span class="enscript-keyword">if</span> (ro6-&gt;ro_rt == 0) {
		ip6stat.ip6s_noroute++;
		IPSEC_STAT_INCREMENT(ipsec6stat.out_noroute);
		error = EHOSTUNREACH;
		<span class="enscript-comment">// release sadb_mutex, after updating sah's route cache
</span>		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-comment">/*
	 * adjust state-&gt;dst if tunnel endpoint is offlink
	 *
	 * XXX: caching rt_gateway value in the state is
	 * not really good, since it may point elsewhere
	 * when the gateway gets modified to a larger
	 * sockaddr via rt_setgate().  This is currently
	 * addressed by SA_SIZE roundup in that routine.
	 */</span>
	<span class="enscript-keyword">if</span> (ro6-&gt;ro_rt-&gt;rt_flags &amp; RTF_GATEWAY)
	        dst6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)ro6-&gt;ro_rt-&gt;rt_gateway;
	RT_UNLOCK(ro6-&gt;ro_rt);
	ROUTE_RELEASE(&amp;state-&gt;ro);
	route_copyout(&amp;state-&gt;ro, ro6, <span class="enscript-keyword">sizeof</span>(state-&gt;ro));
	state-&gt;dst = (<span class="enscript-type">struct</span> sockaddr *)dst6;
	state-&gt;tunneled = 6;
	<span class="enscript-comment">// release sadb_mutex, after updating sah's route cache                                                                                                                          
</span>	lck_mtx_unlock(sadb_mutex);

	state-&gt;m = ipsec6_splithdr(state-&gt;m);
	<span class="enscript-keyword">if</span> (!state-&gt;m) {
		IPSEC_STAT_INCREMENT(ipsec6stat.out_nomem);
		error = ENOMEM;
		<span class="enscript-keyword">return</span> error;
	}

	ip6 = mtod(state-&gt;m, <span class="enscript-type">struct</span> ip6_hdr *);
	<span class="enscript-keyword">switch</span> (sav-&gt;sah-&gt;saidx.proto) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
		error = esp6_output(state-&gt;m, &amp;ip6-&gt;ip6_nxt, state-&gt;m-&gt;m_next, sav);
#<span class="enscript-reference">else</span>
		m_freem(state-&gt;m);
		error = EINVAL;
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
		error = ah6_output(state-&gt;m, &amp;ip6-&gt;ip6_nxt, state-&gt;m-&gt;m_next, sav);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_IPCOMP</span>:
		<span class="enscript-comment">/* XXX code should be here */</span>
		<span class="enscript-comment">/*FALLTHROUGH*/</span>
	<span class="enscript-reference">default</span>:
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;%s: unknown ipsec protocol %d\n&quot;</span>, __FUNCTION__, sav-&gt;sah-&gt;saidx.proto));
		m_freem(state-&gt;m);
		IPSEC_STAT_INCREMENT(ipsec6stat.out_inval);
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">// If error, packet already freed by above output routines
</span>		state-&gt;m = NULL;
		<span class="enscript-keyword">return</span> error;
	}

	plen = state-&gt;m-&gt;m_pkthdr.len - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
	<span class="enscript-keyword">if</span> (plen &gt; IPV6_MAXPACKET) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;%s: IPsec with IPv6 jumbogram is not supported\n&quot;</span>, __FUNCTION__));
		IPSEC_STAT_INCREMENT(ipsec6stat.out_inval);
		error = EINVAL;<span class="enscript-comment">/*XXX*/</span>
		<span class="enscript-keyword">return</span> error;
	}
	ip6 = mtod(state-&gt;m, <span class="enscript-type">struct</span> ip6_hdr *);
	ip6-&gt;ip6_plen = htons(plen);

	ipsec_set_pkthdr_for_interface(sav-&gt;sah-&gt;ipsec_if, state-&gt;m, AF_INET6);

	<span class="enscript-comment">/* Increment statistics */</span>
	ifnet_stat_increment_out(sav-&gt;sah-&gt;ipsec_if, 1, mbuf_pkthdr_len(state-&gt;m), 0);

	<span class="enscript-comment">/* Send to ip6_output */</span>
	bzero(&amp;ro6_new, <span class="enscript-keyword">sizeof</span>(ro6_new));
	bzero(&amp;ip6oa, <span class="enscript-keyword">sizeof</span>(ip6oa));
	ip6oa.ip6oa_flowadv.code = 0;
	ip6oa.ip6oa_flags = IPOAF_SELECT_SRCIF | IPOAF_BOUND_SRCADDR;
	<span class="enscript-keyword">if</span> (state-&gt;outgoing_if) {
		ip6oa.ip6oa_boundif = state-&gt;outgoing_if;
		ip6oa.ip6oa_flags |= IPOAF_BOUND_IF;
	}

	adv = &amp;ip6oa.ip6oa_flowadv;
	(<span class="enscript-type">void</span>) ip6_output(state-&gt;m, NULL, &amp;ro6_new, IPV6_OUTARGS, NULL, NULL, &amp;ip6oa);

	<span class="enscript-keyword">if</span> (adv-&gt;code == FADV_FLOW_CONTROLLED || adv-&gt;code == FADV_SUSPENDED) {
		error = ENOBUFS;
		ifnet_disable_output(sav-&gt;sah-&gt;ipsec_if);
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec46_encapsulate</span>(state, sav)
	<span class="enscript-type">struct</span> secasvar *sav;
	<span class="enscript-type">struct</span> ipsec_output_state *state;
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">struct</span> ip *oip;
	<span class="enscript-type">struct</span> ip *ip;
	size_t hlen;
	size_t plen;

	m = state-&gt;m;
	<span class="enscript-keyword">if</span> (!m) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* can't tunnel between different AFs */</span>
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family
	    != ((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sa_family
	    || ((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family != AF_INET6) {
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/* XXX if the dst is myself, perform nothing. */</span>
	<span class="enscript-keyword">if</span> (key_ismyaddr((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst)) {
	        m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(*ip)) {
		panic(<span class="enscript-string">&quot;ipsec46_encapsulate: assumption failed (first mbuf length)&quot;</span>);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
	hlen = _IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
#<span class="enscript-reference">else</span>
	hlen = ip-&gt;ip_hl &lt;&lt; 2;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (m-&gt;m_len != hlen) {
		panic(<span class="enscript-string">&quot;ipsec46_encapsulate: assumption failed (first mbuf length)&quot;</span>);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* generate header checksum */</span>
	ip-&gt;ip_sum = 0;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
	ip-&gt;ip_sum = in_cksum(m, hlen);
#<span class="enscript-reference">else</span>
	ip-&gt;ip_sum = in_cksum(m, hlen);
#<span class="enscript-reference">endif</span>

	plen = m-&gt;m_pkthdr.len; <span class="enscript-comment">// save original IPv4 packet len, this will be ipv6 payload len
</span>
	<span class="enscript-comment">/*
	 * First move the IPv4 header to the second mbuf in the chain
	 */</span>
	<span class="enscript-keyword">if</span> (M_LEADINGSPACE(m-&gt;m_next) &lt; hlen) {
		<span class="enscript-type">struct</span> mbuf *n;
		MGET(n, M_DONTWAIT, MT_DATA);
		<span class="enscript-keyword">if</span> (!n) {
			m_freem(m);
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		n-&gt;m_len = hlen;
		n-&gt;m_next = m-&gt;m_next;
		m-&gt;m_next = n;
		m-&gt;m_pkthdr.len += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
		oip = mtod(n, <span class="enscript-type">struct</span> ip *);
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_next-&gt;m_len += hlen;
		m-&gt;m_next-&gt;m_data -= hlen;
		m-&gt;m_pkthdr.len += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
		oip = mtod(m-&gt;m_next, <span class="enscript-type">struct</span> ip *);
	}
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
	ovbcopy((caddr_t)ip, (caddr_t)oip, hlen);

	<span class="enscript-comment">/*
	 * Grow the first mbuf to accomodate the new IPv6 header.
	 */</span>
	<span class="enscript-keyword">if</span> (M_LEADINGSPACE(m) &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) - hlen) {
		<span class="enscript-type">struct</span> mbuf *n;
		MGETHDR(n, M_DONTWAIT, MT_HEADER);
		<span class="enscript-keyword">if</span> (!n) {
			m_freem(m);
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		M_COPY_PKTHDR(n, m);
		MH_ALIGN(n, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));
		n-&gt;m_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
		n-&gt;m_next = m-&gt;m_next;
		m-&gt;m_next = NULL;
		m_freem(m);
		state-&gt;m = n;
		m = state-&gt;m;
	} <span class="enscript-keyword">else</span> {	 
		m-&gt;m_len += (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) - hlen);
		m-&gt;m_data -= (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) - hlen);
	}
	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	ip6-&gt;ip6_flow = 0;
	ip6-&gt;ip6_vfc &amp;= ~IPV6_VERSION_MASK;
	ip6-&gt;ip6_vfc |= IPV6_VERSION;

	<span class="enscript-comment">/* construct new IPv6 header. see RFC 2401 5.1.2.2 */</span>
	<span class="enscript-comment">/* ECN consideration. */</span>
	ip46_ecn_ingress(ip6_ipsec_ecn, &amp;ip6-&gt;ip6_flow, &amp;ip-&gt;ip_tos);
	<span class="enscript-keyword">if</span> (plen &lt; IPV6_MAXPACKET - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr))
		ip6-&gt;ip6_plen = htons(plen);
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* ip6-&gt;ip6_plen will be updated in ip6_output() */</span>
	}

	ip6-&gt;ip6_nxt = IPPROTO_IPV4;
	ip6-&gt;ip6_hlim = IPV6_DEFHLIM;

	bcopy(&amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sin6_addr,
	      &amp;ip6-&gt;ip6_src, <span class="enscript-keyword">sizeof</span>(ip6-&gt;ip6_src));
	bcopy(&amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sin6_addr,
	      &amp;ip6-&gt;ip6_dst, <span class="enscript-keyword">sizeof</span>(ip6-&gt;ip6_dst));

	<span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*INET6*/</span>

<span class="enscript-comment">/*
 * Check the variable replay window.
 * ipsec_chkreplay() performs replay check before ICV verification.
 * ipsec_updatereplay() updates replay bitmap.  This must be called after
 * ICV verification (it also performs replay check, which is usually done
 * beforehand).
 * 0 (zero) is returned if packet disallowed, 1 if packet permitted.
 *
 * based on RFC 2401.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec_chkreplay</span>(seq, sav)
	u_int32_t seq;
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> secreplay *replay;
	u_int32_t diff;
	<span class="enscript-type">int</span> fr;
	u_int32_t wsizeb;	<span class="enscript-comment">/* constant: bits of window size */</span>
	<span class="enscript-type">int</span> frlast;		<span class="enscript-comment">/* constant: last frame */</span>

	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (sav == NULL)
		panic(<span class="enscript-string">&quot;ipsec_chkreplay: NULL pointer was passed.\n&quot;</span>);

	lck_mtx_lock(sadb_mutex);
	replay = sav-&gt;replay;

	<span class="enscript-keyword">if</span> (replay-&gt;wsize == 0) {
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> 1;	<span class="enscript-comment">/* no need to check replay. */</span>
	}

	<span class="enscript-comment">/* constant */</span>
	frlast = replay-&gt;wsize - 1;
	wsizeb = replay-&gt;wsize &lt;&lt; 3;

	<span class="enscript-comment">/* sequence number of 0 is invalid */</span>
	<span class="enscript-keyword">if</span> (seq == 0) {
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/* first time is always okay */</span>
	<span class="enscript-keyword">if</span> (replay-&gt;count == 0) {
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> 1;
	}

	<span class="enscript-keyword">if</span> (seq &gt; replay-&gt;lastseq) {
		<span class="enscript-comment">/* larger sequences are okay */</span>
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> 1;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* seq is equal or less than lastseq. */</span>
		diff = replay-&gt;lastseq - seq;

		<span class="enscript-comment">/* over range to check, i.e. too old or wrapped */</span>
		<span class="enscript-keyword">if</span> (diff &gt;= wsizeb) {
			lck_mtx_unlock(sadb_mutex);
			<span class="enscript-keyword">return</span> 0;
		}

		fr = frlast - diff / 8;

		<span class="enscript-comment">/* this packet already seen ? */</span>
		<span class="enscript-keyword">if</span> ((replay-&gt;bitmap)[fr] &amp; (1 &lt;&lt; (diff % 8))) {
			lck_mtx_unlock(sadb_mutex);
			<span class="enscript-keyword">return</span> 0;
		}

		<span class="enscript-comment">/* out of order but good */</span>
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> 1;
	}
}

<span class="enscript-comment">/*
 * check replay counter whether to update or not.
 * OUT:	0:	OK
 *	1:	NG
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec_updatereplay</span>(seq, sav)
	u_int32_t seq;
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">struct</span> secreplay *replay;
	u_int32_t diff;
	<span class="enscript-type">int</span> fr;
	u_int32_t wsizeb;	<span class="enscript-comment">/* constant: bits of window size */</span>
	<span class="enscript-type">int</span> frlast;		<span class="enscript-comment">/* constant: last frame */</span>
	
	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (sav == NULL)
		panic(<span class="enscript-string">&quot;ipsec_chkreplay: NULL pointer was passed.\n&quot;</span>);

	lck_mtx_lock(sadb_mutex);
	replay = sav-&gt;replay;

	<span class="enscript-keyword">if</span> (replay-&gt;wsize == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ok</span>;	<span class="enscript-comment">/* no need to check replay. */</span>

	<span class="enscript-comment">/* constant */</span>
	frlast = replay-&gt;wsize - 1;
	wsizeb = replay-&gt;wsize &lt;&lt; 3;

	<span class="enscript-comment">/* sequence number of 0 is invalid */</span>
	<span class="enscript-keyword">if</span> (seq == 0)
		<span class="enscript-keyword">return</span> 1;

	<span class="enscript-comment">/* first time */</span>
	<span class="enscript-keyword">if</span> (replay-&gt;count == 0) {
		replay-&gt;lastseq = seq;
		bzero(replay-&gt;bitmap, replay-&gt;wsize);
		(replay-&gt;bitmap)[frlast] = 1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ok</span>;
	}

	<span class="enscript-keyword">if</span> (seq &gt; replay-&gt;lastseq) {
		<span class="enscript-comment">/* seq is larger than lastseq. */</span>
		diff = seq - replay-&gt;lastseq;

		<span class="enscript-comment">/* new larger sequence number */</span>
		<span class="enscript-keyword">if</span> (diff &lt; wsizeb) {
			<span class="enscript-comment">/* In window */</span>
			<span class="enscript-comment">/* set bit for this packet */</span>
			vshiftl((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *) replay-&gt;bitmap, diff, replay-&gt;wsize);
			(replay-&gt;bitmap)[frlast] |= 1;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* this packet has a &quot;way larger&quot; */</span>
			bzero(replay-&gt;bitmap, replay-&gt;wsize);
			(replay-&gt;bitmap)[frlast] = 1;
		}
		replay-&gt;lastseq = seq;

		<span class="enscript-comment">/* larger is good */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* seq is equal or less than lastseq. */</span>
		diff = replay-&gt;lastseq - seq;

		<span class="enscript-comment">/* over range to check, i.e. too old or wrapped */</span>
		<span class="enscript-keyword">if</span> (diff &gt;= wsizeb) {
			lck_mtx_unlock(sadb_mutex);
			<span class="enscript-keyword">return</span> 1;
		}

		fr = frlast - diff / 8;

		<span class="enscript-comment">/* this packet already seen ? */</span>
		<span class="enscript-keyword">if</span> ((replay-&gt;bitmap)[fr] &amp; (1 &lt;&lt; (diff % 8))) {
			lck_mtx_unlock(sadb_mutex);
			<span class="enscript-keyword">return</span> 1;
		}

		<span class="enscript-comment">/* mark as seen */</span>
		(replay-&gt;bitmap)[fr] |= (1 &lt;&lt; (diff % 8));

		<span class="enscript-comment">/* out of order but good */</span>
	}

<span class="enscript-reference">ok</span>:
	<span class="enscript-keyword">if</span> (replay-&gt;count == ~0) {

		<span class="enscript-comment">/* set overflow flag */</span>
		replay-&gt;overflow++;

		<span class="enscript-comment">/* don't increment, no more packets accepted */</span>
		<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_CYCSEQ) == 0) {
			lck_mtx_unlock(sadb_mutex);
			<span class="enscript-keyword">return</span> 1;
		}

		ipseclog((LOG_WARNING, <span class="enscript-string">&quot;replay counter made %d cycle. %s\n&quot;</span>,
		    replay-&gt;overflow, ipsec_logsastr(sav)));
	}

	replay-&gt;count++;
	
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * shift variable length buffer to left.
 * IN:	bitmap: pointer to the buffer
 * 	nbit:	the number of to shift.
 *	wsize:	buffer size (bytes).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vshiftl</span>(bitmap, nbit, wsize)
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *bitmap;
	<span class="enscript-type">int</span> nbit, wsize;
{
	<span class="enscript-type">int</span> s, j, i;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> over;

	<span class="enscript-keyword">for</span> (j = 0; j &lt; nbit; j += 8) {
		s = (nbit - j &lt; 8) ? (nbit - j): 8;
		bitmap[0] &lt;&lt;= s;
		<span class="enscript-keyword">for</span> (i = 1; i &lt; wsize; i++) {
			over = (bitmap[i] &gt;&gt; (8 - s));
			bitmap[i] &lt;&lt;= s;
			bitmap[i-1] |= over;
		}
	}

	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">ipsec4_logpacketstr</span>(ip, spi)
	<span class="enscript-type">struct</span> ip *ip;
	u_int32_t spi;
{
	<span class="enscript-type">static</span> <span class="enscript-type">char</span> buf[256] __attribute__((aligned(4)));
	<span class="enscript-type">char</span> *p;
	u_int8_t *s, *d;

	s = (u_int8_t *)(&amp;ip-&gt;ip_src);
	d = (u_int8_t *)(&amp;ip-&gt;ip_dst);

	p = buf;
	snprintf(buf, <span class="enscript-keyword">sizeof</span>(buf), <span class="enscript-string">&quot;packet(SPI=%u &quot;</span>, (u_int32_t)ntohl(spi));
	<span class="enscript-keyword">while</span> (p &amp;&amp; *p)
		p++;
	snprintf(p, <span class="enscript-keyword">sizeof</span>(buf) - (p - buf), <span class="enscript-string">&quot;src=%u.%u.%u.%u&quot;</span>,
		s[0], s[1], s[2], s[3]);
	<span class="enscript-keyword">while</span> (p &amp;&amp; *p)
		p++;
	snprintf(p, <span class="enscript-keyword">sizeof</span>(buf) - (p - buf), <span class="enscript-string">&quot; dst=%u.%u.%u.%u&quot;</span>,
		d[0], d[1], d[2], d[3]);
	<span class="enscript-keyword">while</span> (p &amp;&amp; *p)
		p++;
	snprintf(p, <span class="enscript-keyword">sizeof</span>(buf) - (p - buf), <span class="enscript-string">&quot;)&quot;</span>);

	<span class="enscript-keyword">return</span> buf;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">ipsec6_logpacketstr</span>(ip6, spi)
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	u_int32_t spi;
{
	<span class="enscript-type">static</span> <span class="enscript-type">char</span> buf[256] __attribute__((aligned(4)));
	<span class="enscript-type">char</span> *p;

	p = buf;
	snprintf(buf, <span class="enscript-keyword">sizeof</span>(buf), <span class="enscript-string">&quot;packet(SPI=%u &quot;</span>, (u_int32_t)ntohl(spi));
	<span class="enscript-keyword">while</span> (p &amp;&amp; *p)
		p++;
	snprintf(p, <span class="enscript-keyword">sizeof</span>(buf) - (p - buf), <span class="enscript-string">&quot;src=%s&quot;</span>,
		ip6_sprintf(&amp;ip6-&gt;ip6_src));
	<span class="enscript-keyword">while</span> (p &amp;&amp; *p)
		p++;
	snprintf(p, <span class="enscript-keyword">sizeof</span>(buf) - (p - buf), <span class="enscript-string">&quot; dst=%s&quot;</span>,
		ip6_sprintf(&amp;ip6-&gt;ip6_dst));
	<span class="enscript-keyword">while</span> (p &amp;&amp; *p)
		p++;
	snprintf(p, <span class="enscript-keyword">sizeof</span>(buf) - (p - buf), <span class="enscript-string">&quot;)&quot;</span>);

	<span class="enscript-keyword">return</span> buf;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*INET6*/</span>

<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">ipsec_logsastr</span>(sav)
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">static</span> <span class="enscript-type">char</span> buf[256] __attribute__((aligned(4)));
	<span class="enscript-type">char</span> *p;
	<span class="enscript-type">struct</span> secasindex *saidx = &amp;sav-&gt;sah-&gt;saidx;

	<span class="enscript-comment">/* validity check */</span>
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family
			!= ((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sa_family)
		panic(<span class="enscript-string">&quot;ipsec_logsastr: family mismatched.\n&quot;</span>);

	p = buf;
	snprintf(buf, <span class="enscript-keyword">sizeof</span>(buf), <span class="enscript-string">&quot;SA(SPI=%u &quot;</span>, (u_int32_t)ntohl(sav-&gt;spi));
	<span class="enscript-keyword">while</span> (p &amp;&amp; *p)
		p++;
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;saidx-&gt;src)-&gt;sa_family == AF_INET) {
		u_int8_t *s, *d;
		s = (u_int8_t *)&amp;((<span class="enscript-type">struct</span> sockaddr_in *)&amp;saidx-&gt;src)-&gt;sin_addr;
		d = (u_int8_t *)&amp;((<span class="enscript-type">struct</span> sockaddr_in *)&amp;saidx-&gt;dst)-&gt;sin_addr;
		snprintf(p, <span class="enscript-keyword">sizeof</span>(buf) - (p - buf),
			<span class="enscript-string">&quot;src=%d.%d.%d.%d dst=%d.%d.%d.%d&quot;</span>,
			s[0], s[1], s[2], s[3], d[0], d[1], d[2], d[3]);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;saidx-&gt;src)-&gt;sa_family == AF_INET6) {
		snprintf(p, <span class="enscript-keyword">sizeof</span>(buf) - (p - buf),
			<span class="enscript-string">&quot;src=%s&quot;</span>,
			ip6_sprintf(&amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;saidx-&gt;src)-&gt;sin6_addr));
		<span class="enscript-keyword">while</span> (p &amp;&amp; *p)
			p++;
		snprintf(p, <span class="enscript-keyword">sizeof</span>(buf) - (p - buf),
			<span class="enscript-string">&quot; dst=%s&quot;</span>,
			ip6_sprintf(&amp;((<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;saidx-&gt;dst)-&gt;sin6_addr));
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">while</span> (p &amp;&amp; *p)
		p++;
	snprintf(p, <span class="enscript-keyword">sizeof</span>(buf) - (p - buf), <span class="enscript-string">&quot;)&quot;</span>);

	<span class="enscript-keyword">return</span> buf;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipsec_dumpmbuf</span>(m)
	<span class="enscript-type">struct</span> mbuf *m;
{
	<span class="enscript-type">int</span> totlen;
	<span class="enscript-type">int</span> i;
	u_char *p;

	totlen = 0;
	printf(<span class="enscript-string">&quot;---\n&quot;</span>);
	<span class="enscript-keyword">while</span> (m) {
		p = mtod(m, u_char *);
		<span class="enscript-keyword">for</span> (i = 0; i &lt; m-&gt;m_len; i++) {
			printf(<span class="enscript-string">&quot;%02x &quot;</span>, p[i]);
			totlen++;
			<span class="enscript-keyword">if</span> (totlen % 16 == 0)
				printf(<span class="enscript-string">&quot;\n&quot;</span>);
		}
		m = m-&gt;m_next;
	}
	<span class="enscript-keyword">if</span> (totlen % 16 != 0)
		printf(<span class="enscript-string">&quot;\n&quot;</span>);
	printf(<span class="enscript-string">&quot;---\n&quot;</span>);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
<span class="enscript-comment">/*
 * IPsec output logic for IPv4.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec4_output_internal</span>(<span class="enscript-type">struct</span> ipsec_output_state *state, <span class="enscript-type">struct</span> secasvar *sav)
{
	<span class="enscript-type">struct</span> ip *ip = NULL;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> sockaddr_in *dst4;
	<span class="enscript-type">struct</span> route *ro4;

	<span class="enscript-comment">/* validity check */</span>
	<span class="enscript-keyword">if</span> (sav == NULL || sav-&gt;sah == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/*
	 * If there is no valid SA, we give up to process any
	 * more.  In such a case, the SA's status is changed
	 * from DYING to DEAD after allocating.  If a packet
	 * send to the receiver by dead SA, the receiver can
	 * not decode a packet because SA has been dead.
	 */</span>
	<span class="enscript-keyword">if</span> (sav-&gt;state != SADB_SASTATE_MATURE
	 &amp;&amp; sav-&gt;state != SADB_SASTATE_DYING) {
		IPSEC_STAT_INCREMENT(ipsecstat.out_nosa);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	
	state-&gt;outgoing_if = sav-&gt;sah-&gt;outgoing_if;

	<span class="enscript-comment">/*
	 * There may be the case that SA status will be changed when
	 * we are refering to one. So calling splsoftnet().
	 */</span>

	<span class="enscript-keyword">if</span> (sav-&gt;sah-&gt;saidx.mode == IPSEC_MODE_TUNNEL) {
		<span class="enscript-comment">/*
		 * build IPsec tunnel.
		 */</span>
		state-&gt;m = ipsec4_splithdr(state-&gt;m);
		<span class="enscript-keyword">if</span> (!state-&gt;m) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

		<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family == AF_INET6) {
			error = ipsec46_encapsulate(state, sav);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-comment">// packet already freed by encapsulation error handling
</span>				state-&gt;m = NULL;
				<span class="enscript-keyword">return</span> error;
			}

			error = ipsec6_update_routecache_and_output(state, sav);
			<span class="enscript-keyword">return</span> error;

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family == AF_INET) {
			error = ipsec4_encapsulate(state-&gt;m, sav);
			<span class="enscript-keyword">if</span> (error) {
				state-&gt;m = NULL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			ip = mtod(state-&gt;m, <span class="enscript-type">struct</span> ip *);

			<span class="enscript-comment">// grab sadb_mutex, before updating sah's route cache
</span>			lck_mtx_lock(sadb_mutex);
			ro4= &amp;sav-&gt;sah-&gt;sa_route;
			dst4 = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)&amp;ro4-&gt;ro_dst;
			<span class="enscript-keyword">if</span> (ro4-&gt;ro_rt != NULL) {
			        RT_LOCK(ro4-&gt;ro_rt);
			}
			<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro4) ||
			    dst4-&gt;sin_addr.s_addr != ip-&gt;ip_dst.s_addr) {
			        <span class="enscript-keyword">if</span> (ro4-&gt;ro_rt != NULL)
				        RT_UNLOCK(ro4-&gt;ro_rt);
				ROUTE_RELEASE(ro4);
			}
			<span class="enscript-keyword">if</span> (ro4-&gt;ro_rt == 0) {
				dst4-&gt;sin_family = AF_INET;
				dst4-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(*dst4);
				dst4-&gt;sin_addr = ip-&gt;ip_dst;
				rtalloc(ro4);
				<span class="enscript-keyword">if</span> (ro4-&gt;ro_rt == 0) {
					OSAddAtomic(1, &amp;ipstat.ips_noroute);
					error = EHOSTUNREACH;
					<span class="enscript-comment">// release sadb_mutex, after updating sah's route cache
</span>					lck_mtx_unlock(sadb_mutex);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
				}
				RT_LOCK(ro4-&gt;ro_rt);
			}

			<span class="enscript-comment">/*
			 * adjust state-&gt;dst if tunnel endpoint is offlink
			 *
			 * XXX: caching rt_gateway value in the state is
			 * not really good, since it may point elsewhere
			 * when the gateway gets modified to a larger
			 * sockaddr via rt_setgate().  This is currently
			 * addressed by SA_SIZE roundup in that routine.
			 */</span>
			<span class="enscript-keyword">if</span> (ro4-&gt;ro_rt-&gt;rt_flags &amp; RTF_GATEWAY)
			        dst4 = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)ro4-&gt;ro_rt-&gt;rt_gateway;
			RT_UNLOCK(ro4-&gt;ro_rt);
			ROUTE_RELEASE(&amp;state-&gt;ro);
			route_copyout(&amp;state-&gt;ro, ro4, <span class="enscript-keyword">sizeof</span>(state-&gt;ro));
			state-&gt;dst = (<span class="enscript-type">struct</span> sockaddr *)dst4;
			state-&gt;tunneled = 4;
			<span class="enscript-comment">// release sadb_mutex, after updating sah's route cache                                                                                                    
</span>			lck_mtx_unlock(sadb_mutex);
		} <span class="enscript-keyword">else</span> {
			ipseclog((LOG_ERR, <span class="enscript-string">&quot;%s: family mismatched between inner and outer spi=%u\n&quot;</span>,
				  __FUNCTION__, (u_int32_t)ntohl(sav-&gt;spi)));
			error = EAFNOSUPPORT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

	state-&gt;m = ipsec4_splithdr(state-&gt;m);
	<span class="enscript-keyword">if</span> (!state-&gt;m) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	<span class="enscript-keyword">switch</span> (sav-&gt;sah-&gt;saidx.proto) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
		<span class="enscript-keyword">if</span> ((error = esp4_output(state-&gt;m, sav)) != 0) {
			state-&gt;m = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">else</span>
		m_freem(state-&gt;m);
		state-&gt;m = NULL;
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
		<span class="enscript-keyword">if</span> ((error = ah4_output(state-&gt;m, sav)) != 0) {
			state-&gt;m = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_IPCOMP</span>:
		<span class="enscript-keyword">if</span> ((error = ipcomp4_output(state-&gt;m, sav)) != 0) {
			state-&gt;m = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		ipseclog((LOG_ERR,
			<span class="enscript-string">&quot;ipsec4_output: unknown ipsec protocol %d\n&quot;</span>,
			sav-&gt;sah-&gt;saidx.proto));
		m_freem(state-&gt;m);
		state-&gt;m = NULL;
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> (state-&gt;m == 0) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec4_interface_output</span>(<span class="enscript-type">struct</span> ipsec_output_state *state, ifnet_t interface)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> secasvar *sav = NULL;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-keyword">if</span> (!state)
		panic(<span class="enscript-string">&quot;state == NULL in ipsec4_output&quot;</span>);
	<span class="enscript-keyword">if</span> (!state-&gt;m)
		panic(<span class="enscript-string">&quot;state-&gt;m == NULL in ipsec4_output&quot;</span>);
	<span class="enscript-keyword">if</span> (!state-&gt;dst)
		panic(<span class="enscript-string">&quot;state-&gt;dst == NULL in ipsec4_output&quot;</span>);
	
	sav = key_alloc_outbound_sav_for_interface(interface, AF_INET);
	<span class="enscript-keyword">if</span> (sav == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	
	<span class="enscript-keyword">if</span> ((error = ipsec4_output_internal(state, sav)) != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	
	KERNEL_DEBUG(DBG_FNC_IPSEC_OUT | DBG_FUNC_END, 0,0,0,0,0);
	<span class="enscript-keyword">if</span> (sav)
		key_freesav(sav, KEY_SADB_UNLOCKED);
	<span class="enscript-keyword">return</span> 0;
	
<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">if</span> (sav)
		key_freesav(sav, KEY_SADB_UNLOCKED);
	m_freem(state-&gt;m);
	state-&gt;m = NULL;
	KERNEL_DEBUG(DBG_FNC_IPSEC_OUT | DBG_FUNC_END, error,0,0,0,0);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec4_output</span>(<span class="enscript-type">struct</span> ipsec_output_state *state, <span class="enscript-type">struct</span> secpolicy *sp, __unused <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> ip *ip = NULL;
	<span class="enscript-type">struct</span> ipsecrequest *isr = NULL;
	<span class="enscript-type">struct</span> secasindex saidx;
	<span class="enscript-type">struct</span> secasvar *sav = NULL;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> sockaddr_in *sin;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-keyword">if</span> (!state)
		panic(<span class="enscript-string">&quot;state == NULL in ipsec4_output&quot;</span>);
	<span class="enscript-keyword">if</span> (!state-&gt;m)
		panic(<span class="enscript-string">&quot;state-&gt;m == NULL in ipsec4_output&quot;</span>);
	<span class="enscript-keyword">if</span> (!state-&gt;dst)
		panic(<span class="enscript-string">&quot;state-&gt;dst == NULL in ipsec4_output&quot;</span>);
	
	KERNEL_DEBUG(DBG_FNC_IPSEC_OUT | DBG_FUNC_START, 0,0,0,0,0);
	
	KEYDEBUG(KEYDEBUG_IPSEC_DATA,
			 printf(<span class="enscript-string">&quot;ipsec4_output: applied SP\n&quot;</span>);
			 kdebug_secpolicy(sp));
	
	<span class="enscript-keyword">for</span> (isr = sp-&gt;req; isr != NULL; isr = isr-&gt;next) {
		<span class="enscript-comment">/* make SA index for search proper SA */</span>
		ip = mtod(state-&gt;m, <span class="enscript-type">struct</span> ip *);
		bcopy(&amp;isr-&gt;saidx, &amp;saidx, <span class="enscript-keyword">sizeof</span>(saidx));
		saidx.mode = isr-&gt;saidx.mode;
		saidx.reqid = isr-&gt;saidx.reqid;
		sin = (<span class="enscript-type">struct</span> sockaddr_in *)&amp;saidx.src;
		<span class="enscript-keyword">if</span> (sin-&gt;sin_len == 0) {
			sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(*sin);
			sin-&gt;sin_family = AF_INET;
			sin-&gt;sin_port = IPSEC_PORT_ANY;
			bcopy(&amp;ip-&gt;ip_src, &amp;sin-&gt;sin_addr,
				  <span class="enscript-keyword">sizeof</span>(sin-&gt;sin_addr));
		}
		sin = (<span class="enscript-type">struct</span> sockaddr_in *)&amp;saidx.dst;
		<span class="enscript-keyword">if</span> (sin-&gt;sin_len == 0) {
			sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(*sin);
			sin-&gt;sin_family = AF_INET;
			sin-&gt;sin_port = IPSEC_PORT_ANY;
			<span class="enscript-comment">/*
			 * Get port from packet if upper layer is UDP and nat traversal
			 * is enabled and transport mode.
			 */</span>
			
			<span class="enscript-keyword">if</span> ((esp_udp_encap_port &amp; 0xFFFF) != 0 &amp;&amp;
				isr-&gt;saidx.mode == IPSEC_MODE_TRANSPORT) {
				
				<span class="enscript-keyword">if</span> (ip-&gt;ip_p == IPPROTO_UDP) {
					<span class="enscript-type">struct</span> udphdr  *udp;
					size_t hlen;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
					hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
#<span class="enscript-reference">else</span>
					hlen = ip-&gt;ip_hl &lt;&lt; 2;
#<span class="enscript-reference">endif</span>
					<span class="enscript-keyword">if</span> (state-&gt;m-&gt;m_len &lt; hlen + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr)) {
						state-&gt;m = m_pullup(state-&gt;m, hlen + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udphdr));
						<span class="enscript-keyword">if</span> (!state-&gt;m) {
							ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;IPv4 output: can't pullup UDP header\n&quot;</span>));
							IPSEC_STAT_INCREMENT(ipsecstat.in_inval);
							<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
						}
						ip = mtod(state-&gt;m, <span class="enscript-type">struct</span> ip *);
					}
					udp = (<span class="enscript-type">struct</span> udphdr *)(<span class="enscript-type">void</span> *)(((u_int8_t *)ip) + hlen);
					sin-&gt;sin_port = udp-&gt;uh_dport;
				}
			}
			
			bcopy(&amp;ip-&gt;ip_dst, &amp;sin-&gt;sin_addr,
				  <span class="enscript-keyword">sizeof</span>(sin-&gt;sin_addr));
		}
		
		<span class="enscript-keyword">if</span> ((error = key_checkrequest(isr, &amp;saidx, &amp;sav)) != 0) {
			<span class="enscript-comment">/*
			 * IPsec processing is required, but no SA found.
			 * I assume that key_acquire() had been called
			 * to get/establish the SA. Here I discard
			 * this packet because it is responsibility for
			 * upper layer to retransmit the packet.
			 */</span>
			IPSEC_STAT_INCREMENT(ipsecstat.out_nosa);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		
		<span class="enscript-comment">/* validity check */</span>
		<span class="enscript-keyword">if</span> (sav == NULL) {
			<span class="enscript-keyword">switch</span> (ipsec_get_reqlevel(isr)) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_LEVEL_USE</span>:
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_LEVEL_REQUIRE</span>:
					<span class="enscript-comment">/* must be not reached here. */</span>
					panic(<span class="enscript-string">&quot;ipsec4_output: no SA found, but required.&quot;</span>);
			}
		}
		
		<span class="enscript-keyword">if</span> ((error = ipsec4_output_internal(state, sav)) != 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}
	
	KERNEL_DEBUG(DBG_FNC_IPSEC_OUT | DBG_FUNC_END, 0,0,0,0,0);
	<span class="enscript-keyword">if</span> (sav)
		key_freesav(sav, KEY_SADB_UNLOCKED);
	<span class="enscript-keyword">return</span> 0;
	
<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">if</span> (sav)
		key_freesav(sav, KEY_SADB_UNLOCKED);
	m_freem(state-&gt;m);
	state-&gt;m = NULL;
	KERNEL_DEBUG(DBG_FNC_IPSEC_OUT | DBG_FUNC_END, error,0,0,0,0);
	<span class="enscript-keyword">return</span> error;
}

#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-comment">/*
 * IPsec output logic for IPv6, transport mode.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_output_trans_internal</span>(
	<span class="enscript-type">struct</span> ipsec_output_state *state,
	<span class="enscript-type">struct</span> secasvar *sav,
	u_char *nexthdrp,
	<span class="enscript-type">struct</span> mbuf *mprev)
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> plen;
	
	<span class="enscript-comment">/* validity check */</span>
	<span class="enscript-keyword">if</span> (sav == NULL || sav-&gt;sah == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	
	<span class="enscript-comment">/*
	 * If there is no valid SA, we give up to process.
	 * see same place at ipsec4_output().
	 */</span>
	<span class="enscript-keyword">if</span> (sav-&gt;state != SADB_SASTATE_MATURE
	 &amp;&amp; sav-&gt;state != SADB_SASTATE_DYING) {
		IPSEC_STAT_INCREMENT(ipsec6stat.out_nosa);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	
	state-&gt;outgoing_if = sav-&gt;sah-&gt;outgoing_if;

	<span class="enscript-keyword">switch</span> (sav-&gt;sah-&gt;saidx.proto) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
		error = esp6_output(state-&gt;m, nexthdrp, mprev-&gt;m_next, sav);
#<span class="enscript-reference">else</span>
		m_freem(state-&gt;m);
		error = EINVAL;
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
		error = ah6_output(state-&gt;m, nexthdrp, mprev-&gt;m_next, sav);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_IPCOMP</span>:
		error = ipcomp6_output(state-&gt;m, nexthdrp, mprev-&gt;m_next, sav);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;ipsec6_output_trans: &quot;</span>
			<span class="enscript-string">&quot;unknown ipsec protocol %d\n&quot;</span>, sav-&gt;sah-&gt;saidx.proto));
		m_freem(state-&gt;m);
		IPSEC_STAT_INCREMENT(ipsec6stat.out_inval);
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (error) {
		state-&gt;m = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	plen = state-&gt;m-&gt;m_pkthdr.len - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
	<span class="enscript-keyword">if</span> (plen &gt; IPV6_MAXPACKET) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;ipsec6_output_trans: &quot;</span>
			<span class="enscript-string">&quot;IPsec with IPv6 jumbogram is not supported\n&quot;</span>));
		IPSEC_STAT_INCREMENT(ipsec6stat.out_inval);
		error = EINVAL;	<span class="enscript-comment">/*XXX*/</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	ip6 = mtod(state-&gt;m, <span class="enscript-type">struct</span> ip6_hdr *);
	ip6-&gt;ip6_plen = htons(plen);

	<span class="enscript-keyword">return</span> 0;
<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_output_trans</span>(
					<span class="enscript-type">struct</span> ipsec_output_state *state,
					u_char *nexthdrp,
					<span class="enscript-type">struct</span> mbuf *mprev,
					<span class="enscript-type">struct</span> secpolicy *sp,
					__unused <span class="enscript-type">int</span> flags,
					<span class="enscript-type">int</span> *tun)
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">struct</span> ipsecrequest *isr = NULL;
	<span class="enscript-type">struct</span> secasindex saidx;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> sockaddr_in6 *sin6;
	<span class="enscript-type">struct</span> secasvar *sav = NULL;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-keyword">if</span> (!state)
		panic(<span class="enscript-string">&quot;state == NULL in ipsec6_output_trans&quot;</span>);
	<span class="enscript-keyword">if</span> (!state-&gt;m)
		panic(<span class="enscript-string">&quot;state-&gt;m == NULL in ipsec6_output_trans&quot;</span>);
	<span class="enscript-keyword">if</span> (!nexthdrp)
		panic(<span class="enscript-string">&quot;nexthdrp == NULL in ipsec6_output_trans&quot;</span>);
	<span class="enscript-keyword">if</span> (!mprev)
		panic(<span class="enscript-string">&quot;mprev == NULL in ipsec6_output_trans&quot;</span>);
	<span class="enscript-keyword">if</span> (!sp)
		panic(<span class="enscript-string">&quot;sp == NULL in ipsec6_output_trans&quot;</span>);
	<span class="enscript-keyword">if</span> (!tun)
		panic(<span class="enscript-string">&quot;tun == NULL in ipsec6_output_trans&quot;</span>);
	
	KEYDEBUG(KEYDEBUG_IPSEC_DATA,
			 printf(<span class="enscript-string">&quot;ipsec6_output_trans: applyed SP\n&quot;</span>);
			 kdebug_secpolicy(sp));
	
	*tun = 0;
	<span class="enscript-keyword">for</span> (isr = sp-&gt;req; isr; isr = isr-&gt;next) {
		<span class="enscript-keyword">if</span> (isr-&gt;saidx.mode == IPSEC_MODE_TUNNEL) {
			<span class="enscript-comment">/* the rest will be handled by ipsec6_output_tunnel() */</span>
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-comment">/* make SA index for search proper SA */</span>
		ip6 = mtod(state-&gt;m, <span class="enscript-type">struct</span> ip6_hdr *);
		bcopy(&amp;isr-&gt;saidx, &amp;saidx, <span class="enscript-keyword">sizeof</span>(saidx));
		saidx.mode = isr-&gt;saidx.mode;
		saidx.reqid = isr-&gt;saidx.reqid;
		sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;saidx.src;
		<span class="enscript-keyword">if</span> (sin6-&gt;sin6_len == 0) {
			sin6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(*sin6);
			sin6-&gt;sin6_family = AF_INET6;
			sin6-&gt;sin6_port = IPSEC_PORT_ANY;
			bcopy(&amp;ip6-&gt;ip6_src, &amp;sin6-&gt;sin6_addr,
				  <span class="enscript-keyword">sizeof</span>(ip6-&gt;ip6_src));
			<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;ip6-&gt;ip6_src)) {
				<span class="enscript-comment">/* fix scope id for comparing SPD */</span>
				sin6-&gt;sin6_addr.s6_addr16[1] = 0;
				sin6-&gt;sin6_scope_id = ntohs(ip6-&gt;ip6_src.s6_addr16[1]);
			}
		}
		sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;saidx.dst;
		<span class="enscript-keyword">if</span> (sin6-&gt;sin6_len == 0) {
			sin6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(*sin6);
			sin6-&gt;sin6_family = AF_INET6;
			sin6-&gt;sin6_port = IPSEC_PORT_ANY;
			bcopy(&amp;ip6-&gt;ip6_dst, &amp;sin6-&gt;sin6_addr,
				  <span class="enscript-keyword">sizeof</span>(ip6-&gt;ip6_dst));
			<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;ip6-&gt;ip6_dst)) {
				<span class="enscript-comment">/* fix scope id for comparing SPD */</span>
				sin6-&gt;sin6_addr.s6_addr16[1] = 0;
				sin6-&gt;sin6_scope_id = ntohs(ip6-&gt;ip6_dst.s6_addr16[1]);
			}
		}
		
		<span class="enscript-keyword">if</span> (key_checkrequest(isr, &amp;saidx, &amp;sav) == ENOENT) {
			<span class="enscript-comment">/*
			 * IPsec processing is required, but no SA found.
			 * I assume that key_acquire() had been called
			 * to get/establish the SA. Here I discard
			 * this packet because it is responsibility for
			 * upper layer to retransmit the packet.
			 */</span>
			IPSEC_STAT_INCREMENT(ipsec6stat.out_nosa);
			error = ENOENT;
			
			<span class="enscript-comment">/*
			 * Notify the fact that the packet is discarded
			 * to ourselves. I believe this is better than
			 * just silently discarding. (<a href="mailto:jinmei@kame.net">jinmei@kame.net</a>)
			 * XXX: should we restrict the error to TCP packets?
			 * XXX: should we directly notify sockets via
			 *      pfctlinputs?
			 */</span>
			icmp6_error(state-&gt;m, ICMP6_DST_UNREACH,
						ICMP6_DST_UNREACH_ADMIN, 0);
			state-&gt;m = NULL; <span class="enscript-comment">/* icmp6_error freed the mbuf */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		
		<span class="enscript-comment">/* validity check */</span>
		<span class="enscript-keyword">if</span> (sav == NULL) {
			<span class="enscript-keyword">switch</span> (ipsec_get_reqlevel(isr)) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_LEVEL_USE</span>:
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_LEVEL_REQUIRE</span>:
					<span class="enscript-comment">/* must be not reached here. */</span>
					panic(<span class="enscript-string">&quot;ipsec6_output_trans: no SA found, but required.&quot;</span>);
			}
		}
		
		<span class="enscript-keyword">if</span> ((error = ipsec6_output_trans_internal(state, sav, nexthdrp, mprev)) != 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}
	
	<span class="enscript-comment">/* if we have more to go, we need a tunnel mode processing */</span>
	<span class="enscript-keyword">if</span> (isr != NULL)
		*tun = 1;
	
	<span class="enscript-keyword">if</span> (sav)
		key_freesav(sav, KEY_SADB_UNLOCKED);
	<span class="enscript-keyword">return</span> 0;
	
<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">if</span> (sav)
		key_freesav(sav, KEY_SADB_UNLOCKED);
	m_freem(state-&gt;m);
	state-&gt;m = NULL;
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * IPsec output logic for IPv6, tunnel mode.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_output_tunnel_internal</span>(<span class="enscript-type">struct</span> ipsec_output_state *state, <span class="enscript-type">struct</span> secasvar *sav, <span class="enscript-type">int</span> *must_be_last)
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> plen;
	<span class="enscript-type">struct</span> sockaddr_in6* dst6;
	<span class="enscript-type">struct</span> route *ro6;
	
	<span class="enscript-comment">/* validity check */</span>
	<span class="enscript-keyword">if</span> (sav == NULL || sav-&gt;sah == NULL || sav-&gt;sah-&gt;saidx.mode != IPSEC_MODE_TUNNEL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
		
	<span class="enscript-comment">/*
	 * If there is no valid SA, we give up to process.
	 * see same place at ipsec4_output().
	 */</span>
	<span class="enscript-keyword">if</span> (sav-&gt;state != SADB_SASTATE_MATURE
		&amp;&amp; sav-&gt;state != SADB_SASTATE_DYING) {
		IPSEC_STAT_INCREMENT(ipsec6stat.out_nosa);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	
	state-&gt;outgoing_if = sav-&gt;sah-&gt;outgoing_if;
	
	<span class="enscript-keyword">if</span> (sav-&gt;sah-&gt;saidx.mode == IPSEC_MODE_TUNNEL) {
		<span class="enscript-comment">/*
		 * build IPsec tunnel.
		 */</span>
		state-&gt;m = ipsec6_splithdr(state-&gt;m);
		<span class="enscript-keyword">if</span> (!state-&gt;m) {
			IPSEC_STAT_INCREMENT(ipsec6stat.out_nomem);
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		
		<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family == AF_INET6) {
			error = ipsec6_encapsulate(state-&gt;m, sav);
			<span class="enscript-keyword">if</span> (error) {
				state-&gt;m = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			ip6 = mtod(state-&gt;m, <span class="enscript-type">struct</span> ip6_hdr *);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> sockaddr *)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sa_family == AF_INET) {
			
			<span class="enscript-type">struct</span> ip *ip;
			<span class="enscript-type">struct</span> sockaddr_in* dst4;
			<span class="enscript-type">struct</span> route *ro4 = NULL;
			<span class="enscript-type">struct</span> route  ro4_copy;
			<span class="enscript-type">struct</span> ip_out_args ipoa = { IFSCOPE_NONE, { 0 },
				IPOAF_SELECT_SRCIF, 0 };
			
			<span class="enscript-keyword">if</span> (must_be_last)
				*must_be_last = 1;

			state-&gt;tunneled = 4; <span class="enscript-comment">/* must not process any further in ip6_output */</span>
			error = ipsec64_encapsulate(state-&gt;m, sav);
			<span class="enscript-keyword">if</span> (error) {
				state-&gt;m = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			<span class="enscript-comment">/* Now we have an IPv4 packet */</span>
			ip = mtod(state-&gt;m, <span class="enscript-type">struct</span> ip *);
			
			<span class="enscript-comment">// grab sadb_mutex, to update sah's route cache and get a local copy of it
</span>			lck_mtx_lock(sadb_mutex);
			ro4 = &amp;sav-&gt;sah-&gt;sa_route;
			dst4 = (<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)&amp;ro4-&gt;ro_dst;
			<span class="enscript-keyword">if</span> (ro4-&gt;ro_rt) {
				RT_LOCK(ro4-&gt;ro_rt);
			}
			<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro4) ||
				dst4-&gt;sin_addr.s_addr != ip-&gt;ip_dst.s_addr) {
				<span class="enscript-keyword">if</span> (ro4-&gt;ro_rt != NULL)
					RT_UNLOCK(ro4-&gt;ro_rt);
				ROUTE_RELEASE(ro4);
			}
			<span class="enscript-keyword">if</span> (ro4-&gt;ro_rt == NULL) {
				dst4-&gt;sin_family = AF_INET;
				dst4-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(*dst4);
				dst4-&gt;sin_addr = ip-&gt;ip_dst;
			} <span class="enscript-keyword">else</span> {
				RT_UNLOCK(ro4-&gt;ro_rt);
			}
			route_copyout(&amp;ro4_copy, ro4, <span class="enscript-keyword">sizeof</span>(ro4_copy));
			<span class="enscript-comment">// release sadb_mutex, after updating sah's route cache and getting a local copy
</span>			lck_mtx_unlock(sadb_mutex);
			state-&gt;m = ipsec4_splithdr(state-&gt;m);
			<span class="enscript-keyword">if</span> (!state-&gt;m) {
				error = ENOMEM;
				ROUTE_RELEASE(&amp;ro4_copy);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			<span class="enscript-keyword">switch</span> (sav-&gt;sah-&gt;saidx.proto) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
					<span class="enscript-keyword">if</span> ((error = esp4_output(state-&gt;m, sav)) != 0) {
						state-&gt;m = NULL;
						ROUTE_RELEASE(&amp;ro4_copy);
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
					}
					<span class="enscript-keyword">break</span>;
					
#<span class="enscript-reference">else</span>
					m_freem(state-&gt;m);
					state-&gt;m = NULL;
					error = EINVAL;
					ROUTE_RELEASE(&amp;ro4_copy);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
#<span class="enscript-reference">endif</span>
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
					<span class="enscript-keyword">if</span> ((error = ah4_output(state-&gt;m, sav)) != 0) {
						state-&gt;m = NULL;
						ROUTE_RELEASE(&amp;ro4_copy);
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
					}
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_IPCOMP</span>:
					<span class="enscript-keyword">if</span> ((error = ipcomp4_output(state-&gt;m, sav)) != 0) {
						state-&gt;m = NULL;
						ROUTE_RELEASE(&amp;ro4_copy);
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
					}
					<span class="enscript-keyword">break</span>;
				<span class="enscript-reference">default</span>:
					ipseclog((LOG_ERR,
							  <span class="enscript-string">&quot;ipsec4_output: unknown ipsec protocol %d\n&quot;</span>,
							  sav-&gt;sah-&gt;saidx.proto));
					m_freem(state-&gt;m);
					state-&gt;m = NULL;
					error = EINVAL;
					ROUTE_RELEASE(&amp;ro4_copy);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			
			<span class="enscript-keyword">if</span> (state-&gt;m == 0) {
				error = ENOMEM;
				ROUTE_RELEASE(&amp;ro4_copy);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			ipsec_set_pkthdr_for_interface(sav-&gt;sah-&gt;ipsec_if, state-&gt;m, AF_INET);
			ip = mtod(state-&gt;m, <span class="enscript-type">struct</span> ip *);
			ip-&gt;ip_len = ntohs(ip-&gt;ip_len);  <span class="enscript-comment">/* flip len field before calling ip_output */</span>
			error = ip_output(state-&gt;m, NULL, &amp;ro4_copy, IP_OUTARGS, NULL, &amp;ipoa);
			state-&gt;m = NULL;
			<span class="enscript-comment">// grab sadb_mutex, to synchronize the sah's route cache with the local copy
</span>			lck_mtx_lock(sadb_mutex);
			route_copyin(&amp;ro4_copy, ro4, <span class="enscript-keyword">sizeof</span>(ro4_copy));
			lck_mtx_unlock(sadb_mutex);
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		} <span class="enscript-keyword">else</span> {
			ipseclog((LOG_ERR, <span class="enscript-string">&quot;ipsec6_output_tunnel: &quot;</span>
					  <span class="enscript-string">&quot;unsupported inner family, spi=%u\n&quot;</span>,
					  (u_int32_t)ntohl(sav-&gt;spi)));
			IPSEC_STAT_INCREMENT(ipsec6stat.out_inval);
			error = EAFNOSUPPORT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		
		<span class="enscript-comment">// grab sadb_mutex, before updating sah's route cache
</span>		lck_mtx_lock(sadb_mutex);
		ro6 = &amp;sav-&gt;sah-&gt;sa_route;
		dst6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)&amp;ro6-&gt;ro_dst;
		<span class="enscript-keyword">if</span> (ro6-&gt;ro_rt) {
			RT_LOCK(ro6-&gt;ro_rt);
		}
		<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(ro6) ||
			!IN6_ARE_ADDR_EQUAL(&amp;dst6-&gt;sin6_addr, &amp;ip6-&gt;ip6_dst)) {
			<span class="enscript-keyword">if</span> (ro6-&gt;ro_rt != NULL)
				RT_UNLOCK(ro6-&gt;ro_rt);
			ROUTE_RELEASE(ro6);
		}
		<span class="enscript-keyword">if</span> (ro6-&gt;ro_rt == 0) {
			bzero(dst6, <span class="enscript-keyword">sizeof</span>(*dst6));
			dst6-&gt;sin6_family = AF_INET6;
			dst6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(*dst6);
			dst6-&gt;sin6_addr = ip6-&gt;ip6_dst;
			rtalloc(ro6);
			<span class="enscript-keyword">if</span> (ro6-&gt;ro_rt) {
				RT_LOCK(ro6-&gt;ro_rt);
			}
		}
		<span class="enscript-keyword">if</span> (ro6-&gt;ro_rt == 0) {
			ip6stat.ip6s_noroute++;
			IPSEC_STAT_INCREMENT(ipsec6stat.out_noroute);
			error = EHOSTUNREACH;
			<span class="enscript-comment">// release sadb_mutex, after updating sah's route cache
</span>			lck_mtx_unlock(sadb_mutex);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		
		<span class="enscript-comment">/*
		 * adjust state-&gt;dst if tunnel endpoint is offlink
		 *
		 * XXX: caching rt_gateway value in the state is
		 * not really good, since it may point elsewhere
		 * when the gateway gets modified to a larger
		 * sockaddr via rt_setgate().  This is currently
		 * addressed by SA_SIZE roundup in that routine.
		 */</span>
		<span class="enscript-keyword">if</span> (ro6-&gt;ro_rt-&gt;rt_flags &amp; RTF_GATEWAY)
			dst6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)ro6-&gt;ro_rt-&gt;rt_gateway;
		RT_UNLOCK(ro6-&gt;ro_rt);
		ROUTE_RELEASE(&amp;state-&gt;ro);
		route_copyout(&amp;state-&gt;ro, ro6, <span class="enscript-keyword">sizeof</span>(state-&gt;ro));
		state-&gt;dst = (<span class="enscript-type">struct</span> sockaddr *)dst6;
		state-&gt;tunneled = 6;
		<span class="enscript-comment">// release sadb_mutex, after updating sah's route cache
</span>		lck_mtx_unlock(sadb_mutex);
	}
	
	state-&gt;m = ipsec6_splithdr(state-&gt;m);
	<span class="enscript-keyword">if</span> (!state-&gt;m) {
		IPSEC_STAT_INCREMENT(ipsec6stat.out_nomem);
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	ip6 = mtod(state-&gt;m, <span class="enscript-type">struct</span> ip6_hdr *);
	<span class="enscript-keyword">switch</span> (sav-&gt;sah-&gt;saidx.proto) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_ESP</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC_ESP</span>
			error = esp6_output(state-&gt;m, &amp;ip6-&gt;ip6_nxt, state-&gt;m-&gt;m_next, sav);
#<span class="enscript-reference">else</span>
			m_freem(state-&gt;m);
			error = EINVAL;
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_AH</span>:
			error = ah6_output(state-&gt;m, &amp;ip6-&gt;ip6_nxt, state-&gt;m-&gt;m_next, sav);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPPROTO_IPCOMP</span>:
			<span class="enscript-comment">/* XXX code should be here */</span>
			<span class="enscript-comment">/*FALLTHROUGH*/</span>
		<span class="enscript-reference">default</span>:
			ipseclog((LOG_ERR, <span class="enscript-string">&quot;ipsec6_output_tunnel: &quot;</span>
					  <span class="enscript-string">&quot;unknown ipsec protocol %d\n&quot;</span>, sav-&gt;sah-&gt;saidx.proto));
			m_freem(state-&gt;m);
			IPSEC_STAT_INCREMENT(ipsec6stat.out_inval);
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (error) {
		state-&gt;m = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	plen = state-&gt;m-&gt;m_pkthdr.len - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
	<span class="enscript-keyword">if</span> (plen &gt; IPV6_MAXPACKET) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;ipsec6_output_tunnel: &quot;</span>
				  <span class="enscript-string">&quot;IPsec with IPv6 jumbogram is not supported\n&quot;</span>));
		IPSEC_STAT_INCREMENT(ipsec6stat.out_inval);
		error = EINVAL;	<span class="enscript-comment">/*XXX*/</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	ip6 = mtod(state-&gt;m, <span class="enscript-type">struct</span> ip6_hdr *);
	ip6-&gt;ip6_plen = htons(plen);
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> 0;
	
<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_output_tunnel</span>(
	<span class="enscript-type">struct</span> ipsec_output_state *state,
	<span class="enscript-type">struct</span> secpolicy *sp,
	__unused <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">struct</span> ipsecrequest *isr = NULL;
	<span class="enscript-type">struct</span> secasindex saidx;
	<span class="enscript-type">struct</span> secasvar *sav = NULL;
	<span class="enscript-type">int</span> error = 0;

	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-keyword">if</span> (!state)
		panic(<span class="enscript-string">&quot;state == NULL in ipsec6_output_tunnel&quot;</span>);
	<span class="enscript-keyword">if</span> (!state-&gt;m)
		panic(<span class="enscript-string">&quot;state-&gt;m == NULL in ipsec6_output_tunnel&quot;</span>);
	<span class="enscript-keyword">if</span> (!sp)
		panic(<span class="enscript-string">&quot;sp == NULL in ipsec6_output_tunnel&quot;</span>);

	KEYDEBUG(KEYDEBUG_IPSEC_DATA,
		printf(<span class="enscript-string">&quot;ipsec6_output_tunnel: applyed SP\n&quot;</span>);
		kdebug_secpolicy(sp));

	<span class="enscript-comment">/*
	 * transport mode ipsec (before the 1st tunnel mode) is already
	 * processed by ipsec6_output_trans().
	 */</span>
	<span class="enscript-keyword">for</span> (isr = sp-&gt;req; isr; isr = isr-&gt;next) {
		<span class="enscript-keyword">if</span> (isr-&gt;saidx.mode == IPSEC_MODE_TUNNEL)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">for</span> (<span class="enscript-comment">/* already initialized */</span>; isr; isr = isr-&gt;next) {
		<span class="enscript-keyword">if</span> (isr-&gt;saidx.mode == IPSEC_MODE_TUNNEL) {
			<span class="enscript-comment">/* When tunnel mode, SA peers must be specified. */</span>
			bcopy(&amp;isr-&gt;saidx, &amp;saidx, <span class="enscript-keyword">sizeof</span>(saidx));
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* make SA index to look for a proper SA */</span>
			<span class="enscript-type">struct</span> sockaddr_in6 *sin6;

			bzero(&amp;saidx, <span class="enscript-keyword">sizeof</span>(saidx));
			saidx.proto = isr-&gt;saidx.proto;
			saidx.mode = isr-&gt;saidx.mode;
			saidx.reqid = isr-&gt;saidx.reqid;

			ip6 = mtod(state-&gt;m, <span class="enscript-type">struct</span> ip6_hdr *);
			sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;saidx.src;
			<span class="enscript-keyword">if</span> (sin6-&gt;sin6_len == 0) {
				sin6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(*sin6);
				sin6-&gt;sin6_family = AF_INET6;
				sin6-&gt;sin6_port = IPSEC_PORT_ANY;
				bcopy(&amp;ip6-&gt;ip6_src, &amp;sin6-&gt;sin6_addr,
				    <span class="enscript-keyword">sizeof</span>(ip6-&gt;ip6_src));
				<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;ip6-&gt;ip6_src)) {
					<span class="enscript-comment">/* fix scope id for comparing SPD */</span>
					sin6-&gt;sin6_addr.s6_addr16[1] = 0;
					sin6-&gt;sin6_scope_id = ntohs(ip6-&gt;ip6_src.s6_addr16[1]);
				}
			}
			sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;saidx.dst;
			<span class="enscript-keyword">if</span> (sin6-&gt;sin6_len == 0) {
				sin6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(*sin6);
				sin6-&gt;sin6_family = AF_INET6;
				sin6-&gt;sin6_port = IPSEC_PORT_ANY;
				bcopy(&amp;ip6-&gt;ip6_dst, &amp;sin6-&gt;sin6_addr,
				    <span class="enscript-keyword">sizeof</span>(ip6-&gt;ip6_dst));
				<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;ip6-&gt;ip6_dst)) {
					<span class="enscript-comment">/* fix scope id for comparing SPD */</span>
					sin6-&gt;sin6_addr.s6_addr16[1] = 0;
					sin6-&gt;sin6_scope_id = ntohs(ip6-&gt;ip6_dst.s6_addr16[1]);
				}
			}
		}

		<span class="enscript-keyword">if</span> (key_checkrequest(isr, &amp;saidx, &amp;sav) == ENOENT) {
			<span class="enscript-comment">/*
			 * IPsec processing is required, but no SA found.
			 * I assume that key_acquire() had been called
			 * to get/establish the SA. Here I discard
			 * this packet because it is responsibility for
			 * upper layer to retransmit the packet.
			 */</span>
			IPSEC_STAT_INCREMENT(ipsec6stat.out_nosa);
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

		<span class="enscript-comment">/* validity check */</span>
		<span class="enscript-keyword">if</span> (sav == NULL) {
			<span class="enscript-keyword">switch</span> (ipsec_get_reqlevel(isr)) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_LEVEL_USE</span>:
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IPSEC_LEVEL_REQUIRE</span>:
				<span class="enscript-comment">/* must be not reached here. */</span>
				panic(<span class="enscript-string">&quot;ipsec6_output_tunnel: no SA found, but required.&quot;</span>);
			}
		}

		<span class="enscript-comment">/*
		 * If there is no valid SA, we give up to process.
		 * see same place at ipsec4_output().
		 */</span>
		<span class="enscript-keyword">if</span> (sav-&gt;state != SADB_SASTATE_MATURE
		 &amp;&amp; sav-&gt;state != SADB_SASTATE_DYING) {
			IPSEC_STAT_INCREMENT(ipsec6stat.out_nosa);
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		
		<span class="enscript-type">int</span> must_be_last = 0;
		
		<span class="enscript-keyword">if</span> ((error = ipsec6_output_tunnel_internal(state, sav, &amp;must_be_last)) != 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		
		<span class="enscript-keyword">if</span> (must_be_last &amp;&amp; isr-&gt;next) {
			ipseclog((LOG_ERR, <span class="enscript-string">&quot;ipsec6_output_tunnel: &quot;</span>
					  <span class="enscript-string">&quot;IPv4 must be outer layer, spi=%u\n&quot;</span>,
					  (u_int32_t)ntohl(sav-&gt;spi)));
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

	<span class="enscript-keyword">if</span> (sav)
		key_freesav(sav, KEY_SADB_UNLOCKED);
	<span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">if</span> (sav)
		key_freesav(sav, KEY_SADB_UNLOCKED);
	<span class="enscript-keyword">if</span> (state-&gt;m)
		m_freem(state-&gt;m);
	state-&gt;m = NULL;
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_interface_output</span>(<span class="enscript-type">struct</span> ipsec_output_state *state, ifnet_t interface, u_char *nexthdrp, <span class="enscript-type">struct</span> mbuf *mprev)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> secasvar *sav = NULL;
	
	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
	<span class="enscript-keyword">if</span> (!state)
		panic(<span class="enscript-string">&quot;state == NULL in ipsec6_output&quot;</span>);
	<span class="enscript-keyword">if</span> (!state-&gt;m)
		panic(<span class="enscript-string">&quot;state-&gt;m == NULL in ipsec6_output&quot;</span>);
	<span class="enscript-keyword">if</span> (!nexthdrp)
		panic(<span class="enscript-string">&quot;nexthdrp == NULL in ipsec6_output&quot;</span>);
	<span class="enscript-keyword">if</span> (!mprev)
		panic(<span class="enscript-string">&quot;mprev == NULL in ipsec6_output&quot;</span>);
	
	sav = key_alloc_outbound_sav_for_interface(interface, AF_INET6);
	<span class="enscript-keyword">if</span> (sav == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	
	<span class="enscript-keyword">if</span> (sav-&gt;sah &amp;&amp; sav-&gt;sah-&gt;saidx.mode == IPSEC_MODE_TUNNEL) {
		<span class="enscript-keyword">if</span> ((error = ipsec6_output_tunnel_internal(state, sav, NULL)) != 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((error = ipsec6_output_trans_internal(state, sav, nexthdrp, mprev)) != 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}
	
	<span class="enscript-keyword">if</span> (sav)
		key_freesav(sav, KEY_SADB_UNLOCKED);
	<span class="enscript-keyword">return</span> 0;
	
<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">if</span> (sav)
		key_freesav(sav, KEY_SADB_UNLOCKED);
	m_freem(state-&gt;m);
	state-&gt;m = NULL;
	<span class="enscript-keyword">return</span> error;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/*INET6*/</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
<span class="enscript-comment">/*
 * Chop IP header and option off from the payload.
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">ipsec4_splithdr</span>(m)
	<span class="enscript-type">struct</span> mbuf *m;
{
	<span class="enscript-type">struct</span> mbuf *mh;
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">int</span> hlen;

	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip))
		panic(<span class="enscript-string">&quot;ipsec4_splithdr: first mbuf too short, m_len %d, pkt_len %d, m_flag %x&quot;</span>, m-&gt;m_len, m-&gt;m_pkthdr.len, m-&gt;m_flags);
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
	hlen = _IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
#<span class="enscript-reference">else</span>
	hlen = ip-&gt;ip_hl &lt;&lt; 2;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_len &gt; hlen) {
		MGETHDR(mh, M_DONTWAIT, MT_HEADER);	<span class="enscript-comment">/* MAC-OK */</span>
		<span class="enscript-keyword">if</span> (!mh) {
			m_freem(m);
			<span class="enscript-keyword">return</span> NULL;
		}
		M_COPY_PKTHDR(mh, m);
		MH_ALIGN(mh, hlen);
		m-&gt;m_flags &amp;= ~M_PKTHDR;
		m_mchtype(m, MT_DATA);
		m-&gt;m_len -= hlen;
		m-&gt;m_data += hlen;
		mh-&gt;m_next = m;
		m = mh;
		m-&gt;m_len = hlen;
		bcopy((caddr_t)ip, mtod(m, caddr_t), hlen);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_len &lt; hlen) {
		m = m_pullup(m, hlen);
		<span class="enscript-keyword">if</span> (!m)
			<span class="enscript-keyword">return</span> NULL;
	}
	<span class="enscript-keyword">return</span> m;
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">ipsec6_splithdr</span>(m)
	<span class="enscript-type">struct</span> mbuf *m;
{
	<span class="enscript-type">struct</span> mbuf *mh;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;
	<span class="enscript-type">int</span> hlen;

	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr))
		panic(<span class="enscript-string">&quot;ipsec6_splithdr: first mbuf too short&quot;</span>);
	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	hlen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr);
	<span class="enscript-keyword">if</span> (m-&gt;m_len &gt; hlen) {
		MGETHDR(mh, M_DONTWAIT, MT_HEADER);	<span class="enscript-comment">/* MAC-OK */</span>
		<span class="enscript-keyword">if</span> (!mh) {
			m_freem(m);
			<span class="enscript-keyword">return</span> NULL;
		}
		M_COPY_PKTHDR(mh, m);
		MH_ALIGN(mh, hlen);
		m-&gt;m_flags &amp;= ~M_PKTHDR;
		m_mchtype(m, MT_DATA);
		m-&gt;m_len -= hlen;
		m-&gt;m_data += hlen;
		mh-&gt;m_next = m;
		m = mh;
		m-&gt;m_len = hlen;
		bcopy((caddr_t)ip6, mtod(m, caddr_t), hlen);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_len &lt; hlen) {
		m = m_pullup(m, hlen);
		<span class="enscript-keyword">if</span> (!m)
			<span class="enscript-keyword">return</span> NULL;
	}
	<span class="enscript-keyword">return</span> m;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* validate inbound IPsec tunnel packet. */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec4_tunnel_validate</span>(m, off, nxt0, sav, ifamily)
	<span class="enscript-type">struct</span> mbuf *m;		<span class="enscript-comment">/* no pullup permitted, m-&gt;m_len &gt;= ip */</span>
	<span class="enscript-type">int</span> off;
	u_int nxt0;
	<span class="enscript-type">struct</span> secasvar *sav;
	sa_family_t *ifamily;
{
	u_int8_t nxt = nxt0 &amp; 0xff;
	<span class="enscript-type">struct</span> sockaddr_in *sin;
	<span class="enscript-type">struct</span> sockaddr_in osrc, odst, i4src, i4dst;
	<span class="enscript-type">struct</span> sockaddr_in6 i6src, i6dst;
	<span class="enscript-type">int</span> hlen;
	<span class="enscript-type">struct</span> secpolicy *sp;
	<span class="enscript-type">struct</span> ip *oip;

	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip))
		panic(<span class="enscript-string">&quot;too short mbuf on ipsec4_tunnel_validate&quot;</span>);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (nxt != IPPROTO_IPV4 &amp;&amp; nxt != IPPROTO_IPV6)
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip))
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-comment">/* do not decapsulate if the SA is for transport mode only */</span>
	<span class="enscript-keyword">if</span> (sav-&gt;sah-&gt;saidx.mode == IPSEC_MODE_TRANSPORT)
		<span class="enscript-keyword">return</span> 0;

	oip = mtod(m, <span class="enscript-type">struct</span> ip *);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
	hlen = _IP_VHL_HL(oip-&gt;ip_vhl) &lt;&lt; 2;
#<span class="enscript-reference">else</span>
	hlen = oip-&gt;ip_hl &lt;&lt; 2;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (hlen != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip))
		<span class="enscript-keyword">return</span> 0;

	sin = (<span class="enscript-type">struct</span> sockaddr_in *)&amp;sav-&gt;sah-&gt;saidx.dst;
	<span class="enscript-keyword">if</span> (sin-&gt;sin_family != AF_INET)
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">if</span> (bcmp(&amp;oip-&gt;ip_dst, &amp;sin-&gt;sin_addr, <span class="enscript-keyword">sizeof</span>(oip-&gt;ip_dst)) != 0)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">if</span> (sav-&gt;utun_in_fn ||
		sav-&gt;sah-&gt;ipsec_if != NULL) {
		<span class="enscript-comment">// the ipsec/utun interface SAs don't have a policies.
</span>		<span class="enscript-keyword">if</span> (nxt == IPPROTO_IPV4) {
			*ifamily = AF_INET;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nxt == IPPROTO_IPV6) {
			*ifamily = AF_INET6;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">return</span> 0;
		}
		<span class="enscript-keyword">return</span> 1;
	}

	<span class="enscript-comment">/* XXX slow */</span>
	bzero(&amp;osrc, <span class="enscript-keyword">sizeof</span>(osrc));
	bzero(&amp;odst, <span class="enscript-keyword">sizeof</span>(odst));
	osrc.sin_family = odst.sin_family = AF_INET;
	osrc.sin_len = odst.sin_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
	osrc.sin_addr = oip-&gt;ip_src;
	odst.sin_addr = oip-&gt;ip_dst;
	<span class="enscript-comment">/*
	 * RFC2401 5.2.1 (b): (assume that we are using tunnel mode)
	 * - if the inner destination is multicast address, there can be
	 *   multiple permissible inner source address.  implementation
	 *   may want to skip verification of inner source address against
	 *   SPD selector.
	 * - if the inner protocol is ICMP, the packet may be an error report
	 *   from routers on the other side of the VPN cloud (R in the
	 *   following diagram).  in this case, we cannot verify inner source
	 *   address against SPD selector.
	 *	me -- gw === gw -- R -- you
	 *
	 * we consider the first bullet to be users responsibility on SPD entry
	 * configuration (if you need to encrypt multicast traffic, set
	 * the source range of SPD selector to 0.0.0.0/0, or have explicit
	 * address ranges for possible senders).
	 * the second bullet is not taken care of (yet).
	 *
	 * therefore, we do not do anything special about inner source.
	 */</span>
	<span class="enscript-keyword">if</span> (nxt == IPPROTO_IPV4) {
		bzero(&amp;i4src, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in));
		bzero(&amp;i4dst, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in));
		i4src.sin_family = i4dst.sin_family = *ifamily = AF_INET;
		i4src.sin_len = i4dst.sin_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
		m_copydata(m, off + offsetof(<span class="enscript-type">struct</span> ip, ip_src), <span class="enscript-keyword">sizeof</span>(i4src.sin_addr),
			   (caddr_t)&amp;i4src.sin_addr);
		m_copydata(m, off + offsetof(<span class="enscript-type">struct</span> ip, ip_dst), <span class="enscript-keyword">sizeof</span>(i4dst.sin_addr),
			   (caddr_t)&amp;i4dst.sin_addr);
		sp = key_gettunnel((<span class="enscript-type">struct</span> sockaddr *)&amp;osrc, (<span class="enscript-type">struct</span> sockaddr *)&amp;odst,
				   (<span class="enscript-type">struct</span> sockaddr *)&amp;i4src, (<span class="enscript-type">struct</span> sockaddr *)&amp;i4dst);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nxt == IPPROTO_IPV6) {
		bzero(&amp;i6src, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6));
		bzero(&amp;i6dst, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6));
		i6src.sin6_family = i6dst.sin6_family = *ifamily = AF_INET6;
		i6src.sin6_len = i6dst.sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
		m_copydata(m, off + offsetof(<span class="enscript-type">struct</span> ip6_hdr, ip6_src), <span class="enscript-keyword">sizeof</span>(i6src.sin6_addr),
			   (caddr_t)&amp;i6src.sin6_addr);
		m_copydata(m, off + offsetof(<span class="enscript-type">struct</span> ip6_hdr, ip6_dst), <span class="enscript-keyword">sizeof</span>(i6dst.sin6_addr),
			   (caddr_t)&amp;i6dst.sin6_addr);
		sp = key_gettunnel((<span class="enscript-type">struct</span> sockaddr *)&amp;osrc, (<span class="enscript-type">struct</span> sockaddr *)&amp;odst,
				   (<span class="enscript-type">struct</span> sockaddr *)&amp;i6src, (<span class="enscript-type">struct</span> sockaddr *)&amp;i6dst);
	} <span class="enscript-keyword">else</span> 
		<span class="enscript-keyword">return</span> 0;	<span class="enscript-comment">/* unsupported family */</span>

	<span class="enscript-keyword">if</span> (!sp) 
		<span class="enscript-keyword">return</span> 0;

	key_freesp(sp, KEY_SADB_UNLOCKED);

	<span class="enscript-keyword">return</span> 1;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-comment">/* validate inbound IPsec tunnel packet. */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec6_tunnel_validate</span>(m, off, nxt0, sav, ifamily)
	<span class="enscript-type">struct</span> mbuf *m;		<span class="enscript-comment">/* no pullup permitted, m-&gt;m_len &gt;= ip */</span>
	<span class="enscript-type">int</span> off;
	u_int nxt0;
	<span class="enscript-type">struct</span> secasvar *sav;
	sa_family_t *ifamily;
{
	u_int8_t nxt = nxt0 &amp; 0xff;
	<span class="enscript-type">struct</span> sockaddr_in6 *sin6;
	<span class="enscript-type">struct</span> sockaddr_in6 osrc, odst, isrc, idst;
	<span class="enscript-type">struct</span> secpolicy *sp;
	<span class="enscript-type">struct</span> ip6_hdr *oip6;

	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr))
		panic(<span class="enscript-string">&quot;too short mbuf on ipsec6_tunnel_validate&quot;</span>);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (nxt != IPPROTO_IPV4 &amp;&amp; nxt != IPPROTO_IPV6)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt; off + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr))
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-comment">/* do not decapsulate if the SA is for transport mode only */</span>
	<span class="enscript-keyword">if</span> (sav-&gt;sah-&gt;saidx.mode == IPSEC_MODE_TRANSPORT)
		<span class="enscript-keyword">return</span> 0;

	oip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	<span class="enscript-comment">/* AF_INET should be supported, but at this moment we don't. */</span>
	sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)&amp;sav-&gt;sah-&gt;saidx.dst;
	<span class="enscript-keyword">if</span> (sin6-&gt;sin6_family != AF_INET6)
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">if</span> (!IN6_ARE_ADDR_EQUAL(&amp;oip6-&gt;ip6_dst, &amp;sin6-&gt;sin6_addr))
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">if</span> (sav-&gt;utun_in_fn ||
		sav-&gt;sah-&gt;ipsec_if != NULL) {
		<span class="enscript-comment">// the ipsec/utun interface SAs don't have a policies.
</span>		<span class="enscript-keyword">if</span> (nxt == IPPROTO_IPV4) {
			*ifamily = AF_INET;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nxt == IPPROTO_IPV6) {
			*ifamily = AF_INET6;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">return</span> 0;
		}
		<span class="enscript-keyword">return</span> 1;
	}
	
	<span class="enscript-comment">/* XXX slow */</span>
	bzero(&amp;osrc, <span class="enscript-keyword">sizeof</span>(osrc));
	bzero(&amp;odst, <span class="enscript-keyword">sizeof</span>(odst));
	bzero(&amp;isrc, <span class="enscript-keyword">sizeof</span>(isrc));
	bzero(&amp;idst, <span class="enscript-keyword">sizeof</span>(idst));
	osrc.sin6_family = odst.sin6_family = isrc.sin6_family =
	    idst.sin6_family = *ifamily = AF_INET6;
	osrc.sin6_len = odst.sin6_len = isrc.sin6_len = idst.sin6_len = 
	    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
	osrc.sin6_addr = oip6-&gt;ip6_src;
	odst.sin6_addr = oip6-&gt;ip6_dst;
	m_copydata(m, off + offsetof(<span class="enscript-type">struct</span> ip6_hdr, ip6_src),
	    <span class="enscript-keyword">sizeof</span>(isrc.sin6_addr), (caddr_t)&amp;isrc.sin6_addr);
	m_copydata(m, off + offsetof(<span class="enscript-type">struct</span> ip6_hdr, ip6_dst),
	    <span class="enscript-keyword">sizeof</span>(idst.sin6_addr), (caddr_t)&amp;idst.sin6_addr);

	<span class="enscript-comment">/*
	 * regarding to inner source address validation, see a long comment
	 * in ipsec4_tunnel_validate.
	 */</span>

	sp = key_gettunnel((<span class="enscript-type">struct</span> sockaddr *)&amp;osrc, (<span class="enscript-type">struct</span> sockaddr *)&amp;odst,
	    (<span class="enscript-type">struct</span> sockaddr *)&amp;isrc, (<span class="enscript-type">struct</span> sockaddr *)&amp;idst);
	<span class="enscript-comment">/*
	 * when there is no suitable inbound policy for the packet of the ipsec
	 * tunnel mode, the kernel never decapsulate the tunneled packet
	 * as the ipsec tunnel mode even when the system wide policy is &quot;none&quot;.
	 * then the kernel leaves the generic tunnel module to process this
	 * packet.  if there is no rule of the generic tunnel, the packet
	 * is rejected and the statistics will be counted up.
	 */</span>
	<span class="enscript-keyword">if</span> (!sp)
		<span class="enscript-keyword">return</span> 0;
	key_freesp(sp, KEY_SADB_UNLOCKED);

	<span class="enscript-keyword">return</span> 1;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Make a mbuf chain for encryption.
 * If the original mbuf chain contains a mbuf with a cluster,
 * allocate a new cluster and copy the data to the new cluster.
 * XXX: this hack is inefficient, but is necessary to handle cases
 * of TCP retransmission...
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">ipsec_copypkt</span>(m)
	<span class="enscript-type">struct</span> mbuf *m;
{
	<span class="enscript-type">struct</span> mbuf *n, **mpp, *mnew;

	<span class="enscript-keyword">for</span> (n = m, mpp = &amp;m; n; n = n-&gt;m_next) {
		<span class="enscript-keyword">if</span> (n-&gt;m_flags &amp; M_EXT) {
			<span class="enscript-comment">/*
			 * Make a copy only if there are more than one references
			 * to the cluster.
			 * XXX: is this approach effective?
			 */</span>
			<span class="enscript-keyword">if</span> (
				n-&gt;m_ext.ext_free ||
				m_mclhasreference(n)
			    )
			{
				<span class="enscript-type">int</span> remain, copied;
				<span class="enscript-type">struct</span> mbuf *mm;

				<span class="enscript-keyword">if</span> (n-&gt;m_flags &amp; M_PKTHDR) {
					MGETHDR(mnew, M_DONTWAIT, MT_HEADER); <span class="enscript-comment">/* MAC-OK */</span>
					<span class="enscript-keyword">if</span> (mnew == NULL)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
					M_COPY_PKTHDR(mnew, n);
				}
				<span class="enscript-keyword">else</span> {
					MGET(mnew, M_DONTWAIT, MT_DATA);
					<span class="enscript-keyword">if</span> (mnew == NULL)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
				}
				mnew-&gt;m_len = 0;
				mm = mnew;

				<span class="enscript-comment">/*
				 * Copy data. If we don't have enough space to
				 * store the whole data, allocate a cluster
				 * or additional mbufs.
				 * XXX: we don't use m_copyback(), since the
				 * function does not use clusters and thus is
				 * inefficient.
				 */</span>
				remain = n-&gt;m_len;
				copied = 0;
				<span class="enscript-keyword">while</span> (1) {
					<span class="enscript-type">int</span> len;
					<span class="enscript-type">struct</span> mbuf *mn;

					<span class="enscript-keyword">if</span> (remain &lt;= (mm-&gt;m_flags &amp; M_PKTHDR ? MHLEN : MLEN))
						len = remain;
					<span class="enscript-keyword">else</span> { <span class="enscript-comment">/* allocate a cluster */</span>
						MCLGET(mm, M_DONTWAIT);
						<span class="enscript-keyword">if</span> (!(mm-&gt;m_flags &amp; M_EXT)) {
							m_free(mm);
							<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
						}
						len = remain &lt; MCLBYTES ?
							remain : MCLBYTES;
					}

					bcopy(n-&gt;m_data + copied, mm-&gt;m_data,
					      len);

					copied += len;
					remain -= len;
					mm-&gt;m_len = len;

					<span class="enscript-keyword">if</span> (remain &lt;= 0) <span class="enscript-comment">/* completed? */</span>
						<span class="enscript-keyword">break</span>;

					<span class="enscript-comment">/* need another mbuf */</span>
					MGETHDR(mn, M_DONTWAIT, MT_HEADER);	<span class="enscript-comment">/* XXXMAC: tags copied next time in loop? */</span>
					<span class="enscript-keyword">if</span> (mn == NULL)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
					mn-&gt;m_pkthdr.rcvif = NULL;
					mm-&gt;m_next = mn;
					mm = mn;
				}

				<span class="enscript-comment">/* adjust chain */</span>
				mm-&gt;m_next = m_free(n);
				n = mm;
				*mpp = mnew;
				mpp = &amp;n-&gt;m_next;

				<span class="enscript-keyword">continue</span>;
			}
		}
		*mpp = n;
		mpp = &amp;n-&gt;m_next;
	}

	<span class="enscript-keyword">return</span>(m);
  <span class="enscript-reference">fail</span>:
	m_freem(m);
	<span class="enscript-keyword">return</span>(NULL);
}

<span class="enscript-comment">/*
 * Tags are allocated as mbufs for now, since our minimum size is MLEN, we
 * should make use of up to that much space.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IPSEC_TAG_HEADER</span> \

<span class="enscript-type">struct</span> ipsec_tag {
	<span class="enscript-type">struct</span> socket			*socket;
	u_int32_t				history_count;
	<span class="enscript-type">struct</span> ipsec_history	history[];
};

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IPSEC_TAG_SIZE</span>		(MLEN - sizeof(struct m_tag))
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">IPSEC_TAG_HDR_SIZE</span>	(offsetof(struct ipsec_tag, history[0]))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IPSEC_HISTORY_MAX</span>	((IPSEC_TAG_SIZE - IPSEC_TAG_HDR_SIZE) / \
							 <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ipsec_history))

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ipsec_tag *
<span class="enscript-function-name">ipsec_addaux</span>(
	<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> m_tag		*tag;
	
	<span class="enscript-comment">/* Check if the tag already exists */</span>
	tag = m_tag_locate(m, KERNEL_MODULE_TAG_ID, KERNEL_TAG_TYPE_IPSEC, NULL);
	
	<span class="enscript-keyword">if</span> (tag == NULL) {
		<span class="enscript-type">struct</span> ipsec_tag	*itag;
		
		<span class="enscript-comment">/* Allocate a tag */</span>
		tag = m_tag_create(KERNEL_MODULE_TAG_ID, KERNEL_TAG_TYPE_IPSEC,
						  IPSEC_TAG_SIZE, M_DONTWAIT, m);
		
		<span class="enscript-keyword">if</span> (tag) {
			itag = (<span class="enscript-type">struct</span> ipsec_tag*)(tag + 1);
			itag-&gt;socket = 0;
			itag-&gt;history_count = 0;
			
			m_tag_prepend(m, tag);
		}
	}
	
	<span class="enscript-keyword">return</span> tag ? (<span class="enscript-type">struct</span> ipsec_tag*)(tag + 1) : NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ipsec_tag *
<span class="enscript-function-name">ipsec_findaux</span>(
	<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> m_tag	*tag;
	
	tag = m_tag_locate(m, KERNEL_MODULE_TAG_ID, KERNEL_TAG_TYPE_IPSEC, NULL);
	
	<span class="enscript-keyword">return</span> tag ? (<span class="enscript-type">struct</span> ipsec_tag*)(tag + 1) : NULL;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipsec_delaux</span>(
	<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> m_tag	*tag;
	
	tag = m_tag_locate(m, KERNEL_MODULE_TAG_ID, KERNEL_TAG_TYPE_IPSEC, NULL);
	
	<span class="enscript-keyword">if</span> (tag) {
		m_tag_delete(m, tag);
	}
}

<span class="enscript-comment">/* if the aux buffer is unnecessary, nuke it. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ipsec_optaux</span>(
	<span class="enscript-type">struct</span> mbuf			*m,
	<span class="enscript-type">struct</span> ipsec_tag	*itag)
{
	<span class="enscript-keyword">if</span> (itag &amp;&amp; itag-&gt;socket == NULL &amp;&amp; itag-&gt;history_count == 0) {
		m_tag_delete(m, ((<span class="enscript-type">struct</span> m_tag*)itag) - 1);
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec_setsocket</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> ipsec_tag	*tag;
	
	<span class="enscript-comment">/* if so == NULL, don't insist on getting the aux mbuf */</span>
	<span class="enscript-keyword">if</span> (so) {
		tag = ipsec_addaux(m);
		<span class="enscript-keyword">if</span> (!tag)
			<span class="enscript-keyword">return</span> ENOBUFS;
	} <span class="enscript-keyword">else</span>
		tag = ipsec_findaux(m);
	<span class="enscript-keyword">if</span> (tag) {
		tag-&gt;socket = so;
		ipsec_optaux(m, tag);
	}
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">struct</span> socket *
<span class="enscript-function-name">ipsec_getsocket</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> ipsec_tag	*itag;
	
	itag = ipsec_findaux(m);
	<span class="enscript-keyword">if</span> (itag)
		<span class="enscript-keyword">return</span> itag-&gt;socket;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec_addhist</span>(
	<span class="enscript-type">struct</span> mbuf *m,
	<span class="enscript-type">int</span> proto,
	u_int32_t spi)
{
	<span class="enscript-type">struct</span> ipsec_tag		*itag;
	<span class="enscript-type">struct</span> ipsec_history	*p;
	itag = ipsec_addaux(m);
	<span class="enscript-keyword">if</span> (!itag)
		<span class="enscript-keyword">return</span> ENOBUFS;
	<span class="enscript-keyword">if</span> (itag-&gt;history_count == IPSEC_HISTORY_MAX)
		<span class="enscript-keyword">return</span> ENOSPC;	<span class="enscript-comment">/* XXX */</span>
	
	p = &amp;itag-&gt;history[itag-&gt;history_count];
	itag-&gt;history_count++;
	
	bzero(p, <span class="enscript-keyword">sizeof</span>(*p));
	p-&gt;ih_proto = proto;
	p-&gt;ih_spi = spi;
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">struct</span> ipsec_history *
<span class="enscript-function-name">ipsec_gethist</span>(
	<span class="enscript-type">struct</span> mbuf *m,
	<span class="enscript-type">int</span> *lenp)
{
	<span class="enscript-type">struct</span> ipsec_tag	*itag;
	
	itag = ipsec_findaux(m);
	<span class="enscript-keyword">if</span> (!itag)
		<span class="enscript-keyword">return</span> NULL;
	<span class="enscript-keyword">if</span> (itag-&gt;history_count == 0)
		<span class="enscript-keyword">return</span> NULL;
	<span class="enscript-keyword">if</span> (lenp)
		*lenp = (<span class="enscript-type">int</span>)(itag-&gt;history_count * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ipsec_history));
	<span class="enscript-keyword">return</span> itag-&gt;history;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ipsec_clearhist</span>(
	<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> ipsec_tag	*itag;
	
	itag = ipsec_findaux(m);
	<span class="enscript-keyword">if</span> (itag) {
		itag-&gt;history_count = 0;
	}
	ipsec_optaux(m, itag);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">ipsec_send_natt_keepalive</span>(
	<span class="enscript-type">struct</span> secasvar *sav)
{
	<span class="enscript-type">struct</span> mbuf	       *m;
	<span class="enscript-type">struct</span> ip          *ip;
	<span class="enscript-type">int</span>                 error;
	<span class="enscript-type">struct</span> ip_out_args  ipoa =
	    { IFSCOPE_NONE, { 0 }, IPOAF_SELECT_SRCIF, 0 };
	<span class="enscript-type">struct</span> route        ro;
	<span class="enscript-type">int</span> keepalive_interval = natt_keepalive_interval;

	lck_mtx_assert(sadb_mutex, LCK_MTX_ASSERT_NOTOWNED);

	<span class="enscript-keyword">if</span> ((esp_udp_encap_port &amp; 0xFFFF) == 0 || sav-&gt;remote_ike_port == 0) <span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-keyword">if</span> (sav-&gt;natt_interval != 0) {
		keepalive_interval = (<span class="enscript-type">int</span>)sav-&gt;natt_interval;
	}
	
	<span class="enscript-comment">// natt timestamp may have changed... reverify
</span>	<span class="enscript-keyword">if</span> ((natt_now - sav-&gt;natt_last_activity) &lt; keepalive_interval) <span class="enscript-keyword">return</span> FALSE;

	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_ESP_KEEPALIVE) <span class="enscript-keyword">return</span> FALSE; <span class="enscript-comment">// don't send these from the kernel
</span>
	m = m_gethdr(M_NOWAIT, MT_DATA);
	<span class="enscript-keyword">if</span> (m == NULL) <span class="enscript-keyword">return</span> FALSE;

	ip = (__typeof__(ip))m_mtod(m);

	<span class="enscript-comment">// this sends one type of NATT keepalives (Type 1, ESP keepalives, aren't sent by kernel)
</span>	<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_ESP_KEEPALIVE) == 0) {
		<span class="enscript-type">struct</span> udphdr      *uh;
		
		<span class="enscript-comment">/*
		 * Type 2: a UDP packet complete with IP header.
		 * We must do this because UDP output requires
		 * an inpcb which we don't have. UDP packet
		 * contains one byte payload. The byte is set
		 * to 0xFF.
		 */</span>
		uh = (__typeof__(uh))(<span class="enscript-type">void</span> *)((<span class="enscript-type">char</span> *)m_mtod(m) + <span class="enscript-keyword">sizeof</span>(*ip));
		m-&gt;m_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udpiphdr) + 1;
		bzero(m_mtod(m), m-&gt;m_len);
		m-&gt;m_pkthdr.len = m-&gt;m_len;

		ip-&gt;ip_len = m-&gt;m_len;
		ip-&gt;ip_ttl = ip_defttl;
		ip-&gt;ip_p = IPPROTO_UDP;
		<span class="enscript-keyword">if</span> (sav-&gt;sah-&gt;dir != IPSEC_DIR_INBOUND) {
			ip-&gt;ip_src = ((<span class="enscript-type">struct</span> sockaddr_in*)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sin_addr;
			ip-&gt;ip_dst = ((<span class="enscript-type">struct</span> sockaddr_in*)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sin_addr;
		} <span class="enscript-keyword">else</span> {
			ip-&gt;ip_src = ((<span class="enscript-type">struct</span> sockaddr_in*)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sin_addr;
			ip-&gt;ip_dst = ((<span class="enscript-type">struct</span> sockaddr_in*)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sin_addr;
		}
		uh-&gt;uh_sport = htons((u_short)esp_udp_encap_port);
		uh-&gt;uh_dport = htons(sav-&gt;remote_ike_port);
		uh-&gt;uh_ulen = htons(1 + <span class="enscript-keyword">sizeof</span>(*uh));
		uh-&gt;uh_sum = 0;
		*(u_int8_t*)((<span class="enscript-type">char</span>*)m_mtod(m) + <span class="enscript-keyword">sizeof</span>(*ip) + <span class="enscript-keyword">sizeof</span>(*uh)) = 0xFF;
	}

	<span class="enscript-comment">// grab sadb_mutex, to get a local copy of sah's route cache
</span>	lck_mtx_lock(sadb_mutex);
	<span class="enscript-keyword">if</span> (ROUTE_UNUSABLE(&amp;sav-&gt;sah-&gt;sa_route) ||
	    rt_key(sav-&gt;sah-&gt;sa_route.ro_rt)-&gt;sa_family != AF_INET)
		ROUTE_RELEASE(&amp;sav-&gt;sah-&gt;sa_route);

	route_copyout(&amp;ro, &amp;sav-&gt;sah-&gt;sa_route, <span class="enscript-keyword">sizeof</span>(ro));
	lck_mtx_unlock(sadb_mutex);
	
	necp_mark_packet_as_keepalive(m, TRUE);

	error = ip_output(m, NULL, &amp;ro, IP_OUTARGS | IP_NOIPSEC, NULL, &amp;ipoa);

	<span class="enscript-comment">// grab sadb_mutex, to synchronize the sah's route cache with the local copy
</span>	lck_mtx_lock(sadb_mutex);
	route_copyin(&amp;ro, &amp;sav-&gt;sah-&gt;sa_route, <span class="enscript-keyword">sizeof</span>(ro));
	lck_mtx_unlock(sadb_mutex);
	<span class="enscript-keyword">if</span> (error == 0) {
		sav-&gt;natt_last_activity = natt_now;
		<span class="enscript-keyword">return</span> TRUE;
	}
	<span class="enscript-keyword">return</span> FALSE;
}

__private_extern__ bool
<span class="enscript-function-name">ipsec_fill_offload_frame</span>(ifnet_t ifp,
						 <span class="enscript-type">struct</span> secasvar *sav,
						 <span class="enscript-type">struct</span> ifnet_keepalive_offload_frame *frame,
						 size_t frame_data_offset)
{
	u_int8_t *data = NULL;
	<span class="enscript-type">struct</span> ip *ip = NULL;
	<span class="enscript-type">struct</span> udphdr *uh = NULL;

	<span class="enscript-keyword">if</span> (sav == NULL || sav-&gt;sah == NULL || frame == NULL ||
		(ifp != NULL &amp;&amp; ifp-&gt;if_index != sav-&gt;sah-&gt;outgoing_if) ||
		sav-&gt;sah-&gt;saidx.dst.ss_family != AF_INET ||
		!(sav-&gt;flags &amp; SADB_X_EXT_NATT) ||
		!(sav-&gt;flags &amp; SADB_X_EXT_NATT_KEEPALIVE) ||
		!(sav-&gt;flags &amp; SADB_X_EXT_NATT_KEEPALIVE_OFFLOAD) ||
		sav-&gt;flags &amp; SADB_X_EXT_ESP_KEEPALIVE ||
		(esp_udp_encap_port &amp; 0xFFFF) == 0 ||
		sav-&gt;remote_ike_port == 0 ||
		(natt_keepalive_interval == 0 &amp;&amp; sav-&gt;natt_interval == 0 &amp;&amp; sav-&gt;natt_offload_interval == 0)) {
		<span class="enscript-comment">/* SA is not eligible for keepalive offload on this interface */</span>
		<span class="enscript-keyword">return</span> (FALSE);
	}

	<span class="enscript-keyword">if</span> (frame_data_offset + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udpiphdr) + 1 &gt;
	    IFNET_KEEPALIVE_OFFLOAD_FRAME_DATA_SIZE) {
		<span class="enscript-comment">/* Not enough room in this data frame */</span>
		<span class="enscript-keyword">return</span> (FALSE);
	}
	
	data = frame-&gt;data;
	ip = (__typeof__(ip))(<span class="enscript-type">void</span> *)(data + frame_data_offset);
	uh = (__typeof__(uh))(<span class="enscript-type">void</span> *)(data + frame_data_offset + <span class="enscript-keyword">sizeof</span>(*ip));

	frame-&gt;length = frame_data_offset + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udpiphdr) + 1;
	frame-&gt;type = IFNET_KEEPALIVE_OFFLOAD_FRAME_IPSEC;
	frame-&gt;ether_type = IFNET_KEEPALIVE_OFFLOAD_FRAME_ETHERTYPE_IPV4;

	bzero(data, IFNET_KEEPALIVE_OFFLOAD_FRAME_DATA_SIZE);

	ip-&gt;ip_v = IPVERSION;
	ip-&gt;ip_hl = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip) &gt;&gt; 2;
	ip-&gt;ip_off &amp;= htons(~IP_OFFMASK);
	ip-&gt;ip_off &amp;= htons(~IP_MF);
	<span class="enscript-keyword">switch</span> (ip4_ipsec_dfbit) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:	<span class="enscript-comment">/* clear DF bit */</span>
			ip-&gt;ip_off &amp;= htons(~IP_DF);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:	<span class="enscript-comment">/* set DF bit */</span>
			ip-&gt;ip_off |= htons(IP_DF);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:	<span class="enscript-comment">/* copy DF bit */</span>
			<span class="enscript-keyword">break</span>;
	}
	ip-&gt;ip_len = htons(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> udpiphdr) + 1);
	ip-&gt;ip_id = ip_randomid();
	ip-&gt;ip_ttl = ip_defttl;
	ip-&gt;ip_p = IPPROTO_UDP;
	ip-&gt;ip_sum = 0;
	<span class="enscript-keyword">if</span> (sav-&gt;sah-&gt;dir != IPSEC_DIR_INBOUND) {
		ip-&gt;ip_src = ((<span class="enscript-type">struct</span> sockaddr_in*)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sin_addr;
		ip-&gt;ip_dst = ((<span class="enscript-type">struct</span> sockaddr_in*)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sin_addr;
	} <span class="enscript-keyword">else</span> {
		ip-&gt;ip_src = ((<span class="enscript-type">struct</span> sockaddr_in*)&amp;sav-&gt;sah-&gt;saidx.dst)-&gt;sin_addr;
		ip-&gt;ip_dst = ((<span class="enscript-type">struct</span> sockaddr_in*)&amp;sav-&gt;sah-&gt;saidx.src)-&gt;sin_addr;
	}
	ip-&gt;ip_sum = in_cksum_hdr_opt(ip);
	uh-&gt;uh_sport = htons((u_short)esp_udp_encap_port);
	uh-&gt;uh_dport = htons(sav-&gt;remote_ike_port);
	uh-&gt;uh_ulen = htons(1 + <span class="enscript-keyword">sizeof</span>(*uh));
	uh-&gt;uh_sum = 0;
	*(u_int8_t*)(data + frame_data_offset + <span class="enscript-keyword">sizeof</span>(*ip) + <span class="enscript-keyword">sizeof</span>(*uh)) = 0xFF;

	<span class="enscript-keyword">if</span> (sav-&gt;natt_offload_interval != 0) {
		frame-&gt;interval = sav-&gt;natt_offload_interval;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sav-&gt;natt_interval != 0) {
		frame-&gt;interval = sav-&gt;natt_interval;
	} <span class="enscript-keyword">else</span> {
		frame-&gt;interval = natt_keepalive_interval;
	}
	<span class="enscript-keyword">return</span> (TRUE);
}
</pre>
<hr />
</body></html>