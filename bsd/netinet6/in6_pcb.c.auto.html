<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>in6_pcb.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">in6_pcb.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */</span>

<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)in_pcb.c	8.2 (Berkeley) 1/4/94
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/priv.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/nd6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/in6_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ah.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ah6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/necp.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

<span class="enscript-comment">/*
 * in6_pcblookup_local_and_cleanup does everything
 * in6_pcblookup_local does but it checks for a socket
 * that's going away. Since we know that the lock is
 * held read+write when this function is called, we
 * can safely dispose of this socket like the slow
 * timer would usually do and return NULL. This is
 * great for bind.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> inpcb *
<span class="enscript-function-name">in6_pcblookup_local_and_cleanup</span>(<span class="enscript-type">struct</span> inpcbinfo *pcbinfo,
    <span class="enscript-type">struct</span> in6_addr *laddr, u_int lport_arg, <span class="enscript-type">int</span> wild_okay)
{
	<span class="enscript-type">struct</span> inpcb *inp;

	<span class="enscript-comment">/* Perform normal lookup */</span>
	inp = in6_pcblookup_local(pcbinfo, laddr, lport_arg, wild_okay);

	<span class="enscript-comment">/* Check if we found a match but it's waiting to be disposed */</span>
	<span class="enscript-keyword">if</span> (inp != NULL &amp;&amp; inp-&gt;inp_wantcnt == WNT_STOPUSING) {
		<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;

		lck_mtx_lock(&amp;inp-&gt;inpcb_mtx);

		<span class="enscript-keyword">if</span> (so-&gt;so_usecount == 0) {
			<span class="enscript-keyword">if</span> (inp-&gt;inp_state != INPCB_STATE_DEAD)
				in6_pcbdetach(inp);
			in_pcbdispose(inp);	<span class="enscript-comment">/* will unlock &amp; destroy */</span>
			inp = NULL;
		} <span class="enscript-keyword">else</span> {
			lck_mtx_unlock(&amp;inp-&gt;inpcb_mtx);
		}
	}

	<span class="enscript-keyword">return</span> (inp);
}

<span class="enscript-comment">/*
 * Bind an INPCB to an address and/or port.  This routine should not alter
 * the caller-supplied local address &quot;nam&quot;.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_pcbbind</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;
	<span class="enscript-type">struct</span> inpcbinfo *pcbinfo = inp-&gt;inp_pcbinfo;
	u_short	lport = 0;
	<span class="enscript-type">int</span> wild = 0, reuseport = (so-&gt;so_options &amp; SO_REUSEPORT);
	<span class="enscript-type">struct</span> ifnet *outif = NULL;
	<span class="enscript-type">struct</span> sockaddr_in6 sin6;
	<span class="enscript-type">int</span> error;
	kauth_cred_t cred;

	<span class="enscript-keyword">if</span> (!in6_ifaddrs) <span class="enscript-comment">/* XXX broken! */</span>
		<span class="enscript-keyword">return</span> (EADDRNOTAVAIL);
	<span class="enscript-keyword">if</span> (inp-&gt;inp_lport || !IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_laddr))
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (!(so-&gt;so_options &amp; (SO_REUSEADDR|SO_REUSEPORT)))
		wild = 1;
	socket_unlock(so, 0); <span class="enscript-comment">/* keep reference */</span>
	lck_rw_lock_exclusive(pcbinfo-&gt;ipi_lock);

	bzero(&amp;sin6, <span class="enscript-keyword">sizeof</span> (sin6));
	<span class="enscript-keyword">if</span> (nam != NULL) {
		<span class="enscript-keyword">if</span> (nam-&gt;sa_len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6)) {
			lck_rw_done(pcbinfo-&gt;ipi_lock);
			socket_lock(so, 0);
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		<span class="enscript-comment">/*
		 * family check.
		 */</span>
		<span class="enscript-keyword">if</span> (nam-&gt;sa_family != AF_INET6) {
			lck_rw_done(pcbinfo-&gt;ipi_lock);
			socket_lock(so, 0);
			<span class="enscript-keyword">return</span> (EAFNOSUPPORT);
		}
		lport = SIN6(nam)-&gt;sin6_port;

		*(&amp;sin6) = *SIN6(nam);

		<span class="enscript-comment">/* KAME hack: embed scopeid */</span>
		<span class="enscript-keyword">if</span> (in6_embedscope(&amp;sin6.sin6_addr, &amp;sin6, inp, NULL,
		    NULL) != 0) {
			lck_rw_done(pcbinfo-&gt;ipi_lock);
			socket_lock(so, 0);
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		<span class="enscript-comment">/* Sanitize local copy for address searches */</span>
                sin6.sin6_flowinfo = 0;
                sin6.sin6_scope_id = 0;
		sin6.sin6_port = 0;

		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_MULTICAST(&amp;sin6.sin6_addr)) {
			<span class="enscript-comment">/*
			 * Treat SO_REUSEADDR as SO_REUSEPORT for multicast;
			 * allow compepte duplication of binding if
			 * SO_REUSEPORT is set, or if SO_REUSEADDR is set
			 * and a multicast address is bound on both
			 * new and duplicated sockets.
			 */</span>
			<span class="enscript-keyword">if</span> (so-&gt;so_options &amp; SO_REUSEADDR)
				reuseport = SO_REUSEADDR|SO_REUSEPORT;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!IN6_IS_ADDR_UNSPECIFIED(&amp;sin6.sin6_addr)) {
			<span class="enscript-type">struct</span> ifaddr *ifa;

			ifa = ifa_ifwithaddr(SA(&amp;sin6));
			<span class="enscript-keyword">if</span> (ifa == NULL) {
				lck_rw_done(pcbinfo-&gt;ipi_lock);
				socket_lock(so, 0);
				<span class="enscript-keyword">return</span> (EADDRNOTAVAIL);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * XXX: bind to an anycast address might
				 * accidentally cause sending a packet with
				 * anycast source address.  We should allow
				 * to bind to a deprecated address, since
				 * the application dare to use it.
				 */</span>
				IFA_LOCK_SPIN(ifa);
				<span class="enscript-keyword">if</span> (((<span class="enscript-type">struct</span> in6_ifaddr *)ifa)-&gt;ia6_flags &amp;
				    (IN6_IFF_ANYCAST|IN6_IFF_NOTREADY|
				    IN6_IFF_DETACHED)) {
					IFA_UNLOCK(ifa);
					IFA_REMREF(ifa);
					lck_rw_done(pcbinfo-&gt;ipi_lock);
					socket_lock(so, 0);
					<span class="enscript-keyword">return</span> (EADDRNOTAVAIL);
				}
				<span class="enscript-comment">/*
				 * Opportunistically determine the outbound
				 * interface that may be used; this may not
				 * hold true if we end up using a route
				 * going over a different interface, e.g.
				 * when sending to a local address.  This
				 * will get updated again after sending.
				 */</span>
				outif = ifa-&gt;ifa_ifp;
				IFA_UNLOCK(ifa);
				IFA_REMREF(ifa);
			}
		}
		<span class="enscript-keyword">if</span> (lport != 0) {
			<span class="enscript-type">struct</span> inpcb *t;
			uid_t u;

			<span class="enscript-comment">/* GROSS */</span>
			<span class="enscript-keyword">if</span> (ntohs(lport) &lt; IPV6PORT_RESERVED) {
				cred = kauth_cred_proc_ref(p);
				error = priv_check_cred(cred,
				    PRIV_NETINET_RESERVEDPORT, 0);
				kauth_cred_unref(&amp;cred);
				<span class="enscript-keyword">if</span> (error != 0) {
					lck_rw_done(pcbinfo-&gt;ipi_lock);
					socket_lock(so, 0);
					<span class="enscript-keyword">return</span> (EACCES);
				}
			}
			<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_MULTICAST(&amp;sin6.sin6_addr) &amp;&amp;
			    (u = kauth_cred_getuid(so-&gt;so_cred)) != 0) {
				t = in6_pcblookup_local_and_cleanup(pcbinfo,
				    &amp;sin6.sin6_addr, lport,
				    INPLOOKUP_WILDCARD);
				<span class="enscript-keyword">if</span> (t != NULL &amp;&amp; (!IN6_IS_ADDR_UNSPECIFIED(
				    &amp;sin6.sin6_addr) ||
				    !IN6_IS_ADDR_UNSPECIFIED(&amp;t-&gt;in6p_laddr) ||
				    !(t-&gt;inp_socket-&gt;so_options &amp;
				    SO_REUSEPORT)) &amp;&amp; (u != kauth_cred_getuid(
				    t-&gt;inp_socket-&gt;so_cred)) &amp;&amp;
				    !(t-&gt;inp_socket-&gt;so_flags &amp;
				    SOF_REUSESHAREUID)) {
					lck_rw_done(pcbinfo-&gt;ipi_lock);
					socket_lock(so, 0);
					<span class="enscript-keyword">return</span> (EADDRINUSE);
				}
				<span class="enscript-keyword">if</span> (!(inp-&gt;inp_flags &amp; IN6P_IPV6_V6ONLY) &amp;&amp;
				    IN6_IS_ADDR_UNSPECIFIED(&amp;sin6.sin6_addr)) {
					<span class="enscript-type">struct</span> sockaddr_in sin;

					in6_sin6_2_sin(&amp;sin, &amp;sin6);
					t = in_pcblookup_local_and_cleanup(
					    pcbinfo, sin.sin_addr, lport,
					    INPLOOKUP_WILDCARD);
					<span class="enscript-keyword">if</span> (t != NULL &amp;&amp;
					    !(t-&gt;inp_socket-&gt;so_options &amp;
					    SO_REUSEPORT) &amp;&amp;
					    (kauth_cred_getuid(so-&gt;so_cred) !=
					    kauth_cred_getuid(t-&gt;inp_socket-&gt;
					    so_cred)) &amp;&amp; (t-&gt;inp_laddr.s_addr !=
					    INADDR_ANY || SOCK_DOM(so) ==
					    SOCK_DOM(t-&gt;inp_socket))) {
						lck_rw_done(pcbinfo-&gt;ipi_lock);
						socket_lock(so, 0);
						<span class="enscript-keyword">return</span> (EADDRINUSE);
					}
				}
			}
			t = in6_pcblookup_local_and_cleanup(pcbinfo,
			    &amp;sin6.sin6_addr, lport, wild);
			<span class="enscript-keyword">if</span> (t != NULL &amp;&amp;
			    (reuseport &amp; t-&gt;inp_socket-&gt;so_options) == 0) {
				lck_rw_done(pcbinfo-&gt;ipi_lock);
				socket_lock(so, 0);
				<span class="enscript-keyword">return</span> (EADDRINUSE);
			}
			<span class="enscript-keyword">if</span> (!(inp-&gt;inp_flags &amp; IN6P_IPV6_V6ONLY) &amp;&amp;
			    IN6_IS_ADDR_UNSPECIFIED(&amp;sin6.sin6_addr)) {
				<span class="enscript-type">struct</span> sockaddr_in sin;

				in6_sin6_2_sin(&amp;sin, &amp;sin6);
				t = in_pcblookup_local_and_cleanup(pcbinfo,
				    sin.sin_addr, lport, wild);
				<span class="enscript-keyword">if</span> (t != NULL &amp;&amp; (reuseport &amp;
				    t-&gt;inp_socket-&gt;so_options) == 0 &amp;&amp;
				    (t-&gt;inp_laddr.s_addr != INADDR_ANY ||
				    SOCK_DOM(so) == SOCK_DOM(t-&gt;inp_socket))) {
					lck_rw_done(pcbinfo-&gt;ipi_lock);
					socket_lock(so, 0);
					<span class="enscript-keyword">return</span> (EADDRINUSE);
				}
			}
		}
	}

	socket_lock(so, 0);
	<span class="enscript-comment">/* check if the socket got bound when the lock was released */</span>
	<span class="enscript-keyword">if</span> (inp-&gt;inp_lport || !IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_laddr)) {
		lck_rw_done(pcbinfo-&gt;ipi_lock);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_UNSPECIFIED(&amp;sin6.sin6_addr)) {
		inp-&gt;in6p_laddr = sin6.sin6_addr;
		inp-&gt;in6p_last_outifp = outif;
	}

	<span class="enscript-keyword">if</span> (lport == 0) {
		<span class="enscript-type">int</span> e;
		<span class="enscript-keyword">if</span> ((e = in6_pcbsetport(&amp;inp-&gt;in6p_laddr, inp, p, 1)) != 0) {
			<span class="enscript-comment">/* Undo any address bind from above. */</span>
			inp-&gt;in6p_laddr = in6addr_any;
			inp-&gt;in6p_last_outifp = NULL;	
			lck_rw_done(pcbinfo-&gt;ipi_lock);
			<span class="enscript-keyword">return</span> (e);
		}
	} <span class="enscript-keyword">else</span> {
		inp-&gt;inp_lport = lport;
		<span class="enscript-keyword">if</span> (in_pcbinshash(inp, 1) != 0) {
			inp-&gt;in6p_laddr = in6addr_any;
			inp-&gt;inp_lport = 0;
			inp-&gt;in6p_last_outifp = NULL;
			lck_rw_done(pcbinfo-&gt;ipi_lock);
			<span class="enscript-keyword">return</span> (EAGAIN);
		}
	}
	lck_rw_done(pcbinfo-&gt;ipi_lock);
	sflt_notify(so, sock_evt_bound, NULL);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Transform old in6_pcbconnect() into an inner subroutine for new
 * in6_pcbconnect(); do some validity-checking on the remote address
 * (in &quot;nam&quot;) and then determine local host address (i.e., which
 * interface) to use to access that remote host.
 *
 * This routine may alter the caller-supplied remote address &quot;nam&quot;.
 *
 * This routine might return an ifp with a reference held if the caller
 * provides a non-NULL outif, even in the error case.  The caller is
 * responsible for releasing its reference.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_pcbladdr</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> sockaddr *nam,
    <span class="enscript-type">struct</span> in6_addr *plocal_addr6, <span class="enscript-type">struct</span> ifnet **outif)
{
	<span class="enscript-type">struct</span> in6_addr *addr6 = NULL;
	<span class="enscript-type">struct</span> in6_addr src_storage;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope;

	<span class="enscript-keyword">if</span> (outif != NULL)
		*outif = NULL;
	<span class="enscript-keyword">if</span> (nam-&gt;sa_len != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_in6))
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (SIN6(nam)-&gt;sin6_family != AF_INET6)
		<span class="enscript-keyword">return</span> (EAFNOSUPPORT);
	<span class="enscript-keyword">if</span> (SIN6(nam)-&gt;sin6_port == 0)
		<span class="enscript-keyword">return</span> (EADDRNOTAVAIL);

	<span class="enscript-comment">/* KAME hack: embed scopeid */</span>
	<span class="enscript-keyword">if</span> (in6_embedscope(&amp;SIN6(nam)-&gt;sin6_addr, SIN6(nam), inp, NULL, NULL) != 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (in6_ifaddrs) {
		<span class="enscript-comment">/*
		 * If the destination address is UNSPECIFIED addr,
		 * use the loopback addr, e.g ::1.
		 */</span>
		<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;SIN6(nam)-&gt;sin6_addr))
			SIN6(nam)-&gt;sin6_addr = in6addr_loopback;
	}

	ifscope = (inp-&gt;inp_flags &amp; INP_BOUND_IF) ?
	    inp-&gt;inp_boundifp-&gt;if_index : IFSCOPE_NONE;

	<span class="enscript-comment">/*
	 * XXX: in6_selectsrc might replace the bound local address
	 * with the address specified by setsockopt(IPV6_PKTINFO).
	 * Is it the intended behavior?
	 *
	 * in6_selectsrc() might return outif with its reference held
	 * even in the error case; caller always needs to release it
	 * if non-NULL.
	 */</span>
	addr6 = in6_selectsrc(SIN6(nam), inp-&gt;in6p_outputopts, inp,
	    &amp;inp-&gt;in6p_route, outif, &amp;src_storage, ifscope, &amp;error);

	<span class="enscript-keyword">if</span> (outif != NULL) {
		<span class="enscript-type">struct</span> rtentry *rt = inp-&gt;in6p_route.ro_rt;
		<span class="enscript-comment">/*
		 * If in6_selectsrc() returns a route, it should be one
		 * which points to the same ifp as outif.  Just in case
		 * it isn't, use the one from the route for consistency.
		 * Otherwise if there is no route, leave outif alone as
		 * it could still be useful to the caller.
		 */</span>
		<span class="enscript-keyword">if</span> (rt != NULL &amp;&amp; rt-&gt;rt_ifp != *outif) {
			ifnet_reference(rt-&gt;rt_ifp);	<span class="enscript-comment">/* for caller */</span>
			<span class="enscript-keyword">if</span> (*outif != NULL)
				ifnet_release(*outif);
			*outif = rt-&gt;rt_ifp;
		}
	}

	<span class="enscript-keyword">if</span> (addr6 == NULL) {
		<span class="enscript-keyword">if</span> (outif != NULL &amp;&amp; (*outif) != NULL &amp;&amp;
		    inp_restricted_send(inp, *outif)) {
			soevent(inp-&gt;inp_socket,
			    (SO_FILT_HINT_LOCKED | SO_FILT_HINT_IFDENIED));
			error = EHOSTUNREACH;
		}
		<span class="enscript-keyword">if</span> (error == 0)
			error = EADDRNOTAVAIL;
		<span class="enscript-keyword">return</span> (error);
	}

	*plocal_addr6 = *addr6;
	<span class="enscript-comment">/*
	 * Don't do pcblookup call here; return interface in
	 * plocal_addr6 and exit to caller, that will do the lookup.
	 */</span>
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Outer subroutine:
 * Connect from a socket to a specified address.
 * Both address and port must be specified in argument sin.
 * If don't have a local address for this socket yet,
 * then pick one.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_pcbconnect</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> in6_addr addr6;
	<span class="enscript-type">struct</span> sockaddr_in6 *sin6 = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)nam;
	<span class="enscript-type">struct</span> inpcb *pcb;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> ifnet *outif = NULL;
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;

	<span class="enscript-comment">/*
	 * Call inner routine, to assign local interface address.
	 * in6_pcbladdr() may automatically fill in sin6_scope_id.
	 *
	 * in6_pcbladdr() might return an ifp with its reference held
	 * even in the error case, so make sure that it's released
	 * whenever it's non-NULL.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = in6_pcbladdr(inp, nam, &amp;addr6, &amp;outif)) != 0) {
		<span class="enscript-keyword">if</span> (outif != NULL &amp;&amp; inp_restricted_send(inp, outif)) 
			soevent(so,
			    (SO_FILT_HINT_LOCKED | SO_FILT_HINT_IFDENIED));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	socket_unlock(so, 0);
	pcb = in6_pcblookup_hash(inp-&gt;inp_pcbinfo, &amp;sin6-&gt;sin6_addr,
	    sin6-&gt;sin6_port, IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_laddr) ?
	    &amp;addr6 : &amp;inp-&gt;in6p_laddr, inp-&gt;inp_lport, 0, NULL);
	socket_lock(so, 0);
	<span class="enscript-keyword">if</span> (pcb != NULL) {
		in_pcb_checkstate(pcb, WNT_RELEASE, pcb == inp ? 1 : 0);
		error = EADDRINUSE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_laddr)) {
		<span class="enscript-keyword">if</span> (inp-&gt;inp_lport == 0) {
			error = in6_pcbbind(inp, NULL, p);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		inp-&gt;in6p_laddr = addr6;
		inp-&gt;in6p_last_outifp = outif;	<span class="enscript-comment">/* no reference needed */</span>
		inp-&gt;in6p_flags |= INP_IN6ADDR_ANY;
	}
	<span class="enscript-keyword">if</span> (!lck_rw_try_lock_exclusive(inp-&gt;inp_pcbinfo-&gt;ipi_lock)) {
		<span class="enscript-comment">/* lock inversion issue, mostly with udp multicast packets */</span>
		socket_unlock(so, 0);
		lck_rw_lock_exclusive(inp-&gt;inp_pcbinfo-&gt;ipi_lock);
		socket_lock(so, 0);
	}
	inp-&gt;in6p_faddr = sin6-&gt;sin6_addr;
	inp-&gt;inp_fport = sin6-&gt;sin6_port;
	<span class="enscript-keyword">if</span> (nstat_collect &amp;&amp; SOCK_PROTO(so) == IPPROTO_UDP)
		nstat_pcb_invalidate_cache(inp);
	in_pcbrehash(inp);
	lck_rw_done(inp-&gt;inp_pcbinfo-&gt;ipi_lock);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (outif != NULL)
		ifnet_release(outif);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_pcbdisconnect</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;

	<span class="enscript-keyword">if</span> (!lck_rw_try_lock_exclusive(inp-&gt;inp_pcbinfo-&gt;ipi_lock)) {
		<span class="enscript-comment">/* lock inversion issue, mostly with udp multicast packets */</span>
		socket_unlock(so, 0);
		lck_rw_lock_exclusive(inp-&gt;inp_pcbinfo-&gt;ipi_lock);
		socket_lock(so, 0);
	}
	<span class="enscript-keyword">if</span> (nstat_collect &amp;&amp; SOCK_PROTO(so) == IPPROTO_UDP)
		nstat_pcb_cache(inp);
	bzero((caddr_t)&amp;inp-&gt;in6p_faddr, <span class="enscript-keyword">sizeof</span> (inp-&gt;in6p_faddr));
	inp-&gt;inp_fport = 0;
	<span class="enscript-comment">/* clear flowinfo - RFC 6437 */</span>
	inp-&gt;inp_flow &amp;= ~IPV6_FLOWLABEL_MASK;
	in_pcbrehash(inp);
	lck_rw_done(inp-&gt;inp_pcbinfo-&gt;ipi_lock);
	<span class="enscript-comment">/*
	 * A multipath subflow socket would have its SS_NOFDREF set by default,
	 * so check for SOF_MP_SUBFLOW socket flag before detaching the PCB;
	 * when the socket is closed for real, SOF_MP_SUBFLOW would be cleared.
	 */</span>
	<span class="enscript-keyword">if</span> (!(so-&gt;so_flags &amp; SOF_MP_SUBFLOW) &amp;&amp; (so-&gt;so_state &amp; SS_NOFDREF))
		in6_pcbdetach(inp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_pcbdetach</span>(<span class="enscript-type">struct</span> inpcb *inp)
{
	<span class="enscript-type">struct</span> socket *so = inp-&gt;inp_socket;

	<span class="enscript-keyword">if</span> (so-&gt;so_pcb == NULL) {
		<span class="enscript-comment">/* PCB has been disposed */</span>
		panic(<span class="enscript-string">&quot;%s: inp=%p so=%p proto=%d so_pcb is null!\n&quot;</span>, __func__,
		    inp, so, SOCK_PROTO(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	<span class="enscript-keyword">if</span> (inp-&gt;in6p_sp != NULL) {
		(<span class="enscript-type">void</span>) ipsec6_delete_pcbpolicy(inp);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>

	<span class="enscript-comment">/*
	 * Let NetworkStatistics know this PCB is going away
	 * before we detach it.
	 */</span>
	<span class="enscript-keyword">if</span> (nstat_collect &amp;&amp;
	    (SOCK_PROTO(so) == IPPROTO_TCP || SOCK_PROTO(so) == IPPROTO_UDP))
		nstat_pcb_detach(inp);
	<span class="enscript-comment">/* mark socket state as dead */</span>
	<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_STOPUSING, 1) != WNT_STOPUSING) {
		panic(<span class="enscript-string">&quot;%s: so=%p proto=%d couldn't set to STOPUSING\n&quot;</span>,
		    __func__, so, SOCK_PROTO(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (!(so-&gt;so_flags &amp; SOF_PCBCLEARING)) {
		<span class="enscript-type">struct</span> ip_moptions *imo;
		<span class="enscript-type">struct</span> ip6_moptions *im6o;

		inp-&gt;inp_vflag = 0;
		<span class="enscript-keyword">if</span> (inp-&gt;in6p_options != NULL) {
			m_freem(inp-&gt;in6p_options);
			inp-&gt;in6p_options = NULL;
		}
		ip6_freepcbopts(inp-&gt;in6p_outputopts);
		ROUTE_RELEASE(&amp;inp-&gt;in6p_route);
		<span class="enscript-comment">/* free IPv4 related resources in case of mapped addr */</span>
		<span class="enscript-keyword">if</span> (inp-&gt;inp_options != NULL) {
			(<span class="enscript-type">void</span>) m_free(inp-&gt;inp_options);
			inp-&gt;inp_options = NULL;
		}
		im6o = inp-&gt;in6p_moptions;
		inp-&gt;in6p_moptions = NULL;
		<span class="enscript-keyword">if</span> (im6o != NULL)
			IM6O_REMREF(im6o);

		imo = inp-&gt;inp_moptions;
		inp-&gt;inp_moptions = NULL;
		<span class="enscript-keyword">if</span> (imo != NULL)
			IMO_REMREF(imo);
		sofreelastref(so, 0);
		inp-&gt;inp_state = INPCB_STATE_DEAD;
		<span class="enscript-comment">/* makes sure we're not called twice from so_close */</span>
		so-&gt;so_flags |= SOF_PCBCLEARING;
 
		inpcb_gc_sched(inp-&gt;inp_pcbinfo, INPCB_TIMER_FAST);
	}
}

<span class="enscript-type">struct</span> sockaddr *
<span class="enscript-function-name">in6_sockaddr</span>(in_port_t port, <span class="enscript-type">struct</span> in6_addr *addr_p)
{
	<span class="enscript-type">struct</span> sockaddr_in6 *sin6;

	MALLOC(sin6, <span class="enscript-type">struct</span> sockaddr_in6 *, <span class="enscript-keyword">sizeof</span> (*sin6), M_SONAME, M_WAITOK);
	<span class="enscript-keyword">if</span> (sin6 == NULL)
		<span class="enscript-keyword">return</span> (NULL);
	bzero(sin6, <span class="enscript-keyword">sizeof</span> (*sin6));
	sin6-&gt;sin6_family = AF_INET6;
	sin6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span> (*sin6);
	sin6-&gt;sin6_port = port;
	sin6-&gt;sin6_addr = *addr_p;

	<span class="enscript-comment">/* would be good to use sa6_recoverscope(), except for locking  */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;sin6-&gt;sin6_addr))
		sin6-&gt;sin6_scope_id = ntohs(sin6-&gt;sin6_addr.s6_addr16[1]);
	<span class="enscript-keyword">else</span>
		sin6-&gt;sin6_scope_id = 0;	<span class="enscript-comment">/* XXX */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;sin6-&gt;sin6_addr))
		sin6-&gt;sin6_addr.s6_addr16[1] = 0;

	<span class="enscript-keyword">return</span> ((<span class="enscript-type">struct</span> sockaddr *)sin6);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_sockaddr_s</span>(in_port_t port, <span class="enscript-type">struct</span> in6_addr *addr_p,
    <span class="enscript-type">struct</span> sockaddr_in6 *sin6)
{
	bzero(sin6, <span class="enscript-keyword">sizeof</span> (*sin6));
	sin6-&gt;sin6_family = AF_INET6;
	sin6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span> (*sin6);
	sin6-&gt;sin6_port = port;
	sin6-&gt;sin6_addr = *addr_p;

	<span class="enscript-comment">/* would be good to use sa6_recoverscope(), except for locking  */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;sin6-&gt;sin6_addr))
		sin6-&gt;sin6_scope_id = ntohs(sin6-&gt;sin6_addr.s6_addr16[1]);
	<span class="enscript-keyword">else</span>
		sin6-&gt;sin6_scope_id = 0;	<span class="enscript-comment">/* XXX */</span>
	<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;sin6-&gt;sin6_addr))
		sin6-&gt;sin6_addr.s6_addr16[1] = 0;
}

<span class="enscript-comment">/*
 * The calling convention of in6_getsockaddr() and in6_getpeeraddr() was
 * modified to match the pru_sockaddr() and pru_peeraddr() entry points
 * in struct pr_usrreqs, so that protocols can just reference then directly
 * without the need for a wrapper function.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_getsockaddr</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **nam)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">struct</span> in6_addr addr;
	in_port_t port;

	<span class="enscript-keyword">if</span> ((inp = sotoinpcb(so)) == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	port = inp-&gt;inp_lport;
	addr = inp-&gt;in6p_laddr;

	*nam = in6_sockaddr(port, &amp;addr);
	<span class="enscript-keyword">if</span> (*nam == NULL)
		<span class="enscript-keyword">return</span> (ENOBUFS);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_getsockaddr_s</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr_storage *ss)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">struct</span> in6_addr addr;
	in_port_t port;

	VERIFY(ss != NULL);
	bzero(ss, <span class="enscript-keyword">sizeof</span> (*ss));

	<span class="enscript-keyword">if</span> ((inp = sotoinpcb(so)) == NULL
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		|| (necp_socket_should_use_flow_divert(inp))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
		)
		<span class="enscript-keyword">return</span> (inp == NULL ? EINVAL : EPROTOTYPE);

	port = inp-&gt;inp_lport;
	addr = inp-&gt;in6p_laddr;

	in6_sockaddr_s(port, &amp;addr, SIN6(ss));
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_getpeeraddr</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **nam)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">struct</span> in6_addr addr;
	in_port_t port;

	<span class="enscript-keyword">if</span> ((inp = sotoinpcb(so)) == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	port = inp-&gt;inp_fport;
	addr = inp-&gt;in6p_faddr;

	*nam = in6_sockaddr(port, &amp;addr);
	<span class="enscript-keyword">if</span> (*nam == NULL)
		<span class="enscript-keyword">return</span> (ENOBUFS);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_getpeeraddr_s</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr_storage *ss)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">struct</span> in6_addr addr;
	in_port_t port;

	VERIFY(ss != NULL);
	bzero(ss, <span class="enscript-keyword">sizeof</span> (*ss));

	<span class="enscript-keyword">if</span> ((inp = sotoinpcb(so)) == NULL
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		|| (necp_socket_should_use_flow_divert(inp))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
		)
		<span class="enscript-keyword">return</span> (inp == NULL ? EINVAL : EPROTOTYPE);

	port = inp-&gt;inp_fport;
	addr = inp-&gt;in6p_faddr;

	in6_sockaddr_s(port, &amp;addr, SIN6(ss));
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_mapped_sockaddr</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **nam)
{
	<span class="enscript-type">struct</span>	inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">int</span>	error;

	<span class="enscript-keyword">if</span> (inp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV4) {
		error = in_getsockaddr(so, nam);
		<span class="enscript-keyword">if</span> (error == 0)
			error = in6_sin_2_v4mapsin6_in_sock(nam);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* scope issues will be handled in in6_getsockaddr(). */</span>
		error = in6_getsockaddr(so, nam);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_mapped_peeraddr</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **nam)
{
	<span class="enscript-type">struct</span>	inpcb *inp = sotoinpcb(so);
	<span class="enscript-type">int</span>	error;

	<span class="enscript-keyword">if</span> (inp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (inp-&gt;inp_vflag &amp; INP_IPV4) {
		error = in_getpeeraddr(so, nam);
		<span class="enscript-keyword">if</span> (error == 0)
			error = in6_sin_2_v4mapsin6_in_sock(nam);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* scope issues will be handled in in6_getpeeraddr(). */</span>
		error = in6_getpeeraddr(so, nam);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Pass some notification to all connections of a protocol
 * associated with address dst.  The local address and/or port numbers
 * may be specified to limit the search.  The &quot;usual action&quot; will be
 * taken, depending on the ctlinput cmd.  The caller must filter any
 * cmds that are uninteresting (e.g., no error in the map).
 * Call the protocol specific routine (if any) to report
 * any errors for each matching socket.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_pcbnotify</span>(<span class="enscript-type">struct</span> inpcbinfo *pcbinfo, <span class="enscript-type">struct</span> sockaddr *dst, u_int fport_arg,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *src, u_int lport_arg, <span class="enscript-type">int</span> cmd, <span class="enscript-type">void</span> *cmdarg,
    <span class="enscript-type">void</span> (*notify)(<span class="enscript-type">struct</span> inpcb *, <span class="enscript-type">int</span>))
{
	<span class="enscript-type">struct</span> inpcbhead *head = pcbinfo-&gt;ipi_listhead;
	<span class="enscript-type">struct</span> inpcb *inp, *ninp;
	<span class="enscript-type">struct</span> sockaddr_in6 sa6_src, *sa6_dst;
	u_short	fport = fport_arg, lport = lport_arg;
	u_int32_t flowinfo;
	<span class="enscript-type">int</span> errno;

	<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span>)cmd &gt;= PRC_NCMDS || dst-&gt;sa_family != AF_INET6)
		<span class="enscript-keyword">return</span>;

	sa6_dst = (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)dst;
	<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;sa6_dst-&gt;sin6_addr))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/*
	 * note that src can be NULL when we get notify by local fragmentation.
	 */</span>
	sa6_src = (src == NULL) ?
	    sa6_any : *(<span class="enscript-type">struct</span> sockaddr_in6 *)(uintptr_t)(size_t)src;
	flowinfo = sa6_src.sin6_flowinfo;

	<span class="enscript-comment">/*
	 * Redirects go to all references to the destination,
	 * and use in6_rtchange to invalidate the route cache.
	 * Dead host indications: also use in6_rtchange to invalidate
	 * the cache, and deliver the error to all the sockets.
	 * Otherwise, if we have knowledge of the local port and address,
	 * deliver only to that socket.
	 */</span>
	<span class="enscript-keyword">if</span> (PRC_IS_REDIRECT(cmd) || cmd == PRC_HOSTDEAD) {
		fport = 0;
		lport = 0;
		bzero((caddr_t)&amp;sa6_src.sin6_addr, <span class="enscript-keyword">sizeof</span> (sa6_src.sin6_addr));

		<span class="enscript-keyword">if</span> (cmd != PRC_HOSTDEAD)
			notify = in6_rtchange;
	}
	errno = inet6ctlerrmap[cmd];
	lck_rw_lock_shared(pcbinfo-&gt;ipi_lock);
	<span class="enscript-keyword">for</span> (inp = LIST_FIRST(head); inp != NULL; inp = ninp) {
		ninp = LIST_NEXT(inp, inp_list);

		<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV6))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * If the error designates a new path MTU for a destination
		 * and the application (associated with this socket) wanted to
		 * know the value, notify. Note that we notify for all
		 * disconnected sockets if the corresponding application
		 * wanted. This is because some UDP applications keep sending
		 * sockets disconnected.
		 * XXX: should we avoid to notify the value to TCP sockets?
		 */</span>
		<span class="enscript-keyword">if</span> (cmd == PRC_MSGSIZE &amp;&amp; (inp-&gt;inp_flags &amp; IN6P_MTU) != 0 &amp;&amp;
		    (IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_faddr) ||
		    IN6_ARE_ADDR_EQUAL(&amp;inp-&gt;in6p_faddr,
		    &amp;sa6_dst-&gt;sin6_addr))) {
			ip6_notify_pmtu(inp, (<span class="enscript-type">struct</span> sockaddr_in6 *)(<span class="enscript-type">void</span> *)dst,
			    (u_int32_t *)cmdarg);
		}

		<span class="enscript-comment">/*
		 * Detect if we should notify the error. If no source and
		 * destination ports are specifed, but non-zero flowinfo and
		 * local address match, notify the error. This is the case
		 * when the error is delivered with an encrypted buffer
		 * by ESP. Otherwise, just compare addresses and ports
		 * as usual.
		 */</span>
		<span class="enscript-keyword">if</span> (lport == 0 &amp;&amp; fport == 0 &amp;&amp; flowinfo &amp;&amp;
		    inp-&gt;inp_socket != NULL &amp;&amp;
		    flowinfo == (inp-&gt;inp_flow &amp; IPV6_FLOWLABEL_MASK) &amp;&amp;
		    IN6_ARE_ADDR_EQUAL(&amp;inp-&gt;in6p_laddr, &amp;sa6_src.sin6_addr))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">do_notify</span>;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!IN6_ARE_ADDR_EQUAL(&amp;inp-&gt;in6p_faddr,
		    &amp;sa6_dst-&gt;sin6_addr) || inp-&gt;inp_socket == NULL ||
		    (lport &amp;&amp; inp-&gt;inp_lport != lport) ||
		    (!IN6_IS_ADDR_UNSPECIFIED(&amp;sa6_src.sin6_addr) &amp;&amp;
		    !IN6_ARE_ADDR_EQUAL(&amp;inp-&gt;in6p_laddr,
		    &amp;sa6_src.sin6_addr)) || (fport &amp;&amp; inp-&gt;inp_fport != fport))
			<span class="enscript-keyword">continue</span>;

<span class="enscript-reference">do_notify</span>:
		<span class="enscript-keyword">if</span> (notify) {
			<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_ACQUIRE, 0) ==
			    WNT_STOPUSING)
				<span class="enscript-keyword">continue</span>;
			socket_lock(inp-&gt;inp_socket, 1);
			(*notify)(inp, errno);
			(<span class="enscript-type">void</span>) in_pcb_checkstate(inp, WNT_RELEASE, 1);
			socket_unlock(inp-&gt;inp_socket, 1);
		}
	}
	lck_rw_done(pcbinfo-&gt;ipi_lock);
}

<span class="enscript-comment">/*
 * Lookup a PCB based on the local address and port.
 */</span>
<span class="enscript-type">struct</span> inpcb *
<span class="enscript-function-name">in6_pcblookup_local</span>(<span class="enscript-type">struct</span> inpcbinfo *pcbinfo, <span class="enscript-type">struct</span> in6_addr *laddr,
    u_int lport_arg, <span class="enscript-type">int</span> wild_okay)
{
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">int</span> matchwild = 3, wildcard;
	u_short lport = lport_arg;
	<span class="enscript-type">struct</span> inpcbporthead *porthash;
	<span class="enscript-type">struct</span> inpcb *match = NULL;
	<span class="enscript-type">struct</span> inpcbport *phd;

	<span class="enscript-keyword">if</span> (!wild_okay) {
		<span class="enscript-type">struct</span> inpcbhead *head;
		<span class="enscript-comment">/*
		 * Look for an unconnected (wildcard foreign addr) PCB that
		 * matches the local address and port we're looking for.
		 */</span>
		head = &amp;pcbinfo-&gt;ipi_hashbase[INP_PCBHASH(INADDR_ANY, lport, 0,
		    pcbinfo-&gt;ipi_hashmask)];
		LIST_FOREACH(inp, head, inp_hash) {
			<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV6))
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_faddr) &amp;&amp;
			    IN6_ARE_ADDR_EQUAL(&amp;inp-&gt;in6p_laddr, laddr) &amp;&amp;
			    inp-&gt;inp_lport == lport) {
				<span class="enscript-comment">/*
				 * Found.
				 */</span>
				<span class="enscript-keyword">return</span> (inp);
			}
		}
		<span class="enscript-comment">/*
		 * Not found.
		 */</span>
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-comment">/*
	 * Best fit PCB lookup.
	 *
	 * First see if this local port is in use by looking on the
	 * port hash list.
	 */</span>
	porthash = &amp;pcbinfo-&gt;ipi_porthashbase[INP_PCBPORTHASH(lport,
	    pcbinfo-&gt;ipi_porthashmask)];
	LIST_FOREACH(phd, porthash, phd_hash) {
		<span class="enscript-keyword">if</span> (phd-&gt;phd_port == lport)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (phd != NULL) {
		<span class="enscript-comment">/*
		 * Port is in use by one or more PCBs. Look for best
		 * fit.
		 */</span>
		LIST_FOREACH(inp, &amp;phd-&gt;phd_pcblist, inp_portlist) {
			wildcard = 0;
			<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV6))
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_faddr))
				wildcard++;
			<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_laddr)) {
				<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(laddr))
					wildcard++;
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!IN6_ARE_ADDR_EQUAL(
				    &amp;inp-&gt;in6p_laddr, laddr))
					<span class="enscript-keyword">continue</span>;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (!IN6_IS_ADDR_UNSPECIFIED(laddr))
					wildcard++;
			}
			<span class="enscript-keyword">if</span> (wildcard &lt; matchwild) {
				match = inp;
				matchwild = wildcard;
				<span class="enscript-keyword">if</span> (matchwild == 0) {
					<span class="enscript-keyword">break</span>;
				}
			}
		}
	}
	<span class="enscript-keyword">return</span> (match);
}

<span class="enscript-comment">/*
 * Check for alternatives when higher level complains
 * about service problems.  For now, invalidate cached
 * routing information.  If the route was created dynamically
 * (by a redirect), time to try a default gateway again.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_losing</span>(<span class="enscript-type">struct</span> inpcb *in6p)
{
	<span class="enscript-type">struct</span> rtentry *rt;

	<span class="enscript-keyword">if</span> ((rt = in6p-&gt;in6p_route.ro_rt) != NULL) {
		RT_LOCK(rt);
		<span class="enscript-keyword">if</span> (rt-&gt;rt_flags &amp; RTF_DYNAMIC) {
			<span class="enscript-comment">/*
			 * Prevent another thread from modifying rt_key,
			 * rt_gateway via rt_setgate() after the rt_lock
			 * is dropped by marking the route as defunct.
			 */</span>
			rt-&gt;rt_flags |= RTF_CONDEMNED;
			RT_UNLOCK(rt);
			(<span class="enscript-type">void</span>) rtrequest(RTM_DELETE, rt_key(rt),
			    rt-&gt;rt_gateway, rt_mask(rt), rt-&gt;rt_flags, NULL);
		} <span class="enscript-keyword">else</span> {
			RT_UNLOCK(rt);
		}
		<span class="enscript-comment">/*
		 * A new route can be allocated
		 * the next time output is attempted.
		 */</span>
	}
	ROUTE_RELEASE(&amp;in6p-&gt;in6p_route);
}

<span class="enscript-comment">/*
 * After a routing change, flush old routing
 * and allocate a (hopefully) better one.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">in6_rtchange</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">int</span> errno)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">errno</span>)
	<span class="enscript-comment">/*
	 * A new route can be allocated the next time
	 * output is attempted.
	 */</span>
	ROUTE_RELEASE(&amp;inp-&gt;in6p_route);
}

<span class="enscript-comment">/*
 * Check if PCB exists hash list. Also returns uid and gid of socket
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">in6_pcblookup_hash_exists</span>(<span class="enscript-type">struct</span> inpcbinfo *pcbinfo, <span class="enscript-type">struct</span> in6_addr *faddr,
    u_int fport_arg, <span class="enscript-type">struct</span> in6_addr *laddr, u_int lport_arg, <span class="enscript-type">int</span> wildcard,
    uid_t *uid, gid_t *gid, <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> inpcbhead *head;
	<span class="enscript-type">struct</span> inpcb *inp;
	u_short fport = fport_arg, lport = lport_arg;
	<span class="enscript-type">int</span> found;

	*uid = UID_MAX;
	*gid = GID_MAX;

	lck_rw_lock_shared(pcbinfo-&gt;ipi_lock);

	<span class="enscript-comment">/*
	 * First look for an exact match.
	 */</span>
	head = &amp;pcbinfo-&gt;ipi_hashbase[INP_PCBHASH(faddr-&gt;s6_addr32[3] <span class="enscript-comment">/* XXX */</span>,
	    lport, fport, pcbinfo-&gt;ipi_hashmask)];
	LIST_FOREACH(inp, head, inp_hash) {
		<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV6))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (inp_restricted_recv(inp, ifp))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(&amp;inp-&gt;in6p_faddr, faddr) &amp;&amp;
		    IN6_ARE_ADDR_EQUAL(&amp;inp-&gt;in6p_laddr, laddr) &amp;&amp;
		    inp-&gt;inp_fport == fport &amp;&amp;
		    inp-&gt;inp_lport == lport) {
			<span class="enscript-keyword">if</span> ((found = (inp-&gt;inp_socket != NULL))) {
				<span class="enscript-comment">/*
				 * Found. Check if pcb is still valid
				 */</span>
				*uid = kauth_cred_getuid(
				    inp-&gt;inp_socket-&gt;so_cred);
				*gid = kauth_cred_getgid(
				    inp-&gt;inp_socket-&gt;so_cred);
			}
			lck_rw_done(pcbinfo-&gt;ipi_lock);
			<span class="enscript-keyword">return</span> (found);
		}
	}
	<span class="enscript-keyword">if</span> (wildcard) {
		<span class="enscript-type">struct</span> inpcb *local_wild = NULL;

		head = &amp;pcbinfo-&gt;ipi_hashbase[INP_PCBHASH(INADDR_ANY, lport, 0,
		    pcbinfo-&gt;ipi_hashmask)];
		LIST_FOREACH(inp, head, inp_hash) {
			<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV6))
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (inp_restricted_recv(inp, ifp))
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_faddr) &amp;&amp;
			    inp-&gt;inp_lport == lport) {
				<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(&amp;inp-&gt;in6p_laddr,
				    laddr)) {
					found = (inp-&gt;inp_socket != NULL);
					<span class="enscript-keyword">if</span> (found) {
						*uid = kauth_cred_getuid(
						    inp-&gt;inp_socket-&gt;so_cred);
						*gid = kauth_cred_getgid(
						    inp-&gt;inp_socket-&gt;so_cred);
					}
					lck_rw_done(pcbinfo-&gt;ipi_lock);
					<span class="enscript-keyword">return</span> (found);
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(
				    &amp;inp-&gt;in6p_laddr)) {
					local_wild = inp;
				}
			}
		}
		<span class="enscript-keyword">if</span> (local_wild) {
			<span class="enscript-keyword">if</span> ((found = (local_wild-&gt;inp_socket != NULL))) {
				*uid = kauth_cred_getuid(
				    local_wild-&gt;inp_socket-&gt;so_cred);
				*gid = kauth_cred_getgid(
				    local_wild-&gt;inp_socket-&gt;so_cred);
			}
			lck_rw_done(pcbinfo-&gt;ipi_lock);
			<span class="enscript-keyword">return</span> (found);
		}
	}

	<span class="enscript-comment">/*
	 * Not found.
	 */</span>
	lck_rw_done(pcbinfo-&gt;ipi_lock);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Lookup PCB in hash list.
 */</span>
<span class="enscript-type">struct</span> inpcb *
<span class="enscript-function-name">in6_pcblookup_hash</span>(<span class="enscript-type">struct</span> inpcbinfo *pcbinfo, <span class="enscript-type">struct</span> in6_addr *faddr,
    u_int fport_arg, <span class="enscript-type">struct</span> in6_addr *laddr, u_int lport_arg, <span class="enscript-type">int</span> wildcard,
    <span class="enscript-type">struct</span> ifnet *ifp)
{
	<span class="enscript-type">struct</span> inpcbhead *head;
	<span class="enscript-type">struct</span> inpcb *inp;
	u_short fport = fport_arg, lport = lport_arg;

	lck_rw_lock_shared(pcbinfo-&gt;ipi_lock);

	<span class="enscript-comment">/*
	 * First look for an exact match.
	 */</span>
	head = &amp;pcbinfo-&gt;ipi_hashbase[INP_PCBHASH(faddr-&gt;s6_addr32[3] <span class="enscript-comment">/* XXX */</span>,
	    lport, fport, pcbinfo-&gt;ipi_hashmask)];
	LIST_FOREACH(inp, head, inp_hash) {
		<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV6))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (inp_restricted_recv(inp, ifp))
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(&amp;inp-&gt;in6p_faddr, faddr) &amp;&amp;
		    IN6_ARE_ADDR_EQUAL(&amp;inp-&gt;in6p_laddr, laddr) &amp;&amp;
		    inp-&gt;inp_fport == fport &amp;&amp;
		    inp-&gt;inp_lport == lport) {
			<span class="enscript-comment">/*
			 * Found. Check if pcb is still valid
			 */</span>
			<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_ACQUIRE, 0) !=
			    WNT_STOPUSING) {
				lck_rw_done(pcbinfo-&gt;ipi_lock);
				<span class="enscript-keyword">return</span> (inp);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* it's there but dead, say it isn't found */</span>
				lck_rw_done(pcbinfo-&gt;ipi_lock);
				<span class="enscript-keyword">return</span> (NULL);
			}
		}
	}
	<span class="enscript-keyword">if</span> (wildcard) {
		<span class="enscript-type">struct</span> inpcb *local_wild = NULL;

		head = &amp;pcbinfo-&gt;ipi_hashbase[INP_PCBHASH(INADDR_ANY, lport, 0,
		    pcbinfo-&gt;ipi_hashmask)];
		LIST_FOREACH(inp, head, inp_hash) {
			<span class="enscript-keyword">if</span> (!(inp-&gt;inp_vflag &amp; INP_IPV6))
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (inp_restricted_recv(inp, ifp))
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(&amp;inp-&gt;in6p_faddr) &amp;&amp;
			    inp-&gt;inp_lport == lport) {
				<span class="enscript-keyword">if</span> (IN6_ARE_ADDR_EQUAL(&amp;inp-&gt;in6p_laddr,
				    laddr)) {
					<span class="enscript-keyword">if</span> (in_pcb_checkstate(inp, WNT_ACQUIRE,
					    0) != WNT_STOPUSING) {
						lck_rw_done(pcbinfo-&gt;ipi_lock);
						<span class="enscript-keyword">return</span> (inp);
					} <span class="enscript-keyword">else</span> {
						<span class="enscript-comment">/* dead; say it isn't found */</span>
						lck_rw_done(pcbinfo-&gt;ipi_lock);
						<span class="enscript-keyword">return</span> (NULL);
					}
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IN6_IS_ADDR_UNSPECIFIED(
				    &amp;inp-&gt;in6p_laddr)) {
					local_wild = inp;
				}
			}
		}
		<span class="enscript-keyword">if</span> (local_wild &amp;&amp; in_pcb_checkstate(local_wild,
		    WNT_ACQUIRE, 0) != WNT_STOPUSING) {
			lck_rw_done(pcbinfo-&gt;ipi_lock);
			<span class="enscript-keyword">return</span> (local_wild);
		} <span class="enscript-keyword">else</span> {
			lck_rw_done(pcbinfo-&gt;ipi_lock);
			<span class="enscript-keyword">return</span> (NULL);
		}
	}

	<span class="enscript-comment">/*
	 * Not found.
	 */</span>
	lck_rw_done(pcbinfo-&gt;ipi_lock);
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">init_sin6</span>(<span class="enscript-type">struct</span> sockaddr_in6 *sin6, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> ip6_hdr *ip;

	ip = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	bzero(sin6, <span class="enscript-keyword">sizeof</span> (*sin6));
	sin6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span> (*sin6);
	sin6-&gt;sin6_family = AF_INET6;
	sin6-&gt;sin6_addr = ip-&gt;ip6_src;
	<span class="enscript-keyword">if</span> (IN6_IS_SCOPE_LINKLOCAL(&amp;sin6-&gt;sin6_addr)) {
		sin6-&gt;sin6_addr.s6_addr16[1] = 0;
		<span class="enscript-keyword">if</span> ((m-&gt;m_pkthdr.pkt_flags &amp; (PKTF_LOOP|PKTF_IFAINFO)) ==
		    (PKTF_LOOP|PKTF_IFAINFO))
			sin6-&gt;sin6_scope_id = m-&gt;m_pkthdr.src_ifindex;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.rcvif != NULL)
			sin6-&gt;sin6_scope_id = m-&gt;m_pkthdr.rcvif-&gt;if_index;
	}
}

<span class="enscript-comment">/*
 * The following routines implement this scheme:
 *
 * Callers of ip6_output() that intend to cache the route in the inpcb pass
 * a local copy of the struct route to ip6_output().  Using a local copy of
 * the cached route significantly simplifies things as IP no longer has to
 * worry about having exclusive access to the passed in struct route, since
 * it's defined in the caller's stack; in essence, this allows for a lock-
 * less operation when updating the struct route at the IP level and below,
 * whenever necessary. The scheme works as follows:
 *
 * Prior to dropping the socket's lock and calling ip6_output(), the caller
 * copies the struct route from the inpcb into its stack, and adds a reference
 * to the cached route entry, if there was any.  The socket's lock is then
 * dropped and ip6_output() is called with a pointer to the copy of struct
 * route defined on the stack (not to the one in the inpcb.)
 *
 * Upon returning from ip6_output(), the caller then acquires the socket's
 * lock and synchronizes the cache; if there is no route cached in the inpcb,
 * it copies the local copy of struct route (which may or may not contain any
 * route) back into the cache; otherwise, if the inpcb has a route cached in
 * it, the one in the local copy will be freed, if there's any.  Trashing the
 * cached route in the inpcb can be avoided because ip6_output() is single-
 * threaded per-PCB (i.e. multiple transmits on a PCB are always serialized
 * by the socket/transport layer.)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">in6p_route_copyout</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> route_in6 *dst)
{
	<span class="enscript-type">struct</span> route_in6 *src = &amp;inp-&gt;in6p_route;

	lck_mtx_assert(&amp;inp-&gt;inpcb_mtx, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* Minor sanity check */</span>
	<span class="enscript-keyword">if</span> (src-&gt;ro_rt != NULL &amp;&amp; rt_key(src-&gt;ro_rt)-&gt;sa_family != AF_INET6)
		panic(<span class="enscript-string">&quot;%s: wrong or corrupted route: %p&quot;</span>, __func__, src);

	route_copyout((<span class="enscript-type">struct</span> route *)dst, (<span class="enscript-type">struct</span> route *)src, <span class="enscript-keyword">sizeof</span> (*dst));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">in6p_route_copyin</span>(<span class="enscript-type">struct</span> inpcb *inp, <span class="enscript-type">struct</span> route_in6 *src)
{
	<span class="enscript-type">struct</span> route_in6 *dst = &amp;inp-&gt;in6p_route;

	lck_mtx_assert(&amp;inp-&gt;inpcb_mtx, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* Minor sanity check */</span>
	<span class="enscript-keyword">if</span> (src-&gt;ro_rt != NULL &amp;&amp; rt_key(src-&gt;ro_rt)-&gt;sa_family != AF_INET6)
		panic(<span class="enscript-string">&quot;%s: wrong or corrupted route: %p&quot;</span>, __func__, src);

	route_copyin((<span class="enscript-type">struct</span> route *)src, (<span class="enscript-type">struct</span> route *)dst, <span class="enscript-keyword">sizeof</span> (*src));
}
</pre>
<hr />
</body></html>