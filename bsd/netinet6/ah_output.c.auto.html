<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ah_output.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ah_output.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	$FreeBSD: src/sys/netinet6/ah_output.c,v 1.1.2.3 2001/07/03 11:01:49 ume Exp $	*/</span>
<span class="enscript-comment">/*	$KAME: ah_output.c,v 1.30 2001/02/21 00:50:53 itojun Exp $	*/</span>

<span class="enscript-comment">/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>

<span class="enscript-comment">/*
 * RFC1826/2402 authentication header.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_IP_VHL</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/icmp6.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ipsec6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ah.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ah6.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/key.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netkey/keydb.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_osdep.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> in_addr *<span class="enscript-function-name">ah4_finaldst</span>(<span class="enscript-type">struct</span> mbuf *);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> lck_mtx_t *sadb_mutex;

<span class="enscript-comment">/*
 * compute AH header size.
 * transport mode only.  for tunnel mode, we should implement
 * virtual interface, and control MTU/MSS by the interface MTU.
 */</span>
size_t
<span class="enscript-function-name">ah_hdrsiz</span>(isr)
	<span class="enscript-type">struct</span> ipsecrequest *isr;
{

	<span class="enscript-comment">/* sanity check */</span>
	<span class="enscript-keyword">if</span> (isr == NULL)
		panic(<span class="enscript-string">&quot;ah_hdrsiz: NULL was passed.\n&quot;</span>);

	<span class="enscript-keyword">if</span> (isr-&gt;saidx.proto != IPPROTO_AH)
		panic(<span class="enscript-string">&quot;unsupported mode passed to ah_hdrsiz&quot;</span>);

#<span class="enscript-reference">if</span> 0
	{

		lck_mtx_lock(sadb_mutex);
		<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ah_algorithm *algo;
		size_t hdrsiz;

		<span class="enscript-comment">/*%%%%% this needs to change - no sav in ipsecrequest any more */</span>
		<span class="enscript-keyword">if</span> (isr-&gt;sav == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">estimate</span>;
		<span class="enscript-keyword">if</span> (isr-&gt;sav-&gt;state != SADB_SASTATE_MATURE
		 &amp;&amp; isr-&gt;sav-&gt;state != SADB_SASTATE_DYING)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">estimate</span>;
	
		<span class="enscript-comment">/* we need transport mode AH. */</span>
		algo = ah_algorithm_lookup(isr-&gt;sav-&gt;alg_auth);
		<span class="enscript-keyword">if</span> (!algo)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">estimate</span>;
	
		<span class="enscript-comment">/*
		 * XXX
		 * right now we don't calcurate the padding size.  simply
		 * treat the padding size as constant, for simplicity.
		 *
		 * XXX variable size padding support
		 */</span>
		hdrsiz = (((*algo-&gt;sumsiz)(isr-&gt;sav) + 3) &amp; ~(4 - 1));
		<span class="enscript-keyword">if</span> (isr-&gt;sav-&gt;flags &amp; SADB_X_EXT_OLD)
			hdrsiz += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ah);
		<span class="enscript-keyword">else</span>
			hdrsiz += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newah);
	
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-keyword">return</span> hdrsiz;
	}

<span class="enscript-reference">estimate</span>:
#<span class="enscript-reference">endif</span>

    <span class="enscript-comment">//lck_mtx_unlock(sadb_mutex);
</span>	<span class="enscript-comment">/* ASSUMING:
	 *	sizeof(struct newah) &gt; sizeof(struct ah).
	 *	16 = (16 + 3) &amp; ~(4 - 1).
	 */</span>
	<span class="enscript-keyword">return</span> <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newah) + 16;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
<span class="enscript-comment">/*
 * Modify the packet so that it includes the authentication data.
 * The mbuf passed must start with IPv4 header.
 *
 * assumes that the first mbuf contains IPv4 header + option only.
 * the function does not modify m.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ah4_output</span>(m, sav)
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ah_algorithm *algo;
	u_int32_t spi;
	u_char *ahdrpos;
	u_char *ahsumpos = NULL;
	size_t hlen = 0;	<span class="enscript-comment">/*IP header+option in bytes*/</span>
	size_t plen = 0;	<span class="enscript-comment">/*AH payload size in bytes*/</span>
	size_t ahlen = 0;	<span class="enscript-comment">/*plen + sizeof(ah)*/</span>
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">struct</span> in_addr dst = { 0 };
	<span class="enscript-type">struct</span> in_addr *finaldst;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* sanity checks */</span>
	<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_OLD) == 0 &amp;&amp; !sav-&gt;replay) {
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;ah4_output: internal error: &quot;</span>
			<span class="enscript-string">&quot;sav-&gt;replay is null: %x-&gt;%x, SPI=%u\n&quot;</span>,
			(u_int32_t)ntohl(ip-&gt;ip_src.s_addr),
			(u_int32_t)ntohl(ip-&gt;ip_dst.s_addr),
			(u_int32_t)ntohl(sav-&gt;spi)));
		IPSEC_STAT_INCREMENT(ipsecstat.out_inval);
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	algo = ah_algorithm_lookup(sav-&gt;alg_auth);
	<span class="enscript-keyword">if</span> (!algo) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;ah4_output: unsupported algorithm: &quot;</span>
		    <span class="enscript-string">&quot;SPI=%u\n&quot;</span>, (u_int32_t)ntohl(sav-&gt;spi)));
		IPSEC_STAT_INCREMENT(ipsecstat.out_inval);
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	spi = sav-&gt;spi;

	<span class="enscript-comment">/*
	 * determine the size to grow.
	 */</span>
	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_OLD) {
		<span class="enscript-comment">/* RFC 1826 */</span>
		plen = ((*algo-&gt;sumsiz)(sav) + 3) &amp; ~(4 - 1); <span class="enscript-comment">/*XXX pad to 8byte?*/</span>
		ahlen = plen + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ah);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* RFC 2402 */</span>
		plen = ((*algo-&gt;sumsiz)(sav) + 3) &amp; ~(4 - 1); <span class="enscript-comment">/*XXX pad to 8byte?*/</span>
		ahlen = plen + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newah);
	}

	<span class="enscript-comment">/*
	 * grow the mbuf to accomodate AH.
	 */</span>
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
	hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
#<span class="enscript-reference">else</span>
	hlen = ip-&gt;ip_hl &lt;&lt; 2;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (m-&gt;m_len != hlen)
		panic(<span class="enscript-string">&quot;ah4_output: assumption failed (first mbuf length)&quot;</span>);
	<span class="enscript-keyword">if</span> (M_LEADINGSPACE(m-&gt;m_next) &lt; ahlen) {
		<span class="enscript-type">struct</span> mbuf *n;
		MGET(n, M_DONTWAIT, MT_DATA);
		<span class="enscript-keyword">if</span> (!n) {
			ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;ENOBUFS in ah4_output %d\n&quot;</span>,
			    __LINE__));
			m_freem(m);
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
		n-&gt;m_len = ahlen;
		n-&gt;m_next = m-&gt;m_next;
		m-&gt;m_next = n;
		m-&gt;m_pkthdr.len += ahlen;
		ahdrpos = mtod(n, u_char *);
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_next-&gt;m_len += ahlen;
		m-&gt;m_next-&gt;m_data -= ahlen;
		m-&gt;m_pkthdr.len += ahlen;
		ahdrpos = mtod(m-&gt;m_next, u_char *);
	}

	ip = mtod(m, <span class="enscript-type">struct</span> ip *);	<span class="enscript-comment">/*just to be sure*/</span>

	<span class="enscript-comment">/*
	 * initialize AH.
	 */</span>
	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_OLD) {
		<span class="enscript-type">struct</span> ah *ahdr;

		ahdr = (<span class="enscript-type">struct</span> ah *)(<span class="enscript-type">void</span> *)ahdrpos;
		ahsumpos = (u_char *)(ahdr + 1);
		ahdr-&gt;ah_len = plen &gt;&gt; 2;
		ahdr-&gt;ah_nxt = ip-&gt;ip_p;
		ahdr-&gt;ah_reserve = htons(0);
		ahdr-&gt;ah_spi = spi;
		bzero(ahdr + 1, plen);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> newah *ahdr;

		ahdr = (<span class="enscript-type">struct</span> newah *)(<span class="enscript-type">void</span> *)ahdrpos;
		ahsumpos = (u_char *)(ahdr + 1);
		ahdr-&gt;ah_len = (plen &gt;&gt; 2) + 1;	<span class="enscript-comment">/* plus one for seq# */</span>
		ahdr-&gt;ah_nxt = ip-&gt;ip_p;
		ahdr-&gt;ah_reserve = htons(0);
		ahdr-&gt;ah_spi = spi;
		<span class="enscript-keyword">if</span> (sav-&gt;replay-&gt;count == ~0) {
			<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_CYCSEQ) == 0) {
				<span class="enscript-comment">/* XXX Is it noisy ? */</span>
				ipseclog((LOG_WARNING,
				    <span class="enscript-string">&quot;replay counter overflowed. %s\n&quot;</span>,
				    ipsec_logsastr(sav)));
				IPSEC_STAT_INCREMENT(ipsecstat.out_inval);
				m_freem(m);
				<span class="enscript-keyword">return</span> EINVAL;
			}
		}
		lck_mtx_lock(sadb_mutex);
		sav-&gt;replay-&gt;count++;
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-comment">/*
		 * XXX sequence number must not be cycled, if the SA is
		 * installed by IKE daemon.
		 */</span>
		ahdr-&gt;ah_seq = htonl(sav-&gt;replay-&gt;count);
		bzero(ahdr + 1, plen);
	}

	<span class="enscript-comment">/*
	 * modify IPv4 header.
	 */</span>
	ip-&gt;ip_p = IPPROTO_AH;
	<span class="enscript-keyword">if</span> (ahlen &lt; (IP_MAXPACKET - ntohs(ip-&gt;ip_len)))
		ip-&gt;ip_len = htons(ntohs(ip-&gt;ip_len) + ahlen);
	<span class="enscript-keyword">else</span> {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;IPv4 AH output: size exceeds limit\n&quot;</span>));
		IPSEC_STAT_INCREMENT(ipsecstat.out_inval);
		m_freem(m);
		<span class="enscript-keyword">return</span> EMSGSIZE;
	}

	<span class="enscript-comment">/*
	 * If there is source routing option, update destination field in
	 * the IPv4 header to the final destination.
	 * Note that we do not need to update source routing option itself
	 * (as done in IPv4 AH processing -- see ip6_output()), since
	 * source routing option is not part of the ICV computation.
	 */</span>
	finaldst = ah4_finaldst(m);
	<span class="enscript-keyword">if</span> (finaldst) {
		dst.s_addr = ip-&gt;ip_dst.s_addr;
		ip-&gt;ip_dst.s_addr = finaldst-&gt;s_addr;
	}

	<span class="enscript-comment">/*
	 * calcurate the checksum, based on security association
	 * and the algorithm specified.
	 */</span>
	error = ah4_calccksum(m, (caddr_t)ahsumpos, plen, algo, sav);
	<span class="enscript-keyword">if</span> (error) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;error after ah4_calccksum, called from ah4_output&quot;</span>));
		m_freem(m);
		m = NULL;
		IPSEC_STAT_INCREMENT(ipsecstat.out_inval);
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">if</span> (finaldst) {
		ip = mtod(m, <span class="enscript-type">struct</span> ip *);	<span class="enscript-comment">/*just to make sure*/</span>
		ip-&gt;ip_dst.s_addr = dst.s_addr;
	}
	lck_mtx_lock(sadb_stat_mutex);
	ipsecstat.out_success++;
	ipsecstat.out_ahhist[sav-&gt;alg_auth]++;
	lck_mtx_unlock(sadb_stat_mutex);
	key_sa_recordxfer(sav, m);

	<span class="enscript-keyword">return</span> 0;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Calculate AH length */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ah_hdrlen</span>(sav)
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ah_algorithm *algo;
	<span class="enscript-type">int</span> plen, ahlen;
	
	algo = ah_algorithm_lookup(sav-&gt;alg_auth);
	<span class="enscript-keyword">if</span> (!algo)
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_OLD) {
		<span class="enscript-comment">/* RFC 1826 */</span>
		plen = ((*algo-&gt;sumsiz)(sav) + 3) &amp; ~(4 - 1);	<span class="enscript-comment">/*XXX pad to 8byte?*/</span>
		ahlen = plen + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ah);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* RFC 2402 */</span>
		plen = ((*algo-&gt;sumsiz)(sav) + 3) &amp; ~(4 - 1);	<span class="enscript-comment">/*XXX pad to 8byte?*/</span>
		ahlen = plen + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newah);
	}

	<span class="enscript-keyword">return</span>(ahlen);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-comment">/*
 * Fill in the Authentication Header and calculate checksum.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ah6_output</span>(m, nexthdrp, md, sav)
	<span class="enscript-type">struct</span> mbuf *m;
	u_char *nexthdrp;
	<span class="enscript-type">struct</span> mbuf *md;
	<span class="enscript-type">struct</span> secasvar *sav;
{
	<span class="enscript-type">struct</span> mbuf *mprev;
	<span class="enscript-type">struct</span> mbuf *mah;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> ah_algorithm *algo;
	u_int32_t spi;
	u_char *ahsumpos = NULL;
	size_t plen;	<span class="enscript-comment">/*AH payload size in bytes*/</span>
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> ahlen;
	<span class="enscript-type">struct</span> ip6_hdr *ip6;

	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr)) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;ah6_output: first mbuf too short\n&quot;</span>));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	ahlen = ah_hdrlen(sav);
	<span class="enscript-keyword">if</span> (ahlen == 0)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">for</span> (mprev = m; mprev &amp;&amp; mprev-&gt;m_next != md; mprev = mprev-&gt;m_next)
		;
	<span class="enscript-keyword">if</span> (!mprev || mprev-&gt;m_next != md) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;ah6_output: md is not in chain\n&quot;</span>));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	MGET(mah, M_DONTWAIT, MT_DATA);
	<span class="enscript-keyword">if</span> (!mah) {
		m_freem(m);
		<span class="enscript-keyword">return</span> ENOBUFS;
	}
	<span class="enscript-keyword">if</span> (ahlen &gt; MLEN) {
		MCLGET(mah, M_DONTWAIT);
		<span class="enscript-keyword">if</span> ((mah-&gt;m_flags &amp; M_EXT) == 0) {
			m_free(mah);
			m_freem(m);
			<span class="enscript-keyword">return</span> ENOBUFS;
		}
	}
	mah-&gt;m_len = ahlen;
	mah-&gt;m_next = md;
	mprev-&gt;m_next = mah;
	m-&gt;m_pkthdr.len += ahlen;

	<span class="enscript-comment">/* fix plen */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr) &gt; IPV6_MAXPACKET) {
		ipseclog((LOG_ERR,
		    <span class="enscript-string">&quot;ip6_output: AH with IPv6 jumbogram is not supported\n&quot;</span>));
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	ip6 = mtod(m, <span class="enscript-type">struct</span> ip6_hdr *);
	ip6-&gt;ip6_plen = htons(m-&gt;m_pkthdr.len - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip6_hdr));

	<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_OLD) == 0 &amp;&amp; !sav-&gt;replay) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;ah6_output: internal error: &quot;</span>
			  <span class="enscript-string">&quot;sav-&gt;replay is null: SPI=%u\n&quot;</span>,
			  (u_int32_t)ntohl(sav-&gt;spi)));
		IPSEC_STAT_INCREMENT(ipsec6stat.out_inval);
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	algo = ah_algorithm_lookup(sav-&gt;alg_auth);
	<span class="enscript-keyword">if</span> (!algo) {
		ipseclog((LOG_ERR, <span class="enscript-string">&quot;ah6_output: unsupported algorithm: &quot;</span>
		    <span class="enscript-string">&quot;SPI=%u\n&quot;</span>, (u_int32_t)ntohl(sav-&gt;spi)));
		IPSEC_STAT_INCREMENT(ipsec6stat.out_inval);
		m_freem(m);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	spi = sav-&gt;spi;

	<span class="enscript-comment">/*
	 * initialize AH.
	 */</span>
	<span class="enscript-keyword">if</span> (sav-&gt;flags &amp; SADB_X_EXT_OLD) {
		<span class="enscript-type">struct</span> ah *ahdr = mtod(mah, <span class="enscript-type">struct</span> ah *);

		plen = mah-&gt;m_len - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ah);
		ahsumpos = (u_char *)(ahdr + 1);
		ahdr-&gt;ah_nxt = *nexthdrp;
		*nexthdrp = IPPROTO_AH;
		ahdr-&gt;ah_len = plen &gt;&gt; 2;
		ahdr-&gt;ah_reserve = htons(0);
		ahdr-&gt;ah_spi = spi;
		bzero(ahdr + 1, plen);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> newah *ahdr = mtod(mah, <span class="enscript-type">struct</span> newah *);

		plen = mah-&gt;m_len - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> newah);
		ahsumpos = (u_char *)(ahdr + 1);
		ahdr-&gt;ah_nxt = *nexthdrp;
		*nexthdrp = IPPROTO_AH;
		ahdr-&gt;ah_len = (plen &gt;&gt; 2) + 1;	<span class="enscript-comment">/* plus one for seq# */</span>
		ahdr-&gt;ah_reserve = htons(0);
		ahdr-&gt;ah_spi = spi;
		<span class="enscript-keyword">if</span> (sav-&gt;replay-&gt;count == ~0) {
			<span class="enscript-keyword">if</span> ((sav-&gt;flags &amp; SADB_X_EXT_CYCSEQ) == 0) {
				<span class="enscript-comment">/* XXX Is it noisy ? */</span>
				ipseclog((LOG_WARNING,
				     <span class="enscript-string">&quot;replay counter overflowed. %s\n&quot;</span>,
				    ipsec_logsastr(sav)));
				IPSEC_STAT_INCREMENT(ipsec6stat.out_inval);
				m_freem(m);
				<span class="enscript-keyword">return</span> EINVAL;
			}
		}
		lck_mtx_lock(sadb_mutex);
		sav-&gt;replay-&gt;count++;
		lck_mtx_unlock(sadb_mutex);
		<span class="enscript-comment">/*
		 * XXX sequence number must not be cycled, if the SA is
		 * installed by IKE daemon.
		 */</span>
		ahdr-&gt;ah_seq = htonl(sav-&gt;replay-&gt;count);
		bzero(ahdr + 1, plen);
	}

	<span class="enscript-comment">/*
	 * calcurate the checksum, based on security association
	 * and the algorithm specified.
	 */</span>
	error = ah6_calccksum(m, (caddr_t)ahsumpos, plen, algo, sav);
	<span class="enscript-keyword">if</span> (error) {
		IPSEC_STAT_INCREMENT(ipsec6stat.out_inval);
		m_freem(m);
	} <span class="enscript-keyword">else</span> {
		IPSEC_STAT_INCREMENT(ipsec6stat.out_success);
		key_sa_recordxfer(sav, m);
	}
	IPSEC_STAT_INCREMENT(ipsec6stat.out_ahhist[sav-&gt;alg_auth]);

	<span class="enscript-keyword">return</span>(error);
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET</span>
<span class="enscript-comment">/*
 * Find the final destination if there is loose/strict source routing option.
 * Returns NULL if there's no source routing options.
 * Returns NULL on errors too.
 * Note that this function will return a pointer INTO the given parameter,
 * struct mbuf *m.
 * The mbuf must be pulled up toward, at least, ip option part.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> in_addr *
<span class="enscript-function-name">ah4_finaldst</span>(m)
	<span class="enscript-type">struct</span> mbuf *m;
{
	<span class="enscript-type">struct</span> ip *ip;
	<span class="enscript-type">int</span> optlen;
	u_char *q;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> hlen;

	<span class="enscript-keyword">if</span> (!m)
		panic(<span class="enscript-string">&quot;ah4_finaldst: m == NULL&quot;</span>);
	ip = mtod(m, <span class="enscript-type">struct</span> ip *);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_IP_VHL</span>
	hlen = IP_VHL_HL(ip-&gt;ip_vhl) &lt;&lt; 2;
#<span class="enscript-reference">else</span>
	hlen = ip-&gt;ip_hl &lt;&lt; 2;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (m-&gt;m_len &lt; hlen) {
		ipseclog((LOG_DEBUG,
		    <span class="enscript-string">&quot;ah4_finaldst: parameter mbuf wrong (not pulled up)\n&quot;</span>));
		<span class="enscript-keyword">return</span> NULL;
	}

	<span class="enscript-keyword">if</span> (hlen == <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip))
		<span class="enscript-keyword">return</span> NULL;

	optlen = hlen - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ip);
	<span class="enscript-keyword">if</span> (optlen &lt; 0) {
		ipseclog((LOG_DEBUG, <span class="enscript-string">&quot;ah4_finaldst: wrong optlen %d\n&quot;</span>,
		    optlen));
		<span class="enscript-keyword">return</span> NULL;
	}

	q = (u_char *)(ip + 1);
	i = 0;
	<span class="enscript-keyword">while</span> (i &lt; optlen) {
		<span class="enscript-keyword">if</span> (i + IPOPT_OPTVAL &gt;= optlen)
			<span class="enscript-keyword">return</span> NULL;
		<span class="enscript-keyword">if</span> (q[i + IPOPT_OPTVAL] == IPOPT_EOL ||
		    q[i + IPOPT_OPTVAL] == IPOPT_NOP ||
		    i + IPOPT_OLEN &lt; optlen)
			;
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> NULL;

		<span class="enscript-keyword">switch</span> (q[i + IPOPT_OPTVAL]) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_EOL</span>:
			i = optlen;	<span class="enscript-comment">/* bye */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_NOP</span>:
			i++;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_LSRR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IPOPT_SSRR</span>:
			<span class="enscript-keyword">if</span> (q[i + IPOPT_OLEN] &lt; 2 + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr) ||
			    optlen - i &lt; q[i + IPOPT_OLEN]) {
				ipseclog((LOG_ERR,
				    <span class="enscript-string">&quot;ip_finaldst: invalid IP option &quot;</span>
				    <span class="enscript-string">&quot;(code=%02x len=%02x)\n&quot;</span>,
				    q[i + IPOPT_OPTVAL], q[i + IPOPT_OLEN]));
				<span class="enscript-keyword">return</span> NULL;
			}
			i += q[i + IPOPT_OLEN] - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr);
			<span class="enscript-keyword">return</span> (<span class="enscript-type">struct</span> in_addr *)(<span class="enscript-type">void</span> *)(q + i);
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">if</span> (q[i + IPOPT_OLEN] &lt; 2 ||
			    optlen - i &lt; q[i + IPOPT_OLEN]) {
				ipseclog((LOG_ERR,
				    <span class="enscript-string">&quot;ip_finaldst: invalid IP option &quot;</span>
				    <span class="enscript-string">&quot;(code=%02x len=%02x)\n&quot;</span>,
				    q[i + IPOPT_OPTVAL], q[i + IPOPT_OLEN]));
				<span class="enscript-keyword">return</span> NULL;
			}
			i += q[i + IPOPT_OLEN];
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">return</span> NULL;
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>