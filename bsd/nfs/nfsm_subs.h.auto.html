<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nfsm_subs.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nfsm_subs.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfsm_subs.h	8.2 (Berkeley) 3/30/95
 * FreeBSD-Id: nfsm_subs.h,v 1.13 1997/07/16 09:06:30 dfr Exp $
 */</span>


#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_NFS_NFSM_SUBS_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_NFS_NFSM_SUBS_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE_API_PRIVATE</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_rpchead</span>(<span class="enscript-type">struct</span> nfsreq *, mbuf_t, u_int64_t *, mbuf_t *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_rpchead2</span>(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, kauth_cred_t, <span class="enscript-type">struct</span> nfsreq *, mbuf_t, u_int64_t *, mbuf_t *);

<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_new_mbuf</span>(<span class="enscript-type">struct</span> nfsm_chain *, size_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_add_opaque_f</span>(<span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">const</span> u_char *, uint32_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_add_opaque_nopad_f</span>(<span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">const</span> u_char *, uint32_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_add_uio</span>(<span class="enscript-type">struct</span> nfsm_chain *, uio_t, uint32_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_add_fattr4_f</span>(<span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">struct</span> vnode_attr *, <span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_add_v2sattr_f</span>(<span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">struct</span> vnode_attr *, uint32_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_add_v3sattr_f</span>(<span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">struct</span> vnode_attr *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_add_string_nfc</span>(<span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">const</span> uint8_t *, uint32_t);

<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_advance</span>(<span class="enscript-type">struct</span> nfsm_chain *, uint32_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_offset</span>(<span class="enscript-type">struct</span> nfsm_chain *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_reverse</span>(<span class="enscript-type">struct</span> nfsm_chain *, uint32_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_get_opaque_pointer_f</span>(<span class="enscript-type">struct</span> nfsm_chain *, uint32_t, u_char **);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_get_opaque_f</span>(<span class="enscript-type">struct</span> nfsm_chain *, uint32_t, u_char *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_get_uio</span>(<span class="enscript-type">struct</span> nfsm_chain *, uint32_t, uio_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_get_fh_attr</span>(<span class="enscript-type">struct</span> nfsm_chain *, nfsnode_t,
	vfs_context_t, <span class="enscript-type">int</span>, uint64_t *, fhandle_t *, <span class="enscript-type">struct</span> nfs_vattr *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_get_wcc_data_f</span>(<span class="enscript-type">struct</span> nfsm_chain *, nfsnode_t, <span class="enscript-type">struct</span> timespec *, <span class="enscript-type">int</span> *, u_int64_t *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_get_secinfo</span>(<span class="enscript-type">struct</span> nfsm_chain *, uint32_t *, <span class="enscript-type">int</span> *);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">nfsm_adj</span>(mbuf_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_mbuf_get_list</span>(size_t, mbuf_t *, <span class="enscript-type">int</span> *);

<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_add_fattr</span>(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">struct</span> vnode_attr *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_add_wcc_data_f</span>(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">int</span>,
	<span class="enscript-type">struct</span> vnode_attr *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> vnode_attr *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_get_path_namei</span>(<span class="enscript-type">struct</span> nfsm_chain *, uint32_t, <span class="enscript-type">struct</span> nameidata *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_get_sattr</span>(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">struct</span> vnode_attr *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsm_chain_trim_data</span>(<span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span> *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>

<span class="enscript-comment">/* check name length */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_name_len_check</span>(E, ND, LEN) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> (((ND)-&gt;nd_vers == NFS_VER2) &amp;&amp; ((LEN) &gt; NFS_MAXNAMLEN)) \
			(E) = NFSERR_NAMETOL; \
		<span class="enscript-keyword">if</span> ((LEN) &lt;= 0) \
			error = EBADRPC; \
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_assert</span>(E, COND, ERR) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> (!(COND)) \
			(E) = (ERR); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* Initialize a vnode_attr to retrieve attributes for the NFS server. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_srv_vattr_init</span>(VAP, VERS) \
	<span class="enscript-keyword">do</span> { \
		VATTR_INIT(VAP); \
		VATTR_WANTED((VAP), va_type); \
		VATTR_WANTED((VAP), va_mode); \
		VATTR_WANTED((VAP), va_nlink); \
		VATTR_WANTED((VAP), va_uid); \
		VATTR_WANTED((VAP), va_gid); \
		VATTR_WANTED((VAP), va_data_size); \
		VATTR_WANTED((VAP), va_data_alloc); \
		VATTR_WANTED((VAP), va_rdev); \
		VATTR_WANTED((VAP), va_fsid); \
		VATTR_WANTED((VAP), va_fileid); \
		VATTR_WANTED((VAP), va_access_time); \
		VATTR_WANTED((VAP), va_modify_time); \
		VATTR_WANTED((VAP), va_change_time); \
		<span class="enscript-keyword">if</span> ((VERS) == NFS_VER2) \
			VATTR_WANTED((VAP), va_iosize); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* Initialize a vnode_attr to retrieve pre-operation attributes for the NFS server. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_srv_pre_vattr_init</span>(VAP) \
	<span class="enscript-keyword">do</span> { \
		VATTR_INIT(VAP); \
		VATTR_WANTED((VAP), va_data_size); \
		VATTR_WANTED((VAP), va_modify_time); \
		VATTR_WANTED((VAP), va_change_time); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* round up to a multiple of 4 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_rndup</span>(a)	(((a)+3)&amp;(~0x3))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_pad</span>(a)	(nfsm_rndup(a) - (a))

<span class="enscript-comment">/*
 * control flow macros:
 * go to the appropriate label on condition
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsmout_if</span>(E)	do { if (E) goto nfsmout; } while (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsmerr_if</span>(E)	do { if (E) goto nfsmerr; } while (0)

<span class="enscript-comment">/*
 * For NFS v2 errors and EBADRPC, the reply contains only the error.
 * This macro is used to skip any reply building code and go straight
 * to nfsmout instead.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsmout_on_status</span>(ND, E) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (((ND)-&gt;nd_repstat == EBADRPC) || \
		    ((ND)-&gt;nd_repstat &amp;&amp; ((ND)-&gt;nd_vers == NFS_VER2))) { \
			(E) = 0; \
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>; \
		} \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* initialize an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_null</span>(NMC) \
	<span class="enscript-keyword">do</span> { \
		(NMC)-&gt;nmc_mhead = (NMC)-&gt;nmc_mcur = NULL; \
		(NMC)-&gt;nmc_ptr = NULL; \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* cleanup an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_cleanup</span>(NMC) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (!(NMC)-&gt;nmc_mhead) <span class="enscript-keyword">break</span>; \
		mbuf_freem((NMC)-&gt;nmc_mhead); \
		nfsm_chain_null(NMC); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* get an mbuf given a size hint */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_mbuf_get</span>(E, MBP, SIZEHINT) \
	<span class="enscript-keyword">do</span> { \
		*(MBP) = NULL; \
		<span class="enscript-keyword">if</span> ((size_t)(SIZEHINT) &gt;= nfs_mbuf_minclsize) \
			(E) = mbuf_mclget(MBUF_WAITOK, MBUF_TYPE_DATA, (MBP)); \
		<span class="enscript-keyword">else</span> \
			(E) = mbuf_get(MBUF_WAITOK, MBUF_TYPE_DATA, (MBP)); \
	} <span class="enscript-keyword">while</span> (0)


<span class="enscript-comment">/*
 * macros for building NFS mbuf chains
 */</span>

<span class="enscript-comment">/* prepare an mbuf chain for building starting with the given mbuf */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_init</span>(NMC, MB) \
	<span class="enscript-keyword">do</span> { \
		(NMC)-&gt;nmc_mhead = (MB); \
		(NMC)-&gt;nmc_mcur = (NMC)-&gt;nmc_mhead; \
		(NMC)-&gt;nmc_ptr = mbuf_data((NMC)-&gt;nmc_mcur); \
		(NMC)-&gt;nmc_left = mbuf_trailingspace((NMC)-&gt;nmc_mcur); \
		(NMC)-&gt;nmc_flags = 0; \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* prepare an mbuf chain for building starting with a newly allocated mbuf */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_build_alloc_init</span>(E, NMC, SIZEHINT) \
	<span class="enscript-keyword">do</span> { \
		mbuf_t ncbimb; \
		nfsm_mbuf_get((E), &amp;ncbimb, (SIZEHINT)); \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		nfsm_chain_init((NMC), ncbimb); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* done building an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_build_done</span>(E, NMC) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> ((E) || !(NMC)-&gt;nmc_mcur) <span class="enscript-keyword">break</span>; \
		<span class="enscript-comment">/* cap off current mbuf */</span> \
		mbuf_setlen((NMC)-&gt;nmc_mcur, \
			(NMC)-&gt;nmc_ptr - (caddr_t)mbuf_data((NMC)-&gt;nmc_mcur)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 *  set the TCP record mark at the head of an mbuf chain -
 *  assumes 4 bytes are already allocated in the head mbuf
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_set_recmark</span>(E, NMC, VAL) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		*((uint32_t*)mbuf_data((NMC)-&gt;nmc_mhead)) \
			= txdr_unsigned(VAL); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* make sure there's room for size bytes in current mbuf */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_check_size</span>(E, NMC, SIZE) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> ((NMC)-&gt;nmc_left &lt; (SIZE)) { \
			(E) = nfsm_chain_new_mbuf((NMC), (SIZE)); \
			<span class="enscript-keyword">if</span> (!(E) &amp;&amp; ((NMC)-&gt;nmc_left &lt; (SIZE))) \
				(E) = ENOMEM; \
		} \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add a 32bit value to an mbuf chain extending if necessary */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_32</span>(E, NMC, VAL) \
	<span class="enscript-keyword">do</span> { \
		nfsm_chain_check_size((E), (NMC), NFSX_UNSIGNED); \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		*((uint32_t*)(NMC)-&gt;nmc_ptr) = txdr_unsigned(VAL); \
		(NMC)-&gt;nmc_ptr += NFSX_UNSIGNED; \
		(NMC)-&gt;nmc_left -= NFSX_UNSIGNED; \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add a 64bit value to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_64</span>(E, NMC, VAL) \
	<span class="enscript-keyword">do</span> { \
		uint64_t __tmp64; \
		nfsm_chain_check_size((E), (NMC), 2 * NFSX_UNSIGNED); \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		__tmp64 = (VAL); \
		txdr_hyper(&amp;__tmp64, (NMC)-&gt;nmc_ptr); \
		(NMC)-&gt;nmc_ptr += 2 * NFSX_UNSIGNED; \
		(NMC)-&gt;nmc_left -= 2 * NFSX_UNSIGNED; \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* zero the last 4 bytes for a range of opaque */</span>
<span class="enscript-comment">/* data to make sure any pad bytes will be zero. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_zero_opaque_pad</span>(BUF, LEN) \
	*(((uint32_t*)(BUF))+((nfsm_rndup(LEN)&gt;&gt;2)-1)) = 0

<span class="enscript-comment">/* add buffer of opaque data to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_opaque</span>(E, NMC, BUF, LEN) \
	<span class="enscript-keyword">do</span> { \
		uint32_t rndlen = nfsm_rndup(LEN); \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> ((NMC)-&gt;nmc_left &lt; rndlen) { \
			(E) = nfsm_chain_add_opaque_f((NMC), (<span class="enscript-type">const</span> u_char*)(BUF), (LEN)); \
			<span class="enscript-keyword">break</span>; \
		} \
		nfsm_chain_zero_opaque_pad((NMC)-&gt;nmc_ptr, (LEN)); \
		bcopy((BUF), (NMC)-&gt;nmc_ptr, (LEN)); \
		(NMC)-&gt;nmc_ptr += rndlen; \
		(NMC)-&gt;nmc_left -= rndlen; \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add buffer of opaque data to an mbuf chain without padding */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_opaque_nopad</span>(E, NMC, BUF, LEN) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> ((NMC)-&gt;nmc_left &lt; (uint32_t) (LEN)) { \
			(E) = nfsm_chain_add_opaque_nopad_f((NMC), (<span class="enscript-type">const</span> u_char*)(BUF), (LEN)); \
			<span class="enscript-keyword">break</span>; \
		} \
		bcopy((BUF), (NMC)-&gt;nmc_ptr, (LEN)); \
		(NMC)-&gt;nmc_ptr += (LEN); \
		(NMC)-&gt;nmc_left -= (LEN); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* finish an mbuf in a chain to allow subsequent insertion */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_finish_mbuf</span>(E, NMC) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		mbuf_setlen((NMC)-&gt;nmc_mcur, \
			(NMC)-&gt;nmc_ptr - (caddr_t)mbuf_data((NMC)-&gt;nmc_mcur)); \
		(NMC)-&gt;nmc_left = 0; \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add a file handle to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_fh</span>(E, NMC, VERS, FHP, FHLEN) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> ((VERS) != NFS_VER2) \
			nfsm_chain_add_32((E), (NMC), (FHLEN)); \
		nfsm_chain_add_opaque((E), (NMC), (FHP), (FHLEN)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add a string to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_string</span>(E, NMC, STR, LEN) \
	<span class="enscript-keyword">do</span> { \
		nfsm_chain_add_32((E), (NMC), (LEN)); \
		nfsm_chain_add_opaque((E), (NMC), (STR), (LEN)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add a name to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_name</span>(E, NMC, STR, LEN, NMP) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> (NMFLAG((NMP), NFC)) \
			(E) = nfsm_chain_add_string_nfc((NMC), (<span class="enscript-type">const</span> uint8_t*)(STR), (LEN)); \
		<span class="enscript-keyword">else</span> \
			nfsm_chain_add_string((E), (NMC), (STR), (LEN)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add an NFSv2 time to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_v2time</span>(E, NMC, TVP) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (TVP) { \
			nfsm_chain_add_32((E), (NMC), (TVP)-&gt;tv_sec); \
			nfsm_chain_add_32((E), (NMC), ((TVP)-&gt;tv_nsec != -1) ? \
				((uint32_t)(TVP)-&gt;tv_nsec / 1000) : 0xffffffff); \
		} <span class="enscript-keyword">else</span> { \
			<span class="enscript-comment">/* no time... use -1 */</span> \
			nfsm_chain_add_32((E), (NMC), -1); \
			nfsm_chain_add_32((E), (NMC), -1); \
		} \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add an NFSv3 time to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_v3time</span>(E, NMC, TVP) \
	<span class="enscript-keyword">do</span> { \
		nfsm_chain_add_32((E), (NMC), (TVP)-&gt;tv_sec); \
		nfsm_chain_add_32((E), (NMC), (TVP)-&gt;tv_nsec); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add an NFS v2 or v3 time to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_time</span>(E, NMC, VERS, TVP) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> ((VERS) == NFS_VER2) { \
			nfsm_chain_add_v2time((E), (NMC), (TVP)); \
		} <span class="enscript-keyword">else</span> { \
			nfsm_chain_add_v3time((E), (NMC), (TVP)); \
		} \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add an NFSv3 postop file handle to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_postop_fh</span>(E, NMC, FHP, FHLEN) \
	<span class="enscript-keyword">do</span> { \
		nfsm_chain_add_32((E), (NMC), TRUE); \
		nfsm_chain_add_fh((E), (NMC), NFS_VER3, (FHP), (FHLEN)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add NFSv3 postop attributes to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_postop_attr</span>(E, ND, NMC, ATTRERR, VAP) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> (ATTRERR) { \
			nfsm_chain_add_32((E), (NMC), FALSE); \
			<span class="enscript-keyword">break</span>; \
		} \
		nfsm_chain_add_32((E), (NMC), TRUE); \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		(E) = nfsm_chain_add_fattr((ND), (NMC), (VAP)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* Add an NFSv2 &quot;sattr&quot; structure to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_v2sattr</span>(E, NMC, VAP, SZRDEV) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		(E) = nfsm_chain_add_v2sattr_f((NMC), (VAP), (SZRDEV)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* Add an NFSv3 &quot;sattr&quot; structure to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_v3sattr</span>(E, NMC, VAP) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		(E) = nfsm_chain_add_v3sattr_f((NMC), (VAP)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* Add an NFSv4 &quot;fattr&quot; structure to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_fattr4</span>(E, NMC, VAP, NMP) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		(E) = nfsm_chain_add_fattr4_f((NMC), (VAP), (NMP)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add NFSv3 WCC data to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_wcc_data</span>(E, ND, NMC, PREERR, PREVAP, POSTERR, POSTVAP) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		(E) = nfsm_chain_add_wcc_data_f((ND), (NMC), \
			(PREERR), (PREVAP), (POSTERR), (POSTVAP)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add NFSv4 COMPOUND header */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS4_TAG_LENGTH</span>	12
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_compound_header</span>(E, NMC, TAG, MINOR, NUMOPS) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> ((TAG) &amp;&amp; strlen(TAG)) { \
			<span class="enscript-comment">/* put tags into a fixed-length space-padded field */</span> \
			<span class="enscript-type">char</span> __nfstag[NFS4_TAG_LENGTH+1]; \
			snprintf(__nfstag, <span class="enscript-keyword">sizeof</span>(__nfstag), <span class="enscript-string">&quot;%-*s&quot;</span>, NFS4_TAG_LENGTH, (TAG)); \
			nfsm_chain_add_32((E), (NMC), NFS4_TAG_LENGTH); \
			nfsm_chain_add_opaque((E), (NMC), __nfstag, NFS4_TAG_LENGTH); \
		} <span class="enscript-keyword">else</span> { \
			nfsm_chain_add_32((E), (NMC), 0); \
		} \
		nfsm_chain_add_32((E), (NMC), (MINOR)); <span class="enscript-comment">/*minorversion*/</span> \
		nfsm_chain_add_32((E), (NMC), (NUMOPS)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add NFSv4 attr bitmap */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_bitmap</span>(E, NMC, B, LEN) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-type">int</span> __i; \
		nfsm_chain_add_32((E), (NMC), (LEN)); \
		<span class="enscript-keyword">for</span> (__i=0; __i &lt; (LEN); __i++) \
			nfsm_chain_add_32((E), (NMC), (B)[__i]); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add NFSv4 attr bitmap masked with the given mask */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_bitmap_masked</span>(E, NMC, B, LEN, MASK) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-type">int</span> __i; \
		nfsm_chain_add_32((E), (NMC), (LEN)); \
		<span class="enscript-keyword">for</span> (__i=0; __i &lt; (LEN); __i++) \
			nfsm_chain_add_32((E), (NMC), ((B)[__i] &amp; (MASK)[__i])); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add NFSv4 attr bitmap masked with the supported attributes for this mount/node */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_bitmap_supported</span>(E, NMC, B, NMP, NP) \
	<span class="enscript-keyword">do</span> { \
		uint32_t __bitmap[NFS_ATTR_BITMAP_LEN], *__bmp = (B); \
		<span class="enscript-type">int</span> __nonamedattr = 0, __noacl = 0, __nomode = 0; \
		<span class="enscript-keyword">if</span> (!((NMP)-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR) || \
		    ((NP) &amp;&amp; (((nfsnode_t)(NP))-&gt;n_flag &amp; (NISDOTZFS|NISDOTZFSCHILD)))) \
			__nonamedattr = 1; \
		<span class="enscript-keyword">if</span> (!((NMP)-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_ACL)) \
			__noacl = 1; \
		<span class="enscript-keyword">if</span> (NMFLAG((NMP), ACLONLY)) \
			__nomode = 1; \
		<span class="enscript-keyword">if</span> (__nonamedattr || __noacl || __nomode) { \
			<span class="enscript-comment">/* don't ask for attrs we're not supporting */</span> \
			<span class="enscript-comment">/* some &quot;.zfs&quot; directories can't handle being asked for some attributes */</span> \
			<span class="enscript-type">int</span> __ii; \
			NFS_CLEAR_ATTRIBUTES(__bitmap); \
			<span class="enscript-keyword">for</span> (__ii=0; __ii &lt; NFS_ATTR_BITMAP_LEN; __ii++) \
				__bitmap[__ii] = (B)[__ii]; \
			<span class="enscript-keyword">if</span> (__nonamedattr) \
				NFS_BITMAP_CLR(__bitmap, NFS_FATTR_NAMED_ATTR); \
			<span class="enscript-keyword">if</span> (__noacl) \
				NFS_BITMAP_CLR(__bitmap, NFS_FATTR_ACL); \
			<span class="enscript-keyword">if</span> (__nomode) \
				NFS_BITMAP_CLR(__bitmap, NFS_FATTR_MODE); \
			__bmp = __bitmap; \
		} \
		nfsm_chain_add_bitmap_masked((E), (NMC), __bmp, NFS_ATTR_BITMAP_LEN, (NMP)-&gt;nm_fsattr.nfsa_supp_attr); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* Add an NFSv4 &quot;stateid&quot; structure to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_stateid</span>(E, NMC, SID) \
	<span class="enscript-keyword">do</span> { \
		nfsm_chain_add_32((E), (NMC), (SID)-&gt;seqid); \
		nfsm_chain_add_32((E), (NMC), (SID)-&gt;other[0]); \
		nfsm_chain_add_32((E), (NMC), (SID)-&gt;other[1]); \
		nfsm_chain_add_32((E), (NMC), (SID)-&gt;other[2]); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add an NFSv4 lock owner structure to an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_add_lock_owner4</span>(E, NMC, NMP, NLOP) \
	<span class="enscript-keyword">do</span> { \
		nfsm_chain_add_64((E), (NMC), (NMP)-&gt;nm_clientid); \
		nfsm_chain_add_32((E), (NMC), 5*NFSX_UNSIGNED); \
		nfsm_chain_add_32((E), (NMC), (NLOP)-&gt;nlo_name); \
		nfsm_chain_add_32((E), (NMC), (NLOP)-&gt;nlo_pid); \
		nfsm_chain_add_64((E), (NMC), (NLOP)-&gt;nlo_pid_start.tv_sec); \
		nfsm_chain_add_32((E), (NMC), (NLOP)-&gt;nlo_pid_start.tv_usec); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * macros for dissecting NFS mbuf chains
 */</span>

<span class="enscript-comment">/* prepare an mbuf chain for dissection starting with the given mbuf */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_dissect_init</span>(E, NMC, H) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (!(H)) { \
			(E) = EINVAL; \
			<span class="enscript-keyword">break</span>; \
		} \
		(NMC)-&gt;nmc_mcur = (NMC)-&gt;nmc_mhead = (H); \
		(NMC)-&gt;nmc_ptr = mbuf_data(H); \
		(NMC)-&gt;nmc_left = mbuf_len(H); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* skip a number of bytes in an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_adv</span>(E, NMC, LEN) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> ((NMC)-&gt;nmc_left &gt;= (uint32_t)(LEN)) { \
			(NMC)-&gt;nmc_left -= (LEN); \
			(NMC)-&gt;nmc_ptr += (LEN); \
		} <span class="enscript-keyword">else</span> { \
			(E) = nfsm_chain_advance((NMC), (LEN)); \
		} \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* get a 32bit value from an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_get_32</span>(E, NMC, LVAL) \
	<span class="enscript-keyword">do</span> { \
		uint32_t __tmp32, *__tmpptr; \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> ((NMC)-&gt;nmc_left &gt;= NFSX_UNSIGNED) { \
			__tmpptr = (uint32_t*)(NMC)-&gt;nmc_ptr; \
			(NMC)-&gt;nmc_left -= NFSX_UNSIGNED; \
			(NMC)-&gt;nmc_ptr += NFSX_UNSIGNED; \
		} <span class="enscript-keyword">else</span> { \
			__tmpptr = &amp;__tmp32; \
			(E) = nfsm_chain_get_opaque_f((NMC), NFSX_UNSIGNED, (u_char*)__tmpptr); \
			<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		} \
		(LVAL) = fxdr_unsigned(uint32_t, *__tmpptr); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* get a 64bit value from an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_get_64</span>(E, NMC, LVAL) \
	<span class="enscript-keyword">do</span> { \
		uint64_t __tmp64, *__tmpptr; \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> ((NMC)-&gt;nmc_left &gt;= 2 * NFSX_UNSIGNED) { \
			__tmpptr = (uint64_t*)(NMC)-&gt;nmc_ptr; \
			(NMC)-&gt;nmc_left -= 2 * NFSX_UNSIGNED; \
			(NMC)-&gt;nmc_ptr += 2 * NFSX_UNSIGNED; \
		} <span class="enscript-keyword">else</span> { \
			__tmpptr = &amp;__tmp64; \
			(E) = nfsm_chain_get_opaque_f((NMC), 2 * NFSX_UNSIGNED, (u_char*)__tmpptr); \
			<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		} \
		fxdr_hyper(__tmpptr, &amp;(LVAL)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* get a pointer to the next consecutive bytes in an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_get_opaque_pointer</span>(E, NMC, LEN, PTR) \
	<span class="enscript-keyword">do</span> { \
		uint32_t rndlen; \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		rndlen = nfsm_rndup(LEN); \
		<span class="enscript-keyword">if</span> ((NMC)-&gt;nmc_left &gt;= rndlen) { \
			(PTR) = (<span class="enscript-type">void</span>*)(NMC)-&gt;nmc_ptr; \
			(NMC)-&gt;nmc_left -= rndlen; \
			(NMC)-&gt;nmc_ptr += rndlen; \
		} <span class="enscript-keyword">else</span> { \
			(E) = nfsm_chain_get_opaque_pointer_f((NMC), (LEN), (u_char**)&amp;(PTR)); \
		} \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* copy the next consecutive bytes of opaque data from an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_get_opaque</span>(E, NMC, LEN, PTR) \
	<span class="enscript-keyword">do</span> { \
		uint32_t rndlen; \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		rndlen = nfsm_rndup(LEN); \
		<span class="enscript-keyword">if</span> ((NMC)-&gt;nmc_left &gt;= rndlen) { \
			u_char *__tmpptr = (u_char*)(NMC)-&gt;nmc_ptr; \
			(NMC)-&gt;nmc_left -= rndlen; \
			(NMC)-&gt;nmc_ptr += rndlen; \
			bcopy(__tmpptr, (PTR), (LEN)); \
		} <span class="enscript-keyword">else</span> { \
			(E) = nfsm_chain_get_opaque_f((NMC), (LEN), (u_char*)(PTR)); \
		} \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* get the size of and a pointer to a file handle in an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_get_fh_ptr</span>(E, NMC, VERS, FHP, FHSIZE) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> ((VERS) != NFS_VER2) \
			nfsm_chain_get_32((E), (NMC), (FHSIZE)); \
		<span class="enscript-keyword">else</span> \
			(FHSIZE) = NFSX_V2FH;\
		nfsm_chain_get_opaque_pointer((E), (NMC), (FHSIZE), (FHP));\
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* get the size of and data for a file handle in an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_get_fh</span>(E, NMC, VERS, FHP) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> ((VERS) != NFS_VER2) \
			nfsm_chain_get_32((E), (NMC), (FHP)-&gt;fh_len); \
		<span class="enscript-keyword">else</span> \
			(FHP)-&gt;fh_len = NFSX_V2FH;\
		nfsm_chain_get_opaque((E), (NMC), (uint32_t)(FHP)-&gt;fh_len, (FHP)-&gt;fh_data);\
		<span class="enscript-keyword">if</span> (E) \
			(FHP)-&gt;fh_len = 0;\
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* get an NFS v2 or v3 time from an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_get_time</span>(E, NMC, VERS, TSEC, TNSEC) \
	<span class="enscript-keyword">do</span> { \
		nfsm_chain_get_32((E), (NMC), (TSEC)); \
		nfsm_chain_get_32((E), (NMC), (TNSEC)); \
		<span class="enscript-keyword">if</span> ((E) || ((VERS) != NFS_VER2)) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> ((uint32_t)(TNSEC) == 0xffffffff) \
			(TNSEC) = 0; \
		<span class="enscript-keyword">else</span> \
			(TNSEC) *= 1000; \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* get postop attributes from an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_postop_attr_get</span>(E, NMC, F, VAP) \
	<span class="enscript-keyword">do</span> { \
		(F) = 0; \
		<span class="enscript-keyword">if</span> ((E) || !(NMC)-&gt;nmc_mhead) <span class="enscript-keyword">break</span>; \
		nfsm_chain_get_32((E), (NMC), (F)); \
		<span class="enscript-keyword">if</span> ((E) || !(F)) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> (((E) = nfs_parsefattr((NMC), NFS_VER3, (VAP)))) \
			(F) = 0; \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* update a node's attribute cache with postop attributes from an mbuf chain */</span>
<span class="enscript-comment">/* (F returns whether the attributes were updated or not) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_postop_attr_update_flag</span>(E, NMC, NP, F, X) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-type">struct</span> nfs_vattr ttvattr; \
		nfsm_chain_postop_attr_get((E), (NMC), (F), &amp;ttvattr); \
		<span class="enscript-keyword">if</span> ((E) || !(F)) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> (((E) = nfs_loadattrcache((NP), &amp;ttvattr, (X), 1))) { \
			(F) = 0; \
			<span class="enscript-keyword">break</span>; \
		} \
		<span class="enscript-keyword">if</span> (*(X) == 0) \
			(F) = 0; \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* update a node's attribute cache with postop attributes from an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_postop_attr_update</span>(E, NMC, NP, X) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-type">int</span> __dummy_flag = 0; \
		nfsm_chain_postop_attr_update_flag((E), (NMC), (NP), __dummy_flag, (X)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* get and process NFSv3 WCC data from an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_get_wcc_data</span>(E, NMC, NP, PREMTIME, NEWPOSTATTR, X) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		(E) = nfsm_chain_get_wcc_data_f((NMC), (NP), (PREMTIME), (NEWPOSTATTR), (X)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* update a node's attribute cache with attributes from an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_loadattr</span>(E, NMC, NP, VERS, X) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-type">struct</span> nfs_vattr ttvattr; \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> ((VERS) == NFS_VER4) { \
			(E) = nfs4_parsefattr((NMC), NULL, &amp;ttvattr, NULL, NULL, NULL); \
		} <span class="enscript-keyword">else</span> { \
			(E) = nfs_parsefattr((NMC), (VERS), &amp;ttvattr); \
		} \
		<span class="enscript-keyword">if</span> (!(E) &amp;&amp; (NP)) \
			(E) = nfs_loadattrcache((NP), &amp;ttvattr, (X), 0); \
		NVATTR_CLEANUP(&amp;ttvattr); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* get NFSv4 attr bitmap */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_get_bitmap</span>(E, NMC, B, LEN) \
	<span class="enscript-keyword">do</span> { \
		uint32_t __len = 0, __i; \
		nfsm_chain_get_32((E), (NMC), __len); \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">for</span> (__i=0; __i &lt; MIN(__len, (LEN)); __i++) \
			nfsm_chain_get_32((E), (NMC), (B)[__i]); \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">for</span> (; __i &lt; __len; __i++) \
			nfsm_chain_adv((E), (NMC), NFSX_UNSIGNED); \
		<span class="enscript-keyword">for</span> (; __i &lt; (LEN); __i++) \
			(B)[__i] = 0; \
		(LEN) = __len; \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* get an NFSv4 &quot;stateid&quot; structure from an mbuf chain */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_get_stateid</span>(E, NMC, SID) \
	<span class="enscript-keyword">do</span> { \
		nfsm_chain_get_32((E), (NMC), (SID)-&gt;seqid); \
		nfsm_chain_get_32((E), (NMC), (SID)-&gt;other[0]); \
		nfsm_chain_get_32((E), (NMC), (SID)-&gt;other[1]); \
		nfsm_chain_get_32((E), (NMC), (SID)-&gt;other[2]); \
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_skip_tag</span>(E, NMC) \
	<span class="enscript-keyword">do</span> { \
		uint32_t __val = 0; \
		nfsm_chain_get_32((E), (NMC), __val); \
		nfsm_chain_adv((E), (NMC), nfsm_rndup(__val)); \
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_op_check</span>(E, NMC, OP) \
	<span class="enscript-keyword">do</span> { \
		uint32_t __val = 0; \
		nfsm_chain_get_32((E), (NMC), __val); \
		<span class="enscript-comment">/* [sigh] some implementations return the &quot;illegal&quot; op for unsupported ops */</span> \
		nfsm_assert((E), ((__val == (OP)) || (__val == NFS_OP_ILLEGAL)), EBADRPC); \
		nfsm_chain_get_32((E), (NMC), __val); \
		nfsm_assert((E), (__val == NFS_OK), __val); \
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfsm_chain_check_change_info</span>(E, NMC, DNP) \
	<span class="enscript-keyword">do</span> { \
		uint64_t __ci_before, __ci_after; \
		uint32_t __ci_atomic = 0; \
		nfsm_chain_get_32((E), (NMC), __ci_atomic); \
		nfsm_chain_get_64((E), (NMC), __ci_before); \
		nfsm_chain_get_64((E), (NMC), __ci_after); \
		<span class="enscript-keyword">if</span> ((E) || !(DNP)) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">if</span> (__ci_atomic &amp;&amp; (__ci_before == (DNP)-&gt;n_ncchange)) { \
			(DNP)-&gt;n_ncchange = __ci_after; \
		} <span class="enscript-keyword">else</span> { \
			cache_purge(NFSTOV(DNP)); \
			(DNP)-&gt;n_ncgen++; \
		} \
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE_API_PRIVATE */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _NFS_NFSM_SUBS_H_ */</span>
</pre>
<hr />
</body></html>