<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nfs_vnops.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nfs_vnops.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfs_vnops.c	8.16 (Berkeley) 5/27/95
 * FreeBSD-Id: nfs_vnops.c,v 1.72 1997/11/07 09:20:48 phk Exp $
 */</span>


<span class="enscript-comment">/*
 * vnode op calls for Sun NFS version 2 and 3
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dirent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lockf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/attr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vfs/vfs_support.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/fifofs/fifo.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/rpcv2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_gss.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsmount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/xdr_subs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsm_subs.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_VNOP_DBG</span>(...) NFS_DBG(NFS_FAC_VNOP, 7, ## __VA_ARGS__)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_READLINK_NOCACHE</span> 0

<span class="enscript-comment">/*
 * NFS vnode ops
 */</span>
<span class="enscript-type">int</span>	nfs_vnop_lookup(<span class="enscript-type">struct</span> vnop_lookup_args *);
<span class="enscript-type">int</span>	nfsspec_vnop_read(<span class="enscript-type">struct</span> vnop_read_args *);
<span class="enscript-type">int</span>	nfsspec_vnop_write(<span class="enscript-type">struct</span> vnop_write_args *);
<span class="enscript-type">int</span>	nfsspec_vnop_close(<span class="enscript-type">struct</span> vnop_close_args *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FIFO</span>
<span class="enscript-type">int</span>	nfsfifo_vnop_read(<span class="enscript-type">struct</span> vnop_read_args *);
<span class="enscript-type">int</span>	nfsfifo_vnop_write(<span class="enscript-type">struct</span> vnop_write_args *);
<span class="enscript-type">int</span>	nfsfifo_vnop_close(<span class="enscript-type">struct</span> vnop_close_args *);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">int</span>	nfs_vnop_ioctl(<span class="enscript-type">struct</span> vnop_ioctl_args *);
<span class="enscript-type">int</span>	nfs_vnop_select(<span class="enscript-type">struct</span> vnop_select_args *);
<span class="enscript-type">int</span>	nfs_vnop_setattr(<span class="enscript-type">struct</span> vnop_setattr_args *);
<span class="enscript-type">int</span>	nfs_vnop_fsync(<span class="enscript-type">struct</span> vnop_fsync_args *);
<span class="enscript-type">int</span>	nfs_vnop_rename(<span class="enscript-type">struct</span> vnop_rename_args *);
<span class="enscript-type">int</span>	nfs_vnop_readdir(<span class="enscript-type">struct</span> vnop_readdir_args *);
<span class="enscript-type">int</span>	nfs_vnop_readlink(<span class="enscript-type">struct</span> vnop_readlink_args *);
<span class="enscript-type">int</span>	nfs_vnop_pathconf(<span class="enscript-type">struct</span> vnop_pathconf_args *);
<span class="enscript-type">int</span>	nfs_vnop_pagein(<span class="enscript-type">struct</span> vnop_pagein_args *);
<span class="enscript-type">int</span>	nfs_vnop_pageout(<span class="enscript-type">struct</span> vnop_pageout_args *);
<span class="enscript-type">int</span>	nfs_vnop_blktooff(<span class="enscript-type">struct</span> vnop_blktooff_args *);
<span class="enscript-type">int</span>	nfs_vnop_offtoblk(<span class="enscript-type">struct</span> vnop_offtoblk_args *);
<span class="enscript-type">int</span>	nfs_vnop_blockmap(<span class="enscript-type">struct</span> vnop_blockmap_args *);
<span class="enscript-type">int</span>	nfs_vnop_monitor(<span class="enscript-type">struct</span> vnop_monitor_args *);

<span class="enscript-type">int</span>	nfs3_vnop_create(<span class="enscript-type">struct</span> vnop_create_args *);
<span class="enscript-type">int</span>	nfs3_vnop_mknod(<span class="enscript-type">struct</span> vnop_mknod_args *);
<span class="enscript-type">int</span>	nfs3_vnop_getattr(<span class="enscript-type">struct</span> vnop_getattr_args *);
<span class="enscript-type">int</span>	nfs3_vnop_link(<span class="enscript-type">struct</span> vnop_link_args *);
<span class="enscript-type">int</span>	nfs3_vnop_mkdir(<span class="enscript-type">struct</span> vnop_mkdir_args *);
<span class="enscript-type">int</span>	nfs3_vnop_rmdir(<span class="enscript-type">struct</span> vnop_rmdir_args *);
<span class="enscript-type">int</span>	nfs3_vnop_symlink(<span class="enscript-type">struct</span> vnop_symlink_args *);

vnop_t **nfsv2_vnodeop_p;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> vnodeopv_entry_desc nfsv2_vnodeop_entries[] = {
	{ &amp;vnop_default_desc, (vnop_t *)vn_default_error },
	{ &amp;vnop_lookup_desc, (vnop_t *)nfs_vnop_lookup },	<span class="enscript-comment">/* lookup */</span>
	{ &amp;vnop_create_desc, (vnop_t *)nfs3_vnop_create },	<span class="enscript-comment">/* create */</span>
	{ &amp;vnop_mknod_desc, (vnop_t *)nfs3_vnop_mknod },	<span class="enscript-comment">/* mknod */</span>
	{ &amp;vnop_open_desc, (vnop_t *)nfs_vnop_open },		<span class="enscript-comment">/* open */</span>
	{ &amp;vnop_close_desc, (vnop_t *)nfs_vnop_close },		<span class="enscript-comment">/* close */</span>
	{ &amp;vnop_access_desc, (vnop_t *)nfs_vnop_access },	<span class="enscript-comment">/* access */</span>
	{ &amp;vnop_getattr_desc, (vnop_t *)nfs3_vnop_getattr },	<span class="enscript-comment">/* getattr */</span>
	{ &amp;vnop_setattr_desc, (vnop_t *)nfs_vnop_setattr },	<span class="enscript-comment">/* setattr */</span>
	{ &amp;vnop_read_desc, (vnop_t *)nfs_vnop_read },		<span class="enscript-comment">/* read */</span>
	{ &amp;vnop_write_desc, (vnop_t *)nfs_vnop_write },		<span class="enscript-comment">/* write */</span>
	{ &amp;vnop_ioctl_desc, (vnop_t *)nfs_vnop_ioctl },		<span class="enscript-comment">/* ioctl */</span>
	{ &amp;vnop_select_desc, (vnop_t *)nfs_vnop_select },	<span class="enscript-comment">/* select */</span>
	{ &amp;vnop_revoke_desc, (vnop_t *)nfs_vnop_revoke },	<span class="enscript-comment">/* revoke */</span>
	{ &amp;vnop_mmap_desc, (vnop_t *)nfs_vnop_mmap },		<span class="enscript-comment">/* mmap */</span>
	{ &amp;vnop_mnomap_desc, (vnop_t *)nfs_vnop_mnomap },	<span class="enscript-comment">/* mnomap */</span>
	{ &amp;vnop_fsync_desc, (vnop_t *)nfs_vnop_fsync },		<span class="enscript-comment">/* fsync */</span>
	{ &amp;vnop_remove_desc, (vnop_t *)nfs_vnop_remove },	<span class="enscript-comment">/* remove */</span>
	{ &amp;vnop_link_desc, (vnop_t *)nfs3_vnop_link },		<span class="enscript-comment">/* link */</span>
	{ &amp;vnop_rename_desc, (vnop_t *)nfs_vnop_rename },	<span class="enscript-comment">/* rename */</span>
	{ &amp;vnop_mkdir_desc, (vnop_t *)nfs3_vnop_mkdir },	<span class="enscript-comment">/* mkdir */</span>
	{ &amp;vnop_rmdir_desc, (vnop_t *)nfs3_vnop_rmdir },	<span class="enscript-comment">/* rmdir */</span>
	{ &amp;vnop_symlink_desc, (vnop_t *)nfs3_vnop_symlink },	<span class="enscript-comment">/* symlink */</span>
	{ &amp;vnop_readdir_desc, (vnop_t *)nfs_vnop_readdir },	<span class="enscript-comment">/* readdir */</span>
	{ &amp;vnop_readlink_desc, (vnop_t *)nfs_vnop_readlink },	<span class="enscript-comment">/* readlink */</span>
	{ &amp;vnop_inactive_desc, (vnop_t *)nfs_vnop_inactive },	<span class="enscript-comment">/* inactive */</span>
	{ &amp;vnop_reclaim_desc, (vnop_t *)nfs_vnop_reclaim },	<span class="enscript-comment">/* reclaim */</span>
	{ &amp;vnop_strategy_desc, (vnop_t *)err_strategy },	<span class="enscript-comment">/* strategy */</span>
	{ &amp;vnop_pathconf_desc, (vnop_t *)nfs_vnop_pathconf },	<span class="enscript-comment">/* pathconf */</span>
	{ &amp;vnop_advlock_desc, (vnop_t *)nfs_vnop_advlock },	<span class="enscript-comment">/* advlock */</span>
	{ &amp;vnop_bwrite_desc, (vnop_t *)err_bwrite },		<span class="enscript-comment">/* bwrite */</span>
	{ &amp;vnop_pagein_desc, (vnop_t *)nfs_vnop_pagein },	<span class="enscript-comment">/* Pagein */</span>
	{ &amp;vnop_pageout_desc, (vnop_t *)nfs_vnop_pageout },	<span class="enscript-comment">/* Pageout */</span>
	{ &amp;vnop_copyfile_desc, (vnop_t *)err_copyfile },	<span class="enscript-comment">/* Copyfile */</span>
	{ &amp;vnop_blktooff_desc, (vnop_t *)nfs_vnop_blktooff },	<span class="enscript-comment">/* blktooff */</span>
	{ &amp;vnop_offtoblk_desc, (vnop_t *)nfs_vnop_offtoblk },	<span class="enscript-comment">/* offtoblk */</span>
	{ &amp;vnop_blockmap_desc, (vnop_t *)nfs_vnop_blockmap },	<span class="enscript-comment">/* blockmap */</span>
	{ &amp;vnop_monitor_desc, (vnop_t *)nfs_vnop_monitor },	<span class="enscript-comment">/* monitor */</span>
	{ NULL, NULL }
};
<span class="enscript-type">struct</span> vnodeopv_desc nfsv2_vnodeop_opv_desc =
	{ &amp;nfsv2_vnodeop_p, nfsv2_vnodeop_entries };

vnop_t **nfsv4_vnodeop_p;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> vnodeopv_entry_desc nfsv4_vnodeop_entries[] = {
	{ &amp;vnop_default_desc, (vnop_t *)vn_default_error },
	{ &amp;vnop_lookup_desc, (vnop_t *)nfs_vnop_lookup },	<span class="enscript-comment">/* lookup */</span>
	{ &amp;vnop_create_desc, (vnop_t *)nfs4_vnop_create },	<span class="enscript-comment">/* create */</span>
	{ &amp;vnop_mknod_desc, (vnop_t *)nfs4_vnop_mknod },	<span class="enscript-comment">/* mknod */</span>
	{ &amp;vnop_open_desc, (vnop_t *)nfs_vnop_open },		<span class="enscript-comment">/* open */</span>
	{ &amp;vnop_close_desc, (vnop_t *)nfs_vnop_close },		<span class="enscript-comment">/* close */</span>
	{ &amp;vnop_access_desc, (vnop_t *)nfs_vnop_access },	<span class="enscript-comment">/* access */</span>
	{ &amp;vnop_getattr_desc, (vnop_t *)nfs4_vnop_getattr },	<span class="enscript-comment">/* getattr */</span>
	{ &amp;vnop_setattr_desc, (vnop_t *)nfs_vnop_setattr },	<span class="enscript-comment">/* setattr */</span>
	{ &amp;vnop_read_desc, (vnop_t *)nfs_vnop_read },		<span class="enscript-comment">/* read */</span>
	{ &amp;vnop_write_desc, (vnop_t *)nfs_vnop_write },		<span class="enscript-comment">/* write */</span>
	{ &amp;vnop_ioctl_desc, (vnop_t *)nfs_vnop_ioctl },		<span class="enscript-comment">/* ioctl */</span>
	{ &amp;vnop_select_desc, (vnop_t *)nfs_vnop_select },	<span class="enscript-comment">/* select */</span>
	{ &amp;vnop_revoke_desc, (vnop_t *)nfs_vnop_revoke },	<span class="enscript-comment">/* revoke */</span>
	{ &amp;vnop_mmap_desc, (vnop_t *)nfs_vnop_mmap },		<span class="enscript-comment">/* mmap */</span>
	{ &amp;vnop_mnomap_desc, (vnop_t *)nfs_vnop_mnomap },	<span class="enscript-comment">/* mnomap */</span>
	{ &amp;vnop_fsync_desc, (vnop_t *)nfs_vnop_fsync },		<span class="enscript-comment">/* fsync */</span>
	{ &amp;vnop_remove_desc, (vnop_t *)nfs_vnop_remove },	<span class="enscript-comment">/* remove */</span>
	{ &amp;vnop_link_desc, (vnop_t *)nfs4_vnop_link },		<span class="enscript-comment">/* link */</span>
	{ &amp;vnop_rename_desc, (vnop_t *)nfs_vnop_rename },	<span class="enscript-comment">/* rename */</span>
	{ &amp;vnop_mkdir_desc, (vnop_t *)nfs4_vnop_mkdir },	<span class="enscript-comment">/* mkdir */</span>
	{ &amp;vnop_rmdir_desc, (vnop_t *)nfs4_vnop_rmdir },	<span class="enscript-comment">/* rmdir */</span>
	{ &amp;vnop_symlink_desc, (vnop_t *)nfs4_vnop_symlink },	<span class="enscript-comment">/* symlink */</span>
	{ &amp;vnop_readdir_desc, (vnop_t *)nfs_vnop_readdir },	<span class="enscript-comment">/* readdir */</span>
	{ &amp;vnop_readlink_desc, (vnop_t *)nfs_vnop_readlink },	<span class="enscript-comment">/* readlink */</span>
	{ &amp;vnop_inactive_desc, (vnop_t *)nfs_vnop_inactive },	<span class="enscript-comment">/* inactive */</span>
	{ &amp;vnop_reclaim_desc, (vnop_t *)nfs_vnop_reclaim },	<span class="enscript-comment">/* reclaim */</span>
	{ &amp;vnop_strategy_desc, (vnop_t *)err_strategy },	<span class="enscript-comment">/* strategy */</span>
	{ &amp;vnop_pathconf_desc, (vnop_t *)nfs_vnop_pathconf },	<span class="enscript-comment">/* pathconf */</span>
	{ &amp;vnop_advlock_desc, (vnop_t *)nfs_vnop_advlock },	<span class="enscript-comment">/* advlock */</span>
	{ &amp;vnop_bwrite_desc, (vnop_t *)err_bwrite },		<span class="enscript-comment">/* bwrite */</span>
	{ &amp;vnop_pagein_desc, (vnop_t *)nfs_vnop_pagein },	<span class="enscript-comment">/* Pagein */</span>
	{ &amp;vnop_pageout_desc, (vnop_t *)nfs_vnop_pageout },	<span class="enscript-comment">/* Pageout */</span>
	{ &amp;vnop_copyfile_desc, (vnop_t *)err_copyfile },	<span class="enscript-comment">/* Copyfile */</span>
	{ &amp;vnop_blktooff_desc, (vnop_t *)nfs_vnop_blktooff },	<span class="enscript-comment">/* blktooff */</span>
	{ &amp;vnop_offtoblk_desc, (vnop_t *)nfs_vnop_offtoblk },	<span class="enscript-comment">/* offtoblk */</span>
	{ &amp;vnop_blockmap_desc, (vnop_t *)nfs_vnop_blockmap },	<span class="enscript-comment">/* blockmap */</span>
	{ &amp;vnop_getxattr_desc, (vnop_t *)nfs4_vnop_getxattr },	<span class="enscript-comment">/* getxattr */</span>
	{ &amp;vnop_setxattr_desc, (vnop_t *)nfs4_vnop_setxattr },	<span class="enscript-comment">/* setxattr */</span>
	{ &amp;vnop_removexattr_desc, (vnop_t *)nfs4_vnop_removexattr },<span class="enscript-comment">/* removexattr */</span>
	{ &amp;vnop_listxattr_desc, (vnop_t *)nfs4_vnop_listxattr },<span class="enscript-comment">/* listxattr */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	{ &amp;vnop_getnamedstream_desc, (vnop_t *)nfs4_vnop_getnamedstream },	<span class="enscript-comment">/* getnamedstream */</span>
	{ &amp;vnop_makenamedstream_desc, (vnop_t *)nfs4_vnop_makenamedstream },	<span class="enscript-comment">/* makenamedstream */</span>
	{ &amp;vnop_removenamedstream_desc, (vnop_t *)nfs4_vnop_removenamedstream },<span class="enscript-comment">/* removenamedstream */</span>
#<span class="enscript-reference">endif</span>
	{ &amp;vnop_monitor_desc, (vnop_t *)nfs_vnop_monitor },	<span class="enscript-comment">/* monitor */</span>
	{ NULL, NULL }
};
<span class="enscript-type">struct</span> vnodeopv_desc nfsv4_vnodeop_opv_desc =
	{ &amp;nfsv4_vnodeop_p, nfsv4_vnodeop_entries };

<span class="enscript-comment">/*
 * Special device vnode ops
 */</span>
vnop_t **spec_nfsv2nodeop_p;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> vnodeopv_entry_desc spec_nfsv2nodeop_entries[] = {
	{ &amp;vnop_default_desc, (vnop_t *)vn_default_error },
	{ &amp;vnop_lookup_desc, (vnop_t *)spec_lookup },		<span class="enscript-comment">/* lookup */</span>
	{ &amp;vnop_create_desc, (vnop_t *)spec_create },		<span class="enscript-comment">/* create */</span>
	{ &amp;vnop_mknod_desc, (vnop_t *)spec_mknod },		<span class="enscript-comment">/* mknod */</span>
	{ &amp;vnop_open_desc, (vnop_t *)spec_open },		<span class="enscript-comment">/* open */</span>
	{ &amp;vnop_close_desc, (vnop_t *)nfsspec_vnop_close },	<span class="enscript-comment">/* close */</span>
	{ &amp;vnop_getattr_desc, (vnop_t *)nfs3_vnop_getattr },	<span class="enscript-comment">/* getattr */</span>
	{ &amp;vnop_setattr_desc, (vnop_t *)nfs_vnop_setattr },	<span class="enscript-comment">/* setattr */</span>
	{ &amp;vnop_read_desc, (vnop_t *)nfsspec_vnop_read },	<span class="enscript-comment">/* read */</span>
	{ &amp;vnop_write_desc, (vnop_t *)nfsspec_vnop_write },	<span class="enscript-comment">/* write */</span>
	{ &amp;vnop_ioctl_desc, (vnop_t *)spec_ioctl },		<span class="enscript-comment">/* ioctl */</span>
	{ &amp;vnop_select_desc, (vnop_t *)spec_select },		<span class="enscript-comment">/* select */</span>
	{ &amp;vnop_revoke_desc, (vnop_t *)spec_revoke },		<span class="enscript-comment">/* revoke */</span>
	{ &amp;vnop_mmap_desc, (vnop_t *)spec_mmap },		<span class="enscript-comment">/* mmap */</span>
	{ &amp;vnop_fsync_desc, (vnop_t *)nfs_vnop_fsync },		<span class="enscript-comment">/* fsync */</span>
	{ &amp;vnop_remove_desc, (vnop_t *)spec_remove },		<span class="enscript-comment">/* remove */</span>
	{ &amp;vnop_link_desc, (vnop_t *)spec_link },		<span class="enscript-comment">/* link */</span>
	{ &amp;vnop_rename_desc, (vnop_t *)spec_rename },		<span class="enscript-comment">/* rename */</span>
	{ &amp;vnop_mkdir_desc, (vnop_t *)spec_mkdir },		<span class="enscript-comment">/* mkdir */</span>
	{ &amp;vnop_rmdir_desc, (vnop_t *)spec_rmdir },		<span class="enscript-comment">/* rmdir */</span>
	{ &amp;vnop_symlink_desc, (vnop_t *)spec_symlink },		<span class="enscript-comment">/* symlink */</span>
	{ &amp;vnop_readdir_desc, (vnop_t *)spec_readdir },		<span class="enscript-comment">/* readdir */</span>
	{ &amp;vnop_readlink_desc, (vnop_t *)spec_readlink },	<span class="enscript-comment">/* readlink */</span>
	{ &amp;vnop_inactive_desc, (vnop_t *)nfs_vnop_inactive },	<span class="enscript-comment">/* inactive */</span>
	{ &amp;vnop_reclaim_desc, (vnop_t *)nfs_vnop_reclaim },	<span class="enscript-comment">/* reclaim */</span>
	{ &amp;vnop_strategy_desc, (vnop_t *)spec_strategy },	<span class="enscript-comment">/* strategy */</span>
	{ &amp;vnop_pathconf_desc, (vnop_t *)spec_pathconf },	<span class="enscript-comment">/* pathconf */</span>
	{ &amp;vnop_advlock_desc, (vnop_t *)spec_advlock },		<span class="enscript-comment">/* advlock */</span>
	{ &amp;vnop_bwrite_desc, (vnop_t *)vn_bwrite },		<span class="enscript-comment">/* bwrite */</span>
	{ &amp;vnop_pagein_desc, (vnop_t *)nfs_vnop_pagein },	<span class="enscript-comment">/* Pagein */</span>
	{ &amp;vnop_pageout_desc, (vnop_t *)nfs_vnop_pageout },	<span class="enscript-comment">/* Pageout */</span>
	{ &amp;vnop_blktooff_desc, (vnop_t *)nfs_vnop_blktooff },	<span class="enscript-comment">/* blktooff */</span>
	{ &amp;vnop_offtoblk_desc, (vnop_t *)nfs_vnop_offtoblk },	<span class="enscript-comment">/* offtoblk */</span>
	{ &amp;vnop_blockmap_desc, (vnop_t *)nfs_vnop_blockmap },	<span class="enscript-comment">/* blockmap */</span>
	{ &amp;vnop_monitor_desc, (vnop_t *)nfs_vnop_monitor },	<span class="enscript-comment">/* monitor */</span>
	{ NULL, NULL }
};
<span class="enscript-type">struct</span> vnodeopv_desc spec_nfsv2nodeop_opv_desc =
	{ &amp;spec_nfsv2nodeop_p, spec_nfsv2nodeop_entries };
vnop_t **spec_nfsv4nodeop_p;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> vnodeopv_entry_desc spec_nfsv4nodeop_entries[] = {
	{ &amp;vnop_default_desc, (vnop_t *)vn_default_error },
	{ &amp;vnop_lookup_desc, (vnop_t *)spec_lookup },		<span class="enscript-comment">/* lookup */</span>
	{ &amp;vnop_create_desc, (vnop_t *)spec_create },		<span class="enscript-comment">/* create */</span>
	{ &amp;vnop_mknod_desc, (vnop_t *)spec_mknod },		<span class="enscript-comment">/* mknod */</span>
	{ &amp;vnop_open_desc, (vnop_t *)spec_open },		<span class="enscript-comment">/* open */</span>
	{ &amp;vnop_close_desc, (vnop_t *)nfsspec_vnop_close },	<span class="enscript-comment">/* close */</span>
	{ &amp;vnop_getattr_desc, (vnop_t *)nfs4_vnop_getattr },	<span class="enscript-comment">/* getattr */</span>
	{ &amp;vnop_setattr_desc, (vnop_t *)nfs_vnop_setattr },	<span class="enscript-comment">/* setattr */</span>
	{ &amp;vnop_read_desc, (vnop_t *)nfsspec_vnop_read },	<span class="enscript-comment">/* read */</span>
	{ &amp;vnop_write_desc, (vnop_t *)nfsspec_vnop_write },	<span class="enscript-comment">/* write */</span>
	{ &amp;vnop_ioctl_desc, (vnop_t *)spec_ioctl },		<span class="enscript-comment">/* ioctl */</span>
	{ &amp;vnop_select_desc, (vnop_t *)spec_select },		<span class="enscript-comment">/* select */</span>
	{ &amp;vnop_revoke_desc, (vnop_t *)spec_revoke },		<span class="enscript-comment">/* revoke */</span>
	{ &amp;vnop_mmap_desc, (vnop_t *)spec_mmap },		<span class="enscript-comment">/* mmap */</span>
	{ &amp;vnop_fsync_desc, (vnop_t *)nfs_vnop_fsync },		<span class="enscript-comment">/* fsync */</span>
	{ &amp;vnop_remove_desc, (vnop_t *)spec_remove },		<span class="enscript-comment">/* remove */</span>
	{ &amp;vnop_link_desc, (vnop_t *)spec_link },		<span class="enscript-comment">/* link */</span>
	{ &amp;vnop_rename_desc, (vnop_t *)spec_rename },		<span class="enscript-comment">/* rename */</span>
	{ &amp;vnop_mkdir_desc, (vnop_t *)spec_mkdir },		<span class="enscript-comment">/* mkdir */</span>
	{ &amp;vnop_rmdir_desc, (vnop_t *)spec_rmdir },		<span class="enscript-comment">/* rmdir */</span>
	{ &amp;vnop_symlink_desc, (vnop_t *)spec_symlink },		<span class="enscript-comment">/* symlink */</span>
	{ &amp;vnop_readdir_desc, (vnop_t *)spec_readdir },		<span class="enscript-comment">/* readdir */</span>
	{ &amp;vnop_readlink_desc, (vnop_t *)spec_readlink },	<span class="enscript-comment">/* readlink */</span>
	{ &amp;vnop_inactive_desc, (vnop_t *)nfs_vnop_inactive },	<span class="enscript-comment">/* inactive */</span>
	{ &amp;vnop_reclaim_desc, (vnop_t *)nfs_vnop_reclaim },	<span class="enscript-comment">/* reclaim */</span>
	{ &amp;vnop_strategy_desc, (vnop_t *)spec_strategy },	<span class="enscript-comment">/* strategy */</span>
	{ &amp;vnop_pathconf_desc, (vnop_t *)spec_pathconf },	<span class="enscript-comment">/* pathconf */</span>
	{ &amp;vnop_advlock_desc, (vnop_t *)spec_advlock },		<span class="enscript-comment">/* advlock */</span>
	{ &amp;vnop_bwrite_desc, (vnop_t *)vn_bwrite },		<span class="enscript-comment">/* bwrite */</span>
	{ &amp;vnop_pagein_desc, (vnop_t *)nfs_vnop_pagein },	<span class="enscript-comment">/* Pagein */</span>
	{ &amp;vnop_pageout_desc, (vnop_t *)nfs_vnop_pageout },	<span class="enscript-comment">/* Pageout */</span>
	{ &amp;vnop_blktooff_desc, (vnop_t *)nfs_vnop_blktooff },	<span class="enscript-comment">/* blktooff */</span>
	{ &amp;vnop_offtoblk_desc, (vnop_t *)nfs_vnop_offtoblk },	<span class="enscript-comment">/* offtoblk */</span>
	{ &amp;vnop_blockmap_desc, (vnop_t *)nfs_vnop_blockmap },	<span class="enscript-comment">/* blockmap */</span>
	{ &amp;vnop_getxattr_desc, (vnop_t *)nfs4_vnop_getxattr },	<span class="enscript-comment">/* getxattr */</span>
	{ &amp;vnop_setxattr_desc, (vnop_t *)nfs4_vnop_setxattr },	<span class="enscript-comment">/* setxattr */</span>
	{ &amp;vnop_removexattr_desc, (vnop_t *)nfs4_vnop_removexattr },<span class="enscript-comment">/* removexattr */</span>
	{ &amp;vnop_listxattr_desc, (vnop_t *)nfs4_vnop_listxattr },<span class="enscript-comment">/* listxattr */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	{ &amp;vnop_getnamedstream_desc, (vnop_t *)nfs4_vnop_getnamedstream },	<span class="enscript-comment">/* getnamedstream */</span>
	{ &amp;vnop_makenamedstream_desc, (vnop_t *)nfs4_vnop_makenamedstream },	<span class="enscript-comment">/* makenamedstream */</span>
	{ &amp;vnop_removenamedstream_desc, (vnop_t *)nfs4_vnop_removenamedstream },<span class="enscript-comment">/* removenamedstream */</span>
#<span class="enscript-reference">endif</span>
	{ &amp;vnop_monitor_desc, (vnop_t *)nfs_vnop_monitor },	<span class="enscript-comment">/* monitor */</span>
	{ NULL, NULL }
};
<span class="enscript-type">struct</span> vnodeopv_desc spec_nfsv4nodeop_opv_desc =
	{ &amp;spec_nfsv4nodeop_p, spec_nfsv4nodeop_entries };

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FIFO</span>
vnop_t **fifo_nfsv2nodeop_p;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> vnodeopv_entry_desc fifo_nfsv2nodeop_entries[] = {
	{ &amp;vnop_default_desc, (vnop_t *)vn_default_error },
	{ &amp;vnop_lookup_desc, (vnop_t *)fifo_lookup },		<span class="enscript-comment">/* lookup */</span>
	{ &amp;vnop_create_desc, (vnop_t *)fifo_create },		<span class="enscript-comment">/* create */</span>
	{ &amp;vnop_mknod_desc, (vnop_t *)fifo_mknod },		<span class="enscript-comment">/* mknod */</span>
	{ &amp;vnop_open_desc, (vnop_t *)fifo_open },		<span class="enscript-comment">/* open */</span>
	{ &amp;vnop_close_desc, (vnop_t *)nfsfifo_vnop_close },	<span class="enscript-comment">/* close */</span>
	{ &amp;vnop_getattr_desc, (vnop_t *)nfs3_vnop_getattr },	<span class="enscript-comment">/* getattr */</span>
	{ &amp;vnop_setattr_desc, (vnop_t *)nfs_vnop_setattr },	<span class="enscript-comment">/* setattr */</span>
	{ &amp;vnop_read_desc, (vnop_t *)nfsfifo_vnop_read },	<span class="enscript-comment">/* read */</span>
	{ &amp;vnop_write_desc, (vnop_t *)nfsfifo_vnop_write },	<span class="enscript-comment">/* write */</span>
	{ &amp;vnop_ioctl_desc, (vnop_t *)fifo_ioctl },		<span class="enscript-comment">/* ioctl */</span>
	{ &amp;vnop_select_desc, (vnop_t *)fifo_select },		<span class="enscript-comment">/* select */</span>
	{ &amp;vnop_revoke_desc, (vnop_t *)fifo_revoke },		<span class="enscript-comment">/* revoke */</span>
	{ &amp;vnop_mmap_desc, (vnop_t *)fifo_mmap },		<span class="enscript-comment">/* mmap */</span>
	{ &amp;vnop_fsync_desc, (vnop_t *)nfs_vnop_fsync },		<span class="enscript-comment">/* fsync */</span>
	{ &amp;vnop_remove_desc, (vnop_t *)fifo_remove },		<span class="enscript-comment">/* remove */</span>
	{ &amp;vnop_link_desc, (vnop_t *)fifo_link },		<span class="enscript-comment">/* link */</span>
	{ &amp;vnop_rename_desc, (vnop_t *)fifo_rename },		<span class="enscript-comment">/* rename */</span>
	{ &amp;vnop_mkdir_desc, (vnop_t *)fifo_mkdir },		<span class="enscript-comment">/* mkdir */</span>
	{ &amp;vnop_rmdir_desc, (vnop_t *)fifo_rmdir },		<span class="enscript-comment">/* rmdir */</span>
	{ &amp;vnop_symlink_desc, (vnop_t *)fifo_symlink },		<span class="enscript-comment">/* symlink */</span>
	{ &amp;vnop_readdir_desc, (vnop_t *)fifo_readdir },		<span class="enscript-comment">/* readdir */</span>
	{ &amp;vnop_readlink_desc, (vnop_t *)fifo_readlink },	<span class="enscript-comment">/* readlink */</span>
	{ &amp;vnop_inactive_desc, (vnop_t *)nfs_vnop_inactive },	<span class="enscript-comment">/* inactive */</span>
	{ &amp;vnop_reclaim_desc, (vnop_t *)nfs_vnop_reclaim },	<span class="enscript-comment">/* reclaim */</span>
	{ &amp;vnop_strategy_desc, (vnop_t *)fifo_strategy },	<span class="enscript-comment">/* strategy */</span>
	{ &amp;vnop_pathconf_desc, (vnop_t *)fifo_pathconf },	<span class="enscript-comment">/* pathconf */</span>
	{ &amp;vnop_advlock_desc, (vnop_t *)fifo_advlock },		<span class="enscript-comment">/* advlock */</span>
	{ &amp;vnop_bwrite_desc, (vnop_t *)vn_bwrite },		<span class="enscript-comment">/* bwrite */</span>
	{ &amp;vnop_pagein_desc, (vnop_t *)nfs_vnop_pagein },	<span class="enscript-comment">/* Pagein */</span>
	{ &amp;vnop_pageout_desc, (vnop_t *)nfs_vnop_pageout },	<span class="enscript-comment">/* Pageout */</span>
	{ &amp;vnop_blktooff_desc, (vnop_t *)nfs_vnop_blktooff },	<span class="enscript-comment">/* blktooff */</span>
	{ &amp;vnop_offtoblk_desc, (vnop_t *)nfs_vnop_offtoblk },	<span class="enscript-comment">/* offtoblk */</span>
	{ &amp;vnop_blockmap_desc, (vnop_t *)nfs_vnop_blockmap },	<span class="enscript-comment">/* blockmap */</span>
	{ &amp;vnop_monitor_desc, (vnop_t *)nfs_vnop_monitor },	<span class="enscript-comment">/* monitor */</span>
	{ NULL, NULL }
};
<span class="enscript-type">struct</span> vnodeopv_desc fifo_nfsv2nodeop_opv_desc =
	{ &amp;fifo_nfsv2nodeop_p, fifo_nfsv2nodeop_entries };

vnop_t **fifo_nfsv4nodeop_p;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> vnodeopv_entry_desc fifo_nfsv4nodeop_entries[] = {
	{ &amp;vnop_default_desc, (vnop_t *)vn_default_error },
	{ &amp;vnop_lookup_desc, (vnop_t *)fifo_lookup },		<span class="enscript-comment">/* lookup */</span>
	{ &amp;vnop_create_desc, (vnop_t *)fifo_create },		<span class="enscript-comment">/* create */</span>
	{ &amp;vnop_mknod_desc, (vnop_t *)fifo_mknod },		<span class="enscript-comment">/* mknod */</span>
	{ &amp;vnop_open_desc, (vnop_t *)fifo_open },		<span class="enscript-comment">/* open */</span>
	{ &amp;vnop_close_desc, (vnop_t *)nfsfifo_vnop_close },	<span class="enscript-comment">/* close */</span>
	{ &amp;vnop_getattr_desc, (vnop_t *)nfs4_vnop_getattr },	<span class="enscript-comment">/* getattr */</span>
	{ &amp;vnop_setattr_desc, (vnop_t *)nfs_vnop_setattr },	<span class="enscript-comment">/* setattr */</span>
	{ &amp;vnop_read_desc, (vnop_t *)nfsfifo_vnop_read },	<span class="enscript-comment">/* read */</span>
	{ &amp;vnop_write_desc, (vnop_t *)nfsfifo_vnop_write },	<span class="enscript-comment">/* write */</span>
	{ &amp;vnop_ioctl_desc, (vnop_t *)fifo_ioctl },		<span class="enscript-comment">/* ioctl */</span>
	{ &amp;vnop_select_desc, (vnop_t *)fifo_select },		<span class="enscript-comment">/* select */</span>
	{ &amp;vnop_revoke_desc, (vnop_t *)fifo_revoke },		<span class="enscript-comment">/* revoke */</span>
	{ &amp;vnop_mmap_desc, (vnop_t *)fifo_mmap },		<span class="enscript-comment">/* mmap */</span>
	{ &amp;vnop_fsync_desc, (vnop_t *)nfs_vnop_fsync },		<span class="enscript-comment">/* fsync */</span>
	{ &amp;vnop_remove_desc, (vnop_t *)fifo_remove },		<span class="enscript-comment">/* remove */</span>
	{ &amp;vnop_link_desc, (vnop_t *)fifo_link },		<span class="enscript-comment">/* link */</span>
	{ &amp;vnop_rename_desc, (vnop_t *)fifo_rename },		<span class="enscript-comment">/* rename */</span>
	{ &amp;vnop_mkdir_desc, (vnop_t *)fifo_mkdir },		<span class="enscript-comment">/* mkdir */</span>
	{ &amp;vnop_rmdir_desc, (vnop_t *)fifo_rmdir },		<span class="enscript-comment">/* rmdir */</span>
	{ &amp;vnop_symlink_desc, (vnop_t *)fifo_symlink },		<span class="enscript-comment">/* symlink */</span>
	{ &amp;vnop_readdir_desc, (vnop_t *)fifo_readdir },		<span class="enscript-comment">/* readdir */</span>
	{ &amp;vnop_readlink_desc, (vnop_t *)fifo_readlink },	<span class="enscript-comment">/* readlink */</span>
	{ &amp;vnop_inactive_desc, (vnop_t *)nfs_vnop_inactive },	<span class="enscript-comment">/* inactive */</span>
	{ &amp;vnop_reclaim_desc, (vnop_t *)nfs_vnop_reclaim },	<span class="enscript-comment">/* reclaim */</span>
	{ &amp;vnop_strategy_desc, (vnop_t *)fifo_strategy },	<span class="enscript-comment">/* strategy */</span>
	{ &amp;vnop_pathconf_desc, (vnop_t *)fifo_pathconf },	<span class="enscript-comment">/* pathconf */</span>
	{ &amp;vnop_advlock_desc, (vnop_t *)fifo_advlock },		<span class="enscript-comment">/* advlock */</span>
	{ &amp;vnop_bwrite_desc, (vnop_t *)vn_bwrite },		<span class="enscript-comment">/* bwrite */</span>
	{ &amp;vnop_pagein_desc, (vnop_t *)nfs_vnop_pagein },	<span class="enscript-comment">/* Pagein */</span>
	{ &amp;vnop_pageout_desc, (vnop_t *)nfs_vnop_pageout },	<span class="enscript-comment">/* Pageout */</span>
	{ &amp;vnop_blktooff_desc, (vnop_t *)nfs_vnop_blktooff },	<span class="enscript-comment">/* blktooff */</span>
	{ &amp;vnop_offtoblk_desc, (vnop_t *)nfs_vnop_offtoblk },	<span class="enscript-comment">/* offtoblk */</span>
	{ &amp;vnop_blockmap_desc, (vnop_t *)nfs_vnop_blockmap },	<span class="enscript-comment">/* blockmap */</span>
	{ &amp;vnop_getxattr_desc, (vnop_t *)nfs4_vnop_getxattr },	<span class="enscript-comment">/* getxattr */</span>
	{ &amp;vnop_setxattr_desc, (vnop_t *)nfs4_vnop_setxattr },	<span class="enscript-comment">/* setxattr */</span>
	{ &amp;vnop_removexattr_desc, (vnop_t *)nfs4_vnop_removexattr },<span class="enscript-comment">/* removexattr */</span>
	{ &amp;vnop_listxattr_desc, (vnop_t *)nfs4_vnop_listxattr },<span class="enscript-comment">/* listxattr */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
	{ &amp;vnop_getnamedstream_desc, (vnop_t *)nfs4_vnop_getnamedstream },	<span class="enscript-comment">/* getnamedstream */</span>
	{ &amp;vnop_makenamedstream_desc, (vnop_t *)nfs4_vnop_makenamedstream },	<span class="enscript-comment">/* makenamedstream */</span>
	{ &amp;vnop_removenamedstream_desc, (vnop_t *)nfs4_vnop_removenamedstream },<span class="enscript-comment">/* removenamedstream */</span>
#<span class="enscript-reference">endif</span>
	{ &amp;vnop_monitor_desc, (vnop_t *)nfs_vnop_monitor },	<span class="enscript-comment">/* monitor */</span>
	{ NULL, NULL }
};
<span class="enscript-type">struct</span> vnodeopv_desc fifo_nfsv4nodeop_opv_desc =
	{ &amp;fifo_nfsv4nodeop_p, fifo_nfsv4nodeop_entries };
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* FIFO */</span>

<span class="enscript-type">int</span>	nfs_sillyrename(nfsnode_t,nfsnode_t,<span class="enscript-type">struct</span> componentname *,vfs_context_t);
<span class="enscript-type">int</span>	nfs_getattr_internal(nfsnode_t, <span class="enscript-type">struct</span> nfs_vattr *, vfs_context_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_refresh_fh(nfsnode_t, vfs_context_t);

<span class="enscript-comment">/*
 * Find the slot in the access cache for this UID.
 * If adding and no existing slot is found, reuse slots in FIFO order.
 * The index of the next slot to use is kept in the last entry of the n_access array.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_node_access_slot</span>(nfsnode_t np, uid_t uid, <span class="enscript-type">int</span> add)
{
	<span class="enscript-type">int</span> slot;

	<span class="enscript-keyword">for</span> (slot=0; slot &lt; NFS_ACCESS_CACHE_SIZE; slot++)
		<span class="enscript-keyword">if</span> (np-&gt;n_accessuid[slot] == uid)
			<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">if</span> (slot == NFS_ACCESS_CACHE_SIZE) {
		<span class="enscript-keyword">if</span> (!add)
			<span class="enscript-keyword">return</span> (-1);
		slot = np-&gt;n_access[NFS_ACCESS_CACHE_SIZE];
		np-&gt;n_access[NFS_ACCESS_CACHE_SIZE] = (slot + 1) % NFS_ACCESS_CACHE_SIZE;
	}
	<span class="enscript-keyword">return</span> (slot);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_access_rpc</span>(nfsnode_t np, u_int32_t *access, <span class="enscript-type">int</span> rpcflags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, status, slot;
	uint32_t access_result = 0;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> timeval now;
	uid_t uid;

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_build_alloc_init(error, &amp;nmreq, NFSX_FH(NFS_VER3) + NFSX_UNSIGNED);
	nfsm_chain_add_fh(error, &amp;nmreq, NFS_VER3, np-&gt;n_fhp, np-&gt;n_fhsize);
	nfsm_chain_add_32(error, &amp;nmreq, *access);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfs_request2(np, NULL, &amp;nmreq, NFSPROC_ACCESS,
		vfs_context_thread(ctx), vfs_context_ucred(ctx),
		NULL, rpcflags, &amp;nmrep, &amp;xid, &amp;status);
	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_postop_attr_update(error, &amp;nmrep, np, &amp;xid);
	<span class="enscript-keyword">if</span> (!error)
		error = status;
	nfsm_chain_get_32(error, &amp;nmrep, access_result);
	nfsmout_if(error);

	uid = kauth_cred_getuid(vfs_context_ucred(ctx));
	slot = nfs_node_access_slot(np, uid, 1);
	np-&gt;n_accessuid[slot] = uid;
	microuptime(&amp;now);
	np-&gt;n_accessstamp[slot] = now.tv_sec;
	np-&gt;n_access[slot] = access_result;

	<span class="enscript-comment">/*
	 * If we asked for DELETE but didn't get it, the server
	 * may simply not support returning that bit (possible
	 * on UNIX systems).  So, we'll assume that it is OK,
	 * and just let any subsequent delete action fail if it
	 * really isn't deletable.
	 */</span>
	<span class="enscript-keyword">if</span> ((*access &amp; NFS_ACCESS_DELETE) &amp;&amp;
	    !(np-&gt;n_access[slot] &amp; NFS_ACCESS_DELETE))
		np-&gt;n_access[slot] |= NFS_ACCESS_DELETE;
	<span class="enscript-comment">/* &quot;.zfs&quot; subdirectories may erroneously give a denied answer for add/remove */</span>
	<span class="enscript-keyword">if</span> (nfs_access_dotzfs &amp;&amp; (np-&gt;n_flag &amp; NISDOTZFSCHILD))
		np-&gt;n_access[slot] |= (NFS_ACCESS_MODIFY|NFS_ACCESS_EXTEND|NFS_ACCESS_DELETE);
	<span class="enscript-comment">/* pass back the access returned with this request */</span>
	*access = np-&gt;n_access[slot];
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS access vnode op.
 * For NFS version 2, just return ok. File accesses may fail later.
 * For NFS version 3+, use the access RPC to check accessibility. If file
 * permissions are changed on the server, accesses might still fail later.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_access</span>(
	<span class="enscript-type">struct</span> vnop_access_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		int a_action;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t vp = ap-&gt;a_vp;
	<span class="enscript-type">int</span> error = 0, slot, dorpc, rpcflags = 0;
	u_int32_t access, waccess;
	nfsnode_t np = VTONFS(vp);
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> nfsvers;
	<span class="enscript-type">struct</span> timeval now;
	uid_t uid;

	nmp = VTONMP(vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER2) {
		<span class="enscript-keyword">if</span> ((ap-&gt;a_action &amp; KAUTH_VNODE_WRITE_RIGHTS) &amp;&amp;
		    vfs_isrdonly(vnode_mount(vp)))
			<span class="enscript-keyword">return</span> (EROFS);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * For NFS v3, do an access rpc, otherwise you are stuck emulating
	 * ufs_access() locally using the vattr. This may not be correct,
	 * since the server may apply other access criteria such as
	 * client uid--&gt;server uid mapping that we do not know about, but
	 * this is better than just returning anything that is lying about
	 * in the cache.
	 */</span>

	<span class="enscript-comment">/*
	 * Convert KAUTH primitives to NFS access rights.
	 */</span>
	access = 0;
	<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
		<span class="enscript-comment">/* directory */</span>
		<span class="enscript-keyword">if</span> (ap-&gt;a_action &amp;
		    (KAUTH_VNODE_LIST_DIRECTORY |
		    KAUTH_VNODE_READ_EXTATTRIBUTES))
			access |= NFS_ACCESS_READ;
		<span class="enscript-keyword">if</span> (ap-&gt;a_action &amp; KAUTH_VNODE_SEARCH)
			access |= NFS_ACCESS_LOOKUP;
		<span class="enscript-keyword">if</span> (ap-&gt;a_action &amp;
		    (KAUTH_VNODE_ADD_FILE |
		    KAUTH_VNODE_ADD_SUBDIRECTORY))
			access |= NFS_ACCESS_MODIFY | NFS_ACCESS_EXTEND;
		<span class="enscript-keyword">if</span> (ap-&gt;a_action &amp; KAUTH_VNODE_DELETE_CHILD)
			access |= NFS_ACCESS_MODIFY;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* file */</span>
		<span class="enscript-keyword">if</span> (ap-&gt;a_action &amp;
		    (KAUTH_VNODE_READ_DATA |
		    KAUTH_VNODE_READ_EXTATTRIBUTES))
			access |= NFS_ACCESS_READ;
		<span class="enscript-keyword">if</span> (ap-&gt;a_action &amp; KAUTH_VNODE_WRITE_DATA)
			access |= NFS_ACCESS_MODIFY | NFS_ACCESS_EXTEND;
		<span class="enscript-keyword">if</span> (ap-&gt;a_action &amp; KAUTH_VNODE_APPEND_DATA)
			access |= NFS_ACCESS_EXTEND;
		<span class="enscript-keyword">if</span> (ap-&gt;a_action &amp; KAUTH_VNODE_EXECUTE)
			access |= NFS_ACCESS_EXECUTE;
	}
	<span class="enscript-comment">/* common */</span>
	<span class="enscript-keyword">if</span> (ap-&gt;a_action &amp; KAUTH_VNODE_DELETE)
		access |= NFS_ACCESS_DELETE;
	<span class="enscript-keyword">if</span> (ap-&gt;a_action &amp;
	    (KAUTH_VNODE_WRITE_ATTRIBUTES |
	    KAUTH_VNODE_WRITE_EXTATTRIBUTES |
	    KAUTH_VNODE_WRITE_SECURITY))
		access |= NFS_ACCESS_MODIFY;
	<span class="enscript-comment">/* XXX this is pretty dubious */</span>
	<span class="enscript-keyword">if</span> (ap-&gt;a_action &amp; KAUTH_VNODE_CHANGE_OWNER)
		access |= NFS_ACCESS_MODIFY;

	<span class="enscript-comment">/* if caching, always ask for every right */</span>
	<span class="enscript-keyword">if</span> (nfs_access_cache_timeout &gt; 0) {
		waccess = NFS_ACCESS_READ | NFS_ACCESS_MODIFY |
			NFS_ACCESS_EXTEND | NFS_ACCESS_EXECUTE |
			NFS_ACCESS_DELETE | NFS_ACCESS_LOOKUP;
	} <span class="enscript-keyword">else</span> {
		waccess = access;
	}

	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * Does our cached result allow us to give a definite yes to
	 * this request?
	 */</span>
	<span class="enscript-keyword">if</span> (auth_is_kerberized(np-&gt;n_auth) || auth_is_kerberized(nmp-&gt;nm_auth))
		uid = nfs_cred_getasid2uid(vfs_context_ucred(ctx));
	<span class="enscript-keyword">else</span>
		uid = kauth_cred_getuid(vfs_context_ucred(ctx));
	slot = nfs_node_access_slot(np, uid, 0);
	dorpc = 1;
	<span class="enscript-keyword">if</span> (access == 0) {
		<span class="enscript-comment">/* not asking for any rights understood by NFS, so don't bother doing an RPC */</span>
		<span class="enscript-comment">/* OSAddAtomic(1, &amp;nfsstats.accesscache_hits); */</span>
		dorpc = 0;
		waccess = 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (NACCESSVALID(np, slot)) {
		microuptime(&amp;now);
		<span class="enscript-keyword">if</span> (((now.tv_sec &lt; (np-&gt;n_accessstamp[slot] + nfs_access_cache_timeout)) &amp;&amp;
		    ((np-&gt;n_access[slot] &amp; access) == access)) || nfs_use_cache(nmp)) {
			<span class="enscript-comment">/* OSAddAtomic(1, &amp;nfsstats.accesscache_hits); */</span>
			dorpc = 0;
			waccess = np-&gt;n_access[slot];
		}
	}
	nfs_node_unlock(np);
	<span class="enscript-keyword">if</span> (dorpc) {
		<span class="enscript-comment">/* Either a no, or a don't know.  Go to the wire. */</span>
		<span class="enscript-comment">/* OSAddAtomic(1, &amp;nfsstats.accesscache_misses); */</span>

		<span class="enscript-comment">/*
		 * Allow an access call to timeout if we have it cached
		 * so we won't hang if the server isn't responding.
		 */</span>
		<span class="enscript-keyword">if</span> (NACCESSVALID(np, slot))
			rpcflags |= R_SOFT;

		error = nmp-&gt;nm_funcs-&gt;nf_access_rpc(np, &amp;waccess, rpcflags, ctx);

		<span class="enscript-comment">/*
		 * If the server didn't respond return the cached access.
		 */</span>
		<span class="enscript-keyword">if</span> ((error == ETIMEDOUT) &amp;&amp; (rpcflags &amp; R_SOFT)) {
			error = 0;
			waccess = np-&gt;n_access[slot];
		}
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; ((waccess &amp; access) != access))
		error = EACCES;

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * NFS open vnode op
 *
 * Perform various update/invalidation checks and then add the
 * open to the node.  Regular files will have an open file structure
 * on the node and, for NFSv4, perform an OPEN request on the server.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_open</span>(
	<span class="enscript-type">struct</span> vnop_open_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		int a_mode;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t vp = ap-&gt;a_vp;
	nfsnode_t np = VTONFS(vp);
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error, accessMode, denyMode, opened = 0;
	<span class="enscript-type">struct</span> nfs_open_owner *noop = NULL;
	<span class="enscript-type">struct</span> nfs_open_file *nofp = NULL;
	<span class="enscript-type">enum</span> vtype vtype;

	<span class="enscript-keyword">if</span> (!(ap-&gt;a_mode &amp; (FREAD|FWRITE)))
		<span class="enscript-keyword">return</span> (EINVAL);

	nmp = VTONMP(vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE)
		<span class="enscript-keyword">return</span> (EIO);

	vtype = vnode_vtype(vp);
	<span class="enscript-keyword">if</span> ((vtype != VREG) &amp;&amp; (vtype != VDIR) &amp;&amp; (vtype != VLNK))
		<span class="enscript-keyword">return</span> (EACCES);

	<span class="enscript-comment">/* First, check if we need to update/invalidate */</span>
	<span class="enscript-keyword">if</span> (ISSET(np-&gt;n_flag, NUPDATESIZE))
		nfs_data_update_size(np, 0);
	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np)))
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NNEEDINVALIDATE) {
		np-&gt;n_flag &amp;= ~NNEEDINVALIDATE;
		<span class="enscript-keyword">if</span> (vtype == VDIR)
			nfs_invaldir(np);
		nfs_node_unlock(np);
		nfs_vinvalbuf(vp, V_SAVE|V_IGNORE_WRITEERR, ctx, 1);
		<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np)))
			<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (vtype == VREG)
		np-&gt;n_lastrahead = -1;
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NMODIFIED) {
		<span class="enscript-keyword">if</span> (vtype == VDIR)
			nfs_invaldir(np);
		nfs_node_unlock(np);
		<span class="enscript-keyword">if</span> ((error = nfs_vinvalbuf(vp, V_SAVE|V_IGNORE_WRITEERR, ctx, 1)))
			<span class="enscript-keyword">return</span> (error);
	} <span class="enscript-keyword">else</span> {
		nfs_node_unlock(np);
	}

	<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
	<span class="enscript-keyword">if</span> ((error = nfs_getattr(np, NULL, ctx, NGA_UNCACHED)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (vtype != VREG) {
		<span class="enscript-comment">/* Just mark that it was opened */</span>
		lck_mtx_lock(&amp;np-&gt;n_openlock);
		np-&gt;n_openrefcnt++;
		lck_mtx_unlock(&amp;np-&gt;n_openlock);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* mode contains some combination of: FREAD, FWRITE, O_SHLOCK, O_EXLOCK */</span>
	accessMode = 0;
	<span class="enscript-keyword">if</span> (ap-&gt;a_mode &amp; FREAD)
		accessMode |= NFS_OPEN_SHARE_ACCESS_READ;
	<span class="enscript-keyword">if</span> (ap-&gt;a_mode &amp; FWRITE)
		accessMode |= NFS_OPEN_SHARE_ACCESS_WRITE;
	<span class="enscript-keyword">if</span> (ap-&gt;a_mode &amp; O_EXLOCK)
		denyMode = NFS_OPEN_SHARE_DENY_BOTH;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ap-&gt;a_mode &amp; O_SHLOCK)
		denyMode = NFS_OPEN_SHARE_DENY_WRITE;
	<span class="enscript-keyword">else</span>
		denyMode = NFS_OPEN_SHARE_DENY_NONE;
	<span class="enscript-comment">// XXX don't do deny modes just yet (and never do it for !v4)
</span>	denyMode = NFS_OPEN_SHARE_DENY_NONE;

	noop = nfs_open_owner_find(nmp, vfs_context_ucred(ctx), 1);
	<span class="enscript-keyword">if</span> (!noop)
		<span class="enscript-keyword">return</span> (ENOMEM);

<span class="enscript-reference">restart</span>:
	error = nfs_mount_state_in_use_start(nmp, vfs_context_thread(ctx));
	<span class="enscript-keyword">if</span> (error) {
		nfs_open_owner_rele(noop);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
		error = EIO;
		nfs_mount_state_in_use_end(nmp, 0);
		nfs_open_owner_rele(noop);
		<span class="enscript-keyword">return</span> (error);
	}

	error = nfs_open_file_find(np, noop, &amp;nofp, accessMode, denyMode, 1);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST)) {
		NP(np, <span class="enscript-string">&quot;nfs_vnop_open: LOST %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
		error = EIO;
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN)) {
		nfs_mount_state_in_use_end(nmp, 0);
		error = nfs4_reopen(nofp, vfs_context_thread(ctx));
		nofp = NULL;
		<span class="enscript-keyword">if</span> (!error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}
	<span class="enscript-keyword">if</span> (!error)
		error = nfs_open_file_set_busy(nofp, vfs_context_thread(ctx));
	<span class="enscript-keyword">if</span> (error) {
		nofp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &lt; NFS_VER4) {
		<span class="enscript-comment">/*
		 * NFS v2/v3 opens are always allowed - so just add it.
		 */</span>
		nfs_open_file_add_open(nofp, accessMode, denyMode, 0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * If we just created the file and the modes match, then we simply use
	 * the open performed in the create.  Otherwise, send the request.
	 */</span>
	<span class="enscript-keyword">if</span> ((nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_CREATE) &amp;&amp;
	    (nofp-&gt;nof_creator == current_thread()) &amp;&amp;
	    (accessMode == NFS_OPEN_SHARE_ACCESS_BOTH) &amp;&amp;
	    (denyMode == NFS_OPEN_SHARE_DENY_NONE)) {
		nofp-&gt;nof_flags &amp;= ~NFS_OPEN_FILE_CREATE;
		nofp-&gt;nof_creator = NULL;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (!opened)
			error = nfs4_open(np, nofp, accessMode, denyMode, ctx);
		<span class="enscript-keyword">if</span> ((error == EACCES) &amp;&amp; (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_CREATE) &amp;&amp;
		    (nofp-&gt;nof_creator == current_thread())) {
			<span class="enscript-comment">/*
			 * Ugh.  This can happen if we just created the file with read-only
			 * perms and we're trying to open it for real with different modes
			 * (e.g. write-only or with a deny mode) and the server decides to
			 * not allow the second open because of the read-only perms.
			 * The best we can do is to just use the create's open.
			 * We may have access we don't need or we may not have a requested
			 * deny mode.  We may log complaints later, but we'll try to avoid it.
			 */</span>
			<span class="enscript-keyword">if</span> (denyMode != NFS_OPEN_SHARE_DENY_NONE)
				NP(np, <span class="enscript-string">&quot;nfs_vnop_open: deny mode foregone on create, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
			nofp-&gt;nof_creator = NULL;
			error = 0;
		}
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		opened = 1;
		<span class="enscript-comment">/*
		 * If we had just created the file, we already had it open.
		 * If the actual open mode is less than what we grabbed at
		 * create time, then we'll downgrade the open here.
		 */</span>
		<span class="enscript-keyword">if</span> ((nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_CREATE) &amp;&amp;
		    (nofp-&gt;nof_creator == current_thread())) {
			error = nfs_close(np, nofp, NFS_OPEN_SHARE_ACCESS_BOTH, NFS_OPEN_SHARE_DENY_NONE, ctx);
			<span class="enscript-keyword">if</span> (error)
				NP(np, <span class="enscript-string">&quot;nfs_vnop_open: create close error %d, %d&quot;</span>, error, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
			<span class="enscript-keyword">if</span> (!nfs_mount_state_error_should_restart(error)) {
				error = 0;
				nofp-&gt;nof_flags &amp;= ~NFS_OPEN_FILE_CREATE;
			}
		}
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (nofp)
		nfs_open_file_clear_busy(nofp);
	<span class="enscript-keyword">if</span> (nfs_mount_state_in_use_end(nmp, error)) {
		nofp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}
	<span class="enscript-keyword">if</span> (error)
		NP(np, <span class="enscript-string">&quot;nfs_vnop_open: error %d, %d&quot;</span>, error, kauth_cred_getuid(noop-&gt;noo_cred));
	<span class="enscript-keyword">if</span> (noop)
		nfs_open_owner_rele(noop);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; vtype == VREG &amp;&amp; (ap-&gt;a_mode &amp; FWRITE)) {
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		nmp-&gt;nm_state &amp;= ~NFSSTA_SQUISHY;
		nmp-&gt;nm_curdeadtimeout = nmp-&gt;nm_deadtimeout;
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_curdeadtimeout &lt;= 0)
			nmp-&gt;nm_deadto_start = 0;
		nmp-&gt;nm_writers++;
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	}
		
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">nfs_no_of_open_file_writers</span>(nfsnode_t np)
{
	uint32_t writers = 0;
	<span class="enscript-type">struct</span> nfs_open_file *nofp;

	TAILQ_FOREACH(nofp,  &amp;np-&gt;n_opens, nof_link) {
		writers += nofp-&gt;nof_w + nofp-&gt;nof_rw + nofp-&gt;nof_w_dw + nofp-&gt;nof_rw_dw +
			nofp-&gt;nof_w_drw + nofp-&gt;nof_rw_drw + nofp-&gt;nof_d_w_dw +
			nofp-&gt;nof_d_rw_dw + nofp-&gt;nof_d_w_drw + nofp-&gt;nof_d_rw_drw +
			nofp-&gt;nof_d_w + nofp-&gt;nof_d_rw;
	}
	
	<span class="enscript-keyword">return</span> (writers);
}

<span class="enscript-comment">/*
 * NFS close vnode op
 *
 * What an NFS client should do upon close after writing is a debatable issue.
 * Most NFS clients push delayed writes to the server upon close, basically for
 * two reasons:
 * 1 - So that any write errors may be reported back to the client process
 *     doing the close system call. By far the two most likely errors are
 *     NFSERR_NOSPC and NFSERR_DQUOT to indicate space allocation failure.
 * 2 - To put a worst case upper bound on cache inconsistency between
 *     multiple clients for the file.
 * There is also a consistency problem for Version 2 of the protocol w.r.t.
 * not being able to tell if other clients are writing a file concurrently,
 * since there is no way of knowing if the changed modify time in the reply
 * is only due to the write for this client.
 * (NFS Version 3 provides weak cache consistency data in the reply that
 *  should be sufficient to detect and handle this case.)
 *
 * The current code does the following:
 * for NFS Version 2 - play it safe and flush/invalidate all dirty buffers
 * for NFS Version 3 - flush dirty buffers to the server but don't invalidate them.
 * for NFS Version 4 - basically the same as NFSv3
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_close</span>(
	<span class="enscript-type">struct</span> vnop_close_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		int a_fflag;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t vp = ap-&gt;a_vp;
	nfsnode_t np = VTONFS(vp);
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, error1, nfsvers;
	<span class="enscript-type">int</span> fflag = ap-&gt;a_fflag;
	<span class="enscript-type">enum</span> vtype vtype;
	<span class="enscript-type">int</span> accessMode, denyMode;
	<span class="enscript-type">struct</span> nfs_open_owner *noop = NULL;
	<span class="enscript-type">struct</span> nfs_open_file *nofp = NULL;

	nmp = VTONMP(vp);
	<span class="enscript-keyword">if</span> (!nmp)
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	vtype = vnode_vtype(vp);

	<span class="enscript-comment">/* First, check if we need to update/flush/invalidate */</span>
	<span class="enscript-keyword">if</span> (ISSET(np-&gt;n_flag, NUPDATESIZE))
		nfs_data_update_size(np, 0);
	nfs_node_lock_force(np);
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NNEEDINVALIDATE) {
		np-&gt;n_flag &amp;= ~NNEEDINVALIDATE;
		nfs_node_unlock(np);
		nfs_vinvalbuf(vp, V_SAVE|V_IGNORE_WRITEERR, ctx, 1);
		nfs_node_lock_force(np);
	}
	<span class="enscript-keyword">if</span> ((vtype == VREG) &amp;&amp; (np-&gt;n_flag &amp; NMODIFIED) &amp;&amp; (fflag &amp; FWRITE)) {
		<span class="enscript-comment">/* we're closing an open for write and the file is modified, so flush it */</span>
		nfs_node_unlock(np);
		<span class="enscript-keyword">if</span> (nfsvers != NFS_VER2)
			error = nfs_flush(np, MNT_WAIT, vfs_context_thread(ctx), 0);
		<span class="enscript-keyword">else</span>
			error = nfs_vinvalbuf(vp, V_SAVE, ctx, 1);
		nfs_node_lock_force(np);
		NATTRINVALIDATE(np);
	}
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NWRITEERR) {
		np-&gt;n_flag &amp;= ~NWRITEERR;
		error = np-&gt;n_error;
	}
	nfs_node_unlock(np);

	<span class="enscript-keyword">if</span> (vtype != VREG) {
		<span class="enscript-comment">/* Just mark that it was closed */</span>
		lck_mtx_lock(&amp;np-&gt;n_openlock);
		<span class="enscript-keyword">if</span> (np-&gt;n_openrefcnt == 0) {
			<span class="enscript-keyword">if</span> (fflag &amp; (FREAD|FWRITE)) {
				NP(np, <span class="enscript-string">&quot;nfs_vnop_close: open reference underrun&quot;</span>);
				error = EINVAL;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fflag &amp; (FREAD|FWRITE)) {
			np-&gt;n_openrefcnt--;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* No FREAD/FWRITE set - probably the final close */</span>
			np-&gt;n_openrefcnt = 0;
		}
		lck_mtx_unlock(&amp;np-&gt;n_openlock);
		<span class="enscript-keyword">return</span> (error);
	}
	error1 = error;

	<span class="enscript-comment">/* fflag should contain some combination of: FREAD, FWRITE, FHASLOCK */</span>
	accessMode = 0;
	<span class="enscript-keyword">if</span> (fflag &amp; FREAD)
		accessMode |= NFS_OPEN_SHARE_ACCESS_READ;
	<span class="enscript-keyword">if</span> (fflag &amp; FWRITE)
		accessMode |= NFS_OPEN_SHARE_ACCESS_WRITE;
<span class="enscript-comment">// XXX It would be nice if we still had the O_EXLOCK/O_SHLOCK flags that were on the open
</span><span class="enscript-comment">//	if (fflag &amp; O_EXLOCK)
</span><span class="enscript-comment">//		denyMode = NFS_OPEN_SHARE_DENY_BOTH;
</span><span class="enscript-comment">//	else if (fflag &amp; O_SHLOCK)
</span><span class="enscript-comment">//		denyMode = NFS_OPEN_SHARE_DENY_WRITE;
</span><span class="enscript-comment">//	else
</span><span class="enscript-comment">//		denyMode = NFS_OPEN_SHARE_DENY_NONE;
</span>#<span class="enscript-reference">if</span> 0  // <span class="enscript-variable-name">Not</span> <span class="enscript-variable-name">yet</span>
	<span class="enscript-keyword">if</span> (fflag &amp; FHASLOCK) {
		<span class="enscript-comment">/* XXX assume FHASLOCK is for the deny mode and not flock */</span>
		<span class="enscript-comment">/* FHASLOCK flock will be unlocked in the close path, but the flag is not cleared. */</span>
		<span class="enscript-keyword">if</span> (nofp-&gt;nof_deny &amp; NFS_OPEN_SHARE_DENY_READ)
			denyMode = NFS_OPEN_SHARE_DENY_BOTH;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_deny &amp; NFS_OPEN_SHARE_DENY_WRITE)
			denyMode = NFS_OPEN_SHARE_DENY_WRITE;
		<span class="enscript-keyword">else</span>
			denyMode = NFS_OPEN_SHARE_DENY_NONE;
	} <span class="enscript-keyword">else</span> {
			denyMode = NFS_OPEN_SHARE_DENY_NONE;
	}
#<span class="enscript-reference">else</span>
	<span class="enscript-comment">// XXX don't do deny modes just yet (and never do it for !v4)
</span>	denyMode = NFS_OPEN_SHARE_DENY_NONE;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (!accessMode) {
		<span class="enscript-comment">/*
		 * No mode given to close?
		 * Guess this is the final close.
		 * We should unlock all locks and close all opens.
		 */</span>
		uint32_t writers;
		mount_t mp = vnode_mount(vp);
		<span class="enscript-type">int</span> force = (!mp || vfs_isforce(mp));

		writers = nfs_no_of_open_file_writers(np);
		nfs_release_open_state_for_node(np, force);
		<span class="enscript-keyword">if</span> (writers) {
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">if</span> (writers &gt; nmp-&gt;nm_writers) {
				NP(np, <span class="enscript-string">&quot;nfs_vnop_close: number of write opens for mount underrun. Node has %d&quot;</span>
				   <span class="enscript-string">&quot; opens for write. Mount has total of %d opens for write\n&quot;</span>, 
				   writers, nmp-&gt;nm_writers);
				nmp-&gt;nm_writers = 0;
			} <span class="enscript-keyword">else</span> {
				nmp-&gt;nm_writers -= writers;
			}
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		}
		
		<span class="enscript-keyword">return</span> (error);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fflag &amp; FWRITE) {
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_writers == 0) {
			NP(np, <span class="enscript-string">&quot;nfs_vnop_close: removing open writer from mount, but mount has no files open for writing&quot;</span>);
		} <span class="enscript-keyword">else</span> {
			nmp-&gt;nm_writers--;
		}
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	}
	

	noop = nfs_open_owner_find(nmp, vfs_context_ucred(ctx), 0);
	<span class="enscript-keyword">if</span> (!noop) {
		<span class="enscript-comment">// printf(&quot;nfs_vnop_close: can't get open owner!\n&quot;);
</span>		<span class="enscript-keyword">return</span> (EIO);
	}

<span class="enscript-reference">restart</span>:
	error = nfs_mount_state_in_use_start(nmp, NULL);
	<span class="enscript-keyword">if</span> (error) {
		nfs_open_owner_rele(noop);
		<span class="enscript-keyword">return</span> (error);
	}

	error = nfs_open_file_find(np, noop, &amp;nofp, 0, 0, 0);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN)) {
		nfs_mount_state_in_use_end(nmp, 0);
		error = nfs4_reopen(nofp, NULL);
		nofp = NULL;
		<span class="enscript-keyword">if</span> (!error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}
	<span class="enscript-keyword">if</span> (error) {
		NP(np, <span class="enscript-string">&quot;nfs_vnop_close: no open file for owner, error %d, %d&quot;</span>, error, kauth_cred_getuid(noop-&gt;noo_cred));
		error = EBADF;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	error = nfs_open_file_set_busy(nofp, NULL);
	<span class="enscript-keyword">if</span> (error) {
		nofp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = nfs_close(np, nofp, accessMode, denyMode, ctx);
	<span class="enscript-keyword">if</span> (error)
		NP(np, <span class="enscript-string">&quot;nfs_vnop_close: close error %d, %d&quot;</span>, error, kauth_cred_getuid(noop-&gt;noo_cred));

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (nofp)
		nfs_open_file_clear_busy(nofp);
	<span class="enscript-keyword">if</span> (nfs_mount_state_in_use_end(nmp, error)) {
		nofp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}
	<span class="enscript-keyword">if</span> (!error)
		error = error1;
	<span class="enscript-keyword">if</span> (error)
		NP(np, <span class="enscript-string">&quot;nfs_vnop_close: error %d, %d&quot;</span>, error, kauth_cred_getuid(noop-&gt;noo_cred));
	<span class="enscript-keyword">if</span> (noop)
		nfs_open_owner_rele(noop);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs_close(): common function that does all the heavy lifting of file closure
 *
 * Takes an open file structure and a set of access/deny modes and figures out how
 * to update the open file structure (and the state on the server) appropriately.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_close</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_open_file *nofp,
	uint32_t accessMode,
	uint32_t denyMode,
	vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfs_lock_owner *nlop;
	<span class="enscript-type">int</span> error = 0, changed = 0, delegated = 0, closed = 0, downgrade = 0;
	uint32_t newAccessMode, newDenyMode;
	
	<span class="enscript-comment">/* warn if modes don't match current state */</span>
	<span class="enscript-keyword">if</span> (((accessMode &amp; nofp-&gt;nof_access) != accessMode) || ((denyMode &amp; nofp-&gt;nof_deny) != denyMode))
		NP(np, <span class="enscript-string">&quot;nfs_close: mode mismatch %d %d, current %d %d, %d&quot;</span>,
			accessMode, denyMode, nofp-&gt;nof_access, nofp-&gt;nof_deny,
			kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));

	<span class="enscript-comment">/*
	 * If we're closing a write-only open, we may not have a write-only count
	 * if we also grabbed read access.  So, check the read-write count.
	 */</span>
	<span class="enscript-keyword">if</span> (denyMode == NFS_OPEN_SHARE_DENY_NONE) {
		<span class="enscript-keyword">if</span> ((accessMode == NFS_OPEN_SHARE_ACCESS_WRITE) &amp;&amp;
		    (nofp-&gt;nof_w == 0) &amp;&amp; (nofp-&gt;nof_d_w == 0) &amp;&amp;
		    (nofp-&gt;nof_rw || nofp-&gt;nof_d_rw))
			accessMode = NFS_OPEN_SHARE_ACCESS_BOTH;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (denyMode == NFS_OPEN_SHARE_DENY_WRITE) {
		<span class="enscript-keyword">if</span> ((accessMode == NFS_OPEN_SHARE_ACCESS_WRITE) &amp;&amp;
		    (nofp-&gt;nof_w_dw == 0) &amp;&amp; (nofp-&gt;nof_d_w_dw == 0) &amp;&amp;
		    (nofp-&gt;nof_rw_dw || nofp-&gt;nof_d_rw_dw))
			accessMode = NFS_OPEN_SHARE_ACCESS_BOTH;
	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* NFS_OPEN_SHARE_DENY_BOTH */</span>
		<span class="enscript-keyword">if</span> ((accessMode == NFS_OPEN_SHARE_ACCESS_WRITE) &amp;&amp;
		    (nofp-&gt;nof_w_drw == 0) &amp;&amp; (nofp-&gt;nof_d_w_drw == 0) &amp;&amp;
		    (nofp-&gt;nof_rw_drw || nofp-&gt;nof_d_rw_drw))
			accessMode = NFS_OPEN_SHARE_ACCESS_BOTH;
	}

	nfs_open_file_remove_open_find(nofp, accessMode, denyMode, &amp;newAccessMode, &amp;newDenyMode, &amp;delegated);
	<span class="enscript-keyword">if</span> ((newAccessMode != nofp-&gt;nof_access) || (newDenyMode != nofp-&gt;nof_deny))
		changed = 1;
	<span class="enscript-keyword">else</span>
		changed = 0;

	<span class="enscript-keyword">if</span> (NFSTONMP(np)-&gt;nm_vers &lt; NFS_VER4) <span class="enscript-comment">/* NFS v2/v3 closes simply need to remove the open. */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">v3close</span>;

	<span class="enscript-keyword">if</span> ((newAccessMode == 0) || (nofp-&gt;nof_opencnt == 1)) {
		<span class="enscript-comment">/*
		 * No more access after this close, so clean up and close it.
		 * Don't send a close RPC if we're closing a delegated open.
		 */</span>
		nfs_wait_bufs(np);
		closed = 1;
		<span class="enscript-keyword">if</span> (!delegated &amp;&amp; !(nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST))
			error = nfs4_close_rpc(np, nofp, vfs_context_thread(ctx), vfs_context_ucred(ctx), 0);
		<span class="enscript-keyword">if</span> (error == NFSERR_LOCKS_HELD) {
			<span class="enscript-comment">/*
			 * Hmm... the server says we have locks we need to release first
			 * Find the lock owner and try to unlock everything.
			 */</span>
			nlop = nfs_lock_owner_find(np, vfs_context_proc(ctx), 0);
			<span class="enscript-keyword">if</span> (nlop) {
				nfs4_unlock_rpc(np, nlop, F_WRLCK, 0, UINT64_MAX,
					0, vfs_context_thread(ctx), vfs_context_ucred(ctx));
				nfs_lock_owner_rele(nlop);
			}
			error = nfs4_close_rpc(np, nofp, vfs_context_thread(ctx), vfs_context_ucred(ctx), 0);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (changed) {
		<span class="enscript-comment">/*
		 * File is still open but with less access, so downgrade the open.
		 * Don't send a downgrade RPC if we're closing a delegated open.
		 */</span>
		<span class="enscript-keyword">if</span> (!delegated &amp;&amp; !(nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST)) {
			downgrade = 1;
			<span class="enscript-comment">/*
			 * If we have delegated opens, we should probably claim them before sending
			 * the downgrade because the server may not know the open we are downgrading to.
			 */</span>
			<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_rw_drw || nofp-&gt;nof_d_w_drw || nofp-&gt;nof_d_r_drw ||
			    nofp-&gt;nof_d_rw_dw || nofp-&gt;nof_d_w_dw || nofp-&gt;nof_d_r_dw ||
			    nofp-&gt;nof_d_rw || nofp-&gt;nof_d_w || nofp-&gt;nof_d_r)
				nfs4_claim_delegated_state_for_open_file(nofp, 0);
			<span class="enscript-comment">/* need to remove the open before sending the downgrade */</span>
			nfs_open_file_remove_open(nofp, accessMode, denyMode);
			error = nfs4_open_downgrade_rpc(np, nofp, ctx);
			<span class="enscript-keyword">if</span> (error) <span class="enscript-comment">/* Hmm.. that didn't work. Add the open back in. */</span>
				nfs_open_file_add_open(nofp, accessMode, denyMode, delegated);
		}
	}

	<span class="enscript-keyword">if</span> (error) {
		NP(np, <span class="enscript-string">&quot;nfs_close: error %d, %d&quot;</span>, error, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
		<span class="enscript-keyword">return</span> (error);
	}

<span class="enscript-reference">v3close</span>:
	<span class="enscript-keyword">if</span> (!downgrade)
		nfs_open_file_remove_open(nofp, accessMode, denyMode);

	<span class="enscript-keyword">if</span> (closed) {
		lck_mtx_lock(&amp;nofp-&gt;nof_lock);
		<span class="enscript-keyword">if</span> (nofp-&gt;nof_r || nofp-&gt;nof_d_r || nofp-&gt;nof_w || nofp-&gt;nof_d_w || nofp-&gt;nof_d_rw ||
		    (nofp-&gt;nof_rw &amp;&amp; !((nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_CREATE) &amp;&amp; !nofp-&gt;nof_creator &amp;&amp; (nofp-&gt;nof_rw == 1))) ||
		    nofp-&gt;nof_r_dw || nofp-&gt;nof_d_r_dw || nofp-&gt;nof_w_dw || nofp-&gt;nof_d_w_dw ||
		    nofp-&gt;nof_rw_dw || nofp-&gt;nof_d_rw_dw || nofp-&gt;nof_r_drw || nofp-&gt;nof_d_r_drw ||
		    nofp-&gt;nof_w_drw || nofp-&gt;nof_d_w_drw || nofp-&gt;nof_rw_drw || nofp-&gt;nof_d_rw_drw)
			NP(np, <span class="enscript-string">&quot;nfs_close: unexpected count: %u.%u %u.%u %u.%u dw %u.%u %u.%u %u.%u drw %u.%u %u.%u %u.%u flags 0x%x, %d&quot;</span>,
				nofp-&gt;nof_r, nofp-&gt;nof_d_r, nofp-&gt;nof_w, nofp-&gt;nof_d_w,
				nofp-&gt;nof_rw, nofp-&gt;nof_d_rw, nofp-&gt;nof_r_dw, nofp-&gt;nof_d_r_dw,
				nofp-&gt;nof_w_dw, nofp-&gt;nof_d_w_dw, nofp-&gt;nof_rw_dw, nofp-&gt;nof_d_rw_dw,
				nofp-&gt;nof_r_drw, nofp-&gt;nof_d_r_drw, nofp-&gt;nof_w_drw, nofp-&gt;nof_d_w_drw,
				nofp-&gt;nof_rw_drw, nofp-&gt;nof_d_rw_drw, nofp-&gt;nof_flags,
				kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
		<span class="enscript-comment">/* clear out all open info, just to be safe */</span>
		nofp-&gt;nof_access = nofp-&gt;nof_deny = 0;
		nofp-&gt;nof_mmap_access = nofp-&gt;nof_mmap_deny = 0;
		nofp-&gt;nof_r = nofp-&gt;nof_d_r = 0;
		nofp-&gt;nof_w = nofp-&gt;nof_d_w = 0;
		nofp-&gt;nof_rw = nofp-&gt;nof_d_rw = 0;
		nofp-&gt;nof_r_dw = nofp-&gt;nof_d_r_dw = 0;
		nofp-&gt;nof_w_dw = nofp-&gt;nof_d_w_dw = 0;
		nofp-&gt;nof_rw_dw = nofp-&gt;nof_d_rw_dw = 0;
		nofp-&gt;nof_r_drw = nofp-&gt;nof_d_r_drw = 0;
		nofp-&gt;nof_w_drw = nofp-&gt;nof_d_w_drw = 0;
		nofp-&gt;nof_rw_drw = nofp-&gt;nof_d_rw_drw = 0;
		nofp-&gt;nof_flags &amp;= ~NFS_OPEN_FILE_CREATE;
		lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
		<span class="enscript-comment">/* XXX we may potentially want to clean up idle/unused open file structures */</span>
	}
	<span class="enscript-keyword">if</span> (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST) {
		error = EIO;
		NP(np, <span class="enscript-string">&quot;nfs_close: LOST%s, %d&quot;</span>, !nofp-&gt;nof_opencnt ? <span class="enscript-string">&quot; (last)&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
			kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
	}
		
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_getattr_rpc</span>(
	nfsnode_t np,
	mount_t mp,
	u_char *fhp,
	size_t fhsize,
	<span class="enscript-type">int</span> flags,
	vfs_context_t ctx,
	<span class="enscript-type">struct</span> nfs_vattr *nvap,
	u_int64_t *xidp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = mp ? VFSTONFS(mp) : NFSTONMP(np);
	<span class="enscript-type">int</span> error = 0, status, nfsvers, rpcflags = 0;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	<span class="enscript-keyword">if</span> (flags &amp; NGA_MONITOR) <span class="enscript-comment">/* vnode monitor requests should be soft */</span>
		rpcflags = R_RECOVER;

	<span class="enscript-keyword">if</span> (flags &amp; NGA_SOFT) <span class="enscript-comment">/* Return ETIMEDOUT if server not responding */</span>
		rpcflags |= R_SOFT;

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_build_alloc_init(error, &amp;nmreq, NFSX_FH(nfsvers));
	<span class="enscript-keyword">if</span> (nfsvers != NFS_VER2)
		nfsm_chain_add_32(error, &amp;nmreq, fhsize);
	nfsm_chain_add_opaque(error, &amp;nmreq, fhp, fhsize);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfs_request2(np, mp, &amp;nmreq, NFSPROC_GETATTR, 
			vfs_context_thread(ctx), vfs_context_ucred(ctx),
			NULL, rpcflags, &amp;nmrep, xidp, &amp;status);
	<span class="enscript-keyword">if</span> (!error)
		error = status;
	nfsmout_if(error);
	error = nfs_parsefattr(&amp;nmrep, nfsvers, nvap);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs_refresh_fh will attempt to update the file handle for the node.
 *
 * It only does this for symbolic links and regular files that are not currently opened.
 *
 * On Success returns 0 and the nodes file handle is updated, or ESTALE on failure.
 */</span> 
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_refresh_fh</span>(nfsnode_t np, vfs_context_t ctx)
{
	vnode_t dvp, vp = NFSTOV(np);
	nfsnode_t dnp;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *v_name = vnode_getname(vp);
	<span class="enscript-type">char</span> *name;
	<span class="enscript-type">int</span> namelen, fhsize, refreshed;
	<span class="enscript-type">int</span> error, wanted = 0;
	uint8_t *fhp;
	<span class="enscript-type">struct</span> timespec ts = {2, 0};

	NFS_VNOP_DBG(<span class="enscript-string">&quot;vnode is %d\n&quot;</span>, vnode_vtype(vp));

	dvp = vnode_parent(vp);
	<span class="enscript-keyword">if</span> ((vnode_vtype(vp) != VREG &amp;&amp; vnode_vtype(vp) != VLNK) ||
	    v_name == NULL || *v_name == <span class="enscript-string">'\0'</span> || dvp == NULL) {
		<span class="enscript-keyword">if</span> (v_name != NULL)
			vnode_putname(v_name);
		<span class="enscript-keyword">return</span> (ESTALE);
	}
	dnp = VTONFS(dvp);
	
	namelen = strlen(v_name);
	MALLOC(name, <span class="enscript-type">char</span> *, namelen + 1, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (name == NULL) {
		vnode_putname(v_name);
		<span class="enscript-keyword">return</span> (ESTALE);
	}
	bcopy(v_name, name, namelen+1);
	NFS_VNOP_DBG(<span class="enscript-string">&quot;Trying to refresh %s : %s\n&quot;</span>, v_name, name);
	vnode_putname(v_name);

	<span class="enscript-comment">/* Allocate the maximum size file handle */</span>
	MALLOC(fhp, uint8_t *, NFS4_FHSIZE, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (fhp == NULL) {
		FREE(name, M_TEMP);
		<span class="enscript-keyword">return</span> (ESTALE);
	}
	
	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np))) {
		FREE(name, M_TEMP);
		FREE(fhp, M_TEMP);
		<span class="enscript-keyword">return</span> (ESTALE);
	}
	
	fhsize = np-&gt;n_fhsize;
	bcopy(np-&gt;n_fhp, fhp, fhsize);
	<span class="enscript-keyword">while</span> (ISSET(np-&gt;n_flag, NREFRESH)) {
		SET(np-&gt;n_flag, NREFRESHWANT);
		NFS_VNOP_DBG(<span class="enscript-string">&quot;Waiting for refresh of %s\n&quot;</span>, name);
		msleep(np, &amp;np-&gt;n_lock, PZERO-1, <span class="enscript-string">&quot;nfsrefreshwant&quot;</span>, &amp;ts);
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(NFSTONMP(np), NULL,  vfs_context_thread(ctx), 0)))
			<span class="enscript-keyword">break</span>;
	}
	refreshed = error ? 0 : !NFS_CMPFH(np, fhp, fhsize);
	SET(np-&gt;n_flag, NREFRESH);
	nfs_node_unlock(np);

	NFS_VNOP_DBG(<span class="enscript-string">&quot;error = %d, refreshed = %d\n&quot;</span>, error, refreshed);
	<span class="enscript-keyword">if</span> (error || refreshed)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	
	<span class="enscript-comment">/* Check that there are no open references for this file */</span>
	lck_mtx_lock(&amp;np-&gt;n_openlock);
	<span class="enscript-keyword">if</span> (np-&gt;n_openrefcnt || !TAILQ_EMPTY(&amp;np-&gt;n_opens) || !TAILQ_EMPTY(&amp;np-&gt;n_lock_owners)) {
		<span class="enscript-type">int</span> cnt = 0;
		<span class="enscript-type">struct</span> nfs_open_file *ofp;
		
		TAILQ_FOREACH(ofp, &amp;np-&gt;n_opens, nof_link) {
			cnt += ofp-&gt;nof_opencnt;
		}
		<span class="enscript-keyword">if</span> (cnt) {
			lck_mtx_unlock(&amp;np-&gt;n_openlock);
			NFS_VNOP_DBG(<span class="enscript-string">&quot;Can not refresh file handle for %s with open state\n&quot;</span>, name);
			NFS_VNOP_DBG(<span class="enscript-string">&quot;\topenrefcnt = %d, opens = %d lock_owners = %d\n&quot;</span>, 
					  np-&gt;n_openrefcnt, cnt, !TAILQ_EMPTY(&amp;np-&gt;n_lock_owners));
			error = ESTALE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
	}
	lck_mtx_unlock(&amp;np-&gt;n_openlock);
	<span class="enscript-comment">/* 
	 * Since the FH is currently stale we should not be able to
	 * establish any open state until the FH is refreshed.
	 */</span>

	error = nfs_node_lock(np);
	nfsmout_if(error);
	<span class="enscript-comment">/*
	 * Symlinks should never need invalidations and are holding
	 * the one and only nfsbuf in an uncached acquired state
	 * trying to do a readlink. So we will hang if we invalidate
	 * in that case. Only in in the VREG case do we need to
	 * invalidate.
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_vtype(vp) == VREG) {
		np-&gt;n_flag &amp;= ~NNEEDINVALIDATE;
		nfs_node_unlock(np);
		error = nfs_vinvalbuf(vp, V_IGNORE_WRITEERR, ctx, 1);
		<span class="enscript-keyword">if</span> (error)
			NFS_VNOP_DBG(<span class="enscript-string">&quot;nfs_vinvalbuf returned %d\n&quot;</span>, error);
		nfsmout_if(error);
	} <span class="enscript-keyword">else</span> {
		nfs_node_unlock(np);
	}

	NFS_VNOP_DBG(<span class="enscript-string">&quot;Looking up %s\n&quot;</span>, name);
	error = nfs_lookitup(dnp, name, namelen, ctx, &amp;np);
	<span class="enscript-keyword">if</span> (error)
		NFS_VNOP_DBG(<span class="enscript-string">&quot;nfs_lookitup returned %d\n&quot;</span>, error);

<span class="enscript-reference">nfsmout</span>:
	nfs_node_lock_force(np);
	wanted = ISSET(np-&gt;n_flag, NREFRESHWANT);
	CLR(np-&gt;n_flag, NREFRESH|NREFRESHWANT);
	nfs_node_unlock(np);
	<span class="enscript-keyword">if</span> (wanted)
		wakeup(np);
	
	<span class="enscript-keyword">if</span> (error == 0)
		NFS_VNOP_DBG(<span class="enscript-string">&quot;%s refreshed file handle\n&quot;</span>, name);

	FREE(name, M_TEMP);
	FREE(fhp, M_TEMP);
	
	<span class="enscript-keyword">return</span> (error ? ESTALE : 0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_getattr</span>(nfsnode_t np, <span class="enscript-type">struct</span> nfs_vattr *nvap, vfs_context_t ctx, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">int</span> error;
	
<span class="enscript-reference">retry</span>:
	error = nfs_getattr_internal(np, nvap, ctx, flags);
	<span class="enscript-keyword">if</span> (error == ESTALE) {
		error = nfs_refresh_fh(np, ctx);
		<span class="enscript-keyword">if</span> (!error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_getattr_internal</span>(nfsnode_t np, <span class="enscript-type">struct</span> nfs_vattr *nvap, vfs_context_t ctx, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, nfsvers, inprogset = 0, wanted = 0, avoidfloods;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">struct</span> timespec ts = { 2, 0 };
	u_int64_t xid;

	FSDBG_TOP(513, np-&gt;n_size, np, np-&gt;n_vattr.nva_size, np-&gt;n_flag);

	nmp = NFSTONMP(np);
	
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	<span class="enscript-keyword">if</span> (!nvap)
		nvap = &amp;nvattr;
	NVATTR_INIT(nvap);

	<span class="enscript-comment">/* Update local times for special files. */</span>
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; (NACC | NUPD)) {
		nfs_node_lock_force(np);
		np-&gt;n_flag |= NCHG;
		nfs_node_unlock(np);
	}
	<span class="enscript-comment">/* Update size, if necessary */</span>
	<span class="enscript-keyword">if</span> (ISSET(np-&gt;n_flag, NUPDATESIZE))
		nfs_data_update_size(np, 0);

	error = nfs_node_lock(np);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (!(flags &amp; (NGA_UNCACHED|NGA_MONITOR)) || ((nfsvers &gt;= NFS_VER4) &amp;&amp; (np-&gt;n_openflags &amp; N_DELEG_MASK))) {
		<span class="enscript-comment">/*
		 * Use the cache or wait for any getattr in progress if:
		 * - it's a cached request, or
		 * - we have a delegation, or
		 * - the server isn't responding
		 */</span>
		<span class="enscript-keyword">while</span> (1) {
			error = nfs_getattrcache(np, nvap, flags);
			<span class="enscript-keyword">if</span> (!error || (error != ENOENT)) {
				nfs_node_unlock(np);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}
			error = 0;
			<span class="enscript-keyword">if</span> (!ISSET(np-&gt;n_flag, NGETATTRINPROG))
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (flags &amp; NGA_MONITOR) {
				<span class="enscript-comment">/* no need to wait if a request is pending */</span>
				error = EINPROGRESS;
				nfs_node_unlock(np);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}
			SET(np-&gt;n_flag, NGETATTRWANT);
			msleep(np, &amp;np-&gt;n_lock, PZERO-1, <span class="enscript-string">&quot;nfsgetattrwant&quot;</span>, &amp;ts);
			<span class="enscript-keyword">if</span> ((error = nfs_sigintr(NFSTONMP(np), NULL, vfs_context_thread(ctx), 0))) {
				nfs_node_unlock(np);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}
		}
		SET(np-&gt;n_flag, NGETATTRINPROG);
		inprogset = 1;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!ISSET(np-&gt;n_flag, NGETATTRINPROG)) {
		SET(np-&gt;n_flag, NGETATTRINPROG);
		inprogset = 1;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; NGA_MONITOR) {
		<span class="enscript-comment">/* no need to make a request if one is pending */</span>
		error = EINPROGRESS;
	}
	nfs_node_unlock(np);

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		error = ENXIO;
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;

	<span class="enscript-comment">/*
	 * Return cached attributes if they are valid,
	 * if the server doesn't respond, and this is
	 * some softened up style of mount.
	 */</span>
	<span class="enscript-keyword">if</span> (NATTRVALID(np) &amp;&amp; nfs_use_cache(nmp))
		flags |= NGA_SOFT;

	<span class="enscript-comment">/*
	 * We might want to try to get both the attributes and access info by
	 * making an ACCESS call and seeing if it returns updated attributes.
	 * But don't bother if we aren't caching access info or if the
	 * attributes returned wouldn't be cached.
	 */</span>
	<span class="enscript-keyword">if</span> (!(flags &amp; NGA_ACL) &amp;&amp; (nfsvers != NFS_VER2) &amp;&amp; nfs_access_for_getattr &amp;&amp; (nfs_access_cache_timeout &gt; 0)) {
		<span class="enscript-keyword">if</span> (nfs_attrcachetimeout(np) &gt; 0) {
			<span class="enscript-comment">/*  OSAddAtomic(1, &amp;nfsstats.accesscache_misses); */</span>
			u_int32_t access = NFS_ACCESS_ALL;
			<span class="enscript-type">int</span> rpcflags = 0;

			<span class="enscript-comment">/* Return cached attrs if server doesn't respond */</span>
			<span class="enscript-keyword">if</span> (flags &amp; NGA_SOFT)
				rpcflags |= R_SOFT;

			error = nmp-&gt;nm_funcs-&gt;nf_access_rpc(np, &amp;access, rpcflags, ctx);

			<span class="enscript-keyword">if</span> (error == ETIMEDOUT)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">returncached</span>;

			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			nfs_node_lock_force(np);
			error = nfs_getattrcache(np, nvap, flags);
			nfs_node_unlock(np);
			<span class="enscript-keyword">if</span> (!error || (error != ENOENT))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			<span class="enscript-comment">/* Well, that didn't work... just do a getattr... */</span>
			error = 0;
		}
	}

	avoidfloods = 0;

<span class="enscript-reference">tryagain</span>:
	error = nmp-&gt;nm_funcs-&gt;nf_getattr_rpc(np, NULL, np-&gt;n_fhp, np-&gt;n_fhsize, flags, ctx, nvap, &amp;xid);
	<span class="enscript-keyword">if</span> (!error) {
		nfs_node_lock_force(np);
		error = nfs_loadattrcache(np, nvap, &amp;xid, 0);
		nfs_node_unlock(np);
	}

	<span class="enscript-comment">/*
	 * If the server didn't respond, return cached attributes.
	 */</span>
<span class="enscript-reference">returncached</span>:
	<span class="enscript-keyword">if</span> ((flags &amp; NGA_SOFT) &amp;&amp; (error == ETIMEDOUT)) {
		nfs_node_lock_force(np);
		error = nfs_getattrcache(np, nvap, flags);
		<span class="enscript-keyword">if</span> (!error || (error != ENOENT)) {
			nfs_node_unlock(np);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
		nfs_node_unlock(np);
	}
	nfsmout_if(error);

	<span class="enscript-keyword">if</span> (!xid) { <span class="enscript-comment">/* out-of-order rpc - attributes were dropped */</span>
		FSDBG(513, -1, np, np-&gt;n_xid &gt;&gt; 32, np-&gt;n_xid);
		<span class="enscript-keyword">if</span> (avoidfloods++ &lt; 20)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
		<span class="enscript-comment">/* avoidfloods&gt;1 is bizarre.  at 20 pull the plug */</span>
		<span class="enscript-comment">/* just return the last attributes we got */</span>
	}
<span class="enscript-reference">nfsmout</span>:
	nfs_node_lock_force(np);
	<span class="enscript-keyword">if</span> (inprogset) {
		wanted = ISSET(np-&gt;n_flag, NGETATTRWANT);
		CLR(np-&gt;n_flag, (NGETATTRINPROG | NGETATTRWANT));
	}
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-comment">/* check if the node changed on us */</span>
		vnode_t vp = NFSTOV(np);
		<span class="enscript-type">enum</span> vtype vtype = vnode_vtype(vp);
		<span class="enscript-keyword">if</span> ((vtype == VDIR) &amp;&amp; NFS_CHANGED_NC(nfsvers, np, nvap)) {
			FSDBG(513, -1, np, 0, np);
			np-&gt;n_flag &amp;= ~NNEGNCENTRIES;
			cache_purge(vp);
			np-&gt;n_ncgen++;
			NFS_CHANGED_UPDATE_NC(nfsvers, np, nvap);
			NFS_VNOP_DBG(<span class="enscript-string">&quot;Purge directory 0x%llx\n&quot;</span>, 
			      (uint64_t)VM_KERNEL_ADDRPERM(vp));
		}
		<span class="enscript-keyword">if</span> (NFS_CHANGED(nfsvers, np, nvap)) {
			FSDBG(513, -1, np, -1, np);
			<span class="enscript-keyword">if</span> (vtype == VDIR) {
				NFS_VNOP_DBG(<span class="enscript-string">&quot;Invalidate directory 0x%llx\n&quot;</span>, 
			               (uint64_t)VM_KERNEL_ADDRPERM(vp));
				nfs_invaldir(np);
			}
			nfs_node_unlock(np);
			<span class="enscript-keyword">if</span> (wanted)
				wakeup(np);
			error = nfs_vinvalbuf(vp, V_SAVE, ctx, 1);
			FSDBG(513, -1, np, -2, error);
			<span class="enscript-keyword">if</span> (!error) {
				nfs_node_lock_force(np);
				NFS_CHANGED_UPDATE(nfsvers, np, nvap);
				nfs_node_unlock(np);
			}
		} <span class="enscript-keyword">else</span> {
			nfs_node_unlock(np);
			<span class="enscript-keyword">if</span> (wanted)
				wakeup(np);
		}
	} <span class="enscript-keyword">else</span> {
		nfs_node_unlock(np);
		<span class="enscript-keyword">if</span> (wanted)
			wakeup(np);
	}

	<span class="enscript-keyword">if</span> (nvap == &amp;nvattr) {
		NVATTR_CLEANUP(nvap);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(flags &amp; NGA_ACL)) {
		<span class="enscript-comment">/* make sure we don't return an ACL if it wasn't asked for */</span>
		NFS_BITMAP_CLR(nvap-&gt;nva_bitmap, NFS_FATTR_ACL);
		<span class="enscript-keyword">if</span> (nvap-&gt;nva_acl) {
			kauth_acl_free(nvap-&gt;nva_acl);
			nvap-&gt;nva_acl = NULL;
		}
	}
	FSDBG_BOT(513, np-&gt;n_size, error, np-&gt;n_vattr.nva_size, np-&gt;n_flag);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS getattr call from vfs.
 */</span>

<span class="enscript-comment">/*
 * The attributes we support over the wire.
 * We also get fsid but the vfs layer gets it out of the mount 
 * structure after this calling us so there's no need to return it,
 * and Finder expects to call getattrlist just looking for the FSID
 * with out hanging on a non responsive server.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS3_SUPPORTED_VATTRS</span> \
	(VNODE_ATTR_va_rdev |		\
	 VNODE_ATTR_va_nlink |		\
	 VNODE_ATTR_va_data_size |	\
	 VNODE_ATTR_va_data_alloc |	\
	 VNODE_ATTR_va_uid |		\
	 VNODE_ATTR_va_gid |		\
	 VNODE_ATTR_va_mode |		\
	 VNODE_ATTR_va_modify_time |	\
	 VNODE_ATTR_va_change_time |	\
	 VNODE_ATTR_va_access_time |	\
	 VNODE_ATTR_va_fileid |		\
	 VNODE_ATTR_va_type)

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_vnop_getattr</span>(
	<span class="enscript-type">struct</span> vnop_getattr_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		struct vnode_attr *a_vap;
		vfs_context_t a_context;
	} */</span> *ap)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nfs_vattr nva;
	<span class="enscript-type">struct</span> vnode_attr *vap = ap-&gt;a_vap;
	dev_t rdev;

	<span class="enscript-comment">/*
	 * Lets don't go over the wire if we don't support any of the attributes.
	 * Just fall through at the VFS layer and let it cons up what it needs.
	 */</span>
	<span class="enscript-comment">/* Return the io size no matter what, since we don't go over the wire for this */</span>
	VATTR_RETURN(vap, va_iosize, nfs_iosize);
	<span class="enscript-keyword">if</span> ((vap-&gt;va_active &amp; NFS3_SUPPORTED_VATTRS) == 0)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(ap-&gt;a_vap, va_name))
	    NFS_VNOP_DBG(<span class="enscript-string">&quot;Getting attrs for 0x%llx, vname is %s\n&quot;</span>, 
	          (uint64_t)VM_KERNEL_ADDRPERM(ap-&gt;a_vp),
	          ap-&gt;a_vp-&gt;v_name ? ap-&gt;a_vp-&gt;v_name : <span class="enscript-string">&quot;empty&quot;</span>);
	error = nfs_getattr(VTONFS(ap-&gt;a_vp), &amp;nva, ap-&gt;a_context, NGA_CACHED);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/* copy nva to *a_vap */</span>
	VATTR_RETURN(vap, va_type, nva.nva_type);
	VATTR_RETURN(vap, va_mode, nva.nva_mode);
	rdev = makedev(nva.nva_rawdev.specdata1, nva.nva_rawdev.specdata2);
	VATTR_RETURN(vap, va_rdev, rdev);
	VATTR_RETURN(vap, va_uid, nva.nva_uid);
	VATTR_RETURN(vap, va_gid, nva.nva_gid);
	VATTR_RETURN(vap, va_nlink, nva.nva_nlink);
	VATTR_RETURN(vap, va_fileid, nva.nva_fileid);
	VATTR_RETURN(vap, va_data_size, nva.nva_size);
	VATTR_RETURN(vap, va_data_alloc, nva.nva_bytes);
	vap-&gt;va_access_time.tv_sec = nva.nva_timesec[NFSTIME_ACCESS];
	vap-&gt;va_access_time.tv_nsec = nva.nva_timensec[NFSTIME_ACCESS];
	VATTR_SET_SUPPORTED(vap, va_access_time);
	vap-&gt;va_modify_time.tv_sec = nva.nva_timesec[NFSTIME_MODIFY];
	vap-&gt;va_modify_time.tv_nsec = nva.nva_timensec[NFSTIME_MODIFY];
	VATTR_SET_SUPPORTED(vap, va_modify_time);
	vap-&gt;va_change_time.tv_sec = nva.nva_timesec[NFSTIME_CHANGE];
	vap-&gt;va_change_time.tv_nsec = nva.nva_timensec[NFSTIME_CHANGE];
	VATTR_SET_SUPPORTED(vap, va_change_time);

	<span class="enscript-comment">// VATTR_RETURN(vap, va_encoding, 0xffff /* kTextEncodingUnknown */);
</span>	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS setattr call.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_setattr</span>(
	<span class="enscript-type">struct</span> vnop_setattr_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		struct vnode_attr *a_vap;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t vp = ap-&gt;a_vp;
	nfsnode_t np = VTONFS(vp);
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> vnode_attr *vap = ap-&gt;a_vap;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> biosize, nfsvers, namedattrs;
	u_quad_t origsize, vapsize;
	<span class="enscript-type">struct</span> nfs_dulookup dul;
	nfsnode_t dnp = NULL;
	vnode_t dvp = NULL;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *vname = NULL;
	<span class="enscript-type">struct</span> nfs_open_owner *noop = NULL;
	<span class="enscript-type">struct</span> nfs_open_file *nofp = NULL;

	nmp = VTONMP(vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	namedattrs = (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR);
	biosize = nmp-&gt;nm_biosize;

	<span class="enscript-comment">/* Disallow write attempts if the filesystem is mounted read-only. */</span>
	<span class="enscript-keyword">if</span> (vnode_vfsisrdonly(vp))
		<span class="enscript-keyword">return</span> (EROFS);

	origsize = np-&gt;n_size;
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_size)) {
		<span class="enscript-keyword">switch</span> (vnode_vtype(vp)) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VDIR</span>:
			<span class="enscript-keyword">return</span> (EISDIR);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VCHR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VBLK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VSOCK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VFIFO</span>:
			<span class="enscript-keyword">if</span> (!VATTR_IS_ACTIVE(vap, va_modify_time) &amp;&amp;
			    !VATTR_IS_ACTIVE(vap, va_access_time) &amp;&amp;
			    !VATTR_IS_ACTIVE(vap, va_mode) &amp;&amp;
			    !VATTR_IS_ACTIVE(vap, va_uid) &amp;&amp;
			    !VATTR_IS_ACTIVE(vap, va_gid)) {
				<span class="enscript-keyword">return</span> (0);
			}
			VATTR_CLEAR_ACTIVE(vap, va_data_size);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/*
			 * Disallow write attempts if the filesystem is
			 * mounted read-only.
			 */</span>
			<span class="enscript-keyword">if</span> (vnode_vfsisrdonly(vp))
				<span class="enscript-keyword">return</span> (EROFS);
			FSDBG_TOP(512, np-&gt;n_size, vap-&gt;va_data_size,
				  np-&gt;n_vattr.nva_size, np-&gt;n_flag);
			<span class="enscript-comment">/* clear NNEEDINVALIDATE, if set */</span>
			<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np)))
				<span class="enscript-keyword">return</span> (error);
			<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NNEEDINVALIDATE)
				np-&gt;n_flag &amp;= ~NNEEDINVALIDATE;
			nfs_node_unlock(np);
			<span class="enscript-comment">/* flush everything */</span>
			error = nfs_vinvalbuf(vp, (vap-&gt;va_data_size ? V_SAVE : 0) , ctx, 1);
			<span class="enscript-keyword">if</span> (error) {
				NP(np, <span class="enscript-string">&quot;nfs_setattr: nfs_vinvalbuf %d&quot;</span>, error);
				FSDBG_BOT(512, np-&gt;n_size, vap-&gt;va_data_size, np-&gt;n_vattr.nva_size, -1);
				<span class="enscript-keyword">return</span> (error);
			}
			<span class="enscript-keyword">if</span> (nfsvers &gt;= NFS_VER4) {
				<span class="enscript-comment">/* setting file size requires having the file open for write access */</span>
				<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE)
					<span class="enscript-keyword">return</span> (EIO);
				noop = nfs_open_owner_find(nmp, vfs_context_ucred(ctx), 1);
				<span class="enscript-keyword">if</span> (!noop)
					<span class="enscript-keyword">return</span> (ENOMEM);
<span class="enscript-reference">restart</span>:
				error = nfs_mount_state_in_use_start(nmp, vfs_context_thread(ctx));
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">return</span> (error);
				<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
					nfs_mount_state_in_use_end(nmp, 0);
					<span class="enscript-keyword">return</span> (EIO);
				}
				error = nfs_open_file_find(np, noop, &amp;nofp, 0, 0, 1);
				<span class="enscript-keyword">if</span> (!error &amp;&amp; (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST))
					error = EIO;
				<span class="enscript-keyword">if</span> (!error &amp;&amp; (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN)) {
					nfs_mount_state_in_use_end(nmp, 0);
					error = nfs4_reopen(nofp, vfs_context_thread(ctx));
					nofp = NULL;
					<span class="enscript-keyword">if</span> (!error)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
				}
				<span class="enscript-keyword">if</span> (!error)
					error = nfs_open_file_set_busy(nofp, vfs_context_thread(ctx));
				<span class="enscript-keyword">if</span> (error) {
					nfs_open_owner_rele(noop);
					<span class="enscript-keyword">return</span> (error);
				}
				<span class="enscript-keyword">if</span> (!(nofp-&gt;nof_access &amp; NFS_OPEN_SHARE_ACCESS_WRITE)) {
					<span class="enscript-comment">/* we don't have the file open for write access, so open it */</span>
					error = nfs4_open(np, nofp, NFS_OPEN_SHARE_ACCESS_WRITE, NFS_OPEN_SHARE_DENY_NONE, ctx);
					<span class="enscript-keyword">if</span> (!error)
						nofp-&gt;nof_flags |= NFS_OPEN_FILE_SETATTR;
					<span class="enscript-keyword">if</span> (nfs_mount_state_error_should_restart(error)) {
						nfs_open_file_clear_busy(nofp);
						nofp = NULL;
						<span class="enscript-keyword">if</span> (nfs_mount_state_in_use_end(nmp, error))
							<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
					}
				}
			}
			nfs_data_lock(np, NFS_DATA_LOCK_EXCLUSIVE);
			<span class="enscript-keyword">if</span> (np-&gt;n_size &gt; vap-&gt;va_data_size) { <span class="enscript-comment">/* shrinking? */</span>
				daddr64_t obn, bn;
				<span class="enscript-type">int</span> neweofoff, mustwrite;
				<span class="enscript-type">struct</span> nfsbuf *bp;

				obn = (np-&gt;n_size - 1) / biosize;
				bn = vap-&gt;va_data_size / biosize;
				<span class="enscript-keyword">for</span> ( ; obn &gt;= bn; obn--) {
					<span class="enscript-keyword">if</span> (!nfs_buf_is_incore(np, obn))
						<span class="enscript-keyword">continue</span>;
					error = nfs_buf_get(np, obn, biosize, NULL, NBLK_READ, &amp;bp);
					<span class="enscript-keyword">if</span> (error)
						<span class="enscript-keyword">continue</span>;
					<span class="enscript-keyword">if</span> (obn != bn) {
						FSDBG(512, bp, bp-&gt;nb_flags, 0, obn);
						SET(bp-&gt;nb_flags, NB_INVAL);
						nfs_buf_release(bp, 1);
						<span class="enscript-keyword">continue</span>;
					}
					mustwrite = 0;
					neweofoff = vap-&gt;va_data_size - NBOFF(bp);
					<span class="enscript-comment">/* check for any dirty data before the new EOF */</span>
					<span class="enscript-keyword">if</span> ((bp-&gt;nb_dirtyend &gt; 0) &amp;&amp; (bp-&gt;nb_dirtyoff &lt; neweofoff)) {
						<span class="enscript-comment">/* clip dirty range to EOF */</span>
						<span class="enscript-keyword">if</span> (bp-&gt;nb_dirtyend &gt; neweofoff) {
							bp-&gt;nb_dirtyend = neweofoff;
							<span class="enscript-keyword">if</span> (bp-&gt;nb_dirtyoff &gt;= bp-&gt;nb_dirtyend)
								bp-&gt;nb_dirtyoff = bp-&gt;nb_dirtyend = 0;
						}
						<span class="enscript-keyword">if</span> ((bp-&gt;nb_dirtyend &gt; 0) &amp;&amp; (bp-&gt;nb_dirtyoff &lt; neweofoff))
							mustwrite++;
					}
					bp-&gt;nb_dirty &amp;= (1 &lt;&lt; round_page_32(neweofoff)/PAGE_SIZE) - 1;
					<span class="enscript-keyword">if</span> (bp-&gt;nb_dirty)
						mustwrite++;
					<span class="enscript-keyword">if</span> (!mustwrite) {
						FSDBG(512, bp, bp-&gt;nb_flags, 0, obn);
						SET(bp-&gt;nb_flags, NB_INVAL);
						nfs_buf_release(bp, 1);
						<span class="enscript-keyword">continue</span>;
					}
					<span class="enscript-comment">/* gotta write out dirty data before invalidating */</span>
					<span class="enscript-comment">/* (NB_STABLE indicates that data writes should be FILESYNC) */</span>
					<span class="enscript-comment">/* (NB_NOCACHE indicates buffer should be discarded) */</span>
					CLR(bp-&gt;nb_flags, (NB_DONE | NB_ERROR | NB_INVAL | NB_ASYNC | NB_READ));
					SET(bp-&gt;nb_flags, NB_STABLE | NB_NOCACHE);
					<span class="enscript-keyword">if</span> (!IS_VALID_CRED(bp-&gt;nb_wcred)) {
						kauth_cred_t cred = vfs_context_ucred(ctx);
						kauth_cred_ref(cred);
						bp-&gt;nb_wcred = cred;
					}
					error = nfs_buf_write(bp);
					<span class="enscript-comment">// Note: bp has been released
</span>					<span class="enscript-keyword">if</span> (error) {
						FSDBG(512, bp, 0xd00dee, 0xbad, error);
						nfs_node_lock_force(np);
						np-&gt;n_error = error;
						np-&gt;n_flag |= NWRITEERR;
						<span class="enscript-comment">/*
						 * There was a write error and we need to
						 * invalidate attrs and flush buffers in
						 * order to sync up with the server.
						 * (if this write was extending the file,
						 * we may no longer know the correct size)
						 */</span>
						NATTRINVALIDATE(np);
						nfs_node_unlock(np);
						nfs_data_unlock(np);
						nfs_vinvalbuf(vp, V_SAVE|V_IGNORE_WRITEERR, ctx, 1);
						nfs_data_lock(np, NFS_DATA_LOCK_EXCLUSIVE);
						error = 0;
					}
				}
			}
			<span class="enscript-keyword">if</span> (vap-&gt;va_data_size != np-&gt;n_size)
				ubc_setsize(vp, (off_t)vap-&gt;va_data_size); <span class="enscript-comment">/* XXX error? */</span>
			origsize = np-&gt;n_size;
			np-&gt;n_size = np-&gt;n_vattr.nva_size = vap-&gt;va_data_size;
			nfs_node_lock_force(np);
			CLR(np-&gt;n_flag, NUPDATESIZE);
			nfs_node_unlock(np);
			FSDBG(512, np, np-&gt;n_size, np-&gt;n_vattr.nva_size, 0xf00d0001);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_modify_time) ||
		    VATTR_IS_ACTIVE(vap, va_access_time) ||
		    (vap-&gt;va_vaflags &amp; VA_UTIMES_NULL)) {
		<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np)))
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">if</span> ((np-&gt;n_flag &amp; NMODIFIED) &amp;&amp; (vnode_vtype(vp) == VREG)) {
			nfs_node_unlock(np);
			error = nfs_vinvalbuf(vp, V_SAVE, ctx, 1);
			<span class="enscript-keyword">if</span> (error == EINTR)
				<span class="enscript-keyword">return</span> (error);
		} <span class="enscript-keyword">else</span> {
			nfs_node_unlock(np);
		}
	}
	<span class="enscript-keyword">if</span> ((VATTR_IS_ACTIVE(vap, va_mode) || VATTR_IS_ACTIVE(vap, va_uid) || VATTR_IS_ACTIVE(vap, va_gid) ||
	     VATTR_IS_ACTIVE(vap, va_acl) || VATTR_IS_ACTIVE(vap, va_uuuid) || VATTR_IS_ACTIVE(vap, va_guuid)) &amp;&amp;
	    !(error = nfs_node_lock(np))) {
		NACCESSINVALIDATE(np);
		nfs_node_unlock(np);
		<span class="enscript-keyword">if</span> (!namedattrs) {
			dvp = vnode_getparent(vp);
			vname = vnode_getname(vp);
			dnp = (dvp &amp;&amp; vname) ? VTONFS(dvp) : NULL;
			<span class="enscript-keyword">if</span> (dnp) {
				error = nfs_node_set_busy(dnp, vfs_context_thread(ctx));
				<span class="enscript-keyword">if</span> (error) {
					dnp = NULL;
					error = 0;
				}
			}
			<span class="enscript-keyword">if</span> (dnp) {
				nfs_dulookup_init(&amp;dul, dnp, vname, strlen(vname), ctx);
				nfs_dulookup_start(&amp;dul, dnp, ctx);
			}
		}
	}

	<span class="enscript-keyword">if</span> (!error)
		error = nmp-&gt;nm_funcs-&gt;nf_setattr_rpc(np, vap, ctx);

	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_mode) || VATTR_IS_ACTIVE(vap, va_uid) || VATTR_IS_ACTIVE(vap, va_gid) ||
	    VATTR_IS_ACTIVE(vap, va_acl) || VATTR_IS_ACTIVE(vap, va_uuuid) || VATTR_IS_ACTIVE(vap, va_guuid)) {
		<span class="enscript-keyword">if</span> (!namedattrs) {
			<span class="enscript-keyword">if</span> (dnp) {
				nfs_dulookup_finish(&amp;dul, dnp, ctx);
				nfs_node_clear_busy(dnp);
			}
			<span class="enscript-keyword">if</span> (dvp != NULLVP)
				vnode_put(dvp);
			<span class="enscript-keyword">if</span> (vname != NULL)
				vnode_putname(vname);
		}
	}

	FSDBG_BOT(512, np-&gt;n_size, vap-&gt;va_data_size, np-&gt;n_vattr.nva_size, error);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_size)) {
		<span class="enscript-keyword">if</span> (error &amp;&amp; (origsize != np-&gt;n_size) &amp;&amp;
		    ((nfsvers &lt; NFS_VER4) || !nfs_mount_state_error_should_restart(error))) {
			<span class="enscript-comment">/* make every effort to resync file size w/ server... */</span>
			<span class="enscript-comment">/* (don't bother if we'll be restarting the operation) */</span>
			<span class="enscript-type">int</span> err; <span class="enscript-comment">/* preserve &quot;error&quot; for return */</span>
			np-&gt;n_size = np-&gt;n_vattr.nva_size = origsize;
			nfs_node_lock_force(np);
			CLR(np-&gt;n_flag, NUPDATESIZE);
			nfs_node_unlock(np);
			FSDBG(512, np, np-&gt;n_size, np-&gt;n_vattr.nva_size, 0xf00d0002);
			ubc_setsize(vp, (off_t)np-&gt;n_size); <span class="enscript-comment">/* XXX check error */</span>
			vapsize = vap-&gt;va_data_size;
			vap-&gt;va_data_size = origsize;
			err = nmp-&gt;nm_funcs-&gt;nf_setattr_rpc(np, vap, ctx);
			<span class="enscript-keyword">if</span> (err)
				NP(np, <span class="enscript-string">&quot;nfs_vnop_setattr: nfs%d_setattr_rpc %d %d&quot;</span>, nfsvers, error, err);
			vap-&gt;va_data_size = vapsize;
		}
		nfs_node_lock_force(np);
		<span class="enscript-comment">/*
		 * The size was just set.  If the size is already marked for update, don't
		 * trust the newsize (it may have been set while the setattr was in progress).
		 * Clear the update flag and make sure we fetch new attributes so we are sure
		 * we have the latest size.
		 */</span>
		<span class="enscript-keyword">if</span> (ISSET(np-&gt;n_flag, NUPDATESIZE)) {
			CLR(np-&gt;n_flag, NUPDATESIZE);
			NATTRINVALIDATE(np);
			nfs_node_unlock(np);
			nfs_getattr(np, NULL, ctx, NGA_UNCACHED);
		} <span class="enscript-keyword">else</span> {
			nfs_node_unlock(np);
		}
		nfs_data_unlock(np);
		<span class="enscript-keyword">if</span> (nfsvers &gt;= NFS_VER4) {
			<span class="enscript-keyword">if</span> (nofp) {
				<span class="enscript-comment">/* don't close our setattr open if we'll be restarting... */</span>
				<span class="enscript-keyword">if</span> (!nfs_mount_state_error_should_restart(error) &amp;&amp;
				    (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_SETATTR)) {
					<span class="enscript-type">int</span> err = nfs_close(np, nofp, NFS_OPEN_SHARE_ACCESS_WRITE, NFS_OPEN_SHARE_DENY_NONE, ctx);
					<span class="enscript-keyword">if</span> (err)
						NP(np, <span class="enscript-string">&quot;nfs_vnop_setattr: close error: %d&quot;</span>, err);
					nofp-&gt;nof_flags &amp;= ~NFS_OPEN_FILE_SETATTR;
				}
				nfs_open_file_clear_busy(nofp);
				nofp = NULL;
			}
			<span class="enscript-keyword">if</span> (nfs_mount_state_in_use_end(nmp, error))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
			nfs_open_owner_rele(noop);
		}
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Do an NFS setattr RPC.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_setattr_rpc</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> vnode_attr *vap,
	vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(np);
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, status, wccpostattr = 0, nfsvers;
	u_int64_t xid, nextxid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	VATTR_SET_SUPPORTED(vap, va_mode);
	VATTR_SET_SUPPORTED(vap, va_uid);
	VATTR_SET_SUPPORTED(vap, va_gid);
	VATTR_SET_SUPPORTED(vap, va_data_size);
	VATTR_SET_SUPPORTED(vap, va_access_time);
	VATTR_SET_SUPPORTED(vap, va_modify_time);

	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_flags)) {
		<span class="enscript-keyword">if</span> (vap-&gt;va_flags) {	<span class="enscript-comment">/* we don't support setting flags */</span>
			<span class="enscript-keyword">if</span> (vap-&gt;va_active &amp; ~VNODE_ATTR_va_flags)
				<span class="enscript-keyword">return</span> (EINVAL);	<span class="enscript-comment">/* return EINVAL if other attributes also set */</span>
			<span class="enscript-keyword">else</span>
				<span class="enscript-keyword">return</span> (ENOTSUP);	<span class="enscript-comment">/* return ENOTSUP for chflags(2) */</span>
		}
		<span class="enscript-comment">/* no flags set, so we'll just ignore it */</span>
		<span class="enscript-keyword">if</span> (!(vap-&gt;va_active &amp; ~VNODE_ATTR_va_flags))
			<span class="enscript-keyword">return</span> (0); <span class="enscript-comment">/* no (other) attributes to set, so nothing to do */</span>
	}

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_build_alloc_init(error, &amp;nmreq,
		NFSX_FH(nfsvers) + NFSX_SATTR(nfsvers));
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_mode)) {
			nfsm_chain_add_32(error, &amp;nmreq, TRUE);
			nfsm_chain_add_32(error, &amp;nmreq, vap-&gt;va_mode);
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, &amp;nmreq, FALSE);
		}
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_uid)) {
			nfsm_chain_add_32(error, &amp;nmreq, TRUE);
			nfsm_chain_add_32(error, &amp;nmreq, vap-&gt;va_uid);
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, &amp;nmreq, FALSE);
		}
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_gid)) {
			nfsm_chain_add_32(error, &amp;nmreq, TRUE);
			nfsm_chain_add_32(error, &amp;nmreq, vap-&gt;va_gid);
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, &amp;nmreq, FALSE);
		}
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_size)) {
			nfsm_chain_add_32(error, &amp;nmreq, TRUE);
			nfsm_chain_add_64(error, &amp;nmreq, vap-&gt;va_data_size);
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, &amp;nmreq, FALSE);
		}
		<span class="enscript-keyword">if</span> (vap-&gt;va_vaflags &amp; VA_UTIMES_NULL) {
			nfsm_chain_add_32(error, &amp;nmreq, NFS_TIME_SET_TO_SERVER);
			nfsm_chain_add_32(error, &amp;nmreq, NFS_TIME_SET_TO_SERVER);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_access_time)) {
				nfsm_chain_add_32(error, &amp;nmreq, NFS_TIME_SET_TO_CLIENT);
				nfsm_chain_add_32(error, &amp;nmreq, vap-&gt;va_access_time.tv_sec);
				nfsm_chain_add_32(error, &amp;nmreq, vap-&gt;va_access_time.tv_nsec);
			} <span class="enscript-keyword">else</span> {
				nfsm_chain_add_32(error, &amp;nmreq, NFS_TIME_DONT_CHANGE);
			}
			<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_modify_time)) {
				nfsm_chain_add_32(error, &amp;nmreq, NFS_TIME_SET_TO_CLIENT);
				nfsm_chain_add_32(error, &amp;nmreq, vap-&gt;va_modify_time.tv_sec);
				nfsm_chain_add_32(error, &amp;nmreq, vap-&gt;va_modify_time.tv_nsec);
			} <span class="enscript-keyword">else</span> {
				nfsm_chain_add_32(error, &amp;nmreq, NFS_TIME_DONT_CHANGE);
			}
		}
		nfsm_chain_add_32(error, &amp;nmreq, FALSE);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_32(error, &amp;nmreq, VATTR_IS_ACTIVE(vap, va_mode) ?
			vtonfsv2_mode(vnode_vtype(NFSTOV(np)), vap-&gt;va_mode) : -1);
		nfsm_chain_add_32(error, &amp;nmreq, VATTR_IS_ACTIVE(vap, va_uid) ?
			vap-&gt;va_uid : (uint32_t)-1);
		nfsm_chain_add_32(error, &amp;nmreq, VATTR_IS_ACTIVE(vap, va_gid) ?
			vap-&gt;va_gid : (uint32_t)-1);
		nfsm_chain_add_32(error, &amp;nmreq, VATTR_IS_ACTIVE(vap, va_data_size) ?
			vap-&gt;va_data_size : (uint32_t)-1);
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_access_time)) {
			nfsm_chain_add_32(error, &amp;nmreq, vap-&gt;va_access_time.tv_sec);
			nfsm_chain_add_32(error, &amp;nmreq, (vap-&gt;va_access_time.tv_nsec != -1) ?
				((uint32_t)vap-&gt;va_access_time.tv_nsec / 1000) : 0xffffffff);
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, &amp;nmreq, -1);
			nfsm_chain_add_32(error, &amp;nmreq, -1);
		}
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_modify_time)) {
			nfsm_chain_add_32(error, &amp;nmreq, vap-&gt;va_modify_time.tv_sec);
			nfsm_chain_add_32(error, &amp;nmreq, (vap-&gt;va_modify_time.tv_nsec != -1) ?
				((uint32_t)vap-&gt;va_modify_time.tv_nsec / 1000) : 0xffffffff);
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, &amp;nmreq, -1);
			nfsm_chain_add_32(error, &amp;nmreq, -1);
		}
	}
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfs_request(np, NULL, &amp;nmreq, NFSPROC_SETATTR, ctx, NULL, &amp;nmrep, &amp;xid, &amp;status);
	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
		<span class="enscript-type">struct</span> timespec premtime = { 0, 0 };
		nfsm_chain_get_wcc_data(error, &amp;nmrep, np, &amp;premtime, &amp;wccpostattr, &amp;xid);
		nfsmout_if(error);
		<span class="enscript-comment">/* if file hadn't changed, update cached mtime */</span>
		<span class="enscript-keyword">if</span> (nfstimespeccmp(&amp;np-&gt;n_mtime, &amp;premtime, ==))
			NFS_CHANGED_UPDATE(nfsvers, np, &amp;np-&gt;n_vattr);
		<span class="enscript-comment">/* if directory hadn't changed, update namecache mtime */</span>
		<span class="enscript-keyword">if</span> ((vnode_vtype(NFSTOV(np)) == VDIR) &amp;&amp;
		    nfstimespeccmp(&amp;np-&gt;n_ncmtime, &amp;premtime, ==))
			NFS_CHANGED_UPDATE_NC(nfsvers, np, &amp;np-&gt;n_vattr);
		<span class="enscript-keyword">if</span> (!wccpostattr)
			NATTRINVALIDATE(np);
		error = status;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (!error)
			error = status;
		nfsm_chain_loadattr(error, &amp;nmrep, np, nfsvers, &amp;xid);
	}
	<span class="enscript-comment">/*
	 * We just changed the attributes and we want to make sure that we
	 * see the latest attributes.  Get the next XID.  If it's not the
	 * next XID after the SETATTR XID, then it's possible that another
	 * RPC was in flight at the same time and it might put stale attributes
	 * in the cache.  In that case, we invalidate the attributes and set
	 * the attribute cache XID to guarantee that newer attributes will
	 * get loaded next.
	 */</span>
	nextxid = 0;
	nfs_get_xid(&amp;nextxid);
	<span class="enscript-keyword">if</span> (nextxid != (xid + 1)) {
		np-&gt;n_xid = nextxid;
		NATTRINVALIDATE(np);
	}
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS lookup call, one step at a time...
 * First look in cache
 * If not found, unlock the directory nfsnode and do the RPC
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_lookup</span>(
	<span class="enscript-type">struct</span> vnop_lookup_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_dvp;
		vnode_t *a_vpp;
		struct componentname *a_cnp;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	<span class="enscript-type">struct</span> componentname *cnp = ap-&gt;a_cnp;
	vnode_t dvp = ap-&gt;a_dvp;
	vnode_t *vpp = ap-&gt;a_vpp;
	<span class="enscript-type">int</span> flags = cnp-&gt;cn_flags;
	vnode_t newvp;
	nfsnode_t dnp, np;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	mount_t mp;
	<span class="enscript-type">int</span> nfsvers, error, busyerror = ENOENT, isdot, isdotdot, negnamecache;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">int</span> ngflags;
	<span class="enscript-type">struct</span> vnop_access_args naa;
	fhandle_t fh;
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;

	*vpp = NULLVP;

	dnp = VTONFS(dvp);
	NVATTR_INIT(&amp;nvattr);

	mp = vnode_mount(dvp);
	nmp = VFSTONFS(mp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_return</span>;
	}
	nfsvers = nmp-&gt;nm_vers;
	negnamecache = !NMFLAG(nmp, NONEGNAMECACHE);

	<span class="enscript-keyword">if</span> ((error = busyerror = nfs_node_set_busy(dnp, vfs_context_thread(ctx))))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_return</span>;
	<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
	<span class="enscript-keyword">if</span> ((error = nfs_getattr(dnp, NULL, ctx, NGA_CACHED)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_return</span>;

	error = cache_lookup(dvp, vpp, cnp);
	<span class="enscript-keyword">switch</span> (error) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOENT</span>:
		<span class="enscript-comment">/* negative cache entry */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_return</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		<span class="enscript-comment">/* cache miss */</span>
		<span class="enscript-keyword">if</span> ((nfsvers &gt; NFS_VER2) &amp;&amp; NMFLAG(nmp, RDIRPLUS)) {
			<span class="enscript-comment">/* if rdirplus, try dir buf cache lookup */</span>
			error = nfs_dir_buf_cache_lookup(dnp, &amp;np, cnp, ctx, 0);
			<span class="enscript-keyword">if</span> (!error &amp;&amp; np) {
				<span class="enscript-comment">/* dir buf cache hit */</span>
				*vpp = NFSTOV(np);
				error = -1;
			}
		}
		<span class="enscript-keyword">if</span> (error != -1) <span class="enscript-comment">/* cache miss */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* FALLTHROUGH */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">-1</span>:
		<span class="enscript-comment">/* cache hit, not really an error */</span>
		OSAddAtomic64(1, &amp;nfsstats.lookupcache_hits);

		nfs_node_clear_busy(dnp);
		busyerror = ENOENT;

		<span class="enscript-comment">/* check for directory access */</span>
		naa.a_desc = &amp;vnop_access_desc;
		naa.a_vp = dvp;
		naa.a_action = KAUTH_VNODE_SEARCH;
		naa.a_context = ctx;

		<span class="enscript-comment">/* compute actual success/failure based on accessibility */</span>
		error = nfs_vnop_access(&amp;naa);
		<span class="enscript-comment">/* FALLTHROUGH */</span>
	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/* unexpected error from cache_lookup */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_return</span>;
	}

	<span class="enscript-comment">/* skip lookup, if we know who we are: &quot;.&quot; or &quot;..&quot; */</span>
	isdot = isdotdot = 0;
	<span class="enscript-keyword">if</span> (cnp-&gt;cn_nameptr[0] == <span class="enscript-string">'.'</span>) {
		<span class="enscript-keyword">if</span> (cnp-&gt;cn_namelen == 1)
			isdot = 1;
		<span class="enscript-keyword">if</span> ((cnp-&gt;cn_namelen == 2) &amp;&amp; (cnp-&gt;cn_nameptr[1] == <span class="enscript-string">'.'</span>))
			isdotdot = 1;
	}
	<span class="enscript-keyword">if</span> (isdotdot || isdot) {
		fh.fh_len = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;
	}
	<span class="enscript-keyword">if</span> ((nfsvers &gt;= NFS_VER4) &amp;&amp; (dnp-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER)) {
		<span class="enscript-comment">/* we should never be looking things up in a trigger directory, return nothing */</span>
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_return</span>;
	}

	<span class="enscript-comment">/* do we know this name is too long? */</span>
	nmp = VTONMP(dvp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_return</span>;
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_MAXNAME) &amp;&amp;
	     (cnp-&gt;cn_namelen &gt; (<span class="enscript-type">int</span>)nmp-&gt;nm_fsattr.nfsa_maxname)) {
		error = ENAMETOOLONG;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_return</span>;
	}

	error = 0;
	newvp = NULLVP;

	OSAddAtomic64(1, &amp;nfsstats.lookupcache_misses);

	error = nmp-&gt;nm_funcs-&gt;nf_lookup_rpc_async(dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx, &amp;req);
	nfsmout_if(error);
	error = nmp-&gt;nm_funcs-&gt;nf_lookup_rpc_async_finish(dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx, req, &amp;xid, &amp;fh, &amp;nvattr);
	nfsmout_if(error);

	<span class="enscript-comment">/* is the file handle the same as this directory's file handle? */</span>
	isdot = NFS_CMPFH(dnp, fh.fh_data, fh.fh_len);

<span class="enscript-reference">found</span>:
	<span class="enscript-keyword">if</span> (flags &amp; ISLASTCN) {
		<span class="enscript-keyword">switch</span> (cnp-&gt;cn_nameiop) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">DELETE</span>:
			cnp-&gt;cn_flags &amp;= ~MAKEENTRY;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RENAME</span>:
			cnp-&gt;cn_flags &amp;= ~MAKEENTRY;
			<span class="enscript-keyword">if</span> (isdot) {
				error = EISDIR;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_return</span>;
			}
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (isdotdot) {
		newvp = vnode_getparent(dvp);
		<span class="enscript-keyword">if</span> (!newvp) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_return</span>;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (isdot) {
		error = vnode_get(dvp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_return</span>;
		newvp = dvp;
		nfs_node_lock_force(dnp);
		<span class="enscript-keyword">if</span> (fh.fh_len &amp;&amp; (dnp-&gt;n_xid &lt;= xid))
			nfs_loadattrcache(dnp, &amp;nvattr, &amp;xid, 0);
		nfs_node_unlock(dnp);
	} <span class="enscript-keyword">else</span> {
		ngflags = (cnp-&gt;cn_flags &amp; MAKEENTRY) ? NG_MAKEENTRY : 0;
		error = nfs_nget(mp, dnp, cnp, fh.fh_data, fh.fh_len, &amp;nvattr, &amp;xid, rq.r_auth, ngflags, &amp;np);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_return</span>;
		newvp = NFSTOV(np);
		nfs_node_unlock(np);
	}
	*vpp = newvp;

<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (((cnp-&gt;cn_nameiop == CREATE) || (cnp-&gt;cn_nameiop == RENAME)) &amp;&amp;
		    (flags &amp; ISLASTCN) &amp;&amp; (error == ENOENT)) {
			<span class="enscript-keyword">if</span> (vnode_mount(dvp) &amp;&amp; vnode_vfsisrdonly(dvp))
				error = EROFS;
			<span class="enscript-keyword">else</span>
				error = EJUSTRETURN;
		}
	}
	<span class="enscript-keyword">if</span> ((error == ENOENT) &amp;&amp; (cnp-&gt;cn_flags &amp; MAKEENTRY) &amp;&amp;
	    (cnp-&gt;cn_nameiop != CREATE) &amp;&amp; negnamecache) {
		<span class="enscript-comment">/* add a negative entry in the name cache */</span>
		nfs_node_lock_force(dnp);
		cache_enter(dvp, NULL, cnp);
		dnp-&gt;n_flag |= NNEGNCENTRIES;
		nfs_node_unlock(dnp);
	}
<span class="enscript-reference">error_return</span>:
	NVATTR_CLEANUP(&amp;nvattr);
	<span class="enscript-keyword">if</span> (!busyerror)
		nfs_node_clear_busy(dnp);
	<span class="enscript-keyword">if</span> (error &amp;&amp; *vpp) {
	        vnode_put(*vpp);
		*vpp = NULLVP;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span> nfs_readlink_nocache = DEFAULT_READLINK_NOCACHE;

<span class="enscript-comment">/*
 * NFS readlink call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_readlink</span>(
	<span class="enscript-type">struct</span> vnop_readlink_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		struct uio *a_uio;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	nfsnode_t np = VTONFS(ap-&gt;a_vp);
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, nfsvers;
	uint32_t buflen;
	uio_t uio = ap-&gt;a_uio;
	<span class="enscript-type">struct</span> nfsbuf *bp = NULL;
	<span class="enscript-type">struct</span> timespec ts;
	<span class="enscript-type">int</span> timeo;

	<span class="enscript-keyword">if</span> (vnode_vtype(ap-&gt;a_vp) != VLNK)
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-keyword">if</span> (uio_resid(uio) == 0)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> (uio_offset(uio) &lt; 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	nmp = VTONMP(ap-&gt;a_vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	
	<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
	<span class="enscript-keyword">if</span> ((error = nfs_getattr(np, NULL, ctx, nfs_readlink_nocache ? NGA_UNCACHED : NGA_CACHED))) {
		FSDBG(531, np, 0xd1e0001, 0, error);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> (nfs_readlink_nocache) {
		timeo = nfs_attrcachetimeout(np);
		nanouptime(&amp;ts);
	}
	
<span class="enscript-reference">retry</span>:
	OSAddAtomic64(1, &amp;nfsstats.biocache_readlinks);
	error = nfs_buf_get(np, 0, NFS_MAXPATHLEN, vfs_context_thread(ctx), NBLK_META, &amp;bp);
	<span class="enscript-keyword">if</span> (error) {
		FSDBG(531, np, 0xd1e0002, 0, error);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> (nfs_readlink_nocache) {
		NFS_VNOP_DBG(<span class="enscript-string">&quot;timeo = %d ts.tv_sec = %ld need refresh = %d cached = %d\n&quot;</span>, timeo, ts.tv_sec,
			     (np-&gt;n_rltim.tv_sec + timeo) &lt; ts.tv_sec || nfs_readlink_nocache &gt; 1, 
			     ISSET(bp-&gt;nb_flags, NB_CACHE) == NB_CACHE);
		<span class="enscript-comment">/* n_rltim is synchronized by the associated nfs buf */</span>
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_CACHE) &amp;&amp; ((nfs_readlink_nocache &gt; 1)  || ((np-&gt;n_rltim.tv_sec + timeo) &lt; ts.tv_sec))) {
			SET(bp-&gt;nb_flags, NB_INVAL);
			nfs_buf_release(bp, 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}
	}
	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_CACHE)) {
<span class="enscript-reference">readagain</span>:
		OSAddAtomic64(1, &amp;nfsstats.readlink_bios);
		buflen = bp-&gt;nb_bufsize;
		error = nmp-&gt;nm_funcs-&gt;nf_readlink_rpc(np, bp-&gt;nb_data, &amp;buflen, ctx);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error == ESTALE) {
				NFS_VNOP_DBG(<span class="enscript-string">&quot;Stale FH from readlink rpc\n&quot;</span>);
				error = nfs_refresh_fh(np, ctx);
				<span class="enscript-keyword">if</span> (error == 0)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">readagain</span>;
			}
			SET(bp-&gt;nb_flags, NB_ERROR);
			bp-&gt;nb_error = error;
			NFS_VNOP_DBG(<span class="enscript-string">&quot;readlink failed %d\n&quot;</span>, error);
		} <span class="enscript-keyword">else</span> {
			bp-&gt;nb_validoff = 0;
			bp-&gt;nb_validend = buflen;
			np-&gt;n_rltim = ts;
			NFS_VNOP_DBG(<span class="enscript-string">&quot;readlink of %.*s\n&quot;</span>, bp-&gt;nb_validend, (<span class="enscript-type">char</span> *)bp-&gt;nb_data);
		}
	} <span class="enscript-keyword">else</span> {
		NFS_VNOP_DBG(<span class="enscript-string">&quot;got cached link of %.*s\n&quot;</span>, bp-&gt;nb_validend, (<span class="enscript-type">char</span> *)bp-&gt;nb_data);
	}
	
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (bp-&gt;nb_validend &gt; 0))
		error = uiomove(bp-&gt;nb_data, bp-&gt;nb_validend, uio);
	FSDBG(531, np, bp-&gt;nb_validend, 0, error);
	nfs_buf_release(bp, 1);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Do a readlink RPC.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_readlink_rpc</span>(nfsnode_t np, <span class="enscript-type">char</span> *buf, uint32_t *buflenp, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, nfsvers, status;
	uint32_t len;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_build_alloc_init(error, &amp;nmreq, NFSX_FH(nfsvers));
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfs_request(np, NULL, &amp;nmreq, NFSPROC_READLINK, ctx, NULL, &amp;nmrep, &amp;xid, &amp;status);
	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
		nfsm_chain_postop_attr_update(error, &amp;nmrep, np, &amp;xid);
	<span class="enscript-keyword">if</span> (!error)
		error = status;
	nfsm_chain_get_32(error, &amp;nmrep, len);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER2) &amp;&amp; (len &gt; *buflenp)) {
		error = EBADRPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}
	<span class="enscript-keyword">if</span> (len &gt;= *buflenp) {
		<span class="enscript-keyword">if</span> (np-&gt;n_size &amp;&amp; (np-&gt;n_size &lt; *buflenp))
			len = np-&gt;n_size;
		<span class="enscript-keyword">else</span>
			len = *buflenp - 1;
	}
	nfsm_chain_get_opaque(error, &amp;nmrep, len, buf);
	<span class="enscript-keyword">if</span> (!error)
		*buflenp = len;
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS read RPC call
 * Ditto above
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_read_rpc</span>(nfsnode_t np, uio_t uio, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, nfsvers, eof = 0;
	size_t nmrsize, len, retlen;
	user_ssize_t tsiz;
	off_t txoffset;
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;
	uint32_t stategenid = 0, restart = 0;

	FSDBG_TOP(536, np, uio_offset(uio), uio_resid(uio), 0);
	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	nmrsize = nmp-&gt;nm_rsize;

	txoffset = uio_offset(uio);
	tsiz = uio_resid(uio);
	<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER2) &amp;&amp; ((uint64_t)(txoffset + tsiz) &gt; 0xffffffffULL)) {
		FSDBG_BOT(536, np, uio_offset(uio), uio_resid(uio), EFBIG);
		<span class="enscript-keyword">return</span> (EFBIG);
	}

	<span class="enscript-keyword">while</span> (tsiz &gt; 0) {
		len = retlen = (tsiz &gt; (user_ssize_t)nmrsize) ? nmrsize : (size_t)tsiz;
		FSDBG(536, np, txoffset, len, 0);
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
			error = EIO;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4)
			stategenid = nmp-&gt;nm_stategenid;
		error = nmp-&gt;nm_funcs-&gt;nf_read_rpc_async(np, txoffset, len,
				vfs_context_thread(ctx), vfs_context_ucred(ctx), NULL, &amp;req);
		<span class="enscript-keyword">if</span> (!error)
			error = nmp-&gt;nm_funcs-&gt;nf_read_rpc_async_finish(np, req, uio, &amp;retlen, &amp;eof);
		<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; nfs_mount_state_error_should_restart(error) &amp;&amp;
		    (++restart &lt;= nfs_mount_state_max_restarts(nmp))) { <span class="enscript-comment">/* guard against no progress */</span>
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">if</span> ((error != NFSERR_GRACE) &amp;&amp; (stategenid == nmp-&gt;nm_stategenid)) {
				NP(np, <span class="enscript-string">&quot;nfs_read_rpc: error %d, initiating recovery&quot;</span>, error);
				nfs_need_recover(nmp, error);
			}
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
				error = EIO;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (error == NFSERR_GRACE)
					tsleep(&amp;nmp-&gt;nm_state, (PZERO-1), <span class="enscript-string">&quot;nfsgrace&quot;</span>, 2*hz);
				<span class="enscript-keyword">if</span> (!(error = nfs_mount_state_wait_for_recovery(nmp)))
					<span class="enscript-keyword">continue</span>;
			}
		}
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		txoffset += retlen;
		tsiz -= retlen;
		<span class="enscript-keyword">if</span> (nfsvers != NFS_VER2) {
			<span class="enscript-keyword">if</span> (eof || (retlen == 0))
				tsiz = 0;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (retlen &lt; len)
			tsiz = 0;
	}

	FSDBG_BOT(536, np, eof, uio_resid(uio), error);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_read_rpc_async</span>(
	nfsnode_t np,
	off_t offset,
	size_t len,
	thread_t thd,
	kauth_cred_t cred,
	<span class="enscript-type">struct</span> nfsreq_cbinfo *cb,
	<span class="enscript-type">struct</span> nfsreq **reqp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, nfsvers;
	<span class="enscript-type">struct</span> nfsm_chain nmreq;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_build_alloc_init(error, &amp;nmreq, NFSX_FH(nfsvers) + 3 * NFSX_UNSIGNED);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
		nfsm_chain_add_64(error, &amp;nmreq, offset);
		nfsm_chain_add_32(error, &amp;nmreq, len);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_32(error, &amp;nmreq, offset);
		nfsm_chain_add_32(error, &amp;nmreq, len);
		nfsm_chain_add_32(error, &amp;nmreq, 0);
	}
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfs_request_async(np, NULL, &amp;nmreq, NFSPROC_READ, thd, cred, NULL, 0, cb, reqp);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_read_rpc_async_finish</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfsreq *req,
	uio_t uio,
	size_t *lenp,
	<span class="enscript-type">int</span> *eofp)
{
	<span class="enscript-type">int</span> error = 0, lockerror, nfsvers, status, eof = 0;
	size_t retlen = 0;
	uint64_t xid;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfsm_chain nmrep;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		nfs_request_async_cancel(req);
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	nfsvers = nmp-&gt;nm_vers;

	nfsm_chain_null(&amp;nmrep);

	error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);
	<span class="enscript-keyword">if</span> (error == EINPROGRESS) <span class="enscript-comment">/* async request restarted */</span>
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
		nfsm_chain_postop_attr_update(error, &amp;nmrep, np, &amp;xid);
	<span class="enscript-keyword">if</span> (!error)
		error = status;
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
		nfsm_chain_adv(error, &amp;nmrep, NFSX_UNSIGNED);
		nfsm_chain_get_32(error, &amp;nmrep, eof);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_loadattr(error, &amp;nmrep, np, nfsvers, &amp;xid);
	}
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfsm_chain_get_32(error, &amp;nmrep, retlen);
	<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER2) &amp;&amp; (retlen &gt; *lenp))
		error = EBADRPC;
	nfsmout_if(error);
	error = nfsm_chain_get_uio(&amp;nmrep, MIN(retlen, *lenp), uio);
	<span class="enscript-keyword">if</span> (eofp) {
		<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
			<span class="enscript-keyword">if</span> (!eof &amp;&amp; !retlen)
				eof = 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (retlen &lt; *lenp) {
			eof = 1;
		}
		*eofp = eof;
	}
	*lenp = MIN(retlen, *lenp);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS write call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_write</span>(
	<span class="enscript-type">struct</span> vnop_write_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		struct uio *a_uio;
		int a_ioflag;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	uio_t uio = ap-&gt;a_uio;
	vnode_t vp = ap-&gt;a_vp;
	nfsnode_t np = VTONFS(vp);
	<span class="enscript-type">int</span> ioflag = ap-&gt;a_ioflag;
	<span class="enscript-type">struct</span> nfsbuf *bp;
	<span class="enscript-type">struct</span> nfsmount *nmp = VTONMP(vp);
	daddr64_t lbn;
	<span class="enscript-type">int</span> biosize;
	<span class="enscript-type">int</span> n, on, error = 0;
	off_t boff, start, end;
	uio_t auio;
	<span class="enscript-type">char</span> auio_buf [ UIO_SIZEOF(1) ];
	thread_t thd;
	kauth_cred_t cred;

	FSDBG_TOP(515, np, uio_offset(uio), uio_resid(uio), ioflag);

	<span class="enscript-keyword">if</span> (vnode_vtype(vp) != VREG) {
		FSDBG_BOT(515, np, uio_offset(uio), uio_resid(uio), EIO);
		<span class="enscript-keyword">return</span> (EIO);
	}

	thd = vfs_context_thread(ctx);
	cred = vfs_context_ucred(ctx);

	nfs_data_lock(np, NFS_DATA_LOCK_SHARED);

	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np))) {
		nfs_data_unlock(np);
		FSDBG_BOT(515, np, uio_offset(uio), uio_resid(uio), error);
		<span class="enscript-keyword">return</span> (error);
	}
	np-&gt;n_wrbusy++;

	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NWRITEERR) {
		error = np-&gt;n_error;
		np-&gt;n_flag &amp;= ~NWRITEERR;
	}
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NNEEDINVALIDATE) {
		np-&gt;n_flag &amp;= ~NNEEDINVALIDATE;
		nfs_node_unlock(np);
		nfs_data_unlock(np);
		nfs_vinvalbuf(vp, V_SAVE|V_IGNORE_WRITEERR, ctx, 1);
		nfs_data_lock(np, NFS_DATA_LOCK_SHARED);
	} <span class="enscript-keyword">else</span> {
		nfs_node_unlock(np);
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	biosize = nmp-&gt;nm_biosize;

	<span class="enscript-keyword">if</span> (ioflag &amp; (IO_APPEND | IO_SYNC)) {
		nfs_node_lock_force(np);
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NMODIFIED) {
			NATTRINVALIDATE(np);
			nfs_node_unlock(np);
			nfs_data_unlock(np);
			error = nfs_vinvalbuf(vp, V_SAVE, ctx, 1);
			nfs_data_lock(np, NFS_DATA_LOCK_SHARED);
			<span class="enscript-keyword">if</span> (error) {
				FSDBG(515, np, uio_offset(uio), 0x10bad01, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		} <span class="enscript-keyword">else</span> {
			nfs_node_unlock(np);
		}
		<span class="enscript-keyword">if</span> (ioflag &amp; IO_APPEND) {
			nfs_data_unlock(np);
			<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
			error = nfs_getattr(np, NULL, ctx, NGA_UNCACHED);
			<span class="enscript-comment">/* we'll be extending the file, so take the data lock exclusive */</span>
			nfs_data_lock(np, NFS_DATA_LOCK_EXCLUSIVE);
			<span class="enscript-keyword">if</span> (error) {
				FSDBG(515, np, uio_offset(uio), 0x10bad02, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			uio_setoffset(uio, np-&gt;n_size);
		}
	}
	<span class="enscript-keyword">if</span> (uio_offset(uio) &lt; 0) {
		error = EINVAL;
		FSDBG_BOT(515, np, uio_offset(uio), 0xbad0ff, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (uio_resid(uio) == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (((uio_offset(uio) + uio_resid(uio)) &gt; (off_t)np-&gt;n_size) &amp;&amp; !(ioflag &amp; IO_APPEND)) {
		<span class="enscript-comment">/*
		 * It looks like we'll be extending the file, so take the data lock exclusive.
		 */</span>
		nfs_data_unlock(np);
		nfs_data_lock(np, NFS_DATA_LOCK_EXCLUSIVE);

		<span class="enscript-comment">/*
		 * Also, if the write begins after the previous EOF buffer, make sure to zero
		 * and validate the new bytes in that buffer.
		 */</span>
		<span class="enscript-type">struct</span> nfsbuf *eofbp = NULL;
		daddr64_t eofbn = np-&gt;n_size / biosize;
		<span class="enscript-type">int</span> eofoff = np-&gt;n_size % biosize;
		lbn = uio_offset(uio) / biosize;

		<span class="enscript-keyword">if</span> (eofoff &amp;&amp; (eofbn &lt; lbn)) {
			<span class="enscript-keyword">if</span> ((error = nfs_buf_get(np, eofbn, biosize, thd, NBLK_WRITE|NBLK_ONLYVALID, &amp;eofbp)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			np-&gt;n_size += (biosize - eofoff);
			nfs_node_lock_force(np);
			CLR(np-&gt;n_flag, NUPDATESIZE);
			np-&gt;n_flag |= NMODIFIED;
			nfs_node_unlock(np);
			FSDBG(516, np, np-&gt;n_size, np-&gt;n_vattr.nva_size, 0xf00d0001);
			ubc_setsize(vp, (off_t)np-&gt;n_size); <span class="enscript-comment">/* XXX errors */</span>
			<span class="enscript-keyword">if</span> (eofbp) {
				<span class="enscript-comment">/*
				 * For the old last page, don't zero bytes if there
				 * are invalid bytes in that page (i.e. the page isn't
				 * currently valid).
				 * For pages after the old last page, zero them and
				 * mark them as valid.
				 */</span>
				<span class="enscript-type">char</span> *d;
				<span class="enscript-type">int</span> i;
				<span class="enscript-keyword">if</span> (ioflag &amp; IO_NOCACHE)
					SET(eofbp-&gt;nb_flags, NB_NOCACHE);
				NFS_BUF_MAP(eofbp);
				FSDBG(516, eofbp, eofoff, biosize - eofoff, 0xe0fff01e);
				d = eofbp-&gt;nb_data;
				i = eofoff/PAGE_SIZE;
				<span class="enscript-keyword">while</span> (eofoff &lt; biosize) {
					<span class="enscript-type">int</span> poff = eofoff &amp; PAGE_MASK;
					<span class="enscript-keyword">if</span> (!poff || NBPGVALID(eofbp,i)) {
						bzero(d + eofoff, PAGE_SIZE - poff);
						NBPGVALID_SET(eofbp, i);
					}
					eofoff += PAGE_SIZE - poff;
					i++;
				}
				nfs_buf_release(eofbp, 1);
			}
		}
	}

	<span class="enscript-keyword">do</span> {
		OSAddAtomic64(1, &amp;nfsstats.biocache_writes);
		lbn = uio_offset(uio) / biosize;
		on = uio_offset(uio) % biosize;
		n = biosize - on;
		<span class="enscript-keyword">if</span> (uio_resid(uio) &lt; n)
			n = uio_resid(uio);
<span class="enscript-reference">again</span>:
		<span class="enscript-comment">/*
		 * Get a cache block for writing.  The range to be written is
		 * (off..off+n) within the block.  We ensure that the block
		 * either has no dirty region or that the given range is
		 * contiguous with the existing dirty region.
		 */</span>
		error = nfs_buf_get(np, lbn, biosize, thd, NBLK_WRITE, &amp;bp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		<span class="enscript-comment">/* map the block because we know we're going to write to it */</span>
		NFS_BUF_MAP(bp);

		<span class="enscript-keyword">if</span> (ioflag &amp; IO_NOCACHE)
			SET(bp-&gt;nb_flags, NB_NOCACHE);

		<span class="enscript-keyword">if</span> (!IS_VALID_CRED(bp-&gt;nb_wcred)) {
			kauth_cred_ref(cred);
			bp-&gt;nb_wcred = cred;
		}

		<span class="enscript-comment">/*
		 * If there's already a dirty range AND dirty pages in this block we
		 * need to send a commit AND write the dirty pages before continuing.
		 *
		 * If there's already a dirty range OR dirty pages in this block
		 * and the new write range is not contiguous with the existing range,
		 * then force the buffer to be written out now.
		 * (We used to just extend the dirty range to cover the valid,
		 * but unwritten, data in between also.  But writing ranges
		 * of data that weren't actually written by an application
		 * risks overwriting some other client's data with stale data
		 * that's just masquerading as new written data.)
		 */</span>
		<span class="enscript-keyword">if</span> (bp-&gt;nb_dirtyend &gt; 0) {
		    <span class="enscript-keyword">if</span> (on &gt; bp-&gt;nb_dirtyend || (on + n) &lt; bp-&gt;nb_dirtyoff || bp-&gt;nb_dirty) {
			FSDBG(515, np, uio_offset(uio), bp, 0xd15c001);
			<span class="enscript-comment">/* write/commit buffer &quot;synchronously&quot; */</span>
			<span class="enscript-comment">/* (NB_STABLE indicates that data writes should be FILESYNC) */</span>
			CLR(bp-&gt;nb_flags, (NB_DONE | NB_ERROR | NB_INVAL));
			SET(bp-&gt;nb_flags, (NB_ASYNC | NB_STABLE));
			error = nfs_buf_write(bp);
			<span class="enscript-keyword">if</span> (error)
			    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
		    }
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bp-&gt;nb_dirty) {
		    <span class="enscript-type">int</span> firstpg, lastpg;
		    u_int32_t pagemask;
		    <span class="enscript-comment">/* calculate write range pagemask */</span>
		    firstpg = on/PAGE_SIZE;
		    lastpg = (on+n-1)/PAGE_SIZE;
		    pagemask = ((1 &lt;&lt; (lastpg+1)) - 1) &amp; ~((1 &lt;&lt; firstpg) - 1);
		    <span class="enscript-comment">/* check if there are dirty pages outside the write range */</span>
		    <span class="enscript-keyword">if</span> (bp-&gt;nb_dirty &amp; ~pagemask) {
			FSDBG(515, np, uio_offset(uio), bp, 0xd15c002);
			<span class="enscript-comment">/* write/commit buffer &quot;synchronously&quot; */</span>
			<span class="enscript-comment">/* (NB_STABLE indicates that data writes should be FILESYNC) */</span>
			CLR(bp-&gt;nb_flags, (NB_DONE | NB_ERROR | NB_INVAL));
			SET(bp-&gt;nb_flags, (NB_ASYNC | NB_STABLE));
			error = nfs_buf_write(bp);
			<span class="enscript-keyword">if</span> (error)
			    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
		    }
		    <span class="enscript-comment">/* if the first or last pages are already dirty */</span>
		    <span class="enscript-comment">/* make sure that the dirty range encompasses those pages */</span>
		    <span class="enscript-keyword">if</span> (NBPGDIRTY(bp,firstpg) || NBPGDIRTY(bp,lastpg)) {
			FSDBG(515, np, uio_offset(uio), bp, 0xd15c003);
		    	bp-&gt;nb_dirtyoff = min(on, firstpg * PAGE_SIZE);
			<span class="enscript-keyword">if</span> (NBPGDIRTY(bp,lastpg)) {
			    bp-&gt;nb_dirtyend = (lastpg+1) * PAGE_SIZE;
			    <span class="enscript-comment">/* clip to EOF */</span>
			    <span class="enscript-keyword">if</span> (NBOFF(bp) + bp-&gt;nb_dirtyend &gt; (off_t)np-&gt;n_size) {
				    bp-&gt;nb_dirtyend = np-&gt;n_size - NBOFF(bp);
				    <span class="enscript-keyword">if</span> (bp-&gt;nb_dirtyoff &gt;= bp-&gt;nb_dirtyend)
					    bp-&gt;nb_dirtyoff = bp-&gt;nb_dirtyend = 0;
			    }
			} <span class="enscript-keyword">else</span>
			    bp-&gt;nb_dirtyend = on+n;
		    }
		}

		<span class="enscript-comment">/*
		 * Are we extending the size of the file with this write?
		 * If so, update file size now that we have the block.
		 * If there was a partial buf at the old eof, validate
		 * and zero the new bytes.
		 */</span>
		<span class="enscript-keyword">if</span> ((uio_offset(uio) + n) &gt; (off_t)np-&gt;n_size) {
			daddr64_t eofbn = np-&gt;n_size / biosize;
			<span class="enscript-type">int</span> neweofoff = (uio_offset(uio) + n) % biosize;

			FSDBG(515, 0xb1ffa000, uio_offset(uio) + n, eofoff, neweofoff);

			<span class="enscript-comment">/* if we're extending within the same last block */</span>
			<span class="enscript-comment">/* and the block is flagged as being cached... */</span>
			<span class="enscript-keyword">if</span> ((lbn == eofbn) &amp;&amp; ISSET(bp-&gt;nb_flags, NB_CACHE)) {
				<span class="enscript-comment">/* ...check that all pages in buffer are valid */</span>
				<span class="enscript-type">int</span> endpg = ((neweofoff ? neweofoff : biosize) - 1)/PAGE_SIZE;
				u_int32_t pagemask;
				<span class="enscript-comment">/* pagemask only has to extend to last page being written to */</span>
				pagemask = (1 &lt;&lt; (endpg+1)) - 1;
				FSDBG(515, 0xb1ffa001, bp-&gt;nb_valid, pagemask, 0);
				<span class="enscript-keyword">if</span> ((bp-&gt;nb_valid &amp; pagemask) != pagemask) {
					<span class="enscript-comment">/* zerofill any hole */</span>
					<span class="enscript-keyword">if</span> (on &gt; bp-&gt;nb_validend) {
						<span class="enscript-type">int</span> i;
						<span class="enscript-keyword">for</span> (i=bp-&gt;nb_validend/PAGE_SIZE; i &lt;= (on - 1)/PAGE_SIZE; i++)
							NBPGVALID_SET(bp, i);
						NFS_BUF_MAP(bp);
						FSDBG(516, bp, bp-&gt;nb_validend, on - bp-&gt;nb_validend, 0xf01e);
						bzero((<span class="enscript-type">char</span> *)bp-&gt;nb_data + bp-&gt;nb_validend,
							on - bp-&gt;nb_validend);
					}
					<span class="enscript-comment">/* zerofill any trailing data in the last page */</span>
					<span class="enscript-keyword">if</span> (neweofoff) {
						NFS_BUF_MAP(bp);
						FSDBG(516, bp, neweofoff, PAGE_SIZE - (neweofoff &amp; PAGE_MASK), 0xe0f);
						bzero((<span class="enscript-type">char</span> *)bp-&gt;nb_data + neweofoff,
							PAGE_SIZE - (neweofoff &amp; PAGE_MASK));
					}
				}
			}
			np-&gt;n_size = uio_offset(uio) + n;
			nfs_node_lock_force(np);
			CLR(np-&gt;n_flag, NUPDATESIZE);
			np-&gt;n_flag |= NMODIFIED;
			nfs_node_unlock(np);
			FSDBG(516, np, np-&gt;n_size, np-&gt;n_vattr.nva_size, 0xf00d0001);
			ubc_setsize(vp, (off_t)np-&gt;n_size); <span class="enscript-comment">/* XXX errors */</span>
		}
		<span class="enscript-comment">/*
		 * If dirtyend exceeds file size, chop it down.  This should
		 * not occur unless there is a race.
		 */</span>
		<span class="enscript-keyword">if</span> (NBOFF(bp) + bp-&gt;nb_dirtyend &gt; (off_t)np-&gt;n_size) {
			bp-&gt;nb_dirtyend = np-&gt;n_size - NBOFF(bp);
			<span class="enscript-keyword">if</span> (bp-&gt;nb_dirtyoff &gt;= bp-&gt;nb_dirtyend)
				bp-&gt;nb_dirtyoff = bp-&gt;nb_dirtyend = 0;
		}
		<span class="enscript-comment">/*
		 * UBC doesn't handle partial pages, so we need to make sure
		 * that any pages left in the page cache are completely valid.
		 *
		 * Writes that are smaller than a block are delayed if they
		 * don't extend to the end of the block.
		 *
		 * If the block isn't (completely) cached, we may need to read
		 * in some parts of pages that aren't covered by the write.
		 * If the write offset (on) isn't page aligned, we'll need to
		 * read the start of the first page being written to.  Likewise,
		 * if the offset of the end of the write (on+n) isn't page aligned,
		 * we'll need to read the end of the last page being written to.
		 *
		 * Notes:
		 * We don't want to read anything we're just going to write over.
		 * We don't want to read anything we're just going drop when the
		 *   I/O is complete (i.e. don't do reads for NOCACHE requests).
		 * We don't want to issue multiple I/Os if we don't have to
		 *   (because they're synchronous rpcs).
		 * We don't want to read anything we already have modified in the
		 *   page cache.
		 */</span>
		<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_CACHE) &amp;&amp; (n &lt; biosize)) {
			<span class="enscript-type">int</span> firstpg, lastpg, dirtypg;
			<span class="enscript-type">int</span> firstpgoff, lastpgoff;
			start = end = -1;
			firstpg = on/PAGE_SIZE;
			firstpgoff = on &amp; PAGE_MASK;
			lastpg = (on+n-1)/PAGE_SIZE;
			lastpgoff = (on+n) &amp; PAGE_MASK;
			<span class="enscript-keyword">if</span> (firstpgoff &amp;&amp; !NBPGVALID(bp,firstpg)) {
				<span class="enscript-comment">/* need to read start of first page */</span>
				start = firstpg * PAGE_SIZE;
				end = start + firstpgoff;
			}
			<span class="enscript-keyword">if</span> (lastpgoff &amp;&amp; !NBPGVALID(bp,lastpg)) {
				<span class="enscript-comment">/* need to read end of last page */</span>
				<span class="enscript-keyword">if</span> (start &lt; 0)
					start = (lastpg * PAGE_SIZE) + lastpgoff;
				end = (lastpg + 1) * PAGE_SIZE;
			}
			<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_NOCACHE)) {
				<span class="enscript-comment">/*
				 * For nocache writes, if there is any partial page at the
				 * start or end of the write range, then we do the write
				 * synchronously to make sure that we can drop the data
				 * from the cache as soon as the WRITE finishes.  Normally,
				 * we would do an unstable write and not drop the data until
				 * it was committed.  But doing that here would risk allowing
				 * invalid data to be read from the cache between the WRITE
				 * and the COMMIT.
				 * (NB_STABLE indicates that data writes should be FILESYNC)
				 */</span>
				<span class="enscript-keyword">if</span> (end &gt; start)
					SET(bp-&gt;nb_flags, NB_STABLE);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">skipread</span>;
			}
			<span class="enscript-keyword">if</span> (end &gt; start) {
				<span class="enscript-comment">/* need to read the data in range: start...end-1 */</span>

				<span class="enscript-comment">/* first, check for dirty pages in between */</span>
				<span class="enscript-comment">/* if there are, we'll have to do two reads because */</span>
				<span class="enscript-comment">/* we don't want to overwrite the dirty pages. */</span>
				<span class="enscript-keyword">for</span> (dirtypg=start/PAGE_SIZE; dirtypg &lt;= (end-1)/PAGE_SIZE; dirtypg++)
					<span class="enscript-keyword">if</span> (NBPGDIRTY(bp,dirtypg))
						<span class="enscript-keyword">break</span>;

				<span class="enscript-comment">/* if start is at beginning of page, try */</span>
				<span class="enscript-comment">/* to get any preceeding pages as well. */</span>
				<span class="enscript-keyword">if</span> (!(start &amp; PAGE_MASK)) {
					<span class="enscript-comment">/* stop at next dirty/valid page or start of block */</span>
					<span class="enscript-keyword">for</span> (; start &gt; 0; start-=PAGE_SIZE)
						<span class="enscript-keyword">if</span> (NBPGVALID(bp,((start-1)/PAGE_SIZE)))
							<span class="enscript-keyword">break</span>;
				}

				NFS_BUF_MAP(bp);
				<span class="enscript-comment">/* setup uio for read(s) */</span>
				boff = NBOFF(bp);
				auio = uio_createwithbuffer(1, 0, UIO_SYSSPACE, UIO_READ,
					&amp;auio_buf, <span class="enscript-keyword">sizeof</span>(auio_buf));

				<span class="enscript-keyword">if</span> (dirtypg &lt;= (end-1)/PAGE_SIZE) {
					<span class="enscript-comment">/* there's a dirty page in the way, so just do two reads */</span>
					<span class="enscript-comment">/* we'll read the preceding data here */</span>
					uio_reset(auio, boff + start, UIO_SYSSPACE, UIO_READ);
					uio_addiov(auio, CAST_USER_ADDR_T(bp-&gt;nb_data + start), on - start);
					error = nfs_read_rpc(np, auio, ctx);
					<span class="enscript-keyword">if</span> (error) {
						<span class="enscript-comment">/* couldn't read the data, so treat buffer as synchronous NOCACHE */</span>
						SET(bp-&gt;nb_flags, (NB_NOCACHE|NB_STABLE));
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">skipread</span>;
					}
					<span class="enscript-keyword">if</span> (uio_resid(auio) &gt; 0) {
						FSDBG(516, bp, (caddr_t)uio_curriovbase(auio) - bp-&gt;nb_data, uio_resid(auio), 0xd00dee01);
						bzero(CAST_DOWN(caddr_t, uio_curriovbase(auio)), uio_resid(auio));
					}
					<span class="enscript-keyword">if</span> (!error) {
						<span class="enscript-comment">/* update validoff/validend if necessary */</span>
						<span class="enscript-keyword">if</span> ((bp-&gt;nb_validoff &lt; 0) || (bp-&gt;nb_validoff &gt; start))
							bp-&gt;nb_validoff = start;
						<span class="enscript-keyword">if</span> ((bp-&gt;nb_validend &lt; 0) || (bp-&gt;nb_validend &lt; on))
							bp-&gt;nb_validend = on;
						<span class="enscript-keyword">if</span> ((off_t)np-&gt;n_size &gt; boff + bp-&gt;nb_validend)
							bp-&gt;nb_validend = min(np-&gt;n_size - (boff + start), biosize);
						<span class="enscript-comment">/* validate any pages before the write offset */</span>
						<span class="enscript-keyword">for</span> (; start &lt; on/PAGE_SIZE; start+=PAGE_SIZE)
							NBPGVALID_SET(bp, start/PAGE_SIZE);
					}
					<span class="enscript-comment">/* adjust start to read any trailing data */</span>
					start = on+n;
				}

				<span class="enscript-comment">/* if end is at end of page, try to */</span>
				<span class="enscript-comment">/* get any following pages as well. */</span>
				<span class="enscript-keyword">if</span> (!(end &amp; PAGE_MASK)) {
					<span class="enscript-comment">/* stop at next valid page or end of block */</span>
					<span class="enscript-keyword">for</span> (; end &lt; biosize; end+=PAGE_SIZE)
						<span class="enscript-keyword">if</span> (NBPGVALID(bp,end/PAGE_SIZE))
							<span class="enscript-keyword">break</span>;
				}

				<span class="enscript-keyword">if</span> (((boff+start) &gt;= (off_t)np-&gt;n_size) ||
				    ((start &gt;= on) &amp;&amp; ((boff + on + n) &gt;= (off_t)np-&gt;n_size))) {
					<span class="enscript-comment">/*
					 * Either this entire read is beyond the current EOF
					 * or the range that we won't be modifying (on+n...end)
					 * is all beyond the current EOF.
					 * No need to make a trip across the network to
					 * read nothing.  So, just zero the buffer instead.
					 */</span>
					FSDBG(516, bp, start, end - start, 0xd00dee00);
					bzero(bp-&gt;nb_data + start, end - start);
					error = 0;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* now we'll read the (rest of the) data */</span>
					uio_reset(auio, boff + start, UIO_SYSSPACE, UIO_READ);
					uio_addiov(auio, CAST_USER_ADDR_T(bp-&gt;nb_data + start), end - start);
					error = nfs_read_rpc(np, auio, ctx);
					<span class="enscript-keyword">if</span> (error) {
						<span class="enscript-comment">/* couldn't read the data, so treat buffer as synchronous NOCACHE */</span>
						SET(bp-&gt;nb_flags, (NB_NOCACHE|NB_STABLE));
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">skipread</span>;
					}
					<span class="enscript-keyword">if</span> (uio_resid(auio) &gt; 0) {
						FSDBG(516, bp, (caddr_t)uio_curriovbase(auio) - bp-&gt;nb_data, uio_resid(auio), 0xd00dee02);
						bzero(CAST_DOWN(caddr_t, uio_curriovbase(auio)), uio_resid(auio));
					}
				}
				<span class="enscript-keyword">if</span> (!error) {
					<span class="enscript-comment">/* update validoff/validend if necessary */</span>
					<span class="enscript-keyword">if</span> ((bp-&gt;nb_validoff &lt; 0) || (bp-&gt;nb_validoff &gt; start))
						bp-&gt;nb_validoff = start;
					<span class="enscript-keyword">if</span> ((bp-&gt;nb_validend &lt; 0) || (bp-&gt;nb_validend &lt; end))
						bp-&gt;nb_validend = end;
					<span class="enscript-keyword">if</span> ((off_t)np-&gt;n_size &gt; boff + bp-&gt;nb_validend)
						bp-&gt;nb_validend = min(np-&gt;n_size - (boff + start), biosize);
					<span class="enscript-comment">/* validate any pages before the write offset's page */</span>
					<span class="enscript-keyword">for</span> (; start &lt; (off_t)trunc_page_32(on); start+=PAGE_SIZE)
						NBPGVALID_SET(bp, start/PAGE_SIZE);
					<span class="enscript-comment">/* validate any pages after the range of pages being written to */</span>
					<span class="enscript-keyword">for</span> (; (end - 1) &gt; (off_t)round_page_32(on+n-1); end-=PAGE_SIZE)
						NBPGVALID_SET(bp, (end-1)/PAGE_SIZE);
				}
				<span class="enscript-comment">/* Note: pages being written to will be validated when written */</span>
			}
		}
<span class="enscript-reference">skipread</span>:

		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_ERROR)) {
			error = bp-&gt;nb_error;
			nfs_buf_release(bp, 1);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		nfs_node_lock_force(np);
		np-&gt;n_flag |= NMODIFIED;
		nfs_node_unlock(np);

		NFS_BUF_MAP(bp);
		error = uiomove((<span class="enscript-type">char</span> *)bp-&gt;nb_data + on, n, uio);
		<span class="enscript-keyword">if</span> (error) {
			SET(bp-&gt;nb_flags, NB_ERROR);
			nfs_buf_release(bp, 1);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-comment">/* validate any pages written to */</span>
		start = on &amp; ~PAGE_MASK;
		<span class="enscript-keyword">for</span> (; start &lt; on+n; start += PAGE_SIZE) {
			NBPGVALID_SET(bp, start/PAGE_SIZE);
			<span class="enscript-comment">/*
			 * This may seem a little weird, but we don't actually set the
			 * dirty bits for writes.  This is because we keep the dirty range
			 * in the nb_dirtyoff/nb_dirtyend fields.  Also, particularly for
			 * delayed writes, when we give the pages back to the VM we don't
			 * want to keep them marked dirty, because when we later write the
			 * buffer we won't be able to tell which pages were written dirty
			 * and which pages were mmapped and dirtied.
			 */</span>
		}
		<span class="enscript-keyword">if</span> (bp-&gt;nb_dirtyend &gt; 0) {
			bp-&gt;nb_dirtyoff = min(on, bp-&gt;nb_dirtyoff);
			bp-&gt;nb_dirtyend = max((on + n), bp-&gt;nb_dirtyend);
		} <span class="enscript-keyword">else</span> {
			bp-&gt;nb_dirtyoff = on;
			bp-&gt;nb_dirtyend = on + n;
		}
		<span class="enscript-keyword">if</span> (bp-&gt;nb_validend &lt;= 0 || bp-&gt;nb_validend &lt; bp-&gt;nb_dirtyoff ||
		    bp-&gt;nb_validoff &gt; bp-&gt;nb_dirtyend) {
			bp-&gt;nb_validoff = bp-&gt;nb_dirtyoff;
			bp-&gt;nb_validend = bp-&gt;nb_dirtyend;
		} <span class="enscript-keyword">else</span> {
			bp-&gt;nb_validoff = min(bp-&gt;nb_validoff, bp-&gt;nb_dirtyoff);
			bp-&gt;nb_validend = max(bp-&gt;nb_validend, bp-&gt;nb_dirtyend);
		}
		<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_CACHE))
			nfs_buf_normalize_valid_range(np, bp);

		<span class="enscript-comment">/*
		 * Since this block is being modified, it must be written
		 * again and not just committed.
		 */</span>
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_NEEDCOMMIT)) {
			nfs_node_lock_force(np);
			<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_NEEDCOMMIT)) {
				np-&gt;n_needcommitcnt--;
				CHECK_NEEDCOMMITCNT(np);
			}
			CLR(bp-&gt;nb_flags, NB_NEEDCOMMIT);
			nfs_node_unlock(np);
		}

		<span class="enscript-keyword">if</span> (ioflag &amp; IO_SYNC) {
			error = nfs_buf_write(bp);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (((n + on) == biosize) || (ioflag &amp; IO_APPEND) ||
			   (ioflag &amp; IO_NOCACHE) || ISSET(bp-&gt;nb_flags, NB_NOCACHE)) {
			SET(bp-&gt;nb_flags, NB_ASYNC);
			error = nfs_buf_write(bp);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* If the block wasn't already delayed: charge for the write */</span>
			<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_DELWRI)) {
				proc_t p = vfs_context_proc(ctx);
				<span class="enscript-keyword">if</span> (p &amp;&amp; p-&gt;p_stats)
					OSIncrementAtomicLong(&amp;p-&gt;p_stats-&gt;p_ru.ru_oublock);
			}
			nfs_buf_write_delayed(bp);
		}
		<span class="enscript-keyword">if</span> (np-&gt;n_needcommitcnt &gt;= NFS_A_LOT_OF_NEEDCOMMITS)
		        nfs_flushcommits(np, 1);

	} <span class="enscript-keyword">while</span> (uio_resid(uio) &gt; 0 &amp;&amp; n &gt; 0);

<span class="enscript-reference">out</span>:
	nfs_node_lock_force(np);
	np-&gt;n_wrbusy--;
	nfs_node_unlock(np);
	nfs_data_unlock(np);
	FSDBG_BOT(515, np, uio_offset(uio), uio_resid(uio), error);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * NFS write call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_write_rpc</span>(
	nfsnode_t np,
	uio_t uio,
	vfs_context_t ctx,
	<span class="enscript-type">int</span> *iomodep,
	uint64_t *wverfp)
{
	<span class="enscript-keyword">return</span> nfs_write_rpc2(np, uio, vfs_context_thread(ctx), vfs_context_ucred(ctx), iomodep, wverfp);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_write_rpc2</span>(
	nfsnode_t np,
	uio_t uio,
	thread_t thd,
	kauth_cred_t cred,
	<span class="enscript-type">int</span> *iomodep,
	uint64_t *wverfp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, nfsvers;
	<span class="enscript-type">int</span> wverfset, commit, committed;
	uint64_t wverf = 0, wverf2;
	size_t nmwsize, totalsize, tsiz, len, rlen;
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;
	uint32_t stategenid = 0, vrestart = 0, restart = 0;
	uio_t uio_save = NULL;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-comment">/* XXX limitation based on need to back up uio on short write */</span>
	<span class="enscript-keyword">if</span> (uio_iovcnt(uio) != 1)
		panic(<span class="enscript-string">&quot;nfs3_write_rpc: iovcnt &gt; 1&quot;</span>);
#<span class="enscript-reference">endif</span>
	FSDBG_TOP(537, np, uio_offset(uio), uio_resid(uio), *iomodep);
	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	nmwsize = nmp-&gt;nm_wsize;

	wverfset = 0;
	committed = NFS_WRITE_FILESYNC;

	totalsize = tsiz = uio_resid(uio);
	<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER2) &amp;&amp; ((uint64_t)(uio_offset(uio) + tsiz) &gt; 0xffffffffULL)) {
		FSDBG_BOT(537, np, uio_offset(uio), uio_resid(uio), EFBIG);
		<span class="enscript-keyword">return</span> (EFBIG);
	}

	uio_save = uio_duplicate(uio);
	<span class="enscript-keyword">if</span> (uio_save == NULL) {
		<span class="enscript-keyword">return</span> (EIO);
	}

	<span class="enscript-keyword">while</span> (tsiz &gt; 0) {
		len = (tsiz &gt; nmwsize) ? nmwsize : tsiz;
		FSDBG(537, np, uio_offset(uio), len, 0);
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
			error = EIO;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4)
			stategenid = nmp-&gt;nm_stategenid;
		error = nmp-&gt;nm_funcs-&gt;nf_write_rpc_async(np, uio, len, thd, cred, *iomodep, NULL, &amp;req);
		<span class="enscript-keyword">if</span> (!error)
			error = nmp-&gt;nm_funcs-&gt;nf_write_rpc_async_finish(np, req, &amp;commit, &amp;rlen, &amp;wverf2);
		nmp = NFSTONMP(np);
		<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
			error = ENXIO;
		<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; nfs_mount_state_error_should_restart(error) &amp;&amp;
		    (++restart &lt;= nfs_mount_state_max_restarts(nmp))) { <span class="enscript-comment">/* guard against no progress */</span>
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">if</span> ((error != NFSERR_GRACE) &amp;&amp; (stategenid == nmp-&gt;nm_stategenid)) {
				NP(np, <span class="enscript-string">&quot;nfs_write_rpc: error %d, initiating recovery&quot;</span>, error);
				nfs_need_recover(nmp, error);
			}
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
				error = EIO;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (error == NFSERR_GRACE)
					tsleep(&amp;nmp-&gt;nm_state, (PZERO-1), <span class="enscript-string">&quot;nfsgrace&quot;</span>, 2*hz);
				<span class="enscript-keyword">if</span> (!(error = nfs_mount_state_wait_for_recovery(nmp)))
					<span class="enscript-keyword">continue</span>;
			}
		}
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (nfsvers == NFS_VER2) {
			tsiz -= len;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/* check for a short write */</span>
		<span class="enscript-keyword">if</span> (rlen &lt; len) {
			<span class="enscript-comment">/* Reset the uio to reflect the actual transfer */</span>
			*uio = *uio_save;
			uio_update(uio, totalsize - (tsiz - rlen));
			len = rlen;
		}

		<span class="enscript-comment">/* return lowest commit level returned */</span>
		<span class="enscript-keyword">if</span> (commit &lt; committed)
			committed = commit;

		tsiz -= len;

		<span class="enscript-comment">/* check write verifier */</span>
		<span class="enscript-keyword">if</span> (!wverfset) {
			wverf = wverf2;
			wverfset = 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wverf != wverf2) {
			<span class="enscript-comment">/* verifier changed, so we need to restart all the writes */</span>
			<span class="enscript-keyword">if</span> (++vrestart &gt; 100) {
				<span class="enscript-comment">/* give up after too many restarts */</span>
				error = EIO;
				<span class="enscript-keyword">break</span>;
			}
			*uio = *uio_save;	<span class="enscript-comment">// Reset the uio back to the start
</span>			committed = NFS_WRITE_FILESYNC;
			wverfset = 0;
			tsiz = totalsize;
		}
	}
	<span class="enscript-keyword">if</span> (uio_save)
		uio_free(uio_save);
	<span class="enscript-keyword">if</span> (wverfset &amp;&amp; wverfp)
		*wverfp = wverf;
	*iomodep = committed;
	<span class="enscript-keyword">if</span> (error)
		uio_setresid(uio, tsiz);
	FSDBG_BOT(537, np, committed, uio_resid(uio), error);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_write_rpc_async</span>(
	nfsnode_t np,
	uio_t uio,
	size_t len,
	thread_t thd,
	kauth_cred_t cred,
	<span class="enscript-type">int</span> iomode,
	<span class="enscript-type">struct</span> nfsreq_cbinfo *cb,
	<span class="enscript-type">struct</span> nfsreq **reqp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	mount_t mp;
	<span class="enscript-type">int</span> error = 0, nfsvers;
	<span class="enscript-type">struct</span> nfsm_chain nmreq;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	<span class="enscript-comment">/* for async mounts, don't bother sending sync write requests */</span>
	<span class="enscript-keyword">if</span> ((iomode != NFS_WRITE_UNSTABLE) &amp;&amp; nfs_allow_async &amp;&amp;
	    ((mp = NFSTOMP(np))) &amp;&amp; (vfs_flags(mp) &amp; MNT_ASYNC))
		iomode = NFS_WRITE_UNSTABLE;

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_build_alloc_init(error, &amp;nmreq,
		NFSX_FH(nfsvers) + 5 * NFSX_UNSIGNED + nfsm_rndup(len));
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
		nfsm_chain_add_64(error, &amp;nmreq, uio_offset(uio));
		nfsm_chain_add_32(error, &amp;nmreq, len);
		nfsm_chain_add_32(error, &amp;nmreq, iomode);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_32(error, &amp;nmreq, 0);
		nfsm_chain_add_32(error, &amp;nmreq, uio_offset(uio));
		nfsm_chain_add_32(error, &amp;nmreq, 0);
	}
	nfsm_chain_add_32(error, &amp;nmreq, len);
	nfsmout_if(error);
	error = nfsm_chain_add_uio(&amp;nmreq, uio, len);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfs_request_async(np, NULL, &amp;nmreq, NFSPROC_WRITE, thd, cred, NULL, 0, cb, reqp);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_write_rpc_async_finish</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfsreq *req,
	<span class="enscript-type">int</span> *iomodep,
	size_t *rlenp,
	uint64_t *wverfp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, nfsvers, status;
	<span class="enscript-type">int</span> updatemtime = 0, wccpostattr = 0, rlen, committed = NFS_WRITE_FILESYNC;
	u_int64_t xid, wverf;
	mount_t mp;
	<span class="enscript-type">struct</span> nfsm_chain nmrep;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		nfs_request_async_cancel(req);
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	nfsvers = nmp-&gt;nm_vers;

	nfsm_chain_null(&amp;nmrep);

	error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);
	<span class="enscript-keyword">if</span> (error == EINPROGRESS) <span class="enscript-comment">/* async request restarted */</span>
		<span class="enscript-keyword">return</span> (error);
	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		error = ENXIO;
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (lockerror = nfs_node_lock(np)))
		error = lockerror;
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
		<span class="enscript-type">struct</span> timespec premtime = { 0, 0 };
		nfsm_chain_get_wcc_data(error, &amp;nmrep, np, &amp;premtime, &amp;wccpostattr, &amp;xid);
		<span class="enscript-keyword">if</span> (nfstimespeccmp(&amp;np-&gt;n_mtime, &amp;premtime, ==))
			updatemtime = 1;
		<span class="enscript-keyword">if</span> (!error)
			error = status;
		nfsm_chain_get_32(error, &amp;nmrep, rlen);
		nfsmout_if(error);
		*rlenp = rlen;
		<span class="enscript-keyword">if</span> (rlen &lt;= 0)
			error = NFSERR_IO;
		nfsm_chain_get_32(error, &amp;nmrep, committed);
		nfsm_chain_get_64(error, &amp;nmrep, wverf);
		nfsmout_if(error);
		<span class="enscript-keyword">if</span> (wverfp)
			*wverfp = wverf;
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_state &amp; NFSSTA_HASWRITEVERF)) {
			nmp-&gt;nm_verf = wverf;
			nmp-&gt;nm_state |= NFSSTA_HASWRITEVERF;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nmp-&gt;nm_verf != wverf) {
			nmp-&gt;nm_verf = wverf;
		}
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (!error)
			error = status;
		nfsm_chain_loadattr(error, &amp;nmrep, np, nfsvers, &amp;xid);
		nfsmout_if(error);
	}
	<span class="enscript-keyword">if</span> (updatemtime)
		NFS_CHANGED_UPDATE(nfsvers, np, &amp;np-&gt;n_vattr);
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">if</span> ((committed != NFS_WRITE_FILESYNC) &amp;&amp; nfs_allow_async &amp;&amp;
	    ((mp = NFSTOMP(np))) &amp;&amp; (vfs_flags(mp) &amp; MNT_ASYNC))
		committed = NFS_WRITE_FILESYNC;
	*iomodep = committed;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS mknod vnode op
 *
 * For NFS v2 this is a kludge. Use a create RPC but with the IFMT bits of the
 * mode set to specify the file type and the size field for rdev.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_vnop_mknod</span>(
	<span class="enscript-type">struct</span> vnop_mknod_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_dvp;
		vnode_t *a_vpp;
		struct componentname *a_cnp;
		struct vnode_attr *a_vap;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vnode_t dvp = ap-&gt;a_dvp;
	vnode_t *vpp = ap-&gt;a_vpp;
	<span class="enscript-type">struct</span> componentname *cnp = ap-&gt;a_cnp;
	<span class="enscript-type">struct</span> vnode_attr *vap = ap-&gt;a_vap;
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t newvp = NULL;
	nfsnode_t np = NULL;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	nfsnode_t dnp = VTONFS(dvp);
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	fhandle_t fh;
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, busyerror = ENOENT, status, wccpostattr = 0;
	<span class="enscript-type">struct</span> timespec premtime = { 0, 0 };
	u_int32_t rdev;
	u_int64_t xid = 0, dxid;
	<span class="enscript-type">int</span> nfsvers, gotuid, gotgid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;

	nmp = VTONMP(dvp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	<span class="enscript-keyword">if</span> (!VATTR_IS_ACTIVE(vap, va_type))
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (vap-&gt;va_type == VCHR || vap-&gt;va_type == VBLK) {
		<span class="enscript-keyword">if</span> (!VATTR_IS_ACTIVE(vap, va_rdev))
			<span class="enscript-keyword">return</span> (EINVAL);
		rdev = vap-&gt;va_rdev;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vap-&gt;va_type == VFIFO || vap-&gt;va_type == VSOCK)
		rdev = 0xffffffff;
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}
	<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER2) &amp;&amp; (cnp-&gt;cn_namelen &gt; NFS_MAXNAMLEN))
		<span class="enscript-keyword">return</span> (ENAMETOOLONG);

	nfs_avoid_needless_id_setting_on_create(dnp, vap, ctx);

	VATTR_SET_SUPPORTED(vap, va_mode);
	VATTR_SET_SUPPORTED(vap, va_uid);
	VATTR_SET_SUPPORTED(vap, va_gid);
	VATTR_SET_SUPPORTED(vap, va_data_size);
	VATTR_SET_SUPPORTED(vap, va_access_time);
	VATTR_SET_SUPPORTED(vap, va_modify_time);
	gotuid = VATTR_IS_ACTIVE(vap, va_uid);
	gotgid = VATTR_IS_ACTIVE(vap, va_gid);

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_build_alloc_init(error, &amp;nmreq,
		NFSX_FH(nfsvers) + 4 * NFSX_UNSIGNED +
		nfsm_rndup(cnp-&gt;cn_namelen) + NFSX_SATTR(nfsvers));
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, dnp-&gt;n_fhp, dnp-&gt;n_fhsize);
	nfsm_chain_add_name(error, &amp;nmreq, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, nmp);
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
		nfsm_chain_add_32(error, &amp;nmreq, vtonfs_type(vap-&gt;va_type, nfsvers));
		nfsm_chain_add_v3sattr(error, &amp;nmreq, vap);
		<span class="enscript-keyword">if</span> (vap-&gt;va_type == VCHR || vap-&gt;va_type == VBLK) {
			nfsm_chain_add_32(error, &amp;nmreq, major(vap-&gt;va_rdev));
			nfsm_chain_add_32(error, &amp;nmreq, minor(vap-&gt;va_rdev));
		}
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_v2sattr(error, &amp;nmreq, vap, rdev);
	}
	nfsm_chain_build_done(error, &amp;nmreq);
	<span class="enscript-keyword">if</span> (!error)
		error = busyerror = nfs_node_set_busy(dnp, vfs_context_thread(ctx));
	nfsmout_if(error);

	error = nfs_request_async(dnp, NULL, &amp;nmreq, NFSPROC_MKNOD,
			vfs_context_thread(ctx), vfs_context_ucred(ctx), NULL, 0, NULL, &amp;req);
	<span class="enscript-keyword">if</span> (!error)
		error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
		error = lockerror;
	<span class="enscript-comment">/* XXX no EEXIST kludge here? */</span>
	dxid = xid;
	<span class="enscript-keyword">if</span> (!error &amp;&amp; !status) {
		<span class="enscript-keyword">if</span> (dnp-&gt;n_flag &amp; NNEGNCENTRIES) {
			dnp-&gt;n_flag &amp;= ~NNEGNCENTRIES;
			cache_purge_negatives(dvp);
		}
		error = nfsm_chain_get_fh_attr(&amp;nmrep, dnp, ctx, nfsvers, &amp;xid, &amp;fh, &amp;nvattr);
	}
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
		nfsm_chain_get_wcc_data(error, &amp;nmrep, dnp, &amp;premtime, &amp;wccpostattr, &amp;dxid);
	<span class="enscript-keyword">if</span> (!error)
		error = status;
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);

	<span class="enscript-keyword">if</span> (!lockerror) {
		dnp-&gt;n_flag |= NMODIFIED;
		<span class="enscript-comment">/* if directory hadn't changed, update namecache mtime */</span>
		<span class="enscript-keyword">if</span> (nfstimespeccmp(&amp;dnp-&gt;n_ncmtime, &amp;premtime, ==))
			NFS_CHANGED_UPDATE_NC(nfsvers, dnp, &amp;dnp-&gt;n_vattr);
		nfs_node_unlock(dnp);
		<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
		nfs_getattr(dnp, NULL, ctx, wccpostattr ? NGA_CACHED : NGA_UNCACHED);
	}

	<span class="enscript-keyword">if</span> (!error &amp;&amp; fh.fh_len)
		error = nfs_nget(NFSTOMP(dnp), dnp, cnp, fh.fh_data, fh.fh_len, &amp;nvattr, &amp;xid, rq.r_auth, NG_MAKEENTRY, &amp;np);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; !np)
		error = nfs_lookitup(dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx, &amp;np);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; np)
		newvp = NFSTOV(np);
	<span class="enscript-keyword">if</span> (!busyerror)
		nfs_node_clear_busy(dnp);

	<span class="enscript-keyword">if</span> (!error &amp;&amp; (gotuid || gotgid) &amp;&amp;
	    (!newvp || nfs_getattrcache(np, &amp;nvattr, 0) ||
	     (gotuid &amp;&amp; (nvattr.nva_uid != vap-&gt;va_uid)) ||
	     (gotgid &amp;&amp; (nvattr.nva_gid != vap-&gt;va_gid)))) {
		<span class="enscript-comment">/* clear ID bits if server didn't use them (or we can't tell) */</span>
		VATTR_CLEAR_SUPPORTED(vap, va_uid);
		VATTR_CLEAR_SUPPORTED(vap, va_gid);
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (newvp) {
			nfs_node_unlock(np);
			vnode_put(newvp);
		}
	} <span class="enscript-keyword">else</span> {
		*vpp = newvp;
		nfs_node_unlock(np);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> uint32_t create_verf;
<span class="enscript-comment">/*
 * NFS file create call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_vnop_create</span>(
	<span class="enscript-type">struct</span> vnop_create_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_dvp;
		vnode_t *a_vpp;
		struct componentname *a_cnp;
		struct vnode_attr *a_vap;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t dvp = ap-&gt;a_dvp;
	<span class="enscript-type">struct</span> vnode_attr *vap = ap-&gt;a_vap;
	<span class="enscript-type">struct</span> componentname *cnp = ap-&gt;a_cnp;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	fhandle_t fh;
	nfsnode_t np = NULL;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	nfsnode_t dnp = VTONFS(dvp);
	vnode_t newvp = NULL;
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, busyerror = ENOENT, status, wccpostattr = 0, fmode = 0;
	<span class="enscript-type">struct</span> timespec premtime = { 0, 0 };
	<span class="enscript-type">int</span> nfsvers, gotuid, gotgid;
	u_int64_t xid, dxid;
	uint32_t val;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;
	<span class="enscript-type">struct</span> nfs_dulookup dul;

	nmp = VTONMP(dvp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER2) &amp;&amp; (cnp-&gt;cn_namelen &gt; NFS_MAXNAMLEN))
		<span class="enscript-keyword">return</span> (ENAMETOOLONG);

	nfs_avoid_needless_id_setting_on_create(dnp, vap, ctx);

	VATTR_SET_SUPPORTED(vap, va_mode);
	VATTR_SET_SUPPORTED(vap, va_uid);
	VATTR_SET_SUPPORTED(vap, va_gid);
	VATTR_SET_SUPPORTED(vap, va_data_size);
	VATTR_SET_SUPPORTED(vap, va_access_time);
	VATTR_SET_SUPPORTED(vap, va_modify_time);
	gotuid = VATTR_IS_ACTIVE(vap, va_uid);
	gotgid = VATTR_IS_ACTIVE(vap, va_gid);

	<span class="enscript-keyword">if</span> (vap-&gt;va_vaflags &amp; VA_EXCLUSIVE) {
		fmode |= O_EXCL;
		<span class="enscript-keyword">if</span> (!VATTR_IS_ACTIVE(vap, va_access_time) || !VATTR_IS_ACTIVE(vap, va_modify_time))
			vap-&gt;va_vaflags |= VA_UTIMES_NULL;
	}

<span class="enscript-reference">again</span>:
	error = busyerror = nfs_node_set_busy(dnp, vfs_context_thread(ctx));
	nfs_dulookup_init(&amp;dul, dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx);

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_build_alloc_init(error, &amp;nmreq,
		NFSX_FH(nfsvers) + 2 * NFSX_UNSIGNED +
		nfsm_rndup(cnp-&gt;cn_namelen) + NFSX_SATTR(nfsvers));
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, dnp-&gt;n_fhp, dnp-&gt;n_fhsize);
	nfsm_chain_add_name(error, &amp;nmreq, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, nmp);
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
		<span class="enscript-keyword">if</span> (fmode &amp; O_EXCL) {
			nfsm_chain_add_32(error, &amp;nmreq, NFS_CREATE_EXCLUSIVE);
			lck_rw_lock_shared(in_ifaddr_rwlock);
			<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;in_ifaddrhead))
				val = IA_SIN(in_ifaddrhead.tqh_first)-&gt;sin_addr.s_addr;
			<span class="enscript-keyword">else</span>
				val = create_verf;
			lck_rw_done(in_ifaddr_rwlock);
			nfsm_chain_add_32(error, &amp;nmreq, val);
			++create_verf;
			nfsm_chain_add_32(error, &amp;nmreq, create_verf);
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, &amp;nmreq, NFS_CREATE_UNCHECKED);
			nfsm_chain_add_v3sattr(error, &amp;nmreq, vap);
		}
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_v2sattr(error, &amp;nmreq, vap, 0);
	}
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);

	error = nfs_request_async(dnp, NULL, &amp;nmreq, NFSPROC_CREATE,
			vfs_context_thread(ctx), vfs_context_ucred(ctx), NULL, 0, NULL, &amp;req);
	<span class="enscript-keyword">if</span> (!error) {
		nfs_dulookup_start(&amp;dul, dnp, ctx);
		error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);
	}

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
		error = lockerror;
	dxid = xid;
	<span class="enscript-keyword">if</span> (!error &amp;&amp; !status) {
		<span class="enscript-keyword">if</span> (dnp-&gt;n_flag &amp; NNEGNCENTRIES) {
			dnp-&gt;n_flag &amp;= ~NNEGNCENTRIES;
			cache_purge_negatives(dvp);
		}
		error = nfsm_chain_get_fh_attr(&amp;nmrep, dnp, ctx, nfsvers, &amp;xid, &amp;fh, &amp;nvattr);
	}
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
		nfsm_chain_get_wcc_data(error, &amp;nmrep, dnp, &amp;premtime, &amp;wccpostattr, &amp;dxid);
	<span class="enscript-keyword">if</span> (!error)
		error = status;
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);

	<span class="enscript-keyword">if</span> (!lockerror) {
		dnp-&gt;n_flag |= NMODIFIED;
		<span class="enscript-comment">/* if directory hadn't changed, update namecache mtime */</span>
		<span class="enscript-keyword">if</span> (nfstimespeccmp(&amp;dnp-&gt;n_ncmtime, &amp;premtime, ==))
			NFS_CHANGED_UPDATE_NC(nfsvers, dnp, &amp;dnp-&gt;n_vattr);
		nfs_node_unlock(dnp);
		<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
		nfs_getattr(dnp, NULL, ctx, wccpostattr ? NGA_CACHED : NGA_UNCACHED);
	}

	<span class="enscript-keyword">if</span> (!error &amp;&amp; fh.fh_len)
		error = nfs_nget(NFSTOMP(dnp), dnp, cnp, fh.fh_data, fh.fh_len, &amp;nvattr, &amp;xid, rq.r_auth, NG_MAKEENTRY, &amp;np);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; !np)
		error = nfs_lookitup(dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx, &amp;np);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; np)
		newvp = NFSTOV(np);

	nfs_dulookup_finish(&amp;dul, dnp, ctx);
	<span class="enscript-keyword">if</span> (!busyerror)
		nfs_node_clear_busy(dnp);

	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER3) &amp;&amp; (fmode &amp; O_EXCL) &amp;&amp; (error == NFSERR_NOTSUPP)) {
			fmode &amp;= ~O_EXCL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
		}
		<span class="enscript-keyword">if</span> (newvp) {
			nfs_node_unlock(np);
			vnode_put(newvp);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((nfsvers == NFS_VER3) &amp;&amp; (fmode &amp; O_EXCL)) {
		nfs_node_unlock(np);
		error = nfs3_setattr_rpc(np, vap, ctx);
		<span class="enscript-keyword">if</span> (error &amp;&amp; (gotuid || gotgid)) {
			<span class="enscript-comment">/* it's possible the server didn't like our attempt to set IDs. */</span>
			<span class="enscript-comment">/* so, let's try it again without those */</span>
			VATTR_CLEAR_ACTIVE(vap, va_uid);
			VATTR_CLEAR_ACTIVE(vap, va_gid);
			error = nfs3_setattr_rpc(np, vap, ctx);
		}
		<span class="enscript-keyword">if</span> (error)
			vnode_put(newvp);
		<span class="enscript-keyword">else</span>
			nfs_node_lock_force(np);
	}
	<span class="enscript-keyword">if</span> (!error)
		*ap-&gt;a_vpp = newvp;
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (gotuid || gotgid) &amp;&amp;
	    (!newvp || nfs_getattrcache(np, &amp;nvattr, 0) ||
	     (gotuid &amp;&amp; (nvattr.nva_uid != vap-&gt;va_uid)) ||
	     (gotgid &amp;&amp; (nvattr.nva_gid != vap-&gt;va_gid)))) {
		<span class="enscript-comment">/* clear ID bits if server didn't use them (or we can't tell) */</span>
		VATTR_CLEAR_SUPPORTED(vap, va_uid);
		VATTR_CLEAR_SUPPORTED(vap, va_gid);
	}
	<span class="enscript-keyword">if</span> (!error)
		nfs_node_unlock(np);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS file remove call
 * To try and make NFS semantics closer to UFS semantics, a file that has
 * other processes using the vnode is renamed instead of removed and then
 * removed later on the last close.
 * - If vnode_isinuse()
 *	  If a rename is not already in the works
 *	     call nfs_sillyrename() to set it up
 *     else
 *	  do the remove RPC
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_remove</span>(
	<span class="enscript-type">struct</span> vnop_remove_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_dvp;
		vnode_t a_vp;
		struct componentname *a_cnp;
		int a_flags;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t vp = ap-&gt;a_vp;
	vnode_t dvp = ap-&gt;a_dvp;
	<span class="enscript-type">struct</span> componentname *cnp = ap-&gt;a_cnp;
	nfsnode_t dnp = VTONFS(dvp);
	nfsnode_t np = VTONFS(vp);
	<span class="enscript-type">int</span> error = 0, nfsvers, namedattrs, inuse, gotattr = 0, flushed = 0, setsize = 0;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_dulookup dul;

	<span class="enscript-comment">/* XXX prevent removing a sillyrenamed file? */</span>

	nmp = NFSTONMP(dnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	namedattrs = (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR);

<span class="enscript-reference">again_relock</span>:
	error = nfs_node_set_busy2(dnp, np, vfs_context_thread(ctx));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/* lock the node while we remove the file */</span>
	lck_mtx_lock(nfs_node_hash_mutex);
	<span class="enscript-keyword">while</span> (np-&gt;n_hflag &amp; NHLOCKED) {
		np-&gt;n_hflag |= NHLOCKWANT;
		msleep(np, nfs_node_hash_mutex, PINOD, <span class="enscript-string">&quot;nfs_remove&quot;</span>, NULL);
	}
	np-&gt;n_hflag |= NHLOCKED;
	lck_mtx_unlock(nfs_node_hash_mutex);

	<span class="enscript-keyword">if</span> (!namedattrs)
		nfs_dulookup_init(&amp;dul, dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx);
<span class="enscript-reference">again</span>:
	inuse = vnode_isinuse(vp, 0);
	<span class="enscript-keyword">if</span> ((ap-&gt;a_flags &amp; VNODE_REMOVE_NODELETEBUSY) &amp;&amp; inuse) {
		<span class="enscript-comment">/* Caller requested Carbon delete semantics, but file is busy */</span>
		error = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (inuse &amp;&amp; !gotattr) {
		<span class="enscript-keyword">if</span> (nfs_getattr(np, &amp;nvattr, ctx, NGA_CACHED))
			nvattr.nva_nlink = 1;
		gotattr = 1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}
	<span class="enscript-keyword">if</span> (!inuse || (np-&gt;n_sillyrename &amp;&amp; (nvattr.nva_nlink &gt; 1))) {

		<span class="enscript-keyword">if</span> (!inuse &amp;&amp; !flushed) { <span class="enscript-comment">/* flush all the buffers first */</span>
			<span class="enscript-comment">/* unlock the node */</span>
			lck_mtx_lock(nfs_node_hash_mutex);
			np-&gt;n_hflag &amp;= ~NHLOCKED;
			<span class="enscript-keyword">if</span> (np-&gt;n_hflag &amp; NHLOCKWANT) {
				np-&gt;n_hflag &amp;= ~NHLOCKWANT;
				wakeup(np);
			}
			lck_mtx_unlock(nfs_node_hash_mutex);
			nfs_node_clear_busy2(dnp, np);
			error = nfs_vinvalbuf(vp, V_SAVE, ctx, 1);
			FSDBG(260, np, np-&gt;n_size, np-&gt;n_vattr.nva_size, 0xf00d0011);
			flushed = 1;
			<span class="enscript-keyword">if</span> (error == EINTR) {
				nfs_node_lock_force(np);
				NATTRINVALIDATE(np);
				nfs_node_unlock(np);
				<span class="enscript-keyword">return</span> (error);
			}
			<span class="enscript-keyword">if</span> (!namedattrs)
				nfs_dulookup_finish(&amp;dul, dnp, ctx);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again_relock</span>;
		}

		<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; (np-&gt;n_openflags &amp; N_DELEG_MASK))
			nfs4_delegation_return(np, 0, vfs_context_thread(ctx), vfs_context_ucred(ctx));

		<span class="enscript-comment">/*
		 * Purge the name cache so that the chance of a lookup for
		 * the name succeeding while the remove is in progress is
		 * minimized.
		 */</span>
		nfs_name_cache_purge(dnp, np, cnp, ctx);

		<span class="enscript-keyword">if</span> (!namedattrs)
			nfs_dulookup_start(&amp;dul, dnp, ctx);

		<span class="enscript-comment">/* Do the rpc */</span>
		error = nmp-&gt;nm_funcs-&gt;nf_remove_rpc(dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen,
				vfs_context_thread(ctx), vfs_context_ucred(ctx));

		<span class="enscript-comment">/*
		 * Kludge City: If the first reply to the remove rpc is lost..
		 *   the reply to the retransmitted request will be ENOENT
		 *   since the file was in fact removed
		 *   Therefore, we cheat and return success.
		 */</span>
		<span class="enscript-keyword">if</span> (error == ENOENT)
			error = 0;

		<span class="enscript-keyword">if</span> (!error &amp;&amp; !inuse &amp;&amp; !np-&gt;n_sillyrename) {
			<span class="enscript-comment">/*
			 * removal succeeded, it's not in use, and not silly renamed so
			 * remove nfsnode from hash now so we can't accidentally find it
			 * again if another object gets created with the same filehandle
			 * before this vnode gets reclaimed
			 */</span>
			lck_mtx_lock(nfs_node_hash_mutex);
			<span class="enscript-keyword">if</span> (np-&gt;n_hflag &amp; NHHASHED) {
				LIST_REMOVE(np, n_hash);
				np-&gt;n_hflag &amp;= ~NHHASHED;
				FSDBG(266, 0, np, np-&gt;n_flag, 0xb1eb1e);
			}
			lck_mtx_unlock(nfs_node_hash_mutex);
			<span class="enscript-comment">/* clear flags now: won't get nfs_vnop_inactive for recycled vnode */</span>
			<span class="enscript-comment">/* clear all flags other than these */</span>
			nfs_node_lock_force(np);
			np-&gt;n_flag &amp;= (NMODIFIED);
			NATTRINVALIDATE(np);
			nfs_node_unlock(np);
			vnode_recycle(vp);
			setsize = 1;
		} <span class="enscript-keyword">else</span> {
			nfs_node_lock_force(np);
			NATTRINVALIDATE(np);
			nfs_node_unlock(np);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!np-&gt;n_sillyrename) {
		<span class="enscript-keyword">if</span> (!namedattrs)
			nfs_dulookup_start(&amp;dul, dnp, ctx);
		error = nfs_sillyrename(dnp, np, cnp, ctx);
		nfs_node_lock_force(np);
		NATTRINVALIDATE(np);
		nfs_node_unlock(np);
	} <span class="enscript-keyword">else</span> {
		nfs_node_lock_force(np);
		NATTRINVALIDATE(np);
		nfs_node_unlock(np);
		<span class="enscript-keyword">if</span> (!namedattrs)
			nfs_dulookup_start(&amp;dul, dnp, ctx);
	}

	<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
	nfs_getattr(dnp, NULL, ctx, NGA_CACHED);
	<span class="enscript-keyword">if</span> (!namedattrs)
		nfs_dulookup_finish(&amp;dul, dnp, ctx);
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/* unlock the node */</span>
	lck_mtx_lock(nfs_node_hash_mutex);
	np-&gt;n_hflag &amp;= ~NHLOCKED;
	<span class="enscript-keyword">if</span> (np-&gt;n_hflag &amp; NHLOCKWANT) {
		np-&gt;n_hflag &amp;= ~NHLOCKWANT;
		wakeup(np);
	}
	lck_mtx_unlock(nfs_node_hash_mutex);
	nfs_node_clear_busy2(dnp, np);
	<span class="enscript-keyword">if</span> (setsize)
		ubc_setsize(vp, 0);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS silly-renamed file removal function called from nfs_vnop_inactive
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_removeit</span>(<span class="enscript-type">struct</span> nfs_sillyrename *nsp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(nsp-&gt;nsr_dnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">return</span> nmp-&gt;nm_funcs-&gt;nf_remove_rpc(nsp-&gt;nsr_dnp, nsp-&gt;nsr_name, nsp-&gt;nsr_namlen, NULL, nsp-&gt;nsr_cred);
}

<span class="enscript-comment">/*
 * NFS remove rpc, called from nfs_remove() and nfs_removeit().
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_remove_rpc</span>(
	nfsnode_t dnp,
	<span class="enscript-type">char</span> *name,
	<span class="enscript-type">int</span> namelen,
	thread_t thd,
	kauth_cred_t cred)
{
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, status, wccpostattr = 0;
	<span class="enscript-type">struct</span> timespec premtime = { 0, 0 };
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> nfsvers;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;

	nmp = NFSTONMP(dnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER2) &amp;&amp; (namelen &gt; NFS_MAXNAMLEN))
		<span class="enscript-keyword">return</span> (ENAMETOOLONG);

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_build_alloc_init(error, &amp;nmreq,
		NFSX_FH(nfsvers) + NFSX_UNSIGNED + nfsm_rndup(namelen));
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, dnp-&gt;n_fhp, dnp-&gt;n_fhsize);
	nfsm_chain_add_name(error, &amp;nmreq, name, namelen, nmp);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);

	error = nfs_request2(dnp, NULL, &amp;nmreq, NFSPROC_REMOVE, thd, cred, NULL, 0, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
		error = lockerror;
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
		nfsm_chain_get_wcc_data(error, &amp;nmrep, dnp, &amp;premtime, &amp;wccpostattr, &amp;xid);
	nfsmout_if(error);
	dnp-&gt;n_flag |= NMODIFIED;
	<span class="enscript-comment">/* if directory hadn't changed, update namecache mtime */</span>
	<span class="enscript-keyword">if</span> (nfstimespeccmp(&amp;dnp-&gt;n_ncmtime, &amp;premtime, ==))
		NFS_CHANGED_UPDATE_NC(nfsvers, dnp, &amp;dnp-&gt;n_vattr);
	<span class="enscript-keyword">if</span> (!wccpostattr)
		NATTRINVALIDATE(dnp);
	<span class="enscript-keyword">if</span> (!error)
		error = status;
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(dnp);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS file rename call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_rename</span>(
	<span class="enscript-type">struct</span> vnop_rename_args  <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_fdvp;
		vnode_t a_fvp;
		struct componentname *a_fcnp;
		vnode_t a_tdvp;
		vnode_t a_tvp;
		struct componentname *a_tcnp;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t fdvp = ap-&gt;a_fdvp;
	vnode_t fvp = ap-&gt;a_fvp;
	vnode_t tdvp = ap-&gt;a_tdvp;
	vnode_t tvp = ap-&gt;a_tvp;
	nfsnode_t fdnp, fnp, tdnp, tnp;
	<span class="enscript-type">struct</span> componentname *tcnp = ap-&gt;a_tcnp;
	<span class="enscript-type">struct</span> componentname *fcnp = ap-&gt;a_fcnp;
	<span class="enscript-type">int</span> error, nfsvers, inuse=0, tvprecycle=0, locked=0;
	mount_t fmp, tdmp, tmp;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">struct</span> nfsmount *nmp;

	fdnp = VTONFS(fdvp);
	fnp = VTONFS(fvp);
	tdnp = VTONFS(tdvp);
	tnp = tvp ? VTONFS(tvp) : NULL;

	nmp = NFSTONMP(fdnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	error = nfs_node_set_busy4(fdnp, fnp, tdnp, tnp, vfs_context_thread(ctx));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (tvp &amp;&amp; (tvp != fvp)) {
		<span class="enscript-comment">/* lock the node while we rename over the existing file */</span>
		lck_mtx_lock(nfs_node_hash_mutex);
		<span class="enscript-keyword">while</span> (tnp-&gt;n_hflag &amp; NHLOCKED) {
			tnp-&gt;n_hflag |= NHLOCKWANT;
			msleep(tnp, nfs_node_hash_mutex, PINOD, <span class="enscript-string">&quot;nfs_rename&quot;</span>, NULL);
		}
		tnp-&gt;n_hflag |= NHLOCKED;
		lck_mtx_unlock(nfs_node_hash_mutex);
		locked = 1;
	}

	<span class="enscript-comment">/* Check for cross-device rename */</span>
	fmp = vnode_mount(fvp);
	tmp = tvp ? vnode_mount(tvp) : NULL;
	tdmp = vnode_mount(tdvp);
	<span class="enscript-keyword">if</span> ((fmp != tdmp) || (tvp &amp;&amp; (fmp != tmp))) {
		error = EXDEV;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* XXX prevent renaming from/over a sillyrenamed file? */</span>

	<span class="enscript-comment">/*
	 * If the tvp exists and is in use, sillyrename it before doing the
	 * rename of the new file over it.
	 * XXX Can't sillyrename a directory.
	 * Don't sillyrename if source and target are same vnode (hard
	 * links or case-variants)
	 */</span>
	<span class="enscript-keyword">if</span> (tvp &amp;&amp; (tvp != fvp))
		inuse = vnode_isinuse(tvp, 0);
	<span class="enscript-keyword">if</span> (inuse &amp;&amp; !tnp-&gt;n_sillyrename &amp;&amp; (vnode_vtype(tvp) != VDIR)) {
		error = nfs_sillyrename(tdnp, tnp, tcnp, ctx);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/* sillyrename failed. Instead of pressing on, return error */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>; <span class="enscript-comment">/* should not be ENOENT. */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* sillyrename succeeded.*/</span>
			tvp = NULL;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tvp &amp;&amp; (nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; (tnp-&gt;n_openflags &amp; N_DELEG_MASK)) {
		nfs4_delegation_return(tnp, 0, vfs_context_thread(ctx), vfs_context_ucred(ctx));
	}

	error = nmp-&gt;nm_funcs-&gt;nf_rename_rpc(fdnp, fcnp-&gt;cn_nameptr, fcnp-&gt;cn_namelen,
			tdnp, tcnp-&gt;cn_nameptr, tcnp-&gt;cn_namelen, ctx);

	<span class="enscript-comment">/*
	 * Kludge: Map ENOENT =&gt; 0 assuming that it is a reply to a retry.
	 */</span>
	<span class="enscript-keyword">if</span> (error == ENOENT)
		error = 0;

	<span class="enscript-keyword">if</span> (tvp &amp;&amp; (tvp != fvp) &amp;&amp; !tnp-&gt;n_sillyrename) {
		nfs_node_lock_force(tnp);
		tvprecycle = (!error &amp;&amp; !vnode_isinuse(tvp, 0) &amp;&amp;
		    (nfs_getattrcache(tnp, &amp;nvattr, 0) || (nvattr.nva_nlink == 1)));
		nfs_node_unlock(tnp);
		lck_mtx_lock(nfs_node_hash_mutex);
		<span class="enscript-keyword">if</span> (tvprecycle &amp;&amp; (tnp-&gt;n_hflag &amp; NHHASHED)) {
			<span class="enscript-comment">/*
			 * remove nfsnode from hash now so we can't accidentally find it
			 * again if another object gets created with the same filehandle
			 * before this vnode gets reclaimed
			 */</span>
			LIST_REMOVE(tnp, n_hash);
			tnp-&gt;n_hflag &amp;= ~NHHASHED;
			FSDBG(266, 0, tnp, tnp-&gt;n_flag, 0xb1eb1e);
		}
		lck_mtx_unlock(nfs_node_hash_mutex);
	}

	<span class="enscript-comment">/* purge the old name cache entries and enter the new one */</span>
	nfs_name_cache_purge(fdnp, fnp, fcnp, ctx);
	<span class="enscript-keyword">if</span> (tvp) {
		nfs_name_cache_purge(tdnp, tnp, tcnp, ctx);
		<span class="enscript-keyword">if</span> (tvprecycle) {
			<span class="enscript-comment">/* clear flags now: won't get nfs_vnop_inactive for recycled vnode */</span>
			<span class="enscript-comment">/* clear all flags other than these */</span>
			nfs_node_lock_force(tnp);
			tnp-&gt;n_flag &amp;= (NMODIFIED);
			nfs_node_unlock(tnp);
			vnode_recycle(tvp);
		}
	}
	<span class="enscript-keyword">if</span> (!error) {
		nfs_node_lock_force(tdnp);
		<span class="enscript-keyword">if</span> (tdnp-&gt;n_flag &amp; NNEGNCENTRIES) {
			tdnp-&gt;n_flag &amp;= ~NNEGNCENTRIES;
			cache_purge_negatives(tdvp);
		}
		nfs_node_unlock(tdnp);
		nfs_node_lock_force(fnp);
		cache_enter(tdvp, fvp, tcnp);
		<span class="enscript-keyword">if</span> (tdvp != fdvp) {	<span class="enscript-comment">/* update parent pointer */</span>
			<span class="enscript-keyword">if</span> (fnp-&gt;n_parent &amp;&amp; !vnode_get(fnp-&gt;n_parent)) {
				<span class="enscript-comment">/* remove ref from old parent */</span>
				vnode_rele(fnp-&gt;n_parent);
				vnode_put(fnp-&gt;n_parent);
			}
			fnp-&gt;n_parent = tdvp;
			<span class="enscript-keyword">if</span> (tdvp &amp;&amp; !vnode_get(tdvp)) {
				<span class="enscript-comment">/* add ref to new parent */</span>
				vnode_ref(tdvp);
				vnode_put(tdvp);
			} <span class="enscript-keyword">else</span> {
				fnp-&gt;n_parent = NULL;
			}
		}
		nfs_node_unlock(fnp);
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
	nfs_getattr(fdnp, NULL, ctx, NGA_CACHED);
	nfs_getattr(tdnp, NULL, ctx, NGA_CACHED);
	<span class="enscript-keyword">if</span> (locked) {
		<span class="enscript-comment">/* unlock node */</span>
		lck_mtx_lock(nfs_node_hash_mutex);
		tnp-&gt;n_hflag &amp;= ~NHLOCKED;
		<span class="enscript-keyword">if</span> (tnp-&gt;n_hflag &amp; NHLOCKWANT) {
			tnp-&gt;n_hflag &amp;= ~NHLOCKWANT;
			wakeup(tnp);
		}
		lck_mtx_unlock(nfs_node_hash_mutex);
	}
	nfs_node_clear_busy4(fdnp, fnp, tdnp, tnp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Do an NFS rename rpc. Called from nfs_vnop_rename() and nfs_sillyrename().
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_rename_rpc</span>(
	nfsnode_t fdnp,
	<span class="enscript-type">char</span> *fnameptr,
	<span class="enscript-type">int</span> fnamelen,
	nfsnode_t tdnp,
	<span class="enscript-type">char</span> *tnameptr,
	<span class="enscript-type">int</span> tnamelen,
	vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, status, fwccpostattr = 0, twccpostattr = 0;
	<span class="enscript-type">struct</span> timespec fpremtime = { 0, 0 }, tpremtime = { 0, 0 };
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> nfsvers;
	u_int64_t xid, txid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;

	nmp = NFSTONMP(fdnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER2) &amp;&amp;
	    ((fnamelen &gt; NFS_MAXNAMLEN) || (tnamelen &gt; NFS_MAXNAMLEN)))
		<span class="enscript-keyword">return</span> (ENAMETOOLONG);

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_build_alloc_init(error, &amp;nmreq,
		(NFSX_FH(nfsvers) + NFSX_UNSIGNED) * 2 +
		nfsm_rndup(fnamelen) + nfsm_rndup(tnamelen));
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, fdnp-&gt;n_fhp, fdnp-&gt;n_fhsize);
	nfsm_chain_add_name(error, &amp;nmreq, fnameptr, fnamelen, nmp);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, tdnp-&gt;n_fhp, tdnp-&gt;n_fhsize);
	nfsm_chain_add_name(error, &amp;nmreq, tnameptr, tnamelen, nmp);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);

	error = nfs_request(fdnp, NULL, &amp;nmreq, NFSPROC_RENAME, ctx, NULL, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock2(fdnp, tdnp)))
		error = lockerror;
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
		txid = xid;
		nfsm_chain_get_wcc_data(error, &amp;nmrep, fdnp, &amp;fpremtime, &amp;fwccpostattr, &amp;xid);
		nfsm_chain_get_wcc_data(error, &amp;nmrep, tdnp, &amp;tpremtime, &amp;twccpostattr, &amp;txid);
	}
	<span class="enscript-keyword">if</span> (!error)
		error = status;
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">if</span> (!lockerror) {
		fdnp-&gt;n_flag |= NMODIFIED;
		<span class="enscript-comment">/* if directory hadn't changed, update namecache mtime */</span>
		<span class="enscript-keyword">if</span> (nfstimespeccmp(&amp;fdnp-&gt;n_ncmtime, &amp;fpremtime, ==))
			NFS_CHANGED_UPDATE_NC(nfsvers, fdnp, &amp;fdnp-&gt;n_vattr);
		<span class="enscript-keyword">if</span> (!fwccpostattr)
			NATTRINVALIDATE(fdnp);
		tdnp-&gt;n_flag |= NMODIFIED;
		<span class="enscript-comment">/* if directory hadn't changed, update namecache mtime */</span>
		<span class="enscript-keyword">if</span> (nfstimespeccmp(&amp;tdnp-&gt;n_ncmtime, &amp;tpremtime, ==))
			NFS_CHANGED_UPDATE_NC(nfsvers, tdnp, &amp;tdnp-&gt;n_vattr);
		<span class="enscript-keyword">if</span> (!twccpostattr)
			NATTRINVALIDATE(tdnp);
		nfs_node_unlock2(fdnp, tdnp);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS hard link create call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_vnop_link</span>(
	<span class="enscript-type">struct</span> vnop_link_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		vnode_t a_tdvp;
		struct componentname *a_cnp;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t vp = ap-&gt;a_vp;
	vnode_t tdvp = ap-&gt;a_tdvp;
	<span class="enscript-type">struct</span> componentname *cnp = ap-&gt;a_cnp;
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, status, wccpostattr = 0, attrflag = 0;
	<span class="enscript-type">struct</span> timespec premtime = { 0, 0 };
	<span class="enscript-type">struct</span> nfsmount *nmp;
	nfsnode_t np = VTONFS(vp);
	nfsnode_t tdnp = VTONFS(tdvp);
	<span class="enscript-type">int</span> nfsvers;
	u_int64_t xid, txid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;

	<span class="enscript-keyword">if</span> (vnode_mount(vp) != vnode_mount(tdvp))
		<span class="enscript-keyword">return</span> (EXDEV);

	nmp = VTONMP(vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER2) &amp;&amp; (cnp-&gt;cn_namelen &gt; NFS_MAXNAMLEN))
		<span class="enscript-keyword">return</span> (ENAMETOOLONG);

	<span class="enscript-comment">/*
	 * Push all writes to the server, so that the attribute cache
	 * doesn't get &quot;out of sync&quot; with the server.
	 * XXX There should be a better way!
	 */</span>
	nfs_flush(np, MNT_WAIT, vfs_context_thread(ctx), V_IGNORE_WRITEERR);

	error = nfs_node_set_busy2(tdnp, np, vfs_context_thread(ctx));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_build_alloc_init(error, &amp;nmreq,
		NFSX_FH(nfsvers)*2 + NFSX_UNSIGNED + nfsm_rndup(cnp-&gt;cn_namelen));
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, tdnp-&gt;n_fhp, tdnp-&gt;n_fhsize);
	nfsm_chain_add_name(error, &amp;nmreq, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, nmp);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfs_request(np, NULL, &amp;nmreq, NFSPROC_LINK, ctx, NULL, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock2(tdnp, np))) {
		error = lockerror;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
		txid = xid;
		nfsm_chain_postop_attr_update_flag(error, &amp;nmrep, np, attrflag, &amp;xid);
		nfsm_chain_get_wcc_data(error, &amp;nmrep, tdnp, &amp;premtime, &amp;wccpostattr, &amp;txid);
	}
	<span class="enscript-keyword">if</span> (!error)
		error = status;
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">if</span> (!lockerror) {
		<span class="enscript-keyword">if</span> (!attrflag)
			NATTRINVALIDATE(np);
		tdnp-&gt;n_flag |= NMODIFIED;
		<span class="enscript-comment">/* if directory hadn't changed, update namecache mtime */</span>
		<span class="enscript-keyword">if</span> (nfstimespeccmp(&amp;tdnp-&gt;n_ncmtime, &amp;premtime, ==))
			NFS_CHANGED_UPDATE_NC(nfsvers, tdnp, &amp;tdnp-&gt;n_vattr);
		<span class="enscript-keyword">if</span> (!wccpostattr)
			NATTRINVALIDATE(tdnp);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; (tdnp-&gt;n_flag &amp; NNEGNCENTRIES)) {
			tdnp-&gt;n_flag &amp;= ~NNEGNCENTRIES;
			cache_purge_negatives(tdvp);
		}
		nfs_node_unlock2(tdnp, np);
	}
	nfs_node_clear_busy2(tdnp, np);
	<span class="enscript-comment">/*
	 * Kludge: Map EEXIST =&gt; 0 assuming that it is a reply to a retry.
	 */</span>
	<span class="enscript-keyword">if</span> (error == EEXIST)
		error = 0;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS symbolic link create call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_vnop_symlink</span>(
	<span class="enscript-type">struct</span> vnop_symlink_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_dvp;
		vnode_t *a_vpp;
		struct componentname *a_cnp;
		struct vnode_attr *a_vap;
		char *a_target;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t dvp = ap-&gt;a_dvp;
	<span class="enscript-type">struct</span> vnode_attr *vap = ap-&gt;a_vap;
	<span class="enscript-type">struct</span> componentname *cnp = ap-&gt;a_cnp;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	fhandle_t fh;
	<span class="enscript-type">int</span> slen, error = 0, lockerror = ENOENT, busyerror = ENOENT, status, wccpostattr = 0;
	<span class="enscript-type">struct</span> timespec premtime = { 0, 0 };
	vnode_t newvp = NULL;
	<span class="enscript-type">int</span> nfsvers, gotuid, gotgid;
	u_int64_t xid = 0, dxid;
	nfsnode_t np = NULL;
	nfsnode_t dnp = VTONFS(dvp);
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;
	<span class="enscript-type">struct</span> nfs_dulookup dul;

	nmp = VTONMP(dvp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	slen = strlen(ap-&gt;a_target);
	<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER2) &amp;&amp;
	    ((cnp-&gt;cn_namelen &gt; NFS_MAXNAMLEN) || (slen &gt; NFS_MAXPATHLEN)))
		<span class="enscript-keyword">return</span> (ENAMETOOLONG);

	nfs_avoid_needless_id_setting_on_create(dnp, vap, ctx);

	VATTR_SET_SUPPORTED(vap, va_mode);
	VATTR_SET_SUPPORTED(vap, va_uid);
	VATTR_SET_SUPPORTED(vap, va_gid);
	VATTR_SET_SUPPORTED(vap, va_data_size);
	VATTR_SET_SUPPORTED(vap, va_access_time);
	VATTR_SET_SUPPORTED(vap, va_modify_time);
	gotuid = VATTR_IS_ACTIVE(vap, va_uid);
	gotgid = VATTR_IS_ACTIVE(vap, va_gid);

	error = busyerror = nfs_node_set_busy(dnp, vfs_context_thread(ctx));
	nfs_dulookup_init(&amp;dul, dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx);

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_build_alloc_init(error, &amp;nmreq,
		NFSX_FH(nfsvers) + 2 * NFSX_UNSIGNED +
		nfsm_rndup(cnp-&gt;cn_namelen) + nfsm_rndup(slen) + NFSX_SATTR(nfsvers));
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, dnp-&gt;n_fhp, dnp-&gt;n_fhsize);
	nfsm_chain_add_name(error, &amp;nmreq, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, nmp);
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
		nfsm_chain_add_v3sattr(error, &amp;nmreq, vap);
	nfsm_chain_add_name(error, &amp;nmreq, ap-&gt;a_target, slen, nmp);
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER2)
		nfsm_chain_add_v2sattr(error, &amp;nmreq, vap, -1);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);

	error = nfs_request_async(dnp, NULL, &amp;nmreq, NFSPROC_SYMLINK,
			vfs_context_thread(ctx), vfs_context_ucred(ctx), NULL, 0, NULL, &amp;req);
	<span class="enscript-keyword">if</span> (!error) {
		nfs_dulookup_start(&amp;dul, dnp, ctx);
		error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);
	}

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
		error = lockerror;
	dxid = xid;
	<span class="enscript-keyword">if</span> (!error &amp;&amp; !status) {
		<span class="enscript-keyword">if</span> (dnp-&gt;n_flag &amp; NNEGNCENTRIES) {
			dnp-&gt;n_flag &amp;= ~NNEGNCENTRIES;
			cache_purge_negatives(dvp);
		}
		<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
			error = nfsm_chain_get_fh_attr(&amp;nmrep, dnp, ctx, nfsvers, &amp;xid, &amp;fh, &amp;nvattr);
		<span class="enscript-keyword">else</span>
			fh.fh_len = 0;
	}
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
		nfsm_chain_get_wcc_data(error, &amp;nmrep, dnp, &amp;premtime, &amp;wccpostattr, &amp;dxid);
	<span class="enscript-keyword">if</span> (!error)
		error = status;
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);

	<span class="enscript-keyword">if</span> (!lockerror) {
		dnp-&gt;n_flag |= NMODIFIED;
		<span class="enscript-comment">/* if directory hadn't changed, update namecache mtime */</span>
		<span class="enscript-keyword">if</span> (nfstimespeccmp(&amp;dnp-&gt;n_ncmtime, &amp;premtime, ==))
			NFS_CHANGED_UPDATE_NC(nfsvers, dnp, &amp;dnp-&gt;n_vattr);
		nfs_node_unlock(dnp);
		<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
		nfs_getattr(dnp, NULL, ctx, wccpostattr ? NGA_CACHED : NGA_UNCACHED);
	}

	<span class="enscript-keyword">if</span> (!error &amp;&amp; fh.fh_len)
		error = nfs_nget(NFSTOMP(dnp), dnp, cnp, fh.fh_data, fh.fh_len, &amp;nvattr, &amp;xid, rq.r_auth, NG_MAKEENTRY, &amp;np);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; np)
		newvp = NFSTOV(np);

	nfs_dulookup_finish(&amp;dul, dnp, ctx);

	<span class="enscript-comment">/*
	 * Kludge: Map EEXIST =&gt; 0 assuming that you have a reply to a retry
	 * if we can succeed in looking up the symlink.
	 */</span>
	<span class="enscript-keyword">if</span> ((error == EEXIST) || (!error &amp;&amp; !newvp)) {
		<span class="enscript-keyword">if</span> (newvp) {
			nfs_node_unlock(np);
			vnode_put(newvp);
			newvp = NULL;
		}
		error = nfs_lookitup(dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx, &amp;np);
		<span class="enscript-keyword">if</span> (!error) {
			newvp = NFSTOV(np);
			<span class="enscript-keyword">if</span> (vnode_vtype(newvp) != VLNK)
				error = EEXIST;
		}
	}
	<span class="enscript-keyword">if</span> (!busyerror)
		nfs_node_clear_busy(dnp);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (gotuid || gotgid) &amp;&amp;
	    (!newvp || nfs_getattrcache(np, &amp;nvattr, 0) ||
	     (gotuid &amp;&amp; (nvattr.nva_uid != vap-&gt;va_uid)) ||
	     (gotgid &amp;&amp; (nvattr.nva_gid != vap-&gt;va_gid)))) {
		<span class="enscript-comment">/* clear ID bits if server didn't use them (or we can't tell) */</span>
		VATTR_CLEAR_SUPPORTED(vap, va_uid);
		VATTR_CLEAR_SUPPORTED(vap, va_gid);
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (newvp) {
			nfs_node_unlock(np);
			vnode_put(newvp);
		}
	} <span class="enscript-keyword">else</span> {
		nfs_node_unlock(np);
		*ap-&gt;a_vpp = newvp;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS make dir call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_vnop_mkdir</span>(
	<span class="enscript-type">struct</span> vnop_mkdir_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_dvp;
		vnode_t *a_vpp;
		struct componentname *a_cnp;
		struct vnode_attr *a_vap;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t dvp = ap-&gt;a_dvp;
	<span class="enscript-type">struct</span> vnode_attr *vap = ap-&gt;a_vap;
	<span class="enscript-type">struct</span> componentname *cnp = ap-&gt;a_cnp;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	nfsnode_t np = NULL;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	nfsnode_t dnp = VTONFS(dvp);
	vnode_t newvp = NULL;
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, busyerror = ENOENT, status, wccpostattr = 0;
	<span class="enscript-type">struct</span> timespec premtime = { 0, 0 };
	<span class="enscript-type">int</span> nfsvers, gotuid, gotgid;
	u_int64_t xid= 0, dxid;
	fhandle_t fh;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;
	<span class="enscript-type">struct</span> nfs_dulookup dul;

	nmp = VTONMP(dvp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER2) &amp;&amp; (cnp-&gt;cn_namelen &gt; NFS_MAXNAMLEN))
		<span class="enscript-keyword">return</span> (ENAMETOOLONG);

	nfs_avoid_needless_id_setting_on_create(dnp, vap, ctx);

	VATTR_SET_SUPPORTED(vap, va_mode);
	VATTR_SET_SUPPORTED(vap, va_uid);
	VATTR_SET_SUPPORTED(vap, va_gid);
	VATTR_SET_SUPPORTED(vap, va_data_size);
	VATTR_SET_SUPPORTED(vap, va_access_time);
	VATTR_SET_SUPPORTED(vap, va_modify_time);
	gotuid = VATTR_IS_ACTIVE(vap, va_uid);
	gotgid = VATTR_IS_ACTIVE(vap, va_gid);

	error = busyerror = nfs_node_set_busy(dnp, vfs_context_thread(ctx));
	nfs_dulookup_init(&amp;dul, dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx);

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_build_alloc_init(error, &amp;nmreq,
		NFSX_FH(nfsvers) + NFSX_UNSIGNED +
		nfsm_rndup(cnp-&gt;cn_namelen) + NFSX_SATTR(nfsvers));
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, dnp-&gt;n_fhp, dnp-&gt;n_fhsize);
	nfsm_chain_add_name(error, &amp;nmreq, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, nmp);
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
		nfsm_chain_add_v3sattr(error, &amp;nmreq, vap);
	<span class="enscript-keyword">else</span>
		nfsm_chain_add_v2sattr(error, &amp;nmreq, vap, -1);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);

	error = nfs_request_async(dnp, NULL, &amp;nmreq, NFSPROC_MKDIR,
			vfs_context_thread(ctx), vfs_context_ucred(ctx), NULL, 0, NULL, &amp;req);
	<span class="enscript-keyword">if</span> (!error) {
		nfs_dulookup_start(&amp;dul, dnp, ctx);
		error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);
	}

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
		error = lockerror;
	dxid = xid;
	<span class="enscript-keyword">if</span> (!error &amp;&amp; !status) {
		<span class="enscript-keyword">if</span> (dnp-&gt;n_flag &amp; NNEGNCENTRIES) {
			dnp-&gt;n_flag &amp;= ~NNEGNCENTRIES;
			cache_purge_negatives(dvp);
		}
		error = nfsm_chain_get_fh_attr(&amp;nmrep, dnp, ctx, nfsvers, &amp;xid, &amp;fh, &amp;nvattr);
	}
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
		nfsm_chain_get_wcc_data(error, &amp;nmrep, dnp, &amp;premtime, &amp;wccpostattr, &amp;dxid);
	<span class="enscript-keyword">if</span> (!error)
		error = status;
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);

	<span class="enscript-keyword">if</span> (!lockerror) {
		dnp-&gt;n_flag |= NMODIFIED;
		<span class="enscript-comment">/* if directory hadn't changed, update namecache mtime */</span>
		<span class="enscript-keyword">if</span> (nfstimespeccmp(&amp;dnp-&gt;n_ncmtime, &amp;premtime, ==))
			NFS_CHANGED_UPDATE_NC(nfsvers, dnp, &amp;dnp-&gt;n_vattr);
		nfs_node_unlock(dnp);
		<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
		nfs_getattr(dnp, NULL, ctx, wccpostattr ? NGA_CACHED : NGA_UNCACHED);
	}

	<span class="enscript-keyword">if</span> (!error &amp;&amp; fh.fh_len)
		error = nfs_nget(NFSTOMP(dnp), dnp, cnp, fh.fh_data, fh.fh_len, &amp;nvattr, &amp;xid, rq.r_auth, NG_MAKEENTRY, &amp;np);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; np)
		newvp = NFSTOV(np);

	nfs_dulookup_finish(&amp;dul, dnp, ctx);

	<span class="enscript-comment">/*
	 * Kludge: Map EEXIST =&gt; 0 assuming that you have a reply to a retry
	 * if we can succeed in looking up the directory.
	 */</span>
	<span class="enscript-keyword">if</span> ((error == EEXIST) || (!error &amp;&amp; !newvp)) {
		<span class="enscript-keyword">if</span> (newvp) {
			nfs_node_unlock(np);
			vnode_put(newvp);
			newvp = NULL;
		}
		error = nfs_lookitup(dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx, &amp;np);
		<span class="enscript-keyword">if</span> (!error) {
			newvp = NFSTOV(np);
			<span class="enscript-keyword">if</span> (vnode_vtype(newvp) != VDIR)
				error = EEXIST;
		}
	}
	<span class="enscript-keyword">if</span> (!busyerror)
		nfs_node_clear_busy(dnp);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (gotuid || gotgid) &amp;&amp;
	    (!newvp || nfs_getattrcache(np, &amp;nvattr, 0) ||
	     (gotuid &amp;&amp; (nvattr.nva_uid != vap-&gt;va_uid)) ||
	     (gotgid &amp;&amp; (nvattr.nva_gid != vap-&gt;va_gid)))) {
		<span class="enscript-comment">/* clear ID bits if server didn't use them (or we can't tell) */</span>
		VATTR_CLEAR_SUPPORTED(vap, va_uid);
		VATTR_CLEAR_SUPPORTED(vap, va_gid);
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (newvp) {
			nfs_node_unlock(np);
			vnode_put(newvp);
		}
	} <span class="enscript-keyword">else</span> {
		nfs_node_unlock(np);
		*ap-&gt;a_vpp = newvp;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS remove directory call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_vnop_rmdir</span>(
	<span class="enscript-type">struct</span> vnop_rmdir_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_dvp;
		vnode_t a_vp;
		struct componentname *a_cnp;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t vp = ap-&gt;a_vp;
	vnode_t dvp = ap-&gt;a_dvp;
	<span class="enscript-type">struct</span> componentname *cnp = ap-&gt;a_cnp;
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, status, wccpostattr = 0;
	<span class="enscript-type">struct</span> timespec premtime = { 0, 0 };
	<span class="enscript-type">struct</span> nfsmount *nmp;
	nfsnode_t np = VTONFS(vp);
	nfsnode_t dnp = VTONFS(dvp);
	<span class="enscript-type">int</span> nfsvers;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;
	<span class="enscript-type">struct</span> nfs_dulookup dul;

	nmp = VTONMP(vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER2) &amp;&amp; (cnp-&gt;cn_namelen &gt; NFS_MAXNAMLEN))
		<span class="enscript-keyword">return</span> (ENAMETOOLONG);

	<span class="enscript-keyword">if</span> ((error = nfs_node_set_busy2(dnp, np, vfs_context_thread(ctx))))
		<span class="enscript-keyword">return</span> (error);

	nfs_dulookup_init(&amp;dul, dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx);

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_build_alloc_init(error, &amp;nmreq,
		NFSX_FH(nfsvers) + NFSX_UNSIGNED + nfsm_rndup(cnp-&gt;cn_namelen));
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, dnp-&gt;n_fhp, dnp-&gt;n_fhsize);
	nfsm_chain_add_name(error, &amp;nmreq, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, nmp);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);

	error = nfs_request_async(dnp, NULL, &amp;nmreq, NFSPROC_RMDIR,
			vfs_context_thread(ctx), vfs_context_ucred(ctx), NULL, 0, NULL, &amp;req);
	<span class="enscript-keyword">if</span> (!error) {
		nfs_dulookup_start(&amp;dul, dnp, ctx);
		error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);
	}

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
		error = lockerror;
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
		nfsm_chain_get_wcc_data(error, &amp;nmrep, dnp, &amp;premtime, &amp;wccpostattr, &amp;xid);
	<span class="enscript-keyword">if</span> (!error)
		error = status;
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);

	<span class="enscript-keyword">if</span> (!lockerror) {
		dnp-&gt;n_flag |= NMODIFIED;
		<span class="enscript-comment">/* if directory hadn't changed, update namecache mtime */</span>
		<span class="enscript-keyword">if</span> (nfstimespeccmp(&amp;dnp-&gt;n_ncmtime, &amp;premtime, ==))
			NFS_CHANGED_UPDATE_NC(nfsvers, dnp, &amp;dnp-&gt;n_vattr);
		nfs_node_unlock(dnp);
		nfs_name_cache_purge(dnp, np, cnp, ctx);
		<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
		nfs_getattr(dnp, NULL, ctx, wccpostattr ? NGA_CACHED : NGA_UNCACHED);
	}
	nfs_dulookup_finish(&amp;dul, dnp, ctx);
	nfs_node_clear_busy2(dnp, np);

	<span class="enscript-comment">/*
	 * Kludge: Map ENOENT =&gt; 0 assuming that you have a reply to a retry.
	 */</span>
	<span class="enscript-keyword">if</span> (error == ENOENT)
		error = 0;
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-comment">/*
		 * remove nfsnode from hash now so we can't accidentally find it
		 * again if another object gets created with the same filehandle
		 * before this vnode gets reclaimed
		 */</span>
		lck_mtx_lock(nfs_node_hash_mutex);
		<span class="enscript-keyword">if</span> (np-&gt;n_hflag &amp; NHHASHED) {
			LIST_REMOVE(np, n_hash);
			np-&gt;n_hflag &amp;= ~NHHASHED;
			FSDBG(266, 0, np, np-&gt;n_flag, 0xb1eb1e);
		}
		lck_mtx_unlock(nfs_node_hash_mutex);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS readdir call
 *
 * The incoming &quot;offset&quot; is a directory cookie indicating where in the
 * directory entries should be read from.  A zero cookie means start at
 * the beginning of the directory.  Any other cookie will be a cookie
 * returned from the server.  
 *
 * Using that cookie, determine which buffer (and where in that buffer)
 * to start returning entries from.  Buffer logical block numbers are
 * the cookies they start at.  If a buffer is found that is not full,
 * call into the bio/RPC code to fill it.  The RPC code will probably
 * fill several buffers (dropping the first, requiring a re-get).
 *
 * When done copying entries to the buffer, set the offset to the current
 * entry's cookie and enter that cookie in the cookie cache.
 *
 * Note: because the getdirentries(2) API returns a long-typed offset,
 * the incoming offset is a potentially truncated cookie (ptc).
 * The cookie matching code is aware of this and will fall back to
 * matching only 32 bits of the cookie.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_readdir</span>(
	<span class="enscript-type">struct</span> vnop_readdir_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		struct uio *a_uio;
		int a_flags;
		int *a_eofflag;
		int *a_numdirent;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t dvp = ap-&gt;a_vp;
	nfsnode_t dnp = VTONFS(dvp);
	<span class="enscript-type">struct</span> nfsmount *nmp;
	uio_t uio = ap-&gt;a_uio;
	<span class="enscript-type">int</span> error, nfsvers, extended, numdirent, bigcookies, ptc, done;
	uint16_t i, iptc, rlen, nlen;
	uint64_t cookie, nextcookie, lbn = 0;
	<span class="enscript-type">struct</span> nfsbuf *bp = NULL;
	<span class="enscript-type">struct</span> nfs_dir_buf_header *ndbhp;
	<span class="enscript-type">struct</span> direntry *dp, *dpptc;
	<span class="enscript-type">struct</span> dirent dent;
	<span class="enscript-type">char</span> *cp = NULL;
	thread_t thd;

	nmp = VTONMP(dvp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	bigcookies = (nmp-&gt;nm_state &amp; NFSSTA_BIGCOOKIES);
	extended = (ap-&gt;a_flags &amp; VNODE_READDIR_EXTENDED);

	<span class="enscript-keyword">if</span> (vnode_vtype(dvp) != VDIR)
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-keyword">if</span> (ap-&gt;a_eofflag)
		*ap-&gt;a_eofflag = 0;

	<span class="enscript-keyword">if</span> (uio_resid(uio) == 0)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> ((nfsvers &gt;= NFS_VER4) &amp;&amp; (dnp-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER)) {
		<span class="enscript-comment">/* trigger directories should never be read, return nothing */</span>
		<span class="enscript-keyword">return</span> (0);
	}

	thd = vfs_context_thread(ctx);
	numdirent = done = 0;
	nextcookie = uio_offset(uio);
	ptc = bigcookies &amp;&amp; NFS_DIR_COOKIE_POTENTIALLY_TRUNCATED(nextcookie);

	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(dnp)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (dnp-&gt;n_flag &amp; NNEEDINVALIDATE) {
		dnp-&gt;n_flag &amp;= ~NNEEDINVALIDATE;
		nfs_invaldir(dnp);
		nfs_node_unlock(dnp);
		error = nfs_vinvalbuf(dvp, 0, ctx, 1);
		<span class="enscript-keyword">if</span> (!error)
			error = nfs_node_lock(dnp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * check for need to invalidate when (re)starting at beginning
	 */</span>
	<span class="enscript-keyword">if</span> (!nextcookie) {
		<span class="enscript-keyword">if</span> (dnp-&gt;n_flag &amp; NMODIFIED) {
			nfs_invaldir(dnp);
			nfs_node_unlock(dnp);
			<span class="enscript-keyword">if</span> ((error = nfs_vinvalbuf(dvp, 0, ctx, 1)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		} <span class="enscript-keyword">else</span> {
			nfs_node_unlock(dnp);
		}
		<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
		<span class="enscript-keyword">if</span> ((error = nfs_getattr(dnp, NULL, ctx, NGA_UNCACHED)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	} <span class="enscript-keyword">else</span> {
		nfs_node_unlock(dnp);
	}

	error = nfs_dir_cookie_to_lbn(dnp, nextcookie, &amp;ptc, &amp;lbn);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (error &lt; 0) { <span class="enscript-comment">/* just hit EOF cookie */</span>
			done = 1;
			error = 0;
		}
		<span class="enscript-keyword">if</span> (ap-&gt;a_eofflag)
			*ap-&gt;a_eofflag = 1;
	}

	<span class="enscript-keyword">while</span> (!error &amp;&amp; !done) {
		OSAddAtomic64(1, &amp;nfsstats.biocache_readdirs);
		cookie = nextcookie;
<span class="enscript-reference">getbuffer</span>:
		error = nfs_buf_get(dnp, lbn, NFS_DIRBLKSIZ, thd, NBLK_READ, &amp;bp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		ndbhp = (<span class="enscript-type">struct</span> nfs_dir_buf_header*)bp-&gt;nb_data;
		<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_CACHE) || !ISSET(ndbhp-&gt;ndbh_flags, NDB_FULL)) {
			<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_CACHE)) { <span class="enscript-comment">/* initialize the buffer */</span>
				ndbhp-&gt;ndbh_flags = 0;
				ndbhp-&gt;ndbh_count = 0;
				ndbhp-&gt;ndbh_entry_end = <span class="enscript-keyword">sizeof</span>(*ndbhp);
				ndbhp-&gt;ndbh_ncgen = dnp-&gt;n_ncgen;
			}
			error = nfs_buf_readdir(bp, ctx);
			<span class="enscript-keyword">if</span> (error == NFSERR_DIRBUFDROPPED)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">getbuffer</span>;
			<span class="enscript-keyword">if</span> (error)
				nfs_buf_release(bp, 1);
			<span class="enscript-keyword">if</span> (error &amp;&amp; (error != ENXIO) &amp;&amp; (error != ETIMEDOUT) &amp;&amp; (error != EINTR) &amp;&amp; (error != ERESTART)) {
				<span class="enscript-keyword">if</span> (!nfs_node_lock(dnp)) {
					nfs_invaldir(dnp);
					nfs_node_unlock(dnp);
				}
				nfs_vinvalbuf(dvp, 0, ctx, 1);
				<span class="enscript-keyword">if</span> (error == NFSERR_BAD_COOKIE)
					error = ENOENT;
			}
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-comment">/* find next entry to return */</span>
		dp = NFS_DIR_BUF_FIRST_DIRENTRY(bp);
		i = 0;
		<span class="enscript-keyword">if</span> ((lbn != cookie) &amp;&amp; !(ptc &amp;&amp; NFS_DIR_COOKIE_SAME32(lbn, cookie))) {
			dpptc = NULL;
			iptc = 0;
			<span class="enscript-keyword">for</span> (; (i &lt; ndbhp-&gt;ndbh_count) &amp;&amp; (cookie != dp-&gt;d_seekoff); i++) {
				<span class="enscript-keyword">if</span> (ptc &amp;&amp; !dpptc &amp;&amp; NFS_DIR_COOKIE_SAME32(cookie, dp-&gt;d_seekoff)) {
					iptc = i;
					dpptc = dp;
				}
				nextcookie = dp-&gt;d_seekoff;
				dp = NFS_DIRENTRY_NEXT(dp);
			}
			<span class="enscript-keyword">if</span> ((i == ndbhp-&gt;ndbh_count) &amp;&amp; dpptc) {
				i = iptc;
				dp = dpptc;
			}
			<span class="enscript-keyword">if</span> (i &lt; ndbhp-&gt;ndbh_count) {
				nextcookie = dp-&gt;d_seekoff;
				dp = NFS_DIRENTRY_NEXT(dp);
				i++;
			}
		}
		ptc = 0;  <span class="enscript-comment">/* only have to deal with ptc on first cookie */</span>

		<span class="enscript-comment">/* return as many entries as we can */</span>
		<span class="enscript-keyword">for</span> (; i &lt; ndbhp-&gt;ndbh_count; i++) {
			<span class="enscript-keyword">if</span> (extended) {
				rlen = dp-&gt;d_reclen;
				cp = (<span class="enscript-type">char</span>*)dp;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (!cp) {
					cp = (<span class="enscript-type">char</span>*)&amp;dent;
					bzero(cp, <span class="enscript-keyword">sizeof</span>(dent));
				}
				<span class="enscript-keyword">if</span> (dp-&gt;d_namlen &gt; (<span class="enscript-keyword">sizeof</span>(dent.d_name) - 1))
					nlen = <span class="enscript-keyword">sizeof</span>(dent.d_name) - 1;
				<span class="enscript-keyword">else</span>
					nlen = dp-&gt;d_namlen;
				rlen = NFS_DIRENT_LEN(nlen);
				dent.d_reclen = rlen;
				dent.d_ino = dp-&gt;d_ino;
				dent.d_type = dp-&gt;d_type;
				dent.d_namlen = nlen;
				strlcpy(dent.d_name, dp-&gt;d_name, nlen + 1);
			}
			<span class="enscript-comment">/* check that the record fits */</span>
			<span class="enscript-keyword">if</span> (rlen &gt; uio_resid(uio)) {
				done = 1;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> ((error = uiomove(cp, rlen, uio)))
				<span class="enscript-keyword">break</span>;
			numdirent++;
			nextcookie = dp-&gt;d_seekoff;
			dp = NFS_DIRENTRY_NEXT(dp);
		}

		<span class="enscript-keyword">if</span> (i == ndbhp-&gt;ndbh_count) {
			<span class="enscript-comment">/* hit end of buffer, move to next buffer */</span>
			lbn = nextcookie;
			<span class="enscript-comment">/* if we also hit EOF, we're done */</span>
			<span class="enscript-keyword">if</span> (ISSET(ndbhp-&gt;ndbh_flags, NDB_EOF)) {
				done = 1;
				<span class="enscript-keyword">if</span> (ap-&gt;a_eofflag)
					*ap-&gt;a_eofflag = 1;
			}
		}
		<span class="enscript-keyword">if</span> (!error)
			uio_setoffset(uio, nextcookie);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; !done &amp;&amp; (nextcookie == cookie)) {
			printf(<span class="enscript-string">&quot;nfs readdir cookie didn't change 0x%llx, %d/%d\n&quot;</span>, cookie, i, ndbhp-&gt;ndbh_count);
			error = EIO;
		}
		nfs_buf_release(bp, 1);
	}

	<span class="enscript-keyword">if</span> (!error)
		nfs_dir_cookie_cache(dnp, nextcookie, lbn);

	<span class="enscript-keyword">if</span> (ap-&gt;a_numdirent)
		*ap-&gt;a_numdirent = numdirent;
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Invalidate cached directory information, except for the actual directory
 * blocks (which are invalidated separately).
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_invaldir</span>(nfsnode_t dnp)
{
	<span class="enscript-keyword">if</span> (vnode_vtype(NFSTOV(dnp)) != VDIR)
		<span class="enscript-keyword">return</span>;
	dnp-&gt;n_eofcookie = 0;
	dnp-&gt;n_cookieverf = 0;
	<span class="enscript-keyword">if</span> (!dnp-&gt;n_cookiecache)
		<span class="enscript-keyword">return</span>;
	dnp-&gt;n_cookiecache-&gt;free = 0;
	dnp-&gt;n_cookiecache-&gt;mru = -1;
	memset(dnp-&gt;n_cookiecache-&gt;next, -1, NFSNUMCOOKIES);
}

<span class="enscript-comment">/*
 * calculate how much space is available for additional directory entries.
 */</span>
uint32_t
<span class="enscript-function-name">nfs_dir_buf_freespace</span>(<span class="enscript-type">struct</span> nfsbuf *bp, <span class="enscript-type">int</span> rdirplus)
{
	<span class="enscript-type">struct</span> nfs_dir_buf_header *ndbhp = (<span class="enscript-type">struct</span> nfs_dir_buf_header*)bp-&gt;nb_data;
	uint32_t space;

	<span class="enscript-keyword">if</span> (!ndbhp)
		<span class="enscript-keyword">return</span> (0);
	space = bp-&gt;nb_bufsize - ndbhp-&gt;ndbh_entry_end;
	<span class="enscript-keyword">if</span> (rdirplus)
		space -= ndbhp-&gt;ndbh_count * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_vattr);
	<span class="enscript-keyword">return</span> (space);
}

<span class="enscript-comment">/*
 * add/update a cookie-&gt;lbn entry in the directory cookie cache
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_dir_cookie_cache</span>(nfsnode_t dnp, uint64_t cookie, uint64_t lbn)
{
	<span class="enscript-type">struct</span> nfsdmap *ndcc;
	int8_t i, prev;

	<span class="enscript-keyword">if</span> (!cookie)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (nfs_node_lock(dnp))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (cookie == dnp-&gt;n_eofcookie) { <span class="enscript-comment">/* EOF cookie */</span>
		nfs_node_unlock(dnp);
		<span class="enscript-keyword">return</span>;
	}

	ndcc = dnp-&gt;n_cookiecache;
	<span class="enscript-keyword">if</span> (!ndcc) {
		<span class="enscript-comment">/* allocate the cookie cache structure */</span>
		MALLOC_ZONE(dnp-&gt;n_cookiecache, <span class="enscript-type">struct</span> nfsdmap *,
			<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfsdmap), M_NFSDIROFF, M_WAITOK); 
		<span class="enscript-keyword">if</span> (!dnp-&gt;n_cookiecache) {
			nfs_node_unlock(dnp);
			<span class="enscript-keyword">return</span>;
		}
		ndcc = dnp-&gt;n_cookiecache;
		ndcc-&gt;free = 0;
		ndcc-&gt;mru = -1;
		memset(ndcc-&gt;next, -1, NFSNUMCOOKIES);
	}

	<span class="enscript-comment">/*
	 * Search the list for this cookie.
	 * Keep track of previous and last entries.
	 */</span>
	prev = -1;
	i = ndcc-&gt;mru;
	<span class="enscript-keyword">while</span> ((i != -1) &amp;&amp; (cookie != ndcc-&gt;cookies[i].key)) {
		<span class="enscript-keyword">if</span> (ndcc-&gt;next[i] == -1) <span class="enscript-comment">/* stop on last entry so we can reuse */</span>
			<span class="enscript-keyword">break</span>;
		prev = i;
		i = ndcc-&gt;next[i];
	}
	<span class="enscript-keyword">if</span> ((i != -1) &amp;&amp; (cookie == ndcc-&gt;cookies[i].key)) {
		<span class="enscript-comment">/* found it, remove from list */</span>
		<span class="enscript-keyword">if</span> (prev != -1)
			ndcc-&gt;next[prev] = ndcc-&gt;next[i];
		<span class="enscript-keyword">else</span>
			ndcc-&gt;mru = ndcc-&gt;next[i];
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* not found, use next free entry or reuse last entry */</span>
		<span class="enscript-keyword">if</span> (ndcc-&gt;free != NFSNUMCOOKIES)
			i = ndcc-&gt;free++;
		<span class="enscript-keyword">else</span>
			ndcc-&gt;next[prev] = -1;
		ndcc-&gt;cookies[i].key = cookie;
		ndcc-&gt;cookies[i].lbn = lbn;
	}
	<span class="enscript-comment">/* insert cookie at head of MRU list */</span>
	ndcc-&gt;next[i] = ndcc-&gt;mru;
	ndcc-&gt;mru = i;
	nfs_node_unlock(dnp);
}

<span class="enscript-comment">/*
 * Try to map the given directory cookie to a directory buffer (return lbn).
 * If we have a possibly truncated cookie (ptc), check for 32-bit matches too.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_dir_cookie_to_lbn</span>(nfsnode_t dnp, uint64_t cookie, <span class="enscript-type">int</span> *ptc, uint64_t *lbnp)
{
	<span class="enscript-type">struct</span> nfsdmap *ndcc = dnp-&gt;n_cookiecache;
	int8_t eofptc, found;
	<span class="enscript-type">int</span> i, iptc;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfsbuf *bp, *lastbp;
	<span class="enscript-type">struct</span> nfsbuflists blist;
	<span class="enscript-type">struct</span> direntry *dp, *dpptc;
	<span class="enscript-type">struct</span> nfs_dir_buf_header *ndbhp;

	<span class="enscript-keyword">if</span> (!cookie) {  <span class="enscript-comment">/* initial cookie */</span>
		*lbnp = 0;
		*ptc = 0;
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (nfs_node_lock(dnp))
		<span class="enscript-keyword">return</span> (ENOENT);

	<span class="enscript-keyword">if</span> (cookie == dnp-&gt;n_eofcookie) { <span class="enscript-comment">/* EOF cookie */</span>
		nfs_node_unlock(dnp);
		OSAddAtomic64(1, &amp;nfsstats.direofcache_hits);
		*ptc = 0;
		<span class="enscript-keyword">return</span> (-1);
	}
	<span class="enscript-comment">/* note if cookie is a 32-bit match with the EOF cookie */</span>
	eofptc = *ptc ? NFS_DIR_COOKIE_SAME32(cookie, dnp-&gt;n_eofcookie) : 0;
	iptc = -1;

	<span class="enscript-comment">/* search the list for the cookie */</span>
	<span class="enscript-keyword">for</span> (i = ndcc ? ndcc-&gt;mru : -1; i &gt;= 0; i = ndcc-&gt;next[i]) {
		<span class="enscript-keyword">if</span> (ndcc-&gt;cookies[i].key == cookie) {
			<span class="enscript-comment">/* found a match for this cookie */</span>
			*lbnp = ndcc-&gt;cookies[i].lbn;
			nfs_node_unlock(dnp);
			OSAddAtomic64(1, &amp;nfsstats.direofcache_hits);
			*ptc = 0;
			<span class="enscript-keyword">return</span> (0);
		}
		<span class="enscript-comment">/* check for 32-bit match */</span>
		<span class="enscript-keyword">if</span> (*ptc &amp;&amp; (iptc == -1) &amp;&amp; NFS_DIR_COOKIE_SAME32(ndcc-&gt;cookies[i].key, cookie))
			iptc = i;
	}
	<span class="enscript-comment">/* exact match not found */</span>
	<span class="enscript-keyword">if</span> (eofptc) {
		<span class="enscript-comment">/* but 32-bit match hit the EOF cookie */</span>
		nfs_node_unlock(dnp);
		OSAddAtomic64(1, &amp;nfsstats.direofcache_hits);
		<span class="enscript-keyword">return</span> (-1);
	}
	<span class="enscript-keyword">if</span> (iptc &gt;= 0) {
		<span class="enscript-comment">/* but 32-bit match got a hit */</span>
		*lbnp = ndcc-&gt;cookies[iptc].lbn;
		nfs_node_unlock(dnp);
		OSAddAtomic64(1, &amp;nfsstats.direofcache_hits);
		<span class="enscript-keyword">return</span> (0);
	}
	nfs_node_unlock(dnp);

	<span class="enscript-comment">/*
	 * No match found in the cookie cache... hmm...
	 * Let's search the directory's buffers for the cookie.
	 */</span>
	nmp = NFSTONMP(dnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	dpptc = NULL;
	found = 0;

	lck_mtx_lock(nfs_buf_mutex);
	<span class="enscript-comment">/*
	 * Scan the list of buffers, keeping them in order.
	 * Note that itercomplete inserts each of the remaining buffers
	 * into the head of list (thus reversing the elements).  So, we
	 * make sure to iterate through all buffers, inserting them after
	 * each other, to keep them in order.
	 * Also note: the LIST_INSERT_AFTER(lastbp) is only safe because
	 * we don't drop nfs_buf_mutex.
	 */</span>
	<span class="enscript-keyword">if</span> (!nfs_buf_iterprepare(dnp, &amp;blist, NBI_CLEAN)) {
		lastbp = NULL;
		<span class="enscript-keyword">while</span> ((bp = LIST_FIRST(&amp;blist))) {
			LIST_REMOVE(bp, nb_vnbufs);
			<span class="enscript-keyword">if</span> (!lastbp)
				LIST_INSERT_HEAD(&amp;dnp-&gt;n_cleanblkhd, bp, nb_vnbufs);
			<span class="enscript-keyword">else</span>
				LIST_INSERT_AFTER(lastbp, bp, nb_vnbufs);
			lastbp = bp;
			<span class="enscript-keyword">if</span> (found)
				<span class="enscript-keyword">continue</span>;
			nfs_buf_refget(bp);
			<span class="enscript-keyword">if</span> (nfs_buf_acquire(bp, NBAC_NOWAIT, 0, 0)) {
				<span class="enscript-comment">/* just skip this buffer */</span>
				nfs_buf_refrele(bp);
				<span class="enscript-keyword">continue</span>;
			}
			nfs_buf_refrele(bp);

			<span class="enscript-comment">/* scan the buffer for the cookie */</span>
			ndbhp = (<span class="enscript-type">struct</span> nfs_dir_buf_header*)bp-&gt;nb_data;
			dp = NFS_DIR_BUF_FIRST_DIRENTRY(bp);
			dpptc = NULL;
			<span class="enscript-keyword">for</span> (i=0; (i &lt; ndbhp-&gt;ndbh_count) &amp;&amp; (cookie != dp-&gt;d_seekoff); i++) {
				<span class="enscript-keyword">if</span> (*ptc &amp;&amp; !dpptc &amp;&amp; NFS_DIR_COOKIE_SAME32(cookie, dp-&gt;d_seekoff)) {
					dpptc = dp;
					iptc = i;
				}
				dp = NFS_DIRENTRY_NEXT(dp);
			}
			<span class="enscript-keyword">if</span> ((i == ndbhp-&gt;ndbh_count) &amp;&amp; dpptc) {
				<span class="enscript-comment">/* found only a PTC match */</span>
				dp = dpptc;
				i = iptc;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (i &lt; ndbhp-&gt;ndbh_count) {
				*ptc = 0;
			}
			<span class="enscript-keyword">if</span> (i &lt; (ndbhp-&gt;ndbh_count-1)) {
				<span class="enscript-comment">/* next entry is *in* this buffer: return this block */</span>
				*lbnp = bp-&gt;nb_lblkno;
				found = 1;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (i == (ndbhp-&gt;ndbh_count-1)) {
				<span class="enscript-comment">/* next entry refers to *next* buffer: return next block */</span>
				*lbnp = dp-&gt;d_seekoff;
				found = 1;
			}
			nfs_buf_drop(bp);
		}
		nfs_buf_itercomplete(dnp, &amp;blist, NBI_CLEAN);
	}
	lck_mtx_unlock(nfs_buf_mutex);
	<span class="enscript-keyword">if</span> (found) {
		OSAddAtomic64(1, &amp;nfsstats.direofcache_hits);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* still not found... oh well, just start a new block */</span>
	*lbnp = cookie;
	OSAddAtomic64(1, &amp;nfsstats.direofcache_misses);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * scan a directory buffer for the given name
 * Returns: ESRCH if not found, ENOENT if found invalid, 0 if found
 * Note: should only be called with RDIRPLUS directory buffers
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NDBS_PURGE</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NDBS_UPDATE</span>	2

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_dir_buf_search</span>(
	<span class="enscript-type">struct</span> nfsbuf *bp,
	<span class="enscript-type">struct</span> componentname *cnp,
	fhandle_t *fhp,
	<span class="enscript-type">struct</span> nfs_vattr *nvap,
	uint64_t *xidp,
	time_t *attrstampp,
	daddr64_t *nextlbnp,
	<span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> direntry *dp;
	<span class="enscript-type">struct</span> nfs_dir_buf_header *ndbhp;
	<span class="enscript-type">struct</span> nfs_vattr *nvattrp;
	daddr64_t nextlbn = 0;
	<span class="enscript-type">int</span> i, error = ESRCH, fhlen;

	<span class="enscript-comment">/* scan the buffer for the name */</span>
	ndbhp = (<span class="enscript-type">struct</span> nfs_dir_buf_header*)bp-&gt;nb_data;
	dp = NFS_DIR_BUF_FIRST_DIRENTRY(bp);
	<span class="enscript-keyword">for</span> (i=0; i &lt; ndbhp-&gt;ndbh_count; i++) {
		nextlbn = dp-&gt;d_seekoff;
		<span class="enscript-keyword">if</span> ((cnp-&gt;cn_namelen == dp-&gt;d_namlen) &amp;&amp; !strcmp(cnp-&gt;cn_nameptr, dp-&gt;d_name)) {
			fhlen = dp-&gt;d_name[dp-&gt;d_namlen+1];
			nvattrp = NFS_DIR_BUF_NVATTR(bp, i);
			<span class="enscript-keyword">if</span> ((ndbhp-&gt;ndbh_ncgen != bp-&gt;nb_np-&gt;n_ncgen) || (fhp-&gt;fh_len == 0) ||
			    (nvattrp-&gt;nva_type == VNON) || (nvattrp-&gt;nva_fileid == 0)) {
				<span class="enscript-comment">/* entry is not valid */</span>
				error = ENOENT;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (flags == NDBS_PURGE) {
				dp-&gt;d_fileno = 0;
				bzero(nvattrp, <span class="enscript-keyword">sizeof</span>(*nvattrp));
				error = ENOENT;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (flags == NDBS_UPDATE) {
				<span class="enscript-comment">/* update direntry's attrs if fh matches */</span>
				<span class="enscript-keyword">if</span> ((fhp-&gt;fh_len == fhlen) &amp;&amp; !bcmp(&amp;dp-&gt;d_name[dp-&gt;d_namlen+2], fhp-&gt;fh_data, fhlen)) {
					bcopy(nvap, nvattrp, <span class="enscript-keyword">sizeof</span>(*nvap));
					dp-&gt;d_fileno = nvattrp-&gt;nva_fileid;
					nvattrp-&gt;nva_fileid = *xidp;
					*(time_t*)(&amp;dp-&gt;d_name[dp-&gt;d_namlen+2+fhp-&gt;fh_len]) = *attrstampp;
				}
				error = 0;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/* copy out fh, attrs, attrstamp, and xid */</span>
			fhp-&gt;fh_len = fhlen;
			bcopy(&amp;dp-&gt;d_name[dp-&gt;d_namlen+2], fhp-&gt;fh_data, MAX(fhp-&gt;fh_len, (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(fhp-&gt;fh_data)));
			*attrstampp = *(time_t*)(&amp;dp-&gt;d_name[dp-&gt;d_namlen+2+fhp-&gt;fh_len]);
			bcopy(nvattrp, nvap, <span class="enscript-keyword">sizeof</span>(*nvap));
			*xidp = nvap-&gt;nva_fileid;
			nvap-&gt;nva_fileid = dp-&gt;d_fileno;
			error = 0;
			<span class="enscript-keyword">break</span>;
		}
		dp = NFS_DIRENTRY_NEXT(dp);
	}
	<span class="enscript-keyword">if</span> (nextlbnp)
		*nextlbnp = nextlbn;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Look up a name in a directory's buffers.
 * Note: should only be called with RDIRPLUS directory buffers
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_dir_buf_cache_lookup</span>(nfsnode_t dnp, nfsnode_t *npp, <span class="enscript-type">struct</span> componentname *cnp, vfs_context_t ctx, <span class="enscript-type">int</span> purge)
{
	nfsnode_t newnp;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, i, found = 0, count = 0;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	fhandle_t fh;
	time_t attrstamp = 0;
	thread_t thd = vfs_context_thread(ctx);
	<span class="enscript-type">struct</span> nfsbuf *bp, *lastbp, *foundbp;
	<span class="enscript-type">struct</span> nfsbuflists blist;
	daddr64_t lbn, nextlbn;
	<span class="enscript-type">int</span> dotunder = (cnp-&gt;cn_namelen &gt; 2) &amp;&amp; (cnp-&gt;cn_nameptr[0] == <span class="enscript-string">'.'</span>) &amp;&amp; (cnp-&gt;cn_nameptr[1] == <span class="enscript-string">'_'</span>);

	nmp = NFSTONMP(dnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> (!purge)
		*npp = NULL;

	<span class="enscript-comment">/* first check most recent buffer (and next one too) */</span>
	lbn = dnp-&gt;n_lastdbl;
	<span class="enscript-keyword">for</span> (i=0; i &lt; 2; i++) {
		<span class="enscript-keyword">if</span> ((error = nfs_buf_get(dnp, lbn, NFS_DIRBLKSIZ, thd, NBLK_READ|NBLK_ONLYVALID, &amp;bp)))
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">if</span> (!bp)
			<span class="enscript-keyword">break</span>;
		count++;
		error = nfs_dir_buf_search(bp, cnp, &amp;fh, &amp;nvattr, &amp;xid, &amp;attrstamp, &amp;nextlbn, purge ? NDBS_PURGE : 0);
		nfs_buf_release(bp, 0);
		<span class="enscript-keyword">if</span> (error == ESRCH) {
			error = 0;
		} <span class="enscript-keyword">else</span> {
			found = 1;
			<span class="enscript-keyword">break</span>;
		}
		lbn = nextlbn;
	}

	lck_mtx_lock(nfs_buf_mutex);
	<span class="enscript-keyword">if</span> (found) {
		dnp-&gt;n_lastdbl = lbn;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Scan the list of buffers, keeping them in order.
	 * Note that itercomplete inserts each of the remaining buffers
	 * into the head of list (thus reversing the elements).  So, we
	 * make sure to iterate through all buffers, inserting them after
	 * each other, to keep them in order.
	 * Also note: the LIST_INSERT_AFTER(lastbp) is only safe because
	 * we don't drop nfs_buf_mutex.
	 */</span>
	<span class="enscript-keyword">if</span> (!nfs_buf_iterprepare(dnp, &amp;blist, NBI_CLEAN)) {
		lastbp = foundbp = NULL;
		<span class="enscript-keyword">while</span> ((bp = LIST_FIRST(&amp;blist))) {
			LIST_REMOVE(bp, nb_vnbufs);
			<span class="enscript-keyword">if</span> (!lastbp)
				LIST_INSERT_HEAD(&amp;dnp-&gt;n_cleanblkhd, bp, nb_vnbufs);
			<span class="enscript-keyword">else</span>
				LIST_INSERT_AFTER(lastbp, bp, nb_vnbufs);
			lastbp = bp;
			<span class="enscript-keyword">if</span> (error || found)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (!purge &amp;&amp; dotunder &amp;&amp; (count &gt; 100)) <span class="enscript-comment">/* don't waste too much time looking for ._ files */</span>
				<span class="enscript-keyword">continue</span>;
			nfs_buf_refget(bp);
			lbn = bp-&gt;nb_lblkno;
			<span class="enscript-keyword">if</span> (nfs_buf_acquire(bp, NBAC_NOWAIT, 0, 0)) {
				<span class="enscript-comment">/* just skip this buffer */</span>
				nfs_buf_refrele(bp);
				<span class="enscript-keyword">continue</span>;
			}
			nfs_buf_refrele(bp);
			count++;
			error = nfs_dir_buf_search(bp, cnp, &amp;fh, &amp;nvattr, &amp;xid, &amp;attrstamp, NULL, purge ? NDBS_PURGE : 0);
			<span class="enscript-keyword">if</span> (error == ESRCH) {
				error = 0;
			} <span class="enscript-keyword">else</span> {
				found = 1;
				foundbp = bp;
			}
			nfs_buf_drop(bp);
		}
		<span class="enscript-keyword">if</span> (found) {
			LIST_REMOVE(foundbp, nb_vnbufs);
			LIST_INSERT_HEAD(&amp;dnp-&gt;n_cleanblkhd, foundbp, nb_vnbufs);
			dnp-&gt;n_lastdbl = foundbp-&gt;nb_lblkno;
		}
		nfs_buf_itercomplete(dnp, &amp;blist, NBI_CLEAN);
	}
<span class="enscript-reference">done</span>:
	lck_mtx_unlock(nfs_buf_mutex);

	<span class="enscript-keyword">if</span> (!error &amp;&amp; found &amp;&amp; !purge) {
		error = nfs_nget(NFSTOMP(dnp), dnp, cnp, fh.fh_data, fh.fh_len,
				&amp;nvattr, &amp;xid, dnp-&gt;n_auth, NG_MAKEENTRY, &amp;newnp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		newnp-&gt;n_attrstamp = attrstamp;
		*npp = newnp;
		nfs_node_unlock(newnp);
		<span class="enscript-comment">/* check if the dir buffer's attrs are out of date */</span>
		<span class="enscript-keyword">if</span> (!nfs_getattr(newnp, &amp;nvattr, ctx, NGA_CACHED) &amp;&amp;
		    (newnp-&gt;n_attrstamp != attrstamp)) {
			<span class="enscript-comment">/* they are, so update them */</span>
			error = nfs_buf_get(dnp, lbn, NFS_DIRBLKSIZ, thd, NBLK_READ|NBLK_ONLYVALID, &amp;bp);
			<span class="enscript-keyword">if</span> (!error &amp;&amp; bp) {
				attrstamp = newnp-&gt;n_attrstamp;
				xid = newnp-&gt;n_xid;
				nfs_dir_buf_search(bp, cnp, &amp;fh, &amp;nvattr, &amp;xid, &amp;attrstamp, NULL, NDBS_UPDATE);
				nfs_buf_release(bp, 0);
			}
			error = 0;
		}
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Purge name cache entries for the given node.
 * For RDIRPLUS, also invalidate the entry in the directory's buffers.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_name_cache_purge</span>(nfsnode_t dnp, nfsnode_t np, <span class="enscript-type">struct</span> componentname *cnp, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(dnp);

	cache_purge(NFSTOV(np));
	<span class="enscript-keyword">if</span> (nmp &amp;&amp; (nmp-&gt;nm_vers &gt; NFS_VER2) &amp;&amp; NMFLAG(nmp, RDIRPLUS))
		nfs_dir_buf_cache_lookup(dnp, NULL, cnp, ctx, 1);
}

<span class="enscript-comment">/*
 * NFS V3 readdir (plus) RPC.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_readdir_rpc</span>(nfsnode_t dnp, <span class="enscript-type">struct</span> nfsbuf *bp, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, lockerror, nfsvers, rdirplus, bigcookies;
	<span class="enscript-type">int</span> i, status, attrflag, fhflag, more_entries = 1, eof, bp_dropped = 0;
	uint32_t nmreaddirsize, nmrsize;
	uint32_t namlen, skiplen, fhlen, xlen, attrlen, reclen, space_free, space_needed;
	uint64_t cookie, lastcookie, xid, savedxid, fileno;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep, nmrepsave;
	fhandle_t fh;
	<span class="enscript-type">struct</span> nfs_vattr *nvattrp;
	<span class="enscript-type">struct</span> nfs_dir_buf_header *ndbhp;
	<span class="enscript-type">struct</span> direntry *dp;
	<span class="enscript-type">char</span> *padstart, padlen;
	<span class="enscript-type">struct</span> timeval now;

	nmp = NFSTONMP(dnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	nmreaddirsize = nmp-&gt;nm_readdirsize;
	nmrsize = nmp-&gt;nm_rsize;
	bigcookies = nmp-&gt;nm_state &amp; NFSSTA_BIGCOOKIES;
<span class="enscript-reference">noplus</span>:
	rdirplus = ((nfsvers &gt; NFS_VER2) &amp;&amp; NMFLAG(nmp, RDIRPLUS)) ? 1 : 0;

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
		<span class="enscript-keyword">return</span> (lockerror);

	<span class="enscript-comment">/* determine cookie to use, and move dp to the right offset */</span>
	ndbhp = (<span class="enscript-type">struct</span> nfs_dir_buf_header*)bp-&gt;nb_data;
	dp = NFS_DIR_BUF_FIRST_DIRENTRY(bp);
	<span class="enscript-keyword">if</span> (ndbhp-&gt;ndbh_count) {
		<span class="enscript-keyword">for</span> (i=0; i &lt; ndbhp-&gt;ndbh_count-1; i++)
			dp = NFS_DIRENTRY_NEXT(dp);
		cookie = dp-&gt;d_seekoff;
		dp = NFS_DIRENTRY_NEXT(dp);
	} <span class="enscript-keyword">else</span> {
		cookie = bp-&gt;nb_lblkno;
		<span class="enscript-comment">/* increment with every buffer read */</span>
		OSAddAtomic64(1, &amp;nfsstats.readdir_bios);
	}
	lastcookie = cookie;

	<span class="enscript-comment">/*
	 * Loop around doing readdir(plus) RPCs of size nm_readdirsize until
	 * the buffer is full (or we hit EOF).  Then put the remainder of the
	 * results in the next buffer(s).
	 */</span>
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);
	<span class="enscript-keyword">while</span> (nfs_dir_buf_freespace(bp, rdirplus) &amp;&amp; !(ndbhp-&gt;ndbh_flags &amp; NDB_FULL)) {
		nfsm_chain_build_alloc_init(error, &amp;nmreq,
			NFSX_FH(nfsvers) + NFSX_READDIR(nfsvers) + NFSX_UNSIGNED);
		nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, dnp-&gt;n_fhp, dnp-&gt;n_fhsize);
		<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
			<span class="enscript-comment">/* opaque values don't need swapping, but as long */</span>
			<span class="enscript-comment">/* as we are consistent about it, it should be ok */</span>
			nfsm_chain_add_64(error, &amp;nmreq, cookie);
			nfsm_chain_add_64(error, &amp;nmreq, dnp-&gt;n_cookieverf);
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, &amp;nmreq, cookie);
		}
		nfsm_chain_add_32(error, &amp;nmreq, nmreaddirsize);
		<span class="enscript-keyword">if</span> (rdirplus)
			nfsm_chain_add_32(error, &amp;nmreq, nmrsize);
		nfsm_chain_build_done(error, &amp;nmreq);
		nfs_node_unlock(dnp);
		lockerror = ENOENT;
		nfsmout_if(error);

		error = nfs_request(dnp, NULL, &amp;nmreq,
				rdirplus ? NFSPROC_READDIRPLUS : NFSPROC_READDIR,
				ctx, NULL, &amp;nmrep, &amp;xid, &amp;status);

		<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
			error = lockerror;

		savedxid = xid;
		<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
			nfsm_chain_postop_attr_update(error, &amp;nmrep, dnp, &amp;xid);
		<span class="enscript-keyword">if</span> (!error)
			error = status;
		<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
			nfsm_chain_get_64(error, &amp;nmrep, dnp-&gt;n_cookieverf);
		nfsm_chain_get_32(error, &amp;nmrep, more_entries);

		<span class="enscript-keyword">if</span> (!lockerror) {
			nfs_node_unlock(dnp);
			lockerror = ENOENT;
		}
		<span class="enscript-keyword">if</span> (error == NFSERR_NOTSUPP) {
			<span class="enscript-comment">/* oops... it doesn't look like readdirplus is supported */</span>
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			NFS_BITMAP_CLR(nmp-&gt;nm_flags, NFS_MFLAG_RDIRPLUS);
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">noplus</span>;
		}
		nfsmout_if(error);

		<span class="enscript-keyword">if</span> (rdirplus)
			microuptime(&amp;now);

		<span class="enscript-comment">/* loop through the entries packing them into the buffer */</span>
		<span class="enscript-keyword">while</span> (more_entries) {
			<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
				nfsm_chain_get_64(error, &amp;nmrep, fileno);
			<span class="enscript-keyword">else</span>
				nfsm_chain_get_32(error, &amp;nmrep, fileno);
			nfsm_chain_get_32(error, &amp;nmrep, namlen);
			nfsmout_if(error);
			<span class="enscript-comment">/* just truncate names that don't fit in direntry.d_name */</span>
			<span class="enscript-keyword">if</span> (namlen &lt;= 0) {
				error = EBADRPC;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}
			<span class="enscript-keyword">if</span> (namlen &gt; (<span class="enscript-keyword">sizeof</span>(dp-&gt;d_name)-1)) {
				skiplen = namlen - <span class="enscript-keyword">sizeof</span>(dp-&gt;d_name) + 1;
				namlen = <span class="enscript-keyword">sizeof</span>(dp-&gt;d_name) - 1;
			} <span class="enscript-keyword">else</span> {
				skiplen = 0;
			}
			<span class="enscript-comment">/* guess that fh size will be same as parent */</span>
			fhlen = rdirplus ? (1 + dnp-&gt;n_fhsize) : 0;
			xlen = rdirplus ? (fhlen + <span class="enscript-keyword">sizeof</span>(time_t)) : 0;
			attrlen = rdirplus ? <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_vattr) : 0;
			reclen = NFS_DIRENTRY_LEN(namlen + xlen);
			space_needed = reclen + attrlen;
			space_free = nfs_dir_buf_freespace(bp, rdirplus);
			<span class="enscript-keyword">if</span> (space_needed &gt; space_free) {
				<span class="enscript-comment">/*
				 * We still have entries to pack, but we've
				 * run out of room in the current buffer.
				 * So we need to move to the next buffer.
				 * The block# for the next buffer is the
				 * last cookie in the current buffer.
				 */</span>
<span class="enscript-reference">nextbuffer</span>:
				ndbhp-&gt;ndbh_flags |= NDB_FULL;
				nfs_buf_release(bp, 0);
				bp_dropped = 1;
				bp = NULL;
				error = nfs_buf_get(dnp, lastcookie, NFS_DIRBLKSIZ, vfs_context_thread(ctx), NBLK_READ, &amp;bp);
				nfsmout_if(error);
				<span class="enscript-comment">/* initialize buffer */</span>
				ndbhp = (<span class="enscript-type">struct</span> nfs_dir_buf_header*)bp-&gt;nb_data;
				ndbhp-&gt;ndbh_flags = 0;
				ndbhp-&gt;ndbh_count = 0;
				ndbhp-&gt;ndbh_entry_end = <span class="enscript-keyword">sizeof</span>(*ndbhp);
				ndbhp-&gt;ndbh_ncgen = dnp-&gt;n_ncgen;
				space_free = nfs_dir_buf_freespace(bp, rdirplus);
				dp = NFS_DIR_BUF_FIRST_DIRENTRY(bp);
				<span class="enscript-comment">/* increment with every buffer read */</span>
				OSAddAtomic64(1, &amp;nfsstats.readdir_bios);
			}
			nmrepsave = nmrep;
			dp-&gt;d_fileno = fileno;
			dp-&gt;d_namlen = namlen;
			dp-&gt;d_reclen = reclen;
			dp-&gt;d_type = DT_UNKNOWN;
			nfsm_chain_get_opaque(error, &amp;nmrep, namlen, dp-&gt;d_name);
			nfsmout_if(error);
			dp-&gt;d_name[namlen] = <span class="enscript-string">'\0'</span>;
			<span class="enscript-keyword">if</span> (skiplen)
				nfsm_chain_adv(error, &amp;nmrep,
					nfsm_rndup(namlen + skiplen) - nfsm_rndup(namlen));
			<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
				nfsm_chain_get_64(error, &amp;nmrep, cookie);
			<span class="enscript-keyword">else</span>
				nfsm_chain_get_32(error, &amp;nmrep, cookie);
			nfsmout_if(error);
			dp-&gt;d_seekoff = cookie;
			<span class="enscript-keyword">if</span> (!bigcookies &amp;&amp; (cookie &gt;&gt; 32) &amp;&amp; (nmp == NFSTONMP(dnp))) {
				<span class="enscript-comment">/* we've got a big cookie, make sure flag is set */</span>
				lck_mtx_lock(&amp;nmp-&gt;nm_lock);
				nmp-&gt;nm_state |= NFSSTA_BIGCOOKIES;
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
				bigcookies = 1;
			}
			<span class="enscript-keyword">if</span> (rdirplus) {
				nvattrp = NFS_DIR_BUF_NVATTR(bp, ndbhp-&gt;ndbh_count);
				<span class="enscript-comment">/* check for attributes */</span>
				nfsm_chain_get_32(error, &amp;nmrep, attrflag);
				nfsmout_if(error);
				<span class="enscript-keyword">if</span> (attrflag) {
					<span class="enscript-comment">/* grab attributes */</span>
					error = nfs_parsefattr(&amp;nmrep, NFS_VER3, nvattrp);
					nfsmout_if(error);
					dp-&gt;d_type = IFTODT(VTTOIF(nvattrp-&gt;nva_type));
					<span class="enscript-comment">/* fileid is already in d_fileno, so stash xid in attrs */</span>
					nvattrp-&gt;nva_fileid = savedxid;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* mark the attributes invalid */</span>
					bzero(nvattrp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_vattr));
				}
				<span class="enscript-comment">/* check for file handle */</span>
				nfsm_chain_get_32(error, &amp;nmrep, fhflag);
				nfsmout_if(error);
				<span class="enscript-keyword">if</span> (fhflag) {
					nfsm_chain_get_fh(error, &amp;nmrep, NFS_VER3, &amp;fh);
					nfsmout_if(error);
					fhlen = fh.fh_len + 1;
					xlen = fhlen + <span class="enscript-keyword">sizeof</span>(time_t);
					reclen = NFS_DIRENTRY_LEN(namlen + xlen);
					space_needed = reclen + attrlen;
					<span class="enscript-keyword">if</span> (space_needed &gt; space_free) {
						<span class="enscript-comment">/* didn't actually have the room... move on to next buffer */</span>
						nmrep = nmrepsave;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">nextbuffer</span>;
					}
					<span class="enscript-comment">/* pack the file handle into the record */</span>
					dp-&gt;d_name[dp-&gt;d_namlen+1] = fh.fh_len;
					bcopy(fh.fh_data, &amp;dp-&gt;d_name[dp-&gt;d_namlen+2], fh.fh_len);
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* mark the file handle invalid */</span>
					fh.fh_len = 0;
					fhlen = fh.fh_len + 1;
					xlen = fhlen + <span class="enscript-keyword">sizeof</span>(time_t);
					reclen = NFS_DIRENTRY_LEN(namlen + xlen);
					bzero(&amp;dp-&gt;d_name[dp-&gt;d_namlen+1], fhlen);
				}
				*(time_t*)(&amp;dp-&gt;d_name[dp-&gt;d_namlen+1+fhlen]) = now.tv_sec;
				dp-&gt;d_reclen = reclen;
			}
			padstart = dp-&gt;d_name + dp-&gt;d_namlen + 1 + xlen;
			ndbhp-&gt;ndbh_count++;
			lastcookie = cookie;
			<span class="enscript-comment">/* advance to next direntry in buffer */</span>
			dp = NFS_DIRENTRY_NEXT(dp);
			ndbhp-&gt;ndbh_entry_end = (<span class="enscript-type">char</span>*)dp - bp-&gt;nb_data;
			<span class="enscript-comment">/* zero out the pad bytes */</span>
			padlen = (<span class="enscript-type">char</span>*)dp - padstart;
			<span class="enscript-keyword">if</span> (padlen &gt; 0)
				bzero(padstart, padlen);
			<span class="enscript-comment">/* check for more entries */</span>
			nfsm_chain_get_32(error, &amp;nmrep, more_entries);
			nfsmout_if(error);
		}
		<span class="enscript-comment">/* Finally, get the eof boolean */</span>
		nfsm_chain_get_32(error, &amp;nmrep, eof);
		nfsmout_if(error);
		<span class="enscript-keyword">if</span> (eof) {
			ndbhp-&gt;ndbh_flags |= (NDB_FULL|NDB_EOF);
			nfs_node_lock_force(dnp);
			dnp-&gt;n_eofcookie = lastcookie;
			nfs_node_unlock(dnp);
		} <span class="enscript-keyword">else</span> {
			more_entries = 1;
		}
		<span class="enscript-keyword">if</span> (bp_dropped) {
			nfs_buf_release(bp, 0);
			bp = NULL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
			error = lockerror;
		nfsmout_if(error);
		nfsm_chain_cleanup(&amp;nmrep);
		nfsm_chain_null(&amp;nmreq);
	}
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (bp_dropped &amp;&amp; bp)
		nfs_buf_release(bp, 0);
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(dnp);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (bp_dropped ? NFSERR_DIRBUFDROPPED : error);
}

<span class="enscript-comment">/*
 * Silly rename. To make the NFS filesystem that is stateless look a little
 * more like the &quot;ufs&quot; a remove of an active vnode is translated to a rename
 * to a funny looking filename that is removed by nfs_vnop_inactive on the
 * nfsnode. There is the potential for another process on a different client
 * to create the same funny name between when the lookitup() fails and the
 * rename() completes, but...
 */</span>

<span class="enscript-comment">/* format of &quot;random&quot; silly names - includes a number and pid */</span>
<span class="enscript-comment">/* (note: shouldn't exceed size of nfs_sillyrename.nsr_name) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_SILLYNAME_FORMAT</span> <span class="enscript-string">&quot;.nfs.%08x.%04x&quot;</span>
<span class="enscript-comment">/* starting from zero isn't silly enough */</span>
<span class="enscript-type">static</span> uint32_t nfs_sillyrename_number = 0x20051025;

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_sillyrename</span>(
	nfsnode_t dnp,
	nfsnode_t np,
	<span class="enscript-type">struct</span> componentname *cnp,
	vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfs_sillyrename *nsp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">short</span> pid;
	kauth_cred_t cred;
	uint32_t num;
	<span class="enscript-type">struct</span> nfsmount *nmp;

	nmp = NFSTONMP(dnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	nfs_name_cache_purge(dnp, np, cnp, ctx);

	MALLOC_ZONE(nsp, <span class="enscript-type">struct</span> nfs_sillyrename *,
			<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nfs_sillyrename), M_NFSREQ, M_WAITOK);
	<span class="enscript-keyword">if</span> (!nsp)
		<span class="enscript-keyword">return</span> (ENOMEM);
	cred = vfs_context_ucred(ctx);
	kauth_cred_ref(cred);
	nsp-&gt;nsr_cred = cred;
	nsp-&gt;nsr_dnp = dnp;
	error = vnode_ref(NFSTOV(dnp));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_norele</span>;

	<span class="enscript-comment">/* Fudge together a funny name */</span>
	pid = vfs_context_pid(ctx);
	num = OSAddAtomic(1, &amp;nfs_sillyrename_number);
	nsp-&gt;nsr_namlen = snprintf(nsp-&gt;nsr_name, <span class="enscript-keyword">sizeof</span>(nsp-&gt;nsr_name),
				NFS_SILLYNAME_FORMAT, num, (pid &amp; 0xffff));
	<span class="enscript-keyword">if</span> (nsp-&gt;nsr_namlen &gt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(nsp-&gt;nsr_name))
		nsp-&gt;nsr_namlen = <span class="enscript-keyword">sizeof</span>(nsp-&gt;nsr_name) - 1;

	<span class="enscript-comment">/* Try lookitups until we get one that isn't there */</span>
	<span class="enscript-keyword">while</span> (nfs_lookitup(dnp, nsp-&gt;nsr_name, nsp-&gt;nsr_namlen, ctx, NULL) == 0) {
		num = OSAddAtomic(1, &amp;nfs_sillyrename_number);
		nsp-&gt;nsr_namlen = snprintf(nsp-&gt;nsr_name, <span class="enscript-keyword">sizeof</span>(nsp-&gt;nsr_name),
					NFS_SILLYNAME_FORMAT, num, (pid &amp; 0xffff));
		<span class="enscript-keyword">if</span> (nsp-&gt;nsr_namlen &gt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(nsp-&gt;nsr_name))
			nsp-&gt;nsr_namlen = <span class="enscript-keyword">sizeof</span>(nsp-&gt;nsr_name) - 1;
	}

	<span class="enscript-comment">/* now, do the rename */</span>
	error = nmp-&gt;nm_funcs-&gt;nf_rename_rpc(dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen,
					dnp, nsp-&gt;nsr_name, nsp-&gt;nsr_namlen, ctx);

	<span class="enscript-comment">/* Kludge: Map ENOENT =&gt; 0 assuming that it is a reply to a retry. */</span>
	<span class="enscript-keyword">if</span> (error == ENOENT)
		error = 0;
	<span class="enscript-keyword">if</span> (!error) {
		nfs_node_lock_force(dnp);
		<span class="enscript-keyword">if</span> (dnp-&gt;n_flag &amp; NNEGNCENTRIES) {
			dnp-&gt;n_flag &amp;= ~NNEGNCENTRIES;
			cache_purge_negatives(NFSTOV(dnp));
		}
		nfs_node_unlock(dnp);
	}
	FSDBG(267, dnp, np, num, error);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	error = nfs_lookitup(dnp, nsp-&gt;nsr_name, nsp-&gt;nsr_namlen, ctx, &amp;np);
	nfs_node_lock_force(np);
	np-&gt;n_sillyrename = nsp;
	nfs_node_unlock(np);
	<span class="enscript-keyword">return</span> (0);
<span class="enscript-reference">bad</span>:
	vnode_rele(NFSTOV(dnp));
<span class="enscript-reference">bad_norele</span>:
	nsp-&gt;nsr_cred = NOCRED;
	kauth_cred_unref(&amp;cred);
	FREE_ZONE(nsp, <span class="enscript-keyword">sizeof</span>(*nsp), M_NFSREQ);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_lookup_rpc_async</span>(
	nfsnode_t dnp,
	<span class="enscript-type">char</span> *name,
	<span class="enscript-type">int</span> namelen,
	vfs_context_t ctx,
	<span class="enscript-type">struct</span> nfsreq **reqp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfsm_chain nmreq;
	<span class="enscript-type">int</span> error = 0, nfsvers;

	nmp = NFSTONMP(dnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	nfsm_chain_null(&amp;nmreq);

	nfsm_chain_build_alloc_init(error, &amp;nmreq,
		NFSX_FH(nfsvers) + NFSX_UNSIGNED + nfsm_rndup(namelen));
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, dnp-&gt;n_fhp, dnp-&gt;n_fhsize);
	nfsm_chain_add_name(error, &amp;nmreq, name, namelen, nmp);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfs_request_async(dnp, NULL, &amp;nmreq, NFSPROC_LOOKUP,
			vfs_context_thread(ctx), vfs_context_ucred(ctx), NULL, 0, NULL, reqp);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_lookup_rpc_async_finish</span>(
	nfsnode_t dnp,
	__unused <span class="enscript-type">char</span> *name,
	__unused <span class="enscript-type">int</span> namelen,
	vfs_context_t ctx,
	<span class="enscript-type">struct</span> nfsreq *req,
	u_int64_t *xidp,
	fhandle_t *fhp,
	<span class="enscript-type">struct</span> nfs_vattr *nvap)
{
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, status, nfsvers, attrflag;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfsm_chain nmrep;

	nmp = NFSTONMP(dnp);
	<span class="enscript-keyword">if</span> (nmp == NULL)
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	nfsm_chain_null(&amp;nmrep);

	error = nfs_request_async_finish(req, &amp;nmrep, xidp, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
		error = lockerror;
	xid = *xidp;
	<span class="enscript-keyword">if</span> (error || status) {
		<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
			nfsm_chain_postop_attr_update(error, &amp;nmrep, dnp, &amp;xid);
		<span class="enscript-keyword">if</span> (!error)
			error = status;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}

	nfsmout_if(error || !fhp || !nvap);

	<span class="enscript-comment">/* get the file handle */</span>
	nfsm_chain_get_fh(error, &amp;nmrep, nfsvers, fhp);

	<span class="enscript-comment">/* get the attributes */</span>
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
		nfsm_chain_postop_attr_get(error, &amp;nmrep, attrflag, nvap);
		nfsm_chain_postop_attr_update(error, &amp;nmrep, dnp, &amp;xid);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; !attrflag)
			error = nfs3_getattr_rpc(NULL, NFSTOMP(dnp), fhp-&gt;fh_data, fhp-&gt;fh_len, 0, ctx, nvap, xidp);
	} <span class="enscript-keyword">else</span> {
		error = nfs_parsefattr(&amp;nmrep, nfsvers, nvap);
	}
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(dnp);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Look up a file name and optionally either update the file handle or
 * allocate an nfsnode, depending on the value of npp.
 * npp == NULL	--&gt; just do the lookup
 * *npp == NULL --&gt; allocate a new nfsnode and make sure attributes are
 *			handled too
 * *npp != NULL --&gt; update the file handle in the vnode
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_lookitup</span>(
	nfsnode_t dnp,
	<span class="enscript-type">char</span> *name,
	<span class="enscript-type">int</span> namelen,
	vfs_context_t ctx,
	nfsnode_t *npp)
{
	<span class="enscript-type">int</span> error = 0;
	nfsnode_t np, newnp = NULL;
	u_int64_t xid;
	fhandle_t fh;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;

	nmp = NFSTONMP(dnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_MAXNAME) &amp;&amp;
	    (namelen &gt; (<span class="enscript-type">int</span>)nmp-&gt;nm_fsattr.nfsa_maxname))
		<span class="enscript-keyword">return</span> (ENAMETOOLONG);

	NVATTR_INIT(&amp;nvattr);

	<span class="enscript-comment">/* check for lookup of &quot;.&quot; */</span>
	<span class="enscript-keyword">if</span> ((name[0] == <span class="enscript-string">'.'</span>) &amp;&amp; (namelen == 1)) {
		<span class="enscript-comment">/* skip lookup, we know who we are */</span>
		fh.fh_len = 0;
		newnp = dnp;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}

	error = nmp-&gt;nm_funcs-&gt;nf_lookup_rpc_async(dnp, name, namelen, ctx, &amp;req);
	nfsmout_if(error);
	error = nmp-&gt;nm_funcs-&gt;nf_lookup_rpc_async_finish(dnp, name, namelen, ctx, req, &amp;xid, &amp;fh, &amp;nvattr);
	nfsmout_if(!npp || error);

	<span class="enscript-keyword">if</span> (*npp) {
		np = *npp;
		<span class="enscript-keyword">if</span> (fh.fh_len != np-&gt;n_fhsize) {
			u_char *oldbuf = (np-&gt;n_fhsize &gt; NFS_SMALLFH) ? np-&gt;n_fhp : NULL;
			<span class="enscript-keyword">if</span> (fh.fh_len &gt; NFS_SMALLFH) {
				MALLOC_ZONE(np-&gt;n_fhp, u_char *, fh.fh_len, M_NFSBIGFH, M_WAITOK);
				<span class="enscript-keyword">if</span> (!np-&gt;n_fhp) {
				    np-&gt;n_fhp = oldbuf;
				    error = ENOMEM;
				    <span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
				}
			} <span class="enscript-keyword">else</span> {
				np-&gt;n_fhp = &amp;np-&gt;n_fh[0];
			}
			<span class="enscript-keyword">if</span> (oldbuf)
				FREE_ZONE(oldbuf, np-&gt;n_fhsize, M_NFSBIGFH);
		}
		bcopy(fh.fh_data, np-&gt;n_fhp, fh.fh_len);
		np-&gt;n_fhsize = fh.fh_len;
		nfs_node_lock_force(np);
		error = nfs_loadattrcache(np, &amp;nvattr, &amp;xid, 0);
		nfs_node_unlock(np);
		nfsmout_if(error);
		newnp = np;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (NFS_CMPFH(dnp, fh.fh_data, fh.fh_len)) {
		nfs_node_lock_force(dnp);
		<span class="enscript-keyword">if</span> (dnp-&gt;n_xid &lt;= xid)
			error = nfs_loadattrcache(dnp, &amp;nvattr, &amp;xid, 0);
		nfs_node_unlock(dnp);
		nfsmout_if(error);
		newnp = dnp;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> componentname cn, *cnp = &amp;cn;
		bzero(cnp, <span class="enscript-keyword">sizeof</span>(*cnp));
		cnp-&gt;cn_nameptr = name;
		cnp-&gt;cn_namelen = namelen;
		error = nfs_nget(NFSTOMP(dnp), dnp, cnp, fh.fh_data, fh.fh_len,
			    &amp;nvattr, &amp;xid, rq.r_auth, NG_MAKEENTRY, &amp;np);
		nfsmout_if(error);
		newnp = np;
	}

<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (npp &amp;&amp; !*npp &amp;&amp; !error)
		*npp = newnp;
	NVATTR_CLEANUP(&amp;nvattr);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * set up and initialize a &quot;._&quot; file lookup structure used for
 * performing async lookups.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_dulookup_init</span>(<span class="enscript-type">struct</span> nfs_dulookup *dulp, nfsnode_t dnp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> namelen, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error, du_namelen;
	vnode_t du_vp;
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(dnp);

	<span class="enscript-comment">/* check for ._ file in name cache */</span>
	dulp-&gt;du_flags = 0;
	bzero(&amp;dulp-&gt;du_cn, <span class="enscript-keyword">sizeof</span>(dulp-&gt;du_cn));
	du_namelen = namelen + 2;
	<span class="enscript-keyword">if</span> (!nmp || NMFLAG(nmp, NONEGNAMECACHE))
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> ((namelen &gt;= 2) &amp;&amp; (name[0] == <span class="enscript-string">'.'</span>) &amp;&amp; (name[1] == <span class="enscript-string">'_'</span>))
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> (du_namelen &gt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(dulp-&gt;du_smallname))
		MALLOC(dulp-&gt;du_cn.cn_nameptr, <span class="enscript-type">char</span> *, du_namelen + 1, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">else</span>
		dulp-&gt;du_cn.cn_nameptr = dulp-&gt;du_smallname;
	<span class="enscript-keyword">if</span> (!dulp-&gt;du_cn.cn_nameptr)
		<span class="enscript-keyword">return</span>;
	dulp-&gt;du_cn.cn_namelen = du_namelen;
	snprintf(dulp-&gt;du_cn.cn_nameptr, du_namelen + 1, <span class="enscript-string">&quot;._%s&quot;</span>, name);
	dulp-&gt;du_cn.cn_nameptr[du_namelen] = <span class="enscript-string">'\0'</span>;
	dulp-&gt;du_cn.cn_nameiop = LOOKUP;
	dulp-&gt;du_cn.cn_flags = MAKEENTRY;

	error = cache_lookup(NFSTOV(dnp), &amp;du_vp, &amp;dulp-&gt;du_cn);
	<span class="enscript-keyword">if</span> (error == -1) {
		vnode_put(du_vp);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!error) {
		nmp = NFSTONMP(dnp);
		<span class="enscript-keyword">if</span> (nmp &amp;&amp; (nmp-&gt;nm_vers &gt; NFS_VER2) &amp;&amp; NMFLAG(nmp, RDIRPLUS)) {
			<span class="enscript-comment">/* if rdirplus, try dir buf cache lookup */</span>
			nfsnode_t du_np = NULL;
			<span class="enscript-keyword">if</span> (!nfs_dir_buf_cache_lookup(dnp, &amp;du_np, &amp;dulp-&gt;du_cn, ctx, 0) &amp;&amp; du_np) {
				<span class="enscript-comment">/* dir buf cache hit */</span>
				du_vp = NFSTOV(du_np);
				vnode_put(du_vp);
				error = -1;
			}
		}
		<span class="enscript-keyword">if</span> (!error)
			dulp-&gt;du_flags |= NFS_DULOOKUP_DOIT;
	}
}

<span class="enscript-comment">/*
 * start an async &quot;._&quot; file lookup request
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_dulookup_start</span>(<span class="enscript-type">struct</span> nfs_dulookup *dulp, nfsnode_t dnp, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(dnp);
	<span class="enscript-type">struct</span> nfsreq *req = &amp;dulp-&gt;du_req;

	<span class="enscript-keyword">if</span> (!nmp || !(dulp-&gt;du_flags &amp; NFS_DULOOKUP_DOIT) || (dulp-&gt;du_flags &amp; NFS_DULOOKUP_INPROG))
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> (!nmp-&gt;nm_funcs-&gt;nf_lookup_rpc_async(dnp, dulp-&gt;du_cn.cn_nameptr,
			dulp-&gt;du_cn.cn_namelen, ctx, &amp;req))
		dulp-&gt;du_flags |= NFS_DULOOKUP_INPROG;
}

<span class="enscript-comment">/*
 * finish an async &quot;._&quot; file lookup request and clean up the structure
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_dulookup_finish</span>(<span class="enscript-type">struct</span> nfs_dulookup *dulp, nfsnode_t dnp, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(dnp);
	<span class="enscript-type">int</span> error;
	nfsnode_t du_np;
	u_int64_t xid;
	fhandle_t fh;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;

	<span class="enscript-keyword">if</span> (!nmp || !(dulp-&gt;du_flags &amp; NFS_DULOOKUP_INPROG))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	NVATTR_INIT(&amp;nvattr);
	error = nmp-&gt;nm_funcs-&gt;nf_lookup_rpc_async_finish(dnp, dulp-&gt;du_cn.cn_nameptr,
			dulp-&gt;du_cn.cn_namelen, ctx, &amp;dulp-&gt;du_req, &amp;xid, &amp;fh, &amp;nvattr);
	dulp-&gt;du_flags &amp;= ~NFS_DULOOKUP_INPROG;
	<span class="enscript-keyword">if</span> (error == ENOENT) {
		<span class="enscript-comment">/* add a negative entry in the name cache */</span>
		nfs_node_lock_force(dnp);
		cache_enter(NFSTOV(dnp), NULL, &amp;dulp-&gt;du_cn);
		dnp-&gt;n_flag |= NNEGNCENTRIES;
		nfs_node_unlock(dnp);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!error) {
		error = nfs_nget(NFSTOMP(dnp), dnp, &amp;dulp-&gt;du_cn, fh.fh_data, fh.fh_len,
			    &amp;nvattr, &amp;xid, dulp-&gt;du_req.r_auth, NG_MAKEENTRY, &amp;du_np);
		<span class="enscript-keyword">if</span> (!error) {
			nfs_node_unlock(du_np);
			vnode_put(NFSTOV(du_np));
		}
	}
	NVATTR_CLEANUP(&amp;nvattr);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (dulp-&gt;du_flags &amp; NFS_DULOOKUP_INPROG)
		nfs_request_async_cancel(&amp;dulp-&gt;du_req);
	<span class="enscript-keyword">if</span> (dulp-&gt;du_cn.cn_nameptr &amp;&amp; (dulp-&gt;du_cn.cn_nameptr != dulp-&gt;du_smallname))
		FREE(dulp-&gt;du_cn.cn_nameptr, M_TEMP);
}


<span class="enscript-comment">/*
 * NFS Version 3 commit RPC
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_commit_rpc</span>(
	nfsnode_t np,
	uint64_t offset,
	uint64_t count,
	kauth_cred_t cred,
	uint64_t wverf)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, lockerror, status, wccpostattr = 0, nfsvers;
	<span class="enscript-type">struct</span> timespec premtime = { 0, 0 };
	u_int64_t xid, newwverf;
	uint32_t count32;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;

	nmp = NFSTONMP(np);
	FSDBG(521, np, offset, count, nmp ? nmp-&gt;nm_state : 0);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_state &amp; NFSSTA_HASWRITEVERF))
		<span class="enscript-keyword">return</span> (0);
	nfsvers = nmp-&gt;nm_vers;

	<span class="enscript-keyword">if</span> (count &gt; UINT32_MAX)
		count32 = 0;
	<span class="enscript-keyword">else</span>
		count32 = count;

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_build_alloc_init(error, &amp;nmreq, NFSX_FH(NFS_VER3));
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	nfsm_chain_add_64(error, &amp;nmreq, offset);
	nfsm_chain_add_32(error, &amp;nmreq, count32);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfs_request2(np, NULL, &amp;nmreq, NFSPROC_COMMIT,
			current_thread(), cred, NULL, 0, &amp;nmrep, &amp;xid, &amp;status);
	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	<span class="enscript-comment">/* can we do anything useful with the wcc info? */</span>
	nfsm_chain_get_wcc_data(error, &amp;nmrep, np, &amp;premtime, &amp;wccpostattr, &amp;xid);
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	<span class="enscript-keyword">if</span> (!error)
		error = status;
	nfsm_chain_get_64(error, &amp;nmrep, newwverf);
	nfsmout_if(error);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_verf != newwverf)
		nmp-&gt;nm_verf = newwverf;
	<span class="enscript-keyword">if</span> (wverf != newwverf)
		error = NFSERR_STALEWRITEVERF;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_blockmap</span>(
	__unused <span class="enscript-type">struct</span> vnop_blockmap_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		off_t a_foffset;
		size_t a_size;
		daddr64_t *a_bpn;
		size_t *a_run;
		void *a_poff;
		int a_flags;
	} */</span> *ap)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);
}


<span class="enscript-comment">/*
 * fsync vnode op. Just call nfs_flush().
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_fsync</span>(
	<span class="enscript-type">struct</span> vnop_fsync_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		int a_waitfor;
		vfs_context_t a_context;
	} */</span> *ap)
{
	<span class="enscript-keyword">return</span> (nfs_flush(VTONFS(ap-&gt;a_vp), ap-&gt;a_waitfor, vfs_context_thread(ap-&gt;a_context), 0));
}


<span class="enscript-comment">/*
 * Do an NFS pathconf RPC.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_pathconf_rpc</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_fsattr *nfsap,
	vfs_context_t ctx)
{
	u_int64_t xid;
	<span class="enscript-type">int</span> error = 0, lockerror, status, nfsvers;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(np);
	uint32_t val = 0;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">/* fetch pathconf info from server */</span>
	nfsm_chain_build_alloc_init(error, &amp;nmreq, NFSX_FH(NFS_VER3));
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfs_request(np, NULL, &amp;nmreq, NFSPROC_PATHCONF, ctx, NULL, &amp;nmrep, &amp;xid, &amp;status);
	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_postop_attr_update(error, &amp;nmrep, np, &amp;xid);
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	<span class="enscript-keyword">if</span> (!error)
		error = status;
	nfsm_chain_get_32(error, &amp;nmrep, nfsap-&gt;nfsa_maxlink);
	nfsm_chain_get_32(error, &amp;nmrep, nfsap-&gt;nfsa_maxname);
	nfsap-&gt;nfsa_flags &amp;= ~(NFS_FSFLAG_NO_TRUNC|NFS_FSFLAG_CHOWN_RESTRICTED|NFS_FSFLAG_CASE_INSENSITIVE|NFS_FSFLAG_CASE_PRESERVING);
	nfsm_chain_get_32(error, &amp;nmrep, val);
	<span class="enscript-keyword">if</span> (val)
		nfsap-&gt;nfsa_flags |= NFS_FSFLAG_NO_TRUNC;
	nfsm_chain_get_32(error, &amp;nmrep, val);
	<span class="enscript-keyword">if</span> (val)
		nfsap-&gt;nfsa_flags |= NFS_FSFLAG_CHOWN_RESTRICTED;
	nfsm_chain_get_32(error, &amp;nmrep, val);
	<span class="enscript-keyword">if</span> (val)
		nfsap-&gt;nfsa_flags |= NFS_FSFLAG_CASE_INSENSITIVE;
	nfsm_chain_get_32(error, &amp;nmrep, val);
	<span class="enscript-keyword">if</span> (val)
		nfsap-&gt;nfsa_flags |= NFS_FSFLAG_CASE_PRESERVING;
	NFS_BITMAP_SET(nfsap-&gt;nfsa_bitmap, NFS_FATTR_MAXLINK);
	NFS_BITMAP_SET(nfsap-&gt;nfsa_bitmap, NFS_FATTR_MAXNAME);
	NFS_BITMAP_SET(nfsap-&gt;nfsa_bitmap, NFS_FATTR_NO_TRUNC);
	NFS_BITMAP_SET(nfsap-&gt;nfsa_bitmap, NFS_FATTR_CHOWN_RESTRICTED);
	NFS_BITMAP_SET(nfsap-&gt;nfsa_bitmap, NFS_FATTR_CASE_INSENSITIVE);
	NFS_BITMAP_SET(nfsap-&gt;nfsa_bitmap, NFS_FATTR_CASE_PRESERVING);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* save pathconf info for NFSv3 mount */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs3_pathconf_cache</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">struct</span> nfs_fsattr *nfsap)
{
	nmp-&gt;nm_fsattr.nfsa_maxlink = nfsap-&gt;nfsa_maxlink;
	nmp-&gt;nm_fsattr.nfsa_maxname = nfsap-&gt;nfsa_maxname;
	nmp-&gt;nm_fsattr.nfsa_flags &amp;= ~(NFS_FSFLAG_NO_TRUNC|NFS_FSFLAG_CHOWN_RESTRICTED|NFS_FSFLAG_CASE_INSENSITIVE|NFS_FSFLAG_CASE_PRESERVING);
	nmp-&gt;nm_fsattr.nfsa_flags |= nfsap-&gt;nfsa_flags &amp; NFS_FSFLAG_NO_TRUNC;
	nmp-&gt;nm_fsattr.nfsa_flags |= nfsap-&gt;nfsa_flags &amp; NFS_FSFLAG_CHOWN_RESTRICTED;
	nmp-&gt;nm_fsattr.nfsa_flags |= nfsap-&gt;nfsa_flags &amp; NFS_FSFLAG_CASE_INSENSITIVE;
	nmp-&gt;nm_fsattr.nfsa_flags |= nfsap-&gt;nfsa_flags &amp; NFS_FSFLAG_CASE_PRESERVING;
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_MAXLINK);
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_MAXNAME);
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_NO_TRUNC);
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_CHOWN_RESTRICTED);
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_CASE_INSENSITIVE);
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_CASE_PRESERVING);
	nmp-&gt;nm_state |= NFSSTA_GOTPATHCONF;
}

<span class="enscript-comment">/*
 * Return POSIX pathconf information applicable to nfs.
 *
 * The NFS V2 protocol doesn't support this, so just return EINVAL
 * for V2.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_pathconf</span>(
	<span class="enscript-type">struct</span> vnop_pathconf_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		int a_name;
		int32_t *a_retval;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vnode_t vp = ap-&gt;a_vp;
	nfsnode_t np = VTONFS(vp);
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_fsattr nfsa, *nfsap;
	<span class="enscript-type">int</span> error = 0;
	uint64_t maxFileSize;
	uint nbits;

	nmp = VTONMP(vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">switch</span> (ap-&gt;a_name) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_LINK_MAX</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_NAME_MAX</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_CHOWN_RESTRICTED</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_NO_TRUNC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_CASE_SENSITIVE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_CASE_PRESERVING</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_FILESIZEBITS</span>:
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers == NFS_VER2) {
			*ap-&gt;a_retval = 32;
			<span class="enscript-keyword">return</span> (0);
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_XATTR_SIZE_BITS</span>:
		<span class="enscript-comment">/* Do we support xattrs natively? */</span>
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR)
			<span class="enscript-keyword">break</span>;  <span class="enscript-comment">/* Yes */</span>
		<span class="enscript-comment">/* No... so just return an error */</span>
		<span class="enscript-comment">/* FALLTHROUGH */</span>
	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">/* don't bother contacting the server if we know the answer */</span>
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers == NFS_VER2)
		<span class="enscript-keyword">return</span> (EINVAL);

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers == NFS_VER3) {
		<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_state &amp; NFSSTA_GOTPATHCONF)) {
			<span class="enscript-comment">/* no pathconf info cached */</span>
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			NFS_CLEAR_ATTRIBUTES(nfsa.nfsa_bitmap);
			error = nfs3_pathconf_rpc(np, &amp;nfsa, ap-&gt;a_context);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
			nmp = VTONMP(vp);
			<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
				<span class="enscript-keyword">return</span> (ENXIO);
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_HOMOGENEOUS) {
				<span class="enscript-comment">/* all files have the same pathconf info, */</span>
				<span class="enscript-comment">/* so cache a copy of the results */</span>
				nfs3_pathconf_cache(nmp, &amp;nfsa);
			}
			nfsap = &amp;nfsa;
		} <span class="enscript-keyword">else</span> {
			nfsap = &amp;nmp-&gt;nm_fsattr;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_HOMOGENEOUS)) {
		<span class="enscript-comment">/* no pathconf info cached */</span>
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		NFS_CLEAR_ATTRIBUTES(nfsa.nfsa_bitmap);
		error = nfs4_pathconf_rpc(np, &amp;nfsa, ap-&gt;a_context);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		nmp = VTONMP(vp);
		<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
			<span class="enscript-keyword">return</span> (ENXIO);
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		nfsap = &amp;nfsa;
	} <span class="enscript-keyword">else</span> {
		nfsap = &amp;nmp-&gt;nm_fsattr;
	}

	<span class="enscript-keyword">switch</span> (ap-&gt;a_name) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_LINK_MAX</span>:
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nfsap-&gt;nfsa_bitmap, NFS_FATTR_MAXLINK))
			*ap-&gt;a_retval = nfsap-&gt;nfsa_maxlink;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers == NFS_VER4) &amp;&amp; NFS_BITMAP_ISSET(np-&gt;n_vattr.nva_bitmap, NFS_FATTR_MAXLINK))
			*ap-&gt;a_retval = np-&gt;n_vattr.nva_maxlink;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_NAME_MAX</span>:
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nfsap-&gt;nfsa_bitmap, NFS_FATTR_MAXNAME))
			*ap-&gt;a_retval = nfsap-&gt;nfsa_maxname;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_CHOWN_RESTRICTED</span>:
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nfsap-&gt;nfsa_bitmap, NFS_FATTR_CHOWN_RESTRICTED))
			*ap-&gt;a_retval = (nfsap-&gt;nfsa_flags &amp; NFS_FSFLAG_CHOWN_RESTRICTED) ? 200112 <span class="enscript-comment">/* _POSIX_CHOWN_RESTRICTED */</span> : 0;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_NO_TRUNC</span>:
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nfsap-&gt;nfsa_bitmap, NFS_FATTR_NO_TRUNC))
			*ap-&gt;a_retval = (nfsap-&gt;nfsa_flags &amp; NFS_FSFLAG_NO_TRUNC) ? 200112 <span class="enscript-comment">/* _POSIX_NO_TRUNC */</span> : 0;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_CASE_SENSITIVE</span>:
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nfsap-&gt;nfsa_bitmap, NFS_FATTR_CASE_INSENSITIVE))
			*ap-&gt;a_retval = (nfsap-&gt;nfsa_flags &amp; NFS_FSFLAG_CASE_INSENSITIVE) ? 0 : 1;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_CASE_PRESERVING</span>:
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nfsap-&gt;nfsa_bitmap, NFS_FATTR_CASE_PRESERVING))
			*ap-&gt;a_retval = (nfsap-&gt;nfsa_flags &amp; NFS_FSFLAG_CASE_PRESERVING) ? 1 : 0;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_XATTR_SIZE_BITS</span>: <span class="enscript-comment">/* same as file size bits if named attrs supported */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">_PC_FILESIZEBITS</span>:
		<span class="enscript-keyword">if</span> (!NFS_BITMAP_ISSET(nfsap-&gt;nfsa_bitmap, NFS_FATTR_MAXFILESIZE)) {
			*ap-&gt;a_retval = 64;
			error = 0;
			<span class="enscript-keyword">break</span>;
		}
		maxFileSize = nfsap-&gt;nfsa_maxfilesize;
		nbits = 1;
		<span class="enscript-keyword">if</span> (maxFileSize &amp; 0xffffffff00000000ULL) {
			nbits += 32;
			maxFileSize &gt;&gt;= 32;
		}
		<span class="enscript-keyword">if</span> (maxFileSize &amp; 0xffff0000) {
			nbits += 16;
			maxFileSize &gt;&gt;= 16;
		}
		<span class="enscript-keyword">if</span> (maxFileSize &amp; 0xff00) {
			nbits += 8;
			maxFileSize &gt;&gt;= 8;
		}
		<span class="enscript-keyword">if</span> (maxFileSize &amp; 0xf0) {
			nbits += 4;
			maxFileSize &gt;&gt;= 4;
		}
		<span class="enscript-keyword">if</span> (maxFileSize &amp; 0xc) {
			nbits += 2;
			maxFileSize &gt;&gt;= 2;
		}
		<span class="enscript-keyword">if</span> (maxFileSize &amp; 0x2) {
			nbits += 1;
		}
		*ap-&gt;a_retval = nbits;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EINVAL;
	}

	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Read wrapper for special devices.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsspec_vnop_read</span>(
	<span class="enscript-type">struct</span> vnop_read_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		struct uio *a_uio;
		int a_ioflag;
		vfs_context_t a_context;
	} */</span> *ap)
{
	nfsnode_t np = VTONFS(ap-&gt;a_vp);
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * Set access flag.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np)))
		<span class="enscript-keyword">return</span> (error);
	np-&gt;n_flag |= NACC;
	microtime(&amp;now);
	np-&gt;n_atim.tv_sec = now.tv_sec;
	np-&gt;n_atim.tv_nsec = now.tv_usec * 1000;
	nfs_node_unlock(np);
	<span class="enscript-keyword">return</span> (VOCALL(spec_vnodeop_p, VOFFSET(vnop_read), ap));
}

<span class="enscript-comment">/*
 * Write wrapper for special devices.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsspec_vnop_write</span>(
	<span class="enscript-type">struct</span> vnop_write_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		struct uio *a_uio;
		int a_ioflag;
		vfs_context_t a_context;
	} */</span> *ap)
{
	nfsnode_t np = VTONFS(ap-&gt;a_vp);
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * Set update flag.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np)))
		<span class="enscript-keyword">return</span> (error);
	np-&gt;n_flag |= NUPD;
	microtime(&amp;now);
	np-&gt;n_mtim.tv_sec = now.tv_sec;
	np-&gt;n_mtim.tv_nsec = now.tv_usec * 1000;
	nfs_node_unlock(np);
	<span class="enscript-keyword">return</span> (VOCALL(spec_vnodeop_p, VOFFSET(vnop_write), ap));
}

<span class="enscript-comment">/*
 * Close wrapper for special devices.
 *
 * Update the times on the nfsnode then do device close.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsspec_vnop_close</span>(
	<span class="enscript-type">struct</span> vnop_close_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		int a_fflag;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vnode_t vp = ap-&gt;a_vp;
	nfsnode_t np = VTONFS(vp);
	<span class="enscript-type">struct</span> vnode_attr vattr;
	mount_t mp;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np)))
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; (NACC | NUPD)) {
		np-&gt;n_flag |= NCHG;
		<span class="enscript-keyword">if</span> (!vnode_isinuse(vp, 0) &amp;&amp; (mp = vnode_mount(vp)) &amp;&amp; !vfs_isrdonly(mp)) {
			VATTR_INIT(&amp;vattr);
			<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NACC) {
				vattr.va_access_time = np-&gt;n_atim;
				VATTR_SET_ACTIVE(&amp;vattr, va_access_time);
			}
			<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NUPD) {
				vattr.va_modify_time = np-&gt;n_mtim;
				VATTR_SET_ACTIVE(&amp;vattr, va_modify_time);
			}
			nfs_node_unlock(np);
			vnode_setattr(vp, &amp;vattr, ap-&gt;a_context);
		} <span class="enscript-keyword">else</span> {
			nfs_node_unlock(np);
		}
	} <span class="enscript-keyword">else</span> {
		nfs_node_unlock(np);
	}
	<span class="enscript-keyword">return</span> (VOCALL(spec_vnodeop_p, VOFFSET(vnop_close), ap));
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FIFO</span>
<span class="enscript-type">extern</span> vnop_t **fifo_vnodeop_p;

<span class="enscript-comment">/*
 * Read wrapper for fifos.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsfifo_vnop_read</span>(
	<span class="enscript-type">struct</span> vnop_read_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		struct uio *a_uio;
		int a_ioflag;
		vfs_context_t a_context;
	} */</span> *ap)
{
	nfsnode_t np = VTONFS(ap-&gt;a_vp);
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * Set access flag.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np)))
		<span class="enscript-keyword">return</span> (error);
	np-&gt;n_flag |= NACC;
	microtime(&amp;now);
	np-&gt;n_atim.tv_sec = now.tv_sec;
	np-&gt;n_atim.tv_nsec = now.tv_usec * 1000;
	nfs_node_unlock(np);
	<span class="enscript-keyword">return</span> (VOCALL(fifo_vnodeop_p, VOFFSET(vnop_read), ap));
}

<span class="enscript-comment">/*
 * Write wrapper for fifos.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsfifo_vnop_write</span>(
	<span class="enscript-type">struct</span> vnop_write_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		struct uio *a_uio;
		int a_ioflag;
		vfs_context_t a_context;
	} */</span> *ap)
{
	nfsnode_t np = VTONFS(ap-&gt;a_vp);
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * Set update flag.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np)))
		<span class="enscript-keyword">return</span> (error);
	np-&gt;n_flag |= NUPD;
	microtime(&amp;now);
	np-&gt;n_mtim.tv_sec = now.tv_sec;
	np-&gt;n_mtim.tv_nsec = now.tv_usec * 1000;
	nfs_node_unlock(np);
	<span class="enscript-keyword">return</span> (VOCALL(fifo_vnodeop_p, VOFFSET(vnop_write), ap));
}

<span class="enscript-comment">/*
 * Close wrapper for fifos.
 *
 * Update the times on the nfsnode then do fifo close.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsfifo_vnop_close</span>(
	<span class="enscript-type">struct</span> vnop_close_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		int a_fflag;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vnode_t vp = ap-&gt;a_vp;
	nfsnode_t np = VTONFS(vp);
	<span class="enscript-type">struct</span> vnode_attr vattr;
	<span class="enscript-type">struct</span> timeval now;
	mount_t mp;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np)))
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; (NACC | NUPD)) {
		microtime(&amp;now);
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NACC) {
			np-&gt;n_atim.tv_sec = now.tv_sec;
			np-&gt;n_atim.tv_nsec = now.tv_usec * 1000;
		}
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NUPD) {
			np-&gt;n_mtim.tv_sec = now.tv_sec;
			np-&gt;n_mtim.tv_nsec = now.tv_usec * 1000;
		}
		np-&gt;n_flag |= NCHG;
		<span class="enscript-keyword">if</span> (!vnode_isinuse(vp, 1) &amp;&amp; (mp = vnode_mount(vp)) &amp;&amp; !vfs_isrdonly(mp)) {
			VATTR_INIT(&amp;vattr);
			<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NACC) {
				vattr.va_access_time = np-&gt;n_atim;
				VATTR_SET_ACTIVE(&amp;vattr, va_access_time);
			}
			<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NUPD) {
				vattr.va_modify_time = np-&gt;n_mtim;
				VATTR_SET_ACTIVE(&amp;vattr, va_modify_time);
			}
			nfs_node_unlock(np);
			vnode_setattr(vp, &amp;vattr, ap-&gt;a_context);
		} <span class="enscript-keyword">else</span> {
			nfs_node_unlock(np);
		}
	} <span class="enscript-keyword">else</span> {
		nfs_node_unlock(np);
	}
	<span class="enscript-keyword">return</span> (VOCALL(fifo_vnodeop_p, VOFFSET(vnop_close), ap));
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* FIFO */</span>

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_ioctl</span>(
	<span class="enscript-type">struct</span> vnop_ioctl_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		u_int32_t a_command;
		caddr_t a_data;
		int a_fflag;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> nfsmount *mp = VTONMP(vp);
	<span class="enscript-type">struct</span> user_nfs_gss_principal gprinc;
	uint32_t len;
	<span class="enscript-type">int</span> error = ENOTTY;

	<span class="enscript-keyword">if</span> (mp == NULL)
		<span class="enscript-keyword">return</span> (ENXIO);
	
	<span class="enscript-keyword">switch</span> (ap-&gt;a_command) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_FULLFSYNC</span>:
		<span class="enscript-keyword">if</span> (vnode_vfsisrdonly(vp))
			<span class="enscript-keyword">return</span> (EROFS);
		error = nfs_flush(VTONFS(vp), MNT_WAIT, vfs_context_thread(ctx), 0);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_FSCTL_DESTROY_CRED</span>:
		<span class="enscript-keyword">if</span> (!auth_is_kerberized(mp-&gt;nm_auth))
			<span class="enscript-keyword">return</span> (ENOTSUP);
		error = nfs_gss_clnt_ctx_remove(mp, vfs_context_ucred(ctx));
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_FSCTL_SET_CRED</span>:
		<span class="enscript-keyword">if</span> (!auth_is_kerberized(mp-&gt;nm_auth))
			<span class="enscript-keyword">return</span> (ENOTSUP);
		NFS_DBG(NFS_FAC_GSS, 7, <span class="enscript-string">&quot;Enter NFS_FSCTL_SET_CRED (proc %d) data = %p\n&quot;</span>, vfs_context_is64bit(ctx), (<span class="enscript-type">void</span> *)ap-&gt;a_data);
		<span class="enscript-keyword">if</span> (vfs_context_is64bit(ctx)) {
			gprinc = *(<span class="enscript-type">struct</span> user_nfs_gss_principal *)ap-&gt;a_data;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> nfs_gss_principal *tp;
			tp = (<span class="enscript-type">struct</span> nfs_gss_principal *)ap-&gt;a_data;
			gprinc.princlen = tp-&gt;princlen;
			gprinc.nametype = tp-&gt;nametype;
			gprinc.principal = CAST_USER_ADDR_T(tp-&gt;principal);
		}
		<span class="enscript-keyword">if</span> (gprinc.princlen &gt; MAXPATHLEN)
			<span class="enscript-keyword">return</span> (EINVAL);
		NFS_DBG(NFS_FAC_GSS, 7, <span class="enscript-string">&quot;Received principal length %d name type = %d\n&quot;</span>, gprinc.princlen, gprinc.nametype);
		uint8_t *p;
		MALLOC(p, uint8_t *, gprinc.princlen+1, M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (p == NULL)
			<span class="enscript-keyword">return</span> (ENOMEM);
		error = copyin(gprinc.principal, p, gprinc.princlen);
		<span class="enscript-keyword">if</span> (error) {
			NFS_DBG(NFS_FAC_GSS, 7, <span class="enscript-string">&quot;NFS_FSCTL_SET_CRED could not copy in princiapl data of len %d: %d\n&quot;</span>,
				gprinc.princlen, error);
			FREE(p, M_TEMP);
			<span class="enscript-keyword">return</span> (error);
		}
		NFS_DBG(NFS_FAC_GSS, 7, <span class="enscript-string">&quot;Seting credential to principal %s\n&quot;</span>, p);
		error = nfs_gss_clnt_ctx_set_principal(mp, ctx, p, gprinc.princlen, gprinc.nametype);
		NFS_DBG(NFS_FAC_GSS, 7, <span class="enscript-string">&quot;Seting credential to principal %s returned %d\n&quot;</span>, p, error);
		FREE(p, M_TEMP);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_FSCTL_GET_CRED</span>:
		<span class="enscript-keyword">if</span> (!auth_is_kerberized(mp-&gt;nm_auth))
			<span class="enscript-keyword">return</span> (ENOTSUP);
		error = nfs_gss_clnt_ctx_get_principal(mp, ctx, &amp;gprinc);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (vfs_context_is64bit(ctx)) {
			<span class="enscript-type">struct</span> user_nfs_gss_principal *upp = (<span class="enscript-type">struct</span> user_nfs_gss_principal *)ap-&gt;a_data;
			len = upp-&gt;princlen;
			<span class="enscript-keyword">if</span> (gprinc.princlen &lt; len)
				len = gprinc.princlen;
			upp-&gt;princlen = gprinc.princlen;
			upp-&gt;nametype = gprinc.nametype;
			upp-&gt;flags = gprinc.flags;
			<span class="enscript-keyword">if</span> (gprinc.principal)
				error = copyout((<span class="enscript-type">void</span> *)gprinc.principal, upp-&gt;principal, len);
			<span class="enscript-keyword">else</span>
				upp-&gt;principal = USER_ADDR_NULL;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> nfs_gss_principal *u32pp = (<span class="enscript-type">struct</span> nfs_gss_principal *)ap-&gt;a_data;
			len = u32pp-&gt;princlen;
			<span class="enscript-keyword">if</span> (gprinc.princlen &lt; len)
				len = gprinc.princlen;
			u32pp-&gt;princlen = gprinc.princlen;
			u32pp-&gt;nametype = gprinc.nametype;
			u32pp-&gt;flags = gprinc.flags;
			<span class="enscript-keyword">if</span> (gprinc.principal)
				error = copyout((<span class="enscript-type">void</span> *)gprinc.principal, u32pp-&gt;principal, len);
			<span class="enscript-keyword">else</span>
				u32pp-&gt;principal = (user32_addr_t)0;
		}
		<span class="enscript-keyword">if</span> (error) {
			NFS_DBG(NFS_FAC_GSS, 7, <span class="enscript-string">&quot;NFS_FSCTL_GET_CRED could not copy out princiapl data of len %d: %d\n&quot;</span>,
				gprinc.princlen, error);
		}
		FREE(gprinc.principal, M_TEMP);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_select</span>(
	__unused <span class="enscript-type">struct</span> vnop_select_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		int a_which;
		int a_fflags;
		void *a_wql;
		vfs_context_t a_context;
	} */</span> *ap)
{

	<span class="enscript-comment">/*
	 * We were once bogusly seltrue() which returns 1.  Is this right?
	 */</span>
	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * vnode OP for pagein using UPL
 *
 * No buffer I/O, just RPCs straight into the mapped pages.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_pagein</span>(
	<span class="enscript-type">struct</span> vnop_pagein_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		upl_t a_pl;
		vm_offset_t a_pl_offset;
		off_t a_f_offset;
		size_t a_size;
		int a_flags;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vnode_t vp = ap-&gt;a_vp;
	upl_t pl = ap-&gt;a_pl;
	size_t size = ap-&gt;a_size;
	off_t f_offset = ap-&gt;a_f_offset;
	vm_offset_t pl_offset = ap-&gt;a_pl_offset;
	<span class="enscript-type">int</span> flags = ap-&gt;a_flags;
	thread_t thd;
	kauth_cred_t cred;
	nfsnode_t np = VTONFS(vp);
	size_t nmrsize, iosize, txsize, rxsize, retsize;
	off_t txoffset;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0;
	vm_offset_t ioaddr, rxaddr;
	uio_t uio;
	<span class="enscript-type">char</span> uio_buf [ UIO_SIZEOF(1) ];
	<span class="enscript-type">int</span> nofreeupl = flags &amp; UPL_NOCOMMIT;
	upl_page_info_t *plinfo;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAXPAGINGREQS</span>	16	<span class="enscript-comment">/* max outstanding RPCs for pagein/pageout */</span>
	<span class="enscript-type">struct</span> nfsreq *req[MAXPAGINGREQS];
	<span class="enscript-type">int</span> nextsend, nextwait;
	uint32_t stategenid = 0, restart = 0;
	kern_return_t kret;

	FSDBG(322, np, f_offset, size, flags);
	<span class="enscript-keyword">if</span> (pl == (upl_t)NULL)
		panic(<span class="enscript-string">&quot;nfs_pagein: no upl&quot;</span>);

	<span class="enscript-keyword">if</span> (size &lt;= 0) {
		printf(<span class="enscript-string">&quot;nfs_pagein: invalid size %ld&quot;</span>, size);
		<span class="enscript-keyword">if</span> (!nofreeupl)
			(<span class="enscript-type">void</span>) ubc_upl_abort_range(pl, pl_offset, size, 0);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> (f_offset &lt; 0 || f_offset &gt;= (off_t)np-&gt;n_size || (f_offset &amp; PAGE_MASK_64)) {
		<span class="enscript-keyword">if</span> (!nofreeupl)
			ubc_upl_abort_range(pl, pl_offset, size,
				UPL_ABORT_ERROR | UPL_ABORT_FREE_ON_EMPTY);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	thd = vfs_context_thread(ap-&gt;a_context);
	cred = ubc_getcred(vp);
	<span class="enscript-keyword">if</span> (!IS_VALID_CRED(cred))
		cred = vfs_context_ucred(ap-&gt;a_context);

	uio = uio_createwithbuffer(1, f_offset, UIO_SYSSPACE, UIO_READ,
		&amp;uio_buf, <span class="enscript-keyword">sizeof</span>(uio_buf));

	nmp = VTONMP(vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		<span class="enscript-keyword">if</span> (!nofreeupl)
			ubc_upl_abort_range(pl, pl_offset, size,
				UPL_ABORT_ERROR | UPL_ABORT_FREE_ON_EMPTY);
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	nmrsize = nmp-&gt;nm_rsize;

	plinfo = ubc_upl_pageinfo(pl);
	kret = ubc_upl_map(pl, &amp;ioaddr);
	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;nfs_vnop_pagein: ubc_upl_map() failed with (%d)&quot;</span>, kret);
	ioaddr += pl_offset;

<span class="enscript-reference">tryagain</span>:
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4)
		stategenid = nmp-&gt;nm_stategenid;
	txsize = rxsize = size;
	txoffset = f_offset;
	rxaddr = ioaddr;

	bzero(req, <span class="enscript-keyword">sizeof</span>(req));
	nextsend = nextwait = 0;
	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
			error = EIO;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* send requests while we need to and have available slots */</span>
		<span class="enscript-keyword">while</span> ((txsize &gt; 0) &amp;&amp; (req[nextsend] == NULL)) {
			iosize = MIN(nmrsize, txsize);
			<span class="enscript-keyword">if</span> ((error = nmp-&gt;nm_funcs-&gt;nf_read_rpc_async(np, txoffset, iosize, thd, cred, NULL, &amp;req[nextsend]))) {
				req[nextsend] = NULL;
				<span class="enscript-keyword">break</span>;
			}
			txoffset += iosize;
			txsize -= iosize;
			nextsend = (nextsend + 1) % MAXPAGINGREQS;
		}
		<span class="enscript-comment">/* wait while we need to and break out if more requests to send */</span>
		<span class="enscript-keyword">while</span> ((rxsize &gt; 0) &amp;&amp; req[nextwait]) {
			iosize = retsize = MIN(nmrsize, rxsize);
			uio_reset(uio, uio_offset(uio), UIO_SYSSPACE, UIO_READ);
			uio_addiov(uio, CAST_USER_ADDR_T(rxaddr), iosize);
			FSDBG(322, uio_offset(uio), uio_resid(uio), rxaddr, rxsize);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">UPL_DEBUG</span>
			upl_ubc_alias_set(pl, (uintptr_t) current_thread(), (uintptr_t) 2);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* UPL_DEBUG */</span>
			OSAddAtomic64(1, &amp;nfsstats.pageins);
			error = nmp-&gt;nm_funcs-&gt;nf_read_rpc_async_finish(np, req[nextwait], uio, &amp;retsize, NULL);
			req[nextwait] = NULL;
			nextwait = (nextwait + 1) % MAXPAGINGREQS;
			<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; nfs_mount_state_error_should_restart(error)) {
				lck_mtx_lock(&amp;nmp-&gt;nm_lock);
				<span class="enscript-keyword">if</span> ((error != NFSERR_GRACE) &amp;&amp; (stategenid == nmp-&gt;nm_stategenid)) {
					NP(np, <span class="enscript-string">&quot;nfs_vnop_pagein: error %d, initiating recovery&quot;</span>, error);
					nfs_need_recover(nmp, error);
				}
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
				restart++;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">cancel</span>;
			}
			<span class="enscript-keyword">if</span> (error) {
				FSDBG(322, uio_offset(uio), uio_resid(uio), error, -1);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (retsize &lt; iosize) {
				<span class="enscript-comment">/* Just zero fill the rest of the valid area. */</span>
				<span class="enscript-type">int</span> zcnt = iosize - retsize;
				bzero((<span class="enscript-type">char</span> *)rxaddr + retsize, zcnt);
				FSDBG(324, uio_offset(uio), retsize, zcnt, rxaddr);
				uio_update(uio, zcnt);
			}
			rxaddr += iosize;	
			rxsize -= iosize;
			<span class="enscript-keyword">if</span> (txsize)
				<span class="enscript-keyword">break</span>;
		}
	} <span class="enscript-keyword">while</span> (!error &amp;&amp; (txsize || rxsize));

	restart = 0;

	<span class="enscript-keyword">if</span> (error) {
<span class="enscript-reference">cancel</span>:
		<span class="enscript-comment">/* cancel any outstanding requests */</span>
		<span class="enscript-keyword">while</span> (req[nextwait]) {
			nfs_request_async_cancel(req[nextwait]);
			req[nextwait] = NULL;
			nextwait = (nextwait + 1) % MAXPAGINGREQS;
		}
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
			error = EIO;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (restart) {
			<span class="enscript-keyword">if</span> (restart &lt;= nfs_mount_state_max_restarts(nmp)) { <span class="enscript-comment">/* guard against no progress */</span>
				<span class="enscript-keyword">if</span> (error == NFSERR_GRACE)
					tsleep(&amp;nmp-&gt;nm_state, (PZERO-1), <span class="enscript-string">&quot;nfsgrace&quot;</span>, 2*hz);
				<span class="enscript-keyword">if</span> (!(error = nfs_mount_state_wait_for_recovery(nmp)))
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
			} <span class="enscript-keyword">else</span> {
				NP(np, <span class="enscript-string">&quot;nfs_pagein: too many restarts, aborting&quot;</span>);
			}
		}
	}

	ubc_upl_unmap(pl);

	<span class="enscript-keyword">if</span> (!nofreeupl) {
		<span class="enscript-keyword">if</span> (error)
			ubc_upl_abort_range(pl, pl_offset, size,
					    UPL_ABORT_ERROR |
					    UPL_ABORT_FREE_ON_EMPTY);
		<span class="enscript-keyword">else</span>
			ubc_upl_commit_range(pl, pl_offset, size,
					     UPL_COMMIT_CLEAR_DIRTY |
					     UPL_COMMIT_FREE_ON_EMPTY);
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * the following are needed only by nfs_pageout to know how to handle errors
 * see nfs_pageout comments on explanation of actions.
 * the errors here are copied from errno.h and errors returned by servers
 * are expected to match the same numbers here. If not, our actions maybe
 * erroneous.
 */</span>
<span class="enscript-type">char</span> <span class="enscript-function-name">nfs_pageouterrorhandler</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">enum</span> actiontype {NOACTION, DUMP, DUMPANDLOG, RETRY, SEVER};
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_ELAST</span> 88
<span class="enscript-type">static</span> u_char errorcount[NFS_ELAST+1]; <span class="enscript-comment">/* better be zeros when initialized */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> errortooutcome[NFS_ELAST+1] = {
	NOACTION,
	DUMP,			<span class="enscript-comment">/* EPERM	1	Operation not permitted */</span>
	DUMP,			<span class="enscript-comment">/* ENOENT	2	No such file or directory */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ESRCH	3	No such process */</span>
	RETRY,			<span class="enscript-comment">/* EINTR 	4	Interrupted system call */</span>
	DUMP,			<span class="enscript-comment">/* EIO		5	Input/output error */</span>
	DUMP,			<span class="enscript-comment">/* ENXIO	6	Device not configured */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* E2BIG	7	Argument list too long */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ENOEXEC	8	Exec format error */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EBADF	9	Bad file descriptor */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ECHILD	10	No child processes */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EDEADLK	11	Resource deadlock avoided - was EAGAIN */</span>
	RETRY,			<span class="enscript-comment">/* ENOMEM	12	Cannot allocate memory */</span>
	DUMP,			<span class="enscript-comment">/* EACCES	13	Permission denied */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EFAULT	14	Bad address */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ENOTBLK	15	POSIX - Block device required */</span>
	RETRY,			<span class="enscript-comment">/* EBUSY	16	Device busy */</span>
	DUMP,			<span class="enscript-comment">/* EEXIST	17	File exists */</span>
	DUMP,			<span class="enscript-comment">/* EXDEV	18	Cross-device link */</span>
	DUMP,			<span class="enscript-comment">/* ENODEV	19	Operation not supported by device */</span>
	DUMP,			<span class="enscript-comment">/* ENOTDIR	20	Not a directory */</span>
	DUMP,			<span class="enscript-comment">/* EISDIR 	21	Is a directory */</span>
	DUMP,			<span class="enscript-comment">/* EINVAL	22	Invalid argument */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ENFILE	23	Too many open files in system */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EMFILE	24	Too many open files */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ENOTTY	25	Inappropriate ioctl for device */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ETXTBSY	26	Text file busy - POSIX */</span>
	DUMP,			<span class="enscript-comment">/* EFBIG	27	File too large */</span>
	DUMP,			<span class="enscript-comment">/* ENOSPC	28	No space left on device */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ESPIPE	29	Illegal seek */</span>
	DUMP,			<span class="enscript-comment">/* EROFS	30	Read-only file system */</span>
	DUMP,			<span class="enscript-comment">/* EMLINK	31	Too many links */</span>
	RETRY,			<span class="enscript-comment">/* EPIPE	32	Broken pipe */</span>
	<span class="enscript-comment">/* math software */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EDOM				33	Numerical argument out of domain */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ERANGE			34	Result too large */</span>
	RETRY,			<span class="enscript-comment">/* EAGAIN/EWOULDBLOCK	35	Resource temporarily unavailable */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EINPROGRESS		36	Operation now in progress */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EALREADY			37	Operation already in progress */</span>
	<span class="enscript-comment">/* ipc/network software -- argument errors */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ENOTSOC			38	Socket operation on non-socket */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EDESTADDRREQ		39	Destination address required */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EMSGSIZE			40	Message too long */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EPROTOTYPE		41	Protocol wrong type for socket */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ENOPROTOOPT		42	Protocol not available */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EPROTONOSUPPORT	43	Protocol not supported */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ESOCKTNOSUPPORT	44	Socket type not supported */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ENOTSUP			45	Operation not supported */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EPFNOSUPPORT		46	Protocol family not supported */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EAFNOSUPPORT		47	Address family not supported by protocol family */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EADDRINUSE		48	Address already in use */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EADDRNOTAVAIL	49	Can't assign requested address */</span>
	<span class="enscript-comment">/* ipc/network software -- operational errors */</span>
	RETRY,			<span class="enscript-comment">/* ENETDOWN			50	Network is down */</span>
	RETRY,			<span class="enscript-comment">/* ENETUNREACH		51	Network is unreachable */</span>
	RETRY,			<span class="enscript-comment">/* ENETRESET		52	Network dropped connection on reset */</span>
	RETRY,			<span class="enscript-comment">/* ECONNABORTED		53	Software caused connection abort */</span>
	RETRY,			<span class="enscript-comment">/* ECONNRESET		54	Connection reset by peer */</span>
	RETRY,			<span class="enscript-comment">/* ENOBUFS			55	No buffer space available */</span>
	RETRY,			<span class="enscript-comment">/* EISCONN			56	Socket is already connected */</span>
	RETRY,			<span class="enscript-comment">/* ENOTCONN			57	Socket is not connected */</span>
	RETRY,			<span class="enscript-comment">/* ESHUTDOWN		58	Can't send after socket shutdown */</span>
	RETRY,			<span class="enscript-comment">/* ETOOMANYREFS		59	Too many references: can't splice */</span>
	RETRY,			<span class="enscript-comment">/* ETIMEDOUT		60	Operation timed out */</span>
	RETRY,			<span class="enscript-comment">/* ECONNREFUSED		61	Connection refused */</span>

	DUMPANDLOG,		<span class="enscript-comment">/* ELOOP			62	Too many levels of symbolic links */</span>
	DUMP,			<span class="enscript-comment">/* ENAMETOOLONG		63	File name too long */</span>
	RETRY,			<span class="enscript-comment">/* EHOSTDOWN		64	Host is down */</span>
	RETRY,			<span class="enscript-comment">/* EHOSTUNREACH		65	No route to host */</span>
	DUMP,			<span class="enscript-comment">/* ENOTEMPTY		66	Directory not empty */</span>
	<span class="enscript-comment">/* quotas &amp; mush */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* PROCLIM			67	Too many processes */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EUSERS			68	Too many users */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EDQUOT			69	Disc quota exceeded */</span>
	<span class="enscript-comment">/* Network File System */</span>
	DUMP,			<span class="enscript-comment">/* ESTALE			70	Stale NFS file handle */</span>
	DUMP,			<span class="enscript-comment">/* EREMOTE			71	Too many levels of remote in path */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EBADRPC			72	RPC struct is bad */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ERPCMISMATCH		73	RPC version wrong */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EPROGUNAVAIL		74	RPC prog. not avail */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EPROGMISMATCH	75	Program version wrong */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EPROCUNAVAIL		76	Bad procedure for program */</span>

	DUMPANDLOG,		<span class="enscript-comment">/* ENOLCK			77	No locks available */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ENOSYS			78	Function not implemented */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EFTYPE			79	Inappropriate file type or format */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EAUTH			80	Authentication error */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ENEEDAUTH		81	Need authenticator */</span>
	<span class="enscript-comment">/* Intelligent device errors */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EPWROFF			82	Device power is off */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EDEVERR			83	Device error, e.g. paper out */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EOVERFLOW		84	Value too large to be stored in data type */</span>
	<span class="enscript-comment">/* Program loading errors */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EBADEXEC			85	Bad executable */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EBADARCH			86	Bad CPU type in executable */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* ESHLIBVERS		87	Shared library version mismatch */</span>
	DUMPANDLOG,		<span class="enscript-comment">/* EBADMACHO		88	Malformed Macho file */</span>
};

<span class="enscript-type">char</span>
<span class="enscript-function-name">nfs_pageouterrorhandler</span>(<span class="enscript-type">int</span> error)
{
	<span class="enscript-keyword">if</span> (error &gt; NFS_ELAST)
		<span class="enscript-keyword">return</span>(DUMP);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span>(errortooutcome[error]);
}


<span class="enscript-comment">/*
 * vnode OP for pageout using UPL
 *
 * No buffer I/O, just RPCs straight from the mapped pages.
 * File size changes are not permitted in pageout.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_pageout</span>(
	<span class="enscript-type">struct</span> vnop_pageout_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		upl_t a_pl;
		vm_offset_t a_pl_offset;
		off_t a_f_offset;
		size_t a_size;
		int a_flags;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vnode_t vp = ap-&gt;a_vp;
	upl_t pl = ap-&gt;a_pl;
	size_t size = ap-&gt;a_size;
	off_t f_offset = ap-&gt;a_f_offset;
	vm_offset_t pl_offset = ap-&gt;a_pl_offset;
	<span class="enscript-type">int</span> flags = ap-&gt;a_flags;
	nfsnode_t np = VTONFS(vp);
	thread_t thd;
	kauth_cred_t cred;
	<span class="enscript-type">struct</span> nfsbuf *bp;
	<span class="enscript-type">struct</span> nfsmount *nmp = VTONMP(vp);
	daddr64_t lbn;
	<span class="enscript-type">int</span> error = 0, iomode;
	off_t off, txoffset, rxoffset;
	vm_offset_t ioaddr, txaddr, rxaddr;
	uio_t auio;
	<span class="enscript-type">char</span> uio_buf [ UIO_SIZEOF(1) ];
	<span class="enscript-type">int</span> nofreeupl = flags &amp; UPL_NOCOMMIT;
	size_t nmwsize, biosize, iosize, pgsize, txsize, rxsize, xsize, remsize;
	<span class="enscript-type">struct</span> nfsreq *req[MAXPAGINGREQS];
	<span class="enscript-type">int</span> nextsend, nextwait, wverfset, commit;
	uint64_t wverf, wverf2;
	uint32_t stategenid = 0, vrestart = 0, restart = 0, vrestarts = 0, restarts = 0;
	kern_return_t kret;

	FSDBG(323, f_offset, size, pl, pl_offset);

	<span class="enscript-keyword">if</span> (pl == (upl_t)NULL)
		panic(<span class="enscript-string">&quot;nfs_pageout: no upl&quot;</span>);

	<span class="enscript-keyword">if</span> (size &lt;= 0) {
		printf(<span class="enscript-string">&quot;nfs_pageout: invalid size %ld&quot;</span>, size);
		<span class="enscript-keyword">if</span> (!nofreeupl)
			ubc_upl_abort_range(pl, pl_offset, size, 0);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (!nmp) {
		<span class="enscript-keyword">if</span> (!nofreeupl)
			ubc_upl_abort(pl, UPL_ABORT_DUMP_PAGES|UPL_ABORT_FREE_ON_EMPTY);
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	biosize = nmp-&gt;nm_biosize;
	nmwsize = nmp-&gt;nm_wsize;

	nfs_data_lock_noupdate(np, NFS_DATA_LOCK_SHARED);

	<span class="enscript-comment">/*
	 * Check to see whether the buffer is incore.
	 * If incore and not busy, invalidate it from the cache.
	 */</span>
	<span class="enscript-keyword">for</span> (iosize = 0; iosize &lt; size; iosize += xsize) {
		off = f_offset + iosize;
		<span class="enscript-comment">/* need make sure we do things on block boundaries */</span>
		xsize = biosize - (off % biosize);
		<span class="enscript-keyword">if</span> (off + xsize &gt; f_offset + size)
			xsize = f_offset + size - off;
		lbn = (daddr64_t)(off / biosize);
		lck_mtx_lock(nfs_buf_mutex);
		<span class="enscript-keyword">if</span> ((bp = nfs_buf_incore(np, lbn))) {
			FSDBG(323, off, bp, bp-&gt;nb_lflags, bp-&gt;nb_flags);
			<span class="enscript-keyword">if</span> (nfs_buf_acquire(bp, NBAC_NOWAIT, 0, 0)) {
				lck_mtx_unlock(nfs_buf_mutex);
				nfs_data_unlock_noupdate(np);
				<span class="enscript-comment">/* no panic. just tell vm we are busy */</span>
				<span class="enscript-keyword">if</span> (!nofreeupl)
					ubc_upl_abort_range(pl, pl_offset, size, 0);
				<span class="enscript-keyword">return</span> (EBUSY);
			}
			<span class="enscript-keyword">if</span> (bp-&gt;nb_dirtyend &gt; 0) {
				<span class="enscript-comment">/*
				 * if there's a dirty range in the buffer, check
				 * to see if it extends beyond the pageout region
				 *
				 * if the dirty region lies completely within the
				 * pageout region, we just invalidate the buffer
				 * because it's all being written out now anyway.
				 *
				 * if any of the dirty region lies outside the
				 * pageout region, we'll try to clip the dirty
				 * region to eliminate the portion that's being
				 * paged out.  If that's not possible, because
				 * the dirty region extends before and after the
				 * pageout region, then we'll just return EBUSY.
				 */</span>
				off_t boff, start, end;
				boff = NBOFF(bp);
				start = off;
				end = off + xsize;
				<span class="enscript-comment">/* clip end to EOF */</span>
				<span class="enscript-keyword">if</span> (end &gt; (off_t)np-&gt;n_size)
					end = np-&gt;n_size;
				start -= boff;
				end -= boff;
				<span class="enscript-keyword">if</span> ((bp-&gt;nb_dirtyoff &lt; start) &amp;&amp;
				    (bp-&gt;nb_dirtyend &gt; end)) {
				    <span class="enscript-comment">/*
				     * not gonna be able to clip the dirty region
				     *
				     * But before returning the bad news, move the
				     * buffer to the start of the delwri list and
				     * give the list a push to try to flush the
				     * buffer out.
				     */</span>
				    FSDBG(323, np, bp, 0xd00deebc, EBUSY);
				    nfs_buf_remfree(bp);
				    TAILQ_INSERT_HEAD(&amp;nfsbufdelwri, bp, nb_free);
				    nfsbufdelwricnt++;
				    nfs_buf_drop(bp);
				    nfs_buf_delwri_push(1);
				    lck_mtx_unlock(nfs_buf_mutex);
				    nfs_data_unlock_noupdate(np);
				    <span class="enscript-keyword">if</span> (!nofreeupl)
					    ubc_upl_abort_range(pl, pl_offset, size, 0);
				    <span class="enscript-keyword">return</span> (EBUSY);
				}
				<span class="enscript-keyword">if</span> ((bp-&gt;nb_dirtyoff &lt; start) ||
				    (bp-&gt;nb_dirtyend &gt; end)) {
				    <span class="enscript-comment">/* clip dirty region, if necessary */</span>
				    <span class="enscript-keyword">if</span> (bp-&gt;nb_dirtyoff &lt; start)
					bp-&gt;nb_dirtyend = min(bp-&gt;nb_dirtyend, start);
				    <span class="enscript-keyword">if</span> (bp-&gt;nb_dirtyend &gt; end)
					bp-&gt;nb_dirtyoff = max(bp-&gt;nb_dirtyoff, end);
				    FSDBG(323, bp, bp-&gt;nb_dirtyoff, bp-&gt;nb_dirtyend, 0xd00dee00);
				    <span class="enscript-comment">/* we're leaving this block dirty */</span>
				    nfs_buf_drop(bp);
				    lck_mtx_unlock(nfs_buf_mutex);
				    <span class="enscript-keyword">continue</span>;
				}
			}
			nfs_buf_remfree(bp);
			lck_mtx_unlock(nfs_buf_mutex);
			SET(bp-&gt;nb_flags, NB_INVAL);
			nfs_node_lock_force(np);
			<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_NEEDCOMMIT)) {
				CLR(bp-&gt;nb_flags, NB_NEEDCOMMIT);
				np-&gt;n_needcommitcnt--;
				CHECK_NEEDCOMMITCNT(np);
			}
			nfs_node_unlock(np);
			nfs_buf_release(bp, 1);
		} <span class="enscript-keyword">else</span> {
			lck_mtx_unlock(nfs_buf_mutex);
		}
	}

	thd = vfs_context_thread(ap-&gt;a_context);
	cred = ubc_getcred(vp);
	<span class="enscript-keyword">if</span> (!IS_VALID_CRED(cred))
		cred = vfs_context_ucred(ap-&gt;a_context);

	nfs_node_lock_force(np);
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NWRITEERR) {
		error = np-&gt;n_error;
		nfs_node_unlock(np);
		nfs_data_unlock_noupdate(np);
		<span class="enscript-keyword">if</span> (!nofreeupl)
			ubc_upl_abort_range(pl, pl_offset, size,
					    UPL_ABORT_FREE_ON_EMPTY);
		<span class="enscript-keyword">return</span> (error);
	}
	nfs_node_unlock(np);

	<span class="enscript-keyword">if</span> (f_offset &lt; 0 || f_offset &gt;= (off_t)np-&gt;n_size ||
	    f_offset &amp; PAGE_MASK_64 || size &amp; PAGE_MASK_64) {
		nfs_data_unlock_noupdate(np);
		<span class="enscript-keyword">if</span> (!nofreeupl)
			ubc_upl_abort_range(pl, pl_offset, size,
					    UPL_ABORT_FREE_ON_EMPTY);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	kret = ubc_upl_map(pl, &amp;ioaddr);
	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;nfs_vnop_pageout: ubc_upl_map() failed with (%d)&quot;</span>, kret);
	ioaddr += pl_offset;

	<span class="enscript-keyword">if</span> ((u_quad_t)f_offset + size &gt; np-&gt;n_size)
		xsize = np-&gt;n_size - f_offset;
	<span class="enscript-keyword">else</span>
		xsize = size;

	pgsize = round_page_64(xsize);
	<span class="enscript-keyword">if</span> ((size &gt; pgsize) &amp;&amp; !nofreeupl)
		ubc_upl_abort_range(pl, pl_offset + pgsize, size - pgsize,
				    UPL_ABORT_FREE_ON_EMPTY);

	<span class="enscript-comment">/*
	 * check for partial page and clear the
	 * contents past end of the file before
	 * releasing it in the VM page cache
	 */</span>
	<span class="enscript-keyword">if</span> ((u_quad_t)f_offset &lt; np-&gt;n_size &amp;&amp; (u_quad_t)f_offset + size &gt; np-&gt;n_size) {
		size_t io = np-&gt;n_size - f_offset;
		bzero((caddr_t)(ioaddr + io), size - io);
		FSDBG(321, np-&gt;n_size, f_offset, f_offset + io, size - io);
	}
	nfs_data_unlock_noupdate(np);

	auio = uio_createwithbuffer(1, 0, UIO_SYSSPACE, UIO_WRITE,
		&amp;uio_buf, <span class="enscript-keyword">sizeof</span>(uio_buf));

<span class="enscript-reference">tryagain</span>:
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4)
		stategenid = nmp-&gt;nm_stategenid;
	wverf = wverf2 = wverfset = 0;
	txsize = rxsize = xsize;
	txoffset = rxoffset = f_offset;
	txaddr = rxaddr = ioaddr;
	commit = NFS_WRITE_FILESYNC;

	bzero(req, <span class="enscript-keyword">sizeof</span>(req));
	nextsend = nextwait = 0;
	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
			error = EIO;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* send requests while we need to and have available slots */</span>
		<span class="enscript-keyword">while</span> ((txsize &gt; 0) &amp;&amp; (req[nextsend] == NULL)) {
			iosize = MIN(nmwsize, txsize);
			uio_reset(auio, txoffset, UIO_SYSSPACE, UIO_WRITE);
			uio_addiov(auio, CAST_USER_ADDR_T(txaddr), iosize);
			FSDBG(323, uio_offset(auio), iosize, txaddr, txsize);
			OSAddAtomic64(1, &amp;nfsstats.pageouts);
			nfs_node_lock_force(np);
			np-&gt;n_numoutput++;
			nfs_node_unlock(np);
			vnode_startwrite(vp);
			iomode = NFS_WRITE_UNSTABLE;
			<span class="enscript-keyword">if</span> ((error = nmp-&gt;nm_funcs-&gt;nf_write_rpc_async(np, auio, iosize, thd, cred, iomode, NULL, &amp;req[nextsend]))) {
				req[nextsend] = NULL;
				vnode_writedone(vp);
				nfs_node_lock_force(np);
				np-&gt;n_numoutput--;
				nfs_node_unlock(np);
				<span class="enscript-keyword">break</span>;
			}
			txaddr += iosize;
			txoffset += iosize;
			txsize -= iosize;
			nextsend = (nextsend + 1) % MAXPAGINGREQS;
		}
		<span class="enscript-comment">/* wait while we need to and break out if more requests to send */</span>
		<span class="enscript-keyword">while</span> ((rxsize &gt; 0) &amp;&amp; req[nextwait]) {
			iosize = remsize = MIN(nmwsize, rxsize);
			error = nmp-&gt;nm_funcs-&gt;nf_write_rpc_async_finish(np, req[nextwait], &amp;iomode, &amp;iosize, &amp;wverf2);
			req[nextwait] = NULL;
			nextwait = (nextwait + 1) % MAXPAGINGREQS;
			vnode_writedone(vp);
			nfs_node_lock_force(np);
			np-&gt;n_numoutput--;
			nfs_node_unlock(np);
			<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; nfs_mount_state_error_should_restart(error)) {
				lck_mtx_lock(&amp;nmp-&gt;nm_lock);
				<span class="enscript-keyword">if</span> ((error != NFSERR_GRACE) &amp;&amp; (stategenid == nmp-&gt;nm_stategenid)) {
					NP(np, <span class="enscript-string">&quot;nfs_vnop_pageout: error %d, initiating recovery&quot;</span>, error);
					nfs_need_recover(nmp, error);
				}
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
				restart = 1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">cancel</span>;
			}
			<span class="enscript-keyword">if</span> (error) {
				FSDBG(323, rxoffset, rxsize, error, -1);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (!wverfset) {
				wverf = wverf2;
				wverfset = 1;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wverf != wverf2) {
				<span class="enscript-comment">/* verifier changed, so we need to restart all the writes */</span>
				vrestart = 1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">cancel</span>;
			}
			<span class="enscript-comment">/* Retain the lowest commitment level returned. */</span>
			<span class="enscript-keyword">if</span> (iomode &lt; commit)
				commit = iomode;
			rxaddr += iosize;	
			rxoffset += iosize;	
			rxsize -= iosize;
			remsize -= iosize;
			<span class="enscript-keyword">if</span> (remsize &gt; 0) {
				<span class="enscript-comment">/* need to try sending the remainder */</span>
				iosize = remsize;
				uio_reset(auio, rxoffset, UIO_SYSSPACE, UIO_WRITE);
				uio_addiov(auio, CAST_USER_ADDR_T(rxaddr), remsize);
				iomode = NFS_WRITE_UNSTABLE;
				error = nfs_write_rpc2(np, auio, thd, cred, &amp;iomode, &amp;wverf2);
				<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; nfs_mount_state_error_should_restart(error)) {
					NP(np, <span class="enscript-string">&quot;nfs_vnop_pageout: restart: error %d&quot;</span>, error);
					lck_mtx_lock(&amp;nmp-&gt;nm_lock);
					<span class="enscript-keyword">if</span> ((error != NFSERR_GRACE) &amp;&amp; (stategenid == nmp-&gt;nm_stategenid)) {
						NP(np, <span class="enscript-string">&quot;nfs_vnop_pageout: error %d, initiating recovery&quot;</span>, error);
						nfs_need_recover(nmp, error);
					}
					lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
					restart = 1;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">cancel</span>;
				}
				<span class="enscript-keyword">if</span> (error) {
					FSDBG(323, rxoffset, rxsize, error, -1);
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-keyword">if</span> (wverf != wverf2) {
					<span class="enscript-comment">/* verifier changed, so we need to restart all the writes */</span>
					vrestart = 1;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">cancel</span>;
				}
				<span class="enscript-keyword">if</span> (iomode &lt; commit)
					commit = iomode;
				rxaddr += iosize;	
				rxoffset += iosize;	
				rxsize -= iosize;
			}
			<span class="enscript-keyword">if</span> (txsize)
				<span class="enscript-keyword">break</span>;
		}
	} <span class="enscript-keyword">while</span> (!error &amp;&amp; (txsize || rxsize));

	vrestart = 0;

	<span class="enscript-keyword">if</span> (!error &amp;&amp; (commit != NFS_WRITE_FILESYNC)) {
		error = nmp-&gt;nm_funcs-&gt;nf_commit_rpc(np, f_offset, xsize, cred, wverf);
		<span class="enscript-keyword">if</span> (error == NFSERR_STALEWRITEVERF) {
			vrestart = 1;
			error = EIO;
		}
	}

	<span class="enscript-keyword">if</span> (error) {
<span class="enscript-reference">cancel</span>:
		<span class="enscript-comment">/* cancel any outstanding requests */</span>
		<span class="enscript-keyword">while</span> (req[nextwait]) {
			nfs_request_async_cancel(req[nextwait]);
			req[nextwait] = NULL;
			nextwait = (nextwait + 1) % MAXPAGINGREQS;
			vnode_writedone(vp);
			nfs_node_lock_force(np);
			np-&gt;n_numoutput--;
			nfs_node_unlock(np);
		}
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
			error = EIO;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (vrestart) {
				<span class="enscript-keyword">if</span> (++vrestarts &lt;= 100) <span class="enscript-comment">/* guard against no progress */</span>
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
				NP(np, <span class="enscript-string">&quot;nfs_pageout: too many restarts, aborting&quot;</span>);
				FSDBG(323, f_offset, xsize, ERESTART, -1);
			}
			<span class="enscript-keyword">if</span> (restart) {
				<span class="enscript-keyword">if</span> (restarts &lt;= nfs_mount_state_max_restarts(nmp)) { <span class="enscript-comment">/* guard against no progress */</span>
					<span class="enscript-keyword">if</span> (error == NFSERR_GRACE)
						tsleep(&amp;nmp-&gt;nm_state, (PZERO-1), <span class="enscript-string">&quot;nfsgrace&quot;</span>, 2*hz);
					<span class="enscript-keyword">if</span> (!(error = nfs_mount_state_wait_for_recovery(nmp)))
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
				} <span class="enscript-keyword">else</span> {
					NP(np, <span class="enscript-string">&quot;nfs_pageout: too many restarts, aborting&quot;</span>);
					FSDBG(323, f_offset, xsize, ERESTART, -1);
				}
			}
		}
	}

	ubc_upl_unmap(pl);

	<span class="enscript-comment">/*
	 * We've had several different solutions on what to do when the pageout
	 * gets an error. If we don't handle it, and return an error to the
	 * caller, vm, it will retry . This can end in endless looping
	 * between vm and here doing retries of the same page. Doing a dump
	 * back to vm, will get it out of vm's knowledge and we lose whatever
	 * data existed. This is risky, but in some cases necessary. For
	 * example, the initial fix here was to do that for ESTALE. In that case
	 * the server is telling us that the file is no longer the same. We
	 * would not want to keep paging out to that. We also saw some 151
	 * errors from Auspex server and NFSv3 can return errors higher than
	 * ELAST. Those along with NFS known server errors we will &quot;dump&quot; from
	 * vm.  Errors we don't expect to occur, we dump and log for further
	 * analysis. Errors that could be transient, networking ones,
	 * we let vm &quot;retry&quot;. Lastly, errors that we retry, but may have potential
	 * to storm the network, we &quot;retrywithsleep&quot;. &quot;sever&quot; will be used in
	 * in the future to dump all pages of object for cases like ESTALE.
	 * All this is the basis for the states returned and first guesses on
	 * error handling. Tweaking expected as more statistics are gathered.
	 * Note, in the long run we may need another more robust solution to
	 * have some kind of persistant store when the vm cannot dump nor keep
	 * retrying as a solution, but this would be a file architectural change
	 */</span>
	<span class="enscript-keyword">if</span> (!nofreeupl) { <span class="enscript-comment">/* otherwise stacked file system has to handle this */</span>
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-type">int</span> abortflags = 0;
			<span class="enscript-type">char</span> action = nfs_pageouterrorhandler(error);
			
			<span class="enscript-keyword">switch</span> (action) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">DUMP</span>:
					abortflags = UPL_ABORT_DUMP_PAGES|UPL_ABORT_FREE_ON_EMPTY;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">DUMPANDLOG</span>:
					abortflags = UPL_ABORT_DUMP_PAGES|UPL_ABORT_FREE_ON_EMPTY;
					<span class="enscript-keyword">if</span> (error &lt;= NFS_ELAST) {
						<span class="enscript-keyword">if</span> ((errorcount[error] % 100) == 0)
							NP(np, <span class="enscript-string">&quot;nfs_pageout: unexpected error %d. dumping vm page&quot;</span>, error);
						errorcount[error]++;
					}
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RETRY</span>:
					abortflags = UPL_ABORT_FREE_ON_EMPTY;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">SEVER</span>: <span class="enscript-comment">/* not implemented */</span>
				<span class="enscript-reference">default</span>:
					NP(np, <span class="enscript-string">&quot;nfs_pageout: action %d not expected&quot;</span>, action);
					<span class="enscript-keyword">break</span>;
			}

			ubc_upl_abort_range(pl, pl_offset, pgsize, abortflags);
			<span class="enscript-comment">/* return error in all cases above */</span>

		} <span class="enscript-keyword">else</span> {
			ubc_upl_commit_range(pl, pl_offset, pgsize,
					     UPL_COMMIT_CLEAR_DIRTY |
					     UPL_COMMIT_FREE_ON_EMPTY);
		}
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* Blktooff derives file offset given a logical block number */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_blktooff</span>(
	<span class="enscript-type">struct</span> vnop_blktooff_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		daddr64_t a_lblkno;
		off_t *a_offset;
	} */</span> *ap)
{
	<span class="enscript-type">int</span> biosize;
	vnode_t vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> nfsmount *nmp = VTONMP(vp);

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	biosize = nmp-&gt;nm_biosize;

	*ap-&gt;a_offset = (off_t)(ap-&gt;a_lblkno * biosize);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_offtoblk</span>(
	<span class="enscript-type">struct</span> vnop_offtoblk_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		off_t a_offset;
		daddr64_t *a_lblkno;
	} */</span> *ap)
{
	<span class="enscript-type">int</span> biosize;
	vnode_t vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> nfsmount *nmp = VTONMP(vp);

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	biosize = nmp-&gt;nm_biosize;

	*ap-&gt;a_lblkno = (daddr64_t)(ap-&gt;a_offset / biosize);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * vnode change monitoring
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_monitor</span>(
	<span class="enscript-type">struct</span> vnop_monitor_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		uint32_t a_events;
		uint32_t a_flags;
		void *a_handle;
		vfs_context_t a_context;
	} */</span> *ap)
{
	nfsnode_t np = VTONFS(ap-&gt;a_vp);
	<span class="enscript-type">struct</span> nfsmount *nmp = VTONMP(ap-&gt;a_vp);
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-comment">/* make sure that the vnode's monitoring status is up to date */</span>
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (vnode_ismonitored(ap-&gt;a_vp)) {
		<span class="enscript-comment">/* This vnode is currently being monitored, make sure we're tracking it. */</span>
		<span class="enscript-keyword">if</span> (np-&gt;n_monlink.le_next == NFSNOLIST) {
			LIST_INSERT_HEAD(&amp;nmp-&gt;nm_monlist, np, n_monlink);
			nfs_mount_sock_thread_wake(nmp);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* This vnode is no longer being monitored, make sure we're not tracking it. */</span>
		<span class="enscript-comment">/* Wait for any in-progress getattr to complete first. */</span>
		<span class="enscript-keyword">while</span> (np-&gt;n_mflag &amp; NMMONSCANINPROG) {
			<span class="enscript-type">struct</span> timespec ts = { 1, 0 };
			np-&gt;n_mflag |= NMMONSCANWANT;
			msleep(&amp;np-&gt;n_mflag, &amp;nmp-&gt;nm_lock, PZERO-1, <span class="enscript-string">&quot;nfswaitmonscan&quot;</span>, &amp;ts);
		}
		<span class="enscript-keyword">if</span> (np-&gt;n_monlink.le_next != NFSNOLIST) {
			LIST_REMOVE(np, n_monlink);
			np-&gt;n_monlink.le_next = NFSNOLIST;
		}
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Send a vnode notification for the given events.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_vnode_notify</span>(nfsnode_t np, uint32_t events)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(np);
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">struct</span> vnode_attr vattr, *vap = NULL;
	<span class="enscript-type">struct</span> timeval now;

	microuptime(&amp;now);
	<span class="enscript-keyword">if</span> ((np-&gt;n_evtstamp == now.tv_sec) || !nmp) {
		<span class="enscript-comment">/* delay sending this notify */</span>
		np-&gt;n_events |= events;
		<span class="enscript-keyword">return</span>;
	}
	events |= np-&gt;n_events;
	np-&gt;n_events = 0;
	np-&gt;n_evtstamp = now.tv_sec;

	vfs_get_notify_attributes(&amp;vattr);
	<span class="enscript-keyword">if</span> (!nfs_getattrcache(np, &amp;nvattr, 0)) {
		vap = &amp;vattr;
		VATTR_INIT(vap);
		VATTR_RETURN(vap, va_fsid, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_fsid.val[0]);
		VATTR_RETURN(vap, va_fileid, nvattr.nva_fileid);
		VATTR_RETURN(vap, va_mode, nvattr.nva_mode);
		VATTR_RETURN(vap, va_uid, nvattr.nva_uid);
		VATTR_RETURN(vap, va_gid, nvattr.nva_gid);
		VATTR_RETURN(vap, va_nlink, nvattr.nva_nlink);
	}
	vnode_notify(NFSTOV(np), events, vap);
}
</pre>
<hr />
</body></html>