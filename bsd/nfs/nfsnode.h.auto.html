<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nfsnode.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nfsnode.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfsnode.h	8.9 (Berkeley) 5/14/95
 * FreeBSD-Id: nfsnode.h,v 1.24 1997/10/28 14:06:25 bde Exp $
 */</span>


#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_NFS_NFSNODE_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_NFS_NFSNODE_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE_API_PRIVATE</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_NFS_NFS_H_</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs.h&gt;</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>

<span class="enscript-comment">/*
 * Silly rename structure that hangs off the nfsnode until the name
 * can be removed by nfs_vnop_inactive()
 */</span>
<span class="enscript-type">struct</span> nfs_sillyrename {
	kauth_cred_t	nsr_cred;
	<span class="enscript-type">struct</span> nfsnode	*nsr_dnp;
	<span class="enscript-type">int</span>		nsr_namlen;
	<span class="enscript-type">char</span>		nsr_name[20];
};

<span class="enscript-comment">/*
 * The nfsbuf is the nfs equivalent to a struct buf.
 */</span>
<span class="enscript-type">struct</span> nfsbuf {
	LIST_ENTRY(nfsbuf)	nb_hash;	<span class="enscript-comment">/* hash chain */</span>
	LIST_ENTRY(nfsbuf)	nb_vnbufs;	<span class="enscript-comment">/* nfsnode's nfsbuf chain */</span>
	TAILQ_ENTRY(nfsbuf)	nb_free;	<span class="enscript-comment">/* free list position if not active. */</span>
	<span class="enscript-type">volatile</span> uint32_t	nb_flags;	<span class="enscript-comment">/* NB_* flags. */</span>
	<span class="enscript-type">volatile</span> uint32_t	nb_lflags;	<span class="enscript-comment">/* NBL_* flags. */</span>
	<span class="enscript-type">volatile</span> uint32_t	nb_refs;	<span class="enscript-comment">/* outstanding references. */</span>
	uint32_t		nb_bufsize;	<span class="enscript-comment">/* buffer size */</span>
	daddr64_t		nb_lblkno;	<span class="enscript-comment">/* logical block number. */</span>
	uint64_t		nb_verf;	<span class="enscript-comment">/* V3 write verifier */</span>
	<span class="enscript-type">int</span>			nb_commitlevel;	<span class="enscript-comment">/* lowest write commit level */</span>
	time_t			nb_timestamp;	<span class="enscript-comment">/* buffer timestamp */</span>
	<span class="enscript-type">int</span>			nb_error;	<span class="enscript-comment">/* errno value. */</span>
	u_int32_t		nb_valid;	<span class="enscript-comment">/* valid pages in buf */</span>
	u_int32_t		nb_dirty;	<span class="enscript-comment">/* dirty pages in buf */</span>
	<span class="enscript-type">int</span>			nb_validoff;	<span class="enscript-comment">/* offset in buffer of valid region. */</span>
	<span class="enscript-type">int</span>			nb_validend;	<span class="enscript-comment">/* offset of end of valid region. */</span>
	<span class="enscript-type">int</span>			nb_dirtyoff;	<span class="enscript-comment">/* offset in buffer of dirty region. */</span>
	<span class="enscript-type">int</span>			nb_dirtyend;	<span class="enscript-comment">/* offset of end of dirty region. */</span>
	<span class="enscript-type">int</span>			nb_offio;	<span class="enscript-comment">/* offset in buffer of I/O region. */</span>
	<span class="enscript-type">int</span>			nb_endio;	<span class="enscript-comment">/* offset of end of I/O region. */</span>
	<span class="enscript-type">int</span>			nb_rpcs;	<span class="enscript-comment">/* Count of RPCs remaining for this buffer. */</span>
	caddr_t			nb_data;	<span class="enscript-comment">/* mapped buffer */</span>
	nfsnode_t		nb_np;		<span class="enscript-comment">/* nfsnode buffer belongs to */</span>
	kauth_cred_t		nb_rcred;	<span class="enscript-comment">/* read credentials reference */</span>
	kauth_cred_t		nb_wcred;	<span class="enscript-comment">/* write credentials reference */</span>
	<span class="enscript-type">void</span> *			nb_pagelist;	<span class="enscript-comment">/* upl */</span>
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MAXBSIZE</span>	(32 * PAGE_SIZE)	<span class="enscript-comment">/* valid/dirty page masks limit buffer size */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_A_LOT_OF_NEEDCOMMITS</span>	256			<span class="enscript-comment">/* max# uncommitted buffers for a node */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_A_LOT_OF_DELAYED_WRITES</span>	MAX(nfsbufcnt/8,512)	<span class="enscript-comment">/* max# &quot;delwri&quot; buffers in system */</span>

<span class="enscript-comment">/*
 * These flags are kept in b_lflags...
 * nfs_buf_mutex must be held before examining/updating
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NBL_BUSY</span>	0x00000001	<span class="enscript-comment">/* I/O in progress. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NBL_WANTED</span>	0x00000002	<span class="enscript-comment">/* Process wants this buffer. */</span>

<span class="enscript-comment">/*
 * These flags are kept in nb_flags and they're (purposefully)
 * very similar to the B_* flags for struct buf.
 * nfs_buf_mutex is not needed to examine/update these.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_STALEWVERF</span>	0x00000001	<span class="enscript-comment">/* write verifier changed on us */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_NEEDCOMMIT</span>	0x00000002	<span class="enscript-comment">/* buffer needs to be committed */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_ASYNC</span>	0x00000004	<span class="enscript-comment">/* Start I/O, do not wait. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_CACHE</span>	0x00000020	<span class="enscript-comment">/* buffer data found in the cache */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_STABLE</span>	0x00000040	<span class="enscript-comment">/* write FILESYNC not UNSTABLE */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_DELWRI</span>	0x00000080	<span class="enscript-comment">/* delayed write: dirty range needs to be written */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_DONE</span>		0x00000200	<span class="enscript-comment">/* I/O completed. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_EINTR</span>	0x00000400	<span class="enscript-comment">/* I/O was interrupted */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_ERROR</span>	0x00000800	<span class="enscript-comment">/* I/O error occurred. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_INVAL</span>	0x00002000	<span class="enscript-comment">/* Does not contain valid info. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_NCRDAHEAD</span>	0x00004000	<span class="enscript-comment">/* &quot;nocache readahead&quot; data */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_NOCACHE</span>	0x00008000	<span class="enscript-comment">/* Do not cache block after use. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_WRITE</span>	0x00000000	<span class="enscript-comment">/* Write buffer (pseudo flag). */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_READ</span>		0x00100000	<span class="enscript-comment">/* Read buffer. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_MULTASYNCRPC</span>	0x00200000	<span class="enscript-comment">/* multiple async RPCs issued for buffer */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_PAGELIST</span>	0x00400000	<span class="enscript-comment">/* Buffer describes pagelist I/O. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_WRITEINPROG</span>	0x01000000	<span class="enscript-comment">/* Write in progress. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NB_META</span>		0x40000000	<span class="enscript-comment">/* buffer contains meta-data. */</span>

<span class="enscript-comment">/* Flags for operation type in nfs_buf_get() */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NBLK_READ</span>	0x00000001	<span class="enscript-comment">/* buffer for read */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NBLK_WRITE</span>	0x00000002	<span class="enscript-comment">/* buffer for write */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NBLK_META</span>	0x00000004	<span class="enscript-comment">/* buffer for metadata */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NBLK_OPMASK</span>	0x00000007	<span class="enscript-comment">/* operation mask */</span>
<span class="enscript-comment">/* modifiers for above flags... */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBLK_NOWAIT</span>	0x40000000	<span class="enscript-comment">/* don't wait on busy buffer */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBLK_ONLYVALID</span>	0x80000000	<span class="enscript-comment">/* only return cached buffer */</span>

<span class="enscript-comment">/* These flags are used for nfsbuf iterating */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBI_ITER</span>		0x01	<span class="enscript-comment">/* iteration in progress */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBI_ITERWANT</span>		0x02	<span class="enscript-comment">/* waiting to iterate */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBI_CLEAN</span>		0x04	<span class="enscript-comment">/* requesting clean buffers */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBI_DIRTY</span>		0x08	<span class="enscript-comment">/* requesting dirty buffers */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBI_NOWAIT</span>		0x10	<span class="enscript-comment">/* don't block on NBI_ITER */</span>

<span class="enscript-comment">/* Flags for nfs_buf_acquire */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBAC_NOWAIT</span>		0x01	<span class="enscript-comment">/* Don't wait if buffer is busy */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NBAC_REMOVE</span>		0x02	<span class="enscript-comment">/* Remove from free list once buffer is acquired */</span>

<span class="enscript-comment">/* some convenience macros...  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NBOFF</span>(BP)			((off_t)(BP)-&gt;nb_lblkno * (off_t)(BP)-&gt;nb_bufsize)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NBPGVALID</span>(BP,P)			(((BP)-&gt;nb_valid &gt;&gt; (P)) &amp; 0x1)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NBPGDIRTY</span>(BP,P)			(((BP)-&gt;nb_dirty &gt;&gt; (P)) &amp; 0x1)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NBPGVALID_SET</span>(BP,P)		((BP)-&gt;nb_valid |= (1 &lt;&lt; (P)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NBPGDIRTY_SET</span>(BP,P)		((BP)-&gt;nb_dirty |= (1 &lt;&lt; (P)))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NBUFSTAMPVALID</span>(BP)		((BP)-&gt;nb_timestamp != ~0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NBUFSTAMPINVALIDATE</span>(BP)		((BP)-&gt;nb_timestamp = ~0)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_BUF_MAP</span>(BP) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (!(BP)-&gt;nb_data &amp;&amp; nfs_buf_map(BP)) \
			panic(<span class="enscript-string">&quot;nfs_buf_map failed&quot;</span>); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-function-name">LIST_HEAD</span>(nfsbuflists, nfsbuf);
<span class="enscript-function-name">TAILQ_HEAD</span>(nfsbuffreehead, nfsbuf);

<span class="enscript-type">extern</span> lck_mtx_t *nfs_buf_mutex;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfsbufcnt, nfsbufmin, nfsbufmax, nfsbufmetacnt, nfsbufmetamax;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfsbuffreecnt, nfsbuffreemetacnt, nfsbufdelwricnt, nfsneedbuffer;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfs_nbdwrite;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> nfsbuffreehead nfsbuffree, nfsbufdelwri;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFSBUFDEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFSBUFCNTCHK</span>() \
	<span class="enscript-keyword">do</span> { \
	<span class="enscript-keyword">if</span> (	(nfsbufcnt &lt; 0) || \
		(nfsbufcnt &gt; nfsbufmax) || \
		(nfsbufmetacnt &lt; 0) || \
		(nfsbufmetacnt &gt; nfsbufmetamax) || \
		(nfsbufmetacnt &gt; nfsbufcnt) || \
		(nfsbuffreecnt &lt; 0) || \
		(nfsbuffreecnt &gt; nfsbufmax) || \
		(nfsbuffreecnt &gt; nfsbufcnt) || \
		(nfsbuffreemetacnt &lt; 0) || \
		(nfsbuffreemetacnt &gt; nfsbufmax) || \
		(nfsbuffreemetacnt &gt; nfsbufcnt) || \
		(nfsbuffreemetacnt &gt; nfsbufmetamax) || \
		(nfsbuffreemetacnt &gt; nfsbufmetacnt) || \
		(nfsbufdelwricnt &lt; 0) || \
		(nfsbufdelwricnt &gt; nfsbufmax) || \
		(nfsbufdelwricnt &gt; nfsbufcnt) || \
		(nfs_nbdwrite &lt; 0) || \
		(nfs_nbdwrite &gt; nfsbufcnt) || \
		0) \
		panic(<span class="enscript-string">&quot;nfsbuf count error: max %d meta %d cnt %d meta %d free %d meta %d delwr %d bdw %d\n&quot;</span>, \
			nfsbufmax, nfsbufmetamax, nfsbufcnt, nfsbufmetacnt, nfsbuffreecnt, nfsbuffreemetacnt, \
			nfsbufdelwricnt, nfs_nbdwrite); \
	} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFSBUFCNTCHK</span>()
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * NFS directory buffer
 *
 * Each buffer for a directory consists of:
 *
 * - a small header
 * - a packed list of direntry structures
 *   (if RDIRPLUS is enabled, a file handle and attrstamp are
 *   packed after the direntry name.)
 * - free/unused space
 * - if RDIRPLUS is enabled, an array of attributes
 *   that is indexed backwards from the end of the buffer.
 */</span>
<span class="enscript-type">struct</span> nfs_dir_buf_header {
	uint16_t	ndbh_flags;	<span class="enscript-comment">/* flags (see below) */</span>
	uint16_t	ndbh_count;	<span class="enscript-comment">/* # of entries */</span>
	uint32_t	ndbh_entry_end;	<span class="enscript-comment">/* end offset of direntry data */</span>
	uint32_t	ndbh_ncgen;	<span class="enscript-comment">/* name cache generation# */</span>
	uint32_t	ndbh_pad;	<span class="enscript-comment">/* reserved */</span>
};
<span class="enscript-comment">/* ndbh_flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NDB_FULL</span>	0x0001	<span class="enscript-comment">/* buffer has been filled */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NDB_EOF</span>		0x0002	<span class="enscript-comment">/* buffer contains EOF */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NDB_PLUS</span>	0x0004	<span class="enscript-comment">/* buffer contains RDIRPLUS data */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_DIR_BUF_FIRST_DIRENTRY</span>(BP) \
	((<span class="enscript-type">struct</span> direntry*)((<span class="enscript-type">char</span>*)((BP)-&gt;nb_data) + <span class="enscript-keyword">sizeof</span>(*ndbhp)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_DIR_BUF_NVATTR</span>(BP, IDX) \
	(&amp;((<span class="enscript-type">struct</span> nfs_vattr*)((<span class="enscript-type">char</span>*)((BP)-&gt;nb_data) + (BP)-&gt;nb_bufsize))[-((IDX)+1)])
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_DIRENTRY_LEN</span>(namlen) \
	((<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> direntry) + (namlen) - (MAXPATHLEN-1) + 7) &amp; ~7)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_DIRENT_LEN</span>(namlen) \
	((<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> dirent) - (NAME_MAX+1)) + (((namlen) + 1 + 3) &amp;~ 3))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_DIRENTRY_NEXT</span>(DP) \
	((<span class="enscript-type">struct</span> direntry*)((<span class="enscript-type">char</span>*)(DP) + (DP)-&gt;d_reclen))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_DIR_COOKIE_POTENTIALLY_TRUNCATED</span>(C) \
	((C) &amp;&amp; ((((C) &gt;&gt; 32) == 0) || (((C) &amp; 0x80000000ULL) &amp;&amp; (((C) &gt;&gt; 32) == 0xffffffff))))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_DIR_COOKIE_SAME32</span>(C1, C2) \
	(((C1) &amp; 0xffffffffULL) == ((C2) &amp; 0xffffffffULL))

<span class="enscript-comment">/*
 * NFS directory cookie cache
 *
 * This structure is used to cache cookie-to-buffer mappings for
 * cookies recently returned from READDIR.  The entries are kept in an
 * array.  The most-recently-used (MRU) list is headed by the entry at
 * index &quot;mru&quot;.  The index of the next entry in the list is kept in the
 * &quot;next&quot; array.  (An index value of -1 marks an invalid entry.)
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSNUMCOOKIES</span>		14
<span class="enscript-type">struct</span> nfsdmap {
	int8_t		free;			<span class="enscript-comment">/* next unused slot */</span>
	int8_t		mru;			<span class="enscript-comment">/* head of MRU list */</span>
	int8_t		next[NFSNUMCOOKIES];	<span class="enscript-comment">/* MRU list links */</span>
	<span class="enscript-type">struct</span> {
	    uint64_t	key;			<span class="enscript-comment">/* cookie */</span>
	    uint64_t	lbn;			<span class="enscript-comment">/* lbn of buffer */</span>
	} cookies[NFSNUMCOOKIES];		<span class="enscript-comment">/* MRU list entries */</span>
};

<span class="enscript-comment">/*
 * NFS vnode attribute structure
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSTIME_ACCESS</span>	0	<span class="enscript-comment">/* time of last access */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSTIME_MODIFY</span>	1	<span class="enscript-comment">/* time of last modification */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSTIME_CHANGE</span>	2	<span class="enscript-comment">/* time file changed */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSTIME_CREATE</span>	3	<span class="enscript-comment">/* time file created */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSTIME_BACKUP</span>	4	<span class="enscript-comment">/* time of last backup */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSTIME_COUNT</span>	5

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_COMPARE_MTIME</span>(TVP, NVAP, CMP) \
	(((TVP)-&gt;tv_sec == (NVAP)-&gt;nva_timesec[NFSTIME_MODIFY]) ?	\
	 ((TVP)-&gt;tv_nsec CMP (NVAP)-&gt;nva_timensec[NFSTIME_MODIFY]) :	\
	 ((TVP)-&gt;tv_sec CMP (NVAP)-&gt;nva_timesec[NFSTIME_MODIFY]))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_COPY_TIME</span>(TVP, NVAP, WHICH) \
	<span class="enscript-keyword">do</span> { \
	(TVP)-&gt;tv_sec = (NVAP)-&gt;nva_timesec[NFSTIME_##WHICH]; \
	(TVP)-&gt;tv_nsec = (NVAP)-&gt;nva_timensec[NFSTIME_##WHICH]; \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">struct</span> nfs_vattr {
	<span class="enscript-type">enum</span> vtype	nva_type;	<span class="enscript-comment">/* vnode type (for create) */</span>
	uint32_t	nva_mode;	<span class="enscript-comment">/* file's access mode (and type) */</span>
	uid_t		nva_uid;	<span class="enscript-comment">/* owner user id */</span>
	gid_t		nva_gid;	<span class="enscript-comment">/* owner group id */</span>
	guid_t		nva_uuuid;	<span class="enscript-comment">/* owner user UUID */</span>
	guid_t		nva_guuid;	<span class="enscript-comment">/* owner group UUID */</span>
	kauth_acl_t	nva_acl;	<span class="enscript-comment">/* access control list */</span>
	nfs_specdata	nva_rawdev;	<span class="enscript-comment">/* device the special file represents */</span>
	uint32_t	nva_flags;	<span class="enscript-comment">/* file flags (see below) */</span>
	uint32_t	nva_maxlink;	<span class="enscript-comment">/* maximum # of links (v4) */</span>
	uint64_t	nva_nlink;	<span class="enscript-comment">/* number of references to file */</span>
	uint64_t	nva_fileid;	<span class="enscript-comment">/* file id */</span>
	nfs_fsid	nva_fsid;	<span class="enscript-comment">/* file system id */</span>
	uint64_t	nva_size;	<span class="enscript-comment">/* file size in bytes */</span>
	uint64_t	nva_bytes;	<span class="enscript-comment">/* bytes of disk space held by file */</span>
	uint64_t	nva_change;	<span class="enscript-comment">/* change attribute */</span>
	int64_t		nva_timesec[NFSTIME_COUNT];
	int32_t		nva_timensec[NFSTIME_COUNT];
	uint32_t 	nva_bitmap[NFS_ATTR_BITMAP_LEN]; <span class="enscript-comment">/* attributes that are valid */</span>
};

<span class="enscript-comment">/* nva_flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FFLAG_ARCHIVED</span>		0x0001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FFLAG_HIDDEN</span>		0x0002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FFLAG_HAS_NAMED_ATTRS</span>	0x0004	<span class="enscript-comment">/* file has named attributes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FFLAG_TRIGGER</span>		0x0008	<span class="enscript-comment">/* node is a trigger/mirror mount point */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FFLAG_TRIGGER_REFERRAL</span>	0x0010	<span class="enscript-comment">/* trigger is a referral */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FFLAG_IS_ATTR</span>		0x8000	<span class="enscript-comment">/* file is a named attribute file/directory */</span>

<span class="enscript-comment">/* flags for nfs_getattr() */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NGA_CACHED</span>	0x0001	<span class="enscript-comment">/* use cached attributes (if still valid) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NGA_UNCACHED</span>	0x0002	<span class="enscript-comment">/* fetch new attributes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NGA_ACL</span>		0x0004	<span class="enscript-comment">/* fetch ACL */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NGA_MONITOR</span>	0x0008	<span class="enscript-comment">/* vnode monitor attr update poll */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NGA_SOFT</span>	0x0010	<span class="enscript-comment">/* use cached attributes if ETIMEOUT */</span>

<span class="enscript-comment">/* macros for initting/cleaning up nfs_vattr structures */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NVATTR_INIT</span>(NVAP) \
	<span class="enscript-keyword">do</span> { \
		NFS_CLEAR_ATTRIBUTES((NVAP)-&gt;nva_bitmap); \
		(NVAP)-&gt;nva_flags = 0; \
		(NVAP)-&gt;nva_acl = NULL; \
	} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NVATTR_CLEANUP</span>(NVAP) \
	<span class="enscript-keyword">do</span> { \
		NFS_CLEAR_ATTRIBUTES((NVAP)-&gt;nva_bitmap); \
		<span class="enscript-keyword">if</span> ((NVAP)-&gt;nva_acl) { \
			kauth_acl_free((NVAP)-&gt;nva_acl); \
			(NVAP)-&gt;nva_acl = NULL; \
		} \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * macros for detecting node changes
 *
 * These macros help us determine if a file has been changed on the server and
 * thus whether or not we need to invalidate any cached data.
 *
 * For NFSv2/v3, the modification time is used.
 * For NFSv4, the change attribute is used.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_CHANGED</span>(VERS, NP, NVAP) \
		(((VERS) &gt;= NFS_VER4) ? \
			((NP)-&gt;n_change != (NVAP)-&gt;nva_change) : \
			NFS_COMPARE_MTIME(&amp;(NP)-&gt;n_mtime, (NVAP), !=))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_CHANGED_NC</span>(VERS, NP, NVAP) \
		(((VERS) &gt;= NFS_VER4) ? \
			((NP)-&gt;n_ncchange != (NVAP)-&gt;nva_change) : \
			NFS_COMPARE_MTIME(&amp;(NP)-&gt;n_ncmtime, (NVAP), !=))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_CHANGED_UPDATE</span>(VERS, NP, NVAP) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> ((VERS) &gt;= NFS_VER4) \
			(NP)-&gt;n_change = (NVAP)-&gt;nva_change; \
		<span class="enscript-keyword">else</span> \
			NFS_COPY_TIME(&amp;(NP)-&gt;n_mtime, (NVAP), MODIFY); \
	} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_CHANGED_UPDATE_NC</span>(VERS, NP, NVAP) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> ((VERS) &gt;= NFS_VER4) \
			(NP)-&gt;n_ncchange = (NVAP)-&gt;nva_change; \
		<span class="enscript-keyword">else</span> \
			NFS_COPY_TIME(&amp;(NP)-&gt;n_ncmtime, (NVAP), MODIFY); \
	} <span class="enscript-keyword">while</span> (0)


<span class="enscript-type">extern</span> lck_grp_t *nfs_open_grp;
<span class="enscript-type">extern</span> uint32_t nfs_open_owner_seqnum, nfs_lock_owner_seqnum;

<span class="enscript-comment">/*
 * NFSv4 open owner structure - one per cred per mount
 */</span>
<span class="enscript-type">struct</span> nfs_open_owner {
	TAILQ_ENTRY(nfs_open_owner)	noo_link;	<span class="enscript-comment">/* List of open owners (on mount) */</span>
	lck_mtx_t			noo_lock;	<span class="enscript-comment">/* owner mutex */</span>
	<span class="enscript-type">struct</span> nfsmount *		noo_mount;	<span class="enscript-comment">/* NFS mount */</span>
	uint32_t			noo_refcnt;	<span class="enscript-comment">/* # outstanding references */</span>
	uint32_t			noo_flags;	<span class="enscript-comment">/* see below */</span>
	kauth_cred_t			noo_cred;	<span class="enscript-comment">/* credentials of open owner */</span>
	uint32_t			noo_name;	<span class="enscript-comment">/* unique name used otw */</span>
	uint32_t			noo_seqid;	<span class="enscript-comment">/* client-side sequence ID */</span>
	TAILQ_HEAD(,nfs_open_file)	noo_opens;	<span class="enscript-comment">/* list of open files */</span>
};
<span class="enscript-comment">/* noo_flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_OPEN_OWNER_LINK</span>	0x1	<span class="enscript-comment">/* linked into mount's open owner list */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_OPEN_OWNER_BUSY</span>	0x2	<span class="enscript-comment">/* open state-modifying operation in progress */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_OPEN_OWNER_WANT</span>	0x4	<span class="enscript-comment">/* someone else wants to mark busy */</span>

<span class="enscript-comment">/*
 * NFS open file structure - one per open owner per nfsnode
 */</span>
<span class="enscript-type">struct</span> nfs_open_file {
	lck_mtx_t			nof_lock;		<span class="enscript-comment">/* open file mutex */</span>
	TAILQ_ENTRY(nfs_open_file)	nof_link;		<span class="enscript-comment">/* list of open files */</span>
	TAILQ_ENTRY(nfs_open_file)	nof_oolink;		<span class="enscript-comment">/* list of open owner's open files */</span>
	<span class="enscript-type">struct</span> nfs_open_owner *		nof_owner;		<span class="enscript-comment">/* open owner */</span>
	nfsnode_t			nof_np;			<span class="enscript-comment">/* nfsnode this open is for */</span>
	nfs_stateid			nof_stateid;		<span class="enscript-comment">/* open stateid */</span>
	thread_t			nof_creator;		<span class="enscript-comment">/* thread that created file */</span>
	uint32_t			nof_opencnt;		<span class="enscript-comment">/* open file count */</span>
	uint16_t			nof_flags;		<span class="enscript-comment">/* see below */</span>
	uint8_t				nof_access:4;		<span class="enscript-comment">/* access mode for this open */</span>
	uint8_t				nof_deny:4;		<span class="enscript-comment">/* deny mode for this open */</span>
	uint8_t				nof_mmap_access:4;	<span class="enscript-comment">/* mmap open access mode */</span>
	uint8_t				nof_mmap_deny:4;	<span class="enscript-comment">/* mmap open deny mode */</span>
	<span class="enscript-comment">/* counts of access/deny mode open combinations */</span>
	uint32_t			nof_r;			<span class="enscript-comment">/* read opens (deny none) */</span>
	uint32_t			nof_w;			<span class="enscript-comment">/* write opens (deny none) */</span>
	uint32_t			nof_rw;			<span class="enscript-comment">/* read/write opens (deny none) */</span>
	uint32_t			nof_r_dw;		<span class="enscript-comment">/* read deny-write opens */</span>
	<span class="enscript-comment">/* the rest of the counts have a max of 2 (1 for open + 1 for mmap) */</span>
	uint32_t			nof_w_dw:2;		<span class="enscript-comment">/* write deny-write opens (max 2) */</span>
	uint32_t			nof_rw_dw:2;		<span class="enscript-comment">/* read/write deny-write opens (max 2) */</span>
	uint32_t			nof_r_drw:2;		<span class="enscript-comment">/* read deny-read/write opens (max 2) */</span>
	uint32_t			nof_w_drw:2;		<span class="enscript-comment">/* write deny-read/write opens (max 2) */</span>
	uint32_t			nof_rw_drw:2;		<span class="enscript-comment">/* read/write deny-read/write opens (max 2) */</span>
	<span class="enscript-comment">/* counts of DELEGATED access/deny mode open combinations */</span>
	uint32_t			nof_d_w_dw:2;		<span class="enscript-comment">/* write deny-write opens (max 2) */</span>
	uint32_t			nof_d_rw_dw:2;		<span class="enscript-comment">/* read/write deny-write opens (max 2) */</span>
	uint32_t			nof_d_r_drw:2;		<span class="enscript-comment">/* read deny-read/write opens (max 2) */</span>
	uint32_t			nof_d_w_drw:2;		<span class="enscript-comment">/* write deny-read/write opens (max 2) */</span>
	uint32_t			nof_d_rw_drw:2;		<span class="enscript-comment">/* read/write deny-read/write opens (max 2) */</span>
	uint32_t			nof_d_r;		<span class="enscript-comment">/* read opens (deny none) */</span>
	uint32_t			nof_d_w;		<span class="enscript-comment">/* write opens (deny none) */</span>
	uint32_t			nof_d_rw;		<span class="enscript-comment">/* read/write opens (deny none) */</span>
	uint32_t			nof_d_r_dw;		<span class="enscript-comment">/* read deny-write opens */</span>
};
<span class="enscript-comment">/* nof_flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_OPEN_FILE_BUSY</span>	0x0001	<span class="enscript-comment">/* open state-modifying operation in progress */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_OPEN_FILE_WANT</span>	0x0002	<span class="enscript-comment">/* someone else wants to mark busy */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_OPEN_FILE_CREATE</span>	0x0004	<span class="enscript-comment">/* has an open(RW) from a &quot;CREATE&quot; call */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_OPEN_FILE_NEEDCLOSE</span>	0x0008	<span class="enscript-comment">/* has an open(R) from an (unopen) VNOP_READ or VNOP_MMAP call */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_OPEN_FILE_SETATTR</span>	0x0020	<span class="enscript-comment">/* has an open(W) to perform a SETATTR(size) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_OPEN_FILE_POSIXLOCK</span>	0x0040	<span class="enscript-comment">/* server supports POSIX locking semantics */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_OPEN_FILE_LOST</span>	0x0080	<span class="enscript-comment">/* open state has been lost */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_OPEN_FILE_REOPEN</span>	0x0100	<span class="enscript-comment">/* file needs to be reopened */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_OPEN_FILE_REOPENING</span>	0x0200	<span class="enscript-comment">/* file is being reopened */</span>

<span class="enscript-type">struct</span> nfs_lock_owner;
<span class="enscript-comment">/*
 * NFS file lock
 *
 * Each lock request (pending or granted) has an
 * nfs_file_lock structure representing its state.
 */</span>
<span class="enscript-type">struct</span> nfs_file_lock {
	TAILQ_ENTRY(nfs_file_lock)	nfl_link;	<span class="enscript-comment">/* List of locks on nfsnode */</span>
	TAILQ_ENTRY(nfs_file_lock)	nfl_lolink;	<span class="enscript-comment">/* List of locks held by locker */</span>
	<span class="enscript-type">struct</span> nfs_lock_owner *		nfl_owner;	<span class="enscript-comment">/* lock owner that holds this lock */</span>
	uint64_t			nfl_start;	<span class="enscript-comment">/* starting offset */</span>
	uint64_t			nfl_end;	<span class="enscript-comment">/* ending offset (inclusive) */</span>
	uint32_t			nfl_blockcnt;	<span class="enscript-comment">/* # locks blocked on this lock */</span>
	uint16_t			nfl_flags;	<span class="enscript-comment">/* see below */</span>
	uint8_t				nfl_type;	<span class="enscript-comment">/* lock type: read/write */</span>
};
<span class="enscript-comment">/* nfl_flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FILE_LOCK_ALLOC</span>		0x01	<span class="enscript-comment">/* lock was allocated */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FILE_LOCK_STYLE_POSIX</span>	0x02	<span class="enscript-comment">/* POSIX-style fcntl() lock */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FILE_LOCK_STYLE_FLOCK</span>	0x04	<span class="enscript-comment">/* flock(2)-style lock */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FILE_LOCK_STYLE_MASK</span>	0x06	<span class="enscript-comment">/* lock style mask */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FILE_LOCK_WAIT</span>		0x08	<span class="enscript-comment">/* may block on conflicting locks */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FILE_LOCK_BLOCKED</span>		0x10	<span class="enscript-comment">/* request is blocked */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FILE_LOCK_DEAD</span>		0x20	<span class="enscript-comment">/* lock (request) no longer exists */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FILE_LOCK_DELEGATED</span>		0x40	<span class="enscript-comment">/* lock acquired via delegation */</span>

<span class="enscript-function-name">TAILQ_HEAD</span>(nfs_file_lock_queue, nfs_file_lock);

<span class="enscript-comment">/*
 * Calculate length of lock range given the endpoints.
 * Note that struct flock has &quot;to EOF&quot; reported as 0 but
 * the NFSv4 protocol has &quot;to EOF&quot; reported as UINT64_MAX.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_FLOCK_LENGTH</span>(S, E)	(((E) == UINT64_MAX) ? 0 : ((E) - (S) + 1))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_LOCK_LENGTH</span>(S, E)	(((E) == UINT64_MAX) ? UINT64_MAX : ((E) - (S) + 1))

<span class="enscript-comment">/*
 * NFSv4 lock owner structure - per open owner per process per nfsnode
 *
 * A lock owner is a process + an nfsnode.
 *
 * Note that flock(2) locks technically should have the lock owner be
 * an fglob pointer instead of a process.  However, implementing that
 * correctly would not be trivial.  So, for now, flock(2) locks are
 * essentially treated like whole-file POSIX locks.
 */</span>
<span class="enscript-type">struct</span> nfs_lock_owner {
	lck_mtx_t			nlo_lock;	<span class="enscript-comment">/* owner mutex */</span>
	TAILQ_ENTRY(nfs_lock_owner)	nlo_link;	<span class="enscript-comment">/* List of lock owners (on nfsnode) */</span>
	<span class="enscript-type">struct</span> nfs_open_owner *		nlo_open_owner;	<span class="enscript-comment">/* corresponding open owner */</span>
	<span class="enscript-type">struct</span> nfs_file_lock_queue	nlo_locks;	<span class="enscript-comment">/* list of locks held */</span>
	<span class="enscript-type">struct</span> nfs_file_lock		nlo_alock;	<span class="enscript-comment">/* most lockers will only ever have one */</span>
	<span class="enscript-type">struct</span> timeval			nlo_pid_start;	<span class="enscript-comment">/* Start time of process id */</span>
	pid_t				nlo_pid;	<span class="enscript-comment">/* lock-owning process ID */</span>
	uint32_t			nlo_refcnt;	<span class="enscript-comment">/* # outstanding references */</span>
	uint32_t			nlo_flags;	<span class="enscript-comment">/* see below */</span>
	uint32_t			nlo_name;	<span class="enscript-comment">/* unique name used otw */</span>
	uint32_t			nlo_seqid;	<span class="enscript-comment">/* client-side sequence ID */</span>
	uint32_t			nlo_stategenid;	<span class="enscript-comment">/* mount state generation ID */</span>
	nfs_stateid			nlo_stateid;	<span class="enscript-comment">/* lock stateid */</span>
};
<span class="enscript-comment">/* nlo_flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_LOCK_OWNER_LINK</span>	0x1	<span class="enscript-comment">/* linked into mount's lock owner list */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_LOCK_OWNER_BUSY</span>	0x2	<span class="enscript-comment">/* lock state-modifying operation in progress */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_LOCK_OWNER_WANT</span>	0x4	<span class="enscript-comment">/* someone else wants to mark busy */</span>

<span class="enscript-comment">/*
 * The nfsnode is the NFS equivalent of an inode.
 * There is a unique nfsnode for each NFS vnode.
 * An nfsnode is 'named' by its file handle. (nget/nfs_node.c)
 * NB: Hopefully the current order of the fields is such that everything will
 *     be well aligned and, therefore, tightly packed.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_ACCESS_CACHE_SIZE</span>	3

<span class="enscript-type">struct</span> nfsnode {
	lck_mtx_t		n_lock;		<span class="enscript-comment">/* nfs node lock */</span>
	lck_rw_t		n_datalock;	<span class="enscript-comment">/* nfs node data lock */</span>
	<span class="enscript-type">void</span>			*n_datalockowner;<span class="enscript-comment">/* nfs node data lock owner (exclusive) */</span>
	LIST_ENTRY(nfsnode)	n_hash;		<span class="enscript-comment">/* Hash chain */</span>
	LIST_ENTRY(nfsnode)	n_monlink;	<span class="enscript-comment">/* list of monitored nodes */</span>
	u_quad_t		n_size;		<span class="enscript-comment">/* Current size of file */</span>
	u_quad_t		n_newsize;	<span class="enscript-comment">/* new size of file (pending update) */</span>
	u_int64_t		n_xid;		<span class="enscript-comment">/* last xid to loadattr */</span>
	<span class="enscript-type">struct</span> nfs_vattr	n_vattr;	<span class="enscript-comment">/* Vnode attribute cache */</span>
	time_t			n_attrstamp;	<span class="enscript-comment">/* Attr. cache timestamp */</span>
	time_t			n_aclstamp;	<span class="enscript-comment">/* ACL cache timestamp */</span>
	time_t			n_evtstamp;	<span class="enscript-comment">/* last vnode event timestamp */</span>
	uint32_t		n_events;	<span class="enscript-comment">/* pending vnode events */</span>
	u_int8_t		n_access[NFS_ACCESS_CACHE_SIZE+1];	<span class="enscript-comment">/* ACCESS cache */</span>
	uid_t                   n_accessuid[NFS_ACCESS_CACHE_SIZE];	<span class="enscript-comment">/* credentials having access */</span>
	time_t                  n_accessstamp[NFS_ACCESS_CACHE_SIZE];	<span class="enscript-comment">/* access cache timestamp */</span>
	<span class="enscript-type">union</span> {
	    <span class="enscript-type">struct</span> {
		<span class="enscript-type">struct</span> timespec	n3_mtime;	<span class="enscript-comment">/* Prev modify time. */</span>
		<span class="enscript-type">struct</span> timespec	n3_ncmtime;	<span class="enscript-comment">/* namecache modify time. */</span>
	    } v3;
	    <span class="enscript-type">struct</span> {
		uint64_t	n4_change;	<span class="enscript-comment">/* prev change attribute */</span>
		uint64_t	n4_ncchange;	<span class="enscript-comment">/* namecache change attribute */</span>
		u_char		*n4_attrdirfh;	<span class="enscript-comment">/* associated attr directory fh */</span>
		<span class="enscript-type">struct</span> timeval	n4_lastio;	<span class="enscript-comment">/* time of most recent I/O on attr */</span>
	    } v4;
	} n_un4;
	vnode_t			n_parent;	<span class="enscript-comment">/* this node's parent */</span>
	u_char			*n_fhp;		<span class="enscript-comment">/* NFS File Handle */</span>
	vnode_t			n_vnode;	<span class="enscript-comment">/* associated vnode */</span>
	mount_t			n_mount;	<span class="enscript-comment">/* associated mount (NHINIT) */</span>
	<span class="enscript-type">int</span>			n_error;	<span class="enscript-comment">/* Save write error value */</span>
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> timespec	ns_atim;	<span class="enscript-comment">/* Special file times */</span>
		<span class="enscript-type">struct</span> timespec nl_rltim;	<span class="enscript-comment">/* Time of last readlink */</span>
		daddr64_t	nf_lastread;	<span class="enscript-comment">/* last block# read from (for readahead) */</span>
		uint64_t	nd_cookieverf;	<span class="enscript-comment">/* Cookie verifier (dir only) */</span>
	} n_un1;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> timespec	ns_mtim;	<span class="enscript-comment">/* Special file times */</span>
		daddr64_t	nf_lastrahead;	<span class="enscript-comment">/* last block# read ahead */</span>
		uint64_t	nd_eofcookie;	<span class="enscript-comment">/* Dir. EOF cookie cache */</span>
	} n_un2;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> nfs_sillyrename *nf_silly;<span class="enscript-comment">/* Ptr to silly rename struct */</span>
		<span class="enscript-type">struct</span> nfsdmap *nd_cookiecache; <span class="enscript-comment">/* dir cookie cache */</span>
	} n_un3;
	uint32_t		n_flag;		<span class="enscript-comment">/* node flags */</span>
	u_short			n_fhsize;	<span class="enscript-comment">/* size in bytes, of fh */</span>
	u_short			n_hflag;	<span class="enscript-comment">/* node hash flags */</span>
	u_short			n_bflag;	<span class="enscript-comment">/* node buffer flags */</span>
	u_short			n_mflag;	<span class="enscript-comment">/* node mount flags */</span>
	u_char			n_fh[NFS_SMALLFH];<span class="enscript-comment">/* Small File Handle */</span>
	uint32_t		n_auth;		<span class="enscript-comment">/* security flavor used for this node */</span>
	<span class="enscript-type">struct</span> nfsbuflists	n_cleanblkhd;	<span class="enscript-comment">/* clean blocklist head */</span>
	<span class="enscript-type">struct</span> nfsbuflists	n_dirtyblkhd;	<span class="enscript-comment">/* dirty blocklist head */</span>
	<span class="enscript-type">union</span> {
		<span class="enscript-type">int</span>		nf_wrbusy;	<span class="enscript-comment">/* # threads in write/fsync */</span>
		uint32_t	nd_ncgen;	<span class="enscript-comment">/* dir name cache generation# */</span>
	} n_un5;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">int</span>		nf_needcommitcnt;<span class="enscript-comment">/* # bufs that need committing */</span>
		daddr64_t	nd_lastdbl;	<span class="enscript-comment">/* last dir buf lookup block# */</span>
	} n_un6;
	<span class="enscript-type">int</span>			n_bufiterflags;	<span class="enscript-comment">/* buf iterator flags */</span>
	<span class="enscript-type">union</span> {
		<span class="enscript-type">int</span>		nf_numoutput;	<span class="enscript-comment">/* write I/Os in progress */</span>
		<span class="enscript-type">int</span>		nd_trigseq;	<span class="enscript-comment">/* vnode trigger seq# */</span>
	} n_un7;
	<span class="enscript-comment">/* open state */</span>
	lck_mtx_t		n_openlock;	<span class="enscript-comment">/* nfs node open lock */</span>
	uint32_t		n_openflags;	<span class="enscript-comment">/* open state flags */</span>
	uint32_t		n_openrefcnt;	<span class="enscript-comment">/* # non-file opens */</span>
	TAILQ_HEAD(,nfs_open_file) n_opens;	<span class="enscript-comment">/* list of open files */</span>
	<span class="enscript-comment">/* lock state */</span>
	TAILQ_HEAD(, nfs_lock_owner) n_lock_owners; <span class="enscript-comment">/* list of lock owners */</span>
	<span class="enscript-type">struct</span> nfs_file_lock_queue n_locks;	<span class="enscript-comment">/* list of locks */</span>
	<span class="enscript-comment">/* delegation state */</span>
	nfs_stateid		n_dstateid;	<span class="enscript-comment">/* delegation stateid */</span>
	TAILQ_ENTRY(nfsnode)	n_dlink;	<span class="enscript-comment">/* delegation list link */</span>
	TAILQ_ENTRY(nfsnode)	n_dreturn;	<span class="enscript-comment">/* delegation return list link */</span>
	<span class="enscript-type">struct</span> kauth_ace	n_dace;		<span class="enscript-comment">/* delegation ACE */</span>
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_DATA_LOCK_SHARED</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_DATA_LOCK_EXCLUSIVE</span>	2

#<span class="enscript-reference">define</span> <span class="enscript-function-name">nfstimespeccmp</span>(tvp, uvp, cmp)		\
	(((tvp)-&gt;tv_sec == (uvp)-&gt;tv_sec) ?	\
	 ((tvp)-&gt;tv_nsec cmp (uvp)-&gt;tv_nsec) :	\
	 ((tvp)-&gt;tv_sec cmp (uvp)-&gt;tv_sec))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CHECK_NEEDCOMMITCNT</span>(np) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> ((np)-&gt;n_needcommitcnt &lt; 0) { \
			printf(<span class="enscript-string">&quot;nfs: n_needcommitcnt negative\n&quot;</span>); \
			(np)-&gt;n_needcommitcnt = 0; \
		} \
	} <span class="enscript-keyword">while</span> (0)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_atim</span>			n_un1.ns_atim
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_mtim</span>			n_un2.ns_mtim
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_rltim</span>			n_un1.nl_rltim
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_lastread</span>		n_un1.nf_lastread
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_lastrahead</span>		n_un2.nf_lastrahead
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_sillyrename</span>		n_un3.nf_silly
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_wrbusy</span>		n_un5.nf_wrbusy
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_needcommitcnt</span>		n_un6.nf_needcommitcnt
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_numoutput</span>		n_un7.nf_numoutput
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_cookieverf</span>		n_un1.nd_cookieverf
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_eofcookie</span>		n_un2.nd_eofcookie
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_cookiecache</span>		n_un3.nd_cookiecache
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_ncgen</span>			n_un5.nd_ncgen
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_lastdbl</span>		n_un6.nd_lastdbl
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_trigseq</span>		n_un7.nd_trigseq
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_mtime</span>			n_un4.v3.n3_mtime
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_ncmtime</span>		n_un4.v3.n3_ncmtime
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_change</span>		n_un4.v4.n4_change
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_ncchange</span>		n_un4.v4.n4_ncchange
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_attrdirfh</span>		n_un4.v4.n4_attrdirfh
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">n_lastio</span>		n_un4.v4.n4_lastio

<span class="enscript-comment">/*
 * Flags for n_flag
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NUPDATESIZE</span>	0x00001	<span class="enscript-comment">/* size of file needs updating */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NREVOKE</span>		0x00002	<span class="enscript-comment">/* node revoked */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NMODIFIED</span>	0x00004	<span class="enscript-comment">/* Might have a modified buffer in bio */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NWRITEERR</span>	0x00008	<span class="enscript-comment">/* Flag write errors so close will know */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NNEEDINVALIDATE</span>	0x00010	<span class="enscript-comment">/* need to call vinvalbuf() */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NGETATTRINPROG</span>	0x00020	<span class="enscript-comment">/* GETATTR RPC in progress */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NGETATTRWANT</span>	0x00040	<span class="enscript-comment">/* waiting for GETATTR RPC */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NACC</span>		0x00100	<span class="enscript-comment">/* Special file accessed */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NUPD</span>		0x00200	<span class="enscript-comment">/* Special file updated */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NCHG</span>		0x00400	<span class="enscript-comment">/* Special file times changed */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NNEGNCENTRIES</span>	0x00800	<span class="enscript-comment">/* directory has negative name cache entries */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NBUSY</span>		0x01000	<span class="enscript-comment">/* node is busy */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NBUSYWANT</span>	0x02000	<span class="enscript-comment">/* waiting on busy node */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NISDOTZFS</span>	0x04000	<span class="enscript-comment">/* a &quot;.zfs&quot; directory */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NISDOTZFSCHILD</span>	0x08000	<span class="enscript-comment">/* a child of a &quot;.zfs&quot; directory */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NISMAPPED</span>	0x10000	<span class="enscript-comment">/* node is mmapped   */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NREFRESH</span>	0x20000 <span class="enscript-comment">/* node's fh needs to be refreshed */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NREFRESHWANT</span>	0x40000 <span class="enscript-comment">/* Waiting for fh to be refreshed */</span>

<span class="enscript-comment">/*
 * Flags for n_hflag
 * Note: protected by nfs_node_hash_mutex
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NHHASHED</span>	0x0001  <span class="enscript-comment">/* node is in hash table */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NHINIT</span>		0x0002  <span class="enscript-comment">/* node is being initialized */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NHLOCKED</span>	0x0004  <span class="enscript-comment">/* node is locked (initting or deleting) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NHLOCKWANT</span>	0x0008  <span class="enscript-comment">/* someone wants to lock */</span>

<span class="enscript-comment">/*
 * Flags for n_bflag
 * Note: protected by nfs_buf_mutex
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NBFLUSHINPROG</span>	0x0001	<span class="enscript-comment">/* Avoid multiple calls to nfs_flush() */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NBFLUSHWANT</span>	0x0002	<span class="enscript-comment">/* waiting for nfs_flush() to complete */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NBINVALINPROG</span>	0x0004	<span class="enscript-comment">/* Avoid multiple calls to nfs_vinvalbuf() */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NBINVALWANT</span>	0x0008	<span class="enscript-comment">/* waiting for nfs_vinvalbuf() to complete */</span>

<span class="enscript-comment">/*
 * Flags for n_mflag
 * Note: protected by nfsmount's nm_lock
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NMMONSCANINPROG</span>	0x0001	<span class="enscript-comment">/* monitored node is currently updating attributes */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NMMONSCANWANT</span>	0x0002	<span class="enscript-comment">/* waiting for attribute update to complete */</span>

<span class="enscript-comment">/*
 * n_openflags
 * Note: protected by n_openlock
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">N_OPENBUSY</span>		0x0001	<span class="enscript-comment">/* open state is busy - being updated */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">N_OPENWANT</span>		0x0002	<span class="enscript-comment">/* someone wants to mark busy */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">N_DELEG_READ</span>		0x0004	<span class="enscript-comment">/* we have a read delegation */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">N_DELEG_WRITE</span>		0x0008	<span class="enscript-comment">/* we have a write delegation */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">N_DELEG_MASK</span>		0x000c	<span class="enscript-comment">/* delegation mask */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">N_DELEG_RETURN</span>		0x0010	<span class="enscript-comment">/* delegation queued for return */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">N_DELEG_RETURNING</span>	0x0020	<span class="enscript-comment">/* delegation being returned */</span>

<span class="enscript-comment">/* attr/access/ACL cache timestamp macros */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NATTRVALID</span>(np)		((np)-&gt;n_attrstamp != ~0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NATTRINVALIDATE</span>(np)	((np)-&gt;n_attrstamp = ~0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NACCESSVALID</span>(np, slot)	(((slot) &gt;= 0) &amp;&amp; ((slot) &lt; NFS_ACCESS_CACHE_SIZE) &amp;&amp; ((np)-&gt;n_accessstamp[(slot)] != ~0))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NACCESSINVALIDATE</span>(np) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-type">int</span> __i; \
		<span class="enscript-keyword">for</span> (__i=0; __i &lt; NFS_ACCESS_CACHE_SIZE; __i++) \
			(np)-&gt;n_accessstamp[__i] = ~0; \
		(np)-&gt;n_access[NFS_ACCESS_CACHE_SIZE] = 0; \
	} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NACLVALID</span>(np)		((np)-&gt;n_aclstamp != ~0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NACLINVALIDATE</span>(np)	((np)-&gt;n_aclstamp = ~0)

<span class="enscript-comment">/*
 * NFS-specific flags for nfs_vinvalbuf/nfs_flush
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">V_IGNORE_WRITEERR</span>	0x8000

<span class="enscript-comment">/*
 * Flags for nfs_nget()
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NG_MARKROOT</span>	0x0001	<span class="enscript-comment">/* mark vnode as root of FS */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NG_MAKEENTRY</span>	0x0002	<span class="enscript-comment">/* add name cache entry for vnode */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NG_NOCREATE</span>	0x0004	<span class="enscript-comment">/* don't create a new node, return existing one */</span>

<span class="enscript-comment">/*
 * Convert between nfsnode pointers and vnode pointers
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VTONFS</span>(vp)	((nfsnode_t)vnode_fsnode(vp))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFSTOV</span>(np)	((np)-&gt;n_vnode)

<span class="enscript-comment">/* nfsnode hash table mutex */</span>
<span class="enscript-type">extern</span> lck_mtx_t *nfs_node_hash_mutex;

<span class="enscript-comment">/*
 * printf-like helper macro that also outputs node name.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NP</span>(NP, FMT, ...) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *__vname = (NP) ? vnode_getname(NFSTOV(NP)) : NULL; \
		printf(FMT <span class="enscript-string">&quot; %s\n&quot;</span>, ##__VA_ARGS__, __vname ? __vname : <span class="enscript-string">&quot;???&quot;</span>); \
		<span class="enscript-keyword">if</span> (__vname) vnode_putname(__vname); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * nfsiod structures
 */</span>
<span class="enscript-type">struct</span> nfsiod {
	TAILQ_ENTRY(nfsiod)	niod_link;	<span class="enscript-comment">/* List of nfsiods */</span>
	<span class="enscript-type">struct</span> nfsmount *	niod_nmp;	<span class="enscript-comment">/* mount point for this nfsiod */</span>
};
<span class="enscript-function-name">TAILQ_HEAD</span>(nfsiodlist, nfsiod);
<span class="enscript-function-name">TAILQ_HEAD</span>(nfsiodmountlist, nfsmount);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> nfsiodlist nfsiodfree, nfsiodwork;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> nfsiodmountlist nfsiodmounts;
<span class="enscript-type">extern</span> lck_mtx_t *nfsiod_mutex;

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">KERNEL</span>)

<span class="enscript-type">typedef</span> <span class="enscript-type">int</span>     <span class="enscript-function-name">vnop_t</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">extern</span>	vnop_t	**fifo_nfsv2nodeop_p;
<span class="enscript-type">extern</span>	vnop_t	**nfsv2_vnodeop_p;
<span class="enscript-type">extern</span>	vnop_t	**spec_nfsv2nodeop_p;
<span class="enscript-type">extern</span>	vnop_t	**fifo_nfsv4nodeop_p;
<span class="enscript-type">extern</span>	vnop_t	**nfsv4_vnodeop_p;
<span class="enscript-type">extern</span>	vnop_t	**spec_nfsv4nodeop_p;

<span class="enscript-comment">/*
 * Prototypes for NFS vnode operations
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">nfs_vnop_revoke</span> nop_revoke
<span class="enscript-type">int</span>	nfs_vnop_inactive(<span class="enscript-type">struct</span> vnop_inactive_args *);
<span class="enscript-type">int</span>	nfs_vnop_reclaim(<span class="enscript-type">struct</span> vnop_reclaim_args *);

<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_node_lock</span>(nfsnode_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_node_lock_internal</span>(nfsnode_t, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_node_lock_force</span>(nfsnode_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_node_unlock</span>(nfsnode_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_node_lock2</span>(nfsnode_t, nfsnode_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_node_unlock2</span>(nfsnode_t, nfsnode_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_node_set_busy</span>(nfsnode_t, thread_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_node_set_busy2</span>(nfsnode_t, nfsnode_t, thread_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_node_set_busy4</span>(nfsnode_t, nfsnode_t, nfsnode_t, nfsnode_t, thread_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_node_clear_busy</span>(nfsnode_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_node_clear_busy2</span>(nfsnode_t, nfsnode_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_node_clear_busy4</span>(nfsnode_t, nfsnode_t, nfsnode_t, nfsnode_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_data_lock</span>(nfsnode_t, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_data_lock_noupdate</span>(nfsnode_t, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_data_lock_internal</span>(nfsnode_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_data_unlock</span>(nfsnode_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_data_unlock_noupdate</span>(nfsnode_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_data_unlock_internal</span>(nfsnode_t, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_data_update_size</span>(nfsnode_t, <span class="enscript-type">int</span>);

<span class="enscript-comment">/* other stuff */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_removeit</span>(<span class="enscript-type">struct</span> nfs_sillyrename *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_nget</span>(mount_t,nfsnode_t,<span class="enscript-type">struct</span> componentname *,u_char *,<span class="enscript-type">int</span>,<span class="enscript-type">struct</span> nfs_vattr *,u_int64_t *,uint32_t,<span class="enscript-type">int</span>,nfsnode_t*);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_mount_is_dirty</span>(mount_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_dir_cookie_cache</span>(nfsnode_t, uint64_t, uint64_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_dir_cookie_to_lbn</span>(nfsnode_t, uint64_t, <span class="enscript-type">int</span> *, uint64_t *);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_invaldir</span>(nfsnode_t);
uint32_t <span class="enscript-function-name">nfs_dir_buf_freespace</span>(<span class="enscript-type">struct</span> nfsbuf *, <span class="enscript-type">int</span>);

<span class="enscript-comment">/* nfsbuf functions */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_nbinit</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_timer</span>(<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_remfree</span>(<span class="enscript-type">struct</span> nfsbuf *);
boolean_t <span class="enscript-function-name">nfs_buf_is_incore</span>(nfsnode_t, daddr64_t);
<span class="enscript-type">struct</span> nfsbuf * <span class="enscript-function-name">nfs_buf_incore</span>(nfsnode_t, daddr64_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_buf_get</span>(nfsnode_t, daddr64_t, uint32_t, thread_t, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> nfsbuf **);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_buf_upl_setup</span>(<span class="enscript-type">struct</span> nfsbuf *bp);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_upl_check</span>(<span class="enscript-type">struct</span> nfsbuf *bp);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_normalize_valid_range</span>(nfsnode_t, <span class="enscript-type">struct</span> nfsbuf *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_buf_map</span>(<span class="enscript-type">struct</span> nfsbuf *);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_release</span>(<span class="enscript-type">struct</span> nfsbuf *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_buf_iowait</span>(<span class="enscript-type">struct</span> nfsbuf *);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_iodone</span>(<span class="enscript-type">struct</span> nfsbuf *);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_write_delayed</span>(<span class="enscript-type">struct</span> nfsbuf *);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_check_write_verifier</span>(nfsnode_t, <span class="enscript-type">struct</span> nfsbuf *);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_freeup</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_refget</span>(<span class="enscript-type">struct</span> nfsbuf *bp);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_refrele</span>(<span class="enscript-type">struct</span> nfsbuf *bp);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_drop</span>(<span class="enscript-type">struct</span> nfsbuf *);
errno_t <span class="enscript-function-name">nfs_buf_acquire</span>(<span class="enscript-type">struct</span> nfsbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_buf_iterprepare</span>(nfsnode_t, <span class="enscript-type">struct</span> nfsbuflists *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_itercomplete</span>(nfsnode_t, <span class="enscript-type">struct</span> nfsbuflists *, <span class="enscript-type">int</span>);

<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_bioread</span>(nfsnode_t, uio_t, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_buf_readahead</span>(nfsnode_t, <span class="enscript-type">int</span>, daddr64_t *, daddr64_t, thread_t, kauth_cred_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_buf_readdir</span>(<span class="enscript-type">struct</span> nfsbuf *, vfs_context_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_buf_read</span>(<span class="enscript-type">struct</span> nfsbuf *);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_read_finish</span>(<span class="enscript-type">struct</span> nfsbuf *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_buf_read_rpc</span>(<span class="enscript-type">struct</span> nfsbuf *, thread_t, kauth_cred_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_read_rpc_finish</span>(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_buf_write</span>(<span class="enscript-type">struct</span> nfsbuf *);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_write_finish</span>(<span class="enscript-type">struct</span> nfsbuf *, thread_t, kauth_cred_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_buf_write_rpc</span>(<span class="enscript-type">struct</span> nfsbuf *, <span class="enscript-type">int</span>, thread_t, kauth_cred_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_write_rpc_finish</span>(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_buf_write_dirty_pages</span>(<span class="enscript-type">struct</span> nfsbuf *, thread_t, kauth_cred_t);

<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_flushcommits</span>(nfsnode_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_flush</span>(nfsnode_t, <span class="enscript-type">int</span>, thread_t, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_delwri_push</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_delwri_service</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_buf_delwri_thread</span>(<span class="enscript-type">void</span> *, wait_result_t);;

<span class="enscript-type">int</span> <span class="enscript-function-name">nfsiod_start</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfsiod_terminate</span>(<span class="enscript-type">struct</span> nfsiod *);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfsiod_thread</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsiod_continue</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_asyncio_finish</span>(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_asyncio_resend</span>(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_async_write_start</span>(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_async_write_done</span>(<span class="enscript-type">struct</span> nfsmount *);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE_API_PRIVATE */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _NFS_NFSNODE_H_ */</span>
</pre>
<hr />
</body></html>