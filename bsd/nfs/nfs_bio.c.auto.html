<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nfs_bio.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nfs_bio.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfs_bio.c	8.9 (Berkeley) 3/30/95
 * FreeBSD-Id: nfs_bio.c,v 1.44 1997/09/10 19:52:25 phk Exp $
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dirent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vmparam.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/rpcv2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_gss.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsmount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

kern_return_t	thread_terminate(thread_t); <span class="enscript-comment">/* XXX */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NFSBUFHASH</span>(np, lbn)	\
	(&amp;nfsbufhashtbl[((<span class="enscript-type">long</span>)(np) / <span class="enscript-keyword">sizeof</span>(*(np)) + (<span class="enscript-type">int</span>)(lbn)) &amp; nfsbufhash])
<span class="enscript-function-name">LIST_HEAD</span>(nfsbufhashhead, nfsbuf) *nfsbufhashtbl;
<span class="enscript-type">struct</span> nfsbuffreehead nfsbuffree, nfsbuffreemeta, nfsbufdelwri;
u_long nfsbufhash;
<span class="enscript-type">int</span> nfsbufcnt, nfsbufmin, nfsbufmax, nfsbufmetacnt, nfsbufmetamax;
<span class="enscript-type">int</span> nfsbuffreecnt, nfsbuffreemetacnt, nfsbufdelwricnt, nfsneedbuffer;
<span class="enscript-type">int</span> nfs_nbdwrite;
<span class="enscript-type">int</span> nfs_buf_timer_on = 0;
thread_t nfsbufdelwrithd = NULL;

lck_grp_t *nfs_buf_lck_grp;
lck_mtx_t *nfs_buf_mutex;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSBUF_FREE_PERIOD</span>	30	<span class="enscript-comment">/* seconds */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSBUF_LRU_STALE</span>	120
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSBUF_META_STALE</span>	240

<span class="enscript-comment">/* number of nfsbufs nfs_buf_freeup() should attempt to free from nfsbuffree list */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LRU_TO_FREEUP</span>			6
<span class="enscript-comment">/* number of nfsbufs nfs_buf_freeup() should attempt to free from nfsbuffreemeta list */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">META_TO_FREEUP</span>			3
<span class="enscript-comment">/* total number of nfsbufs nfs_buf_freeup() should attempt to free */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TOTAL_TO_FREEUP</span>			(LRU_TO_FREEUP+META_TO_FREEUP)
<span class="enscript-comment">/* fraction of nfsbufs nfs_buf_freeup() should attempt to free from nfsbuffree list when called from timer */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LRU_FREEUP_FRAC_ON_TIMER</span>	8
<span class="enscript-comment">/* fraction of nfsbufs nfs_buf_freeup() should attempt to free from nfsbuffreemeta list when called from timer */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">META_FREEUP_FRAC_ON_TIMER</span>	16
<span class="enscript-comment">/* fraction of total nfsbufs that nfsbuffreecnt should exceed before bothering to call nfs_buf_freeup() */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LRU_FREEUP_MIN_FRAC</span>		4
<span class="enscript-comment">/* fraction of total nfsbufs that nfsbuffreemetacnt should exceed before bothering to call nfs_buf_freeup() */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">META_FREEUP_MIN_FRAC</span>		2

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_BUF_FREEUP</span>() \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-comment">/* only call nfs_buf_freeup() if it has work to do: */</span> \
		<span class="enscript-keyword">if</span> (((nfsbuffreecnt &gt; nfsbufcnt/LRU_FREEUP_MIN_FRAC) || \
		     (nfsbuffreemetacnt &gt; nfsbufcnt/META_FREEUP_MIN_FRAC)) &amp;&amp; \
		    ((nfsbufcnt - TOTAL_TO_FREEUP) &gt; nfsbufmin)) \
			nfs_buf_freeup(0); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * Initialize nfsbuf lists
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_nbinit</span>(<span class="enscript-type">void</span>)
{
	nfs_buf_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;nfs_buf&quot;</span>, LCK_GRP_ATTR_NULL);
	nfs_buf_mutex = lck_mtx_alloc_init(nfs_buf_lck_grp, LCK_ATTR_NULL);

	nfsbufcnt = nfsbufmetacnt =
	nfsbuffreecnt = nfsbuffreemetacnt = nfsbufdelwricnt = 0;
	nfsbufmin = 128;
	<span class="enscript-comment">/* size nfsbufmax to cover at most half sane_size (w/default buf size) */</span>
	nfsbufmax = (sane_size &gt;&gt; PAGE_SHIFT) / (2 * (NFS_RWSIZE &gt;&gt; PAGE_SHIFT));
	nfsbufmetamax = nfsbufmax / 4;
	nfsneedbuffer = 0;
	nfs_nbdwrite = 0;

	nfsbufhashtbl = hashinit(nfsbufmax/4, M_TEMP, &amp;nfsbufhash);
	TAILQ_INIT(&amp;nfsbuffree);
	TAILQ_INIT(&amp;nfsbuffreemeta);
	TAILQ_INIT(&amp;nfsbufdelwri);

}

<span class="enscript-comment">/*
 * Check periodically for stale/unused nfs bufs
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_timer</span>(__unused <span class="enscript-type">void</span> *param0, __unused <span class="enscript-type">void</span> *param1)
{
	nfs_buf_freeup(1);

	lck_mtx_lock(nfs_buf_mutex);
	<span class="enscript-keyword">if</span> (nfsbufcnt &lt;= nfsbufmin) {
		nfs_buf_timer_on = 0;
		lck_mtx_unlock(nfs_buf_mutex);
		<span class="enscript-keyword">return</span>;
	}
	lck_mtx_unlock(nfs_buf_mutex);

	nfs_interval_timer_start(nfs_buf_timer_call,
		NFSBUF_FREE_PERIOD * 1000);
}

<span class="enscript-comment">/*
 * try to free up some excess, unused nfsbufs
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_freeup</span>(<span class="enscript-type">int</span> timer)
{
	<span class="enscript-type">struct</span> nfsbuf *fbp;
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">int</span> count;
	<span class="enscript-type">struct</span> nfsbuffreehead nfsbuffreeup;

	TAILQ_INIT(&amp;nfsbuffreeup);

	lck_mtx_lock(nfs_buf_mutex);

	microuptime(&amp;now);

	FSDBG(320, nfsbufcnt, nfsbuffreecnt, nfsbuffreemetacnt, 0);

	count = timer ? nfsbuffreecnt/LRU_FREEUP_FRAC_ON_TIMER : LRU_TO_FREEUP;
	<span class="enscript-keyword">while</span> ((nfsbufcnt &gt; nfsbufmin) &amp;&amp; (count-- &gt; 0)) {
		fbp = TAILQ_FIRST(&amp;nfsbuffree);
		<span class="enscript-keyword">if</span> (!fbp)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (fbp-&gt;nb_refs)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (NBUFSTAMPVALID(fbp) &amp;&amp;
		    (fbp-&gt;nb_timestamp + (2*NFSBUF_LRU_STALE)) &gt; now.tv_sec)
			<span class="enscript-keyword">break</span>;
		nfs_buf_remfree(fbp);
		<span class="enscript-comment">/* disassociate buffer from any nfsnode */</span>
		<span class="enscript-keyword">if</span> (fbp-&gt;nb_np) {
			<span class="enscript-keyword">if</span> (fbp-&gt;nb_vnbufs.le_next != NFSNOLIST) {
				LIST_REMOVE(fbp, nb_vnbufs);
				fbp-&gt;nb_vnbufs.le_next = NFSNOLIST;
			}
			fbp-&gt;nb_np = NULL;
		}
		LIST_REMOVE(fbp, nb_hash);
		TAILQ_INSERT_TAIL(&amp;nfsbuffreeup, fbp, nb_free);
		nfsbufcnt--;
	}

	count = timer ? nfsbuffreemetacnt/META_FREEUP_FRAC_ON_TIMER : META_TO_FREEUP;
	<span class="enscript-keyword">while</span> ((nfsbufcnt &gt; nfsbufmin) &amp;&amp; (count-- &gt; 0)) {
		fbp = TAILQ_FIRST(&amp;nfsbuffreemeta);
		<span class="enscript-keyword">if</span> (!fbp)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (fbp-&gt;nb_refs)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (NBUFSTAMPVALID(fbp) &amp;&amp;
		    (fbp-&gt;nb_timestamp + (2*NFSBUF_META_STALE)) &gt; now.tv_sec)
			<span class="enscript-keyword">break</span>;
		nfs_buf_remfree(fbp);
		<span class="enscript-comment">/* disassociate buffer from any nfsnode */</span>
		<span class="enscript-keyword">if</span> (fbp-&gt;nb_np) {
			<span class="enscript-keyword">if</span> (fbp-&gt;nb_vnbufs.le_next != NFSNOLIST) {
				LIST_REMOVE(fbp, nb_vnbufs);
				fbp-&gt;nb_vnbufs.le_next = NFSNOLIST;
			}
			fbp-&gt;nb_np = NULL;
		}
		LIST_REMOVE(fbp, nb_hash);
		TAILQ_INSERT_TAIL(&amp;nfsbuffreeup, fbp, nb_free);
		nfsbufcnt--;
		nfsbufmetacnt--;
	}

	FSDBG(320, nfsbufcnt, nfsbuffreecnt, nfsbuffreemetacnt, 0);
	NFSBUFCNTCHK();

	lck_mtx_unlock(nfs_buf_mutex);

	<span class="enscript-keyword">while</span> ((fbp = TAILQ_FIRST(&amp;nfsbuffreeup))) {
		TAILQ_REMOVE(&amp;nfsbuffreeup, fbp, nb_free);
		<span class="enscript-comment">/* nuke any creds */</span>
		<span class="enscript-keyword">if</span> (IS_VALID_CRED(fbp-&gt;nb_rcred))
			kauth_cred_unref(&amp;fbp-&gt;nb_rcred);
		<span class="enscript-keyword">if</span> (IS_VALID_CRED(fbp-&gt;nb_wcred))
			kauth_cred_unref(&amp;fbp-&gt;nb_wcred);
		<span class="enscript-comment">/* if buf was NB_META, dump buffer */</span>
		<span class="enscript-keyword">if</span> (ISSET(fbp-&gt;nb_flags, NB_META) &amp;&amp; fbp-&gt;nb_data)
			kfree(fbp-&gt;nb_data, fbp-&gt;nb_bufsize);
		FREE(fbp, M_TEMP);
	}

}

<span class="enscript-comment">/*
 * remove a buffer from the freelist
 * (must be called with nfs_buf_mutex held)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_remfree</span>(<span class="enscript-type">struct</span> nfsbuf *bp)
{
	<span class="enscript-keyword">if</span> (bp-&gt;nb_free.tqe_next == NFSNOLIST)
		panic(<span class="enscript-string">&quot;nfsbuf not on free list&quot;</span>);
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_DELWRI)) {
		nfsbufdelwricnt--;
		TAILQ_REMOVE(&amp;nfsbufdelwri, bp, nb_free);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_META)) {
		nfsbuffreemetacnt--;
		TAILQ_REMOVE(&amp;nfsbuffreemeta, bp, nb_free);
	} <span class="enscript-keyword">else</span> {
		nfsbuffreecnt--;
		TAILQ_REMOVE(&amp;nfsbuffree, bp, nb_free);
	}
	bp-&gt;nb_free.tqe_next = NFSNOLIST;
	NFSBUFCNTCHK();
}

<span class="enscript-comment">/*
 * check for existence of nfsbuf in cache
 */</span>
boolean_t
<span class="enscript-function-name">nfs_buf_is_incore</span>(nfsnode_t np, daddr64_t blkno)
{
	boolean_t rv;
	lck_mtx_lock(nfs_buf_mutex);
	<span class="enscript-keyword">if</span> (nfs_buf_incore(np, blkno))
		rv = TRUE;
	<span class="enscript-keyword">else</span>
		rv = FALSE;
	lck_mtx_unlock(nfs_buf_mutex);
	<span class="enscript-keyword">return</span> (rv);
}

<span class="enscript-comment">/*
 * return incore buffer (must be called with nfs_buf_mutex held)
 */</span>
<span class="enscript-type">struct</span> nfsbuf *
<span class="enscript-function-name">nfs_buf_incore</span>(nfsnode_t np, daddr64_t blkno)
{
	<span class="enscript-comment">/* Search hash chain */</span>
	<span class="enscript-type">struct</span> nfsbuf * bp = NFSBUFHASH(np, blkno)-&gt;lh_first;
	<span class="enscript-keyword">for</span> (; bp != NULL; bp = bp-&gt;nb_hash.le_next)
		<span class="enscript-keyword">if</span> ((bp-&gt;nb_lblkno == blkno) &amp;&amp; (bp-&gt;nb_np == np)) {
			<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_INVAL)) {
				FSDBG(547, bp, blkno, bp-&gt;nb_flags, bp-&gt;nb_np);
				<span class="enscript-keyword">return</span> (bp);
			}
		}
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * Check if it's OK to drop a page.
 *
 * Called by vnode_pager() on pageout request of non-dirty page.
 * We need to make sure that it's not part of a delayed write.
 * If it is, we can't let the VM drop it because we may need it
 * later when/if we need to write the data (again).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_buf_page_inval</span>(vnode_t vp, off_t offset)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = VTONMP(vp);
	<span class="enscript-type">struct</span> nfsbuf *bp;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	lck_mtx_lock(nfs_buf_mutex);
	bp = nfs_buf_incore(VTONFS(vp), (daddr64_t)(offset / nmp-&gt;nm_biosize));
	<span class="enscript-keyword">if</span> (!bp)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	FSDBG(325, bp, bp-&gt;nb_flags, bp-&gt;nb_dirtyoff, bp-&gt;nb_dirtyend);
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_lflags, NBL_BUSY)) {
		error = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/*
	 * If there's a dirty range in the buffer, check to
	 * see if this page intersects with the dirty range.
	 * If it does, we can't let the pager drop the page.
	 */</span>
	<span class="enscript-keyword">if</span> (bp-&gt;nb_dirtyend &gt; 0) {
		<span class="enscript-type">int</span> start = offset - NBOFF(bp);
		<span class="enscript-keyword">if</span> ((bp-&gt;nb_dirtyend &gt; start) &amp;&amp;
		    (bp-&gt;nb_dirtyoff &lt; (start + PAGE_SIZE))) {
			<span class="enscript-comment">/*
			 * Before returning the bad news, move the
			 * buffer to the start of the delwri list and
			 * give the list a push to try to flush the
			 * buffer out.
			 */</span>
			error = EBUSY;
			nfs_buf_remfree(bp);
			TAILQ_INSERT_HEAD(&amp;nfsbufdelwri, bp, nb_free);
			nfsbufdelwricnt++;
			nfs_buf_delwri_push(1);
		}
	}
<span class="enscript-reference">out</span>:
	lck_mtx_unlock(nfs_buf_mutex);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * set up the UPL for a buffer
 * (must NOT be called with nfs_buf_mutex held)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_buf_upl_setup</span>(<span class="enscript-type">struct</span> nfsbuf *bp)
{
	kern_return_t kret;
	upl_t upl;
	<span class="enscript-type">int</span> upl_flags;

	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_PAGELIST))
		<span class="enscript-keyword">return</span> (0);

	upl_flags = UPL_PRECIOUS;
	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_READ)) {
		<span class="enscript-comment">/*
		 * We're doing a &quot;write&quot;, so we intend to modify
		 * the pages we're gathering.
		 */</span>
		upl_flags |= UPL_WILL_MODIFY;
	}
	kret = ubc_create_upl(NFSTOV(bp-&gt;nb_np), NBOFF(bp), bp-&gt;nb_bufsize,
				&amp;upl, NULL, upl_flags);
	<span class="enscript-keyword">if</span> (kret == KERN_INVALID_ARGUMENT) {
		<span class="enscript-comment">/* vm object probably doesn't exist any more */</span>
		bp-&gt;nb_pagelist = NULL;
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
		printf(<span class="enscript-string">&quot;nfs_buf_upl_setup(): failed to get pagelist %d\n&quot;</span>, kret);
		bp-&gt;nb_pagelist = NULL;
		<span class="enscript-keyword">return</span> (EIO);
	}

	FSDBG(538, bp, NBOFF(bp), bp-&gt;nb_bufsize, bp-&gt;nb_np);

	bp-&gt;nb_pagelist = upl;
	SET(bp-&gt;nb_flags, NB_PAGELIST);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * update buffer's valid/dirty info from UBC
 * (must NOT be called with nfs_buf_mutex held)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_upl_check</span>(<span class="enscript-type">struct</span> nfsbuf *bp)
{
	upl_page_info_t *pl;
	off_t filesize, fileoffset;
	<span class="enscript-type">int</span> i, npages;

	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_PAGELIST))
		<span class="enscript-keyword">return</span>;

	npages = round_page_32(bp-&gt;nb_bufsize) / PAGE_SIZE;
	filesize = ubc_getsize(NFSTOV(bp-&gt;nb_np));
	fileoffset = NBOFF(bp);
	<span class="enscript-keyword">if</span> (fileoffset &lt; filesize)
		SET(bp-&gt;nb_flags, NB_CACHE);
	<span class="enscript-keyword">else</span>
		CLR(bp-&gt;nb_flags, NB_CACHE);

	pl = ubc_upl_pageinfo(bp-&gt;nb_pagelist);
	bp-&gt;nb_valid = bp-&gt;nb_dirty = 0;

	<span class="enscript-keyword">for</span> (i=0; i &lt; npages; i++, fileoffset += PAGE_SIZE_64) {
		<span class="enscript-comment">/* anything beyond the end of the file is not valid or dirty */</span>
		<span class="enscript-keyword">if</span> (fileoffset &gt;= filesize)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (!upl_valid_page(pl, i)) {
			CLR(bp-&gt;nb_flags, NB_CACHE);
			<span class="enscript-keyword">continue</span>;
		}
		NBPGVALID_SET(bp,i);
		<span class="enscript-keyword">if</span> (upl_dirty_page(pl, i))
			NBPGDIRTY_SET(bp, i);
	}
	fileoffset = NBOFF(bp);
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_CACHE)) {
		bp-&gt;nb_validoff = 0;
		bp-&gt;nb_validend = bp-&gt;nb_bufsize;
		<span class="enscript-keyword">if</span> (fileoffset + bp-&gt;nb_validend &gt; filesize)
			bp-&gt;nb_validend = filesize - fileoffset;
	} <span class="enscript-keyword">else</span> {
		bp-&gt;nb_validoff = bp-&gt;nb_validend = -1;
	}
	FSDBG(539, bp, fileoffset, bp-&gt;nb_valid, bp-&gt;nb_dirty);
	FSDBG(539, bp-&gt;nb_validoff, bp-&gt;nb_validend, bp-&gt;nb_dirtyoff, bp-&gt;nb_dirtyend);
}

<span class="enscript-comment">/*
 * make sure that a buffer is mapped
 * (must NOT be called with nfs_buf_mutex held)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_buf_map</span>(<span class="enscript-type">struct</span> nfsbuf *bp)
{
	kern_return_t kret;

	<span class="enscript-keyword">if</span> (bp-&gt;nb_data)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_PAGELIST))
		<span class="enscript-keyword">return</span> (EINVAL);

	kret = ubc_upl_map(bp-&gt;nb_pagelist, (vm_offset_t *)&amp;(bp-&gt;nb_data));
	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;nfs_buf_map: ubc_upl_map() failed with (%d)&quot;</span>, kret);
	<span class="enscript-keyword">if</span> (bp-&gt;nb_data == 0)
		panic(<span class="enscript-string">&quot;ubc_upl_map mapped 0&quot;</span>);
	FSDBG(540, bp, bp-&gt;nb_flags, NBOFF(bp), bp-&gt;nb_data);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * normalize an nfsbuf's valid range
 *
 * the read/write code guarantees that we'll always have a valid
 * region that is an integral number of pages.  If either end
 * of the valid range isn't page-aligned, it gets corrected
 * here as we extend the valid range through all of the
 * contiguous valid pages.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_normalize_valid_range</span>(nfsnode_t np, <span class="enscript-type">struct</span> nfsbuf *bp)
{
	<span class="enscript-type">int</span> pg, npg;
	<span class="enscript-comment">/* pull validoff back to start of contiguous valid page range */</span>
	pg = bp-&gt;nb_validoff/PAGE_SIZE;
	<span class="enscript-keyword">while</span> (pg &gt;= 0 &amp;&amp; NBPGVALID(bp,pg))
		pg--;
	bp-&gt;nb_validoff = (pg+1) * PAGE_SIZE;
	<span class="enscript-comment">/* push validend forward to end of contiguous valid page range */</span>
	npg = bp-&gt;nb_bufsize/PAGE_SIZE;
	pg = bp-&gt;nb_validend/PAGE_SIZE;
	<span class="enscript-keyword">while</span> (pg &lt; npg &amp;&amp; NBPGVALID(bp,pg))
		pg++;
	bp-&gt;nb_validend = pg * PAGE_SIZE;
	<span class="enscript-comment">/* clip to EOF */</span>
	<span class="enscript-keyword">if</span> (NBOFF(bp) + bp-&gt;nb_validend &gt; (off_t)np-&gt;n_size)
		bp-&gt;nb_validend = np-&gt;n_size % bp-&gt;nb_bufsize;
}

<span class="enscript-comment">/*
 * process some entries on the delayed write queue
 * (must be called with nfs_buf_mutex held)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_delwri_service</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> nfsbuf *bp;
	nfsnode_t np;
	<span class="enscript-type">int</span> error, i = 0;

	<span class="enscript-keyword">while</span> (i &lt; 8 &amp;&amp; (bp = TAILQ_FIRST(&amp;nfsbufdelwri)) != NULL) {
		np = bp-&gt;nb_np;
		nfs_buf_remfree(bp);
		nfs_buf_refget(bp);
		<span class="enscript-keyword">while</span> ((error = nfs_buf_acquire(bp, 0, 0, 0)) == EAGAIN);
		nfs_buf_refrele(bp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (!bp-&gt;nb_np) {
			<span class="enscript-comment">/* buffer is no longer valid */</span>
			nfs_buf_drop(bp);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_NEEDCOMMIT))
			nfs_buf_check_write_verifier(np, bp);
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_NEEDCOMMIT)) {
			<span class="enscript-comment">/* put buffer at end of delwri list */</span>
			TAILQ_INSERT_TAIL(&amp;nfsbufdelwri, bp, nb_free);
			nfsbufdelwricnt++;
			nfs_buf_drop(bp);
			lck_mtx_unlock(nfs_buf_mutex);
			nfs_flushcommits(np, 1);
		} <span class="enscript-keyword">else</span> {
			SET(bp-&gt;nb_flags, NB_ASYNC);
			lck_mtx_unlock(nfs_buf_mutex);
			nfs_buf_write(bp);
		}
		i++;
		lck_mtx_lock(nfs_buf_mutex);
	}
}

<span class="enscript-comment">/*
 * thread to service the delayed write queue when asked
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_delwri_thread</span>(__unused <span class="enscript-type">void</span> *arg, __unused wait_result_t wr)
{
	<span class="enscript-type">struct</span> timespec ts = { 30, 0 };
	<span class="enscript-type">int</span> error = 0;

	lck_mtx_lock(nfs_buf_mutex);
	<span class="enscript-keyword">while</span> (!error) {
		nfs_buf_delwri_service();
		error = msleep(&amp;nfsbufdelwrithd, nfs_buf_mutex, 0, <span class="enscript-string">&quot;nfsbufdelwri&quot;</span>, &amp;ts);
	}
	nfsbufdelwrithd = NULL;
	lck_mtx_unlock(nfs_buf_mutex);
	thread_terminate(nfsbufdelwrithd);
}

<span class="enscript-comment">/*
 * try to push out some delayed/uncommitted writes
 * (&quot;locked&quot; indicates whether nfs_buf_mutex is already held)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_delwri_push</span>(<span class="enscript-type">int</span> locked)
{
	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;nfsbufdelwri))
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> (!locked)
		lck_mtx_lock(nfs_buf_mutex);
	<span class="enscript-comment">/* wake up the delayed write service thread */</span>
	<span class="enscript-keyword">if</span> (nfsbufdelwrithd)
		wakeup(&amp;nfsbufdelwrithd);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kernel_thread_start(nfs_buf_delwri_thread, NULL, &amp;nfsbufdelwrithd) == KERN_SUCCESS)
		thread_deallocate(nfsbufdelwrithd);
	<span class="enscript-comment">/* otherwise, try to do some of the work ourselves */</span>
	<span class="enscript-keyword">if</span> (!nfsbufdelwrithd)
		nfs_buf_delwri_service();
	<span class="enscript-keyword">if</span> (!locked)
		lck_mtx_unlock(nfs_buf_mutex);
}

<span class="enscript-comment">/*
 * Get an nfs buffer.
 *
 * Returns errno on error, 0 otherwise.
 * Any buffer is returned in *bpp.
 *
 * If NBLK_ONLYVALID is set, only return buffer if found in cache.
 * If NBLK_NOWAIT is set, don't wait for the buffer if it's marked BUSY.
 *
 * Check for existence of buffer in cache.
 * Or attempt to reuse a buffer from one of the free lists.
 * Or allocate a new buffer if we haven't already hit max allocation.
 * Or wait for a free buffer.
 *
 * If available buffer found, prepare it, and return it.
 *
 * If the calling process is interrupted by a signal for
 * an interruptible mount point, return EINTR.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_buf_get</span>(
	nfsnode_t np,
	daddr64_t blkno,
	uint32_t size,
	thread_t thd,
	<span class="enscript-type">int</span> flags,
	<span class="enscript-type">struct</span> nfsbuf **bpp)
{
	vnode_t vp = NFSTOV(np);
	<span class="enscript-type">struct</span> nfsmount *nmp = VTONMP(vp);
	<span class="enscript-type">struct</span> nfsbuf *bp;
	uint32_t bufsize;
	<span class="enscript-type">int</span> slpflag = PCATCH;
	<span class="enscript-type">int</span> operation = (flags &amp; NBLK_OPMASK);
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> timespec ts;

	FSDBG_TOP(541, np, blkno, size, flags);
	*bpp = NULL;

	bufsize = size;
	<span class="enscript-keyword">if</span> (bufsize &gt; NFS_MAXBSIZE)
		panic(<span class="enscript-string">&quot;nfs_buf_get: buffer larger than NFS_MAXBSIZE requested&quot;</span>);

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		FSDBG_BOT(541, np, blkno, 0, ENXIO);
		<span class="enscript-keyword">return</span> (ENXIO);
	}

	<span class="enscript-keyword">if</span> (!UBCINFOEXISTS(vp)) {
		operation = NBLK_META;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bufsize &lt; (uint32_t)nmp-&gt;nm_biosize) {
		<span class="enscript-comment">/* reg files should always have biosize blocks */</span>
		bufsize = nmp-&gt;nm_biosize;
	}

	<span class="enscript-comment">/* if NBLK_WRITE, check for too many delayed/uncommitted writes */</span>
	<span class="enscript-keyword">if</span> ((operation == NBLK_WRITE) &amp;&amp; (nfs_nbdwrite &gt; NFS_A_LOT_OF_DELAYED_WRITES)) {
		FSDBG_TOP(542, np, blkno, nfs_nbdwrite, NFS_A_LOT_OF_DELAYED_WRITES);

		<span class="enscript-comment">/* poke the delwri list */</span>
		nfs_buf_delwri_push(0);

		<span class="enscript-comment">/* sleep to let other threads run... */</span>
		tsleep(&amp;nfs_nbdwrite, PCATCH, <span class="enscript-string">&quot;nfs_nbdwrite&quot;</span>, 1);
		FSDBG_BOT(542, np, blkno, nfs_nbdwrite, NFS_A_LOT_OF_DELAYED_WRITES);
	}

<span class="enscript-reference">loop</span>:
	lck_mtx_lock(nfs_buf_mutex);

	<span class="enscript-comment">/* wait for any buffer invalidation/flushing to complete */</span>
	<span class="enscript-keyword">while</span> (np-&gt;n_bflag &amp; NBINVALINPROG) {
		np-&gt;n_bflag |= NBINVALWANT;
		ts.tv_sec = 2;
		ts.tv_nsec = 0;
		msleep(&amp;np-&gt;n_bflag, nfs_buf_mutex, slpflag, <span class="enscript-string">&quot;nfs_buf_get_invalwait&quot;</span>, &amp;ts);
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(VTONMP(vp), NULL, thd, 0))) {
			lck_mtx_unlock(nfs_buf_mutex);
			FSDBG_BOT(541, np, blkno, 0, error);
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">if</span> (np-&gt;n_bflag &amp; NBINVALINPROG)
			slpflag = 0;
	}

	<span class="enscript-comment">/* check for existence of nfsbuf in cache */</span>
	<span class="enscript-keyword">if</span> ((bp = nfs_buf_incore(np, blkno))) {
		<span class="enscript-comment">/* if busy, set wanted and wait */</span>
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_lflags, NBL_BUSY)) {
			<span class="enscript-keyword">if</span> (flags &amp; NBLK_NOWAIT) {
				lck_mtx_unlock(nfs_buf_mutex);
				FSDBG_BOT(541, np, blkno, bp, 0xbcbcbcbc);
				<span class="enscript-keyword">return</span> (0);
			}
			FSDBG_TOP(543, np, blkno, bp, bp-&gt;nb_flags);
			SET(bp-&gt;nb_lflags, NBL_WANTED);

			ts.tv_sec = 2;
			ts.tv_nsec = 0;
			msleep(bp, nfs_buf_mutex, slpflag|(PRIBIO+1)|PDROP,
					<span class="enscript-string">&quot;nfsbufget&quot;</span>, (slpflag == PCATCH) ? NULL : &amp;ts);
			slpflag = 0;
			FSDBG_BOT(543, np, blkno, bp, bp-&gt;nb_flags);
			<span class="enscript-keyword">if</span> ((error = nfs_sigintr(VTONMP(vp), NULL, thd, 0))) {
				FSDBG_BOT(541, np, blkno, 0, error);
				<span class="enscript-keyword">return</span> (error);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
		}
		<span class="enscript-keyword">if</span> (bp-&gt;nb_bufsize != bufsize)
			panic(<span class="enscript-string">&quot;nfsbuf size mismatch&quot;</span>);
		SET(bp-&gt;nb_lflags, NBL_BUSY);
		SET(bp-&gt;nb_flags, NB_CACHE);
		nfs_buf_remfree(bp);
		<span class="enscript-comment">/* additional paranoia: */</span>
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_PAGELIST))
			panic(<span class="enscript-string">&quot;pagelist buffer was not busy&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">buffer_setup</span>;
	}

	<span class="enscript-keyword">if</span> (flags &amp; NBLK_ONLYVALID) {
		lck_mtx_unlock(nfs_buf_mutex);
		FSDBG_BOT(541, np, blkno, 0, 0x0000cace);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * where to get a free buffer:
	 * - if meta and maxmeta reached, must reuse meta
	 * - alloc new if we haven't reached min bufs
	 * - if free lists are NOT empty
	 *   - if free list is stale, use it
	 *   - else if freemeta list is stale, use it
	 *   - else if max bufs allocated, use least-time-to-stale
	 * - alloc new if we haven't reached max allowed
	 * - start clearing out delwri list and try again
	 */</span>

	<span class="enscript-keyword">if</span> ((operation == NBLK_META) &amp;&amp; (nfsbufmetacnt &gt;= nfsbufmetamax)) {
		<span class="enscript-comment">/* if we've hit max meta buffers, must reuse a meta buffer */</span>
		bp = TAILQ_FIRST(&amp;nfsbuffreemeta);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((nfsbufcnt &gt; nfsbufmin) &amp;&amp;
	    (!TAILQ_EMPTY(&amp;nfsbuffree) || !TAILQ_EMPTY(&amp;nfsbuffreemeta))) {
		<span class="enscript-comment">/* try to pull an nfsbuf off a free list */</span>
		<span class="enscript-type">struct</span> nfsbuf *lrubp, *metabp;
		<span class="enscript-type">struct</span> timeval now;
		microuptime(&amp;now);

		<span class="enscript-comment">/* if the next LRU or META buffer is invalid or stale, use it */</span>
		lrubp = TAILQ_FIRST(&amp;nfsbuffree);
		<span class="enscript-keyword">if</span> (lrubp &amp;&amp; (!NBUFSTAMPVALID(lrubp) ||
		    ((lrubp-&gt;nb_timestamp + NFSBUF_LRU_STALE) &lt; now.tv_sec)))
			bp = lrubp;
		metabp = TAILQ_FIRST(&amp;nfsbuffreemeta);
		<span class="enscript-keyword">if</span> (!bp &amp;&amp; metabp &amp;&amp; (!NBUFSTAMPVALID(metabp) ||
		    ((metabp-&gt;nb_timestamp + NFSBUF_META_STALE) &lt; now.tv_sec)))
			bp = metabp;

		<span class="enscript-keyword">if</span> (!bp &amp;&amp; (nfsbufcnt &gt;= nfsbufmax)) {
			<span class="enscript-comment">/* we've already allocated all bufs, so */</span>
			<span class="enscript-comment">/* choose the buffer that'll go stale first */</span>
			<span class="enscript-keyword">if</span> (!metabp)
				bp = lrubp;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!lrubp)
				bp = metabp;
			<span class="enscript-keyword">else</span> {
				int32_t lru_stale_time, meta_stale_time;
				lru_stale_time = lrubp-&gt;nb_timestamp + NFSBUF_LRU_STALE;
				meta_stale_time = metabp-&gt;nb_timestamp + NFSBUF_META_STALE;
				<span class="enscript-keyword">if</span> (lru_stale_time &lt;= meta_stale_time)
					bp = lrubp;
				<span class="enscript-keyword">else</span>
					bp = metabp;
			}
		}
	}

	<span class="enscript-keyword">if</span> (bp) {
		<span class="enscript-comment">/* we have a buffer to reuse */</span>
		FSDBG(544, np, blkno, bp, bp-&gt;nb_flags);
		nfs_buf_remfree(bp);
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_DELWRI))
			panic(<span class="enscript-string">&quot;nfs_buf_get: delwri&quot;</span>);
		SET(bp-&gt;nb_lflags, NBL_BUSY);
		<span class="enscript-comment">/* disassociate buffer from previous nfsnode */</span>
		<span class="enscript-keyword">if</span> (bp-&gt;nb_np) {
			<span class="enscript-keyword">if</span> (bp-&gt;nb_vnbufs.le_next != NFSNOLIST) {
				LIST_REMOVE(bp, nb_vnbufs);
				bp-&gt;nb_vnbufs.le_next = NFSNOLIST;
			}
			bp-&gt;nb_np = NULL;
		}
		LIST_REMOVE(bp, nb_hash);
		<span class="enscript-comment">/* nuke any creds we're holding */</span>
		<span class="enscript-keyword">if</span> (IS_VALID_CRED(bp-&gt;nb_rcred))
			kauth_cred_unref(&amp;bp-&gt;nb_rcred);
		<span class="enscript-keyword">if</span> (IS_VALID_CRED(bp-&gt;nb_wcred))
			kauth_cred_unref(&amp;bp-&gt;nb_wcred);
		<span class="enscript-comment">/* if buf will no longer be NB_META, dump old buffer */</span>
		<span class="enscript-keyword">if</span> (operation == NBLK_META) {
			<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_META))
				nfsbufmetacnt++;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_META)) {
			<span class="enscript-keyword">if</span> (bp-&gt;nb_data) {
				kfree(bp-&gt;nb_data, bp-&gt;nb_bufsize);
				bp-&gt;nb_data = NULL;
			}
			nfsbufmetacnt--;
		}
		<span class="enscript-comment">/* re-init buf fields */</span>
		bp-&gt;nb_error = 0;
		bp-&gt;nb_validoff = bp-&gt;nb_validend = -1;
		bp-&gt;nb_dirtyoff = bp-&gt;nb_dirtyend = 0;
		bp-&gt;nb_valid = 0;
		bp-&gt;nb_dirty = 0;
		bp-&gt;nb_verf = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* no buffer to reuse */</span>
		<span class="enscript-keyword">if</span> ((nfsbufcnt &lt; nfsbufmax) &amp;&amp;
		    ((operation != NBLK_META) || (nfsbufmetacnt &lt; nfsbufmetamax))) {
			<span class="enscript-comment">/* just alloc a new one */</span>
			MALLOC(bp, <span class="enscript-type">struct</span> nfsbuf *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfsbuf), M_TEMP, M_WAITOK);
			<span class="enscript-keyword">if</span> (!bp) {
				lck_mtx_unlock(nfs_buf_mutex);
				FSDBG_BOT(541, np, blkno, 0, error);
				<span class="enscript-keyword">return</span> (ENOMEM);
			}
			nfsbufcnt++;

			<span class="enscript-comment">/*
			 * If any excess bufs, make sure the timer
			 * is running to free them up later.
			 */</span>
			<span class="enscript-keyword">if</span> (nfsbufcnt &gt; nfsbufmin &amp;&amp; !nfs_buf_timer_on) {
				nfs_buf_timer_on = 1;
				nfs_interval_timer_start(nfs_buf_timer_call,
					NFSBUF_FREE_PERIOD * 1000);
			}

			<span class="enscript-keyword">if</span> (operation == NBLK_META)
				nfsbufmetacnt++;
			NFSBUFCNTCHK();
			<span class="enscript-comment">/* init nfsbuf */</span>
			bzero(bp, <span class="enscript-keyword">sizeof</span>(*bp));
			bp-&gt;nb_free.tqe_next = NFSNOLIST;
			bp-&gt;nb_validoff = bp-&gt;nb_validend = -1;
			FSDBG(545, np, blkno, bp, 0);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* too many bufs... wait for buffers to free up */</span>
			FSDBG_TOP(546, np, blkno, nfsbufcnt, nfsbufmax);

			<span class="enscript-comment">/* poke the delwri list */</span>
			nfs_buf_delwri_push(1);

			nfsneedbuffer = 1;
			msleep(&amp;nfsneedbuffer, nfs_buf_mutex, PCATCH|PDROP, <span class="enscript-string">&quot;nfsbufget&quot;</span>, NULL);
			FSDBG_BOT(546, np, blkno, nfsbufcnt, nfsbufmax);
			<span class="enscript-keyword">if</span> ((error = nfs_sigintr(VTONMP(vp), NULL, thd, 0))) {
				FSDBG_BOT(541, np, blkno, 0, error);
				<span class="enscript-keyword">return</span> (error);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
		}
	}

	<span class="enscript-comment">/* set up nfsbuf */</span>
	SET(bp-&gt;nb_lflags, NBL_BUSY);
	bp-&gt;nb_flags = 0;
	bp-&gt;nb_lblkno = blkno;
	<span class="enscript-comment">/* insert buf in hash */</span>
	LIST_INSERT_HEAD(NFSBUFHASH(np, blkno), bp, nb_hash);
	<span class="enscript-comment">/* associate buffer with new nfsnode */</span>
	bp-&gt;nb_np = np;
	LIST_INSERT_HEAD(&amp;np-&gt;n_cleanblkhd, bp, nb_vnbufs);

<span class="enscript-reference">buffer_setup</span>:

	<span class="enscript-comment">/* unlock hash */</span>
	lck_mtx_unlock(nfs_buf_mutex);

	<span class="enscript-keyword">switch</span> (operation) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NBLK_META</span>:
		SET(bp-&gt;nb_flags, NB_META);
		<span class="enscript-keyword">if</span> ((bp-&gt;nb_bufsize != bufsize) &amp;&amp; bp-&gt;nb_data) {
			kfree(bp-&gt;nb_data, bp-&gt;nb_bufsize);
			bp-&gt;nb_data = NULL;
			bp-&gt;nb_validoff = bp-&gt;nb_validend = -1;
			bp-&gt;nb_dirtyoff = bp-&gt;nb_dirtyend = 0;
			bp-&gt;nb_valid = 0;
			bp-&gt;nb_dirty = 0;
			CLR(bp-&gt;nb_flags, NB_CACHE);
		}
		<span class="enscript-keyword">if</span> (!bp-&gt;nb_data)
			bp-&gt;nb_data = kalloc(bufsize);
		<span class="enscript-keyword">if</span> (!bp-&gt;nb_data) {
			<span class="enscript-comment">/* Ack! couldn't allocate the data buffer! */</span>
			<span class="enscript-comment">/* clean up buffer and return error */</span>
			lck_mtx_lock(nfs_buf_mutex);
			LIST_REMOVE(bp, nb_vnbufs);
			bp-&gt;nb_vnbufs.le_next = NFSNOLIST;
			bp-&gt;nb_np = NULL;
			<span class="enscript-comment">/* invalidate usage timestamp to allow immediate freeing */</span>
			NBUFSTAMPINVALIDATE(bp);
			<span class="enscript-keyword">if</span> (bp-&gt;nb_free.tqe_next != NFSNOLIST)
				panic(<span class="enscript-string">&quot;nfsbuf on freelist&quot;</span>);
			TAILQ_INSERT_HEAD(&amp;nfsbuffree, bp, nb_free);
			nfsbuffreecnt++;
			lck_mtx_unlock(nfs_buf_mutex);
			FSDBG_BOT(541, np, blkno, 0xb00, ENOMEM);
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
		bp-&gt;nb_bufsize = bufsize;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">NBLK_READ</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NBLK_WRITE</span>:
		<span class="enscript-comment">/*
		 * Set or clear NB_READ now to let the UPL subsystem know
		 * if we intend to modify the pages or not.
		 */</span>
		<span class="enscript-keyword">if</span> (operation == NBLK_READ) {
			SET(bp-&gt;nb_flags, NB_READ);
		} <span class="enscript-keyword">else</span> {
			CLR(bp-&gt;nb_flags, NB_READ);
		}
		<span class="enscript-keyword">if</span> (bufsize &lt; PAGE_SIZE)
			bufsize = PAGE_SIZE;
		bp-&gt;nb_bufsize = bufsize;
		bp-&gt;nb_validoff = bp-&gt;nb_validend = -1;

		<span class="enscript-keyword">if</span> (UBCINFOEXISTS(vp)) {
			<span class="enscript-comment">/* set up upl */</span>
			<span class="enscript-keyword">if</span> (nfs_buf_upl_setup(bp)) {
				<span class="enscript-comment">/* unable to create upl */</span>
				<span class="enscript-comment">/* vm object must no longer exist */</span>
				<span class="enscript-comment">/* clean up buffer and return error */</span>
				lck_mtx_lock(nfs_buf_mutex);
				LIST_REMOVE(bp, nb_vnbufs);
				bp-&gt;nb_vnbufs.le_next = NFSNOLIST;
				bp-&gt;nb_np = NULL;
				<span class="enscript-comment">/* invalidate usage timestamp to allow immediate freeing */</span>
				NBUFSTAMPINVALIDATE(bp);
				<span class="enscript-keyword">if</span> (bp-&gt;nb_free.tqe_next != NFSNOLIST)
					panic(<span class="enscript-string">&quot;nfsbuf on freelist&quot;</span>);
				TAILQ_INSERT_HEAD(&amp;nfsbuffree, bp, nb_free);
				nfsbuffreecnt++;
				lck_mtx_unlock(nfs_buf_mutex);
				FSDBG_BOT(541, np, blkno, 0x2bc, EIO);
				<span class="enscript-keyword">return</span> (EIO);
			}
			nfs_buf_upl_check(bp);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;nfs_buf_get: %d unknown operation&quot;</span>, operation);
	}

	*bpp = bp;

	FSDBG_BOT(541, np, blkno, bp, bp-&gt;nb_flags);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_release</span>(<span class="enscript-type">struct</span> nfsbuf *bp, <span class="enscript-type">int</span> freeup)
{
	nfsnode_t np = bp-&gt;nb_np;
	vnode_t vp;
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">int</span> wakeup_needbuffer, wakeup_buffer, wakeup_nbdwrite;

	FSDBG_TOP(548, bp, NBOFF(bp), bp-&gt;nb_flags, bp-&gt;nb_data);
	FSDBG(548, bp-&gt;nb_validoff, bp-&gt;nb_validend, bp-&gt;nb_dirtyoff, bp-&gt;nb_dirtyend);
	FSDBG(548, bp-&gt;nb_valid, 0, bp-&gt;nb_dirty, 0);

	vp = np ? NFSTOV(np) : NULL;
	<span class="enscript-keyword">if</span> (vp &amp;&amp; UBCINFOEXISTS(vp) &amp;&amp; bp-&gt;nb_bufsize) {
		<span class="enscript-type">int</span> upl_flags, rv;
		upl_t upl;
		uint32_t i;

		<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_PAGELIST) &amp;&amp; !ISSET(bp-&gt;nb_flags, NB_INVAL)) {
			rv = nfs_buf_upl_setup(bp);
			<span class="enscript-keyword">if</span> (rv)
				printf(<span class="enscript-string">&quot;nfs_buf_release: upl create failed %d\n&quot;</span>, rv);
			<span class="enscript-keyword">else</span>
				nfs_buf_upl_check(bp);
		}
		upl = bp-&gt;nb_pagelist;
		<span class="enscript-keyword">if</span> (!upl)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">pagelist_cleanup_done</span>;
		<span class="enscript-keyword">if</span> (bp-&gt;nb_data) {
			<span class="enscript-keyword">if</span> (ubc_upl_unmap(upl) != KERN_SUCCESS)
				panic(<span class="enscript-string">&quot;ubc_upl_unmap failed&quot;</span>);
			bp-&gt;nb_data = NULL;
		}
		<span class="enscript-comment">/*
		 * Abort the pages on error or: if this is an invalid or
		 * non-needcommit nocache buffer AND no pages are dirty.
		 */</span>
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_ERROR) || (!bp-&gt;nb_dirty &amp;&amp; (ISSET(bp-&gt;nb_flags, NB_INVAL) ||
		    (ISSET(bp-&gt;nb_flags, NB_NOCACHE) &amp;&amp; !ISSET(bp-&gt;nb_flags, (NB_NEEDCOMMIT | NB_DELWRI)))))) {
			<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, (NB_READ | NB_INVAL | NB_NOCACHE)))
				upl_flags = UPL_ABORT_DUMP_PAGES;
			<span class="enscript-keyword">else</span>
				upl_flags = 0;
			ubc_upl_abort(upl, upl_flags);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">pagelist_cleanup_done</span>;
		}
		<span class="enscript-keyword">for</span> (i=0; i &lt;= (bp-&gt;nb_bufsize - 1)/PAGE_SIZE; i++) {
			<span class="enscript-keyword">if</span> (!NBPGVALID(bp,i))
				ubc_upl_abort_range(upl,
					i*PAGE_SIZE, PAGE_SIZE,
					UPL_ABORT_DUMP_PAGES |
					UPL_ABORT_FREE_ON_EMPTY);
			<span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (NBPGDIRTY(bp,i))
					upl_flags = UPL_COMMIT_SET_DIRTY;
				<span class="enscript-keyword">else</span>
					upl_flags = UPL_COMMIT_CLEAR_DIRTY;
				
				<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, (NB_NEEDCOMMIT | NB_DELWRI)))
					upl_flags |= UPL_COMMIT_CLEAR_PRECIOUS;

				ubc_upl_commit_range(upl,
					i*PAGE_SIZE, PAGE_SIZE,
					upl_flags |
					UPL_COMMIT_INACTIVATE |
					UPL_COMMIT_FREE_ON_EMPTY);
			}
		}
<span class="enscript-reference">pagelist_cleanup_done</span>:
		<span class="enscript-comment">/* invalidate any pages past EOF */</span>
		<span class="enscript-keyword">if</span> (NBOFF(bp) + bp-&gt;nb_bufsize &gt; (off_t)(np-&gt;n_size)) {
			off_t start, end;
			start = trunc_page_64(np-&gt;n_size) + PAGE_SIZE_64;
			end = trunc_page_64(NBOFF(bp) + bp-&gt;nb_bufsize);
			<span class="enscript-keyword">if</span> (start &lt; NBOFF(bp))
				start = NBOFF(bp);
			<span class="enscript-keyword">if</span> (end &gt; start) {
				<span class="enscript-keyword">if</span> ((rv = ubc_msync(vp, start, end, NULL, UBC_INVALIDATE)))
					printf(<span class="enscript-string">&quot;nfs_buf_release(): ubc_msync failed!, error %d\n&quot;</span>, rv);
			}
		}
		CLR(bp-&gt;nb_flags, NB_PAGELIST);
		bp-&gt;nb_pagelist = NULL;
	}

	lck_mtx_lock(nfs_buf_mutex);

	wakeup_needbuffer = wakeup_buffer = wakeup_nbdwrite = 0;

	<span class="enscript-comment">/* Wake up any processes waiting for any buffer to become free. */</span>
	<span class="enscript-keyword">if</span> (nfsneedbuffer) {
		nfsneedbuffer = 0;
		wakeup_needbuffer = 1;
	}
	<span class="enscript-comment">/* Wake up any processes waiting for _this_ buffer to become free. */</span>
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_lflags, NBL_WANTED)) {
		CLR(bp-&gt;nb_lflags, NBL_WANTED);
		wakeup_buffer = 1;
	}

	<span class="enscript-comment">/* If it's non-needcommit nocache, or an error, mark it invalid. */</span>
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_ERROR) ||
	    (ISSET(bp-&gt;nb_flags, NB_NOCACHE) &amp;&amp; !ISSET(bp-&gt;nb_flags, (NB_NEEDCOMMIT | NB_DELWRI))))
		SET(bp-&gt;nb_flags, NB_INVAL);

	<span class="enscript-keyword">if</span> ((bp-&gt;nb_bufsize &lt;= 0) || ISSET(bp-&gt;nb_flags, NB_INVAL)) {
		<span class="enscript-comment">/* If it's invalid or empty, dissociate it from its nfsnode */</span>
		<span class="enscript-keyword">if</span> (bp-&gt;nb_vnbufs.le_next != NFSNOLIST) {
			LIST_REMOVE(bp, nb_vnbufs);
			bp-&gt;nb_vnbufs.le_next = NFSNOLIST;
		}
		bp-&gt;nb_np = NULL;
		<span class="enscript-comment">/* if this was a delayed write, wakeup anyone */</span>
		<span class="enscript-comment">/* waiting for delayed writes to complete */</span>
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_DELWRI)) {
			CLR(bp-&gt;nb_flags, NB_DELWRI);
			nfs_nbdwrite--;
			NFSBUFCNTCHK();
			wakeup_nbdwrite = 1;
		}
		<span class="enscript-comment">/* invalidate usage timestamp to allow immediate freeing */</span>
		NBUFSTAMPINVALIDATE(bp);
		<span class="enscript-comment">/* put buffer at head of free list */</span>
		<span class="enscript-keyword">if</span> (bp-&gt;nb_free.tqe_next != NFSNOLIST)
			panic(<span class="enscript-string">&quot;nfsbuf on freelist&quot;</span>);
		SET(bp-&gt;nb_flags, NB_INVAL);
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_META)) {
			TAILQ_INSERT_HEAD(&amp;nfsbuffreemeta, bp, nb_free);
			nfsbuffreemetacnt++;
		} <span class="enscript-keyword">else</span> {
			TAILQ_INSERT_HEAD(&amp;nfsbuffree, bp, nb_free);
			nfsbuffreecnt++;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_DELWRI)) {
		<span class="enscript-comment">/* put buffer at end of delwri list */</span>
		<span class="enscript-keyword">if</span> (bp-&gt;nb_free.tqe_next != NFSNOLIST)
			panic(<span class="enscript-string">&quot;nfsbuf on freelist&quot;</span>);
		TAILQ_INSERT_TAIL(&amp;nfsbufdelwri, bp, nb_free);
		nfsbufdelwricnt++;
		freeup = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* update usage timestamp */</span>
		microuptime(&amp;now);
		bp-&gt;nb_timestamp = now.tv_sec;
		<span class="enscript-comment">/* put buffer at end of free list */</span>
		<span class="enscript-keyword">if</span> (bp-&gt;nb_free.tqe_next != NFSNOLIST)
			panic(<span class="enscript-string">&quot;nfsbuf on freelist&quot;</span>);
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_META)) {
			TAILQ_INSERT_TAIL(&amp;nfsbuffreemeta, bp, nb_free);
			nfsbuffreemetacnt++;
		} <span class="enscript-keyword">else</span> {
			TAILQ_INSERT_TAIL(&amp;nfsbuffree, bp, nb_free);
			nfsbuffreecnt++;
		}
	}

	NFSBUFCNTCHK();

	<span class="enscript-comment">/* Unlock the buffer. */</span>
	CLR(bp-&gt;nb_flags, (NB_ASYNC | NB_STABLE));
	CLR(bp-&gt;nb_lflags, NBL_BUSY);

	FSDBG_BOT(548, bp, NBOFF(bp), bp-&gt;nb_flags, bp-&gt;nb_data);

	lck_mtx_unlock(nfs_buf_mutex);

	<span class="enscript-keyword">if</span> (wakeup_needbuffer)
		wakeup(&amp;nfsneedbuffer);
	<span class="enscript-keyword">if</span> (wakeup_buffer)
		wakeup(bp);
	<span class="enscript-keyword">if</span> (wakeup_nbdwrite)
		wakeup(&amp;nfs_nbdwrite);
	<span class="enscript-keyword">if</span> (freeup)
		NFS_BUF_FREEUP();
}

<span class="enscript-comment">/*
 * Wait for operations on the buffer to complete.
 * When they do, extract and return the I/O's error value.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_buf_iowait</span>(<span class="enscript-type">struct</span> nfsbuf *bp)
{
	FSDBG_TOP(549, bp, NBOFF(bp), bp-&gt;nb_flags, bp-&gt;nb_error);

	lck_mtx_lock(nfs_buf_mutex);

	<span class="enscript-keyword">while</span> (!ISSET(bp-&gt;nb_flags, NB_DONE))
		msleep(bp, nfs_buf_mutex, PRIBIO + 1, <span class="enscript-string">&quot;nfs_buf_iowait&quot;</span>, NULL);

	lck_mtx_unlock(nfs_buf_mutex);

	FSDBG_BOT(549, bp, NBOFF(bp), bp-&gt;nb_flags, bp-&gt;nb_error);

	<span class="enscript-comment">/* check for interruption of I/O, then errors. */</span>
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_EINTR)) {
		CLR(bp-&gt;nb_flags, NB_EINTR);
		<span class="enscript-keyword">return</span> (EINTR);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_ERROR))
		<span class="enscript-keyword">return</span> (bp-&gt;nb_error ? bp-&gt;nb_error : EIO);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Mark I/O complete on a buffer.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_iodone</span>(<span class="enscript-type">struct</span> nfsbuf *bp)
{

	FSDBG_TOP(550, bp, NBOFF(bp), bp-&gt;nb_flags, bp-&gt;nb_error);

	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_DONE))
		panic(<span class="enscript-string">&quot;nfs_buf_iodone already&quot;</span>);

	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_READ)) {
		CLR(bp-&gt;nb_flags, NB_WRITEINPROG);
		<span class="enscript-comment">/*
		 * vnode_writedone() takes care of waking up
		 * any throttled write operations
		 */</span>
		vnode_writedone(NFSTOV(bp-&gt;nb_np));
		nfs_node_lock_force(bp-&gt;nb_np);
		bp-&gt;nb_np-&gt;n_numoutput--;
		nfs_node_unlock(bp-&gt;nb_np);
	}
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_ASYNC)) {	<span class="enscript-comment">/* if async, release it */</span>
		SET(bp-&gt;nb_flags, NB_DONE);		<span class="enscript-comment">/* note that it's done */</span>
		nfs_buf_release(bp, 1);
	} <span class="enscript-keyword">else</span> {		                        <span class="enscript-comment">/* or just wakeup the buffer */</span>	
	        lck_mtx_lock(nfs_buf_mutex);
		SET(bp-&gt;nb_flags, NB_DONE);		<span class="enscript-comment">/* note that it's done */</span>
		CLR(bp-&gt;nb_lflags, NBL_WANTED);
	        lck_mtx_unlock(nfs_buf_mutex);
		wakeup(bp);
	}

	FSDBG_BOT(550, bp, NBOFF(bp), bp-&gt;nb_flags, bp-&gt;nb_error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_write_delayed</span>(<span class="enscript-type">struct</span> nfsbuf *bp)
{
	nfsnode_t np = bp-&gt;nb_np;

	FSDBG_TOP(551, bp, NBOFF(bp), bp-&gt;nb_flags, 0);
	FSDBG(551, bp, bp-&gt;nb_dirtyoff, bp-&gt;nb_dirtyend, bp-&gt;nb_dirty);

	<span class="enscript-comment">/*
	 * If the block hasn't been seen before:
	 *	(1) Mark it as having been seen,
	 *	(2) Make sure it's on its node's correct block list,
	 */</span>
	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_DELWRI)) {
		SET(bp-&gt;nb_flags, NB_DELWRI);
		<span class="enscript-comment">/* move to dirty list */</span>
		lck_mtx_lock(nfs_buf_mutex);
		nfs_nbdwrite++;
		NFSBUFCNTCHK();
		<span class="enscript-keyword">if</span> (bp-&gt;nb_vnbufs.le_next != NFSNOLIST)
			LIST_REMOVE(bp, nb_vnbufs);
		LIST_INSERT_HEAD(&amp;np-&gt;n_dirtyblkhd, bp, nb_vnbufs);
		lck_mtx_unlock(nfs_buf_mutex);
	}

	<span class="enscript-comment">/*
	 * If the vnode has &quot;too many&quot; write operations in progress
	 * wait for them to finish the IO
	 */</span>
	vnode_waitforwrites(NFSTOV(np), VNODE_ASYNC_THROTTLE, 0, 0, <span class="enscript-string">&quot;nfs_buf_write_delayed&quot;</span>);

	<span class="enscript-comment">/* the file is in a modified state, so make sure the flag's set */</span>
	nfs_node_lock_force(np);
	np-&gt;n_flag |= NMODIFIED;
	nfs_node_unlock(np);

	<span class="enscript-comment">/*
	 * If we have too many delayed write buffers,
	 * just fall back to doing the async write.
	 */</span>
	<span class="enscript-keyword">if</span> (nfs_nbdwrite &lt; 0)
		panic(<span class="enscript-string">&quot;nfs_buf_write_delayed: Negative nfs_nbdwrite&quot;</span>);
	<span class="enscript-keyword">if</span> (nfs_nbdwrite &gt; NFS_A_LOT_OF_DELAYED_WRITES) {
		<span class="enscript-comment">/* issue async write */</span>
		SET(bp-&gt;nb_flags, NB_ASYNC);
		nfs_buf_write(bp);
		FSDBG_BOT(551, bp, NBOFF(bp), bp-&gt;nb_flags, bp-&gt;nb_error);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* Otherwise, the &quot;write&quot; is done, so mark and release the buffer. */</span>
	SET(bp-&gt;nb_flags, NB_DONE);
	nfs_buf_release(bp, 1);
	FSDBG_BOT(551, bp, NBOFF(bp), bp-&gt;nb_flags, 0);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Check that a &quot;needcommit&quot; buffer can still be committed.
 * If the write verifier has changed, we need to clear the
 * the needcommit flag.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_check_write_verifier</span>(nfsnode_t np, <span class="enscript-type">struct</span> nfsbuf *bp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;

	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_NEEDCOMMIT))
		<span class="enscript-keyword">return</span>;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_STALEWVERF) &amp;&amp; (bp-&gt;nb_verf == nmp-&gt;nm_verf))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* write verifier changed, clear commit/wverf flags */</span>
	CLR(bp-&gt;nb_flags, (NB_NEEDCOMMIT | NB_STALEWVERF));
	bp-&gt;nb_verf = 0;
	nfs_node_lock_force(np);
	np-&gt;n_needcommitcnt--;
	CHECK_NEEDCOMMITCNT(np);
	nfs_node_unlock(np);
}

<span class="enscript-comment">/*
 * add a reference to a buffer so it doesn't disappear while being used
 * (must be called with nfs_buf_mutex held)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_refget</span>(<span class="enscript-type">struct</span> nfsbuf *bp)
{
	bp-&gt;nb_refs++;
}
<span class="enscript-comment">/*
 * release a reference on a buffer
 * (must be called with nfs_buf_mutex held)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_refrele</span>(<span class="enscript-type">struct</span> nfsbuf *bp)
{
	bp-&gt;nb_refs--;
}

<span class="enscript-comment">/*
 * mark a particular buffer as BUSY
 * (must be called with nfs_buf_mutex held)
 */</span>
errno_t
<span class="enscript-function-name">nfs_buf_acquire</span>(<span class="enscript-type">struct</span> nfsbuf *bp, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> slpflag, <span class="enscript-type">int</span> slptimeo)
{
	errno_t error;
	<span class="enscript-type">struct</span> timespec ts;

	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_lflags, NBL_BUSY)) {
		<span class="enscript-comment">/*	
		 * since the lck_mtx_lock may block, the buffer
		 * may become BUSY, so we need to recheck for
		 * a NOWAIT request
		 */</span>
	        <span class="enscript-keyword">if</span> (flags &amp; NBAC_NOWAIT)
			<span class="enscript-keyword">return</span> (EBUSY);
	        SET(bp-&gt;nb_lflags, NBL_WANTED);

		ts.tv_sec = (slptimeo/100);
		<span class="enscript-comment">/* the hz value is 100; which leads to 10ms */</span>
		ts.tv_nsec = (slptimeo % 100) * 10  * NSEC_PER_USEC * 1000;

		error = msleep(bp, nfs_buf_mutex, slpflag | (PRIBIO + 1),
			<span class="enscript-string">&quot;nfs_buf_acquire&quot;</span>, &amp;ts);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">return</span> (EAGAIN);
	}
	<span class="enscript-keyword">if</span> (flags &amp; NBAC_REMOVE)
	        nfs_buf_remfree(bp);
	SET(bp-&gt;nb_lflags, NBL_BUSY);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * simply drop the BUSY status of a buffer
 * (must be called with nfs_buf_mutex held)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_drop</span>(<span class="enscript-type">struct</span> nfsbuf *bp)
{
	<span class="enscript-type">int</span> need_wakeup = 0;

	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_lflags, NBL_BUSY))
		panic(<span class="enscript-string">&quot;nfs_buf_drop: buffer not busy!&quot;</span>);
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_lflags, NBL_WANTED)) {
	        <span class="enscript-comment">/* delay the actual wakeup until after we clear NBL_BUSY */</span>
		need_wakeup = 1;
	}
	<span class="enscript-comment">/* Unlock the buffer. */</span>
	CLR(bp-&gt;nb_lflags, (NBL_BUSY | NBL_WANTED));

	<span class="enscript-keyword">if</span> (need_wakeup)
	        wakeup(bp);
}

<span class="enscript-comment">/*
 * prepare for iterating over an nfsnode's buffer list
 * this lock protects the queue manipulation
 * (must be called with nfs_buf_mutex held)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_buf_iterprepare</span>(nfsnode_t np, <span class="enscript-type">struct</span> nfsbuflists *iterheadp, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> nfsbuflists *listheadp;

	<span class="enscript-keyword">if</span> (flags &amp; NBI_DIRTY)
		listheadp = &amp;np-&gt;n_dirtyblkhd;
	<span class="enscript-keyword">else</span>
		listheadp = &amp;np-&gt;n_cleanblkhd;

	<span class="enscript-keyword">if</span> ((flags &amp; NBI_NOWAIT) &amp;&amp; (np-&gt;n_bufiterflags &amp; NBI_ITER)) {
	        LIST_INIT(iterheadp);
		<span class="enscript-keyword">return</span>(EWOULDBLOCK);
	}

	<span class="enscript-keyword">while</span> (np-&gt;n_bufiterflags &amp; NBI_ITER) 	{
	        np-&gt;n_bufiterflags |= NBI_ITERWANT;
		msleep(&amp;np-&gt;n_bufiterflags, nfs_buf_mutex, 0, <span class="enscript-string">&quot;nfs_buf_iterprepare&quot;</span>, NULL);
	}
	<span class="enscript-keyword">if</span> (LIST_EMPTY(listheadp)) {
	        LIST_INIT(iterheadp);
		<span class="enscript-keyword">return</span>(EINVAL);
	}
	np-&gt;n_bufiterflags |= NBI_ITER;

	iterheadp-&gt;lh_first = listheadp-&gt;lh_first;
	listheadp-&gt;lh_first-&gt;nb_vnbufs.le_prev = &amp;iterheadp-&gt;lh_first;	
	LIST_INIT(listheadp);

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * clean up after iterating over an nfsnode's buffer list
 * this lock protects the queue manipulation
 * (must be called with nfs_buf_mutex held)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_itercomplete</span>(nfsnode_t np, <span class="enscript-type">struct</span> nfsbuflists *iterheadp, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> nfsbuflists * listheadp;
	<span class="enscript-type">struct</span> nfsbuf *bp;

	<span class="enscript-keyword">if</span> (flags &amp; NBI_DIRTY)
		listheadp = &amp;np-&gt;n_dirtyblkhd;
	<span class="enscript-keyword">else</span>
		listheadp = &amp;np-&gt;n_cleanblkhd;

	<span class="enscript-keyword">while</span> (!LIST_EMPTY(iterheadp)) {
		bp = LIST_FIRST(iterheadp);
		LIST_REMOVE(bp, nb_vnbufs);
		LIST_INSERT_HEAD(listheadp, bp, nb_vnbufs);
	}

	np-&gt;n_bufiterflags &amp;= ~NBI_ITER;
	<span class="enscript-keyword">if</span> (np-&gt;n_bufiterflags &amp; NBI_ITERWANT) {
		np-&gt;n_bufiterflags &amp;= ~NBI_ITERWANT;
		wakeup(&amp;np-&gt;n_bufiterflags);
	}
}


<span class="enscript-comment">/*
 * Read an NFS buffer for a file.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_buf_read</span>(<span class="enscript-type">struct</span> nfsbuf *bp)
{
	<span class="enscript-type">int</span> error = 0;
	nfsnode_t np;
	thread_t thd;
	kauth_cred_t cred;

	np = bp-&gt;nb_np;
	cred = bp-&gt;nb_rcred;
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
		kauth_cred_ref(cred);
	thd = ISSET(bp-&gt;nb_flags, NB_ASYNC) ? NULL : current_thread();

	<span class="enscript-comment">/* sanity checks */</span>
	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_READ))
		panic(<span class="enscript-string">&quot;nfs_buf_read: !NB_READ&quot;</span>);
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_DONE))
		CLR(bp-&gt;nb_flags, NB_DONE);

	NFS_BUF_MAP(bp);

	OSAddAtomic64(1, &amp;nfsstats.read_bios);

	error = nfs_buf_read_rpc(bp, thd, cred);
	<span class="enscript-comment">/*
	 * For async I/O, the callbacks will finish up the
	 * read.  Otherwise, the read has already been finished.
	 */</span>

	<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
		kauth_cred_unref(&amp;cred);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * finish the reading of a buffer
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_read_finish</span>(<span class="enscript-type">struct</span> nfsbuf *bp)
{
	nfsnode_t np = bp-&gt;nb_np;
	<span class="enscript-type">struct</span> nfsmount *nmp;

	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_ERROR)) {
		<span class="enscript-comment">/* update valid range */</span>
		bp-&gt;nb_validoff = 0;
		bp-&gt;nb_validend = bp-&gt;nb_endio;
		<span class="enscript-keyword">if</span> (bp-&gt;nb_endio &lt; (<span class="enscript-type">int</span>)bp-&gt;nb_bufsize) { 
			<span class="enscript-comment">/*
			 * The read may be short because we have unflushed writes
			 * that are extending the file size and the reads hit the
			 * (old) EOF on the server.  So, just make sure nb_validend
			 * correctly tracks EOF.
			 * Note that the missing data should have already been zeroed
			 * in nfs_buf_read_rpc_finish().
			 */</span>
			off_t boff = NBOFF(bp);
			<span class="enscript-keyword">if</span> ((off_t)np-&gt;n_size &gt;= (boff + bp-&gt;nb_bufsize))
				bp-&gt;nb_validend = bp-&gt;nb_bufsize;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((off_t)np-&gt;n_size &gt;= boff)
				bp-&gt;nb_validend = np-&gt;n_size - boff;
			<span class="enscript-keyword">else</span>
				bp-&gt;nb_validend = 0;
		}
		<span class="enscript-keyword">if</span> ((nmp = NFSTONMP(np)) &amp;&amp; (nmp-&gt;nm_vers == NFS_VER2) &amp;&amp;
		    ((NBOFF(bp) + bp-&gt;nb_validend) &gt; 0x100000000LL))
			bp-&gt;nb_validend = 0x100000000LL - NBOFF(bp);
		bp-&gt;nb_valid = (1 &lt;&lt; (round_page_32(bp-&gt;nb_validend) / PAGE_SIZE)) - 1;
		<span class="enscript-keyword">if</span> (bp-&gt;nb_validend &amp; PAGE_MASK) {
			<span class="enscript-comment">/* zero-fill remainder of last page */</span>
			bzero(bp-&gt;nb_data + bp-&gt;nb_validend, PAGE_SIZE - (bp-&gt;nb_validend &amp; PAGE_MASK));
		}
	}
	nfs_buf_iodone(bp);
}

<span class="enscript-comment">/*
 * initiate the NFS READ RPC(s) for a buffer
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_buf_read_rpc</span>(<span class="enscript-type">struct</span> nfsbuf *bp, thread_t thd, kauth_cred_t cred)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	nfsnode_t np = bp-&gt;nb_np;
	<span class="enscript-type">int</span> error = 0, nfsvers, async;
	<span class="enscript-type">int</span> offset, nrpcs;
	uint32_t nmrsize, length, len;
	off_t boff;
	<span class="enscript-type">struct</span> nfsreq *req;
	<span class="enscript-type">struct</span> nfsreq_cbinfo cb;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		bp-&gt;nb_error = error = ENXIO;
		SET(bp-&gt;nb_flags, NB_ERROR);
		nfs_buf_iodone(bp);
		<span class="enscript-keyword">return</span> (error);
	}
	nfsvers = nmp-&gt;nm_vers;
	nmrsize = nmp-&gt;nm_rsize;

	boff = NBOFF(bp);
	offset = 0;
	length = bp-&gt;nb_bufsize;

	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER2) {
		<span class="enscript-keyword">if</span> (boff &gt; 0xffffffffLL) {
			bp-&gt;nb_error = error = EFBIG;
			SET(bp-&gt;nb_flags, NB_ERROR);
			nfs_buf_iodone(bp);
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">if</span> ((boff + length - 1) &gt; 0xffffffffLL)
			length = 0x100000000LL - boff;
	}

	<span class="enscript-comment">/* Note: Can only do async I/O if nfsiods are configured. */</span>
	async = (bp-&gt;nb_flags &amp; NB_ASYNC);
	cb.rcb_func = async ? nfs_buf_read_rpc_finish : NULL;
	cb.rcb_bp = bp;

	bp-&gt;nb_offio = bp-&gt;nb_endio = 0;
	bp-&gt;nb_rpcs = nrpcs = (length + nmrsize - 1) / nmrsize;
	<span class="enscript-keyword">if</span> (async &amp;&amp; (nrpcs &gt; 1)) {
		SET(bp-&gt;nb_flags, NB_MULTASYNCRPC);
	} <span class="enscript-keyword">else</span> {
		CLR(bp-&gt;nb_flags, NB_MULTASYNCRPC);
	}

	<span class="enscript-keyword">while</span> (length &gt; 0) {
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_ERROR)) {
			error = bp-&gt;nb_error;
			<span class="enscript-keyword">break</span>;
		}
		len = (length &gt; nmrsize) ? nmrsize : length;
		cb.rcb_args[0] = offset;
		cb.rcb_args[1] = len;
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4)
			cb.rcb_args[2] = nmp-&gt;nm_stategenid;
		req = NULL;
		error = nmp-&gt;nm_funcs-&gt;nf_read_rpc_async(np, boff + offset, len, thd, cred, &amp;cb, &amp;req);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		offset += len;
		length -= len;
		<span class="enscript-keyword">if</span> (async)
			<span class="enscript-keyword">continue</span>;
		nfs_buf_read_rpc_finish(req);
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_ERROR)) {
			error = bp-&gt;nb_error;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (length &gt; 0) {
		<span class="enscript-comment">/*
		 * Something bad happened while trying to send the RPC(s).
		 * Wait for any outstanding requests to complete.
		 */</span>
		bp-&gt;nb_error = error;
		SET(bp-&gt;nb_flags, NB_ERROR);
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_MULTASYNCRPC)) {
			nrpcs = (length + nmrsize - 1) / nmrsize;
			lck_mtx_lock(nfs_buf_mutex);
			bp-&gt;nb_rpcs -= nrpcs;
			<span class="enscript-keyword">if</span> (bp-&gt;nb_rpcs == 0) {
				<span class="enscript-comment">/* No RPCs left, so the buffer's done */</span>
				lck_mtx_unlock(nfs_buf_mutex);
				nfs_buf_iodone(bp);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* wait for the last RPC to mark it done */</span>
				<span class="enscript-keyword">while</span> (bp-&gt;nb_rpcs &gt; 0)
					msleep(&amp;bp-&gt;nb_rpcs, nfs_buf_mutex, 0,
						<span class="enscript-string">&quot;nfs_buf_read_rpc_cancel&quot;</span>, NULL);
				lck_mtx_unlock(nfs_buf_mutex);
			}
		} <span class="enscript-keyword">else</span> {
			nfs_buf_iodone(bp);
		}
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * finish up an NFS READ RPC on a buffer
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_read_rpc_finish</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	size_t rlen;
	<span class="enscript-type">struct</span> nfsreq_cbinfo cb;
	<span class="enscript-type">struct</span> nfsbuf *bp;
	<span class="enscript-type">int</span> error = 0, nfsvers, offset, length, eof = 0, multasyncrpc, finished;
	<span class="enscript-type">void</span> *wakeme = NULL;
	<span class="enscript-type">struct</span> nfsreq *rreq = NULL;
	nfsnode_t np;
	thread_t thd;
	kauth_cred_t cred;
	uio_t auio;
	<span class="enscript-type">char</span> uio_buf [ UIO_SIZEOF(1) ];

<span class="enscript-reference">finish</span>:
	np = req-&gt;r_np;
	thd = req-&gt;r_thread;
	cred = req-&gt;r_cred;
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
		kauth_cred_ref(cred);
	cb = req-&gt;r_callback;
	bp = cb.rcb_bp;
	<span class="enscript-keyword">if</span> (cb.rcb_func) <span class="enscript-comment">/* take an extra reference on the nfsreq in case we want to resend it later due to grace error */</span>
		nfs_request_ref(req, 0);

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		SET(bp-&gt;nb_flags, NB_ERROR);
		bp-&gt;nb_error = error = ENXIO;
	}
	<span class="enscript-keyword">if</span> (error || ISSET(bp-&gt;nb_flags, NB_ERROR)) {
		<span class="enscript-comment">/* just drop it */</span>
		nfs_request_async_cancel(req);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	nfsvers = nmp-&gt;nm_vers;
	offset = cb.rcb_args[0];
	rlen = length = cb.rcb_args[1];

	auio = uio_createwithbuffer(1, NBOFF(bp) + offset, UIO_SYSSPACE,
                                UIO_READ, &amp;uio_buf, <span class="enscript-keyword">sizeof</span>(uio_buf));
	uio_addiov(auio, CAST_USER_ADDR_T(bp-&gt;nb_data + offset), length);

	<span class="enscript-comment">/* finish the RPC */</span>
	error = nmp-&gt;nm_funcs-&gt;nf_read_rpc_async_finish(np, req, auio, &amp;rlen, &amp;eof);
	<span class="enscript-keyword">if</span> ((error == EINPROGRESS) &amp;&amp; cb.rcb_func) {
		<span class="enscript-comment">/* async request restarted */</span>
		<span class="enscript-keyword">if</span> (cb.rcb_func)
			nfs_request_rele(req);
		<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
			kauth_cred_unref(&amp;cred);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; nfs_mount_state_error_should_restart(error) &amp;&amp; !ISSET(bp-&gt;nb_flags, NB_ERROR)) {
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">if</span> ((error != NFSERR_OLD_STATEID) &amp;&amp; (error != NFSERR_GRACE) &amp;&amp; (cb.rcb_args[2] == nmp-&gt;nm_stategenid)) {
			NP(np, <span class="enscript-string">&quot;nfs_buf_read_rpc_finish: error %d @ 0x%llx, 0x%x 0x%x, initiating recovery&quot;</span>,
				error, NBOFF(bp)+offset, cb.rcb_args[2], nmp-&gt;nm_stategenid);
			nfs_need_recover(nmp, error);
		}
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
			error = EIO;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (error == NFSERR_GRACE) {
				<span class="enscript-keyword">if</span> (cb.rcb_func) {
					<span class="enscript-comment">/*
					 * For an async I/O request, handle a grace delay just like
					 * jukebox errors.  Set the resend time and queue it up.
					 */</span>
					<span class="enscript-type">struct</span> timeval now;
					<span class="enscript-keyword">if</span> (req-&gt;r_nmrep.nmc_mhead) {
						mbuf_freem(req-&gt;r_nmrep.nmc_mhead);
						req-&gt;r_nmrep.nmc_mhead = NULL;
					}
					req-&gt;r_error = 0;
					microuptime(&amp;now);
					lck_mtx_lock(&amp;req-&gt;r_mtx);
					req-&gt;r_resendtime = now.tv_sec + 2;
					req-&gt;r_xid = 0;                 <span class="enscript-comment">// get a new XID
</span>					req-&gt;r_flags |= R_RESTART;
					req-&gt;r_start = 0;
					nfs_asyncio_resend(req);
					lck_mtx_unlock(&amp;req-&gt;r_mtx);
					<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
						kauth_cred_unref(&amp;cred);
					<span class="enscript-comment">/* Note: nfsreq reference taken will be dropped later when finished */</span>
					<span class="enscript-keyword">return</span>;
				}
				<span class="enscript-comment">/* otherwise, just pause a couple seconds and retry */</span>
				tsleep(&amp;nmp-&gt;nm_state, (PZERO-1), <span class="enscript-string">&quot;nfsgrace&quot;</span>, 2*hz);
			}
			<span class="enscript-keyword">if</span> (!(error = nfs_mount_state_wait_for_recovery(nmp))) {
				rlen = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">readagain</span>;
			}
		}
	}
	<span class="enscript-keyword">if</span> (error) {
		SET(bp-&gt;nb_flags, NB_ERROR);
		bp-&gt;nb_error = error;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> ((rlen &gt; 0) &amp;&amp; (bp-&gt;nb_endio &lt; (offset + (<span class="enscript-type">int</span>)rlen)))
		bp-&gt;nb_endio = offset + rlen;

	<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER2) || eof || (rlen == 0)) {
		<span class="enscript-comment">/* zero out the remaining data (up to EOF) */</span>
		off_t rpcrem, eofrem, rem;
		rpcrem = (length - rlen);
		eofrem = np-&gt;n_size - (NBOFF(bp) + offset + rlen);
		rem = (rpcrem &lt; eofrem) ? rpcrem : eofrem;
		<span class="enscript-keyword">if</span> (rem &gt; 0)
			bzero(bp-&gt;nb_data + offset + rlen, rem);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (((<span class="enscript-type">int</span>)rlen &lt; length) &amp;&amp; !ISSET(bp-&gt;nb_flags, NB_ERROR)) {
		<span class="enscript-comment">/*
		 * short read
		 *
		 * We haven't hit EOF and we didn't get all the data
		 * requested, so we need to issue another read for the rest.
		 * (Don't bother if the buffer already hit an error.)
		 */</span>
<span class="enscript-reference">readagain</span>:
		offset += rlen;
		length -= rlen;
		cb.rcb_args[0] = offset;
		cb.rcb_args[1] = length;
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4)
			cb.rcb_args[2] = nmp-&gt;nm_stategenid;
		error = nmp-&gt;nm_funcs-&gt;nf_read_rpc_async(np, NBOFF(bp) + offset, length, thd, cred, &amp;cb, &amp;rreq);
		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
				kauth_cred_unref(&amp;cred);
			<span class="enscript-keyword">if</span> (!cb.rcb_func) {
				<span class="enscript-comment">/* if !async we'll need to wait for this RPC to finish */</span>
				req = rreq;
				rreq = NULL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
			}
			nfs_request_rele(req);
			<span class="enscript-comment">/*
			 * We're done here.
			 * Outstanding RPC count is unchanged.
			 * Callback will be called when RPC is done.
			 */</span>
			<span class="enscript-keyword">return</span>;
		}
		SET(bp-&gt;nb_flags, NB_ERROR);
		bp-&gt;nb_error = error;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (cb.rcb_func)
		nfs_request_rele(req);
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
		kauth_cred_unref(&amp;cred);

	<span class="enscript-comment">/*
	 * Decrement outstanding RPC count on buffer
	 * and call nfs_buf_read_finish on last RPC.
	 *
	 * (Note: when there are multiple async RPCs issued for a
	 * buffer we need nfs_buffer_mutex to avoid problems when
	 * aborting a partially-initiated set of RPCs)
	 */</span>

	multasyncrpc = ISSET(bp-&gt;nb_flags, NB_MULTASYNCRPC);
	<span class="enscript-keyword">if</span> (multasyncrpc)
		lck_mtx_lock(nfs_buf_mutex);

	bp-&gt;nb_rpcs--;
	finished = (bp-&gt;nb_rpcs == 0);

	<span class="enscript-keyword">if</span> (multasyncrpc)
		lck_mtx_unlock(nfs_buf_mutex);

	<span class="enscript-keyword">if</span> (finished) {
		<span class="enscript-keyword">if</span> (multasyncrpc)
			wakeme = &amp;bp-&gt;nb_rpcs;
		nfs_buf_read_finish(bp);
		<span class="enscript-keyword">if</span> (wakeme)
			wakeup(wakeme);
	}
}

<span class="enscript-comment">/*
 * Do buffer readahead.
 * Initiate async I/O to read buffers not in cache.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_buf_readahead</span>(nfsnode_t np, <span class="enscript-type">int</span> ioflag, daddr64_t *rabnp, daddr64_t lastrabn, thread_t thd, kauth_cred_t cred)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(np);
	<span class="enscript-type">struct</span> nfsbuf *bp;
	<span class="enscript-type">int</span> error = 0;
	uint32_t nra;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_readahead &lt;= 0)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> (*rabnp &gt; lastrabn)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">for</span> (nra = 0; (nra &lt; nmp-&gt;nm_readahead) &amp;&amp; (*rabnp &lt;= lastrabn); nra++, *rabnp = *rabnp + 1) {
		<span class="enscript-comment">/* check if block exists and is valid. */</span>
		<span class="enscript-keyword">if</span> ((*rabnp * nmp-&gt;nm_biosize) &gt;= (off_t)np-&gt;n_size) {
			<span class="enscript-comment">/* stop reading ahead if we're beyond EOF */</span>
			*rabnp = lastrabn;
			<span class="enscript-keyword">break</span>;
		}
		error = nfs_buf_get(np, *rabnp, nmp-&gt;nm_biosize, thd, NBLK_READ|NBLK_NOWAIT, &amp;bp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		nfs_node_lock_force(np);
		np-&gt;n_lastrahead = *rabnp;
		nfs_node_unlock(np);
		<span class="enscript-keyword">if</span> (!bp)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> ((ioflag &amp; IO_NOCACHE) &amp;&amp; ISSET(bp-&gt;nb_flags, NB_CACHE) &amp;&amp;
		    !bp-&gt;nb_dirty &amp;&amp; !ISSET(bp-&gt;nb_flags, (NB_DELWRI|NB_NCRDAHEAD))) {
			CLR(bp-&gt;nb_flags, NB_CACHE);
			bp-&gt;nb_valid = 0;
			bp-&gt;nb_validoff = bp-&gt;nb_validend = -1;
		}
		<span class="enscript-keyword">if</span> ((bp-&gt;nb_dirtyend &lt;= 0) &amp;&amp; !bp-&gt;nb_dirty &amp;&amp;
		    !ISSET(bp-&gt;nb_flags, (NB_CACHE|NB_DELWRI))) {
			SET(bp-&gt;nb_flags, (NB_READ|NB_ASYNC));
			<span class="enscript-keyword">if</span> (ioflag &amp; IO_NOCACHE)
				SET(bp-&gt;nb_flags, NB_NCRDAHEAD);
			<span class="enscript-keyword">if</span> (!IS_VALID_CRED(bp-&gt;nb_rcred) &amp;&amp; IS_VALID_CRED(cred)) {
				kauth_cred_ref(cred);
				bp-&gt;nb_rcred = cred;
			}
			<span class="enscript-keyword">if</span> ((error = nfs_buf_read(bp)))
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">continue</span>;
		}
		nfs_buf_release(bp, 1);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS buffer I/O for reading files.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_bioread</span>(nfsnode_t np, uio_t uio, <span class="enscript-type">int</span> ioflag, vfs_context_t ctx)
{
	vnode_t vp = NFSTOV(np);
	<span class="enscript-type">struct</span> nfsbuf *bp = NULL;
	<span class="enscript-type">struct</span> nfsmount *nmp = VTONMP(vp);
	daddr64_t lbn, rabn = 0, lastrabn, maxrabn = -1;
	off_t diff;
	<span class="enscript-type">int</span> error = 0, n = 0, on = 0;
	<span class="enscript-type">int</span> nfsvers, biosize, modified, readaheads = 0;
	thread_t thd;
	kauth_cred_t cred;
	int64_t io_resid;

	FSDBG_TOP(514, np, uio_offset(uio), uio_resid(uio), ioflag);

	nfsvers = nmp-&gt;nm_vers;
	biosize = nmp-&gt;nm_biosize;
	thd = vfs_context_thread(ctx);
	cred = vfs_context_ucred(ctx);

	<span class="enscript-keyword">if</span> (vnode_vtype(vp) != VREG) {
		printf(<span class="enscript-string">&quot;nfs_bioread: type %x unexpected\n&quot;</span>, vnode_vtype(vp));
		FSDBG_BOT(514, np, 0xd1e0016, 0, EINVAL);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/*
	 * For NFS, cache consistency can only be maintained approximately.
	 * Although RFC1094 does not specify the criteria, the following is
	 * believed to be compatible with the reference port.
	 * 
	 * If the file has changed since the last read RPC or you have
	 * written to the file, you may have lost data cache consistency
	 * with the server.  So, check for a change, and flush all of the
	 * file's data out of the cache.
	 * NB: This implies that cache data can be read when up to
	 * NFS_MAXATTRTIMO seconds out of date. If you find that you
	 * need current attributes, nfs_getattr() can be forced to fetch
	 * new attributes (via NATTRINVALIDATE() or NGA_UNCACHED).
	 */</span>

	<span class="enscript-keyword">if</span> (ISSET(np-&gt;n_flag, NUPDATESIZE))
		nfs_data_update_size(np, 0);

	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np))) {
		FSDBG_BOT(514, np, 0xd1e0222, 0, error);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NNEEDINVALIDATE) {
		np-&gt;n_flag &amp;= ~NNEEDINVALIDATE;
		nfs_node_unlock(np);
		error = nfs_vinvalbuf(vp, V_SAVE|V_IGNORE_WRITEERR, ctx, 1);
		<span class="enscript-keyword">if</span> (!error)
			error = nfs_node_lock(np);
		<span class="enscript-keyword">if</span> (error) {
			FSDBG_BOT(514, np, 0xd1e0322, 0, error);
			<span class="enscript-keyword">return</span> (error);
		}
	}

	modified = (np-&gt;n_flag &amp; NMODIFIED);
	nfs_node_unlock(np);
	<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
	error = nfs_getattr(np, NULL, ctx, modified ? NGA_UNCACHED : NGA_CACHED);
	<span class="enscript-keyword">if</span> (error) {
		FSDBG_BOT(514, np, 0xd1e0004, 0, error);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> (uio_resid(uio) == 0) {
		FSDBG_BOT(514, np, 0xd1e0001, 0, 0);
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">if</span> (uio_offset(uio) &lt; 0) {
		FSDBG_BOT(514, np, 0xd1e0002, 0, EINVAL);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/*
	 * set up readahead - which may be limited by:
	 * + current request length (for IO_NOCACHE)
	 * + readahead setting
	 * + file size
	 */</span>
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_readahead &gt; 0) {
		off_t end = uio_offset(uio) + uio_resid(uio);
		<span class="enscript-keyword">if</span> (end &gt; (off_t)np-&gt;n_size)
			end = np-&gt;n_size;
		rabn = uio_offset(uio) / biosize;
		maxrabn = (end - 1) / biosize;
		nfs_node_lock_force(np);
		<span class="enscript-keyword">if</span> (!(ioflag &amp; IO_NOCACHE) &amp;&amp;
		    (!rabn || (rabn == np-&gt;n_lastread) || (rabn == (np-&gt;n_lastread+1)))) {
			maxrabn += nmp-&gt;nm_readahead;
			<span class="enscript-keyword">if</span> ((maxrabn * biosize) &gt;= (off_t)np-&gt;n_size)
				maxrabn = ((off_t)np-&gt;n_size - 1)/biosize;
		}
		<span class="enscript-keyword">if</span> (maxrabn &lt; np-&gt;n_lastrahead)
			np-&gt;n_lastrahead = -1;
		<span class="enscript-keyword">if</span> (rabn &lt; np-&gt;n_lastrahead)
			rabn = np-&gt;n_lastrahead + 1;
		nfs_node_unlock(np);
	} <span class="enscript-keyword">else</span> {
		rabn = maxrabn = 0;
	}

	<span class="enscript-keyword">do</span> {

		nfs_data_lock(np, NFS_DATA_LOCK_SHARED);
		lbn = uio_offset(uio) / biosize;

		<span class="enscript-comment">/*
		 * Copy directly from any cached pages without grabbing the bufs.
		 * (If we are NOCACHE and we've issued readahead requests, we need
		 * to grab the NB_NCRDAHEAD bufs to drop them.)
		 */</span>
		<span class="enscript-keyword">if</span> ((!(ioflag &amp; IO_NOCACHE) || !readaheads) &amp;&amp;
		    ((uio-&gt;uio_segflg == UIO_USERSPACE32 ||
		      uio-&gt;uio_segflg == UIO_USERSPACE64 ||
		      uio-&gt;uio_segflg == UIO_USERSPACE))) {
			io_resid = uio_resid(uio);
			diff = np-&gt;n_size - uio_offset(uio);
			<span class="enscript-keyword">if</span> (diff &lt; io_resid)
				io_resid = diff;
			<span class="enscript-keyword">if</span> (io_resid &gt; 0) {
				<span class="enscript-type">int</span> count = (io_resid &gt; INT_MAX) ? INT_MAX : io_resid;
				error = cluster_copy_ubc_data(vp, uio, &amp;count, 0);
				<span class="enscript-keyword">if</span> (error) {
					nfs_data_unlock(np);
					FSDBG_BOT(514, np, uio_offset(uio), 0xcacefeed, error);
					<span class="enscript-keyword">return</span> (error);
				}
			}
			<span class="enscript-comment">/* count any biocache reads that we just copied directly */</span>
			<span class="enscript-keyword">if</span> (lbn != (uio_offset(uio)/biosize)) {
				OSAddAtomic64((uio_offset(uio)/biosize) - lbn, &amp;nfsstats.biocache_reads);
				FSDBG(514, np, 0xcacefeed, uio_offset(uio), error);
			}
		}

		lbn = uio_offset(uio) / biosize;
		on = uio_offset(uio) % biosize;
		nfs_node_lock_force(np);
		np-&gt;n_lastread = (uio_offset(uio) - 1) / biosize;
		nfs_node_unlock(np);

		<span class="enscript-keyword">if</span> ((uio_resid(uio) &lt;= 0) || (uio_offset(uio) &gt;= (off_t)np-&gt;n_size)) {
			nfs_data_unlock(np);
			FSDBG_BOT(514, np, uio_offset(uio), uio_resid(uio), 0xaaaaaaaa);
			<span class="enscript-keyword">return</span> (0);
		}

		<span class="enscript-comment">/* adjust readahead block number, if necessary */</span>
		<span class="enscript-keyword">if</span> (rabn &lt; lbn)
			rabn = lbn;
		lastrabn = MIN(maxrabn, lbn + nmp-&gt;nm_readahead);
		<span class="enscript-keyword">if</span> (rabn &lt;= lastrabn) { <span class="enscript-comment">/* start readaheads */</span>
			error = nfs_buf_readahead(np, ioflag, &amp;rabn, lastrabn, thd, cred);
			<span class="enscript-keyword">if</span> (error) {
				nfs_data_unlock(np);
				FSDBG_BOT(514, np, 0xd1e000b, 1, error);
				<span class="enscript-keyword">return</span> (error);
			}
			readaheads = 1;
		}

		OSAddAtomic64(1, &amp;nfsstats.biocache_reads);

		<span class="enscript-comment">/*
		 * If the block is in the cache and has the required data
		 * in a valid region, just copy it out.
		 * Otherwise, get the block and write back/read in,
		 * as required.
		 */</span>
<span class="enscript-reference">again</span>:
		io_resid = uio_resid(uio);
		n = (io_resid &gt; (biosize - on)) ? (biosize - on) : io_resid;
		diff = np-&gt;n_size - uio_offset(uio);
		<span class="enscript-keyword">if</span> (diff &lt; n)
			n = diff;

		error = nfs_buf_get(np, lbn, biosize, thd, NBLK_READ, &amp;bp);
		<span class="enscript-keyword">if</span> (error) {
			nfs_data_unlock(np);
			FSDBG_BOT(514, np, 0xd1e000c, 0, error);
			<span class="enscript-keyword">return</span> (error);
		}

		<span class="enscript-keyword">if</span> ((ioflag &amp; IO_NOCACHE) &amp;&amp; ISSET(bp-&gt;nb_flags, NB_CACHE)) {
			<span class="enscript-comment">/*
			 * IO_NOCACHE found a cached buffer.
			 * Flush the buffer if it's dirty.
			 * Invalidate the data if it wasn't just read
			 * in as part of a &quot;nocache readahead&quot;.
			 */</span>
			<span class="enscript-keyword">if</span> (bp-&gt;nb_dirty || (bp-&gt;nb_dirtyend &gt; 0)) {
				<span class="enscript-comment">/* so write the buffer out and try again */</span>
				SET(bp-&gt;nb_flags, NB_NOCACHE);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">flushbuffer</span>;
			}
			<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_NCRDAHEAD)) {
				CLR(bp-&gt;nb_flags, NB_NCRDAHEAD);
				SET(bp-&gt;nb_flags, NB_NOCACHE);
			}
		}

		<span class="enscript-comment">/* if any pages are valid... */</span>
		<span class="enscript-keyword">if</span> (bp-&gt;nb_valid) {
			<span class="enscript-comment">/* ...check for any invalid pages in the read range */</span>
			<span class="enscript-type">int</span> pg, firstpg, lastpg, dirtypg;
			dirtypg = firstpg = lastpg = -1;
			pg = on/PAGE_SIZE;
			<span class="enscript-keyword">while</span> (pg &lt;= (on + n - 1)/PAGE_SIZE) {
				<span class="enscript-keyword">if</span> (!NBPGVALID(bp,pg)) {
					<span class="enscript-keyword">if</span> (firstpg &lt; 0)
						firstpg = pg;
					lastpg = pg;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (firstpg &gt;= 0 &amp;&amp; dirtypg &lt; 0 &amp;&amp; NBPGDIRTY(bp,pg))
					dirtypg = pg;
				pg++;
			}

			<span class="enscript-comment">/* if there are no invalid pages, we're all set */</span>
			<span class="enscript-keyword">if</span> (firstpg &lt; 0) {
				<span class="enscript-keyword">if</span> (bp-&gt;nb_validoff &lt; 0) {
					<span class="enscript-comment">/* valid range isn't set up, so */</span>
					<span class="enscript-comment">/* set it to what we know is valid */</span>
					bp-&gt;nb_validoff = trunc_page(on);
					bp-&gt;nb_validend = round_page(on+n);
					nfs_buf_normalize_valid_range(np, bp);
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">buffer_ready</span>;
			}

			<span class="enscript-comment">/* there are invalid pages in the read range */</span>
			<span class="enscript-keyword">if</span> (((dirtypg &gt; firstpg) &amp;&amp; (dirtypg &lt; lastpg)) ||
			    (((firstpg*PAGE_SIZE) &lt; bp-&gt;nb_dirtyend) &amp;&amp; (((lastpg+1)*PAGE_SIZE) &gt; bp-&gt;nb_dirtyoff))) {
				<span class="enscript-comment">/* there are also dirty page(s) (or range) in the read range, */</span>
				<span class="enscript-comment">/* so write the buffer out and try again */</span>
<span class="enscript-reference">flushbuffer</span>:
				CLR(bp-&gt;nb_flags, (NB_DONE | NB_ERROR | NB_INVAL));
				SET(bp-&gt;nb_flags, NB_ASYNC);
				<span class="enscript-keyword">if</span> (!IS_VALID_CRED(bp-&gt;nb_wcred)) {
					kauth_cred_ref(cred);
					bp-&gt;nb_wcred = cred;
				}
				error = nfs_buf_write(bp);
				<span class="enscript-keyword">if</span> (error) {
					nfs_data_unlock(np);
					FSDBG_BOT(514, np, 0xd1e000d, 0, error);
					<span class="enscript-keyword">return</span> (error);
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
			}
			<span class="enscript-keyword">if</span> (!bp-&gt;nb_dirty &amp;&amp; bp-&gt;nb_dirtyend &lt;= 0 &amp;&amp;
			    (lastpg - firstpg + 1) &gt; (biosize/PAGE_SIZE)/2) {
				<span class="enscript-comment">/* we need to read in more than half the buffer and the */</span>
				<span class="enscript-comment">/* buffer's not dirty, so just fetch the whole buffer */</span>
				bp-&gt;nb_valid = 0;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* read the page range in */</span>
				uio_t auio;
				<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];
				
				NFS_BUF_MAP(bp);
				auio = uio_createwithbuffer(1, (NBOFF(bp) + firstpg * PAGE_SIZE_64),
						UIO_SYSSPACE, UIO_READ, &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
				<span class="enscript-keyword">if</span> (!auio) {
					error = ENOMEM;
				} <span class="enscript-keyword">else</span> {
					uio_addiov(auio, CAST_USER_ADDR_T(bp-&gt;nb_data + (firstpg * PAGE_SIZE)),
							((lastpg - firstpg + 1) * PAGE_SIZE));
					error = nfs_read_rpc(np, auio, ctx);
				}
				<span class="enscript-keyword">if</span> (error) {
					<span class="enscript-keyword">if</span> (ioflag &amp; IO_NOCACHE)
						SET(bp-&gt;nb_flags, NB_NOCACHE);
					nfs_buf_release(bp, 1);
					nfs_data_unlock(np);
					FSDBG_BOT(514, np, 0xd1e000e, 0, error);
					<span class="enscript-keyword">return</span> (error);
				}
				<span class="enscript-comment">/* Make sure that the valid range is set to cover this read. */</span>
				bp-&gt;nb_validoff = trunc_page_32(on);
				bp-&gt;nb_validend = round_page_32(on+n);
				nfs_buf_normalize_valid_range(np, bp);
				<span class="enscript-keyword">if</span> (uio_resid(auio) &gt; 0) {
					<span class="enscript-comment">/* if short read, must have hit EOF, */</span>
					<span class="enscript-comment">/* so zero the rest of the range */</span>
					bzero(CAST_DOWN(caddr_t, uio_curriovbase(auio)), uio_resid(auio));
				}
				<span class="enscript-comment">/* mark the pages (successfully read) as valid */</span>
				<span class="enscript-keyword">for</span> (pg=firstpg; pg &lt;= lastpg; pg++)
					NBPGVALID_SET(bp,pg);
			}
		}
		<span class="enscript-comment">/* if no pages are valid, read the whole block */</span>
		<span class="enscript-keyword">if</span> (!bp-&gt;nb_valid) {
			<span class="enscript-keyword">if</span> (!IS_VALID_CRED(bp-&gt;nb_rcred) &amp;&amp; IS_VALID_CRED(cred)) {
				kauth_cred_ref(cred);
				bp-&gt;nb_rcred = cred;
			}
			SET(bp-&gt;nb_flags, NB_READ);
			CLR(bp-&gt;nb_flags, (NB_DONE | NB_ERROR | NB_INVAL));
			error = nfs_buf_read(bp);
			<span class="enscript-keyword">if</span> (ioflag &amp; IO_NOCACHE)
				SET(bp-&gt;nb_flags, NB_NOCACHE);
			<span class="enscript-keyword">if</span> (error) {
				nfs_data_unlock(np);
				nfs_buf_release(bp, 1);
				FSDBG_BOT(514, np, 0xd1e000f, 0, error);
				<span class="enscript-keyword">return</span> (error);
			}
		}
<span class="enscript-reference">buffer_ready</span>:
		<span class="enscript-comment">/* validate read range against valid range and clip */</span>
		<span class="enscript-keyword">if</span> (bp-&gt;nb_validend &gt; 0) {
			diff = (on &gt;= bp-&gt;nb_validend) ? 0 : (bp-&gt;nb_validend - on);
			<span class="enscript-keyword">if</span> (diff &lt; n)
				n = diff;
		}
		<span class="enscript-keyword">if</span> (n &gt; 0) {
			NFS_BUF_MAP(bp);
			error = uiomove(bp-&gt;nb_data + on, n, uio);
		}

		nfs_buf_release(bp, 1);
		nfs_data_unlock(np);
		nfs_node_lock_force(np);
		np-&gt;n_lastread = (uio_offset(uio) - 1) / biosize;
		nfs_node_unlock(np);
	} <span class="enscript-keyword">while</span> (error == 0 &amp;&amp; uio_resid(uio) &gt; 0 &amp;&amp; n &gt; 0);
	FSDBG_BOT(514, np, uio_offset(uio), uio_resid(uio), error);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * limit the number of outstanding async I/O writes
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_async_write_start</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">int</span> error = 0, slpflag = NMFLAG(nmp, INTR) ? PCATCH : 0;
	<span class="enscript-type">struct</span> timespec ts = {1, 0};

	<span class="enscript-keyword">if</span> (nfs_max_async_writes &lt;= 0)
		<span class="enscript-keyword">return</span> (0);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">while</span> ((nfs_max_async_writes &gt; 0) &amp;&amp; (nmp-&gt;nm_asyncwrites &gt;= nfs_max_async_writes)) {
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(nmp, NULL, current_thread(), 1)))
			<span class="enscript-keyword">break</span>;
		msleep(&amp;nmp-&gt;nm_asyncwrites, &amp;nmp-&gt;nm_lock, slpflag|(PZERO-1), <span class="enscript-string">&quot;nfsasyncwrites&quot;</span>, &amp;ts);
		slpflag = 0;
	}
	<span class="enscript-keyword">if</span> (!error)
		nmp-&gt;nm_asyncwrites++;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">return</span> (error);
}
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_async_write_done</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_asyncwrites &lt;= 0)
		<span class="enscript-keyword">return</span>;
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_asyncwrites-- &gt;= nfs_max_async_writes)
		wakeup(&amp;nmp-&gt;nm_asyncwrites);
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
}

<span class="enscript-comment">/*
 * write (or commit) the given NFS buffer
 *
 * Commit the buffer if we can.
 * Write out any dirty range.
 * If any dirty pages remain, write them out.
 * Mark buffer done.
 *
 * For async requests, all the work beyond sending the initial
 * write RPC is handled in the RPC callback(s).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_buf_write</span>(<span class="enscript-type">struct</span> nfsbuf *bp)
{
	<span class="enscript-type">int</span> error = 0, oldflags, async;
	nfsnode_t np;
	thread_t thd;
	kauth_cred_t cred;
	proc_t p = current_proc();
	<span class="enscript-type">int</span> iomode, doff, dend, firstpg, lastpg;
	uint32_t pagemask;

	FSDBG_TOP(553, bp, NBOFF(bp), bp-&gt;nb_flags, 0);

	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_lflags, NBL_BUSY))
		panic(<span class="enscript-string">&quot;nfs_buf_write: buffer is not busy???&quot;</span>);

	np = bp-&gt;nb_np;
	async = ISSET(bp-&gt;nb_flags, NB_ASYNC);
	oldflags = bp-&gt;nb_flags;

	CLR(bp-&gt;nb_flags, (NB_READ|NB_DONE|NB_ERROR|NB_DELWRI));
	<span class="enscript-keyword">if</span> (ISSET(oldflags, NB_DELWRI)) {
		lck_mtx_lock(nfs_buf_mutex);
		nfs_nbdwrite--;
		NFSBUFCNTCHK();
		lck_mtx_unlock(nfs_buf_mutex);
		wakeup(&amp;nfs_nbdwrite);
	}

	<span class="enscript-comment">/* move to clean list */</span>
	<span class="enscript-keyword">if</span> (ISSET(oldflags, (NB_ASYNC|NB_DELWRI))) {
		lck_mtx_lock(nfs_buf_mutex);
		<span class="enscript-keyword">if</span> (bp-&gt;nb_vnbufs.le_next != NFSNOLIST)
			LIST_REMOVE(bp, nb_vnbufs);
		LIST_INSERT_HEAD(&amp;np-&gt;n_cleanblkhd, bp, nb_vnbufs);
		lck_mtx_unlock(nfs_buf_mutex);
	}
	nfs_node_lock_force(np);
	np-&gt;n_numoutput++;
	nfs_node_unlock(np);
	vnode_startwrite(NFSTOV(np));

	<span class="enscript-keyword">if</span> (p &amp;&amp; p-&gt;p_stats)
		OSIncrementAtomicLong(&amp;p-&gt;p_stats-&gt;p_ru.ru_oublock);

	cred = bp-&gt;nb_wcred;
	<span class="enscript-keyword">if</span> (!IS_VALID_CRED(cred) &amp;&amp; ISSET(bp-&gt;nb_flags, NB_READ))
		cred = bp-&gt;nb_rcred;  <span class="enscript-comment">/* shouldn't really happen, but... */</span>
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
		kauth_cred_ref(cred);
	thd = async ? NULL : current_thread();

	<span class="enscript-comment">/* We need to make sure the pages are locked before doing I/O.  */</span>
	<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_META)) {
		<span class="enscript-keyword">if</span> (UBCINFOEXISTS(NFSTOV(np))) {
			<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_PAGELIST)) {
				error = nfs_buf_upl_setup(bp);
				<span class="enscript-keyword">if</span> (error) {
					printf(<span class="enscript-string">&quot;nfs_buf_write: upl create failed %d\n&quot;</span>, error);
					SET(bp-&gt;nb_flags, NB_ERROR);
					bp-&gt;nb_error = error = EIO;
					nfs_buf_iodone(bp);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				nfs_buf_upl_check(bp);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* We should never be in nfs_buf_write() with no UBCINFO. */</span>
			printf(<span class="enscript-string">&quot;nfs_buf_write: ubcinfo already gone\n&quot;</span>);
			SET(bp-&gt;nb_flags, NB_ERROR);
			bp-&gt;nb_error = error = EIO;
			nfs_buf_iodone(bp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-comment">/* If NB_NEEDCOMMIT is set, a commit RPC may do the trick. */</span>
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_NEEDCOMMIT))
		nfs_buf_check_write_verifier(np, bp);
	<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_NEEDCOMMIT)) {
		<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(np);
		<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
			SET(bp-&gt;nb_flags, NB_ERROR);
			bp-&gt;nb_error = error = EIO;
			nfs_buf_iodone(bp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		SET(bp-&gt;nb_flags, NB_WRITEINPROG);
		error = nmp-&gt;nm_funcs-&gt;nf_commit_rpc(np, NBOFF(bp) + bp-&gt;nb_dirtyoff,
				bp-&gt;nb_dirtyend - bp-&gt;nb_dirtyoff, bp-&gt;nb_wcred, bp-&gt;nb_verf);
		CLR(bp-&gt;nb_flags, NB_WRITEINPROG);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error != NFSERR_STALEWRITEVERF) {
				SET(bp-&gt;nb_flags, NB_ERROR);
				bp-&gt;nb_error = error;
			}
			nfs_buf_iodone(bp);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		bp-&gt;nb_dirtyoff = bp-&gt;nb_dirtyend = 0;
		CLR(bp-&gt;nb_flags, NB_NEEDCOMMIT);
		nfs_node_lock_force(np);
		np-&gt;n_needcommitcnt--;
		CHECK_NEEDCOMMITCNT(np);
		nfs_node_unlock(np);
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (bp-&gt;nb_dirtyend &gt; 0)) {
		<span class="enscript-comment">/* sanity check the dirty range */</span>
		<span class="enscript-keyword">if</span> (NBOFF(bp) + bp-&gt;nb_dirtyend &gt; (off_t) np-&gt;n_size) {
			bp-&gt;nb_dirtyend = np-&gt;n_size - NBOFF(bp);
			<span class="enscript-keyword">if</span> (bp-&gt;nb_dirtyoff &gt;= bp-&gt;nb_dirtyend)
				bp-&gt;nb_dirtyoff = bp-&gt;nb_dirtyend = 0;
		}
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (bp-&gt;nb_dirtyend &gt; 0)) {
		<span class="enscript-comment">/* there's a dirty range that needs to be written out */</span>
		NFS_BUF_MAP(bp);

		doff = bp-&gt;nb_dirtyoff;
		dend = bp-&gt;nb_dirtyend;

		<span class="enscript-comment">/* if doff page is dirty, move doff to start of page */</span>
		<span class="enscript-keyword">if</span> (NBPGDIRTY(bp, doff / PAGE_SIZE))
			doff -= doff &amp; PAGE_MASK;
		<span class="enscript-comment">/* try to expand write range to include preceding dirty pages */</span>
		<span class="enscript-keyword">if</span> (!(doff &amp; PAGE_MASK))
			<span class="enscript-keyword">while</span> ((doff &gt; 0) &amp;&amp; NBPGDIRTY(bp, (doff - 1) / PAGE_SIZE))
				doff -= PAGE_SIZE;
		<span class="enscript-comment">/* if dend page is dirty, move dend to start of next page */</span>
		<span class="enscript-keyword">if</span> ((dend &amp; PAGE_MASK) &amp;&amp; NBPGDIRTY(bp, dend / PAGE_SIZE))
			dend = round_page_32(dend);
		<span class="enscript-comment">/* try to expand write range to include trailing dirty pages */</span>
		<span class="enscript-keyword">if</span> (!(dend &amp; PAGE_MASK))
			<span class="enscript-keyword">while</span> ((dend &lt; (<span class="enscript-type">int</span>)bp-&gt;nb_bufsize) &amp;&amp; NBPGDIRTY(bp, dend / PAGE_SIZE))
				dend += PAGE_SIZE;
		<span class="enscript-comment">/* make sure to keep dend clipped to EOF */</span>
		<span class="enscript-keyword">if</span> ((NBOFF(bp) + dend) &gt; (off_t) np-&gt;n_size)
			dend = np-&gt;n_size - NBOFF(bp);
		<span class="enscript-comment">/* calculate range of complete pages being written */</span>
		firstpg = round_page_32(doff) / PAGE_SIZE;
		lastpg = (trunc_page_32(dend) - 1) / PAGE_SIZE;
		<span class="enscript-comment">/* calculate mask for that page range */</span>
		pagemask = ((1 &lt;&lt; (lastpg + 1)) - 1) &amp; ~((1 &lt;&lt; firstpg) - 1);

		<span class="enscript-comment">/*
		 * compare page mask to nb_dirty; if there are other dirty pages
		 * then write FILESYNC; otherwise, write UNSTABLE if async and
		 * not needcommit/stable; otherwise write FILESYNC
		 */</span>
		<span class="enscript-keyword">if</span> (bp-&gt;nb_dirty &amp; ~pagemask)
			iomode = NFS_WRITE_FILESYNC;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((bp-&gt;nb_flags &amp; (NB_ASYNC | NB_NEEDCOMMIT | NB_STABLE)) == NB_ASYNC)
			iomode = NFS_WRITE_UNSTABLE;
		<span class="enscript-keyword">else</span>
			iomode = NFS_WRITE_FILESYNC;

		<span class="enscript-comment">/* write the whole contiguous dirty range */</span>
		bp-&gt;nb_offio = doff;
		bp-&gt;nb_endio = dend;

		OSAddAtomic64(1, &amp;nfsstats.write_bios);

		SET(bp-&gt;nb_flags, NB_WRITEINPROG);
		error = nfs_buf_write_rpc(bp, iomode, thd, cred);
		<span class="enscript-comment">/*
		 * For async I/O, the callbacks will finish up the
		 * write and push out any dirty pages.  Otherwise,
		 * the write has already been finished and any dirty
		 * pages pushed out.
		 */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (!error &amp;&amp; bp-&gt;nb_dirty) <span class="enscript-comment">/* write out any dirty pages */</span>
			error = nfs_buf_write_dirty_pages(bp, thd, cred);
		nfs_buf_iodone(bp);
	}
	<span class="enscript-comment">/* note: bp is still valid only for !async case */</span>
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (!async) {
		error = nfs_buf_iowait(bp);
		<span class="enscript-comment">/* move to clean list */</span>
		<span class="enscript-keyword">if</span> (oldflags &amp; NB_DELWRI) {
			lck_mtx_lock(nfs_buf_mutex);
			<span class="enscript-keyword">if</span> (bp-&gt;nb_vnbufs.le_next != NFSNOLIST)
				LIST_REMOVE(bp, nb_vnbufs);
			LIST_INSERT_HEAD(&amp;np-&gt;n_cleanblkhd, bp, nb_vnbufs);
			lck_mtx_unlock(nfs_buf_mutex);
		}
		FSDBG_BOT(553, bp, NBOFF(bp), bp-&gt;nb_flags, error);
		nfs_buf_release(bp, 1);
		<span class="enscript-comment">/* check if we need to invalidate (and we can) */</span>
		<span class="enscript-keyword">if</span> ((np-&gt;n_flag &amp; NNEEDINVALIDATE) &amp;&amp;
		    !(np-&gt;n_bflag &amp; (NBINVALINPROG|NBFLUSHINPROG))) {
			<span class="enscript-type">int</span> invalidate = 0;
			nfs_node_lock_force(np);
			<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NNEEDINVALIDATE) {
				invalidate = 1;
				np-&gt;n_flag &amp;= ~NNEEDINVALIDATE;
			}
			nfs_node_unlock(np);
			<span class="enscript-keyword">if</span> (invalidate) {
				<span class="enscript-comment">/*
				 * There was a write error and we need to
				 * invalidate attrs and flush buffers in
				 * order to sync up with the server.
				 * (if this write was extending the file,
				 * we may no longer know the correct size)
				 *
				 * But we couldn't call vinvalbuf while holding
				 * the buffer busy.  So we call vinvalbuf() after
				 * releasing the buffer.
				 */</span>
				nfs_vinvalbuf2(NFSTOV(np), V_SAVE|V_IGNORE_WRITEERR, thd, cred, 1);
			}
		}
	}

	<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
		kauth_cred_unref(&amp;cred);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * finish the writing of a buffer
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_write_finish</span>(<span class="enscript-type">struct</span> nfsbuf *bp, thread_t thd, kauth_cred_t cred)
{
	nfsnode_t np = bp-&gt;nb_np;
	<span class="enscript-type">int</span> error = (bp-&gt;nb_flags &amp; NB_ERROR) ? bp-&gt;nb_error : 0;
	<span class="enscript-type">int</span> firstpg, lastpg;
	uint32_t pagemask;

	<span class="enscript-keyword">if</span> ((error == EINTR) || (error == ERESTART)) {
		CLR(bp-&gt;nb_flags, NB_ERROR);
		SET(bp-&gt;nb_flags, NB_EINTR);
	}

	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-comment">/* calculate range of complete pages being written */</span>
		firstpg = round_page_32(bp-&gt;nb_offio) / PAGE_SIZE;
		lastpg = (trunc_page_32(bp-&gt;nb_endio) - 1) / PAGE_SIZE;
		<span class="enscript-comment">/* calculate mask for that page range written */</span>
		pagemask = ((1 &lt;&lt; (lastpg + 1)) - 1) &amp; ~((1 &lt;&lt; firstpg) - 1);
		<span class="enscript-comment">/* clear dirty bits for pages we've written */</span>
		bp-&gt;nb_dirty &amp;= ~pagemask;
	}

	<span class="enscript-comment">/* manage needcommit state */</span>
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (bp-&gt;nb_commitlevel == NFS_WRITE_UNSTABLE)) {
		<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_NEEDCOMMIT)) {
			nfs_node_lock_force(np);
			np-&gt;n_needcommitcnt++;
			nfs_node_unlock(np);
			SET(bp-&gt;nb_flags, NB_NEEDCOMMIT);
		}
		<span class="enscript-comment">/* make sure nb_dirtyoff/nb_dirtyend reflect actual range written */</span>
		bp-&gt;nb_dirtyoff = bp-&gt;nb_offio;
		bp-&gt;nb_dirtyend = bp-&gt;nb_endio;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_NEEDCOMMIT)) {
		nfs_node_lock_force(np);
		np-&gt;n_needcommitcnt--;
		CHECK_NEEDCOMMITCNT(np);
		nfs_node_unlock(np);
		CLR(bp-&gt;nb_flags, NB_NEEDCOMMIT);
	}

	CLR(bp-&gt;nb_flags, NB_WRITEINPROG);

	<span class="enscript-comment">/*
	 * For an unstable write, the buffer is still treated as dirty until
	 * a commit (or stable (re)write) is performed.  Buffers needing only
	 * a commit are marked with the NB_DELWRI and NB_NEEDCOMMIT flags.
	 *
	 * If the write was interrupted we set NB_EINTR.  Don't set NB_ERROR
	 * because that would cause the buffer to be dropped.  The buffer is
	 * still valid and simply needs to be written again.
	 */</span>
	<span class="enscript-keyword">if</span> ((error == EINTR) || (error == ERESTART) || (!error &amp;&amp; (bp-&gt;nb_flags &amp; NB_NEEDCOMMIT))) {
		CLR(bp-&gt;nb_flags, NB_INVAL);
		<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_DELWRI)) {
			SET(bp-&gt;nb_flags, NB_DELWRI);
			lck_mtx_lock(nfs_buf_mutex);
			nfs_nbdwrite++;
			NFSBUFCNTCHK();
			lck_mtx_unlock(nfs_buf_mutex);
		}
		<span class="enscript-comment">/*
		 * Since for the NB_ASYNC case, we've reassigned the buffer to the
		 * clean list, we have to reassign it back to the dirty one. Ugh.
		 */</span>
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_ASYNC)) {
			<span class="enscript-comment">/* move to dirty list */</span>
			lck_mtx_lock(nfs_buf_mutex);
			<span class="enscript-keyword">if</span> (bp-&gt;nb_vnbufs.le_next != NFSNOLIST)
				LIST_REMOVE(bp, nb_vnbufs);
			LIST_INSERT_HEAD(&amp;np-&gt;n_dirtyblkhd, bp, nb_vnbufs);
			lck_mtx_unlock(nfs_buf_mutex);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* either there's an error or we don't need to commit */</span>
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/*
			 * There was a write error and we need to invalidate
			 * attrs and flush buffers in order to sync up with the
			 * server.  (if this write was extending the file, we
			 * may no longer know the correct size)
			 *
			 * But we can't call vinvalbuf while holding this
			 * buffer busy.  Set a flag to do it after releasing
			 * the buffer.
			 */</span>
			nfs_node_lock_force(np);
			np-&gt;n_error = error;
			np-&gt;n_flag |= (NWRITEERR | NNEEDINVALIDATE);
			NATTRINVALIDATE(np);
			nfs_node_unlock(np);
		}
		<span class="enscript-comment">/* clear the dirty range */</span>
		bp-&gt;nb_dirtyoff = bp-&gt;nb_dirtyend = 0;
	}

	<span class="enscript-keyword">if</span> (!error &amp;&amp; bp-&gt;nb_dirty)
		nfs_buf_write_dirty_pages(bp, thd, cred);
	nfs_buf_iodone(bp);
}

<span class="enscript-comment">/*
 * write out any pages marked dirty in a buffer
 *
 * We do use unstable writes and follow up with a commit.
 * If we catch the write verifier changing we'll restart
 * do the writes filesync.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_buf_write_dirty_pages</span>(<span class="enscript-type">struct</span> nfsbuf *bp, thread_t thd, kauth_cred_t cred)
{
	nfsnode_t np = bp-&gt;nb_np;
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(np);
	<span class="enscript-type">int</span> error = 0, commit, iomode, iomode2, len, pg, count, npages, off;
	uint32_t dirty = bp-&gt;nb_dirty;
	uint64_t wverf;
	uio_t auio;
	<span class="enscript-type">char</span> uio_buf [ UIO_SIZEOF(1) ];

	<span class="enscript-keyword">if</span> (!bp-&gt;nb_dirty)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/* there are pages marked dirty that need to be written out */</span>
	OSAddAtomic64(1, &amp;nfsstats.write_bios);
	NFS_BUF_MAP(bp);
	SET(bp-&gt;nb_flags, NB_WRITEINPROG);
	npages = bp-&gt;nb_bufsize / PAGE_SIZE;
	iomode = NFS_WRITE_UNSTABLE;

	auio = uio_createwithbuffer(1, 0, UIO_SYSSPACE, UIO_WRITE,
		&amp;uio_buf, <span class="enscript-keyword">sizeof</span>(uio_buf));

<span class="enscript-reference">again</span>:
	dirty = bp-&gt;nb_dirty;
	wverf = bp-&gt;nb_verf;
	commit = NFS_WRITE_FILESYNC;
	<span class="enscript-keyword">for</span> (pg = 0; pg &lt; npages; pg++) {
		<span class="enscript-keyword">if</span> (!NBPGDIRTY(bp, pg))
			<span class="enscript-keyword">continue</span>;
		count = 1;
		<span class="enscript-keyword">while</span> (((pg + count) &lt; npages) &amp;&amp; NBPGDIRTY(bp, pg + count))
			count++;
		<span class="enscript-comment">/* write count pages starting with page pg */</span>
		off = pg * PAGE_SIZE;
		len = count * PAGE_SIZE;
		<span class="enscript-comment">/* clip writes to EOF */</span>
		<span class="enscript-keyword">if</span> (NBOFF(bp) + off + len &gt; (off_t) np-&gt;n_size)
			len -= (NBOFF(bp) + off + len) - np-&gt;n_size;
		<span class="enscript-keyword">if</span> (len &gt; 0) {
			iomode2 = iomode;
			uio_reset(auio, NBOFF(bp) + off, UIO_SYSSPACE, UIO_WRITE);
			uio_addiov(auio, CAST_USER_ADDR_T(bp-&gt;nb_data + off), len);
			error = nfs_write_rpc2(np, auio, thd, cred, &amp;iomode2, &amp;bp-&gt;nb_verf);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (iomode2 &lt; commit) <span class="enscript-comment">/* Retain the lowest commitment level returned. */</span>
				commit = iomode2;
			<span class="enscript-keyword">if</span> ((commit != NFS_WRITE_FILESYNC) &amp;&amp; (wverf != bp-&gt;nb_verf)) {
				<span class="enscript-comment">/* verifier changed, redo all the writes filesync */</span>
				iomode = NFS_WRITE_FILESYNC;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
			}
		}
		<span class="enscript-comment">/* clear dirty bits */</span>
		<span class="enscript-keyword">while</span> (count--) {
			dirty &amp;= ~(1 &lt;&lt; pg);
			<span class="enscript-keyword">if</span> (count) <span class="enscript-comment">/* leave pg on last page */</span>
				pg++;
		}
	}
	CLR(bp-&gt;nb_flags, NB_WRITEINPROG);

	<span class="enscript-keyword">if</span> (!error &amp;&amp; (commit != NFS_WRITE_FILESYNC)) {
		error = nmp-&gt;nm_funcs-&gt;nf_commit_rpc(np, NBOFF(bp), bp-&gt;nb_bufsize, cred, wverf);
		<span class="enscript-keyword">if</span> (error == NFSERR_STALEWRITEVERF) {
			<span class="enscript-comment">/* verifier changed, so we need to restart all the writes */</span>
			iomode = NFS_WRITE_FILESYNC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
		}
	}
	<span class="enscript-keyword">if</span> (!error) {
		bp-&gt;nb_dirty = dirty;
	} <span class="enscript-keyword">else</span> {
		SET(bp-&gt;nb_flags, NB_ERROR);
		bp-&gt;nb_error = error;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * initiate the NFS WRITE RPC(s) for a buffer
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_buf_write_rpc</span>(<span class="enscript-type">struct</span> nfsbuf *bp, <span class="enscript-type">int</span> iomode, thread_t thd, kauth_cred_t cred)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	nfsnode_t np = bp-&gt;nb_np;
	<span class="enscript-type">int</span> error = 0, nfsvers, async;
	<span class="enscript-type">int</span> offset, nrpcs;
	uint32_t nmwsize, length, len;
	<span class="enscript-type">struct</span> nfsreq *req;
	<span class="enscript-type">struct</span> nfsreq_cbinfo cb;
	uio_t auio;
	<span class="enscript-type">char</span> uio_buf [ UIO_SIZEOF(1) ];

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		bp-&gt;nb_error = error = ENXIO;
		SET(bp-&gt;nb_flags, NB_ERROR);
		nfs_buf_iodone(bp);
		<span class="enscript-keyword">return</span> (error);
	}
	nfsvers = nmp-&gt;nm_vers;
	nmwsize = nmp-&gt;nm_wsize;

	offset = bp-&gt;nb_offio;
	length = bp-&gt;nb_endio - bp-&gt;nb_offio;

	<span class="enscript-comment">/* Note: Can only do async I/O if nfsiods are configured. */</span>
	async = (bp-&gt;nb_flags &amp; NB_ASYNC) &amp;&amp; (NFSIOD_MAX &gt; 0);
	bp-&gt;nb_commitlevel = NFS_WRITE_FILESYNC;
	cb.rcb_func = async ? nfs_buf_write_rpc_finish : NULL;
	cb.rcb_bp = bp;

	<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER2) &amp;&amp; ((NBOFF(bp) + bp-&gt;nb_endio) &gt; 0xffffffffLL)) {
		bp-&gt;nb_error = error = EFBIG;
		SET(bp-&gt;nb_flags, NB_ERROR);
		nfs_buf_iodone(bp);
		<span class="enscript-keyword">return</span> (error);
	}

	auio = uio_createwithbuffer(1, NBOFF(bp) + offset, UIO_SYSSPACE,
		UIO_WRITE, &amp;uio_buf, <span class="enscript-keyword">sizeof</span>(uio_buf));
	uio_addiov(auio, CAST_USER_ADDR_T(bp-&gt;nb_data + offset), length);

	bp-&gt;nb_rpcs = nrpcs = (length + nmwsize - 1) / nmwsize;
	<span class="enscript-keyword">if</span> (async &amp;&amp; (nrpcs &gt; 1)) {
		SET(bp-&gt;nb_flags, NB_MULTASYNCRPC);
	} <span class="enscript-keyword">else</span> {
		CLR(bp-&gt;nb_flags, NB_MULTASYNCRPC);
	}

	<span class="enscript-keyword">while</span> (length &gt; 0) {
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_ERROR)) {
			error = bp-&gt;nb_error;
			<span class="enscript-keyword">break</span>;
		}
		len = (length &gt; nmwsize) ? nmwsize : length;
		cb.rcb_args[0] = offset;
		cb.rcb_args[1] = len;
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4)
			cb.rcb_args[2] = nmp-&gt;nm_stategenid;
		<span class="enscript-keyword">if</span> (async &amp;&amp; ((error = nfs_async_write_start(nmp))))
			<span class="enscript-keyword">break</span>;
		req = NULL;
		error = nmp-&gt;nm_funcs-&gt;nf_write_rpc_async(np, auio, len, thd, cred,
				iomode, &amp;cb, &amp;req);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (async)
				nfs_async_write_done(nmp);
			<span class="enscript-keyword">break</span>;
		}
		offset += len;
		length -= len;
		<span class="enscript-keyword">if</span> (async)
			<span class="enscript-keyword">continue</span>;
		nfs_buf_write_rpc_finish(req);
	}

	<span class="enscript-keyword">if</span> (length &gt; 0) {
		<span class="enscript-comment">/*
		 * Something bad happened while trying to send the RPCs.
		 * Wait for any outstanding requests to complete.
		 */</span>
		bp-&gt;nb_error = error;
		SET(bp-&gt;nb_flags, NB_ERROR);
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_MULTASYNCRPC)) {
			nrpcs = (length + nmwsize - 1) / nmwsize;
			lck_mtx_lock(nfs_buf_mutex);
			bp-&gt;nb_rpcs -= nrpcs;
			<span class="enscript-keyword">if</span> (bp-&gt;nb_rpcs == 0) {
				<span class="enscript-comment">/* No RPCs left, so the buffer's done */</span>
				lck_mtx_unlock(nfs_buf_mutex);
				nfs_buf_write_finish(bp, thd, cred);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* wait for the last RPC to mark it done */</span>
				<span class="enscript-keyword">while</span> (bp-&gt;nb_rpcs &gt; 0)
					msleep(&amp;bp-&gt;nb_rpcs, nfs_buf_mutex, 0,
						<span class="enscript-string">&quot;nfs_buf_write_rpc_cancel&quot;</span>, NULL);
				lck_mtx_unlock(nfs_buf_mutex);
			}
		} <span class="enscript-keyword">else</span> {
			nfs_buf_write_finish(bp, thd, cred);
		}
		<span class="enscript-comment">/* It may have just been an interrupt... that's OK */</span>
		<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_ERROR))
			error = 0;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * finish up an NFS WRITE RPC on a buffer
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_buf_write_rpc_finish</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">int</span> error = 0, nfsvers, offset, length, multasyncrpc, finished;
	<span class="enscript-type">int</span> committed = NFS_WRITE_FILESYNC;
	uint64_t wverf = 0;
	size_t rlen;
	<span class="enscript-type">void</span> *wakeme = NULL;
	<span class="enscript-type">struct</span> nfsreq_cbinfo cb;
	<span class="enscript-type">struct</span> nfsreq *wreq = NULL;
	<span class="enscript-type">struct</span> nfsbuf *bp;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	nfsnode_t np;
	thread_t thd;
	kauth_cred_t cred;
	uio_t auio;
	<span class="enscript-type">char</span> uio_buf [ UIO_SIZEOF(1) ];

<span class="enscript-reference">finish</span>:
	np = req-&gt;r_np;
	thd = req-&gt;r_thread;
	cred = req-&gt;r_cred;
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
		kauth_cred_ref(cred);
	cb = req-&gt;r_callback;
	bp = cb.rcb_bp;
	<span class="enscript-keyword">if</span> (cb.rcb_func) <span class="enscript-comment">/* take an extra reference on the nfsreq in case we want to resend it later due to grace error */</span>
		nfs_request_ref(req, 0);

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		SET(bp-&gt;nb_flags, NB_ERROR);
		bp-&gt;nb_error = error = ENXIO;
	}
	<span class="enscript-keyword">if</span> (error || ISSET(bp-&gt;nb_flags, NB_ERROR)) {
		<span class="enscript-comment">/* just drop it */</span>
		nfs_request_async_cancel(req);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	nfsvers = nmp-&gt;nm_vers;

	offset = cb.rcb_args[0];
	rlen = length = cb.rcb_args[1];

	<span class="enscript-comment">/* finish the RPC */</span>
	error = nmp-&gt;nm_funcs-&gt;nf_write_rpc_async_finish(np, req, &amp;committed, &amp;rlen, &amp;wverf);
	<span class="enscript-keyword">if</span> ((error == EINPROGRESS) &amp;&amp; cb.rcb_func) {
		<span class="enscript-comment">/* async request restarted */</span>
		<span class="enscript-keyword">if</span> (cb.rcb_func)
			nfs_request_rele(req);
		<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
			kauth_cred_unref(&amp;cred);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; nfs_mount_state_error_should_restart(error) &amp;&amp; !ISSET(bp-&gt;nb_flags, NB_ERROR)) {
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">if</span> ((error != NFSERR_OLD_STATEID) &amp;&amp; (error != NFSERR_GRACE) &amp;&amp; (cb.rcb_args[2] == nmp-&gt;nm_stategenid)) {
			NP(np, <span class="enscript-string">&quot;nfs_buf_write_rpc_finish: error %d @ 0x%llx, 0x%x 0x%x, initiating recovery&quot;</span>,
				error, NBOFF(bp)+offset, cb.rcb_args[2], nmp-&gt;nm_stategenid);
			nfs_need_recover(nmp, error);
		}
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
			error = EIO;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (error == NFSERR_GRACE) {
				<span class="enscript-keyword">if</span> (cb.rcb_func) {
					<span class="enscript-comment">/*
					 * For an async I/O request, handle a grace delay just like
					 * jukebox errors.  Set the resend time and queue it up.
					 */</span>
					<span class="enscript-type">struct</span> timeval now;
					<span class="enscript-keyword">if</span> (req-&gt;r_nmrep.nmc_mhead) {
						mbuf_freem(req-&gt;r_nmrep.nmc_mhead);
						req-&gt;r_nmrep.nmc_mhead = NULL;
					}
					req-&gt;r_error = 0;
					microuptime(&amp;now);
					lck_mtx_lock(&amp;req-&gt;r_mtx);
					req-&gt;r_resendtime = now.tv_sec + 2;
					req-&gt;r_xid = 0;                 <span class="enscript-comment">// get a new XID
</span>					req-&gt;r_flags |= R_RESTART;
					req-&gt;r_start = 0;
					nfs_asyncio_resend(req);
					lck_mtx_unlock(&amp;req-&gt;r_mtx);
					<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
						kauth_cred_unref(&amp;cred);
					<span class="enscript-comment">/* Note: nfsreq reference taken will be dropped later when finished */</span>
					<span class="enscript-keyword">return</span>;
				}
				<span class="enscript-comment">/* otherwise, just pause a couple seconds and retry */</span>
				tsleep(&amp;nmp-&gt;nm_state, (PZERO-1), <span class="enscript-string">&quot;nfsgrace&quot;</span>, 2*hz);
			}
			<span class="enscript-keyword">if</span> (!(error = nfs_mount_state_wait_for_recovery(nmp))) {
				rlen = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">writeagain</span>;
			}
		}
	}
	<span class="enscript-keyword">if</span> (error) {
		SET(bp-&gt;nb_flags, NB_ERROR);
		bp-&gt;nb_error = error;
	}
	<span class="enscript-keyword">if</span> (error || (nfsvers == NFS_VER2))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> (rlen &lt;= 0) {
		SET(bp-&gt;nb_flags, NB_ERROR);
		bp-&gt;nb_error = error = EIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* save lowest commit level returned */</span>
	<span class="enscript-keyword">if</span> (committed &lt; bp-&gt;nb_commitlevel)
		bp-&gt;nb_commitlevel = committed;

	<span class="enscript-comment">/* check the write verifier */</span>
	<span class="enscript-keyword">if</span> (!bp-&gt;nb_verf) {
		bp-&gt;nb_verf = wverf;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bp-&gt;nb_verf != wverf) {
		<span class="enscript-comment">/* verifier changed, so buffer will need to be rewritten */</span>
		bp-&gt;nb_flags |= NB_STALEWVERF;
		bp-&gt;nb_commitlevel = NFS_WRITE_UNSTABLE;
		bp-&gt;nb_verf = wverf;
	}

	<span class="enscript-comment">/*
	 * check for a short write
	 *
	 * If the server didn't write all the data, then we
	 * need to issue another write for the rest of it.
	 * (Don't bother if the buffer hit an error or stale wverf.)
	 */</span>
	<span class="enscript-keyword">if</span> (((<span class="enscript-type">int</span>)rlen &lt; length) &amp;&amp; !(bp-&gt;nb_flags &amp; (NB_STALEWVERF|NB_ERROR))) {
<span class="enscript-reference">writeagain</span>:
		offset += rlen;
		length -= rlen;

		auio = uio_createwithbuffer(1, NBOFF(bp) + offset, UIO_SYSSPACE,
			UIO_WRITE, &amp;uio_buf, <span class="enscript-keyword">sizeof</span>(uio_buf));
		uio_addiov(auio, CAST_USER_ADDR_T(bp-&gt;nb_data + offset), length);

		cb.rcb_args[0] = offset;
		cb.rcb_args[1] = length;
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4)
			cb.rcb_args[2] = nmp-&gt;nm_stategenid;

		<span class="enscript-comment">// XXX iomode should really match the original request
</span>		error = nmp-&gt;nm_funcs-&gt;nf_write_rpc_async(np, auio, length, thd, cred,
				NFS_WRITE_FILESYNC, &amp;cb, &amp;wreq);
		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
				kauth_cred_unref(&amp;cred);
			<span class="enscript-keyword">if</span> (!cb.rcb_func) {
				<span class="enscript-comment">/* if !async we'll need to wait for this RPC to finish */</span>
				req = wreq;
				wreq = NULL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">finish</span>;
			}
			nfs_request_rele(req);
			<span class="enscript-comment">/*
			 * We're done here.
			 * Outstanding RPC count is unchanged.
			 * Callback will be called when RPC is done.
			 */</span>
			<span class="enscript-keyword">return</span>;
		}
		SET(bp-&gt;nb_flags, NB_ERROR);
		bp-&gt;nb_error = error;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (cb.rcb_func) {
		nfs_async_write_done(nmp);
		nfs_request_rele(req);
	}
	<span class="enscript-comment">/*
	 * Decrement outstanding RPC count on buffer
	 * and call nfs_buf_write_finish on last RPC.
	 *
	 * (Note: when there are multiple async RPCs issued for a
	 * buffer we need nfs_buffer_mutex to avoid problems when
	 * aborting a partially-initiated set of RPCs)
	 */</span>
	multasyncrpc = ISSET(bp-&gt;nb_flags, NB_MULTASYNCRPC);
	<span class="enscript-keyword">if</span> (multasyncrpc)
		lck_mtx_lock(nfs_buf_mutex);

	bp-&gt;nb_rpcs--;
	finished = (bp-&gt;nb_rpcs == 0);

	<span class="enscript-keyword">if</span> (multasyncrpc)
		lck_mtx_unlock(nfs_buf_mutex);

	<span class="enscript-keyword">if</span> (finished) {
		<span class="enscript-keyword">if</span> (multasyncrpc)
			wakeme = &amp;bp-&gt;nb_rpcs;
		nfs_buf_write_finish(bp, thd, cred);
		<span class="enscript-keyword">if</span> (wakeme)
			wakeup(wakeme);
	}

	<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
		kauth_cred_unref(&amp;cred);
}

<span class="enscript-comment">/*
 * Send commit(s) for the given node's &quot;needcommit&quot; buffers 
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_flushcommits</span>(nfsnode_t np, <span class="enscript-type">int</span> nowait)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfsbuf *bp, *prevlbp, *lbp;
	<span class="enscript-type">struct</span> nfsbuflists blist, commitlist;
	<span class="enscript-type">int</span> error = 0, retv, wcred_set, flags, dirty;
	u_quad_t off, endoff, toff;
	uint64_t wverf;
	u_int32_t count;
	kauth_cred_t wcred = NULL;

	FSDBG_TOP(557, np, 0, 0, 0);

	<span class="enscript-comment">/*
	 * A nb_flags == (NB_DELWRI | NB_NEEDCOMMIT) block has been written to the
	 * server, but nas not been committed to stable storage on the server
	 * yet. The byte range is worked out for as many nfsbufs as we can handle
	 * and the commit rpc is done.
	 */</span>
	<span class="enscript-keyword">if</span> (!LIST_EMPTY(&amp;np-&gt;n_dirtyblkhd)) {
		error = nfs_node_lock(np);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		np-&gt;n_flag |= NMODIFIED;
		nfs_node_unlock(np);
	}

	off = (u_quad_t)-1;
	endoff = 0;
	wcred_set = 0;
	LIST_INIT(&amp;commitlist);

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers == NFS_VER2) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	flags = NBI_DIRTY;
	<span class="enscript-keyword">if</span> (nowait)
		flags |= NBI_NOWAIT;
	lck_mtx_lock(nfs_buf_mutex);
	wverf = nmp-&gt;nm_verf;
	<span class="enscript-keyword">if</span> (!nfs_buf_iterprepare(np, &amp;blist, flags)) {
		<span class="enscript-keyword">while</span> ((bp = LIST_FIRST(&amp;blist))) {
			LIST_REMOVE(bp, nb_vnbufs);
			LIST_INSERT_HEAD(&amp;np-&gt;n_dirtyblkhd, bp, nb_vnbufs);
			error = nfs_buf_acquire(bp, NBAC_NOWAIT, 0, 0);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_NEEDCOMMIT))
				nfs_buf_check_write_verifier(np, bp);
			<span class="enscript-keyword">if</span> (((bp-&gt;nb_flags &amp; (NB_DELWRI | NB_NEEDCOMMIT)) != (NB_DELWRI | NB_NEEDCOMMIT)) ||
			    (bp-&gt;nb_verf != wverf)) {
				nfs_buf_drop(bp);
				<span class="enscript-keyword">continue</span>;
			}
			nfs_buf_remfree(bp);

			<span class="enscript-comment">/* buffer UPLs will be grabbed *in order* below */</span>

			FSDBG(557, bp, bp-&gt;nb_flags, bp-&gt;nb_valid, bp-&gt;nb_dirty);
			FSDBG(557, bp-&gt;nb_validoff, bp-&gt;nb_validend,
			      bp-&gt;nb_dirtyoff, bp-&gt;nb_dirtyend);

			<span class="enscript-comment">/*
			 * Work out if all buffers are using the same cred
			 * so we can deal with them all with one commit.
			 *
			 * Note: creds in bp's must be obtained by kauth_cred_ref
			 * on the same original cred in order for them to be equal.
			 */</span>
			<span class="enscript-keyword">if</span> (wcred_set == 0) {
				wcred = bp-&gt;nb_wcred;
				<span class="enscript-keyword">if</span> (!IS_VALID_CRED(wcred))
					panic(<span class="enscript-string">&quot;nfs: needcommit w/out wcred&quot;</span>);
				wcred_set = 1;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((wcred_set == 1) &amp;&amp; wcred != bp-&gt;nb_wcred) {
				wcred_set = -1;
			}
			SET(bp-&gt;nb_flags, NB_WRITEINPROG);

			<span class="enscript-comment">/*
			 * Add this buffer to the list of buffers we are committing.
			 * Buffers are inserted into the list in ascending order so that
			 * we can take the UPLs in order after the list is complete.
			 */</span>
			prevlbp = NULL;
			LIST_FOREACH(lbp, &amp;commitlist, nb_vnbufs) {
				<span class="enscript-keyword">if</span> (bp-&gt;nb_lblkno &lt; lbp-&gt;nb_lblkno)
					<span class="enscript-keyword">break</span>;
				prevlbp = lbp;
			}
			LIST_REMOVE(bp, nb_vnbufs);
			<span class="enscript-keyword">if</span> (prevlbp)
				LIST_INSERT_AFTER(prevlbp, bp, nb_vnbufs);
			<span class="enscript-keyword">else</span>
				LIST_INSERT_HEAD(&amp;commitlist, bp, nb_vnbufs);

			<span class="enscript-comment">/* update commit range start, end */</span>
			toff = NBOFF(bp) + bp-&gt;nb_dirtyoff;
			<span class="enscript-keyword">if</span> (toff &lt; off)
				off = toff;
			toff += (u_quad_t)(bp-&gt;nb_dirtyend - bp-&gt;nb_dirtyoff);
			<span class="enscript-keyword">if</span> (toff &gt; endoff)
				endoff = toff;
		}
		nfs_buf_itercomplete(np, &amp;blist, NBI_DIRTY);
	}
	lck_mtx_unlock(nfs_buf_mutex);

	<span class="enscript-keyword">if</span> (LIST_EMPTY(&amp;commitlist)) {
		error = ENOBUFS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * We need a UPL to prevent others from accessing the buffers during
	 * our commit RPC(s).
	 *
	 * We used to also check for dirty pages here; if there were any we'd
	 * abort the commit and force the entire buffer to be written again.
	 * Instead of doing that, we just go ahead and commit the dirty range,
	 * and then leave the buffer around with dirty pages that will be
	 * written out later.
	 */</span>
	LIST_FOREACH(bp, &amp;commitlist, nb_vnbufs) {
		<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_PAGELIST)) {
			retv = nfs_buf_upl_setup(bp);
			<span class="enscript-keyword">if</span> (retv) {
				<span class="enscript-comment">/* Unable to create the UPL, the VM object probably no longer exists. */</span>
				printf(<span class="enscript-string">&quot;nfs_flushcommits: upl create failed %d\n&quot;</span>, retv);
				bp-&gt;nb_valid = bp-&gt;nb_dirty = 0;
			}
		}
		nfs_buf_upl_check(bp);
	}

	<span class="enscript-comment">/*
	 * Commit data on the server, as required.
	 * If all bufs are using the same wcred, then use that with
	 * one call for all of them, otherwise commit each one
	 * separately.
	 */</span>
	<span class="enscript-keyword">if</span> (wcred_set == 1) {
		<span class="enscript-comment">/*
		 * Note, it's possible the commit range could be &gt;2^32-1.
		 * If it is, we'll send one commit that covers the whole file.
		 */</span>
		<span class="enscript-keyword">if</span> ((endoff - off) &gt; 0xffffffff)
			count = 0;
		<span class="enscript-keyword">else</span>
			count = (endoff - off);
		retv = nmp-&gt;nm_funcs-&gt;nf_commit_rpc(np, off, count, wcred, wverf);
	} <span class="enscript-keyword">else</span> {
		retv = 0;
		LIST_FOREACH(bp, &amp;commitlist, nb_vnbufs) {
			toff = NBOFF(bp) + bp-&gt;nb_dirtyoff;
			count = bp-&gt;nb_dirtyend - bp-&gt;nb_dirtyoff;
			retv = nmp-&gt;nm_funcs-&gt;nf_commit_rpc(np, toff, count, bp-&gt;nb_wcred, wverf);
			<span class="enscript-keyword">if</span> (retv)
				<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-comment">/*
	 * Now, either mark the blocks I/O done or mark the
	 * blocks dirty, depending on whether the commit
	 * succeeded.
	 */</span>
	<span class="enscript-keyword">while</span> ((bp = LIST_FIRST(&amp;commitlist))) {
		LIST_REMOVE(bp, nb_vnbufs);
		FSDBG(557, bp, retv, bp-&gt;nb_flags, bp-&gt;nb_dirty);
		nfs_node_lock_force(np);
		CLR(bp-&gt;nb_flags, (NB_NEEDCOMMIT | NB_WRITEINPROG));
		np-&gt;n_needcommitcnt--;
		CHECK_NEEDCOMMITCNT(np);
		nfs_node_unlock(np);

		<span class="enscript-keyword">if</span> (retv) {
			<span class="enscript-comment">/* move back to dirty list */</span>
			lck_mtx_lock(nfs_buf_mutex);
			LIST_INSERT_HEAD(&amp;np-&gt;n_dirtyblkhd, bp, nb_vnbufs);
			lck_mtx_unlock(nfs_buf_mutex);
			nfs_buf_release(bp, 1);
			<span class="enscript-keyword">continue</span>;
		}

		nfs_node_lock_force(np);
		np-&gt;n_numoutput++;
		nfs_node_unlock(np);
		vnode_startwrite(NFSTOV(np));
		<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_DELWRI)) {
			lck_mtx_lock(nfs_buf_mutex);
			nfs_nbdwrite--;
			NFSBUFCNTCHK();
			lck_mtx_unlock(nfs_buf_mutex);
			wakeup(&amp;nfs_nbdwrite);
		}
		CLR(bp-&gt;nb_flags, (NB_READ|NB_DONE|NB_ERROR|NB_DELWRI));
		<span class="enscript-comment">/* if block still has dirty pages, we don't want it to */</span>
		<span class="enscript-comment">/* be released in nfs_buf_iodone().  So, don't set NB_ASYNC. */</span>
		<span class="enscript-keyword">if</span> (!(dirty = bp-&gt;nb_dirty))
			SET(bp-&gt;nb_flags, NB_ASYNC);
		<span class="enscript-keyword">else</span>
			CLR(bp-&gt;nb_flags, NB_ASYNC);

		<span class="enscript-comment">/* move to clean list */</span>
		lck_mtx_lock(nfs_buf_mutex);
		LIST_INSERT_HEAD(&amp;np-&gt;n_cleanblkhd, bp, nb_vnbufs);
		lck_mtx_unlock(nfs_buf_mutex);

		bp-&gt;nb_dirtyoff = bp-&gt;nb_dirtyend = 0;

		nfs_buf_iodone(bp);
		<span class="enscript-keyword">if</span> (dirty) {
			<span class="enscript-comment">/* throw it back in as a delayed write buffer */</span>
			CLR(bp-&gt;nb_flags, NB_DONE);
			nfs_buf_write_delayed(bp);
		}
	}

<span class="enscript-reference">done</span>:
	FSDBG_BOT(557, np, 0, 0, error);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Flush all the blocks associated with a vnode.
 * 	Walk through the buffer pool and push any dirty pages
 *	associated with the vnode.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_flush</span>(nfsnode_t np, <span class="enscript-type">int</span> waitfor, thread_t thd, <span class="enscript-type">int</span> ignore_writeerr)
{
	<span class="enscript-type">struct</span> nfsbuf *bp;
	<span class="enscript-type">struct</span> nfsbuflists blist;
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(np);
	<span class="enscript-type">int</span> error = 0, error2, slptimeo = 0, slpflag = 0;
	<span class="enscript-type">int</span> nfsvers, flags, passone = 1;

	FSDBG_TOP(517, np, waitfor, ignore_writeerr, 0);

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, INTR))
		slpflag = PCATCH;

	<span class="enscript-keyword">if</span> (!LIST_EMPTY(&amp;np-&gt;n_dirtyblkhd)) {
		nfs_node_lock_force(np);
		np-&gt;n_flag |= NMODIFIED;
		nfs_node_unlock(np);
	}

	lck_mtx_lock(nfs_buf_mutex);
	<span class="enscript-keyword">while</span> (np-&gt;n_bflag &amp; NBFLUSHINPROG) {
		np-&gt;n_bflag |= NBFLUSHWANT;
		error = msleep(&amp;np-&gt;n_bflag, nfs_buf_mutex, slpflag, <span class="enscript-string">&quot;nfs_flush&quot;</span>, NULL);
		<span class="enscript-keyword">if</span> ((error &amp;&amp; (error != EWOULDBLOCK)) ||
		    ((error = nfs_sigintr(NFSTONMP(np), NULL, thd, 0)))) {
			lck_mtx_unlock(nfs_buf_mutex);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	np-&gt;n_bflag |= NBFLUSHINPROG;

	<span class="enscript-comment">/*
	 * On the first pass, start async/unstable writes on all
	 * delayed write buffers.  Then wait for all writes to complete
	 * and call nfs_flushcommits() to commit any uncommitted buffers.
	 * On all subsequent passes, start STABLE writes on any remaining
	 * dirty buffers.  Then wait for all writes to complete.
	 */</span>
<span class="enscript-reference">again</span>:
	FSDBG(518, LIST_FIRST(&amp;np-&gt;n_dirtyblkhd), np-&gt;n_flag, 0, 0);
	<span class="enscript-keyword">if</span> (!NFSTONMP(np)) {
		lck_mtx_unlock(nfs_buf_mutex);
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* Start/do any write(s) that are required. */</span>
	<span class="enscript-keyword">if</span> (!nfs_buf_iterprepare(np, &amp;blist, NBI_DIRTY)) {
		<span class="enscript-keyword">while</span> ((bp = LIST_FIRST(&amp;blist))) {
			LIST_REMOVE(bp, nb_vnbufs);
			LIST_INSERT_HEAD(&amp;np-&gt;n_dirtyblkhd, bp, nb_vnbufs);
			flags = (passone || !(waitfor == MNT_WAIT || waitfor == MNT_DWAIT)) ? NBAC_NOWAIT : 0;
			<span class="enscript-keyword">if</span> (flags != NBAC_NOWAIT)
				nfs_buf_refget(bp);
			<span class="enscript-keyword">while</span> ((error = nfs_buf_acquire(bp, flags, slpflag, slptimeo))) {
				FSDBG(524, bp, flags, bp-&gt;nb_lflags, bp-&gt;nb_flags);
				<span class="enscript-keyword">if</span> (error == EBUSY)
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">if</span> (error) {
					error2 = nfs_sigintr(NFSTONMP(np), NULL, thd, 0);
					<span class="enscript-keyword">if</span> (error2) {
						<span class="enscript-keyword">if</span> (flags != NBAC_NOWAIT)
							nfs_buf_refrele(bp);
						nfs_buf_itercomplete(np, &amp;blist, NBI_DIRTY);
						lck_mtx_unlock(nfs_buf_mutex);
						error = error2;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
					}
					<span class="enscript-keyword">if</span> (slpflag == PCATCH) {
						slpflag = 0;
						slptimeo = 2 * hz;
					}
				}
			}
			<span class="enscript-keyword">if</span> (flags != NBAC_NOWAIT)
				nfs_buf_refrele(bp);
			<span class="enscript-keyword">if</span> (error == EBUSY)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (!bp-&gt;nb_np) {
				<span class="enscript-comment">/* buffer is no longer valid */</span>
				nfs_buf_drop(bp);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_NEEDCOMMIT))
				nfs_buf_check_write_verifier(np, bp);
			<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_DELWRI)) {
				<span class="enscript-comment">/* buffer is no longer dirty */</span>
				nfs_buf_drop(bp);
				<span class="enscript-keyword">continue</span>;
			}
			FSDBG(525, bp, passone, bp-&gt;nb_lflags, bp-&gt;nb_flags);
			<span class="enscript-keyword">if</span> ((passone || !(waitfor == MNT_WAIT || waitfor == MNT_DWAIT)) &amp;&amp;
			    ISSET(bp-&gt;nb_flags, NB_NEEDCOMMIT)) {
				nfs_buf_drop(bp);
				<span class="enscript-keyword">continue</span>;
			}
			nfs_buf_remfree(bp);
			lck_mtx_unlock(nfs_buf_mutex);
			<span class="enscript-keyword">if</span> (ISSET(bp-&gt;nb_flags, NB_ERROR)) {
				nfs_node_lock_force(np);
				np-&gt;n_error = bp-&gt;nb_error ? bp-&gt;nb_error : EIO;
				np-&gt;n_flag |= NWRITEERR;
				nfs_node_unlock(np);
				nfs_buf_release(bp, 1);
				lck_mtx_lock(nfs_buf_mutex);
				<span class="enscript-keyword">continue</span>;
			}
			SET(bp-&gt;nb_flags, NB_ASYNC);
			<span class="enscript-keyword">if</span> (!passone) {
				<span class="enscript-comment">/* NB_STABLE forces this to be written FILESYNC */</span>
				SET(bp-&gt;nb_flags, NB_STABLE);
			}
			nfs_buf_write(bp);
			lck_mtx_lock(nfs_buf_mutex);
		}
		nfs_buf_itercomplete(np, &amp;blist, NBI_DIRTY);
	}
	lck_mtx_unlock(nfs_buf_mutex);

	<span class="enscript-keyword">if</span> (waitfor == MNT_WAIT || waitfor == MNT_DWAIT) {
	        <span class="enscript-keyword">while</span> ((error = vnode_waitforwrites(NFSTOV(np), 0, slpflag, slptimeo, <span class="enscript-string">&quot;nfsflush&quot;</span>))) {
		        error2 = nfs_sigintr(NFSTONMP(np), NULL, thd, 0);
			<span class="enscript-keyword">if</span> (error2) {
			        error = error2;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">if</span> (slpflag == PCATCH) {
				slpflag = 0;
				slptimeo = 2 * hz;
			}
		}
	}

	<span class="enscript-keyword">if</span> (nfsvers != NFS_VER2) {
		<span class="enscript-comment">/* loop while it looks like there are still buffers to be */</span>
		<span class="enscript-comment">/* commited and nfs_flushcommits() seems to be handling them. */</span>
		<span class="enscript-keyword">while</span> (np-&gt;n_needcommitcnt)
			<span class="enscript-keyword">if</span> (nfs_flushcommits(np, 0))
				<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (passone) {
		passone = 0;
		<span class="enscript-keyword">if</span> (!LIST_EMPTY(&amp;np-&gt;n_dirtyblkhd)) {
			nfs_node_lock_force(np);
			np-&gt;n_flag |= NMODIFIED;
			nfs_node_unlock(np);
		}
		lck_mtx_lock(nfs_buf_mutex);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}

	<span class="enscript-keyword">if</span> (waitfor == MNT_WAIT || waitfor == MNT_DWAIT) {
		<span class="enscript-keyword">if</span> (!LIST_EMPTY(&amp;np-&gt;n_dirtyblkhd)) {
			nfs_node_lock_force(np);
			np-&gt;n_flag |= NMODIFIED;
			nfs_node_unlock(np);
		}
		lck_mtx_lock(nfs_buf_mutex);
		<span class="enscript-keyword">if</span> (!LIST_EMPTY(&amp;np-&gt;n_dirtyblkhd))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
		lck_mtx_unlock(nfs_buf_mutex);
		nfs_node_lock_force(np);
		<span class="enscript-comment">/*
		 * OK, it looks like there are no dirty blocks.  If we have no
		 * writes in flight and no one in the write code, we can clear
		 * the modified flag.  In order to make sure we see the latest
		 * attributes and size, we also invalidate the attributes and
		 * advance the attribute cache XID to guarantee that attributes
		 * newer than our clearing of NMODIFIED will get loaded next.
		 * (If we don't do this, it's possible for the flush's final
		 * write/commit (xid1) to be executed in parallel with a subsequent
		 * getattr request (xid2).  The getattr could return attributes
		 * from *before* the write/commit completed but the stale attributes
		 * would be preferred because of the xid ordering.)
		 */</span>
		<span class="enscript-keyword">if</span> (!np-&gt;n_wrbusy &amp;&amp; !np-&gt;n_numoutput) {
			np-&gt;n_flag &amp;= ~NMODIFIED;
			NATTRINVALIDATE(np);
			nfs_get_xid(&amp;np-&gt;n_xid);
		}
	} <span class="enscript-keyword">else</span> {
		nfs_node_lock_force(np);
	}

	FSDBG(526, np-&gt;n_flag, np-&gt;n_error, 0, 0);
	<span class="enscript-keyword">if</span> (!ignore_writeerr &amp;&amp; (np-&gt;n_flag &amp; NWRITEERR)) {
		error = np-&gt;n_error;
		np-&gt;n_flag &amp;= ~NWRITEERR;
	}
	nfs_node_unlock(np);
<span class="enscript-reference">done</span>:
	lck_mtx_lock(nfs_buf_mutex);
	flags = np-&gt;n_bflag;
	np-&gt;n_bflag &amp;= ~(NBFLUSHINPROG|NBFLUSHWANT);
	lck_mtx_unlock(nfs_buf_mutex);
	<span class="enscript-keyword">if</span> (flags &amp; NBFLUSHWANT)
		wakeup(&amp;np-&gt;n_bflag);
<span class="enscript-reference">out</span>:
	FSDBG_BOT(517, np, error, ignore_writeerr, 0);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Flush out and invalidate all buffers associated with a vnode.
 * Called with the underlying object locked.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vinvalbuf_internal</span>(
	nfsnode_t np,
	<span class="enscript-type">int</span> flags,
	thread_t thd,
	kauth_cred_t cred,
	<span class="enscript-type">int</span> slpflag,
	<span class="enscript-type">int</span> slptimeo)
{
	<span class="enscript-type">struct</span> nfsbuf *bp;
	<span class="enscript-type">struct</span> nfsbuflists blist;
	<span class="enscript-type">int</span> list, error = 0;

	<span class="enscript-keyword">if</span> (flags &amp; V_SAVE) {
		<span class="enscript-keyword">if</span> ((error = nfs_flush(np, MNT_WAIT, thd, (flags &amp; V_IGNORE_WRITEERR))))
			<span class="enscript-keyword">return</span> (error);
	}

	lck_mtx_lock(nfs_buf_mutex);
	<span class="enscript-keyword">for</span> (;;) {
		list = NBI_CLEAN;
		<span class="enscript-keyword">if</span> (nfs_buf_iterprepare(np, &amp;blist, list)) {
			list = NBI_DIRTY;
			<span class="enscript-keyword">if</span> (nfs_buf_iterprepare(np, &amp;blist, list))
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">while</span> ((bp = LIST_FIRST(&amp;blist))) {
			LIST_REMOVE(bp, nb_vnbufs);
			<span class="enscript-keyword">if</span> (list == NBI_CLEAN)
				LIST_INSERT_HEAD(&amp;np-&gt;n_cleanblkhd, bp, nb_vnbufs);
			<span class="enscript-keyword">else</span>
				LIST_INSERT_HEAD(&amp;np-&gt;n_dirtyblkhd, bp, nb_vnbufs);
			nfs_buf_refget(bp);
			<span class="enscript-keyword">while</span> ((error = nfs_buf_acquire(bp, NBAC_REMOVE, slpflag, slptimeo))) {
				FSDBG(556, np, bp, NBOFF(bp), bp-&gt;nb_flags);
				<span class="enscript-keyword">if</span> (error != EAGAIN) {
					FSDBG(554, np, bp, -1, error);
					nfs_buf_refrele(bp);
					nfs_buf_itercomplete(np, &amp;blist, list);
					lck_mtx_unlock(nfs_buf_mutex);
					<span class="enscript-keyword">return</span> (error);
				}
			}
			nfs_buf_refrele(bp);
			FSDBG(554, np, bp, NBOFF(bp), bp-&gt;nb_flags);
			lck_mtx_unlock(nfs_buf_mutex);
			<span class="enscript-keyword">if</span> ((flags &amp; V_SAVE) &amp;&amp; UBCINFOEXISTS(NFSTOV(np)) &amp;&amp; bp-&gt;nb_np &amp;&amp;
			    (NBOFF(bp) &lt; (off_t)np-&gt;n_size)) {
				<span class="enscript-comment">/* extra paranoia: make sure we're not */</span>
				<span class="enscript-comment">/* somehow leaving any dirty data around */</span>
				<span class="enscript-type">int</span> mustwrite = 0;
				<span class="enscript-type">int</span> end = (NBOFF(bp) + bp-&gt;nb_bufsize &gt; (off_t)np-&gt;n_size) ?
				    ((off_t)np-&gt;n_size - NBOFF(bp)) : bp-&gt;nb_bufsize;
				<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_PAGELIST)) {
					error = nfs_buf_upl_setup(bp);
					<span class="enscript-keyword">if</span> (error == EINVAL) {
						<span class="enscript-comment">/* vm object must no longer exist */</span>
						<span class="enscript-comment">/* hopefully we don't need to do */</span>
						<span class="enscript-comment">/* anything for this buffer */</span>
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error)
						printf(<span class="enscript-string">&quot;nfs_vinvalbuf: upl setup failed %d\n&quot;</span>, error);
					bp-&gt;nb_valid = bp-&gt;nb_dirty = 0;
				}
				nfs_buf_upl_check(bp);
				<span class="enscript-comment">/* check for any dirty data before the EOF */</span>
				<span class="enscript-keyword">if</span> ((bp-&gt;nb_dirtyend &gt; 0) &amp;&amp; (bp-&gt;nb_dirtyoff &lt; end)) {
					<span class="enscript-comment">/* clip dirty range to EOF */</span>
					<span class="enscript-keyword">if</span> (bp-&gt;nb_dirtyend &gt; end) {
						bp-&gt;nb_dirtyend = end;
						<span class="enscript-keyword">if</span> (bp-&gt;nb_dirtyoff &gt;= bp-&gt;nb_dirtyend)
							bp-&gt;nb_dirtyoff = bp-&gt;nb_dirtyend = 0;
					}
					<span class="enscript-keyword">if</span> ((bp-&gt;nb_dirtyend &gt; 0) &amp;&amp; (bp-&gt;nb_dirtyoff &lt; end))
						mustwrite++;
				}
				bp-&gt;nb_dirty &amp;= (1 &lt;&lt; (round_page_32(end)/PAGE_SIZE)) - 1;
				<span class="enscript-keyword">if</span> (bp-&gt;nb_dirty)
					mustwrite++;
				<span class="enscript-comment">/* also make sure we'll have a credential to do the write */</span>
				<span class="enscript-keyword">if</span> (mustwrite &amp;&amp; !IS_VALID_CRED(bp-&gt;nb_wcred) &amp;&amp; !IS_VALID_CRED(cred)) {
					printf(<span class="enscript-string">&quot;nfs_vinvalbuf: found dirty buffer with no write creds\n&quot;</span>);
					mustwrite = 0;
				}
				<span class="enscript-keyword">if</span> (mustwrite) {
					FSDBG(554, np, bp, 0xd00dee, bp-&gt;nb_flags);
					<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_PAGELIST))
						panic(<span class="enscript-string">&quot;nfs_vinvalbuf: dirty buffer without upl&quot;</span>);
					<span class="enscript-comment">/* gotta write out dirty data before invalidating */</span>
					<span class="enscript-comment">/* (NB_STABLE indicates that data writes should be FILESYNC) */</span>
					<span class="enscript-comment">/* (NB_NOCACHE indicates buffer should be discarded) */</span>
					CLR(bp-&gt;nb_flags, (NB_DONE | NB_ERROR | NB_INVAL | NB_ASYNC));
					SET(bp-&gt;nb_flags, NB_STABLE | NB_NOCACHE);
					<span class="enscript-keyword">if</span> (!IS_VALID_CRED(bp-&gt;nb_wcred)) {
						kauth_cred_ref(cred);
						bp-&gt;nb_wcred = cred;
					}
					error = nfs_buf_write(bp);
					<span class="enscript-comment">// Note: bp has been released
</span>					<span class="enscript-keyword">if</span> (error) {
						FSDBG(554, bp, 0xd00dee, 0xbad, error);
						nfs_node_lock_force(np);
						<span class="enscript-keyword">if</span> ((error != EINTR) &amp;&amp; (error != ERESTART)) {
							np-&gt;n_error = error;
							np-&gt;n_flag |= NWRITEERR;
						}
						<span class="enscript-comment">/*
						 * There was a write error and we need to
						 * invalidate attrs to sync with server.
						 * (if this write was extending the file,
						 * we may no longer know the correct size)
						 */</span>
						NATTRINVALIDATE(np);
						nfs_node_unlock(np);
						<span class="enscript-keyword">if</span> ((error == EINTR) || (error == ERESTART)) {
							<span class="enscript-comment">/*
							 * Abort on EINTR.  If we don't, we could
							 * be stuck in this loop forever because
							 * the buffer will continue to stay dirty.
							 */</span>
							lck_mtx_lock(nfs_buf_mutex);
							nfs_buf_itercomplete(np, &amp;blist, list);
							lck_mtx_unlock(nfs_buf_mutex);
							<span class="enscript-keyword">return</span> (error);
						}
						error = 0;
					}
					lck_mtx_lock(nfs_buf_mutex);
					<span class="enscript-keyword">continue</span>;
				}
			}
			SET(bp-&gt;nb_flags, NB_INVAL);
			<span class="enscript-comment">// hold off on FREEUPs until we're done here
</span>			nfs_buf_release(bp, 0);
			lck_mtx_lock(nfs_buf_mutex);
		}
		nfs_buf_itercomplete(np, &amp;blist, list);
	}
	<span class="enscript-keyword">if</span> (!LIST_EMPTY(&amp;(np)-&gt;n_dirtyblkhd) || !LIST_EMPTY(&amp;(np)-&gt;n_cleanblkhd))
		panic(<span class="enscript-string">&quot;nfs_vinvalbuf: flush/inval failed&quot;</span>);
	lck_mtx_unlock(nfs_buf_mutex);
	nfs_node_lock_force(np);
	<span class="enscript-keyword">if</span> (!(flags &amp; V_SAVE))
		np-&gt;n_flag &amp;= ~NMODIFIED;
	<span class="enscript-keyword">if</span> (vnode_vtype(NFSTOV(np)) == VREG)
		np-&gt;n_lastrahead = -1;
	nfs_node_unlock(np);
	NFS_BUF_FREEUP();
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Flush and invalidate all dirty buffers. If another process is already
 * doing the flush, just wait for completion.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vinvalbuf</span>(vnode_t vp, <span class="enscript-type">int</span> flags, vfs_context_t ctx, <span class="enscript-type">int</span> intrflg)
{
	<span class="enscript-keyword">return</span> nfs_vinvalbuf2(vp, flags, vfs_context_thread(ctx), vfs_context_ucred(ctx), intrflg);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vinvalbuf2</span>(vnode_t vp, <span class="enscript-type">int</span> flags, thread_t thd, kauth_cred_t cred, <span class="enscript-type">int</span> intrflg)
{
	nfsnode_t np = VTONFS(vp);
	<span class="enscript-type">struct</span> nfsmount *nmp = VTONMP(vp);
	<span class="enscript-type">int</span> error, slpflag, slptimeo, nflags, retry = 0;
	<span class="enscript-type">int</span> ubcflags = UBC_PUSHALL | UBC_SYNC | UBC_INVALIDATE;
	<span class="enscript-type">struct</span> timespec ts = { 2, 0 };
	off_t size;

	FSDBG_TOP(554, np, flags, intrflg, 0);

	<span class="enscript-comment">/*
	 * If the mount is gone no sense to try and write anything.
	 * and hang trying to do IO.
	 */</span>
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		flags &amp;= ~V_SAVE;
		ubcflags &amp;= ~UBC_PUSHALL;
	}
	
	<span class="enscript-keyword">if</span> (nmp &amp;&amp; !NMFLAG(nmp, INTR))
		intrflg = 0;
	<span class="enscript-keyword">if</span> (intrflg) {
		slpflag = PCATCH;
		slptimeo = 2 * hz;
	} <span class="enscript-keyword">else</span> {
		slpflag = 0;
		slptimeo = 0;
	}

	<span class="enscript-comment">/* First wait for any other process doing a flush to complete.  */</span>
	lck_mtx_lock(nfs_buf_mutex);
	<span class="enscript-keyword">while</span> (np-&gt;n_bflag &amp; NBINVALINPROG) {
		np-&gt;n_bflag |= NBINVALWANT;
		msleep(&amp;np-&gt;n_bflag, nfs_buf_mutex, slpflag, <span class="enscript-string">&quot;nfs_vinvalbuf&quot;</span>, &amp;ts);
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(VTONMP(vp), NULL, thd, 0))) {
			lck_mtx_unlock(nfs_buf_mutex);
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">if</span> (np-&gt;n_bflag &amp; NBINVALINPROG)
			slpflag = 0;
	}
	np-&gt;n_bflag |= NBINVALINPROG;
	lck_mtx_unlock(nfs_buf_mutex);

	<span class="enscript-comment">/* Now, flush as required.  */</span>
<span class="enscript-reference">again</span>:
	error = nfs_vinvalbuf_internal(np, flags, thd, cred, slpflag, 0);
	<span class="enscript-keyword">while</span> (error) {
		FSDBG(554, np, 0, 0, error);
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(VTONMP(vp), NULL, thd, 0)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		error = nfs_vinvalbuf_internal(np, flags, thd, cred, 0, slptimeo);
	}

	<span class="enscript-comment">/* get the pages out of vm also */</span>
	<span class="enscript-keyword">if</span> (UBCINFOEXISTS(vp) &amp;&amp; (size = ubc_getsize(vp)))
		<span class="enscript-keyword">if</span> ((error = ubc_msync(vp, 0, size, NULL, ubcflags))) {
			<span class="enscript-keyword">if</span> (error == EINVAL)
				panic(<span class="enscript-string">&quot;nfs_vinvalbuf(): ubc_msync failed!, error %d&quot;</span>, error);
			<span class="enscript-keyword">if</span> (retry++ &lt; 10) { <span class="enscript-comment">/* retry invalidating a few times */</span>
				<span class="enscript-keyword">if</span> (retry &gt; 1 || error == ENXIO)
					ubcflags &amp;= ~UBC_PUSHALL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
			}
			<span class="enscript-comment">/* give up */</span>
			printf(<span class="enscript-string">&quot;nfs_vinvalbuf(): ubc_msync failed!, error %d\n&quot;</span>, error);
		}
<span class="enscript-reference">done</span>:
	lck_mtx_lock(nfs_buf_mutex);
	nflags = np-&gt;n_bflag;
	np-&gt;n_bflag &amp;= ~(NBINVALINPROG|NBINVALWANT);
	lck_mtx_unlock(nfs_buf_mutex);
	<span class="enscript-keyword">if</span> (nflags &amp; NBINVALWANT)
		wakeup(&amp;np-&gt;n_bflag);

	FSDBG_BOT(554, np, flags, intrflg, error);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Wait for any busy buffers to complete.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_wait_bufs</span>(nfsnode_t np)
{
	<span class="enscript-type">struct</span> nfsbuf *bp;
	<span class="enscript-type">struct</span> nfsbuflists blist;
	<span class="enscript-type">int</span> error = 0;

	lck_mtx_lock(nfs_buf_mutex);
	<span class="enscript-keyword">if</span> (!nfs_buf_iterprepare(np, &amp;blist, NBI_CLEAN)) {
		<span class="enscript-keyword">while</span> ((bp = LIST_FIRST(&amp;blist))) {
			LIST_REMOVE(bp, nb_vnbufs);
			LIST_INSERT_HEAD(&amp;np-&gt;n_cleanblkhd, bp, nb_vnbufs);
			nfs_buf_refget(bp);
			<span class="enscript-keyword">while</span> ((error = nfs_buf_acquire(bp, 0, 0, 0))) {
				<span class="enscript-keyword">if</span> (error != EAGAIN) {
					nfs_buf_refrele(bp);
					nfs_buf_itercomplete(np, &amp;blist, NBI_CLEAN);
					lck_mtx_unlock(nfs_buf_mutex);
					<span class="enscript-keyword">return</span>;
				}
			}
			nfs_buf_refrele(bp);
			nfs_buf_drop(bp);
		}
		nfs_buf_itercomplete(np, &amp;blist, NBI_CLEAN);
	}
	<span class="enscript-keyword">if</span> (!nfs_buf_iterprepare(np, &amp;blist, NBI_DIRTY)) {
		<span class="enscript-keyword">while</span> ((bp = LIST_FIRST(&amp;blist))) {
			LIST_REMOVE(bp, nb_vnbufs);
			LIST_INSERT_HEAD(&amp;np-&gt;n_dirtyblkhd, bp, nb_vnbufs);
			nfs_buf_refget(bp);
			<span class="enscript-keyword">while</span> ((error = nfs_buf_acquire(bp, 0, 0, 0))) {
				<span class="enscript-keyword">if</span> (error != EAGAIN) {
					nfs_buf_refrele(bp);
					nfs_buf_itercomplete(np, &amp;blist, NBI_DIRTY);
					lck_mtx_unlock(nfs_buf_mutex);
					<span class="enscript-keyword">return</span>;
				}
			}
			nfs_buf_refrele(bp);
			nfs_buf_drop(bp);
		}
		nfs_buf_itercomplete(np, &amp;blist, NBI_DIRTY);
	}
	lck_mtx_unlock(nfs_buf_mutex);
}


<span class="enscript-comment">/*
 * Add an async I/O request to the mount's async I/O queue and make
 * sure that an nfsiod will service it.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_asyncio_finish</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfsiod *niod;
	<span class="enscript-type">int</span> started = 0;

	FSDBG_TOP(552, nmp, 0, 0, 0);
<span class="enscript-reference">again</span>:
	nmp = req-&gt;r_nmp;

	<span class="enscript-keyword">if</span> (nmp == NULL)
		<span class="enscript-keyword">return</span>;

	lck_mtx_lock(nfsiod_mutex);
	niod = nmp-&gt;nm_niod;

	<span class="enscript-comment">/* grab an nfsiod if we don't have one already */</span>
	<span class="enscript-keyword">if</span> (!niod) {
		niod = TAILQ_FIRST(&amp;nfsiodfree);
		<span class="enscript-keyword">if</span> (niod) {
			TAILQ_REMOVE(&amp;nfsiodfree, niod, niod_link);
			TAILQ_INSERT_TAIL(&amp;nfsiodwork, niod, niod_link);
			niod-&gt;niod_nmp = nmp;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (((nfsiod_thread_count &lt; NFSIOD_MAX) || (nfsiod_thread_count &lt;= 0)) &amp;&amp; (started &lt; 4)) {
			<span class="enscript-comment">/*
			 * Try starting a new thread.
			 * We may try a couple times if other callers
			 * get the new threads before we do.
			 */</span>
			lck_mtx_unlock(nfsiod_mutex);
			started++;
			<span class="enscript-keyword">if</span> (!nfsiod_start())
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
			lck_mtx_lock(nfsiod_mutex);
		}
	}

	<span class="enscript-keyword">if</span> (req-&gt;r_achain.tqe_next == NFSREQNOLIST)
		TAILQ_INSERT_TAIL(&amp;nmp-&gt;nm_iodq, req, r_achain);

	<span class="enscript-comment">/* If this mount doesn't already have an nfsiod working on it... */</span>
	<span class="enscript-keyword">if</span> (!nmp-&gt;nm_niod) {
		<span class="enscript-keyword">if</span> (niod) { <span class="enscript-comment">/* give it the nfsiod we just grabbed */</span>
			nmp-&gt;nm_niod = niod;
			lck_mtx_unlock(nfsiod_mutex);
			wakeup(niod);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nfsiod_thread_count &gt; 0) {
			<span class="enscript-comment">/* just queue it up on nfsiod mounts queue if needed */</span>
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_iodlink.tqe_next == NFSNOLIST)
				TAILQ_INSERT_TAIL(&amp;nfsiodmounts, nmp, nm_iodlink);
			lck_mtx_unlock(nfsiod_mutex);
		} <span class="enscript-keyword">else</span> {
			printf(<span class="enscript-string">&quot;nfs_asyncio(): no nfsiods? %d %d (%d)\n&quot;</span>, nfsiod_thread_count, NFSIOD_MAX, started);
			lck_mtx_unlock(nfsiod_mutex);
			<span class="enscript-comment">/* we have no other option but to be persistent */</span>
			started = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
		}
	} <span class="enscript-keyword">else</span> {
		lck_mtx_unlock(nfsiod_mutex);
	}

	FSDBG_BOT(552, nmp, 0, 0, 0);
}

<span class="enscript-comment">/*
 * queue up async I/O request for resend
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_asyncio_resend</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = req-&gt;r_nmp;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span>;

	nfs_gss_clnt_rpcdone(req);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (!(req-&gt;r_flags &amp; R_RESENDQ)) {
		TAILQ_INSERT_TAIL(&amp;nmp-&gt;nm_resendq, req, r_rchain);
		req-&gt;r_flags |= R_RESENDQ;
		<span class="enscript-comment">/*
		 * We take a reference on this request so that it can't be
		 * destroyed while a resend is queued or in progress.
		 */</span>
		nfs_request_ref(req, 1);
	}
	nfs_mount_sock_thread_wake(nmp);
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
}

<span class="enscript-comment">/*
 * Read directory data into a buffer.
 *
 * Buffer will be filled (unless EOF is hit).
 * Buffers after this one may also be completely/partially filled.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_buf_readdir</span>(<span class="enscript-type">struct</span> nfsbuf *bp, vfs_context_t ctx)
{
	nfsnode_t np = bp-&gt;nb_np;
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(np);
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &lt; NFS_VER4)
		error = nfs3_readdir_rpc(np, bp, ctx);
	<span class="enscript-keyword">else</span>
		error = nfs4_readdir_rpc(np, bp, ctx);

	<span class="enscript-keyword">if</span> (error &amp;&amp; (error != NFSERR_DIRBUFDROPPED)) {
		SET(bp-&gt;nb_flags, NB_ERROR);
		bp-&gt;nb_error = error;
	}
	<span class="enscript-keyword">return</span> (error);
}
</pre>
<hr />
</body></html>