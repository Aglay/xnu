<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nfs_node.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nfs_node.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfs_node.c	8.6 (Berkeley) 5/22/95
 * FreeBSD-Id: nfs_node.c,v 1.22 1997/10/28 14:06:20 bde Exp $
 */</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/rpcv2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_gss.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsmount.h&gt;</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NFSNOHASH</span>(fhsum) \
	(&amp;nfsnodehashtbl[(fhsum) &amp; nfsnodehash])
<span class="enscript-type">static</span> <span class="enscript-function-name">LIST_HEAD</span>(nfsnodehashhead, nfsnode) *nfsnodehashtbl;
<span class="enscript-type">static</span> u_long nfsnodehash;

<span class="enscript-type">static</span> lck_grp_t *nfs_node_hash_lck_grp;
<span class="enscript-type">static</span> lck_grp_t *nfs_node_lck_grp;
<span class="enscript-type">static</span> lck_grp_t *nfs_data_lck_grp;
lck_mtx_t *nfs_node_hash_mutex;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_NODE_DBG</span>(...) NFS_DBG(NFS_FAC_NODE, 7, ## __VA_ARGS__)

<span class="enscript-comment">/*
 * Initialize hash links for nfsnodes
 * and build nfsnode free list.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_nhinit</span>(<span class="enscript-type">void</span>)
{
	nfs_node_hash_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;nfs_node_hash&quot;</span>, LCK_GRP_ATTR_NULL);
	nfs_node_hash_mutex = lck_mtx_alloc_init(nfs_node_hash_lck_grp, LCK_ATTR_NULL);
	nfs_node_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;nfs_node&quot;</span>, LCK_GRP_ATTR_NULL);
	nfs_data_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;nfs_data&quot;</span>, LCK_GRP_ATTR_NULL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_nhinit_finish</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_lock(nfs_node_hash_mutex);
	<span class="enscript-keyword">if</span> (!nfsnodehashtbl)
		nfsnodehashtbl = hashinit(desiredvnodes, M_NFSNODE, &amp;nfsnodehash);
	lck_mtx_unlock(nfs_node_hash_mutex);
}

<span class="enscript-comment">/*
 * Compute an entry in the NFS hash table structure
 */</span>
u_long
<span class="enscript-function-name">nfs_hash</span>(u_char *fhp, <span class="enscript-type">int</span> fhsize)
{
	u_long fhsum;
	<span class="enscript-type">int</span> i;

	fhsum = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; fhsize; i++)
		fhsum += *fhp++;
	<span class="enscript-keyword">return</span> (fhsum);
}

	
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_case_insensitive</span>(mount_t);

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_case_insensitive</span>(mount_t mp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = VFSTONFS(mp);
	<span class="enscript-type">int</span> answer = 0;
	<span class="enscript-type">int</span> skip = 0;
	
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		<span class="enscript-keyword">return</span> (0);
	}
	
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers == NFS_VER2) {
		<span class="enscript-comment">/* V2 has no way to know */</span>
		<span class="enscript-keyword">return</span> (0);
	}

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers == NFS_VER3) {
		<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_state &amp; NFSSTA_GOTPATHCONF)) {
			<span class="enscript-comment">/* We're holding the node lock so we just return 
			 * with answer as case sensitive. Is very rare
			 * for file systems not to be homogenous w.r.t. pathconf
			 */</span>
			skip = 1;
		} 
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_HOMOGENEOUS)) {
		<span class="enscript-comment">/* no pathconf info cached */</span>
		skip = 1;
	}

	<span class="enscript-keyword">if</span> (!skip &amp;&amp; NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_CASE_INSENSITIVE))
		answer = 1;

	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-keyword">return</span> (answer);
}

	
<span class="enscript-comment">/*
 * Look up a vnode/nfsnode by file handle.
 * Callers must check for mount points!!
 * In all cases, a pointer to a
 * nfsnode structure is returned.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_nget</span>(
	mount_t mp,
	nfsnode_t dnp,
	<span class="enscript-type">struct</span> componentname *cnp,
	u_char *fhp,
	<span class="enscript-type">int</span> fhsize,
	<span class="enscript-type">struct</span> nfs_vattr *nvap,
	u_int64_t *xidp,
	uint32_t auth,
	<span class="enscript-type">int</span> flags,
	nfsnode_t *npp)
{
	nfsnode_t np;
	<span class="enscript-type">struct</span> nfsnodehashhead *nhpp;
	vnode_t vp;
	<span class="enscript-type">int</span> error, nfsvers;
	mount_t mp2;
	<span class="enscript-type">struct</span> vnode_fsparam vfsp;
	uint32_t vid;

	FSDBG_TOP(263, mp, dnp, flags, npp);

	<span class="enscript-comment">/* Check for unmount in progress */</span>
	<span class="enscript-keyword">if</span> (!mp || vfs_isforce(mp)) {
		*npp = NULL;
		error = ENXIO;
		FSDBG_BOT(263, mp, dnp, 0xd1e, error);
		<span class="enscript-keyword">return</span> (error);
	}
	nfsvers = VFSTONFS(mp)-&gt;nm_vers;

	nhpp = NFSNOHASH(nfs_hash(fhp, fhsize));
<span class="enscript-reference">loop</span>:
	lck_mtx_lock(nfs_node_hash_mutex);
	<span class="enscript-keyword">for</span> (np = nhpp-&gt;lh_first; np != 0; np = np-&gt;n_hash.le_next) {
		mp2 = (np-&gt;n_hflag &amp; NHINIT) ? np-&gt;n_mount : NFSTOMP(np);
		<span class="enscript-keyword">if</span> (mp != mp2 || np-&gt;n_fhsize != fhsize ||
		    bcmp(fhp, np-&gt;n_fhp, fhsize))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (nvap &amp;&amp; (nvap-&gt;nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL) &amp;&amp;
		    cnp &amp;&amp; (cnp-&gt;cn_namelen &gt; (fhsize - (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(dnp)))) {
			<span class="enscript-comment">/* The name was too long to fit in the file handle.  Check it against the node's name. */</span>
			<span class="enscript-type">int</span> namecmp = 0;
			<span class="enscript-type">const</span> <span class="enscript-type">char</span> *vname = vnode_getname(NFSTOV(np));
			<span class="enscript-keyword">if</span> (vname) {
				<span class="enscript-keyword">if</span> (cnp-&gt;cn_namelen != (<span class="enscript-type">int</span>)strlen(vname))
					namecmp = 1;
				<span class="enscript-keyword">else</span>
					namecmp = strncmp(vname, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen);
				vnode_putname(vname);
			}
			<span class="enscript-keyword">if</span> (namecmp)  <span class="enscript-comment">/* full name didn't match */</span>
				<span class="enscript-keyword">continue</span>;
		}
		FSDBG(263, dnp, np, np-&gt;n_flag, 0xcace0000);
		<span class="enscript-comment">/* if the node is locked, sleep on it */</span>
		<span class="enscript-keyword">if</span> ((np-&gt;n_hflag &amp; NHLOCKED) &amp;&amp; !(flags &amp; NG_NOCREATE)) {
			np-&gt;n_hflag |= NHLOCKWANT;
			FSDBG(263, dnp, np, np-&gt;n_flag, 0xcace2222);
			msleep(np, nfs_node_hash_mutex, PDROP | PINOD, <span class="enscript-string">&quot;nfs_nget&quot;</span>, NULL);
			FSDBG(263, dnp, np, np-&gt;n_flag, 0xcace3333);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
		}
		vp = NFSTOV(np);
		vid = vnode_vid(vp);
		lck_mtx_unlock(nfs_node_hash_mutex);
		<span class="enscript-keyword">if</span> ((error = vnode_getwithvid(vp, vid))) {
			<span class="enscript-comment">/*
			 * If vnode is being reclaimed or has already
			 * changed identity, no need to wait.
			 */</span>
			FSDBG_BOT(263, dnp, *npp, 0xcace0d1e, error);
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np))) {
			<span class="enscript-comment">/* this only fails if the node is now unhashed */</span>
			<span class="enscript-comment">/* so let's see if we can find/create it again */</span>
			FSDBG(263, dnp, *npp, 0xcaced1e2, error);
			vnode_put(vp);
			<span class="enscript-keyword">if</span> (flags &amp; NG_NOCREATE) {
				*npp = 0;
				FSDBG_BOT(263, dnp, *npp, 0xcaced1e0, ENOENT);
				<span class="enscript-keyword">return</span> (ENOENT);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
		}
		<span class="enscript-comment">/* update attributes */</span>
		<span class="enscript-keyword">if</span> (nvap)
			error = nfs_loadattrcache(np, nvap, xidp, 0);
		<span class="enscript-keyword">if</span> (error) {
			nfs_node_unlock(np);
			vnode_put(vp);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (dnp &amp;&amp; cnp &amp;&amp; (flags &amp; NG_MAKEENTRY))
				cache_enter(NFSTOV(dnp), vp, cnp);
			<span class="enscript-comment">/*
			 * Update the vnode if the name/and or the parent has
			 * changed. We need to do this so that if getattrlist is
			 * called asking for ATTR_CMN_NAME, that the &quot;most&quot;
			 * correct name is being returned. In addition for
			 * monitored vnodes we need to kick the vnode out of the
			 * name cache. We do this so that if there are hard
			 * links in the same directory the link will not be
			 * found and a lookup will get us here to return the
			 * name of the current link. In addition by removing the
			 * name from the name cache the old name will not be
			 * found after a rename done on another client or the
			 * server.  The principle reason to do this is because
			 * Finder is asking for notifications on a directory.
			 * The directory changes, Finder gets notified, reads
			 * the directory (which we have purged) and for each
			 * entry returned calls getattrlist with the name
			 * returned from readdir. gettattrlist has to call
			 * namei/lookup to resolve the name, because its not in
			 * the cache we end up here. We need to update the name
			 * so Finder will get the name it called us with.
			 *
			 * We had an imperfect solution with respect to case
			 * sensitivity.  There is a test that is run in
			 * FileBuster that does renames from some name to
			 * another name differing only in case. It then reads
			 * the directory looking for the new name, after it
			 * finds that new name, it ask gettattrlist to verify
			 * that the name is the new name.  Usually that works,
			 * but renames generate fsevents and fseventsd will do a
			 * lookup on the name via lstat. Since that test renames
			 * old name to new name back and forth there is a race
			 * that an fsevent will be behind and will access the
			 * file by the old name, on a case insensitive file
			 * system that will work. Problem is if we do a case
			 * sensitive compare, we're going to change the name,
			 * which the test's getattrlist verification step is
			 * going to fail. So we will check the case sensitivity
			 * of the file system and do the appropriate compare. In
			 * a rare instance for non homogeneous file systems
			 * w.r.t. pathconf we will use case sensitive compares.
			 * That could break if the file system is actually case
			 * insensitive.
			 *
			 * Note that V2 does not know the case, so we just
			 * assume case sensitivity. 
			 *
			 * This is clearly not perfect due to races, but this is
			 * as good as its going to get. You can defeat the
			 * handling of hard links simply by doing:
			 *
			 *	while :; do ls -l &gt; /dev/null; done
			 *
			 * in a terminal window. Even a single ls -l can cause a
			 * race.
			 *
			 * &lt;rant&gt;What we really need is for the caller, that
			 * knows the name being used is valid since it got it
			 * from a readdir to use that name and not ask for the
			 * ATTR_CMN_NAME&lt;/rant&gt;
			 */</span>
			<span class="enscript-keyword">if</span> (dnp &amp;&amp; cnp &amp;&amp; (vp != NFSTOV(dnp))) {
				<span class="enscript-type">int</span> update_flags = (vnode_ismonitored((NFSTOV(dnp)))) ? VNODE_UPDATE_CACHE : 0;
				<span class="enscript-type">int</span> (*cmp)(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s1, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *s2, size_t n);

				cmp = nfs_case_insensitive(mp) ? strncasecmp : strncmp;

				<span class="enscript-keyword">if</span> (vp-&gt;v_name &amp;&amp; cnp-&gt;cn_namelen &amp;&amp; (*cmp)(cnp-&gt;cn_nameptr, vp-&gt;v_name, cnp-&gt;cn_namelen))
					update_flags |= VNODE_UPDATE_NAME;
				<span class="enscript-keyword">if</span> ((vp-&gt;v_name == NULL &amp;&amp; cnp-&gt;cn_namelen != 0) || (vp-&gt;v_name != NULL &amp;&amp; cnp-&gt;cn_namelen == 0))
					update_flags |= VNODE_UPDATE_NAME;
				<span class="enscript-keyword">if</span> (vnode_parent(vp) != NFSTOV(dnp))
					update_flags |= VNODE_UPDATE_PARENT;
				<span class="enscript-keyword">if</span> (update_flags) {
					NFS_NODE_DBG(<span class="enscript-string">&quot;vnode_update_identity old name %s new name %*s\n&quot;</span>,
						     vp-&gt;v_name, cnp-&gt;cn_namelen, cnp-&gt;cn_nameptr ? cnp-&gt;cn_nameptr : <span class="enscript-string">&quot;&quot;</span>);
					vnode_update_identity(vp, NFSTOV(dnp), cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, 0, update_flags);
				}
			}

			*npp = np;
		}
		FSDBG_BOT(263, dnp, *npp, 0xcace0000, error);
		<span class="enscript-keyword">return</span>(error);
	}

	FSDBG(263, mp, dnp, npp, 0xaaaaaaaa);

	<span class="enscript-keyword">if</span> (flags &amp; NG_NOCREATE) {
		lck_mtx_unlock(nfs_node_hash_mutex);
		*npp = 0;
		FSDBG_BOT(263, dnp, *npp, 0x80000001, ENOENT);
		<span class="enscript-keyword">return</span> (ENOENT);
	}

	<span class="enscript-comment">/*
	 * allocate and initialize nfsnode and stick it in the hash
	 * before calling getnewvnode().  Anyone finding it in the
	 * hash before initialization is complete will wait for it.
	 */</span>
	MALLOC_ZONE(np, nfsnode_t, <span class="enscript-keyword">sizeof</span> *np, M_NFSNODE, M_WAITOK);
	<span class="enscript-keyword">if</span> (!np) {
		lck_mtx_unlock(nfs_node_hash_mutex);
		*npp = 0;
		FSDBG_BOT(263, dnp, *npp, 0x80000001, ENOMEM);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	bzero(np, <span class="enscript-keyword">sizeof</span> *np);
	np-&gt;n_hflag |= (NHINIT | NHLOCKED);
	np-&gt;n_mount = mp;
	np-&gt;n_auth = auth;
	TAILQ_INIT(&amp;np-&gt;n_opens);
	TAILQ_INIT(&amp;np-&gt;n_lock_owners);
	TAILQ_INIT(&amp;np-&gt;n_locks);
	np-&gt;n_dlink.tqe_next = NFSNOLIST;
	np-&gt;n_dreturn.tqe_next = NFSNOLIST;
	np-&gt;n_monlink.le_next = NFSNOLIST;

	<span class="enscript-comment">/* ugh... need to keep track of &quot;.zfs&quot; directories to workaround server bugs */</span>
	<span class="enscript-keyword">if</span> ((nvap-&gt;nva_type == VDIR) &amp;&amp; cnp &amp;&amp; (cnp-&gt;cn_namelen == 4) &amp;&amp;
	    (cnp-&gt;cn_nameptr[0] == <span class="enscript-string">'.'</span>) &amp;&amp; (cnp-&gt;cn_nameptr[1] == <span class="enscript-string">'z'</span>) &amp;&amp;
	    (cnp-&gt;cn_nameptr[2] == <span class="enscript-string">'f'</span>) &amp;&amp; (cnp-&gt;cn_nameptr[3] == <span class="enscript-string">'s'</span>))
		np-&gt;n_flag |= NISDOTZFS;
	<span class="enscript-keyword">if</span> (dnp &amp;&amp; (dnp-&gt;n_flag &amp; NISDOTZFS))
		np-&gt;n_flag |= NISDOTZFSCHILD;

	<span class="enscript-keyword">if</span> (dnp &amp;&amp; cnp &amp;&amp; ((cnp-&gt;cn_namelen != 2) ||
	    (cnp-&gt;cn_nameptr[0] != <span class="enscript-string">'.'</span>) || (cnp-&gt;cn_nameptr[1] != <span class="enscript-string">'.'</span>))) {
		vnode_t dvp = NFSTOV(dnp);
		<span class="enscript-keyword">if</span> (!vnode_get(dvp)) {
			<span class="enscript-keyword">if</span> (!vnode_ref(dvp))
				np-&gt;n_parent = dvp;
			vnode_put(dvp);
		}
	}

	<span class="enscript-comment">/* setup node's file handle */</span>
	<span class="enscript-keyword">if</span> (fhsize &gt; NFS_SMALLFH) {
		MALLOC_ZONE(np-&gt;n_fhp, u_char *,
				fhsize, M_NFSBIGFH, M_WAITOK);
		<span class="enscript-keyword">if</span> (!np-&gt;n_fhp) {
			lck_mtx_unlock(nfs_node_hash_mutex);
			FREE_ZONE(np, <span class="enscript-keyword">sizeof</span> *np, M_NFSNODE);
			*npp = 0;
			FSDBG_BOT(263, dnp, *npp, 0x80000002, ENOMEM);
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
	} <span class="enscript-keyword">else</span> {
		np-&gt;n_fhp = &amp;np-&gt;n_fh[0];
	}
	bcopy(fhp, np-&gt;n_fhp, fhsize);
	np-&gt;n_fhsize = fhsize;

	<span class="enscript-comment">/* Insert the nfsnode in the hash queue for its new file handle */</span>
	LIST_INSERT_HEAD(nhpp, np, n_hash);
	np-&gt;n_hflag |= NHHASHED;
	FSDBG(266, 0, np, np-&gt;n_flag, np-&gt;n_hflag);

	<span class="enscript-comment">/* lock the new nfsnode */</span>
	lck_mtx_init(&amp;np-&gt;n_lock, nfs_node_lck_grp, LCK_ATTR_NULL);
	lck_rw_init(&amp;np-&gt;n_datalock, nfs_data_lck_grp, LCK_ATTR_NULL);
	lck_mtx_init(&amp;np-&gt;n_openlock, nfs_open_grp, LCK_ATTR_NULL);
	lck_mtx_lock(&amp;np-&gt;n_lock);

	<span class="enscript-comment">/* release lock on hash table */</span>
	lck_mtx_unlock(nfs_node_hash_mutex);

	<span class="enscript-comment">/* do initial loading of attributes */</span>
	NACLINVALIDATE(np);
	NACCESSINVALIDATE(np);
	error = nfs_loadattrcache(np, nvap, xidp, 1);
	<span class="enscript-keyword">if</span> (error) {
		FSDBG(266, 0, np, np-&gt;n_flag, 0xb1eb1e);
		nfs_node_unlock(np);
		lck_mtx_lock(nfs_node_hash_mutex);
		LIST_REMOVE(np, n_hash);
		np-&gt;n_hflag &amp;= ~(NHHASHED|NHINIT|NHLOCKED);
		<span class="enscript-keyword">if</span> (np-&gt;n_hflag &amp; NHLOCKWANT) {
			np-&gt;n_hflag &amp;= ~NHLOCKWANT;
			wakeup(np);
		}
		lck_mtx_unlock(nfs_node_hash_mutex);
		<span class="enscript-keyword">if</span> (np-&gt;n_parent) {
			<span class="enscript-keyword">if</span> (!vnode_get(np-&gt;n_parent)) {
				vnode_rele(np-&gt;n_parent);
				vnode_put(np-&gt;n_parent);
			}
			np-&gt;n_parent = NULL;
		}
		lck_mtx_destroy(&amp;np-&gt;n_lock, nfs_node_lck_grp);
		lck_rw_destroy(&amp;np-&gt;n_datalock, nfs_data_lck_grp);
		lck_mtx_destroy(&amp;np-&gt;n_openlock, nfs_open_grp);
		<span class="enscript-keyword">if</span> (np-&gt;n_fhsize &gt; NFS_SMALLFH)
			FREE_ZONE(np-&gt;n_fhp, np-&gt;n_fhsize, M_NFSBIGFH);
		FREE_ZONE(np, <span class="enscript-keyword">sizeof</span> *np, M_NFSNODE);
		*npp = 0;
		FSDBG_BOT(263, dnp, *npp, 0x80000003, error);
		<span class="enscript-keyword">return</span> (error);
	}
	NFS_CHANGED_UPDATE(nfsvers, np, nvap);
	<span class="enscript-keyword">if</span> (nvap-&gt;nva_type == VDIR)
		NFS_CHANGED_UPDATE_NC(nfsvers, np, nvap);

	<span class="enscript-comment">/* now, attempt to get a new vnode */</span>
	vfsp.vnfs_mp = mp;
	vfsp.vnfs_vtype = nvap-&gt;nva_type;
	vfsp.vnfs_str = <span class="enscript-string">&quot;nfs&quot;</span>;
	vfsp.vnfs_dvp = dnp ? NFSTOV(dnp) : NULL;
	vfsp.vnfs_fsnode = np;
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER4) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FIFO</span>
		<span class="enscript-keyword">if</span> (nvap-&gt;nva_type == VFIFO)
			vfsp.vnfs_vops = fifo_nfsv4nodeop_p;
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* FIFO */</span>
		<span class="enscript-keyword">if</span> (nvap-&gt;nva_type == VBLK || nvap-&gt;nva_type == VCHR)
			vfsp.vnfs_vops = spec_nfsv4nodeop_p;
		<span class="enscript-keyword">else</span>
			vfsp.vnfs_vops = nfsv4_vnodeop_p;
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FIFO</span>
		<span class="enscript-keyword">if</span> (nvap-&gt;nva_type == VFIFO)
			vfsp.vnfs_vops = fifo_nfsv2nodeop_p;
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* FIFO */</span>
		<span class="enscript-keyword">if</span> (nvap-&gt;nva_type == VBLK || nvap-&gt;nva_type == VCHR)
			vfsp.vnfs_vops = spec_nfsv2nodeop_p;
		<span class="enscript-keyword">else</span>
			vfsp.vnfs_vops = nfsv2_vnodeop_p;
	}
	vfsp.vnfs_markroot = (flags &amp; NG_MARKROOT) ? 1 : 0;
	vfsp.vnfs_marksystem = 0;
	vfsp.vnfs_rdev = 0;
	vfsp.vnfs_filesize = nvap-&gt;nva_size;
	vfsp.vnfs_cnp = cnp;
	vfsp.vnfs_flags = VNFS_ADDFSREF;
	<span class="enscript-keyword">if</span> (!dnp || !cnp || !(flags &amp; NG_MAKEENTRY))
		vfsp.vnfs_flags |= VNFS_NOCACHE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	<span class="enscript-keyword">if</span> ((nfsvers &gt;= NFS_VER4) &amp;&amp; (nvap-&gt;nva_type == VDIR) &amp;&amp; (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER)) {
		<span class="enscript-type">struct</span> vnode_trigger_param vtp;
		bzero(&amp;vtp, <span class="enscript-keyword">sizeof</span>(vtp));
		bcopy(&amp;vfsp, &amp;vtp.vnt_params, <span class="enscript-keyword">sizeof</span>(vfsp));
		vtp.vnt_resolve_func = nfs_mirror_mount_trigger_resolve;
		vtp.vnt_unresolve_func = nfs_mirror_mount_trigger_unresolve;
		vtp.vnt_rearm_func = nfs_mirror_mount_trigger_rearm;
		vtp.vnt_flags = VNT_AUTO_REARM;
		error = vnode_create(VNCREATE_TRIGGER, VNCREATE_TRIGGER_SIZE, &amp;vtp, &amp;np-&gt;n_vnode);
	} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
	{
		error = vnode_create(VNCREATE_FLAVOR, VCREATESIZE, &amp;vfsp, &amp;np-&gt;n_vnode);
	}
	<span class="enscript-keyword">if</span> (error) {
		FSDBG(266, 0, np, np-&gt;n_flag, 0xb1eb1e);
		nfs_node_unlock(np);
		lck_mtx_lock(nfs_node_hash_mutex);
		LIST_REMOVE(np, n_hash);
		np-&gt;n_hflag &amp;= ~(NHHASHED|NHINIT|NHLOCKED);
		<span class="enscript-keyword">if</span> (np-&gt;n_hflag &amp; NHLOCKWANT) {
			np-&gt;n_hflag &amp;= ~NHLOCKWANT;
			wakeup(np);
		}
		lck_mtx_unlock(nfs_node_hash_mutex);
		<span class="enscript-keyword">if</span> (np-&gt;n_parent) {
			<span class="enscript-keyword">if</span> (!vnode_get(np-&gt;n_parent)) {
				vnode_rele(np-&gt;n_parent);
				vnode_put(np-&gt;n_parent);
			}
			np-&gt;n_parent = NULL;
		}
		lck_mtx_destroy(&amp;np-&gt;n_lock, nfs_node_lck_grp);
		lck_rw_destroy(&amp;np-&gt;n_datalock, nfs_data_lck_grp);
		lck_mtx_destroy(&amp;np-&gt;n_openlock, nfs_open_grp);
		<span class="enscript-keyword">if</span> (np-&gt;n_fhsize &gt; NFS_SMALLFH)
			FREE_ZONE(np-&gt;n_fhp, np-&gt;n_fhsize, M_NFSBIGFH);
		FREE_ZONE(np, <span class="enscript-keyword">sizeof</span> *np, M_NFSNODE);
		*npp = 0;
		FSDBG_BOT(263, dnp, *npp, 0x80000004, error);
		<span class="enscript-keyword">return</span> (error);
	}
	vp = np-&gt;n_vnode;
	vnode_settag(vp, VT_NFS);
	<span class="enscript-comment">/* node is now initialized */</span>

	<span class="enscript-comment">/* check if anyone's waiting on this node */</span>
	lck_mtx_lock(nfs_node_hash_mutex);
	np-&gt;n_hflag &amp;= ~(NHINIT|NHLOCKED);
	<span class="enscript-keyword">if</span> (np-&gt;n_hflag &amp; NHLOCKWANT) {
		np-&gt;n_hflag &amp;= ~NHLOCKWANT;
		wakeup(np);
	}
	lck_mtx_unlock(nfs_node_hash_mutex);

	*npp = np;

	FSDBG_BOT(263, dnp, vp, *npp, error);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_inactive</span>(ap)
	<span class="enscript-type">struct</span> vnop_inactive_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		vfs_context_t a_context;
	} */</span> *ap;
{
	vnode_t vp = ap-&gt;a_vp;
	vfs_context_t ctx = ap-&gt;a_context;
	nfsnode_t np;
	<span class="enscript-type">struct</span> nfs_sillyrename *nsp;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">int</span> unhash, attrerr, busyerror, error, inuse, busied, force;
	<span class="enscript-type">struct</span> nfs_open_file *nofp;
	<span class="enscript-type">struct</span> componentname cn;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	mount_t mp;

	<span class="enscript-keyword">if</span> (vp == NULL)
		panic(<span class="enscript-string">&quot;nfs_vnop_inactive: vp == NULL&quot;</span>);
	np = VTONFS(vp);
	<span class="enscript-keyword">if</span> (np == NULL)
		panic(<span class="enscript-string">&quot;nfs_vnop_inactive: np == NULL&quot;</span>);
			
	nmp = NFSTONMP(np);
	mp = vnode_mount(vp);

<span class="enscript-reference">restart</span>:
	force = (!mp || vfs_isforce(mp));
	error = 0;
	inuse = (nfs_mount_state_in_use_start(nmp, NULL) == 0);

	<span class="enscript-comment">/* There shouldn't be any open or lock state at this point */</span>
	lck_mtx_lock(&amp;np-&gt;n_openlock);
	<span class="enscript-keyword">if</span> (np-&gt;n_openrefcnt &amp;&amp; !force) {
		<span class="enscript-comment">/*
		 * vnode_rele and vnode_put drop the vnode lock before
		 * calling VNOP_INACTIVE, so there is a race were the
		 * vnode could become active again. Perhaps there are
		 * other places where this can happen, so if we've got
		 * here we need to get out.
		 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFS_NODE_DEBUG</span>
		NP(np, <span class="enscript-string">&quot;nfs_vnop_inactive: still open: %d&quot;</span>, np-&gt;n_openrefcnt);
#<span class="enscript-reference">endif</span>		
		lck_mtx_unlock(&amp;np-&gt;n_openlock);
		<span class="enscript-keyword">return</span> 0;
	}

	TAILQ_FOREACH(nofp, &amp;np-&gt;n_opens, nof_link) {
		lck_mtx_lock(&amp;nofp-&gt;nof_lock);
		<span class="enscript-keyword">if</span> (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_BUSY) {
			<span class="enscript-keyword">if</span> (!force)
				NP(np, <span class="enscript-string">&quot;nfs_vnop_inactive: open file busy&quot;</span>);
			busied = 0;
		} <span class="enscript-keyword">else</span> {
			nofp-&gt;nof_flags |= NFS_OPEN_FILE_BUSY;
			busied = 1;
		}
		lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
		<span class="enscript-keyword">if</span> ((np-&gt;n_flag &amp; NREVOKE) || (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST)) {
			<span class="enscript-keyword">if</span> (busied)
				nfs_open_file_clear_busy(nofp);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * If we just created the file, we already had it open in
		 * anticipation of getting a subsequent open call.  If the
		 * node has gone inactive without being open, we need to
		 * clean up (close) the open done in the create.
		 */</span>
		<span class="enscript-keyword">if</span> ((nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_CREATE) &amp;&amp; nofp-&gt;nof_creator &amp;&amp; !force) {
			<span class="enscript-keyword">if</span> (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN) {
				lck_mtx_unlock(&amp;np-&gt;n_openlock);
				<span class="enscript-keyword">if</span> (busied)
					nfs_open_file_clear_busy(nofp);
				<span class="enscript-keyword">if</span> (inuse)
					nfs_mount_state_in_use_end(nmp, 0);
				<span class="enscript-keyword">if</span> (!nfs4_reopen(nofp, NULL))
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
			}
			nofp-&gt;nof_flags &amp;= ~NFS_OPEN_FILE_CREATE;
			lck_mtx_unlock(&amp;np-&gt;n_openlock);
			error = nfs_close(np, nofp, NFS_OPEN_SHARE_ACCESS_BOTH, NFS_OPEN_SHARE_DENY_NONE, ctx);
			<span class="enscript-keyword">if</span> (error) {
				NP(np, <span class="enscript-string">&quot;nfs_vnop_inactive: create close error: %d&quot;</span>, error);
				nofp-&gt;nof_flags |= NFS_OPEN_FILE_CREATE;
			}
			<span class="enscript-keyword">if</span> (busied)
				nfs_open_file_clear_busy(nofp);
			<span class="enscript-keyword">if</span> (inuse)
				nfs_mount_state_in_use_end(nmp, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		}
		<span class="enscript-keyword">if</span> (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_NEEDCLOSE) {
			<span class="enscript-comment">/*
			 * If the file is marked as needing reopen, but this was the only
			 * open on the file, just drop the open.
			 */</span>
			nofp-&gt;nof_flags &amp;= ~NFS_OPEN_FILE_NEEDCLOSE;
			<span class="enscript-keyword">if</span> ((nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN) &amp;&amp; (nofp-&gt;nof_opencnt == 1)) {
				nofp-&gt;nof_flags &amp;= ~NFS_OPEN_FILE_REOPEN;
				nofp-&gt;nof_r--;
				nofp-&gt;nof_opencnt--;
				nofp-&gt;nof_access = 0;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!force) {
				lck_mtx_unlock(&amp;np-&gt;n_openlock);
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN) {
					<span class="enscript-keyword">if</span> (busied)
						nfs_open_file_clear_busy(nofp);
					<span class="enscript-keyword">if</span> (inuse)
						nfs_mount_state_in_use_end(nmp, 0);
					<span class="enscript-keyword">if</span> (!nfs4_reopen(nofp, NULL))
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
				}
				error = nfs_close(np, nofp, NFS_OPEN_SHARE_ACCESS_READ, NFS_OPEN_SHARE_DENY_NONE, ctx);
				<span class="enscript-keyword">if</span> (error) {
					NP(np, <span class="enscript-string">&quot;nfs_vnop_inactive: need close error: %d&quot;</span>, error);
					nofp-&gt;nof_flags |= NFS_OPEN_FILE_NEEDCLOSE;
				}
				<span class="enscript-keyword">if</span> (busied)
					nfs_open_file_clear_busy(nofp);
				<span class="enscript-keyword">if</span> (inuse)
					nfs_mount_state_in_use_end(nmp, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
			}
		}
		<span class="enscript-keyword">if</span> (nofp-&gt;nof_opencnt &amp;&amp; !force)
			NP(np, <span class="enscript-string">&quot;nfs_vnop_inactive: file still open: %d&quot;</span>, nofp-&gt;nof_opencnt);
		<span class="enscript-keyword">if</span> (!force &amp;&amp; (nofp-&gt;nof_access || nofp-&gt;nof_deny ||
		    nofp-&gt;nof_mmap_access || nofp-&gt;nof_mmap_deny ||
		    nofp-&gt;nof_r || nofp-&gt;nof_w || nofp-&gt;nof_rw ||
		    nofp-&gt;nof_r_dw || nofp-&gt;nof_w_dw || nofp-&gt;nof_rw_dw ||
		    nofp-&gt;nof_r_drw || nofp-&gt;nof_w_drw || nofp-&gt;nof_rw_drw ||
		    nofp-&gt;nof_d_r || nofp-&gt;nof_d_w || nofp-&gt;nof_d_rw ||
		    nofp-&gt;nof_d_r_dw || nofp-&gt;nof_d_w_dw || nofp-&gt;nof_d_rw_dw ||
		    nofp-&gt;nof_d_r_drw || nofp-&gt;nof_d_w_drw || nofp-&gt;nof_d_rw_drw)) {
			NP(np, <span class="enscript-string">&quot;nfs_vnop_inactive: non-zero access: %d %d %d %d # %u.%u %u.%u %u.%u dw %u.%u %u.%u %u.%u drw %u.%u %u.%u %u.%u&quot;</span>,
				nofp-&gt;nof_access, nofp-&gt;nof_deny,
				nofp-&gt;nof_mmap_access, nofp-&gt;nof_mmap_deny,
				nofp-&gt;nof_r, nofp-&gt;nof_d_r,
				nofp-&gt;nof_w, nofp-&gt;nof_d_w,
				nofp-&gt;nof_rw, nofp-&gt;nof_d_rw,
				nofp-&gt;nof_r_dw, nofp-&gt;nof_d_r_dw,
				nofp-&gt;nof_w_dw, nofp-&gt;nof_d_w_dw,
				nofp-&gt;nof_rw_dw, nofp-&gt;nof_d_rw_dw,
				nofp-&gt;nof_r_drw, nofp-&gt;nof_d_r_drw,
				nofp-&gt;nof_w_drw, nofp-&gt;nof_d_w_drw,
				nofp-&gt;nof_rw_drw, nofp-&gt;nof_d_rw_drw);
		}
		<span class="enscript-keyword">if</span> (busied)
			nfs_open_file_clear_busy(nofp);
	}
	lck_mtx_unlock(&amp;np-&gt;n_openlock);

	<span class="enscript-keyword">if</span> (inuse &amp;&amp; nfs_mount_state_in_use_end(nmp, error))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;

	nfs_node_lock_force(np);

	<span class="enscript-keyword">if</span> (vnode_vtype(vp) != VDIR) {
		nsp = np-&gt;n_sillyrename; 
		np-&gt;n_sillyrename = NULL;
	} <span class="enscript-keyword">else</span> {
		nsp = NULL;
	}

	FSDBG_TOP(264, vp, np, np-&gt;n_flag, nsp);

	<span class="enscript-keyword">if</span> (!nsp) {
		<span class="enscript-comment">/* no silly file to clean up... */</span>
		<span class="enscript-comment">/* clear all flags other than these */</span>
		np-&gt;n_flag &amp;= (NMODIFIED);
		nfs_node_unlock(np);
		FSDBG_BOT(264, vp, np, np-&gt;n_flag, 0);
		<span class="enscript-keyword">return</span> (0);
	}
	nfs_node_unlock(np);

	<span class="enscript-comment">/* Remove the silly file that was rename'd earlier */</span>

	<span class="enscript-comment">/* flush all the buffers */</span>
	nfs_vinvalbuf2(vp, V_SAVE, vfs_context_thread(ctx), nsp-&gt;nsr_cred, 1);

	<span class="enscript-comment">/* try to get the latest attributes */</span>
	attrerr = nfs_getattr(np, &amp;nvattr, ctx, NGA_UNCACHED);

	<span class="enscript-comment">/* Check if we should remove it from the node hash. */</span>
	<span class="enscript-comment">/* Leave it if inuse or it has multiple hard links. */</span>
	<span class="enscript-keyword">if</span> (vnode_isinuse(vp, 0) || (!attrerr &amp;&amp; (nvattr.nva_nlink &gt; 1))) {
		unhash = 0;
	} <span class="enscript-keyword">else</span> {
		unhash = 1;
		ubc_setsize(vp, 0);
	}

	<span class="enscript-comment">/* mark this node and the directory busy while we do the remove */</span>
	busyerror = nfs_node_set_busy2(nsp-&gt;nsr_dnp, np, vfs_context_thread(ctx));

	<span class="enscript-comment">/* lock the node while we remove the silly file */</span>
	lck_mtx_lock(nfs_node_hash_mutex);
	<span class="enscript-keyword">while</span> (np-&gt;n_hflag &amp; NHLOCKED) {
		np-&gt;n_hflag |= NHLOCKWANT;
		msleep(np, nfs_node_hash_mutex, PINOD, <span class="enscript-string">&quot;nfs_inactive&quot;</span>, NULL);
	}
	np-&gt;n_hflag |= NHLOCKED;
	lck_mtx_unlock(nfs_node_hash_mutex);

	<span class="enscript-comment">/* purge the name cache to deter others from finding it */</span>
	bzero(&amp;cn, <span class="enscript-keyword">sizeof</span>(cn));
	cn.cn_nameptr = nsp-&gt;nsr_name;
	cn.cn_namelen = nsp-&gt;nsr_namlen;
	nfs_name_cache_purge(nsp-&gt;nsr_dnp, np, &amp;cn, ctx);

	FSDBG(264, np, np-&gt;n_size, np-&gt;n_vattr.nva_size, 0xf00d00f1);

	<span class="enscript-comment">/* now remove the silly file */</span>
	nfs_removeit(nsp);

	<span class="enscript-comment">/* clear all flags other than these */</span>
	nfs_node_lock_force(np);
	np-&gt;n_flag &amp;= (NMODIFIED);
	nfs_node_unlock(np);

	<span class="enscript-keyword">if</span> (!busyerror)
		nfs_node_clear_busy2(nsp-&gt;nsr_dnp, np);

	<span class="enscript-keyword">if</span> (unhash &amp;&amp; vnode_isinuse(vp, 0)) {
		<span class="enscript-comment">/* vnode now inuse after silly remove? */</span>
		unhash = 0;
		ubc_setsize(vp, np-&gt;n_size);
	}

	lck_mtx_lock(nfs_node_hash_mutex);
	<span class="enscript-keyword">if</span> (unhash) {
		<span class="enscript-comment">/*
		 * remove nfsnode from hash now so we can't accidentally find it
		 * again if another object gets created with the same filehandle
		 * before this vnode gets reclaimed
		 */</span>
		<span class="enscript-keyword">if</span> (np-&gt;n_hflag &amp; NHHASHED) {
			LIST_REMOVE(np, n_hash);
			np-&gt;n_hflag &amp;= ~NHHASHED;
			FSDBG(266, 0, np, np-&gt;n_flag, 0xb1eb1e);
		}
		vnode_recycle(vp);
	}
	<span class="enscript-comment">/* unlock the node */</span>
	np-&gt;n_hflag &amp;= ~NHLOCKED;
	<span class="enscript-keyword">if</span> (np-&gt;n_hflag &amp; NHLOCKWANT) {
		np-&gt;n_hflag &amp;= ~NHLOCKWANT;
		wakeup(np);
	}
	lck_mtx_unlock(nfs_node_hash_mutex);

	<span class="enscript-comment">/* cleanup sillyrename info */</span>
	<span class="enscript-keyword">if</span> (nsp-&gt;nsr_cred != NOCRED)
		kauth_cred_unref(&amp;nsp-&gt;nsr_cred);
	vnode_rele(NFSTOV(nsp-&gt;nsr_dnp));
	FREE_ZONE(nsp, <span class="enscript-keyword">sizeof</span>(*nsp), M_NFSREQ);

	FSDBG_BOT(264, vp, np, np-&gt;n_flag, 0);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Reclaim an nfsnode so that it can be used for other purposes.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_reclaim</span>(ap)
	<span class="enscript-type">struct</span> vnop_reclaim_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		vfs_context_t a_context;
	} */</span> *ap;
{
	vnode_t vp = ap-&gt;a_vp;
	nfsnode_t np = VTONFS(vp);
	vfs_context_t ctx = ap-&gt;a_context;
	<span class="enscript-type">struct</span> nfs_open_file *nofp, *nextnofp;
	<span class="enscript-type">struct</span> nfs_file_lock *nflp, *nextnflp;
	<span class="enscript-type">struct</span> nfs_lock_owner *nlop, *nextnlop;
	<span class="enscript-type">struct</span> nfsmount *nmp = np-&gt;n_mount ? VFSTONFS(np-&gt;n_mount) : NFSTONMP(np);
	mount_t mp = vnode_mount(vp);
	<span class="enscript-type">int</span> force;

	FSDBG_TOP(265, vp, np, np-&gt;n_flag, 0);
	force = (!mp || vfs_isforce(mp) || nfs_mount_gone(nmp));

	<span class="enscript-comment">/* There shouldn't be any open or lock state at this point */</span>
	lck_mtx_lock(&amp;np-&gt;n_openlock);

	<span class="enscript-keyword">if</span> (nmp &amp;&amp; (nmp-&gt;nm_vers &gt;= NFS_VER4)) {
		<span class="enscript-comment">/* need to drop a delegation */</span>
		<span class="enscript-keyword">if</span> (np-&gt;n_dreturn.tqe_next != NFSNOLIST) {
			<span class="enscript-comment">/* remove this node from the delegation return list */</span>
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">if</span> (np-&gt;n_dreturn.tqe_next != NFSNOLIST) {
				TAILQ_REMOVE(&amp;nmp-&gt;nm_dreturnq, np, n_dreturn);
				np-&gt;n_dreturn.tqe_next = NFSNOLIST;
			}
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		}
		<span class="enscript-keyword">if</span> (np-&gt;n_dlink.tqe_next != NFSNOLIST) {
			<span class="enscript-comment">/* remove this node from the delegation list */</span>
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">if</span> (np-&gt;n_dlink.tqe_next != NFSNOLIST) {
				TAILQ_REMOVE(&amp;nmp-&gt;nm_delegations, np, n_dlink);
				np-&gt;n_dlink.tqe_next = NFSNOLIST;
			}
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		}
		<span class="enscript-keyword">if</span> ((np-&gt;n_openflags &amp; N_DELEG_MASK) &amp;&amp; !force) {
			<span class="enscript-comment">/* try to return the delegation */</span>
			np-&gt;n_openflags &amp;= ~N_DELEG_MASK;
			nfs4_delegreturn_rpc(nmp, np-&gt;n_fhp, np-&gt;n_fhsize, &amp;np-&gt;n_dstateid,
				R_RECOVER, vfs_context_thread(ctx), vfs_context_ucred(ctx));
		}
		<span class="enscript-keyword">if</span> (np-&gt;n_attrdirfh) {
			FREE(np-&gt;n_attrdirfh, M_TEMP);
			np-&gt;n_attrdirfh = NULL;
		}
	}

	<span class="enscript-comment">/* clean up file locks */</span>
	TAILQ_FOREACH_SAFE(nflp, &amp;np-&gt;n_locks, nfl_link, nextnflp) {
		<span class="enscript-keyword">if</span> (!(nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_DEAD) &amp;&amp; !force) {
			NP(np, <span class="enscript-string">&quot;nfs_vnop_reclaim: lock 0x%llx 0x%llx 0x%x (bc %d)&quot;</span>,
				nflp-&gt;nfl_start, nflp-&gt;nfl_end, nflp-&gt;nfl_flags, nflp-&gt;nfl_blockcnt);
		}
		<span class="enscript-keyword">if</span> (!(nflp-&gt;nfl_flags &amp; (NFS_FILE_LOCK_BLOCKED|NFS_FILE_LOCK_DEAD))) {
			<span class="enscript-comment">/* try sending an unlock RPC if it wasn't delegated */</span>
			<span class="enscript-keyword">if</span> (!(nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_DELEGATED) &amp;&amp; !force)
				nmp-&gt;nm_funcs-&gt;nf_unlock_rpc(np, nflp-&gt;nfl_owner, F_WRLCK, nflp-&gt;nfl_start, nflp-&gt;nfl_end, R_RECOVER,
					NULL, nflp-&gt;nfl_owner-&gt;nlo_open_owner-&gt;noo_cred);
			lck_mtx_lock(&amp;nflp-&gt;nfl_owner-&gt;nlo_lock);
			TAILQ_REMOVE(&amp;nflp-&gt;nfl_owner-&gt;nlo_locks, nflp, nfl_lolink);
			lck_mtx_unlock(&amp;nflp-&gt;nfl_owner-&gt;nlo_lock);
		}
		TAILQ_REMOVE(&amp;np-&gt;n_locks, nflp, nfl_link);
		nfs_file_lock_destroy(nflp);
	}
	<span class="enscript-comment">/* clean up lock owners */</span>
	TAILQ_FOREACH_SAFE(nlop, &amp;np-&gt;n_lock_owners, nlo_link, nextnlop) {
		<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;nlop-&gt;nlo_locks) &amp;&amp; !force)
			NP(np, <span class="enscript-string">&quot;nfs_vnop_reclaim: lock owner with locks&quot;</span>);
		TAILQ_REMOVE(&amp;np-&gt;n_lock_owners, nlop, nlo_link);
		nfs_lock_owner_destroy(nlop);
	}
	<span class="enscript-comment">/* clean up open state */</span>
	<span class="enscript-keyword">if</span> (np-&gt;n_openrefcnt &amp;&amp; !force)
		NP(np, <span class="enscript-string">&quot;nfs_vnop_reclaim: still open: %d&quot;</span>, np-&gt;n_openrefcnt);
	TAILQ_FOREACH_SAFE(nofp, &amp;np-&gt;n_opens, nof_link, nextnofp) {
		<span class="enscript-keyword">if</span> (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_BUSY)
			NP(np, <span class="enscript-string">&quot;nfs_vnop_reclaim: open file busy&quot;</span>);
		<span class="enscript-keyword">if</span> (!(np-&gt;n_flag &amp; NREVOKE) &amp;&amp; !(nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST)) {
			<span class="enscript-keyword">if</span> (nofp-&gt;nof_opencnt &amp;&amp; !force)
				NP(np, <span class="enscript-string">&quot;nfs_vnop_reclaim: file still open: %d&quot;</span>, nofp-&gt;nof_opencnt);
			<span class="enscript-keyword">if</span> (!force &amp;&amp; (nofp-&gt;nof_access || nofp-&gt;nof_deny ||
			    nofp-&gt;nof_mmap_access || nofp-&gt;nof_mmap_deny ||
			    nofp-&gt;nof_r || nofp-&gt;nof_w || nofp-&gt;nof_rw ||
			    nofp-&gt;nof_r_dw || nofp-&gt;nof_w_dw || nofp-&gt;nof_rw_dw ||
			    nofp-&gt;nof_r_drw || nofp-&gt;nof_w_drw || nofp-&gt;nof_rw_drw ||
			    nofp-&gt;nof_d_r || nofp-&gt;nof_d_w || nofp-&gt;nof_d_rw ||
			    nofp-&gt;nof_d_r_dw || nofp-&gt;nof_d_w_dw || nofp-&gt;nof_d_rw_dw ||
			    nofp-&gt;nof_d_r_drw || nofp-&gt;nof_d_w_drw || nofp-&gt;nof_d_rw_drw)) {
				NP(np, <span class="enscript-string">&quot;nfs_vnop_reclaim: non-zero access: %d %d %d %d # %u.%u %u.%u %u.%u dw %u.%u %u.%u %u.%u drw %u.%u %u.%u %u.%u&quot;</span>,
					nofp-&gt;nof_access, nofp-&gt;nof_deny,
					nofp-&gt;nof_mmap_access, nofp-&gt;nof_mmap_deny,
					nofp-&gt;nof_r, nofp-&gt;nof_d_r,
					nofp-&gt;nof_w, nofp-&gt;nof_d_w,
					nofp-&gt;nof_rw, nofp-&gt;nof_d_rw,
					nofp-&gt;nof_r_dw, nofp-&gt;nof_d_r_dw,
					nofp-&gt;nof_w_dw, nofp-&gt;nof_d_w_dw,
					nofp-&gt;nof_rw_dw, nofp-&gt;nof_d_rw_dw,
					nofp-&gt;nof_r_drw, nofp-&gt;nof_d_r_drw,
					nofp-&gt;nof_w_drw, nofp-&gt;nof_d_w_drw,
					nofp-&gt;nof_rw_drw, nofp-&gt;nof_d_rw_drw);
				<span class="enscript-comment">/* try sending a close RPC if it wasn't delegated */</span>
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_r || nofp-&gt;nof_w || nofp-&gt;nof_rw ||
				    nofp-&gt;nof_r_dw || nofp-&gt;nof_w_dw || nofp-&gt;nof_rw_dw ||
				    nofp-&gt;nof_r_drw || nofp-&gt;nof_w_drw || nofp-&gt;nof_rw_drw)
					nfs4_close_rpc(np, nofp, NULL, nofp-&gt;nof_owner-&gt;noo_cred, R_RECOVER);
			}
		}
		TAILQ_REMOVE(&amp;np-&gt;n_opens, nofp, nof_link);
		nfs_open_file_destroy(nofp);
	}
	lck_mtx_unlock(&amp;np-&gt;n_openlock);

	<span class="enscript-keyword">if</span> (np-&gt;n_monlink.le_next != NFSNOLIST) {
		<span class="enscript-comment">/* Wait for any in-progress getattr to complete, */</span>
		<span class="enscript-comment">/* then remove this node from the monitored node list. */</span>
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">while</span> (np-&gt;n_mflag &amp; NMMONSCANINPROG) {
			<span class="enscript-type">struct</span> timespec ts = { 1, 0 };
			np-&gt;n_mflag |= NMMONSCANWANT;
			msleep(&amp;np-&gt;n_mflag, &amp;nmp-&gt;nm_lock, PZERO-1, <span class="enscript-string">&quot;nfswaitmonscan&quot;</span>, &amp;ts);
		}
		<span class="enscript-keyword">if</span> (np-&gt;n_monlink.le_next != NFSNOLIST) {
			LIST_REMOVE(np, n_monlink);
			np-&gt;n_monlink.le_next = NFSNOLIST;
		}
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	}

	lck_mtx_lock(nfs_buf_mutex);
	<span class="enscript-keyword">if</span> (!force &amp;&amp; (!LIST_EMPTY(&amp;np-&gt;n_dirtyblkhd) || !LIST_EMPTY(&amp;np-&gt;n_cleanblkhd)))
		NP(np, <span class="enscript-string">&quot;nfs_reclaim: dropping %s buffers&quot;</span>, (!LIST_EMPTY(&amp;np-&gt;n_dirtyblkhd) ? <span class="enscript-string">&quot;dirty&quot;</span> : <span class="enscript-string">&quot;clean&quot;</span>));
	lck_mtx_unlock(nfs_buf_mutex);
	nfs_vinvalbuf(vp, V_IGNORE_WRITEERR, ap-&gt;a_context, 0);

	lck_mtx_lock(nfs_node_hash_mutex);

	<span class="enscript-keyword">if</span> ((vnode_vtype(vp) != VDIR) &amp;&amp; np-&gt;n_sillyrename) {
		<span class="enscript-keyword">if</span> (!force)
			NP(np, <span class="enscript-string">&quot;nfs_reclaim: leaving unlinked file %s&quot;</span>, np-&gt;n_sillyrename-&gt;nsr_name);
		<span class="enscript-keyword">if</span> (np-&gt;n_sillyrename-&gt;nsr_cred != NOCRED)
			kauth_cred_unref(&amp;np-&gt;n_sillyrename-&gt;nsr_cred);
		vnode_rele(NFSTOV(np-&gt;n_sillyrename-&gt;nsr_dnp));
		FREE_ZONE(np-&gt;n_sillyrename, <span class="enscript-keyword">sizeof</span>(*np-&gt;n_sillyrename), M_NFSREQ);
	}

	vnode_removefsref(vp);

	<span class="enscript-keyword">if</span> (np-&gt;n_hflag &amp; NHHASHED) {
		LIST_REMOVE(np, n_hash);
		np-&gt;n_hflag &amp;= ~NHHASHED;
		FSDBG(266, 0, np, np-&gt;n_flag, 0xb1eb1e);
	}
	lck_mtx_unlock(nfs_node_hash_mutex);

	<span class="enscript-comment">/*
	 * Free up any directory cookie structures and large file handle
	 * structures that might be associated with this nfs node.
	 */</span>
	nfs_node_lock_force(np);
	<span class="enscript-keyword">if</span> ((vnode_vtype(vp) == VDIR) &amp;&amp; np-&gt;n_cookiecache)
		FREE_ZONE(np-&gt;n_cookiecache, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfsdmap), M_NFSDIROFF);
	<span class="enscript-keyword">if</span> (np-&gt;n_fhsize &gt; NFS_SMALLFH)
		FREE_ZONE(np-&gt;n_fhp, np-&gt;n_fhsize, M_NFSBIGFH);
	<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_acl)
		kauth_acl_free(np-&gt;n_vattr.nva_acl);
	nfs_node_unlock(np);
	vnode_clearfsnode(vp);

	<span class="enscript-keyword">if</span> (np-&gt;n_parent) {
		<span class="enscript-keyword">if</span> (!vnode_get(np-&gt;n_parent)) {
			vnode_rele(np-&gt;n_parent);
			vnode_put(np-&gt;n_parent);
		}
		np-&gt;n_parent = NULL;
	}

	lck_mtx_destroy(&amp;np-&gt;n_lock, nfs_node_lck_grp);
	lck_rw_destroy(&amp;np-&gt;n_datalock, nfs_data_lck_grp);
	lck_mtx_destroy(&amp;np-&gt;n_openlock, nfs_open_grp);

	FSDBG_BOT(265, vp, np, np-&gt;n_flag, 0xd1ed1e);
	FREE_ZONE(np, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfsnode), M_NFSNODE);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Acquire an NFS node lock
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_node_lock_internal</span>(nfsnode_t np, <span class="enscript-type">int</span> force)
{
	FSDBG_TOP(268, np, force, 0, 0);
	lck_mtx_lock(&amp;np-&gt;n_lock);
	<span class="enscript-keyword">if</span> (!force &amp;&amp; !(np-&gt;n_hflag &amp;&amp; NHHASHED)) {
		FSDBG_BOT(268, np, 0xdead, 0, 0);
		lck_mtx_unlock(&amp;np-&gt;n_lock);
		<span class="enscript-keyword">return</span> (ENOENT);
	}
	FSDBG_BOT(268, np, force, 0, 0);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_node_lock</span>(nfsnode_t np)
{
	<span class="enscript-keyword">return</span> nfs_node_lock_internal(np, 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_node_lock_force</span>(nfsnode_t np)
{
	nfs_node_lock_internal(np, 1);
}

<span class="enscript-comment">/*
 * Release an NFS node lock
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_node_unlock</span>(nfsnode_t np)
{
	FSDBG(269, np, current_thread(), 0, 0);
	lck_mtx_unlock(&amp;np-&gt;n_lock);
}

<span class="enscript-comment">/*
 * Acquire 2 NFS node locks
 *   - locks taken in reverse address order
 *   - both or neither of the locks are taken
 *   - only one lock taken per node (dup nodes are skipped)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_node_lock2</span>(nfsnode_t np1, nfsnode_t np2)
{
	nfsnode_t first, second;
	<span class="enscript-type">int</span> error;

	first = (np1 &gt; np2) ? np1 : np2;
	second = (np1 &gt; np2) ? np2 : np1;
	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(first)))
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (np1 == np2)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(second)))
		nfs_node_unlock(first);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_node_unlock2</span>(nfsnode_t np1, nfsnode_t np2)
{
	nfs_node_unlock(np1);
	<span class="enscript-keyword">if</span> (np1 != np2)
		nfs_node_unlock(np2);
}

<span class="enscript-comment">/*
 * Manage NFS node busy state.
 * (Similar to NFS node locks above)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_node_set_busy</span>(nfsnode_t np, thread_t thd)
{
	<span class="enscript-type">struct</span> timespec ts = { 2, 0 };
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np)))
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">while</span> (ISSET(np-&gt;n_flag, NBUSY)) {
		SET(np-&gt;n_flag, NBUSYWANT);
		msleep(np, &amp;np-&gt;n_lock, PZERO-1, <span class="enscript-string">&quot;nfsbusywant&quot;</span>, &amp;ts);
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(NFSTONMP(np), NULL, thd, 0)))
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (!error)
		SET(np-&gt;n_flag, NBUSY);
	nfs_node_unlock(np);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_node_clear_busy</span>(nfsnode_t np)
{
	<span class="enscript-type">int</span> wanted;

	nfs_node_lock_force(np);
	wanted = ISSET(np-&gt;n_flag, NBUSYWANT);
	CLR(np-&gt;n_flag, NBUSY|NBUSYWANT);
	nfs_node_unlock(np);
	<span class="enscript-keyword">if</span> (wanted)
		wakeup(np);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_node_set_busy2</span>(nfsnode_t np1, nfsnode_t np2, thread_t thd)
{
	nfsnode_t first, second;
	<span class="enscript-type">int</span> error;

	first = (np1 &gt; np2) ? np1 : np2;
	second = (np1 &gt; np2) ? np2 : np1;
	<span class="enscript-keyword">if</span> ((error = nfs_node_set_busy(first, thd)))
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (np1 == np2)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> ((error = nfs_node_set_busy(second, thd)))
		nfs_node_clear_busy(first);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_node_clear_busy2</span>(nfsnode_t np1, nfsnode_t np2)
{
	nfs_node_clear_busy(np1);
	<span class="enscript-keyword">if</span> (np1 != np2)
		nfs_node_clear_busy(np2);
}

<span class="enscript-comment">/* helper function to sort four nodes in reverse address order (no dupes) */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_node_sort4</span>(nfsnode_t np1, nfsnode_t np2, nfsnode_t np3, nfsnode_t np4, nfsnode_t *list, <span class="enscript-type">int</span> *lcntp)
{
	nfsnode_t na[2], nb[2];
	<span class="enscript-type">int</span> a, b, i, lcnt;

	<span class="enscript-comment">/* sort pairs then merge */</span>
	na[0] = (np1 &gt; np2) ? np1 : np2;
	na[1] = (np1 &gt; np2) ? np2 : np1;
	nb[0] = (np3 &gt; np4) ? np3 : np4;
	nb[1] = (np3 &gt; np4) ? np4 : np3;
	<span class="enscript-keyword">for</span> (a = b = i = lcnt = 0; i &lt; 4; i++) {
		<span class="enscript-keyword">if</span> (a &gt;= 2)
			list[lcnt] = nb[b++];
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((b &gt;= 2) || (na[a] &gt;= nb[b]))
			list[lcnt] = na[a++];
		<span class="enscript-keyword">else</span>
			list[lcnt] = nb[b++];
		<span class="enscript-keyword">if</span> ((lcnt &lt;= 0) || (list[lcnt] != list[lcnt-1]))
			lcnt++; <span class="enscript-comment">/* omit dups */</span>
	}
	<span class="enscript-keyword">if</span> (list[lcnt-1] == NULL)
		lcnt--;
	*lcntp = lcnt;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_node_set_busy4</span>(nfsnode_t np1, nfsnode_t np2, nfsnode_t np3, nfsnode_t np4, thread_t thd)
{
	nfsnode_t list[4];
	<span class="enscript-type">int</span> i, lcnt, error;

	nfs_node_sort4(np1, np2, np3, np4, list, &amp;lcnt);

	<span class="enscript-comment">/* Now we can lock using list[0 - lcnt-1] */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; lcnt; ++i)
		<span class="enscript-keyword">if</span> ((error = nfs_node_set_busy(list[i], thd))) {
			<span class="enscript-comment">/* Drop any locks we acquired. */</span>
			<span class="enscript-keyword">while</span> (--i &gt;= 0)
				nfs_node_clear_busy(list[i]);
			<span class="enscript-keyword">return</span> (error);
		}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_node_clear_busy4</span>(nfsnode_t np1, nfsnode_t np2, nfsnode_t np3, nfsnode_t np4)
{
	nfsnode_t list[4];
	<span class="enscript-type">int</span> lcnt;

	nfs_node_sort4(np1, np2, np3, np4, list, &amp;lcnt);
	<span class="enscript-keyword">while</span> (--lcnt &gt;= 0)
		nfs_node_clear_busy(list[lcnt]);
}

<span class="enscript-comment">/*
 * Acquire an NFS node data lock
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_data_lock</span>(nfsnode_t np, <span class="enscript-type">int</span> locktype)
{
	nfs_data_lock_internal(np, locktype, 1);
}
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_data_lock_noupdate</span>(nfsnode_t np, <span class="enscript-type">int</span> locktype)
{
	nfs_data_lock_internal(np, locktype, 0);
}
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_data_lock_internal</span>(nfsnode_t np, <span class="enscript-type">int</span> locktype, <span class="enscript-type">int</span> updatesize)
{
	FSDBG_TOP(270, np, locktype, np-&gt;n_datalockowner, 0);
	<span class="enscript-keyword">if</span> (locktype == NFS_DATA_LOCK_SHARED) {
		<span class="enscript-keyword">if</span> (updatesize &amp;&amp; ISSET(np-&gt;n_flag, NUPDATESIZE))
			nfs_data_update_size(np, 0);
		lck_rw_lock_shared(&amp;np-&gt;n_datalock);
	} <span class="enscript-keyword">else</span> {
		lck_rw_lock_exclusive(&amp;np-&gt;n_datalock);
		np-&gt;n_datalockowner = current_thread();
		<span class="enscript-keyword">if</span> (updatesize &amp;&amp; ISSET(np-&gt;n_flag, NUPDATESIZE))
			nfs_data_update_size(np, 1);
	}
	FSDBG_BOT(270, np, locktype, np-&gt;n_datalockowner, 0);
}

<span class="enscript-comment">/*
 * Release an NFS node data lock
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_data_unlock</span>(nfsnode_t np)
{
	nfs_data_unlock_internal(np, 1);
}
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_data_unlock_noupdate</span>(nfsnode_t np)
{
	nfs_data_unlock_internal(np, 0);
}
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_data_unlock_internal</span>(nfsnode_t np, <span class="enscript-type">int</span> updatesize)
{
	<span class="enscript-type">int</span> mine = (np-&gt;n_datalockowner == current_thread());
	FSDBG_TOP(271, np, np-&gt;n_datalockowner, current_thread(), 0);
	<span class="enscript-keyword">if</span> (updatesize &amp;&amp; mine &amp;&amp; ISSET(np-&gt;n_flag, NUPDATESIZE))
		nfs_data_update_size(np, 1);
	np-&gt;n_datalockowner = NULL;
	lck_rw_done(&amp;np-&gt;n_datalock);
	<span class="enscript-keyword">if</span> (updatesize &amp;&amp; !mine &amp;&amp; ISSET(np-&gt;n_flag, NUPDATESIZE))
		nfs_data_update_size(np, 0);
	FSDBG_BOT(271, np, np-&gt;n_datalockowner, current_thread(), 0);
}


<span class="enscript-comment">/*
 * update an NFS node's size
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_data_update_size</span>(nfsnode_t np, <span class="enscript-type">int</span> datalocked)
{
	<span class="enscript-type">int</span> error;

	FSDBG_TOP(272, np, np-&gt;n_flag, np-&gt;n_size, np-&gt;n_newsize);
	<span class="enscript-keyword">if</span> (!datalocked) {
		nfs_data_lock(np, NFS_DATA_LOCK_EXCLUSIVE);
		<span class="enscript-comment">/* grabbing data lock will automatically update size */</span>
		nfs_data_unlock(np);
		FSDBG_BOT(272, np, np-&gt;n_flag, np-&gt;n_size, np-&gt;n_newsize);
		<span class="enscript-keyword">return</span>;
	}
	error = nfs_node_lock(np);
	<span class="enscript-keyword">if</span> (error || !ISSET(np-&gt;n_flag, NUPDATESIZE)) {
		<span class="enscript-keyword">if</span> (!error)
			nfs_node_unlock(np);
		FSDBG_BOT(272, np, np-&gt;n_flag, np-&gt;n_size, np-&gt;n_newsize);
		<span class="enscript-keyword">return</span>;
	}
	CLR(np-&gt;n_flag, NUPDATESIZE);
	np-&gt;n_size = np-&gt;n_newsize;
	<span class="enscript-comment">/* make sure we invalidate buffers the next chance we get */</span>
	SET(np-&gt;n_flag, NNEEDINVALIDATE);
	nfs_node_unlock(np);
	ubc_setsize(NFSTOV(np), (off_t)np-&gt;n_size); <span class="enscript-comment">/* XXX error? */</span>
	FSDBG_BOT(272, np, np-&gt;n_flag, np-&gt;n_size, np-&gt;n_newsize);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DODEBUG</span> 1

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_mount_is_dirty</span>(mount_t mp)
{
	u_long i;
	nfsnode_t np;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DODEBUG</span>	
	<span class="enscript-type">struct</span> timeval now, then, diff;
	u_long ncnt = 0;
	microuptime(&amp;now);
#<span class="enscript-reference">endif</span>
	lck_mtx_lock(nfs_node_hash_mutex);
	<span class="enscript-keyword">for</span> (i = 0; i &lt;= nfsnodehash; i++) {
		LIST_FOREACH(np, &amp;nfsnodehashtbl[i], n_hash) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DODEBUG</span>
			ncnt++;
#<span class="enscript-reference">endif</span>			
			<span class="enscript-keyword">if</span> (np-&gt;n_mount == mp &amp;&amp; !LIST_EMPTY(&amp;np-&gt;n_dirtyblkhd))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
<span class="enscript-reference">out</span>:
	lck_mtx_unlock(nfs_node_hash_mutex);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DODEBUG</span>
	microuptime(&amp;then);
	timersub(&amp;then, &amp;now, &amp;diff);
	
	NFS_DBG(NFS_FAC_SOCK, 7, <span class="enscript-string">&quot;mount_is_dirty for %s took %lld mics for %ld slots and %ld nodes return %d\n&quot;</span>,
		vfs_statfs(mp)-&gt;f_mntfromname, (uint64_t)diff.tv_sec * 1000000LL + diff.tv_usec, i, ncnt, (i &lt;= nfsnodehash));
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> (i &lt;=  nfsnodehash);
}
</pre>
<hr />
</body></html>