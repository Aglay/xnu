<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nfs.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nfs.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfs.h	8.4 (Berkeley) 5/1/95
 * FreeBSD-Id: nfs.h,v 1.32 1997/10/12 20:25:38 phk Exp $
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_NFS_NFS_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_NFS_NFS_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE_API_PRIVATE</span>
<span class="enscript-comment">/*
 * Tunable constants for nfs
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_TICKINTVL</span>	5		<span class="enscript-comment">/* Desired time for a tick (msec) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_HZ</span>		(hz / nfs_ticks) <span class="enscript-comment">/* Ticks/sec */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfs_ticks;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_TIMEO</span>	(1 * NFS_HZ)	<span class="enscript-comment">/* Default timeout = 1 second */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_MINTIMEO</span>	(1 * NFS_HZ)	<span class="enscript-comment">/* Min timeout to use */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_MAXTIMEO</span>	(60 * NFS_HZ)	<span class="enscript-comment">/* Max timeout to backoff to */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_MINIDEMTIMEO</span> (5 * NFS_HZ)	<span class="enscript-comment">/* Min timeout for non-idempotent ops*/</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_MAXREXMIT</span>	100		<span class="enscript-comment">/* Stop counting after this many */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_RETRANS</span>	10		<span class="enscript-comment">/* Num of retrans for soft mounts */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_TRYLATERDEL</span>	4		<span class="enscript-comment">/* Initial try later delay (sec) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_MAXGRPS</span>	16U		<span class="enscript-comment">/* Max. size of groups list */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_MINATTRTIMO</span> 5		<span class="enscript-comment">/* Attribute cache timeout in sec */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_MAXATTRTIMO</span> 60
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_MINDIRATTRTIMO</span> 5		<span class="enscript-comment">/* directory attribute cache timeout in sec */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_MAXDIRATTRTIMO</span> 60
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_IOSIZE</span>	(1024 * 1024)	<span class="enscript-comment">/* suggested I/O size */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_RWSIZE</span>	32768		<span class="enscript-comment">/* Def. read/write data size &lt;= 32K */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_WSIZE</span>	NFS_RWSIZE	<span class="enscript-comment">/* Def. write data size &lt;= 32K */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_RSIZE</span>	NFS_RWSIZE	<span class="enscript-comment">/* Def. read data size &lt;= 32K */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_DGRAM_WSIZE</span>	8192		<span class="enscript-comment">/* UDP Def. write data size &lt;= 8K */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_DGRAM_RSIZE</span>	8192		<span class="enscript-comment">/* UDP Def. read data size &lt;= 8K */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_READDIRSIZE</span>	32768		<span class="enscript-comment">/* Def. readdir size */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_DEFRAHEAD</span>	16		<span class="enscript-comment">/* Def. read ahead # blocks */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_MAXRAHEAD</span>	128		<span class="enscript-comment">/* Max. read ahead # blocks */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_DEFMAXASYNCWRITES</span> 	128	<span class="enscript-comment">/* Def. max # concurrent async write RPCs */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_DEFASYNCTHREAD</span> 	16	<span class="enscript-comment">/* Def. # nfsiod threads */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_MAXASYNCTHREAD</span> 	64	<span class="enscript-comment">/* max # nfsiod threads */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_ASYNCTHREADMAXIDLE</span>	60	<span class="enscript-comment">/* Seconds before idle nfsiods are reaped */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_DEFSTATFSRATELIMIT</span> 	10	<span class="enscript-comment">/* Def. max # statfs RPCs per second */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_REQUESTDELAY</span>	10	<span class="enscript-comment">/* ms interval to check request queue */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSRV_MAXWGATHERDELAY</span>	100	<span class="enscript-comment">/* Max. write gather delay (msec) */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NFSRV_WGATHERDELAY</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSRV_WGATHERDELAY</span>	1	<span class="enscript-comment">/* Default write gather delay (msec) */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_DIRBLKSIZ</span>	4096		<span class="enscript-comment">/* size of NFS directory buffers */</span>
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">KERNEL</span>) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DIRBLKSIZ</span>)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DIRBLKSIZ</span>	512		<span class="enscript-comment">/* XXX we used to use ufs's DIRBLKSIZ */</span>
 					<span class="enscript-comment">/* can't be larger than NFS_FABLKSIZE */</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* default values for unresponsive mount timeouts */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_TPRINTF_INITIAL_DELAY</span>	12
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_TPRINTF_DELAY</span>		30

<span class="enscript-comment">/*
 * Oddballs
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_CMPFH</span>(n, f, s) \
	((n)-&gt;n_fhsize == (s) &amp;&amp; !bcmp((caddr_t)(n)-&gt;n_fhp, (caddr_t)(f), (s)))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFSRV_NDMAXDATA</span>(n) \
		(((n)-&gt;nd_vers == NFS_VER3) ? (((n)-&gt;nd_nam2) ? \
		 NFS_MAXDGRAMDATA : NFSRV_MAXDATA) : NFS_V2MAXDATA)

<span class="enscript-comment">/*
 * The IO_METASYNC flag should be implemented for local file systems.
 * (Until then, it is nothin at all.)
 */</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">IO_METASYNC</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IO_METASYNC</span>	0
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Expected allocation sizes for major data structures. If the actual size
 * of the structure exceeds these sizes, then malloc() will be allocating
 * almost twice the memory required. This is used in nfs_init() to warn
 * the sysadmin that the size of a structure should be reduced.
 * (These sizes are always a power of 2. If the kernel malloc() changes
 *  to one that does not allocate space in powers of 2 size, then this all
 *  becomes bunk!).
 * Note that some of these structures come out of their own nfs zones.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_NODEALLOC</span>	1024
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MNTALLOC</span>	1024
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_SVCALLOC</span>	512

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_ARGSVERSION_XDR</span>	88	<span class="enscript-comment">/* NFS mount args are in XDR format */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_XDRARGS_VERSION_0</span>	0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_BITMAP_LEN</span>	1		<span class="enscript-comment">/* length of mount attributes bitmap */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_BITMAP_LEN</span>	1		<span class="enscript-comment">/* length of mount flags bitmap */</span>

<span class="enscript-comment">/* NFS mount attributes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_FLAGS</span>			0	<span class="enscript-comment">/* mount flags (NFS_MATTR_*) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_NFS_VERSION</span>		1	<span class="enscript-comment">/* NFS protocol version */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_NFS_MINOR_VERSION</span>	2	<span class="enscript-comment">/* NFS protocol minor version */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_READ_SIZE</span>		3	<span class="enscript-comment">/* READ RPC size */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_WRITE_SIZE</span>		4	<span class="enscript-comment">/* WRITE RPC size */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_READDIR_SIZE</span>		5	<span class="enscript-comment">/* READDIR RPC size */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_READAHEAD</span>		6	<span class="enscript-comment">/* block readahead count */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_ATTRCACHE_REG_MIN</span>	7	<span class="enscript-comment">/* minimum attribute cache time */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_ATTRCACHE_REG_MAX</span>	8	<span class="enscript-comment">/* maximum attribute cache time */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_ATTRCACHE_DIR_MIN</span>	9	<span class="enscript-comment">/* minimum attribute cache time for dirs */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_ATTRCACHE_DIR_MAX</span>	10	<span class="enscript-comment">/* maximum attribute cache time for dirs */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_LOCK_MODE</span>		11	<span class="enscript-comment">/* advisory file locking mode (NFS_LOCK_MODE_*) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_SECURITY</span>		12	<span class="enscript-comment">/* RPC security flavors to use */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_MAX_GROUP_LIST</span>	13	<span class="enscript-comment">/* max # of RPC AUTH_SYS groups */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_SOCKET_TYPE</span>		14	<span class="enscript-comment">/* socket transport type as a netid-like string */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_NFS_PORT</span>		15	<span class="enscript-comment">/* port # to use for NFS protocol */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_MOUNT_PORT</span>		16	<span class="enscript-comment">/* port # to use for MOUNT protocol */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_REQUEST_TIMEOUT</span>	17	<span class="enscript-comment">/* initial RPC request timeout value */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_SOFT_RETRY_COUNT</span>	18	<span class="enscript-comment">/* max RPC retransmissions for soft mounts */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_DEAD_TIMEOUT</span>		19	<span class="enscript-comment">/* how long until unresponsive mount is considered dead */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_FH</span>			20	<span class="enscript-comment">/* file handle for mount directory */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_FS_LOCATIONS</span>		21	<span class="enscript-comment">/* list of locations for the file system */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_MNTFLAGS</span>		22	<span class="enscript-comment">/* VFS mount flags (MNT_*) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_MNTFROM</span>		23	<span class="enscript-comment">/* fixed string to use for &quot;f_mntfromname&quot; */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_REALM</span>			24	<span class="enscript-comment">/* Realm to authenticate with */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_PRINCIPAL</span>		25	<span class="enscript-comment">/* GSS principal to authenticate with */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_SVCPRINCIPAL</span>		26	<span class="enscript-comment">/* GSS principal to authenticate to, the server principal */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MATTR_NFS_VERSION_RANGE</span>	27	<span class="enscript-comment">/* Packed version range to try */</span>

<span class="enscript-comment">/* NFS mount flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_SOFT</span>			0	<span class="enscript-comment">/* soft mount (requests fail if unresponsive) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_INTR</span>			1	<span class="enscript-comment">/* allow operations to be interrupted */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_RESVPORT</span>		2	<span class="enscript-comment">/* use a reserved port */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_NOCONNECT</span>		3	<span class="enscript-comment">/* don't connect the socket (UDP) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_DUMBTIMER</span>		4	<span class="enscript-comment">/* don't estimate RTT dynamically */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_CALLUMNT</span>		5	<span class="enscript-comment">/* call MOUNTPROC_UMNT on unmount */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_RDIRPLUS</span>		6	<span class="enscript-comment">/* request additional info when reading directories */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_NONEGNAMECACHE</span>	7	<span class="enscript-comment">/* don't do negative name caching */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_MUTEJUKEBOX</span>		8	<span class="enscript-comment">/* don't treat jukebox errors as unresponsive */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_EPHEMERAL</span>		9	<span class="enscript-comment">/* ephemeral (mirror) mount */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_NOCALLBACK</span>		10	<span class="enscript-comment">/* don't provide callback RPC service */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_NONAMEDATTR</span>		11	<span class="enscript-comment">/* don't use named attributes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_NOACL</span>			12	<span class="enscript-comment">/* don't support ACLs */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_ACLONLY</span>		13	<span class="enscript-comment">/* only support ACLs - not mode */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_NFC</span>			14	<span class="enscript-comment">/* send NFC strings */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_NOQUOTA</span>		15	<span class="enscript-comment">/* don't support QUOTA requests */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_MNTUDP</span>		16	<span class="enscript-comment">/* MOUNT protocol should use UDP */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MFLAG_MNTQUICK</span>		17	<span class="enscript-comment">/* use short timeouts while mounting */</span>

<span class="enscript-comment">/* Macros for packing and unpacking packed versions */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PVER2MAJOR</span>(M) ((uint32_t)(((M) &gt;&gt; 16) &amp; 0xffff))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PVER2MINOR</span>(m) ((uint32_t)((m) &amp; 0xffff))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VER2PVER</span>(M, m) ((uint32_t)((M) &lt;&lt; 16) | ((m) &amp; 0xffff))

<span class="enscript-comment">/* NFS advisory file locking modes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_LOCK_MODE_ENABLED</span>		0	<span class="enscript-comment">/* advisory file locking enabled */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_LOCK_MODE_DISABLED</span>		1	<span class="enscript-comment">/* do not support advisory file locking */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_LOCK_MODE_LOCAL</span>		2	<span class="enscript-comment">/* perform advisory file locking locally */</span>

<span class="enscript-comment">/*
 * Old-style arguments to mount NFS
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_ARGSVERSION</span>	6		<span class="enscript-comment">/* change when nfs_args changes */</span>
<span class="enscript-type">struct</span> nfs_args {
	<span class="enscript-type">int</span>		version;	<span class="enscript-comment">/* args structure version number */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
	user32_addr_t addr;		<span class="enscript-comment">/* file server address */</span>
#<span class="enscript-reference">else</span>
	<span class="enscript-type">struct</span> sockaddr	*addr;		<span class="enscript-comment">/* file server address */</span>
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span>		addrlen;	<span class="enscript-comment">/* length of address */</span>
	<span class="enscript-type">int</span>		sotype;		<span class="enscript-comment">/* Socket type */</span>
	<span class="enscript-type">int</span>		proto;		<span class="enscript-comment">/* and Protocol */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
	user32_addr_t fh;		<span class="enscript-comment">/* File handle to be mounted */</span>
#<span class="enscript-reference">else</span>
	u_char		*fh;		<span class="enscript-comment">/* File handle to be mounted */</span>
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span>		fhsize;		<span class="enscript-comment">/* Size, in bytes, of fh */</span>
	<span class="enscript-type">int</span>		flags;		<span class="enscript-comment">/* flags */</span>
	<span class="enscript-type">int</span>		wsize;		<span class="enscript-comment">/* write size in bytes */</span>
	<span class="enscript-type">int</span>		rsize;		<span class="enscript-comment">/* read size in bytes */</span>
	<span class="enscript-type">int</span>		readdirsize;	<span class="enscript-comment">/* readdir size in bytes */</span>
	<span class="enscript-type">int</span>		timeo;		<span class="enscript-comment">/* initial timeout in .1 secs */</span>
	<span class="enscript-type">int</span>		retrans;	<span class="enscript-comment">/* times to retry send */</span>
	<span class="enscript-type">int</span>		maxgrouplist;	<span class="enscript-comment">/* Max. size of group list */</span>
	<span class="enscript-type">int</span>		readahead;	<span class="enscript-comment">/* # of blocks to readahead */</span>
	<span class="enscript-type">int</span>		leaseterm;	<span class="enscript-comment">/* obsolete: Term (sec) of lease */</span>
	<span class="enscript-type">int</span>		deadthresh;	<span class="enscript-comment">/* obsolete: Retrans threshold */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
	user32_addr_t hostname;	<span class="enscript-comment">/* server's name */</span>
#<span class="enscript-reference">else</span>
	<span class="enscript-type">char</span>		*hostname;	<span class="enscript-comment">/* server's name */</span>
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* NFS_ARGSVERSION 3 ends here */</span>
	<span class="enscript-type">int</span>		acregmin;	<span class="enscript-comment">/* reg file min attr cache timeout */</span>
	<span class="enscript-type">int</span>		acregmax;	<span class="enscript-comment">/* reg file max attr cache timeout */</span>
	<span class="enscript-type">int</span>		acdirmin;	<span class="enscript-comment">/* dir min attr cache timeout */</span>
	<span class="enscript-type">int</span>		acdirmax;	<span class="enscript-comment">/* dir max attr cache timeout */</span>
	<span class="enscript-comment">/* NFS_ARGSVERSION 4 ends here */</span>
	uint32_t	auth;		<span class="enscript-comment">/* security mechanism flavor */</span>
	<span class="enscript-comment">/* NFS_ARGSVERSION 5 ends here */</span>
	uint32_t	deadtimeout;	<span class="enscript-comment">/* secs until unresponsive mount considered dead */</span>
};

<span class="enscript-comment">/* incremental size additions in each version of nfs_args */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_ARGSVERSION4_INCSIZE</span>	(4 * sizeof(int))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_ARGSVERSION5_INCSIZE</span>	(sizeof(uint32_t))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_ARGSVERSION6_INCSIZE</span>	(sizeof(uint32_t))

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
<span class="enscript-comment">/* LP64 version of nfs_args.  all pointers and longs
 * grow when we're dealing with a 64-bit process.
 * WARNING - keep in sync with nfs_args
 */</span>
<span class="enscript-type">struct</span> user_nfs_args {
	<span class="enscript-type">int</span>		version;	<span class="enscript-comment">/* args structure version number */</span>
	user_addr_t	addr __attribute((aligned(8)));		<span class="enscript-comment">/* file server address */</span>
	<span class="enscript-type">int</span>		addrlen;	<span class="enscript-comment">/* length of address */</span>
	<span class="enscript-type">int</span>		sotype;		<span class="enscript-comment">/* Socket type */</span>
	<span class="enscript-type">int</span>		proto;		<span class="enscript-comment">/* and Protocol */</span>
	user_addr_t	fh __attribute((aligned(8)));		<span class="enscript-comment">/* File handle to be mounted */</span>
	<span class="enscript-type">int</span>		fhsize;		<span class="enscript-comment">/* Size, in bytes, of fh */</span>
	<span class="enscript-type">int</span>		flags;		<span class="enscript-comment">/* flags */</span>
	<span class="enscript-type">int</span>		wsize;		<span class="enscript-comment">/* write size in bytes */</span>
	<span class="enscript-type">int</span>		rsize;		<span class="enscript-comment">/* read size in bytes */</span>
	<span class="enscript-type">int</span>		readdirsize;	<span class="enscript-comment">/* readdir size in bytes */</span>
	<span class="enscript-type">int</span>		timeo;		<span class="enscript-comment">/* initial timeout in .1 secs */</span>
	<span class="enscript-type">int</span>		retrans;	<span class="enscript-comment">/* times to retry send */</span>
	<span class="enscript-type">int</span>		maxgrouplist;	<span class="enscript-comment">/* Max. size of group list */</span>
	<span class="enscript-type">int</span>		readahead;	<span class="enscript-comment">/* # of blocks to readahead */</span>
	<span class="enscript-type">int</span>		leaseterm;	<span class="enscript-comment">/* obsolete: Term (sec) of lease */</span>
	<span class="enscript-type">int</span>		deadthresh;	<span class="enscript-comment">/* obsolete: Retrans threshold */</span>
	user_addr_t	hostname __attribute((aligned(8)));	<span class="enscript-comment">/* server's name */</span>
	<span class="enscript-comment">/* NFS_ARGSVERSION 3 ends here */</span>
	<span class="enscript-type">int</span>		acregmin;	<span class="enscript-comment">/* reg file min attr cache timeout */</span>
	<span class="enscript-type">int</span>		acregmax;	<span class="enscript-comment">/* reg file max attr cache timeout */</span>
	<span class="enscript-type">int</span>		acdirmin;	<span class="enscript-comment">/* dir min attr cache timeout */</span>
	<span class="enscript-type">int</span>		acdirmax;	<span class="enscript-comment">/* dir max attr cache timeout */</span>
	<span class="enscript-comment">/* NFS_ARGSVERSION 4 ends here */</span>
	uint32_t	auth;		<span class="enscript-comment">/* security mechanism flavor */</span>
	<span class="enscript-comment">/* NFS_ARGSVERSION 5 ends here */</span>
	uint32_t	deadtimeout;	<span class="enscript-comment">/* secs until unresponsive mount considered dead */</span>
};
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">KERNEL</span>

<span class="enscript-comment">/*
 * Old-style NFS mount option flags
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_SOFT</span>		0x00000001  <span class="enscript-comment">/* soft mount (hard is default) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_WSIZE</span>		0x00000002  <span class="enscript-comment">/* set write size */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_RSIZE</span>		0x00000004  <span class="enscript-comment">/* set read size */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_TIMEO</span>		0x00000008  <span class="enscript-comment">/* set initial timeout */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_RETRANS</span>		0x00000010  <span class="enscript-comment">/* set number of request retries */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_MAXGRPS</span>		0x00000020  <span class="enscript-comment">/* set maximum grouplist size */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_INT</span>		0x00000040  <span class="enscript-comment">/* allow interrupts on hard mount */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_NOCONN</span>		0x00000080  <span class="enscript-comment">/* Don't Connect the socket */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_NONEGNAMECACHE</span>	0x00000100  <span class="enscript-comment">/* Don't do negative name caching */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_NFSV3</span>		0x00000200  <span class="enscript-comment">/* Use NFS Version 3 protocol */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_NFSV4</span>		0x00000400  <span class="enscript-comment">/* Use NFS Version 4 protocol */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_DUMBTIMR</span>		0x00000800  <span class="enscript-comment">/* Don't estimate rtt dynamically */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_DEADTIMEOUT</span>	0x00001000  <span class="enscript-comment">/* unmount after a period of unresponsiveness */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_READAHEAD</span>	0x00002000  <span class="enscript-comment">/* set read ahead */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_CALLUMNT</span>		0x00004000  <span class="enscript-comment">/* call MOUNTPROC_UMNT on unmount */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_RESVPORT</span>		0x00008000  <span class="enscript-comment">/* Allocate a reserved port */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_RDIRPLUS</span>		0x00010000  <span class="enscript-comment">/* Use Readdirplus for V3 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_READDIRSIZE</span>	0x00020000  <span class="enscript-comment">/* Set readdir size */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_NOLOCKS</span>		0x00040000  <span class="enscript-comment">/* don't support file locking */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_LOCALLOCKS</span>	0x00080000  <span class="enscript-comment">/* do file locking locally on client */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_ACREGMIN</span>		0x00100000  <span class="enscript-comment">/* reg min attr cache timeout */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_ACREGMAX</span>		0x00200000  <span class="enscript-comment">/* reg max attr cache timeout */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_ACDIRMIN</span>		0x00400000  <span class="enscript-comment">/* dir min attr cache timeout */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_ACDIRMAX</span>		0x00800000  <span class="enscript-comment">/* dir max attr cache timeout */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_SECFLAVOR</span>	0x01000000  <span class="enscript-comment">/* Use security flavor */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_SECSYSOK</span>		0x02000000  <span class="enscript-comment">/* Server can support auth sys */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_MUTEJUKEBOX</span>	0x04000000  <span class="enscript-comment">/* don't treat jukebox errors as unresponsive */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSMNT_NOQUOTA</span>		0x08000000  <span class="enscript-comment">/* don't support QUOTA requests */</span>


<span class="enscript-comment">/*
 * fs.nfs sysctl(3) NFS_MOUNTINFO defines
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MOUNT_INFO_VERSION</span>	0	<span class="enscript-comment">/* nfsstat mount information version */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MIATTR_BITMAP_LEN</span>	1	<span class="enscript-comment">/* length of mount info attributes bitmap */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MIFLAG_BITMAP_LEN</span>	1	<span class="enscript-comment">/* length of mount info flags bitmap */</span>

<span class="enscript-comment">/* NFS mount info attributes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MIATTR_FLAGS</span>		0	<span class="enscript-comment">/* mount info flags bitmap (MIFLAG_*) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MIATTR_ORIG_ARGS</span>		1	<span class="enscript-comment">/* original mount args passed into mount call */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MIATTR_CUR_ARGS</span> 		2	<span class="enscript-comment">/* current mount args values */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MIATTR_CUR_LOC_INDEX</span>	3	<span class="enscript-comment">/* current fs location index */</span>

<span class="enscript-comment">/* NFS mount info flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MIFLAG_DEAD</span>		0	<span class="enscript-comment">/* mount is dead */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MIFLAG_NOTRESP</span>	1	<span class="enscript-comment">/* server is unresponsive */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MIFLAG_RECOVERY</span>	2	<span class="enscript-comment">/* mount in recovery */</span>


<span class="enscript-comment">/*
 * Structures for the nfssvc(2) syscall. Not that anyone but nfsd
 * should ever try and use it.
 */</span>
<span class="enscript-type">struct</span> nfsd_args {
	<span class="enscript-type">int</span>	sock;		<span class="enscript-comment">/* Socket to serve */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
	user32_addr_t	name;		<span class="enscript-comment">/* Client addr for connection based sockets */</span>
#<span class="enscript-reference">else</span>
	caddr_t	name;		<span class="enscript-comment">/* Client addr for connection based sockets */</span>
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span>	namelen;	<span class="enscript-comment">/* Length of name */</span>
};

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
<span class="enscript-comment">/* LP64 version of nfsd_args.  all pointers and longs
 * grow when we're dealing with a 64-bit process.
 * WARNING - keep in sync with nfsd_args
 */</span>
<span class="enscript-type">struct</span> user_nfsd_args {
	<span class="enscript-type">int</span>	        sock;		<span class="enscript-comment">/* Socket to serve */</span>
	user_addr_t	name __attribute((aligned(8)));		<span class="enscript-comment">/* Client addr for connection based sockets */</span>
	<span class="enscript-type">int</span>	        namelen;	<span class="enscript-comment">/* Length of name */</span>
};

#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">KERNEL</span>

<span class="enscript-comment">/*
 * NFS Server File Handle structures
 */</span>

<span class="enscript-comment">/* NFS export handle identifies which NFS export */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_FH_VERSION</span>	0x4e580000		<span class="enscript-comment">/* 'NX00' */</span>
<span class="enscript-type">struct</span> nfs_exphandle {
	uint32_t	nxh_version;		<span class="enscript-comment">/* data structure version */</span>
	uint32_t	nxh_fsid;		<span class="enscript-comment">/* File System Export ID */</span>
	uint32_t	nxh_expid;		<span class="enscript-comment">/* Export ID */</span>
	uint16_t	nxh_flags;		<span class="enscript-comment">/* export handle flags */</span>
	uint8_t		nxh_reserved;		<span class="enscript-comment">/* future use */</span>
	uint8_t		nxh_fidlen;		<span class="enscript-comment">/* length of File ID */</span>
};

<span class="enscript-comment">/* nxh_flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NXHF_INVALIDFH</span>		0x0001		<span class="enscript-comment">/* file handle is invalid */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_MAX_FID_SIZE</span>	(NFS_MAX_FH_SIZE - sizeof(struct nfs_exphandle))
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSV4_MAX_FID_SIZE</span>	(NFSV4_MAX_FH_SIZE - sizeof(struct nfs_exphandle))
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSV3_MAX_FID_SIZE</span>	(NFSV3_MAX_FH_SIZE - sizeof(struct nfs_exphandle))
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSV2_MAX_FID_SIZE</span>	(NFSV2_MAX_FH_SIZE - sizeof(struct nfs_exphandle))

<span class="enscript-comment">/* NFS server internal view of fhandle_t */</span>
<span class="enscript-comment">/* The first sizeof(fhandle_t) bytes must match what goes into fhandle_t. */</span>
<span class="enscript-comment">/* (fhp is used to allow use of an external buffer) */</span>
<span class="enscript-type">struct</span> nfs_filehandle {
	uint32_t		nfh_len;	<span class="enscript-comment">/* total length of file handle */</span>
	<span class="enscript-type">struct</span> nfs_exphandle	nfh_xh;		<span class="enscript-comment">/* export handle */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>		nfh_fid[NFS_MAX_FID_SIZE]; <span class="enscript-comment">/* File ID */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>		*nfh_fhp;	<span class="enscript-comment">/* pointer to file handle */</span>
};

<span class="enscript-comment">/*
 * NFS export data structures
 */</span>

<span class="enscript-comment">/* Structure to hold an array of security flavors */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NX_MAX_SEC_FLAVORS</span> 5
<span class="enscript-type">struct</span> nfs_sec {
	<span class="enscript-type">int</span> count;
	uint32_t flavors[NX_MAX_SEC_FLAVORS];
}; 

<span class="enscript-type">struct</span> nfs_export_net_args {
	uint32_t		nxna_flags;	<span class="enscript-comment">/* export flags */</span>
	<span class="enscript-type">struct</span> xucred		nxna_cred;	<span class="enscript-comment">/* mapped credential for root/all user */</span>
	<span class="enscript-type">struct</span> sockaddr_storage	nxna_addr;	<span class="enscript-comment">/* net address to which exported */</span>
	<span class="enscript-type">struct</span> sockaddr_storage	nxna_mask;	<span class="enscript-comment">/* mask for net address */</span>
	<span class="enscript-type">struct</span> nfs_sec		nxna_sec;	<span class="enscript-comment">/* security mechanism flavors */</span>
};

<span class="enscript-type">struct</span> nfs_export_args {
	uint32_t		nxa_fsid;	<span class="enscript-comment">/* export FS ID */</span>
	uint32_t		nxa_expid;	<span class="enscript-comment">/* export ID */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
	user32_addr_t		nxa_fspath;	<span class="enscript-comment">/* export FS path */</span>
	user32_addr_t		nxa_exppath;	<span class="enscript-comment">/* export sub-path */</span>
#<span class="enscript-reference">else</span>
	<span class="enscript-type">char</span>			*nxa_fspath;	<span class="enscript-comment">/* export FS path */</span>
	<span class="enscript-type">char</span>			*nxa_exppath;	<span class="enscript-comment">/* export sub-path */</span>
#<span class="enscript-reference">endif</span>
	uint32_t		nxa_flags;	<span class="enscript-comment">/* export arg flags */</span>
	uint32_t		nxa_netcount;	<span class="enscript-comment">/* #entries in ex_nets array */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
	user32_addr_t		nxa_nets;	<span class="enscript-comment">/* array of net args */</span>
#<span class="enscript-reference">else</span>
	<span class="enscript-type">struct</span> nfs_export_net_args *nxa_nets;	<span class="enscript-comment">/* array of net args */</span>
#<span class="enscript-reference">endif</span>
};

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
<span class="enscript-comment">/* LP64 version of export_args */</span>

<span class="enscript-type">struct</span> user_nfs_export_args {
	uint32_t		nxa_fsid;	<span class="enscript-comment">/* export FS ID */</span>
	uint32_t		nxa_expid;	<span class="enscript-comment">/* export ID */</span>
	user_addr_t		nxa_fspath;	<span class="enscript-comment">/* export FS path */</span>
	user_addr_t		nxa_exppath;	<span class="enscript-comment">/* export sub-path */</span>
	uint32_t		nxa_flags;	<span class="enscript-comment">/* export arg flags */</span>
	uint32_t		nxa_netcount;	<span class="enscript-comment">/* #entries in ex_nets array */</span>
	user_addr_t		nxa_nets;	<span class="enscript-comment">/* array of net args */</span>
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KERNEL */</span>

<span class="enscript-comment">/* nfs export arg flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NXA_DELETE</span>		0x0001	<span class="enscript-comment">/* delete the specified export(s) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NXA_ADD</span>			0x0002	<span class="enscript-comment">/* add the specified export(s) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NXA_REPLACE</span>		0x0003	<span class="enscript-comment">/* delete and add the specified export(s) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NXA_DELETE_ALL</span>		0x0004	<span class="enscript-comment">/* delete all exports */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NXA_OFFLINE</span>		0x0008	<span class="enscript-comment">/* export is offline */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NXA_CHECK</span>		0x0010	<span class="enscript-comment">/* check if exportable */</span>

<span class="enscript-comment">/* export option flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NX_READONLY</span>		0x0001	<span class="enscript-comment">/* exported read-only */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NX_DEFAULTEXPORT</span>	0x0002	<span class="enscript-comment">/* exported to the world */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NX_MAPROOT</span>		0x0004	<span class="enscript-comment">/* map root access to anon credential */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NX_MAPALL</span>		0x0008	<span class="enscript-comment">/* map all access to anon credential */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NX_32BITCLIENTS</span>		0x0020	<span class="enscript-comment">/* restrict directory cookies to 32 bits */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NX_OFFLINE</span>		0x0040	<span class="enscript-comment">/* export is offline */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NX_MANGLEDNAMES</span>		0x0080	<span class="enscript-comment">/* export will return mangled names for names &gt; 255 bytes */</span>

<span class="enscript-comment">/*
 * fs.nfs sysctl(3) export stats record structures
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_EXPORT_STAT_REC_VERSION</span> 1	<span class="enscript-comment">/* export stat record version */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_USER_STAT_REC_VERSION</span> 1     <span class="enscript-comment">/* active user list record version */</span>

<span class="enscript-comment">/* descriptor describing following records */</span>
<span class="enscript-type">struct</span> nfs_export_stat_desc
{
	uint32_t rec_vers;		<span class="enscript-comment">/* version of export stat records */</span>
	uint32_t rec_count;		<span class="enscript-comment">/* total record count */</span>
}__attribute__((__packed__));

<span class="enscript-comment">/* export stat record containing path and stat counters */</span>
<span class="enscript-type">struct</span> nfs_export_stat_rec {
	<span class="enscript-type">char</span>     path[RPCMNT_PATHLEN + 1];
	uint64_t ops;		<span class="enscript-comment">/* Count of NFS Requests received for this export */</span>
	uint64_t bytes_read;	<span class="enscript-comment">/* Count of bytes read from this export */</span>
	uint64_t bytes_written;	<span class="enscript-comment">/* Count of bytes written to this export */</span>
}__attribute__((__packed__));

<span class="enscript-comment">/* Active user list stat buffer descriptor */</span>
<span class="enscript-type">struct</span> nfs_user_stat_desc
{
	uint32_t rec_vers;	<span class="enscript-comment">/* version of active user stat records */</span>
	uint32_t rec_count;	<span class="enscript-comment">/* total record count */</span>
}__attribute__((__packed__));

<span class="enscript-comment">/* Active user list user stat record format */</span>
<span class="enscript-type">struct</span> nfs_user_stat_user_rec {
	u_char			rec_type;
	uid_t			uid;
	<span class="enscript-type">struct</span> sockaddr_storage	sock;
	uint64_t		ops;
	uint64_t		bytes_read;
	uint64_t		bytes_written;
	uint32_t		tm_start;
	uint32_t		tm_last;
}__attribute__((__packed__));

<span class="enscript-comment">/* Active user list path record format */</span>
<span class="enscript-type">struct</span> nfs_user_stat_path_rec {
	u_char	rec_type;
	<span class="enscript-type">char</span>	path[RPCMNT_PATHLEN + 1];
}__attribute__((__packed__));

<span class="enscript-comment">/* Defines for rec_type field of
 * nfs_user_stat_rec &amp; nfs_user_stat_rec
 * data structures
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_USER_STAT_USER_REC</span>  0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_USER_STAT_PATH_REC</span>  1


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
<span class="enscript-type">struct</span> nfs_exportfs;

<span class="enscript-type">struct</span> nfs_export_options {
	uint32_t		nxo_flags;	<span class="enscript-comment">/* export options */</span>
	kauth_cred_t		nxo_cred;	<span class="enscript-comment">/* mapped credential */</span>
	<span class="enscript-type">struct</span> nfs_sec		nxo_sec;	<span class="enscript-comment">/* security mechanism flavors */</span>
};

<span class="enscript-comment">/* Network address lookup element and individual export options */</span>
<span class="enscript-type">struct</span> nfs_netopt {
	<span class="enscript-type">struct</span> radix_node		no_rnodes[2];	<span class="enscript-comment">/* radix tree glue */</span>
	<span class="enscript-type">struct</span> nfs_export_options	no_opt;		<span class="enscript-comment">/* export options */</span>
};

<span class="enscript-comment">/* statistic counters for each exported directory
 *
 * Since 64-bit atomic operations are not available on 32-bit platforms,
 * 64-bit counters are implemented using 32-bit integers and 32-bit
 * atomic operations
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> nfsstatcount64 {
	uint32_t	hi;
	uint32_t	lo;
} nfsstatcount64;

<span class="enscript-type">struct</span> nfs_export_stat_counters {
	<span class="enscript-type">struct</span> nfsstatcount64 ops;		<span class="enscript-comment">/* Count of NFS Requests received for this export  */</span>
	<span class="enscript-type">struct</span> nfsstatcount64 bytes_read;	<span class="enscript-comment">/* Count of bytes read from this export */</span>
	<span class="enscript-type">struct</span> nfsstatcount64 bytes_written;	<span class="enscript-comment">/* Count of bytes written to his export */</span>
}__attribute__((__packed__));

<span class="enscript-comment">/* Macro for updating nfs export stat counters */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFSStatAdd64</span>(PTR, VAL) \
	<span class="enscript-keyword">do</span> { \
		uint32_t NFSSA_OldValue = \
		OSAddAtomic((VAL), &amp;(PTR)-&gt;lo); \
		<span class="enscript-keyword">if</span> ((NFSSA_OldValue + (VAL)) &lt; NFSSA_OldValue) \
			OSAddAtomic(1, &amp;(PTR)-&gt;hi); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* Some defines for dealing with active user list stats */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSRV_USER_STAT_DEF_MAX_NODES</span> 1024	<span class="enscript-comment">/* default active user list size limit */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSRV_USER_STAT_DEF_IDLE_SEC</span>  7200	<span class="enscript-comment">/* default idle seconds (node no longer considered active) */</span>

<span class="enscript-comment">/* active user list globals */</span>
<span class="enscript-type">extern</span> uint32_t nfsrv_user_stat_enabled;		<span class="enscript-comment">/* enable/disable active user list */</span>
<span class="enscript-type">extern</span> uint32_t nfsrv_user_stat_node_count;		<span class="enscript-comment">/* current count of user stat nodes */</span>
<span class="enscript-type">extern</span> uint32_t nfsrv_user_stat_max_idle_sec;	<span class="enscript-comment">/* idle seconds (node no longer considered active) */</span>
<span class="enscript-type">extern</span> uint32_t nfsrv_user_stat_max_nodes;		<span class="enscript-comment">/* active user list size limit */</span>
<span class="enscript-type">extern</span> lck_grp_t *nfsrv_active_user_mutex_group;

<span class="enscript-comment">/* An active user node represented in the kernel */</span>
<span class="enscript-type">struct</span> nfs_user_stat_node {
	TAILQ_ENTRY(nfs_user_stat_node)	lru_link;
	LIST_ENTRY(nfs_user_stat_node)	hash_link;
	uid_t			uid;
	<span class="enscript-type">struct</span> sockaddr_storage	sock;
	uint64_t		ops;
	uint64_t		bytes_read;
	uint64_t		bytes_written;
	uint32_t		tm_start;
	uint32_t		tm_last;
};

<span class="enscript-comment">/* Hash table for active user nodes */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_USER_STAT_HASH_SIZE</span> 16	<span class="enscript-comment">/* MUST be a power of 2 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_USER_STAT_HASH</span>(userhashtbl, uid) \
		&amp;((userhashtbl)[(uid) &amp; (NFS_USER_STAT_HASH_SIZE - 1)])

<span class="enscript-function-name">TAILQ_HEAD</span>(nfs_user_stat_lru_head, nfs_user_stat_node);
<span class="enscript-function-name">LIST_HEAD</span>(nfs_user_stat_hashtbl_head, nfs_user_stat_node);

<span class="enscript-comment">/* Active user list data structure */</span>
<span class="enscript-comment">/* One per exported directory */</span>
<span class="enscript-type">struct</span> nfs_active_user_list {
	<span class="enscript-type">struct</span> nfs_user_stat_lru_head		user_lru;
	<span class="enscript-type">struct</span> nfs_user_stat_hashtbl_head	user_hashtbl[NFS_USER_STAT_HASH_SIZE];
	uint32_t				node_count;
	lck_mtx_t user_mutex;
};


<span class="enscript-comment">/* Network export information */</span>
<span class="enscript-comment">/* one of these for each exported directory */</span>
<span class="enscript-type">struct</span> nfs_export {
	LIST_ENTRY(nfs_export)		nx_next;	<span class="enscript-comment">/* FS export list */</span>
	LIST_ENTRY(nfs_export)		nx_hash;	<span class="enscript-comment">/* export hash chain */</span>
	<span class="enscript-type">struct</span> nfs_export		*nx_parent;	<span class="enscript-comment">/* parent export */</span>
	uint32_t			nx_id;		<span class="enscript-comment">/* export ID */</span>
	uint32_t			nx_flags;	<span class="enscript-comment">/* export flags */</span>
	<span class="enscript-type">struct</span> nfs_exportfs		*nx_fs;		<span class="enscript-comment">/* exported file system */</span>
	<span class="enscript-type">char</span>				*nx_path;	<span class="enscript-comment">/* exported file system sub-path */</span>
	<span class="enscript-type">struct</span> nfs_filehandle		nx_fh;		<span class="enscript-comment">/* export root file handle */</span>
	<span class="enscript-type">struct</span> nfs_export_options	nx_defopt;	<span class="enscript-comment">/* default options */</span>
	uint32_t			nx_expcnt;	<span class="enscript-comment">/* # exports in table */</span>
	<span class="enscript-type">struct</span> radix_node_head		*nx_rtable[AF_MAX+1]; <span class="enscript-comment">/* table of exports (netopts) */</span>
	<span class="enscript-type">struct</span> nfs_export_stat_counters	nx_stats;	<span class="enscript-comment">/* statistic counters for this exported directory */</span>
	<span class="enscript-type">struct</span> nfs_active_user_list	nx_user_list;	<span class="enscript-comment">/* Active User List for this exported directory */</span>
	<span class="enscript-type">struct</span> timeval			nx_exptime;	<span class="enscript-comment">/* time of export for write verifier */</span>
};

<span class="enscript-comment">/* NFS exported file system info */</span>
<span class="enscript-comment">/* one of these for each exported file system */</span>
<span class="enscript-type">struct</span> nfs_exportfs {
	LIST_ENTRY(nfs_exportfs)	nxfs_next;	<span class="enscript-comment">/* exported file system list */</span>
	uint32_t			nxfs_id;	<span class="enscript-comment">/* exported file system ID */</span>
	<span class="enscript-type">char</span>				*nxfs_path;	<span class="enscript-comment">/* exported file system path */</span>
	LIST_HEAD(,nfs_export)		nxfs_exports;	<span class="enscript-comment">/* list of exports for this file system */</span>
};

<span class="enscript-type">extern</span> <span class="enscript-function-name">LIST_HEAD</span>(nfsrv_expfs_list, nfs_exportfs) nfsrv_exports;
<span class="enscript-type">extern</span> lck_rw_t nfsrv_export_rwlock;  <span class="enscript-comment">// lock for export data structures
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSRVEXPHASHSZ</span>	64
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NFSRVEXPHASHVAL</span>(FSID, EXPID)	\
	(((FSID) &gt;&gt; 24) ^ ((FSID) &gt;&gt; 16) ^ ((FSID) &gt;&gt; 8) ^ (EXPID))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NFSRVEXPHASH</span>(FSID, EXPID)	\
	(&amp;nfsrv_export_hashtbl[NFSRVEXPHASHVAL((FSID),(EXPID)) &amp; nfsrv_export_hash])
<span class="enscript-type">extern</span> <span class="enscript-function-name">LIST_HEAD</span>(nfsrv_export_hashhead, nfs_export) *nfsrv_export_hashtbl;
<span class="enscript-type">extern</span> u_long nfsrv_export_hash;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
<span class="enscript-comment">/*
 * NFS server file mod fsevents
 */</span>
<span class="enscript-type">struct</span> nfsrv_fmod {
	LIST_ENTRY(nfsrv_fmod)	fm_link;
	vnode_t			fm_vp;
	<span class="enscript-type">struct</span> vfs_context	fm_context;
	uint64_t		fm_deadline;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSRVFMODHASHSZ</span>	128
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFSRVFMODHASH</span>(vp) (((uintptr_t) vp) &amp; nfsrv_fmod_hash)
<span class="enscript-type">extern</span> <span class="enscript-function-name">LIST_HEAD</span>(nfsrv_fmod_hashhead, nfsrv_fmod) *nfsrv_fmod_hashtbl;
<span class="enscript-type">extern</span> u_long nfsrv_fmod_hash;
<span class="enscript-type">extern</span> lck_mtx_t *nfsrv_fmod_mutex;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfsrv_fmod_pending, nfsrv_fsevents_enabled;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfsrv_async, nfsrv_export_hash_size, 
			nfsrv_reqcache_size, nfsrv_sock_max_rec_queue_length;
<span class="enscript-type">extern</span> uint32_t nfsrv_gss_context_ttl;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> nfsstats nfsstats;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_UC_Q_DEBUG</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFS_UC_Q_DEBUG</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfsrv_uc_use_proxy;
<span class="enscript-type">extern</span> uint32_t nfsrv_uc_queue_limit;
<span class="enscript-type">extern</span> uint32_t nfsrv_uc_queue_max_seen;
<span class="enscript-type">extern</span> <span class="enscript-type">volatile</span> uint32_t nfsrv_uc_queue_count;						      
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">KERNEL</span>

<span class="enscript-comment">/*
 * XXX to allow amd to include nfs.h without nfsproto.h
 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFS_NPROCS</span>
<span class="enscript-comment">/*
 * Stats structure
 */</span>
<span class="enscript-type">struct</span> nfsstats {
	uint64_t	attrcache_hits;
	uint64_t	attrcache_misses;
	uint64_t	lookupcache_hits;
	uint64_t	lookupcache_misses;
	uint64_t	direofcache_hits;
	uint64_t	direofcache_misses;
	uint64_t	biocache_reads;
	uint64_t	read_bios;
	uint64_t	read_physios;
	uint64_t	biocache_writes;
	uint64_t	write_bios;
	uint64_t	write_physios;
	uint64_t	biocache_readlinks;
	uint64_t	readlink_bios;
	uint64_t	biocache_readdirs;
	uint64_t	readdir_bios;
	uint64_t	rpccnt[NFS_NPROCS];
	uint64_t	rpcretries;
	uint64_t	srvrpccnt[NFS_NPROCS];
	uint64_t	srvrpc_errs;
	uint64_t	srv_errs;
	uint64_t	rpcrequests;
	uint64_t	rpctimeouts;
	uint64_t	rpcunexpected;
	uint64_t	rpcinvalid;
	uint64_t	srvcache_inproghits;
	uint64_t	srvcache_idemdonehits;
	uint64_t	srvcache_nonidemdonehits;
	uint64_t	srvcache_misses;
	uint64_t	srvvop_writes;
	uint64_t	pageins;
	uint64_t	pageouts;
};
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Flags for nfssvc() system call.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSSVC_NFSD</span>	0x004
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSSVC_ADDSOCK</span>	0x008
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSSVC_EXPORT</span>	0x200

<span class="enscript-comment">/*
 * Flags for nfsclnt() system call.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSCLNT_LOCKDANS</span>	0x200
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSCLNT_LOCKDNOTIFY</span>	0x400
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSCLNT_TESTIDMAP</span>	0x001

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/_types/_guid_t.h&gt;</span> <span class="enscript-comment">/* for guid_t below */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAXIDNAMELEN</span>		1024
<span class="enscript-type">struct</span> nfs_testmapid {
	uint32_t		ntm_name2id;	<span class="enscript-comment">/* lookup name 2 id or id 2 name */</span>
	uint32_t		ntm_grpflag;	<span class="enscript-comment">/* Is this a group or user maping */</span>
	uint32_t		ntm_id;		<span class="enscript-comment">/* id to map or return */</span>
	uint32_t		pad;	
	guid_t			ntm_guid;	<span class="enscript-comment">/* intermidiate guid used in conversion */</span>
	<span class="enscript-type">char</span>			ntm_name[MAXIDNAMELEN]; <span class="enscript-comment">/* name to map or return */</span>
};
	
<span class="enscript-comment">/*
 * fs.nfs sysctl(3) identifiers
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_NFSSTATS</span>	1	<span class="enscript-comment">/* struct: struct nfsstats */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_EXPORTSTATS</span> 3	<span class="enscript-comment">/* gets exported directory stats */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_USERSTATS</span>	4	<span class="enscript-comment">/* gets exported directory active user stats */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_USERCOUNT</span>	5	<span class="enscript-comment">/* gets current count of active nfs users */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MOUNTINFO</span>	6	<span class="enscript-comment">/* gets information about an NFS mount */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">NFS_WDELAYHASHSIZ</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_WDELAYHASHSIZ</span> 16	<span class="enscript-comment">/* and with this */</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_KERNEL_DEBUG</span> KERNEL_DEBUG

<span class="enscript-comment">/* kernel debug trace macros */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">FSDBG</span>(A, B, C, D, E) \
	NFS_KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, (A))) | DBG_FUNC_NONE, \
		(<span class="enscript-type">int</span>)(B), (<span class="enscript-type">int</span>)(C), (<span class="enscript-type">int</span>)(D), (<span class="enscript-type">int</span>)(E), 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">FSDBG_TOP</span>(A, B, C, D, E) \
	NFS_KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, (A))) | DBG_FUNC_START, \
		(<span class="enscript-type">int</span>)(B), (<span class="enscript-type">int</span>)(C), (<span class="enscript-type">int</span>)(D), (<span class="enscript-type">int</span>)(E), 0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">FSDBG_BOT</span>(A, B, C, D, E) \
	NFS_KERNEL_DEBUG((FSDBG_CODE(DBG_FSRW, (A))) | DBG_FUNC_END, \
		(<span class="enscript-type">int</span>)(B), (<span class="enscript-type">int</span>)(C), (<span class="enscript-type">int</span>)(D), (<span class="enscript-type">int</span>)(E), 0)

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MALLOC_DECLARE</span>
<span class="enscript-function-name">MALLOC_DECLARE</span>(M_NFSREQ);
<span class="enscript-function-name">MALLOC_DECLARE</span>(M_NFSMNT);
<span class="enscript-function-name">MALLOC_DECLARE</span>(M_NFSDIROFF);
<span class="enscript-function-name">MALLOC_DECLARE</span>(M_NFSRVDESC);
<span class="enscript-function-name">MALLOC_DECLARE</span>(M_NFSD);
<span class="enscript-function-name">MALLOC_DECLARE</span>(M_NFSBIGFH);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span> vnode_attr; <span class="enscript-type">struct</span> nameidata; <span class="enscript-type">struct</span> dqblk; <span class="enscript-type">struct</span> sockaddr_in; <span class="enscript-comment">/* XXX */</span>
<span class="enscript-type">struct</span> nfsbuf;
<span class="enscript-type">struct</span> nfs_vattr;
<span class="enscript-type">struct</span> nfs_fsattr;
<span class="enscript-type">struct</span> nfsnode;
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> nfsnode * nfsnode_t;
<span class="enscript-type">struct</span> nfs_open_owner;
<span class="enscript-type">struct</span> nfs_open_file;
<span class="enscript-type">struct</span> nfs_lock_owner;
<span class="enscript-type">struct</span> nfs_file_lock;
<span class="enscript-type">struct</span> nfsreq;
<span class="enscript-type">struct</span> nfs_rpc_record_state;
<span class="enscript-type">struct</span> nfs_fs_locations;
<span class="enscript-type">struct</span> nfs_location_index;
<span class="enscript-type">struct</span> nfs_socket;
<span class="enscript-type">struct</span> nfs_socket_search;
<span class="enscript-type">struct</span> nfsrv_uc_arg;

<span class="enscript-comment">/*
 * The set of signals the interrupt an I/O in progress for NFSMNT_INT mounts.
 * What should be in this set is open to debate, but I believe that since
 * I/O system calls on ufs are never interrupted by signals the set should
 * be minimal. My reasoning is that many current programs that use signals
 * such as SIGALRM will not expect file I/O system calls to be interrupted
 * by them and break.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSINT_SIGMASK</span>	(sigmask(SIGINT)|sigmask(SIGTERM)|sigmask(SIGKILL)| \
			 sigmask(SIGHUP)|sigmask(SIGQUIT))

<span class="enscript-type">extern</span> size_t nfs_mbuf_mhlen, nfs_mbuf_minclsize;

<span class="enscript-comment">/*
 * NFS mbuf chain structure used for managing the building/dissection of RPCs
 */</span>
<span class="enscript-type">struct</span> nfsm_chain {
	mbuf_t		nmc_mhead;	<span class="enscript-comment">/* mbuf chain head */</span>
	mbuf_t		nmc_mcur;	<span class="enscript-comment">/* current mbuf */</span>
	caddr_t		nmc_ptr;	<span class="enscript-comment">/* pointer into current mbuf */</span>
	uint32_t	nmc_left;	<span class="enscript-comment">/* bytes remaining in current mbuf */</span>
	uint32_t	nmc_flags;	<span class="enscript-comment">/* flags for this nfsm_chain */</span>
};
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSM_CHAIN_FLAG_ADD_CLUSTERS</span>	0x1	<span class="enscript-comment">/* always add mbuf clusters */</span>

<span class="enscript-comment">/*
 * Each retransmission of an RPCSEC_GSS request
 * has an additional sequence number.
 */</span>
<span class="enscript-type">struct</span> gss_seq {
	SLIST_ENTRY(gss_seq)	gss_seqnext;
	uint32_t		gss_seqnum;
};

<span class="enscript-comment">/*
 * async NFS request callback info
 */</span>
<span class="enscript-type">struct</span> nfsreq_cbinfo {
	<span class="enscript-type">void</span>			(*rcb_func)(<span class="enscript-type">struct</span> nfsreq *);	<span class="enscript-comment">/* async request callback function */</span>
	<span class="enscript-type">struct</span> nfsbuf		*rcb_bp;			<span class="enscript-comment">/* buffer I/O RPC is for */</span>
	uint32_t		rcb_args[3];			<span class="enscript-comment">/* additional callback args */</span>
};

<span class="enscript-comment">/*
 * Arguments to use if a request needs to call SECINFO to handle a WRONGSEC error
 *
 * If only node is set, use the parent file handle and this node's name; otherwise,
 * use any file handle and name provided.
 */</span>
<span class="enscript-type">struct</span> nfsreq_secinfo_args {
	nfsnode_t		rsia_np;		<span class="enscript-comment">/* the node */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>		*rsia_name;		<span class="enscript-comment">/* alternate name string */</span>
	u_char			*rsia_fh;		<span class="enscript-comment">/* alternate file handle */</span>
	uint32_t		rsia_namelen;		<span class="enscript-comment">/* length of string */</span>
	uint32_t		rsia_fhsize;		<span class="enscript-comment">/* length of fh */</span>
};
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFSREQ_SECINFO_SET</span>(SI, NP, FH, FHSIZE, NAME, NAMELEN) \
	<span class="enscript-keyword">do</span> { \
		(SI)-&gt;rsia_np = (NP); \
		(SI)-&gt;rsia_fh = (FH); \
		(SI)-&gt;rsia_fhsize = (FHSIZE); \
		(SI)-&gt;rsia_name = (NAME); \
		(SI)-&gt;rsia_namelen = (NAMELEN); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/*
 * NFS outstanding request list element
 */</span>
<span class="enscript-type">struct</span> nfsreq {
	lck_mtx_t		r_mtx;		<span class="enscript-comment">/* NFS request mutex */</span>
	TAILQ_ENTRY(nfsreq)	r_chain;	<span class="enscript-comment">/* request queue chain */</span>
	TAILQ_ENTRY(nfsreq)	r_achain;	<span class="enscript-comment">/* mount's async I/O request queue chain */</span>
	TAILQ_ENTRY(nfsreq)	r_rchain;	<span class="enscript-comment">/* mount's async I/O resend queue chain */</span>
	TAILQ_ENTRY(nfsreq)	r_cchain;	<span class="enscript-comment">/* mount's cwnd queue chain */</span>
	mbuf_t			r_mrest;	<span class="enscript-comment">/* request body mbufs */</span>
	mbuf_t			r_mhead;	<span class="enscript-comment">/* request header mbufs */</span>
	<span class="enscript-type">struct</span> nfsm_chain	r_nmrep;	<span class="enscript-comment">/* reply mbufs */</span>
	nfsnode_t		r_np;		<span class="enscript-comment">/* NFS node */</span>
	<span class="enscript-type">struct</span> nfsmount		*r_nmp;		<span class="enscript-comment">/* NFS mount point */</span>
	uint64_t		r_xid;		<span class="enscript-comment">/* RPC transaction ID */</span>
	uint32_t		r_procnum;	<span class="enscript-comment">/* NFS procedure number */</span>
	uint32_t		r_mreqlen;	<span class="enscript-comment">/* request length */</span>
	<span class="enscript-type">int</span>			r_flags;	<span class="enscript-comment">/* flags on request, see below */</span>
	<span class="enscript-type">int</span>			r_lflags;	<span class="enscript-comment">/* flags protected by list mutex, see below */</span>
	<span class="enscript-type">int</span>			r_refs;		<span class="enscript-comment">/* # outstanding references */</span>
	uint8_t			r_delay;	<span class="enscript-comment">/* delay to use for jukebox error */</span>
	uint8_t			r_retry;	<span class="enscript-comment">/* max retransmission count */</span>
	uint8_t			r_rexmit;	<span class="enscript-comment">/* current retrans count */</span>
	<span class="enscript-type">int</span>			r_rtt;		<span class="enscript-comment">/* RTT for rpc */</span>
	thread_t		r_thread;	<span class="enscript-comment">/* thread that did I/O system call */</span>
	kauth_cred_t		r_cred;		<span class="enscript-comment">/* credential used for request */</span>
	time_t			r_start;	<span class="enscript-comment">/* request start time */</span>
	time_t			r_lastmsg;	<span class="enscript-comment">/* time of last tprintf */</span>
	time_t			r_resendtime;	<span class="enscript-comment">/* time of next jukebox error resend */</span>
	<span class="enscript-type">struct</span> nfs_gss_clnt_ctx	*r_gss_ctx;	<span class="enscript-comment">/* RPCSEC_GSS context */</span>
	SLIST_HEAD(, gss_seq)	r_gss_seqlist;	<span class="enscript-comment">/* RPCSEC_GSS sequence numbers */</span>
	uint32_t		r_gss_argoff;	<span class="enscript-comment">/* RPCSEC_GSS offset to args */</span>
	uint32_t		r_gss_arglen;	<span class="enscript-comment">/* RPCSEC_GSS arg length */</span>
	uint32_t		r_auth;		<span class="enscript-comment">/* security flavor request sent with */</span>
	uint32_t		*r_wrongsec;	<span class="enscript-comment">/* wrongsec: other flavors to try */</span>
	<span class="enscript-type">int</span>			r_error;	<span class="enscript-comment">/* request error */</span>
	<span class="enscript-type">struct</span> nfsreq_cbinfo	r_callback;	<span class="enscript-comment">/* callback info */</span>
	<span class="enscript-type">struct</span> nfsreq_secinfo_args r_secinfo;	<span class="enscript-comment">/* secinfo args */</span>
};

<span class="enscript-comment">/*
 * Queue head for nfsreq's
 */</span>
<span class="enscript-function-name">TAILQ_HEAD</span>(nfs_reqqhead, nfsreq);
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> nfs_reqqhead nfs_reqq;
<span class="enscript-type">extern</span> lck_grp_t *nfs_request_grp;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">R_XID32</span>(x)	((x) &amp; 0xffffffff)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSNOLIST</span>	((void *)0x0badcafe)	<span class="enscript-comment">/* sentinel value for nfs lists */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSREQNOLIST</span>	NFSNOLIST		<span class="enscript-comment">/* sentinel value for nfsreq lists */</span>

<span class="enscript-comment">/* Flag values for r_flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_TIMING</span>	0x00000001	<span class="enscript-comment">/* timing request (in mntp) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_CWND</span>		0x00000002	<span class="enscript-comment">/* request accounted for in congestion window */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_SOFTTERM</span>	0x00000004	<span class="enscript-comment">/* request terminated (e.g. soft mnt) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_RESTART</span>	0x00000008	<span class="enscript-comment">/* RPC should be restarted. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_INITTED</span>	0x00000010	<span class="enscript-comment">/* request has been initialized */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_TPRINTFMSG</span>	0x00000020	<span class="enscript-comment">/* Did a tprintf msg. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_MUSTRESEND</span>	0x00000040	<span class="enscript-comment">/* Must resend request */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_ALLOCATED</span>	0x00000080	<span class="enscript-comment">/* request was allocated */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_SENT</span>		0x00000100	<span class="enscript-comment">/* request has been sent */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_WAITSENT</span>	0x00000200	<span class="enscript-comment">/* someone is waiting for request to be sent */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_RESENDERR</span>	0x00000400	<span class="enscript-comment">/* resend failed */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_JBTPRINTFMSG</span>	0x00000800	<span class="enscript-comment">/* Did a tprintf msg for jukebox error */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_ASYNC</span>		0x00001000	<span class="enscript-comment">/* async request */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_ASYNCWAIT</span>	0x00002000	<span class="enscript-comment">/* async request now being waited on */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_RESENDQ</span>	0x00004000	<span class="enscript-comment">/* async request currently on resendq */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_SENDING</span>	0x00008000	<span class="enscript-comment">/* request currently being sent */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_SOFT</span>		0x00010000	<span class="enscript-comment">/* request is soft - don't retry or reconnect */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_IOD</span>		0x00020000	<span class="enscript-comment">/* request is being managed by an IOD */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_NOINTR</span>	0x20000000	<span class="enscript-comment">/* request should not be interupted by a signal */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_RECOVER</span>	0x40000000	<span class="enscript-comment">/* a state recovery RPC - during NFSSTA_RECOVER */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_SETUP</span>		0x80000000	<span class="enscript-comment">/* a setup RPC - during (re)connection */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">R_OPTMASK</span>	0xe0000000	<span class="enscript-comment">/* mask of all RPC option flags */</span>

<span class="enscript-comment">/* Flag values for r_lflags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RL_BUSY</span>		0x0001		<span class="enscript-comment">/* Locked. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RL_WAITING</span>	0x0002		<span class="enscript-comment">/* Someone waiting for lock. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">RL_QUEUED</span>	0x0004		<span class="enscript-comment">/* request is on the queue */</span>

<span class="enscript-type">extern</span> u_int32_t nfs_xid, nfs_xidwrap;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfs_iosize, nfs_allow_async, nfs_statfs_rate_limit;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfs_access_cache_timeout, nfs_access_delete, nfs_access_dotzfs, nfs_access_for_getattr;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfs_lockd_mounts, nfs_lockd_request_sent, nfs_single_des;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfs_tprintf_initial_delay, nfs_tprintf_delay;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfsiod_thread_count, nfsiod_thread_max, nfs_max_async_writes;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfs_idmap_ctrl, nfs_callback_port;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfs_is_mobile, nfs_readlink_nocache, nfs_root_steals_ctx;
<span class="enscript-type">extern</span> uint32_t nfs_squishy_flags;
<span class="enscript-type">extern</span> uint32_t nfs_debug_ctl;

<span class="enscript-comment">/* bits for nfs_idmap_ctrl: */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_IDMAP_CTRL_USE_IDMAP_SERVICE</span>		0x00000001 <span class="enscript-comment">/* use the ID mapping service */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_IDMAP_CTRL_FALLBACK_NO_COMMON_IDS</span>		0x00000002 <span class="enscript-comment">/* fallback should NOT handle common IDs like &quot;root&quot; and &quot;nobody&quot; */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_IDMAP_CTRL_FALLBACK_NO_WELLKNOWN_IDS</span>	0x00000004 <span class="enscript-comment">/* fallback should NOT handle the well known &quot;XXX@&quot; IDs */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_IDMAP_CTRL_UNKNOWN_IS_99</span>			0x00000008 <span class="enscript-comment">/* for unknown IDs use uid/gid 99 instead of -2/nobody */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_IDMAP_CTRL_COMPARE_RESULTS</span>			0x00000010 <span class="enscript-comment">/* compare results of ID mapping service and fallback */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_IDMAP_CTRL_LOG_FAILED_MAPPINGS</span>		0x00000020 <span class="enscript-comment">/* log failed ID mapping attempts */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_IDMAP_CTRL_LOG_SUCCESSFUL_MAPPINGS</span>		0x00000040 <span class="enscript-comment">/* log successful ID mapping attempts */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSIOD_MAX</span>	(MIN(nfsiod_thread_max, NFS_MAXASYNCTHREAD))

<span class="enscript-type">struct</span> nfs_dulookup {
	<span class="enscript-type">int</span> du_flags;			<span class="enscript-comment">/* state of ._ lookup */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_DULOOKUP_DOIT</span>	0x1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_DULOOKUP_INPROG</span>	0x2
	<span class="enscript-type">struct</span> componentname du_cn;	<span class="enscript-comment">/* ._ name being looked up */</span>
	<span class="enscript-type">struct</span> nfsreq du_req;		<span class="enscript-comment">/* NFS request for lookup */</span>
	<span class="enscript-type">char</span> du_smallname[48];		<span class="enscript-comment">/* buffer for small names */</span>
};

<span class="enscript-comment">/*
 * One nfsrv_sock structure is maintained for each socket the
 * server is servicing requests on.
 */</span>
<span class="enscript-type">struct</span> nfsrv_sock {
	TAILQ_ENTRY(nfsrv_sock) ns_chain;	<span class="enscript-comment">/* List of all nfsrv_sock's */</span>
	TAILQ_ENTRY(nfsrv_sock) ns_svcq;	<span class="enscript-comment">/* List of sockets needing servicing */</span>
	TAILQ_ENTRY(nfsrv_sock) ns_wgq;		<span class="enscript-comment">/* List of sockets with a pending write gather */</span>
	<span class="enscript-type">struct</span> nfsrv_uc_arg *ns_ua;		<span class="enscript-comment">/* Opaque pointer to upcall */</span>
	lck_rw_t	ns_rwlock;		<span class="enscript-comment">/* lock for most fields */</span>
	socket_t	ns_so;
	mbuf_t		ns_nam;
	mbuf_t		ns_raw;
	mbuf_t		ns_rawend;
	mbuf_t		ns_rec;
	mbuf_t		ns_recend;
	mbuf_t		ns_frag;
	<span class="enscript-type">int</span>		ns_flag;
	<span class="enscript-type">int</span>		ns_sotype;
	<span class="enscript-type">int</span>		ns_cc;
	<span class="enscript-type">int</span>		ns_reclen;
	<span class="enscript-type">int</span>		ns_reccnt;
	u_int32_t		ns_sref;
	time_t		ns_timestamp;		<span class="enscript-comment">/* socket timestamp */</span>
	lck_mtx_t	ns_wgmutex;		<span class="enscript-comment">/* mutex for write gather fields */</span>
	u_quad_t	ns_wgtime;		<span class="enscript-comment">/* next Write deadline (usec) */</span>
	LIST_HEAD(, nfsrv_descript) ns_tq;	<span class="enscript-comment">/* Write gather lists */</span>
	LIST_HEAD(nfsrv_wg_delayhash, nfsrv_descript) ns_wdelayhashtbl[NFS_WDELAYHASHSIZ];
};

<span class="enscript-comment">/* Bits for &quot;ns_flag&quot; */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SLP_VALID</span>	0x0001 <span class="enscript-comment">/* nfs sock valid */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SLP_DOREC</span>	0x0002 <span class="enscript-comment">/* nfs sock has received data to process */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SLP_NEEDQ</span>	0x0004 <span class="enscript-comment">/* network socket has data to receive */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SLP_DISCONN</span>	0x0008 <span class="enscript-comment">/* socket needs to be zapped */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SLP_GETSTREAM</span>	0x0010 <span class="enscript-comment">/* currently in nfsrv_getstream() */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SLP_LASTFRAG</span>	0x0020 <span class="enscript-comment">/* on last fragment of RPC record */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SLP_DOWRITES</span>	0x0040 <span class="enscript-comment">/* nfs sock has gathered writes to service */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SLP_WORKTODO</span>	0x004e <span class="enscript-comment">/* mask of all &quot;work to do&quot; flags */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SLP_ALLFLAGS</span>	0x007f
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SLP_WAITQ</span>	0x4000 <span class="enscript-comment">/* nfs sock is on the wait queue */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SLP_WORKQ</span>	0x8000 <span class="enscript-comment">/* nfs sock is on the work queue */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SLP_QUEUED</span>	0xc000 <span class="enscript-comment">/* nfs sock is on a queue */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SLPNOLIST</span> ((struct nfsrv_sock *)0xdeadbeef)	<span class="enscript-comment">/* sentinel value for sockets not in the nfsrv_sockwg list */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> nfsrv_sock *nfsrv_udpsock, *nfsrv_udp6sock;

<span class="enscript-comment">/*
 * global NFS server socket lists:
 *
 * nfsrv_socklist - list of all sockets (ns_chain)
 * nfsrv_sockwait - sockets w/new data waiting to be worked on (ns_svcq)
 * nfsrv_sockwork - sockets being worked on which may have more work to do (ns_svcq)
 * nfsrv_sockwg - sockets with pending write gather input (ns_wgq)
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-function-name">TAILQ_HEAD</span>(nfsrv_sockhead, nfsrv_sock) nfsrv_socklist, nfsrv_sockwg,
						nfsrv_sockwait, nfsrv_sockwork;

<span class="enscript-comment">/* lock groups for nfsrv_sock's */</span>
<span class="enscript-type">extern</span> lck_grp_t *nfsrv_slp_rwlock_group;
<span class="enscript-type">extern</span> lck_grp_t *nfsrv_slp_mutex_group;

<span class="enscript-comment">/*
 * One of these structures is allocated for each nfsd.
 */</span>
<span class="enscript-type">struct</span> nfsd {
	TAILQ_ENTRY(nfsd)	nfsd_chain;	<span class="enscript-comment">/* List of all nfsd's */</span>
	TAILQ_ENTRY(nfsd)	nfsd_queue;	<span class="enscript-comment">/* List of waiting nfsd's */</span>
	<span class="enscript-type">int</span>			nfsd_flag;	<span class="enscript-comment">/* NFSD_ flags */</span>
	<span class="enscript-type">struct</span> nfsrv_sock	*nfsd_slp;	<span class="enscript-comment">/* Current socket */</span>
	<span class="enscript-type">struct</span> nfsrv_descript	*nfsd_nd;	<span class="enscript-comment">/* Associated nfsrv_descript */</span>
};

<span class="enscript-comment">/* Bits for &quot;nfsd_flag&quot; */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSD_WAITING</span>	0x01
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFSD_REQINPROG</span>	0x02

<span class="enscript-comment">/*
 * This structure is used by the server for describing each request.
 * Some fields are used only when write request gathering is performed.
 */</span>
<span class="enscript-type">struct</span> nfsrv_descript {
	u_quad_t		nd_time;	<span class="enscript-comment">/* Write deadline (usec) */</span>
	off_t			nd_off;		<span class="enscript-comment">/* Start byte offset */</span>
	off_t			nd_eoff;	<span class="enscript-comment">/* and end byte offset */</span>
	LIST_ENTRY(nfsrv_descript) nd_hash;	<span class="enscript-comment">/* Hash list */</span>
	LIST_ENTRY(nfsrv_descript) nd_tq;	<span class="enscript-comment">/* and timer list */</span>
	LIST_HEAD(,nfsrv_descript) nd_coalesce;	<span class="enscript-comment">/* coalesced writes */</span>
	<span class="enscript-type">struct</span> nfsm_chain	nd_nmreq;	<span class="enscript-comment">/* Request mbuf chain */</span>
	mbuf_t			nd_mrep;	<span class="enscript-comment">/* Reply mbuf list (WG) */</span>
	mbuf_t			nd_nam;		<span class="enscript-comment">/* and socket addr */</span>
	mbuf_t			nd_nam2;	<span class="enscript-comment">/* return socket addr */</span>
	u_int32_t		nd_procnum;	<span class="enscript-comment">/* RPC # */</span>
	<span class="enscript-type">int</span>			nd_stable;	<span class="enscript-comment">/* storage type */</span>
	<span class="enscript-type">int</span>			nd_vers;	<span class="enscript-comment">/* NFS version */</span>
	<span class="enscript-type">int</span>			nd_len;		<span class="enscript-comment">/* Length of this write */</span>
	<span class="enscript-type">int</span>			nd_repstat;	<span class="enscript-comment">/* Reply status */</span>
	u_int32_t			nd_retxid;	<span class="enscript-comment">/* Reply xid */</span>
	<span class="enscript-type">struct</span> timeval		nd_starttime;	<span class="enscript-comment">/* Time RPC initiated */</span>
	<span class="enscript-type">struct</span> nfs_filehandle	nd_fh;		<span class="enscript-comment">/* File handle */</span>
	uint32_t		nd_sec;		<span class="enscript-comment">/* Security flavor */</span>
	<span class="enscript-type">struct</span> nfs_gss_svc_ctx	*nd_gss_context;<span class="enscript-comment">/* RPCSEC_GSS context */</span>
	uint32_t		nd_gss_seqnum;	<span class="enscript-comment">/* RPCSEC_GSS seq num */</span>
	mbuf_t			nd_gss_mb;	<span class="enscript-comment">/* RPCSEC_GSS results mbuf */</span>
	kauth_cred_t		nd_cr;		<span class="enscript-comment">/* Credentials */</span>
};

<span class="enscript-type">extern</span> <span class="enscript-function-name">TAILQ_HEAD</span>(nfsd_head, nfsd) nfsd_head, nfsd_queue;

<span class="enscript-comment">/* mutex for nfs server */</span>
<span class="enscript-type">extern</span> lck_mtx_t *nfsd_mutex;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfsd_thread_count, nfsd_thread_max;

<span class="enscript-comment">/* request list mutex */</span>
<span class="enscript-type">extern</span> lck_mtx_t *nfs_request_mutex;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfs_request_timer_on;

<span class="enscript-comment">/* mutex for nfs client globals */</span>
<span class="enscript-type">extern</span> lck_mtx_t *nfs_global_mutex;

<span class="enscript-comment">/* NFSv4 callback globals */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfs4_callback_timer_on;
<span class="enscript-type">extern</span> in_port_t nfs4_cb_port, nfs4_cb_port6;

<span class="enscript-comment">/* nfs timer call structures */</span>
<span class="enscript-type">extern</span> thread_call_t	nfs_request_timer_call;
<span class="enscript-type">extern</span> thread_call_t	nfs_buf_timer_call;
<span class="enscript-type">extern</span> thread_call_t	nfs4_callback_timer_call;
<span class="enscript-type">extern</span> thread_call_t	nfsrv_idlesock_timer_call;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
<span class="enscript-type">extern</span> thread_call_t	nfsrv_fmod_timer_call;
#<span class="enscript-reference">endif</span>

__BEGIN_DECLS

nfstype	vtonfs_type(<span class="enscript-type">enum</span> vtype, <span class="enscript-type">int</span>);
<span class="enscript-type">enum</span> vtype <span class="enscript-function-name">nfstov_type</span>(nfstype, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	vtonfsv2_mode(<span class="enscript-type">enum</span> vtype, mode_t);

<span class="enscript-type">void</span>	nfs_mbuf_init(<span class="enscript-type">void</span>);

<span class="enscript-type">void</span>	nfs_nhinit(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	nfs_nhinit_finish(<span class="enscript-type">void</span>);
u_long	nfs_hash(u_char *, <span class="enscript-type">int</span>);

<span class="enscript-type">int</span>	nfs4_init_clientid(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">int</span>	nfs4_setclientid(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">int</span>	nfs4_renew(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs4_renew_timer(<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
<span class="enscript-type">void</span>	nfs4_mount_callback_setup(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">void</span>	nfs4_mount_callback_shutdown(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">void</span>	nfs4_cb_accept(socket_t, <span class="enscript-type">void</span> *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs4_cb_rcv(socket_t, <span class="enscript-type">void</span> *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs4_callback_timer(<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
<span class="enscript-type">int</span>	nfs4_secinfo_rpc(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">struct</span> nfsreq_secinfo_args *, kauth_cred_t, uint32_t *, <span class="enscript-type">int</span> *);
<span class="enscript-type">int</span>	nfs4_get_fs_locations(<span class="enscript-type">struct</span> nfsmount *, nfsnode_t, u_char *, <span class="enscript-type">int</span>, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, vfs_context_t, <span class="enscript-type">struct</span> nfs_fs_locations *);
<span class="enscript-type">void</span>	nfs_fs_locations_cleanup(<span class="enscript-type">struct</span> nfs_fs_locations *);
<span class="enscript-type">void</span>	nfs4_default_attrs_for_referral_trigger(nfsnode_t, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> nfs_vattr *, fhandle_t *);

<span class="enscript-type">int</span>	nfs_sockaddr_cmp(<span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> sockaddr *);
<span class="enscript-type">int</span>	nfs_connect(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs_disconnect(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">void</span>	nfs_need_reconnect(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">void</span>	nfs_mount_sock_thread_wake(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">int</span>	nfs_mount_check_dead_timeout(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">int</span>	nfs_mount_gone(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">void</span>	nfs_mount_rele(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">void</span>	nfs_mount_zombie(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs_mount_make_zombie(<span class="enscript-type">struct</span> nfsmount *);

<span class="enscript-type">void</span>	nfs_rpc_record_state_init(<span class="enscript-type">struct</span> nfs_rpc_record_state *);
<span class="enscript-type">void</span>	nfs_rpc_record_state_cleanup(<span class="enscript-type">struct</span> nfs_rpc_record_state *);
<span class="enscript-type">int</span>	nfs_rpc_record_read(socket_t, <span class="enscript-type">struct</span> nfs_rpc_record_state *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span> *, mbuf_t *);

<span class="enscript-type">int</span>	nfs_getattr(nfsnode_t, <span class="enscript-type">struct</span> nfs_vattr *, vfs_context_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_getattrcache(nfsnode_t, <span class="enscript-type">struct</span> nfs_vattr *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_loadattrcache(nfsnode_t, <span class="enscript-type">struct</span> nfs_vattr *, u_int64_t *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_attrcachetimeout(nfsnode_t);

<span class="enscript-type">int</span>	nfs_buf_page_inval(vnode_t vp, off_t offset);
<span class="enscript-type">int</span>	nfs_vinvalbuf(vnode_t, <span class="enscript-type">int</span>, vfs_context_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_vinvalbuf2(vnode_t, <span class="enscript-type">int</span>, thread_t, kauth_cred_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_vinvalbuf_internal(nfsnode_t, <span class="enscript-type">int</span>, thread_t, kauth_cred_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs_wait_bufs(nfsnode_t);

<span class="enscript-type">int</span>	nfs_request_create(nfsnode_t, mount_t, <span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">int</span>, thread_t, kauth_cred_t, <span class="enscript-type">struct</span> nfsreq **);
<span class="enscript-type">void</span>	nfs_request_destroy(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">void</span>	nfs_request_ref(<span class="enscript-type">struct</span> nfsreq *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs_request_rele(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">int</span>	nfs_request_add_header(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">int</span>	nfs_request_send(<span class="enscript-type">struct</span> nfsreq *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs_request_wait(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">int</span>	nfs_request_finish(<span class="enscript-type">struct</span> nfsreq *, <span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">int</span> *);
<span class="enscript-type">int</span>	nfs_request(nfsnode_t, mount_t, <span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">int</span>, vfs_context_t, <span class="enscript-type">struct</span> nfsreq_secinfo_args *, <span class="enscript-type">struct</span> nfsm_chain *, u_int64_t *, <span class="enscript-type">int</span> *);
<span class="enscript-type">int</span>	nfs_request2(nfsnode_t, mount_t, <span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">int</span>, thread_t, kauth_cred_t, <span class="enscript-type">struct</span> nfsreq_secinfo_args *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> nfsm_chain *, u_int64_t *, <span class="enscript-type">int</span> *);
<span class="enscript-type">int</span>	nfs_request_gss(mount_t, <span class="enscript-type">struct</span> nfsm_chain *, thread_t,	kauth_cred_t, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx *, <span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">int</span> *);
<span class="enscript-type">int</span>	nfs_request_async(nfsnode_t, mount_t, <span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">int</span>, thread_t, kauth_cred_t, <span class="enscript-type">struct</span> nfsreq_secinfo_args *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> nfsreq_cbinfo *, <span class="enscript-type">struct</span> nfsreq **);
<span class="enscript-type">int</span>	nfs_request_async_finish(<span class="enscript-type">struct</span> nfsreq *, <span class="enscript-type">struct</span> nfsm_chain *, u_int64_t *, <span class="enscript-type">int</span> *);
<span class="enscript-type">void</span>	nfs_request_async_cancel(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">void</span>	nfs_request_timer(<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
<span class="enscript-type">int</span>	nfs_request_using_gss(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">void</span>	nfs_get_xid(uint64_t *);
<span class="enscript-type">int</span>	nfs_sigintr(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">struct</span> nfsreq *, thread_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_noremotehang(thread_t);

<span class="enscript-type">int</span>	nfs_send(<span class="enscript-type">struct</span> nfsreq *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_sndlock(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">void</span>	nfs_sndunlock(<span class="enscript-type">struct</span> nfsreq *);

<span class="enscript-type">int</span>	nfs_uaddr2sockaddr(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">struct</span> sockaddr *);

<span class="enscript-type">int</span>	nfs_aux_request(<span class="enscript-type">struct</span> nfsmount *, thread_t, <span class="enscript-type">struct</span> sockaddr *, socket_t, <span class="enscript-type">int</span>, mbuf_t, uint32_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> nfsm_chain *);
<span class="enscript-type">int</span>	nfs_portmap_lookup(<span class="enscript-type">struct</span> nfsmount *, vfs_context_t, <span class="enscript-type">struct</span> sockaddr *, socket_t, uint32_t, uint32_t, uint32_t, <span class="enscript-type">int</span>);

<span class="enscript-type">void</span>	nfs_location_next(<span class="enscript-type">struct</span> nfs_fs_locations *, <span class="enscript-type">struct</span> nfs_location_index *);
<span class="enscript-type">int</span>	nfs_location_index_cmp(<span class="enscript-type">struct</span> nfs_location_index *, <span class="enscript-type">struct</span> nfs_location_index *);
<span class="enscript-type">void</span>	nfs_location_mntfromname(<span class="enscript-type">struct</span> nfs_fs_locations *, <span class="enscript-type">struct</span> nfs_location_index, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_socket_create(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">int</span>, in_port_t, uint32_t, uint32_t, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> nfs_socket **);
<span class="enscript-type">void</span>	nfs_socket_destroy(<span class="enscript-type">struct</span> nfs_socket *);
<span class="enscript-type">void</span>	nfs_socket_options(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">struct</span> nfs_socket *);
<span class="enscript-type">void</span>	nfs_connect_upcall(socket_t, <span class="enscript-type">void</span> *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_connect_error_class(<span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_connect_search_loop(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">struct</span> nfs_socket_search *);
<span class="enscript-type">void</span>	nfs_socket_search_update_error(<span class="enscript-type">struct</span> nfs_socket_search *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs_socket_search_cleanup(<span class="enscript-type">struct</span> nfs_socket_search *);
<span class="enscript-type">void</span>	nfs_mount_connect_thread(<span class="enscript-type">void</span> *, __unused wait_result_t);

<span class="enscript-type">int</span>	nfs_lookitup(nfsnode_t, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, vfs_context_t, nfsnode_t *);
<span class="enscript-type">void</span>	nfs_dulookup_init(<span class="enscript-type">struct</span> nfs_dulookup *, nfsnode_t, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">void</span>	nfs_dulookup_start(<span class="enscript-type">struct</span> nfs_dulookup *, nfsnode_t, vfs_context_t);
<span class="enscript-type">void</span>	nfs_dulookup_finish(<span class="enscript-type">struct</span> nfs_dulookup *, nfsnode_t, vfs_context_t);
<span class="enscript-type">int</span>	nfs_dir_buf_cache_lookup(nfsnode_t, nfsnode_t *, <span class="enscript-type">struct</span> componentname *, vfs_context_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_dir_buf_search(<span class="enscript-type">struct</span> nfsbuf *, <span class="enscript-type">struct</span> componentname *, fhandle_t *, <span class="enscript-type">struct</span> nfs_vattr *, uint64_t *, time_t *, daddr64_t *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs_name_cache_purge(nfsnode_t, nfsnode_t, <span class="enscript-type">struct</span> componentname *, vfs_context_t);

uint32_t <span class="enscript-function-name">nfs4_ace_nfstype_to_vfstype</span>(uint32_t, <span class="enscript-type">int</span> *);
uint32_t <span class="enscript-function-name">nfs4_ace_vfstype_to_nfstype</span>(uint32_t, <span class="enscript-type">int</span> *);
uint32_t <span class="enscript-function-name">nfs4_ace_nfsflags_to_vfsflags</span>(uint32_t);
uint32_t <span class="enscript-function-name">nfs4_ace_vfsflags_to_nfsflags</span>(uint32_t);
uint32_t <span class="enscript-function-name">nfs4_ace_nfsmask_to_vfsrights</span>(uint32_t);
uint32_t <span class="enscript-function-name">nfs4_ace_vfsrights_to_nfsmask</span>(uint32_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs4_id2guid</span>(<span class="enscript-type">char</span> *, guid_t *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs4_guid2id</span>(guid_t *, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span> *, <span class="enscript-type">int</span>);

<span class="enscript-type">int</span>	nfs_parsefattr(<span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> nfs_vattr *);
<span class="enscript-type">int</span>	nfs4_parsefattr(<span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">struct</span> nfs_fsattr *, <span class="enscript-type">struct</span> nfs_vattr *, fhandle_t *, <span class="enscript-type">struct</span> dqblk *, <span class="enscript-type">struct</span> nfs_fs_locations *);
<span class="enscript-type">void</span>	nfs_vattr_set_supported(uint32_t *, <span class="enscript-type">struct</span> vnode_attr *);
<span class="enscript-type">void</span>	nfs_vattr_set_bitmap(<span class="enscript-type">struct</span> nfsmount *, uint32_t *, <span class="enscript-type">struct</span> vnode_attr *);
<span class="enscript-type">void</span>	nfs3_pathconf_cache(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">struct</span> nfs_fsattr *);
<span class="enscript-type">int</span>	nfs3_mount_rpc(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">char</span> *, vfs_context_t, <span class="enscript-type">int</span>, fhandle_t *, <span class="enscript-type">struct</span> nfs_sec *);
<span class="enscript-type">void</span>	nfs3_umount_rpc(<span class="enscript-type">struct</span> nfsmount *, vfs_context_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_node_access_slot(nfsnode_t, uid_t, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs_vnode_notify(nfsnode_t, uint32_t);

<span class="enscript-type">void</span>	nfs_avoid_needless_id_setting_on_create(nfsnode_t, <span class="enscript-type">struct</span> vnode_attr *, vfs_context_t);
<span class="enscript-type">int</span>	nfs4_create_rpc(vfs_context_t, nfsnode_t, <span class="enscript-type">struct</span> componentname *, <span class="enscript-type">struct</span> vnode_attr *, <span class="enscript-type">int</span>, <span class="enscript-type">char</span> *, nfsnode_t *);
<span class="enscript-type">int</span>	nfs_open_state_set_busy(nfsnode_t, thread_t);
<span class="enscript-type">void</span>	nfs_open_state_clear_busy(nfsnode_t);
<span class="enscript-type">struct</span> nfs_open_owner *<span class="enscript-function-name">nfs_open_owner_find</span>(<span class="enscript-type">struct</span> nfsmount *, kauth_cred_t, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs_open_owner_destroy(<span class="enscript-type">struct</span> nfs_open_owner *);
<span class="enscript-type">void</span>	nfs_open_owner_ref(<span class="enscript-type">struct</span> nfs_open_owner *);
<span class="enscript-type">void</span>	nfs_open_owner_rele(<span class="enscript-type">struct</span> nfs_open_owner *);
<span class="enscript-type">int</span>	nfs_open_owner_set_busy(<span class="enscript-type">struct</span> nfs_open_owner *, thread_t);
<span class="enscript-type">void</span>	nfs_open_owner_clear_busy(<span class="enscript-type">struct</span> nfs_open_owner *);
<span class="enscript-type">void</span>	nfs_owner_seqid_increment(<span class="enscript-type">struct</span> nfs_open_owner *, <span class="enscript-type">struct</span> nfs_lock_owner *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_open_file_find(nfsnode_t, <span class="enscript-type">struct</span> nfs_open_owner *, <span class="enscript-type">struct</span> nfs_open_file **, uint32_t, uint32_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_open_file_find_internal(nfsnode_t, <span class="enscript-type">struct</span> nfs_open_owner *, <span class="enscript-type">struct</span> nfs_open_file **, uint32_t, uint32_t, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs_open_file_destroy(<span class="enscript-type">struct</span> nfs_open_file *);
<span class="enscript-type">int</span>	nfs_open_file_set_busy(<span class="enscript-type">struct</span> nfs_open_file *, thread_t);
<span class="enscript-type">void</span>	nfs_open_file_clear_busy(<span class="enscript-type">struct</span> nfs_open_file *);
<span class="enscript-type">void</span>	nfs_open_file_add_open(<span class="enscript-type">struct</span> nfs_open_file *, uint32_t, uint32_t, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs_open_file_remove_open_find(<span class="enscript-type">struct</span> nfs_open_file *, uint32_t, uint32_t, uint32_t *, uint32_t *, <span class="enscript-type">int</span>*);
<span class="enscript-type">void</span>	nfs_open_file_remove_open(<span class="enscript-type">struct</span> nfs_open_file *, uint32_t, uint32_t);
<span class="enscript-type">void</span>	nfs_get_stateid(nfsnode_t, thread_t, kauth_cred_t, nfs_stateid *);
<span class="enscript-type">int</span>	nfs4_open(nfsnode_t, <span class="enscript-type">struct</span> nfs_open_file *, uint32_t, uint32_t, vfs_context_t);
<span class="enscript-type">int</span>	nfs4_open_delegated(nfsnode_t, <span class="enscript-type">struct</span> nfs_open_file *, uint32_t, uint32_t, vfs_context_t);
<span class="enscript-type">int</span>	nfs_close(nfsnode_t, <span class="enscript-type">struct</span> nfs_open_file *, uint32_t, uint32_t, vfs_context_t);
<span class="enscript-type">int</span>	nfs_check_for_locks(<span class="enscript-type">struct</span> nfs_open_owner *, <span class="enscript-type">struct</span> nfs_open_file *);
<span class="enscript-type">int</span>	nfs4_reopen(<span class="enscript-type">struct</span> nfs_open_file *, thread_t);
<span class="enscript-type">int</span>	nfs4_open_rpc(<span class="enscript-type">struct</span> nfs_open_file *, vfs_context_t, <span class="enscript-type">struct</span> componentname *, <span class="enscript-type">struct</span> vnode_attr *, vnode_t, vnode_t *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs4_open_rpc_internal(<span class="enscript-type">struct</span> nfs_open_file *, vfs_context_t, thread_t, kauth_cred_t, <span class="enscript-type">struct</span> componentname *, <span class="enscript-type">struct</span> vnode_attr *, vnode_t, vnode_t *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs4_open_confirm_rpc(<span class="enscript-type">struct</span> nfsmount *, nfsnode_t, u_char *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> nfs_open_owner *, nfs_stateid *, thread_t, kauth_cred_t, <span class="enscript-type">struct</span> nfs_vattr *, uint64_t *);
<span class="enscript-type">int</span>	nfs4_open_reopen_rpc(<span class="enscript-type">struct</span> nfs_open_file *, thread_t, kauth_cred_t, <span class="enscript-type">struct</span> componentname *, vnode_t, vnode_t *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs4_open_reclaim_rpc(<span class="enscript-type">struct</span> nfs_open_file *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs4_claim_delegated_open_rpc(<span class="enscript-type">struct</span> nfs_open_file *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs4_claim_delegated_state_for_open_file(<span class="enscript-type">struct</span> nfs_open_file *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs4_claim_delegated_state_for_node(nfsnode_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs4_open_downgrade_rpc(nfsnode_t, <span class="enscript-type">struct</span> nfs_open_file *, vfs_context_t);
<span class="enscript-type">int</span>	nfs4_close_rpc(nfsnode_t, <span class="enscript-type">struct</span> nfs_open_file *, thread_t, kauth_cred_t, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs4_delegation_return_enqueue(nfsnode_t);
<span class="enscript-type">int</span>	nfs4_delegation_return(nfsnode_t, <span class="enscript-type">int</span>, thread_t, kauth_cred_t);
<span class="enscript-type">int</span>	nfs4_delegreturn_rpc(<span class="enscript-type">struct</span> nfsmount *, u_char *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> nfs_stateid *, <span class="enscript-type">int</span>, thread_t, kauth_cred_t);
<span class="enscript-type">void</span>	nfs_release_open_state_for_node(nfsnode_t, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs_revoke_open_state_for_node(nfsnode_t);
<span class="enscript-type">struct</span> nfs_lock_owner *<span class="enscript-function-name">nfs_lock_owner_find</span>(nfsnode_t, proc_t, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs_lock_owner_destroy(<span class="enscript-type">struct</span> nfs_lock_owner *);
<span class="enscript-type">void</span>	nfs_lock_owner_ref(<span class="enscript-type">struct</span> nfs_lock_owner *);
<span class="enscript-type">void</span>	nfs_lock_owner_rele(<span class="enscript-type">struct</span> nfs_lock_owner *);
<span class="enscript-type">int</span>	nfs_lock_owner_set_busy(<span class="enscript-type">struct</span> nfs_lock_owner *, thread_t);
<span class="enscript-type">void</span>	nfs_lock_owner_clear_busy(<span class="enscript-type">struct</span> nfs_lock_owner *);
<span class="enscript-type">void</span>	nfs_lock_owner_insert_held_lock(<span class="enscript-type">struct</span> nfs_lock_owner *, <span class="enscript-type">struct</span> nfs_file_lock *);
<span class="enscript-type">struct</span> nfs_file_lock *<span class="enscript-function-name">nfs_file_lock_alloc</span>(<span class="enscript-type">struct</span> nfs_lock_owner *);
<span class="enscript-type">void</span>	nfs_file_lock_destroy(<span class="enscript-type">struct</span> nfs_file_lock *);
<span class="enscript-type">int</span>	nfs_file_lock_conflict(<span class="enscript-type">struct</span> nfs_file_lock *, <span class="enscript-type">struct</span> nfs_file_lock *, <span class="enscript-type">int</span> *);
<span class="enscript-type">int</span>	nfs4_lock_rpc(nfsnode_t, <span class="enscript-type">struct</span> nfs_open_file *, <span class="enscript-type">struct</span> nfs_file_lock *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, thread_t, kauth_cred_t);
<span class="enscript-type">int</span>	nfs_unlock_rpc(nfsnode_t, <span class="enscript-type">struct</span> nfs_lock_owner *, <span class="enscript-type">int</span>, uint64_t, uint64_t, thread_t, kauth_cred_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_advlock_getlock(nfsnode_t, <span class="enscript-type">struct</span> nfs_lock_owner *, <span class="enscript-type">struct</span> flock *, uint64_t, uint64_t, vfs_context_t);
<span class="enscript-type">int</span>	nfs_advlock_setlock(nfsnode_t, <span class="enscript-type">struct</span> nfs_open_file *, <span class="enscript-type">struct</span> nfs_lock_owner *, <span class="enscript-type">int</span>, uint64_t, uint64_t, <span class="enscript-type">int</span>, <span class="enscript-type">short</span>, vfs_context_t);
<span class="enscript-type">int</span>	nfs_advlock_unlock(nfsnode_t, <span class="enscript-type">struct</span> nfs_open_file *, <span class="enscript-type">struct</span> nfs_lock_owner *, uint64_t, uint64_t, <span class="enscript-type">int</span>, vfs_context_t);

nfsnode_t <span class="enscript-function-name">nfs4_named_attr_dir_get</span>(nfsnode_t, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">int</span>	nfs4_named_attr_get(nfsnode_t, <span class="enscript-type">struct</span> componentname *, uint32_t, <span class="enscript-type">int</span>, vfs_context_t, nfsnode_t *, <span class="enscript-type">struct</span> nfs_open_file **);
<span class="enscript-type">int</span>	nfs4_named_attr_remove(nfsnode_t, nfsnode_t, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, vfs_context_t);

<span class="enscript-type">int</span>	nfs_mount_state_in_use_start(<span class="enscript-type">struct</span> nfsmount *, thread_t);
<span class="enscript-type">int</span>	nfs_mount_state_in_use_end(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_mount_state_error_should_restart(<span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_mount_state_error_delegation_lost(<span class="enscript-type">int</span>);
uint	nfs_mount_state_max_restarts(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">int</span>	nfs_mount_state_wait_for_recovery(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">void</span>	nfs_need_recover(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">int</span> error);
<span class="enscript-type">void</span>	nfs_recover(<span class="enscript-type">struct</span> nfsmount *);

<span class="enscript-type">int</span>	nfs_vnop_access(<span class="enscript-type">struct</span> vnop_access_args *);
<span class="enscript-type">int</span>	nfs_vnop_remove(<span class="enscript-type">struct</span> vnop_remove_args *);
<span class="enscript-type">int</span>	nfs_vnop_read(<span class="enscript-type">struct</span> vnop_read_args *);
<span class="enscript-type">int</span>	nfs_vnop_write(<span class="enscript-type">struct</span> vnop_write_args *);
<span class="enscript-type">int</span>	nfs_vnop_open(<span class="enscript-type">struct</span> vnop_open_args *);
<span class="enscript-type">int</span>	nfs_vnop_close(<span class="enscript-type">struct</span> vnop_close_args *);
<span class="enscript-type">int</span>	nfs_vnop_advlock(<span class="enscript-type">struct</span> vnop_advlock_args *);
<span class="enscript-type">int</span>	nfs_vnop_mmap(<span class="enscript-type">struct</span> vnop_mmap_args *);
<span class="enscript-type">int</span>	nfs_vnop_mnomap(<span class="enscript-type">struct</span> vnop_mnomap_args *);

<span class="enscript-type">int</span>	nfs4_vnop_create(<span class="enscript-type">struct</span> vnop_create_args *);
<span class="enscript-type">int</span>	nfs4_vnop_mknod(<span class="enscript-type">struct</span> vnop_mknod_args *);
<span class="enscript-type">int</span>	nfs4_vnop_close(<span class="enscript-type">struct</span> vnop_close_args *);
<span class="enscript-type">int</span>	nfs4_vnop_getattr(<span class="enscript-type">struct</span> vnop_getattr_args *);
<span class="enscript-type">int</span>	nfs4_vnop_link(<span class="enscript-type">struct</span> vnop_link_args *);
<span class="enscript-type">int</span>	nfs4_vnop_mkdir(<span class="enscript-type">struct</span> vnop_mkdir_args *);
<span class="enscript-type">int</span>	nfs4_vnop_rmdir(<span class="enscript-type">struct</span> vnop_rmdir_args *);
<span class="enscript-type">int</span>	nfs4_vnop_symlink(<span class="enscript-type">struct</span> vnop_symlink_args *);
<span class="enscript-type">int</span>	nfs4_vnop_getxattr(<span class="enscript-type">struct</span> vnop_getxattr_args *);
<span class="enscript-type">int</span>	nfs4_vnop_setxattr(<span class="enscript-type">struct</span> vnop_setxattr_args *);
<span class="enscript-type">int</span>	nfs4_vnop_removexattr(<span class="enscript-type">struct</span> vnop_removexattr_args *);
<span class="enscript-type">int</span>	nfs4_vnop_listxattr(<span class="enscript-type">struct</span> vnop_listxattr_args *);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
<span class="enscript-type">int</span>	nfs4_vnop_getnamedstream(<span class="enscript-type">struct</span> vnop_getnamedstream_args *);
<span class="enscript-type">int</span>	nfs4_vnop_makenamedstream(<span class="enscript-type">struct</span> vnop_makenamedstream_args *);
<span class="enscript-type">int</span>	nfs4_vnop_removenamedstream(<span class="enscript-type">struct</span> vnop_removenamedstream_args *);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">int</span>	nfs_read_rpc(nfsnode_t, uio_t, vfs_context_t);
<span class="enscript-type">int</span>	nfs_write_rpc(nfsnode_t, uio_t, vfs_context_t, <span class="enscript-type">int</span> *, uint64_t *);
<span class="enscript-type">int</span>	nfs_write_rpc2(nfsnode_t, uio_t, thread_t, kauth_cred_t, <span class="enscript-type">int</span> *, uint64_t *);

<span class="enscript-type">int</span>	nfs3_access_rpc(nfsnode_t, u_int32_t *, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">int</span>	nfs4_access_rpc(nfsnode_t, u_int32_t *, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">int</span>	nfs3_getattr_rpc(nfsnode_t, mount_t, u_char *, size_t, <span class="enscript-type">int</span>, vfs_context_t, <span class="enscript-type">struct</span> nfs_vattr *, u_int64_t *);
<span class="enscript-type">int</span>	nfs4_getattr_rpc(nfsnode_t, mount_t, u_char *, size_t, <span class="enscript-type">int</span>, vfs_context_t, <span class="enscript-type">struct</span> nfs_vattr *, u_int64_t *);
<span class="enscript-type">int</span>	nfs3_setattr_rpc(nfsnode_t, <span class="enscript-type">struct</span> vnode_attr *, vfs_context_t);
<span class="enscript-type">int</span>	nfs4_setattr_rpc(nfsnode_t, <span class="enscript-type">struct</span> vnode_attr *, vfs_context_t);
<span class="enscript-type">int</span>	nfs3_read_rpc_async(nfsnode_t, off_t, size_t, thread_t, kauth_cred_t, <span class="enscript-type">struct</span> nfsreq_cbinfo *, <span class="enscript-type">struct</span> nfsreq **);
<span class="enscript-type">int</span>	nfs4_read_rpc_async(nfsnode_t, off_t, size_t, thread_t, kauth_cred_t, <span class="enscript-type">struct</span> nfsreq_cbinfo *, <span class="enscript-type">struct</span> nfsreq **);
<span class="enscript-type">int</span>	nfs3_read_rpc_async_finish(nfsnode_t, <span class="enscript-type">struct</span> nfsreq *, uio_t, size_t *, <span class="enscript-type">int</span> *);
<span class="enscript-type">int</span>	nfs4_read_rpc_async_finish(nfsnode_t, <span class="enscript-type">struct</span> nfsreq *, uio_t, size_t *, <span class="enscript-type">int</span> *);
<span class="enscript-type">int</span>	nfs3_write_rpc_async(nfsnode_t, uio_t, size_t, thread_t, kauth_cred_t, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> nfsreq_cbinfo *, <span class="enscript-type">struct</span> nfsreq **);
<span class="enscript-type">int</span>	nfs4_write_rpc_async(nfsnode_t, uio_t, size_t, thread_t, kauth_cred_t, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> nfsreq_cbinfo *, <span class="enscript-type">struct</span> nfsreq **);
<span class="enscript-type">int</span>	nfs3_write_rpc_async_finish(nfsnode_t, <span class="enscript-type">struct</span> nfsreq *, <span class="enscript-type">int</span> *, size_t *, uint64_t *);
<span class="enscript-type">int</span>	nfs4_write_rpc_async_finish(nfsnode_t, <span class="enscript-type">struct</span> nfsreq *, <span class="enscript-type">int</span> *, size_t *, uint64_t *);
<span class="enscript-type">int</span>	nfs3_readdir_rpc(nfsnode_t, <span class="enscript-type">struct</span> nfsbuf *, vfs_context_t);
<span class="enscript-type">int</span>	nfs4_readdir_rpc(nfsnode_t, <span class="enscript-type">struct</span> nfsbuf *, vfs_context_t);
<span class="enscript-type">int</span>	nfs3_readlink_rpc(nfsnode_t, <span class="enscript-type">char</span> *, uint32_t *, vfs_context_t);
<span class="enscript-type">int</span>	nfs4_readlink_rpc(nfsnode_t, <span class="enscript-type">char</span> *, uint32_t *, vfs_context_t);
<span class="enscript-type">int</span>	nfs3_commit_rpc(nfsnode_t, uint64_t, uint64_t, kauth_cred_t, uint64_t);
<span class="enscript-type">int</span>	nfs4_commit_rpc(nfsnode_t, uint64_t, uint64_t, kauth_cred_t, uint64_t);
<span class="enscript-type">int</span>	nfs3_lookup_rpc_async(nfsnode_t, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, vfs_context_t, <span class="enscript-type">struct</span> nfsreq **);
<span class="enscript-type">int</span>	nfs4_lookup_rpc_async(nfsnode_t, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, vfs_context_t, <span class="enscript-type">struct</span> nfsreq **);
<span class="enscript-type">int</span>	nfs3_lookup_rpc_async_finish(nfsnode_t, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, vfs_context_t, <span class="enscript-type">struct</span> nfsreq *, u_int64_t *, fhandle_t *, <span class="enscript-type">struct</span> nfs_vattr *);
<span class="enscript-type">int</span>	nfs4_lookup_rpc_async_finish(nfsnode_t, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, vfs_context_t, <span class="enscript-type">struct</span> nfsreq *, u_int64_t *, fhandle_t *, <span class="enscript-type">struct</span> nfs_vattr *);
<span class="enscript-type">int</span>	nfs3_remove_rpc(nfsnode_t, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, thread_t, kauth_cred_t);
<span class="enscript-type">int</span>	nfs4_remove_rpc(nfsnode_t, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, thread_t, kauth_cred_t);
<span class="enscript-type">int</span>	nfs3_rename_rpc(nfsnode_t, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, nfsnode_t, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">int</span>	nfs4_rename_rpc(nfsnode_t, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, nfsnode_t, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">int</span>	nfs3_pathconf_rpc(nfsnode_t, <span class="enscript-type">struct</span> nfs_fsattr *, vfs_context_t);
<span class="enscript-type">int</span>	nfs4_pathconf_rpc(nfsnode_t, <span class="enscript-type">struct</span> nfs_fsattr *, vfs_context_t);
<span class="enscript-type">int</span>	nfs3_setlock_rpc(nfsnode_t, <span class="enscript-type">struct</span> nfs_open_file *, <span class="enscript-type">struct</span> nfs_file_lock *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, thread_t, kauth_cred_t);
<span class="enscript-type">int</span>	nfs4_setlock_rpc(nfsnode_t, <span class="enscript-type">struct</span> nfs_open_file *, <span class="enscript-type">struct</span> nfs_file_lock *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, thread_t, kauth_cred_t);
<span class="enscript-type">int</span>	nfs3_unlock_rpc(nfsnode_t, <span class="enscript-type">struct</span> nfs_lock_owner *, <span class="enscript-type">int</span>, uint64_t, uint64_t, <span class="enscript-type">int</span>, thread_t, kauth_cred_t);
<span class="enscript-type">int</span>	nfs4_unlock_rpc(nfsnode_t, <span class="enscript-type">struct</span> nfs_lock_owner *, <span class="enscript-type">int</span>, uint64_t, uint64_t, <span class="enscript-type">int</span>, thread_t, kauth_cred_t);
<span class="enscript-type">int</span>	nfs3_getlock_rpc(nfsnode_t, <span class="enscript-type">struct</span> nfs_lock_owner *, <span class="enscript-type">struct</span> flock *, uint64_t, uint64_t, vfs_context_t);
<span class="enscript-type">int</span>	nfs4_getlock_rpc(nfsnode_t, <span class="enscript-type">struct</span> nfs_lock_owner *, <span class="enscript-type">struct</span> flock *, uint64_t, uint64_t, vfs_context_t);

<span class="enscript-type">void</span>	nfsrv_active_user_list_reclaim(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	nfsrv_cleancache(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	nfsrv_cleanup(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span>	nfsrv_credcheck(<span class="enscript-type">struct</span> nfsrv_descript *, vfs_context_t, <span class="enscript-type">struct</span> nfs_export *,
			<span class="enscript-type">struct</span> nfs_export_options *);
<span class="enscript-type">void</span>	nfsrv_idlesock_timer(<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
<span class="enscript-type">int</span>	nfsrv_dorec(<span class="enscript-type">struct</span> nfsrv_sock *, <span class="enscript-type">struct</span> nfsd *, <span class="enscript-type">struct</span> nfsrv_descript **);
<span class="enscript-type">int</span>	nfsrv_errmap(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfsrv_export(<span class="enscript-type">struct</span> user_nfs_export_args *, vfs_context_t);
<span class="enscript-type">int</span>	nfsrv_fhmatch(<span class="enscript-type">struct</span> nfs_filehandle *, <span class="enscript-type">struct</span> nfs_filehandle *);
<span class="enscript-type">int</span>	nfsrv_fhtovp(<span class="enscript-type">struct</span> nfs_filehandle *, <span class="enscript-type">struct</span> nfsrv_descript *, vnode_t *,
			<span class="enscript-type">struct</span> nfs_export **, <span class="enscript-type">struct</span> nfs_export_options **);
<span class="enscript-type">int</span>	nfsrv_check_exports_allow_address(mbuf_t);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
<span class="enscript-type">void</span>	nfsrv_fmod_timer(<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">int</span>	nfsrv_getcache(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, mbuf_t *);
<span class="enscript-type">void</span>	nfsrv_group_sort(gid_t *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfsrv_init(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	nfsrv_initcache(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span>	nfsrv_is_initialized(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span>	nfsrv_namei(<span class="enscript-type">struct</span> nfsrv_descript *, vfs_context_t, <span class="enscript-type">struct</span> nameidata *,
			<span class="enscript-type">struct</span> nfs_filehandle *, vnode_t *,
			<span class="enscript-type">struct</span> nfs_export **, <span class="enscript-type">struct</span> nfs_export_options **);
<span class="enscript-type">void</span>	nfsrv_rcv(socket_t, <span class="enscript-type">void</span> *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfsrv_rcv_locked(socket_t, <span class="enscript-type">struct</span> nfsrv_sock *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfsrv_rephead(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, <span class="enscript-type">struct</span> nfsm_chain *, size_t);
<span class="enscript-type">int</span>	nfsrv_send(<span class="enscript-type">struct</span> nfsrv_sock *, mbuf_t, mbuf_t);
<span class="enscript-type">void</span>	nfsrv_updatecache(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">int</span>, mbuf_t);
<span class="enscript-type">void</span>	nfsrv_update_user_stat(<span class="enscript-type">struct</span> nfs_export *, <span class="enscript-type">struct</span> nfsrv_descript *, uid_t, u_int, u_int, u_int);
<span class="enscript-type">int</span>	nfsrv_vptofh(<span class="enscript-type">struct</span> nfs_export *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> nfs_filehandle *,
			vnode_t, vfs_context_t, <span class="enscript-type">struct</span> nfs_filehandle *);
<span class="enscript-type">void</span>	nfsrv_wakenfsd(<span class="enscript-type">struct</span> nfsrv_sock *);
<span class="enscript-type">void</span>	nfsrv_wg_timer(<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
<span class="enscript-type">int</span>	nfsrv_writegather(<span class="enscript-type">struct</span> nfsrv_descript **, <span class="enscript-type">struct</span> nfsrv_sock *,
			       vfs_context_t, mbuf_t *);

<span class="enscript-type">int</span>	nfsrv_access(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_commit(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_create(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_fsinfo(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_getattr(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_link(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_lookup(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_mkdir(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_mknod(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_noop(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_null(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_pathconf(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_read(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_readdir(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_readdirplus(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_readlink(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_remove(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_rename(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_rmdir(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_setattr(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_statfs(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_symlink(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);
<span class="enscript-type">int</span>	nfsrv_write(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_sock *, vfs_context_t, mbuf_t *);

<span class="enscript-type">void</span>	nfs_interval_timer_start(thread_call_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_use_cache(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">void</span>	nfs_up(<span class="enscript-type">struct</span> nfsmount *, thread_t, <span class="enscript-type">int</span>, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *);
<span class="enscript-type">void</span>	nfs_down(<span class="enscript-type">struct</span> nfsmount *, thread_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_msg(thread_t, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>);

<span class="enscript-type">int</span>	nfs_mountroot(<span class="enscript-type">void</span>);
<span class="enscript-type">struct</span> nfs_diskless;
<span class="enscript-type">int</span>	nfs_boot_init(<span class="enscript-type">struct</span> nfs_diskless *);
<span class="enscript-type">int</span>	nfs_boot_getfh(<span class="enscript-type">struct</span> nfs_diskless *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
resolver_result_t <span class="enscript-function-name">nfs_mirror_mount_trigger_resolve</span>(vnode_t, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> componentname *, <span class="enscript-type">enum</span> path_operation, <span class="enscript-type">int</span>, <span class="enscript-type">void</span> *, vfs_context_t);
resolver_result_t <span class="enscript-function-name">nfs_mirror_mount_trigger_unresolve</span>(vnode_t, <span class="enscript-type">int</span>, <span class="enscript-type">void</span> *, vfs_context_t);
resolver_result_t <span class="enscript-function-name">nfs_mirror_mount_trigger_rearm</span>(vnode_t, <span class="enscript-type">int</span>, <span class="enscript-type">void</span> *, vfs_context_t);
<span class="enscript-type">int</span>	nfs_mirror_mount_domount(vnode_t, vnode_t, vfs_context_t);
<span class="enscript-type">void</span>	nfs_ephemeral_mount_harvester_start(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>	nfs_ephemeral_mount_harvester(__unused <span class="enscript-type">void</span> *arg, __unused wait_result_t wr);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* socket upcall interfaces */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">nfsrv_uc_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfsrv_uc_cleanup</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfsrv_uc_addsock</span>(<span class="enscript-type">struct</span> nfsrv_sock *, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfsrv_uc_dequeue</span>(<span class="enscript-type">struct</span> nfsrv_sock *);
    
<span class="enscript-comment">/* Debug support */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_DEBUG_LEVEL</span>   (nfs_debug_ctl &amp; 0xf)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_DEBUG_FACILITY</span> ((nfs_debug_ctl &gt;&gt; 4) &amp; 0xff)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_DEBUG_FLAGS</span> ((nfs_debug_ctl &gt;&gt; 12) &amp; 0xff)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_DEBUG_VALUE</span> ((nfs_debug_ctl &gt;&gt; 20) &amp; 0xfff)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FAC_SOCK</span>	0x01
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FAC_STATE</span>	0x02
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FAC_NODE</span>	0x04
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FAC_VNOP</span>	0x08
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FAC_BIO</span>	0x10
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FAC_GSS</span>	0x20
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_FAC_VFS</span>	0x40

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_DBG</span>(fac, lev, fmt, ...) \
	<span class="enscript-keyword">if</span> (__builtin_expect(NFS_DEBUG_LEVEL, 0)) nfs_printf(fac, lev, <span class="enscript-string">&quot;%s: %d: &quot;</span> fmt, __func__, __LINE__, ## __VA_ARGS__)

<span class="enscript-type">void</span> <span class="enscript-function-name">nfs_printf</span>(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, ...) __printflike(3,4);
<span class="enscript-type">int</span>  <span class="enscript-function-name">nfs_mountopts</span>(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>);

__END_DECLS

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* KERNEL */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE_API_PRIVATE */</span>

#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>