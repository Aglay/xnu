<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nfs_syscalls.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nfs_syscalls.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc.  All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfs_syscalls.c	8.5 (Berkeley) 3/30/95
 * FreeBSD-Id: nfs_syscalls.c,v 1.32 1997/11/07 08:53:25 phk Exp $
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span> <span class="enscript-comment">/* for fdflags */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lockf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fsevents.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/xdr_subs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/rpcv2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsm_subs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsrvcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_gss.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsmount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_lock.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

kern_return_t	thread_terminate(thread_t); <span class="enscript-comment">/* XXX */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>

<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (*nfsrv_procs[NFS_NPROCS])(<span class="enscript-type">struct</span> nfsrv_descript *nd,
					    <span class="enscript-type">struct</span> nfsrv_sock *slp,
					    vfs_context_t ctx,
					    mbuf_t *mrepp);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfsrv_wg_delay;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfsrv_wg_delay_v3;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> nfsrv_require_resv_port = 0;
<span class="enscript-type">static</span> time_t  nfsrv_idlesock_timer_on = 0;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> nfsrv_sock_tcp_cnt = 0;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSD_MIN_IDLE_TIMEOUT</span> 30
<span class="enscript-type">static</span> <span class="enscript-type">int</span> nfsrv_sock_idle_timeout = 3600; <span class="enscript-comment">/* One hour */</span>

<span class="enscript-type">int</span>	nfssvc_export(user_addr_t argp);
<span class="enscript-type">int</span>	nfssvc_nfsd(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span>	nfssvc_addsock(socket_t, mbuf_t);
<span class="enscript-type">void</span>	nfsrv_zapsock(<span class="enscript-type">struct</span> nfsrv_sock *);
<span class="enscript-type">void</span>	nfsrv_slpderef(<span class="enscript-type">struct</span> nfsrv_sock *);
<span class="enscript-type">void</span>	nfsrv_slpfree(<span class="enscript-type">struct</span> nfsrv_sock *);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>

<span class="enscript-comment">/*
 * sysctl stuff
 */</span>
<span class="enscript-function-name">SYSCTL_DECL</span>(_vfs_generic);
<span class="enscript-function-name">SYSCTL_NODE</span>(_vfs_generic, OID_AUTO, nfs, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;nfs hinge&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
<span class="enscript-function-name">SYSCTL_NODE</span>(_vfs_generic_nfs, OID_AUTO, client, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;nfs client hinge&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, initialdowndelay, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_tprintf_initial_delay, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, nextdowndelay, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_tprintf_delay, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, iosize, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_iosize, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, access_cache_timeout, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_access_cache_timeout, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, allow_async, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_allow_async, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, statfs_rate_limit, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_statfs_rate_limit, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, nfsiod_thread_max, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsiod_thread_max, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, nfsiod_thread_count, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;nfsiod_thread_count, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, lockd_mounts, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;nfs_lockd_mounts, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, max_async_writes, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_max_async_writes, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, single_des, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_single_des, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, access_delete, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_access_delete, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, access_dotzfs, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_access_dotzfs, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, access_for_getattr, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_access_for_getattr, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, idmap_ctrl, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_idmap_ctrl, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, callback_port, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_callback_port, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, is_mobile, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_is_mobile, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, squishy_flags, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_squishy_flags, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_UINT</span>(_vfs_generic_nfs_client, OID_AUTO, debug_ctl, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_debug_ctl, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, readlink_nocache, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_readlink_nocache, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_client, OID_AUTO, root_steals_gss_context, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfs_root_steals_ctx, 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSCLIENT */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>
<span class="enscript-function-name">SYSCTL_NODE</span>(_vfs_generic_nfs, OID_AUTO, server, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;nfs server hinge&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, wg_delay, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsrv_wg_delay, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, wg_delay_v3, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsrv_wg_delay_v3, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, require_resv_port, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsrv_require_resv_port, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, async, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsrv_async, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, export_hash_size, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsrv_export_hash_size, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, reqcache_size, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsrv_reqcache_size, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, request_queue_length, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsrv_sock_max_rec_queue_length, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, user_stats, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsrv_user_stat_enabled, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_UINT</span>(_vfs_generic_nfs_server, OID_AUTO, gss_context_ttl, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsrv_gss_context_ttl, 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, fsevents, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsrv_fsevents_enabled, 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, nfsd_thread_max, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsd_thread_max, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, nfsd_thread_count, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;nfsd_thread_count, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, nfsd_sock_idle_timeout, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsrv_sock_idle_timeout, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, nfsd_tcp_connections, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;nfsrv_sock_tcp_cnt, 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFS_UC_Q_DEBUG</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, use_upcall_svc, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsrv_uc_use_proxy, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, upcall_queue_limit, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsrv_uc_queue_limit, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, upcall_queue_max_seen, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;nfsrv_uc_queue_max_seen, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vfs_generic_nfs_server, OID_AUTO, upcall_queue_count, CTLFLAG_RD | CTLFLAG_LOCKED, __DECONST(<span class="enscript-type">int</span> *, &amp;nfsrv_uc_queue_count), 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mapname2id</span>(<span class="enscript-type">struct</span> nfs_testmapid *map)
{
	<span class="enscript-type">int</span> error;

	error = nfs4_id2guid(map-&gt;ntm_name, &amp;map-&gt;ntm_guid, map-&gt;ntm_grpflag);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (map-&gt;ntm_grpflag)
		error = kauth_cred_guid2gid(&amp;map-&gt;ntm_guid, (gid_t *)&amp;map-&gt;ntm_id);
	<span class="enscript-keyword">else</span>
		error = kauth_cred_guid2uid(&amp;map-&gt;ntm_guid, (uid_t *)&amp;map-&gt;ntm_id);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mapid2name</span>(<span class="enscript-type">struct</span> nfs_testmapid *map)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> len = <span class="enscript-keyword">sizeof</span>(map-&gt;ntm_name);
	
	<span class="enscript-keyword">if</span> (map-&gt;ntm_grpflag)
		error = kauth_cred_gid2guid((gid_t)map-&gt;ntm_id, &amp;map-&gt;ntm_guid);
	<span class="enscript-keyword">else</span>
		error = kauth_cred_uid2guid((uid_t)map-&gt;ntm_id, &amp;map-&gt;ntm_guid);

	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	
	error = nfs4_guid2id(&amp;map-&gt;ntm_guid, map-&gt;ntm_name, &amp;len, map-&gt;ntm_grpflag);

	<span class="enscript-keyword">return</span> (error);
	
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfsclnt_testidmap</span>(proc_t p, user_addr_t argp)
{
	<span class="enscript-type">struct</span> nfs_testmapid mapid;
	<span class="enscript-type">int</span> error, coerror;
		
        <span class="enscript-comment">/* Let root make this call. */</span>
	error = proc_suser(p);
        <span class="enscript-keyword">if</span> (error)
                <span class="enscript-keyword">return</span> (error);

	error = copyin(argp, &amp;mapid, <span class="enscript-keyword">sizeof</span>(mapid));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (mapid.ntm_name2id)
		error = mapname2id(&amp;mapid);
	<span class="enscript-keyword">else</span>
		error = mapid2name(&amp;mapid);

	coerror = copyout(&amp;mapid, argp, <span class="enscript-keyword">sizeof</span>(mapid));

	<span class="enscript-keyword">return</span> (error ? error : coerror);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsclnt</span>(proc_t p, <span class="enscript-type">struct</span> nfsclnt_args *uap, __unused <span class="enscript-type">int</span> *retval)
{
	<span class="enscript-type">struct</span> lockd_ans la;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">switch</span> (uap-&gt;flag) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSCLNT_LOCKDANS</span>:
		error = copyin(uap-&gt;argp, &amp;la, <span class="enscript-keyword">sizeof</span>(la));
		<span class="enscript-keyword">if</span> (!error)
			error = nfslockdans(p, &amp;la);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSCLNT_LOCKDNOTIFY</span>:
		error = nfslockdnotify(p, uap-&gt;argp);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSCLNT_TESTIDMAP</span>:
		error = nfsclnt_testidmap(p, uap-&gt;argp);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EINVAL;
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Asynchronous I/O threads for client NFS.
 * They do read-ahead and write-behind operations on the block I/O cache.
 *
 * The pool of up to nfsiod_thread_max threads is launched on demand and exit
 * when unused for a while.  There are as many nfsiod structs as there are
 * nfsiod threads; however there's no strict tie between a thread and a struct.
 * Each thread puts an nfsiod on the free list and sleeps on it.  When it wakes
 * up, it removes the next struct nfsiod from the queue and services it.  Then
 * it will put the struct at the head of free list and sleep on it.
 * Async requests will pull the next struct nfsiod from the head of the free list,
 * put it on the work queue, and wake whatever thread is waiting on that struct.
 */</span>

<span class="enscript-comment">/*
 * nfsiod thread exit routine
 *
 * Must be called with nfsiod_mutex held so that the
 * decision to terminate is atomic with the termination.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsiod_terminate</span>(<span class="enscript-type">struct</span> nfsiod *niod)
{
	nfsiod_thread_count--;
	lck_mtx_unlock(nfsiod_mutex);
	<span class="enscript-keyword">if</span> (niod)
		FREE(niod, M_TEMP);
	<span class="enscript-keyword">else</span>
		printf(<span class="enscript-string">&quot;nfsiod: terminating without niod\n&quot;</span>);
	thread_terminate(current_thread());
	<span class="enscript-comment">/*NOTREACHED*/</span>
}

<span class="enscript-comment">/* nfsiod thread startup routine */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsiod_thread</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> nfsiod *niod;
	<span class="enscript-type">int</span> error;

	MALLOC(niod, <span class="enscript-type">struct</span> nfsiod *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfsiod), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (!niod) {
		lck_mtx_lock(nfsiod_mutex);
		nfsiod_thread_count--;
		wakeup(current_thread());
		lck_mtx_unlock(nfsiod_mutex);
		thread_terminate(current_thread());
		<span class="enscript-comment">/*NOTREACHED*/</span>
	}
	bzero(niod, <span class="enscript-keyword">sizeof</span>(*niod));
	lck_mtx_lock(nfsiod_mutex);
	TAILQ_INSERT_HEAD(&amp;nfsiodfree, niod, niod_link);
	wakeup(current_thread());
	error = msleep0(niod, nfsiod_mutex, PWAIT | PDROP, <span class="enscript-string">&quot;nfsiod&quot;</span>, NFS_ASYNCTHREADMAXIDLE*hz, nfsiod_continue);
	<span class="enscript-comment">/* shouldn't return... so we have an error */</span>
	<span class="enscript-comment">/* remove an old nfsiod struct and terminate */</span>
	lck_mtx_lock(nfsiod_mutex);
	<span class="enscript-keyword">if</span> ((niod = TAILQ_LAST(&amp;nfsiodfree, nfsiodlist)))
		TAILQ_REMOVE(&amp;nfsiodfree, niod, niod_link);
	nfsiod_terminate(niod);
	<span class="enscript-comment">/*NOTREACHED*/</span>
}

<span class="enscript-comment">/*
 * Start up another nfsiod thread.
 * (unless we're already maxed out and there are nfsiods running)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsiod_start</span>(<span class="enscript-type">void</span>)
{
	thread_t thd = THREAD_NULL;

	lck_mtx_lock(nfsiod_mutex);
	<span class="enscript-keyword">if</span> ((nfsiod_thread_count &gt;= NFSIOD_MAX) &amp;&amp; (nfsiod_thread_count &gt; 0)) {
		lck_mtx_unlock(nfsiod_mutex);
		<span class="enscript-keyword">return</span> (EBUSY);
	}
	nfsiod_thread_count++;
	<span class="enscript-keyword">if</span> (kernel_thread_start((thread_continue_t)nfsiod_thread, NULL, &amp;thd) != KERN_SUCCESS) {
		lck_mtx_unlock(nfsiod_mutex);
		<span class="enscript-keyword">return</span> (EBUSY);
	}
	<span class="enscript-comment">/* wait for the thread to complete startup */</span>
	msleep(thd, nfsiod_mutex, PWAIT | PDROP, <span class="enscript-string">&quot;nfsiodw&quot;</span>, NULL);
	thread_deallocate(thd);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Continuation for Asynchronous I/O threads for NFS client.
 *
 * Grab an nfsiod struct to work on, do some work, then drop it
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsiod_continue</span>(<span class="enscript-type">int</span> error)
{
	<span class="enscript-type">struct</span> nfsiod *niod;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfsreq *req, *treq;
	<span class="enscript-type">struct</span> nfs_reqqhead iodq;
	<span class="enscript-type">int</span> morework;

	lck_mtx_lock(nfsiod_mutex);
	niod = TAILQ_FIRST(&amp;nfsiodwork);
	<span class="enscript-keyword">if</span> (!niod) {
		<span class="enscript-comment">/* there's no work queued up */</span>
		<span class="enscript-comment">/* remove an old nfsiod struct and terminate */</span>
		<span class="enscript-keyword">if</span> ((niod = TAILQ_LAST(&amp;nfsiodfree, nfsiodlist)))
			TAILQ_REMOVE(&amp;nfsiodfree, niod, niod_link);
		nfsiod_terminate(niod);
		<span class="enscript-comment">/*NOTREACHED*/</span>
	}
	TAILQ_REMOVE(&amp;nfsiodwork, niod, niod_link);

<span class="enscript-reference">worktodo</span>:
	<span class="enscript-keyword">while</span> ((nmp = niod-&gt;niod_nmp)) {
		<span class="enscript-keyword">if</span> (nmp == NULL){
			niod-&gt;niod_nmp = NULL;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* 
		 * Service this mount's async I/O queue.
		 *
		 * In order to ensure some level of fairness between mounts,
		 * we grab all the work up front before processing it so any
		 * new work that arrives will be serviced on a subsequent
		 * iteration - and we have a chance to see if other work needs
		 * to be done (e.g. the delayed write queue needs to be pushed
		 * or other mounts are waiting for an nfsiod).
		 */</span>
		<span class="enscript-comment">/* grab the current contents of the queue */</span>
		TAILQ_INIT(&amp;iodq);
		TAILQ_CONCAT(&amp;iodq, &amp;nmp-&gt;nm_iodq, r_achain);
		<span class="enscript-comment">/* Mark each iod request as being managed by an iod */</span>
		TAILQ_FOREACH(req, &amp;iodq, r_achain) {
			lck_mtx_lock(&amp;req-&gt;r_mtx);
			assert(!(req-&gt;r_flags &amp; R_IOD));
			req-&gt;r_flags |= R_IOD;
			lck_mtx_unlock(&amp;req-&gt;r_mtx);
		}
		lck_mtx_unlock(nfsiod_mutex);

		<span class="enscript-comment">/* process the queue */</span>
		TAILQ_FOREACH_SAFE(req, &amp;iodq, r_achain, treq) {
			TAILQ_REMOVE(&amp;iodq, req, r_achain);
			req-&gt;r_achain.tqe_next = NFSREQNOLIST;
			req-&gt;r_callback.rcb_func(req);
		}

		<span class="enscript-comment">/* now check if there's more/other work to be done */</span>
		lck_mtx_lock(nfsiod_mutex);
		morework = !TAILQ_EMPTY(&amp;nmp-&gt;nm_iodq);
		<span class="enscript-keyword">if</span> (!morework || !TAILQ_EMPTY(&amp;nfsiodmounts)) {
			<span class="enscript-comment">/* 
			 * we're going to stop working on this mount but if the 
			 * mount still needs more work so queue it up
			 */</span>
			<span class="enscript-keyword">if</span> (morework &amp;&amp; nmp-&gt;nm_iodlink.tqe_next == NFSNOLIST)
				TAILQ_INSERT_TAIL(&amp;nfsiodmounts, nmp, nm_iodlink);
			nmp-&gt;nm_niod = NULL;
			niod-&gt;niod_nmp = NULL;
		}
	}

	<span class="enscript-comment">/* loop if there's still a mount to work on */</span>
	<span class="enscript-keyword">if</span> (!niod-&gt;niod_nmp &amp;&amp; !TAILQ_EMPTY(&amp;nfsiodmounts)) {
		niod-&gt;niod_nmp = TAILQ_FIRST(&amp;nfsiodmounts);
		TAILQ_REMOVE(&amp;nfsiodmounts, niod-&gt;niod_nmp, nm_iodlink);
		niod-&gt;niod_nmp-&gt;nm_iodlink.tqe_next = NFSNOLIST;
	}
	<span class="enscript-keyword">if</span> (niod-&gt;niod_nmp)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">worktodo</span>;

	<span class="enscript-comment">/* queue ourselves back up - if there aren't too many threads running */</span>
	<span class="enscript-keyword">if</span> (nfsiod_thread_count &lt;= NFSIOD_MAX) {
		TAILQ_INSERT_HEAD(&amp;nfsiodfree, niod, niod_link);
		error = msleep0(niod, nfsiod_mutex, PWAIT | PDROP, <span class="enscript-string">&quot;nfsiod&quot;</span>, NFS_ASYNCTHREADMAXIDLE*hz, nfsiod_continue);
		<span class="enscript-comment">/* shouldn't return... so we have an error */</span>
		<span class="enscript-comment">/* remove an old nfsiod struct and terminate */</span>
		lck_mtx_lock(nfsiod_mutex);
		<span class="enscript-keyword">if</span> ((niod = TAILQ_LAST(&amp;nfsiodfree, nfsiodlist)))
			TAILQ_REMOVE(&amp;nfsiodfree, niod, niod_link);
	}
	nfsiod_terminate(niod);
	<span class="enscript-comment">/*NOTREACHED*/</span>
	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSCLIENT */</span>


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>

<span class="enscript-comment">/*
 * NFS server system calls
 * getfh() lives here too, but maybe should move to kern/vfs_syscalls.c
 */</span>

<span class="enscript-comment">/*
 * Get file handle system call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getfh</span>(proc_t p, <span class="enscript-type">struct</span> getfh_args *uap, __unused <span class="enscript-type">int</span> *retval)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">int</span> error, fhlen, fidlen;
	<span class="enscript-type">struct</span> nameidata nd;
	<span class="enscript-type">char</span> path[MAXPATHLEN], *ptr;
	size_t pathlen;
	<span class="enscript-type">struct</span> nfs_exportfs *nxfs;
	<span class="enscript-type">struct</span> nfs_export *nx;

	<span class="enscript-comment">/*
	 * Must be super user
	 */</span>
	error = proc_suser(p);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	error = copyinstr(uap-&gt;fname, path, MAXPATHLEN, &amp;pathlen);
	<span class="enscript-keyword">if</span> (!error)
		error = copyin(uap-&gt;fhp, &amp;fhlen, <span class="enscript-keyword">sizeof</span>(fhlen));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-comment">/* limit fh size to length specified (or v3 size by default) */</span>
	<span class="enscript-keyword">if</span> ((fhlen != NFSV2_MAX_FH_SIZE) &amp;&amp; (fhlen != NFSV3_MAX_FH_SIZE))
		fhlen = NFSV3_MAX_FH_SIZE;
	fidlen = fhlen - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_exphandle);

	<span class="enscript-keyword">if</span> (!nfsrv_is_initialized())
		<span class="enscript-keyword">return</span> (EINVAL);

	NDINIT(&amp;nd, LOOKUP, OP_LOOKUP, FOLLOW | LOCKLEAF | AUDITVNPATH1, 
			UIO_SYSSPACE, CAST_USER_ADDR_T(path), vfs_context_current());
	error = namei(&amp;nd);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	nameidone(&amp;nd);

	vp = nd.ni_vp;

	<span class="enscript-comment">// find exportfs that matches f_mntonname
</span>	lck_rw_lock_shared(&amp;nfsrv_export_rwlock);
	ptr = vnode_mount(vp)-&gt;mnt_vfsstat.f_mntonname;
	LIST_FOREACH(nxfs, &amp;nfsrv_exports, nxfs_next) {
		<span class="enscript-keyword">if</span> (!strncmp(nxfs-&gt;nxfs_path, ptr, MAXPATHLEN))
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (!nxfs || strncmp(nxfs-&gt;nxfs_path, path, strlen(nxfs-&gt;nxfs_path))) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">// find export that best matches remainder of path
</span>	ptr = path + strlen(nxfs-&gt;nxfs_path);
	<span class="enscript-keyword">while</span> (*ptr &amp;&amp; (*ptr == <span class="enscript-string">'/'</span>))
		ptr++;
	LIST_FOREACH(nx, &amp;nxfs-&gt;nxfs_exports, nx_next) {
		<span class="enscript-type">int</span> len = strlen(nx-&gt;nx_path);
		<span class="enscript-keyword">if</span> (len == 0)  <span class="enscript-comment">// we've hit the export entry for the root directory
</span>			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (!strncmp(nx-&gt;nx_path, ptr, len))
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (!nx) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	bzero(&amp;nfh, <span class="enscript-keyword">sizeof</span>(nfh));
	nfh.nfh_xh.nxh_version = htonl(NFS_FH_VERSION);
	nfh.nfh_xh.nxh_fsid = htonl(nxfs-&gt;nxfs_id);
	nfh.nfh_xh.nxh_expid = htonl(nx-&gt;nx_id);
	nfh.nfh_xh.nxh_flags = 0;
	nfh.nfh_xh.nxh_reserved = 0;
	nfh.nfh_len = fidlen;
	error = VFS_VPTOFH(vp, (<span class="enscript-type">int</span>*)&amp;nfh.nfh_len, &amp;nfh.nfh_fid[0], NULL);
	<span class="enscript-keyword">if</span> (nfh.nfh_len &gt; (uint32_t)fidlen)
		error = EOVERFLOW;
	nfh.nfh_xh.nxh_fidlen = nfh.nfh_len;
	nfh.nfh_len += <span class="enscript-keyword">sizeof</span>(nfh.nfh_xh);
	nfh.nfh_fhp = (u_char*)&amp;nfh.nfh_xh;

<span class="enscript-reference">out</span>:
	lck_rw_done(&amp;nfsrv_export_rwlock);
	vnode_put(vp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	error = copyout((caddr_t)&amp;nfh, uap-&gt;fhp, <span class="enscript-keyword">sizeof</span>(fhandle_t));
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">extern</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> fileops vnops;

<span class="enscript-comment">/*
 * syscall for the rpc.lockd to use to translate a NFS file handle into
 * an open descriptor.
 *
 * warning: do not remove the suser() call or this becomes one giant
 * security hole.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fhopen</span>( proc_t p,
	<span class="enscript-type">struct</span> fhopen_args *uap,
	int32_t *retval)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	<span class="enscript-type">struct</span> flock lf;
	<span class="enscript-type">struct</span> fileproc *fp, *nfp;
	<span class="enscript-type">int</span> fmode, error, type;
	<span class="enscript-type">int</span> indx;
	vfs_context_t ctx = vfs_context_current();
	kauth_action_t action;

	<span class="enscript-comment">/*
	 * Must be super user
	 */</span>
	error = suser(vfs_context_ucred(ctx), 0);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> (!nfsrv_is_initialized()) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	fmode = FFLAGS(uap-&gt;flags);
	<span class="enscript-comment">/* why not allow a non-read/write open for our lockd? */</span>
	<span class="enscript-keyword">if</span> (((fmode &amp; (FREAD | FWRITE)) == 0) || (fmode &amp; O_CREAT))
		<span class="enscript-keyword">return</span> (EINVAL);

	error = copyin(uap-&gt;u_fhp, &amp;nfh.nfh_len, <span class="enscript-keyword">sizeof</span>(nfh.nfh_len));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> ((nfh.nfh_len &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_exphandle)) ||
	    (nfh.nfh_len &gt; (<span class="enscript-type">int</span>)NFSV3_MAX_FH_SIZE))
		<span class="enscript-keyword">return</span> (EINVAL);
	error = copyin(uap-&gt;u_fhp, &amp;nfh, <span class="enscript-keyword">sizeof</span>(nfh.nfh_len) + nfh.nfh_len);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	nfh.nfh_fhp = (u_char*)&amp;nfh.nfh_xh;

	lck_rw_lock_shared(&amp;nfsrv_export_rwlock);
	<span class="enscript-comment">/* now give me my vnode, it gets returned to me with a reference */</span>
	error = nfsrv_fhtovp(&amp;nfh, NULL, &amp;vp, &amp;nx, &amp;nxo);
	lck_rw_done(&amp;nfsrv_export_rwlock);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (error == NFSERR_TRYLATER)
			error = EAGAIN; <span class="enscript-comment">// XXX EBUSY? Or just leave as TRYLATER?
</span>		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/*
	 * From now on we have to make sure not
	 * to forget about the vnode.
	 * Any error that causes an abort must vnode_put(vp).
	 * Just set error = err and 'goto bad;'.
	 */</span>

	<span class="enscript-comment">/*
	 * from vn_open  
	 */</span>      
	<span class="enscript-keyword">if</span> (vnode_vtype(vp) == VSOCK) {
		error = EOPNOTSUPP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;      
	}

	<span class="enscript-comment">/* disallow write operations on directories */</span>
	<span class="enscript-keyword">if</span> (vnode_isdir(vp) &amp;&amp; (fmode &amp; (FWRITE | O_TRUNC))) {
		error = EISDIR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* compute action to be authorized */</span>
	action = 0;
	<span class="enscript-keyword">if</span> (fmode &amp; FREAD)
		action |= KAUTH_VNODE_READ_DATA;
	<span class="enscript-keyword">if</span> (fmode &amp; (FWRITE | O_TRUNC))
		action |= KAUTH_VNODE_WRITE_DATA;
	<span class="enscript-keyword">if</span> ((error = vnode_authorize(vp, NULL, action, ctx)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> ((error = VNOP_OPEN(vp, fmode, ctx)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	<span class="enscript-keyword">if</span> ((error = vnode_ref_ext(vp, fmode, 0)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-comment">/*
	 * end of vn_open code
	 */</span>

	<span class="enscript-comment">// starting here... error paths should call vn_close/vnode_put
</span>	<span class="enscript-keyword">if</span> ((error = falloc(p, &amp;nfp, &amp;indx, ctx)) != 0) {
		vn_close(vp, fmode &amp; FMASK, ctx);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	fp = nfp;

	fp-&gt;f_fglob-&gt;fg_flag = fmode &amp; FMASK;
	fp-&gt;f_fglob-&gt;fg_ops = &amp;vnops;
	fp-&gt;f_fglob-&gt;fg_data = (caddr_t)vp;

	<span class="enscript-comment">// XXX do we really need to support this with fhopen()?
</span>	<span class="enscript-keyword">if</span> (fmode &amp; (O_EXLOCK | O_SHLOCK)) {
		lf.l_whence = SEEK_SET;
		lf.l_start = 0;
		lf.l_len = 0;
		<span class="enscript-keyword">if</span> (fmode &amp; O_EXLOCK)
			lf.l_type = F_WRLCK;
		<span class="enscript-keyword">else</span>
			lf.l_type = F_RDLCK;
		type = F_FLOCK;
		<span class="enscript-keyword">if</span> ((fmode &amp; FNONBLOCK) == 0)
			type |= F_WAIT;
		<span class="enscript-keyword">if</span> ((error = VNOP_ADVLOCK(vp, (caddr_t)fp-&gt;f_fglob, F_SETLK, &amp;lf, type, ctx, NULL))) {
			<span class="enscript-type">struct</span> vfs_context context = *vfs_context_current();
			<span class="enscript-comment">/* Modify local copy (to not damage thread copy) */</span>
			context.vc_ucred = fp-&gt;f_fglob-&gt;fg_cred;

			vn_close(vp, fp-&gt;f_fglob-&gt;fg_flag, &amp;context);
			fp_free(p, indx, fp);
			<span class="enscript-keyword">return</span> (error);
		}
		fp-&gt;f_fglob-&gt;fg_flag |= FHASLOCK;
	}

	vnode_put(vp);

	proc_fdlock(p);
	procfdtbl_releasefd(p, indx, NULL);
	fp_drop(p, indx, fp, 1);
	proc_fdunlock(p);

	*retval = indx;
	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">bad</span>:
	vnode_put(vp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS server pseudo system call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfssvc</span>(proc_t p, <span class="enscript-type">struct</span> nfssvc_args *uap, __unused <span class="enscript-type">int</span> *retval)
{
	mbuf_t nam;
	<span class="enscript-type">struct</span> user_nfsd_args user_nfsdarg;
	socket_t so;
	<span class="enscript-type">int</span> error;

	AUDIT_ARG(cmd, uap-&gt;flag);

	<span class="enscript-comment">/*
	 * Must be super user for most operations (export ops checked later).
	 */</span>
	<span class="enscript-keyword">if</span> ((uap-&gt;flag != NFSSVC_EXPORT) &amp;&amp; ((error = proc_suser(p))))
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_system_check_nfsd(kauth_cred_get());
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* make sure NFS server data structures have been initialized */</span>
	nfsrv_init();

	<span class="enscript-keyword">if</span> (uap-&gt;flag &amp; NFSSVC_ADDSOCK) {
		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			error = copyin(uap-&gt;argp, (caddr_t)&amp;user_nfsdarg, <span class="enscript-keyword">sizeof</span>(user_nfsdarg));
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> nfsd_args    tmp_args;
			error = copyin(uap-&gt;argp, (caddr_t)&amp;tmp_args, <span class="enscript-keyword">sizeof</span>(tmp_args));
			<span class="enscript-keyword">if</span> (error == 0) {
				user_nfsdarg.sock = tmp_args.sock;
				user_nfsdarg.name = CAST_USER_ADDR_T(tmp_args.name);
				user_nfsdarg.namelen = tmp_args.namelen;
			}
		}
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-comment">/* get the socket */</span>
		error = file_socket(user_nfsdarg.sock, &amp;so);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-comment">/* Get the client address for connected sockets. */</span>
		<span class="enscript-keyword">if</span> (user_nfsdarg.name == USER_ADDR_NULL || user_nfsdarg.namelen == 0) {
			nam = NULL;
		} <span class="enscript-keyword">else</span> {
			error = sockargs(&amp;nam, user_nfsdarg.name, user_nfsdarg.namelen, MBUF_TYPE_SONAME);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-comment">/* drop the iocount file_socket() grabbed on the file descriptor */</span>
				file_drop(user_nfsdarg.sock);
				<span class="enscript-keyword">return</span> (error);
			}
		}
		<span class="enscript-comment">/*
		 * nfssvc_addsock() will grab a retain count on the socket
		 * to keep the socket from being closed when nfsd closes its
		 * file descriptor for it.
		 */</span>
		error = nfssvc_addsock(so, nam);
		<span class="enscript-comment">/* drop the iocount file_socket() grabbed on the file descriptor */</span>
		file_drop(user_nfsdarg.sock);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uap-&gt;flag &amp; NFSSVC_NFSD) {
		error = nfssvc_nfsd();
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uap-&gt;flag &amp; NFSSVC_EXPORT) {
		error = nfssvc_export(uap-&gt;argp);
	} <span class="enscript-keyword">else</span> {
		error = EINVAL;
	}
	<span class="enscript-keyword">if</span> (error == EINTR || error == ERESTART)
		error = 0;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Adds a socket to the list for servicing by nfsds.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfssvc_addsock</span>(socket_t so, mbuf_t mynam)
{
	<span class="enscript-type">struct</span> nfsrv_sock *slp;
	<span class="enscript-type">int</span> error = 0, sodomain, sotype, soprotocol, on = 1;
	<span class="enscript-type">int</span> first;
	<span class="enscript-type">struct</span> timeval timeo;

	<span class="enscript-comment">/* make sure mbuf constants are set up */</span>
	<span class="enscript-keyword">if</span> (!nfs_mbuf_mhlen)
		nfs_mbuf_init();

	sock_gettype(so, &amp;sodomain, &amp;sotype, &amp;soprotocol);

	<span class="enscript-comment">/* There should be only one UDP socket for each of IPv4 and IPv6 */</span>
	<span class="enscript-keyword">if</span> ((sodomain == AF_INET) &amp;&amp; (soprotocol == IPPROTO_UDP) &amp;&amp; nfsrv_udpsock) {
		mbuf_freem(mynam);
		<span class="enscript-keyword">return</span> (EEXIST);
	}
	<span class="enscript-keyword">if</span> ((sodomain == AF_INET6) &amp;&amp; (soprotocol == IPPROTO_UDP) &amp;&amp; nfsrv_udp6sock) {
		mbuf_freem(mynam);
		<span class="enscript-keyword">return</span> (EEXIST);
	}

	<span class="enscript-comment">/* Set protocol options and reserve some space (for UDP). */</span>
	<span class="enscript-keyword">if</span> (sotype == SOCK_STREAM) {
		error = nfsrv_check_exports_allow_address(mynam);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		sock_setsockopt(so, SOL_SOCKET, SO_KEEPALIVE, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	}
	<span class="enscript-keyword">if</span> ((sodomain == AF_INET) &amp;&amp; (soprotocol == IPPROTO_TCP))
		sock_setsockopt(so, IPPROTO_TCP, TCP_NODELAY, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	<span class="enscript-keyword">if</span> (sotype == SOCK_DGRAM) { <span class="enscript-comment">/* set socket buffer sizes for UDP */</span>
		<span class="enscript-type">int</span> reserve = NFS_UDPSOCKBUF;
		error |= sock_setsockopt(so, SOL_SOCKET, SO_SNDBUF, &amp;reserve, <span class="enscript-keyword">sizeof</span>(reserve));
		error |= sock_setsockopt(so, SOL_SOCKET, SO_RCVBUF, &amp;reserve, <span class="enscript-keyword">sizeof</span>(reserve));
		<span class="enscript-keyword">if</span> (error) {
			log(LOG_INFO, <span class="enscript-string">&quot;nfssvc_addsock: UDP socket buffer setting error(s) %d\n&quot;</span>, error);
			error = 0;
		}
	}
	sock_nointerrupt(so, 0);

	<span class="enscript-comment">/*
	 * Set socket send/receive timeouts.
	 * Receive timeout shouldn't matter, but setting the send timeout
	 * will make sure that an unresponsive client can't hang the server.
	 */</span>
	timeo.tv_usec = 0;
	timeo.tv_sec = 1;
	error |= sock_setsockopt(so, SOL_SOCKET, SO_RCVTIMEO, &amp;timeo, <span class="enscript-keyword">sizeof</span>(timeo));
	timeo.tv_sec = 30;
	error |= sock_setsockopt(so, SOL_SOCKET, SO_SNDTIMEO, &amp;timeo, <span class="enscript-keyword">sizeof</span>(timeo));
	<span class="enscript-keyword">if</span> (error) {
		log(LOG_INFO, <span class="enscript-string">&quot;nfssvc_addsock: socket timeout setting error(s) %d\n&quot;</span>, error);
		error = 0;
	}

	MALLOC(slp, <span class="enscript-type">struct</span> nfsrv_sock *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfsrv_sock), M_NFSSVC, M_WAITOK);
	<span class="enscript-keyword">if</span> (!slp) {
		mbuf_freem(mynam);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	bzero((caddr_t)slp, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nfsrv_sock));
	lck_rw_init(&amp;slp-&gt;ns_rwlock, nfsrv_slp_rwlock_group, LCK_ATTR_NULL);
	lck_mtx_init(&amp;slp-&gt;ns_wgmutex, nfsrv_slp_mutex_group, LCK_ATTR_NULL);

	lck_mtx_lock(nfsd_mutex);

	<span class="enscript-keyword">if</span> (soprotocol == IPPROTO_UDP) {
		<span class="enscript-keyword">if</span> (sodomain == AF_INET) {
			<span class="enscript-comment">/* There should be only one UDP/IPv4 socket */</span>
			<span class="enscript-keyword">if</span> (nfsrv_udpsock) {
				lck_mtx_unlock(nfsd_mutex);
				nfsrv_slpfree(slp);
				mbuf_freem(mynam);
				<span class="enscript-keyword">return</span> (EEXIST);
			}
			nfsrv_udpsock = slp;
		}
		<span class="enscript-keyword">if</span> (sodomain == AF_INET6) {
			<span class="enscript-comment">/* There should be only one UDP/IPv6 socket */</span>
			<span class="enscript-keyword">if</span> (nfsrv_udp6sock) {
				lck_mtx_unlock(nfsd_mutex);
				nfsrv_slpfree(slp);
				mbuf_freem(mynam);
				<span class="enscript-keyword">return</span> (EEXIST);
			}
			nfsrv_udp6sock = slp;
		}
	}

	<span class="enscript-comment">/* add the socket to the list */</span>
	first = TAILQ_EMPTY(&amp;nfsrv_socklist);
	TAILQ_INSERT_TAIL(&amp;nfsrv_socklist, slp, ns_chain);
	<span class="enscript-keyword">if</span> (soprotocol == IPPROTO_TCP) {
		nfsrv_sock_tcp_cnt++;
		<span class="enscript-keyword">if</span> (nfsrv_sock_idle_timeout &lt; 0)
			nfsrv_sock_idle_timeout = 0;
		<span class="enscript-keyword">if</span> (nfsrv_sock_idle_timeout &amp;&amp; (nfsrv_sock_idle_timeout &lt; NFSD_MIN_IDLE_TIMEOUT))
			nfsrv_sock_idle_timeout = NFSD_MIN_IDLE_TIMEOUT;
		<span class="enscript-comment">/*
		 * Possibly start or stop the idle timer. We only start the idle timer when
		 * we have more than 2 * nfsd_thread_max connections. If the idle timer is
		 * on then we may need to turn it off based on the nvsrv_sock_idle_timeout or
		 * the number of connections.
		 */</span>
		<span class="enscript-keyword">if</span> ((nfsrv_sock_tcp_cnt &gt; 2 * nfsd_thread_max) || nfsrv_idlesock_timer_on) {
			<span class="enscript-keyword">if</span> (nfsrv_sock_idle_timeout == 0 || nfsrv_sock_tcp_cnt &lt;= 2 * nfsd_thread_max) {
				<span class="enscript-keyword">if</span> (nfsrv_idlesock_timer_on) {
					thread_call_cancel(nfsrv_idlesock_timer_call);
					nfsrv_idlesock_timer_on = 0;
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-type">struct</span> nfsrv_sock *old_slp;
				<span class="enscript-type">struct</span> timeval now;
				time_t time_to_wait = nfsrv_sock_idle_timeout;
				<span class="enscript-comment">/*
				 * Get the oldest tcp socket and calculate the
				 * earliest time for the next idle timer to fire
				 * based on the possibly updated nfsrv_sock_idle_timeout
				 */</span>
				TAILQ_FOREACH(old_slp, &amp;nfsrv_socklist, ns_chain) {
					<span class="enscript-keyword">if</span> (old_slp-&gt;ns_sotype == SOCK_STREAM) {
						microuptime(&amp;now);
						time_to_wait -= now.tv_sec - old_slp-&gt;ns_timestamp;
						<span class="enscript-keyword">if</span> (time_to_wait &lt; 1)
							time_to_wait = 1;
						<span class="enscript-keyword">break</span>;
					}
				}
				<span class="enscript-comment">/*
				 * If we have a timer scheduled, but if its going to fire too late,
				 * turn it off.
				 */</span>
				<span class="enscript-keyword">if</span> (nfsrv_idlesock_timer_on &gt; now.tv_sec + time_to_wait) {
					thread_call_cancel(nfsrv_idlesock_timer_call);
					nfsrv_idlesock_timer_on = 0;
				}
				<span class="enscript-comment">/* Schedule the idle thread if it isn't already */</span>
				<span class="enscript-keyword">if</span> (!nfsrv_idlesock_timer_on) {
					nfs_interval_timer_start(nfsrv_idlesock_timer_call, time_to_wait * 1000);
					nfsrv_idlesock_timer_on = now.tv_sec + time_to_wait;
				}
			}
		}
	}

	sock_retain(so); <span class="enscript-comment">/* grab a retain count on the socket */</span>
	slp-&gt;ns_so = so;
	slp-&gt;ns_sotype = sotype;
	slp-&gt;ns_nam = mynam;

	<span class="enscript-comment">/* set up the socket up-call */</span>
	nfsrv_uc_addsock(slp, first);

	<span class="enscript-comment">/* mark that the socket is not in the nfsrv_sockwg list */</span>
	slp-&gt;ns_wgq.tqe_next = SLPNOLIST;

	slp-&gt;ns_flag = SLP_VALID | SLP_NEEDQ;

	nfsrv_wakenfsd(slp);
	lck_mtx_unlock(nfsd_mutex);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * nfssvc_nfsd()
 *
 * nfsd theory of operation:
 *
 * The first nfsd thread stays in user mode accepting new TCP connections
 * which are then added via the &quot;addsock&quot; call.  The rest of the nfsd threads
 * simply call into the kernel and remain there in a loop handling NFS
 * requests until killed by a signal.
 * 
 * There's a list of nfsd threads (nfsd_head).
 * There's an nfsd queue that contains only those nfsds that are
 *   waiting for work to do (nfsd_queue).
 *
 * There's a list of all NFS sockets (nfsrv_socklist) and two queues for
 *   managing the work on the sockets:
 *   nfsrv_sockwait - sockets w/new data waiting to be worked on
 *   nfsrv_sockwork - sockets being worked on which may have more work to do
 *   nfsrv_sockwg -- sockets which have pending write gather data
 * When a socket receives data, if it is not currently queued, it
 *   will be placed at the end of the &quot;wait&quot; queue.
 * Whenever a socket needs servicing we make sure it is queued and
 *   wake up a waiting nfsd (if there is one).
 *
 * nfsds will service at most 8 requests from the same socket before
 *   defecting to work on another socket.
 * nfsds will defect immediately if there are any sockets in the &quot;wait&quot; queue
 * nfsds looking for a socket to work on check the &quot;wait&quot; queue first and
 *   then check the &quot;work&quot; queue.
 * When an nfsd starts working on a socket, it removes it from the head of
 *   the queue it's currently on and moves it to the end of the &quot;work&quot; queue.
 * When nfsds are checking the queues for work, any sockets found not to 
 *   have any work are simply dropped from the queue.
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfssvc_nfsd</span>(<span class="enscript-type">void</span>)
{
	mbuf_t m, mrep;
	<span class="enscript-type">struct</span> nfsrv_sock *slp;
	<span class="enscript-type">struct</span> nfsd *nfsd;
	<span class="enscript-type">struct</span> nfsrv_descript *nd = NULL;
	<span class="enscript-type">int</span> error = 0, cacherep, writes_todo;
	<span class="enscript-type">int</span> siz, procrastinate, opcnt = 0;
	u_quad_t cur_usec;
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">struct</span> vfs_context context;
	<span class="enscript-type">struct</span> timespec to;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">nolint</span>
	cacherep = RC_DOIT;
	writes_todo = 0;
#<span class="enscript-reference">endif</span>

	MALLOC(nfsd, <span class="enscript-type">struct</span> nfsd *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfsd), M_NFSD, M_WAITOK);
	<span class="enscript-keyword">if</span> (!nfsd)
		<span class="enscript-keyword">return</span> (ENOMEM);
	bzero(nfsd, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfsd));
	lck_mtx_lock(nfsd_mutex);
	<span class="enscript-keyword">if</span> (nfsd_thread_count++ == 0)
		nfsrv_initcache();		<span class="enscript-comment">/* Init the server request cache */</span>
	
	TAILQ_INSERT_TAIL(&amp;nfsd_head, nfsd, nfsd_chain);
	lck_mtx_unlock(nfsd_mutex);

	context.vc_thread = current_thread();

	<span class="enscript-comment">/* Set time out so that nfsd threads can wake up a see if they are still needed. */</span>
	to.tv_sec = 5;
	to.tv_nsec = 0;

	<span class="enscript-comment">/*
	 * Loop getting rpc requests until SIGKILL.
	 */</span>
	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> (nfsd_thread_max &lt;= 0) {
			<span class="enscript-comment">/* NFS server shutting down, get out ASAP */</span>
			error = EINTR;
			slp = nfsd-&gt;nfsd_slp;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nfsd-&gt;nfsd_flag &amp; NFSD_REQINPROG) {
			<span class="enscript-comment">/* already have some work to do */</span>
			error = 0;
			slp = nfsd-&gt;nfsd_slp;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* need to find work to do */</span>
			error = 0;
			lck_mtx_lock(nfsd_mutex);
			<span class="enscript-keyword">while</span> (!nfsd-&gt;nfsd_slp &amp;&amp; TAILQ_EMPTY(&amp;nfsrv_sockwait) &amp;&amp; TAILQ_EMPTY(&amp;nfsrv_sockwork)) {
				<span class="enscript-keyword">if</span> (nfsd_thread_count &gt; nfsd_thread_max) {
					<span class="enscript-comment">/*
					 * If we have no socket and there are more
					 * nfsd threads than configured, let's exit.
					 */</span>
					error = 0;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				}
				nfsd-&gt;nfsd_flag |= NFSD_WAITING;
				TAILQ_INSERT_HEAD(&amp;nfsd_queue, nfsd, nfsd_queue);
				error = msleep(nfsd, nfsd_mutex, PSOCK | PCATCH, <span class="enscript-string">&quot;nfsd&quot;</span>, &amp;to);
				<span class="enscript-keyword">if</span> (error) {
					<span class="enscript-keyword">if</span> (nfsd-&gt;nfsd_flag &amp; NFSD_WAITING) {
						TAILQ_REMOVE(&amp;nfsd_queue, nfsd, nfsd_queue);
						nfsd-&gt;nfsd_flag &amp;= ~NFSD_WAITING;
					}
					<span class="enscript-keyword">if</span> (error == EWOULDBLOCK)
						<span class="enscript-keyword">continue</span>;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				}
			}
			slp = nfsd-&gt;nfsd_slp;
			<span class="enscript-keyword">if</span> (!slp &amp;&amp; !TAILQ_EMPTY(&amp;nfsrv_sockwait)) {
				<span class="enscript-comment">/* look for a socket to work on in the wait queue */</span>
				<span class="enscript-keyword">while</span> ((slp = TAILQ_FIRST(&amp;nfsrv_sockwait))) {
					lck_rw_lock_exclusive(&amp;slp-&gt;ns_rwlock);
					<span class="enscript-comment">/* remove from the head of the queue */</span>
					TAILQ_REMOVE(&amp;nfsrv_sockwait, slp, ns_svcq);
					slp-&gt;ns_flag &amp;= ~SLP_WAITQ;
					<span class="enscript-keyword">if</span> ((slp-&gt;ns_flag &amp; SLP_VALID) &amp;&amp; (slp-&gt;ns_flag &amp; SLP_WORKTODO))
						<span class="enscript-keyword">break</span>;
					<span class="enscript-comment">/* nothing to do, so skip this socket */</span>
					lck_rw_done(&amp;slp-&gt;ns_rwlock);
				}
			}
			<span class="enscript-keyword">if</span> (!slp &amp;&amp; !TAILQ_EMPTY(&amp;nfsrv_sockwork)) {
				<span class="enscript-comment">/* look for a socket to work on in the work queue */</span>
				<span class="enscript-keyword">while</span> ((slp = TAILQ_FIRST(&amp;nfsrv_sockwork))) {
					lck_rw_lock_exclusive(&amp;slp-&gt;ns_rwlock);
					<span class="enscript-comment">/* remove from the head of the queue */</span>
					TAILQ_REMOVE(&amp;nfsrv_sockwork, slp, ns_svcq);
					slp-&gt;ns_flag &amp;= ~SLP_WORKQ;
					<span class="enscript-keyword">if</span> ((slp-&gt;ns_flag &amp; SLP_VALID) &amp;&amp; (slp-&gt;ns_flag &amp; SLP_WORKTODO))
						<span class="enscript-keyword">break</span>;
					<span class="enscript-comment">/* nothing to do, so skip this socket */</span>
					lck_rw_done(&amp;slp-&gt;ns_rwlock);
				}
			}
			<span class="enscript-keyword">if</span> (!nfsd-&gt;nfsd_slp &amp;&amp; slp) {
				<span class="enscript-comment">/* we found a socket to work on, grab a reference */</span>
				slp-&gt;ns_sref++;
				microuptime(&amp;now);
				slp-&gt;ns_timestamp = now.tv_sec;
				<span class="enscript-comment">/* We keep the socket list in least recently used order for reaping idle sockets */</span>
				TAILQ_REMOVE(&amp;nfsrv_socklist, slp, ns_chain);
				TAILQ_INSERT_TAIL(&amp;nfsrv_socklist, slp, ns_chain);
				nfsd-&gt;nfsd_slp = slp;
				opcnt = 0;
				<span class="enscript-comment">/* and put it at the back of the work queue */</span>
				TAILQ_INSERT_TAIL(&amp;nfsrv_sockwork, slp, ns_svcq);
				slp-&gt;ns_flag |= SLP_WORKQ;
				lck_rw_done(&amp;slp-&gt;ns_rwlock);
			}
			lck_mtx_unlock(nfsd_mutex);
			<span class="enscript-keyword">if</span> (!slp)
				<span class="enscript-keyword">continue</span>;
			lck_rw_lock_exclusive(&amp;slp-&gt;ns_rwlock);
			<span class="enscript-keyword">if</span> (slp-&gt;ns_flag &amp; SLP_VALID) {
				<span class="enscript-keyword">if</span> ((slp-&gt;ns_flag &amp; (SLP_NEEDQ|SLP_DISCONN)) == SLP_NEEDQ) {
					slp-&gt;ns_flag &amp;= ~SLP_NEEDQ;
					nfsrv_rcv_locked(slp-&gt;ns_so, slp, MBUF_WAITOK);
				}
				<span class="enscript-keyword">if</span> (slp-&gt;ns_flag &amp; SLP_DISCONN)
					nfsrv_zapsock(slp);
				error = nfsrv_dorec(slp, nfsd, &amp;nd);
				<span class="enscript-keyword">if</span> (error == EINVAL) {	<span class="enscript-comment">// RPCSEC_GSS drop
</span>					<span class="enscript-keyword">if</span> (slp-&gt;ns_sotype == SOCK_STREAM)
						nfsrv_zapsock(slp); <span class="enscript-comment">// drop connection
</span>				}
				writes_todo = 0;
				<span class="enscript-keyword">if</span> (error &amp;&amp; (slp-&gt;ns_wgtime || (slp-&gt;ns_flag &amp; SLP_DOWRITES))) {
					microuptime(&amp;now);
					cur_usec = (u_quad_t)now.tv_sec * 1000000 +
						(u_quad_t)now.tv_usec;
					<span class="enscript-keyword">if</span> (slp-&gt;ns_wgtime &lt;= cur_usec) {
						error = 0;
						cacherep = RC_DOIT;
						writes_todo = 1;
					}
					slp-&gt;ns_flag &amp;= ~SLP_DOWRITES;
				}
				nfsd-&gt;nfsd_flag |= NFSD_REQINPROG;
			}
			lck_rw_done(&amp;slp-&gt;ns_rwlock);
		}
		<span class="enscript-keyword">if</span> (error || (slp &amp;&amp; !(slp-&gt;ns_flag &amp; SLP_VALID))) {
			<span class="enscript-keyword">if</span> (nd) {
				nfsm_chain_cleanup(&amp;nd-&gt;nd_nmreq);
				<span class="enscript-keyword">if</span> (nd-&gt;nd_nam2)
					mbuf_freem(nd-&gt;nd_nam2);
				<span class="enscript-keyword">if</span> (IS_VALID_CRED(nd-&gt;nd_cr))
					kauth_cred_unref(&amp;nd-&gt;nd_cr);
				<span class="enscript-keyword">if</span> (nd-&gt;nd_gss_context)
					nfs_gss_svc_ctx_deref(nd-&gt;nd_gss_context);
				FREE_ZONE(nd, <span class="enscript-keyword">sizeof</span>(*nd), M_NFSRVDESC);
				nd = NULL;
			}
			nfsd-&gt;nfsd_slp = NULL;
			nfsd-&gt;nfsd_flag &amp;= ~NFSD_REQINPROG;
			<span class="enscript-keyword">if</span> (slp)
				nfsrv_slpderef(slp);
			<span class="enscript-keyword">if</span> (nfsd_thread_max &lt;= 0)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (nd) {
		    microuptime(&amp;nd-&gt;nd_starttime);
		    <span class="enscript-keyword">if</span> (nd-&gt;nd_nam2)
			nd-&gt;nd_nam = nd-&gt;nd_nam2;
		    <span class="enscript-keyword">else</span>
			nd-&gt;nd_nam = slp-&gt;ns_nam;

		    cacherep = nfsrv_getcache(nd, slp, &amp;mrep);

		    <span class="enscript-keyword">if</span> (nfsrv_require_resv_port) {
			<span class="enscript-comment">/* Check if source port is a reserved port */</span>
			in_port_t port = 0;
			<span class="enscript-type">struct</span> sockaddr *saddr = mbuf_data(nd-&gt;nd_nam);

			<span class="enscript-keyword">if</span> (saddr-&gt;sa_family == AF_INET)
				port = ntohs(((<span class="enscript-type">struct</span> sockaddr_in*)saddr)-&gt;sin_port);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (saddr-&gt;sa_family == AF_INET6)
				port = ntohs(((<span class="enscript-type">struct</span> sockaddr_in6*)saddr)-&gt;sin6_port);
			<span class="enscript-keyword">if</span> ((port &gt;= IPPORT_RESERVED) &amp;&amp; (nd-&gt;nd_procnum != NFSPROC_NULL)) {
			    nd-&gt;nd_procnum = NFSPROC_NOOP;
			    nd-&gt;nd_repstat = (NFSERR_AUTHERR | AUTH_TOOWEAK);
			    cacherep = RC_DOIT;
			}
		    }

		}

		<span class="enscript-comment">/*
		 * Loop to get all the write RPC replies that have been
		 * gathered together.
		 */</span>
		<span class="enscript-keyword">do</span> {
		    <span class="enscript-keyword">switch</span> (cacherep) {
		    <span class="enscript-keyword">case</span> <span class="enscript-reference">RC_DOIT</span>:
			<span class="enscript-keyword">if</span> (nd &amp;&amp; (nd-&gt;nd_vers == NFS_VER3))
			    procrastinate = nfsrv_wg_delay_v3;
			<span class="enscript-keyword">else</span>
			    procrastinate = nfsrv_wg_delay;
			lck_rw_lock_shared(&amp;nfsrv_export_rwlock);
			context.vc_ucred = NULL;
			<span class="enscript-keyword">if</span> (writes_todo || ((nd-&gt;nd_procnum == NFSPROC_WRITE) &amp;&amp; (procrastinate &gt; 0)))
				error = nfsrv_writegather(&amp;nd, slp, &amp;context, &amp;mrep);
			<span class="enscript-keyword">else</span>
				error = (*(nfsrv_procs[nd-&gt;nd_procnum]))(nd, slp, &amp;context, &amp;mrep);
			lck_rw_done(&amp;nfsrv_export_rwlock);
			<span class="enscript-keyword">if</span> (mrep == NULL) {
				<span class="enscript-comment">/*
				 * If this is a stream socket and we are not going
				 * to send a reply we better close the connection
				 * so the client doesn't hang.
				 */</span>
				<span class="enscript-keyword">if</span> (error &amp;&amp; slp-&gt;ns_sotype == SOCK_STREAM) {
					lck_rw_lock_exclusive(&amp;slp-&gt;ns_rwlock);
					nfsrv_zapsock(slp);
					lck_rw_done(&amp;slp-&gt;ns_rwlock);
					printf(<span class="enscript-string">&quot;NFS server: NULL reply from proc = %d error = %d\n&quot;</span>,
						nd-&gt;nd_procnum, error);
				}
				<span class="enscript-keyword">break</span>;

			}
			<span class="enscript-keyword">if</span> (error) {
				OSAddAtomic64(1, &amp;nfsstats.srv_errs);
				nfsrv_updatecache(nd, FALSE, mrep);
				<span class="enscript-keyword">if</span> (nd-&gt;nd_nam2) {
					mbuf_freem(nd-&gt;nd_nam2);
					nd-&gt;nd_nam2 = NULL;
				}
				<span class="enscript-keyword">break</span>;
			}
			OSAddAtomic64(1, &amp;nfsstats.srvrpccnt[nd-&gt;nd_procnum]);
			nfsrv_updatecache(nd, TRUE, mrep);
			<span class="enscript-comment">/* FALLTHRU */</span>

		    <span class="enscript-keyword">case</span> <span class="enscript-reference">RC_REPLY</span>:
			<span class="enscript-keyword">if</span> (nd-&gt;nd_gss_mb != NULL) {	<span class="enscript-comment">// It's RPCSEC_GSS
</span>				<span class="enscript-comment">/*
				 * Need to checksum or encrypt the reply
				 */</span>
				error = nfs_gss_svc_protect_reply(nd, mrep);
				<span class="enscript-keyword">if</span> (error) {
				    	mbuf_freem(mrep);
					<span class="enscript-keyword">break</span>;
				}
			}

			<span class="enscript-comment">/*
			 * Get the total size of the reply
			 */</span>
			m = mrep;
			siz = 0;
			<span class="enscript-keyword">while</span> (m) {
				siz += mbuf_len(m);
				m = mbuf_next(m);
			}
			<span class="enscript-keyword">if</span> (siz &lt;= 0 || siz &gt; NFS_MAXPACKET) {
				printf(<span class="enscript-string">&quot;mbuf siz=%d\n&quot;</span>,siz);
				panic(<span class="enscript-string">&quot;Bad nfs svc reply&quot;</span>);
			}
			m = mrep;
			mbuf_pkthdr_setlen(m, siz);
			error = mbuf_pkthdr_setrcvif(m, NULL);
			<span class="enscript-keyword">if</span> (error)
				panic(<span class="enscript-string">&quot;nfsd setrcvif failed: %d&quot;</span>, error);
			<span class="enscript-comment">/*
			 * For stream protocols, prepend a Sun RPC
			 * Record Mark.
			 */</span>
			<span class="enscript-keyword">if</span> (slp-&gt;ns_sotype == SOCK_STREAM) {
				error = mbuf_prepend(&amp;m, NFSX_UNSIGNED, MBUF_WAITOK);
				<span class="enscript-keyword">if</span> (!error)
					*(u_int32_t*)mbuf_data(m) = htonl(0x80000000 | siz);
			}
			<span class="enscript-keyword">if</span> (!error) {
				<span class="enscript-keyword">if</span> (slp-&gt;ns_flag &amp; SLP_VALID) {
				    error = nfsrv_send(slp, nd-&gt;nd_nam2, m);
				} <span class="enscript-keyword">else</span> {
				    error = EPIPE;
				    mbuf_freem(m);
				}
			} <span class="enscript-keyword">else</span> {
				mbuf_freem(m);
			}
			mrep = NULL;
			<span class="enscript-keyword">if</span> (nd-&gt;nd_nam2) {
				mbuf_freem(nd-&gt;nd_nam2);
				nd-&gt;nd_nam2 = NULL;
			}
			<span class="enscript-keyword">if</span> (error == EPIPE) {
				lck_rw_lock_exclusive(&amp;slp-&gt;ns_rwlock);
				nfsrv_zapsock(slp);
				lck_rw_done(&amp;slp-&gt;ns_rwlock);
			}
			<span class="enscript-keyword">if</span> (error == EINTR || error == ERESTART) {
				nfsm_chain_cleanup(&amp;nd-&gt;nd_nmreq);
				<span class="enscript-keyword">if</span> (IS_VALID_CRED(nd-&gt;nd_cr))
					kauth_cred_unref(&amp;nd-&gt;nd_cr);
				<span class="enscript-keyword">if</span> (nd-&gt;nd_gss_context)
					nfs_gss_svc_ctx_deref(nd-&gt;nd_gss_context);
				FREE_ZONE(nd, <span class="enscript-keyword">sizeof</span>(*nd), M_NFSRVDESC);
				nfsrv_slpderef(slp);
				lck_mtx_lock(nfsd_mutex);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			<span class="enscript-keyword">break</span>;
		    <span class="enscript-keyword">case</span> <span class="enscript-reference">RC_DROPIT</span>:
			mbuf_freem(nd-&gt;nd_nam2);
			nd-&gt;nd_nam2 = NULL;
			<span class="enscript-keyword">break</span>;
		    };
		    opcnt++;
		    <span class="enscript-keyword">if</span> (nd) {
			nfsm_chain_cleanup(&amp;nd-&gt;nd_nmreq);
			<span class="enscript-keyword">if</span> (nd-&gt;nd_nam2)
				mbuf_freem(nd-&gt;nd_nam2);
			<span class="enscript-keyword">if</span> (IS_VALID_CRED(nd-&gt;nd_cr))
				kauth_cred_unref(&amp;nd-&gt;nd_cr);
			<span class="enscript-keyword">if</span> (nd-&gt;nd_gss_context)
				nfs_gss_svc_ctx_deref(nd-&gt;nd_gss_context);
			FREE_ZONE(nd, <span class="enscript-keyword">sizeof</span>(*nd), M_NFSRVDESC);
			nd = NULL;
		    }

		    <span class="enscript-comment">/*
		     * Check to see if there are outstanding writes that
		     * need to be serviced.
		     */</span>
		    writes_todo = 0;
		    <span class="enscript-keyword">if</span> (slp-&gt;ns_wgtime) {
			microuptime(&amp;now);
			cur_usec = (u_quad_t)now.tv_sec * 1000000 +
				(u_quad_t)now.tv_usec;
			<span class="enscript-keyword">if</span> (slp-&gt;ns_wgtime &lt;= cur_usec) {
			    cacherep = RC_DOIT;
			    writes_todo = 1;
			}
		    }
		} <span class="enscript-keyword">while</span> (writes_todo);

		nd = NULL;
		<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;nfsrv_sockwait) &amp;&amp; (opcnt &lt; 8)) {
			lck_rw_lock_exclusive(&amp;slp-&gt;ns_rwlock);
			error = nfsrv_dorec(slp, nfsd, &amp;nd);
			<span class="enscript-keyword">if</span> (error == EINVAL) {	<span class="enscript-comment">// RPCSEC_GSS drop
</span>				<span class="enscript-keyword">if</span> (slp-&gt;ns_sotype == SOCK_STREAM)
					nfsrv_zapsock(slp); <span class="enscript-comment">// drop connection
</span>			}
			lck_rw_done(&amp;slp-&gt;ns_rwlock);
		}
		<span class="enscript-keyword">if</span> (!nd) {
			<span class="enscript-comment">/* drop our reference on the socket */</span>
			nfsd-&gt;nfsd_flag &amp;= ~NFSD_REQINPROG;
			nfsd-&gt;nfsd_slp = NULL;
			nfsrv_slpderef(slp);
		}
	}
	lck_mtx_lock(nfsd_mutex);
<span class="enscript-reference">done</span>:
	TAILQ_REMOVE(&amp;nfsd_head, nfsd, nfsd_chain);
	FREE(nfsd, M_NFSD);
	<span class="enscript-keyword">if</span> (--nfsd_thread_count == 0)
		nfsrv_cleanup();
	lck_mtx_unlock(nfsd_mutex);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfssvc_export</span>(user_addr_t argp)
{
	<span class="enscript-type">int</span> error = 0, is_64bit;
	<span class="enscript-type">struct</span> user_nfs_export_args unxa;
	vfs_context_t ctx = vfs_context_current();

	is_64bit = IS_64BIT_PROCESS(vfs_context_proc(ctx));

	<span class="enscript-comment">/* copy in pointers to path and export args */</span>
	<span class="enscript-keyword">if</span> (is_64bit) {
		error = copyin(argp, (caddr_t)&amp;unxa, <span class="enscript-keyword">sizeof</span>(unxa));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> nfs_export_args tnxa;
		error = copyin(argp, (caddr_t)&amp;tnxa, <span class="enscript-keyword">sizeof</span>(tnxa));
		<span class="enscript-keyword">if</span> (error == 0) {
			<span class="enscript-comment">/* munge into LP64 version of nfs_export_args structure */</span>
			unxa.nxa_fsid = tnxa.nxa_fsid;
			unxa.nxa_expid = tnxa.nxa_expid;
			unxa.nxa_fspath = CAST_USER_ADDR_T(tnxa.nxa_fspath);
			unxa.nxa_exppath = CAST_USER_ADDR_T(tnxa.nxa_exppath);
			unxa.nxa_flags = tnxa.nxa_flags;
			unxa.nxa_netcount = tnxa.nxa_netcount;
			unxa.nxa_nets = CAST_USER_ADDR_T(tnxa.nxa_nets);
		}
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	error = nfsrv_export(&amp;unxa, ctx);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Shut down a socket associated with an nfsrv_sock structure.
 * Should be called with the send lock set, if required.
 * The trick here is to increment the sref at the start, so that the nfsds
 * will stop using it and clear ns_flag at the end so that it will not be
 * reassigned during cleanup.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_zapsock</span>(<span class="enscript-type">struct</span> nfsrv_sock *slp)
{
	socket_t so;

	<span class="enscript-keyword">if</span> ((slp-&gt;ns_flag &amp; SLP_VALID) == 0)
		<span class="enscript-keyword">return</span>;
	slp-&gt;ns_flag &amp;= ~SLP_ALLFLAGS;

	so = slp-&gt;ns_so;
	<span class="enscript-keyword">if</span> (so == NULL)
		<span class="enscript-keyword">return</span>;

	sock_setupcall(so, NULL, NULL);
	sock_shutdown(so, SHUT_RDWR);

	<span class="enscript-comment">/*
	 * Remove from the up-call queue
	 */</span>
	nfsrv_uc_dequeue(slp);
}

<span class="enscript-comment">/*
 * cleanup and release a server socket structure.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_slpfree</span>(<span class="enscript-type">struct</span> nfsrv_sock *slp)
{
	<span class="enscript-type">struct</span> nfsrv_descript *nwp, *nnwp;

	<span class="enscript-keyword">if</span> (slp-&gt;ns_so) {
		sock_release(slp-&gt;ns_so);
		slp-&gt;ns_so = NULL;
	}
	<span class="enscript-keyword">if</span> (slp-&gt;ns_nam)
		mbuf_free(slp-&gt;ns_nam);
	<span class="enscript-keyword">if</span> (slp-&gt;ns_raw)
		mbuf_freem(slp-&gt;ns_raw);
	<span class="enscript-keyword">if</span> (slp-&gt;ns_rec)
		mbuf_freem(slp-&gt;ns_rec);
	<span class="enscript-keyword">if</span> (slp-&gt;ns_frag)
		mbuf_freem(slp-&gt;ns_frag);
	slp-&gt;ns_nam = slp-&gt;ns_raw = slp-&gt;ns_rec = slp-&gt;ns_frag = NULL;
	slp-&gt;ns_reccnt = 0;

	<span class="enscript-keyword">for</span> (nwp = slp-&gt;ns_tq.lh_first; nwp; nwp = nnwp) {
		nnwp = nwp-&gt;nd_tq.le_next;
		LIST_REMOVE(nwp, nd_tq);
		nfsm_chain_cleanup(&amp;nwp-&gt;nd_nmreq);
		<span class="enscript-keyword">if</span> (nwp-&gt;nd_mrep)
			mbuf_freem(nwp-&gt;nd_mrep);
		<span class="enscript-keyword">if</span> (nwp-&gt;nd_nam2)
			mbuf_freem(nwp-&gt;nd_nam2);
		<span class="enscript-keyword">if</span> (IS_VALID_CRED(nwp-&gt;nd_cr))
			kauth_cred_unref(&amp;nwp-&gt;nd_cr);
		<span class="enscript-keyword">if</span> (nwp-&gt;nd_gss_context)
			nfs_gss_svc_ctx_deref(nwp-&gt;nd_gss_context);
		FREE_ZONE(nwp, <span class="enscript-keyword">sizeof</span>(*nwp), M_NFSRVDESC);
	}
	LIST_INIT(&amp;slp-&gt;ns_tq);

	lck_rw_destroy(&amp;slp-&gt;ns_rwlock, nfsrv_slp_rwlock_group);
	lck_mtx_destroy(&amp;slp-&gt;ns_wgmutex, nfsrv_slp_mutex_group);
	FREE(slp, M_NFSSVC);
}

<span class="enscript-comment">/*
 * Derefence a server socket structure. If it has no more references and
 * is no longer valid, you can throw it away.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_slpderef_locked</span>(<span class="enscript-type">struct</span> nfsrv_sock *slp)
{
	lck_rw_lock_exclusive(&amp;slp-&gt;ns_rwlock);
	slp-&gt;ns_sref--;

	<span class="enscript-keyword">if</span> (slp-&gt;ns_sref || (slp-&gt;ns_flag &amp; SLP_VALID)) {
		<span class="enscript-keyword">if</span> ((slp-&gt;ns_flag &amp; SLP_QUEUED) &amp;&amp; !(slp-&gt;ns_flag &amp; SLP_WORKTODO)) {
			<span class="enscript-comment">/* remove socket from queue since there's no work */</span>
			<span class="enscript-keyword">if</span> (slp-&gt;ns_flag &amp; SLP_WAITQ)
				TAILQ_REMOVE(&amp;nfsrv_sockwait, slp, ns_svcq);
			<span class="enscript-keyword">else</span>
				TAILQ_REMOVE(&amp;nfsrv_sockwork, slp, ns_svcq);
			slp-&gt;ns_flag &amp;= ~SLP_QUEUED;
		}
		lck_rw_done(&amp;slp-&gt;ns_rwlock);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* This socket is no longer valid, so we'll get rid of it */</span>

	<span class="enscript-keyword">if</span> (slp-&gt;ns_flag &amp; SLP_QUEUED) {
		<span class="enscript-keyword">if</span> (slp-&gt;ns_flag &amp; SLP_WAITQ)
			TAILQ_REMOVE(&amp;nfsrv_sockwait, slp, ns_svcq);
		<span class="enscript-keyword">else</span>
			TAILQ_REMOVE(&amp;nfsrv_sockwork, slp, ns_svcq);
		slp-&gt;ns_flag &amp;= ~SLP_QUEUED;
	}
	lck_rw_done(&amp;slp-&gt;ns_rwlock);

	TAILQ_REMOVE(&amp;nfsrv_socklist, slp, ns_chain);
	<span class="enscript-keyword">if</span> (slp-&gt;ns_sotype == SOCK_STREAM)
		nfsrv_sock_tcp_cnt--;

	<span class="enscript-comment">/* now remove from the write gather socket list */</span> 
	<span class="enscript-keyword">if</span> (slp-&gt;ns_wgq.tqe_next != SLPNOLIST) {
		TAILQ_REMOVE(&amp;nfsrv_sockwg, slp, ns_wgq);
		slp-&gt;ns_wgq.tqe_next = SLPNOLIST;
	}
	nfsrv_slpfree(slp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_slpderef</span>(<span class="enscript-type">struct</span> nfsrv_sock *slp)
{
	lck_mtx_lock(nfsd_mutex);
	nfsrv_slpderef_locked(slp);
	lck_mtx_unlock(nfsd_mutex);
}

<span class="enscript-comment">/*
 * Check periodically for idle sockest if needed and
 * zap them.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_idlesock_timer</span>(__unused <span class="enscript-type">void</span> *param0, __unused <span class="enscript-type">void</span> *param1)
{
	<span class="enscript-type">struct</span> nfsrv_sock *slp, *tslp;
	<span class="enscript-type">struct</span> timeval now;
	time_t time_to_wait = nfsrv_sock_idle_timeout;

	microuptime(&amp;now);
	lck_mtx_lock(nfsd_mutex);

	<span class="enscript-comment">/* Turn off the timer if we're suppose to and get out */</span>
	<span class="enscript-keyword">if</span> (nfsrv_sock_idle_timeout &lt; NFSD_MIN_IDLE_TIMEOUT)
	    nfsrv_sock_idle_timeout = 0;
	<span class="enscript-keyword">if</span> ((nfsrv_sock_tcp_cnt &lt;= 2 * nfsd_thread_max) || (nfsrv_sock_idle_timeout == 0)) {
		nfsrv_idlesock_timer_on = 0;
		lck_mtx_unlock(nfsd_mutex);
		<span class="enscript-keyword">return</span>;
	}

	TAILQ_FOREACH_SAFE(slp, &amp;nfsrv_socklist, ns_chain, tslp) {
		lck_rw_lock_exclusive(&amp;slp-&gt;ns_rwlock);
		<span class="enscript-comment">/* Skip udp and referenced sockets */</span>
		<span class="enscript-keyword">if</span> (slp-&gt;ns_sotype == SOCK_DGRAM || slp-&gt;ns_sref) {
			lck_rw_done(&amp;slp-&gt;ns_rwlock);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/*
		 * If this is the first non-referenced socket that hasn't idle out,
		 * use its time stamp to calculate the earlist time in the future
		 * to start the next invocation of the timer. Since the nfsrv_socklist
		 * is sorted oldest access to newest. Once we find the first one,
		 * we're done and break out of the loop.
		 */</span>
		<span class="enscript-keyword">if</span> (((slp-&gt;ns_timestamp + nfsrv_sock_idle_timeout)  &gt;  now.tv_sec) ||
			nfsrv_sock_tcp_cnt &lt;= 2 * nfsd_thread_max) {
			time_to_wait -= now.tv_sec - slp-&gt;ns_timestamp;
			<span class="enscript-keyword">if</span> (time_to_wait &lt; 1)
				time_to_wait = 1;
			lck_rw_done(&amp;slp-&gt;ns_rwlock);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		 * Bump the ref count. nfsrv_slpderef below will destroy
		 * the socket, since nfsrv_zapsock has closed it.
		 */</span>
		slp-&gt;ns_sref++;
		nfsrv_zapsock(slp);
		lck_rw_done(&amp;slp-&gt;ns_rwlock);
		nfsrv_slpderef_locked(slp);
	}

	<span class="enscript-comment">/* Start ourself back up */</span>
	nfs_interval_timer_start(nfsrv_idlesock_timer_call, time_to_wait * 1000);
	<span class="enscript-comment">/* Remember when the next timer will fire for nfssvc_addsock. */</span>
	nfsrv_idlesock_timer_on = now.tv_sec + time_to_wait;
	lck_mtx_unlock(nfsd_mutex);
}

<span class="enscript-comment">/*
 * Clean up the data structures for the server.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_cleanup</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> nfsrv_sock *slp, *nslp;
	<span class="enscript-type">struct</span> timeval now;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-type">struct</span> nfsrv_fmod *fp, *nfp;
	<span class="enscript-type">int</span> i;
#<span class="enscript-reference">endif</span>

	microuptime(&amp;now);
	<span class="enscript-keyword">for</span> (slp = TAILQ_FIRST(&amp;nfsrv_socklist); slp != 0; slp = nslp) {
		nslp = TAILQ_NEXT(slp, ns_chain);
		lck_rw_lock_exclusive(&amp;slp-&gt;ns_rwlock);
		slp-&gt;ns_sref++;
		<span class="enscript-keyword">if</span> (slp-&gt;ns_flag &amp; SLP_VALID)
			nfsrv_zapsock(slp);
		lck_rw_done(&amp;slp-&gt;ns_rwlock);
		nfsrv_slpderef_locked(slp);
	}
#
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-comment">/*
	 * Flush pending file write fsevents
	 */</span>
	lck_mtx_lock(nfsrv_fmod_mutex);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; NFSRVFMODHASHSZ; i++) {
		<span class="enscript-keyword">for</span> (fp = LIST_FIRST(&amp;nfsrv_fmod_hashtbl[i]); fp; fp = nfp) {
			<span class="enscript-comment">/*
			 * Fire off the content modified fsevent for each
			 * entry, remove it from the list, and free it.
			 */</span>
			<span class="enscript-keyword">if</span> (nfsrv_fsevents_enabled) {
				fp-&gt;fm_context.vc_thread = current_thread();
				add_fsevent(FSE_CONTENT_MODIFIED, &amp;fp-&gt;fm_context,
						FSE_ARG_VNODE, fp-&gt;fm_vp,
						FSE_ARG_DONE);
			}
			vnode_put(fp-&gt;fm_vp);
			kauth_cred_unref(&amp;fp-&gt;fm_context.vc_ucred);
			nfp = LIST_NEXT(fp, fm_link);
			LIST_REMOVE(fp, fm_link);
			FREE(fp, M_TEMP);
		}
	}
	nfsrv_fmod_pending = 0;
	lck_mtx_unlock(nfsrv_fmod_mutex);
#<span class="enscript-reference">endif</span>

	nfsrv_uc_cleanup();     <span class="enscript-comment">/* Stop nfs socket up-call threads */</span>
	
	nfs_gss_svc_cleanup();	<span class="enscript-comment">/* Remove any RPCSEC_GSS contexts */</span>

	nfsrv_cleancache();	<span class="enscript-comment">/* And clear out server cache */</span>

	nfsrv_udpsock = NULL;
	nfsrv_udp6sock = NULL;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFS_NOSERVER */</span>
</pre>
<hr />
</body></html>