<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nfs_serv.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nfs_serv.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc.  All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfs_serv.c	8.7 (Berkeley) 5/14/95
 * FreeBSD-Id: nfs_serv.c,v 1.52 1997/10/28 15:59:05 bde Exp $
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dirent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fsevents.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vmparam.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/rpcv2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/xdr_subs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsm_subs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsrvcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_gss.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>

<span class="enscript-comment">/*
 * NFS server globals
 */</span>

<span class="enscript-type">int</span> nfsd_thread_count = 0;
<span class="enscript-type">int</span> nfsd_thread_max = 0;
lck_grp_t *nfsd_lck_grp;
lck_mtx_t *nfsd_mutex;
<span class="enscript-type">struct</span> nfsd_head nfsd_head, nfsd_queue;

lck_grp_t *nfsrv_slp_rwlock_group;
lck_grp_t *nfsrv_slp_mutex_group;
<span class="enscript-type">struct</span> nfsrv_sockhead nfsrv_socklist, nfsrv_sockwg,
			nfsrv_sockwait, nfsrv_sockwork;
<span class="enscript-type">struct</span> nfsrv_sock *nfsrv_udpsock = NULL;
<span class="enscript-type">struct</span> nfsrv_sock *nfsrv_udp6sock = NULL;

<span class="enscript-comment">/* NFS exports */</span>
<span class="enscript-type">struct</span> nfsrv_expfs_list nfsrv_exports;
<span class="enscript-type">struct</span> nfsrv_export_hashhead *nfsrv_export_hashtbl = NULL;
<span class="enscript-type">int</span> nfsrv_export_hash_size = NFSRVEXPHASHSZ;
u_long nfsrv_export_hash;
lck_grp_t *nfsrv_export_rwlock_group;
lck_rw_t nfsrv_export_rwlock;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
<span class="enscript-comment">/* NFS server file modification event generator */</span>
<span class="enscript-type">struct</span> nfsrv_fmod_hashhead *nfsrv_fmod_hashtbl;
u_long nfsrv_fmod_hash;
lck_grp_t *nfsrv_fmod_grp;
lck_mtx_t *nfsrv_fmod_mutex;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> nfsrv_fmod_timer_on = 0;
<span class="enscript-type">int</span> nfsrv_fsevents_enabled = 1;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* NFS server timers */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
thread_call_t	nfsrv_fmod_timer_call;
#<span class="enscript-reference">endif</span>
thread_call_t	nfsrv_idlesock_timer_call;
thread_call_t	nfsrv_wg_timer_call;
<span class="enscript-type">int</span> nfsrv_wg_timer_on;

<span class="enscript-comment">/* globals for the active user list */</span>
uint32_t nfsrv_user_stat_enabled = 1;
uint32_t nfsrv_user_stat_node_count = 0;
uint32_t nfsrv_user_stat_max_idle_sec = NFSRV_USER_STAT_DEF_IDLE_SEC;
uint32_t nfsrv_user_stat_max_nodes = NFSRV_USER_STAT_DEF_MAX_NODES;
lck_grp_t *nfsrv_active_user_mutex_group;

<span class="enscript-type">int</span> nfsrv_wg_delay = NFSRV_WGATHERDELAY * 1000;
<span class="enscript-type">int</span> nfsrv_wg_delay_v3 = 0;

<span class="enscript-type">int</span> nfsrv_async = 0;

<span class="enscript-type">int</span> <span class="enscript-function-name">nfsrv_authorize</span>(vnode_t,vnode_t,kauth_action_t,vfs_context_t,<span class="enscript-type">struct</span> nfs_export_options*,<span class="enscript-type">int</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsrv_wg_coalesce</span>(<span class="enscript-type">struct</span> nfsrv_descript *, <span class="enscript-type">struct</span> nfsrv_descript *);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfsrv_modified</span>(vnode_t, vfs_context_t);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">IOSleep</span>(<span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">safe_getpath</span>(<span class="enscript-type">struct</span> vnode *dvp, <span class="enscript-type">char</span> *leafname, <span class="enscript-type">char</span> *path, <span class="enscript-type">int</span> _len, <span class="enscript-type">int</span> *truncated_path);

<span class="enscript-comment">/*
 * Initialize the data structures for the server.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSRV_NOT_INITIALIZED</span>	0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSRV_INITIALIZING</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFSRV_INITIALIZED</span>	2
<span class="enscript-type">static</span> <span class="enscript-type">volatile</span> UInt32 nfsrv_initted = NFSRV_NOT_INITIALIZED;

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_is_initialized</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (nfsrv_initted == NFSRV_INITIALIZED);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* make sure we init only once */</span>
	<span class="enscript-keyword">if</span> (!OSCompareAndSwap(NFSRV_NOT_INITIALIZED, NFSRV_INITIALIZING, &amp;nfsrv_initted)) {
		<span class="enscript-comment">/* wait until initialization is complete */</span>
		<span class="enscript-keyword">while</span> (!nfsrv_is_initialized())
			IOSleep(500);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nfsrv_sock) &gt; NFS_SVCALLOC)
		printf(<span class="enscript-string">&quot;struct nfsrv_sock bloated (&gt; %dbytes)\n&quot;</span>,NFS_SVCALLOC);

	<span class="enscript-comment">/* init nfsd mutex */</span>
	nfsd_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;nfsd&quot;</span>, LCK_GRP_ATTR_NULL);
	nfsd_mutex = lck_mtx_alloc_init(nfsd_lck_grp, LCK_ATTR_NULL);

	<span class="enscript-comment">/* init slp rwlock */</span>
	nfsrv_slp_rwlock_group = lck_grp_alloc_init(<span class="enscript-string">&quot;nfsrv-slp-rwlock&quot;</span>, LCK_GRP_ATTR_NULL);
	nfsrv_slp_mutex_group  = lck_grp_alloc_init(<span class="enscript-string">&quot;nfsrv-slp-mutex&quot;</span>, LCK_GRP_ATTR_NULL);

	<span class="enscript-comment">/* init export data structures */</span>
	LIST_INIT(&amp;nfsrv_exports);
	nfsrv_export_rwlock_group = lck_grp_alloc_init(<span class="enscript-string">&quot;nfsrv-export-rwlock&quot;</span>, LCK_GRP_ATTR_NULL);
	lck_rw_init(&amp;nfsrv_export_rwlock, nfsrv_export_rwlock_group, LCK_ATTR_NULL);

	<span class="enscript-comment">/* init active user list mutex structures */</span>
	nfsrv_active_user_mutex_group = lck_grp_alloc_init(<span class="enscript-string">&quot;nfs-active-user-mutex&quot;</span>, LCK_GRP_ATTR_NULL);

	<span class="enscript-comment">/* init nfs server request cache mutex */</span>
	nfsrv_reqcache_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;nfsrv_reqcache&quot;</span>, LCK_GRP_ATTR_NULL);
	nfsrv_reqcache_mutex = lck_mtx_alloc_init(nfsrv_reqcache_lck_grp, LCK_ATTR_NULL);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-comment">/* init NFS server file modified event generation */</span>
	nfsrv_fmod_hashtbl = hashinit(NFSRVFMODHASHSZ, M_TEMP, &amp;nfsrv_fmod_hash);
	nfsrv_fmod_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;nfsrv_fmod&quot;</span>, LCK_GRP_ATTR_NULL);
	nfsrv_fmod_mutex = lck_mtx_alloc_init(nfsrv_fmod_grp, LCK_ATTR_NULL);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* initialize NFS server timer callouts */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	nfsrv_fmod_timer_call = thread_call_allocate(nfsrv_fmod_timer, NULL);
#<span class="enscript-reference">endif</span>
	nfsrv_idlesock_timer_call = thread_call_allocate(nfsrv_idlesock_timer, NULL);
	nfsrv_wg_timer_call = thread_call_allocate(nfsrv_wg_timer, NULL);

	<span class="enscript-comment">/* Init server data structures */</span>
	TAILQ_INIT(&amp;nfsrv_socklist);
	TAILQ_INIT(&amp;nfsrv_sockwait);
	TAILQ_INIT(&amp;nfsrv_sockwork);
	TAILQ_INIT(&amp;nfsrv_sockwg);
	TAILQ_INIT(&amp;nfsd_head);
	TAILQ_INIT(&amp;nfsd_queue);
	nfsrv_udpsock = NULL;
	nfsrv_udp6sock = NULL;

	<span class="enscript-comment">/* Setup the up-call handling */</span>
	nfsrv_uc_init();
	
	<span class="enscript-comment">/* initialization complete */</span>
	nfsrv_initted = NFSRV_INITIALIZED;
}


<span class="enscript-comment">/*
 *
 * NFS version 2 and 3 server request processing functions
 *
 * These functions take the following parameters:
 *
 *      struct nfsrv_descript *nd - the NFS request descriptor
 *      struct nfsrv_sock *slp    - the NFS socket the request came in on
 *      vfs_context_t ctx         - VFS context
 *      mbuf_t *mrepp             - pointer to hold the reply mbuf list
 *
 * These routines generally have 3 phases:
 *
 *   1 - break down and validate the RPC request in the mbuf chain
 *       provided in nd-&gt;nd_nmreq.
 *   2 - perform the vnode operations for the request
 *       (many are very similar to syscalls in vfs_syscalls.c and
 *       should therefore be kept in sync with those implementations)
 *   3 - build the RPC reply in an mbuf chain (nmrep) and return the mbuf chain
 *
 */</span>

<span class="enscript-comment">/*
 * nfs v3 access service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_access</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;
	vnode_t vp;
	<span class="enscript-type">int</span> error, attrerr;
	<span class="enscript-type">struct</span> vnode_attr vattr;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	u_int32_t nfsmode;
	kauth_action_t testaction;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;

	error = 0;
	attrerr = ENOENT;
	nfsmode = 0;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	*mrepp = NULL;
	vp = NULL;

	nfsm_chain_get_fh_ptr(error, nmreq, NFS_VER3, nfh.nfh_fhp, nfh.nfh_len);
	nfsm_chain_get_32(error, nmreq, nfsmode);
	nfsmerr_if(error);
	error = nfsrv_fhtovp(&amp;nfh, nd, &amp;vp, &amp;nx, &amp;nxo);
	nfsmerr_if(error);

	<span class="enscript-comment">/* update export stats */</span>
	NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

	<span class="enscript-comment">/* update active user stats */</span>
	nfsrv_update_user_stat(nx, nd, kauth_cred_getuid(nd-&gt;nd_cr), 1, 0, 0);

	error = nfsrv_credcheck(nd, ctx, nx, nxo);
	nfsmerr_if(error);

	<span class="enscript-comment">/*
	 * Each NFS mode bit is tested separately.
	 *
	 * XXX this code is nominally correct, but returns a pessimistic
	 *     rather than optimistic result.  It will be necessary to add
	 *     an NFS-specific interface to the vnode_authorize code to
	 *     obtain good performance in the optimistic mode.
	 */</span>
	<span class="enscript-keyword">if</span> (nfsmode &amp; NFS_ACCESS_READ) {
		testaction = vnode_isdir(vp) ? KAUTH_VNODE_LIST_DIRECTORY : KAUTH_VNODE_READ_DATA;
		<span class="enscript-keyword">if</span> (nfsrv_authorize(vp, NULL, testaction, ctx, nxo, 0))
			nfsmode &amp;= ~NFS_ACCESS_READ;
	}
	<span class="enscript-keyword">if</span> ((nfsmode &amp; NFS_ACCESS_LOOKUP) &amp;&amp;
	    (!vnode_isdir(vp) ||
	    nfsrv_authorize(vp, NULL, KAUTH_VNODE_SEARCH, ctx, nxo, 0)))
		nfsmode &amp;= ~NFS_ACCESS_LOOKUP;
	<span class="enscript-keyword">if</span> (nfsmode &amp; NFS_ACCESS_MODIFY) {
		<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
			testaction =
			    KAUTH_VNODE_ADD_FILE |
			    KAUTH_VNODE_ADD_SUBDIRECTORY |
			    KAUTH_VNODE_DELETE_CHILD;
		} <span class="enscript-keyword">else</span> {
			testaction =
			    KAUTH_VNODE_WRITE_DATA;
		}
		<span class="enscript-keyword">if</span> (nfsrv_authorize(vp, NULL, testaction, ctx, nxo, 0))
			nfsmode &amp;= ~NFS_ACCESS_MODIFY;
	}
	<span class="enscript-keyword">if</span> (nfsmode &amp; NFS_ACCESS_EXTEND) {
		<span class="enscript-keyword">if</span> (vnode_isdir(vp)) {
			testaction =
			    KAUTH_VNODE_ADD_FILE |
			    KAUTH_VNODE_ADD_SUBDIRECTORY;
		} <span class="enscript-keyword">else</span> {
			testaction =
			    KAUTH_VNODE_WRITE_DATA |
			    KAUTH_VNODE_APPEND_DATA;
		}
		<span class="enscript-keyword">if</span> (nfsrv_authorize(vp, NULL, testaction, ctx, nxo, 0))
			nfsmode &amp;= ~NFS_ACCESS_EXTEND;
	}

	<span class="enscript-comment">/*
	 * Note concerning NFS_ACCESS_DELETE:
	 * For hard links, the answer may be wrong if the vnode
	 * has multiple parents with different permissions.
	 * Also, some clients (e.g. MacOSX 10.3) may incorrectly
	 * interpret the missing/cleared DELETE bit.
	 * So we'll just leave the DELETE bit alone.  At worst,
	 * we're telling the client it might be able to do
	 * something it really can't.
	 */</span>

	<span class="enscript-keyword">if</span> ((nfsmode &amp; NFS_ACCESS_EXECUTE) &amp;&amp;
	    (vnode_isdir(vp) ||
	    nfsrv_authorize(vp, NULL, KAUTH_VNODE_EXECUTE, ctx, nxo, 0)))
		nfsmode &amp;= ~NFS_ACCESS_EXECUTE;

	<span class="enscript-comment">/* get postop attributes */</span>
	nfsm_srv_vattr_init(&amp;vattr, NFS_VER3);
	attrerr = vnode_getattr(vp, &amp;vattr, ctx);

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_POSTOPATTR(NFS_VER3) + NFSX_UNSIGNED);
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, attrerr, &amp;vattr);
	<span class="enscript-keyword">if</span> (!nd-&gt;nd_repstat)
		nfsm_chain_add_32(error, &amp;nmrep, nfsmode);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs getattr service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_getattr</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;
	<span class="enscript-type">struct</span> vnode_attr vattr;
	vnode_t vp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;

	error = 0;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	*mrepp = NULL;
	vp = NULL;

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	nfsmerr_if(error);
	error = nfsrv_fhtovp(&amp;nfh, nd, &amp;vp, &amp;nx, &amp;nxo);
	nfsmerr_if(error);

	<span class="enscript-comment">/* update export stats */</span>
	NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

	<span class="enscript-comment">/* update active user stats */</span>
	nfsrv_update_user_stat(nx, nd, kauth_cred_getuid(nd-&gt;nd_cr), 1, 0, 0);

	error = nfsrv_credcheck(nd, ctx, nx, nxo);
	nfsmerr_if(error);

	nfsm_srv_vattr_init(&amp;vattr, nd-&gt;nd_vers);
	error = vnode_getattr(vp, &amp;vattr, ctx);
	vnode_put(vp);
	vp = NULL;

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_FATTR(nd-&gt;nd_vers));
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_if(nd-&gt;nd_repstat);
	error = nfsm_chain_add_fattr(nd, &amp;nmrep, &amp;vattr);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs setattr service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_setattr</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;
	<span class="enscript-type">struct</span> vnode_attr preattr, postattr;
	<span class="enscript-type">struct</span> vnode_attr vattr, *vap = &amp;vattr;
	vnode_t vp;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	<span class="enscript-type">int</span> error, preattrerr, postattrerr, gcheck;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> timespec guard = { 0, 0 };
	kauth_action_t action;
	uid_t saved_uid;

	error = 0;
	preattrerr = postattrerr = ENOENT;
	gcheck = 0;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	*mrepp = NULL;
	vp = NULL;

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	nfsmerr_if(error);

	VATTR_INIT(vap);
	error = nfsm_chain_get_sattr(nd, nmreq, vap);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_chain_get_32(error, nmreq, gcheck);
		<span class="enscript-keyword">if</span> (gcheck)
			nfsm_chain_get_time(error, nmreq, nd-&gt;nd_vers, guard.tv_sec, guard.tv_nsec);
	}
	nfsmerr_if(error);

	<span class="enscript-comment">/*
	 * Save the original credential UID in case they are
	 * mapped and we need to map the IDs in the attributes.
	 */</span>
	saved_uid = kauth_cred_getuid(nd-&gt;nd_cr);

	<span class="enscript-comment">/*
	 * Now that we have all the fields, lets do it.
	 */</span>
	error = nfsrv_fhtovp(&amp;nfh, nd, &amp;vp, &amp;nx, &amp;nxo);
	nfsmerr_if(error);

	<span class="enscript-comment">/* update export stats */</span>
	NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

	<span class="enscript-comment">/* update active user stats */</span>
	nfsrv_update_user_stat(nx, nd, saved_uid, 1, 0, 0);

	error = nfsrv_credcheck(nd, ctx, nx, nxo);
	nfsmerr_if(error);

	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_srv_pre_vattr_init(&amp;preattr);
		error = preattrerr = vnode_getattr(vp, &amp;preattr, ctx);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; gcheck &amp;&amp; VATTR_IS_SUPPORTED(&amp;preattr, va_change_time) &amp;&amp;
			(preattr.va_change_time.tv_sec != guard.tv_sec ||
			 preattr.va_change_time.tv_nsec != guard.tv_nsec))
			error = NFSERR_NOT_SYNC;
		<span class="enscript-keyword">if</span> (!preattrerr &amp;&amp; !VATTR_ALL_SUPPORTED(&amp;preattr))
			preattrerr = ENOENT;
		nfsmerr_if(error);
	}

	<span class="enscript-comment">/*
	 * If the credentials were mapped, we should
	 * map the same values in the attributes.
	 */</span>
	<span class="enscript-keyword">if</span> ((vap-&gt;va_uid == saved_uid) &amp;&amp; (kauth_cred_getuid(nd-&gt;nd_cr) != saved_uid)) {
		<span class="enscript-type">int</span> ismember;
		VATTR_SET(vap, va_uid, kauth_cred_getuid(nd-&gt;nd_cr));
		<span class="enscript-keyword">if</span> (kauth_cred_ismember_gid(nd-&gt;nd_cr, vap-&gt;va_gid, &amp;ismember) || !ismember)
			VATTR_SET(vap, va_gid, kauth_cred_getgid(nd-&gt;nd_cr));
	}

	<span class="enscript-comment">/* Authorize the attribute changes.  */</span>
	error = vnode_authattr(vp, vap, &amp;action, ctx);
	<span class="enscript-keyword">if</span> (!error)
		error = nfsrv_authorize(vp, NULL, action, ctx, nxo, 0);

	<span class="enscript-comment">/* set the new attributes */</span>
	<span class="enscript-keyword">if</span> (!error)
		error = vnode_setattr(vp, vap, ctx);

	<span class="enscript-keyword">if</span> (!error || (nd-&gt;nd_vers == NFS_VER3)) {
		nfsm_srv_vattr_init(&amp;postattr, nd-&gt;nd_vers);
		postattrerr = vnode_getattr(vp, &amp;postattr, ctx);
		<span class="enscript-keyword">if</span> (!error)
			error = postattrerr;
	}

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);

	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_WCCORFATTR(nd-&gt;nd_vers));
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
		nfsm_chain_add_wcc_data(error, nd, &amp;nmrep,
			preattrerr, &amp;preattr, postattrerr, &amp;postattr);
	<span class="enscript-keyword">else</span>
		error = nfsm_chain_add_fattr(nd, &amp;nmrep, &amp;postattr);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs lookup rpc
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_lookup</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> nameidata ni;
	vnode_t vp, dirp = NULL;
	<span class="enscript-type">struct</span> nfs_filehandle dnfh, nfh;
	<span class="enscript-type">struct</span> nfs_export *nx = NULL;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	<span class="enscript-type">int</span> error, attrerr, dirattrerr, isdotdot;
	uint32_t len = 0;
	uid_t saved_uid;
	<span class="enscript-type">struct</span> vnode_attr va, dirattr, *vap = &amp;va;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	attrerr = dirattrerr = ENOENT;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	saved_uid = kauth_cred_getuid(nd-&gt;nd_cr);

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, dnfh.nfh_fhp, dnfh.nfh_len);
	nfsm_chain_get_32(error, nmreq, len);
	nfsm_name_len_check(error, nd, len);
	nfsmerr_if(error);

	ni.ni_cnd.cn_nameiop = LOOKUP;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	ni.ni_op = OP_LOOKUP;
#<span class="enscript-reference">endif</span>
	ni.ni_cnd.cn_flags = LOCKLEAF;
	error = nfsm_chain_get_path_namei(nmreq, len, &amp;ni);
	isdotdot = ((len == 2) &amp;&amp; (ni.ni_cnd.cn_pnbuf[0] == <span class="enscript-string">'.'</span>) &amp;&amp; (ni.ni_cnd.cn_pnbuf[1] == <span class="enscript-string">'.'</span>));
	<span class="enscript-keyword">if</span> (!error) {
		error = nfsrv_namei(nd, ctx, &amp;ni, &amp;dnfh, &amp;dirp, &amp;nx, &amp;nxo);
		<span class="enscript-keyword">if</span> (nx != NULL) {
			<span class="enscript-comment">/* update export stats */</span>
			NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

			<span class="enscript-comment">/* update active user stats */</span>
			nfsrv_update_user_stat(nx, nd, saved_uid, 1, 0, 0);
		}
	}

	<span class="enscript-keyword">if</span> (dirp) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
			nfsm_srv_vattr_init(&amp;dirattr, NFS_VER3);
			dirattrerr = vnode_getattr(dirp, &amp;dirattr, ctx);
		}
		vnode_put(dirp);
	}
	nfsmerr_if(error);

	nameidone(&amp;ni);

	vp = ni.ni_vp;
	error = nfsrv_vptofh(nx, nd-&gt;nd_vers, (isdotdot ? &amp;dnfh : NULL), vp, ctx, &amp;nfh);
	<span class="enscript-keyword">if</span> (!error) {
		nfsm_srv_vattr_init(vap, nd-&gt;nd_vers);
		attrerr = vnode_getattr(vp, vap, ctx);
	}
	vnode_put(vp);

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_SRVFH(nd-&gt;nd_vers, &amp;nfh) +
			NFSX_POSTOPORFATTR(nd-&gt;nd_vers) + NFSX_POSTOPATTR(nd-&gt;nd_vers));
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	<span class="enscript-keyword">if</span> (nd-&gt;nd_repstat) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
			nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, dirattrerr, &amp;dirattr);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}
	nfsm_chain_add_fh(error, &amp;nmrep, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, attrerr, vap);
		nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, dirattrerr, &amp;dirattr);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!error) {
		error = nfsm_chain_add_fattr(nd, &amp;nmrep, vap);
	}
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs readlink service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_readlink</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">int</span> error, mpcnt, tlen, len, attrerr;
	vnode_t vp;
	<span class="enscript-type">struct</span> vnode_attr vattr;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;
	mbuf_t mpath, mp;
	uio_t auio = NULL;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(4) ];
	<span class="enscript-type">char</span> *uio_bufp = &amp;uio_buf[0];
	<span class="enscript-type">int</span> uio_buflen = UIO_SIZEOF(4);

	error = 0;
	attrerr = ENOENT;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	mpath = NULL;
	vp = NULL;
	len = NFS_MAXPATHLEN;

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	nfsmerr_if(error);

	<span class="enscript-comment">/* get mbuf list to hold symlink path */</span>
	error = nfsm_mbuf_get_list(len, &amp;mpath, &amp;mpcnt);
	nfsmerr_if(error);
	<span class="enscript-keyword">if</span> (mpcnt &gt; 4) {
		uio_buflen = UIO_SIZEOF(mpcnt);
		MALLOC(uio_bufp, <span class="enscript-type">char</span>*, uio_buflen, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (!uio_bufp)
			error = ENOMEM;
		nfsmerr_if(error);
	}
	auio = uio_createwithbuffer(mpcnt, 0, UIO_SYSSPACE, UIO_READ, uio_bufp, uio_buflen);
	<span class="enscript-keyword">if</span> (!auio)
		error = ENOMEM;
	nfsmerr_if(error);

	<span class="enscript-keyword">for</span> (mp = mpath; mp; mp = mbuf_next(mp))
		uio_addiov(auio, CAST_USER_ADDR_T((caddr_t)mbuf_data(mp)), mbuf_len(mp));

	error = nfsrv_fhtovp(&amp;nfh, nd, &amp;vp, &amp;nx, &amp;nxo);
	nfsmerr_if(error);

	<span class="enscript-comment">/* update export stats */</span>
	NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

	<span class="enscript-comment">/* update active user stats */</span>
	nfsrv_update_user_stat(nx, nd, kauth_cred_getuid(nd-&gt;nd_cr), 1, 0, 0);

	error = nfsrv_credcheck(nd, ctx, nx, nxo);
	nfsmerr_if(error);

	<span class="enscript-keyword">if</span> (vnode_vtype(vp) != VLNK) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
			error = EINVAL;
		<span class="enscript-keyword">else</span>
			error = ENXIO;
	}

	<span class="enscript-keyword">if</span> (!error)
		error = nfsrv_authorize(vp, NULL, KAUTH_VNODE_READ_DATA, ctx, nxo, 0);
	<span class="enscript-keyword">if</span> (!error)
		error = VNOP_READLINK(vp, auio, ctx);
	<span class="enscript-keyword">if</span> (vp) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
			nfsm_srv_vattr_init(&amp;vattr, NFS_VER3);
			attrerr = vnode_getattr(vp, &amp;vattr, ctx);
		}
		vnode_put(vp);
		vp = NULL;
	}
	<span class="enscript-keyword">if</span> (error) {
		mbuf_freem(mpath);
		mpath = NULL;
	}

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_POSTOPATTR(nd-&gt;nd_vers) + NFSX_UNSIGNED);
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
		nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, attrerr, &amp;vattr);
	<span class="enscript-keyword">if</span> (error || nd-&gt;nd_repstat) {
		nfsm_chain_build_done(error, &amp;nmrep);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}
	<span class="enscript-keyword">if</span> (auio &amp;&amp; (uio_resid(auio) &gt; 0)) {
		len -= uio_resid(auio);
		tlen = nfsm_rndup(len);
		nfsm_adj(mpath, NFS_MAXPATHLEN-tlen, tlen-len);
	}
	nfsm_chain_add_32(error, &amp;nmrep, len);
	nfsm_chain_build_done(error, &amp;nmrep);
	nfsmout_if(error);
	error = mbuf_setnext(nmrep.nmc_mcur, mpath);
	<span class="enscript-keyword">if</span> (!error)
		mpath = NULL;
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);
	<span class="enscript-keyword">if</span> (mpath)
		mbuf_freem(mpath);
	<span class="enscript-keyword">if</span> (uio_bufp != &amp;uio_buf[0])
		FREE(uio_bufp, M_TEMP);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs read service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_read</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">int</span> error, attrerr, mreadcnt;
	uint32_t reqlen, maxlen, count, len, tlen, left;
	mbuf_t mread, m;
	vnode_t vp;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	uio_t auio = NULL;
	<span class="enscript-type">char</span> *uio_bufp = NULL;
	<span class="enscript-type">struct</span> vnode_attr vattr, *vap = &amp;vattr;
	off_t off;
	uid_t saved_uid;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(0) ];
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	attrerr = ENOENT;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	mread = NULL;
	vp = NULL;
	len = reqlen = 0;
	saved_uid = kauth_cred_getuid(nd-&gt;nd_cr);

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	nfsmerr_if(error);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
		nfsm_chain_get_64(error, nmreq, off);
	<span class="enscript-keyword">else</span>
		nfsm_chain_get_32(error, nmreq, off);
	nfsm_chain_get_32(error, nmreq, reqlen);
	maxlen = NFSRV_NDMAXDATA(nd);
	<span class="enscript-keyword">if</span> (reqlen &gt; maxlen)
		reqlen = maxlen;
	nfsmerr_if(error);
	error = nfsrv_fhtovp(&amp;nfh, nd, &amp;vp, &amp;nx, &amp;nxo);
	nfsmerr_if(error);

	<span class="enscript-comment">/* update export stats */</span>
	NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

	error = nfsrv_credcheck(nd, ctx, nx, nxo);
	nfsmerr_if(error);

	<span class="enscript-keyword">if</span> (vnode_vtype(vp) != VREG) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
			error = EINVAL;
		<span class="enscript-keyword">else</span>
			error = (vnode_vtype(vp) == VDIR) ? EISDIR : EACCES;
	}

	<span class="enscript-keyword">if</span> (!error) {
	    <span class="enscript-keyword">if</span> ((error = nfsrv_authorize(vp, NULL, KAUTH_VNODE_READ_DATA, ctx, nxo, 1)))
		error = nfsrv_authorize(vp, NULL, KAUTH_VNODE_EXECUTE, ctx, nxo, 1);
	}
	nfsm_srv_vattr_init(vap, nd-&gt;nd_vers);
	attrerr = vnode_getattr(vp, vap, ctx);
	<span class="enscript-keyword">if</span> (!error)
		error = attrerr;
	nfsmerr_if(error);

	<span class="enscript-keyword">if</span> ((u_quad_t)off &gt;= vap-&gt;va_data_size)
		count = 0;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (((u_quad_t)off + reqlen) &gt; vap-&gt;va_data_size)
		count = nfsm_rndup(vap-&gt;va_data_size - off);
	<span class="enscript-keyword">else</span>
		count = reqlen;

	len = left = count;
	<span class="enscript-keyword">if</span> (count &gt; 0) {
		<span class="enscript-comment">/* get mbuf list to hold read data */</span>
		error = nfsm_mbuf_get_list(count, &amp;mread, &amp;mreadcnt);
		nfsmerr_if(error);
		MALLOC(uio_bufp, <span class="enscript-type">char</span> *, UIO_SIZEOF(mreadcnt), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (uio_bufp)
			auio = uio_createwithbuffer(mreadcnt, off, UIO_SYSSPACE,
					UIO_READ, uio_bufp, UIO_SIZEOF(mreadcnt));
		<span class="enscript-keyword">if</span> (!uio_bufp || !auio) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">errorexit</span>;
		}
		<span class="enscript-keyword">for</span> (m = mread; m; m = mbuf_next(m))
			uio_addiov(auio, CAST_USER_ADDR_T((caddr_t)mbuf_data(m)), mbuf_len(m));
		error = VNOP_READ(vp, auio, IO_NODELOCKED, ctx);
	} <span class="enscript-keyword">else</span> {
		auio = uio_createwithbuffer(0, 0, UIO_SYSSPACE, UIO_READ, &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
		<span class="enscript-keyword">if</span> (!auio) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">errorexit</span>;
		}
	}

<span class="enscript-reference">errorexit</span>:
	<span class="enscript-keyword">if</span> (!error || (nd-&gt;nd_vers == NFS_VER3)) {
		nfsm_srv_vattr_init(vap, nd-&gt;nd_vers);
		attrerr = vnode_getattr(vp, vap, ctx);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; (nd-&gt;nd_vers == NFS_VER2))
			error = attrerr; <span class="enscript-comment">/* NFSv2 must have attributes to return */</span>
	}
	nfsmerr_if(error);

	vnode_put(vp);
	vp = NULL;

	<span class="enscript-comment">/* trim off any data not actually read */</span>
	len -= uio_resid(auio);
	tlen = nfsm_rndup(len);
	<span class="enscript-keyword">if</span> (count != tlen || tlen != len)
		nfsm_adj(mread, count - tlen, tlen - len);

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_POSTOPORFATTR(nd-&gt;nd_vers) + 3 * NFSX_UNSIGNED);
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
		nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, attrerr, vap);
	<span class="enscript-keyword">if</span> (error || nd-&gt;nd_repstat) {
		nfsm_chain_build_done(error, &amp;nmrep);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_chain_add_32(error, &amp;nmrep, len);
		nfsm_chain_add_32(error, &amp;nmrep, (len &lt; reqlen) ? TRUE : FALSE);
	} <span class="enscript-keyword">else</span> {
		error = nfsm_chain_add_fattr(nd, &amp;nmrep, vap);
	}
	nfsm_chain_add_32(error, &amp;nmrep, len);
	nfsm_chain_build_done(error, &amp;nmrep);
	nfsmout_if(error);
	error = mbuf_setnext(nmrep.nmc_mcur, mread);
	<span class="enscript-keyword">if</span> (!error)
		mread = NULL;

	<span class="enscript-comment">/* update export stats */</span>
	NFSStatAdd64(&amp;nx-&gt;nx_stats.bytes_read, len);

	<span class="enscript-comment">/* update active user stats */</span>
	nfsrv_update_user_stat(nx, nd, saved_uid, 1, len, 0);
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);
	<span class="enscript-keyword">if</span> (mread)
		mbuf_freem(mread);
	<span class="enscript-keyword">if</span> (uio_bufp != NULL)
		FREE(uio_bufp, M_TEMP);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
<span class="enscript-comment">/*
 * NFS File modification reporting
 *
 * When the contents of a file are changed, a &quot;content modified&quot;
 * fsevent needs to be issued.  Normally this would be done at
 * file close time.  This is difficult for NFS because the protocol
 * has no &quot;close&quot; operation.  The client sends a stream of write
 * requests that just stop.  So we keep a hash table full of
 * vnodes that have been written to recently, and issue a
 * &quot;content modified&quot; fsevent only if there are no writes to
 * a vnode for nfsrv_fmod_pendtime milliseconds.
 */</span>
<span class="enscript-type">int</span> nfsrv_fmod_pending;		<span class="enscript-comment">/* count of vnodes being written to */</span>
<span class="enscript-type">int</span> nfsrv_fmod_pendtime = 1000;	<span class="enscript-comment">/* msec to wait */</span>
<span class="enscript-type">int</span> nfsrv_fmod_min_interval = 100;	<span class="enscript-comment">/* msec min interval between callbacks */</span>

<span class="enscript-comment">/*
 * This function is called via the kernel's callout
 * mechanism.  Calls are made only when there are
 * vnodes pending a fsevent creation, and no more
 * frequently than every nfsrv_fmod_min_interval ms.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_fmod_timer</span>(__unused <span class="enscript-type">void</span> *param0, __unused <span class="enscript-type">void</span> *param1)
{
	<span class="enscript-type">struct</span> nfsrv_fmod_hashhead *headp, firehead;
	<span class="enscript-type">struct</span> nfsrv_fmod *fp, *nfp, *pfp;
	uint64_t timenow, next_deadline;
	<span class="enscript-type">int</span> interval = 0, i, fmod_fire;

	LIST_INIT(&amp;firehead);
	lck_mtx_lock(nfsrv_fmod_mutex);
<span class="enscript-reference">again</span>:
	clock_get_uptime(&amp;timenow);
	clock_interval_to_deadline(nfsrv_fmod_pendtime, 1000 * 1000,
		&amp;next_deadline);

	<span class="enscript-comment">/*
	 * Scan all the hash chains
	 */</span>
	fmod_fire = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; NFSRVFMODHASHSZ; i++) {
		<span class="enscript-comment">/*
		 * For each hash chain, look for an entry
		 * that has exceeded the deadline.
		 */</span>
		headp = &amp;nfsrv_fmod_hashtbl[i];
		LIST_FOREACH(fp, headp, fm_link) {
			<span class="enscript-keyword">if</span> (timenow &gt;= fp-&gt;fm_deadline)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (fp-&gt;fm_deadline &lt; next_deadline)
				next_deadline = fp-&gt;fm_deadline;
		}

		<span class="enscript-comment">/*
		 * If we have an entry that's exceeded the
		 * deadline, then the same is true for all
		 * following entries in the chain, since they're
		 * sorted in time order.
		 */</span>
		pfp = NULL;
		<span class="enscript-keyword">while</span> (fp) {
			<span class="enscript-comment">/* move each entry to the fire list */</span>
			nfp = LIST_NEXT(fp, fm_link);
			LIST_REMOVE(fp, fm_link);
			fmod_fire++;
			<span class="enscript-keyword">if</span> (pfp)
				LIST_INSERT_AFTER(pfp, fp, fm_link);
			<span class="enscript-keyword">else</span>
				LIST_INSERT_HEAD(&amp;firehead, fp, fm_link);
			pfp = fp;
			fp = nfp;
		}
	}

	<span class="enscript-keyword">if</span> (fmod_fire) {
		lck_mtx_unlock(nfsrv_fmod_mutex);
		<span class="enscript-comment">/*
		 * Fire off the content modified fsevent for each
		 * entry and free it.
		 */</span>
		LIST_FOREACH_SAFE(fp, &amp;firehead, fm_link, nfp) {
			<span class="enscript-keyword">if</span> (nfsrv_fsevents_enabled) {
				fp-&gt;fm_context.vc_thread = current_thread();
				add_fsevent(FSE_CONTENT_MODIFIED, &amp;fp-&gt;fm_context,
					FSE_ARG_VNODE, fp-&gt;fm_vp,
					FSE_ARG_DONE);
			}
			vnode_put(fp-&gt;fm_vp);
			kauth_cred_unref(&amp;fp-&gt;fm_context.vc_ucred);
			LIST_REMOVE(fp, fm_link);
			FREE(fp, M_TEMP);
		}
		lck_mtx_lock(nfsrv_fmod_mutex);
		nfsrv_fmod_pending -= fmod_fire;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}

	<span class="enscript-comment">/*
	 * If there are still pending entries, set up another
	 * callout to handle them later. Set the timeout deadline
	 * so that the callout happens when the oldest pending
	 * entry is ready to send its fsevent.
	 */</span>
	<span class="enscript-keyword">if</span> (nfsrv_fmod_pending &gt; 0) {
		interval = (next_deadline - timenow) / (1000 * 1000);
		<span class="enscript-keyword">if</span> (interval &lt; nfsrv_fmod_min_interval)
			interval = nfsrv_fmod_min_interval;
	}

	nfsrv_fmod_timer_on = interval &gt; 0;
	<span class="enscript-keyword">if</span> (nfsrv_fmod_timer_on)
		nfs_interval_timer_start(nfsrv_fmod_timer_call, interval);

	lck_mtx_unlock(nfsrv_fmod_mutex);
}

<span class="enscript-comment">/*
 * When a vnode has been written to, enter it in the hash
 * table of vnodes pending creation of an fsevent. If the
 * callout timer isn't already running, schedule a callback
 * for nfsrv_fmod_pendtime msec from now.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_modified</span>(vnode_t vp, vfs_context_t ctx)
{
	uint64_t deadline;
	<span class="enscript-type">struct</span> nfsrv_fmod *fp;
	<span class="enscript-type">struct</span> nfsrv_fmod_hashhead *head;

	lck_mtx_lock(nfsrv_fmod_mutex);

	<span class="enscript-comment">/*
	 * Compute the time in the future when the
	 * content modified fsevent is to be issued.
	 */</span>
	clock_interval_to_deadline(nfsrv_fmod_pendtime, 1000 * 1000, &amp;deadline);

	<span class="enscript-comment">/*
	 * Check if there's already a file content change fsevent
	 * pending for this vnode.  If there is, update its
	 * timestamp and make sure it's at the front of the hash chain.
	 */</span>
	head = &amp;nfsrv_fmod_hashtbl[NFSRVFMODHASH(vp)];
	LIST_FOREACH(fp, head, fm_link) {
		<span class="enscript-keyword">if</span> (vp == fp-&gt;fm_vp) {
			fp-&gt;fm_deadline = deadline;
			<span class="enscript-keyword">if</span> (fp != LIST_FIRST(head)) {
				LIST_REMOVE(fp, fm_link);
				LIST_INSERT_HEAD(head, fp, fm_link);
			}
			lck_mtx_unlock(nfsrv_fmod_mutex);
			<span class="enscript-keyword">return</span>;
		}
	}

	<span class="enscript-comment">/*
	 * First content change fsevent for this vnode.
	 * Allocate a new file mod entry and add it
	 * on the front of the hash chain.
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_get(vp) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	MALLOC(fp, <span class="enscript-type">struct</span> nfsrv_fmod *, <span class="enscript-keyword">sizeof</span>(*fp), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (fp == NULL) {
		vnode_put(vp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	fp-&gt;fm_vp = vp;
	kauth_cred_ref(vfs_context_ucred(ctx));
	fp-&gt;fm_context = *ctx;
	fp-&gt;fm_deadline = deadline;
	LIST_INSERT_HEAD(head, fp, fm_link);

	<span class="enscript-comment">/*
	 * If added to an empty hash table, then set the
	 * callout timer to go off after nfsrv_fmod_pendtime.
	 */</span>
	nfsrv_fmod_pending++;
	<span class="enscript-keyword">if</span> (!nfsrv_fmod_timer_on) {
		nfsrv_fmod_timer_on = 1;
		nfs_interval_timer_start(nfsrv_fmod_timer_call,
			nfsrv_fmod_pendtime);
	}
<span class="enscript-reference">done</span>:
	lck_mtx_unlock(nfsrv_fmod_mutex);
	<span class="enscript-keyword">return</span>;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FSE */</span>

<span class="enscript-comment">/*
 * nfs write service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_write</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> vnode_attr preattr, postattr;
	<span class="enscript-type">int</span> error, preattrerr, postattrerr;
	<span class="enscript-type">int</span> ioflags, len, retlen;
	<span class="enscript-type">int</span> mlen, mcount;
	<span class="enscript-type">int</span> stable = NFS_WRITE_FILESYNC;
	mbuf_t m;
	vnode_t vp;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	uio_t auio = NULL;
	<span class="enscript-type">char</span> *uio_bufp = NULL;
	off_t off;
	uid_t saved_uid;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	<span class="enscript-keyword">if</span> (nd-&gt;nd_nmreq.nmc_mhead == NULL) {
		*mrepp = NULL;
		<span class="enscript-keyword">return</span> (0);
	}

	error = 0;
	preattrerr = postattrerr = ENOENT;
	saved_uid = kauth_cred_getuid(nd-&gt;nd_cr);
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	vp = NULL;
	len = retlen = 0;

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	nfsmerr_if(error);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_chain_get_64(error, nmreq, off);
		nfsm_chain_adv(error, nmreq, NFSX_UNSIGNED);
		nfsm_chain_get_32(error, nmreq, stable);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_adv(error, nmreq, NFSX_UNSIGNED);
		nfsm_chain_get_32(error, nmreq, off);
		nfsm_chain_adv(error, nmreq, NFSX_UNSIGNED);
		<span class="enscript-keyword">if</span> (nfsrv_async)
	    		stable = NFS_WRITE_UNSTABLE;
	}
	nfsm_chain_get_32(error, nmreq, len);
	nfsmerr_if(error);
	retlen = len;

	<span class="enscript-comment">/*
	 * For NFS Version 2, it is not obvious what a write of zero length
	 * should do, but I might as well be consistent with Version 3,
	 * which is to return ok so long as there are no permission problems.
	 */</span>

	<span class="enscript-keyword">if</span> (len &gt; 0) {
		error = nfsm_chain_trim_data(nmreq, len, &amp;mlen);
		nfsmerr_if(error);
	} <span class="enscript-keyword">else</span> {
		mlen = 0;
	}
	<span class="enscript-keyword">if</span> ((len &gt; NFSRV_MAXDATA) || (len &lt; 0) || (mlen &lt; len)) {
		error = EIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmerr</span>;
	}
	error = nfsrv_fhtovp(&amp;nfh, nd, &amp;vp, &amp;nx, &amp;nxo);
	nfsmerr_if(error);

	<span class="enscript-comment">/* update export stats */</span>
	NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

	error = nfsrv_credcheck(nd, ctx, nx, nxo);
	nfsmerr_if(error);

	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_srv_pre_vattr_init(&amp;preattr);
		preattrerr = vnode_getattr(vp, &amp;preattr, ctx);
	}
	<span class="enscript-keyword">if</span> (vnode_vtype(vp) != VREG) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
			error = EINVAL;
		<span class="enscript-keyword">else</span>
			error = (vnode_vtype(vp) == VDIR) ? EISDIR : EACCES;
	}
	<span class="enscript-keyword">if</span> (!error)
		error = nfsrv_authorize(vp, NULL, KAUTH_VNODE_WRITE_DATA, ctx, nxo, 1);
	nfsmerr_if(error);

	<span class="enscript-keyword">if</span> (len &gt; 0) {
		<span class="enscript-keyword">for</span> (mcount=0, m=nmreq-&gt;nmc_mcur; m; m = mbuf_next(m))
			<span class="enscript-keyword">if</span> (mbuf_len(m) &gt; 0)
				mcount++;
		MALLOC(uio_bufp, <span class="enscript-type">char</span> *, UIO_SIZEOF(mcount), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (uio_bufp)
			auio = uio_createwithbuffer(mcount, off, UIO_SYSSPACE, UIO_WRITE, uio_bufp, UIO_SIZEOF(mcount));
		<span class="enscript-keyword">if</span> (!uio_bufp || !auio)
			error = ENOMEM;
		nfsmerr_if(error);
		<span class="enscript-keyword">for</span> (m = nmreq-&gt;nmc_mcur; m; m = mbuf_next(m))
			<span class="enscript-keyword">if</span> ((mlen = mbuf_len(m)) &gt; 0)
				uio_addiov(auio, CAST_USER_ADDR_T((caddr_t)mbuf_data(m)), mlen);
		<span class="enscript-comment">/*
		 * XXX The IO_METASYNC flag indicates that all metadata (and not just
		 * enough to ensure data integrity) mus be written to stable storage
		 * synchronously.  (IO_METASYNC is not yet implemented in 4.4BSD-Lite.)
		 */</span>
		<span class="enscript-keyword">if</span> (stable == NFS_WRITE_UNSTABLE)
			ioflags = IO_NODELOCKED;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (stable == NFS_WRITE_DATASYNC)
			ioflags = (IO_SYNC | IO_NODELOCKED);
		<span class="enscript-keyword">else</span>
			ioflags = (IO_METASYNC | IO_SYNC | IO_NODELOCKED);

		error = VNOP_WRITE(vp, auio, ioflags, ctx);
		OSAddAtomic64(1, &amp;nfsstats.srvvop_writes);

		<span class="enscript-comment">/* update export stats */</span>
		NFSStatAdd64(&amp;nx-&gt;nx_stats.bytes_written, len);

		<span class="enscript-comment">/* update active user stats */</span>
		nfsrv_update_user_stat(nx, nd, saved_uid, 1, 0, len);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
		<span class="enscript-keyword">if</span> (nfsrv_fsevents_enabled &amp;&amp; !error &amp;&amp; need_fsevent(FSE_CONTENT_MODIFIED, vp))
			nfsrv_modified(vp, ctx);
#<span class="enscript-reference">endif</span>
	}
	nfsm_srv_vattr_init(&amp;postattr, nd-&gt;nd_vers);
	postattrerr = vnode_getattr(vp, &amp;postattr, ctx);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (nd-&gt;nd_vers == NFS_VER2))
		error = postattrerr; <span class="enscript-comment">/* NFSv2 must have attributes to return */</span>
	vnode_put(vp);
	vp = NULL;

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_PREOPATTR(nd-&gt;nd_vers) +
			NFSX_POSTOPORFATTR(nd-&gt;nd_vers) + 2 * NFSX_UNSIGNED +
			NFSX_WRITEVERF(nd-&gt;nd_vers));
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_chain_add_wcc_data(error, nd, &amp;nmrep,
			preattrerr, &amp;preattr, postattrerr, &amp;postattr);
		nfsmout_if(error || nd-&gt;nd_repstat);
		nfsm_chain_add_32(error, &amp;nmrep, retlen);
		<span class="enscript-comment">/* If nfsrv_async is set, then pretend the write was FILESYNC. */</span>
		<span class="enscript-keyword">if</span> ((stable == NFS_WRITE_UNSTABLE) &amp;&amp; !nfsrv_async)
			nfsm_chain_add_32(error, &amp;nmrep, stable);
		<span class="enscript-keyword">else</span>
			nfsm_chain_add_32(error, &amp;nmrep, NFS_WRITE_FILESYNC);
		<span class="enscript-comment">/* write verifier */</span>
		nfsm_chain_add_32(error, &amp;nmrep, nx-&gt;nx_exptime.tv_sec);
		nfsm_chain_add_32(error, &amp;nmrep, nx-&gt;nx_exptime.tv_usec);
	} <span class="enscript-keyword">else</span> {
		error = nfsm_chain_add_fattr(nd, &amp;nmrep, &amp;postattr);
	}
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);
	<span class="enscript-keyword">if</span> (uio_bufp != NULL)
		FREE(uio_bufp, M_TEMP);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS write service with write gathering support. Called when
 * nfsrv_wg_delay &gt; 0.
 * See: Chet Juszczak, &quot;Improving the Write Performance of an NFS Server&quot;,
 * in Proc. of the Winter 1994 Usenix Conference, pg. 247-259, San Franscisco,
 * Jan. 1994.
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NWDELAYHASH</span>(sock, f) \
	(&amp;(sock)-&gt;ns_wdelayhashtbl[(*((u_int32_t *)(f))) % NFS_WDELAYHASHSIZ])
<span class="enscript-comment">/* These macros compare nfsrv_descript structures.  */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFSW_CONTIG</span>(o, n) \
		(((o)-&gt;nd_eoff &gt;= (n)-&gt;nd_off) &amp;&amp; nfsrv_fhmatch(&amp;(o)-&gt;nd_fh, &amp;(n)-&gt;nd_fh))
<span class="enscript-comment">/*
 * XXX The following is an incorrect comparison; it fails to take into account
 * XXX scoping of MAC labels, but we currently lack KPI for credential
 * XXX comparisons.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFSW_SAMECRED</span>(o, n) \
	(!bcmp((caddr_t)(o)-&gt;nd_cr, (caddr_t)(n)-&gt;nd_cr, \
		<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ucred)))

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_writegather</span>(
	<span class="enscript-type">struct</span> nfsrv_descript **ndp,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> nfsrv_descript *nd, *wp, *owp, *swp;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	<span class="enscript-type">struct</span> nfsrv_wg_delayhash *wpp;
	uid_t saved_uid;
	<span class="enscript-type">struct</span> vnode_attr preattr, postattr;
	<span class="enscript-type">int</span> error, mlen, i, ioflags, tlen;
	<span class="enscript-type">int</span> preattrerr, postattrerr;
	vnode_t vp;
	mbuf_t m;
	uio_t auio = NULL;
	<span class="enscript-type">char</span> *uio_bufp = NULL;
	u_quad_t cur_usec;
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	preattrerr = postattrerr = ENOENT;
	nfsm_chain_null(&amp;nmrep);
	vp = NULL;

	*mrepp = NULL;
	<span class="enscript-keyword">if</span> (*ndp) {
	    nd = *ndp;
	    *ndp = NULL;
	    nmreq = &amp;nd-&gt;nd_nmreq;
	    LIST_INIT(&amp;nd-&gt;nd_coalesce);
	    nd-&gt;nd_mrep = NULL;
	    nd-&gt;nd_stable = NFS_WRITE_FILESYNC;
	    microuptime(&amp;now);
	    cur_usec = (u_quad_t)now.tv_sec * 1000000 + (u_quad_t)now.tv_usec;
	    nd-&gt;nd_time = cur_usec +
		((nd-&gt;nd_vers == NFS_VER3) ? nfsrv_wg_delay_v3 : nfsrv_wg_delay);

	    <span class="enscript-comment">/* Now, get the write header... */</span>
	    nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nd-&gt;nd_fh.nfh_fhp, nd-&gt;nd_fh.nfh_len);
	    <span class="enscript-comment">/* XXX shouldn't we be checking for invalid FHs before doing any more work? */</span>
	    nfsmerr_if(error);
	    <span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		    nfsm_chain_get_64(error, nmreq, nd-&gt;nd_off);
		    nfsm_chain_adv(error, nmreq, NFSX_UNSIGNED);
		    nfsm_chain_get_32(error, nmreq, nd-&gt;nd_stable);
	    } <span class="enscript-keyword">else</span> {
		    nfsm_chain_adv(error, nmreq, NFSX_UNSIGNED);
		    nfsm_chain_get_32(error, nmreq, nd-&gt;nd_off);
		    nfsm_chain_adv(error, nmreq, NFSX_UNSIGNED);
		    <span class="enscript-keyword">if</span> (nfsrv_async)
			    nd-&gt;nd_stable = NFS_WRITE_UNSTABLE;
	    }
	    nfsm_chain_get_32(error, nmreq, nd-&gt;nd_len);
	    nfsmerr_if(error);
	    nd-&gt;nd_eoff = nd-&gt;nd_off + nd-&gt;nd_len;

	    <span class="enscript-keyword">if</span> (nd-&gt;nd_len &gt; 0) {
		    error = nfsm_chain_trim_data(nmreq, nd-&gt;nd_len, &amp;mlen);
		    nfsmerr_if(error);
	    } <span class="enscript-keyword">else</span> {
		mlen = 0;
	    }

	    <span class="enscript-keyword">if</span> ((nd-&gt;nd_len &gt; NFSRV_MAXDATA) || (nd-&gt;nd_len &lt; 0)  || (mlen &lt; nd-&gt;nd_len)) {
		error = EIO;
<span class="enscript-reference">nfsmerr</span>:
		nd-&gt;nd_repstat = error;
		error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_WCCDATA(nd-&gt;nd_vers));
		<span class="enscript-keyword">if</span> (!error) {
		    nd-&gt;nd_mrep = nmrep.nmc_mhead;
		    <span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
			nfsm_chain_add_wcc_data(error, nd, &amp;nmrep,
				preattrerr, &amp;preattr, postattrerr, &amp;postattr);
		}
		nfsm_chain_build_done(error, &amp;nmrep);
		nd-&gt;nd_time = 1;
	    }

	    <span class="enscript-comment">/*
	     * Add this entry to the hash and time queues.
	     */</span>
	    lck_mtx_lock(&amp;slp-&gt;ns_wgmutex);
	    owp = NULL;
	    wp = slp-&gt;ns_tq.lh_first;
	    <span class="enscript-keyword">while</span> (wp &amp;&amp; wp-&gt;nd_time &lt; nd-&gt;nd_time) {
		owp = wp;
		wp = wp-&gt;nd_tq.le_next;
	    }
	    <span class="enscript-keyword">if</span> (owp) {
		LIST_INSERT_AFTER(owp, nd, nd_tq);
	    } <span class="enscript-keyword">else</span> {
		LIST_INSERT_HEAD(&amp;slp-&gt;ns_tq, nd, nd_tq);
	    }
	    <span class="enscript-keyword">if</span> (!error) {
		wpp = NWDELAYHASH(slp, nd-&gt;nd_fh.nfh_fid);
		owp = NULL;
		wp = wpp-&gt;lh_first;
		<span class="enscript-keyword">while</span> (wp &amp;&amp; !nfsrv_fhmatch(&amp;nd-&gt;nd_fh, &amp;wp-&gt;nd_fh)) {
		    owp = wp;
		    wp = wp-&gt;nd_hash.le_next;
		}
		<span class="enscript-keyword">while</span> (wp &amp;&amp; (wp-&gt;nd_off &lt; nd-&gt;nd_off) &amp;&amp;
		    nfsrv_fhmatch(&amp;nd-&gt;nd_fh, &amp;wp-&gt;nd_fh)) {
		    owp = wp;
		    wp = wp-&gt;nd_hash.le_next;
		}
		<span class="enscript-keyword">if</span> (owp) {
		    LIST_INSERT_AFTER(owp, nd, nd_hash);
		    <span class="enscript-comment">/*
		     * Search the hash list for overlapping entries and
		     * coalesce.
		     */</span>
		    <span class="enscript-keyword">for</span>(; nd &amp;&amp; NFSW_CONTIG(owp, nd); nd = wp) {
			wp = nd-&gt;nd_hash.le_next;
			<span class="enscript-keyword">if</span> (NFSW_SAMECRED(owp, nd))
			    nfsrv_wg_coalesce(owp, nd);
		    }
		} <span class="enscript-keyword">else</span> {
		    LIST_INSERT_HEAD(wpp, nd, nd_hash);
		}
	    }
	} <span class="enscript-keyword">else</span> {
	    lck_mtx_lock(&amp;slp-&gt;ns_wgmutex);
	}

	<span class="enscript-comment">/*
	 * Now, do VNOP_WRITE()s for any one(s) that need to be done now
	 * and generate the associated reply mbuf list(s).
	 */</span>
<span class="enscript-reference">loop1</span>:
	microuptime(&amp;now);
	cur_usec = (u_quad_t)now.tv_sec * 1000000 + (u_quad_t)now.tv_usec;
	<span class="enscript-keyword">for</span> (nd = slp-&gt;ns_tq.lh_first; nd; nd = owp) {
		owp = nd-&gt;nd_tq.le_next;
		<span class="enscript-keyword">if</span> (nd-&gt;nd_time &gt; cur_usec)
		    <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (nd-&gt;nd_mrep)
		    <span class="enscript-keyword">continue</span>;
		LIST_REMOVE(nd, nd_tq);
		LIST_REMOVE(nd, nd_hash);
		nmreq = &amp;nd-&gt;nd_nmreq;
		preattrerr = postattrerr = ENOENT;

		<span class="enscript-comment">/* save the incoming uid before mapping, */</span>	
		<span class="enscript-comment">/* for updating active user stats later */</span>
		saved_uid = kauth_cred_getuid(nd-&gt;nd_cr);

		error = nfsrv_fhtovp(&amp;nd-&gt;nd_fh, nd, &amp;vp, &amp;nx, &amp;nxo);
		<span class="enscript-keyword">if</span> (!error) {
		    <span class="enscript-comment">/* update per-export stats */</span>
		    NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

		    error = nfsrv_credcheck(nd, ctx, nx, nxo);
		    <span class="enscript-keyword">if</span> (error)
		    	vnode_put(vp);
		}
		<span class="enscript-keyword">if</span> (!error) {
		    <span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
			nfsm_srv_pre_vattr_init(&amp;preattr);
			preattrerr = vnode_getattr(vp, &amp;preattr, ctx);
		    }
		    <span class="enscript-keyword">if</span> (vnode_vtype(vp) != VREG) {
			<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
			    error = EINVAL;
			<span class="enscript-keyword">else</span>
			    error = (vnode_vtype(vp) == VDIR) ? EISDIR : EACCES;
		    }
		} <span class="enscript-keyword">else</span>
		    vp = NULL;
		<span class="enscript-keyword">if</span> (!error)
		    error = nfsrv_authorize(vp, NULL, KAUTH_VNODE_WRITE_DATA, ctx, nxo, 1);

		<span class="enscript-keyword">if</span> (nd-&gt;nd_stable == NFS_WRITE_UNSTABLE)
		    ioflags = IO_NODELOCKED;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nd-&gt;nd_stable == NFS_WRITE_DATASYNC)
		    ioflags = (IO_SYNC | IO_NODELOCKED);
		<span class="enscript-keyword">else</span>
		    ioflags = (IO_METASYNC | IO_SYNC | IO_NODELOCKED);

		<span class="enscript-keyword">if</span> (!error &amp;&amp; ((nd-&gt;nd_eoff - nd-&gt;nd_off) &gt; 0)) {
		    <span class="enscript-keyword">for</span> (i=0, m=nmreq-&gt;nmc_mhead; m; m = mbuf_next(m))
			<span class="enscript-keyword">if</span> (mbuf_len(m) &gt; 0)
			    i++;

		    MALLOC(uio_bufp, <span class="enscript-type">char</span> *, UIO_SIZEOF(i), M_TEMP, M_WAITOK);
		    <span class="enscript-keyword">if</span> (uio_bufp)
			auio = uio_createwithbuffer(i, nd-&gt;nd_off, UIO_SYSSPACE,
						UIO_WRITE, uio_bufp, UIO_SIZEOF(i));
		    <span class="enscript-keyword">if</span> (!uio_bufp || !auio)
			error = ENOMEM;
		    <span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-keyword">for</span> (m = nmreq-&gt;nmc_mhead; m; m = mbuf_next(m))
			    <span class="enscript-keyword">if</span> ((tlen = mbuf_len(m)) &gt; 0)
				uio_addiov(auio, CAST_USER_ADDR_T((caddr_t)mbuf_data(m)), tlen);
			error = VNOP_WRITE(vp, auio, ioflags, ctx);
			OSAddAtomic64(1, &amp;nfsstats.srvvop_writes);

			<span class="enscript-comment">/* update export stats */</span>
			NFSStatAdd64(&amp;nx-&gt;nx_stats.bytes_written, nd-&gt;nd_len);
			<span class="enscript-comment">/* update active user stats */</span>
			nfsrv_update_user_stat(nx, nd, saved_uid, 1, 0, nd-&gt;nd_len);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
			<span class="enscript-keyword">if</span> (nfsrv_fsevents_enabled &amp;&amp; !error &amp;&amp; need_fsevent(FSE_CONTENT_MODIFIED, vp))
				nfsrv_modified(vp, ctx);
#<span class="enscript-reference">endif</span>
		    }
		    <span class="enscript-keyword">if</span> (uio_bufp) {
			FREE(uio_bufp, M_TEMP);
			uio_bufp = NULL;
		    }
		}
		<span class="enscript-keyword">if</span> (vp) {
		    nfsm_srv_vattr_init(&amp;postattr, nd-&gt;nd_vers);
		    postattrerr = vnode_getattr(vp, &amp;postattr, ctx);
		    vnode_put(vp);
		}

		<span class="enscript-comment">/*
		 * Loop around generating replies for all write rpcs that have
		 * now been completed.
		 */</span>
		swp = nd;
		<span class="enscript-keyword">do</span> {
		    <span class="enscript-keyword">if</span> (error) {
			nd-&gt;nd_repstat = error;
			error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_WCCDATA(nd-&gt;nd_vers));
			<span class="enscript-keyword">if</span> (!error &amp;&amp; (nd-&gt;nd_vers == NFS_VER3)) {
			    nfsm_chain_add_wcc_data(error, nd, &amp;nmrep,
				    preattrerr, &amp;preattr, postattrerr, &amp;postattr);
			}
		    } <span class="enscript-keyword">else</span> {
			nd-&gt;nd_repstat = error;
			error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_PREOPATTR(nd-&gt;nd_vers) +
			    NFSX_POSTOPORFATTR(nd-&gt;nd_vers) + 2 * NFSX_UNSIGNED +
			    NFSX_WRITEVERF(nd-&gt;nd_vers));
			<span class="enscript-keyword">if</span> (!error &amp;&amp; (nd-&gt;nd_vers == NFS_VER3)) {
			    nfsm_chain_add_wcc_data(error, nd, &amp;nmrep,
				    preattrerr, &amp;preattr, postattrerr, &amp;postattr);
			    nfsm_chain_add_32(error, &amp;nmrep, nd-&gt;nd_len);
			    nfsm_chain_add_32(error, &amp;nmrep, nd-&gt;nd_stable);
			    <span class="enscript-comment">/* write verifier */</span>
			    nfsm_chain_add_32(error, &amp;nmrep, nx-&gt;nx_exptime.tv_sec);
			    nfsm_chain_add_32(error, &amp;nmrep, nx-&gt;nx_exptime.tv_usec);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!error) {
			    error = nfsm_chain_add_fattr(nd, &amp;nmrep, &amp;postattr);
			}
		    }
		    nfsm_chain_build_done(error, &amp;nmrep);
		    nfsmerr_if(error);
		    nd-&gt;nd_mrep = nmrep.nmc_mhead;

		    <span class="enscript-comment">/*
		     * Done. Put it at the head of the timer queue so that
		     * the final phase can return the reply.
		     */</span>
		    <span class="enscript-keyword">if</span> (nd != swp) {
			nd-&gt;nd_time = 1;
			LIST_INSERT_HEAD(&amp;slp-&gt;ns_tq, nd, nd_tq);
		    }
		    nd = swp-&gt;nd_coalesce.lh_first;
		    <span class="enscript-keyword">if</span> (nd) {
			LIST_REMOVE(nd, nd_tq);
		    }
		} <span class="enscript-keyword">while</span> (nd);
		swp-&gt;nd_time = 1;
		LIST_INSERT_HEAD(&amp;slp-&gt;ns_tq, swp, nd_tq);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop1</span>;
	}

	<span class="enscript-comment">/*
	 * Search for a reply to return.
	 */</span>
	<span class="enscript-keyword">for</span> (nd = slp-&gt;ns_tq.lh_first; nd; nd = nd-&gt;nd_tq.le_next)
		<span class="enscript-keyword">if</span> (nd-&gt;nd_mrep) {
		    LIST_REMOVE(nd, nd_tq);
		    *mrepp = nd-&gt;nd_mrep;
		    *ndp = nd;
		    <span class="enscript-keyword">break</span>;
		}
	slp-&gt;ns_wgtime = slp-&gt;ns_tq.lh_first ? slp-&gt;ns_tq.lh_first-&gt;nd_time : 0;
	lck_mtx_unlock(&amp;slp-&gt;ns_wgmutex);

	<span class="enscript-comment">/*
	 * If we've just created a write pending gather,
	 * start the timer to check on it soon to make sure
	 * the write will be completed.
	 *
	 * Add/Remove the socket in the nfsrv_sockwg queue as needed.
	 */</span>
	lck_mtx_lock(nfsd_mutex);
	<span class="enscript-keyword">if</span> (slp-&gt;ns_wgtime) {
		<span class="enscript-keyword">if</span> (slp-&gt;ns_wgq.tqe_next == SLPNOLIST) {
			TAILQ_INSERT_HEAD(&amp;nfsrv_sockwg, slp, ns_wgq);
		}
		<span class="enscript-keyword">if</span> (!nfsrv_wg_timer_on) {
			nfsrv_wg_timer_on = 1;
			nfs_interval_timer_start(nfsrv_wg_timer_call,
				NFSRV_WGATHERDELAY);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (slp-&gt;ns_wgq.tqe_next != SLPNOLIST) {
		TAILQ_REMOVE(&amp;nfsrv_sockwg, slp, ns_wgq);
		slp-&gt;ns_wgq.tqe_next = SLPNOLIST;
	}
	lck_mtx_unlock(nfsd_mutex);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Coalesce the write request nd into owp. To do this we must:
 * - remove nd from the queues
 * - merge nd-&gt;nd_nmreq into owp-&gt;nd_nmreq
 * - update the nd_eoff and nd_stable for owp
 * - put nd on owp's nd_coalesce list
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_wg_coalesce</span>(<span class="enscript-type">struct</span> nfsrv_descript *owp, <span class="enscript-type">struct</span> nfsrv_descript *nd)
{
	<span class="enscript-type">int</span> overlap, error;
	mbuf_t mp, mpnext;
	<span class="enscript-type">struct</span> nfsrv_descript *p;

	LIST_REMOVE(nd, nd_hash);
	LIST_REMOVE(nd, nd_tq);
	<span class="enscript-keyword">if</span> (owp-&gt;nd_eoff &lt; nd-&gt;nd_eoff) {
		overlap = owp-&gt;nd_eoff - nd-&gt;nd_off;
		<span class="enscript-keyword">if</span> (overlap &lt; 0)
			<span class="enscript-keyword">return</span> (EIO);
		<span class="enscript-keyword">if</span> (overlap &gt; 0)
			mbuf_adj(nd-&gt;nd_nmreq.nmc_mhead, overlap);
		mp = owp-&gt;nd_nmreq.nmc_mhead;
		<span class="enscript-keyword">while</span> ((mpnext = mbuf_next(mp)))
			mp = mpnext;
		error = mbuf_setnext(mp, nd-&gt;nd_nmreq.nmc_mhead);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		owp-&gt;nd_eoff = nd-&gt;nd_eoff;
	} <span class="enscript-keyword">else</span> {
		mbuf_freem(nd-&gt;nd_nmreq.nmc_mhead);
	}
	nd-&gt;nd_nmreq.nmc_mhead = NULL;
	nd-&gt;nd_nmreq.nmc_mcur = NULL;
	<span class="enscript-keyword">if</span> (nd-&gt;nd_stable == NFS_WRITE_FILESYNC)
		owp-&gt;nd_stable = NFS_WRITE_FILESYNC;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((nd-&gt;nd_stable == NFS_WRITE_DATASYNC) &amp;&amp;
		 (owp-&gt;nd_stable == NFS_WRITE_UNSTABLE))
		owp-&gt;nd_stable = NFS_WRITE_DATASYNC;
	LIST_INSERT_HEAD(&amp;owp-&gt;nd_coalesce, nd, nd_tq);

	<span class="enscript-comment">/*
	 * If nd had anything else coalesced into it, transfer them
	 * to owp, otherwise their replies will never get sent.
	 */</span>
	<span class="enscript-keyword">while</span> ((p = nd-&gt;nd_coalesce.lh_first)) {
		LIST_REMOVE(p, nd_tq);
		LIST_INSERT_HEAD(&amp;owp-&gt;nd_coalesce, p, nd_tq);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Scan the write gathering queues for writes that need to be
 * completed now.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_wg_timer</span>(__unused <span class="enscript-type">void</span> *param0, __unused <span class="enscript-type">void</span> *param1)
{
	<span class="enscript-type">struct</span> timeval now;
	uint64_t cur_usec, next_usec;
	<span class="enscript-type">int</span> interval;
	<span class="enscript-type">struct</span> nfsrv_sock *slp;
	<span class="enscript-type">int</span> writes_pending = 0;

	microuptime(&amp;now);
	cur_usec = (uint64_t)now.tv_sec * 1000000 + (uint64_t)now.tv_usec;
	next_usec = cur_usec + (NFSRV_WGATHERDELAY * 1000);

	lck_mtx_lock(nfsd_mutex);
	TAILQ_FOREACH(slp, &amp;nfsrv_sockwg, ns_wgq) {
		<span class="enscript-keyword">if</span> (slp-&gt;ns_wgtime) {
			writes_pending++;
			<span class="enscript-keyword">if</span> (slp-&gt;ns_wgtime &lt;= cur_usec) {
				lck_rw_lock_exclusive(&amp;slp-&gt;ns_rwlock);
				slp-&gt;ns_flag |= SLP_DOWRITES;
				lck_rw_done(&amp;slp-&gt;ns_rwlock);
				nfsrv_wakenfsd(slp);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (slp-&gt;ns_wgtime &lt; next_usec)
				next_usec = slp-&gt;ns_wgtime;
		}
	}

	<span class="enscript-keyword">if</span> (writes_pending == 0) {
		nfsrv_wg_timer_on = 0;
		lck_mtx_unlock(nfsd_mutex);
		<span class="enscript-keyword">return</span>;
	}
	lck_mtx_unlock(nfsd_mutex);

	<span class="enscript-comment">/*
	 * Return the number of msec to wait again
	 */</span>
	interval = (next_usec - cur_usec) / 1000;
	<span class="enscript-keyword">if</span> (interval &lt; 1)
		interval = 1;
	nfs_interval_timer_start(nfsrv_wg_timer_call, interval);
}

<span class="enscript-comment">/*
 * Sort the group list in increasing numerical order.
 * (Insertion sort by Chris Torek, who was grossed out by the bubble sort
 *  that used to be here.)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_group_sort</span>(gid_t *list, <span class="enscript-type">int</span> num)
{
	<span class="enscript-type">int</span> i, j;
	gid_t v;

	<span class="enscript-comment">/* Insertion sort. */</span>
	<span class="enscript-keyword">for</span> (i = 1; i &lt; num; i++) {
		v = list[i];
		<span class="enscript-comment">/* find correct slot for value v, moving others up */</span>
		<span class="enscript-keyword">for</span> (j = i; --j &gt;= 0 &amp;&amp; v &lt; list[j];)
			list[j + 1] = list[j];
		list[j + 1] = v;
	}
}

<span class="enscript-comment">/*
 * nfs create service
 * now does a truncate to 0 length via. setattr if it already exists
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_create</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> vnode_attr dpreattr, dpostattr, postattr;
	<span class="enscript-type">struct</span> vnode_attr va, *vap = &amp;va;
	<span class="enscript-type">struct</span> nameidata ni;
	<span class="enscript-type">int</span> error, rdev, dpreattrerr, dpostattrerr, postattrerr;
	<span class="enscript-type">int</span> how, exclusive_flag;
	uint32_t len = 0, cnflags;
	vnode_t vp, dvp, dirp;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx = NULL;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	u_quad_t tempsize;
	u_char cverf[NFSX_V3CREATEVERF];
	uid_t saved_uid;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	dpreattrerr = dpostattrerr = postattrerr = ENOENT;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	vp = dvp = dirp = NULL;
	exclusive_flag = 0;
	ni.ni_cnd.cn_nameiop = 0;
	rdev = 0;

	saved_uid = kauth_cred_getuid(nd-&gt;nd_cr);

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	nfsm_chain_get_32(error, nmreq, len);
	nfsm_name_len_check(error, nd, len);
	nfsmerr_if(error);

	ni.ni_cnd.cn_nameiop = CREATE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	ni.ni_op = OP_LINK;
#<span class="enscript-reference">endif</span>
	ni.ni_cnd.cn_flags = LOCKPARENT | LOCKLEAF;
	error = nfsm_chain_get_path_namei(nmreq, len, &amp;ni);
	<span class="enscript-keyword">if</span> (!error) {
		error = nfsrv_namei(nd, ctx, &amp;ni, &amp;nfh, &amp;dirp, &amp;nx, &amp;nxo);
		<span class="enscript-keyword">if</span> (nx != NULL) {
			<span class="enscript-comment">/* update export stats */</span>
			NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

			<span class="enscript-comment">/* update active user stats */</span>
			nfsrv_update_user_stat(nx, nd, saved_uid, 1, 0, 0);
		}
	}
	<span class="enscript-keyword">if</span> (dirp) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
			nfsm_srv_pre_vattr_init(&amp;dpreattr);
			dpreattrerr = vnode_getattr(dirp, &amp;dpreattr, ctx);
		} <span class="enscript-keyword">else</span> {
			vnode_put(dirp);
			dirp = NULL;
		}
	}

	<span class="enscript-keyword">if</span> (error) {
		ni.ni_cnd.cn_nameiop = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmerr</span>;
	}

	dvp = ni.ni_dvp;
	vp = ni.ni_vp;
	VATTR_INIT(vap);

	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_chain_get_32(error, nmreq, how);
		nfsmerr_if(error);
		<span class="enscript-keyword">switch</span> (how) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_CREATE_GUARDED</span>:
			<span class="enscript-keyword">if</span> (vp) {
				error = EEXIST;
				<span class="enscript-keyword">break</span>;
			}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_CREATE_UNCHECKED</span>:
			error = nfsm_chain_get_sattr(nd, nmreq, vap);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_CREATE_EXCLUSIVE</span>:
			nfsm_chain_get_opaque(error, nmreq, NFSX_V3CREATEVERF, cverf);
			exclusive_flag = 1;
			<span class="enscript-keyword">if</span> (vp == NULL)
				VATTR_SET(vap, va_mode, 0);
			<span class="enscript-keyword">break</span>;
		};
		VATTR_SET(vap, va_type, VREG);
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-type">enum</span> vtype v_type;

		error = nfsm_chain_get_sattr(nd, nmreq, vap);
		nfsmerr_if(error);
		v_type = vap-&gt;va_type;
		<span class="enscript-keyword">if</span> (v_type == VNON)
			v_type = VREG;
		VATTR_SET(vap, va_type, v_type);

		<span class="enscript-keyword">switch</span> (v_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VCHR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VBLK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">VFIFO</span>:
			rdev = vap-&gt;va_data_size;
			VATTR_CLEAR_ACTIVE(vap, va_data_size);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		};
	}
	nfsmerr_if(error);

	<span class="enscript-comment">/*
	 * If it doesn't exist, create it
	 * otherwise just truncate to 0 length
	 *   should I set the mode too ??
	 */</span>
	<span class="enscript-keyword">if</span> (vp == NULL) {
	        kauth_acl_t xacl = NULL;

		<span class="enscript-comment">/* authorize before creating */</span>
		error = nfsrv_authorize(dvp, NULL, KAUTH_VNODE_ADD_FILE, ctx, nxo, 0);

		<span class="enscript-comment">/* construct ACL and handle inheritance */</span>
		<span class="enscript-keyword">if</span> (!error) {
			error = kauth_acl_inherit(dvp,
			    NULL,
			    &amp;xacl,
			    0 <span class="enscript-comment">/* !isdir */</span>,
			    ctx);

			<span class="enscript-keyword">if</span> (!error &amp;&amp; xacl != NULL)
			        VATTR_SET(vap, va_acl, xacl);
		}
		VATTR_CLEAR_ACTIVE(vap, va_data_size);
		VATTR_CLEAR_ACTIVE(vap, va_access_time);
		<span class="enscript-comment">/*
		 * Server policy is to alway use the mapped rpc credential for 
		 * file system object creation. This has the nice side effect of
		 * enforcing BSD creation semantics
		 */</span>
		VATTR_CLEAR_ACTIVE(vap, va_uid);
		VATTR_CLEAR_ACTIVE(vap, va_gid);

		<span class="enscript-comment">/* validate new-file security information */</span>
		<span class="enscript-keyword">if</span> (!error) 
			error = vnode_authattr_new(dvp, vap, 0, ctx);

		<span class="enscript-keyword">if</span> (vap-&gt;va_type == VREG || vap-&gt;va_type == VSOCK) {

			<span class="enscript-keyword">if</span> (!error)
				error = VNOP_CREATE(dvp, &amp;vp, &amp;ni.ni_cnd, vap, ctx);

			<span class="enscript-keyword">if</span> (!error &amp;&amp; !VATTR_ALL_SUPPORTED(vap))
			        <span class="enscript-comment">/*
				 * If some of the requested attributes weren't handled by the VNOP,
				 * use our fallback code.
				 */</span>
				error = vnode_setattr_fallback(vp, vap, ctx);

			<span class="enscript-keyword">if</span> (xacl != NULL)
				kauth_acl_free(xacl);

			<span class="enscript-keyword">if</span> (!error) {
				<span class="enscript-keyword">if</span> (exclusive_flag) {
					exclusive_flag = 0;
					VATTR_INIT(vap);
					bcopy(cverf, (caddr_t)&amp;vap-&gt;va_access_time,
						NFSX_V3CREATEVERF);
					VATTR_SET_ACTIVE(vap, va_access_time);
					<span class="enscript-comment">// skip authorization, as this is an
</span>					<span class="enscript-comment">// NFS internal implementation detail.
</span>					error = vnode_setattr(vp, vap, ctx);
				}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
				<span class="enscript-keyword">if</span> (nfsrv_fsevents_enabled &amp;&amp; need_fsevent(FSE_CREATE_FILE, vp)) {
				        add_fsevent(FSE_CREATE_FILE, ctx,
						    FSE_ARG_VNODE, vp,
						    FSE_ARG_DONE);
				}
#<span class="enscript-reference">endif</span>
			}

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vap-&gt;va_type == VCHR || vap-&gt;va_type == VBLK ||
			vap-&gt;va_type == VFIFO) {
			<span class="enscript-keyword">if</span> (vap-&gt;va_type == VCHR &amp;&amp; rdev == (<span class="enscript-type">int</span>)0xffffffff)
				VATTR_SET(vap, va_type, VFIFO);
			<span class="enscript-keyword">if</span> (vap-&gt;va_type != VFIFO) {
				error = suser(nd-&gt;nd_cr, NULL);
				nfsmerr_if(error);
			}
			VATTR_SET(vap, va_rdev, (dev_t)rdev);

			error = VNOP_MKNOD(dvp, &amp;vp, &amp;ni.ni_cnd, vap, ctx);

			<span class="enscript-keyword">if</span> (xacl != NULL)
				kauth_acl_free(xacl);

			nfsmerr_if(error);

			<span class="enscript-keyword">if</span> (vp) {
				vnode_recycle(vp);
				vnode_put(vp);
				vp = NULL;
			}
			ni.ni_cnd.cn_nameiop = LOOKUP;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
			ni.ni_op = OP_LOOKUP;
#<span class="enscript-reference">endif</span>
			ni.ni_cnd.cn_flags &amp;= ~LOCKPARENT;
			ni.ni_cnd.cn_context = ctx;
			ni.ni_startdir = dvp;
			ni.ni_usedvp   = dvp;
			cnflags = ni.ni_cnd.cn_flags; <span class="enscript-comment">/* store in case we have to restore */</span>
			<span class="enscript-keyword">while</span> ((error = lookup(&amp;ni)) == ERECYCLE) {
				ni.ni_cnd.cn_flags = cnflags;
				ni.ni_cnd.cn_nameptr = ni.ni_cnd.cn_pnbuf;
				ni.ni_usedvp = ni.ni_dvp = ni.ni_startdir = dvp;
			}
			<span class="enscript-keyword">if</span> (!error) {
				<span class="enscript-keyword">if</span> (ni.ni_cnd.cn_flags &amp; ISSYMLINK)
					error = EINVAL;
				vp = ni.ni_vp;
			}
			nfsmerr_if(error);
		} <span class="enscript-keyword">else</span> {
			error = ENXIO;
		}
		<span class="enscript-comment">/*
		 * nameidone has to happen before we vnode_put(dvp)
		 * since it may need to release the fs_nodelock on the dvp
		 */</span>
		nameidone(&amp;ni);
		ni.ni_cnd.cn_nameiop = 0;

		vnode_put(dvp);
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-comment">/*
		 * nameidone has to happen before we vnode_put(dvp)
		 * since it may need to release the fs_nodelock on the dvp
		 */</span>
	        nameidone(&amp;ni);
		ni.ni_cnd.cn_nameiop = 0;

		vnode_put(dvp);

		<span class="enscript-keyword">if</span> (!error &amp;&amp; VATTR_IS_ACTIVE(vap, va_data_size)) {
			error = nfsrv_authorize(vp, NULL, KAUTH_VNODE_WRITE_DATA,
			    ctx, nxo, 0);
			<span class="enscript-keyword">if</span> (!error) {
				tempsize = vap-&gt;va_data_size;
				VATTR_INIT(vap);
				VATTR_SET(vap, va_data_size, tempsize);
				error = vnode_setattr(vp, vap, ctx);
			}
		}
	}
	<span class="enscript-keyword">if</span> (!error) {
		error = nfsrv_vptofh(nx, nd-&gt;nd_vers, NULL, vp, ctx, &amp;nfh);
		<span class="enscript-keyword">if</span> (!error) {
			nfsm_srv_vattr_init(&amp;postattr, nd-&gt;nd_vers);
			postattrerr = vnode_getattr(vp, &amp;postattr, ctx);
			<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER2)
				error = postattrerr;
		}
	}
	<span class="enscript-keyword">if</span> (vp)
	        vnode_put(vp);

	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		<span class="enscript-keyword">if</span> (exclusive_flag &amp;&amp; !error &amp;&amp;
		    bcmp(cverf, &amp;postattr.va_access_time, NFSX_V3CREATEVERF))
			error = EEXIST;
		nfsm_srv_vattr_init(&amp;dpostattr, NFS_VER3);
		dpostattrerr = vnode_getattr(dirp, &amp;dpostattr, ctx);
		vnode_put(dirp);
		dirp = NULL;
	}

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_SRVFH(nd-&gt;nd_vers, &amp;nfh) +
			NFSX_FATTR(nd-&gt;nd_vers) + NFSX_WCCDATA(nd-&gt;nd_vers));
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		<span class="enscript-keyword">if</span> (!nd-&gt;nd_repstat) {
			nfsm_chain_add_postop_fh(error, &amp;nmrep, nfh.nfh_fhp, nfh.nfh_len);
			nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, postattrerr, &amp;postattr);
		}
		nfsm_chain_add_wcc_data(error, nd, &amp;nmrep,
			dpreattrerr, &amp;dpreattr, dpostattrerr, &amp;dpostattr);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_fh(error, &amp;nmrep, NFS_VER2, nfh.nfh_fhp, nfh.nfh_len);
		<span class="enscript-keyword">if</span> (!error)
			error = nfsm_chain_add_fattr(nd, &amp;nmrep, &amp;postattr);
	}
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (ni.ni_cnd.cn_nameiop) {
	        <span class="enscript-comment">/*
		 * nameidone has to happen before we vnode_put(dvp)
		 * since it may need to release the fs_nodelock on the dvp
		 */</span>
		nameidone(&amp;ni);

		<span class="enscript-keyword">if</span> (vp)
			vnode_put(vp);
		vnode_put(dvp);
	}
	<span class="enscript-keyword">if</span> (dirp)
		vnode_put(dirp);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs v3 mknod service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_mknod</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> vnode_attr dpreattr, dpostattr, postattr;
	<span class="enscript-type">struct</span> vnode_attr va, *vap = &amp;va;
	<span class="enscript-type">struct</span> nameidata ni;
	<span class="enscript-type">int</span> error, dpreattrerr, dpostattrerr, postattrerr;
	uint32_t len = 0, cnflags;
	u_int32_t major = 0, minor = 0;
	<span class="enscript-type">enum</span> vtype vtyp;
	nfstype nvtype;
	vnode_t vp, dvp, dirp;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx = NULL;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	uid_t saved_uid;
	kauth_acl_t xacl = NULL;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	dpreattrerr = dpostattrerr = postattrerr = ENOENT;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	vp = dvp = dirp = NULL;
	ni.ni_cnd.cn_nameiop = 0;

	saved_uid = kauth_cred_getuid(nd-&gt;nd_cr);

	nfsm_chain_get_fh_ptr(error, nmreq, NFS_VER3, nfh.nfh_fhp, nfh.nfh_len);
	nfsm_chain_get_32(error, nmreq, len);
	nfsm_name_len_check(error, nd, len);
	nfsmerr_if(error);

	ni.ni_cnd.cn_nameiop = CREATE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	ni.ni_op = OP_LINK;
#<span class="enscript-reference">endif</span>
	ni.ni_cnd.cn_flags = LOCKPARENT | LOCKLEAF;
	error = nfsm_chain_get_path_namei(nmreq, len, &amp;ni);
	<span class="enscript-keyword">if</span> (!error) {
		error = nfsrv_namei(nd, ctx, &amp;ni, &amp;nfh, &amp;dirp, &amp;nx, &amp;nxo);
		<span class="enscript-keyword">if</span> (nx != NULL) {
			<span class="enscript-comment">/* update export stats */</span>
			NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

			<span class="enscript-comment">/* update active user stats */</span>
			nfsrv_update_user_stat(nx, nd, saved_uid, 1, 0, 0);
		}
	}
	<span class="enscript-keyword">if</span> (dirp) {
		nfsm_srv_pre_vattr_init(&amp;dpreattr);
		dpreattrerr = vnode_getattr(dirp, &amp;dpreattr, ctx);
	}
	<span class="enscript-keyword">if</span> (error) {
		ni.ni_cnd.cn_nameiop = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmerr</span>;
	}

	dvp = ni.ni_dvp;
	vp = ni.ni_vp;

	nfsm_chain_get_32(error, nmreq, nvtype);
	nfsmerr_if(error);
	vtyp = nfstov_type(nvtype, NFS_VER3);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (vtyp != VCHR) &amp;&amp; (vtyp != VBLK) &amp;&amp; (vtyp != VSOCK) &amp;&amp; (vtyp != VFIFO)) {
		error = NFSERR_BADTYPE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	VATTR_INIT(vap);
	error = nfsm_chain_get_sattr(nd, nmreq, vap);
	<span class="enscript-keyword">if</span> ((vtyp == VCHR) || (vtyp == VBLK)) {
		nfsm_chain_get_32(error, nmreq, major);
		nfsm_chain_get_32(error, nmreq, minor);
		nfsmerr_if(error);
		VATTR_SET(vap, va_rdev, makedev(major, minor));
	}
	nfsmerr_if(error);

	<span class="enscript-comment">/*
	 * If it doesn't exist, create it.
	 */</span>
	<span class="enscript-keyword">if</span> (vp) {
		error = EEXIST;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	VATTR_SET(vap, va_type, vtyp);

	<span class="enscript-comment">/* authorize before creating */</span>
	error = nfsrv_authorize(dvp, NULL, KAUTH_VNODE_ADD_FILE, ctx, nxo, 0);

	<span class="enscript-comment">/* construct ACL and handle inheritance */</span>
	<span class="enscript-keyword">if</span> (!error) {
		error = kauth_acl_inherit(dvp,
		    NULL,
		    &amp;xacl,
		    0 <span class="enscript-comment">/* !isdir */</span>,
		    ctx);

		<span class="enscript-keyword">if</span> (!error &amp;&amp; xacl != NULL)
		        VATTR_SET(vap, va_acl, xacl);
	}
	VATTR_CLEAR_ACTIVE(vap, va_data_size);
	VATTR_CLEAR_ACTIVE(vap, va_access_time);
	<span class="enscript-comment">/*
	 * Server policy is to alway use the mapped rpc credential for 
	 * file system object creation. This has the nice side effect of
	 * enforcing BSD creation semantics
	 */</span>
	VATTR_CLEAR_ACTIVE(vap, va_uid);
	VATTR_CLEAR_ACTIVE(vap, va_gid);

	<span class="enscript-comment">/* validate new-file security information */</span>
	<span class="enscript-keyword">if</span> (!error) 
		error = vnode_authattr_new(dvp, vap, 0, ctx);

	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;

	<span class="enscript-keyword">if</span> (vtyp == VSOCK) {
		error = VNOP_CREATE(dvp, &amp;vp, &amp;ni.ni_cnd, vap, ctx);

		<span class="enscript-keyword">if</span> (!error &amp;&amp; !VATTR_ALL_SUPPORTED(vap))
		        <span class="enscript-comment">/*
			 * If some of the requested attributes weren't handled by the VNOP,
			 * use our fallback code.
			 */</span>
			error = vnode_setattr_fallback(vp, vap, ctx);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (vtyp != VFIFO &amp;&amp; (error = suser(nd-&gt;nd_cr, (u_short *)0)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		<span class="enscript-keyword">if</span> ((error = VNOP_MKNOD(dvp, &amp;vp, &amp;ni.ni_cnd, vap, ctx)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		<span class="enscript-keyword">if</span> (vp) {
			vnode_recycle(vp);
			vnode_put(vp);
			vp = NULL;
		}
		ni.ni_cnd.cn_nameiop = LOOKUP;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
		ni.ni_op = OP_LOOKUP;
#<span class="enscript-reference">endif</span>
		ni.ni_cnd.cn_flags &amp;= ~LOCKPARENT;
		ni.ni_cnd.cn_context = vfs_context_current();
		ni.ni_startdir = dvp;
		ni.ni_usedvp   = dvp;
		cnflags = ni.ni_cnd.cn_flags; <span class="enscript-comment">/* store in case we have to restore */</span>
		<span class="enscript-keyword">while</span> ((error = lookup(&amp;ni)) == ERECYCLE) {
			ni.ni_cnd.cn_flags = cnflags;
			ni.ni_cnd.cn_nameptr = ni.ni_cnd.cn_pnbuf;
			ni.ni_usedvp = ni.ni_dvp = ni.ni_startdir = dvp;
		}
		<span class="enscript-keyword">if</span> (!error) {
		        vp = ni.ni_vp;
			<span class="enscript-keyword">if</span> (ni.ni_cnd.cn_flags &amp; ISSYMLINK)
			        error = EINVAL;
		}
	}
<span class="enscript-reference">out1</span>:
	<span class="enscript-keyword">if</span> (xacl != NULL)
		kauth_acl_free(xacl);
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/*
	 * nameidone has to happen before we vnode_put(dvp)
	 * since it may need to release the fs_nodelock on the dvp
	 */</span>
	nameidone(&amp;ni);
	ni.ni_cnd.cn_nameiop = 0;

	vnode_put(dvp);
	dvp = NULL;

	<span class="enscript-keyword">if</span> (!error) {
		error = nfsrv_vptofh(nx, NFS_VER3, NULL, vp, ctx, &amp;nfh);
		<span class="enscript-keyword">if</span> (!error) {
			nfsm_srv_vattr_init(&amp;postattr, NFS_VER3);
			postattrerr = vnode_getattr(vp, &amp;postattr, ctx);
		}
	}
	<span class="enscript-keyword">if</span> (vp) {
		vnode_put(vp);
		vp = NULL;
	}

	nfsm_srv_vattr_init(&amp;dpostattr, NFS_VER3);
	dpostattrerr = vnode_getattr(dirp, &amp;dpostattr, ctx);
	vnode_put(dirp);
	dirp = NULL;

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_SRVFH(NFS_VER3, &amp;nfh) +
			NFSX_POSTOPATTR(NFS_VER3) + NFSX_WCCDATA(NFS_VER3));
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	<span class="enscript-keyword">if</span> (!nd-&gt;nd_repstat) {
		nfsm_chain_add_postop_fh(error, &amp;nmrep, nfh.nfh_fhp, nfh.nfh_len);
		nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, postattrerr, &amp;postattr);
	}
	nfsm_chain_add_wcc_data(error, nd, &amp;nmrep,
		dpreattrerr, &amp;dpreattr, dpostattrerr, &amp;dpostattr);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (ni.ni_cnd.cn_nameiop) {
	        <span class="enscript-comment">/*
		 * nameidone has to happen before we vnode_put(dvp)
		 * since it may need to release the fs_nodelock on the dvp
		 */</span>
		nameidone(&amp;ni);

		<span class="enscript-keyword">if</span> (vp)
			vnode_put(vp);
		vnode_put(dvp);
	}
	<span class="enscript-keyword">if</span> (dvp)
		vnode_put(dvp);
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);
	<span class="enscript-keyword">if</span> (dirp)
		vnode_put(dirp);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs remove service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_remove</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> nameidata ni;
	<span class="enscript-type">int</span> error, dpreattrerr, dpostattrerr;
	uint32_t len = 0;
	uid_t saved_uid;
	vnode_t vp, dvp, dirp = NULL;
	<span class="enscript-type">struct</span> vnode_attr dpreattr, dpostattr;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx = NULL;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	dpreattrerr = dpostattrerr = ENOENT;
	saved_uid = kauth_cred_getuid(nd-&gt;nd_cr);
	dvp = vp = dirp = NULL;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	nfsm_chain_get_32(error, nmreq, len);
	nfsm_name_len_check(error, nd, len);
	nfsmerr_if(error);

	ni.ni_cnd.cn_nameiop = DELETE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	ni.ni_op = OP_UNLINK;
#<span class="enscript-reference">endif</span>
	ni.ni_cnd.cn_flags = LOCKPARENT | LOCKLEAF;
	error = nfsm_chain_get_path_namei(nmreq, len, &amp;ni);
	<span class="enscript-keyword">if</span> (!error) {
		error = nfsrv_namei(nd, ctx, &amp;ni, &amp;nfh, &amp;dirp, &amp;nx, &amp;nxo);
		<span class="enscript-keyword">if</span> (nx != NULL) {
			<span class="enscript-comment">/* update export stats */</span>
			NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

			<span class="enscript-comment">/* update active user stats */</span>
			nfsrv_update_user_stat(nx, nd, saved_uid, 1, 0, 0);
		}
	}
	<span class="enscript-keyword">if</span> (dirp) {
	        <span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
			nfsm_srv_pre_vattr_init(&amp;dpreattr);
			dpreattrerr = vnode_getattr(dirp, &amp;dpreattr, ctx);
		} <span class="enscript-keyword">else</span> {
			vnode_put(dirp);
			dirp = NULL;
		}
	}

	<span class="enscript-keyword">if</span> (!error) {
		dvp = ni.ni_dvp;
		vp = ni.ni_vp;

		<span class="enscript-keyword">if</span> (vnode_vtype(vp) == VDIR)
			error = EPERM;		<span class="enscript-comment">/* POSIX */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vnode_isvroot(vp))
		        <span class="enscript-comment">/*
			 * The root of a mounted filesystem cannot be deleted.
			 */</span>
			error = EBUSY;
		<span class="enscript-keyword">else</span>
			error = nfsrv_authorize(vp, dvp, KAUTH_VNODE_DELETE, ctx, nxo, 0);

		<span class="enscript-keyword">if</span> (!error) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
			<span class="enscript-type">char</span>     *path = NULL;
			<span class="enscript-type">int</span>       plen;
			fse_info  finfo;
	
			<span class="enscript-keyword">if</span> (nfsrv_fsevents_enabled &amp;&amp; need_fsevent(FSE_DELETE, dvp)) {
				plen = MAXPATHLEN;
				<span class="enscript-keyword">if</span> ((path = get_pathbuff()) &amp;&amp; !vn_getpath(vp, path, &amp;plen)) {
					get_fse_info(vp, &amp;finfo, ctx);
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (path) {
					release_pathbuff(path);
					path = NULL;
				}
			}
#<span class="enscript-reference">endif</span>
		    	error = VNOP_REMOVE(dvp, vp, &amp;ni.ni_cnd, 0, ctx);
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
			<span class="enscript-keyword">if</span> (path) {
				<span class="enscript-keyword">if</span> (!error)
					add_fsevent(FSE_DELETE, ctx,
						    FSE_ARG_STRING, plen, path,
						    FSE_ARG_FINFO, &amp;finfo,
						    FSE_ARG_DONE);
			        release_pathbuff(path);
			}
#<span class="enscript-reference">endif</span>
		}

		<span class="enscript-comment">/*
		 * nameidone has to happen before we vnode_put(dvp)
		 * since it may need to release the fs_nodelock on the dvp
		 */</span>
		nameidone(&amp;ni);

		vnode_put(vp);
	        vnode_put(dvp);
	}

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-keyword">if</span> (dirp) {
		nfsm_srv_vattr_init(&amp;dpostattr, nd-&gt;nd_vers);
	        dpostattrerr = vnode_getattr(dirp, &amp;dpostattr, ctx);
		vnode_put(dirp);
	}

	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_WCCDATA(nd-&gt;nd_vers));
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
		nfsm_chain_add_wcc_data(error, nd, &amp;nmrep,
			dpreattrerr, &amp;dpreattr, dpostattrerr, &amp;dpostattr);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs rename service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_rename</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	kauth_cred_t saved_cred = NULL;
	uid_t saved_uid;
	<span class="enscript-type">int</span> error;
	uint32_t fromlen, tolen;
	<span class="enscript-type">int</span> fdpreattrerr, fdpostattrerr;
	<span class="enscript-type">int</span> tdpreattrerr, tdpostattrerr;
	<span class="enscript-type">char</span> *frompath = NULL, *topath = NULL;
	<span class="enscript-type">struct</span> nameidata fromni, toni;
	vnode_t fvp, tvp, tdvp, fdvp, fdirp, tdirp;
	<span class="enscript-type">struct</span> vnode_attr fdpreattr, fdpostattr;
	<span class="enscript-type">struct</span> vnode_attr tdpreattr, tdpostattr;
	<span class="enscript-type">struct</span> nfs_filehandle fnfh, tnfh;
	<span class="enscript-type">struct</span> nfs_export *fnx, *tnx;
	<span class="enscript-type">struct</span> nfs_export_options *fnxo, *tnxo;
	<span class="enscript-type">enum</span> vtype fvtype, tvtype;
	<span class="enscript-type">int</span> holding_mntlock;
	mount_t locked_mp;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;
	<span class="enscript-type">char</span> *from_name, *to_name;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-type">int</span> from_len=0, to_len=0;
	fse_info from_finfo, to_finfo;
#<span class="enscript-reference">endif</span>
	u_char didstats = 0;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *oname;

	error = 0;
	fdpreattrerr = fdpostattrerr = ENOENT;
	tdpreattrerr = tdpostattrerr = ENOENT;
	saved_uid = kauth_cred_getuid(nd-&gt;nd_cr);
	fromlen = tolen = 0;
	frompath = topath = NULL;
	fdirp = tdirp = NULL;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">/*
	 * these need to be set before calling any code
	 * that they may take us out through the error path.
	 */</span>
	holding_mntlock = 0;
	fvp = tvp = NULL;
	fdvp = tdvp = NULL;
	locked_mp = NULL;

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, fnfh.nfh_fhp, fnfh.nfh_len);
	nfsm_chain_get_32(error, nmreq, fromlen);
	nfsm_name_len_check(error, nd, fromlen);
	nfsmerr_if(error);
	error = nfsm_chain_get_path_namei(nmreq, fromlen, &amp;fromni);
	nfsmerr_if(error);
	frompath = fromni.ni_cnd.cn_pnbuf;

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, tnfh.nfh_fhp, tnfh.nfh_len);
	nfsm_chain_get_32(error, nmreq, tolen);
	nfsm_name_len_check(error, nd, tolen);
	nfsmerr_if(error);
	error = nfsm_chain_get_path_namei(nmreq, tolen, &amp;toni);
	nfsmerr_if(error);
	topath = toni.ni_cnd.cn_pnbuf;

	<span class="enscript-comment">/*
	 * Remember our original uid so that we can reset cr_uid before
	 * the second nfsrv_namei() call, in case it is remapped.
	 */</span>
	saved_cred = nd-&gt;nd_cr;
	kauth_cred_ref(saved_cred);
<span class="enscript-reference">retry</span>:
	fromni.ni_cnd.cn_nameiop = DELETE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	fromni.ni_op = OP_UNLINK;
#<span class="enscript-reference">endif</span>
	fromni.ni_cnd.cn_flags = WANTPARENT;

	fromni.ni_cnd.cn_pnbuf = frompath;
	frompath = NULL;
	fromni.ni_cnd.cn_pnlen = MAXPATHLEN;
	fromni.ni_cnd.cn_flags |= HASBUF;

	error = nfsrv_namei(nd, ctx, &amp;fromni, &amp;fnfh, &amp;fdirp, &amp;fnx, &amp;fnxo);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	fdvp = fromni.ni_dvp;
	fvp  = fromni.ni_vp;

	<span class="enscript-keyword">if</span> (fdirp) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
			nfsm_srv_pre_vattr_init(&amp;fdpreattr);
			fdpreattrerr = vnode_getattr(fdirp, &amp;fdpreattr, ctx);
		} <span class="enscript-keyword">else</span> {
			vnode_put(fdirp);
			fdirp = NULL;
		}
	}
	fvtype = vnode_vtype(fvp);

	<span class="enscript-comment">/* reset credential if it was remapped */</span>
	<span class="enscript-keyword">if</span> (nd-&gt;nd_cr != saved_cred) {
		kauth_cred_ref(saved_cred);
		kauth_cred_unref(&amp;nd-&gt;nd_cr);
		ctx-&gt;vc_ucred = nd-&gt;nd_cr = saved_cred;
	}

	toni.ni_cnd.cn_nameiop = RENAME;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	toni.ni_op = OP_RENAME;
#<span class="enscript-reference">endif</span>
	toni.ni_cnd.cn_flags = WANTPARENT;

	toni.ni_cnd.cn_pnbuf = topath;
	topath = NULL;
	toni.ni_cnd.cn_pnlen = MAXPATHLEN;
	toni.ni_cnd.cn_flags |= HASBUF;

	<span class="enscript-keyword">if</span> (fvtype == VDIR)
		toni.ni_cnd.cn_flags |= WILLBEDIR;

	tnx = NULL;
	error = nfsrv_namei(nd, ctx, &amp;toni, &amp;tnfh, &amp;tdirp, &amp;tnx, &amp;tnxo);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/*
		 * Translate error code for rename(&quot;dir1&quot;, &quot;dir2/.&quot;).
		 */</span>
	        <span class="enscript-keyword">if</span> (error == EISDIR &amp;&amp; fvtype == VDIR) {
		        <span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
			        error = EINVAL;
			<span class="enscript-keyword">else</span>
			        error = ENOTEMPTY;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	tdvp = toni.ni_dvp;
	tvp  = toni.ni_vp;

	<span class="enscript-keyword">if</span> (!didstats) {
		<span class="enscript-comment">/* update export stats once only */</span>
		<span class="enscript-keyword">if</span> (tnx != NULL) {
			<span class="enscript-comment">/* update export stats */</span>
			NFSStatAdd64(&amp;tnx-&gt;nx_stats.ops, 1);

			<span class="enscript-comment">/* update active user stats */</span>
			nfsrv_update_user_stat(tnx, nd, saved_uid, 1, 0, 0);
			didstats = 1;
		}
	}

	<span class="enscript-keyword">if</span> (tdirp) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
			nfsm_srv_pre_vattr_init(&amp;tdpreattr);
			tdpreattrerr = vnode_getattr(tdirp, &amp;tdpreattr, ctx);
		} <span class="enscript-keyword">else</span> {
			vnode_put(tdirp);
			tdirp = NULL;
		}
	}

	<span class="enscript-keyword">if</span> (tvp != NULL) {
		tvtype = vnode_vtype(tvp);

		<span class="enscript-keyword">if</span> (fvtype == VDIR &amp;&amp; tvtype != VDIR) {
			<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
				error = EEXIST;
			<span class="enscript-keyword">else</span>
				error = EISDIR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fvtype != VDIR &amp;&amp; tvtype == VDIR) {
			<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
				error = EEXIST;
			<span class="enscript-keyword">else</span>
				error = ENOTDIR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (tvtype == VDIR &amp;&amp; vnode_mountedhere(tvp)) {
			<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
				error = EXDEV;
			<span class="enscript-keyword">else</span>
				error = ENOTEMPTY;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	<span class="enscript-keyword">if</span> (fvp == tdvp) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
			error = EINVAL;
		<span class="enscript-keyword">else</span>
			error = ENOTEMPTY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Authorization.
	 *
	 * If tvp is a directory and not the same as fdvp, or tdvp is not the same as fdvp,
	 * the node is moving between directories and we need rights to remove from the
	 * old and add to the new.
	 *
	 * If tvp already exists and is not a directory, we need to be allowed to delete it.
	 *
	 * Note that we do not inherit when renaming.  XXX this needs to be revisited to
	 * implement the deferred-inherit bit.
	 */</span>
	{
		<span class="enscript-type">int</span> moving = 0;

		error = 0;
		<span class="enscript-keyword">if</span> ((tvp != NULL) &amp;&amp; vnode_isdir(tvp)) {
			<span class="enscript-keyword">if</span> (tvp != fdvp)
				moving = 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tdvp != fdvp) {
			moving = 1;
		}
		<span class="enscript-keyword">if</span> (moving) {
			<span class="enscript-comment">/* moving out of fdvp, must have delete rights */</span>
			<span class="enscript-keyword">if</span> ((error = nfsrv_authorize(fvp, fdvp, KAUTH_VNODE_DELETE, ctx, fnxo, 0)) != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">auth_exit</span>;
			<span class="enscript-comment">/* moving into tdvp or tvp, must have rights to add */</span>
			<span class="enscript-keyword">if</span> ((error = nfsrv_authorize(((tvp != NULL) &amp;&amp; vnode_isdir(tvp)) ? tvp : tdvp,
				 NULL,
				 vnode_isdir(fvp) ? KAUTH_VNODE_ADD_SUBDIRECTORY : KAUTH_VNODE_ADD_FILE,
				 ctx, tnxo, 0)) != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">auth_exit</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* node staying in same directory, must be allowed to add new name */</span>
			<span class="enscript-keyword">if</span> ((error = nfsrv_authorize(fdvp, NULL,
				 vnode_isdir(fvp) ? KAUTH_VNODE_ADD_SUBDIRECTORY : KAUTH_VNODE_ADD_FILE,
				 ctx, fnxo, 0)) != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">auth_exit</span>;
		}
		<span class="enscript-comment">/* overwriting tvp */</span>
		<span class="enscript-keyword">if</span> ((tvp != NULL) &amp;&amp; !vnode_isdir(tvp) &amp;&amp;
		    ((error = nfsrv_authorize(tvp, tdvp, KAUTH_VNODE_DELETE, ctx, tnxo, 0)) != 0))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">auth_exit</span>;

		<span class="enscript-comment">/* XXX more checks? */</span>

<span class="enscript-reference">auth_exit</span>:
		<span class="enscript-comment">/* authorization denied */</span>
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> ((vnode_mount(fvp) != vnode_mount(tdvp)) ||
	    (tvp &amp;&amp; (vnode_mount(fvp) != vnode_mount(tvp)))) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
			error = EXDEV;
		<span class="enscript-keyword">else</span>
			error = ENOTEMPTY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/*
	 * The following edge case is caught here:
	 * (to cannot be a descendent of from)
	 *
	 *       o fdvp
	 *      /
	 *     /
	 *    o fvp
	 *     \
	 *      \
	 *       o tdvp
	 *      /
	 *     /
	 *    o tvp
	 */</span>
	<span class="enscript-keyword">if</span> (tdvp-&gt;v_parent == fvp) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
			error = EXDEV;
		<span class="enscript-keyword">else</span>
			error = ENOTEMPTY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (fvtype == VDIR &amp;&amp; vnode_mountedhere(fvp)) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
			error = EXDEV;
		<span class="enscript-keyword">else</span>
			error = ENOTEMPTY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/*
	 * If source is the same as the destination (that is the
	 * same vnode) then there is nothing to do...
	 * EXCEPT if the underlying file system supports case
	 * insensitivity and is case preserving.  In this case
	 * the file system needs to handle the special case of
	 * getting the same vnode as target (fvp) and source (tvp).
	 *
	 * Only file systems that support pathconf selectors _PC_CASE_SENSITIVE
	 * and _PC_CASE_PRESERVING can have this exception, and they need to
	 * handle the special case of getting the same vnode as target and
	 * source.  NOTE: Then the target is unlocked going into vnop_rename,
	 * so not to cause locking problems. There is a single reference on tvp.
	 *
	 * NOTE - that fvp == tvp also occurs if they are hard linked - NOTE
	 * that correct behaviour then is just to remove the source (link)
	 */</span>
	<span class="enscript-keyword">if</span> ((fvp == tvp) &amp;&amp; (fdvp == tdvp)) {
		<span class="enscript-keyword">if</span> (fromni.ni_cnd.cn_namelen == toni.ni_cnd.cn_namelen &amp;&amp;
	       	    !bcmp(fromni.ni_cnd.cn_nameptr, toni.ni_cnd.cn_nameptr,
			  fromni.ni_cnd.cn_namelen)) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-keyword">if</span> (holding_mntlock &amp;&amp; vnode_mount(fvp) != locked_mp) {
	        <span class="enscript-comment">/*
		 * we're holding a reference and lock
		 * on locked_mp, but it no longer matches
		 * what we want to do... so drop our hold
		 */</span>
		mount_unlock_renames(locked_mp);
		mount_drop(locked_mp, 0);
	        holding_mntlock = 0;
	}
	<span class="enscript-keyword">if</span> (tdvp != fdvp &amp;&amp; fvtype == VDIR) {
	        <span class="enscript-comment">/*
		 * serialize renames that re-shape
		 * the tree... if holding_mntlock is
		 * set, then we're ready to go...
		 * otherwise we
		 * first need to drop the iocounts
		 * we picked up, second take the
		 * lock to serialize the access,
		 * then finally start the lookup
		 * process over with the lock held
		 */</span>
	        <span class="enscript-keyword">if</span> (!holding_mntlock) {
		        <span class="enscript-comment">/*
			 * need to grab a reference on
			 * the mount point before we
			 * drop all the iocounts... once
			 * the iocounts are gone, the mount
			 * could follow
			 */</span>
			locked_mp = vnode_mount(fvp);
			mount_ref(locked_mp, 0);

			<span class="enscript-comment">/* make a copy of to path to pass to nfsrv_namei() again */</span>
			MALLOC_ZONE(topath, caddr_t, MAXPATHLEN, M_NAMEI, M_WAITOK);
			<span class="enscript-keyword">if</span> (topath)
				bcopy(toni.ni_cnd.cn_pnbuf, topath, tolen + 1);

			<span class="enscript-comment">/*
			 * nameidone has to happen before we vnode_put(tdvp)
			 * since it may need to release the fs_nodelock on the tdvp
			 */</span>
			nameidone(&amp;toni);

			<span class="enscript-keyword">if</span> (tvp)
			        vnode_put(tvp);
			vnode_put(tdvp);

			<span class="enscript-comment">/* make a copy of from path to pass to nfsrv_namei() again */</span>
			MALLOC_ZONE(frompath, caddr_t, MAXPATHLEN, M_NAMEI, M_WAITOK);
			<span class="enscript-keyword">if</span> (frompath)
				bcopy(fromni.ni_cnd.cn_pnbuf, frompath, fromlen + 1);

			<span class="enscript-comment">/*
			 * nameidone has to happen before we vnode_put(fdvp)
			 * since it may need to release the fs_nodelock on the fdvp
			 */</span>
			nameidone(&amp;fromni);

			vnode_put(fvp);
			vnode_put(fdvp);

			<span class="enscript-keyword">if</span> (fdirp) {
			        vnode_put(fdirp);
				fdirp = NULL;
			}
			<span class="enscript-keyword">if</span> (tdirp) {
			        vnode_put(tdirp);
				tdirp = NULL;
			}
			mount_lock_renames(locked_mp);
			holding_mntlock = 1;

			fvp = tvp = NULL;
			fdvp = tdvp = NULL;

			fdpreattrerr = tdpreattrerr = ENOENT;

			<span class="enscript-keyword">if</span> (!topath || !frompath) {
				<span class="enscript-comment">/* we couldn't allocate a path, so bail */</span>
				error = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			<span class="enscript-comment">/* reset credential if it was remapped */</span>
			<span class="enscript-keyword">if</span> (nd-&gt;nd_cr != saved_cred) {
				kauth_cred_ref(saved_cred);
				kauth_cred_unref(&amp;nd-&gt;nd_cr);
				ctx-&gt;vc_ucred = nd-&gt;nd_cr = saved_cred;
			}

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}
	} <span class="enscript-keyword">else</span> {
	        <span class="enscript-comment">/*
		 * when we dropped the iocounts to take
		 * the lock, we allowed the identity of
		 * the various vnodes to change... if they did,
		 * we may no longer be dealing with a rename
		 * that reshapes the tree... once we're holding
		 * the iocounts, the vnodes can't change type
		 * so we're free to drop the lock at this point
		 * and continue on
		 */</span>
	        <span class="enscript-keyword">if</span> (holding_mntlock) {
			mount_unlock_renames(locked_mp);
			mount_drop(locked_mp, 0);
		        holding_mntlock = 0;
		}
	}

	<span class="enscript-comment">// save these off so we can later verify that fvp is the same
</span>	vnode_t oparent;
	oname   = fvp-&gt;v_name;
	oparent = fvp-&gt;v_parent;

	<span class="enscript-comment">/*
	 * If generating an fsevent, then
	 * stash any pre-rename info we may need.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-keyword">if</span> (nfsrv_fsevents_enabled &amp;&amp; need_fsevent(FSE_RENAME, fvp)) {
		<span class="enscript-type">int</span> from_truncated = 0, to_truncated = 0;
		
	        get_fse_info(fvp, &amp;from_finfo, ctx);
		<span class="enscript-keyword">if</span> (tvp)
		        get_fse_info(tvp, &amp;to_finfo, ctx);

	        from_name = get_pathbuff();
		<span class="enscript-keyword">if</span> (from_name) {
			from_len = safe_getpath(fdvp, fromni.ni_cnd.cn_nameptr, from_name, MAXPATHLEN, &amp;from_truncated);
		}
		
		to_name = from_name ? get_pathbuff() : NULL;
		<span class="enscript-keyword">if</span> (to_name) {
			to_len = safe_getpath(tdvp, toni.ni_cnd.cn_nameptr, to_name, MAXPATHLEN, &amp;to_truncated);
		}

		<span class="enscript-keyword">if</span> (from_truncated || to_truncated) {
			from_finfo.mode |= FSE_TRUNCATED_PATH;
		}

	} <span class="enscript-keyword">else</span> {
	        from_name = NULL;
	        to_name   = NULL;
	}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* CONFIG_FSE */</span>
	from_name = NULL;
	to_name   = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FSE */</span>

	error = VNOP_RENAME(fromni.ni_dvp, fromni.ni_vp, &amp;fromni.ni_cnd,
			    toni.ni_dvp, toni.ni_vp, &amp;toni.ni_cnd, ctx);
	<span class="enscript-comment">/*
	 * fix up name &amp; parent pointers.  note that we first	
	 * check that fvp has the same name/parent pointers it
	 * had before the rename call... this is a 'weak' check
	 * at best...
	 */</span>
	<span class="enscript-keyword">if</span> (oname == fvp-&gt;v_name &amp;&amp; oparent == fvp-&gt;v_parent) {
		<span class="enscript-type">int</span> update_flags;
		update_flags = VNODE_UPDATE_NAME;
		<span class="enscript-keyword">if</span> (fdvp != tdvp)
			update_flags |= VNODE_UPDATE_PARENT;
		vnode_update_identity(fvp, tdvp, toni.ni_cnd.cn_nameptr,
			toni.ni_cnd.cn_namelen, toni.ni_cnd.cn_hash, update_flags);
	}

	<span class="enscript-comment">/*
	 * If the rename is OK and we've got the paths
	 * then add an fsevent.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-keyword">if</span> (nfsrv_fsevents_enabled &amp;&amp; !error &amp;&amp; from_name &amp;&amp; to_name) {
	        <span class="enscript-keyword">if</span> (tvp) {
		        add_fsevent(FSE_RENAME, ctx,
				    FSE_ARG_STRING, from_len, from_name,
				    FSE_ARG_FINFO, &amp;from_finfo,
				    FSE_ARG_STRING, to_len, to_name,
				    FSE_ARG_FINFO, &amp;to_finfo,
				    FSE_ARG_DONE);
		} <span class="enscript-keyword">else</span> {
		        add_fsevent(FSE_RENAME, ctx,
				    FSE_ARG_STRING, from_len, from_name,
				    FSE_ARG_FINFO, &amp;from_finfo,
				    FSE_ARG_STRING, to_len, to_name,
				    FSE_ARG_DONE);
		}
	}
	<span class="enscript-keyword">if</span> (from_name)
	        release_pathbuff(from_name);
	<span class="enscript-keyword">if</span> (to_name)
	        release_pathbuff(to_name);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FSE */</span>
	from_name = to_name = NULL;
		
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (holding_mntlock) {
	        mount_unlock_renames(locked_mp);
		mount_drop(locked_mp, 0);
		holding_mntlock = 0;
	}
	<span class="enscript-keyword">if</span> (tdvp) {
	        <span class="enscript-comment">/*
		 * nameidone has to happen before we vnode_put(tdvp)
		 * since it may need to release the fs_nodelock on the tdvp
		 */</span>
		nameidone(&amp;toni);
		<span class="enscript-keyword">if</span> (tvp)
		        vnode_put(tvp);
	        vnode_put(tdvp);

		tdvp = NULL;
	}
	<span class="enscript-keyword">if</span> (fdvp) {
		<span class="enscript-comment">/*
		 * nameidone has to happen before we vnode_put(fdvp)
		 * since it may need to release the fs_nodelock on the fdvp
		 */</span>
		nameidone(&amp;fromni);

		<span class="enscript-keyword">if</span> (fvp)
		        vnode_put(fvp);
	        vnode_put(fdvp);

		fdvp = NULL;
	}
	<span class="enscript-keyword">if</span> (fdirp) {
		nfsm_srv_vattr_init(&amp;fdpostattr, nd-&gt;nd_vers);
		fdpostattrerr = vnode_getattr(fdirp, &amp;fdpostattr, ctx);
		vnode_put(fdirp);
		fdirp = NULL;
	}
	<span class="enscript-keyword">if</span> (tdirp) {
		nfsm_srv_vattr_init(&amp;tdpostattr, nd-&gt;nd_vers);
		tdpostattrerr = vnode_getattr(tdirp, &amp;tdpostattr, ctx);
		vnode_put(tdirp);
		tdirp = NULL;
	}

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, 2 * NFSX_WCCDATA(nd-&gt;nd_vers));
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_chain_add_wcc_data(error, nd, &amp;nmrep,
			fdpreattrerr, &amp;fdpreattr, fdpostattrerr, &amp;fdpostattr);
		nfsm_chain_add_wcc_data(error, nd, &amp;nmrep,
			tdpreattrerr, &amp;tdpreattr, tdpostattrerr, &amp;tdpostattr);
	}
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (holding_mntlock) {
	        mount_unlock_renames(locked_mp);
		mount_drop(locked_mp, 0);
	}
	<span class="enscript-keyword">if</span> (tdvp) {
		<span class="enscript-comment">/*
		 * nameidone has to happen before we vnode_put(tdvp)
		 * since it may need to release the fs_nodelock on the tdvp
		 */</span>
		nameidone(&amp;toni);

		<span class="enscript-keyword">if</span> (tvp)
		        vnode_put(tvp);
	        vnode_put(tdvp);
	}
	<span class="enscript-keyword">if</span> (fdvp) {
		<span class="enscript-comment">/*
		 * nameidone has to happen before we vnode_put(fdvp)
		 * since it may need to release the fs_nodelock on the fdvp
		 */</span>
		nameidone(&amp;fromni);

		<span class="enscript-keyword">if</span> (fvp)
		        vnode_put(fvp);
	        vnode_put(fdvp);
	}
	<span class="enscript-keyword">if</span> (fdirp)
		vnode_put(fdirp);
	<span class="enscript-keyword">if</span> (tdirp)
		vnode_put(tdirp);
	<span class="enscript-keyword">if</span> (frompath)
		FREE_ZONE(frompath, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">if</span> (topath)
		FREE_ZONE(topath, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">if</span> (saved_cred)
		kauth_cred_unref(&amp;saved_cred);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs link service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_link</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> nameidata ni;
	<span class="enscript-type">int</span> error, dpreattrerr, dpostattrerr, attrerr;
	uint32_t len = 0;
	vnode_t vp, xp, dvp, dirp;
	<span class="enscript-type">struct</span> vnode_attr dpreattr, dpostattr, attr;
	<span class="enscript-type">struct</span> nfs_filehandle nfh, dnfh;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	dpreattrerr = dpostattrerr = attrerr = ENOENT;
	vp = xp = dvp = dirp = NULL;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, dnfh.nfh_fhp, dnfh.nfh_len);
	nfsm_chain_get_32(error, nmreq, len);
	nfsm_name_len_check(error, nd, len);
	nfsmerr_if(error);
	error = nfsrv_fhtovp(&amp;nfh, nd, &amp;vp, &amp;nx, &amp;nxo);
	nfsmerr_if(error);

	<span class="enscript-comment">/* update export stats */</span>
	NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

	<span class="enscript-comment">/* update active user stats */</span>
	nfsrv_update_user_stat(nx, nd, kauth_cred_getuid(nd-&gt;nd_cr), 1, 0, 0);

	error = nfsrv_credcheck(nd, ctx, nx, nxo);
	nfsmerr_if(error);

	<span class="enscript-comment">/* we're not allowed to link to directories... */</span>
	<span class="enscript-keyword">if</span> (vnode_vtype(vp) == VDIR) {
		error = EPERM;		<span class="enscript-comment">/* POSIX */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* ...or to anything that kauth doesn't want us to (eg. immutable items) */</span>
	<span class="enscript-keyword">if</span> ((error = nfsrv_authorize(vp, NULL, KAUTH_VNODE_LINKTARGET, ctx, nxo, 0)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	ni.ni_cnd.cn_nameiop = CREATE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	ni.ni_op = OP_LINK;
#<span class="enscript-reference">endif</span>
	ni.ni_cnd.cn_flags = LOCKPARENT;
	error = nfsm_chain_get_path_namei(nmreq, len, &amp;ni);
	<span class="enscript-keyword">if</span> (!error)
		error = nfsrv_namei(nd, ctx, &amp;ni, &amp;dnfh, &amp;dirp, &amp;nx, &amp;nxo);
	<span class="enscript-keyword">if</span> (dirp) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
			nfsm_srv_pre_vattr_init(&amp;dpreattr);
			dpreattrerr = vnode_getattr(dirp, &amp;dpreattr, ctx);
		} <span class="enscript-keyword">else</span> {
			vnode_put(dirp);
			dirp = NULL;
		}
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	dvp = ni.ni_dvp;
	xp = ni.ni_vp;

	<span class="enscript-keyword">if</span> (xp != NULL)
		error = EEXIST;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vnode_mount(vp) != vnode_mount(dvp))
		error = EXDEV;
	<span class="enscript-keyword">else</span>
		error = nfsrv_authorize(dvp, NULL, KAUTH_VNODE_ADD_FILE, ctx, nxo, 0);

	<span class="enscript-keyword">if</span> (!error)
		error = VNOP_LINK(vp, dvp, &amp;ni.ni_cnd, ctx);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-keyword">if</span> (nfsrv_fsevents_enabled &amp;&amp; !error &amp;&amp; need_fsevent(FSE_CREATE_FILE, dvp)) {
		<span class="enscript-type">char</span> *target_path = NULL;
		<span class="enscript-type">int</span> plen, truncated=0;
		fse_info finfo;

		<span class="enscript-comment">/* build the path to the new link file */</span>
		target_path = get_pathbuff();
		<span class="enscript-keyword">if</span> (target_path) {
			plen = safe_getpath(dvp, ni.ni_cnd.cn_nameptr, target_path, MAXPATHLEN, &amp;truncated);

			<span class="enscript-keyword">if</span> (get_fse_info(vp, &amp;finfo, ctx) == 0) {
				<span class="enscript-keyword">if</span> (truncated) {
					finfo.mode |= FSE_TRUNCATED_PATH;
				}
				add_fsevent(FSE_CREATE_FILE, ctx,
					    FSE_ARG_STRING, plen, target_path,
					    FSE_ARG_FINFO, &amp;finfo,
					    FSE_ARG_DONE);
			}

			release_pathbuff(target_path);
		}
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * nameidone has to happen before we vnode_put(dvp)
	 * since it may need to release the fs_nodelock on the dvp
	 */</span>
	nameidone(&amp;ni);

	<span class="enscript-keyword">if</span> (xp)
		vnode_put(xp);
	vnode_put(dvp);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_srv_vattr_init(&amp;attr, NFS_VER3);
		attrerr = vnode_getattr(vp, &amp;attr, ctx);
	}
	<span class="enscript-keyword">if</span> (dirp) {
		nfsm_srv_vattr_init(&amp;dpostattr, nd-&gt;nd_vers);
		dpostattrerr = vnode_getattr(dirp, &amp;dpostattr, ctx);
		vnode_put(dirp);
		dirp = NULL;
	}
	vnode_put(vp);
	vp = NULL;

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_POSTOPATTR(nd-&gt;nd_vers) + NFSX_WCCDATA(nd-&gt;nd_vers));
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, attrerr, &amp;attr);
		nfsm_chain_add_wcc_data(error, nd, &amp;nmrep,
			dpreattrerr, &amp;dpreattr, dpostattrerr, &amp;dpostattr);
	}
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs symbolic link service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_symlink</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> vnode_attr dpreattr, dpostattr, postattr;
	<span class="enscript-type">struct</span> vnode_attr va, *vap = &amp;va;
	<span class="enscript-type">struct</span> nameidata ni;
	<span class="enscript-type">int</span> error, dpreattrerr, dpostattrerr, postattrerr;
	uint32_t len = 0, linkdatalen, cnflags;
	uid_t saved_uid;
	<span class="enscript-type">char</span> *linkdata;
	vnode_t vp, dvp, dirp;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx = NULL;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	uio_t auio = NULL;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	dpreattrerr = dpostattrerr = postattrerr = ENOENT;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	linkdata = NULL;
	dirp = NULL;

	saved_uid = kauth_cred_getuid(nd-&gt;nd_cr);

	ni.ni_cnd.cn_nameiop = 0;
	vp = dvp = NULL;

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	nfsm_chain_get_32(error, nmreq, len);
	nfsm_name_len_check(error, nd, len);
	nfsmerr_if(error);

	ni.ni_cnd.cn_nameiop = CREATE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	ni.ni_op = OP_LINK;
#<span class="enscript-reference">endif</span>
	ni.ni_cnd.cn_flags = LOCKPARENT;
	error = nfsm_chain_get_path_namei(nmreq, len, &amp;ni);
	<span class="enscript-keyword">if</span> (!error) {
		error = nfsrv_namei(nd, ctx, &amp;ni, &amp;nfh, &amp;dirp, &amp;nx, &amp;nxo);
		<span class="enscript-keyword">if</span> (nx != NULL) {
			<span class="enscript-comment">/* update export stats */</span>
			NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

			<span class="enscript-comment">/* update active user stats */</span>
			nfsrv_update_user_stat(nx, nd, saved_uid, 1, 0, 0);
		}
	}
	<span class="enscript-keyword">if</span> (dirp) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
			nfsm_srv_pre_vattr_init(&amp;dpreattr);
			dpreattrerr = vnode_getattr(dirp, &amp;dpreattr, ctx);
		} <span class="enscript-keyword">else</span> {
			vnode_put(dirp);
			dirp = NULL;
		}
	}
	<span class="enscript-keyword">if</span> (error) {
		ni.ni_cnd.cn_nameiop = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
	}
	dvp = ni.ni_dvp;
	vp = ni.ni_vp;

	VATTR_INIT(vap);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
		error = nfsm_chain_get_sattr(nd, nmreq, vap);
	nfsm_chain_get_32(error, nmreq, linkdatalen);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (((nd-&gt;nd_vers == NFS_VER2) &amp;&amp; (linkdatalen &gt; NFS_MAXPATHLEN)) ||
			((nd-&gt;nd_vers == NFS_VER3) &amp;&amp; (linkdatalen &gt; MAXPATHLEN))))
		error = NFSERR_NAMETOL;
	nfsmerr_if(error);
	MALLOC(linkdata, caddr_t, linkdatalen + 1, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (linkdata)
		auio = uio_createwithbuffer(1, 0, UIO_SYSSPACE, UIO_READ,
					&amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	<span class="enscript-keyword">if</span> (!linkdata || !auio) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	uio_addiov(auio, CAST_USER_ADDR_T(linkdata), linkdatalen);
	error = nfsm_chain_get_uio(nmreq, linkdatalen, auio);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (nd-&gt;nd_vers == NFS_VER2))
		error = nfsm_chain_get_sattr(nd, nmreq, vap);
	nfsmerr_if(error);
	*(linkdata + linkdatalen) = <span class="enscript-string">'\0'</span>;
	<span class="enscript-keyword">if</span> (vp) {
		error = EEXIST;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	VATTR_SET(vap, va_type, VLNK);
	VATTR_CLEAR_ACTIVE(vap, va_data_size);
	VATTR_CLEAR_ACTIVE(vap, va_access_time);
	<span class="enscript-comment">/*
	 * Server policy is to alway use the mapped rpc credential for 
	 * file system object creation. This has the nice side effect of
	 * enforcing BSD creation semantics
	 */</span>
	VATTR_CLEAR_ACTIVE(vap, va_uid);
	VATTR_CLEAR_ACTIVE(vap, va_gid);

	<span class="enscript-comment">/* authorize before creating */</span>
	error = nfsrv_authorize(dvp, NULL, KAUTH_VNODE_ADD_FILE, ctx, nxo, 0);

	<span class="enscript-comment">/* validate given attributes */</span>
	<span class="enscript-keyword">if</span> (!error)
		error = vnode_authattr_new(dvp, vap, 0, ctx);

	<span class="enscript-keyword">if</span> (!error)
		error = VNOP_SYMLINK(dvp, &amp;vp, &amp;ni.ni_cnd, vap, linkdata, ctx);

	<span class="enscript-keyword">if</span> (!error &amp;&amp; (nd-&gt;nd_vers == NFS_VER3)) {
		<span class="enscript-keyword">if</span> (vp == NULL) {
			ni.ni_cnd.cn_nameiop = LOOKUP;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
			ni.ni_op = OP_LOOKUP;
#<span class="enscript-reference">endif</span>
			ni.ni_cnd.cn_flags &amp;= ~(LOCKPARENT | FOLLOW);
			ni.ni_cnd.cn_flags |= (NOFOLLOW | LOCKLEAF);
			ni.ni_cnd.cn_context = ctx;
			ni.ni_startdir = dvp;
			ni.ni_usedvp   = dvp;
			cnflags = ni.ni_cnd.cn_flags; <span class="enscript-comment">/* store in case we have to restore */</span>
			<span class="enscript-keyword">while</span> ((error = lookup(&amp;ni)) == ERECYCLE) {
				ni.ni_cnd.cn_flags = cnflags;
				ni.ni_cnd.cn_nameptr = ni.ni_cnd.cn_pnbuf;
				ni.ni_usedvp = ni.ni_dvp = ni.ni_startdir = dvp;
			}
			<span class="enscript-keyword">if</span> (!error)
			        vp = ni.ni_vp;
		}
		<span class="enscript-keyword">if</span> (!error) {
			error = nfsrv_vptofh(nx, NFS_VER3, NULL, vp, ctx, &amp;nfh);
			<span class="enscript-keyword">if</span> (!error) {
				nfsm_srv_vattr_init(&amp;postattr, NFS_VER3);
				postattrerr = vnode_getattr(vp, &amp;postattr, ctx);
			}
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-keyword">if</span> (nfsrv_fsevents_enabled &amp;&amp; !error &amp;&amp; vp) {
		add_fsevent(FSE_CREATE_FILE, ctx,
			    FSE_ARG_VNODE, vp,
			    FSE_ARG_DONE);
	}
#<span class="enscript-reference">endif</span>
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/*
	 * nameidone has to happen before we vnode_put(dvp)
	 * since it may need to release the fs_nodelock on the dvp
	 */</span>
	nameidone(&amp;ni);
	ni.ni_cnd.cn_nameiop = 0;
	<span class="enscript-keyword">if</span> (vp)
	        vnode_put(vp);
	vnode_put(dvp);
<span class="enscript-reference">out1</span>:
	<span class="enscript-keyword">if</span> (linkdata) {
		FREE(linkdata, M_TEMP);
		linkdata = NULL;
	}
	<span class="enscript-keyword">if</span> (dirp) {
		nfsm_srv_vattr_init(&amp;dpostattr, nd-&gt;nd_vers);
		dpostattrerr = vnode_getattr(dirp, &amp;dpostattr, ctx);
		vnode_put(dirp);
		dirp = NULL;
	}

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_SRVFH(nd-&gt;nd_vers, &amp;nfh) +
			NFSX_POSTOPATTR(nd-&gt;nd_vers) + NFSX_WCCDATA(nd-&gt;nd_vers));
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		<span class="enscript-keyword">if</span> (!nd-&gt;nd_repstat) {
			nfsm_chain_add_postop_fh(error, &amp;nmrep, nfh.nfh_fhp, nfh.nfh_len);
			nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, postattrerr, &amp;postattr);
		}
		nfsm_chain_add_wcc_data(error, nd, &amp;nmrep,
			dpreattrerr, &amp;dpreattr, dpostattrerr, &amp;dpostattr);
	}
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (ni.ni_cnd.cn_nameiop) {
	        <span class="enscript-comment">/*
		 * nameidone has to happen before we vnode_put(dvp)
		 * since it may need to release the fs_nodelock on the dvp
		 */</span>
		nameidone(&amp;ni);

		<span class="enscript-keyword">if</span> (vp)
			vnode_put(vp);
		vnode_put(dvp);
	}
	<span class="enscript-keyword">if</span> (dirp)
		vnode_put(dirp);
	<span class="enscript-keyword">if</span> (linkdata)
		FREE(linkdata, M_TEMP);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs mkdir service
 */</span>
 
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_mkdir</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> vnode_attr dpreattr, dpostattr, postattr;
	<span class="enscript-type">struct</span> vnode_attr va, *vap = &amp;va;
	<span class="enscript-type">struct</span> nameidata ni;
	<span class="enscript-type">int</span> error, dpreattrerr, dpostattrerr, postattrerr;
	uint32_t len = 0;
	vnode_t vp, dvp, dirp;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx = NULL;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	uid_t saved_uid;
	kauth_acl_t xacl = NULL;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	dpreattrerr = dpostattrerr = postattrerr = ENOENT;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);

	saved_uid = kauth_cred_getuid(nd-&gt;nd_cr);

	ni.ni_cnd.cn_nameiop = 0;
	vp = dvp = dirp = NULL;

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	nfsm_chain_get_32(error, nmreq, len);
	nfsm_name_len_check(error, nd, len);
	nfsmerr_if(error);

	ni.ni_cnd.cn_nameiop = CREATE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	ni.ni_op = OP_LINK;
#<span class="enscript-reference">endif</span>
	ni.ni_cnd.cn_flags = LOCKPARENT;
	error = nfsm_chain_get_path_namei(nmreq, len, &amp;ni);
	<span class="enscript-keyword">if</span> (!error) {
		error = nfsrv_namei(nd, ctx, &amp;ni, &amp;nfh, &amp;dirp, &amp;nx, &amp;nxo);
		<span class="enscript-keyword">if</span> (nx != NULL) {
			<span class="enscript-comment">/* update export stats */</span>
			NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

			<span class="enscript-comment">/* update active user stats */</span>
			nfsrv_update_user_stat(nx, nd, saved_uid, 1, 0, 0);
		}
	}
	<span class="enscript-keyword">if</span> (dirp) {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
			nfsm_srv_pre_vattr_init(&amp;dpreattr);
			dpreattrerr = vnode_getattr(dirp, &amp;dpreattr, ctx);
		} <span class="enscript-keyword">else</span> {
			vnode_put(dirp);
			dirp = NULL;
		}
	}
	<span class="enscript-keyword">if</span> (error) {
		ni.ni_cnd.cn_nameiop = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmerr</span>;
	}
	dvp = ni.ni_dvp;
	vp = ni.ni_vp;

	VATTR_INIT(vap);
	error = nfsm_chain_get_sattr(nd, nmreq, vap);
	nfsmerr_if(error);
	VATTR_SET(vap, va_type, VDIR);

	<span class="enscript-keyword">if</span> (vp != NULL) {
	        <span class="enscript-comment">/*
		 * nameidone has to happen before we vnode_put(dvp)
		 * since it may need to release the fs_nodelock on the dvp
		 */</span>
	        nameidone(&amp;ni);
		vnode_put(dvp);
		vnode_put(vp);
		error = EEXIST;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = nfsrv_authorize(dvp, NULL, KAUTH_VNODE_ADD_SUBDIRECTORY, ctx, nxo, 0);

	<span class="enscript-comment">/* construct ACL and handle inheritance */</span>
	<span class="enscript-keyword">if</span> (!error) {
		error = kauth_acl_inherit(dvp,
		    NULL,
		    &amp;xacl,	<span class="enscript-comment">/* isdir */</span>
		    1,
		    ctx);
		
		<span class="enscript-keyword">if</span> (!error &amp;&amp; xacl != NULL)
		        VATTR_SET(vap, va_acl, xacl);
	}

	VATTR_CLEAR_ACTIVE(vap, va_data_size);
	VATTR_CLEAR_ACTIVE(vap, va_access_time);
	<span class="enscript-comment">/*
	 * We don't support the S_ISGID bit for directories. Solaris and other
	 * SRV4 derived systems might set this to get BSD semantics, which we enforce
	 * any ways. 
	 */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_mode))
		vap-&gt;va_mode &amp;= ~S_ISGID;
	<span class="enscript-comment">/*
	 * Server policy is to alway use the mapped rpc credential for 
	 * file system object creation. This has the nice side effect of
	 * enforcing BSD creation semantics
	 */</span>
	VATTR_CLEAR_ACTIVE(vap, va_uid);
	VATTR_CLEAR_ACTIVE(vap, va_gid);

	<span class="enscript-comment">/* validate new-file security information */</span>
	<span class="enscript-keyword">if</span> (!error)
		error = vnode_authattr_new(dvp, vap, 0, ctx);
	<span class="enscript-comment">/*
	 * vnode_authattr_new can return errors other than EPERM, but that's not going to 
	 * sit well with our clients so we map all errors to EPERM.
         */</span>
	<span class="enscript-keyword">if</span> (error)
		error = EPERM;

	<span class="enscript-keyword">if</span> (!error)
		error = VNOP_MKDIR(dvp, &amp;vp, &amp;ni.ni_cnd, vap, ctx);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
	<span class="enscript-keyword">if</span> (nfsrv_fsevents_enabled &amp;&amp; !error)
		add_fsevent(FSE_CREATE_DIR, ctx, FSE_ARG_VNODE, vp, FSE_ARG_DONE);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (!error &amp;&amp; !VATTR_ALL_SUPPORTED(vap))
	        <span class="enscript-comment">/*
		 * If some of the requested attributes weren't handled by the VNOP,
		 * use our fallback code.
		 */</span>
		error = vnode_setattr_fallback(vp, vap, ctx);

	<span class="enscript-keyword">if</span> (xacl != NULL)
		kauth_acl_free(xacl);
	
	<span class="enscript-keyword">if</span> (!error) {
		error = nfsrv_vptofh(nx, nd-&gt;nd_vers, NULL, vp, ctx, &amp;nfh);
		<span class="enscript-keyword">if</span> (!error) {
			nfsm_srv_vattr_init(&amp;postattr, nd-&gt;nd_vers);
			postattrerr = vnode_getattr(vp, &amp;postattr, ctx);
			<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER2)
				error = postattrerr;
		}
		vnode_put(vp);
		vp = NULL;
	}
	<span class="enscript-comment">/*
	 * nameidone has to happen before we vnode_put(dvp)
	 * since it may need to release the fs_nodelock on the dvp
	 */</span>
	nameidone(&amp;ni);
	vnode_put(dvp);
<span class="enscript-reference">out</span>:
	ni.ni_cnd.cn_nameiop = 0;

	<span class="enscript-keyword">if</span> (dirp) {
		nfsm_srv_vattr_init(&amp;dpostattr, nd-&gt;nd_vers);
		dpostattrerr = vnode_getattr(dirp, &amp;dpostattr, ctx);
		vnode_put(dirp);
		dirp = NULL;
	}

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_SRVFH(nd-&gt;nd_vers, &amp;nfh) +
			NFSX_POSTOPATTR(nd-&gt;nd_vers) + NFSX_WCCDATA(nd-&gt;nd_vers));
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		<span class="enscript-keyword">if</span> (!nd-&gt;nd_repstat) {
			nfsm_chain_add_postop_fh(error, &amp;nmrep, nfh.nfh_fhp, nfh.nfh_len);
			nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, postattrerr, &amp;postattr);
		}
		nfsm_chain_add_wcc_data(error, nd, &amp;nmrep,
			dpreattrerr, &amp;dpreattr, dpostattrerr, &amp;dpostattr);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_fh(error, &amp;nmrep, NFS_VER2, nfh.nfh_fhp, nfh.nfh_len);
		<span class="enscript-keyword">if</span> (!error)
			error = nfsm_chain_add_fattr(nd, &amp;nmrep, &amp;postattr);
	}
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (ni.ni_cnd.cn_nameiop) {
	        <span class="enscript-comment">/*
		 * nameidone has to happen before we vnode_put(dvp)
		 * since it may need to release the fs_nodelock on the dvp
		 */</span>
		nameidone(&amp;ni);
		vnode_put(dvp);
		<span class="enscript-keyword">if</span> (vp)
			vnode_put(vp);
	}
	<span class="enscript-keyword">if</span> (dirp)
		vnode_put(dirp);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs rmdir service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_rmdir</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">int</span> error, dpreattrerr, dpostattrerr;
	uint32_t len = 0;
	uid_t saved_uid;
	vnode_t vp, dvp, dirp;
	<span class="enscript-type">struct</span> vnode_attr dpreattr, dpostattr;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx = NULL;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	<span class="enscript-type">struct</span> nameidata ni;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	dpreattrerr = dpostattrerr = ENOENT;
	saved_uid = kauth_cred_getuid(nd-&gt;nd_cr);
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);

	vp = dvp = dirp = NULL;

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	nfsm_chain_get_32(error, nmreq, len);
	nfsm_name_len_check(error, nd, len);
	nfsmerr_if(error);

	ni.ni_cnd.cn_nameiop = DELETE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	ni.ni_op = OP_UNLINK;
#<span class="enscript-reference">endif</span>
	ni.ni_cnd.cn_flags = LOCKPARENT | LOCKLEAF;
	error = nfsm_chain_get_path_namei(nmreq, len, &amp;ni);
	<span class="enscript-keyword">if</span> (!error) {
		error = nfsrv_namei(nd, ctx, &amp;ni, &amp;nfh, &amp;dirp, &amp;nx, &amp;nxo);
		<span class="enscript-keyword">if</span> (nx != NULL) {
			<span class="enscript-comment">/* update export stats */</span>
			NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

			<span class="enscript-comment">/* update active user stats */</span>
			nfsrv_update_user_stat(nx, nd, saved_uid, 1, 0, 0);
		}
	}
	<span class="enscript-keyword">if</span> (dirp) {
	        <span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
			nfsm_srv_pre_vattr_init(&amp;dpreattr);
			dpreattrerr = vnode_getattr(dirp, &amp;dpreattr, ctx);
		} <span class="enscript-keyword">else</span> {
			vnode_put(dirp);
			dirp = NULL;
		}
	}
	nfsmerr_if(error);

	dvp = ni.ni_dvp;
	vp = ni.ni_vp;

	<span class="enscript-keyword">if</span> (vnode_vtype(vp) != VDIR) {
		error = ENOTDIR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/*
	 * No rmdir &quot;.&quot; please.
	 */</span>
	<span class="enscript-keyword">if</span> (dvp == vp) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/*
	 * The root of a mounted filesystem cannot be deleted.
	 */</span>
	<span class="enscript-keyword">if</span> (vnode_isvroot(vp))
		error = EBUSY;
	<span class="enscript-keyword">if</span> (!error)
		error = nfsrv_authorize(vp, dvp, KAUTH_VNODE_DELETE, ctx, nxo, 0);
	<span class="enscript-keyword">if</span> (!error) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
		<span class="enscript-type">char</span>     *path = NULL;
		<span class="enscript-type">int</span>       plen;
		fse_info  finfo;
		
		<span class="enscript-keyword">if</span> (nfsrv_fsevents_enabled &amp;&amp; need_fsevent(FSE_DELETE, dvp)) {
			plen = MAXPATHLEN;
		        <span class="enscript-keyword">if</span> ((path = get_pathbuff()) &amp;&amp; !vn_getpath(vp, path, &amp;plen)) {
				get_fse_info(vp, &amp;finfo, ctx);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (path) {
				release_pathbuff(path);
				path = NULL;
			}
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FSE */</span>

		error = VNOP_RMDIR(dvp, vp, &amp;ni.ni_cnd, ctx);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FSE</span>
		<span class="enscript-keyword">if</span> (path) {
			<span class="enscript-keyword">if</span> (!error)
				add_fsevent(FSE_DELETE, ctx,
					FSE_ARG_STRING, plen, path,
					FSE_ARG_FINFO, &amp;finfo,
					FSE_ARG_DONE);
		        release_pathbuff(path);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FSE */</span>
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/*
	 * nameidone has to happen before we vnode_put(dvp)
	 * since it may need to release the fs_nodelock on the dvp
	 */</span>
	nameidone(&amp;ni);

	vnode_put(dvp);
	vnode_put(vp);

	<span class="enscript-keyword">if</span> (dirp) {
		nfsm_srv_vattr_init(&amp;dpostattr, nd-&gt;nd_vers);
		dpostattrerr = vnode_getattr(dirp, &amp;dpostattr, ctx);
		vnode_put(dirp);
		dirp = NULL;
	}

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_WCCDATA(nd-&gt;nd_vers));
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
		nfsm_chain_add_wcc_data(error, nd, &amp;nmrep,
			dpreattrerr, &amp;dpreattr, dpostattrerr, &amp;dpostattr);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (dirp)
		vnode_put(dirp);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs readdir service
 * - mallocs what it thinks is enough to read
 *	count rounded up to a multiple of NFS_DIRBLKSIZ &lt;= NFS_MAXREADDIR
 * - calls VNOP_READDIR()
 * - loops around building the reply
 *	if the output generated exceeds count break out of loop
 *	The nfsm_clget macro is used here so that the reply will be packed
 *	tightly in mbuf clusters.
 * - it only knows that it has encountered eof when the VNOP_READDIR()
 *	reads nothing
 * - as such one readdir rpc will return eof false although you are there
 *	and then the next will return eof
 * - it trims out records with d_fileno == 0
 *	this doesn't matter for Unix clients, but they might confuse clients
 *	for other os'.
 * NB: It is tempting to set eof to true if the VNOP_READDIR() reads less
 *	than requested, but this may not apply to all filesystems. For
 *	example, client NFS does not { although it is never remote mounted
 *	anyhow }
 *     The alternate call nfsrv_readdirplus() does lookups as well.
 * PS:  The XNFS protocol spec clearly describes what the &quot;count&quot;s arguments
 *      are supposed to cover.  For readdir, the count is the total number of
 *      bytes included in everything from the directory's postopattr through
 *      the EOF flag.  For readdirplus, the maxcount is the same, and the
 *      dircount includes all that except for the entry attributes and handles.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_readdir</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> direntry *dp;
	<span class="enscript-type">char</span> *cpos, *cend, *rbuf;
	vnode_t vp;
	<span class="enscript-type">struct</span> vnode_attr attr;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	uio_t auio = NULL;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];
	<span class="enscript-type">int</span> len, nlen, rem, xfer, error, attrerr;
	<span class="enscript-type">int</span> siz, count, fullsiz, eofflag, nentries;
	u_quad_t off, toff, verf;
	<span class="enscript-type">int</span> vnopflag;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	attrerr = ENOENT;
	count = nentries = 0;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	rbuf = NULL;
	vp = NULL;

	vnopflag = VNODE_READDIR_EXTENDED | VNODE_READDIR_REQSEEKOFF;

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_chain_get_64(error, nmreq, toff);
		nfsm_chain_get_64(error, nmreq, verf);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_get_32(error, nmreq, toff);
	}
	nfsm_chain_get_32(error, nmreq, count);
	nfsmerr_if(error);

	off = toff;
	siz = ((count + DIRBLKSIZ - 1) &amp; ~(DIRBLKSIZ - 1));
	xfer = NFSRV_NDMAXDATA(nd);
	<span class="enscript-keyword">if</span> (siz &gt; xfer)
		siz = xfer;
	fullsiz = siz;

	error = nfsrv_fhtovp(&amp;nfh, nd, &amp;vp, &amp;nx, &amp;nxo);
	nfsmerr_if(error);

	<span class="enscript-comment">/* update export stats */</span>
	NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

	<span class="enscript-comment">/* update active user stats */</span>
	nfsrv_update_user_stat(nx, nd, kauth_cred_getuid(nd-&gt;nd_cr), 1, 0, 0);

	error = nfsrv_credcheck(nd, ctx, nx, nxo);
	nfsmerr_if(error);

	<span class="enscript-keyword">if</span> (nxo-&gt;nxo_flags &amp; NX_MANGLEDNAMES || nd-&gt;nd_vers == NFS_VER2)
		vnopflag |= VNODE_READDIR_NAMEMAX;

	<span class="enscript-keyword">if</span> ((nd-&gt;nd_vers == NFS_VER2) || (nxo-&gt;nxo_flags &amp; NX_32BITCLIENTS))
		vnopflag |= VNODE_READDIR_SEEKOFF32;

	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_srv_vattr_init(&amp;attr, NFS_VER3);
		error = attrerr = vnode_getattr(vp, &amp;attr, ctx);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; toff &amp;&amp; verf &amp;&amp; (verf != attr.va_filerev))
			error = NFSERR_BAD_COOKIE;
	}
	<span class="enscript-keyword">if</span> (!error)
		error = nfsrv_authorize(vp, NULL, KAUTH_VNODE_LIST_DIRECTORY, ctx, nxo, 0);
	nfsmerr_if(error);

	MALLOC(rbuf, caddr_t, siz, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (rbuf)
		auio = uio_createwithbuffer(1, 0, UIO_SYSSPACE, UIO_READ,
				    &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	<span class="enscript-keyword">if</span> (!rbuf || !auio) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmerr</span>;
	}
<span class="enscript-reference">again</span>:
	uio_reset(auio, off, UIO_SYSSPACE, UIO_READ);
	uio_addiov(auio, CAST_USER_ADDR_T(rbuf), fullsiz);
	eofflag = 0;
	error = VNOP_READDIR(vp, auio, vnopflag, &amp;eofflag, &amp;nentries, ctx);
	off = uio_offset(auio);

	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_srv_vattr_init(&amp;attr, NFS_VER3);
		attrerr = vnode_getattr(vp, &amp;attr, ctx);
	}
	nfsmerr_if(error);

	<span class="enscript-keyword">if</span> (uio_resid(auio) != 0) {
		siz -= uio_resid(auio);

		<span class="enscript-comment">/* If nothing read, return empty reply with eof set */</span>
		<span class="enscript-keyword">if</span> (siz == 0) {
			vnode_put(vp);
			vp = NULL;
			FREE(rbuf, M_TEMP);
			<span class="enscript-comment">/* assemble reply */</span>
			nd-&gt;nd_repstat = error;
			error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_POSTOPATTR(nd-&gt;nd_vers) +
					NFSX_COOKIEVERF(nd-&gt;nd_vers) + 2 * NFSX_UNSIGNED);
			nfsmout_if(error);
			*mrepp = nmrep.nmc_mhead;
			nfsmout_on_status(nd, error);
			<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
				nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, attrerr, &amp;attr);
				nfsm_chain_add_64(error, &amp;nmrep, attr.va_filerev);
			}
			nfsm_chain_add_32(error, &amp;nmrep, FALSE);
			nfsm_chain_add_32(error, &amp;nmrep, TRUE);
			nfsm_chain_build_done(error, &amp;nmrep);
			<span class="enscript-keyword">return</span> (error);
		}
	}

	<span class="enscript-comment">/*
	 * Check for degenerate cases of nothing useful read.
	 * If so go try again
	 */</span>
	cpos = rbuf;
	cend = rbuf + siz;
	dp = (<span class="enscript-type">struct</span> direntry *)cpos;
	<span class="enscript-keyword">while</span> ((dp-&gt;d_fileno == 0) &amp;&amp; (cpos &lt; cend) &amp;&amp; (nentries &gt; 0)) {
		cpos += dp-&gt;d_reclen;
		dp = (<span class="enscript-type">struct</span> direntry *)cpos;
		nentries--;
	}
	<span class="enscript-keyword">if</span> ((cpos &gt;= cend) || (nentries == 0)) {
		toff = off;
		siz = fullsiz;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}

	vnode_put(vp);
	vp = NULL;

	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_POSTOPATTR(nd-&gt;nd_vers) +
			NFSX_COOKIEVERF(nd-&gt;nd_vers) + siz);
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	nmrep.nmc_flags |= NFSM_CHAIN_FLAG_ADD_CLUSTERS;

	len = 2 * NFSX_UNSIGNED;
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		len += NFSX_V3POSTOPATTR + NFSX_V3COOKIEVERF;
		nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, attrerr, &amp;attr);
		nfsm_chain_add_64(error, &amp;nmrep, attr.va_filerev);
		nfsmerr_if(error);
	}

	<span class="enscript-comment">/* Loop through the records and build reply */</span>
	<span class="enscript-keyword">while</span> ((cpos &lt; cend) &amp;&amp; (nentries &gt; 0)) {
		<span class="enscript-keyword">if</span> (dp-&gt;d_fileno != 0) {
			nlen = dp-&gt;d_namlen;
			<span class="enscript-keyword">if</span> ((nd-&gt;nd_vers == NFS_VER2) &amp;&amp; (nlen &gt; NFS_MAXNAMLEN))
				nlen = NFS_MAXNAMLEN;
			rem = nfsm_rndup(nlen)-nlen;
			len += (4 * NFSX_UNSIGNED + nlen + rem);
			<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
				len += 2 * NFSX_UNSIGNED;
			<span class="enscript-keyword">if</span> (len &gt; count) {
				eofflag = 0;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/* Build the directory record xdr from the direntry. */</span>
			nfsm_chain_add_32(error, &amp;nmrep, TRUE);
			<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
				nfsm_chain_add_64(error, &amp;nmrep, dp-&gt;d_fileno);
			} <span class="enscript-keyword">else</span> {
				nfsm_chain_add_32(error, &amp;nmrep, dp-&gt;d_fileno);
			}
			nfsm_chain_add_string(error, &amp;nmrep, dp-&gt;d_name, nlen);
			<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
				<span class="enscript-keyword">if</span> (vnopflag &amp; VNODE_READDIR_SEEKOFF32)
					dp-&gt;d_seekoff &amp;= 0x00000000ffffffffULL;
				nfsm_chain_add_64(error, &amp;nmrep, dp-&gt;d_seekoff);
			} <span class="enscript-keyword">else</span> {
				nfsm_chain_add_32(error, &amp;nmrep, dp-&gt;d_seekoff);
			}
			nfsmerr_if(error);
		}
		cpos += dp-&gt;d_reclen;
		dp = (<span class="enscript-type">struct</span> direntry *)cpos;
		nentries--;
	}
	nfsm_chain_add_32(error, &amp;nmrep, FALSE);
	nfsm_chain_add_32(error, &amp;nmrep, eofflag ? TRUE : FALSE);
	FREE(rbuf, M_TEMP);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-keyword">if</span> (rbuf)
		FREE(rbuf, M_TEMP);
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_POSTOPATTR(nd-&gt;nd_vers));
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
		nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, attrerr, &amp;attr);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_readdirplus</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> direntry *dp;
	<span class="enscript-type">char</span> *cpos, *cend, *rbuf;
	vnode_t vp, nvp;
	<span class="enscript-type">struct</span> nfs_filehandle dnfh, nfh;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	uio_t auio = NULL;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];
	<span class="enscript-type">struct</span> vnode_attr attr, va, *vap = &amp;va;
	<span class="enscript-type">int</span> len, nlen, rem, xfer, error, attrerr, gotfh, gotattr;
	<span class="enscript-type">int</span> siz, dircount, maxcount, fullsiz, eofflag, dirlen, nentries, isdotdot;
	u_quad_t off, toff, verf;
	<span class="enscript-type">int</span> vnopflag;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	attrerr = ENOENT;
	nentries = 0;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	rbuf = NULL;
	vp = NULL;
	dircount = maxcount = 0;

	vnopflag = VNODE_READDIR_EXTENDED | VNODE_READDIR_REQSEEKOFF;

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, dnfh.nfh_fhp, dnfh.nfh_len);
	nfsm_chain_get_64(error, nmreq, toff);
	nfsm_chain_get_64(error, nmreq, verf);
	nfsm_chain_get_32(error, nmreq, dircount);
	nfsm_chain_get_32(error, nmreq, maxcount);
	nfsmerr_if(error);

	off = toff;
	xfer = NFSRV_NDMAXDATA(nd);
	dircount = ((dircount + DIRBLKSIZ - 1) &amp; ~(DIRBLKSIZ - 1));
	<span class="enscript-keyword">if</span> (dircount &gt; xfer)
		dircount = xfer;
	fullsiz = siz = dircount;
	maxcount = ((maxcount + DIRBLKSIZ - 1) &amp; ~(DIRBLKSIZ - 1));
	<span class="enscript-keyword">if</span> (maxcount &gt; xfer)
		maxcount = xfer;

	error = nfsrv_fhtovp(&amp;dnfh, nd, &amp;vp, &amp;nx, &amp;nxo);
	nfsmerr_if(error);

	<span class="enscript-comment">/* update export stats */</span>
	NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

	<span class="enscript-comment">/* update active user stats */</span>
	nfsrv_update_user_stat(nx, nd, kauth_cred_getuid(nd-&gt;nd_cr), 1, 0, 0);

	error = nfsrv_credcheck(nd, ctx, nx, nxo);
	nfsmerr_if(error);

	<span class="enscript-keyword">if</span> (nxo-&gt;nxo_flags &amp; NX_32BITCLIENTS)
		vnopflag |= VNODE_READDIR_SEEKOFF32;

	<span class="enscript-keyword">if</span> (nxo-&gt;nxo_flags &amp; NX_MANGLEDNAMES)
		vnopflag |= VNODE_READDIR_NAMEMAX;

	nfsm_srv_vattr_init(&amp;attr, NFS_VER3);
	error = attrerr = vnode_getattr(vp, &amp;attr, ctx);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; toff &amp;&amp; verf &amp;&amp; (verf != attr.va_filerev))
		error = NFSERR_BAD_COOKIE;
	<span class="enscript-keyword">if</span> (!error)
		error = nfsrv_authorize(vp, NULL, KAUTH_VNODE_LIST_DIRECTORY, ctx, nxo, 0);
	nfsmerr_if(error);

	MALLOC(rbuf, caddr_t, siz, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (rbuf)
		auio = uio_createwithbuffer(1, 0, UIO_SYSSPACE, UIO_READ,
				    &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
	<span class="enscript-keyword">if</span> (!rbuf || !auio) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmerr</span>;
	}

<span class="enscript-reference">again</span>:
	uio_reset(auio, off, UIO_SYSSPACE, UIO_READ);
	uio_addiov(auio, CAST_USER_ADDR_T(rbuf), fullsiz);
	eofflag = 0;
	error = VNOP_READDIR(vp, auio, vnopflag, &amp;eofflag, &amp;nentries, ctx);
	off = uio_offset(auio);
	nfsm_srv_vattr_init(&amp;attr, NFS_VER3);
	attrerr = vnode_getattr(vp, &amp;attr, ctx);
	nfsmerr_if(error);

	<span class="enscript-keyword">if</span> (uio_resid(auio) != 0) {
		siz -= uio_resid(auio);

		<span class="enscript-comment">/* If nothing read, return empty reply with eof set */</span>
		<span class="enscript-keyword">if</span> (siz == 0) {
			vnode_put(vp);
			vp = NULL;
			FREE(rbuf, M_TEMP);
			<span class="enscript-comment">/* assemble reply */</span>
			nd-&gt;nd_repstat = error;
			error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_V3POSTOPATTR +
					NFSX_V3COOKIEVERF + 2 * NFSX_UNSIGNED);
			nfsmout_if(error);
			*mrepp = nmrep.nmc_mhead;
			nfsmout_on_status(nd, error);
			nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, attrerr, &amp;attr);
			nfsm_chain_add_64(error, &amp;nmrep, attr.va_filerev);
			nfsm_chain_add_32(error, &amp;nmrep, FALSE);
			nfsm_chain_add_32(error, &amp;nmrep, TRUE);
			nfsm_chain_build_done(error, &amp;nmrep);
			<span class="enscript-keyword">return</span> (error);
		}
	}

	<span class="enscript-comment">/*
	 * Check for degenerate cases of nothing useful read.
	 * If so go try again
	 */</span>
	cpos = rbuf;
	cend = rbuf + siz;
	dp = (<span class="enscript-type">struct</span> direntry *)cpos;
	<span class="enscript-keyword">while</span> ((dp-&gt;d_fileno == 0) &amp;&amp; (cpos &lt; cend) &amp;&amp; (nentries &gt; 0)) {
		cpos += dp-&gt;d_reclen;
		dp = (<span class="enscript-type">struct</span> direntry *)cpos;
		nentries--;
	}
	<span class="enscript-keyword">if</span> ((cpos &gt;= cend) || (nentries == 0)) {
		toff = off;
		siz = fullsiz;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}

	<span class="enscript-comment">/*
	 * Probe one of the directory entries to see if the filesystem
	 * supports VGET.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = VFS_VGET(vnode_mount(vp), (ino64_t)dp-&gt;d_fileno, &amp;nvp, ctx))) {
		<span class="enscript-keyword">if</span> (error == ENOTSUP) <span class="enscript-comment">/* let others get passed back */</span>
			error = NFSERR_NOTSUPP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmerr</span>;
	}
	vnode_put(nvp);

	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, maxcount);
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	nmrep.nmc_flags |= NFSM_CHAIN_FLAG_ADD_CLUSTERS;

	dirlen = len = NFSX_V3POSTOPATTR + NFSX_V3COOKIEVERF + 2 * NFSX_UNSIGNED;
	nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, attrerr, &amp;attr);
	nfsm_chain_add_64(error, &amp;nmrep, attr.va_filerev);
	nfsmerr_if(error);

	<span class="enscript-comment">/* Loop through the records and build reply */</span>
	<span class="enscript-keyword">while</span> ((cpos &lt; cend) &amp;&amp; (nentries &gt; 0)) {
		<span class="enscript-keyword">if</span> (dp-&gt;d_fileno != 0) {
			nlen = dp-&gt;d_namlen;
			rem = nfsm_rndup(nlen)-nlen;
			gotfh = gotattr = 1;

			<span class="enscript-comment">/* Got to get the vnode for lookup per entry. */</span>
			<span class="enscript-keyword">if</span> (VFS_VGET(vnode_mount(vp), (ino64_t)dp-&gt;d_fileno, &amp;nvp, ctx)) {
				<span class="enscript-comment">/* Can't get the vnode... so no fh or attrs */</span>
				gotfh = gotattr = 0;
			} <span class="enscript-keyword">else</span> {
				isdotdot = ((dp-&gt;d_namlen == 2) &amp;&amp;
					    (dp-&gt;d_name[0] == <span class="enscript-string">'.'</span>) &amp;&amp; (dp-&gt;d_name[1] == <span class="enscript-string">'.'</span>));
				<span class="enscript-keyword">if</span> (nfsrv_vptofh(nx, 0, (isdotdot ? &amp;dnfh : NULL), nvp, ctx, &amp;nfh))
					gotfh = 0;
				nfsm_srv_vattr_init(vap, NFS_VER3);
				<span class="enscript-keyword">if</span> (vnode_getattr(nvp, vap, ctx))
					gotattr = 0;
				vnode_put(nvp);
			}

			<span class="enscript-comment">/*
			 * If either the dircount or maxcount will be
			 * exceeded, get out now. Both of these lengths
			 * are calculated conservatively, including all
			 * XDR overheads.
			 */</span>
			len += 8 * NFSX_UNSIGNED + nlen + rem;
			<span class="enscript-keyword">if</span> (gotattr)
				len += NFSX_V3FATTR;
			<span class="enscript-keyword">if</span> (gotfh)
				len += NFSX_UNSIGNED + nfsm_rndup(nfh.nfh_len);
			dirlen += 6 * NFSX_UNSIGNED + nlen + rem;
			<span class="enscript-keyword">if</span> ((len &gt; maxcount) || (dirlen &gt; dircount)) {
				eofflag = 0;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/* Build the directory record xdr from the direntry. */</span>
			nfsm_chain_add_32(error, &amp;nmrep, TRUE);
			nfsm_chain_add_64(error, &amp;nmrep, dp-&gt;d_fileno);
			nfsm_chain_add_string(error, &amp;nmrep, dp-&gt;d_name, nlen);
			<span class="enscript-keyword">if</span> (vnopflag &amp; VNODE_READDIR_SEEKOFF32)
				dp-&gt;d_seekoff &amp;= 0x00000000ffffffffULL;
			nfsm_chain_add_64(error, &amp;nmrep, dp-&gt;d_seekoff);
			nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, (gotattr ? 0 : ENOENT), vap);
			<span class="enscript-keyword">if</span> (gotfh)
				nfsm_chain_add_postop_fh(error, &amp;nmrep, nfh.nfh_fhp, nfh.nfh_len);
			<span class="enscript-keyword">else</span>
				nfsm_chain_add_32(error, &amp;nmrep, FALSE);
			nfsmerr_if(error);
		}
		cpos += dp-&gt;d_reclen;
		dp = (<span class="enscript-type">struct</span> direntry *)cpos;
		nentries--;
	}
	vnode_put(vp);
	vp = NULL;
	nfsm_chain_add_32(error, &amp;nmrep, FALSE);
	nfsm_chain_add_32(error, &amp;nmrep, eofflag ? TRUE : FALSE);
	FREE(rbuf, M_TEMP);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-keyword">if</span> (rbuf)
		FREE(rbuf, M_TEMP);
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_V3POSTOPATTR);
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, attrerr, &amp;attr);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs commit service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_commit</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	<span class="enscript-type">int</span> error, preattrerr, postattrerr, count;
	<span class="enscript-type">struct</span> vnode_attr preattr, postattr;
	u_quad_t off;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	preattrerr = postattrerr = ENOENT;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	vp = NULL;

	<span class="enscript-comment">/*
	 * XXX At this time VNOP_FSYNC() does not accept offset and byte
	 * count parameters, so those arguments are useless (someday maybe).
	 */</span>

	nfsm_chain_get_fh_ptr(error, nmreq, NFS_VER3, nfh.nfh_fhp, nfh.nfh_len);
	nfsm_chain_get_64(error, nmreq, off);
	nfsm_chain_get_32(error, nmreq, count);
	nfsmerr_if(error);

	error = nfsrv_fhtovp(&amp;nfh, nd, &amp;vp, &amp;nx, &amp;nxo);
	nfsmerr_if(error);

	<span class="enscript-comment">/* update export stats */</span>
	NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

	<span class="enscript-comment">/* update active user stats */</span>
	nfsrv_update_user_stat(nx, nd, kauth_cred_getuid(nd-&gt;nd_cr), 1, 0, 0);

	error = nfsrv_credcheck(nd, ctx, nx, nxo);
	nfsmerr_if(error);

	nfsm_srv_pre_vattr_init(&amp;preattr);
	preattrerr = vnode_getattr(vp, &amp;preattr, ctx);

	error = VNOP_FSYNC(vp, MNT_WAIT, ctx);

	nfsm_srv_vattr_init(&amp;postattr, 1);
	postattrerr = vnode_getattr(vp, &amp;postattr, ctx);

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);

	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_V3WCCDATA + NFSX_V3WRITEVERF);
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	nfsm_chain_add_wcc_data(error, nd, &amp;nmrep,
		preattrerr, &amp;preattr, postattrerr, &amp;postattr);
	<span class="enscript-keyword">if</span> (!nd-&gt;nd_repstat) {
		nfsm_chain_add_32(error, &amp;nmrep, nx-&gt;nx_exptime.tv_sec);
		nfsm_chain_add_32(error, &amp;nmrep, nx-&gt;nx_exptime.tv_usec);
	}
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs statfs service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_statfs</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> vfs_attr va;
	<span class="enscript-type">int</span> error, attrerr;
	vnode_t vp;
	<span class="enscript-type">struct</span> vnode_attr attr;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	off_t blksize;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	attrerr = ENOENT;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	vp = NULL;
	blksize = 512;

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	nfsmerr_if(error);
	error = nfsrv_fhtovp(&amp;nfh, nd, &amp;vp, &amp;nx, &amp;nxo);
	nfsmerr_if(error);

	<span class="enscript-comment">/* update export stats */</span>
	NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

	<span class="enscript-comment">/* update active user stats */</span>
	nfsrv_update_user_stat(nx, nd, kauth_cred_getuid(nd-&gt;nd_cr), 1, 0, 0);

	error = nfsrv_credcheck(nd, ctx, nx, nxo);
	nfsmerr_if(error);

	VFSATTR_INIT(&amp;va);
	VFSATTR_WANTED(&amp;va, f_blocks);
	VFSATTR_WANTED(&amp;va, f_bavail);
	VFSATTR_WANTED(&amp;va, f_files);
	VFSATTR_WANTED(&amp;va, f_ffree);
	error = vfs_getattr(vnode_mount(vp), &amp;va, ctx);
	blksize = vnode_mount(vp)-&gt;mnt_vfsstat.f_bsize;

	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_srv_vattr_init(&amp;attr, nd-&gt;nd_vers);
		attrerr = vnode_getattr(vp, &amp;attr, ctx);
	}

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);

	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_POSTOPATTR(nd-&gt;nd_vers) + NFSX_STATFS(nd-&gt;nd_vers));
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
		nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, attrerr, &amp;attr);
	nfsmout_if(nd-&gt;nd_repstat);

	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_chain_add_64(error, &amp;nmrep, va.f_blocks * blksize);
		nfsm_chain_add_64(error, &amp;nmrep, va.f_bfree * blksize);
		nfsm_chain_add_64(error, &amp;nmrep, va.f_bavail * blksize);
		nfsm_chain_add_64(error, &amp;nmrep, va.f_files);
		nfsm_chain_add_64(error, &amp;nmrep, va.f_ffree);
		nfsm_chain_add_64(error, &amp;nmrep, va.f_ffree);
		nfsm_chain_add_32(error, &amp;nmrep, 0); <span class="enscript-comment">/* invarsec */</span>
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_32(error, &amp;nmrep, NFS_V2MAXDATA);
		nfsm_chain_add_32(error, &amp;nmrep, blksize);
		nfsm_chain_add_32(error, &amp;nmrep, va.f_blocks);
		nfsm_chain_add_32(error, &amp;nmrep, va.f_bfree);
		nfsm_chain_add_32(error, &amp;nmrep, va.f_bavail);
	}
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs fsinfo service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_fsinfo</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">int</span> error, attrerr, prefsize, maxsize;
	vnode_t vp;
	<span class="enscript-type">struct</span> vnode_attr attr;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	attrerr = ENOENT;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	vp = NULL;

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	nfsmerr_if(error);
	error = nfsrv_fhtovp(&amp;nfh, nd, &amp;vp, &amp;nx, &amp;nxo);
	nfsmerr_if(error);

	<span class="enscript-comment">/* update export stats */</span>
	NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

	<span class="enscript-comment">/* update active user stats */</span>
	nfsrv_update_user_stat(nx, nd, kauth_cred_getuid(nd-&gt;nd_cr), 1, 0, 0);

	error = nfsrv_credcheck(nd, ctx, nx, nxo);
	nfsmerr_if(error);

	nfsm_srv_vattr_init(&amp;attr, NFS_VER3);
	attrerr = vnode_getattr(vp, &amp;attr, ctx);

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);

	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_V3POSTOPATTR + NFSX_V3FSINFO);
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, attrerr, &amp;attr);
	nfsmout_if(nd-&gt;nd_repstat);

	<span class="enscript-comment">/*
	 * XXX There should be file system VFS OP(s) to get this information.
	 * For now, assume our usual NFS defaults.
	 */</span>
	<span class="enscript-keyword">if</span> (slp-&gt;ns_sotype == SOCK_DGRAM) {
		maxsize = NFS_MAXDGRAMDATA;
		prefsize = NFS_PREFDGRAMDATA;
	} <span class="enscript-keyword">else</span>
		maxsize = prefsize = NFSRV_MAXDATA;

	nfsm_chain_add_32(error, &amp;nmrep, maxsize);
	nfsm_chain_add_32(error, &amp;nmrep, prefsize);
	nfsm_chain_add_32(error, &amp;nmrep, NFS_FABLKSIZE);
	nfsm_chain_add_32(error, &amp;nmrep, maxsize);
	nfsm_chain_add_32(error, &amp;nmrep, prefsize);
	nfsm_chain_add_32(error, &amp;nmrep, NFS_FABLKSIZE);
	nfsm_chain_add_32(error, &amp;nmrep, prefsize);
	nfsm_chain_add_64(error, &amp;nmrep, 0xffffffffffffffffULL);
	nfsm_chain_add_32(error, &amp;nmrep, 0);
	nfsm_chain_add_32(error, &amp;nmrep, 1);
	<span class="enscript-comment">/* XXX link/symlink support should be taken from volume capabilities */</span>
	nfsm_chain_add_32(error, &amp;nmrep,
		NFSV3FSINFO_LINK | NFSV3FSINFO_SYMLINK |
		NFSV3FSINFO_HOMOGENEOUS | NFSV3FSINFO_CANSETTIME);

<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs pathconf service
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_pathconf</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">int</span> error, attrerr, linkmax, namemax;
	<span class="enscript-type">int</span> chownres, notrunc, case_sensitive, case_preserving;
	vnode_t vp;
	<span class="enscript-type">struct</span> vnode_attr attr;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;

	error = 0;
	attrerr = ENOENT;
	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	vp = NULL;

	nfsm_chain_get_fh_ptr(error, nmreq, nd-&gt;nd_vers, nfh.nfh_fhp, nfh.nfh_len);
	nfsmerr_if(error);
	error = nfsrv_fhtovp(&amp;nfh, nd, &amp;vp, &amp;nx, &amp;nxo);
	nfsmerr_if(error);

	<span class="enscript-comment">/* update export stats */</span>
	NFSStatAdd64(&amp;nx-&gt;nx_stats.ops, 1);

	<span class="enscript-comment">/* update active user stats */</span>
	nfsrv_update_user_stat(nx, nd, kauth_cred_getuid(nd-&gt;nd_cr), 1, 0, 0);

	error = nfsrv_credcheck(nd, ctx, nx, nxo);
	nfsmerr_if(error);

	error = VNOP_PATHCONF(vp, _PC_LINK_MAX, &amp;linkmax, ctx);
	<span class="enscript-keyword">if</span> (!error)
		error = VNOP_PATHCONF(vp, _PC_NAME_MAX, &amp;namemax, ctx);
	<span class="enscript-keyword">if</span> (!error)
		error = VNOP_PATHCONF(vp, _PC_CHOWN_RESTRICTED, &amp;chownres, ctx);
	<span class="enscript-keyword">if</span> (!error)
		error = VNOP_PATHCONF(vp, _PC_NO_TRUNC, &amp;notrunc, ctx);
	<span class="enscript-keyword">if</span> (!error)
		error = VNOP_PATHCONF(vp, _PC_CASE_SENSITIVE, &amp;case_sensitive, ctx);
	<span class="enscript-keyword">if</span> (!error)
		error = VNOP_PATHCONF(vp, _PC_CASE_PRESERVING, &amp;case_preserving, ctx);

	nfsm_srv_vattr_init(&amp;attr, NFS_VER3);
	attrerr = vnode_getattr(vp, &amp;attr, ctx);

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-keyword">if</span> (vp)
		vnode_put(vp);

	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, NFSX_V3POSTOPATTR + NFSX_V3PATHCONF);
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
	nfsmout_on_status(nd, error);
	nfsm_chain_add_postop_attr(error, nd, &amp;nmrep, attrerr, &amp;attr);
	nfsmout_if(nd-&gt;nd_repstat);

	nfsm_chain_add_32(error, &amp;nmrep, linkmax);
	nfsm_chain_add_32(error, &amp;nmrep, namemax);
	nfsm_chain_add_32(error, &amp;nmrep, notrunc);
	nfsm_chain_add_32(error, &amp;nmrep, chownres);
	nfsm_chain_add_32(error, &amp;nmrep, !case_sensitive);
	nfsm_chain_add_32(error, &amp;nmrep, case_preserving);

<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Null operation, used by clients to ping server
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_null</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	__unused vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">int</span> error = NFSERR_RETVOID;
	<span class="enscript-type">struct</span> nfsm_chain nmrep;

	<span class="enscript-comment">/*
	 * RPCSEC_GSS context setup ?
	 */</span>
	<span class="enscript-keyword">if</span> (nd-&gt;nd_gss_context)
		<span class="enscript-keyword">return</span>(nfs_gss_svc_ctx_init(nd, slp, mrepp));

	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, 0);
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * No operation, used for obsolete procedures
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_noop</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	__unused vfs_context_t ctx,
	mbuf_t *mrepp)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> nfsm_chain nmrep;

	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-keyword">if</span> (nd-&gt;nd_repstat)
		error = nd-&gt;nd_repstat;
	<span class="enscript-keyword">else</span>
		error = EPROCUNAVAIL;

	<span class="enscript-comment">/* assemble reply */</span>
	nd-&gt;nd_repstat = error;
	error = nfsrv_rephead(nd, slp, &amp;nmrep, 0);
	nfsmout_if(error);
	*mrepp = nmrep.nmc_mhead;
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-function-name">int</span> (*nfsrv_procs[NFS_NPROCS])(<span class="enscript-type">struct</span> nfsrv_descript *nd,
				    <span class="enscript-type">struct</span> nfsrv_sock *slp,
				    vfs_context_t ctx,
				    mbuf_t *mrepp) = {
	nfsrv_null,
	nfsrv_getattr,
	nfsrv_setattr,
	nfsrv_lookup,
	nfsrv_access,
	nfsrv_readlink,
	nfsrv_read,
	nfsrv_write,
	nfsrv_create,
	nfsrv_mkdir,
	nfsrv_symlink,
	nfsrv_mknod,
	nfsrv_remove,
	nfsrv_rmdir,
	nfsrv_rename,
	nfsrv_link,
	nfsrv_readdir,
	nfsrv_readdirplus,
	nfsrv_statfs,
	nfsrv_fsinfo,
	nfsrv_pathconf,
	nfsrv_commit,
	nfsrv_noop
};

<span class="enscript-comment">/*
 * Perform access checking for vnodes obtained from file handles that would
 * refer to files already opened by a Unix client. You cannot just use
 * vnode_authorize() for two reasons.
 * 1 - You must check for exported rdonly as well as MNT_RDONLY for the write case
 * 2 - The owner is to be given access irrespective of mode bits so that
 *     processes that chmod after opening a file don't break. I don't like
 *     this because it opens a security hole, but since the nfs server opens
 *     a security hole the size of a barn door anyhow, what the heck.
 * 
 * The exception to rule 2 is EPERM. If a file is IMMUTABLE, vnode_authorize()
 * will return EPERM instead of EACCESS. EPERM is always an error.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_authorize</span>(
	vnode_t vp,
	vnode_t dvp,
	kauth_action_t action,
	vfs_context_t ctx,
	<span class="enscript-type">struct</span> nfs_export_options *nxo,
	<span class="enscript-type">int</span> override)
{
	<span class="enscript-type">struct</span> vnode_attr vattr;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (action &amp; KAUTH_VNODE_WRITE_RIGHTS) {
		<span class="enscript-comment">/*
		 * Disallow write attempts on read-only exports;
		 * unless the file is a socket or a block or character
		 * device resident on the file system.
		 */</span>
		<span class="enscript-keyword">if</span> (nxo-&gt;nxo_flags &amp; NX_READONLY) {
			<span class="enscript-keyword">switch</span> (vnode_vtype(vp)) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">VREG</span>: <span class="enscript-keyword">case</span> <span class="enscript-reference">VDIR</span>: <span class="enscript-keyword">case</span> <span class="enscript-reference">VLNK</span>: <span class="enscript-keyword">case</span> <span class="enscript-reference">VCPLX</span>:
				<span class="enscript-keyword">return</span> (EROFS);
			<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">break</span>;
			}
		}
	}
	error = vnode_authorize(vp, dvp, action, ctx);
	<span class="enscript-comment">/*
	 * Allow certain operations for the owner (reads and writes
	 * on files that are already open). Picking up from FreeBSD.
	 */</span>
	<span class="enscript-keyword">if</span> (override &amp;&amp; (error == EACCES)) {
		VATTR_INIT(&amp;vattr);
		VATTR_WANTED(&amp;vattr, va_uid);
		<span class="enscript-keyword">if</span> ((vnode_getattr(vp, &amp;vattr, ctx) == 0) &amp;&amp;
		    (kauth_cred_getuid(vfs_context_ucred(ctx)) == vattr.va_uid))
			error = 0;
	}
	<span class="enscript-keyword">return</span> error;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>

</pre>
<hr />
</body></html>