<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nfs_boot.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nfs_boot.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995, 1997 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1994 Adam Glass, Gordon Ross
 * All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Lawrence Berkeley Laboratory and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *  History:
 *  14-March-97	Dieter Siegmund (<a href="mailto:dieter@next.com">dieter@next.com</a>)
 *	- Use BOOTP instead of RARP to get the IP address at boot time
 *
 *  23-May-97  Umesh Vaishampayan  (<a href="mailto:umeshv@apple.com">umeshv@apple.com</a>)
 *	- Added the ability to mount &quot;/private&quot; separately.
 *
 *  30-May-97	Dieter Siegmund	(<a href="mailto:dieter@next.com">dieter@next.com</a>)
 *	- Clear out the ireq structure before using it to prevent
 *	  our sending using a bogus source IP address, we should use
 *	  an IP address of all zeroes
 *	- Right after BOOTP, get the correct netmask using AUTONETMASK
 *  18-Jul-97	Dieter Siegmund	(<a href="mailto:dieter@apple.com">dieter@apple.com</a>)
 *	- we can't restrict the netmask until we have a default route,
 *	  removed AUTONETMASK call (ifdef'd out)
 *  5-Aug-97	Dieter Siegmund (<a href="mailto:dieter@apple.com">dieter@apple.com</a>)
 *	- use the default route from the bpwhoami call, enabled autonetmask
 *	  again
 *  19-Feb-1999	Dieter Siegmund (<a href="mailto:dieter@apple.com">dieter@apple.com</a>)
 *	- use new BOOTP routine to get the subnet mask and router
 *        and stop using SIOCAUTOADDR
 *      - don't bother mounting private separately if it's not
 *        specified or not required because they are substrings of
 *        one another ie. root=host:/A and private=host:/A/private
 *      - allow the root path to be specified in the boot variable
 *	  &quot;rp&quot; (AKA &quot;rootpath&quot;)
 *  19-Jul-1999 Dieter Siegmund (<a href="mailto:dieter@apple.com">dieter@apple.com</a>)
 *	- replaced big automatic arrays with MALLOC'd data
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/if_ether.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/rpcv2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsdiskless.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/krpc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;ether.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NETHER</span> == 0

<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_boot_init</span>(__unused <span class="enscript-type">struct</span> nfs_diskless *nd)
{
	panic(<span class="enscript-string">&quot;nfs_boot_init: no ether&quot;</span>);
}

<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_boot_getfh</span>(__unused <span class="enscript-type">struct</span> nfs_diskless *nd, __unused <span class="enscript-type">int</span> v3, __unused <span class="enscript-type">int</span> sotype)
{
	panic(<span class="enscript-string">&quot;nfs_boot_getfh: no ether&quot;</span>);
}

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* NETHER */</span>

<span class="enscript-comment">/*
 * Support for NFS diskless booting, specifically getting information
 * about where to boot from, what pathnames, etc.
 *
 * This implememtation uses RARP and the bootparam RPC.
 * We are forced to implement RPC anyway (to get file handles)
 * so we might as well take advantage of it for bootparam too.
 *
 * The diskless boot sequence goes as follows:
 * (1) Use RARP to get our interface address
 * (2) Use RPC/bootparam/whoami to get our hostname,
 *     our IP address, and the server's IP address.
 * (3) Use RPC/bootparam/getfile to get the root path
 * (4) Use RPC/mountd to get the root file handle
 * (5) Use RPC/bootparam/getfile to get the swap path
 * (6) Use RPC/mountd to get the swap file handle
 *
 * (This happens to be the way Sun does it too.)
 */</span>

<span class="enscript-comment">/* bootparam RPC */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bp_whoami</span>(<span class="enscript-type">struct</span> sockaddr_in *bpsin,
	<span class="enscript-type">struct</span> in_addr *my_ip, <span class="enscript-type">struct</span> in_addr *gw_ip);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">bp_getfile</span>(<span class="enscript-type">struct</span> sockaddr_in *bpsin, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *key,
	<span class="enscript-type">struct</span> sockaddr_in *mdsin, <span class="enscript-type">char</span> *servname, <span class="enscript-type">char</span> *path);

<span class="enscript-comment">/* mountd RPC */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">md_mount</span>(<span class="enscript-type">struct</span> sockaddr_in *mdsin, <span class="enscript-type">char</span> *path, <span class="enscript-type">int</span> v3, <span class="enscript-type">int</span> sotype,
	u_char *fhp, u_int32_t *fhlenp);

<span class="enscript-comment">/* other helpers */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">get_file_handle</span>(<span class="enscript-type">struct</span> nfs_dlmount *ndmntp);


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IP_FORMAT</span>	<span class="enscript-string">&quot;%d.%d.%d.%d&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IP_CH</span>(ip)	((u_char *)ip)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IP_LIST</span>(ip)	IP_CH(ip)[0],IP_CH(ip)[1],IP_CH(ip)[2],IP_CH(ip)[3]

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/netboot.h&gt;</span>

<span class="enscript-comment">/*
 * Called with an empty nfs_diskless struct to be filled in.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_boot_init</span>(<span class="enscript-type">struct</span> nfs_diskless *nd)
{
	<span class="enscript-type">struct</span> sockaddr_in 	bp_sin;
	boolean_t		do_bpwhoami = TRUE;
	boolean_t		do_bpgetfile = TRUE;
	<span class="enscript-type">int</span> 			error = 0;
	<span class="enscript-type">struct</span> in_addr 		my_ip;
	<span class="enscript-type">struct</span> sockaddr_in *	sin_p;

	<span class="enscript-comment">/* make sure mbuf constants are set up */</span>
	<span class="enscript-keyword">if</span> (!nfs_mbuf_mhlen)
		nfs_mbuf_init();

	<span class="enscript-comment">/* by this point, networking must already have been configured */</span>
	<span class="enscript-keyword">if</span> (netboot_iaddr(&amp;my_ip) == FALSE) {
	    printf(<span class="enscript-string">&quot;nfs_boot: networking is not initialized\n&quot;</span>);
	    error = ENXIO;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
	}

	<span class="enscript-comment">/* get the root path information */</span>
	MALLOC_ZONE(nd-&gt;nd_root.ndm_path, <span class="enscript-type">char</span> *, MAXPATHLEN, M_NAMEI, M_WAITOK);
	<span class="enscript-keyword">if</span> (!nd-&gt;nd_root.ndm_path) {
	    printf(<span class="enscript-string">&quot;nfs_boot: can't allocate root path buffer\n&quot;</span>);
	    error = ENOMEM;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
	}
	MALLOC_ZONE(nd-&gt;nd_root.ndm_mntfrom, <span class="enscript-type">char</span> *, MAXPATHLEN, M_NAMEI, M_WAITOK);
	<span class="enscript-keyword">if</span> (!nd-&gt;nd_root.ndm_mntfrom) {
	    printf(<span class="enscript-string">&quot;nfs_boot: can't allocate root mntfrom buffer\n&quot;</span>);
	    error = ENOMEM;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
	}
	sin_p = &amp;nd-&gt;nd_root.ndm_saddr;
	bzero((caddr_t)sin_p, <span class="enscript-keyword">sizeof</span>(*sin_p));
	sin_p-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(*sin_p);
	sin_p-&gt;sin_family = AF_INET;
	<span class="enscript-keyword">if</span> (netboot_rootpath(&amp;sin_p-&gt;sin_addr, nd-&gt;nd_root.ndm_host,
			     <span class="enscript-keyword">sizeof</span>(nd-&gt;nd_root.ndm_host),
			     nd-&gt;nd_root.ndm_path, MAXPATHLEN) == TRUE) {
	    do_bpgetfile = FALSE;
	    do_bpwhoami = FALSE;
	}
	nd-&gt;nd_private.ndm_saddr.sin_addr.s_addr = 0;

	<span class="enscript-keyword">if</span> (do_bpwhoami) {
		<span class="enscript-type">struct</span> in_addr router;
		<span class="enscript-comment">/*
		 * Get client name and gateway address.
		 * RPC: bootparam/whoami
		 * Use the old broadcast address for the WHOAMI
		 * call because we do not yet know our netmask.
		 * The server address returned by the WHOAMI call
		 * is used for all subsequent booptaram RPCs.
		 */</span>
		bzero((caddr_t)&amp;bp_sin, <span class="enscript-keyword">sizeof</span>(bp_sin));
		bp_sin.sin_len = <span class="enscript-keyword">sizeof</span>(bp_sin);
		bp_sin.sin_family = AF_INET;
		bp_sin.sin_addr.s_addr = INADDR_BROADCAST;
		hostnamelen = MAXHOSTNAMELEN;
		router.s_addr = 0;
		error = bp_whoami(&amp;bp_sin, &amp;my_ip, &amp;router);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;nfs_boot: bootparam whoami, error=%d&quot;</span>, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
		}
		printf(<span class="enscript-string">&quot;nfs_boot: BOOTPARAMS server &quot;</span> IP_FORMAT <span class="enscript-string">&quot;\n&quot;</span>, 
		       IP_LIST(&amp;bp_sin.sin_addr));
		printf(<span class="enscript-string">&quot;nfs_boot: hostname %s\n&quot;</span>, hostname);
	}
	<span class="enscript-keyword">if</span> (do_bpgetfile) {
		error = bp_getfile(&amp;bp_sin, <span class="enscript-string">&quot;root&quot;</span>, &amp;nd-&gt;nd_root.ndm_saddr,
				   nd-&gt;nd_root.ndm_host, nd-&gt;nd_root.ndm_path);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;nfs_boot: bootparam get root: %d\n&quot;</span>, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
		}
	}

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NO_MOUNT_PRIVATE</span>) 
	<span class="enscript-keyword">if</span> (do_bpgetfile) { <span class="enscript-comment">/* get private path */</span>
		MALLOC_ZONE(nd-&gt;nd_private.ndm_path, <span class="enscript-type">char</span> *, MAXPATHLEN, M_NAMEI, M_WAITOK);
		<span class="enscript-keyword">if</span> (!nd-&gt;nd_private.ndm_path) {
			printf(<span class="enscript-string">&quot;nfs_boot: can't allocate private path buffer\n&quot;</span>);
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
		}
		MALLOC_ZONE(nd-&gt;nd_private.ndm_mntfrom, <span class="enscript-type">char</span> *, MAXPATHLEN, M_NAMEI, M_WAITOK);
		<span class="enscript-keyword">if</span> (!nd-&gt;nd_private.ndm_mntfrom) {
			printf(<span class="enscript-string">&quot;nfs_boot: can't allocate private host buffer\n&quot;</span>);
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
		}
		error = bp_getfile(&amp;bp_sin, <span class="enscript-string">&quot;private&quot;</span>, 
				   &amp;nd-&gt;nd_private.ndm_saddr,
				   nd-&gt;nd_private.ndm_host,
				   nd-&gt;nd_private.ndm_path);
		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-type">char</span> * check_path = NULL;
			
			MALLOC_ZONE(check_path, <span class="enscript-type">char</span> *, MAXPATHLEN, M_NAMEI, M_WAITOK);
			<span class="enscript-keyword">if</span> (!check_path) {
				printf(<span class="enscript-string">&quot;nfs_boot: can't allocate check_path buffer\n&quot;</span>);
				error = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
			}
			snprintf(check_path, MAXPATHLEN, <span class="enscript-string">&quot;%s/private&quot;</span>, nd-&gt;nd_root.ndm_path);
			<span class="enscript-keyword">if</span> ((nd-&gt;nd_root.ndm_saddr.sin_addr.s_addr 
			     == nd-&gt;nd_private.ndm_saddr.sin_addr.s_addr)
			    &amp;&amp; (strncmp(check_path, nd-&gt;nd_private.ndm_path, MAXPATHLEN) == 0)) {
				<span class="enscript-comment">/* private path is prefix of root path, don't mount */</span>
				nd-&gt;nd_private.ndm_saddr.sin_addr.s_addr = 0;
			}
			FREE_ZONE(check_path, MAXPATHLEN, M_NAMEI);
		}
		<span class="enscript-keyword">else</span> { 
			<span class="enscript-comment">/* private key not defined, don't mount */</span>
			nd-&gt;nd_private.ndm_saddr.sin_addr.s_addr = 0;
		}
	}
	<span class="enscript-keyword">else</span> {
		error = 0;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_MOUNT_PRIVATE */</span>
<span class="enscript-reference">failed</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Called with a partially initialized nfs_diskless struct
 * with file handles to be filled in.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_boot_getfh</span>(<span class="enscript-type">struct</span> nfs_diskless *nd, <span class="enscript-type">int</span> v3, <span class="enscript-type">int</span> sotype)
{
	<span class="enscript-type">int</span> error = 0;

	nd-&gt;nd_root.ndm_nfsv3 = v3;
	nd-&gt;nd_root.ndm_sotype = sotype;
	error = get_file_handle(&amp;nd-&gt;nd_root);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;nfs_boot: get_file_handle(v%d) root failed, %d\n&quot;</span>,
			v3 ? 3 : 2, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
	}

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NO_MOUNT_PRIVATE</span>) 
	<span class="enscript-keyword">if</span> (nd-&gt;nd_private.ndm_saddr.sin_addr.s_addr) {
		<span class="enscript-comment">/* get private file handle */</span>
		nd-&gt;nd_private.ndm_nfsv3 = v3;
		nd-&gt;nd_private.ndm_sotype = sotype;
		error = get_file_handle(&amp;nd-&gt;nd_private);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;nfs_boot: get_file_handle(v%d) private failed, %d\n&quot;</span>,
				v3 ? 3 : 2, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_MOUNT_PRIVATE */</span>
<span class="enscript-reference">failed</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">get_file_handle</span>(ndmntp)
	<span class="enscript-type">struct</span> nfs_dlmount *ndmntp;
{
	<span class="enscript-type">char</span> *sp, *dp, *endp;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * Get file handle for &quot;key&quot; (root or swap)
	 * using RPC to mountd/mount
	 */</span>
	error = md_mount(&amp;ndmntp-&gt;ndm_saddr, ndmntp-&gt;ndm_path, ndmntp-&gt;ndm_nfsv3,
			ndmntp-&gt;ndm_sotype, ndmntp-&gt;ndm_fh, &amp;ndmntp-&gt;ndm_fhlen);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/* Construct remote path (for getmntinfo(3)) */</span>
	dp = ndmntp-&gt;ndm_mntfrom;
	endp = dp + MAXPATHLEN - 1;
	<span class="enscript-keyword">for</span> (sp = ndmntp-&gt;ndm_host; *sp &amp;&amp; dp &lt; endp;)
		*dp++ = *sp++;
	<span class="enscript-keyword">if</span> (dp &lt; endp)
		*dp++ = <span class="enscript-string">':'</span>;
	<span class="enscript-keyword">for</span> (sp = ndmntp-&gt;ndm_path; *sp &amp;&amp; dp &lt; endp;)
		*dp++ = *sp++;
	*dp = <span class="enscript-string">'\0'</span>;
	<span class="enscript-keyword">return</span> (0);

}


<span class="enscript-comment">/*
 * Get an mbuf with the given length, and
 * initialize the pkthdr length field.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mbuf_get_with_len</span>(size_t msg_len, mbuf_t *m)
{
	<span class="enscript-type">int</span> error;
	error = mbuf_gethdr(MBUF_WAITOK, MBUF_TYPE_DATA, m);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (msg_len &gt; mbuf_maxlen(*m)) {
		error = mbuf_mclget(MBUF_WAITOK, MBUF_TYPE_DATA, m);
		<span class="enscript-keyword">if</span> (error) {
			mbuf_freem(*m);
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">if</span> (msg_len &gt; mbuf_maxlen(*m))
			panic(<span class="enscript-string">&quot;nfs_boot: msg_len &gt; MCLBYTES&quot;</span>);
	}
	mbuf_setlen(*m, msg_len);
	mbuf_pkthdr_setlen(*m, msg_len);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * String representation for RPC.
 */</span>
<span class="enscript-type">struct</span> rpc_string {
	u_int32_t len;		<span class="enscript-comment">/* length without null or padding */</span>
	u_char data[4];	<span class="enscript-comment">/* data (longer, of course) */</span>
    <span class="enscript-comment">/* data is padded to a long-word boundary */</span>
};
<span class="enscript-comment">/* Compute space used given string length. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">RPC_STR_SIZE</span>(slen) (4 + ((slen + 3) &amp; ~3))

<span class="enscript-comment">/*
 * Inet address in RPC messages
 * (Note, really four 32-bit ints, NOT chars.  Blech.)
 */</span>
<span class="enscript-type">struct</span> bp_inaddr {
	u_int32_t  atype;
	int32_t	addr[4];
};


<span class="enscript-comment">/*
 * RPC: bootparam/whoami
 * Given client IP address, get:
 *	client name	(hostname)
 *	domain name (domainname)
 *	gateway address
 *
 * The hostname and domainname are set here for convenience.
 *
 * Note - bpsin is initialized to the broadcast address,
 * and will be replaced with the bootparam server address
 * after this call is complete.  Have to use PMAP_PROC_CALL
 * to make sure we get responses only from a servers that
 * know about us (don't want to broadcast a getport call).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bp_whoami</span>(bpsin, my_ip, gw_ip)
	<span class="enscript-type">struct</span> sockaddr_in *bpsin;
	<span class="enscript-type">struct</span> in_addr *my_ip;
	<span class="enscript-type">struct</span> in_addr *gw_ip;
{
	<span class="enscript-comment">/* RPC structures for PMAPPROC_CALLIT */</span>
	<span class="enscript-type">struct</span> whoami_call {
		u_int32_t call_prog;
		u_int32_t call_vers;
		u_int32_t call_proc;
		u_int32_t call_arglen;
		<span class="enscript-type">struct</span> bp_inaddr call_ia;
	} *call;

	<span class="enscript-type">struct</span> rpc_string *str;
	<span class="enscript-type">struct</span> bp_inaddr *bia;
	mbuf_t m;
	<span class="enscript-type">struct</span> sockaddr_in sin;
	<span class="enscript-type">int</span> error;
	size_t msg_len, cn_len, dn_len;
	u_char *p;
	int32_t *lp;

	<span class="enscript-comment">/*
	 * Get message buffer of sufficient size.
	 */</span>
	msg_len = <span class="enscript-keyword">sizeof</span>(*call);
	error = mbuf_get_with_len(msg_len, &amp;m);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-comment">/*
	 * Build request message for PMAPPROC_CALLIT.
	 */</span>
	call = mbuf_data(m);
	call-&gt;call_prog = htonl(BOOTPARAM_PROG);
	call-&gt;call_vers = htonl(BOOTPARAM_VERS);
	call-&gt;call_proc = htonl(BOOTPARAM_WHOAMI);
	call-&gt;call_arglen = htonl(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bp_inaddr));

	<span class="enscript-comment">/* client IP address */</span>
	call-&gt;call_ia.atype = htonl(1);
	p = (u_char*)my_ip;
	lp = call-&gt;call_ia.addr;
	*lp++ = htonl(*p);	p++;
	*lp++ = htonl(*p);	p++;
	*lp++ = htonl(*p);	p++;
	*lp++ = htonl(*p);	p++;

	<span class="enscript-comment">/* RPC: portmap/callit */</span>
	bpsin-&gt;sin_port = htons(PMAPPORT);

	error = krpc_call(bpsin, SOCK_DGRAM, PMAPPROG, PMAPVERS, PMAPPROC_CALLIT, &amp;m, &amp;sin);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-comment">/*
	 * Parse result message.
	 */</span>
	msg_len = mbuf_len(m);
	lp = mbuf_data(m);

	<span class="enscript-comment">/* bootparam server port (also grab from address). */</span>
	<span class="enscript-keyword">if</span> (msg_len &lt; <span class="enscript-keyword">sizeof</span>(*lp))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	msg_len -= <span class="enscript-keyword">sizeof</span>(*lp);
	bpsin-&gt;sin_port = htons((<span class="enscript-type">short</span>)ntohl(*lp++));
	bpsin-&gt;sin_addr.s_addr = sin.sin_addr.s_addr;

	<span class="enscript-comment">/* length of encapsulated results */</span>
	<span class="enscript-keyword">if</span> (msg_len &lt; (ntohl(*lp) + <span class="enscript-keyword">sizeof</span>(*lp)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	msg_len = ntohl(*lp++);
	p = (u_char*)lp;

	<span class="enscript-comment">/* client name */</span>
	<span class="enscript-keyword">if</span> (msg_len &lt; <span class="enscript-keyword">sizeof</span>(*str))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	str = (<span class="enscript-type">struct</span> rpc_string *)p;
	cn_len = ntohl(str-&gt;len);
	<span class="enscript-keyword">if</span> (msg_len &lt; cn_len)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	<span class="enscript-keyword">if</span> (cn_len &gt;= MAXHOSTNAMELEN)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	bcopy(str-&gt;data, hostname, cn_len);
	hostname[cn_len] = <span class="enscript-string">'\0'</span>;
	hostnamelen = cn_len;
	p += RPC_STR_SIZE(cn_len);
	msg_len -= RPC_STR_SIZE(cn_len);

	<span class="enscript-comment">/* domain name */</span>
	<span class="enscript-keyword">if</span> (msg_len &lt; <span class="enscript-keyword">sizeof</span>(*str))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	str = (<span class="enscript-type">struct</span> rpc_string *)p;
	dn_len = ntohl(str-&gt;len);
	<span class="enscript-keyword">if</span> (msg_len &lt; dn_len)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	<span class="enscript-keyword">if</span> (dn_len &gt;= MAXHOSTNAMELEN)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	bcopy(str-&gt;data, domainname, dn_len);
	domainname[dn_len] = <span class="enscript-string">'\0'</span>;
	domainnamelen = dn_len;
	p += RPC_STR_SIZE(dn_len);
	msg_len -= RPC_STR_SIZE(dn_len);

	<span class="enscript-comment">/* gateway address */</span>
	<span class="enscript-keyword">if</span> (msg_len &lt; <span class="enscript-keyword">sizeof</span>(*bia))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	bia = (<span class="enscript-type">struct</span> bp_inaddr *)p;
	<span class="enscript-keyword">if</span> (bia-&gt;atype != htonl(1))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	p = (u_char*)gw_ip;
	*p++ = ntohl(bia-&gt;addr[0]);
	*p++ = ntohl(bia-&gt;addr[1]);
	*p++ = ntohl(bia-&gt;addr[2]);
	*p++ = ntohl(bia-&gt;addr[3]);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

<span class="enscript-reference">bad</span>:
	printf(<span class="enscript-string">&quot;nfs_boot: bootparam_whoami: bad reply\n&quot;</span>);
	error = EBADRPC;

<span class="enscript-reference">out</span>:
	mbuf_freem(m);
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * RPC: bootparam/getfile
 * Given client name and file &quot;key&quot;, get:
 *	server name
 *	server IP address
 *	server pathname
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">bp_getfile</span>(bpsin, key, md_sin, serv_name, pathname)
	<span class="enscript-type">struct</span> sockaddr_in *bpsin;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *key;
	<span class="enscript-type">struct</span> sockaddr_in *md_sin;
	<span class="enscript-type">char</span> *serv_name;
	<span class="enscript-type">char</span> *pathname;
{
	<span class="enscript-type">struct</span> rpc_string *str;
	mbuf_t m;
	<span class="enscript-type">struct</span> bp_inaddr *bia;
	<span class="enscript-type">struct</span> sockaddr_in *sin;
	u_char *p, *q;
	<span class="enscript-type">int</span> error, msg_len;
	<span class="enscript-type">int</span> cn_len, key_len, sn_len, path_len;

	<span class="enscript-comment">/*
	 * Get message buffer of sufficient size.
	 */</span>
	cn_len = hostnamelen;
	key_len = strlen(key);
	msg_len = 0;
	msg_len += RPC_STR_SIZE(cn_len);
	msg_len += RPC_STR_SIZE(key_len);
	error = mbuf_get_with_len(msg_len, &amp;m);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-comment">/*
	 * Build request message.
	 */</span>
	p = mbuf_data(m);
	bzero(p, msg_len);
	<span class="enscript-comment">/* client name (hostname) */</span>
	str = (<span class="enscript-type">struct</span> rpc_string *)p;
	str-&gt;len = htonl(cn_len);
	bcopy(hostname, str-&gt;data, cn_len);
	p += RPC_STR_SIZE(cn_len);
	<span class="enscript-comment">/* key name (root or swap) */</span>
	str = (<span class="enscript-type">struct</span> rpc_string *)p;
	str-&gt;len = htonl(key_len);
	bcopy(key, str-&gt;data, key_len);

	<span class="enscript-comment">/* RPC: bootparam/getfile */</span>
	error = krpc_call(bpsin, SOCK_DGRAM, BOOTPARAM_PROG, BOOTPARAM_VERS,
			BOOTPARAM_GETFILE, &amp;m, NULL);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-comment">/*
	 * Parse result message.
	 */</span>
	p = mbuf_data(m);
	msg_len = mbuf_len(m);

	<span class="enscript-comment">/* server name */</span>
	<span class="enscript-keyword">if</span> (msg_len &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(*str))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	str = (<span class="enscript-type">struct</span> rpc_string *)p;
	sn_len = ntohl(str-&gt;len);
	<span class="enscript-keyword">if</span> (msg_len &lt; sn_len)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	<span class="enscript-keyword">if</span> (sn_len &gt;= MAXHOSTNAMELEN)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	bcopy(str-&gt;data, serv_name, sn_len);
	serv_name[sn_len] = <span class="enscript-string">'\0'</span>;
	p += RPC_STR_SIZE(sn_len);
	msg_len -= RPC_STR_SIZE(sn_len);

	<span class="enscript-comment">/* server IP address (mountd) */</span>
	<span class="enscript-keyword">if</span> (msg_len &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(*bia))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	bia = (<span class="enscript-type">struct</span> bp_inaddr *)p;
	<span class="enscript-keyword">if</span> (bia-&gt;atype != htonl(1))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	sin = md_sin;
	bzero((caddr_t)sin, <span class="enscript-keyword">sizeof</span>(*sin));
	sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(*sin);
	sin-&gt;sin_family = AF_INET;
	q = (u_char*) &amp;sin-&gt;sin_addr;
	*q++ = ntohl(bia-&gt;addr[0]);
	*q++ = ntohl(bia-&gt;addr[1]);
	*q++ = ntohl(bia-&gt;addr[2]);
	*q++ = ntohl(bia-&gt;addr[3]);
	p += <span class="enscript-keyword">sizeof</span>(*bia);
	msg_len -= <span class="enscript-keyword">sizeof</span>(*bia);

	<span class="enscript-comment">/* server pathname */</span>
	<span class="enscript-keyword">if</span> (msg_len &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(*str))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	str = (<span class="enscript-type">struct</span> rpc_string *)p;
	path_len = ntohl(str-&gt;len);
	<span class="enscript-keyword">if</span> (msg_len &lt; path_len)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	<span class="enscript-keyword">if</span> (path_len &gt;= MAXPATHLEN)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	bcopy(str-&gt;data, pathname, path_len);
	pathname[path_len] = <span class="enscript-string">'\0'</span>;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

<span class="enscript-reference">bad</span>:
	printf(<span class="enscript-string">&quot;nfs_boot: bootparam_getfile: bad reply\n&quot;</span>);
	error = EBADRPC;

<span class="enscript-reference">out</span>:
	mbuf_freem(m);
	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-comment">/*
 * RPC: mountd/mount
 * Given a server pathname, get an NFS file handle.
 * Also, sets sin-&gt;sin_port to the NFS service port.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">md_mount</span>(mdsin, path, v3, sotype, fhp, fhlenp)
	<span class="enscript-type">struct</span> sockaddr_in *mdsin;		<span class="enscript-comment">/* mountd server address */</span>
	<span class="enscript-type">char</span> *path;
	<span class="enscript-type">int</span> v3;
	<span class="enscript-type">int</span> sotype;
	u_char *fhp;
	u_int32_t *fhlenp;
{
	<span class="enscript-comment">/* The RPC structures */</span>
	<span class="enscript-type">struct</span> rpc_string *str;
	<span class="enscript-type">struct</span> rdata {
		u_int32_t	errno;
		u_char	data[NFSX_V3FHMAX + <span class="enscript-keyword">sizeof</span>(u_int32_t)];
	} *rdata;
	mbuf_t m;
	<span class="enscript-type">int</span> error, mlen, slen;
	<span class="enscript-type">int</span> mntversion = v3 ? RPCMNT_VER3 : RPCMNT_VER1;
	<span class="enscript-type">int</span> proto = (sotype == SOCK_STREAM) ? IPPROTO_TCP : IPPROTO_UDP;
	in_port_t mntport, nfsport;

	<span class="enscript-comment">/* Get port number for MOUNTD. */</span>
	error = krpc_portmap(mdsin, RPCPROG_MNT, mntversion, proto, &amp;mntport);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-comment">/* Get port number for NFS use. */</span>
	<span class="enscript-comment">/* (If NFS/proto unavailable, don't bother with the mount call) */</span>
	error = krpc_portmap(mdsin, NFS_PROG, v3 ? NFS_VER3 : NFS_VER2, proto, &amp;nfsport);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-comment">/* Set port number for MOUNTD */</span>
	mdsin-&gt;sin_port = mntport;

	slen = strlen(path);
	mlen = RPC_STR_SIZE(slen);

	error = mbuf_get_with_len(mlen, &amp;m);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;
	str = mbuf_data(m);
	str-&gt;len = htonl(slen);
	bcopy(path, str-&gt;data, slen);

	<span class="enscript-comment">/* Do RPC to mountd. */</span>
	error = krpc_call(mdsin, sotype, RPCPROG_MNT, mntversion, RPCMNT_MOUNT, &amp;m, NULL);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;	<span class="enscript-comment">/* message already freed */</span>

	<span class="enscript-comment">/*
	 * the reply must be long enough to hold the errno plus either of:
	 * + a v2 filehandle
	 * + a v3 filehandle length + a v3 filehandle
	 */</span>
	mlen = mbuf_len(m);
	<span class="enscript-keyword">if</span> (mlen &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(u_int32_t))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	rdata = mbuf_data(m);
	error = ntohl(rdata-&gt;errno);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> (v3) {
		u_int32_t fhlen;
		u_char *fh;
		<span class="enscript-keyword">if</span> (mlen &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(u_int32_t)*2)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		fhlen = ntohl(*(u_int32_t*)rdata-&gt;data);
		fh = rdata-&gt;data + <span class="enscript-keyword">sizeof</span>(u_int32_t);
		<span class="enscript-keyword">if</span> (mlen &lt; (<span class="enscript-type">int</span>)(<span class="enscript-keyword">sizeof</span>(u_int32_t)*2 + fhlen))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		bcopy(fh, fhp, fhlen);
		*fhlenp = fhlen;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (mlen &lt; ((<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(u_int32_t) + NFSX_V2FH))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		bcopy(rdata-&gt;data, fhp, NFSX_V2FH);
		*fhlenp = NFSX_V2FH;
	}

	<span class="enscript-comment">/* Set port number for NFS use. */</span>
	mdsin-&gt;sin_port = nfsport;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

<span class="enscript-reference">bad</span>:
	error = EBADRPC;

<span class="enscript-reference">out</span>:
	mbuf_freem(m);
	<span class="enscript-keyword">return</span> error;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NETHER */</span>
</pre>
<hr />
</body></html>