<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>krpc_subr.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">krpc_subr.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1994 Gordon Ross, Adam Glass 
 * Copyright (c) 1992 Regents of the University of California.
 * All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/reboot.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/rpcv2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/krpc.h&gt;</span>

<span class="enscript-comment">/*
 * Kernel support for Sun RPC
 *
 * Used currently for bootstrapping in nfs diskless configurations.
 * 
 * Note: will not work on variable-sized rpc args/results.
 *       implicit size-limit of an mbuf.
 */</span>

<span class="enscript-comment">/*
 * Generic RPC headers
 */</span>

<span class="enscript-type">struct</span> auth_info {
	u_int32_t	rp_atype;	<span class="enscript-comment">/* auth type */</span>
	u_int32_t	rp_alen;	<span class="enscript-comment">/* auth length */</span>
};

<span class="enscript-type">struct</span> rpc_call {
	u_int32_t	rp_xid;		<span class="enscript-comment">/* request transaction id */</span>
	int32_t 	rp_direction;	<span class="enscript-comment">/* call direction (0) */</span>
	u_int32_t	rp_rpcvers;	<span class="enscript-comment">/* rpc version (2) */</span>
	u_int32_t	rp_prog;	<span class="enscript-comment">/* program */</span>
	u_int32_t	rp_vers;	<span class="enscript-comment">/* version */</span>
	u_int32_t	rp_proc;	<span class="enscript-comment">/* procedure */</span>
	<span class="enscript-type">struct</span>	auth_info rp_auth;
	<span class="enscript-type">struct</span>	auth_info rp_verf;
};

<span class="enscript-type">struct</span> rpc_reply {
	u_int32_t rp_xid;		<span class="enscript-comment">/* request transaction id */</span>
	int32_t  rp_direction;		<span class="enscript-comment">/* call direction (1) */</span>
	int32_t  rp_astatus;		<span class="enscript-comment">/* accept status (0: accepted) */</span>
	<span class="enscript-type">union</span> {
		u_int32_t rpu_errno;
		<span class="enscript-type">struct</span> {
			<span class="enscript-type">struct</span> auth_info rp_auth;
			u_int32_t	rp_rstatus;
		} rpu_ok;
	} rp_u;
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MIN_REPLY_HDR</span> 16	<span class="enscript-comment">/* xid, dir, astat, errno */</span>

<span class="enscript-comment">/*
 * What is the longest we will wait before re-sending a request?
 * Note this is also the frequency of &quot;RPC timeout&quot; messages.
 * The re-send loop count sup linearly to this maximum, so the
 * first complaint will happen after (1+2+3+4+5)=15 seconds.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_RESEND_DELAY</span> 5	<span class="enscript-comment">/* seconds */</span>

<span class="enscript-comment">/* copied over from nfs_boot.c for printf format. could put in .h file... */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IP_FORMAT</span>       <span class="enscript-string">&quot;%d.%d.%d.%d&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IP_CH</span>(ip)       ((u_char *)ip)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IP_LIST</span>(ip)     IP_CH(ip)[0],IP_CH(ip)[1],IP_CH(ip)[2],IP_CH(ip)[3]


<span class="enscript-comment">/*
 * Call portmap to lookup a port number for a particular rpc program
 * Returns non-zero error on failure.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">krpc_portmap</span>(sin, prog, vers, proto, portp)
	<span class="enscript-type">struct</span> sockaddr_in *sin;	<span class="enscript-comment">/* server address */</span>
	u_int prog, vers, proto;	<span class="enscript-comment">/* host order */</span>
	u_int16_t *portp;		<span class="enscript-comment">/* network order */</span>
{
	<span class="enscript-type">struct</span> sdata {
		u_int32_t prog;		<span class="enscript-comment">/* call program */</span>
		u_int32_t vers;		<span class="enscript-comment">/* call version */</span>
		u_int32_t proto;	<span class="enscript-comment">/* call protocol */</span>
		u_int32_t port;		<span class="enscript-comment">/* call port (unused) */</span>
	} *sdata;
	<span class="enscript-type">struct</span> rdata {
		u_int16_t pad;
		u_int16_t port;
	} *rdata;
	mbuf_t m;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* The portmapper port is fixed. */</span>
	<span class="enscript-keyword">if</span> (prog == PMAPPROG) {
		*portp = htons(PMAPPORT);
		<span class="enscript-keyword">return</span> 0;
	}

	error = mbuf_gethdr(MBUF_WAITOK, MBUF_TYPE_DATA, &amp;m);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;
	mbuf_setlen(m, <span class="enscript-keyword">sizeof</span>(*sdata));
	mbuf_pkthdr_setlen(m, <span class="enscript-keyword">sizeof</span>(*sdata));
	sdata = mbuf_data(m);

	<span class="enscript-comment">/* Do the RPC to get it. */</span>
	sdata-&gt;prog = htonl(prog);
	sdata-&gt;vers = htonl(vers);
	sdata-&gt;proto = htonl(proto);
	sdata-&gt;port = 0;

	sin-&gt;sin_port = htons(PMAPPORT);
	error = krpc_call(sin, SOCK_DGRAM, PMAPPROG, PMAPVERS, PMAPPROC_GETPORT, &amp;m, NULL);
	<span class="enscript-keyword">if</span> (error) 
		<span class="enscript-keyword">return</span> error;

	rdata = mbuf_data(m);
	*portp = rdata-&gt;port;

	<span class="enscript-keyword">if</span> (!rdata-&gt;port)
		error = EPROGUNAVAIL;

	mbuf_freem(m);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Do a remote procedure call (RPC) and wait for its reply.
 * If from_p is non-null, then we are doing broadcast, and
 * the address from whence the response came is saved there.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">krpc_call</span>(sa, sotype, prog, vers, func, data, from_p)
	<span class="enscript-type">struct</span> sockaddr_in *sa;
	u_int sotype, prog, vers, func;
	mbuf_t *data;			<span class="enscript-comment">/* input/output */</span>
	<span class="enscript-type">struct</span> sockaddr_in *from_p;	<span class="enscript-comment">/* output */</span>
{
	socket_t so;
	<span class="enscript-type">struct</span> sockaddr_in *sin;
	mbuf_t m, nam, mhead;
	<span class="enscript-type">struct</span> rpc_call *call;
	<span class="enscript-type">struct</span> rpc_reply *reply;
	<span class="enscript-type">int</span> error, timo, secs;
	size_t len;
	<span class="enscript-type">static</span> u_int32_t xid = ~0xFF;
	u_int16_t tport;
	size_t maxpacket = 1&lt;&lt;16;

	<span class="enscript-comment">/*
	 * Validate address family.
	 * Sorry, this is INET specific...
	 */</span>
	<span class="enscript-keyword">if</span> (sa-&gt;sin_family != AF_INET)
		<span class="enscript-keyword">return</span> (EAFNOSUPPORT);

	<span class="enscript-comment">/* Free at end if not null. */</span>
	nam = mhead = NULL;

	<span class="enscript-comment">/*
	 * Create socket and set its recieve timeout.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = sock_socket(AF_INET, sotype, 0, 0, 0, &amp;so)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;

	{
		<span class="enscript-type">struct</span> timeval tv;

		tv.tv_sec = 1;
		tv.tv_usec = 0;

		<span class="enscript-keyword">if</span> ((error = sock_setsockopt(so, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, <span class="enscript-keyword">sizeof</span>(tv))))
		    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	}

	<span class="enscript-comment">/*
	 * Enable broadcast if necessary.
	 */</span>

	<span class="enscript-keyword">if</span> (from_p &amp;&amp; (sotype == SOCK_DGRAM)) {
		<span class="enscript-type">int</span> on = 1;
		<span class="enscript-keyword">if</span> ((error = sock_setsockopt(so, SOL_SOCKET, SO_BROADCAST, &amp;on, <span class="enscript-keyword">sizeof</span>(on))))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Bind the local endpoint to a reserved port,
	 * because some NFS servers refuse requests from
	 * non-reserved (non-privileged) ports.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = mbuf_get(MBUF_WAITOK, MBUF_TYPE_SONAME, &amp;m)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	sin = mbuf_data(m);
	bzero(sin, <span class="enscript-keyword">sizeof</span>(*sin));
	mbuf_setlen(m, <span class="enscript-keyword">sizeof</span>(*sin));
	sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(*sin);
	sin-&gt;sin_family = AF_INET;
	sin-&gt;sin_addr.s_addr = INADDR_ANY;
	tport = IPPORT_RESERVED;
	<span class="enscript-keyword">do</span> {
		tport--;
		sin-&gt;sin_port = htons(tport);
		error = sock_bind(so, (<span class="enscript-type">struct</span> sockaddr*)sin);
	} <span class="enscript-keyword">while</span> (error == EADDRINUSE &amp;&amp;
			 tport &gt; IPPORT_RESERVED / 2);
	mbuf_freem(m);
	m = NULL;
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;bind failed\n&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Setup socket address for the server.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = mbuf_get(MBUF_WAITOK, MBUF_TYPE_SONAME, &amp;nam)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	sin = mbuf_data(nam);
	mbuf_setlen(nam, sa-&gt;sin_len);
	bcopy((caddr_t)sa, (caddr_t)sin, sa-&gt;sin_len);

	<span class="enscript-keyword">if</span> (sotype == SOCK_STREAM) {
		<span class="enscript-type">struct</span> timeval tv;
		tv.tv_sec = 60;
		tv.tv_usec = 0;
		error = sock_connect(so, mbuf_data(nam), MSG_DONTWAIT);
		<span class="enscript-keyword">if</span> (error &amp;&amp; (error != EINPROGRESS))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		error = sock_connectwait(so, &amp;tv);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error == EINPROGRESS)
				error = ETIMEDOUT;
			printf(<span class="enscript-string">&quot;krpc_call: error waiting for TCP socket connect: %d\n&quot;</span>, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-comment">/*
	 * Prepend RPC message header.
	 */</span>
	m = *data;
	*data = NULL;
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> ((mbuf_flags(m) &amp; MBUF_PKTHDR) == 0)
		panic(<span class="enscript-string">&quot;krpc_call: send data w/o pkthdr&quot;</span>);
	<span class="enscript-keyword">if</span> (mbuf_pkthdr_len(m) &lt; mbuf_len(m))
		panic(<span class="enscript-string">&quot;krpc_call: pkthdr.len not set&quot;</span>);
#<span class="enscript-reference">endif</span>
	len = <span class="enscript-keyword">sizeof</span>(*call);
	<span class="enscript-keyword">if</span> (sotype == SOCK_STREAM)
		len += 4;  <span class="enscript-comment">/* account for RPC record marker */</span>
	mhead = m;
	<span class="enscript-keyword">if</span> ((error = mbuf_prepend(&amp;mhead, len, MBUF_WAITOK)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-keyword">if</span> ((error = mbuf_pkthdr_setrcvif(mhead, NULL)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * Fill in the RPC header
	 */</span>
	<span class="enscript-keyword">if</span> (sotype == SOCK_STREAM) {
		<span class="enscript-comment">/* first, fill in RPC record marker */</span>
		u_int32_t *recmark = mbuf_data(mhead);
		*recmark = htonl(0x80000000 | (mbuf_pkthdr_len(mhead) - 4));
		call = (<span class="enscript-type">struct</span> rpc_call *)(recmark + 1);
	} <span class="enscript-keyword">else</span> {
		call = mbuf_data(mhead);
	}
	bzero((caddr_t)call, <span class="enscript-keyword">sizeof</span>(*call));
	xid++;
	call-&gt;rp_xid = htonl(xid);
	<span class="enscript-comment">/* call-&gt;rp_direction = 0; */</span>
	call-&gt;rp_rpcvers = htonl(2);
	call-&gt;rp_prog = htonl(prog);
	call-&gt;rp_vers = htonl(vers);
	call-&gt;rp_proc = htonl(func);
	<span class="enscript-comment">/* call-&gt;rp_auth = 0; */</span>
	<span class="enscript-comment">/* call-&gt;rp_verf = 0; */</span>

	<span class="enscript-comment">/*
	 * Send it, repeatedly, until a reply is received,
	 * but delay each re-send by an increasing amount.
	 * If the delay hits the maximum, start complaining.
	 */</span>
	timo = 0;
	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-type">struct</span> msghdr msg;
		
		<span class="enscript-comment">/* Send RPC request (or re-send). */</span>
		<span class="enscript-keyword">if</span> ((error = mbuf_copym(mhead, 0, MBUF_COPYALL, MBUF_WAITOK, &amp;m)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		bzero(&amp;msg, <span class="enscript-keyword">sizeof</span>(msg));
		<span class="enscript-keyword">if</span> (sotype == SOCK_STREAM) {
			msg.msg_name = NULL;
			msg.msg_namelen = 0;
		} <span class="enscript-keyword">else</span> {
			msg.msg_name = mbuf_data(nam);
			msg.msg_namelen = mbuf_len(nam);
		}
		error = sock_sendmbuf(so, &amp;msg, m, 0, 0);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;krpc_call: sosend: %d\n&quot;</span>, error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		m = NULL;

		<span class="enscript-comment">/* Determine new timeout. */</span>
		<span class="enscript-keyword">if</span> (timo &lt; MAX_RESEND_DELAY)
			timo++;
            	<span class="enscript-keyword">else</span>
           		printf(<span class="enscript-string">&quot;RPC timeout for server &quot;</span> IP_FORMAT <span class="enscript-string">&quot;\n&quot;</span>,
				IP_LIST(&amp;(sin-&gt;sin_addr.s_addr)));

		<span class="enscript-comment">/*
		 * Wait for up to timo seconds for a reply.
		 * The socket receive timeout was set to 1 second.
		 */</span>
		secs = timo;
		<span class="enscript-keyword">while</span> (secs &gt; 0) {
			size_t readlen;
			
			<span class="enscript-keyword">if</span> (m) {
				mbuf_freem(m);
				m = NULL;
			}
			<span class="enscript-keyword">if</span> (sotype == SOCK_STREAM) {
				<span class="enscript-type">int</span> maxretries = 60;
				<span class="enscript-type">struct</span> iovec aio;
				aio.iov_base = &amp;len;
				aio.iov_len = <span class="enscript-keyword">sizeof</span>(u_int32_t);
				bzero(&amp;msg, <span class="enscript-keyword">sizeof</span>(msg));
				msg.msg_iov = &amp;aio;
				msg.msg_iovlen = 1;
				<span class="enscript-keyword">do</span> {
				   error = sock_receive(so, &amp;msg, MSG_WAITALL, &amp;readlen);
				   <span class="enscript-keyword">if</span> ((error == EWOULDBLOCK) &amp;&amp; (--maxretries &lt;= 0))
					error = ETIMEDOUT;
				} <span class="enscript-keyword">while</span> (error == EWOULDBLOCK);
				<span class="enscript-keyword">if</span> (!error &amp;&amp; readlen &lt; aio.iov_len) {
				    <span class="enscript-comment">/* only log a message if we got a partial word */</span>
				    <span class="enscript-keyword">if</span> (readlen != 0)
					    printf(<span class="enscript-string">&quot;short receive (%ld/%ld) from server &quot;</span> IP_FORMAT <span class="enscript-string">&quot;\n&quot;</span>,
						 readlen, <span class="enscript-keyword">sizeof</span>(u_int32_t), IP_LIST(&amp;(sin-&gt;sin_addr.s_addr)));
				    error = EPIPE;
				}
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				len = ntohl(len) &amp; ~0x80000000;
				<span class="enscript-comment">/*
				 * This is SERIOUS! We are out of sync with the sender
				 * and forcing a disconnect/reconnect is all I can do.
				 */</span>
				<span class="enscript-keyword">if</span> (len &gt; maxpacket) {
				    printf(<span class="enscript-string">&quot;impossible packet length (%ld) from server &quot;</span> IP_FORMAT <span class="enscript-string">&quot;\n&quot;</span>,
					len, IP_LIST(&amp;(sin-&gt;sin_addr.s_addr)));
				    error = EFBIG;
				    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				
				<span class="enscript-keyword">do</span> {
				    readlen = len;
				    error = sock_receivembuf(so, NULL, &amp;m, MSG_WAITALL, &amp;readlen);
				} <span class="enscript-keyword">while</span> (error == EWOULDBLOCK);

				<span class="enscript-keyword">if</span> (!error &amp;&amp; (len &gt; readlen)) {
				    printf(<span class="enscript-string">&quot;short receive (%ld/%ld) from server &quot;</span> IP_FORMAT <span class="enscript-string">&quot;\n&quot;</span>,
					readlen, len, IP_LIST(&amp;(sin-&gt;sin_addr.s_addr)));
				    error = EPIPE;
				}
			} <span class="enscript-keyword">else</span> {
				len = maxpacket;
				readlen = len;
				bzero(&amp;msg, <span class="enscript-keyword">sizeof</span>(msg));
				msg.msg_name = from_p;
				msg.msg_namelen = (from_p == NULL) ? 0 : <span class="enscript-keyword">sizeof</span>(*from_p);
				error = sock_receivembuf(so, &amp;msg, &amp;m, 0, &amp;readlen);
			}

			<span class="enscript-keyword">if</span> (error == EWOULDBLOCK) {
				secs--;
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			len = readlen;

			<span class="enscript-comment">/* Does the reply contain at least a header? */</span>
			<span class="enscript-keyword">if</span> (len &lt; MIN_REPLY_HDR)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (mbuf_len(m) &lt; MIN_REPLY_HDR)
				<span class="enscript-keyword">continue</span>;
			reply = mbuf_data(m);

			<span class="enscript-comment">/* Is it the right reply? */</span>
			<span class="enscript-keyword">if</span> (reply-&gt;rp_direction != htonl(RPC_REPLY))
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (reply-&gt;rp_xid != htonl(xid))
				<span class="enscript-keyword">continue</span>;
			
			<span class="enscript-comment">/* Was RPC accepted? (authorization OK) */</span>
			<span class="enscript-keyword">if</span> (reply-&gt;rp_astatus != 0) {
				error = ntohl(reply-&gt;rp_u.rpu_errno);
				printf(<span class="enscript-string">&quot;rpc denied, error=%d\n&quot;</span>, error);
				<span class="enscript-comment">/* convert rpc error to errno */</span>
				<span class="enscript-keyword">switch</span> (error) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_MISMATCH</span>:
					error = ERPCMISMATCH;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_AUTHERR</span>:
					error = EAUTH;
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			<span class="enscript-comment">/* Did the call succeed? */</span>
			<span class="enscript-keyword">if</span> ((error = ntohl(reply-&gt;rp_u.rpu_ok.rp_rstatus)) != 0) {
				printf(<span class="enscript-string">&quot;rpc status=%d\n&quot;</span>, error);
				<span class="enscript-comment">/* convert rpc error to errno */</span>
				<span class="enscript-keyword">switch</span> (error) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_PROGUNAVAIL</span>:
					error = EPROGUNAVAIL;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_PROGMISMATCH</span>:
					error = EPROGMISMATCH;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_PROCUNAVAIL</span>:
					error = EPROCUNAVAIL;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_GARBAGE</span>:
					error = EINVAL;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_SYSTEM_ERR</span>:
					error = EIO;
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">gotreply</span>;	<span class="enscript-comment">/* break two levels */</span>

		} <span class="enscript-comment">/* while secs */</span>
	} <span class="enscript-comment">/* forever send/receive */</span>

	error = ETIMEDOUT;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

 <span class="enscript-reference">gotreply</span>:

	<span class="enscript-comment">/*
	 * Pull as much as we can into first mbuf, to make
	 * result buffer contiguous.  Note that if the entire
	 * result won't fit into one mbuf, you're out of luck.
	 * XXX - Should not rely on making the entire reply
	 * contiguous (fix callers instead). -gwr
	 */</span>
#<span class="enscript-reference">if</span>	<span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> ((mbuf_flags(m) &amp; MBUF_PKTHDR) == 0)
		panic(<span class="enscript-string">&quot;krpc_call: received pkt w/o header?&quot;</span>);
#<span class="enscript-reference">endif</span>
	len = mbuf_pkthdr_len(m);
	<span class="enscript-keyword">if</span> (sotype == SOCK_STREAM)
		len -= 4;  <span class="enscript-comment">/* the RPC record marker was read separately */</span>
	<span class="enscript-keyword">if</span> (mbuf_len(m) &lt; len) {
		<span class="enscript-keyword">if</span> ((error = mbuf_pullup(&amp;m, len)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		reply = mbuf_data(m);
	}

	<span class="enscript-comment">/*
	 * Strip RPC header
	 */</span>
	len = <span class="enscript-keyword">sizeof</span>(*reply);
	<span class="enscript-keyword">if</span> (reply-&gt;rp_u.rpu_ok.rp_auth.rp_atype != 0) {
		len += ntohl(reply-&gt;rp_u.rpu_ok.rp_auth.rp_alen);
		len = (len + 3) &amp; ~3; <span class="enscript-comment">/* XXX? */</span>
	}
	mbuf_adj(m, len);

	<span class="enscript-comment">/* result */</span>
	*data = m;
 <span class="enscript-reference">out</span>:
	sock_close(so);
<span class="enscript-reference">out1</span>:
	<span class="enscript-keyword">if</span> (nam) mbuf_freem(nam);
	<span class="enscript-keyword">if</span> (mhead) mbuf_freem(mhead);
	<span class="enscript-keyword">return</span> error;
}
</pre>
<hr />
</body></html>