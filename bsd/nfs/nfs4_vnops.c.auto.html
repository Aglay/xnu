<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nfs4_vnops.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nfs4_vnops.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2006-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * vnode op calls for NFS version 4
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dirent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lockf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/attr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/xattr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/paths.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vfs/vfs_support.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/fifofs/fifo.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/rpcv2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_gss.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsmount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/xdr_subs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsm_subs.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_access_rpc</span>(nfsnode_t np, u_int32_t *access, <span class="enscript-type">int</span> rpcflags, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, status, numops, slot;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> timeval now;
	uint32_t access_result = 0, supported = 0, missing;
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(np);
	<span class="enscript-type">int</span> nfsvers = nmp-&gt;nm_vers;
	uid_t uid;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (0);

	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, ACCESS, GETATTR
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 17 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;access&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_ACCESS);
	nfsm_chain_add_32(error, &amp;nmreq, *access);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, np);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request2(np, NULL, &amp;nmreq, NFSPROC4_COMPOUND,
		vfs_context_thread(ctx), vfs_context_ucred(ctx),
		&amp;si, rpcflags, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_ACCESS);
	nfsm_chain_get_32(error, &amp;nmrep, supported);
	nfsm_chain_get_32(error, &amp;nmrep, access_result);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> ((missing = (*access &amp; ~supported))) {
		<span class="enscript-comment">/* missing support for something(s) we wanted */</span>
		<span class="enscript-keyword">if</span> (missing &amp; NFS_ACCESS_DELETE) {
			<span class="enscript-comment">/*
			 * If the server doesn't report DELETE (possible
			 * on UNIX systems), we'll assume that it is OK
			 * and just let any subsequent delete action fail
			 * if it really isn't deletable.
			 */</span>
			access_result |= NFS_ACCESS_DELETE;
		}
	}
	<span class="enscript-comment">/* &quot;.zfs&quot; subdirectories may erroneously give a denied answer for modify/delete */</span>
	<span class="enscript-keyword">if</span> (nfs_access_dotzfs) {
		vnode_t dvp = NULLVP;
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NISDOTZFSCHILD) <span class="enscript-comment">/* may be able to create/delete snapshot dirs */</span>
			access_result |= (NFS_ACCESS_MODIFY|NFS_ACCESS_EXTEND|NFS_ACCESS_DELETE);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (((dvp = vnode_getparent(NFSTOV(np))) != NULLVP) &amp;&amp; (VTONFS(dvp)-&gt;n_flag &amp; NISDOTZFSCHILD))
			access_result |= NFS_ACCESS_DELETE; <span class="enscript-comment">/* may be able to delete snapshot dirs */</span>
		<span class="enscript-keyword">if</span> (dvp != NULLVP)
			vnode_put(dvp);
	}
	<span class="enscript-comment">/* Some servers report DELETE support but erroneously give a denied answer. */</span>
	<span class="enscript-keyword">if</span> (nfs_access_delete &amp;&amp; (*access &amp; NFS_ACCESS_DELETE) &amp;&amp; !(access_result &amp; NFS_ACCESS_DELETE))
		access_result |= NFS_ACCESS_DELETE;
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsm_chain_loadattr(error, &amp;nmrep, np, nfsvers, &amp;xid);
	nfsmout_if(error);

	uid = kauth_cred_getuid(vfs_context_ucred(ctx));
	slot = nfs_node_access_slot(np, uid, 1);
	np-&gt;n_accessuid[slot] = uid;
	microuptime(&amp;now);
	np-&gt;n_accessstamp[slot] = now.tv_sec;
	np-&gt;n_access[slot] = access_result;

	<span class="enscript-comment">/* pass back the access returned with this request */</span>
	*access = np-&gt;n_access[slot];
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_getattr_rpc</span>(
	nfsnode_t np,
	mount_t mp,
	u_char *fhp,
	size_t fhsize,
	<span class="enscript-type">int</span> flags,
	vfs_context_t ctx,
	<span class="enscript-type">struct</span> nfs_vattr *nvap,
	u_int64_t *xidp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = mp ? VFSTONFS(mp) : NFSTONMP(np);
	<span class="enscript-type">int</span> error = 0, status, nfsvers, numops, rpcflags = 0, acls;
	uint32_t bitmap[NFS_ATTR_BITMAP_LEN];
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	acls = (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_ACL);

	<span class="enscript-keyword">if</span> (np &amp;&amp; (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)) {
		nfs4_default_attrs_for_referral_trigger(VTONFS(np-&gt;n_parent), NULL, 0, nvap, NULL);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (flags &amp; NGA_MONITOR) <span class="enscript-comment">/* vnode monitor requests should be soft */</span>
		rpcflags = R_RECOVER;

	<span class="enscript-keyword">if</span> (flags &amp; NGA_SOFT) <span class="enscript-comment">/* Return ETIMEDOUT if server not responding */</span>
		rpcflags |= R_SOFT;

	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, GETATTR
</span>	numops = 2;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 15 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;getattr&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, fhp, fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	NFS_COPY_ATTRIBUTES(nfs_getattr_bitmap, bitmap);
	<span class="enscript-keyword">if</span> ((flags &amp; NGA_ACL) &amp;&amp; acls)
		NFS_BITMAP_SET(bitmap, NFS_FATTR_ACL);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, bitmap, nmp, np);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request2(np, mp, &amp;nmreq, NFSPROC4_COMPOUND, 
			vfs_context_thread(ctx), vfs_context_ucred(ctx),
			NULL, rpcflags, &amp;nmrep, xidp, &amp;status);

	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsmout_if(error);
	error = nfs4_parsefattr(&amp;nmrep, NULL, nvap, NULL, NULL, NULL);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> ((flags &amp; NGA_ACL) &amp;&amp; acls &amp;&amp; !NFS_BITMAP_ISSET(nvap-&gt;nva_bitmap, NFS_FATTR_ACL)) {
		<span class="enscript-comment">/* we asked for the ACL but didn't get one... assume there isn't one */</span>
		NFS_BITMAP_SET(nvap-&gt;nva_bitmap, NFS_FATTR_ACL);
		nvap-&gt;nva_acl = NULL;
	}
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_readlink_rpc</span>(nfsnode_t np, <span class="enscript-type">char</span> *buf, uint32_t *buflenp, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, status, numops;
	uint32_t len = 0;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);
	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, GETATTR, READLINK
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 16 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;readlink&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, NFS_VER4, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, np);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_READLINK);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request(np, NULL, &amp;nmreq, NFSPROC4_COMPOUND, ctx, &amp;si, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsm_chain_loadattr(error, &amp;nmrep, np, NFS_VER4, &amp;xid);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_READLINK);
	nfsm_chain_get_32(error, &amp;nmrep, len);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (len &gt;= *buflenp) {
		<span class="enscript-keyword">if</span> (np-&gt;n_size &amp;&amp; (np-&gt;n_size &lt; *buflenp))
			len = np-&gt;n_size;
		<span class="enscript-keyword">else</span>
			len = *buflenp - 1;
	}
	nfsm_chain_get_opaque(error, &amp;nmrep, len, buf);
	<span class="enscript-keyword">if</span> (!error)
		*buflenp = len;
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_read_rpc_async</span>(
	nfsnode_t np,
	off_t offset,
	size_t len,
	thread_t thd,
	kauth_cred_t cred,
	<span class="enscript-type">struct</span> nfsreq_cbinfo *cb,
	<span class="enscript-type">struct</span> nfsreq **reqp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, nfsvers, numops;
	nfs_stateid stateid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);

	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);

	<span class="enscript-comment">// PUTFH, READ, GETATTR
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 22 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;read&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_READ);
	nfs_get_stateid(np, thd, cred, &amp;stateid);
	nfsm_chain_add_stateid(error, &amp;nmreq, &amp;stateid);
	nfsm_chain_add_64(error, &amp;nmreq, offset);
	nfsm_chain_add_32(error, &amp;nmreq, len);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, np);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request_async(np, NULL, &amp;nmreq, NFSPROC4_COMPOUND, thd, cred, &amp;si, 0, cb, reqp);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_read_rpc_async_finish</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfsreq *req,
	uio_t uio,
	size_t *lenp,
	<span class="enscript-type">int</span> *eofp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, lockerror, nfsvers, numops, status, eof = 0;
	size_t retlen = 0;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsm_chain nmrep;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		nfs_request_async_cancel(req);
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	nfsvers = nmp-&gt;nm_vers;

	nfsm_chain_null(&amp;nmrep);

	error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);
	<span class="enscript-keyword">if</span> (error == EINPROGRESS) <span class="enscript-comment">/* async request restarted */</span>
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_READ);
	nfsm_chain_get_32(error, &amp;nmrep, eof);
	nfsm_chain_get_32(error, &amp;nmrep, retlen);
	<span class="enscript-keyword">if</span> (!error) {
		*lenp = MIN(retlen, *lenp);
		error = nfsm_chain_get_uio(&amp;nmrep, *lenp, uio);
	}
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsm_chain_loadattr(error, &amp;nmrep, np, nfsvers, &amp;xid);
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	<span class="enscript-keyword">if</span> (eofp) {
		<span class="enscript-keyword">if</span> (!eof &amp;&amp; !retlen)
			eof = 1;
		*eofp = eof;
	}
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_IS_ATTR)
		microuptime(&amp;np-&gt;n_lastio);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_write_rpc_async</span>(
	nfsnode_t np,
	uio_t uio,
	size_t len,
	thread_t thd,
	kauth_cred_t cred,
	<span class="enscript-type">int</span> iomode,
	<span class="enscript-type">struct</span> nfsreq_cbinfo *cb,
	<span class="enscript-type">struct</span> nfsreq **reqp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	mount_t mp;
	<span class="enscript-type">int</span> error = 0, nfsvers, numops;
	nfs_stateid stateid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* for async mounts, don't bother sending sync write requests */</span>
	<span class="enscript-keyword">if</span> ((iomode != NFS_WRITE_UNSTABLE) &amp;&amp; nfs_allow_async &amp;&amp;
	    ((mp = NFSTOMP(np))) &amp;&amp; (vfs_flags(mp) &amp; MNT_ASYNC))
		iomode = NFS_WRITE_UNSTABLE;

	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);

	<span class="enscript-comment">// PUTFH, WRITE, GETATTR
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 25 * NFSX_UNSIGNED + len);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;write&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_WRITE);
	nfs_get_stateid(np, thd, cred, &amp;stateid);
	nfsm_chain_add_stateid(error, &amp;nmreq, &amp;stateid);
	nfsm_chain_add_64(error, &amp;nmreq, uio_offset(uio));
	nfsm_chain_add_32(error, &amp;nmreq, iomode);
	nfsm_chain_add_32(error, &amp;nmreq, len);
	<span class="enscript-keyword">if</span> (!error)
		error = nfsm_chain_add_uio(&amp;nmreq, uio, len);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, np);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);

	error = nfs_request_async(np, NULL, &amp;nmreq, NFSPROC4_COMPOUND, thd, cred, &amp;si, 0, cb, reqp);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_write_rpc_async_finish</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfsreq *req,
	<span class="enscript-type">int</span> *iomodep,
	size_t *rlenp,
	uint64_t *wverfp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, nfsvers, numops, status;
	<span class="enscript-type">int</span> committed = NFS_WRITE_FILESYNC;
	size_t rlen = 0;
	u_int64_t xid, wverf;
	mount_t mp;
	<span class="enscript-type">struct</span> nfsm_chain nmrep;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		nfs_request_async_cancel(req);
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	nfsvers = nmp-&gt;nm_vers;

	nfsm_chain_null(&amp;nmrep);

	error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);
	<span class="enscript-keyword">if</span> (error == EINPROGRESS) <span class="enscript-comment">/* async request restarted */</span>
		<span class="enscript-keyword">return</span> (error);
	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		error = ENXIO;
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_WRITE);
	nfsm_chain_get_32(error, &amp;nmrep, rlen);
	nfsmout_if(error);
	*rlenp = rlen;
	<span class="enscript-keyword">if</span> (rlen &lt;= 0)
		error = NFSERR_IO;
	nfsm_chain_get_32(error, &amp;nmrep, committed);
	nfsm_chain_get_64(error, &amp;nmrep, wverf);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (wverfp)
		*wverfp = wverf;
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_state &amp; NFSSTA_HASWRITEVERF)) {
		nmp-&gt;nm_verf = wverf;
		nmp-&gt;nm_state |= NFSSTA_HASWRITEVERF;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nmp-&gt;nm_verf != wverf) {
		nmp-&gt;nm_verf = wverf;
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsm_chain_loadattr(error, &amp;nmrep, np, nfsvers, &amp;xid);
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">if</span> ((committed != NFS_WRITE_FILESYNC) &amp;&amp; nfs_allow_async &amp;&amp;
	    ((mp = NFSTOMP(np))) &amp;&amp; (vfs_flags(mp) &amp; MNT_ASYNC))
		committed = NFS_WRITE_FILESYNC;
	*iomodep = committed;
	<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_IS_ATTR)
		microuptime(&amp;np-&gt;n_lastio);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_remove_rpc</span>(
	nfsnode_t dnp,
	<span class="enscript-type">char</span> *name,
	<span class="enscript-type">int</span> namelen,
	thread_t thd,
	kauth_cred_t cred)
{
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, remove_error = 0, status;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> nfsvers, numops;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(dnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-keyword">if</span> (dnp-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);
	NFSREQ_SECINFO_SET(&amp;si, dnp, NULL, 0, NULL, 0);
<span class="enscript-reference">restart</span>:
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, REMOVE, GETATTR
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 17 * NFSX_UNSIGNED + namelen);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;remove&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, dnp-&gt;n_fhp, dnp-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_REMOVE);
	nfsm_chain_add_name(error, &amp;nmreq, name, namelen, nmp);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, dnp);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);

	error = nfs_request2(dnp, NULL, &amp;nmreq, NFSPROC4_COMPOUND, thd, cred, &amp;si, 0, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_REMOVE);
	remove_error = error;
	nfsm_chain_check_change_info(error, &amp;nmrep, dnp);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsm_chain_loadattr(error, &amp;nmrep, dnp, nfsvers, &amp;xid);
	<span class="enscript-keyword">if</span> (error &amp;&amp; !lockerror)
		NATTRINVALIDATE(dnp);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);

	<span class="enscript-keyword">if</span> (!lockerror) {
		dnp-&gt;n_flag |= NMODIFIED;
		nfs_node_unlock(dnp);
	}
	<span class="enscript-keyword">if</span> (error == NFSERR_GRACE) {
		tsleep(&amp;nmp-&gt;nm_state, (PZERO-1), <span class="enscript-string">&quot;nfsgrace&quot;</span>, 2*hz);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}

	<span class="enscript-keyword">return</span> (remove_error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_rename_rpc</span>(
	nfsnode_t fdnp,
	<span class="enscript-type">char</span> *fnameptr,
	<span class="enscript-type">int</span> fnamelen,
	nfsnode_t tdnp,
	<span class="enscript-type">char</span> *tnameptr,
	<span class="enscript-type">int</span> tnamelen,
	vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, status, nfsvers, numops;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	u_int64_t xid, savedxid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(fdnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-keyword">if</span> (fdnp-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (tdnp-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);

	NFSREQ_SECINFO_SET(&amp;si, fdnp, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH(FROM), SAVEFH, PUTFH(TO), RENAME, GETATTR(TO), RESTOREFH, GETATTR(FROM)
</span>	numops = 7;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 30 * NFSX_UNSIGNED + fnamelen + tnamelen);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;rename&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, fdnp-&gt;n_fhp, fdnp-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_SAVEFH);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, tdnp-&gt;n_fhp, tdnp-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_RENAME);
	nfsm_chain_add_name(error, &amp;nmreq, fnameptr, fnamelen, nmp);
	nfsm_chain_add_name(error, &amp;nmreq, tnameptr, tnamelen, nmp);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, tdnp);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_RESTOREFH);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, fdnp);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);

	error = nfs_request(fdnp, NULL, &amp;nmreq, NFSPROC4_COMPOUND, ctx, &amp;si, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock2(fdnp, tdnp)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_SAVEFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_RENAME);
	nfsm_chain_check_change_info(error, &amp;nmrep, fdnp);
	nfsm_chain_check_change_info(error, &amp;nmrep, tdnp);
	<span class="enscript-comment">/* directory attributes: if we don't get them, make sure to invalidate */</span>
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	savedxid = xid;
	nfsm_chain_loadattr(error, &amp;nmrep, tdnp, nfsvers, &amp;xid);
	<span class="enscript-keyword">if</span> (error &amp;&amp; !lockerror)
		NATTRINVALIDATE(tdnp);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_RESTOREFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	xid = savedxid;
	nfsm_chain_loadattr(error, &amp;nmrep, fdnp, nfsvers, &amp;xid);
	<span class="enscript-keyword">if</span> (error &amp;&amp; !lockerror)
		NATTRINVALIDATE(fdnp);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">if</span> (!lockerror) {
		fdnp-&gt;n_flag |= NMODIFIED;
		tdnp-&gt;n_flag |= NMODIFIED;
		nfs_node_unlock2(fdnp, tdnp);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS V4 readdir RPC.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_readdir_rpc</span>(nfsnode_t dnp, <span class="enscript-type">struct</span> nfsbuf *bp, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, lockerror, nfsvers, namedattr, rdirplus, bigcookies, numops;
	<span class="enscript-type">int</span> i, status, more_entries = 1, eof, bp_dropped = 0;
	uint32_t nmreaddirsize, nmrsize;
	uint32_t namlen, skiplen, fhlen, xlen, attrlen, reclen, space_free, space_needed;
	uint64_t cookie, lastcookie, xid, savedxid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep, nmrepsave;
	fhandle_t fh;
	<span class="enscript-type">struct</span> nfs_vattr nvattr, *nvattrp;
	<span class="enscript-type">struct</span> nfs_dir_buf_header *ndbhp;
	<span class="enscript-type">struct</span> direntry *dp;
	<span class="enscript-type">char</span> *padstart, padlen;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *tag;
	uint32_t entry_attrs[NFS_ATTR_BITMAP_LEN];
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(dnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	nmreaddirsize = nmp-&gt;nm_readdirsize;
	nmrsize = nmp-&gt;nm_rsize;
	bigcookies = nmp-&gt;nm_state &amp; NFSSTA_BIGCOOKIES;
	namedattr = (dnp-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_IS_ATTR) ? 1 : 0;
	rdirplus = (NMFLAG(nmp, RDIRPLUS) || namedattr) ? 1 : 0;
	<span class="enscript-keyword">if</span> (dnp-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);
	NFSREQ_SECINFO_SET(&amp;si, dnp, NULL, 0, NULL, 0);

	<span class="enscript-comment">/*
	 * Set up attribute request for entries.
	 * For READDIRPLUS functionality, get everything.
	 * Otherwise, just get what we need for struct direntry.
	 */</span>
	<span class="enscript-keyword">if</span> (rdirplus) {
		tag = <span class="enscript-string">&quot;readdirplus&quot;</span>;
		NFS_COPY_ATTRIBUTES(nfs_getattr_bitmap, entry_attrs);
		NFS_BITMAP_SET(entry_attrs, NFS_FATTR_FILEHANDLE);
	} <span class="enscript-keyword">else</span> {
		tag = <span class="enscript-string">&quot;readdir&quot;</span>;
		NFS_CLEAR_ATTRIBUTES(entry_attrs);
		NFS_BITMAP_SET(entry_attrs, NFS_FATTR_TYPE);
		NFS_BITMAP_SET(entry_attrs, NFS_FATTR_FILEID);
		NFS_BITMAP_SET(entry_attrs, NFS_FATTR_MOUNTED_ON_FILEID);
	}
	NFS_BITMAP_SET(entry_attrs, NFS_FATTR_RDATTR_ERROR);

	<span class="enscript-comment">/* lock to protect access to cookie verifier */</span>
	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
		<span class="enscript-keyword">return</span> (lockerror);

	<span class="enscript-comment">/* determine cookie to use, and move dp to the right offset */</span>
	ndbhp = (<span class="enscript-type">struct</span> nfs_dir_buf_header*)bp-&gt;nb_data;
	dp = NFS_DIR_BUF_FIRST_DIRENTRY(bp);
	<span class="enscript-keyword">if</span> (ndbhp-&gt;ndbh_count) {
		<span class="enscript-keyword">for</span> (i=0; i &lt; ndbhp-&gt;ndbh_count-1; i++)
			dp = NFS_DIRENTRY_NEXT(dp);
		cookie = dp-&gt;d_seekoff;
		dp = NFS_DIRENTRY_NEXT(dp);
	} <span class="enscript-keyword">else</span> {
		cookie = bp-&gt;nb_lblkno;
		<span class="enscript-comment">/* increment with every buffer read */</span>
		OSAddAtomic64(1, &amp;nfsstats.readdir_bios);
	}
	lastcookie = cookie;

	<span class="enscript-comment">/*
	 * The NFS client is responsible for the &quot;.&quot; and &quot;..&quot; entries in the
	 * directory.  So, we put them at the start of the first buffer.
	 * Don't bother for attribute directories.
	 */</span>
	<span class="enscript-keyword">if</span> (((bp-&gt;nb_lblkno == 0) &amp;&amp; (ndbhp-&gt;ndbh_count == 0)) &amp;&amp;
	    !(dnp-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_IS_ATTR)) {
		fh.fh_len = 0;
		fhlen = rdirplus ? fh.fh_len + 1 : 0;
		xlen = rdirplus ? (fhlen + <span class="enscript-keyword">sizeof</span>(time_t)) : 0;
		<span class="enscript-comment">/* &quot;.&quot; */</span>
		namlen = 1;
		reclen = NFS_DIRENTRY_LEN(namlen + xlen);
		<span class="enscript-keyword">if</span> (xlen)
			bzero(&amp;dp-&gt;d_name[namlen+1], xlen);
		dp-&gt;d_namlen = namlen;
		strlcpy(dp-&gt;d_name, <span class="enscript-string">&quot;.&quot;</span>, namlen+1);
		dp-&gt;d_fileno = dnp-&gt;n_vattr.nva_fileid;
		dp-&gt;d_type = DT_DIR;
		dp-&gt;d_reclen = reclen;
		dp-&gt;d_seekoff = 1;
		padstart = dp-&gt;d_name + dp-&gt;d_namlen + 1 + xlen;
		dp = NFS_DIRENTRY_NEXT(dp);
		padlen = (<span class="enscript-type">char</span>*)dp - padstart;
		<span class="enscript-keyword">if</span> (padlen &gt; 0)
			bzero(padstart, padlen);
		<span class="enscript-keyword">if</span> (rdirplus) <span class="enscript-comment">/* zero out attributes */</span>
			bzero(NFS_DIR_BUF_NVATTR(bp, 0), <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_vattr));

		<span class="enscript-comment">/* &quot;..&quot; */</span>
		namlen = 2;
		reclen = NFS_DIRENTRY_LEN(namlen + xlen);
		<span class="enscript-keyword">if</span> (xlen)
			bzero(&amp;dp-&gt;d_name[namlen+1], xlen);
		dp-&gt;d_namlen = namlen;
		strlcpy(dp-&gt;d_name, <span class="enscript-string">&quot;..&quot;</span>, namlen+1);
		<span class="enscript-keyword">if</span> (dnp-&gt;n_parent)
			dp-&gt;d_fileno = VTONFS(dnp-&gt;n_parent)-&gt;n_vattr.nva_fileid;
		<span class="enscript-keyword">else</span>
			dp-&gt;d_fileno = dnp-&gt;n_vattr.nva_fileid;
		dp-&gt;d_type = DT_DIR;
		dp-&gt;d_reclen = reclen;
		dp-&gt;d_seekoff = 2;
		padstart = dp-&gt;d_name + dp-&gt;d_namlen + 1 + xlen;
		dp = NFS_DIRENTRY_NEXT(dp);
		padlen = (<span class="enscript-type">char</span>*)dp - padstart;
		<span class="enscript-keyword">if</span> (padlen &gt; 0)
			bzero(padstart, padlen);
		<span class="enscript-keyword">if</span> (rdirplus) <span class="enscript-comment">/* zero out attributes */</span>
			bzero(NFS_DIR_BUF_NVATTR(bp, 1), <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_vattr));

		ndbhp-&gt;ndbh_entry_end = (<span class="enscript-type">char</span>*)dp - bp-&gt;nb_data;
		ndbhp-&gt;ndbh_count = 2;
	}

	<span class="enscript-comment">/*
	 * Loop around doing readdir(plus) RPCs of size nm_readdirsize until
	 * the buffer is full (or we hit EOF).  Then put the remainder of the
	 * results in the next buffer(s).
	 */</span>
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);
	<span class="enscript-keyword">while</span> (nfs_dir_buf_freespace(bp, rdirplus) &amp;&amp; !(ndbhp-&gt;ndbh_flags &amp; NDB_FULL)) {

		<span class="enscript-comment">// PUTFH, GETATTR, READDIR
</span>		numops = 3;
		nfsm_chain_build_alloc_init(error, &amp;nmreq, 26 * NFSX_UNSIGNED);
		nfsm_chain_add_compound_header(error, &amp;nmreq, tag, nmp-&gt;nm_minor_vers, numops);
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
		nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, dnp-&gt;n_fhp, dnp-&gt;n_fhsize);
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
		nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, dnp);
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_READDIR);
		nfsm_chain_add_64(error, &amp;nmreq, (cookie &lt;= 2) ? 0 : cookie);
		nfsm_chain_add_64(error, &amp;nmreq, dnp-&gt;n_cookieverf);
		nfsm_chain_add_32(error, &amp;nmreq, nmreaddirsize);
		nfsm_chain_add_32(error, &amp;nmreq, nmrsize);
		nfsm_chain_add_bitmap_supported(error, &amp;nmreq, entry_attrs, nmp, dnp);
		nfsm_chain_build_done(error, &amp;nmreq);
		nfsm_assert(error, (numops == 0), EPROTO);
		nfs_node_unlock(dnp);
		nfsmout_if(error);
		error = nfs_request(dnp, NULL, &amp;nmreq, NFSPROC4_COMPOUND, ctx, &amp;si, &amp;nmrep, &amp;xid, &amp;status);

		<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
			error = lockerror;

		savedxid = xid;
		nfsm_chain_skip_tag(error, &amp;nmrep);
		nfsm_chain_get_32(error, &amp;nmrep, numops);
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
		nfsm_chain_loadattr(error, &amp;nmrep, dnp, nfsvers, &amp;xid);
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_READDIR);
		nfsm_chain_get_64(error, &amp;nmrep, dnp-&gt;n_cookieverf);
		nfsm_chain_get_32(error, &amp;nmrep, more_entries);

		<span class="enscript-keyword">if</span> (!lockerror) {
			nfs_node_unlock(dnp);
			lockerror = ENOENT;
		}
		nfsmout_if(error);

		<span class="enscript-keyword">if</span> (rdirplus)
			microuptime(&amp;now);

		<span class="enscript-comment">/* loop through the entries packing them into the buffer */</span>
		<span class="enscript-keyword">while</span> (more_entries) {
			<span class="enscript-comment">/* Entry: COOKIE, NAME, FATTR */</span>
			nfsm_chain_get_64(error, &amp;nmrep, cookie);
			nfsm_chain_get_32(error, &amp;nmrep, namlen);
			nfsmout_if(error);
			<span class="enscript-keyword">if</span> (!bigcookies &amp;&amp; (cookie &gt;&gt; 32) &amp;&amp; (nmp == NFSTONMP(dnp))) {
				<span class="enscript-comment">/* we've got a big cookie, make sure flag is set */</span>
				lck_mtx_lock(&amp;nmp-&gt;nm_lock);
				nmp-&gt;nm_state |= NFSSTA_BIGCOOKIES;
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
				bigcookies = 1;
			}
			<span class="enscript-comment">/* just truncate names that don't fit in direntry.d_name */</span>
			<span class="enscript-keyword">if</span> (namlen &lt;= 0) {
				error = EBADRPC;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}
			<span class="enscript-keyword">if</span> (namlen &gt; (<span class="enscript-keyword">sizeof</span>(dp-&gt;d_name)-1)) {
				skiplen = namlen - <span class="enscript-keyword">sizeof</span>(dp-&gt;d_name) + 1;
				namlen = <span class="enscript-keyword">sizeof</span>(dp-&gt;d_name) - 1;
			} <span class="enscript-keyword">else</span> {
				skiplen = 0;
			}
			<span class="enscript-comment">/* guess that fh size will be same as parent */</span>
			fhlen = rdirplus ? (1 + dnp-&gt;n_fhsize) : 0;
			xlen = rdirplus ? (fhlen + <span class="enscript-keyword">sizeof</span>(time_t)) : 0;
			attrlen = rdirplus ? <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_vattr) : 0;
			reclen = NFS_DIRENTRY_LEN(namlen + xlen);
			space_needed = reclen + attrlen;
			space_free = nfs_dir_buf_freespace(bp, rdirplus);
			<span class="enscript-keyword">if</span> (space_needed &gt; space_free) {
				<span class="enscript-comment">/*
				 * We still have entries to pack, but we've
				 * run out of room in the current buffer.
				 * So we need to move to the next buffer.
				 * The block# for the next buffer is the
				 * last cookie in the current buffer.
				 */</span>
<span class="enscript-reference">nextbuffer</span>:
				ndbhp-&gt;ndbh_flags |= NDB_FULL;
				nfs_buf_release(bp, 0);
				bp_dropped = 1;
				bp = NULL;
				error = nfs_buf_get(dnp, lastcookie, NFS_DIRBLKSIZ, vfs_context_thread(ctx), NBLK_READ, &amp;bp);
				nfsmout_if(error);
				<span class="enscript-comment">/* initialize buffer */</span>
				ndbhp = (<span class="enscript-type">struct</span> nfs_dir_buf_header*)bp-&gt;nb_data;
				ndbhp-&gt;ndbh_flags = 0;
				ndbhp-&gt;ndbh_count = 0;
				ndbhp-&gt;ndbh_entry_end = <span class="enscript-keyword">sizeof</span>(*ndbhp);
				ndbhp-&gt;ndbh_ncgen = dnp-&gt;n_ncgen;
				space_free = nfs_dir_buf_freespace(bp, rdirplus);
				dp = NFS_DIR_BUF_FIRST_DIRENTRY(bp);
				<span class="enscript-comment">/* increment with every buffer read */</span>
				OSAddAtomic64(1, &amp;nfsstats.readdir_bios);
			}
			nmrepsave = nmrep;
			dp-&gt;d_fileno = cookie; <span class="enscript-comment">/* placeholder */</span>
			dp-&gt;d_seekoff = cookie;
			dp-&gt;d_namlen = namlen;
			dp-&gt;d_reclen = reclen;
			dp-&gt;d_type = DT_UNKNOWN;
			nfsm_chain_get_opaque(error, &amp;nmrep, namlen, dp-&gt;d_name);
			nfsmout_if(error);
			dp-&gt;d_name[namlen] = <span class="enscript-string">'\0'</span>;
			<span class="enscript-keyword">if</span> (skiplen)
				nfsm_chain_adv(error, &amp;nmrep,
					nfsm_rndup(namlen + skiplen) - nfsm_rndup(namlen));
			nfsmout_if(error);
			nvattrp = rdirplus ? NFS_DIR_BUF_NVATTR(bp, ndbhp-&gt;ndbh_count) : &amp;nvattr;
			error = nfs4_parsefattr(&amp;nmrep, NULL, nvattrp, &amp;fh, NULL, NULL);
			<span class="enscript-keyword">if</span> (!error &amp;&amp; NFS_BITMAP_ISSET(nvattrp-&gt;nva_bitmap, NFS_FATTR_ACL)) {
				<span class="enscript-comment">/* we do NOT want ACLs returned to us here */</span>
				NFS_BITMAP_CLR(nvattrp-&gt;nva_bitmap, NFS_FATTR_ACL);
				<span class="enscript-keyword">if</span> (nvattrp-&gt;nva_acl) {
					kauth_acl_free(nvattrp-&gt;nva_acl);
					nvattrp-&gt;nva_acl = NULL;
				}
			}
			<span class="enscript-keyword">if</span> (error &amp;&amp; NFS_BITMAP_ISSET(nvattrp-&gt;nva_bitmap, NFS_FATTR_RDATTR_ERROR)) {
				<span class="enscript-comment">/* OK, we may not have gotten all of the attributes but we will use what we can. */</span>
				<span class="enscript-keyword">if</span> ((error == NFSERR_MOVED) || (error == NFSERR_INVAL)) {
					<span class="enscript-comment">/* set this up to look like a referral trigger */</span>
					nfs4_default_attrs_for_referral_trigger(dnp, dp-&gt;d_name, namlen, nvattrp, &amp;fh);
				}
				error = 0;
			}
			<span class="enscript-comment">/* check for more entries after this one */</span>
			nfsm_chain_get_32(error, &amp;nmrep, more_entries);
			nfsmout_if(error);

			<span class="enscript-comment">/* Skip any &quot;.&quot; and &quot;..&quot; entries returned from server. */</span>
			<span class="enscript-comment">/* Also skip any bothersome named attribute entries. */</span>
			<span class="enscript-keyword">if</span> (((dp-&gt;d_name[0] == <span class="enscript-string">'.'</span>) &amp;&amp; ((namlen == 1) || ((namlen == 2) &amp;&amp; (dp-&gt;d_name[1] == <span class="enscript-string">'.'</span>)))) ||
			    (namedattr &amp;&amp; (namlen == 11) &amp;&amp; (!strcmp(dp-&gt;d_name, <span class="enscript-string">&quot;SUNWattr_ro&quot;</span>) || !strcmp(dp-&gt;d_name, <span class="enscript-string">&quot;SUNWattr_rw&quot;</span>)))) {
				lastcookie = cookie;
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nvattrp-&gt;nva_bitmap, NFS_FATTR_TYPE))
				dp-&gt;d_type = IFTODT(VTTOIF(nvattrp-&gt;nva_type));
			<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nvattrp-&gt;nva_bitmap, NFS_FATTR_FILEID))
				dp-&gt;d_fileno = nvattrp-&gt;nva_fileid;
			<span class="enscript-keyword">if</span> (rdirplus) {
				<span class="enscript-comment">/* fileid is already in d_fileno, so stash xid in attrs */</span>
				nvattrp-&gt;nva_fileid = savedxid;
				<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nvattrp-&gt;nva_bitmap, NFS_FATTR_FILEHANDLE)) {
					fhlen = fh.fh_len + 1;
					xlen = fhlen + <span class="enscript-keyword">sizeof</span>(time_t);
					reclen = NFS_DIRENTRY_LEN(namlen + xlen);
					space_needed = reclen + attrlen;
					<span class="enscript-keyword">if</span> (space_needed &gt; space_free) {
						<span class="enscript-comment">/* didn't actually have the room... move on to next buffer */</span>
						nmrep = nmrepsave;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">nextbuffer</span>;
					}
					<span class="enscript-comment">/* pack the file handle into the record */</span>
					dp-&gt;d_name[dp-&gt;d_namlen+1] = fh.fh_len;
					bcopy(fh.fh_data, &amp;dp-&gt;d_name[dp-&gt;d_namlen+2], fh.fh_len);
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* mark the file handle invalid */</span>
					fh.fh_len = 0;
					fhlen = fh.fh_len + 1;
					xlen = fhlen + <span class="enscript-keyword">sizeof</span>(time_t);
					reclen = NFS_DIRENTRY_LEN(namlen + xlen);
					bzero(&amp;dp-&gt;d_name[dp-&gt;d_namlen+1], fhlen);
				}
				*(time_t*)(&amp;dp-&gt;d_name[dp-&gt;d_namlen+1+fhlen]) = now.tv_sec;
				dp-&gt;d_reclen = reclen;
			}
			padstart = dp-&gt;d_name + dp-&gt;d_namlen + 1 + xlen;
			ndbhp-&gt;ndbh_count++;
			lastcookie = cookie;

			<span class="enscript-comment">/* advance to next direntry in buffer */</span>
			dp = NFS_DIRENTRY_NEXT(dp);
			ndbhp-&gt;ndbh_entry_end = (<span class="enscript-type">char</span>*)dp - bp-&gt;nb_data;
			<span class="enscript-comment">/* zero out the pad bytes */</span>
			padlen = (<span class="enscript-type">char</span>*)dp - padstart;
			<span class="enscript-keyword">if</span> (padlen &gt; 0)
				bzero(padstart, padlen);
		}
		<span class="enscript-comment">/* Finally, get the eof boolean */</span>
		nfsm_chain_get_32(error, &amp;nmrep, eof);
		nfsmout_if(error);
		<span class="enscript-keyword">if</span> (eof) {
			ndbhp-&gt;ndbh_flags |= (NDB_FULL|NDB_EOF);
			nfs_node_lock_force(dnp);
			dnp-&gt;n_eofcookie = lastcookie;
			nfs_node_unlock(dnp);
		} <span class="enscript-keyword">else</span> {
			more_entries = 1;
		}
		<span class="enscript-keyword">if</span> (bp_dropped) {
			nfs_buf_release(bp, 0);
			bp = NULL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
			error = lockerror;
		nfsmout_if(error);
		nfsm_chain_cleanup(&amp;nmrep);
		nfsm_chain_null(&amp;nmreq);
	}
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (bp_dropped &amp;&amp; bp)
		nfs_buf_release(bp, 0);
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(dnp);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (bp_dropped ? NFSERR_DIRBUFDROPPED : error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_lookup_rpc_async</span>(
	nfsnode_t dnp,
	<span class="enscript-type">char</span> *name,
	<span class="enscript-type">int</span> namelen,
	vfs_context_t ctx,
	<span class="enscript-type">struct</span> nfsreq **reqp)
{
	<span class="enscript-type">int</span> error = 0, isdotdot = 0, nfsvers, numops;
	<span class="enscript-type">struct</span> nfsm_chain nmreq;
	uint32_t bitmap[NFS_ATTR_BITMAP_LEN];
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(dnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-keyword">if</span> (dnp-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> ((name[0] == <span class="enscript-string">'.'</span>) &amp;&amp; (name[1] == <span class="enscript-string">'.'</span>) &amp;&amp; (namelen == 2)) {
		isdotdot = 1;
		NFSREQ_SECINFO_SET(&amp;si, dnp, NULL, 0, NULL, 0);
	} <span class="enscript-keyword">else</span> {
		NFSREQ_SECINFO_SET(&amp;si, dnp, dnp-&gt;n_fhp, dnp-&gt;n_fhsize, name, namelen);
	}

	nfsm_chain_null(&amp;nmreq);

	<span class="enscript-comment">// PUTFH, GETATTR, LOOKUP(P), GETFH, GETATTR (FH)
</span>	numops = 5;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 20 * NFSX_UNSIGNED + namelen);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;lookup&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, dnp-&gt;n_fhp, dnp-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, dnp);
	numops--;
	<span class="enscript-keyword">if</span> (isdotdot) {
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_LOOKUPP);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_LOOKUP);
		nfsm_chain_add_name(error, &amp;nmreq, name, namelen, nmp);
	}
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETFH);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	NFS_COPY_ATTRIBUTES(nfs_getattr_bitmap, bitmap);
	<span class="enscript-comment">/* some &quot;.zfs&quot; directories can't handle being asked for some attributes */</span>
	<span class="enscript-keyword">if</span> ((dnp-&gt;n_flag &amp; NISDOTZFS) &amp;&amp; !isdotdot)
		NFS_BITMAP_CLR(bitmap, NFS_FATTR_NAMED_ATTR);
	<span class="enscript-keyword">if</span> ((dnp-&gt;n_flag &amp; NISDOTZFSCHILD) &amp;&amp; isdotdot)
		NFS_BITMAP_CLR(bitmap, NFS_FATTR_NAMED_ATTR);
	<span class="enscript-keyword">if</span> (((namelen == 4) &amp;&amp; (name[0] == <span class="enscript-string">'.'</span>) &amp;&amp; (name[1] == <span class="enscript-string">'z'</span>) &amp;&amp; (name[2] == <span class="enscript-string">'f'</span>) &amp;&amp; (name[3] == <span class="enscript-string">'s'</span>)))
		NFS_BITMAP_CLR(bitmap, NFS_FATTR_NAMED_ATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, bitmap, nmp, NULL);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request_async(dnp, NULL, &amp;nmreq, NFSPROC4_COMPOUND,
			vfs_context_thread(ctx), vfs_context_ucred(ctx), &amp;si, 0, NULL, reqp);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_lookup_rpc_async_finish</span>(
	nfsnode_t dnp,
	<span class="enscript-type">char</span> *name,
	<span class="enscript-type">int</span> namelen,
	vfs_context_t ctx,
	<span class="enscript-type">struct</span> nfsreq *req,
	u_int64_t *xidp,
	fhandle_t *fhp,
	<span class="enscript-type">struct</span> nfs_vattr *nvap)
{
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, status, nfsvers, numops, isdotdot = 0;
	uint32_t op = NFS_OP_LOOKUP;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfsm_chain nmrep;

	nmp = NFSTONMP(dnp);
	<span class="enscript-keyword">if</span> (nmp == NULL)
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-keyword">if</span> ((name[0] == <span class="enscript-string">'.'</span>) &amp;&amp; (name[1] == <span class="enscript-string">'.'</span>) &amp;&amp; (namelen == 2))
		isdotdot = 1;

	nfsm_chain_null(&amp;nmrep);

	error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	<span class="enscript-keyword">if</span> (xidp)
		*xidp = xid;
	nfsm_chain_loadattr(error, &amp;nmrep, dnp, nfsvers, &amp;xid);

	nfsm_chain_op_check(error, &amp;nmrep, (isdotdot ? NFS_OP_LOOKUPP : NFS_OP_LOOKUP));
	nfsmout_if(error || !fhp || !nvap);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETFH);
	nfsm_chain_get_32(error, &amp;nmrep, fhp-&gt;fh_len);
	nfsm_chain_get_opaque(error, &amp;nmrep, fhp-&gt;fh_len, fhp-&gt;fh_data);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	<span class="enscript-keyword">if</span> ((error == NFSERR_MOVED) || (error == NFSERR_INVAL)) {
		<span class="enscript-comment">/* set this up to look like a referral trigger */</span>
		nfs4_default_attrs_for_referral_trigger(dnp, name, namelen, nvap, fhp);
		error = 0;
	} <span class="enscript-keyword">else</span> {
		nfsmout_if(error);
		error = nfs4_parsefattr(&amp;nmrep, NULL, nvap, NULL, NULL, NULL);
	}
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(dnp);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (op == NFS_OP_LOOKUP) &amp;&amp; (nmp-&gt;nm_state &amp; NFSSTA_NEEDSECINFO)) {
		<span class="enscript-comment">/* We still need to get SECINFO to set default for mount. */</span>
		<span class="enscript-comment">/* Do so for the first LOOKUP that returns successfully. */</span>
		<span class="enscript-type">struct</span> nfs_sec sec;

		sec.count = NX_MAX_SEC_FLAVORS;
		error = nfs4_secinfo_rpc(nmp, &amp;req-&gt;r_secinfo, vfs_context_ucred(ctx), sec.flavors, &amp;sec.count);
		<span class="enscript-comment">/* [sigh] some implementations return &quot;illegal&quot; error for unsupported ops */</span>
		<span class="enscript-keyword">if</span> (error == NFSERR_OP_ILLEGAL)
			error = 0;
		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-comment">/* set our default security flavor to the first in the list */</span>
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">if</span> (sec.count)
				nmp-&gt;nm_auth = sec.flavors[0];
			nmp-&gt;nm_state &amp;= ~NFSSTA_NEEDSECINFO;
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		}
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_commit_rpc</span>(
	nfsnode_t np,
	uint64_t offset,
	uint64_t count,
	kauth_cred_t cred,
	uint64_t wverf)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, lockerror, status, nfsvers, numops;
	u_int64_t xid, newwverf;
	uint32_t count32;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(np);
	FSDBG(521, np, offset, count, nmp ? nmp-&gt;nm_state : 0);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_state &amp; NFSSTA_HASWRITEVERF))
		<span class="enscript-keyword">return</span> (0);
	nfsvers = nmp-&gt;nm_vers;

	<span class="enscript-keyword">if</span> (count &gt; UINT32_MAX)
		count32 = 0;
	<span class="enscript-keyword">else</span>
		count32 = count;

	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, COMMIT, GETATTR
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 19 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;commit&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_COMMIT);
	nfsm_chain_add_64(error, &amp;nmreq, offset);
	nfsm_chain_add_32(error, &amp;nmreq, count32);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, np);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request2(np, NULL, &amp;nmreq, NFSPROC4_COMPOUND,
			current_thread(), cred, &amp;si, 0, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_COMMIT);
	nfsm_chain_get_64(error, &amp;nmrep, newwverf);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsm_chain_loadattr(error, &amp;nmrep, np, nfsvers, &amp;xid);
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfsmout_if(error);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_verf != newwverf)
		nmp-&gt;nm_verf = newwverf;
	<span class="enscript-keyword">if</span> (wverf != newwverf)
		error = NFSERR_STALEWRITEVERF;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_pathconf_rpc</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_fsattr *nfsap,
	vfs_context_t ctx)
{
	u_int64_t xid;
	<span class="enscript-type">int</span> error = 0, lockerror, status, nfsvers, numops;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(np);
	uint32_t bitmap[NFS_ATTR_BITMAP_LEN];
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);

	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	NVATTR_INIT(&amp;nvattr);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">/* NFSv4: fetch &quot;pathconf&quot; info for this node */</span>
	<span class="enscript-comment">// PUTFH, GETATTR
</span>	numops = 2;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 16 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;pathconf&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	NFS_COPY_ATTRIBUTES(nfs_getattr_bitmap, bitmap);
	NFS_BITMAP_SET(bitmap, NFS_FATTR_MAXLINK);
	NFS_BITMAP_SET(bitmap, NFS_FATTR_MAXNAME);
	NFS_BITMAP_SET(bitmap, NFS_FATTR_NO_TRUNC);
	NFS_BITMAP_SET(bitmap, NFS_FATTR_CHOWN_RESTRICTED);
	NFS_BITMAP_SET(bitmap, NFS_FATTR_CASE_INSENSITIVE);
	NFS_BITMAP_SET(bitmap, NFS_FATTR_CASE_PRESERVING);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, bitmap, nmp, np);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request(np, NULL, &amp;nmreq, NFSPROC4_COMPOUND, ctx, &amp;si, &amp;nmrep, &amp;xid, &amp;status);

	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsmout_if(error);
	error = nfs4_parsefattr(&amp;nmrep, nfsap, &amp;nvattr, NULL, NULL, NULL);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	<span class="enscript-keyword">if</span> (!error)
		nfs_loadattrcache(np, &amp;nvattr, &amp;xid, 0);
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
<span class="enscript-reference">nfsmout</span>:
	NVATTR_CLEANUP(&amp;nvattr);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_vnop_getattr</span>(
	<span class="enscript-type">struct</span> vnop_getattr_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		struct vnode_attr *a_vap;
		vfs_context_t a_context;
	} */</span> *ap)
{
	<span class="enscript-type">struct</span> vnode_attr *vap = ap-&gt;a_vap;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_vattr nva;
	<span class="enscript-type">int</span> error, acls, ngaflags;

	nmp = VTONMP(ap-&gt;a_vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	acls = (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_ACL);

	ngaflags = NGA_CACHED;
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_acl) &amp;&amp; acls)
		ngaflags |= NGA_ACL;
	error = nfs_getattr(VTONFS(ap-&gt;a_vp), &amp;nva, ap-&gt;a_context, ngaflags);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/* copy what we have in nva to *a_vap */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_rdev) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_RAWDEV)) {
		dev_t rdev = makedev(nva.nva_rawdev.specdata1, nva.nva_rawdev.specdata2);
		VATTR_RETURN(vap, va_rdev, rdev);
	}
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_nlink) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_NUMLINKS))
		VATTR_RETURN(vap, va_nlink, nva.nva_nlink);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_size) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_SIZE))
		VATTR_RETURN(vap, va_data_size, nva.nva_size);
	<span class="enscript-comment">// VATTR_RETURN(vap, va_data_alloc, ???);
</span>	<span class="enscript-comment">// VATTR_RETURN(vap, va_total_size, ???);
</span>	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_total_alloc) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_SPACE_USED))
		VATTR_RETURN(vap, va_total_alloc, nva.nva_bytes);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_uid) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_OWNER))
		VATTR_RETURN(vap, va_uid, nva.nva_uid);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_uuuid) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_OWNER))
		VATTR_RETURN(vap, va_uuuid, nva.nva_uuuid);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_gid) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_OWNER_GROUP))
		VATTR_RETURN(vap, va_gid, nva.nva_gid);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_guuid) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_OWNER_GROUP))
		VATTR_RETURN(vap, va_guuid, nva.nva_guuid);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_mode)) {
		<span class="enscript-keyword">if</span> (NMFLAG(nmp, ACLONLY) || !NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_MODE))
			VATTR_RETURN(vap, va_mode, 0777);
		<span class="enscript-keyword">else</span>
			VATTR_RETURN(vap, va_mode, nva.nva_mode);
	}
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_flags) &amp;&amp;
	    (NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_ARCHIVE) ||
	     NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_HIDDEN) ||
	     (nva.nva_flags &amp; NFS_FFLAG_TRIGGER))) {
		uint32_t flags = 0;
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_ARCHIVE) &amp;&amp;
		    (nva.nva_flags &amp; NFS_FFLAG_ARCHIVED))
			flags |= SF_ARCHIVED;
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_HIDDEN) &amp;&amp;
		    (nva.nva_flags &amp; NFS_FFLAG_HIDDEN))
			flags |= UF_HIDDEN;
		VATTR_RETURN(vap, va_flags, flags);
	}
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_create_time) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_TIME_CREATE)) {
		vap-&gt;va_create_time.tv_sec = nva.nva_timesec[NFSTIME_CREATE];
		vap-&gt;va_create_time.tv_nsec = nva.nva_timensec[NFSTIME_CREATE];
		VATTR_SET_SUPPORTED(vap, va_create_time);
	}
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_access_time) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_TIME_ACCESS)) {
		vap-&gt;va_access_time.tv_sec = nva.nva_timesec[NFSTIME_ACCESS];
		vap-&gt;va_access_time.tv_nsec = nva.nva_timensec[NFSTIME_ACCESS];
		VATTR_SET_SUPPORTED(vap, va_access_time);
	}
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_modify_time) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_TIME_MODIFY)) {
		vap-&gt;va_modify_time.tv_sec = nva.nva_timesec[NFSTIME_MODIFY];
		vap-&gt;va_modify_time.tv_nsec = nva.nva_timensec[NFSTIME_MODIFY];
		VATTR_SET_SUPPORTED(vap, va_modify_time);
	}
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_change_time) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_TIME_METADATA)) {
		vap-&gt;va_change_time.tv_sec = nva.nva_timesec[NFSTIME_CHANGE];
		vap-&gt;va_change_time.tv_nsec = nva.nva_timensec[NFSTIME_CHANGE];
		VATTR_SET_SUPPORTED(vap, va_change_time);
	}
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_backup_time) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_TIME_BACKUP)) {
		vap-&gt;va_backup_time.tv_sec = nva.nva_timesec[NFSTIME_BACKUP];
		vap-&gt;va_backup_time.tv_nsec = nva.nva_timensec[NFSTIME_BACKUP];
		VATTR_SET_SUPPORTED(vap, va_backup_time);
	}
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_fileid) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_FILEID))
		VATTR_RETURN(vap, va_fileid, nva.nva_fileid);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_type) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_TYPE))
		VATTR_RETURN(vap, va_type, nva.nva_type);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_filerev) &amp;&amp; NFS_BITMAP_ISSET(nva.nva_bitmap, NFS_FATTR_CHANGE))
		VATTR_RETURN(vap, va_filerev, nva.nva_change);

	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_acl) &amp;&amp; acls) {
		VATTR_RETURN(vap, va_acl, nva.nva_acl);
		nva.nva_acl = NULL;
	}

	<span class="enscript-comment">// other attrs we might support someday:
</span>	<span class="enscript-comment">// VATTR_RETURN(vap, va_encoding, ??? /* potentially unnormalized UTF-8? */);
</span>
	NVATTR_CLEANUP(&amp;nva);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_setattr_rpc</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> vnode_attr *vap,
	vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(np);
	<span class="enscript-type">int</span> error = 0, setattr_error = 0, lockerror = ENOENT, status, nfsvers, numops;
	u_int64_t xid, nextxid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	uint32_t bitmap[NFS_ATTR_BITMAP_LEN], bmlen;
	uint32_t getbitmap[NFS_ATTR_BITMAP_LEN];
	uint32_t setbitmap[NFS_ATTR_BITMAP_LEN];
	nfs_stateid stateid;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_flags) &amp;&amp; (vap-&gt;va_flags &amp; ~(SF_ARCHIVED|UF_HIDDEN))) {
		<span class="enscript-comment">/* we don't support setting unsupported flags (duh!) */</span>
		<span class="enscript-keyword">if</span> (vap-&gt;va_active &amp; ~VNODE_ATTR_va_flags)
			<span class="enscript-keyword">return</span> (EINVAL);	<span class="enscript-comment">/* return EINVAL if other attributes also set */</span>
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> (ENOTSUP);	<span class="enscript-comment">/* return ENOTSUP for chflags(2) */</span>
	}

	<span class="enscript-comment">/* don't bother requesting some changes if they don't look like they are changing */</span>
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_uid) &amp;&amp; (vap-&gt;va_uid == np-&gt;n_vattr.nva_uid))
		VATTR_CLEAR_ACTIVE(vap, va_uid);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_gid) &amp;&amp; (vap-&gt;va_gid == np-&gt;n_vattr.nva_gid))
		VATTR_CLEAR_ACTIVE(vap, va_gid);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_uuuid) &amp;&amp; kauth_guid_equal(&amp;vap-&gt;va_uuuid, &amp;np-&gt;n_vattr.nva_uuuid))
		VATTR_CLEAR_ACTIVE(vap, va_uuuid);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_guuid) &amp;&amp; kauth_guid_equal(&amp;vap-&gt;va_guuid, &amp;np-&gt;n_vattr.nva_guuid))
		VATTR_CLEAR_ACTIVE(vap, va_guuid);

<span class="enscript-reference">tryagain</span>:
	<span class="enscript-comment">/* do nothing if no attributes will be sent */</span>
	nfs_vattr_set_bitmap(nmp, bitmap, vap);
	<span class="enscript-keyword">if</span> (!bitmap[0] &amp;&amp; !bitmap[1])
		<span class="enscript-keyword">return</span> (0);

	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">/*
	 * Prepare GETATTR bitmap: if we are setting the ACL or mode, we
	 * need to invalidate any cached ACL.  And if we had an ACL cached,
	 * we might as well also fetch the new value.
	 */</span>
	NFS_COPY_ATTRIBUTES(nfs_getattr_bitmap, getbitmap);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(bitmap, NFS_FATTR_ACL) ||
	    NFS_BITMAP_ISSET(bitmap, NFS_FATTR_MODE)) {
		<span class="enscript-keyword">if</span> (NACLVALID(np))
			NFS_BITMAP_SET(getbitmap, NFS_FATTR_ACL);
		NACLINVALIDATE(np);
	}

	<span class="enscript-comment">// PUTFH, SETATTR, GETATTR
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 40 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;setattr&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_SETATTR);
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_size))
		nfs_get_stateid(np, vfs_context_thread(ctx), vfs_context_ucred(ctx), &amp;stateid);
	<span class="enscript-keyword">else</span>
		stateid.seqid = stateid.other[0] = stateid.other[1] = stateid.other[2] = 0;
	nfsm_chain_add_stateid(error, &amp;nmreq, &amp;stateid);
	nfsm_chain_add_fattr4(error, &amp;nmreq, vap, nmp);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, getbitmap, nmp, np);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request(np, NULL, &amp;nmreq, NFSPROC4_COMPOUND, ctx, &amp;si, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_SETATTR);
	nfsmout_if(error == EBADRPC);
	setattr_error = error;
	error = 0;
	bmlen = NFS_ATTR_BITMAP_LEN;
	nfsm_chain_get_bitmap(error, &amp;nmrep, setbitmap, bmlen);
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_size) &amp;&amp; (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_IS_ATTR))
			microuptime(&amp;np-&gt;n_lastio);
		nfs_vattr_set_supported(setbitmap, vap);
		error = setattr_error;
	}
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsm_chain_loadattr(error, &amp;nmrep, np, nfsvers, &amp;xid);
	<span class="enscript-keyword">if</span> (error)
		NATTRINVALIDATE(np);
	<span class="enscript-comment">/*
	 * We just changed the attributes and we want to make sure that we
	 * see the latest attributes.  Get the next XID.  If it's not the
	 * next XID after the SETATTR XID, then it's possible that another
	 * RPC was in flight at the same time and it might put stale attributes
	 * in the cache.  In that case, we invalidate the attributes and set
	 * the attribute cache XID to guarantee that newer attributes will
	 * get loaded next.
	 */</span>
	nextxid = 0;
	nfs_get_xid(&amp;nextxid);
	<span class="enscript-keyword">if</span> (nextxid != (xid + 1)) {
		np-&gt;n_xid = nextxid;
		NATTRINVALIDATE(np);
	}
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">if</span> ((setattr_error == EINVAL) &amp;&amp; VATTR_IS_ACTIVE(vap, va_acl) &amp;&amp; VATTR_IS_ACTIVE(vap, va_mode) &amp;&amp; !NMFLAG(nmp, ACLONLY)) {
		<span class="enscript-comment">/*
		 * Some server's may not like ACL/mode combos that get sent.
		 * If it looks like that's what the server choked on, try setting
		 * just the ACL and not the mode (unless it looks like everything
		 * but mode was already successfully set).
		 */</span>
		<span class="enscript-keyword">if</span> (((bitmap[0] &amp; setbitmap[0]) != bitmap[0]) ||
		    ((bitmap[1] &amp; (setbitmap[1]|NFS_FATTR_MODE)) != bitmap[1])) {
			VATTR_CLEAR_ACTIVE(vap, va_mode);
			error = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
		}
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Wait for any pending recovery to complete.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_mount_state_wait_for_recovery</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">struct</span> timespec ts = { 1, 0 };
	<span class="enscript-type">int</span> error = 0, slpflag = NMFLAG(nmp, INTR) ? PCATCH : 0;

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">while</span> (nmp-&gt;nm_state &amp; NFSSTA_RECOVER) {
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(nmp, NULL, current_thread(), 1)))
			<span class="enscript-keyword">break</span>;
		nfs_mount_sock_thread_wake(nmp);
		msleep(&amp;nmp-&gt;nm_state, &amp;nmp-&gt;nm_lock, slpflag|(PZERO-1), <span class="enscript-string">&quot;nfsrecoverwait&quot;</span>, &amp;ts);
		slpflag = 0;
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * We're about to use/manipulate NFS mount's open/lock state.
 * Wait for any pending state recovery to complete, then
 * mark the state as being in use (which will hold off
 * the recovery thread until we're done).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_mount_state_in_use_start</span>(<span class="enscript-type">struct</span> nfsmount *nmp, thread_t thd)
{
	<span class="enscript-type">struct</span> timespec ts = { 1, 0 };
	<span class="enscript-type">int</span> error = 0, slpflag = (NMFLAG(nmp, INTR) &amp;&amp; thd) ? PCATCH : 0;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; (NFSSTA_FORCE|NFSSTA_DEAD)) {
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	<span class="enscript-keyword">while</span> (nmp-&gt;nm_state &amp; NFSSTA_RECOVER) {
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(nmp, NULL, thd, 1)))
			<span class="enscript-keyword">break</span>;
		nfs_mount_sock_thread_wake(nmp);
		msleep(&amp;nmp-&gt;nm_state, &amp;nmp-&gt;nm_lock, slpflag|(PZERO-1), <span class="enscript-string">&quot;nfsrecoverwait&quot;</span>, &amp;ts);
		slpflag = 0;
	}
	<span class="enscript-keyword">if</span> (!error)
		nmp-&gt;nm_stateinuse++;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * We're done using/manipulating the NFS mount's open/lock
 * state.  If the given error indicates that recovery should
 * be performed, we'll initiate recovery.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_mount_state_in_use_end</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">int</span> error)
{
	<span class="enscript-type">int</span> restart = nfs_mount_state_error_should_restart(error);

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (restart);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (restart &amp;&amp; (error != NFSERR_OLD_STATEID) &amp;&amp; (error != NFSERR_GRACE)) {
		printf(<span class="enscript-string">&quot;nfs_mount_state_in_use_end: error %d, initiating recovery for %s, 0x%x\n&quot;</span>,
			error, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nmp-&gt;nm_stategenid);
		nfs_need_recover(nmp, error);
	}
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_stateinuse &gt; 0)
		nmp-&gt;nm_stateinuse--;
	<span class="enscript-keyword">else</span>
		panic(<span class="enscript-string">&quot;NFS mount state in use count underrun&quot;</span>);
	<span class="enscript-keyword">if</span> (!nmp-&gt;nm_stateinuse &amp;&amp; (nmp-&gt;nm_state &amp; NFSSTA_RECOVER))
		wakeup(&amp;nmp-&gt;nm_stateinuse);
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (error == NFSERR_GRACE)
		tsleep(&amp;nmp-&gt;nm_state, (PZERO-1), <span class="enscript-string">&quot;nfsgrace&quot;</span>, 2*hz);

	<span class="enscript-keyword">return</span> (restart);
}

<span class="enscript-comment">/*
 * Does the error mean we should restart/redo a state-related operation?
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_mount_state_error_should_restart</span>(<span class="enscript-type">int</span> error)
{
	<span class="enscript-keyword">switch</span> (error) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_STALE_STATEID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_STALE_CLIENTID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_ADMIN_REVOKED</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_EXPIRED</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_OLD_STATEID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_BAD_STATEID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_GRACE</span>:
		<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * In some cases we may want to limit how many times we restart a
 * state-related operation - e.g. we're repeatedly getting NFSERR_GRACE.
 * Base the limit on the lease (as long as it's not too short).
 */</span>
uint
<span class="enscript-function-name">nfs_mount_state_max_restarts</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-keyword">return</span> (MAX(nmp-&gt;nm_fsattr.nfsa_lease, 60));
}

<span class="enscript-comment">/*
 * Does the error mean we probably lost a delegation?
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_mount_state_error_delegation_lost</span>(<span class="enscript-type">int</span> error)
{
	<span class="enscript-keyword">switch</span> (error) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_STALE_STATEID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_ADMIN_REVOKED</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_EXPIRED</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_OLD_STATEID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_BAD_STATEID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_GRACE</span>: <span class="enscript-comment">/* ugh! (stupid) RFC 3530 specifically disallows CLAIM_DELEGATE_CUR during grace period? */</span>
		<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Mark an NFS node's open state as busy.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_open_state_set_busy</span>(nfsnode_t np, thread_t thd)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> timespec ts = {2, 0};
	<span class="enscript-type">int</span> error = 0, slpflag;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	slpflag = (NMFLAG(nmp, INTR) &amp;&amp; thd) ? PCATCH : 0;

	lck_mtx_lock(&amp;np-&gt;n_openlock);
	<span class="enscript-keyword">while</span> (np-&gt;n_openflags &amp; N_OPENBUSY) {
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(nmp, NULL, thd, 0)))
			<span class="enscript-keyword">break</span>;
		np-&gt;n_openflags |= N_OPENWANT;
		msleep(&amp;np-&gt;n_openflags, &amp;np-&gt;n_openlock, slpflag, <span class="enscript-string">&quot;nfs_open_state_set_busy&quot;</span>, &amp;ts);
		slpflag = 0;
	}
	<span class="enscript-keyword">if</span> (!error)
		np-&gt;n_openflags |= N_OPENBUSY;
	lck_mtx_unlock(&amp;np-&gt;n_openlock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Clear an NFS node's open state busy flag and wake up
 * anyone wanting it.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_open_state_clear_busy</span>(nfsnode_t np)
{
	<span class="enscript-type">int</span> wanted;

	lck_mtx_lock(&amp;np-&gt;n_openlock);
	<span class="enscript-keyword">if</span> (!(np-&gt;n_openflags &amp; N_OPENBUSY))
		panic(<span class="enscript-string">&quot;nfs_open_state_clear_busy&quot;</span>);
	wanted = (np-&gt;n_openflags &amp; N_OPENWANT);
	np-&gt;n_openflags &amp;= ~(N_OPENBUSY|N_OPENWANT);
	lck_mtx_unlock(&amp;np-&gt;n_openlock);
	<span class="enscript-keyword">if</span> (wanted)
		wakeup(&amp;np-&gt;n_openflags);
}

<span class="enscript-comment">/*
 * Search a mount's open owner list for the owner for this credential.
 * If not found and &quot;alloc&quot; is set, then allocate a new one.
 */</span>
<span class="enscript-type">struct</span> nfs_open_owner *
<span class="enscript-function-name">nfs_open_owner_find</span>(<span class="enscript-type">struct</span> nfsmount *nmp, kauth_cred_t cred, <span class="enscript-type">int</span> alloc)
{
	uid_t uid = kauth_cred_getuid(cred);
	<span class="enscript-type">struct</span> nfs_open_owner *noop, *newnoop = NULL;

<span class="enscript-reference">tryagain</span>:
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	TAILQ_FOREACH(noop, &amp;nmp-&gt;nm_open_owners, noo_link) {
		<span class="enscript-keyword">if</span> (kauth_cred_getuid(noop-&gt;noo_cred) == uid)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (!noop &amp;&amp; !newnoop &amp;&amp; alloc) {
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		MALLOC(newnoop, <span class="enscript-type">struct</span> nfs_open_owner *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_open_owner), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (!newnoop)
			<span class="enscript-keyword">return</span> (NULL);
		bzero(newnoop, <span class="enscript-keyword">sizeof</span>(*newnoop));
		lck_mtx_init(&amp;newnoop-&gt;noo_lock, nfs_open_grp, LCK_ATTR_NULL);
		newnoop-&gt;noo_mount = nmp;
		kauth_cred_ref(cred);
		newnoop-&gt;noo_cred = cred;
		newnoop-&gt;noo_name = OSAddAtomic(1, &amp;nfs_open_owner_seqnum);
		TAILQ_INIT(&amp;newnoop-&gt;noo_opens);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
	}
	<span class="enscript-keyword">if</span> (!noop &amp;&amp; newnoop) {
		newnoop-&gt;noo_flags |= NFS_OPEN_OWNER_LINK;
		TAILQ_INSERT_HEAD(&amp;nmp-&gt;nm_open_owners, newnoop, noo_link);
		noop = newnoop;
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-keyword">if</span> (newnoop &amp;&amp; (noop != newnoop))
		nfs_open_owner_destroy(newnoop);

	<span class="enscript-keyword">if</span> (noop)
		nfs_open_owner_ref(noop);

	<span class="enscript-keyword">return</span> (noop);
}

<span class="enscript-comment">/*
 * destroy an open owner that's no longer needed
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_open_owner_destroy</span>(<span class="enscript-type">struct</span> nfs_open_owner *noop)
{
	<span class="enscript-keyword">if</span> (noop-&gt;noo_cred)
		kauth_cred_unref(&amp;noop-&gt;noo_cred);
	lck_mtx_destroy(&amp;noop-&gt;noo_lock, nfs_open_grp);
	FREE(noop, M_TEMP);
}

<span class="enscript-comment">/*
 * acquire a reference count on an open owner
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_open_owner_ref</span>(<span class="enscript-type">struct</span> nfs_open_owner *noop)
{
	lck_mtx_lock(&amp;noop-&gt;noo_lock);
	noop-&gt;noo_refcnt++;
	lck_mtx_unlock(&amp;noop-&gt;noo_lock);
}

<span class="enscript-comment">/*
 * drop a reference count on an open owner and destroy it if
 * it is no longer referenced and no longer on the mount's list.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_open_owner_rele</span>(<span class="enscript-type">struct</span> nfs_open_owner *noop)
{
	lck_mtx_lock(&amp;noop-&gt;noo_lock);
	<span class="enscript-keyword">if</span> (noop-&gt;noo_refcnt &lt; 1)
		panic(<span class="enscript-string">&quot;nfs_open_owner_rele: no refcnt&quot;</span>);
	noop-&gt;noo_refcnt--;
	<span class="enscript-keyword">if</span> (!noop-&gt;noo_refcnt &amp;&amp; (noop-&gt;noo_flags &amp; NFS_OPEN_OWNER_BUSY))
		panic(<span class="enscript-string">&quot;nfs_open_owner_rele: busy&quot;</span>);
	<span class="enscript-comment">/* XXX we may potentially want to clean up idle/unused open owner structures */</span>
	<span class="enscript-keyword">if</span> (noop-&gt;noo_refcnt || (noop-&gt;noo_flags &amp; NFS_OPEN_OWNER_LINK)) {
		lck_mtx_unlock(&amp;noop-&gt;noo_lock);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">/* owner is no longer referenced or linked to mount, so destroy it */</span>
	lck_mtx_unlock(&amp;noop-&gt;noo_lock);
	nfs_open_owner_destroy(noop);
}

<span class="enscript-comment">/*
 * Mark an open owner as busy because we are about to
 * start an operation that uses and updates open owner state.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_open_owner_set_busy</span>(<span class="enscript-type">struct</span> nfs_open_owner *noop, thread_t thd)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> timespec ts = {2, 0};
	<span class="enscript-type">int</span> error = 0, slpflag;

	nmp = noop-&gt;noo_mount;
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	slpflag = (NMFLAG(nmp, INTR) &amp;&amp; thd) ? PCATCH : 0;

	lck_mtx_lock(&amp;noop-&gt;noo_lock);
	<span class="enscript-keyword">while</span> (noop-&gt;noo_flags &amp; NFS_OPEN_OWNER_BUSY) {
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(nmp, NULL, thd, 0)))
			<span class="enscript-keyword">break</span>;
		noop-&gt;noo_flags |= NFS_OPEN_OWNER_WANT;
		msleep(noop, &amp;noop-&gt;noo_lock, slpflag, <span class="enscript-string">&quot;nfs_open_owner_set_busy&quot;</span>, &amp;ts);
		slpflag = 0;
	}
	<span class="enscript-keyword">if</span> (!error)
		noop-&gt;noo_flags |= NFS_OPEN_OWNER_BUSY;
	lck_mtx_unlock(&amp;noop-&gt;noo_lock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Clear the busy flag on an open owner and wake up anyone waiting
 * to mark it busy.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_open_owner_clear_busy</span>(<span class="enscript-type">struct</span> nfs_open_owner *noop)
{
	<span class="enscript-type">int</span> wanted;

	lck_mtx_lock(&amp;noop-&gt;noo_lock);
	<span class="enscript-keyword">if</span> (!(noop-&gt;noo_flags &amp; NFS_OPEN_OWNER_BUSY))
		panic(<span class="enscript-string">&quot;nfs_open_owner_clear_busy&quot;</span>);
	wanted = (noop-&gt;noo_flags &amp; NFS_OPEN_OWNER_WANT);
	noop-&gt;noo_flags &amp;= ~(NFS_OPEN_OWNER_BUSY|NFS_OPEN_OWNER_WANT);
	lck_mtx_unlock(&amp;noop-&gt;noo_lock);
	<span class="enscript-keyword">if</span> (wanted)
		wakeup(noop);
}

<span class="enscript-comment">/*
 * Given an open/lock owner and an error code, increment the
 * sequence ID if appropriate.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_owner_seqid_increment</span>(<span class="enscript-type">struct</span> nfs_open_owner *noop, <span class="enscript-type">struct</span> nfs_lock_owner *nlop, <span class="enscript-type">int</span> error)
{
	<span class="enscript-keyword">switch</span> (error) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_STALE_CLIENTID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_STALE_STATEID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_OLD_STATEID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_BAD_STATEID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_BAD_SEQID</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_BADXDR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_RESOURCE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSERR_NOFILEHANDLE</span>:
		<span class="enscript-comment">/* do not increment the open seqid on these errors */</span>
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (noop)
		noop-&gt;noo_seqid++;
	<span class="enscript-keyword">if</span> (nlop)
		nlop-&gt;nlo_seqid++;
}

<span class="enscript-comment">/*
 * Search a node's open file list for any conflicts with this request.
 * Also find this open owner's open file structure.
 * If not found and &quot;alloc&quot; is set, then allocate one.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_open_file_find</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_open_owner *noop,
	<span class="enscript-type">struct</span> nfs_open_file **nofpp,
	uint32_t accessMode,
	uint32_t denyMode,
	<span class="enscript-type">int</span> alloc)
{
	*nofpp = NULL;
	<span class="enscript-keyword">return</span> nfs_open_file_find_internal(np, noop, nofpp, accessMode, denyMode, alloc);
}

<span class="enscript-comment">/*
 * Internally, allow using a provisional nodeless nofp (passed in via *nofpp)
 * if an existing one is not found.  This is used in &quot;create&quot; scenarios to
 * officially add the provisional nofp to the node once the node is created.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_open_file_find_internal</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_open_owner *noop,
	<span class="enscript-type">struct</span> nfs_open_file **nofpp,
	uint32_t accessMode,
	uint32_t denyMode,
	<span class="enscript-type">int</span> alloc)
{
	<span class="enscript-type">struct</span> nfs_open_file *nofp = NULL, *nofp2, *newnofp = NULL;

	<span class="enscript-keyword">if</span> (!np)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">alloc</span>;
<span class="enscript-reference">tryagain</span>:
	lck_mtx_lock(&amp;np-&gt;n_openlock);
	TAILQ_FOREACH(nofp2, &amp;np-&gt;n_opens, nof_link) {
		<span class="enscript-keyword">if</span> (nofp2-&gt;nof_owner == noop) {
			nofp = nofp2;
			<span class="enscript-keyword">if</span> (!accessMode)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> ((accessMode &amp; nofp2-&gt;nof_deny) || (denyMode &amp; nofp2-&gt;nof_access)) {
			<span class="enscript-comment">/* This request conflicts with an existing open on this client. */</span>
			lck_mtx_unlock(&amp;np-&gt;n_openlock);
			<span class="enscript-keyword">return</span> (EACCES);
		}
	}

	<span class="enscript-comment">/*
	 * If this open owner doesn't have an open
	 * file structure yet, we create one for it.
	 */</span>
	<span class="enscript-keyword">if</span> (!nofp &amp;&amp; !*nofpp &amp;&amp; !newnofp &amp;&amp; alloc) {
		lck_mtx_unlock(&amp;np-&gt;n_openlock);
<span class="enscript-reference">alloc</span>:
		MALLOC(newnofp, <span class="enscript-type">struct</span> nfs_open_file *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_open_file), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (!newnofp)
			<span class="enscript-keyword">return</span> (ENOMEM);
		bzero(newnofp, <span class="enscript-keyword">sizeof</span>(*newnofp));
		lck_mtx_init(&amp;newnofp-&gt;nof_lock, nfs_open_grp, LCK_ATTR_NULL);
		newnofp-&gt;nof_owner = noop;
		nfs_open_owner_ref(noop);
		newnofp-&gt;nof_np = np;
		lck_mtx_lock(&amp;noop-&gt;noo_lock);
		TAILQ_INSERT_HEAD(&amp;noop-&gt;noo_opens, newnofp, nof_oolink);
		lck_mtx_unlock(&amp;noop-&gt;noo_lock);
		<span class="enscript-keyword">if</span> (np)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
	}
	<span class="enscript-keyword">if</span> (!nofp) {
		<span class="enscript-keyword">if</span> (*nofpp) {
			(*nofpp)-&gt;nof_np = np;
			nofp = *nofpp;
		} <span class="enscript-keyword">else</span> {
			nofp = newnofp;
		}
		<span class="enscript-keyword">if</span> (nofp &amp;&amp; np)
			TAILQ_INSERT_HEAD(&amp;np-&gt;n_opens, nofp, nof_link);
	}
	<span class="enscript-keyword">if</span> (np)
		lck_mtx_unlock(&amp;np-&gt;n_openlock);

	<span class="enscript-keyword">if</span> (alloc &amp;&amp; newnofp &amp;&amp; (nofp != newnofp))
		nfs_open_file_destroy(newnofp);

	*nofpp = nofp;
	<span class="enscript-keyword">return</span> (nofp ? 0 : ESRCH);
}

<span class="enscript-comment">/*
 * Destroy an open file structure.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_open_file_destroy</span>(<span class="enscript-type">struct</span> nfs_open_file *nofp)
{
	lck_mtx_lock(&amp;nofp-&gt;nof_owner-&gt;noo_lock);
	TAILQ_REMOVE(&amp;nofp-&gt;nof_owner-&gt;noo_opens, nofp, nof_oolink);
	lck_mtx_unlock(&amp;nofp-&gt;nof_owner-&gt;noo_lock);
	nfs_open_owner_rele(nofp-&gt;nof_owner);
	lck_mtx_destroy(&amp;nofp-&gt;nof_lock, nfs_open_grp);
	FREE(nofp, M_TEMP);
}

<span class="enscript-comment">/*
 * Mark an open file as busy because we are about to
 * start an operation that uses and updates open file state.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_open_file_set_busy</span>(<span class="enscript-type">struct</span> nfs_open_file *nofp, thread_t thd)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> timespec ts = {2, 0};
	<span class="enscript-type">int</span> error = 0, slpflag;

	nmp = nofp-&gt;nof_owner-&gt;noo_mount;
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	slpflag = (NMFLAG(nmp, INTR) &amp;&amp; thd) ? PCATCH : 0;

	lck_mtx_lock(&amp;nofp-&gt;nof_lock);
	<span class="enscript-keyword">while</span> (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_BUSY) {
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(nmp, NULL, thd, 0)))
			<span class="enscript-keyword">break</span>;
		nofp-&gt;nof_flags |= NFS_OPEN_FILE_WANT;
		msleep(nofp, &amp;nofp-&gt;nof_lock, slpflag, <span class="enscript-string">&quot;nfs_open_file_set_busy&quot;</span>, &amp;ts);
		slpflag = 0;
	}
	<span class="enscript-keyword">if</span> (!error)
		nofp-&gt;nof_flags |= NFS_OPEN_FILE_BUSY;
	lck_mtx_unlock(&amp;nofp-&gt;nof_lock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Clear the busy flag on an open file and wake up anyone waiting
 * to mark it busy.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_open_file_clear_busy</span>(<span class="enscript-type">struct</span> nfs_open_file *nofp)
{
	<span class="enscript-type">int</span> wanted;

	lck_mtx_lock(&amp;nofp-&gt;nof_lock);
	<span class="enscript-keyword">if</span> (!(nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_BUSY))
		panic(<span class="enscript-string">&quot;nfs_open_file_clear_busy&quot;</span>);
	wanted = (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_WANT);
	nofp-&gt;nof_flags &amp;= ~(NFS_OPEN_FILE_BUSY|NFS_OPEN_FILE_WANT);
	lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
	<span class="enscript-keyword">if</span> (wanted)
		wakeup(nofp);
}

<span class="enscript-comment">/*
 * Add the open state for the given access/deny modes to this open file.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_open_file_add_open</span>(<span class="enscript-type">struct</span> nfs_open_file *nofp, uint32_t accessMode, uint32_t denyMode, <span class="enscript-type">int</span> delegated)
{
	lck_mtx_lock(&amp;nofp-&gt;nof_lock);
	nofp-&gt;nof_access |= accessMode;
	nofp-&gt;nof_deny |= denyMode;

	<span class="enscript-keyword">if</span> (delegated) {
		<span class="enscript-keyword">if</span> (denyMode == NFS_OPEN_SHARE_DENY_NONE) {
			<span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_READ)
				nofp-&gt;nof_d_r++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_WRITE)
				nofp-&gt;nof_d_w++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_BOTH)
				nofp-&gt;nof_d_rw++;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (denyMode == NFS_OPEN_SHARE_DENY_WRITE) {
			<span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_READ)
				nofp-&gt;nof_d_r_dw++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_WRITE)
				nofp-&gt;nof_d_w_dw++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_BOTH)
				nofp-&gt;nof_d_rw_dw++;
		} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* NFS_OPEN_SHARE_DENY_BOTH */</span>
			<span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_READ)
				nofp-&gt;nof_d_r_drw++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_WRITE)
				nofp-&gt;nof_d_w_drw++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_BOTH)
				nofp-&gt;nof_d_rw_drw++;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (denyMode == NFS_OPEN_SHARE_DENY_NONE) {
			<span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_READ)
				nofp-&gt;nof_r++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_WRITE)
				nofp-&gt;nof_w++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_BOTH)
				nofp-&gt;nof_rw++;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (denyMode == NFS_OPEN_SHARE_DENY_WRITE) {
			<span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_READ)
				nofp-&gt;nof_r_dw++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_WRITE)
				nofp-&gt;nof_w_dw++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_BOTH)
				nofp-&gt;nof_rw_dw++;
		} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* NFS_OPEN_SHARE_DENY_BOTH */</span>
			<span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_READ)
				nofp-&gt;nof_r_drw++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_WRITE)
				nofp-&gt;nof_w_drw++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_BOTH)
				nofp-&gt;nof_rw_drw++;
		}
	}

	nofp-&gt;nof_opencnt++;
	lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
}

<span class="enscript-comment">/*
 * Find which particular open combo will be closed and report what
 * the new modes will be and whether the open was delegated.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_open_file_remove_open_find</span>(
	<span class="enscript-type">struct</span> nfs_open_file *nofp,
	uint32_t accessMode,
	uint32_t denyMode,
	uint32_t *newAccessMode,
	uint32_t *newDenyMode,
	<span class="enscript-type">int</span> *delegated)
{
	<span class="enscript-comment">/*
	 * Calculate new modes: a mode bit gets removed when there's only
	 * one count in all the corresponding counts
	 */</span>
	*newAccessMode = nofp-&gt;nof_access;
	*newDenyMode = nofp-&gt;nof_deny;

	<span class="enscript-keyword">if</span> ((accessMode &amp; NFS_OPEN_SHARE_ACCESS_READ) &amp;&amp;
	    (nofp-&gt;nof_access &amp; NFS_OPEN_SHARE_ACCESS_READ) &amp;&amp;
	    ((nofp-&gt;nof_r + nofp-&gt;nof_d_r +
	      nofp-&gt;nof_rw + nofp-&gt;nof_d_rw +
	      nofp-&gt;nof_r_dw + nofp-&gt;nof_d_r_dw +
	      nofp-&gt;nof_rw_dw + nofp-&gt;nof_d_rw_dw +
	      nofp-&gt;nof_r_drw + nofp-&gt;nof_d_r_drw +
	      nofp-&gt;nof_rw_dw + nofp-&gt;nof_d_rw_dw) == 1))
		*newAccessMode &amp;= ~NFS_OPEN_SHARE_ACCESS_READ;
	<span class="enscript-keyword">if</span> ((accessMode &amp; NFS_OPEN_SHARE_ACCESS_WRITE) &amp;&amp;
	    (nofp-&gt;nof_access &amp; NFS_OPEN_SHARE_ACCESS_WRITE) &amp;&amp;
	    ((nofp-&gt;nof_w + nofp-&gt;nof_d_w +
	      nofp-&gt;nof_rw + nofp-&gt;nof_d_rw +
	      nofp-&gt;nof_w_dw + nofp-&gt;nof_d_w_dw +
	      nofp-&gt;nof_rw_dw + nofp-&gt;nof_d_rw_dw +
	      nofp-&gt;nof_w_drw + nofp-&gt;nof_d_w_drw +
	      nofp-&gt;nof_rw_dw + nofp-&gt;nof_d_rw_dw) == 1))
		*newAccessMode &amp;= ~NFS_OPEN_SHARE_ACCESS_WRITE;
	<span class="enscript-keyword">if</span> ((denyMode &amp; NFS_OPEN_SHARE_DENY_READ) &amp;&amp;
	    (nofp-&gt;nof_deny &amp; NFS_OPEN_SHARE_DENY_READ) &amp;&amp;
	    ((nofp-&gt;nof_r_drw + nofp-&gt;nof_d_r_drw +
	      nofp-&gt;nof_w_drw + nofp-&gt;nof_d_w_drw +
	      nofp-&gt;nof_rw_drw + nofp-&gt;nof_d_rw_drw) == 1))
		*newDenyMode &amp;= ~NFS_OPEN_SHARE_DENY_READ;
	<span class="enscript-keyword">if</span> ((denyMode &amp; NFS_OPEN_SHARE_DENY_WRITE) &amp;&amp;
	    (nofp-&gt;nof_deny &amp; NFS_OPEN_SHARE_DENY_WRITE) &amp;&amp;
	    ((nofp-&gt;nof_r_drw + nofp-&gt;nof_d_r_drw +
	      nofp-&gt;nof_w_drw + nofp-&gt;nof_d_w_drw +
	      nofp-&gt;nof_rw_drw + nofp-&gt;nof_d_rw_drw +
	      nofp-&gt;nof_r_dw + nofp-&gt;nof_d_r_dw +
	      nofp-&gt;nof_w_dw + nofp-&gt;nof_d_w_dw +
	      nofp-&gt;nof_rw_dw + nofp-&gt;nof_d_rw_dw) == 1))
		*newDenyMode &amp;= ~NFS_OPEN_SHARE_DENY_WRITE;

	<span class="enscript-comment">/* Find the corresponding open access/deny mode counter. */</span>
	<span class="enscript-keyword">if</span> (denyMode == NFS_OPEN_SHARE_DENY_NONE) {
		<span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_READ)
			*delegated = (nofp-&gt;nof_d_r != 0);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_WRITE)
			*delegated = (nofp-&gt;nof_d_w != 0);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_BOTH)
			*delegated = (nofp-&gt;nof_d_rw != 0);
		<span class="enscript-keyword">else</span>
			*delegated = 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (denyMode == NFS_OPEN_SHARE_DENY_WRITE) {
		<span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_READ)
			*delegated = (nofp-&gt;nof_d_r_dw != 0);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_WRITE)
			*delegated = (nofp-&gt;nof_d_w_dw != 0);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_BOTH)
			*delegated = (nofp-&gt;nof_d_rw_dw != 0);
		<span class="enscript-keyword">else</span>
			*delegated = 0;
	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* NFS_OPEN_SHARE_DENY_BOTH */</span>
		<span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_READ)
			*delegated = (nofp-&gt;nof_d_r_drw != 0);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_WRITE)
			*delegated = (nofp-&gt;nof_d_w_drw != 0);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_BOTH)
			*delegated = (nofp-&gt;nof_d_rw_drw != 0);
		<span class="enscript-keyword">else</span>
			*delegated = 0;
	}
}

<span class="enscript-comment">/*
 * Remove the open state for the given access/deny modes to this open file.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_open_file_remove_open</span>(<span class="enscript-type">struct</span> nfs_open_file *nofp, uint32_t accessMode, uint32_t denyMode)
{
	uint32_t newAccessMode, newDenyMode;
	<span class="enscript-type">int</span> delegated = 0;

	lck_mtx_lock(&amp;nofp-&gt;nof_lock);
	nfs_open_file_remove_open_find(nofp, accessMode, denyMode, &amp;newAccessMode, &amp;newDenyMode, &amp;delegated);

	<span class="enscript-comment">/* Decrement the corresponding open access/deny mode counter. */</span>
	<span class="enscript-keyword">if</span> (denyMode == NFS_OPEN_SHARE_DENY_NONE) {
		<span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_READ) {
			<span class="enscript-keyword">if</span> (delegated) {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_r == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(R) delegated count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_d_r--;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_r == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(R) count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_r--;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_WRITE) {
			<span class="enscript-keyword">if</span> (delegated) {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_w == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(W) delegated count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_d_w--;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_w == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(W) count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_w--;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_BOTH) {
			<span class="enscript-keyword">if</span> (delegated) {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_rw == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(RW) delegated count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_d_rw--;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_rw == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(RW) count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_rw--;
			}
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (denyMode == NFS_OPEN_SHARE_DENY_WRITE) {
		<span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_READ) {
			<span class="enscript-keyword">if</span> (delegated) {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_r_dw == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(R,DW) delegated count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_d_r_dw--;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_r_dw == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(R,DW) count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_r_dw--;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_WRITE) {
			<span class="enscript-keyword">if</span> (delegated) {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_w_dw == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(W,DW) delegated count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_d_w_dw--;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_w_dw == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(W,DW) count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_w_dw--;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_BOTH) {
			<span class="enscript-keyword">if</span> (delegated) {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_rw_dw == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(RW,DW) delegated count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_d_rw_dw--;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_rw_dw == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(RW,DW) count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_rw_dw--;
			}
		}
	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* NFS_OPEN_SHARE_DENY_BOTH */</span>
		<span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_READ) {
			<span class="enscript-keyword">if</span> (delegated) {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_r_drw == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(R,DRW) delegated count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_d_r_drw--;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_r_drw == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(R,DRW) count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_r_drw--;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_WRITE) {
			<span class="enscript-keyword">if</span> (delegated) {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_w_drw == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(W,DRW) delegated count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_d_w_drw--;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_w_drw == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(W,DRW) count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_w_drw--;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_BOTH) {
			<span class="enscript-keyword">if</span> (delegated) {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_rw_drw == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(RW,DRW) delegated count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_d_rw_drw--;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (nofp-&gt;nof_rw_drw == 0)
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: open(RW,DRW) count underrun, %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				<span class="enscript-keyword">else</span>
					nofp-&gt;nof_rw_drw--;
			}
		}
	}

	<span class="enscript-comment">/* update the modes */</span>
	nofp-&gt;nof_access = newAccessMode;
	nofp-&gt;nof_deny = newDenyMode;
	nofp-&gt;nof_opencnt--;
	lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
}


<span class="enscript-comment">/*
 * Get the current (delegation, lock, open, default) stateid for this node.
 * If node has a delegation, use that stateid.
 * If pid has a lock, use the lockowner's stateid.
 * Or use the open file's stateid.
 * If no open file, use a default stateid of all ones.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_get_stateid</span>(nfsnode_t np, thread_t thd, kauth_cred_t cred, nfs_stateid *sid)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(np);
	proc_t p = thd ? get_bsdthreadtask_info(thd) : current_proc();  <span class="enscript-comment">// XXX async I/O requests don't have a thread
</span>	<span class="enscript-type">struct</span> nfs_open_owner *noop = NULL;
	<span class="enscript-type">struct</span> nfs_open_file *nofp = NULL;
	<span class="enscript-type">struct</span> nfs_lock_owner *nlop = NULL;
	nfs_stateid *s = NULL;

	<span class="enscript-keyword">if</span> (np-&gt;n_openflags &amp; N_DELEG_MASK) {
		s = &amp;np-&gt;n_dstateid;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (p)
			nlop = nfs_lock_owner_find(np, p, 0);
		<span class="enscript-keyword">if</span> (nlop &amp;&amp; !TAILQ_EMPTY(&amp;nlop-&gt;nlo_locks)) {
			<span class="enscript-comment">/* we hold locks, use lock stateid */</span>
			s = &amp;nlop-&gt;nlo_stateid;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (((noop = nfs_open_owner_find(nmp, cred, 0))) &amp;&amp;
			 (nfs_open_file_find(np, noop, &amp;nofp, 0, 0, 0) == 0) &amp;&amp;
			 !(nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST) &amp;&amp;
			 nofp-&gt;nof_access) {
			<span class="enscript-comment">/* we (should) have the file open, use open stateid */</span>
			<span class="enscript-keyword">if</span> (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN)
				nfs4_reopen(nofp, thd);
			<span class="enscript-keyword">if</span> (!(nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST))
				s = &amp;nofp-&gt;nof_stateid;
		}
	}

	<span class="enscript-keyword">if</span> (s) {
		sid-&gt;seqid = s-&gt;seqid;
		sid-&gt;other[0] = s-&gt;other[0];
		sid-&gt;other[1] = s-&gt;other[1];
		sid-&gt;other[2] = s-&gt;other[2];
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* named attributes may not have a stateid for reads, so don't complain for them */</span>
		<span class="enscript-keyword">if</span> (!(np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_IS_ATTR))
			NP(np, <span class="enscript-string">&quot;nfs_get_stateid: no stateid&quot;</span>);
		sid-&gt;seqid = sid-&gt;other[0] = sid-&gt;other[1] = sid-&gt;other[2] = 0xffffffff;
	}
	<span class="enscript-keyword">if</span> (nlop)
		nfs_lock_owner_rele(nlop);
	<span class="enscript-keyword">if</span> (noop)
		nfs_open_owner_rele(noop);
}


<span class="enscript-comment">/*
 * When we have a delegation, we may be able to perform the OPEN locally.
 * Perform the OPEN by checking the delegation ACE and/or checking via ACCESS.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_open_delegated</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_open_file *nofp,
	uint32_t accessMode,
	uint32_t denyMode,
	vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error = 0, ismember, readtoo = 0, authorized = 0;
	uint32_t action;
	<span class="enscript-type">struct</span> kauth_acl_eval eval;
	kauth_cred_t cred = vfs_context_ucred(ctx);

	<span class="enscript-keyword">if</span> (!(accessMode &amp; NFS_OPEN_SHARE_ACCESS_READ)) {
		<span class="enscript-comment">/*
		 * Try to open it for read access too,
		 * so the buffer cache can read data.
		 */</span>
		readtoo = 1;
		accessMode |= NFS_OPEN_SHARE_ACCESS_READ;
	}

<span class="enscript-reference">tryagain</span>:
	action = 0;
	<span class="enscript-keyword">if</span> (accessMode &amp; NFS_OPEN_SHARE_ACCESS_READ)
		action |= KAUTH_VNODE_READ_DATA;
	<span class="enscript-keyword">if</span> (accessMode &amp; NFS_OPEN_SHARE_ACCESS_WRITE)
		action |= KAUTH_VNODE_WRITE_DATA;

	<span class="enscript-comment">/* evaluate ACE (if we have one) */</span>
	<span class="enscript-keyword">if</span> (np-&gt;n_dace.ace_flags) {
		eval.ae_requested = action;
		eval.ae_acl = &amp;np-&gt;n_dace;
		eval.ae_count = 1;
		eval.ae_options = 0;
		<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_uid == kauth_cred_getuid(cred))
			eval.ae_options |= KAUTH_AEVAL_IS_OWNER;
		error = kauth_cred_ismember_gid(cred, np-&gt;n_vattr.nva_gid, &amp;ismember);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; ismember)
			eval.ae_options |= KAUTH_AEVAL_IN_GROUP;

		eval.ae_exp_gall = KAUTH_VNODE_GENERIC_ALL_BITS;
		eval.ae_exp_gread = KAUTH_VNODE_GENERIC_READ_BITS;
		eval.ae_exp_gwrite = KAUTH_VNODE_GENERIC_WRITE_BITS;
		eval.ae_exp_gexec = KAUTH_VNODE_GENERIC_EXECUTE_BITS;

		error = kauth_acl_evaluate(cred, &amp;eval);

		<span class="enscript-keyword">if</span> (!error &amp;&amp; (eval.ae_result == KAUTH_RESULT_ALLOW))
			authorized = 1;
	}

	<span class="enscript-keyword">if</span> (!authorized) {
		<span class="enscript-comment">/* need to ask the server via ACCESS */</span>
		<span class="enscript-type">struct</span> vnop_access_args naa;
		naa.a_desc = &amp;vnop_access_desc;
		naa.a_vp = NFSTOV(np);
		naa.a_action = action;
		naa.a_context = ctx;
		<span class="enscript-keyword">if</span> (!(error = nfs_vnop_access(&amp;naa)))
			authorized = 1;
	}

	<span class="enscript-keyword">if</span> (!authorized) {
		<span class="enscript-keyword">if</span> (readtoo) {
			<span class="enscript-comment">/* try again without the extra read access */</span>
			accessMode &amp;= ~NFS_OPEN_SHARE_ACCESS_READ;
			readtoo = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
		}
		<span class="enscript-keyword">return</span> (error ? error : EACCES);
	}

	nfs_open_file_add_open(nofp, accessMode, denyMode, 1);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Open a file with the given access/deny modes.
 *
 * If we have a delegation, we may be able to handle the open locally.
 * Otherwise, we will always send the open RPC even if this open's mode is
 * a subset of all the existing opens.  This makes sure that we will always
 * be able to do a downgrade to any of the open modes.
 *
 * Note: local conflicts should have already been checked in nfs_open_file_find().
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_open</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_open_file *nofp,
	uint32_t accessMode,
	uint32_t denyMode,
	vfs_context_t ctx)
{
	vnode_t vp = NFSTOV(np);
	vnode_t dvp = NULL;
	<span class="enscript-type">struct</span> componentname cn;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *vname = NULL;
	size_t namelen;
	<span class="enscript-type">char</span> smallname[128];
	<span class="enscript-type">char</span> *filename = NULL;
	<span class="enscript-type">int</span> error = 0, readtoo = 0;

	<span class="enscript-comment">/*
	 * We can handle the OPEN ourselves if we have a delegation,
	 * unless it's a read delegation and the open is asking for
	 * either write access or deny read.  We also don't bother to
	 * use the delegation if it's being returned.
	 */</span>
	<span class="enscript-keyword">if</span> (np-&gt;n_openflags &amp; N_DELEG_MASK) {
		<span class="enscript-keyword">if</span> ((error = nfs_open_state_set_busy(np, vfs_context_thread(ctx))))
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">if</span> ((np-&gt;n_openflags &amp; N_DELEG_MASK) &amp;&amp; !(np-&gt;n_openflags &amp; N_DELEG_RETURN) &amp;&amp;
		    (((np-&gt;n_openflags &amp; N_DELEG_MASK) == N_DELEG_WRITE) ||
		     (!(accessMode &amp; NFS_OPEN_SHARE_ACCESS_WRITE) &amp;&amp; !(denyMode &amp; NFS_OPEN_SHARE_DENY_READ)))) {
			error = nfs4_open_delegated(np, nofp, accessMode, denyMode, ctx);
			nfs_open_state_clear_busy(np);
			<span class="enscript-keyword">return</span> (error);
		}
		nfs_open_state_clear_busy(np);
	}

	<span class="enscript-comment">/*
	 * [sigh] We can't trust VFS to get the parent right for named
	 * attribute nodes.  (It likes to reparent the nodes after we've
	 * created them.)  Luckily we can probably get the right parent
	 * from the n_parent we have stashed away.
	 */</span>
	<span class="enscript-keyword">if</span> ((np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_IS_ATTR) &amp;&amp;
	    (((dvp = np-&gt;n_parent)) &amp;&amp; (error = vnode_get(dvp))))
		dvp = NULL;
	<span class="enscript-keyword">if</span> (!dvp)
		dvp = vnode_getparent(vp);
	vname = vnode_getname(vp);
	<span class="enscript-keyword">if</span> (!dvp || !vname) {
		<span class="enscript-keyword">if</span> (!error)
			error = EIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	filename = &amp;smallname[0];
	namelen = snprintf(filename, <span class="enscript-keyword">sizeof</span>(smallname), <span class="enscript-string">&quot;%s&quot;</span>, vname);
	<span class="enscript-keyword">if</span> (namelen &gt;= <span class="enscript-keyword">sizeof</span>(smallname)) {
		MALLOC(filename, <span class="enscript-type">char</span> *, namelen+1, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (!filename) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		snprintf(filename, namelen+1, <span class="enscript-string">&quot;%s&quot;</span>, vname);
	}
	bzero(&amp;cn, <span class="enscript-keyword">sizeof</span>(cn));
	cn.cn_nameptr = filename;
	cn.cn_namelen = namelen;

	<span class="enscript-keyword">if</span> (!(accessMode &amp; NFS_OPEN_SHARE_ACCESS_READ)) {
		<span class="enscript-comment">/*
		 * Try to open it for read access too,
		 * so the buffer cache can read data.
		 */</span>
		readtoo = 1;
		accessMode |= NFS_OPEN_SHARE_ACCESS_READ;
	}
<span class="enscript-reference">tryagain</span>:
	error = nfs4_open_rpc(nofp, ctx, &amp;cn, NULL, dvp, &amp;vp, NFS_OPEN_NOCREATE, accessMode, denyMode);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (!nfs_mount_state_error_should_restart(error) &amp;&amp;
		    (error != EINTR) &amp;&amp; (error != ERESTART) &amp;&amp; readtoo) {
			<span class="enscript-comment">/* try again without the extra read access */</span>
			accessMode &amp;= ~NFS_OPEN_SHARE_ACCESS_READ;
			readtoo = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	nfs_open_file_add_open(nofp, accessMode, denyMode, 0);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (filename &amp;&amp; (filename != &amp;smallname[0]))
		FREE(filename, M_TEMP);
	<span class="enscript-keyword">if</span> (vname)
		vnode_putname(vname);
	<span class="enscript-keyword">if</span> (dvp != NULLVP)
		vnode_put(dvp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_mmap</span>(
	<span class="enscript-type">struct</span> vnop_mmap_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		int a_fflags;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t vp = ap-&gt;a_vp;
	nfsnode_t np = VTONFS(vp);
	<span class="enscript-type">int</span> error = 0, accessMode, denyMode, delegated;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_open_owner *noop = NULL;
	<span class="enscript-type">struct</span> nfs_open_file *nofp = NULL;

	nmp = VTONMP(vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (!vnode_isreg(vp) || !(ap-&gt;a_fflags &amp; (PROT_READ|PROT_WRITE)))
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE)
		<span class="enscript-keyword">return</span> (EIO);

	<span class="enscript-comment">/*
	 * fflags contains some combination of: PROT_READ, PROT_WRITE
	 * Since it's not possible to mmap() without having the file open for reading,
	 * read access is always there (regardless if PROT_READ is not set).
	 */</span>
	accessMode = NFS_OPEN_SHARE_ACCESS_READ;
	<span class="enscript-keyword">if</span> (ap-&gt;a_fflags &amp; PROT_WRITE)
		accessMode |= NFS_OPEN_SHARE_ACCESS_WRITE;
	denyMode = NFS_OPEN_SHARE_DENY_NONE;

	noop = nfs_open_owner_find(nmp, vfs_context_ucred(ctx), 1);
	<span class="enscript-keyword">if</span> (!noop)
		<span class="enscript-keyword">return</span> (ENOMEM);

<span class="enscript-reference">restart</span>:
	error = nfs_mount_state_in_use_start(nmp, NULL);
	<span class="enscript-keyword">if</span> (error) {
		nfs_open_owner_rele(noop);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
		error = EIO;
		nfs_mount_state_in_use_end(nmp, 0);
		nfs_open_owner_rele(noop);
		<span class="enscript-keyword">return</span> (error);
	}

	error = nfs_open_file_find(np, noop, &amp;nofp, 0, 0, 1);
	<span class="enscript-keyword">if</span> (error || (!error &amp;&amp; (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST))) {
		NP(np, <span class="enscript-string">&quot;nfs_vnop_mmap: no open file for owner, error %d, %d&quot;</span>, error, kauth_cred_getuid(noop-&gt;noo_cred));
		error = EPERM;
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN)) {
		nfs_mount_state_in_use_end(nmp, 0);
		error = nfs4_reopen(nofp, NULL);
		nofp = NULL;
		<span class="enscript-keyword">if</span> (!error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}
	<span class="enscript-keyword">if</span> (!error)
		error = nfs_open_file_set_busy(nofp, NULL);
	<span class="enscript-keyword">if</span> (error) {
		nofp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * The open reference for mmap must mirror an existing open because
	 * we may need to reclaim it after the file is closed.
	 * So grab another open count matching the accessMode passed in.
	 * If we already had an mmap open, prefer read/write without deny mode.
	 * This means we may have to drop the current mmap open first.
	 *
	 * N.B. We should have an open for the mmap, because, mmap was
	 * called on an open descriptor, or we've created an open for read
	 * from reading the first page for execve. However, if we piggy
	 * backed on an existing NFS_OPEN_SHARE_ACCESS_READ/NFS_OPEN_SHARE_DENY_NONE
	 * that open may have closed.
	 */</span>

	<span class="enscript-keyword">if</span> (!(nofp-&gt;nof_access &amp; NFS_OPEN_SHARE_ACCESS_READ)) {
		<span class="enscript-keyword">if</span> (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_NEEDCLOSE) {
			<span class="enscript-comment">/* We shouldn't get here. We've already open the file for execve */</span>
			NP(np, <span class="enscript-string">&quot;nfs_vnop_mmap: File already needs close access: 0x%x, cred: %d thread: %lld&quot;</span>,
			   nofp-&gt;nof_access, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred), thread_tid(vfs_context_thread(ctx)));
		}
		<span class="enscript-comment">/*
		 * mmapings for execve are just for read. Get out with EPERM if the accessMode is not ACCESS_READ
		 * or the access would be denied. Other accesses should have an open descriptor for the mapping.
		 */</span>
		<span class="enscript-keyword">if</span> (accessMode != NFS_OPEN_SHARE_ACCESS_READ || (accessMode &amp; nofp-&gt;nof_deny)) {
			<span class="enscript-comment">/* not asking for just read access -&gt; fail */</span>
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/* we don't have the file open, so open it for read access */</span>
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &lt; NFS_VER4) {
			<span class="enscript-comment">/* NFS v2/v3 opens are always allowed - so just add it. */</span>
			nfs_open_file_add_open(nofp, NFS_OPEN_SHARE_ACCESS_READ, NFS_OPEN_SHARE_DENY_NONE, 0);
			error = 0;
		} <span class="enscript-keyword">else</span> {
			error = nfs4_open(np, nofp, NFS_OPEN_SHARE_ACCESS_READ, NFS_OPEN_SHARE_DENY_NONE, ctx);
		}
		<span class="enscript-keyword">if</span> (!error)
			nofp-&gt;nof_flags |= NFS_OPEN_FILE_NEEDCLOSE;
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* determine deny mode for open */</span>
	<span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_BOTH) {
		<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_rw || nofp-&gt;nof_d_rw_dw || nofp-&gt;nof_d_rw_drw) {
			delegated = 1;
			<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_rw)
				denyMode = NFS_OPEN_SHARE_DENY_NONE;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_d_rw_dw)
				denyMode = NFS_OPEN_SHARE_DENY_WRITE;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_d_rw_drw)
				denyMode = NFS_OPEN_SHARE_DENY_BOTH;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_rw || nofp-&gt;nof_rw_dw || nofp-&gt;nof_rw_drw) {
			delegated = 0;
			<span class="enscript-keyword">if</span> (nofp-&gt;nof_rw)
				denyMode = NFS_OPEN_SHARE_DENY_NONE;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_rw_dw)
				denyMode = NFS_OPEN_SHARE_DENY_WRITE;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_rw_drw)
				denyMode = NFS_OPEN_SHARE_DENY_BOTH;
		} <span class="enscript-keyword">else</span> {
			error = EPERM;
		}
	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* NFS_OPEN_SHARE_ACCESS_READ */</span>
		<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_r || nofp-&gt;nof_d_r_dw || nofp-&gt;nof_d_r_drw) {
			delegated = 1;
			<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_r)
				denyMode = NFS_OPEN_SHARE_DENY_NONE;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_d_r_dw)
				denyMode = NFS_OPEN_SHARE_DENY_WRITE;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_d_r_drw)
				denyMode = NFS_OPEN_SHARE_DENY_BOTH;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_r || nofp-&gt;nof_r_dw || nofp-&gt;nof_r_drw) {
			delegated = 0;
			<span class="enscript-keyword">if</span> (nofp-&gt;nof_r)
				denyMode = NFS_OPEN_SHARE_DENY_NONE;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_r_dw)
				denyMode = NFS_OPEN_SHARE_DENY_WRITE;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_r_drw)
				denyMode = NFS_OPEN_SHARE_DENY_BOTH;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_d_rw || nofp-&gt;nof_d_rw_dw || nofp-&gt;nof_d_rw_drw) {
			<span class="enscript-comment">/*
			 * This clause and the one below is to co-opt a read write access
			 * for a read only mmaping. We probably got here in that an
			 * existing rw open for an executable file already exists.
			 */</span>
			delegated = 1;
			accessMode = NFS_OPEN_SHARE_ACCESS_BOTH;
			<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_rw)
				denyMode = NFS_OPEN_SHARE_DENY_NONE;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_d_rw_dw)
				denyMode = NFS_OPEN_SHARE_DENY_WRITE;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_d_rw_drw)
				denyMode = NFS_OPEN_SHARE_DENY_BOTH;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_rw || nofp-&gt;nof_rw_dw || nofp-&gt;nof_rw_drw) {
			delegated = 0;
			accessMode = NFS_OPEN_SHARE_ACCESS_BOTH;
			<span class="enscript-keyword">if</span> (nofp-&gt;nof_rw)
				denyMode = NFS_OPEN_SHARE_DENY_NONE;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_rw_dw)
				denyMode = NFS_OPEN_SHARE_DENY_WRITE;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp-&gt;nof_rw_drw)
				denyMode = NFS_OPEN_SHARE_DENY_BOTH;
		} <span class="enscript-keyword">else</span> {
			error = EPERM;
		}
	}
	<span class="enscript-keyword">if</span> (error) <span class="enscript-comment">/* mmap mode without proper open mode */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * If the existing mmap access is more than the new access OR the
	 * existing access is the same and the existing deny mode is less,
	 * then we'll stick with the existing mmap open mode.
	 */</span>
	<span class="enscript-keyword">if</span> ((nofp-&gt;nof_mmap_access &gt; accessMode) ||
	    ((nofp-&gt;nof_mmap_access == accessMode) &amp;&amp; (nofp-&gt;nof_mmap_deny &lt;= denyMode)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* update mmap open mode */</span>
	<span class="enscript-keyword">if</span> (nofp-&gt;nof_mmap_access) {
		error = nfs_close(np, nofp, nofp-&gt;nof_mmap_access, nofp-&gt;nof_mmap_deny, ctx);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (!nfs_mount_state_error_should_restart(error))
				NP(np, <span class="enscript-string">&quot;nfs_vnop_mmap: close of previous mmap mode failed: %d, %d&quot;</span>, error, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
			NP(np, <span class="enscript-string">&quot;nfs_vnop_mmap: update, close error %d, %d&quot;</span>, error, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		nofp-&gt;nof_mmap_access = nofp-&gt;nof_mmap_deny = 0;
	}

	nfs_open_file_add_open(nofp, accessMode, denyMode, delegated);
	nofp-&gt;nof_mmap_access = accessMode;
	nofp-&gt;nof_mmap_deny = denyMode;

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (nofp)
		nfs_open_file_clear_busy(nofp);
	<span class="enscript-keyword">if</span> (nfs_mount_state_in_use_end(nmp, error)) {
		nofp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}
	<span class="enscript-keyword">if</span> (noop)
		nfs_open_owner_rele(noop);

	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-type">int</span> ismapped = 0;
		nfs_node_lock_force(np);
		<span class="enscript-keyword">if</span> ((np-&gt;n_flag &amp; NISMAPPED) == 0) {
			np-&gt;n_flag |= NISMAPPED;
			ismapped = 1;
		}
		nfs_node_unlock(np);
		<span class="enscript-keyword">if</span> (ismapped) {
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			nmp-&gt;nm_state &amp;= ~NFSSTA_SQUISHY;
			nmp-&gt;nm_curdeadtimeout = nmp-&gt;nm_deadtimeout;
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_curdeadtimeout &lt;= 0)
				nmp-&gt;nm_deadto_start = 0;
			nmp-&gt;nm_mappers++;
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		}
	}

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_mnomap</span>(
	<span class="enscript-type">struct</span> vnop_mnomap_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t vp = ap-&gt;a_vp;
	nfsnode_t np = VTONFS(vp);
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_open_file *nofp = NULL;
	off_t size;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> is_mapped_flag = 0;
	
	nmp = VTONMP(vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	nfs_node_lock_force(np);
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NISMAPPED) {
		is_mapped_flag = 1;
		np-&gt;n_flag &amp;= ~NISMAPPED;
	}
	nfs_node_unlock(np);
	<span class="enscript-keyword">if</span> (is_mapped_flag) {
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_mappers)
			nmp-&gt;nm_mappers--;
		<span class="enscript-keyword">else</span>
			NP(np, <span class="enscript-string">&quot;nfs_vnop_mnomap: removing mmap reference from mount, but mount has no files mmapped&quot;</span>);
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	}

	<span class="enscript-comment">/* flush buffers/ubc before we drop the open (in case it's our last open) */</span>
	nfs_flush(np, MNT_WAIT, vfs_context_thread(ctx), V_IGNORE_WRITEERR);
	<span class="enscript-keyword">if</span> (UBCINFOEXISTS(vp) &amp;&amp; (size = ubc_getsize(vp)))
		ubc_msync(vp, 0, size, NULL, UBC_PUSHALL | UBC_SYNC);

	<span class="enscript-comment">/* walk all open files and close all mmap opens */</span>
<span class="enscript-reference">loop</span>:
	error = nfs_mount_state_in_use_start(nmp, NULL);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	lck_mtx_lock(&amp;np-&gt;n_openlock);
	TAILQ_FOREACH(nofp, &amp;np-&gt;n_opens, nof_link) {
		<span class="enscript-keyword">if</span> (!nofp-&gt;nof_mmap_access)
			<span class="enscript-keyword">continue</span>;
		lck_mtx_unlock(&amp;np-&gt;n_openlock);
		<span class="enscript-keyword">if</span> (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN) {
			nfs_mount_state_in_use_end(nmp, 0);
			error = nfs4_reopen(nofp, NULL);
			<span class="enscript-keyword">if</span> (!error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
		}
		<span class="enscript-keyword">if</span> (!error)
			error = nfs_open_file_set_busy(nofp, NULL);
		<span class="enscript-keyword">if</span> (error) {
			lck_mtx_lock(&amp;np-&gt;n_openlock);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (nofp-&gt;nof_mmap_access) {
			error = nfs_close(np, nofp, nofp-&gt;nof_mmap_access, nofp-&gt;nof_mmap_deny, ctx);
			<span class="enscript-keyword">if</span> (!nfs_mount_state_error_should_restart(error)) {
				<span class="enscript-keyword">if</span> (error) <span class="enscript-comment">/* not a state-operation-restarting error, so just clear the access */</span>
					NP(np, <span class="enscript-string">&quot;nfs_vnop_mnomap: close of mmap mode failed: %d, %d&quot;</span>, error, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
				nofp-&gt;nof_mmap_access = nofp-&gt;nof_mmap_deny = 0;
			}
			<span class="enscript-keyword">if</span> (error)
				NP(np, <span class="enscript-string">&quot;nfs_vnop_mnomap: error %d, %d&quot;</span>, error, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
		}
		nfs_open_file_clear_busy(nofp);
		nfs_mount_state_in_use_end(nmp, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
	}
	lck_mtx_unlock(&amp;np-&gt;n_openlock);
	nfs_mount_state_in_use_end(nmp, error);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Search a node's lock owner list for the owner for this process.
 * If not found and &quot;alloc&quot; is set, then allocate a new one.
 */</span>
<span class="enscript-type">struct</span> nfs_lock_owner *
<span class="enscript-function-name">nfs_lock_owner_find</span>(nfsnode_t np, proc_t p, <span class="enscript-type">int</span> alloc)
{
	pid_t pid = proc_pid(p);
	<span class="enscript-type">struct</span> nfs_lock_owner *nlop, *newnlop = NULL;

<span class="enscript-reference">tryagain</span>:
	lck_mtx_lock(&amp;np-&gt;n_openlock);
	TAILQ_FOREACH(nlop, &amp;np-&gt;n_lock_owners, nlo_link) {
		<span class="enscript-keyword">if</span> (nlop-&gt;nlo_pid != pid)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (timevalcmp(&amp;nlop-&gt;nlo_pid_start, &amp;p-&gt;p_start, ==))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* stale lock owner... reuse it if we can */</span>
		<span class="enscript-keyword">if</span> (nlop-&gt;nlo_refcnt) {
			TAILQ_REMOVE(&amp;np-&gt;n_lock_owners, nlop, nlo_link);
			nlop-&gt;nlo_flags &amp;= ~NFS_LOCK_OWNER_LINK;
			lck_mtx_unlock(&amp;np-&gt;n_openlock);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
		}
		nlop-&gt;nlo_pid_start = p-&gt;p_start;
		nlop-&gt;nlo_seqid = 0;
		nlop-&gt;nlo_stategenid = 0;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (!nlop &amp;&amp; !newnlop &amp;&amp; alloc) {
		lck_mtx_unlock(&amp;np-&gt;n_openlock);
		MALLOC(newnlop, <span class="enscript-type">struct</span> nfs_lock_owner *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_lock_owner), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (!newnlop)
			<span class="enscript-keyword">return</span> (NULL);
		bzero(newnlop, <span class="enscript-keyword">sizeof</span>(*newnlop));
		lck_mtx_init(&amp;newnlop-&gt;nlo_lock, nfs_open_grp, LCK_ATTR_NULL);
		newnlop-&gt;nlo_pid = pid;
		newnlop-&gt;nlo_pid_start = p-&gt;p_start;
		newnlop-&gt;nlo_name = OSAddAtomic(1, &amp;nfs_lock_owner_seqnum);
		TAILQ_INIT(&amp;newnlop-&gt;nlo_locks);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
	}
	<span class="enscript-keyword">if</span> (!nlop &amp;&amp; newnlop) {
		newnlop-&gt;nlo_flags |= NFS_LOCK_OWNER_LINK;
		TAILQ_INSERT_HEAD(&amp;np-&gt;n_lock_owners, newnlop, nlo_link);
		nlop = newnlop;
	}
	lck_mtx_unlock(&amp;np-&gt;n_openlock);

	<span class="enscript-keyword">if</span> (newnlop &amp;&amp; (nlop != newnlop))
		nfs_lock_owner_destroy(newnlop);

	<span class="enscript-keyword">if</span> (nlop)
		nfs_lock_owner_ref(nlop);

	<span class="enscript-keyword">return</span> (nlop);
}

<span class="enscript-comment">/*
 * destroy a lock owner that's no longer needed
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_lock_owner_destroy</span>(<span class="enscript-type">struct</span> nfs_lock_owner *nlop)
{
	<span class="enscript-keyword">if</span> (nlop-&gt;nlo_open_owner) {
		nfs_open_owner_rele(nlop-&gt;nlo_open_owner);
		nlop-&gt;nlo_open_owner = NULL;
	}
	lck_mtx_destroy(&amp;nlop-&gt;nlo_lock, nfs_open_grp);
	FREE(nlop, M_TEMP);
}

<span class="enscript-comment">/*
 * acquire a reference count on a lock owner
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_lock_owner_ref</span>(<span class="enscript-type">struct</span> nfs_lock_owner *nlop)
{
	lck_mtx_lock(&amp;nlop-&gt;nlo_lock);
	nlop-&gt;nlo_refcnt++;
	lck_mtx_unlock(&amp;nlop-&gt;nlo_lock);
}

<span class="enscript-comment">/*
 * drop a reference count on a lock owner and destroy it if
 * it is no longer referenced and no longer on the mount's list.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_lock_owner_rele</span>(<span class="enscript-type">struct</span> nfs_lock_owner *nlop)
{
	lck_mtx_lock(&amp;nlop-&gt;nlo_lock);
	<span class="enscript-keyword">if</span> (nlop-&gt;nlo_refcnt &lt; 1)
		panic(<span class="enscript-string">&quot;nfs_lock_owner_rele: no refcnt&quot;</span>);
	nlop-&gt;nlo_refcnt--;
	<span class="enscript-keyword">if</span> (!nlop-&gt;nlo_refcnt &amp;&amp; (nlop-&gt;nlo_flags &amp; NFS_LOCK_OWNER_BUSY))
		panic(<span class="enscript-string">&quot;nfs_lock_owner_rele: busy&quot;</span>);
	<span class="enscript-comment">/* XXX we may potentially want to clean up idle/unused lock owner structures */</span>
	<span class="enscript-keyword">if</span> (nlop-&gt;nlo_refcnt || (nlop-&gt;nlo_flags &amp; NFS_LOCK_OWNER_LINK)) {
		lck_mtx_unlock(&amp;nlop-&gt;nlo_lock);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">/* owner is no longer referenced or linked to mount, so destroy it */</span>
	lck_mtx_unlock(&amp;nlop-&gt;nlo_lock);
	nfs_lock_owner_destroy(nlop);
}

<span class="enscript-comment">/*
 * Mark a lock owner as busy because we are about to
 * start an operation that uses and updates lock owner state.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_lock_owner_set_busy</span>(<span class="enscript-type">struct</span> nfs_lock_owner *nlop, thread_t thd)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> timespec ts = {2, 0};
	<span class="enscript-type">int</span> error = 0, slpflag;

	nmp = nlop-&gt;nlo_open_owner-&gt;noo_mount;
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	slpflag = (NMFLAG(nmp, INTR) &amp;&amp; thd) ? PCATCH : 0;

	lck_mtx_lock(&amp;nlop-&gt;nlo_lock);
	<span class="enscript-keyword">while</span> (nlop-&gt;nlo_flags &amp; NFS_LOCK_OWNER_BUSY) {
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(nmp, NULL, thd, 0)))
			<span class="enscript-keyword">break</span>;
		nlop-&gt;nlo_flags |= NFS_LOCK_OWNER_WANT;
		msleep(nlop, &amp;nlop-&gt;nlo_lock, slpflag, <span class="enscript-string">&quot;nfs_lock_owner_set_busy&quot;</span>, &amp;ts);
		slpflag = 0;
	}
	<span class="enscript-keyword">if</span> (!error)
		nlop-&gt;nlo_flags |= NFS_LOCK_OWNER_BUSY;
	lck_mtx_unlock(&amp;nlop-&gt;nlo_lock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Clear the busy flag on a lock owner and wake up anyone waiting
 * to mark it busy.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_lock_owner_clear_busy</span>(<span class="enscript-type">struct</span> nfs_lock_owner *nlop)
{
	<span class="enscript-type">int</span> wanted;

	lck_mtx_lock(&amp;nlop-&gt;nlo_lock);
	<span class="enscript-keyword">if</span> (!(nlop-&gt;nlo_flags &amp; NFS_LOCK_OWNER_BUSY))
		panic(<span class="enscript-string">&quot;nfs_lock_owner_clear_busy&quot;</span>);
	wanted = (nlop-&gt;nlo_flags &amp; NFS_LOCK_OWNER_WANT);
	nlop-&gt;nlo_flags &amp;= ~(NFS_LOCK_OWNER_BUSY|NFS_LOCK_OWNER_WANT);
	lck_mtx_unlock(&amp;nlop-&gt;nlo_lock);
	<span class="enscript-keyword">if</span> (wanted)
		wakeup(nlop);
}

<span class="enscript-comment">/*
 * Insert a held lock into a lock owner's sorted list.
 * (flock locks are always inserted at the head the list)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_lock_owner_insert_held_lock</span>(<span class="enscript-type">struct</span> nfs_lock_owner *nlop, <span class="enscript-type">struct</span> nfs_file_lock *newnflp)
{
	<span class="enscript-type">struct</span> nfs_file_lock *nflp;

	<span class="enscript-comment">/* insert new lock in lock owner's held lock list */</span>
	lck_mtx_lock(&amp;nlop-&gt;nlo_lock);
	<span class="enscript-keyword">if</span> ((newnflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_MASK) == NFS_FILE_LOCK_STYLE_FLOCK) {
		TAILQ_INSERT_HEAD(&amp;nlop-&gt;nlo_locks, newnflp, nfl_lolink);
	} <span class="enscript-keyword">else</span> {
		TAILQ_FOREACH(nflp, &amp;nlop-&gt;nlo_locks, nfl_lolink) {
			<span class="enscript-keyword">if</span> (newnflp-&gt;nfl_start &lt; nflp-&gt;nfl_start)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (nflp)
			TAILQ_INSERT_BEFORE(nflp, newnflp, nfl_lolink);
		<span class="enscript-keyword">else</span>
			TAILQ_INSERT_TAIL(&amp;nlop-&gt;nlo_locks, newnflp, nfl_lolink);
	}
	lck_mtx_unlock(&amp;nlop-&gt;nlo_lock);
}

<span class="enscript-comment">/*
 * Get a file lock structure for this lock owner.
 */</span>
<span class="enscript-type">struct</span> nfs_file_lock *
<span class="enscript-function-name">nfs_file_lock_alloc</span>(<span class="enscript-type">struct</span> nfs_lock_owner *nlop)
{
	<span class="enscript-type">struct</span> nfs_file_lock *nflp = NULL;

	lck_mtx_lock(&amp;nlop-&gt;nlo_lock);
	<span class="enscript-keyword">if</span> (!nlop-&gt;nlo_alock.nfl_owner) {
		nflp = &amp;nlop-&gt;nlo_alock;
		nflp-&gt;nfl_owner = nlop;
	}
	lck_mtx_unlock(&amp;nlop-&gt;nlo_lock);
	<span class="enscript-keyword">if</span> (!nflp) {
		MALLOC(nflp, <span class="enscript-type">struct</span> nfs_file_lock *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_file_lock), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (!nflp)
			<span class="enscript-keyword">return</span> (NULL);
		bzero(nflp, <span class="enscript-keyword">sizeof</span>(*nflp));
		nflp-&gt;nfl_flags |= NFS_FILE_LOCK_ALLOC;
		nflp-&gt;nfl_owner = nlop;
	}
	nfs_lock_owner_ref(nlop);
	<span class="enscript-keyword">return</span> (nflp);
}

<span class="enscript-comment">/*
 * destroy the given NFS file lock structure
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_file_lock_destroy</span>(<span class="enscript-type">struct</span> nfs_file_lock *nflp)
{
	<span class="enscript-type">struct</span> nfs_lock_owner *nlop = nflp-&gt;nfl_owner;

	<span class="enscript-keyword">if</span> (nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_ALLOC) {
		nflp-&gt;nfl_owner = NULL;
		FREE(nflp, M_TEMP);
	} <span class="enscript-keyword">else</span> {
		lck_mtx_lock(&amp;nlop-&gt;nlo_lock);
		bzero(nflp, <span class="enscript-keyword">sizeof</span>(*nflp));
		lck_mtx_unlock(&amp;nlop-&gt;nlo_lock);
	}
	nfs_lock_owner_rele(nlop);
}

<span class="enscript-comment">/*
 * Check if one file lock conflicts with another.
 * (nflp1 is the new lock.  nflp2 is the existing lock.)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_file_lock_conflict</span>(<span class="enscript-type">struct</span> nfs_file_lock *nflp1, <span class="enscript-type">struct</span> nfs_file_lock *nflp2, <span class="enscript-type">int</span> *willsplit)
{
	<span class="enscript-comment">/* no conflict if lock is dead */</span>
	<span class="enscript-keyword">if</span> ((nflp1-&gt;nfl_flags &amp; NFS_FILE_LOCK_DEAD) || (nflp2-&gt;nfl_flags &amp; NFS_FILE_LOCK_DEAD))
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-comment">/* no conflict if it's ours - unless the lock style doesn't match */</span>
	<span class="enscript-keyword">if</span> ((nflp1-&gt;nfl_owner == nflp2-&gt;nfl_owner) &amp;&amp;
	    ((nflp1-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_MASK) == (nflp2-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_MASK))) {
		<span class="enscript-keyword">if</span> (willsplit &amp;&amp; (nflp1-&gt;nfl_type != nflp2-&gt;nfl_type) &amp;&amp;
		    (nflp1-&gt;nfl_start &gt; nflp2-&gt;nfl_start) &amp;&amp;
		    (nflp1-&gt;nfl_end &lt; nflp2-&gt;nfl_end))
			*willsplit = 1;
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-comment">/* no conflict if ranges don't overlap */</span>
	<span class="enscript-keyword">if</span> ((nflp1-&gt;nfl_start &gt; nflp2-&gt;nfl_end) || (nflp1-&gt;nfl_end &lt; nflp2-&gt;nfl_start))
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-comment">/* no conflict if neither lock is exclusive */</span>
	<span class="enscript-keyword">if</span> ((nflp1-&gt;nfl_type != F_WRLCK) &amp;&amp; (nflp2-&gt;nfl_type != F_WRLCK))
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-comment">/* conflict */</span>
	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * Send an NFSv4 LOCK RPC to the server.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_setlock_rpc</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_open_file *nofp,
	<span class="enscript-type">struct</span> nfs_file_lock *nflp,
	<span class="enscript-type">int</span> reclaim,
	<span class="enscript-type">int</span> flags,
	thread_t thd,
	kauth_cred_t cred)
{
	<span class="enscript-type">struct</span> nfs_lock_owner *nlop = nflp-&gt;nfl_owner;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	uint64_t xid;
	uint32_t locktype;
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, newlocker, numops, status;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);

	newlocker = (nlop-&gt;nlo_stategenid != nmp-&gt;nm_stategenid);
	locktype = (nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_WAIT) ?
			((nflp-&gt;nfl_type == F_WRLCK) ?
				NFS_LOCK_TYPE_WRITEW :
				NFS_LOCK_TYPE_READW) :
			((nflp-&gt;nfl_type == F_WRLCK) ?
				NFS_LOCK_TYPE_WRITE :
				NFS_LOCK_TYPE_READ);
	<span class="enscript-keyword">if</span> (newlocker) {
		error = nfs_open_file_set_busy(nofp, thd);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		error = nfs_open_owner_set_busy(nofp-&gt;nof_owner, thd);
		<span class="enscript-keyword">if</span> (error) {
			nfs_open_file_clear_busy(nofp);
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">if</span> (!nlop-&gt;nlo_open_owner) {
			nfs_open_owner_ref(nofp-&gt;nof_owner);
			nlop-&gt;nlo_open_owner = nofp-&gt;nof_owner;
		}
	}
	error = nfs_lock_owner_set_busy(nlop, thd);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (newlocker) {
			nfs_open_owner_clear_busy(nofp-&gt;nof_owner);
			nfs_open_file_clear_busy(nofp);
		}
		<span class="enscript-keyword">return</span> (error);
	}

	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, GETATTR, LOCK
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 33 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;lock&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, NFS_VER4, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, np);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_LOCK);
	nfsm_chain_add_32(error, &amp;nmreq, locktype);
	nfsm_chain_add_32(error, &amp;nmreq, reclaim);
	nfsm_chain_add_64(error, &amp;nmreq, nflp-&gt;nfl_start);
	nfsm_chain_add_64(error, &amp;nmreq, NFS_LOCK_LENGTH(nflp-&gt;nfl_start, nflp-&gt;nfl_end));
	nfsm_chain_add_32(error, &amp;nmreq, newlocker);
	<span class="enscript-keyword">if</span> (newlocker) {
		nfsm_chain_add_32(error, &amp;nmreq, nofp-&gt;nof_owner-&gt;noo_seqid);
		nfsm_chain_add_stateid(error, &amp;nmreq, &amp;nofp-&gt;nof_stateid);
		nfsm_chain_add_32(error, &amp;nmreq, nlop-&gt;nlo_seqid);
		nfsm_chain_add_lock_owner4(error, &amp;nmreq, nmp, nlop);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_stateid(error, &amp;nmreq, &amp;nlop-&gt;nlo_stateid);
		nfsm_chain_add_32(error, &amp;nmreq, nlop-&gt;nlo_seqid);
	}
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);

	error = nfs_request2(np, NULL, &amp;nmreq, NFSPROC4_COMPOUND, thd, cred, &amp;si, flags|R_NOINTR, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsm_chain_loadattr(error, &amp;nmrep, np, NFS_VER4, &amp;xid);
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_LOCK);
	nfs_owner_seqid_increment(newlocker ? nofp-&gt;nof_owner : NULL, nlop, error);
	nfsm_chain_get_stateid(error, &amp;nmrep, &amp;nlop-&gt;nlo_stateid);

	<span class="enscript-comment">/* Update the lock owner's stategenid once it appears the server has state for it. */</span>
	<span class="enscript-comment">/* We determine this by noting the request was successful (we got a stateid). */</span>
	<span class="enscript-keyword">if</span> (newlocker &amp;&amp; !error)
		nlop-&gt;nlo_stategenid = nmp-&gt;nm_stategenid;
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfs_lock_owner_clear_busy(nlop);
	<span class="enscript-keyword">if</span> (newlocker) {
		nfs_open_owner_clear_busy(nofp-&gt;nof_owner);
		nfs_open_file_clear_busy(nofp);
	}
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Send an NFSv4 LOCKU RPC to the server.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_unlock_rpc</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_lock_owner *nlop,
	<span class="enscript-type">int</span> type,
	uint64_t start,
	uint64_t end,
	<span class="enscript-type">int</span> flags,
	thread_t thd,
	kauth_cred_t cred)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	uint64_t xid;
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, numops, status;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);

	error = nfs_lock_owner_set_busy(nlop, NULL);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, GETATTR, LOCKU
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 26 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;unlock&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, NFS_VER4, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, np);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_LOCKU);
	nfsm_chain_add_32(error, &amp;nmreq, (type == F_WRLCK) ? NFS_LOCK_TYPE_WRITE : NFS_LOCK_TYPE_READ);
	nfsm_chain_add_32(error, &amp;nmreq, nlop-&gt;nlo_seqid);
	nfsm_chain_add_stateid(error, &amp;nmreq, &amp;nlop-&gt;nlo_stateid);
	nfsm_chain_add_64(error, &amp;nmreq, start);
	nfsm_chain_add_64(error, &amp;nmreq, NFS_LOCK_LENGTH(start, end));
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);

	error = nfs_request2(np, NULL, &amp;nmreq, NFSPROC4_COMPOUND, thd, cred, &amp;si, flags|R_NOINTR, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsm_chain_loadattr(error, &amp;nmrep, np, NFS_VER4, &amp;xid);
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_LOCKU);
	nfs_owner_seqid_increment(NULL, nlop, error);
	nfsm_chain_get_stateid(error, &amp;nmrep, &amp;nlop-&gt;nlo_stateid);
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfs_lock_owner_clear_busy(nlop);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Send an NFSv4 LOCKT RPC to the server.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_getlock_rpc</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_lock_owner *nlop,
	<span class="enscript-type">struct</span> flock *fl,
	uint64_t start,
	uint64_t end,
	vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	uint64_t xid, val64 = 0;
	uint32_t val = 0;
	<span class="enscript-type">int</span> error = 0, lockerror, numops, status;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);

	lockerror = ENOENT;
	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, GETATTR, LOCKT
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 26 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;locktest&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, NFS_VER4, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, np);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_LOCKT);
	nfsm_chain_add_32(error, &amp;nmreq, (fl-&gt;l_type == F_WRLCK) ? NFS_LOCK_TYPE_WRITE : NFS_LOCK_TYPE_READ);
	nfsm_chain_add_64(error, &amp;nmreq, start);
	nfsm_chain_add_64(error, &amp;nmreq, NFS_LOCK_LENGTH(start, end));
	nfsm_chain_add_lock_owner4(error, &amp;nmreq, nmp, nlop);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);

	error = nfs_request(np, NULL, &amp;nmreq, NFSPROC4_COMPOUND, ctx, &amp;si, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsm_chain_loadattr(error, &amp;nmrep, np, NFS_VER4, &amp;xid);
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_LOCKT);
	<span class="enscript-keyword">if</span> (error == NFSERR_DENIED) {
		error = 0;
		nfsm_chain_get_64(error, &amp;nmrep, fl-&gt;l_start);
		nfsm_chain_get_64(error, &amp;nmrep, val64);
		fl-&gt;l_len = (val64 == UINT64_MAX) ? 0 : val64;
		nfsm_chain_get_32(error, &amp;nmrep, val);
		fl-&gt;l_type = (val == NFS_LOCK_TYPE_WRITE) ? F_WRLCK : F_RDLCK;
		fl-&gt;l_pid = 0;
		fl-&gt;l_whence = SEEK_SET;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!error) {
		fl-&gt;l_type = F_UNLCK;
	}
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Check for any conflicts with the given lock.
 *
 * Checking for a lock doesn't require the file to be opened.
 * So we skip all the open owner, open file, lock owner work
 * and just check for a conflicting lock.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_advlock_getlock</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_lock_owner *nlop,
	<span class="enscript-type">struct</span> flock *fl,
	uint64_t start,
	uint64_t end,
	vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_file_lock *nflp;
	<span class="enscript-type">int</span> error = 0, answered = 0;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

<span class="enscript-reference">restart</span>:
	<span class="enscript-keyword">if</span> ((error = nfs_mount_state_in_use_start(nmp, vfs_context_thread(ctx))))
		<span class="enscript-keyword">return</span> (error);

	lck_mtx_lock(&amp;np-&gt;n_openlock);
	<span class="enscript-comment">/* scan currently held locks for conflict */</span>
	TAILQ_FOREACH(nflp, &amp;np-&gt;n_locks, nfl_link) {
		<span class="enscript-keyword">if</span> (nflp-&gt;nfl_flags &amp; (NFS_FILE_LOCK_BLOCKED|NFS_FILE_LOCK_DEAD))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> ((start &lt;= nflp-&gt;nfl_end) &amp;&amp; (end &gt;= nflp-&gt;nfl_start) &amp;&amp;
		    ((fl-&gt;l_type == F_WRLCK) || (nflp-&gt;nfl_type == F_WRLCK)))
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (nflp) {
		<span class="enscript-comment">/* found a conflicting lock */</span>
		fl-&gt;l_type = nflp-&gt;nfl_type;
		fl-&gt;l_pid = (nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_FLOCK) ? -1 : nflp-&gt;nfl_owner-&gt;nlo_pid;
		fl-&gt;l_start = nflp-&gt;nfl_start;
		fl-&gt;l_len = NFS_FLOCK_LENGTH(nflp-&gt;nfl_start, nflp-&gt;nfl_end);
		fl-&gt;l_whence = SEEK_SET;
		answered = 1;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((np-&gt;n_openflags &amp; N_DELEG_WRITE) &amp;&amp; !(np-&gt;n_openflags &amp; N_DELEG_RETURN)) {
		<span class="enscript-comment">/*
		 * If we have a write delegation, we know there can't be other
		 * locks on the server.  So the answer is no conflicting lock found.
		 */</span>
		fl-&gt;l_type = F_UNLCK;
		answered = 1;
	}
	lck_mtx_unlock(&amp;np-&gt;n_openlock);
	<span class="enscript-keyword">if</span> (answered) {
		nfs_mount_state_in_use_end(nmp, 0);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* no conflict found locally, so ask the server */</span>
	error = nmp-&gt;nm_funcs-&gt;nf_getlock_rpc(np, nlop, fl, start, end, ctx);

	<span class="enscript-keyword">if</span> (nfs_mount_state_in_use_end(nmp, error))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Acquire a file lock for the given range.
 *
 * Add the lock (request) to the lock queue.
 * Scan the lock queue for any conflicting locks.
 * If a conflict is found, block or return an error.
 * Once end of queue is reached, send request to the server.
 * If the server grants the lock, scan the lock queue and
 * update any existing locks.  Then (optionally) scan the
 * queue again to coalesce any locks adjacent to the new one.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_advlock_setlock</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_open_file *nofp,
	<span class="enscript-type">struct</span> nfs_lock_owner *nlop,
	<span class="enscript-type">int</span> op,
	uint64_t start,
	uint64_t end,
	<span class="enscript-type">int</span> style,
	<span class="enscript-type">short</span> type,
	vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_file_lock *newnflp, *nflp, *nflp2 = NULL, *nextnflp, *flocknflp = NULL;
	<span class="enscript-type">struct</span> nfs_file_lock *coalnflp;
	<span class="enscript-type">int</span> error = 0, error2, willsplit = 0, delay, slpflag, busy = 0, inuse = 0, restart, inqueue = 0;
	<span class="enscript-type">struct</span> timespec ts = {1, 0};

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	slpflag = NMFLAG(nmp, INTR) ? PCATCH : 0;

	<span class="enscript-keyword">if</span> ((type != F_RDLCK) &amp;&amp; (type != F_WRLCK))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* allocate a new lock */</span>
	newnflp = nfs_file_lock_alloc(nlop);
	<span class="enscript-keyword">if</span> (!newnflp)
		<span class="enscript-keyword">return</span> (ENOLCK);
	newnflp-&gt;nfl_start = start;
	newnflp-&gt;nfl_end = end;
	newnflp-&gt;nfl_type = type;
	<span class="enscript-keyword">if</span> (op == F_SETLKW)
		newnflp-&gt;nfl_flags |= NFS_FILE_LOCK_WAIT;
	newnflp-&gt;nfl_flags |= style;
	newnflp-&gt;nfl_flags |= NFS_FILE_LOCK_BLOCKED;

	<span class="enscript-keyword">if</span> ((style == NFS_FILE_LOCK_STYLE_FLOCK) &amp;&amp; (type == F_WRLCK)) {
		<span class="enscript-comment">/*
		 * For exclusive flock-style locks, if we block waiting for the
		 * lock, we need to first release any currently held shared
		 * flock-style lock.  So, the first thing we do is check if we
		 * have a shared flock-style lock.
		 */</span>
		nflp = TAILQ_FIRST(&amp;nlop-&gt;nlo_locks);
		<span class="enscript-keyword">if</span> (nflp &amp;&amp; ((nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_MASK) != NFS_FILE_LOCK_STYLE_FLOCK))
			nflp = NULL;
		<span class="enscript-keyword">if</span> (nflp &amp;&amp; (nflp-&gt;nfl_type != F_RDLCK))
			nflp = NULL;
		flocknflp = nflp;
	}

<span class="enscript-reference">restart</span>:
	restart = 0;
	error = nfs_mount_state_in_use_start(nmp, vfs_context_thread(ctx));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_out</span>;
	inuse = 1;
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
		error = EIO;
		nfs_mount_state_in_use_end(nmp, 0);
		inuse = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_out</span>;
	}
	<span class="enscript-keyword">if</span> (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN) {
		nfs_mount_state_in_use_end(nmp, 0);
		inuse = 0;
		error = nfs4_reopen(nofp, vfs_context_thread(ctx));
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_out</span>;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}

	lck_mtx_lock(&amp;np-&gt;n_openlock);
	<span class="enscript-keyword">if</span> (!inqueue) {
		<span class="enscript-comment">/* insert new lock at beginning of list */</span>
		TAILQ_INSERT_HEAD(&amp;np-&gt;n_locks, newnflp, nfl_link);
		inqueue = 1;
	}

	<span class="enscript-comment">/* scan current list of locks (held and pending) for conflicts */</span>
	<span class="enscript-keyword">for</span> (nflp = TAILQ_NEXT(newnflp, nfl_link); nflp; nflp = nextnflp) {
		nextnflp = TAILQ_NEXT(nflp, nfl_link);
		<span class="enscript-keyword">if</span> (!nfs_file_lock_conflict(newnflp, nflp, &amp;willsplit))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-comment">/* Conflict */</span>
		<span class="enscript-keyword">if</span> (!(newnflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_WAIT)) {
			error = EAGAIN;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* Block until this lock is no longer held. */</span>
		<span class="enscript-keyword">if</span> (nflp-&gt;nfl_blockcnt == UINT_MAX) {
			error = ENOLCK;
			<span class="enscript-keyword">break</span>;
		}
		nflp-&gt;nfl_blockcnt++;
		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> (flocknflp) {
				<span class="enscript-comment">/* release any currently held shared lock before sleeping */</span>
				lck_mtx_unlock(&amp;np-&gt;n_openlock);
				nfs_mount_state_in_use_end(nmp, 0);
				inuse = 0;
				error = nfs_advlock_unlock(np, nofp, nlop, 0, UINT64_MAX, NFS_FILE_LOCK_STYLE_FLOCK, ctx);
				flocknflp = NULL;
				<span class="enscript-keyword">if</span> (!error)
					error = nfs_mount_state_in_use_start(nmp, vfs_context_thread(ctx));
				<span class="enscript-keyword">if</span> (error) {
					lck_mtx_lock(&amp;np-&gt;n_openlock);
					<span class="enscript-keyword">break</span>;
				}
				inuse = 1;
				lck_mtx_lock(&amp;np-&gt;n_openlock);
				<span class="enscript-comment">/* no need to block/sleep if the conflict is gone */</span>
				<span class="enscript-keyword">if</span> (!nfs_file_lock_conflict(newnflp, nflp, NULL))
					<span class="enscript-keyword">break</span>;
			}
			msleep(nflp, &amp;np-&gt;n_openlock, slpflag, <span class="enscript-string">&quot;nfs_advlock_setlock_blocked&quot;</span>, &amp;ts);
			slpflag = 0;
			error = nfs_sigintr(NFSTONMP(np), NULL, vfs_context_thread(ctx), 0);
			<span class="enscript-keyword">if</span> (!error &amp;&amp; (nmp-&gt;nm_state &amp; NFSSTA_RECOVER)) {
				<span class="enscript-comment">/* looks like we have a recover pending... restart */</span>
				restart = 1;
				lck_mtx_unlock(&amp;np-&gt;n_openlock);
				nfs_mount_state_in_use_end(nmp, 0);
				inuse = 0;
				lck_mtx_lock(&amp;np-&gt;n_openlock);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (!error &amp;&amp; (np-&gt;n_flag &amp; NREVOKE))
				error = EIO;
		} <span class="enscript-keyword">while</span> (!error &amp;&amp; nfs_file_lock_conflict(newnflp, nflp, NULL));
		nflp-&gt;nfl_blockcnt--;
		<span class="enscript-keyword">if</span> ((nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_DEAD) &amp;&amp; !nflp-&gt;nfl_blockcnt) {
			TAILQ_REMOVE(&amp;np-&gt;n_locks, nflp, nfl_link);
			nfs_file_lock_destroy(nflp);
		}
		<span class="enscript-keyword">if</span> (error || restart)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* We have released n_openlock and we can't trust that nextnflp is still valid. */</span>
		<span class="enscript-comment">/* So, start this lock-scanning loop over from where it started. */</span>
		nextnflp = TAILQ_NEXT(newnflp, nfl_link);
	}
	lck_mtx_unlock(&amp;np-&gt;n_openlock);
	<span class="enscript-keyword">if</span> (restart)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_out</span>;

	<span class="enscript-keyword">if</span> (willsplit) {
		<span class="enscript-comment">/*
		 * It looks like this operation is splitting a lock.
		 * We allocate a new lock now so we don't have to worry
		 * about the allocation failing after we've updated some state.
		 */</span>
		nflp2 = nfs_file_lock_alloc(nlop);
		<span class="enscript-keyword">if</span> (!nflp2) {
			error = ENOLCK;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_out</span>;
		}
	}

	<span class="enscript-comment">/* once scan for local conflicts is clear, send request to server */</span>
	<span class="enscript-keyword">if</span> ((error = nfs_open_state_set_busy(np, vfs_context_thread(ctx))))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">error_out</span>;
	busy = 1;
	delay = 0;
	<span class="enscript-keyword">do</span> {
		<span class="enscript-comment">/* do we have a delegation? (that we're not returning?) */</span>
		<span class="enscript-keyword">if</span> ((np-&gt;n_openflags &amp; N_DELEG_MASK) &amp;&amp; !(np-&gt;n_openflags &amp; N_DELEG_RETURN)) {
			<span class="enscript-keyword">if</span> (np-&gt;n_openflags &amp; N_DELEG_WRITE) {
				<span class="enscript-comment">/* with a write delegation, just take the lock delegated */</span>
				newnflp-&gt;nfl_flags |= NFS_FILE_LOCK_DELEGATED;
				error = 0;
				<span class="enscript-comment">/* make sure the lock owner knows its open owner */</span>
				<span class="enscript-keyword">if</span> (!nlop-&gt;nlo_open_owner) {
					nfs_open_owner_ref(nofp-&gt;nof_owner);
					nlop-&gt;nlo_open_owner = nofp-&gt;nof_owner;
				}
				<span class="enscript-keyword">break</span>;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * If we don't have any non-delegated opens but we do have
				 * delegated opens, then we need to first claim the delegated
				 * opens so that the lock request on the server can be associated
				 * with an open it knows about.
				 */</span>
				<span class="enscript-keyword">if</span> ((!nofp-&gt;nof_rw_drw &amp;&amp; !nofp-&gt;nof_w_drw &amp;&amp; !nofp-&gt;nof_r_drw &amp;&amp;
				     !nofp-&gt;nof_rw_dw &amp;&amp; !nofp-&gt;nof_w_dw &amp;&amp; !nofp-&gt;nof_r_dw &amp;&amp;
				     !nofp-&gt;nof_rw &amp;&amp; !nofp-&gt;nof_w &amp;&amp; !nofp-&gt;nof_r) &amp;&amp;
				    (nofp-&gt;nof_d_rw_drw || nofp-&gt;nof_d_w_drw || nofp-&gt;nof_d_r_drw ||
				     nofp-&gt;nof_d_rw_dw || nofp-&gt;nof_d_w_dw || nofp-&gt;nof_d_r_dw ||
				     nofp-&gt;nof_d_rw || nofp-&gt;nof_d_w || nofp-&gt;nof_d_r)) {
					error = nfs4_claim_delegated_state_for_open_file(nofp, 0);
					<span class="enscript-keyword">if</span> (error)
						<span class="enscript-keyword">break</span>;
				}
			}
		}
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE)
			error = EIO;
		<span class="enscript-keyword">if</span> (!error)
			error = nmp-&gt;nm_funcs-&gt;nf_setlock_rpc(np, nofp, newnflp, 0, 0, vfs_context_thread(ctx), vfs_context_ucred(ctx));
		<span class="enscript-keyword">if</span> (!error || ((error != NFSERR_DENIED) &amp;&amp; (error != NFSERR_GRACE)))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* request was denied due to either conflict or grace period */</span>
		<span class="enscript-keyword">if</span> ((error == NFSERR_DENIED) &amp;&amp; !(newnflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_WAIT)) {
			error = EAGAIN;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (flocknflp) {
			<span class="enscript-comment">/* release any currently held shared lock before sleeping */</span>
			nfs_open_state_clear_busy(np);
			busy = 0;
			nfs_mount_state_in_use_end(nmp, 0);
			inuse = 0;
			error2 = nfs_advlock_unlock(np, nofp, nlop, 0, UINT64_MAX, NFS_FILE_LOCK_STYLE_FLOCK, ctx);
			flocknflp = NULL;
			<span class="enscript-keyword">if</span> (!error2)
				error2 = nfs_mount_state_in_use_start(nmp, vfs_context_thread(ctx));
			<span class="enscript-keyword">if</span> (!error2) {
				inuse = 1;
				error2 = nfs_open_state_set_busy(np, vfs_context_thread(ctx));
			}
			<span class="enscript-keyword">if</span> (error2) {
				error = error2;
				<span class="enscript-keyword">break</span>;
			}
			busy = 1;
		}
		<span class="enscript-comment">/*
		 * Wait a little bit and send the request again.
		 * Except for retries of blocked v2/v3 request where we've already waited a bit.
		 */</span>
		<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) || (error == NFSERR_GRACE)) {
			<span class="enscript-keyword">if</span> (error == NFSERR_GRACE)
				delay = 4;
			<span class="enscript-keyword">if</span> (delay &lt; 4)
				delay++;
			tsleep(newnflp, slpflag, <span class="enscript-string">&quot;nfs_advlock_setlock_delay&quot;</span>, delay * (hz/2));
			slpflag = 0;
		}
		error = nfs_sigintr(NFSTONMP(np), NULL, vfs_context_thread(ctx), 0);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; (nmp-&gt;nm_state &amp; NFSSTA_RECOVER)) {
			<span class="enscript-comment">/* looks like we have a recover pending... restart */</span>
			nfs_open_state_clear_busy(np);
			busy = 0;
			nfs_mount_state_in_use_end(nmp, 0);
			inuse = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		}
		<span class="enscript-keyword">if</span> (!error &amp;&amp; (np-&gt;n_flag &amp; NREVOKE))
			error = EIO;
	} <span class="enscript-keyword">while</span> (!error);

<span class="enscript-reference">error_out</span>:
	<span class="enscript-keyword">if</span> (nfs_mount_state_error_should_restart(error)) {
		<span class="enscript-comment">/* looks like we need to restart this operation */</span>
		<span class="enscript-keyword">if</span> (busy) {
			nfs_open_state_clear_busy(np);
			busy = 0;
		}
		<span class="enscript-keyword">if</span> (inuse) {
			nfs_mount_state_in_use_end(nmp, error);
			inuse = 0;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}
	lck_mtx_lock(&amp;np-&gt;n_openlock);
	newnflp-&gt;nfl_flags &amp;= ~NFS_FILE_LOCK_BLOCKED;
	<span class="enscript-keyword">if</span> (error) {
		newnflp-&gt;nfl_flags |= NFS_FILE_LOCK_DEAD;
		<span class="enscript-keyword">if</span> (newnflp-&gt;nfl_blockcnt) {
			<span class="enscript-comment">/* wake up anyone blocked on this lock */</span>
			wakeup(newnflp);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* remove newnflp from lock list and destroy */</span>
			<span class="enscript-keyword">if</span> (inqueue)
				TAILQ_REMOVE(&amp;np-&gt;n_locks, newnflp, nfl_link);
			nfs_file_lock_destroy(newnflp);
		}
		lck_mtx_unlock(&amp;np-&gt;n_openlock);
		<span class="enscript-keyword">if</span> (busy)
			nfs_open_state_clear_busy(np);
		<span class="enscript-keyword">if</span> (inuse)
			nfs_mount_state_in_use_end(nmp, error);
		<span class="enscript-keyword">if</span> (nflp2)
			nfs_file_lock_destroy(nflp2);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* server granted the lock */</span>

	<span class="enscript-comment">/*
	 * Scan for locks to update.
	 *
	 * Locks completely covered are killed.
	 * At most two locks may need to be clipped.
	 * It's possible that a single lock may need to be split.
	 */</span>
	TAILQ_FOREACH_SAFE(nflp, &amp;np-&gt;n_locks, nfl_link, nextnflp) {
		<span class="enscript-keyword">if</span> (nflp == newnflp)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (nflp-&gt;nfl_flags &amp; (NFS_FILE_LOCK_BLOCKED|NFS_FILE_LOCK_DEAD))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (nflp-&gt;nfl_owner != nlop)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> ((newnflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_MASK) != (nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_MASK))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> ((newnflp-&gt;nfl_start &gt; nflp-&gt;nfl_end) || (newnflp-&gt;nfl_end &lt; nflp-&gt;nfl_start))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-comment">/* here's one to update */</span>
		<span class="enscript-keyword">if</span> ((newnflp-&gt;nfl_start &lt;= nflp-&gt;nfl_start) &amp;&amp; (newnflp-&gt;nfl_end &gt;= nflp-&gt;nfl_end)) {
			<span class="enscript-comment">/* The entire lock is being replaced. */</span>
			nflp-&gt;nfl_flags |= NFS_FILE_LOCK_DEAD;
			lck_mtx_lock(&amp;nlop-&gt;nlo_lock);
			TAILQ_REMOVE(&amp;nlop-&gt;nlo_locks, nflp, nfl_lolink);
			lck_mtx_unlock(&amp;nlop-&gt;nlo_lock);
			<span class="enscript-comment">/* lock will be destroyed below, if no waiters */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((newnflp-&gt;nfl_start &gt; nflp-&gt;nfl_start) &amp;&amp; (newnflp-&gt;nfl_end &lt; nflp-&gt;nfl_end)) {
			<span class="enscript-comment">/* We're replacing a range in the middle of a lock. */</span>
			<span class="enscript-comment">/* The current lock will be split into two locks. */</span>
			<span class="enscript-comment">/* Update locks and insert new lock after current lock. */</span>
			nflp2-&gt;nfl_flags |= (nflp-&gt;nfl_flags &amp; (NFS_FILE_LOCK_STYLE_MASK|NFS_FILE_LOCK_DELEGATED));
			nflp2-&gt;nfl_type = nflp-&gt;nfl_type;
			nflp2-&gt;nfl_start = newnflp-&gt;nfl_end + 1;
			nflp2-&gt;nfl_end = nflp-&gt;nfl_end;
			nflp-&gt;nfl_end = newnflp-&gt;nfl_start - 1;
			TAILQ_INSERT_AFTER(&amp;np-&gt;n_locks, nflp, nflp2, nfl_link);
			nfs_lock_owner_insert_held_lock(nlop, nflp2);
			nextnflp = nflp2;
			nflp2 = NULL;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (newnflp-&gt;nfl_start &gt; nflp-&gt;nfl_start) {
			<span class="enscript-comment">/* We're replacing the end of a lock. */</span>
			nflp-&gt;nfl_end = newnflp-&gt;nfl_start - 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (newnflp-&gt;nfl_end &lt; nflp-&gt;nfl_end) {
			<span class="enscript-comment">/* We're replacing the start of a lock. */</span>
			nflp-&gt;nfl_start = newnflp-&gt;nfl_end + 1;
		}
		<span class="enscript-keyword">if</span> (nflp-&gt;nfl_blockcnt) {
			<span class="enscript-comment">/* wake up anyone blocked on this lock */</span>
			wakeup(nflp);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_DEAD) {
			<span class="enscript-comment">/* remove nflp from lock list and destroy */</span>
			TAILQ_REMOVE(&amp;np-&gt;n_locks, nflp, nfl_link);
			nfs_file_lock_destroy(nflp);
		}
	}

	nfs_lock_owner_insert_held_lock(nlop, newnflp);

	<span class="enscript-comment">/*
	 * POSIX locks should be coalesced when possible.
	 */</span>
	<span class="enscript-keyword">if</span> ((style == NFS_FILE_LOCK_STYLE_POSIX) &amp;&amp; (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_POSIXLOCK)) {
		<span class="enscript-comment">/*
		 * Walk through the lock queue and check each of our held locks with
		 * the previous and next locks in the lock owner's &quot;held lock list&quot;.
		 * If the two locks can be coalesced, we merge the current lock into
		 * the other (previous or next) lock.  Merging this way makes sure that
		 * lock ranges are always merged forward in the lock queue.  This is
		 * important because anyone blocked on the lock being &quot;merged away&quot;
		 * will still need to block on that range and it will simply continue
		 * checking locks that are further down the list.
		 */</span>
		TAILQ_FOREACH_SAFE(nflp, &amp;np-&gt;n_locks, nfl_link, nextnflp) {
			<span class="enscript-keyword">if</span> (nflp-&gt;nfl_flags &amp; (NFS_FILE_LOCK_BLOCKED|NFS_FILE_LOCK_DEAD))
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (nflp-&gt;nfl_owner != nlop)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> ((nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_MASK) != NFS_FILE_LOCK_STYLE_POSIX)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (((coalnflp = TAILQ_PREV(nflp, nfs_file_lock_queue, nfl_lolink))) &amp;&amp;
			    ((coalnflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_MASK) == NFS_FILE_LOCK_STYLE_POSIX) &amp;&amp;
			    (coalnflp-&gt;nfl_type == nflp-&gt;nfl_type) &amp;&amp;
			    (coalnflp-&gt;nfl_end == (nflp-&gt;nfl_start - 1))) {
				coalnflp-&gt;nfl_end = nflp-&gt;nfl_end;
				nflp-&gt;nfl_flags |= NFS_FILE_LOCK_DEAD;
				lck_mtx_lock(&amp;nlop-&gt;nlo_lock);
				TAILQ_REMOVE(&amp;nlop-&gt;nlo_locks, nflp, nfl_lolink);
				lck_mtx_unlock(&amp;nlop-&gt;nlo_lock);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (((coalnflp = TAILQ_NEXT(nflp, nfl_lolink))) &amp;&amp;
			    ((coalnflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_MASK) == NFS_FILE_LOCK_STYLE_POSIX) &amp;&amp;
			    (coalnflp-&gt;nfl_type == nflp-&gt;nfl_type) &amp;&amp;
			    (coalnflp-&gt;nfl_start == (nflp-&gt;nfl_end + 1))) {
				coalnflp-&gt;nfl_start = nflp-&gt;nfl_start;
				nflp-&gt;nfl_flags |= NFS_FILE_LOCK_DEAD;
				lck_mtx_lock(&amp;nlop-&gt;nlo_lock);
				TAILQ_REMOVE(&amp;nlop-&gt;nlo_locks, nflp, nfl_lolink);
				lck_mtx_unlock(&amp;nlop-&gt;nlo_lock);
			}
			<span class="enscript-keyword">if</span> (!(nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_DEAD))
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (nflp-&gt;nfl_blockcnt) {
				<span class="enscript-comment">/* wake up anyone blocked on this lock */</span>
				wakeup(nflp);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* remove nflp from lock list and destroy */</span>
				TAILQ_REMOVE(&amp;np-&gt;n_locks, nflp, nfl_link);
				nfs_file_lock_destroy(nflp);
			}
		}
	}

	lck_mtx_unlock(&amp;np-&gt;n_openlock);
	nfs_open_state_clear_busy(np);
	nfs_mount_state_in_use_end(nmp, error);

	<span class="enscript-keyword">if</span> (nflp2)
		nfs_file_lock_destroy(nflp2);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Release all (same style) locks within the given range.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_advlock_unlock</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_open_file *nofp,
	<span class="enscript-type">struct</span> nfs_lock_owner *nlop,
	uint64_t start,
	uint64_t end,
	<span class="enscript-type">int</span> style,
	vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_file_lock *nflp, *nextnflp, *newnflp = NULL;
	<span class="enscript-type">int</span> error = 0, willsplit = 0, send_unlock_rpcs = 1;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

<span class="enscript-reference">restart</span>:
	<span class="enscript-keyword">if</span> ((error = nfs_mount_state_in_use_start(nmp, NULL)))
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN) {
		nfs_mount_state_in_use_end(nmp, 0);
		error = nfs4_reopen(nofp, NULL);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}
	<span class="enscript-keyword">if</span> ((error = nfs_open_state_set_busy(np, NULL))) {
		nfs_mount_state_in_use_end(nmp, error);
		<span class="enscript-keyword">return</span> (error);
	}

	lck_mtx_lock(&amp;np-&gt;n_openlock);
	<span class="enscript-keyword">if</span> ((start &gt; 0) &amp;&amp; (end &lt; UINT64_MAX) &amp;&amp; !willsplit) {
		<span class="enscript-comment">/*
		 * We may need to allocate a new lock if an existing lock gets split.
		 * So, we first scan the list to check for a split, and if there's
		 * going to be one, we'll allocate one now.
		 */</span>
		TAILQ_FOREACH_SAFE(nflp, &amp;np-&gt;n_locks, nfl_link, nextnflp) {
			<span class="enscript-keyword">if</span> (nflp-&gt;nfl_flags &amp; (NFS_FILE_LOCK_BLOCKED|NFS_FILE_LOCK_DEAD))
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (nflp-&gt;nfl_owner != nlop)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> ((nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_MASK) != style)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> ((start &gt; nflp-&gt;nfl_end) || (end &lt; nflp-&gt;nfl_start))
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> ((start &gt; nflp-&gt;nfl_start) &amp;&amp; (end &lt; nflp-&gt;nfl_end)) {
				willsplit = 1;
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (willsplit) {
			lck_mtx_unlock(&amp;np-&gt;n_openlock);
			nfs_open_state_clear_busy(np);
			nfs_mount_state_in_use_end(nmp, 0);
			newnflp = nfs_file_lock_alloc(nlop);
			<span class="enscript-keyword">if</span> (!newnflp)
				<span class="enscript-keyword">return</span> (ENOMEM);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		}
	}

	<span class="enscript-comment">/*
	 * Free all of our locks in the given range.
	 *
	 * Note that this process requires sending requests to the server.
	 * Because of this, we will release the n_openlock while performing 
	 * the unlock RPCs.  The N_OPENBUSY state keeps the state of *held*
	 * locks from changing underneath us.  However, other entries in the
	 * list may be removed.  So we need to be careful walking the list.
	 */</span>

	<span class="enscript-comment">/*
	 * Don't unlock ranges that are held by other-style locks.
	 * If style is posix, don't send any unlock rpcs if flock is held.
	 * If we unlock an flock, don't send unlock rpcs for any posix-style
	 * ranges held - instead send unlocks for the ranges not held.
	 */</span>
	<span class="enscript-keyword">if</span> ((style == NFS_FILE_LOCK_STYLE_POSIX) &amp;&amp;
	    ((nflp = TAILQ_FIRST(&amp;nlop-&gt;nlo_locks))) &amp;&amp;
	    ((nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_MASK) == NFS_FILE_LOCK_STYLE_FLOCK))
		send_unlock_rpcs = 0;
	<span class="enscript-keyword">if</span> ((style == NFS_FILE_LOCK_STYLE_FLOCK) &amp;&amp;
	    ((nflp = TAILQ_FIRST(&amp;nlop-&gt;nlo_locks))) &amp;&amp;
	    ((nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_MASK) == NFS_FILE_LOCK_STYLE_FLOCK) &amp;&amp;
	    ((nflp = TAILQ_NEXT(nflp, nfl_lolink))) &amp;&amp;
	    ((nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_MASK) == NFS_FILE_LOCK_STYLE_POSIX)) {
		uint64_t s = 0;
		<span class="enscript-type">int</span> type = TAILQ_FIRST(&amp;nlop-&gt;nlo_locks)-&gt;nfl_type;
		<span class="enscript-type">int</span> delegated = (TAILQ_FIRST(&amp;nlop-&gt;nlo_locks)-&gt;nfl_flags &amp; NFS_FILE_LOCK_DELEGATED);
		<span class="enscript-keyword">while</span> (!delegated &amp;&amp; nflp) {
			<span class="enscript-keyword">if</span> ((nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_MASK) == NFS_FILE_LOCK_STYLE_POSIX) {
				<span class="enscript-comment">/* unlock the range preceding this lock */</span>
				lck_mtx_unlock(&amp;np-&gt;n_openlock);
				error = nmp-&gt;nm_funcs-&gt;nf_unlock_rpc(np, nlop, type, s, nflp-&gt;nfl_start-1, 0,
						vfs_context_thread(ctx), vfs_context_ucred(ctx));
				<span class="enscript-keyword">if</span> (nfs_mount_state_error_should_restart(error)) {
					nfs_open_state_clear_busy(np);
					nfs_mount_state_in_use_end(nmp, error);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
				}
				lck_mtx_lock(&amp;np-&gt;n_openlock);
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				s = nflp-&gt;nfl_end+1;
			}
			nflp = TAILQ_NEXT(nflp, nfl_lolink);
		}
		<span class="enscript-keyword">if</span> (!delegated) {
			lck_mtx_unlock(&amp;np-&gt;n_openlock);
			error = nmp-&gt;nm_funcs-&gt;nf_unlock_rpc(np, nlop, type, s, end, 0,
					vfs_context_thread(ctx), vfs_context_ucred(ctx));
			<span class="enscript-keyword">if</span> (nfs_mount_state_error_should_restart(error)) {
				nfs_open_state_clear_busy(np);
				nfs_mount_state_in_use_end(nmp, error);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
			}
			lck_mtx_lock(&amp;np-&gt;n_openlock);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		send_unlock_rpcs = 0;
	}

	TAILQ_FOREACH_SAFE(nflp, &amp;np-&gt;n_locks, nfl_link, nextnflp) {
		<span class="enscript-keyword">if</span> (nflp-&gt;nfl_flags &amp; (NFS_FILE_LOCK_BLOCKED|NFS_FILE_LOCK_DEAD))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (nflp-&gt;nfl_owner != nlop)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> ((nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_STYLE_MASK) != style)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> ((start &gt; nflp-&gt;nfl_end) || (end &lt; nflp-&gt;nfl_start))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-comment">/* here's one to unlock */</span>
		<span class="enscript-keyword">if</span> ((start &lt;= nflp-&gt;nfl_start) &amp;&amp; (end &gt;= nflp-&gt;nfl_end)) {
			<span class="enscript-comment">/* The entire lock is being unlocked. */</span>
			<span class="enscript-keyword">if</span> (send_unlock_rpcs &amp;&amp; !(nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_DELEGATED)) {
				lck_mtx_unlock(&amp;np-&gt;n_openlock);
				error = nmp-&gt;nm_funcs-&gt;nf_unlock_rpc(np, nlop, nflp-&gt;nfl_type, nflp-&gt;nfl_start, nflp-&gt;nfl_end, 0,
						vfs_context_thread(ctx), vfs_context_ucred(ctx));
				<span class="enscript-keyword">if</span> (nfs_mount_state_error_should_restart(error)) {
					nfs_open_state_clear_busy(np);
					nfs_mount_state_in_use_end(nmp, error);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
				}
				lck_mtx_lock(&amp;np-&gt;n_openlock);
			}
			nextnflp = TAILQ_NEXT(nflp, nfl_link);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			nflp-&gt;nfl_flags |= NFS_FILE_LOCK_DEAD;
			lck_mtx_lock(&amp;nlop-&gt;nlo_lock);
			TAILQ_REMOVE(&amp;nlop-&gt;nlo_locks, nflp, nfl_lolink);
			lck_mtx_unlock(&amp;nlop-&gt;nlo_lock);
			<span class="enscript-comment">/* lock will be destroyed below, if no waiters */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((start &gt; nflp-&gt;nfl_start) &amp;&amp; (end &lt; nflp-&gt;nfl_end)) {
			<span class="enscript-comment">/* We're unlocking a range in the middle of a lock. */</span>
			<span class="enscript-comment">/* The current lock will be split into two locks. */</span>
			<span class="enscript-keyword">if</span> (send_unlock_rpcs &amp;&amp; !(nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_DELEGATED)) {
				lck_mtx_unlock(&amp;np-&gt;n_openlock);
				error = nmp-&gt;nm_funcs-&gt;nf_unlock_rpc(np, nlop, nflp-&gt;nfl_type, start, end, 0,
						vfs_context_thread(ctx), vfs_context_ucred(ctx));
				<span class="enscript-keyword">if</span> (nfs_mount_state_error_should_restart(error)) {
					nfs_open_state_clear_busy(np);
					nfs_mount_state_in_use_end(nmp, error);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
				}
				lck_mtx_lock(&amp;np-&gt;n_openlock);
			}
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-comment">/* update locks and insert new lock after current lock */</span>
			newnflp-&gt;nfl_flags |= (nflp-&gt;nfl_flags &amp; (NFS_FILE_LOCK_STYLE_MASK|NFS_FILE_LOCK_DELEGATED));
			newnflp-&gt;nfl_type = nflp-&gt;nfl_type;
			newnflp-&gt;nfl_start = end + 1;
			newnflp-&gt;nfl_end = nflp-&gt;nfl_end;
			nflp-&gt;nfl_end = start - 1;
			TAILQ_INSERT_AFTER(&amp;np-&gt;n_locks, nflp, newnflp, nfl_link);
			nfs_lock_owner_insert_held_lock(nlop, newnflp);
			nextnflp = newnflp;
			newnflp = NULL;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (start &gt; nflp-&gt;nfl_start) {
			<span class="enscript-comment">/* We're unlocking the end of a lock. */</span>
			<span class="enscript-keyword">if</span> (send_unlock_rpcs &amp;&amp; !(nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_DELEGATED)) {
				lck_mtx_unlock(&amp;np-&gt;n_openlock);
				error = nmp-&gt;nm_funcs-&gt;nf_unlock_rpc(np, nlop, nflp-&gt;nfl_type, start, nflp-&gt;nfl_end, 0,
						vfs_context_thread(ctx), vfs_context_ucred(ctx));
				<span class="enscript-keyword">if</span> (nfs_mount_state_error_should_restart(error)) {
					nfs_open_state_clear_busy(np);
					nfs_mount_state_in_use_end(nmp, error);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
				}
				lck_mtx_lock(&amp;np-&gt;n_openlock);
			}
			nextnflp = TAILQ_NEXT(nflp, nfl_link);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			nflp-&gt;nfl_end = start - 1;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (end &lt; nflp-&gt;nfl_end) {
			<span class="enscript-comment">/* We're unlocking the start of a lock. */</span>
			<span class="enscript-keyword">if</span> (send_unlock_rpcs &amp;&amp; !(nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_DELEGATED)) {
				lck_mtx_unlock(&amp;np-&gt;n_openlock);
				error = nmp-&gt;nm_funcs-&gt;nf_unlock_rpc(np, nlop, nflp-&gt;nfl_type, nflp-&gt;nfl_start, end, 0,
						vfs_context_thread(ctx), vfs_context_ucred(ctx));
				<span class="enscript-keyword">if</span> (nfs_mount_state_error_should_restart(error)) {
					nfs_open_state_clear_busy(np);
					nfs_mount_state_in_use_end(nmp, error);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
				}
				lck_mtx_lock(&amp;np-&gt;n_openlock);
			}
			nextnflp = TAILQ_NEXT(nflp, nfl_link);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			nflp-&gt;nfl_start = end + 1;
		}
		<span class="enscript-keyword">if</span> (nflp-&gt;nfl_blockcnt) {
			<span class="enscript-comment">/* wake up anyone blocked on this lock */</span>
			wakeup(nflp);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_DEAD) {
			<span class="enscript-comment">/* remove nflp from lock list and destroy */</span>
			TAILQ_REMOVE(&amp;np-&gt;n_locks, nflp, nfl_link);
			nfs_file_lock_destroy(nflp);
		}
	}
<span class="enscript-reference">out</span>:
	lck_mtx_unlock(&amp;np-&gt;n_openlock);
	nfs_open_state_clear_busy(np);
	nfs_mount_state_in_use_end(nmp, 0);

	<span class="enscript-keyword">if</span> (newnflp)
		nfs_file_lock_destroy(newnflp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFSv4 advisory file locking
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_advlock</span>(
	<span class="enscript-type">struct</span> vnop_advlock_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		caddr_t a_id;
		int a_op;
		struct flock *a_fl;
		int a_flags;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vnode_t vp = ap-&gt;a_vp;
	nfsnode_t np = VTONFS(ap-&gt;a_vp);
	<span class="enscript-type">struct</span> flock *fl = ap-&gt;a_fl;
	<span class="enscript-type">int</span> op = ap-&gt;a_op;
	<span class="enscript-type">int</span> flags = ap-&gt;a_flags;
	vfs_context_t ctx = ap-&gt;a_context;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_open_owner *noop = NULL;
	<span class="enscript-type">struct</span> nfs_open_file *nofp = NULL;
	<span class="enscript-type">struct</span> nfs_lock_owner *nlop = NULL;
	off_t lstart;
	uint64_t start, end;
	<span class="enscript-type">int</span> error = 0, modified, style;
	<span class="enscript-type">enum</span> vtype vtype;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">OFF_MAX</span> QUAD_MAX

	nmp = VTONMP(ap-&gt;a_vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &lt;= NFS_VER3) &amp;&amp; (nmp-&gt;nm_lockmode == NFS_LOCK_MODE_DISABLED)) {
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE)
		<span class="enscript-keyword">return</span> (EIO);
	vtype = vnode_vtype(ap-&gt;a_vp);
	<span class="enscript-keyword">if</span> (vtype == VDIR) <span class="enscript-comment">/* ignore lock requests on directories */</span>
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> (vtype != VREG) <span class="enscript-comment">/* anything other than regular files is invalid */</span>
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* Convert the flock structure into a start and end. */</span>
	<span class="enscript-keyword">switch</span> (fl-&gt;l_whence) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SEEK_SET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SEEK_CUR</span>:
		<span class="enscript-comment">/*
		 * Caller is responsible for adding any necessary offset
		 * to fl-&gt;l_start when SEEK_CUR is used.
		 */</span>
		lstart = fl-&gt;l_start;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SEEK_END</span>:
		<span class="enscript-comment">/* need to flush, and refetch attributes to make */</span>
		<span class="enscript-comment">/* sure we have the correct end of file offset   */</span>
		<span class="enscript-keyword">if</span> ((error = nfs_node_lock(np)))
			<span class="enscript-keyword">return</span> (error);
		modified = (np-&gt;n_flag &amp; NMODIFIED);
		nfs_node_unlock(np);
		<span class="enscript-keyword">if</span> (modified &amp;&amp; ((error = nfs_vinvalbuf(vp, V_SAVE, ctx, 1))))
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">if</span> ((error = nfs_getattr(np, NULL, ctx, NGA_UNCACHED)))
			<span class="enscript-keyword">return</span> (error);
		nfs_data_lock(np, NFS_DATA_LOCK_SHARED);
		<span class="enscript-keyword">if</span> ((np-&gt;n_size &gt; OFF_MAX) ||
		    ((fl-&gt;l_start &gt; 0) &amp;&amp; (np-&gt;n_size &gt; (u_quad_t)(OFF_MAX - fl-&gt;l_start))))
			error = EOVERFLOW;
		lstart = np-&gt;n_size + fl-&gt;l_start;
		nfs_data_unlock(np);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> (lstart &lt; 0)
		<span class="enscript-keyword">return</span> (EINVAL);
	start = lstart;
	<span class="enscript-keyword">if</span> (fl-&gt;l_len == 0) {
		end = UINT64_MAX;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fl-&gt;l_len &gt; 0) {
		<span class="enscript-keyword">if</span> ((fl-&gt;l_len - 1) &gt; (OFF_MAX - lstart))
			<span class="enscript-keyword">return</span> (EOVERFLOW);
		end = start - 1 + fl-&gt;l_len;
	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* l_len is negative */</span>
		<span class="enscript-keyword">if</span> ((lstart + fl-&gt;l_len) &lt; 0)
			<span class="enscript-keyword">return</span> (EINVAL);
		end = start - 1;
		start += fl-&gt;l_len;
	}
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers == NFS_VER2) &amp;&amp; ((start &gt; INT32_MAX) || (fl-&gt;l_len &amp;&amp; (end &gt; INT32_MAX))))
		<span class="enscript-keyword">return</span> (EINVAL);

	style = (flags &amp; F_FLOCK) ? NFS_FILE_LOCK_STYLE_FLOCK : NFS_FILE_LOCK_STYLE_POSIX;
	<span class="enscript-keyword">if</span> ((style == NFS_FILE_LOCK_STYLE_FLOCK) &amp;&amp; ((start != 0) || (end != UINT64_MAX)))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* find the lock owner, alloc if not unlock */</span>
	nlop = nfs_lock_owner_find(np, vfs_context_proc(ctx), (op != F_UNLCK));
	<span class="enscript-keyword">if</span> (!nlop) {
		error = (op == F_UNLCK) ? 0 : ENOMEM;
		<span class="enscript-keyword">if</span> (error)
			NP(np, <span class="enscript-string">&quot;nfs_vnop_advlock: no lock owner, error %d&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (op == F_GETLK) {
		error = nfs_advlock_getlock(np, nlop, fl, start, end, ctx);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* find the open owner */</span>
		noop = nfs_open_owner_find(nmp, vfs_context_ucred(ctx), 0);
		<span class="enscript-keyword">if</span> (!noop) {
			NP(np, <span class="enscript-string">&quot;nfs_vnop_advlock: no open owner %d&quot;</span>, kauth_cred_getuid(vfs_context_ucred(ctx)));
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-comment">/* find the open file */</span>
<span class="enscript-reference">restart</span>:
		error = nfs_open_file_find(np, noop, &amp;nofp, 0, 0, 0);
		<span class="enscript-keyword">if</span> (error)
			error = EBADF;
		<span class="enscript-keyword">if</span> (!error &amp;&amp; (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST)) {
			NP(np, <span class="enscript-string">&quot;nfs_vnop_advlock: LOST %d&quot;</span>, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
			error = EIO;
		}
		<span class="enscript-keyword">if</span> (!error &amp;&amp; (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN)) {
			error = nfs4_reopen(nofp, ((op == F_UNLCK) ? NULL : vfs_context_thread(ctx)));
			nofp = NULL;
			<span class="enscript-keyword">if</span> (!error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		}
		<span class="enscript-keyword">if</span> (error) {
			NP(np, <span class="enscript-string">&quot;nfs_vnop_advlock: no open file %d, %d&quot;</span>, error, kauth_cred_getuid(noop-&gt;noo_cred));
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (op == F_UNLCK) {
			error = nfs_advlock_unlock(np, nofp, nlop, start, end, style, ctx);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((op == F_SETLK) || (op == F_SETLKW)) {
			<span class="enscript-keyword">if</span> ((op == F_SETLK) &amp;&amp; (flags &amp; F_WAIT))
				op = F_SETLKW;
			error = nfs_advlock_setlock(np, nofp, nlop, op, start, end, style, fl-&gt;l_type, ctx);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* not getlk, unlock or lock? */</span>
			error = EINVAL;
		}
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (nlop)
		nfs_lock_owner_rele(nlop);
	<span class="enscript-keyword">if</span> (noop)
		nfs_open_owner_rele(noop);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Check if an open owner holds any locks on a file.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_check_for_locks</span>(<span class="enscript-type">struct</span> nfs_open_owner *noop, <span class="enscript-type">struct</span> nfs_open_file *nofp)
{
	<span class="enscript-type">struct</span> nfs_lock_owner *nlop;

	TAILQ_FOREACH(nlop, &amp;nofp-&gt;nof_np-&gt;n_lock_owners, nlo_link) {
		<span class="enscript-keyword">if</span> (nlop-&gt;nlo_open_owner != noop)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;nlop-&gt;nlo_locks))
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (nlop ? 1 : 0);
}

<span class="enscript-comment">/*
 * Reopen simple (no deny, no locks) open state that was lost.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_reopen</span>(<span class="enscript-type">struct</span> nfs_open_file *nofp, thread_t thd)
{
	<span class="enscript-type">struct</span> nfs_open_owner *noop = nofp-&gt;nof_owner;
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(nofp-&gt;nof_np);
	nfsnode_t np = nofp-&gt;nof_np;
	vnode_t vp = NFSTOV(np);
	vnode_t dvp = NULL;
	<span class="enscript-type">struct</span> componentname cn;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *vname = NULL;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name = NULL;
	size_t namelen;
	<span class="enscript-type">char</span> smallname[128];
	<span class="enscript-type">char</span> *filename = NULL;
	<span class="enscript-type">int</span> error = 0, done = 0, slpflag = NMFLAG(nmp, INTR) ? PCATCH : 0;
	<span class="enscript-type">struct</span> timespec ts = { 1, 0 };

	lck_mtx_lock(&amp;nofp-&gt;nof_lock);
	<span class="enscript-keyword">while</span> (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPENING) {
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(nmp, NULL, thd, 0)))
			<span class="enscript-keyword">break</span>;
		msleep(&amp;nofp-&gt;nof_flags, &amp;nofp-&gt;nof_lock, slpflag|(PZERO-1), <span class="enscript-string">&quot;nfsreopenwait&quot;</span>, &amp;ts);
		slpflag = 0;
	}
	<span class="enscript-keyword">if</span> (error || !(nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN)) {
		lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
		<span class="enscript-keyword">return</span> (error);
	}
	nofp-&gt;nof_flags |= NFS_OPEN_FILE_REOPENING;
	lck_mtx_unlock(&amp;nofp-&gt;nof_lock);

	nfs_node_lock_force(np);
	<span class="enscript-keyword">if</span> ((vnode_vtype(vp) != VDIR) &amp;&amp; np-&gt;n_sillyrename) {
		<span class="enscript-comment">/*
		 * The node's been sillyrenamed, so we need to use
		 * the sillyrename directory/name to do the open.
		 */</span>
		<span class="enscript-type">struct</span> nfs_sillyrename *nsp = np-&gt;n_sillyrename;
		dvp = NFSTOV(nsp-&gt;nsr_dnp);
		<span class="enscript-keyword">if</span> ((error = vnode_get(dvp))) {
			nfs_node_unlock(np);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		name = nsp-&gt;nsr_name;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * [sigh] We can't trust VFS to get the parent right for named
		 * attribute nodes.  (It likes to reparent the nodes after we've
		 * created them.)  Luckily we can probably get the right parent
		 * from the n_parent we have stashed away.
		 */</span>
		<span class="enscript-keyword">if</span> ((np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_IS_ATTR) &amp;&amp;
		    (((dvp = np-&gt;n_parent)) &amp;&amp; (error = vnode_get(dvp))))
			dvp = NULL;
		<span class="enscript-keyword">if</span> (!dvp)
			dvp = vnode_getparent(vp);
		vname = vnode_getname(vp);
		<span class="enscript-keyword">if</span> (!dvp || !vname) {
			<span class="enscript-keyword">if</span> (!error)
				error = EIO;
			nfs_node_unlock(np);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		name = vname;
	}
	filename = &amp;smallname[0];
	namelen = snprintf(filename, <span class="enscript-keyword">sizeof</span>(smallname), <span class="enscript-string">&quot;%s&quot;</span>, name);
	<span class="enscript-keyword">if</span> (namelen &gt;= <span class="enscript-keyword">sizeof</span>(smallname)) {
		MALLOC(filename, <span class="enscript-type">char</span> *, namelen+1, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (!filename) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		snprintf(filename, namelen+1, <span class="enscript-string">&quot;%s&quot;</span>, name);
	}
	nfs_node_unlock(np);
	bzero(&amp;cn, <span class="enscript-keyword">sizeof</span>(cn));
	cn.cn_nameptr = filename;
	cn.cn_namelen = namelen;

<span class="enscript-reference">restart</span>:
	done = 0;
	<span class="enscript-keyword">if</span> ((error = nfs_mount_state_in_use_start(nmp, thd)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (nofp-&gt;nof_rw)
		error = nfs4_open_reopen_rpc(nofp, thd, noop-&gt;noo_cred, &amp;cn, dvp, &amp;vp, NFS_OPEN_SHARE_ACCESS_BOTH, NFS_OPEN_SHARE_DENY_NONE);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; nofp-&gt;nof_w)
		error = nfs4_open_reopen_rpc(nofp, thd, noop-&gt;noo_cred, &amp;cn, dvp, &amp;vp, NFS_OPEN_SHARE_ACCESS_WRITE, NFS_OPEN_SHARE_DENY_NONE);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; nofp-&gt;nof_r)
		error = nfs4_open_reopen_rpc(nofp, thd, noop-&gt;noo_cred, &amp;cn, dvp, &amp;vp, NFS_OPEN_SHARE_ACCESS_READ, NFS_OPEN_SHARE_DENY_NONE);

	<span class="enscript-keyword">if</span> (nfs_mount_state_in_use_end(nmp, error)) {
		<span class="enscript-keyword">if</span> (error == NFSERR_GRACE)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		printf(<span class="enscript-string">&quot;nfs4_reopen: RPC failed, error %d, lost %d, %s\n&quot;</span>, error,
			(nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST) ? 1 : 0, name ? name : <span class="enscript-string">&quot;???&quot;</span>);
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	done = 1;
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error &amp;&amp; (error != EINTR) &amp;&amp; (error != ERESTART))
		nfs_revoke_open_state_for_node(np);
	lck_mtx_lock(&amp;nofp-&gt;nof_lock);
	nofp-&gt;nof_flags &amp;= ~NFS_OPEN_FILE_REOPENING;
	<span class="enscript-keyword">if</span> (done)
		nofp-&gt;nof_flags &amp;= ~NFS_OPEN_FILE_REOPEN;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error)
		printf(<span class="enscript-string">&quot;nfs4_reopen: failed, error %d, lost %d, %s\n&quot;</span>, error,
			(nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST) ? 1 : 0, name ? name : <span class="enscript-string">&quot;???&quot;</span>);
	lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
	<span class="enscript-keyword">if</span> (filename &amp;&amp; (filename != &amp;smallname[0]))
		FREE(filename, M_TEMP);
	<span class="enscript-keyword">if</span> (vname)
		vnode_putname(vname);
	<span class="enscript-keyword">if</span> (dvp != NULLVP)
		vnode_put(dvp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Send a normal OPEN RPC to open/create a file.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_open_rpc</span>(
	<span class="enscript-type">struct</span> nfs_open_file *nofp,
	vfs_context_t ctx,
	<span class="enscript-type">struct</span> componentname *cnp,
	<span class="enscript-type">struct</span> vnode_attr *vap,
	vnode_t dvp,
	vnode_t *vpp,
	<span class="enscript-type">int</span> create,
	<span class="enscript-type">int</span> share_access,
	<span class="enscript-type">int</span> share_deny)
{
	<span class="enscript-keyword">return</span> (nfs4_open_rpc_internal(nofp, ctx, vfs_context_thread(ctx), vfs_context_ucred(ctx),
					cnp, vap, dvp, vpp, create, share_access, share_deny));
}

<span class="enscript-comment">/*
 * Send an OPEN RPC to reopen a file.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_open_reopen_rpc</span>(
	<span class="enscript-type">struct</span> nfs_open_file *nofp,
	thread_t thd,
	kauth_cred_t cred,
	<span class="enscript-type">struct</span> componentname *cnp,
	vnode_t dvp,
	vnode_t *vpp,
	<span class="enscript-type">int</span> share_access,
	<span class="enscript-type">int</span> share_deny)
{
	<span class="enscript-keyword">return</span> (nfs4_open_rpc_internal(nofp, NULL, thd, cred, cnp, NULL, dvp, vpp, NFS_OPEN_NOCREATE, share_access, share_deny));
}

<span class="enscript-comment">/*
 * Send an OPEN_CONFIRM RPC to confirm an OPEN.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_open_confirm_rpc</span>(
	<span class="enscript-type">struct</span> nfsmount *nmp,
	nfsnode_t dnp,
	u_char *fhp,
	<span class="enscript-type">int</span> fhlen,
	<span class="enscript-type">struct</span> nfs_open_owner *noop,
	nfs_stateid *sid,
	thread_t thd,
	kauth_cred_t cred,
	<span class="enscript-type">struct</span> nfs_vattr *nvap,
	uint64_t *xidp)
{
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">int</span> error = 0, status, numops;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	NFSREQ_SECINFO_SET(&amp;si, dnp, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, OPEN_CONFIRM, GETATTR
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 23 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;open_confirm&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nmp-&gt;nm_vers, fhp, fhlen);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_OPEN_CONFIRM);
	nfsm_chain_add_stateid(error, &amp;nmreq, sid);
	nfsm_chain_add_32(error, &amp;nmreq, noop-&gt;noo_seqid);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, dnp);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request2(dnp, NULL, &amp;nmreq, NFSPROC4_COMPOUND, thd, cred, &amp;si, R_NOINTR, &amp;nmrep, xidp, &amp;status);

	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_OPEN_CONFIRM);
	nfs_owner_seqid_increment(noop, NULL, error);
	nfsm_chain_get_stateid(error, &amp;nmrep, sid);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsmout_if(error);
	error = nfs4_parsefattr(&amp;nmrep, NULL, nvap, NULL, NULL, NULL);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * common OPEN RPC code
 *
 * If create is set, ctx must be passed in.
 * Returns a node on success if no node passed in.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_open_rpc_internal</span>(
	<span class="enscript-type">struct</span> nfs_open_file *nofp,
	vfs_context_t ctx,
	thread_t thd,
	kauth_cred_t cred,
	<span class="enscript-type">struct</span> componentname *cnp,
	<span class="enscript-type">struct</span> vnode_attr *vap,
	vnode_t dvp,
	vnode_t *vpp,
	<span class="enscript-type">int</span> create,
	<span class="enscript-type">int</span> share_access,
	<span class="enscript-type">int</span> share_deny)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_open_owner *noop = nofp-&gt;nof_owner;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">int</span> error = 0, open_error = EIO, lockerror = ENOENT, busyerror = ENOENT, status;
	<span class="enscript-type">int</span> nfsvers, namedattrs, numops, exclusive = 0, gotuid, gotgid;
	u_int64_t xid, savedxid = 0;
	nfsnode_t dnp = VTONFS(dvp);
	nfsnode_t np, newnp = NULL;
	vnode_t newvp = NULL;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	uint32_t bitmap[NFS_ATTR_BITMAP_LEN], bmlen;
	uint32_t rflags, delegation, recall;
	<span class="enscript-type">struct</span> nfs_stateid stateid, dstateid, *sid;
	fhandle_t fh;
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;
	<span class="enscript-type">struct</span> nfs_dulookup dul;
	<span class="enscript-type">char</span> sbuf[64], *s;
	uint32_t ace_type, ace_flags, ace_mask, len, slen;
	<span class="enscript-type">struct</span> kauth_ace ace;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	<span class="enscript-keyword">if</span> (create &amp;&amp; !ctx)
		<span class="enscript-keyword">return</span> (EINVAL);

	nmp = VTONMP(dvp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	namedattrs = (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR);
	<span class="enscript-keyword">if</span> (dnp-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);

	np = *vpp ? VTONFS(*vpp) : NULL;
	<span class="enscript-keyword">if</span> (create &amp;&amp; vap) {
		exclusive = (vap-&gt;va_vaflags &amp; VA_EXCLUSIVE);
		nfs_avoid_needless_id_setting_on_create(dnp, vap, ctx);
		gotuid = VATTR_IS_ACTIVE(vap, va_uid);
		gotgid = VATTR_IS_ACTIVE(vap, va_gid);
		<span class="enscript-keyword">if</span> (exclusive &amp;&amp; (!VATTR_IS_ACTIVE(vap, va_access_time) || !VATTR_IS_ACTIVE(vap, va_modify_time)))
			vap-&gt;va_vaflags |= VA_UTIMES_NULL;
	} <span class="enscript-keyword">else</span> {
		exclusive = gotuid = gotgid = 0;
	}
	<span class="enscript-keyword">if</span> (nofp) {
		sid = &amp;nofp-&gt;nof_stateid;
	} <span class="enscript-keyword">else</span> {
		stateid.seqid = stateid.other[0] = stateid.other[1] = stateid.other[2] = 0;
		sid = &amp;stateid;
	}

	<span class="enscript-keyword">if</span> ((error = nfs_open_owner_set_busy(noop, thd)))
		<span class="enscript-keyword">return</span> (error);
<span class="enscript-reference">again</span>:
	rflags = delegation = recall = 0;
	ace.ace_flags = 0;
	s = sbuf;
	slen = <span class="enscript-keyword">sizeof</span>(sbuf);
	NVATTR_INIT(&amp;nvattr);
	NFSREQ_SECINFO_SET(&amp;si, dnp, NULL, 0, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen);

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, SAVEFH, OPEN(CREATE?), GETATTR(FH), RESTOREFH, GETATTR
</span>	numops = 6;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 53 * NFSX_UNSIGNED + cnp-&gt;cn_namelen);
	nfsm_chain_add_compound_header(error, &amp;nmreq, create ? <span class="enscript-string">&quot;create&quot;</span> : <span class="enscript-string">&quot;open&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, dnp-&gt;n_fhp, dnp-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_SAVEFH);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_OPEN);
	nfsm_chain_add_32(error, &amp;nmreq, noop-&gt;noo_seqid);
	nfsm_chain_add_32(error, &amp;nmreq, share_access);
	nfsm_chain_add_32(error, &amp;nmreq, share_deny);
	nfsm_chain_add_64(error, &amp;nmreq, nmp-&gt;nm_clientid);
	nfsm_chain_add_32(error, &amp;nmreq, NFSX_UNSIGNED);
	nfsm_chain_add_32(error, &amp;nmreq, kauth_cred_getuid(noop-&gt;noo_cred));
	nfsm_chain_add_32(error, &amp;nmreq, create);
	<span class="enscript-keyword">if</span> (create) {
		<span class="enscript-keyword">if</span> (exclusive) {
			<span class="enscript-type">static</span> uint32_t create_verf; <span class="enscript-comment">// XXX need a better verifier
</span>			create_verf++;
			nfsm_chain_add_32(error, &amp;nmreq, NFS_CREATE_EXCLUSIVE);
			<span class="enscript-comment">/* insert 64 bit verifier */</span>
			nfsm_chain_add_32(error, &amp;nmreq, create_verf);
			nfsm_chain_add_32(error, &amp;nmreq, create_verf);
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, &amp;nmreq, NFS_CREATE_UNCHECKED);
			nfsm_chain_add_fattr4(error, &amp;nmreq, vap, nmp);
		}
	}
	nfsm_chain_add_32(error, &amp;nmreq, NFS_CLAIM_NULL);
	nfsm_chain_add_name(error, &amp;nmreq, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, nmp);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	NFS_COPY_ATTRIBUTES(nfs_getattr_bitmap, bitmap);
	NFS_BITMAP_SET(bitmap, NFS_FATTR_FILEHANDLE);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, bitmap, nmp, np);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_RESTOREFH);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, dnp);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	<span class="enscript-keyword">if</span> (!error)
		error = busyerror = nfs_node_set_busy(dnp, thd);
	nfsmout_if(error);

	<span class="enscript-keyword">if</span> (create &amp;&amp; !namedattrs)
		nfs_dulookup_init(&amp;dul, dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx);

	error = nfs_request_async(dnp, NULL, &amp;nmreq, NFSPROC4_COMPOUND, thd, cred, &amp;si, R_NOINTR, NULL, &amp;req);
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-keyword">if</span> (create &amp;&amp; !namedattrs)
			nfs_dulookup_start(&amp;dul, dnp, ctx);
		error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);
		savedxid = xid;
	}

	<span class="enscript-keyword">if</span> (create &amp;&amp; !namedattrs)
		nfs_dulookup_finish(&amp;dul, dnp, ctx);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_SAVEFH);
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_OPEN);
	nfs_owner_seqid_increment(noop, NULL, error);
	nfsm_chain_get_stateid(error, &amp;nmrep, sid);
	nfsm_chain_check_change_info(error, &amp;nmrep, dnp);
	nfsm_chain_get_32(error, &amp;nmrep, rflags);
	bmlen = NFS_ATTR_BITMAP_LEN;
	nfsm_chain_get_bitmap(error, &amp;nmrep, bitmap, bmlen);
	nfsm_chain_get_32(error, &amp;nmrep, delegation);
	<span class="enscript-keyword">if</span> (!error)
		<span class="enscript-keyword">switch</span> (delegation) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_OPEN_DELEGATE_NONE</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_OPEN_DELEGATE_READ</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_OPEN_DELEGATE_WRITE</span>:
			nfsm_chain_get_stateid(error, &amp;nmrep, &amp;dstateid);
			nfsm_chain_get_32(error, &amp;nmrep, recall);
			<span class="enscript-keyword">if</span> (delegation == NFS_OPEN_DELEGATE_WRITE) <span class="enscript-comment">// space (skip) XXX
</span>				nfsm_chain_adv(error, &amp;nmrep, 3 * NFSX_UNSIGNED);
			<span class="enscript-comment">/* if we have any trouble accepting the ACE, just invalidate it */</span>
			ace_type = ace_flags = ace_mask = len = 0;
			nfsm_chain_get_32(error, &amp;nmrep, ace_type);
			nfsm_chain_get_32(error, &amp;nmrep, ace_flags);
			nfsm_chain_get_32(error, &amp;nmrep, ace_mask);
			nfsm_chain_get_32(error, &amp;nmrep, len);
			ace.ace_flags = nfs4_ace_nfstype_to_vfstype(ace_type, &amp;error);
			ace.ace_flags |= nfs4_ace_nfsflags_to_vfsflags(ace_flags);
			ace.ace_rights = nfs4_ace_nfsmask_to_vfsrights(ace_mask);
			<span class="enscript-keyword">if</span> (!error &amp;&amp; (len &gt;= slen)) {
				MALLOC(s, <span class="enscript-type">char</span>*, len+1, M_TEMP, M_WAITOK);
				<span class="enscript-keyword">if</span> (s)
					slen = len+1;
				<span class="enscript-keyword">else</span>
					ace.ace_flags = 0;
			}
			<span class="enscript-keyword">if</span> (s)
				nfsm_chain_get_opaque(error, &amp;nmrep, len, s);
			<span class="enscript-keyword">else</span>
				nfsm_chain_adv(error, &amp;nmrep, nfsm_rndup(len));
			<span class="enscript-keyword">if</span> (!error &amp;&amp; s) {
				s[len] = <span class="enscript-string">'\0'</span>;
				<span class="enscript-keyword">if</span> (nfs4_id2guid(s, &amp;ace.ace_applicable, (ace_flags &amp; NFS_ACE_IDENTIFIER_GROUP)))
					ace.ace_flags = 0;
			}
			<span class="enscript-keyword">if</span> (error || !s)
				ace.ace_flags = 0;
			<span class="enscript-keyword">if</span> (s &amp;&amp; (s != sbuf))
				FREE(s, M_TEMP);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			error = EBADRPC;
			<span class="enscript-keyword">break</span>;
		}
	<span class="enscript-comment">/* At this point if we have no error, the object was created/opened. */</span>
	open_error = error;
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (create &amp;&amp; vap &amp;&amp; !exclusive)
		nfs_vattr_set_supported(bitmap, vap);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsmout_if(error);
	error = nfs4_parsefattr(&amp;nmrep, NULL, &amp;nvattr, &amp;fh, NULL, NULL);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (!NFS_BITMAP_ISSET(nvattr.nva_bitmap, NFS_FATTR_FILEHANDLE)) {
		printf(<span class="enscript-string">&quot;nfs: open/create didn't return filehandle? %s\n&quot;</span>, cnp-&gt;cn_nameptr);
		error = EBADRPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}
	<span class="enscript-keyword">if</span> (!create &amp;&amp; np &amp;&amp; !NFS_CMPFH(np, fh.fh_data, fh.fh_len)) {
		<span class="enscript-comment">// XXX for the open case, what if fh doesn't match the vnode we think we're opening?
</span>		<span class="enscript-comment">// Solaris Named Attributes may do this due to a bug.... so don't warn for named attributes.
</span>		<span class="enscript-keyword">if</span> (!(np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_IS_ATTR))
			NP(np, <span class="enscript-string">&quot;nfs4_open_rpc: warning: file handle mismatch&quot;</span>);
	}
	<span class="enscript-comment">/* directory attributes: if we don't get them, make sure to invalidate */</span>
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_RESTOREFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsm_chain_loadattr(error, &amp;nmrep, dnp, nfsvers, &amp;xid);
	<span class="enscript-keyword">if</span> (error)
		NATTRINVALIDATE(dnp);
	nfsmout_if(error);

	<span class="enscript-keyword">if</span> (rflags &amp; NFS_OPEN_RESULT_LOCKTYPE_POSIX)
		nofp-&gt;nof_flags |= NFS_OPEN_FILE_POSIXLOCK;

	<span class="enscript-keyword">if</span> (rflags &amp; NFS_OPEN_RESULT_CONFIRM) {
		nfs_node_unlock(dnp);
		lockerror = ENOENT;
		NVATTR_CLEANUP(&amp;nvattr);
		error = nfs4_open_confirm_rpc(nmp, dnp, fh.fh_data, fh.fh_len, noop, sid, thd, cred, &amp;nvattr, &amp;xid);
		nfsmout_if(error);
		savedxid = xid;
		<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
			error = lockerror;
	}

<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);

	<span class="enscript-keyword">if</span> (!lockerror &amp;&amp; create) {
		<span class="enscript-keyword">if</span> (!open_error &amp;&amp; (dnp-&gt;n_flag &amp; NNEGNCENTRIES)) {
			dnp-&gt;n_flag &amp;= ~NNEGNCENTRIES;
			cache_purge_negatives(dvp);
		}
		dnp-&gt;n_flag |= NMODIFIED;
		nfs_node_unlock(dnp);
		lockerror = ENOENT;
		nfs_getattr(dnp, NULL, ctx, NGA_CACHED);
	}
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(dnp);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; !np &amp;&amp; fh.fh_len) {
		<span class="enscript-comment">/* create the vnode with the filehandle and attributes */</span>
		xid = savedxid;
		error = nfs_nget(NFSTOMP(dnp), dnp, cnp, fh.fh_data, fh.fh_len, &amp;nvattr, &amp;xid, rq.r_auth, NG_MAKEENTRY, &amp;newnp);
		<span class="enscript-keyword">if</span> (!error)
			newvp = NFSTOV(newnp);
	}
	NVATTR_CLEANUP(&amp;nvattr);
	<span class="enscript-keyword">if</span> (!busyerror)
		nfs_node_clear_busy(dnp);
	<span class="enscript-keyword">if</span> ((delegation == NFS_OPEN_DELEGATE_READ) || (delegation == NFS_OPEN_DELEGATE_WRITE)) {
		<span class="enscript-keyword">if</span> (!np)
			np = newnp;
		<span class="enscript-keyword">if</span> (!error &amp;&amp; np &amp;&amp; !recall) {
			<span class="enscript-comment">/* stuff the delegation state in the node */</span>
			lck_mtx_lock(&amp;np-&gt;n_openlock);
			np-&gt;n_openflags &amp;= ~N_DELEG_MASK;
			np-&gt;n_openflags |= ((delegation == NFS_OPEN_DELEGATE_READ) ? N_DELEG_READ : N_DELEG_WRITE);
			np-&gt;n_dstateid = dstateid;
			np-&gt;n_dace = ace;
			<span class="enscript-keyword">if</span> (np-&gt;n_dlink.tqe_next == NFSNOLIST) {
				lck_mtx_lock(&amp;nmp-&gt;nm_lock);
				<span class="enscript-keyword">if</span> (np-&gt;n_dlink.tqe_next == NFSNOLIST)
					TAILQ_INSERT_TAIL(&amp;nmp-&gt;nm_delegations, np, n_dlink);
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			}
			lck_mtx_unlock(&amp;np-&gt;n_openlock);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* give the delegation back */</span>
			<span class="enscript-keyword">if</span> (np) {
				<span class="enscript-keyword">if</span> (NFS_CMPFH(np, fh.fh_data, fh.fh_len)) {
					<span class="enscript-comment">/* update delegation state and return it */</span>
					lck_mtx_lock(&amp;np-&gt;n_openlock);
					np-&gt;n_openflags &amp;= ~N_DELEG_MASK;
					np-&gt;n_openflags |= ((delegation == NFS_OPEN_DELEGATE_READ) ? N_DELEG_READ : N_DELEG_WRITE);
					np-&gt;n_dstateid = dstateid;
					np-&gt;n_dace = ace;
					<span class="enscript-keyword">if</span> (np-&gt;n_dlink.tqe_next == NFSNOLIST) {
						lck_mtx_lock(&amp;nmp-&gt;nm_lock);
						<span class="enscript-keyword">if</span> (np-&gt;n_dlink.tqe_next == NFSNOLIST)
							TAILQ_INSERT_TAIL(&amp;nmp-&gt;nm_delegations, np, n_dlink);
						lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
					}
					lck_mtx_unlock(&amp;np-&gt;n_openlock);
					<span class="enscript-comment">/* don't need to send a separate delegreturn for fh */</span>
					fh.fh_len = 0;
				}
				<span class="enscript-comment">/* return np's current delegation */</span>
				nfs4_delegation_return(np, 0, thd, cred);
			}
			<span class="enscript-keyword">if</span> (fh.fh_len) <span class="enscript-comment">/* return fh's delegation if it wasn't for np */</span>
				nfs4_delegreturn_rpc(nmp, fh.fh_data, fh.fh_len, &amp;dstateid, 0, thd, cred);
		}
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (exclusive &amp;&amp; (error == NFSERR_NOTSUPP)) {
			exclusive = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
		}
		<span class="enscript-keyword">if</span> (newvp) {
			nfs_node_unlock(newnp);
			vnode_put(newvp);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (create) {
		nfs_node_unlock(newnp);
		<span class="enscript-keyword">if</span> (exclusive) {
			error = nfs4_setattr_rpc(newnp, vap, ctx);
			<span class="enscript-keyword">if</span> (error &amp;&amp; (gotuid || gotgid)) {
				<span class="enscript-comment">/* it's possible the server didn't like our attempt to set IDs. */</span>
				<span class="enscript-comment">/* so, let's try it again without those */</span>
				VATTR_CLEAR_ACTIVE(vap, va_uid);
				VATTR_CLEAR_ACTIVE(vap, va_gid);
				error = nfs4_setattr_rpc(newnp, vap, ctx);
			}
		}
		<span class="enscript-keyword">if</span> (error)
			vnode_put(newvp);
		<span class="enscript-keyword">else</span>
			*vpp = newvp;
	}
	nfs_open_owner_clear_busy(noop);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Send an OPEN RPC to claim a delegated open for a file
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_claim_delegated_open_rpc</span>(
	<span class="enscript-type">struct</span> nfs_open_file *nofp,
	<span class="enscript-type">int</span> share_access,
	<span class="enscript-type">int</span> share_deny,
	<span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_open_owner *noop = nofp-&gt;nof_owner;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, status;
	<span class="enscript-type">int</span> nfsvers, numops;
	u_int64_t xid;
	nfsnode_t np = nofp-&gt;nof_np;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	uint32_t bitmap[NFS_ATTR_BITMAP_LEN], bmlen;
	uint32_t rflags = 0, delegation, recall = 0;
	fhandle_t fh;
	<span class="enscript-type">struct</span> nfs_stateid dstateid;
	<span class="enscript-type">char</span> sbuf[64], *s = sbuf;
	uint32_t ace_type, ace_flags, ace_mask, len, slen = <span class="enscript-keyword">sizeof</span>(sbuf);
	<span class="enscript-type">struct</span> kauth_ace ace;
	vnode_t dvp = NULL;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *vname = NULL;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name = NULL;
	size_t namelen;
	<span class="enscript-type">char</span> smallname[128];
	<span class="enscript-type">char</span> *filename = NULL;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	nfs_node_lock_force(np);
	<span class="enscript-keyword">if</span> ((vnode_vtype(NFSTOV(np)) != VDIR) &amp;&amp; np-&gt;n_sillyrename) {
		<span class="enscript-comment">/*
		 * The node's been sillyrenamed, so we need to use
		 * the sillyrename directory/name to do the open.
		 */</span>
		<span class="enscript-type">struct</span> nfs_sillyrename *nsp = np-&gt;n_sillyrename;
		dvp = NFSTOV(nsp-&gt;nsr_dnp);
		<span class="enscript-keyword">if</span> ((error = vnode_get(dvp))) {
			nfs_node_unlock(np);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		name = nsp-&gt;nsr_name;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * [sigh] We can't trust VFS to get the parent right for named
		 * attribute nodes.  (It likes to reparent the nodes after we've
		 * created them.)  Luckily we can probably get the right parent
		 * from the n_parent we have stashed away.
		 */</span>
		<span class="enscript-keyword">if</span> ((np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_IS_ATTR) &amp;&amp;
		    (((dvp = np-&gt;n_parent)) &amp;&amp; (error = vnode_get(dvp))))
			dvp = NULL;
		<span class="enscript-keyword">if</span> (!dvp)
			dvp = vnode_getparent(NFSTOV(np));
		vname = vnode_getname(NFSTOV(np));
		<span class="enscript-keyword">if</span> (!dvp || !vname) {
			<span class="enscript-keyword">if</span> (!error)
				error = EIO;
			nfs_node_unlock(np);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		name = vname;
	}
	filename = &amp;smallname[0];
	namelen = snprintf(filename, <span class="enscript-keyword">sizeof</span>(smallname), <span class="enscript-string">&quot;%s&quot;</span>, name);
	<span class="enscript-keyword">if</span> (namelen &gt;= <span class="enscript-keyword">sizeof</span>(smallname)) {
		MALLOC(filename, <span class="enscript-type">char</span> *, namelen+1, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (!filename) {
			error = ENOMEM;
			nfs_node_unlock(np);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		snprintf(filename, namelen+1, <span class="enscript-string">&quot;%s&quot;</span>, name);
	}
	nfs_node_unlock(np);

	<span class="enscript-keyword">if</span> ((error = nfs_open_owner_set_busy(noop, NULL)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	NVATTR_INIT(&amp;nvattr);
	delegation = NFS_OPEN_DELEGATE_NONE;
	dstateid = np-&gt;n_dstateid;
	NFSREQ_SECINFO_SET(&amp;si, VTONFS(dvp), NULL, 0, filename, namelen);

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, OPEN, GETATTR(FH)
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 48 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;open_claim_d&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, VTONFS(dvp)-&gt;n_fhp, VTONFS(dvp)-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_OPEN);
	nfsm_chain_add_32(error, &amp;nmreq, noop-&gt;noo_seqid);
	nfsm_chain_add_32(error, &amp;nmreq, share_access);
	nfsm_chain_add_32(error, &amp;nmreq, share_deny);
	<span class="enscript-comment">// open owner: clientid + uid
</span>	nfsm_chain_add_64(error, &amp;nmreq, nmp-&gt;nm_clientid); <span class="enscript-comment">// open_owner4.clientid
</span>	nfsm_chain_add_32(error, &amp;nmreq, NFSX_UNSIGNED);
	nfsm_chain_add_32(error, &amp;nmreq, kauth_cred_getuid(noop-&gt;noo_cred)); <span class="enscript-comment">// open_owner4.owner
</span>	<span class="enscript-comment">// openflag4
</span>	nfsm_chain_add_32(error, &amp;nmreq, NFS_OPEN_NOCREATE);
	<span class="enscript-comment">// open_claim4
</span>	nfsm_chain_add_32(error, &amp;nmreq, NFS_CLAIM_DELEGATE_CUR);
	nfsm_chain_add_stateid(error, &amp;nmreq, &amp;np-&gt;n_dstateid);
	nfsm_chain_add_name(error, &amp;nmreq, filename, namelen, nmp);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	NFS_COPY_ATTRIBUTES(nfs_getattr_bitmap, bitmap);
	NFS_BITMAP_SET(bitmap, NFS_FATTR_FILEHANDLE);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, bitmap, nmp, np);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);

	error = nfs_request2(np, nmp-&gt;nm_mountp, &amp;nmreq, NFSPROC4_COMPOUND, current_thread(),
			noop-&gt;noo_cred, &amp;si, flags|R_NOINTR, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_OPEN);
	nfs_owner_seqid_increment(noop, NULL, error);
	nfsm_chain_get_stateid(error, &amp;nmrep, &amp;nofp-&gt;nof_stateid);
	nfsm_chain_check_change_info(error, &amp;nmrep, np);
	nfsm_chain_get_32(error, &amp;nmrep, rflags);
	bmlen = NFS_ATTR_BITMAP_LEN;
	nfsm_chain_get_bitmap(error, &amp;nmrep, bitmap, bmlen);
	nfsm_chain_get_32(error, &amp;nmrep, delegation);
	<span class="enscript-keyword">if</span> (!error)
		<span class="enscript-keyword">switch</span> (delegation) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_OPEN_DELEGATE_NONE</span>:
			<span class="enscript-comment">// if (!(np-&gt;n_openflags &amp; N_DELEG_RETURN)) /* don't warn if delegation is being returned */
</span>			<span class="enscript-comment">// 	printf(&quot;nfs: open delegated claim didn't return a delegation %s\n&quot;, filename ? filename : &quot;???&quot;);
</span>			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_OPEN_DELEGATE_READ</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_OPEN_DELEGATE_WRITE</span>:
			<span class="enscript-keyword">if</span> ((((np-&gt;n_openflags &amp; N_DELEG_MASK) == N_DELEG_READ) &amp;&amp;
			     (delegation == NFS_OPEN_DELEGATE_WRITE)) ||
			    (((np-&gt;n_openflags &amp; N_DELEG_MASK) == N_DELEG_WRITE) &amp;&amp;
			     (delegation == NFS_OPEN_DELEGATE_READ)))
				printf(<span class="enscript-string">&quot;nfs: open delegated claim returned a different delegation type! have %s got %s %s\n&quot;</span>,
				     ((np-&gt;n_openflags &amp; N_DELEG_MASK) == N_DELEG_WRITE) ? <span class="enscript-string">&quot;W&quot;</span> : <span class="enscript-string">&quot;R&quot;</span>,
				     (delegation == NFS_OPEN_DELEGATE_WRITE) ? <span class="enscript-string">&quot;W&quot;</span> : <span class="enscript-string">&quot;R&quot;</span>, filename ? filename : <span class="enscript-string">&quot;???&quot;</span>);
			nfsm_chain_get_stateid(error, &amp;nmrep, &amp;dstateid);
			nfsm_chain_get_32(error, &amp;nmrep, recall);
			<span class="enscript-keyword">if</span> (delegation == NFS_OPEN_DELEGATE_WRITE) <span class="enscript-comment">// space (skip) XXX
</span>				nfsm_chain_adv(error, &amp;nmrep, 3 * NFSX_UNSIGNED);
			<span class="enscript-comment">/* if we have any trouble accepting the ACE, just invalidate it */</span>
			ace_type = ace_flags = ace_mask = len = 0;
			nfsm_chain_get_32(error, &amp;nmrep, ace_type);
			nfsm_chain_get_32(error, &amp;nmrep, ace_flags);
			nfsm_chain_get_32(error, &amp;nmrep, ace_mask);
			nfsm_chain_get_32(error, &amp;nmrep, len);
			ace.ace_flags = nfs4_ace_nfstype_to_vfstype(ace_type, &amp;error);
			ace.ace_flags |= nfs4_ace_nfsflags_to_vfsflags(ace_flags);
			ace.ace_rights = nfs4_ace_nfsmask_to_vfsrights(ace_mask);
			<span class="enscript-keyword">if</span> (!error &amp;&amp; (len &gt;= slen)) {
				MALLOC(s, <span class="enscript-type">char</span>*, len+1, M_TEMP, M_WAITOK);
				<span class="enscript-keyword">if</span> (s)
					slen = len+1;
				<span class="enscript-keyword">else</span>
					ace.ace_flags = 0;
			}
			<span class="enscript-keyword">if</span> (s)
				nfsm_chain_get_opaque(error, &amp;nmrep, len, s);
			<span class="enscript-keyword">else</span>
				nfsm_chain_adv(error, &amp;nmrep, nfsm_rndup(len));
			<span class="enscript-keyword">if</span> (!error &amp;&amp; s) {
				s[len] = <span class="enscript-string">'\0'</span>;
				<span class="enscript-keyword">if</span> (nfs4_id2guid(s, &amp;ace.ace_applicable, (ace_flags &amp; NFS_ACE_IDENTIFIER_GROUP)))
					ace.ace_flags = 0;
			}
			<span class="enscript-keyword">if</span> (error || !s)
				ace.ace_flags = 0;
			<span class="enscript-keyword">if</span> (s &amp;&amp; (s != sbuf))
				FREE(s, M_TEMP);
			<span class="enscript-keyword">if</span> (!error) {
				<span class="enscript-comment">/* stuff the latest delegation state in the node */</span>
				lck_mtx_lock(&amp;np-&gt;n_openlock);
				np-&gt;n_openflags &amp;= ~N_DELEG_MASK;
				np-&gt;n_openflags |= ((delegation == NFS_OPEN_DELEGATE_READ) ? N_DELEG_READ : N_DELEG_WRITE);
				np-&gt;n_dstateid = dstateid;
				np-&gt;n_dace = ace;
				<span class="enscript-keyword">if</span> (np-&gt;n_dlink.tqe_next == NFSNOLIST) {
					lck_mtx_lock(&amp;nmp-&gt;nm_lock);
					<span class="enscript-keyword">if</span> (np-&gt;n_dlink.tqe_next == NFSNOLIST)
						TAILQ_INSERT_TAIL(&amp;nmp-&gt;nm_delegations, np, n_dlink);
					lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
				}
				lck_mtx_unlock(&amp;np-&gt;n_openlock);
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			error = EBADRPC;
			<span class="enscript-keyword">break</span>;
		}
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	error = nfs4_parsefattr(&amp;nmrep, NULL, &amp;nvattr, &amp;fh, NULL, NULL);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (!NFS_BITMAP_ISSET(nvattr.nva_bitmap, NFS_FATTR_FILEHANDLE)) {
		printf(<span class="enscript-string">&quot;nfs: open reclaim didn't return filehandle? %s\n&quot;</span>, filename ? filename : <span class="enscript-string">&quot;???&quot;</span>);
		error = EBADRPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}
	<span class="enscript-keyword">if</span> (!NFS_CMPFH(np, fh.fh_data, fh.fh_len)) {
		<span class="enscript-comment">// XXX what if fh doesn't match the vnode we think we're re-opening?
</span>		<span class="enscript-comment">// Solaris Named Attributes may do this due to a bug.... so don't warn for named attributes.
</span>		<span class="enscript-keyword">if</span> (!(np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_IS_ATTR))
			printf(<span class="enscript-string">&quot;nfs4_claim_delegated_open_rpc: warning: file handle mismatch %s\n&quot;</span>, filename ? filename : <span class="enscript-string">&quot;???&quot;</span>);
	}
	error = nfs_loadattrcache(np, &amp;nvattr, &amp;xid, 1);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (rflags &amp; NFS_OPEN_RESULT_LOCKTYPE_POSIX)
		nofp-&gt;nof_flags |= NFS_OPEN_FILE_POSIXLOCK;
<span class="enscript-reference">nfsmout</span>:
	NVATTR_CLEANUP(&amp;nvattr);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfs_open_owner_clear_busy(noop);
	<span class="enscript-keyword">if</span> ((delegation == NFS_OPEN_DELEGATE_READ) || (delegation == NFS_OPEN_DELEGATE_WRITE)) {
		<span class="enscript-keyword">if</span> (recall) {
			<span class="enscript-comment">/*
			 * We're making a delegated claim.
			 * Don't return the delegation here in case we have more to claim.
			 * Just make sure it's queued up to be returned.
			 */</span>
			nfs4_delegation_return_enqueue(np);
		}
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">// if (!error)
</span>	<span class="enscript-comment">// 	printf(&quot;nfs: open claim delegated (%d, %d) succeeded for %s\n&quot;, share_access, share_deny, filename ? filename : &quot;???&quot;);
</span>	<span class="enscript-keyword">if</span> (filename &amp;&amp; (filename != &amp;smallname[0]))
		FREE(filename, M_TEMP);
	<span class="enscript-keyword">if</span> (vname)
		vnode_putname(vname);
	<span class="enscript-keyword">if</span> (dvp != NULLVP)
		vnode_put(dvp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Send an OPEN RPC to reclaim an open file.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_open_reclaim_rpc</span>(
	<span class="enscript-type">struct</span> nfs_open_file *nofp,
	<span class="enscript-type">int</span> share_access,
	<span class="enscript-type">int</span> share_deny)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_open_owner *noop = nofp-&gt;nof_owner;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, status;
	<span class="enscript-type">int</span> nfsvers, numops;
	u_int64_t xid;
	nfsnode_t np = nofp-&gt;nof_np;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	uint32_t bitmap[NFS_ATTR_BITMAP_LEN], bmlen;
	uint32_t rflags = 0, delegation, recall = 0;
	fhandle_t fh;
	<span class="enscript-type">struct</span> nfs_stateid dstateid;
	<span class="enscript-type">char</span> sbuf[64], *s = sbuf;
	uint32_t ace_type, ace_flags, ace_mask, len, slen = <span class="enscript-keyword">sizeof</span>(sbuf);
	<span class="enscript-type">struct</span> kauth_ace ace;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	<span class="enscript-keyword">if</span> ((error = nfs_open_owner_set_busy(noop, NULL)))
		<span class="enscript-keyword">return</span> (error);

	NVATTR_INIT(&amp;nvattr);
	delegation = NFS_OPEN_DELEGATE_NONE;
	dstateid = np-&gt;n_dstateid;
	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, OPEN, GETATTR(FH)
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 48 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;open_reclaim&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_OPEN);
	nfsm_chain_add_32(error, &amp;nmreq, noop-&gt;noo_seqid);
	nfsm_chain_add_32(error, &amp;nmreq, share_access);
	nfsm_chain_add_32(error, &amp;nmreq, share_deny);
	<span class="enscript-comment">// open owner: clientid + uid
</span>	nfsm_chain_add_64(error, &amp;nmreq, nmp-&gt;nm_clientid); <span class="enscript-comment">// open_owner4.clientid
</span>	nfsm_chain_add_32(error, &amp;nmreq, NFSX_UNSIGNED);
	nfsm_chain_add_32(error, &amp;nmreq, kauth_cred_getuid(noop-&gt;noo_cred)); <span class="enscript-comment">// open_owner4.owner
</span>	<span class="enscript-comment">// openflag4
</span>	nfsm_chain_add_32(error, &amp;nmreq, NFS_OPEN_NOCREATE);
	<span class="enscript-comment">// open_claim4
</span>	nfsm_chain_add_32(error, &amp;nmreq, NFS_CLAIM_PREVIOUS);
	delegation = (np-&gt;n_openflags &amp; N_DELEG_READ) ? NFS_OPEN_DELEGATE_READ :
			(np-&gt;n_openflags &amp; N_DELEG_WRITE) ? NFS_OPEN_DELEGATE_WRITE :
			NFS_OPEN_DELEGATE_NONE;
	nfsm_chain_add_32(error, &amp;nmreq, delegation);
	delegation = NFS_OPEN_DELEGATE_NONE;
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	NFS_COPY_ATTRIBUTES(nfs_getattr_bitmap, bitmap);
	NFS_BITMAP_SET(bitmap, NFS_FATTR_FILEHANDLE);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, bitmap, nmp, np);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);

	error = nfs_request2(np, nmp-&gt;nm_mountp, &amp;nmreq, NFSPROC4_COMPOUND, current_thread(),
			noop-&gt;noo_cred, &amp;si, R_RECOVER|R_NOINTR, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_OPEN);
	nfs_owner_seqid_increment(noop, NULL, error);
	nfsm_chain_get_stateid(error, &amp;nmrep, &amp;nofp-&gt;nof_stateid);
	nfsm_chain_check_change_info(error, &amp;nmrep, np);
	nfsm_chain_get_32(error, &amp;nmrep, rflags);
	bmlen = NFS_ATTR_BITMAP_LEN;
	nfsm_chain_get_bitmap(error, &amp;nmrep, bitmap, bmlen);
	nfsm_chain_get_32(error, &amp;nmrep, delegation);
	<span class="enscript-keyword">if</span> (!error)
		<span class="enscript-keyword">switch</span> (delegation) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_OPEN_DELEGATE_NONE</span>:
			<span class="enscript-keyword">if</span> (np-&gt;n_openflags &amp; N_DELEG_MASK) {
				<span class="enscript-comment">/*
				 * Hey!  We were supposed to get our delegation back even
				 * if it was getting immediately recalled.  Bad server!
				 *
				 * Just try to return the existing delegation.
				 */</span>
				<span class="enscript-comment">// NP(np, &quot;nfs: open reclaim didn't return delegation?&quot;);
</span>				delegation = (np-&gt;n_openflags &amp; N_DELEG_WRITE) ? NFS_OPEN_DELEGATE_WRITE : NFS_OPEN_DELEGATE_READ;
				recall = 1;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_OPEN_DELEGATE_READ</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_OPEN_DELEGATE_WRITE</span>:
			nfsm_chain_get_stateid(error, &amp;nmrep, &amp;dstateid);
			nfsm_chain_get_32(error, &amp;nmrep, recall);
			<span class="enscript-keyword">if</span> (delegation == NFS_OPEN_DELEGATE_WRITE) <span class="enscript-comment">// space (skip) XXX
</span>				nfsm_chain_adv(error, &amp;nmrep, 3 * NFSX_UNSIGNED);
			<span class="enscript-comment">/* if we have any trouble accepting the ACE, just invalidate it */</span>
			ace_type = ace_flags = ace_mask = len = 0;
			nfsm_chain_get_32(error, &amp;nmrep, ace_type);
			nfsm_chain_get_32(error, &amp;nmrep, ace_flags);
			nfsm_chain_get_32(error, &amp;nmrep, ace_mask);
			nfsm_chain_get_32(error, &amp;nmrep, len);
			ace.ace_flags = nfs4_ace_nfstype_to_vfstype(ace_type, &amp;error);
			ace.ace_flags |= nfs4_ace_nfsflags_to_vfsflags(ace_flags);
			ace.ace_rights = nfs4_ace_nfsmask_to_vfsrights(ace_mask);
			<span class="enscript-keyword">if</span> (!error &amp;&amp; (len &gt;= slen)) {
				MALLOC(s, <span class="enscript-type">char</span>*, len+1, M_TEMP, M_WAITOK);
				<span class="enscript-keyword">if</span> (s)
					slen = len+1;
				<span class="enscript-keyword">else</span>
					ace.ace_flags = 0;
			}
			<span class="enscript-keyword">if</span> (s)
				nfsm_chain_get_opaque(error, &amp;nmrep, len, s);
			<span class="enscript-keyword">else</span>
				nfsm_chain_adv(error, &amp;nmrep, nfsm_rndup(len));
			<span class="enscript-keyword">if</span> (!error &amp;&amp; s) {
				s[len] = <span class="enscript-string">'\0'</span>;
				<span class="enscript-keyword">if</span> (nfs4_id2guid(s, &amp;ace.ace_applicable, (ace_flags &amp; NFS_ACE_IDENTIFIER_GROUP)))
					ace.ace_flags = 0;
			}
			<span class="enscript-keyword">if</span> (error || !s)
				ace.ace_flags = 0;
			<span class="enscript-keyword">if</span> (s &amp;&amp; (s != sbuf))
				FREE(s, M_TEMP);
			<span class="enscript-keyword">if</span> (!error) {
				<span class="enscript-comment">/* stuff the delegation state in the node */</span>
				lck_mtx_lock(&amp;np-&gt;n_openlock);
				np-&gt;n_openflags &amp;= ~N_DELEG_MASK;
				np-&gt;n_openflags |= ((delegation == NFS_OPEN_DELEGATE_READ) ? N_DELEG_READ : N_DELEG_WRITE);
				np-&gt;n_dstateid = dstateid;
				np-&gt;n_dace = ace;
				<span class="enscript-keyword">if</span> (np-&gt;n_dlink.tqe_next == NFSNOLIST) {
					lck_mtx_lock(&amp;nmp-&gt;nm_lock);
					<span class="enscript-keyword">if</span> (np-&gt;n_dlink.tqe_next == NFSNOLIST)
						TAILQ_INSERT_TAIL(&amp;nmp-&gt;nm_delegations, np, n_dlink);
					lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
				}
				lck_mtx_unlock(&amp;np-&gt;n_openlock);
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			error = EBADRPC;
			<span class="enscript-keyword">break</span>;
		}
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	error = nfs4_parsefattr(&amp;nmrep, NULL, &amp;nvattr, &amp;fh, NULL, NULL);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (!NFS_BITMAP_ISSET(nvattr.nva_bitmap, NFS_FATTR_FILEHANDLE)) {
		NP(np, <span class="enscript-string">&quot;nfs: open reclaim didn't return filehandle?&quot;</span>);
		error = EBADRPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}
	<span class="enscript-keyword">if</span> (!NFS_CMPFH(np, fh.fh_data, fh.fh_len)) {
		<span class="enscript-comment">// XXX what if fh doesn't match the vnode we think we're re-opening?
</span>		<span class="enscript-comment">// That should be pretty hard in this case, given that we are doing
</span>		<span class="enscript-comment">// the open reclaim using the file handle (and not a dir/name pair).
</span>		<span class="enscript-comment">// Solaris Named Attributes may do this due to a bug.... so don't warn for named attributes.
</span>		<span class="enscript-keyword">if</span> (!(np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_IS_ATTR))
			NP(np, <span class="enscript-string">&quot;nfs4_open_reclaim_rpc: warning: file handle mismatch&quot;</span>);
	}
	error = nfs_loadattrcache(np, &amp;nvattr, &amp;xid, 1);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (rflags &amp; NFS_OPEN_RESULT_LOCKTYPE_POSIX)
		nofp-&gt;nof_flags |= NFS_OPEN_FILE_POSIXLOCK;
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-comment">// if (!error)
</span>	<span class="enscript-comment">// 	NP(np, &quot;nfs: open reclaim (%d, %d) succeeded&quot;, share_access, share_deny);
</span>	NVATTR_CLEANUP(&amp;nvattr);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfs_open_owner_clear_busy(noop);
	<span class="enscript-keyword">if</span> ((delegation == NFS_OPEN_DELEGATE_READ) || (delegation == NFS_OPEN_DELEGATE_WRITE)) {
		<span class="enscript-keyword">if</span> (recall)
			nfs4_delegation_return_enqueue(np);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_open_downgrade_rpc</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_open_file *nofp,
	vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfs_open_owner *noop = nofp-&gt;nof_owner;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error, lockerror = ENOENT, status, nfsvers, numops;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	<span class="enscript-keyword">if</span> ((error = nfs_open_owner_set_busy(noop, NULL)))
		<span class="enscript-keyword">return</span> (error);

	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, OPEN_DOWNGRADE, GETATTR
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 23 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;open_downgrd&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_OPEN_DOWNGRADE);
	nfsm_chain_add_stateid(error, &amp;nmreq, &amp;nofp-&gt;nof_stateid);
	nfsm_chain_add_32(error, &amp;nmreq, noop-&gt;noo_seqid);
	nfsm_chain_add_32(error, &amp;nmreq, nofp-&gt;nof_access);
	nfsm_chain_add_32(error, &amp;nmreq, nofp-&gt;nof_deny);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, np);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request2(np, NULL, &amp;nmreq, NFSPROC4_COMPOUND,
			vfs_context_thread(ctx), vfs_context_ucred(ctx),
			&amp;si, R_NOINTR, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_OPEN_DOWNGRADE);
	nfs_owner_seqid_increment(noop, NULL, error);
	nfsm_chain_get_stateid(error, &amp;nmrep, &amp;nofp-&gt;nof_stateid);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsm_chain_loadattr(error, &amp;nmrep, np, nfsvers, &amp;xid);
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfs_open_owner_clear_busy(noop);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_close_rpc</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_open_file *nofp,
	thread_t thd,
	kauth_cred_t cred,
	<span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> nfs_open_owner *noop = nofp-&gt;nof_owner;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error, lockerror = ENOENT, status, nfsvers, numops;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	<span class="enscript-keyword">if</span> ((error = nfs_open_owner_set_busy(noop, NULL)))
		<span class="enscript-keyword">return</span> (error);

	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, CLOSE, GETATTR
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 23 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;close&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_CLOSE);
	nfsm_chain_add_32(error, &amp;nmreq, noop-&gt;noo_seqid);
	nfsm_chain_add_stateid(error, &amp;nmreq, &amp;nofp-&gt;nof_stateid);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, np);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request2(np, NULL, &amp;nmreq, NFSPROC4_COMPOUND, thd, cred, &amp;si, flags|R_NOINTR, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_CLOSE);
	nfs_owner_seqid_increment(noop, NULL, error);
	nfsm_chain_get_stateid(error, &amp;nmrep, &amp;nofp-&gt;nof_stateid);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsm_chain_loadattr(error, &amp;nmrep, np, nfsvers, &amp;xid);
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfs_open_owner_clear_busy(noop);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Claim the delegated open combinations this open file holds.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_claim_delegated_state_for_open_file</span>(<span class="enscript-type">struct</span> nfs_open_file *nofp, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> nfs_open_owner *noop = nofp-&gt;nof_owner;
	<span class="enscript-type">struct</span> nfs_lock_owner *nlop;
	<span class="enscript-type">struct</span> nfs_file_lock *nflp, *nextnflp;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, reopen = 0;

	<span class="enscript-keyword">if</span> (nofp-&gt;nof_d_rw_drw) {
		error = nfs4_claim_delegated_open_rpc(nofp, NFS_OPEN_SHARE_ACCESS_BOTH, NFS_OPEN_SHARE_DENY_BOTH, flags);
		<span class="enscript-keyword">if</span> (!error) {
			lck_mtx_lock(&amp;nofp-&gt;nof_lock);
			nofp-&gt;nof_rw_drw += nofp-&gt;nof_d_rw_drw;
			nofp-&gt;nof_d_rw_drw = 0;
			lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
		}
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; nofp-&gt;nof_d_w_drw) {
		error = nfs4_claim_delegated_open_rpc(nofp, NFS_OPEN_SHARE_ACCESS_WRITE, NFS_OPEN_SHARE_DENY_BOTH, flags);
		<span class="enscript-keyword">if</span> (!error) {
			lck_mtx_lock(&amp;nofp-&gt;nof_lock);
			nofp-&gt;nof_w_drw += nofp-&gt;nof_d_w_drw;
			nofp-&gt;nof_d_w_drw = 0;
			lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
		}
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; nofp-&gt;nof_d_r_drw) {
		error = nfs4_claim_delegated_open_rpc(nofp, NFS_OPEN_SHARE_ACCESS_READ, NFS_OPEN_SHARE_DENY_BOTH, flags);
		<span class="enscript-keyword">if</span> (!error) {
			lck_mtx_lock(&amp;nofp-&gt;nof_lock);
			nofp-&gt;nof_r_drw += nofp-&gt;nof_d_r_drw;
			nofp-&gt;nof_d_r_drw = 0;
			lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
		}
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; nofp-&gt;nof_d_rw_dw) {
		error = nfs4_claim_delegated_open_rpc(nofp, NFS_OPEN_SHARE_ACCESS_BOTH, NFS_OPEN_SHARE_DENY_WRITE, flags);
		<span class="enscript-keyword">if</span> (!error) {
			lck_mtx_lock(&amp;nofp-&gt;nof_lock);
			nofp-&gt;nof_rw_dw += nofp-&gt;nof_d_rw_dw;
			nofp-&gt;nof_d_rw_dw = 0;
			lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
		}
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; nofp-&gt;nof_d_w_dw) {
		error = nfs4_claim_delegated_open_rpc(nofp, NFS_OPEN_SHARE_ACCESS_WRITE, NFS_OPEN_SHARE_DENY_WRITE, flags);
		<span class="enscript-keyword">if</span> (!error) {
			lck_mtx_lock(&amp;nofp-&gt;nof_lock);
			nofp-&gt;nof_w_dw += nofp-&gt;nof_d_w_dw;
			nofp-&gt;nof_d_w_dw = 0;
			lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
		}
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; nofp-&gt;nof_d_r_dw) {
		error = nfs4_claim_delegated_open_rpc(nofp, NFS_OPEN_SHARE_ACCESS_READ, NFS_OPEN_SHARE_DENY_WRITE, flags);
		<span class="enscript-keyword">if</span> (!error) {
			lck_mtx_lock(&amp;nofp-&gt;nof_lock);
			nofp-&gt;nof_r_dw += nofp-&gt;nof_d_r_dw;
			nofp-&gt;nof_d_r_dw = 0;
			lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
		}
	}
	<span class="enscript-comment">/* non-deny-mode opens may be reopened if no locks are held */</span>
	<span class="enscript-keyword">if</span> (!error &amp;&amp; nofp-&gt;nof_d_rw) {
		error = nfs4_claim_delegated_open_rpc(nofp, NFS_OPEN_SHARE_ACCESS_BOTH, NFS_OPEN_SHARE_DENY_NONE, flags);
		<span class="enscript-comment">/* for some errors, we should just try reopening the file */</span>
		<span class="enscript-keyword">if</span> (nfs_mount_state_error_delegation_lost(error))
			reopen = error;
		<span class="enscript-keyword">if</span> (!error || reopen) {
			lck_mtx_lock(&amp;nofp-&gt;nof_lock);
			nofp-&gt;nof_rw += nofp-&gt;nof_d_rw;
			nofp-&gt;nof_d_rw = 0;
			lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
		}
	}
	<span class="enscript-comment">/* if we've already set reopen, we should move these other two opens from delegated to not delegated */</span>
	<span class="enscript-keyword">if</span> ((!error || reopen) &amp;&amp; nofp-&gt;nof_d_w) {
		<span class="enscript-keyword">if</span> (!error) {
			error = nfs4_claim_delegated_open_rpc(nofp, NFS_OPEN_SHARE_ACCESS_WRITE, NFS_OPEN_SHARE_DENY_NONE, flags);
			<span class="enscript-comment">/* for some errors, we should just try reopening the file */</span>
			<span class="enscript-keyword">if</span> (nfs_mount_state_error_delegation_lost(error))
				reopen = error;
		}
		<span class="enscript-keyword">if</span> (!error || reopen) {
			lck_mtx_lock(&amp;nofp-&gt;nof_lock);
			nofp-&gt;nof_w += nofp-&gt;nof_d_w;
			nofp-&gt;nof_d_w = 0;
			lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
		}
	}
	<span class="enscript-keyword">if</span> ((!error || reopen) &amp;&amp; nofp-&gt;nof_d_r) {
		<span class="enscript-keyword">if</span> (!error) {
			error = nfs4_claim_delegated_open_rpc(nofp, NFS_OPEN_SHARE_ACCESS_READ, NFS_OPEN_SHARE_DENY_NONE, flags);
			<span class="enscript-comment">/* for some errors, we should just try reopening the file */</span>
			<span class="enscript-keyword">if</span> (nfs_mount_state_error_delegation_lost(error))
				reopen = error;
		}
		<span class="enscript-keyword">if</span> (!error || reopen) {
			lck_mtx_lock(&amp;nofp-&gt;nof_lock);
			nofp-&gt;nof_r += nofp-&gt;nof_d_r;
			nofp-&gt;nof_d_r = 0;
			lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
		}
	}

	<span class="enscript-keyword">if</span> (reopen) {
		<span class="enscript-comment">/*
		 * Any problems with the delegation probably indicates that we
		 * should review/return all of our current delegation state.
		 */</span>
		<span class="enscript-keyword">if</span> ((nmp = NFSTONMP(nofp-&gt;nof_np))) {
			nfs4_delegation_return_enqueue(nofp-&gt;nof_np);
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			nfs_need_recover(nmp, NFSERR_EXPIRED);
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		}
		<span class="enscript-keyword">if</span> (reopen &amp;&amp; (nfs_check_for_locks(noop, nofp) == 0)) {
			<span class="enscript-comment">/* just reopen the file on next access */</span>
			NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs4_claim_delegated_state_for_open_file: %d, need reopen, %d&quot;</span>,
				reopen, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
			lck_mtx_lock(&amp;nofp-&gt;nof_lock);
			nofp-&gt;nof_flags |= NFS_OPEN_FILE_REOPEN;
			lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
			<span class="enscript-keyword">return</span> (0);
		}
		<span class="enscript-keyword">if</span> (reopen)
			NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs4_claim_delegated_state_for_open_file: %d, locks prevent reopen, %d&quot;</span>,
				reopen, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
	}

	<span class="enscript-keyword">if</span> (!error &amp;&amp; ((nmp = NFSTONMP(nofp-&gt;nof_np)))) {
		<span class="enscript-comment">/* claim delegated locks */</span>
		TAILQ_FOREACH(nlop, &amp;nofp-&gt;nof_np-&gt;n_lock_owners, nlo_link) {
			<span class="enscript-keyword">if</span> (nlop-&gt;nlo_open_owner != noop)
				<span class="enscript-keyword">continue</span>;
			TAILQ_FOREACH_SAFE(nflp, &amp;nlop-&gt;nlo_locks, nfl_lolink, nextnflp) {
				<span class="enscript-comment">/* skip dead &amp; blocked lock requests (shouldn't be any in the held lock list) */</span>
				<span class="enscript-keyword">if</span> (nflp-&gt;nfl_flags &amp; (NFS_FILE_LOCK_DEAD|NFS_FILE_LOCK_BLOCKED))
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-comment">/* skip non-delegated locks */</span>
				<span class="enscript-keyword">if</span> (!(nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_DELEGATED))
					<span class="enscript-keyword">continue</span>;
				error = nmp-&gt;nm_funcs-&gt;nf_setlock_rpc(nofp-&gt;nof_np, nofp, nflp, 0, flags, current_thread(), noop-&gt;noo_cred);
				<span class="enscript-keyword">if</span> (error) {
					NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs: delegated lock claim (0x%llx, 0x%llx) failed %d, %d&quot;</span>,
						nflp-&gt;nfl_start, nflp-&gt;nfl_end, error, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-comment">// else {
</span>				<span class="enscript-comment">// 	NP(nofp-&gt;nof_np, &quot;nfs: delegated lock claim (0x%llx, 0x%llx) succeeded, %d&quot;,
</span>				<span class="enscript-comment">// 		nflp-&gt;nfl_start, nflp-&gt;nfl_end, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
</span>				<span class="enscript-comment">// }
</span>			}
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (!error)  <span class="enscript-comment">/* all state claimed successfully! */</span>
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/* restart if it looks like a problem more than just losing the delegation */</span>
	<span class="enscript-keyword">if</span> (!nfs_mount_state_error_delegation_lost(error) &amp;&amp;
	    ((error == ETIMEDOUT) || nfs_mount_state_error_should_restart(error))) {
		NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs delegated lock claim error %d, %d&quot;</span>, error, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));
		<span class="enscript-keyword">if</span> ((error == ETIMEDOUT) &amp;&amp; ((nmp = NFSTONMP(nofp-&gt;nof_np))))
			nfs_need_reconnect(nmp);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* delegated state lost (once held but now not claimable) */</span> 
	NP(nofp-&gt;nof_np, <span class="enscript-string">&quot;nfs delegated state claim error %d, state lost, %d&quot;</span>, error, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred));

	<span class="enscript-comment">/*
	 * Any problems with the delegation probably indicates that we
	 * should review/return all of our current delegation state.
	 */</span>
	<span class="enscript-keyword">if</span> ((nmp = NFSTONMP(nofp-&gt;nof_np))) {
		nfs4_delegation_return_enqueue(nofp-&gt;nof_np);
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		nfs_need_recover(nmp, NFSERR_EXPIRED);
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	}

	<span class="enscript-comment">/* revoke all open file state */</span>
	nfs_revoke_open_state_for_node(nofp-&gt;nof_np);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Release all open state for the given node.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_release_open_state_for_node</span>(nfsnode_t np, <span class="enscript-type">int</span> force)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(np);
	<span class="enscript-type">struct</span> nfs_open_file *nofp;
	<span class="enscript-type">struct</span> nfs_file_lock *nflp, *nextnflp;

	<span class="enscript-comment">/* drop held locks */</span>
	TAILQ_FOREACH_SAFE(nflp, &amp;np-&gt;n_locks, nfl_link, nextnflp) {
		<span class="enscript-comment">/* skip dead &amp; blocked lock requests */</span>
		<span class="enscript-keyword">if</span> (nflp-&gt;nfl_flags &amp; (NFS_FILE_LOCK_DEAD|NFS_FILE_LOCK_BLOCKED))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-comment">/* send an unlock if not a delegated lock */</span>
		<span class="enscript-keyword">if</span> (!force &amp;&amp; nmp &amp;&amp; !(nflp-&gt;nfl_flags &amp; NFS_FILE_LOCK_DELEGATED))
			nmp-&gt;nm_funcs-&gt;nf_unlock_rpc(np, nflp-&gt;nfl_owner, F_WRLCK, nflp-&gt;nfl_start, nflp-&gt;nfl_end, R_RECOVER,
				NULL, nflp-&gt;nfl_owner-&gt;nlo_open_owner-&gt;noo_cred);
		<span class="enscript-comment">/* kill/remove the lock */</span>
		lck_mtx_lock(&amp;np-&gt;n_openlock);
		nflp-&gt;nfl_flags |= NFS_FILE_LOCK_DEAD;
		lck_mtx_lock(&amp;nflp-&gt;nfl_owner-&gt;nlo_lock);
		TAILQ_REMOVE(&amp;nflp-&gt;nfl_owner-&gt;nlo_locks, nflp, nfl_lolink);
		lck_mtx_unlock(&amp;nflp-&gt;nfl_owner-&gt;nlo_lock);
		<span class="enscript-keyword">if</span> (nflp-&gt;nfl_blockcnt) {
			<span class="enscript-comment">/* wake up anyone blocked on this lock */</span>
			wakeup(nflp);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* remove nflp from lock list and destroy */</span>
			TAILQ_REMOVE(&amp;np-&gt;n_locks, nflp, nfl_link);
			nfs_file_lock_destroy(nflp);
		}
		lck_mtx_unlock(&amp;np-&gt;n_openlock);
	}

	lck_mtx_lock(&amp;np-&gt;n_openlock);

	<span class="enscript-comment">/* drop all opens */</span>
	TAILQ_FOREACH(nofp, &amp;np-&gt;n_opens, nof_link) {
		<span class="enscript-keyword">if</span> (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-comment">/* mark open state as lost */</span>
		lck_mtx_lock(&amp;nofp-&gt;nof_lock);
		nofp-&gt;nof_flags &amp;= ~NFS_OPEN_FILE_REOPEN;
		nofp-&gt;nof_flags |= NFS_OPEN_FILE_LOST;
		
		lck_mtx_unlock(&amp;nofp-&gt;nof_lock);
		<span class="enscript-keyword">if</span> (!force &amp;&amp; nmp &amp;&amp; (nmp-&gt;nm_vers &gt;= NFS_VER4))
			nfs4_close_rpc(np, nofp, NULL, nofp-&gt;nof_owner-&gt;noo_cred, R_RECOVER);
	}

	lck_mtx_unlock(&amp;np-&gt;n_openlock);
}

<span class="enscript-comment">/*
 * State for a node has been lost, drop it, and revoke the node.
 * Attempt to return any state if possible in case the server
 * might somehow think we hold it.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_revoke_open_state_for_node</span>(nfsnode_t np)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;

	<span class="enscript-comment">/* mark node as needing to be revoked */</span>
	nfs_node_lock_force(np);
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE)  <span class="enscript-comment">/* already revoked? */</span>
	{
		NP(np, <span class="enscript-string">&quot;nfs_revoke_open_state_for_node(): already revoked&quot;</span>);
		nfs_node_unlock(np);
		<span class="enscript-keyword">return</span>;
	}
	np-&gt;n_flag |= NREVOKE;
	nfs_node_unlock(np);

	nfs_release_open_state_for_node(np, 0);
	NP(np, <span class="enscript-string">&quot;nfs: state lost for %p 0x%x&quot;</span>, np, np-&gt;n_flag);

	<span class="enscript-comment">/* mark mount as needing a revoke scan and have the socket thread do it. */</span>
	<span class="enscript-keyword">if</span> ((nmp = NFSTONMP(np))) {
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		nmp-&gt;nm_state |= NFSSTA_REVOKE;
		nfs_mount_sock_thread_wake(nmp);
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	}
}

<span class="enscript-comment">/*
 * Claim the delegated open combinations that each of this node's open files hold.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_claim_delegated_state_for_node</span>(nfsnode_t np, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> nfs_open_file *nofp;
	<span class="enscript-type">int</span> error = 0;

	lck_mtx_lock(&amp;np-&gt;n_openlock);

	<span class="enscript-comment">/* walk the open file list looking for opens with delegated state to claim */</span>
<span class="enscript-reference">restart</span>:
	TAILQ_FOREACH(nofp, &amp;np-&gt;n_opens, nof_link) {
		<span class="enscript-keyword">if</span> (!nofp-&gt;nof_d_rw_drw &amp;&amp; !nofp-&gt;nof_d_w_drw &amp;&amp; !nofp-&gt;nof_d_r_drw &amp;&amp;
		    !nofp-&gt;nof_d_rw_dw &amp;&amp; !nofp-&gt;nof_d_w_dw &amp;&amp; !nofp-&gt;nof_d_r_dw &amp;&amp;
		    !nofp-&gt;nof_d_rw &amp;&amp; !nofp-&gt;nof_d_w &amp;&amp; !nofp-&gt;nof_d_r)
			<span class="enscript-keyword">continue</span>;
		lck_mtx_unlock(&amp;np-&gt;n_openlock);
		error = nfs4_claim_delegated_state_for_open_file(nofp, flags);
		lck_mtx_lock(&amp;np-&gt;n_openlock);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}

	lck_mtx_unlock(&amp;np-&gt;n_openlock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Mark a node as needed to have its delegation returned.
 * Queue it up on the delegation return queue.
 * Make sure the thread is running.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs4_delegation_return_enqueue</span>(nfsnode_t np)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span>;

	lck_mtx_lock(&amp;np-&gt;n_openlock);
	np-&gt;n_openflags |= N_DELEG_RETURN;
	lck_mtx_unlock(&amp;np-&gt;n_openlock);

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (np-&gt;n_dreturn.tqe_next == NFSNOLIST)
		TAILQ_INSERT_TAIL(&amp;nmp-&gt;nm_dreturnq, np, n_dreturn);
	nfs_mount_sock_thread_wake(nmp);
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
}

<span class="enscript-comment">/*
 * return any delegation we may have for the given node
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_delegation_return</span>(nfsnode_t np, <span class="enscript-type">int</span> flags, thread_t thd, kauth_cred_t cred)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	fhandle_t fh;
	nfs_stateid dstateid;
	<span class="enscript-type">int</span> error;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-comment">/* first, make sure the node's marked for delegation return */</span>
	lck_mtx_lock(&amp;np-&gt;n_openlock);
	np-&gt;n_openflags |= (N_DELEG_RETURN|N_DELEG_RETURNING);
	lck_mtx_unlock(&amp;np-&gt;n_openlock);

	<span class="enscript-comment">/* make sure nobody else is using the delegation state */</span>
	<span class="enscript-keyword">if</span> ((error = nfs_open_state_set_busy(np, NULL)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* claim any delegated state */</span>
	<span class="enscript-keyword">if</span> ((error = nfs4_claim_delegated_state_for_node(np, flags)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* return the delegation */</span>
	lck_mtx_lock(&amp;np-&gt;n_openlock);
	dstateid = np-&gt;n_dstateid;
	fh.fh_len = np-&gt;n_fhsize;
	bcopy(np-&gt;n_fhp, &amp;fh.fh_data, fh.fh_len);
	lck_mtx_unlock(&amp;np-&gt;n_openlock);
	error = nfs4_delegreturn_rpc(NFSTONMP(np), fh.fh_data, fh.fh_len, &amp;dstateid, flags, thd, cred);
	<span class="enscript-comment">/* assume delegation is gone for all errors except ETIMEDOUT, NFSERR_*MOVED */</span>
	<span class="enscript-keyword">if</span> ((error != ETIMEDOUT) &amp;&amp; (error != NFSERR_MOVED) &amp;&amp; (error != NFSERR_LEASE_MOVED)) {
		lck_mtx_lock(&amp;np-&gt;n_openlock);
		np-&gt;n_openflags &amp;= ~N_DELEG_MASK;
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">if</span> (np-&gt;n_dlink.tqe_next != NFSNOLIST) {
			TAILQ_REMOVE(&amp;nmp-&gt;nm_delegations, np, n_dlink);
			np-&gt;n_dlink.tqe_next = NFSNOLIST;
		}
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		lck_mtx_unlock(&amp;np-&gt;n_openlock);
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/* make sure it's no longer on the return queue and clear the return flags */</span>
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (np-&gt;n_dreturn.tqe_next != NFSNOLIST) {
		TAILQ_REMOVE(&amp;nmp-&gt;nm_dreturnq, np, n_dreturn);
		np-&gt;n_dreturn.tqe_next = NFSNOLIST;
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	lck_mtx_lock(&amp;np-&gt;n_openlock);
	np-&gt;n_openflags &amp;= ~(N_DELEG_RETURN|N_DELEG_RETURNING);
	lck_mtx_unlock(&amp;np-&gt;n_openlock);

	<span class="enscript-keyword">if</span> (error) {
		NP(np, <span class="enscript-string">&quot;nfs4_delegation_return, error %d&quot;</span>, error);
		<span class="enscript-keyword">if</span> (error == ETIMEDOUT)
			nfs_need_reconnect(nmp);
		<span class="enscript-keyword">if</span> (nfs_mount_state_error_should_restart(error)) {
			<span class="enscript-comment">/* make sure recovery happens */</span>
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			nfs_need_recover(nmp, nfs_mount_state_error_delegation_lost(error) ? NFSERR_EXPIRED : 0);
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		}
	}

	nfs_open_state_clear_busy(np);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * RPC to return a delegation for a file handle
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_delegreturn_rpc</span>(<span class="enscript-type">struct</span> nfsmount *nmp, u_char *fhp, <span class="enscript-type">int</span> fhlen, <span class="enscript-type">struct</span> nfs_stateid *sid, <span class="enscript-type">int</span> flags, thread_t thd, kauth_cred_t cred)
{
	<span class="enscript-type">int</span> error = 0, status, numops;
	uint64_t xid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	NFSREQ_SECINFO_SET(&amp;si, NULL, fhp, fhlen, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, DELEGRETURN
</span>	numops = 2;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 16 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;delegreturn&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nmp-&gt;nm_vers, fhp, fhlen);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_DELEGRETURN);
	nfsm_chain_add_stateid(error, &amp;nmreq, sid);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request2(NULL, nmp-&gt;nm_mountp, &amp;nmreq, NFSPROC4_COMPOUND, thd, cred, &amp;si, flags, &amp;nmrep, &amp;xid, &amp;status);
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_DELEGRETURN);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * NFS read call.
 * Just call nfs_bioread() to do the work.
 *
 * Note: the exec code paths have a tendency to call VNOP_READ (and VNOP_MMAP)
 * without first calling VNOP_OPEN, so we make sure the file is open here.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vnop_read</span>(
	<span class="enscript-type">struct</span> vnop_read_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		struct uio *a_uio;
		int a_ioflag;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vnode_t vp = ap-&gt;a_vp;
	vfs_context_t ctx = ap-&gt;a_context;
	nfsnode_t np;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_open_owner *noop;
	<span class="enscript-type">struct</span> nfs_open_file *nofp;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (vnode_vtype(ap-&gt;a_vp) != VREG)
		<span class="enscript-keyword">return</span> (vnode_vtype(vp) == VDIR) ? EISDIR : EPERM;

	np = VTONFS(vp);
	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE)
		<span class="enscript-keyword">return</span> (EIO);

	noop = nfs_open_owner_find(nmp, vfs_context_ucred(ctx), 1);
	<span class="enscript-keyword">if</span> (!noop)
		<span class="enscript-keyword">return</span> (ENOMEM);
<span class="enscript-reference">restart</span>:
	error = nfs_open_file_find(np, noop, &amp;nofp, 0, 0, 1);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST)) {
		NP(np, <span class="enscript-string">&quot;nfs_vnop_read: LOST %d&quot;</span>, kauth_cred_getuid(noop-&gt;noo_cred));
		error = EIO;
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN)) {
		error = nfs4_reopen(nofp, vfs_context_thread(ctx));
		nofp = NULL;
		<span class="enscript-keyword">if</span> (!error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}
	<span class="enscript-keyword">if</span> (error) {
		nfs_open_owner_rele(noop);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-comment">/*
	 * Since the read path is a hot path, if we already have
	 * read access, lets go and try and do the read, without
	 * busying the mount and open file node for this open owner.
	 *
	 * N.B. This is inherently racy w.r.t. an execve using
	 * an already open file, in that the read at the end of
	 * this routine will be racing with a potential close.
	 * The code below ultimately has the same problem. In practice
	 * this does not seem to be an issue.
	 */</span>
	<span class="enscript-keyword">if</span> (nofp-&gt;nof_access &amp; NFS_OPEN_SHARE_ACCESS_READ) {
		nfs_open_owner_rele(noop);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">do_read</span>;
	}
	error = nfs_mount_state_in_use_start(nmp, vfs_context_thread(ctx));
	<span class="enscript-keyword">if</span> (error) {
		nfs_open_owner_rele(noop);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-comment">/*
	 * If we don't have a file already open with the access we need (read) then
	 * we need to open one. Otherwise we just co-opt an open. We might not already
	 * have access because we're trying to read the first page of the
	 * file for execve.
	 */</span>
	error = nfs_open_file_set_busy(nofp, vfs_context_thread(ctx));
	<span class="enscript-keyword">if</span> (error) {
		nfs_mount_state_in_use_end(nmp, 0);
		nfs_open_owner_rele(noop);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (!(nofp-&gt;nof_access &amp; NFS_OPEN_SHARE_ACCESS_READ)) {
		<span class="enscript-comment">/* we don't have the file open, so open it for read access if we're not denied */</span>
		<span class="enscript-keyword">if</span> (nofp-&gt;nof_flags &amp; NFS_OPEN_FILE_NEEDCLOSE) {
			NP(np, <span class="enscript-string">&quot;nfs_vnop_read: File already needs close access: 0x%x, cred: %d thread: %lld&quot;</span>,
			   nofp-&gt;nof_access, kauth_cred_getuid(nofp-&gt;nof_owner-&gt;noo_cred), thread_tid(vfs_context_thread(ctx)));
		}
		<span class="enscript-keyword">if</span> (nofp-&gt;nof_deny &amp; NFS_OPEN_SHARE_DENY_READ) {
			nfs_open_file_clear_busy(nofp);
			nfs_mount_state_in_use_end(nmp, 0);
			nfs_open_owner_rele(noop);
			<span class="enscript-keyword">return</span> (EPERM);
		}
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
			error = EIO;
			nfs_open_file_clear_busy(nofp);
			nfs_mount_state_in_use_end(nmp, 0);
			nfs_open_owner_rele(noop);
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &lt; NFS_VER4) {
			<span class="enscript-comment">/* NFS v2/v3 opens are always allowed - so just add it. */</span>
			nfs_open_file_add_open(nofp, NFS_OPEN_SHARE_ACCESS_READ, NFS_OPEN_SHARE_DENY_NONE, 0);
		} <span class="enscript-keyword">else</span> {
			error = nfs4_open(np, nofp, NFS_OPEN_SHARE_ACCESS_READ, NFS_OPEN_SHARE_DENY_NONE, ctx);
		}
		<span class="enscript-keyword">if</span> (!error)
			nofp-&gt;nof_flags |= NFS_OPEN_FILE_NEEDCLOSE;
	}
	<span class="enscript-keyword">if</span> (nofp)
		nfs_open_file_clear_busy(nofp);
	<span class="enscript-keyword">if</span> (nfs_mount_state_in_use_end(nmp, error)) {
		nofp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}
	nfs_open_owner_rele(noop);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
<span class="enscript-reference">do_read</span>:
	<span class="enscript-keyword">return</span> (nfs_bioread(VTONFS(ap-&gt;a_vp), ap-&gt;a_uio, ap-&gt;a_ioflag, ap-&gt;a_context));
}

<span class="enscript-comment">/*
 * Note: the NFSv4 CREATE RPC is for everything EXCEPT regular files.
 * Files are created using the NFSv4 OPEN RPC.  So we must open the
 * file to create it and then close it.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_vnop_create</span>(
	<span class="enscript-type">struct</span> vnop_create_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_dvp;
		vnode_t *a_vpp;
		struct componentname *a_cnp;
		struct vnode_attr *a_vap;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	<span class="enscript-type">struct</span> componentname *cnp = ap-&gt;a_cnp;
	<span class="enscript-type">struct</span> vnode_attr *vap = ap-&gt;a_vap;
	vnode_t dvp = ap-&gt;a_dvp;
	vnode_t *vpp = ap-&gt;a_vpp;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	nfsnode_t np;
	<span class="enscript-type">int</span> error = 0, busyerror = 0, accessMode, denyMode;
	<span class="enscript-type">struct</span> nfs_open_owner *noop = NULL;
	<span class="enscript-type">struct</span> nfs_open_file *newnofp = NULL, *nofp = NULL;

	nmp = VTONMP(dvp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (vap)
		nfs_avoid_needless_id_setting_on_create(VTONFS(dvp), vap, ctx);

	noop = nfs_open_owner_find(nmp, vfs_context_ucred(ctx), 1);
	<span class="enscript-keyword">if</span> (!noop)
		<span class="enscript-keyword">return</span> (ENOMEM);

<span class="enscript-reference">restart</span>:
	error = nfs_mount_state_in_use_start(nmp, vfs_context_thread(ctx));
	<span class="enscript-keyword">if</span> (error) {
		nfs_open_owner_rele(noop);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* grab a provisional, nodeless open file */</span>
	error = nfs_open_file_find(NULL, noop, &amp;newnofp, 0, 0, 1);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (newnofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST)) {
		printf(<span class="enscript-string">&quot;nfs_vnop_create: LOST\n&quot;</span>);
		error = EIO;
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (newnofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN)) {
		<span class="enscript-comment">/* This shouldn't happen given that this is a new, nodeless nofp */</span>
		nfs_mount_state_in_use_end(nmp, 0);
		error = nfs4_reopen(newnofp, vfs_context_thread(ctx));
		nfs_open_file_destroy(newnofp);
		newnofp = NULL;
		<span class="enscript-keyword">if</span> (!error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}
	<span class="enscript-keyword">if</span> (!error)
		error = nfs_open_file_set_busy(newnofp, vfs_context_thread(ctx));
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (newnofp)
			nfs_open_file_destroy(newnofp);
		newnofp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * We're just trying to create the file.
	 * We'll create/open it RW, and set NFS_OPEN_FILE_CREATE.
	 */</span>
	accessMode = NFS_OPEN_SHARE_ACCESS_BOTH;
	denyMode = NFS_OPEN_SHARE_DENY_NONE;

	<span class="enscript-comment">/* Do the open/create */</span>
	error = nfs4_open_rpc(newnofp, ctx, cnp, vap, dvp, vpp, NFS_OPEN_CREATE, accessMode, denyMode);
	<span class="enscript-keyword">if</span> ((error == EACCES) &amp;&amp; vap &amp;&amp; !(vap-&gt;va_vaflags &amp; VA_EXCLUSIVE) &amp;&amp;
	    VATTR_IS_ACTIVE(vap, va_mode) &amp;&amp; !(vap-&gt;va_mode &amp; S_IWUSR)) {
		<span class="enscript-comment">/*
		 * Hmm... it looks like we may have a situation where the request was
		 * retransmitted because we didn't get the first response which successfully
		 * created/opened the file and then the second time we were denied the open
		 * because the mode the file was created with doesn't allow write access.
		 *
		 * We'll try to work around this by temporarily updating the mode and
		 * retrying the open.
		 */</span>
		<span class="enscript-type">struct</span> vnode_attr vattr;

		<span class="enscript-comment">/* first make sure it's there */</span>
		<span class="enscript-type">int</span> error2 = nfs_lookitup(VTONFS(dvp), cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx, &amp;np);
		<span class="enscript-keyword">if</span> (!error2 &amp;&amp; np) {
			nfs_node_unlock(np);
			*vpp = NFSTOV(np);
			<span class="enscript-keyword">if</span> (vnode_vtype(NFSTOV(np)) == VREG) {
				VATTR_INIT(&amp;vattr);
				VATTR_SET(&amp;vattr, va_mode, (vap-&gt;va_mode | S_IWUSR));
				<span class="enscript-keyword">if</span> (!nfs4_setattr_rpc(np, &amp;vattr, ctx)) {
					error2 = nfs4_open_rpc(newnofp, ctx, cnp, NULL, dvp, vpp, NFS_OPEN_NOCREATE, accessMode, denyMode);
					VATTR_INIT(&amp;vattr);
					VATTR_SET(&amp;vattr, va_mode, vap-&gt;va_mode);
					nfs4_setattr_rpc(np, &amp;vattr, ctx);
					<span class="enscript-keyword">if</span> (!error2)
						error = 0;
				}
			}
			<span class="enscript-keyword">if</span> (error) {
				vnode_put(*vpp);
				*vpp = NULL;
			}
		}
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; !*vpp) {
		printf(<span class="enscript-string">&quot;nfs4_open_rpc returned without a node?\n&quot;</span>);
		<span class="enscript-comment">/* Hmmm... with no node, we have no filehandle and can't close it */</span>
		error = EIO;
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/* need to cleanup our temporary nofp */</span>
		nfs_open_file_clear_busy(newnofp);
		nfs_open_file_destroy(newnofp);
		newnofp = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/* After we have a node, add our open file struct to the node */</span>
	np = VTONFS(*vpp);
	nfs_open_file_add_open(newnofp, accessMode, denyMode, 0);
	nofp = newnofp;
	error = nfs_open_file_find_internal(np, noop, &amp;nofp, 0, 0, 0);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/* This shouldn't happen, because we passed in a new nofp to use. */</span>
		printf(<span class="enscript-string">&quot;nfs_open_file_find_internal failed! %d\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp != newnofp) {
		<span class="enscript-comment">/*
		 * Hmm... an open file struct already exists.
		 * Mark the existing one busy and merge our open into it.
		 * Then destroy the one we created.
		 * Note: there's no chance of an open confict because the
		 * open has already been granted.
		 */</span>
		busyerror = nfs_open_file_set_busy(nofp, NULL);
		nfs_open_file_add_open(nofp, accessMode, denyMode, 0);
		nofp-&gt;nof_stateid = newnofp-&gt;nof_stateid;
		<span class="enscript-keyword">if</span> (newnofp-&gt;nof_flags &amp; NFS_OPEN_FILE_POSIXLOCK)
			nofp-&gt;nof_flags |= NFS_OPEN_FILE_POSIXLOCK;
		nfs_open_file_clear_busy(newnofp);
		nfs_open_file_destroy(newnofp);
	}
	newnofp = NULL;
	<span class="enscript-comment">/* mark the node as holding a create-initiated open */</span>
	nofp-&gt;nof_flags |= NFS_OPEN_FILE_CREATE;
	nofp-&gt;nof_creator = current_thread();
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (nofp &amp;&amp; !busyerror)
		nfs_open_file_clear_busy(nofp);
	<span class="enscript-keyword">if</span> (nfs_mount_state_in_use_end(nmp, error)) {
		nofp = newnofp = NULL;
		busyerror = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}
	<span class="enscript-keyword">if</span> (noop)
		nfs_open_owner_rele(noop);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Note: the NFSv4 CREATE RPC is for everything EXCEPT regular files.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_create_rpc</span>(
	vfs_context_t ctx,
	nfsnode_t dnp,
	<span class="enscript-type">struct</span> componentname *cnp,
	<span class="enscript-type">struct</span> vnode_attr *vap,
	<span class="enscript-type">int</span> type,
	<span class="enscript-type">char</span> *link,
	nfsnode_t *npp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">int</span> error = 0, create_error = EIO, lockerror = ENOENT, busyerror = ENOENT, status;
	<span class="enscript-type">int</span> nfsvers, namedattrs, numops;
	u_int64_t xid, savedxid = 0;
	nfsnode_t np = NULL;
	vnode_t newvp = NULL;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	uint32_t bitmap[NFS_ATTR_BITMAP_LEN], bmlen;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *tag;
	nfs_specdata sd;
	fhandle_t fh;
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;
	<span class="enscript-type">struct</span> nfs_dulookup dul;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(dnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	namedattrs = (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR);
	<span class="enscript-keyword">if</span> (dnp-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);

	sd.specdata1 = sd.specdata2 = 0;

	<span class="enscript-keyword">switch</span> (type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFLNK</span>:
		tag = <span class="enscript-string">&quot;symlink&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFBLK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFCHR</span>:
		tag = <span class="enscript-string">&quot;mknod&quot;</span>;
		<span class="enscript-keyword">if</span> (!VATTR_IS_ACTIVE(vap, va_rdev))
			<span class="enscript-keyword">return</span> (EINVAL);
		sd.specdata1 = major(vap-&gt;va_rdev);
		sd.specdata2 = minor(vap-&gt;va_rdev);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSOCK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFFIFO</span>:
		tag = <span class="enscript-string">&quot;mknod&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFDIR</span>:
		tag = <span class="enscript-string">&quot;mkdir&quot;</span>;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	nfs_avoid_needless_id_setting_on_create(dnp, vap, ctx);

	error = busyerror = nfs_node_set_busy(dnp, vfs_context_thread(ctx));
	<span class="enscript-keyword">if</span> (!namedattrs)
		nfs_dulookup_init(&amp;dul, dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx);

	NFSREQ_SECINFO_SET(&amp;si, dnp, NULL, 0, NULL, 0);
	NVATTR_INIT(&amp;nvattr);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH, SAVEFH, CREATE, GETATTR(FH), RESTOREFH, GETATTR
</span>	numops = 6;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 66 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, tag, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, dnp-&gt;n_fhp, dnp-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_SAVEFH);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_CREATE);
	nfsm_chain_add_32(error, &amp;nmreq, type);
	<span class="enscript-keyword">if</span> (type == NFLNK) {
		nfsm_chain_add_name(error, &amp;nmreq, link, strlen(link), nmp);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((type == NFBLK) || (type == NFCHR)) {
		nfsm_chain_add_32(error, &amp;nmreq, sd.specdata1);
		nfsm_chain_add_32(error, &amp;nmreq, sd.specdata2);
	}
	nfsm_chain_add_name(error, &amp;nmreq, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, nmp);
	nfsm_chain_add_fattr4(error, &amp;nmreq, vap, nmp);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	NFS_COPY_ATTRIBUTES(nfs_getattr_bitmap, bitmap);
	NFS_BITMAP_SET(bitmap, NFS_FATTR_FILEHANDLE);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, bitmap, nmp, NULL);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_RESTOREFH);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, dnp);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);

	error = nfs_request_async(dnp, NULL, &amp;nmreq, NFSPROC4_COMPOUND,
			vfs_context_thread(ctx), vfs_context_ucred(ctx), &amp;si, 0, NULL, &amp;req);
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-keyword">if</span> (!namedattrs)
			nfs_dulookup_start(&amp;dul, dnp, ctx);
		error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);
	}

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(dnp)))
		error = lockerror;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_SAVEFH);
	nfsmout_if(error);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_CREATE);
	nfsm_chain_check_change_info(error, &amp;nmrep, dnp);
	bmlen = NFS_ATTR_BITMAP_LEN;
	nfsm_chain_get_bitmap(error, &amp;nmrep, bitmap, bmlen);
	<span class="enscript-comment">/* At this point if we have no error, the object was created. */</span>
	<span class="enscript-comment">/* if we don't get attributes, then we should lookitup. */</span>
	create_error = error;
	nfsmout_if(error);
	nfs_vattr_set_supported(bitmap, vap);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsmout_if(error);
	error = nfs4_parsefattr(&amp;nmrep, NULL, &amp;nvattr, &amp;fh, NULL, NULL);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (!NFS_BITMAP_ISSET(nvattr.nva_bitmap, NFS_FATTR_FILEHANDLE)) {
		printf(<span class="enscript-string">&quot;nfs: create/%s didn't return filehandle? %s\n&quot;</span>, tag, cnp-&gt;cn_nameptr);
		error = EBADRPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}
	<span class="enscript-comment">/* directory attributes: if we don't get them, make sure to invalidate */</span>
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_RESTOREFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	savedxid = xid;
	nfsm_chain_loadattr(error, &amp;nmrep, dnp, nfsvers, &amp;xid);
	<span class="enscript-keyword">if</span> (error)
		NATTRINVALIDATE(dnp);

<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);

	<span class="enscript-keyword">if</span> (!lockerror) {
		<span class="enscript-keyword">if</span> (!create_error &amp;&amp; (dnp-&gt;n_flag &amp; NNEGNCENTRIES)) {
			dnp-&gt;n_flag &amp;= ~NNEGNCENTRIES;
			cache_purge_negatives(NFSTOV(dnp));
		}
		dnp-&gt;n_flag |= NMODIFIED;
		nfs_node_unlock(dnp);
		<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
		nfs_getattr(dnp, NULL, ctx, NGA_CACHED);
	}

	<span class="enscript-keyword">if</span> (!error &amp;&amp; fh.fh_len) {
		<span class="enscript-comment">/* create the vnode with the filehandle and attributes */</span>
		xid = savedxid;
		error = nfs_nget(NFSTOMP(dnp), dnp, cnp, fh.fh_data, fh.fh_len, &amp;nvattr, &amp;xid, rq.r_auth, NG_MAKEENTRY, &amp;np);
		<span class="enscript-keyword">if</span> (!error)
			newvp = NFSTOV(np);
	}
	NVATTR_CLEANUP(&amp;nvattr);

	<span class="enscript-keyword">if</span> (!namedattrs)
		nfs_dulookup_finish(&amp;dul, dnp, ctx);

	<span class="enscript-comment">/*
	 * Kludge: Map EEXIST =&gt; 0 assuming that you have a reply to a retry
	 * if we can succeed in looking up the object.
	 */</span>
	<span class="enscript-keyword">if</span> ((create_error == EEXIST) || (!create_error &amp;&amp; !newvp)) {
		error = nfs_lookitup(dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx, &amp;np);
		<span class="enscript-keyword">if</span> (!error) {
			newvp = NFSTOV(np);
			<span class="enscript-keyword">if</span> (vnode_vtype(newvp) != nfstov_type(type, nfsvers))
				error = EEXIST;
		}
	}
	<span class="enscript-keyword">if</span> (!busyerror)
		nfs_node_clear_busy(dnp);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (newvp) {
			nfs_node_unlock(np);
			vnode_put(newvp);
		}
	} <span class="enscript-keyword">else</span> {
		nfs_node_unlock(np);
		*npp = np;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_vnop_mknod</span>(
	<span class="enscript-type">struct</span> vnop_mknod_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_dvp;
		vnode_t *a_vpp;
		struct componentname *a_cnp;
		struct vnode_attr *a_vap;
		vfs_context_t a_context;
	} */</span> *ap)
{
	nfsnode_t np = NULL;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error;

	nmp = VTONMP(ap-&gt;a_dvp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (!VATTR_IS_ACTIVE(ap-&gt;a_vap, va_type))
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">switch</span> (ap-&gt;a_vap-&gt;va_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VBLK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VCHR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFIFO</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VSOCK</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}

	error = nfs4_create_rpc(ap-&gt;a_context, VTONFS(ap-&gt;a_dvp), ap-&gt;a_cnp, ap-&gt;a_vap,
			vtonfs_type(ap-&gt;a_vap-&gt;va_type, nmp-&gt;nm_vers), NULL, &amp;np);
	<span class="enscript-keyword">if</span> (!error)
		*ap-&gt;a_vpp = NFSTOV(np);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_vnop_mkdir</span>(
	<span class="enscript-type">struct</span> vnop_mkdir_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_dvp;
		vnode_t *a_vpp;
		struct componentname *a_cnp;
		struct vnode_attr *a_vap;
		vfs_context_t a_context;
	} */</span> *ap)
{
	nfsnode_t np = NULL;
	<span class="enscript-type">int</span> error;

	error = nfs4_create_rpc(ap-&gt;a_context, VTONFS(ap-&gt;a_dvp), ap-&gt;a_cnp, ap-&gt;a_vap,
			NFDIR, NULL, &amp;np);
	<span class="enscript-keyword">if</span> (!error)
		*ap-&gt;a_vpp = NFSTOV(np);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_vnop_symlink</span>(
	<span class="enscript-type">struct</span> vnop_symlink_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_dvp;
		vnode_t *a_vpp;
		struct componentname *a_cnp;
		struct vnode_attr *a_vap;
		char *a_target;
		vfs_context_t a_context;
	} */</span> *ap)
{
	nfsnode_t np = NULL;
	<span class="enscript-type">int</span> error;

	error = nfs4_create_rpc(ap-&gt;a_context, VTONFS(ap-&gt;a_dvp), ap-&gt;a_cnp, ap-&gt;a_vap,
			NFLNK, ap-&gt;a_target, &amp;np);
	<span class="enscript-keyword">if</span> (!error)
		*ap-&gt;a_vpp = NFSTOV(np);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_vnop_link</span>(
	<span class="enscript-type">struct</span> vnop_link_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		vnode_t a_tdvp;
		struct componentname *a_cnp;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t vp = ap-&gt;a_vp;
	vnode_t tdvp = ap-&gt;a_tdvp;
	<span class="enscript-type">struct</span> componentname *cnp = ap-&gt;a_cnp;
	<span class="enscript-type">int</span> error = 0, lockerror = ENOENT, status;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	nfsnode_t np = VTONFS(vp);
	nfsnode_t tdnp = VTONFS(tdvp);
	<span class="enscript-type">int</span> nfsvers, numops;
	u_int64_t xid, savedxid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	<span class="enscript-keyword">if</span> (vnode_mount(vp) != vnode_mount(tdvp))
		<span class="enscript-keyword">return</span> (EXDEV);

	nmp = VTONMP(vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (tdnp-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/*
	 * Push all writes to the server, so that the attribute cache
	 * doesn't get &quot;out of sync&quot; with the server.
	 * XXX There should be a better way!
	 */</span>
	nfs_flush(np, MNT_WAIT, vfs_context_thread(ctx), V_IGNORE_WRITEERR);

	<span class="enscript-keyword">if</span> ((error = nfs_node_set_busy2(tdnp, np, vfs_context_thread(ctx))))
		<span class="enscript-keyword">return</span> (error);

	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH(SOURCE), SAVEFH, PUTFH(DIR), LINK, GETATTR(DIR), RESTOREFH, GETATTR
</span>	numops = 7;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 29 * NFSX_UNSIGNED + cnp-&gt;cn_namelen);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;link&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_SAVEFH);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, tdnp-&gt;n_fhp, tdnp-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_LINK);
	nfsm_chain_add_name(error, &amp;nmreq, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, nmp);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, tdnp);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_RESTOREFH);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, nfs_getattr_bitmap, nmp, np);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request(tdnp, NULL, &amp;nmreq, NFSPROC4_COMPOUND, ctx, &amp;si, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock2(tdnp, np))) {
		error = lockerror;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_SAVEFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_LINK);
	nfsm_chain_check_change_info(error, &amp;nmrep, tdnp);
	<span class="enscript-comment">/* directory attributes: if we don't get them, make sure to invalidate */</span>
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	savedxid = xid;
	nfsm_chain_loadattr(error, &amp;nmrep, tdnp, nfsvers, &amp;xid);
	<span class="enscript-keyword">if</span> (error)
		NATTRINVALIDATE(tdnp);
	<span class="enscript-comment">/* link attributes: if we don't get them, make sure to invalidate */</span>
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_RESTOREFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	xid = savedxid;
	nfsm_chain_loadattr(error, &amp;nmrep, np, nfsvers, &amp;xid);
	<span class="enscript-keyword">if</span> (error)
		NATTRINVALIDATE(np);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">if</span> (!lockerror)
		tdnp-&gt;n_flag |= NMODIFIED;
	<span class="enscript-comment">/* Kludge: Map EEXIST =&gt; 0 assuming that it is a reply to a retry. */</span>
	<span class="enscript-keyword">if</span> (error == EEXIST)
		error = 0;
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (tdnp-&gt;n_flag &amp; NNEGNCENTRIES)) {
		tdnp-&gt;n_flag &amp;= ~NNEGNCENTRIES;
		cache_purge_negatives(tdvp);
	}
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock2(tdnp, np);
	nfs_node_clear_busy2(tdnp, np);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_vnop_rmdir</span>(
	<span class="enscript-type">struct</span> vnop_rmdir_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_dvp;
		vnode_t a_vp;
		struct componentname *a_cnp;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	vnode_t vp = ap-&gt;a_vp;
	vnode_t dvp = ap-&gt;a_dvp;
	<span class="enscript-type">struct</span> componentname *cnp = ap-&gt;a_cnp;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, namedattrs;
	nfsnode_t np = VTONFS(vp);
	nfsnode_t dnp = VTONFS(dvp);
	<span class="enscript-type">struct</span> nfs_dulookup dul;

	<span class="enscript-keyword">if</span> (vnode_vtype(vp) != VDIR)
		<span class="enscript-keyword">return</span> (EINVAL);

	nmp = NFSTONMP(dnp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	namedattrs = (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR);

	<span class="enscript-keyword">if</span> ((error = nfs_node_set_busy2(dnp, np, vfs_context_thread(ctx))))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (!namedattrs) {
		nfs_dulookup_init(&amp;dul, dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, ctx);
		nfs_dulookup_start(&amp;dul, dnp, ctx);
	}

	error = nfs4_remove_rpc(dnp, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen,
			vfs_context_thread(ctx), vfs_context_ucred(ctx));

	nfs_name_cache_purge(dnp, np, cnp, ctx);
	<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
	nfs_getattr(dnp, NULL, ctx, NGA_CACHED);
	<span class="enscript-keyword">if</span> (!namedattrs)
		nfs_dulookup_finish(&amp;dul, dnp, ctx);
	nfs_node_clear_busy2(dnp, np);

	<span class="enscript-comment">/*
	 * Kludge: Map ENOENT =&gt; 0 assuming that you have a reply to a retry.
	 */</span>
	<span class="enscript-keyword">if</span> (error == ENOENT)
		error = 0;
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-comment">/*
		 * remove nfsnode from hash now so we can't accidentally find it
		 * again if another object gets created with the same filehandle
		 * before this vnode gets reclaimed
		 */</span>
		lck_mtx_lock(nfs_node_hash_mutex);
		<span class="enscript-keyword">if</span> (np-&gt;n_hflag &amp; NHHASHED) {
			LIST_REMOVE(np, n_hash);
			np-&gt;n_hflag &amp;= ~NHHASHED;
			FSDBG(266, 0, np, np-&gt;n_flag, 0xb1eb1e);
		}
		lck_mtx_unlock(nfs_node_hash_mutex);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFSv4 Named Attributes
 *
 * Both the extended attributes interface and the named streams interface
 * are backed by NFSv4 named attributes.  The implementations for both use
 * a common set of routines in an attempt to reduce code duplication, to
 * increase efficiency, to increase caching of both names and data, and to
 * confine the complexity.
 *
 * Each NFS node caches its named attribute directory's file handle.
 * The directory nodes for the named attribute directories are handled
 * exactly like regular directories (with a couple minor exceptions).
 * Named attribute nodes are also treated as much like regular files as
 * possible.
 *
 * Most of the heavy lifting is done by nfs4_named_attr_get().
 */</span>

<span class="enscript-comment">/*
 * Get the given node's attribute directory node.
 * If !fetch, then only return a cached node.
 * Otherwise, we will attempt to fetch the node from the server.
 * (Note: the node should be marked busy.)
 */</span>
nfsnode_t
<span class="enscript-function-name">nfs4_named_attr_dir_get</span>(nfsnode_t np, <span class="enscript-type">int</span> fetch, vfs_context_t ctx)
{
	nfsnode_t adnp = NULL;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, status, numops;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	u_int64_t xid;
	uint32_t bitmap[NFS_ATTR_BITMAP_LEN];
	fhandle_t fh;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">struct</span> componentname cn;
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (NULL);
	<span class="enscript-keyword">if</span> (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL)
		<span class="enscript-keyword">return</span> (NULL);

	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	NVATTR_INIT(&amp;nvattr);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	bzero(&amp;cn, <span class="enscript-keyword">sizeof</span>(cn));
	cn.cn_nameptr = __CAST_AWAY_QUALIFIER(_PATH_FORKSPECIFIER, <span class="enscript-type">const</span>, <span class="enscript-type">char</span> *); <span class="enscript-comment">/* &quot;/..namedfork/&quot; */</span>
	cn.cn_namelen = strlen(_PATH_FORKSPECIFIER);
	cn.cn_nameiop = LOOKUP;

	<span class="enscript-keyword">if</span> (np-&gt;n_attrdirfh) {
		<span class="enscript-comment">// XXX can't set parent correctly (to np) yet
</span>		error = nfs_nget(nmp-&gt;nm_mountp, NULL, &amp;cn, np-&gt;n_attrdirfh+1, *np-&gt;n_attrdirfh,
				NULL, NULL, RPCAUTH_UNKNOWN, NG_NOCREATE, &amp;adnp);
		<span class="enscript-keyword">if</span> (adnp)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}
	<span class="enscript-keyword">if</span> (!fetch) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}

	<span class="enscript-comment">// PUTFH, OPENATTR, GETATTR
</span>	numops = 3;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 22 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;openattr&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nmp-&gt;nm_vers, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_OPENATTR);
	nfsm_chain_add_32(error, &amp;nmreq, 0);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	NFS_COPY_ATTRIBUTES(nfs_getattr_bitmap, bitmap);
	NFS_BITMAP_SET(bitmap, NFS_FATTR_FILEHANDLE);
	nfsm_chain_add_bitmap_masked(error, &amp;nmreq, bitmap,
		NFS_ATTR_BITMAP_LEN, nmp-&gt;nm_fsattr.nfsa_supp_attr);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request_async(np, NULL, &amp;nmreq, NFSPROC4_COMPOUND,
			vfs_context_thread(ctx), vfs_context_ucred(ctx), &amp;si, 0, NULL, &amp;req);
	<span class="enscript-keyword">if</span> (!error)
		error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);

	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_OPENATTR);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsmout_if(error);
	error = nfs4_parsefattr(&amp;nmrep, NULL, &amp;nvattr, &amp;fh, NULL, NULL);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (!NFS_BITMAP_ISSET(nvattr.nva_bitmap, NFS_FATTR_FILEHANDLE) || !fh.fh_len) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}
	<span class="enscript-keyword">if</span> (!np-&gt;n_attrdirfh || (*np-&gt;n_attrdirfh != fh.fh_len)) {
		<span class="enscript-comment">/* (re)allocate attrdir fh buffer */</span>
		<span class="enscript-keyword">if</span> (np-&gt;n_attrdirfh)
			FREE(np-&gt;n_attrdirfh, M_TEMP);
		MALLOC(np-&gt;n_attrdirfh, u_char*, fh.fh_len+1, M_TEMP, M_WAITOK);
	}
	<span class="enscript-keyword">if</span> (!np-&gt;n_attrdirfh) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}
	<span class="enscript-comment">/* cache the attrdir fh in the node */</span>
	*np-&gt;n_attrdirfh = fh.fh_len;
	bcopy(fh.fh_data, np-&gt;n_attrdirfh+1, fh.fh_len);
	<span class="enscript-comment">/* create node for attrdir */</span>
	<span class="enscript-comment">// XXX can't set parent correctly (to np) yet
</span>	error = nfs_nget(NFSTOMP(np), NULL, &amp;cn, fh.fh_data, fh.fh_len, &amp;nvattr, &amp;xid, rq.r_auth, 0, &amp;adnp);
<span class="enscript-reference">nfsmout</span>:
	NVATTR_CLEANUP(&amp;nvattr);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);

	<span class="enscript-keyword">if</span> (adnp) {
		<span class="enscript-comment">/* sanity check that this node is an attribute directory */</span>
		<span class="enscript-keyword">if</span> (adnp-&gt;n_vattr.nva_type != VDIR)
			error = EINVAL;
		<span class="enscript-keyword">if</span> (!(adnp-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_IS_ATTR))
			error = EINVAL;
		nfs_node_unlock(adnp);
		<span class="enscript-keyword">if</span> (error)
			vnode_put(NFSTOV(adnp));
	}
	<span class="enscript-keyword">return</span> (error ? NULL : adnp);
}

<span class="enscript-comment">/*
 * Get the given node's named attribute node for the name given.
 *
 * In an effort to increase the performance of named attribute access, we try
 * to reduce server requests by doing the following:
 *
 * - cache the node's named attribute directory file handle in the node
 * - maintain a directory vnode for the attribute directory
 * - use name cache entries (positive and negative) to speed up lookups
 * - optionally open the named attribute (with the given accessMode) in the same RPC
 * - combine attribute directory retrieval with the lookup/open RPC
 * - optionally prefetch the named attribute's first block of data in the same RPC
 *
 * Also, in an attempt to reduce the number of copies/variations of this code,
 * parts of the RPC building/processing code are conditionalized on what is
 * needed for any particular request (openattr, lookup vs. open, read).
 *
 * Note that because we may not have the attribute directory node when we start
 * the lookup/open, we lock both the node and the attribute directory node.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_GET_NAMED_ATTR_CREATE</span>		0x1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_GET_NAMED_ATTR_CREATE_GUARDED</span>	0x2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_GET_NAMED_ATTR_TRUNCATE</span>		0x4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_GET_NAMED_ATTR_PREFETCH</span>		0x8

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_named_attr_get</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> componentname *cnp,
	uint32_t accessMode,
	<span class="enscript-type">int</span> flags,
	vfs_context_t ctx,
	nfsnode_t *anpp,
	<span class="enscript-type">struct</span> nfs_open_file **nofpp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0, open_error = EIO;
	<span class="enscript-type">int</span> inuse = 0, adlockerror = ENOENT, busyerror = ENOENT, adbusyerror = ENOENT, nofpbusyerror = ENOENT;
	<span class="enscript-type">int</span> create, guarded, prefetch, truncate, noopbusy = 0;
	<span class="enscript-type">int</span> open, status, numops, hadattrdir, negnamecache;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">struct</span> vnode_attr vattr;
	nfsnode_t adnp = NULL, anp = NULL;
	vnode_t avp = NULL;
	u_int64_t xid, savedxid = 0;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	uint32_t bitmap[NFS_ATTR_BITMAP_LEN], bmlen;
	uint32_t denyMode, rflags, delegation, recall, eof, rlen, retlen;
	nfs_stateid stateid, dstateid;
	fhandle_t fh;
	<span class="enscript-type">struct</span> nfs_open_owner *noop = NULL;
	<span class="enscript-type">struct</span> nfs_open_file *newnofp = NULL, *nofp = NULL;
	<span class="enscript-type">struct</span> vnop_access_args naa;
	thread_t thd;
	kauth_cred_t cred;
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">char</span> sbuf[64], *s;
	uint32_t ace_type, ace_flags, ace_mask, len, slen;
	<span class="enscript-type">struct</span> kauth_ace ace;
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	*anpp = NULL;
	fh.fh_len = 0;
	rflags = delegation = recall = eof = rlen = retlen = 0;
	ace.ace_flags = 0;
	s = sbuf;
	slen = <span class="enscript-keyword">sizeof</span>(sbuf);

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	NVATTR_INIT(&amp;nvattr);
	negnamecache = !NMFLAG(nmp, NONEGNAMECACHE);
	thd = vfs_context_thread(ctx);
	cred = vfs_context_ucred(ctx);
	create = (flags &amp; NFS_GET_NAMED_ATTR_CREATE) ? NFS_OPEN_CREATE : NFS_OPEN_NOCREATE;
	guarded = (flags &amp; NFS_GET_NAMED_ATTR_CREATE_GUARDED) ? NFS_CREATE_GUARDED : NFS_CREATE_UNCHECKED;
	truncate = (flags &amp; NFS_GET_NAMED_ATTR_TRUNCATE);
	prefetch = (flags &amp; NFS_GET_NAMED_ATTR_PREFETCH);

	<span class="enscript-keyword">if</span> (!create) {
		error = nfs_getattr(np, &amp;nvattr, ctx, NGA_CACHED);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nvattr.nva_bitmap, NFS_FATTR_NAMED_ATTR) &amp;&amp;
		    !(nvattr.nva_flags &amp; NFS_FFLAG_HAS_NAMED_ATTRS))
			<span class="enscript-keyword">return</span> (ENOATTR);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (accessMode == NFS_OPEN_SHARE_ACCESS_NONE) {
		<span class="enscript-comment">/* shouldn't happen... but just be safe */</span>
		printf(<span class="enscript-string">&quot;nfs4_named_attr_get: create with no access %s\n&quot;</span>, cnp-&gt;cn_nameptr);
		accessMode = NFS_OPEN_SHARE_ACCESS_READ;
	}
	open = (accessMode != NFS_OPEN_SHARE_ACCESS_NONE);
	<span class="enscript-keyword">if</span> (open) {
		<span class="enscript-comment">/*
		 * We're trying to open the file.
		 * We'll create/open it with the given access mode,
		 * and set NFS_OPEN_FILE_CREATE.
		 */</span>
		denyMode = NFS_OPEN_SHARE_DENY_NONE;
		<span class="enscript-keyword">if</span> (prefetch &amp;&amp; guarded)
			prefetch = 0;  <span class="enscript-comment">/* no sense prefetching data that can't be there */</span>

		noop = nfs_open_owner_find(nmp, vfs_context_ucred(ctx), 1);
		<span class="enscript-keyword">if</span> (!noop)
			<span class="enscript-keyword">return</span> (ENOMEM);
	}

	<span class="enscript-keyword">if</span> ((error = busyerror = nfs_node_set_busy(np, vfs_context_thread(ctx))))
		<span class="enscript-keyword">return</span> (error);

	adnp = nfs4_named_attr_dir_get(np, 0, ctx);
	hadattrdir = (adnp != NULL);
	<span class="enscript-keyword">if</span> (prefetch) {
		microuptime(&amp;now);
		<span class="enscript-comment">/* use the special state ID because we don't have a real one to send */</span>
		stateid.seqid = stateid.other[0] = stateid.other[1] = stateid.other[2] = 0;
		rlen = MIN(nmp-&gt;nm_rsize, nmp-&gt;nm_biosize);
	}
	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-keyword">if</span> (hadattrdir) {
		<span class="enscript-keyword">if</span> ((error = adbusyerror = nfs_node_set_busy(adnp, vfs_context_thread(ctx))))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
		error = nfs_getattr(adnp, NULL, ctx, NGA_CACHED);
		nfsmout_if(error);
		error = cache_lookup(NFSTOV(adnp), &amp;avp, cnp);
		<span class="enscript-keyword">switch</span> (error) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOENT</span>:
			<span class="enscript-comment">/* negative cache entry */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
			<span class="enscript-comment">/* cache miss */</span>
			<span class="enscript-comment">/* try dir buf cache lookup */</span>
			error = nfs_dir_buf_cache_lookup(adnp, &amp;anp, cnp, ctx, 0);
			<span class="enscript-keyword">if</span> (!error &amp;&amp; anp) {
				<span class="enscript-comment">/* dir buf cache hit */</span>
				*anpp = anp;
				error = -1;
			}
			<span class="enscript-keyword">if</span> (error != -1) <span class="enscript-comment">/* cache miss */</span>
				<span class="enscript-keyword">break</span>;
			<span class="enscript-comment">/* FALLTHROUGH */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">-1</span>:
			<span class="enscript-comment">/* cache hit, not really an error */</span>
			OSAddAtomic64(1, &amp;nfsstats.lookupcache_hits);
			<span class="enscript-keyword">if</span> (!anp &amp;&amp; avp)
				*anpp = anp = VTONFS(avp);

			nfs_node_clear_busy(adnp);
			adbusyerror = ENOENT;

			<span class="enscript-comment">/* check for directory access */</span>
			naa.a_desc = &amp;vnop_access_desc;
			naa.a_vp = NFSTOV(adnp);
			naa.a_action = KAUTH_VNODE_SEARCH;
			naa.a_context = ctx;

			<span class="enscript-comment">/* compute actual success/failure based on accessibility */</span>
			error = nfs_vnop_access(&amp;naa);
			<span class="enscript-comment">/* FALLTHROUGH */</span>
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* we either found it, or hit an error */</span>
			<span class="enscript-keyword">if</span> (!error &amp;&amp; guarded) {
				<span class="enscript-comment">/* found cached entry but told not to use it */</span>
				error = EEXIST;
				vnode_put(NFSTOV(anp));
				*anpp = anp = NULL;
			}
			<span class="enscript-comment">/* we're done if error or we don't need to open */</span>
			<span class="enscript-keyword">if</span> (error || !open)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			<span class="enscript-comment">/* no error and we need to open... */</span>
		}
	}

	<span class="enscript-keyword">if</span> (open) {
<span class="enscript-reference">restart</span>:
		error = nfs_mount_state_in_use_start(nmp, vfs_context_thread(ctx));
		<span class="enscript-keyword">if</span> (error) {
			nfs_open_owner_rele(noop);
			noop = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
		inuse = 1;

		<span class="enscript-comment">/* grab an open file - possibly provisional/nodeless if cache_lookup() failed */</span>
		error = nfs_open_file_find(anp, noop, &amp;newnofp, 0, 0, 1);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; (newnofp-&gt;nof_flags &amp; NFS_OPEN_FILE_LOST)) {
			printf(<span class="enscript-string">&quot;nfs4_named_attr_get: LOST %d %s\n&quot;</span>, kauth_cred_getuid(noop-&gt;noo_cred), cnp-&gt;cn_nameptr);
			error = EIO;
		}
		<span class="enscript-keyword">if</span> (!error &amp;&amp; (newnofp-&gt;nof_flags &amp; NFS_OPEN_FILE_REOPEN)) {
			nfs_mount_state_in_use_end(nmp, 0);
			error = nfs4_reopen(newnofp, vfs_context_thread(ctx));
			nfs_open_file_destroy(newnofp);
			newnofp = NULL;
			<span class="enscript-keyword">if</span> (!error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		}
		<span class="enscript-keyword">if</span> (!error)
			error = nfs_open_file_set_busy(newnofp, vfs_context_thread(ctx));
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (newnofp)
				nfs_open_file_destroy(newnofp);
			newnofp = NULL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
		<span class="enscript-keyword">if</span> (anp) {
			<span class="enscript-comment">/*
			 * We already have the node.  So we just need to open
			 * it - which we may be able to do with a delegation.
			 */</span>
			open_error = error = nfs4_open(anp, newnofp, accessMode, denyMode, ctx);
			<span class="enscript-keyword">if</span> (!error) {
				<span class="enscript-comment">/* open succeeded, so our open file is no longer temporary */</span>
				nofp = newnofp;
				nofpbusyerror = 0;
				newnofp = NULL;
				<span class="enscript-keyword">if</span> (nofpp)
					*nofpp = nofp;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
	}

	<span class="enscript-comment">/*
	 * We either don't have the attrdir or we didn't find the attribute
	 * in the name cache, so we need to talk to the server.
	 *
	 * If we don't have the attrdir, we'll need to ask the server for that too.
	 * If the caller is requesting that the attribute be created, we need to
	 * make sure the attrdir is created.
	 * The caller may also request that the first block of an existing attribute
	 * be retrieved at the same time.
	 */</span>

	<span class="enscript-keyword">if</span> (open) {
		<span class="enscript-comment">/* need to mark the open owner busy during the RPC */</span>
		<span class="enscript-keyword">if</span> ((error = nfs_open_owner_set_busy(noop, thd)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		noopbusy = 1;
	}

	<span class="enscript-comment">/*
	 * We'd like to get updated post-open/lookup attributes for the
	 * directory and we may also want to prefetch some data via READ.
	 * We'd like the READ results to be last so that we can leave the
	 * data in the mbufs until the end.
	 *
	 * At a minimum we're sending: PUTFH, LOOKUP/OPEN, GETATTR, PUTFH, GETATTR
	 */</span>
	numops = 5;
	<span class="enscript-keyword">if</span> (!hadattrdir)
		numops += 3;	<span class="enscript-comment">// also sending: OPENATTR, GETATTR, OPENATTR
</span>	<span class="enscript-keyword">if</span> (prefetch)
		numops += 4;	<span class="enscript-comment">// also sending: SAVEFH, RESTOREFH, NVERIFY, READ
</span>	nfsm_chain_build_alloc_init(error, &amp;nmreq, 64 * NFSX_UNSIGNED + cnp-&gt;cn_namelen);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;getnamedattr&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	<span class="enscript-keyword">if</span> (hadattrdir) {
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
		nfsm_chain_add_fh(error, &amp;nmreq, nmp-&gt;nm_vers, adnp-&gt;n_fhp, adnp-&gt;n_fhsize);
	} <span class="enscript-keyword">else</span> {
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
		nfsm_chain_add_fh(error, &amp;nmreq, nmp-&gt;nm_vers, np-&gt;n_fhp, np-&gt;n_fhsize);
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_OPENATTR);
		nfsm_chain_add_32(error, &amp;nmreq, create ? 1 : 0);
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
		NFS_COPY_ATTRIBUTES(nfs_getattr_bitmap, bitmap);
		NFS_BITMAP_SET(bitmap, NFS_FATTR_FILEHANDLE);
		nfsm_chain_add_bitmap_masked(error, &amp;nmreq, bitmap,
			NFS_ATTR_BITMAP_LEN, nmp-&gt;nm_fsattr.nfsa_supp_attr);
	}
	<span class="enscript-keyword">if</span> (open) {
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_OPEN);
		nfsm_chain_add_32(error, &amp;nmreq, noop-&gt;noo_seqid);
		nfsm_chain_add_32(error, &amp;nmreq, accessMode);
		nfsm_chain_add_32(error, &amp;nmreq, denyMode);
		nfsm_chain_add_64(error, &amp;nmreq, nmp-&gt;nm_clientid);
		nfsm_chain_add_32(error, &amp;nmreq, NFSX_UNSIGNED);
		nfsm_chain_add_32(error, &amp;nmreq, kauth_cred_getuid(noop-&gt;noo_cred));
		nfsm_chain_add_32(error, &amp;nmreq, create);
		<span class="enscript-keyword">if</span> (create) {
			nfsm_chain_add_32(error, &amp;nmreq, guarded);
			VATTR_INIT(&amp;vattr);
			<span class="enscript-keyword">if</span> (truncate)
				VATTR_SET(&amp;vattr, va_data_size, 0);
			nfsm_chain_add_fattr4(error, &amp;nmreq, &amp;vattr, nmp);
		}
		nfsm_chain_add_32(error, &amp;nmreq, NFS_CLAIM_NULL);
		nfsm_chain_add_name(error, &amp;nmreq, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, nmp);
	} <span class="enscript-keyword">else</span> {
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_LOOKUP);
		nfsm_chain_add_name(error, &amp;nmreq, cnp-&gt;cn_nameptr, cnp-&gt;cn_namelen, nmp);
	}
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	NFS_COPY_ATTRIBUTES(nfs_getattr_bitmap, bitmap);
	NFS_BITMAP_SET(bitmap, NFS_FATTR_FILEHANDLE);
	nfsm_chain_add_bitmap_masked(error, &amp;nmreq, bitmap,
		NFS_ATTR_BITMAP_LEN, nmp-&gt;nm_fsattr.nfsa_supp_attr);
	<span class="enscript-keyword">if</span> (prefetch) {
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_SAVEFH);
	}
	<span class="enscript-keyword">if</span> (hadattrdir) {
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
		nfsm_chain_add_fh(error, &amp;nmreq, nmp-&gt;nm_vers, adnp-&gt;n_fhp, adnp-&gt;n_fhsize);
	} <span class="enscript-keyword">else</span> {
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
		nfsm_chain_add_fh(error, &amp;nmreq, nmp-&gt;nm_vers, np-&gt;n_fhp, np-&gt;n_fhsize);
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_OPENATTR);
		nfsm_chain_add_32(error, &amp;nmreq, 0);
	}
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	nfsm_chain_add_bitmap_masked(error, &amp;nmreq, nfs_getattr_bitmap,
		NFS_ATTR_BITMAP_LEN, nmp-&gt;nm_fsattr.nfsa_supp_attr);
	<span class="enscript-keyword">if</span> (prefetch) {
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_RESTOREFH);
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_NVERIFY);
		VATTR_INIT(&amp;vattr);
		VATTR_SET(&amp;vattr, va_data_size, 0);
		nfsm_chain_add_fattr4(error, &amp;nmreq, &amp;vattr, nmp);
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_READ);
		nfsm_chain_add_stateid(error, &amp;nmreq, &amp;stateid);
		nfsm_chain_add_64(error, &amp;nmreq, 0);
		nfsm_chain_add_32(error, &amp;nmreq, rlen);
	}
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request_async(hadattrdir ? adnp : np, NULL, &amp;nmreq, NFSPROC4_COMPOUND,
			vfs_context_thread(ctx), vfs_context_ucred(ctx), &amp;si, open ? R_NOINTR: 0, NULL, &amp;req);
	<span class="enscript-keyword">if</span> (!error)
		error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);

	<span class="enscript-keyword">if</span> (hadattrdir &amp;&amp; ((adlockerror = nfs_node_lock(adnp))))
		error = adlockerror;
	savedxid = xid;
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	<span class="enscript-keyword">if</span> (!hadattrdir) {
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_OPENATTR);
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
		nfsmout_if(error);
		error = nfs4_parsefattr(&amp;nmrep, NULL, &amp;nvattr, &amp;fh, NULL, NULL);
		nfsmout_if(error);
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nvattr.nva_bitmap, NFS_FATTR_FILEHANDLE) &amp;&amp; fh.fh_len) {
			<span class="enscript-keyword">if</span> (!np-&gt;n_attrdirfh || (*np-&gt;n_attrdirfh != fh.fh_len)) {
				<span class="enscript-comment">/* (re)allocate attrdir fh buffer */</span>
				<span class="enscript-keyword">if</span> (np-&gt;n_attrdirfh)
					FREE(np-&gt;n_attrdirfh, M_TEMP);
				MALLOC(np-&gt;n_attrdirfh, u_char*, fh.fh_len+1, M_TEMP, M_WAITOK);
			}
			<span class="enscript-keyword">if</span> (np-&gt;n_attrdirfh) {
				<span class="enscript-comment">/* remember the attrdir fh in the node */</span>
				*np-&gt;n_attrdirfh = fh.fh_len;
				bcopy(fh.fh_data, np-&gt;n_attrdirfh+1, fh.fh_len);
				<span class="enscript-comment">/* create busied node for attrdir */</span>
				<span class="enscript-type">struct</span> componentname cn;
				bzero(&amp;cn, <span class="enscript-keyword">sizeof</span>(cn));
				cn.cn_nameptr = __CAST_AWAY_QUALIFIER(_PATH_FORKSPECIFIER, <span class="enscript-type">const</span>, <span class="enscript-type">char</span> *); <span class="enscript-comment">/* &quot;/..namedfork/&quot; */</span>
				cn.cn_namelen = strlen(_PATH_FORKSPECIFIER);
				cn.cn_nameiop = LOOKUP;
				<span class="enscript-comment">// XXX can't set parent correctly (to np) yet
</span>				error = nfs_nget(NFSTOMP(np), NULL, &amp;cn, fh.fh_data, fh.fh_len, &amp;nvattr, &amp;xid, rq.r_auth, 0, &amp;adnp);
				<span class="enscript-keyword">if</span> (!error) {
					adlockerror = 0;
					<span class="enscript-comment">/* set the node busy */</span>
					SET(adnp-&gt;n_flag, NBUSY);
					adbusyerror = 0;
				}
				<span class="enscript-comment">/* if no adnp, oh well... */</span>
				error = 0;
			}
		}
		NVATTR_CLEANUP(&amp;nvattr);
		fh.fh_len = 0;
	}
	<span class="enscript-keyword">if</span> (open) {
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_OPEN);
		nfs_owner_seqid_increment(noop, NULL, error);
		nfsm_chain_get_stateid(error, &amp;nmrep, &amp;newnofp-&gt;nof_stateid);
		nfsm_chain_check_change_info(error, &amp;nmrep, adnp);
		nfsm_chain_get_32(error, &amp;nmrep, rflags);
		bmlen = NFS_ATTR_BITMAP_LEN;
		nfsm_chain_get_bitmap(error, &amp;nmrep, bitmap, bmlen);
		nfsm_chain_get_32(error, &amp;nmrep, delegation);
		<span class="enscript-keyword">if</span> (!error)
			<span class="enscript-keyword">switch</span> (delegation) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_OPEN_DELEGATE_NONE</span>:
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_OPEN_DELEGATE_READ</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_OPEN_DELEGATE_WRITE</span>:
				nfsm_chain_get_stateid(error, &amp;nmrep, &amp;dstateid);
				nfsm_chain_get_32(error, &amp;nmrep, recall);
				<span class="enscript-keyword">if</span> (delegation == NFS_OPEN_DELEGATE_WRITE) <span class="enscript-comment">// space (skip) XXX
</span>					nfsm_chain_adv(error, &amp;nmrep, 3 * NFSX_UNSIGNED);
				<span class="enscript-comment">/* if we have any trouble accepting the ACE, just invalidate it */</span>
				ace_type = ace_flags = ace_mask = len = 0;
				nfsm_chain_get_32(error, &amp;nmrep, ace_type);
				nfsm_chain_get_32(error, &amp;nmrep, ace_flags);
				nfsm_chain_get_32(error, &amp;nmrep, ace_mask);
				nfsm_chain_get_32(error, &amp;nmrep, len);
				ace.ace_flags = nfs4_ace_nfstype_to_vfstype(ace_type, &amp;error);
				ace.ace_flags |= nfs4_ace_nfsflags_to_vfsflags(ace_flags);
				ace.ace_rights = nfs4_ace_nfsmask_to_vfsrights(ace_mask);
				<span class="enscript-keyword">if</span> (!error &amp;&amp; (len &gt;= slen)) {
					MALLOC(s, <span class="enscript-type">char</span>*, len+1, M_TEMP, M_WAITOK);
					<span class="enscript-keyword">if</span> (s)
						slen = len+1;
					<span class="enscript-keyword">else</span>
						ace.ace_flags = 0;
				}
				<span class="enscript-keyword">if</span> (s)
					nfsm_chain_get_opaque(error, &amp;nmrep, len, s);
				<span class="enscript-keyword">else</span>
					nfsm_chain_adv(error, &amp;nmrep, nfsm_rndup(len));
				<span class="enscript-keyword">if</span> (!error &amp;&amp; s) {
					s[len] = <span class="enscript-string">'\0'</span>;
					<span class="enscript-keyword">if</span> (nfs4_id2guid(s, &amp;ace.ace_applicable, (ace_flags &amp; NFS_ACE_IDENTIFIER_GROUP)))
						ace.ace_flags = 0;
				}
				<span class="enscript-keyword">if</span> (error || !s)
					ace.ace_flags = 0;
				<span class="enscript-keyword">if</span> (s &amp;&amp; (s != sbuf))
					FREE(s, M_TEMP);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				error = EBADRPC;
				<span class="enscript-keyword">break</span>;
			}
		<span class="enscript-comment">/* At this point if we have no error, the object was created/opened. */</span>
		open_error = error;
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_LOOKUP);
	}
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsmout_if(error);
	error = nfs4_parsefattr(&amp;nmrep, NULL, &amp;nvattr, &amp;fh, NULL, NULL);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (!NFS_BITMAP_ISSET(nvattr.nva_bitmap, NFS_FATTR_FILEHANDLE) || !fh.fh_len) {
		error = EIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}
	<span class="enscript-keyword">if</span> (prefetch)
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_SAVEFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	<span class="enscript-keyword">if</span> (!hadattrdir)
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_OPENATTR);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsmout_if(error);
	xid = savedxid;
	nfsm_chain_loadattr(error, &amp;nmrep, adnp, nmp-&gt;nm_vers, &amp;xid);
	nfsmout_if(error);

	<span class="enscript-keyword">if</span> (open) {
		<span class="enscript-keyword">if</span> (rflags &amp; NFS_OPEN_RESULT_LOCKTYPE_POSIX)
			newnofp-&gt;nof_flags |= NFS_OPEN_FILE_POSIXLOCK;
		<span class="enscript-keyword">if</span> (rflags &amp; NFS_OPEN_RESULT_CONFIRM) {
			<span class="enscript-keyword">if</span> (adnp) {
				nfs_node_unlock(adnp);
				adlockerror = ENOENT;
			}
			NVATTR_CLEANUP(&amp;nvattr);
			error = nfs4_open_confirm_rpc(nmp, adnp ? adnp : np, fh.fh_data, fh.fh_len, noop, &amp;newnofp-&gt;nof_stateid, thd, cred, &amp;nvattr, &amp;xid);
			nfsmout_if(error);
			savedxid = xid;
			<span class="enscript-keyword">if</span> ((adlockerror = nfs_node_lock(adnp)))
				error = adlockerror;
		}
	}

<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (open &amp;&amp; adnp &amp;&amp; !adlockerror) {
		<span class="enscript-keyword">if</span> (!open_error &amp;&amp; (adnp-&gt;n_flag &amp; NNEGNCENTRIES)) {
			adnp-&gt;n_flag &amp;= ~NNEGNCENTRIES;
			cache_purge_negatives(NFSTOV(adnp));
		}
		adnp-&gt;n_flag |= NMODIFIED;
		nfs_node_unlock(adnp);
		adlockerror = ENOENT;
		nfs_getattr(adnp, NULL, ctx, NGA_CACHED);
	}
	<span class="enscript-keyword">if</span> (adnp &amp;&amp; !adlockerror &amp;&amp; (error == ENOENT) &amp;&amp;
	    (cnp-&gt;cn_flags &amp; MAKEENTRY) &amp;&amp; (cnp-&gt;cn_nameiop != CREATE) &amp;&amp; negnamecache) {
		<span class="enscript-comment">/* add a negative entry in the name cache */</span>
		cache_enter(NFSTOV(adnp), NULL, cnp);
		adnp-&gt;n_flag |= NNEGNCENTRIES;
	}
	<span class="enscript-keyword">if</span> (adnp &amp;&amp; !adlockerror) {
		nfs_node_unlock(adnp);
		adlockerror = ENOENT;
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; !anp &amp;&amp; fh.fh_len) {
		<span class="enscript-comment">/* create the vnode with the filehandle and attributes */</span>
		xid = savedxid;
		error = nfs_nget(NFSTOMP(np), adnp, cnp, fh.fh_data, fh.fh_len, &amp;nvattr, &amp;xid, rq.r_auth, NG_MAKEENTRY, &amp;anp);
		<span class="enscript-keyword">if</span> (!error) {
			*anpp = anp;
			nfs_node_unlock(anp);
		}
		<span class="enscript-keyword">if</span> (!error &amp;&amp; open) {
			nfs_open_file_add_open(newnofp, accessMode, denyMode, 0);
			<span class="enscript-comment">/* After we have a node, add our open file struct to the node */</span>
			nofp = newnofp;
			error = nfs_open_file_find_internal(anp, noop, &amp;nofp, 0, 0, 0);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-comment">/* This shouldn't happen, because we passed in a new nofp to use. */</span>
				printf(<span class="enscript-string">&quot;nfs_open_file_find_internal failed! %d\n&quot;</span>, error);
				nofp = NULL;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp != newnofp) {
				<span class="enscript-comment">/*
				 * Hmm... an open file struct already exists.
				 * Mark the existing one busy and merge our open into it.
				 * Then destroy the one we created.
				 * Note: there's no chance of an open confict because the
				 * open has already been granted.
				 */</span>
				nofpbusyerror = nfs_open_file_set_busy(nofp, NULL);
				nfs_open_file_add_open(nofp, accessMode, denyMode, 0);
				nofp-&gt;nof_stateid = newnofp-&gt;nof_stateid;
				<span class="enscript-keyword">if</span> (newnofp-&gt;nof_flags &amp; NFS_OPEN_FILE_POSIXLOCK)
					nofp-&gt;nof_flags |= NFS_OPEN_FILE_POSIXLOCK;
				nfs_open_file_clear_busy(newnofp);
				nfs_open_file_destroy(newnofp);
				newnofp = NULL;
			}
			<span class="enscript-keyword">if</span> (!error) {
				newnofp = NULL;
				nofpbusyerror = 0;
				<span class="enscript-comment">/* mark the node as holding a create-initiated open */</span>
				nofp-&gt;nof_flags |= NFS_OPEN_FILE_CREATE;
				nofp-&gt;nof_creator = current_thread();
				<span class="enscript-keyword">if</span> (nofpp)
					*nofpp = nofp;
			}
		}
	}
	NVATTR_CLEANUP(&amp;nvattr);
	<span class="enscript-keyword">if</span> (open &amp;&amp; ((delegation == NFS_OPEN_DELEGATE_READ) || (delegation == NFS_OPEN_DELEGATE_WRITE))) {
		<span class="enscript-keyword">if</span> (!error &amp;&amp; anp &amp;&amp; !recall) {
			<span class="enscript-comment">/* stuff the delegation state in the node */</span>
			lck_mtx_lock(&amp;anp-&gt;n_openlock);
			anp-&gt;n_openflags &amp;= ~N_DELEG_MASK;
			anp-&gt;n_openflags |= ((delegation == NFS_OPEN_DELEGATE_READ) ? N_DELEG_READ : N_DELEG_WRITE);
			anp-&gt;n_dstateid = dstateid;
			anp-&gt;n_dace = ace;
			<span class="enscript-keyword">if</span> (anp-&gt;n_dlink.tqe_next == NFSNOLIST) {
				lck_mtx_lock(&amp;nmp-&gt;nm_lock);
				<span class="enscript-keyword">if</span> (anp-&gt;n_dlink.tqe_next == NFSNOLIST)
					TAILQ_INSERT_TAIL(&amp;nmp-&gt;nm_delegations, anp, n_dlink);
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			}
			lck_mtx_unlock(&amp;anp-&gt;n_openlock);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* give the delegation back */</span>
			<span class="enscript-keyword">if</span> (anp) {
				<span class="enscript-keyword">if</span> (NFS_CMPFH(anp, fh.fh_data, fh.fh_len)) {
					<span class="enscript-comment">/* update delegation state and return it */</span>
					lck_mtx_lock(&amp;anp-&gt;n_openlock);
					anp-&gt;n_openflags &amp;= ~N_DELEG_MASK;
					anp-&gt;n_openflags |= ((delegation == NFS_OPEN_DELEGATE_READ) ? N_DELEG_READ : N_DELEG_WRITE);
					anp-&gt;n_dstateid = dstateid;
					anp-&gt;n_dace = ace;
					<span class="enscript-keyword">if</span> (anp-&gt;n_dlink.tqe_next == NFSNOLIST) {
						lck_mtx_lock(&amp;nmp-&gt;nm_lock);
						<span class="enscript-keyword">if</span> (anp-&gt;n_dlink.tqe_next == NFSNOLIST)
							TAILQ_INSERT_TAIL(&amp;nmp-&gt;nm_delegations, anp, n_dlink);
						lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
					}
					lck_mtx_unlock(&amp;anp-&gt;n_openlock);
					<span class="enscript-comment">/* don't need to send a separate delegreturn for fh */</span>
					fh.fh_len = 0;
				}
				<span class="enscript-comment">/* return anp's current delegation */</span>
				nfs4_delegation_return(anp, 0, thd, cred);
			}
			<span class="enscript-keyword">if</span> (fh.fh_len) <span class="enscript-comment">/* return fh's delegation if it wasn't for anp */</span>
				nfs4_delegreturn_rpc(nmp, fh.fh_data, fh.fh_len, &amp;dstateid, 0, thd, cred);
		}
	}
	<span class="enscript-keyword">if</span> (open) {
		<span class="enscript-keyword">if</span> (newnofp) {
			<span class="enscript-comment">/* need to cleanup our temporary nofp */</span>
			nfs_open_file_clear_busy(newnofp);
			nfs_open_file_destroy(newnofp);
			newnofp = NULL;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nofp &amp;&amp; !nofpbusyerror) {
			nfs_open_file_clear_busy(nofp);
			nofpbusyerror = ENOENT;
		}
		<span class="enscript-keyword">if</span> (inuse &amp;&amp; nfs_mount_state_in_use_end(nmp, error)) {
			inuse = 0;
			nofp = newnofp = NULL;
			rflags = delegation = recall = eof = rlen = retlen = 0;
			ace.ace_flags = 0;
			s = sbuf;
			slen = <span class="enscript-keyword">sizeof</span>(sbuf);
			nfsm_chain_cleanup(&amp;nmreq);
			nfsm_chain_cleanup(&amp;nmrep);
			<span class="enscript-keyword">if</span> (anp) {
				vnode_put(NFSTOV(anp));
				*anpp = anp = NULL;
			}
			hadattrdir = (adnp != NULL);
			<span class="enscript-keyword">if</span> (noopbusy) {
				nfs_open_owner_clear_busy(noop);
				noopbusy = 0;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		}
		<span class="enscript-keyword">if</span> (noop) {
			<span class="enscript-keyword">if</span> (noopbusy) {
				nfs_open_owner_clear_busy(noop);
				noopbusy = 0;
			}
			nfs_open_owner_rele(noop);
		}
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; prefetch &amp;&amp; nmrep.nmc_mhead) {
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_RESTOREFH);
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_NVERIFY);
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_READ);
		nfsm_chain_get_32(error, &amp;nmrep, eof);
		nfsm_chain_get_32(error, &amp;nmrep, retlen);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; anp) {
			<span class="enscript-comment">/*
			 * There can be one problem with doing the prefetch.
			 * Because we don't have the node before we start the RPC, we
			 * can't have the buffer busy while the READ is performed.
			 * So there is a chance that other I/O occured on the same
			 * range of data while we were performing this RPC.  If that
			 * happens, then it's possible the data we have in the READ
			 * response is no longer up to date.
			 * Once we have the node and the buffer, we need to make sure
			 * that there's no chance we could be putting stale data in
			 * the buffer.
			 * So, we check if the range read is dirty or if any I/O may
			 * have occured on it while we were performing our RPC.
			 */</span>
			<span class="enscript-type">struct</span> nfsbuf *bp = NULL;
			<span class="enscript-type">int</span> lastpg;
			uint32_t pagemask;

			retlen = MIN(retlen, rlen);

			<span class="enscript-comment">/* check if node needs size update or invalidation */</span>
			<span class="enscript-keyword">if</span> (ISSET(anp-&gt;n_flag, NUPDATESIZE))
				nfs_data_update_size(anp, 0);
			<span class="enscript-keyword">if</span> (!(error = nfs_node_lock(anp))) {
				<span class="enscript-keyword">if</span> (anp-&gt;n_flag &amp; NNEEDINVALIDATE) {
					anp-&gt;n_flag &amp;= ~NNEEDINVALIDATE;
					nfs_node_unlock(anp);
					error = nfs_vinvalbuf(NFSTOV(anp), V_SAVE|V_IGNORE_WRITEERR, ctx, 1);
					<span class="enscript-keyword">if</span> (!error) <span class="enscript-comment">/* lets play it safe and just drop the data */</span>
						error = EIO;
				} <span class="enscript-keyword">else</span> {
					nfs_node_unlock(anp);
				}
			}

			<span class="enscript-comment">/* calculate page mask for the range of data read */</span>
			lastpg = (trunc_page_32(retlen) - 1) / PAGE_SIZE;
			pagemask = ((1 &lt;&lt; (lastpg + 1)) - 1);

			<span class="enscript-keyword">if</span> (!error)
				error = nfs_buf_get(anp, 0, nmp-&gt;nm_biosize, thd, NBLK_READ|NBLK_NOWAIT, &amp;bp);
			<span class="enscript-comment">/* don't save the data if dirty or potential I/O conflict */</span>
			<span class="enscript-keyword">if</span> (!error &amp;&amp; bp &amp;&amp; !bp-&gt;nb_dirtyoff &amp;&amp; !(bp-&gt;nb_dirty &amp; pagemask) &amp;&amp;
			    timevalcmp(&amp;anp-&gt;n_lastio, &amp;now, &lt;)) {
				OSAddAtomic64(1, &amp;nfsstats.read_bios);
				CLR(bp-&gt;nb_flags, (NB_DONE|NB_ASYNC));
				SET(bp-&gt;nb_flags, NB_READ);
				NFS_BUF_MAP(bp);
				nfsm_chain_get_opaque(error, &amp;nmrep, retlen, bp-&gt;nb_data);
				<span class="enscript-keyword">if</span> (error) {
					bp-&gt;nb_error = error;
					SET(bp-&gt;nb_flags, NB_ERROR);
				} <span class="enscript-keyword">else</span> {
					bp-&gt;nb_offio = 0;
					bp-&gt;nb_endio = rlen;
					<span class="enscript-keyword">if</span> ((retlen &gt; 0) &amp;&amp; (bp-&gt;nb_endio &lt; (<span class="enscript-type">int</span>)retlen))
						bp-&gt;nb_endio = retlen;
					<span class="enscript-keyword">if</span> (eof || (retlen == 0)) {
						<span class="enscript-comment">/* zero out the remaining data (up to EOF) */</span>
						off_t rpcrem, eofrem, rem;
						rpcrem = (rlen - retlen);
						eofrem = anp-&gt;n_size - (NBOFF(bp) + retlen);
						rem = (rpcrem &lt; eofrem) ? rpcrem : eofrem;
						<span class="enscript-keyword">if</span> (rem &gt; 0)
							bzero(bp-&gt;nb_data + retlen, rem);
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((retlen &lt; rlen) &amp;&amp; !ISSET(bp-&gt;nb_flags, NB_ERROR)) {
						<span class="enscript-comment">/* ugh... short read ... just invalidate for now... */</span>
						SET(bp-&gt;nb_flags, NB_INVAL);
					}
				}
				nfs_buf_read_finish(bp);
				microuptime(&amp;anp-&gt;n_lastio);
			}
			<span class="enscript-keyword">if</span> (bp)
				nfs_buf_release(bp, 1);
		}
		error = 0; <span class="enscript-comment">/* ignore any transient error in processing the prefetch */</span>
	}
	<span class="enscript-keyword">if</span> (adnp &amp;&amp; !adbusyerror) {
		nfs_node_clear_busy(adnp);
		adbusyerror = ENOENT;
	}
	<span class="enscript-keyword">if</span> (!busyerror) {
		nfs_node_clear_busy(np);
		busyerror = ENOENT;
	}
	<span class="enscript-keyword">if</span> (adnp)
		vnode_put(NFSTOV(adnp));
	<span class="enscript-keyword">if</span> (error &amp;&amp; *anpp) {
		vnode_put(NFSTOV(*anpp));
		*anpp = NULL;
	}
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Remove a named attribute.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_named_attr_remove</span>(nfsnode_t np, nfsnode_t anp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, vfs_context_t ctx)
{
	nfsnode_t adnp = NULL;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> componentname cn;
	<span class="enscript-type">struct</span> vnop_remove_args vra;
	<span class="enscript-type">int</span> error, putanp = 0;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	bzero(&amp;cn, <span class="enscript-keyword">sizeof</span>(cn));
	cn.cn_nameptr = __CAST_AWAY_QUALIFIER(name, <span class="enscript-type">const</span>, <span class="enscript-type">char</span> *);
	cn.cn_namelen = strlen(name);
	cn.cn_nameiop = DELETE;
	cn.cn_flags = 0;

	<span class="enscript-keyword">if</span> (!anp) {
		error = nfs4_named_attr_get(np, &amp;cn, NFS_OPEN_SHARE_ACCESS_NONE,
				0, ctx, &amp;anp, NULL);
		<span class="enscript-keyword">if</span> ((!error &amp;&amp; !anp) || (error == ENOATTR))
			error = ENOENT;
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (anp) {
				vnode_put(NFSTOV(anp));
				anp = NULL;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		putanp = 1;
	}

	<span class="enscript-keyword">if</span> ((error = nfs_node_set_busy(np, vfs_context_thread(ctx))))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	adnp = nfs4_named_attr_dir_get(np, 1, ctx);
	nfs_node_clear_busy(np);
	<span class="enscript-keyword">if</span> (!adnp) {
		error = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	vra.a_desc = &amp;vnop_remove_desc;
	vra.a_dvp = NFSTOV(adnp);
	vra.a_vp = NFSTOV(anp);
	vra.a_cnp = &amp;cn;
	vra.a_flags = 0;
	vra.a_context = ctx;
	error = nfs_vnop_remove(&amp;vra);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (adnp)
		vnode_put(NFSTOV(adnp));
	<span class="enscript-keyword">if</span> (putanp)
		vnode_put(NFSTOV(anp));
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_vnop_getxattr</span>(
	<span class="enscript-type">struct</span> vnop_getxattr_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		const char * a_name;
		uio_t a_uio;
		size_t *a_size;
		int a_options;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">struct</span> componentname cn;
	nfsnode_t anp;
	<span class="enscript-type">int</span> error = 0, isrsrcfork;

	nmp = VTONMP(ap-&gt;a_vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR))
		<span class="enscript-keyword">return</span> (ENOTSUP);
	error = nfs_getattr(VTONFS(ap-&gt;a_vp), &amp;nvattr, ctx, NGA_CACHED);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nvattr.nva_bitmap, NFS_FATTR_NAMED_ATTR) &amp;&amp;
	    !(nvattr.nva_flags &amp; NFS_FFLAG_HAS_NAMED_ATTRS))
		<span class="enscript-keyword">return</span> (ENOATTR);

	bzero(&amp;cn, <span class="enscript-keyword">sizeof</span>(cn));
	cn.cn_nameptr = __CAST_AWAY_QUALIFIER(ap-&gt;a_name, <span class="enscript-type">const</span>, <span class="enscript-type">char</span> *);
	cn.cn_namelen = strlen(ap-&gt;a_name);
	cn.cn_nameiop = LOOKUP;
	cn.cn_flags = MAKEENTRY;

	<span class="enscript-comment">/* we'll normally try to prefetch data for xattrs... the resource fork is really a stream */</span>
	isrsrcfork = (bcmp(ap-&gt;a_name, XATTR_RESOURCEFORK_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_RESOURCEFORK_NAME)) == 0);

	error = nfs4_named_attr_get(VTONFS(ap-&gt;a_vp), &amp;cn, NFS_OPEN_SHARE_ACCESS_NONE,
			!isrsrcfork ? NFS_GET_NAMED_ATTR_PREFETCH : 0, ctx, &amp;anp, NULL);
	<span class="enscript-keyword">if</span> ((!error &amp;&amp; !anp) || (error == ENOENT))
		error = ENOATTR;
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-keyword">if</span> (ap-&gt;a_uio)
			error = nfs_bioread(anp, ap-&gt;a_uio, 0, ctx);
		<span class="enscript-keyword">else</span>
			*ap-&gt;a_size = anp-&gt;n_size;
	}
	<span class="enscript-keyword">if</span> (anp)
		vnode_put(NFSTOV(anp));
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_vnop_setxattr</span>(
	<span class="enscript-type">struct</span> vnop_setxattr_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		const char * a_name;
		uio_t a_uio;
		int a_options;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	<span class="enscript-type">int</span> options = ap-&gt;a_options;
	uio_t uio = ap-&gt;a_uio;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name = ap-&gt;a_name;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> componentname cn;
	nfsnode_t anp = NULL;
	<span class="enscript-type">int</span> error = 0, closeerror = 0, flags, isrsrcfork, isfinderinfo, empty = 0, i;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">FINDERINFOSIZE</span> 32
	uint8_t finfo[FINDERINFOSIZE];
	uint32_t *finfop;
	<span class="enscript-type">struct</span> nfs_open_file *nofp = NULL;
	<span class="enscript-type">char</span> uio_buf [ UIO_SIZEOF(1) ];
	uio_t auio;
	<span class="enscript-type">struct</span> vnop_write_args vwa;

	nmp = VTONMP(ap-&gt;a_vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR))
		<span class="enscript-keyword">return</span> (ENOTSUP);

	<span class="enscript-keyword">if</span> ((options &amp; XATTR_CREATE) &amp;&amp; (options &amp; XATTR_REPLACE))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* XXX limitation based on need to back up uio on short write */</span>
	<span class="enscript-keyword">if</span> (uio_iovcnt(uio) &gt; 1) {
		printf(<span class="enscript-string">&quot;nfs4_vnop_setxattr: iovcnt &gt; 1\n&quot;</span>);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	bzero(&amp;cn, <span class="enscript-keyword">sizeof</span>(cn));
	cn.cn_nameptr = __CAST_AWAY_QUALIFIER(name, <span class="enscript-type">const</span>, <span class="enscript-type">char</span> *);
	cn.cn_namelen = strlen(name);
	cn.cn_nameiop = CREATE;
	cn.cn_flags = MAKEENTRY;

	isfinderinfo = (bcmp(name, XATTR_FINDERINFO_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_FINDERINFO_NAME)) == 0);
	isrsrcfork = isfinderinfo ? 0 : (bcmp(name, XATTR_RESOURCEFORK_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_RESOURCEFORK_NAME)) == 0);
	<span class="enscript-keyword">if</span> (!isrsrcfork)
		uio_setoffset(uio, 0);
	<span class="enscript-keyword">if</span> (isfinderinfo) {
		<span class="enscript-keyword">if</span> (uio_resid(uio) != <span class="enscript-keyword">sizeof</span>(finfo))
			<span class="enscript-keyword">return</span> (ERANGE);
		error = uiomove((<span class="enscript-type">char</span>*)&amp;finfo, <span class="enscript-keyword">sizeof</span>(finfo), uio);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-comment">/* setting a FinderInfo of all zeroes means remove the FinderInfo */</span>
		empty = 1;
		<span class="enscript-keyword">for</span> (i=0, finfop=(uint32_t*)&amp;finfo; i &lt; (<span class="enscript-type">int</span>)(<span class="enscript-keyword">sizeof</span>(finfo)/<span class="enscript-keyword">sizeof</span>(uint32_t)); i++)
			<span class="enscript-keyword">if</span> (finfop[i]) {
				empty = 0;
				<span class="enscript-keyword">break</span>;
			}
		<span class="enscript-keyword">if</span> (empty &amp;&amp; !(options &amp; (XATTR_CREATE|XATTR_REPLACE))) {
			error = nfs4_named_attr_remove(VTONFS(ap-&gt;a_vp), anp, name, ctx);
			<span class="enscript-keyword">if</span> (error == ENOENT)
				error = 0;
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-comment">/* first, let's see if we get a create/replace error */</span>
	}

	<span class="enscript-comment">/*
	 * create/open the xattr
	 *
	 * We need to make sure not to create it if XATTR_REPLACE.
	 * For all xattrs except the resource fork, we also want to
	 * truncate the xattr to remove any current data.  We'll do
	 * that by setting the size to 0 on create/open.
	 */</span>
	flags = 0;
	<span class="enscript-keyword">if</span> (!(options &amp; XATTR_REPLACE))
		flags |= NFS_GET_NAMED_ATTR_CREATE;
	<span class="enscript-keyword">if</span> (options &amp; XATTR_CREATE)
		flags |= NFS_GET_NAMED_ATTR_CREATE_GUARDED;
	<span class="enscript-keyword">if</span> (!isrsrcfork)
		flags |= NFS_GET_NAMED_ATTR_TRUNCATE;

	error = nfs4_named_attr_get(VTONFS(ap-&gt;a_vp), &amp;cn, NFS_OPEN_SHARE_ACCESS_BOTH,
			flags, ctx, &amp;anp, &amp;nofp);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; !anp)
		error = ENOATTR;
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	<span class="enscript-comment">/* grab the open state from the get/create/open */</span>
	<span class="enscript-keyword">if</span> (nofp &amp;&amp; !(error = nfs_open_file_set_busy(nofp, NULL))) {
		nofp-&gt;nof_flags &amp;= ~NFS_OPEN_FILE_CREATE;
		nofp-&gt;nof_creator = NULL;
		nfs_open_file_clear_busy(nofp);
	}

	<span class="enscript-comment">/* Setting an empty FinderInfo really means remove it, skip to the close/remove */</span>
	<span class="enscript-keyword">if</span> (isfinderinfo &amp;&amp; empty)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">doclose</span>;

	<span class="enscript-comment">/*
	 * Write the data out and flush.
	 *
	 * For FinderInfo, we've already copied the data to finfo, so do I/O from there.
	 */</span>
	vwa.a_desc = &amp;vnop_write_desc;
	vwa.a_vp = NFSTOV(anp);
	vwa.a_uio = NULL;
	vwa.a_ioflag = 0;
	vwa.a_context = ctx;
	<span class="enscript-keyword">if</span> (isfinderinfo) {
		auio = uio_createwithbuffer(1, 0, UIO_SYSSPACE, UIO_WRITE, &amp;uio_buf, <span class="enscript-keyword">sizeof</span>(uio_buf));
		uio_addiov(auio, (uintptr_t)&amp;finfo, <span class="enscript-keyword">sizeof</span>(finfo));
		vwa.a_uio = auio;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uio_resid(uio) &gt; 0) {
		vwa.a_uio = uio;
	}
	<span class="enscript-keyword">if</span> (vwa.a_uio) {
		error = nfs_vnop_write(&amp;vwa);
		<span class="enscript-keyword">if</span> (!error)
			error = nfs_flush(anp, MNT_WAIT, vfs_context_thread(ctx), 0);
	}
<span class="enscript-reference">doclose</span>:
	<span class="enscript-comment">/* Close the xattr. */</span>
	<span class="enscript-keyword">if</span> (nofp) {
		<span class="enscript-type">int</span> busyerror = nfs_open_file_set_busy(nofp, NULL);
		closeerror = nfs_close(anp, nofp, NFS_OPEN_SHARE_ACCESS_BOTH, NFS_OPEN_SHARE_DENY_NONE, ctx);
		<span class="enscript-keyword">if</span> (!busyerror)
			nfs_open_file_clear_busy(nofp);
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; isfinderinfo &amp;&amp; empty) { <span class="enscript-comment">/* Setting an empty FinderInfo really means remove it */</span> 
		error = nfs4_named_attr_remove(VTONFS(ap-&gt;a_vp), anp, name, ctx);
		<span class="enscript-keyword">if</span> (error == ENOENT)
			error = 0;
	}
	<span class="enscript-keyword">if</span> (!error)
		error = closeerror;
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (anp)
		vnode_put(NFSTOV(anp));
	<span class="enscript-keyword">if</span> (error == ENOENT)
		error = ENOATTR;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_vnop_removexattr</span>(
	<span class="enscript-type">struct</span> vnop_removexattr_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		const char * a_name;
		int a_options;
		vfs_context_t a_context;
	} */</span> *ap)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = VTONMP(ap-&gt;a_vp);
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR))
		<span class="enscript-keyword">return</span> (ENOTSUP);

	error = nfs4_named_attr_remove(VTONFS(ap-&gt;a_vp), NULL, ap-&gt;a_name, ap-&gt;a_context);
	<span class="enscript-keyword">if</span> (error == ENOENT)
		error = ENOATTR;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_vnop_listxattr</span>(
	<span class="enscript-type">struct</span> vnop_listxattr_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		uio_t a_uio;
		size_t *a_size;
		int a_options;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	nfsnode_t np = VTONFS(ap-&gt;a_vp);
	uio_t uio = ap-&gt;a_uio;
	nfsnode_t adnp = NULL;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error, done, i;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	uint64_t cookie, nextcookie, lbn = 0;
	<span class="enscript-type">struct</span> nfsbuf *bp = NULL;
	<span class="enscript-type">struct</span> nfs_dir_buf_header *ndbhp;
	<span class="enscript-type">struct</span> direntry *dp;

	nmp = VTONMP(ap-&gt;a_vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR))
		<span class="enscript-keyword">return</span> (ENOTSUP);

	error = nfs_getattr(np, &amp;nvattr, ctx, NGA_CACHED);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nvattr.nva_bitmap, NFS_FATTR_NAMED_ATTR) &amp;&amp;
	    !(nvattr.nva_flags &amp; NFS_FFLAG_HAS_NAMED_ATTRS))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> ((error = nfs_node_set_busy(np, vfs_context_thread(ctx))))
		<span class="enscript-keyword">return</span> (error);
	adnp = nfs4_named_attr_dir_get(np, 1, ctx);
	nfs_node_clear_busy(np);
	<span class="enscript-keyword">if</span> (!adnp)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> ((error = nfs_node_lock(adnp)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (adnp-&gt;n_flag &amp; NNEEDINVALIDATE) {
		adnp-&gt;n_flag &amp;= ~NNEEDINVALIDATE;
		nfs_invaldir(adnp);
		nfs_node_unlock(adnp);
		error = nfs_vinvalbuf(NFSTOV(adnp), 0, ctx, 1);
		<span class="enscript-keyword">if</span> (!error)
			error = nfs_node_lock(adnp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * check for need to invalidate when (re)starting at beginning
	 */</span>
	<span class="enscript-keyword">if</span> (adnp-&gt;n_flag &amp; NMODIFIED) {
		nfs_invaldir(adnp);
		nfs_node_unlock(adnp);
		<span class="enscript-keyword">if</span> ((error = nfs_vinvalbuf(NFSTOV(adnp), 0, ctx, 1)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	} <span class="enscript-keyword">else</span> {
		nfs_node_unlock(adnp);
	}
	<span class="enscript-comment">/* nfs_getattr() will check changed and purge caches */</span>
	<span class="enscript-keyword">if</span> ((error = nfs_getattr(adnp, &amp;nvattr, ctx, NGA_UNCACHED)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">if</span> (uio &amp;&amp; (uio_resid(uio) == 0))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	done = 0;
	nextcookie = lbn = 0;

	<span class="enscript-keyword">while</span> (!error &amp;&amp; !done) {
		OSAddAtomic64(1, &amp;nfsstats.biocache_readdirs);
		cookie = nextcookie;
<span class="enscript-reference">getbuffer</span>:
		error = nfs_buf_get(adnp, lbn, NFS_DIRBLKSIZ, vfs_context_thread(ctx), NBLK_READ, &amp;bp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		ndbhp = (<span class="enscript-type">struct</span> nfs_dir_buf_header*)bp-&gt;nb_data;
		<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_CACHE) || !ISSET(ndbhp-&gt;ndbh_flags, NDB_FULL)) {
			<span class="enscript-keyword">if</span> (!ISSET(bp-&gt;nb_flags, NB_CACHE)) { <span class="enscript-comment">/* initialize the buffer */</span>
				ndbhp-&gt;ndbh_flags = 0;
				ndbhp-&gt;ndbh_count = 0;
				ndbhp-&gt;ndbh_entry_end = <span class="enscript-keyword">sizeof</span>(*ndbhp);
				ndbhp-&gt;ndbh_ncgen = adnp-&gt;n_ncgen;
			}
			error = nfs_buf_readdir(bp, ctx);
			<span class="enscript-keyword">if</span> (error == NFSERR_DIRBUFDROPPED)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">getbuffer</span>;
			<span class="enscript-keyword">if</span> (error)
				nfs_buf_release(bp, 1);
			<span class="enscript-keyword">if</span> (error &amp;&amp; (error != ENXIO) &amp;&amp; (error != ETIMEDOUT) &amp;&amp; (error != EINTR) &amp;&amp; (error != ERESTART)) {
				<span class="enscript-keyword">if</span> (!nfs_node_lock(adnp)) {
					nfs_invaldir(adnp);
					nfs_node_unlock(adnp);
				}
				nfs_vinvalbuf(NFSTOV(adnp), 0, ctx, 1);
				<span class="enscript-keyword">if</span> (error == NFSERR_BAD_COOKIE)
					error = ENOENT;
			}
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-comment">/* go through all the entries copying/counting */</span>
		dp = NFS_DIR_BUF_FIRST_DIRENTRY(bp);
		<span class="enscript-keyword">for</span> (i=0; i &lt; ndbhp-&gt;ndbh_count; i++) {
			<span class="enscript-keyword">if</span> (!xattr_protected(dp-&gt;d_name)) {
				<span class="enscript-keyword">if</span> (uio == NULL) {
					*ap-&gt;a_size += dp-&gt;d_namlen + 1;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uio_resid(uio) &lt; (dp-&gt;d_namlen + 1)) {
					error = ERANGE;
				} <span class="enscript-keyword">else</span> {
					error = uiomove(dp-&gt;d_name, dp-&gt;d_namlen+1, uio);
					<span class="enscript-keyword">if</span> (error &amp;&amp; (error != EFAULT))
						error = ERANGE;
				}
			}
			nextcookie = dp-&gt;d_seekoff;
			dp = NFS_DIRENTRY_NEXT(dp);
		}

		<span class="enscript-keyword">if</span> (i == ndbhp-&gt;ndbh_count) {
			<span class="enscript-comment">/* hit end of buffer, move to next buffer */</span>
			lbn = nextcookie;
			<span class="enscript-comment">/* if we also hit EOF, we're done */</span>
			<span class="enscript-keyword">if</span> (ISSET(ndbhp-&gt;ndbh_flags, NDB_EOF))
				done = 1;
		}
		<span class="enscript-keyword">if</span> (!error &amp;&amp; !done &amp;&amp; (nextcookie == cookie)) {
			printf(<span class="enscript-string">&quot;nfs readdir cookie didn't change 0x%llx, %d/%d\n&quot;</span>, cookie, i, ndbhp-&gt;ndbh_count);
			error = EIO;
		}
		nfs_buf_release(bp, 1);
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (adnp)
		vnode_put(NFSTOV(adnp));
	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_vnop_getnamedstream</span>(
	<span class="enscript-type">struct</span> vnop_getnamedstream_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		vnode_t *a_svpp;
		const char *a_name;
		enum nsoperation a_operation;
		int a_flags;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">struct</span> componentname cn;
	nfsnode_t anp;
	<span class="enscript-type">int</span> error = 0;

	nmp = VTONMP(ap-&gt;a_vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR))
		<span class="enscript-keyword">return</span> (ENOTSUP);
	error = nfs_getattr(VTONFS(ap-&gt;a_vp), &amp;nvattr, ctx, NGA_CACHED);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nvattr.nva_bitmap, NFS_FATTR_NAMED_ATTR) &amp;&amp;
	    !(nvattr.nva_flags &amp; NFS_FFLAG_HAS_NAMED_ATTRS))
		<span class="enscript-keyword">return</span> (ENOATTR);

	bzero(&amp;cn, <span class="enscript-keyword">sizeof</span>(cn));
	cn.cn_nameptr = __CAST_AWAY_QUALIFIER(ap-&gt;a_name, <span class="enscript-type">const</span>, <span class="enscript-type">char</span> *);
	cn.cn_namelen = strlen(ap-&gt;a_name);
	cn.cn_nameiop = LOOKUP;
	cn.cn_flags = MAKEENTRY;

	error = nfs4_named_attr_get(VTONFS(ap-&gt;a_vp), &amp;cn, NFS_OPEN_SHARE_ACCESS_NONE,
			0, ctx, &amp;anp, NULL);
	<span class="enscript-keyword">if</span> ((!error &amp;&amp; !anp) || (error == ENOENT))
		error = ENOATTR;
	<span class="enscript-keyword">if</span> (!error &amp;&amp; anp)
		*ap-&gt;a_svpp = NFSTOV(anp);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (anp)
		vnode_put(NFSTOV(anp));
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_vnop_makenamedstream</span>(
	<span class="enscript-type">struct</span> vnop_makenamedstream_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t *a_svpp;
		vnode_t a_vp;
		const char *a_name;
		int a_flags;
		vfs_context_t a_context;
	} */</span> *ap)
{
	vfs_context_t ctx = ap-&gt;a_context;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> componentname cn;
	nfsnode_t anp;
	<span class="enscript-type">int</span> error = 0;

	nmp = VTONMP(ap-&gt;a_vp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR))
		<span class="enscript-keyword">return</span> (ENOTSUP);

	bzero(&amp;cn, <span class="enscript-keyword">sizeof</span>(cn));
	cn.cn_nameptr = __CAST_AWAY_QUALIFIER(ap-&gt;a_name, <span class="enscript-type">const</span>, <span class="enscript-type">char</span> *);
	cn.cn_namelen = strlen(ap-&gt;a_name);
	cn.cn_nameiop = CREATE;
	cn.cn_flags = MAKEENTRY;

	error = nfs4_named_attr_get(VTONFS(ap-&gt;a_vp), &amp;cn, NFS_OPEN_SHARE_ACCESS_BOTH,
			NFS_GET_NAMED_ATTR_CREATE, ctx, &amp;anp, NULL);
	<span class="enscript-keyword">if</span> ((!error &amp;&amp; !anp) || (error == ENOENT))
		error = ENOATTR;
	<span class="enscript-keyword">if</span> (!error &amp;&amp; anp)
		*ap-&gt;a_svpp = NFSTOV(anp);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (anp)
		vnode_put(NFSTOV(anp));
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_vnop_removenamedstream</span>(
	<span class="enscript-type">struct</span> vnop_removenamedstream_args <span class="enscript-comment">/* {
		struct vnodeop_desc *a_desc;
		vnode_t a_vp;
		vnode_t a_svp;
		const char *a_name;
		int a_flags;
		vfs_context_t a_context;
	} */</span> *ap)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = VTONMP(ap-&gt;a_vp);
	nfsnode_t np = ap-&gt;a_vp ? VTONFS(ap-&gt;a_vp) : NULL;
	nfsnode_t anp = ap-&gt;a_svp ? VTONFS(ap-&gt;a_svp) : NULL;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-comment">/*
	 * Given that a_svp is a named stream, checking for
	 * named attribute support is kinda pointless.
	 */</span>
	<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR))
		<span class="enscript-keyword">return</span> (ENOTSUP);

	<span class="enscript-keyword">return</span> (nfs4_named_attr_remove(np, anp, ap-&gt;a_name, ap-&gt;a_context));
}

#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>