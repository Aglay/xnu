<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nfs_subs.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nfs_subs.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfs_subs.c	8.8 (Berkeley) 5/22/95
 * FreeBSD-Id: nfs_subs.c,v 1.47 1997/11/07 08:53:24 phk Exp $
 */</span>

<span class="enscript-comment">/*
 * These functions support the macros and help fiddle mbuf chains for
 * the nfs op functions. They do things like create the rpc header and
 * copy data between mbuf chains and uio lists.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syscall.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vmparam.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/rpcv2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsnode.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_NFS_XDR_SUBS_FUNCS_</span> <span class="enscript-comment">/* define this to get xdrbuf function definitions */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/xdr_subs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsm_subs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_gss.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsmount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_lock.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/specfs/specdev.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_interface.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/utfconv.h&gt;</span>

<span class="enscript-comment">/*
 * NFS globals
 */</span>
<span class="enscript-type">struct</span> nfsstats	__attribute__((aligned(8))) nfsstats;
size_t nfs_mbuf_mhlen = 0, nfs_mbuf_minclsize = 0;

<span class="enscript-comment">/*
 * functions to convert between NFS and VFS types
 */</span>
nfstype
<span class="enscript-function-name">vtonfs_type</span>(<span class="enscript-type">enum</span> vtype vtype, <span class="enscript-type">int</span> nfsvers)
{
	<span class="enscript-keyword">switch</span> (vtype) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNON</span>:
		<span class="enscript-keyword">return</span> NFNON;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VREG</span>:
		<span class="enscript-keyword">return</span> NFREG;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VDIR</span>:
		<span class="enscript-keyword">return</span> NFDIR;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VBLK</span>:
		<span class="enscript-keyword">return</span> NFBLK;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VCHR</span>:
		<span class="enscript-keyword">return</span> NFCHR;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VLNK</span>:
		<span class="enscript-keyword">return</span> NFLNK;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VSOCK</span>:
		<span class="enscript-keyword">if</span> (nfsvers &gt; NFS_VER2)
			<span class="enscript-keyword">return</span> NFSOCK;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFIFO</span>:
		<span class="enscript-keyword">if</span> (nfsvers &gt; NFS_VER2)
			<span class="enscript-keyword">return</span> NFFIFO;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VBAD</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VSTR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VCPLX</span>:
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> NFNON;
	}
}

<span class="enscript-type">enum</span> vtype
<span class="enscript-function-name">nfstov_type</span>(nfstype nvtype, <span class="enscript-type">int</span> nfsvers)
{
	<span class="enscript-keyword">switch</span> (nvtype) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFNON</span>:
		<span class="enscript-keyword">return</span> VNON;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFREG</span>:
		<span class="enscript-keyword">return</span> VREG;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFDIR</span>:
		<span class="enscript-keyword">return</span> VDIR;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFBLK</span>:
		<span class="enscript-keyword">return</span> VBLK;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFCHR</span>:
		<span class="enscript-keyword">return</span> VCHR;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFLNK</span>:
		<span class="enscript-keyword">return</span> VLNK;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSOCK</span>:
		<span class="enscript-keyword">if</span> (nfsvers &gt; NFS_VER2)
			<span class="enscript-keyword">return</span> VSOCK;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFFIFO</span>:
		<span class="enscript-keyword">if</span> (nfsvers &gt; NFS_VER2)
			<span class="enscript-keyword">return</span> VFIFO;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFATTRDIR</span>:
		<span class="enscript-keyword">if</span> (nfsvers &gt; NFS_VER3)
			<span class="enscript-keyword">return</span> VDIR;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFNAMEDATTR</span>:
		<span class="enscript-keyword">if</span> (nfsvers &gt; NFS_VER3)
			<span class="enscript-keyword">return</span> VREG;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> VNON;
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">vtonfsv2_mode</span>(<span class="enscript-type">enum</span> vtype vtype, mode_t m)
{
	<span class="enscript-keyword">switch</span> (vtype) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VNON</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VREG</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VDIR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VBLK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VCHR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VLNK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VSOCK</span>:
		<span class="enscript-keyword">return</span> vnode_makeimode(vtype, m);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFIFO</span>:
		<span class="enscript-keyword">return</span> vnode_makeimode(VCHR, m);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VBAD</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VSTR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VCPLX</span>:
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> vnode_makeimode(VNON, m);
	}
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>

<span class="enscript-comment">/*
 * Mapping of old NFS Version 2 RPC numbers to generic numbers.
 */</span>
<span class="enscript-type">int</span> nfsv3_procid[NFS_NPROCS] = {
	NFSPROC_NULL,
	NFSPROC_GETATTR,
	NFSPROC_SETATTR,
	NFSPROC_NOOP,
	NFSPROC_LOOKUP,
	NFSPROC_READLINK,
	NFSPROC_READ,
	NFSPROC_NOOP,
	NFSPROC_WRITE,
	NFSPROC_CREATE,
	NFSPROC_REMOVE,
	NFSPROC_RENAME,
	NFSPROC_LINK,
	NFSPROC_SYMLINK,
	NFSPROC_MKDIR,
	NFSPROC_RMDIR,
	NFSPROC_READDIR,
	NFSPROC_FSSTAT,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP,
	NFSPROC_NOOP
};

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>

<span class="enscript-comment">/*
 * and the reverse mapping from generic to Version 2 procedure numbers
 */</span>
<span class="enscript-type">int</span> nfsv2_procid[NFS_NPROCS] = {
	NFSV2PROC_NULL,
	NFSV2PROC_GETATTR,
	NFSV2PROC_SETATTR,
	NFSV2PROC_LOOKUP,
	NFSV2PROC_NOOP,
	NFSV2PROC_READLINK,
	NFSV2PROC_READ,
	NFSV2PROC_WRITE,
	NFSV2PROC_CREATE,
	NFSV2PROC_MKDIR,
	NFSV2PROC_SYMLINK,
	NFSV2PROC_CREATE,
	NFSV2PROC_REMOVE,
	NFSV2PROC_RMDIR,
	NFSV2PROC_RENAME,
	NFSV2PROC_LINK,
	NFSV2PROC_READDIR,
	NFSV2PROC_NOOP,
	NFSV2PROC_STATFS,
	NFSV2PROC_NOOP,
	NFSV2PROC_NOOP,
	NFSV2PROC_NOOP,
	NFSV2PROC_NOOP
};


<span class="enscript-comment">/*
 * initialize NFS's cache of mbuf constants
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_mbuf_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> mbuf_stat ms;

	mbuf_stats(&amp;ms);
	nfs_mbuf_mhlen = ms.mhlen;
	nfs_mbuf_minclsize = ms.minclsize;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>

<span class="enscript-comment">/*
 * allocate a list of mbufs to hold the given amount of data
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_mbuf_get_list</span>(size_t size, mbuf_t *mp, <span class="enscript-type">int</span> *mbcnt)
{
	<span class="enscript-type">int</span> error, cnt;
	mbuf_t mhead, mlast, m;
	size_t len, mlen;

	error = cnt = 0;
	mhead = mlast = NULL;
	len = 0;

	<span class="enscript-keyword">while</span> (len &lt; size) {
		nfsm_mbuf_get(error, &amp;m, (size - len));
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (!mhead)
			mhead = m;
		<span class="enscript-keyword">if</span> (mlast &amp;&amp; ((error = mbuf_setnext(mlast, m)))) {
			mbuf_free(m);
			<span class="enscript-keyword">break</span>;
		}
		mlen = mbuf_maxlen(m);
		<span class="enscript-keyword">if</span> ((len + mlen) &gt; size)
			mlen = size - len;
		mbuf_setlen(m, mlen);
		len += mlen;
		cnt++;
		mlast = m;
	}

	<span class="enscript-keyword">if</span> (!error) {
		*mp = mhead;
		*mbcnt = cnt;
	}
	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>

<span class="enscript-comment">/*
 * nfsm_chain_new_mbuf()
 *
 * Add a new mbuf to the given chain.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_new_mbuf</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, size_t sizehint)
{
	mbuf_t mb;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (nmc-&gt;nmc_flags &amp; NFSM_CHAIN_FLAG_ADD_CLUSTERS)
		sizehint = nfs_mbuf_minclsize;

	<span class="enscript-comment">/* allocate a new mbuf */</span>
	nfsm_mbuf_get(error, &amp;mb, sizehint);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (mb == NULL)
		panic(<span class="enscript-string">&quot;got NULL mbuf?&quot;</span>);

	<span class="enscript-comment">/* do we have a current mbuf? */</span>
	<span class="enscript-keyword">if</span> (nmc-&gt;nmc_mcur) {
		<span class="enscript-comment">/* first cap off current mbuf */</span>
		mbuf_setlen(nmc-&gt;nmc_mcur, nmc-&gt;nmc_ptr - (caddr_t)mbuf_data(nmc-&gt;nmc_mcur));
		<span class="enscript-comment">/* then append the new mbuf */</span>
		error = mbuf_setnext(nmc-&gt;nmc_mcur, mb);
		<span class="enscript-keyword">if</span> (error) {
			mbuf_free(mb);
			<span class="enscript-keyword">return</span> (error);
		}
	}

	<span class="enscript-comment">/* set up for using the new mbuf */</span>
	nmc-&gt;nmc_mcur = mb;
	nmc-&gt;nmc_ptr = mbuf_data(mb);
	nmc-&gt;nmc_left = mbuf_trailingspace(mb);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * nfsm_chain_add_opaque_f()
 *
 * Add &quot;len&quot; bytes of opaque data pointed to by &quot;buf&quot; to the given chain.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_add_opaque_f</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, <span class="enscript-type">const</span> u_char *buf, uint32_t len)
{
	uint32_t paddedlen, tlen;
	<span class="enscript-type">int</span> error;

	paddedlen = nfsm_rndup(len);

	<span class="enscript-keyword">while</span> (paddedlen) {
		<span class="enscript-keyword">if</span> (!nmc-&gt;nmc_left) {
			error = nfsm_chain_new_mbuf(nmc, paddedlen);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
		}
		tlen = MIN(nmc-&gt;nmc_left, paddedlen);
		<span class="enscript-keyword">if</span> (tlen) {
			<span class="enscript-keyword">if</span> (len) {
				<span class="enscript-keyword">if</span> (tlen &gt; len)
					tlen = len;
				bcopy(buf, nmc-&gt;nmc_ptr, tlen);
			} <span class="enscript-keyword">else</span> {
				bzero(nmc-&gt;nmc_ptr, tlen);
			}
			nmc-&gt;nmc_ptr += tlen;
			nmc-&gt;nmc_left -= tlen;
			paddedlen -= tlen;
			<span class="enscript-keyword">if</span> (len) {
				buf += tlen;
				len -= tlen;
			}
		}
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * nfsm_chain_add_opaque_nopad_f()
 *
 * Add &quot;len&quot; bytes of opaque data pointed to by &quot;buf&quot; to the given chain.
 * Do not XDR pad.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_add_opaque_nopad_f</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, <span class="enscript-type">const</span> u_char *buf, uint32_t len)
{
	uint32_t tlen;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">while</span> (len &gt; 0) {
		<span class="enscript-keyword">if</span> (nmc-&gt;nmc_left &lt;= 0) {
			error = nfsm_chain_new_mbuf(nmc, len);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
		}
		tlen = MIN(nmc-&gt;nmc_left, len);
		bcopy(buf, nmc-&gt;nmc_ptr, tlen);
		nmc-&gt;nmc_ptr += tlen;
		nmc-&gt;nmc_left -= tlen;
		len -= tlen;
		buf += tlen;
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * nfsm_chain_add_uio()
 *
 * Add &quot;len&quot; bytes of data from &quot;uio&quot; to the given chain.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_add_uio</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, uio_t uio, uint32_t len)
{
	uint32_t paddedlen, tlen;
	<span class="enscript-type">int</span> error;

	paddedlen = nfsm_rndup(len);

	<span class="enscript-keyword">while</span> (paddedlen) {
		<span class="enscript-keyword">if</span> (!nmc-&gt;nmc_left) {
			error = nfsm_chain_new_mbuf(nmc, paddedlen);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
		}
		tlen = MIN(nmc-&gt;nmc_left, paddedlen);
		<span class="enscript-keyword">if</span> (tlen) {
			<span class="enscript-keyword">if</span> (len) {
				<span class="enscript-keyword">if</span> (tlen &gt; len)
					tlen = len;
				uiomove(nmc-&gt;nmc_ptr, tlen, uio);
			} <span class="enscript-keyword">else</span> {
				bzero(nmc-&gt;nmc_ptr, tlen);
			}
			nmc-&gt;nmc_ptr += tlen;
			nmc-&gt;nmc_left -= tlen;
			paddedlen -= tlen;
			<span class="enscript-keyword">if</span> (len)
				len -= tlen;
		}
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Find the length of the NFS mbuf chain
 * up to the current encoding/decoding offset.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_offset</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc)
{
	mbuf_t mb;
	<span class="enscript-type">int</span> len = 0;

	<span class="enscript-keyword">for</span> (mb = nmc-&gt;nmc_mhead; mb; mb = mbuf_next(mb)) {
		<span class="enscript-keyword">if</span> (mb == nmc-&gt;nmc_mcur)
			<span class="enscript-keyword">return</span> (len + (nmc-&gt;nmc_ptr - (caddr_t) mbuf_data(mb)));
		len += mbuf_len(mb);
	}

	<span class="enscript-keyword">return</span> (len);
}

<span class="enscript-comment">/*
 * nfsm_chain_advance()
 *
 * Advance an nfsm_chain by &quot;len&quot; bytes.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_advance</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, uint32_t len)
{
	mbuf_t mb;

	<span class="enscript-keyword">while</span> (len) {
		<span class="enscript-keyword">if</span> (nmc-&gt;nmc_left &gt;= len) {
			nmc-&gt;nmc_left -= len;
			nmc-&gt;nmc_ptr += len;
			<span class="enscript-keyword">return</span> (0);
		}
		len -= nmc-&gt;nmc_left;
		nmc-&gt;nmc_mcur = mb = mbuf_next(nmc-&gt;nmc_mcur);
		<span class="enscript-keyword">if</span> (!mb)
			<span class="enscript-keyword">return</span> (EBADRPC);
		nmc-&gt;nmc_ptr = mbuf_data(mb);
		nmc-&gt;nmc_left = mbuf_len(mb);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * nfsm_chain_reverse()
 *
 * Reverse decode offset in an nfsm_chain by &quot;len&quot; bytes.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_reverse</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, uint32_t len)
{
	uint32_t mlen, new_offset;
	<span class="enscript-type">int</span> error = 0;

	mlen = nmc-&gt;nmc_ptr - (caddr_t) mbuf_data(nmc-&gt;nmc_mcur);
	<span class="enscript-keyword">if</span> (len &lt;= mlen) {
		nmc-&gt;nmc_ptr -= len;
		nmc-&gt;nmc_left += len;
		<span class="enscript-keyword">return</span> (0);
	}

	new_offset = nfsm_chain_offset(nmc) - len;
	nfsm_chain_dissect_init(error, nmc, nmc-&gt;nmc_mhead);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">return</span> (nfsm_chain_advance(nmc, new_offset));
}

<span class="enscript-comment">/*
 * nfsm_chain_get_opaque_pointer_f()
 *
 * Return a pointer to the next &quot;len&quot; bytes of contiguous data in
 * the mbuf chain.  If the next &quot;len&quot; bytes are not contiguous, we
 * try to manipulate the mbuf chain so that it is.
 *
 * The nfsm_chain is advanced by nfsm_rndup(&quot;len&quot;) bytes.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_get_opaque_pointer_f</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, uint32_t len, u_char **pptr)
{
	mbuf_t mbcur, mb;
	uint32_t left, need, mblen, cplen, padlen;
	u_char *ptr;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/* move to next mbuf with data */</span>
	<span class="enscript-keyword">while</span> (nmc-&gt;nmc_mcur &amp;&amp; (nmc-&gt;nmc_left == 0)) {
		mb = mbuf_next(nmc-&gt;nmc_mcur);
		nmc-&gt;nmc_mcur = mb;
		<span class="enscript-keyword">if</span> (!mb)
			<span class="enscript-keyword">break</span>;
		nmc-&gt;nmc_ptr = mbuf_data(mb);
		nmc-&gt;nmc_left = mbuf_len(mb);
	}
	<span class="enscript-comment">/* check if we've run out of data */</span>
	<span class="enscript-keyword">if</span> (!nmc-&gt;nmc_mcur)
		<span class="enscript-keyword">return</span> (EBADRPC);

	<span class="enscript-comment">/* do we already have a contiguous buffer? */</span>
	<span class="enscript-keyword">if</span> (nmc-&gt;nmc_left &gt;= len) {
		<span class="enscript-comment">/* the returned pointer will be the current pointer */</span>
		*pptr = (u_char*)nmc-&gt;nmc_ptr;
		error = nfsm_chain_advance(nmc, nfsm_rndup(len));
		<span class="enscript-keyword">return</span> (error);
	}

	padlen = nfsm_rndup(len) - len;

	<span class="enscript-comment">/* we need (len - left) more bytes */</span>
	mbcur = nmc-&gt;nmc_mcur;
	left = nmc-&gt;nmc_left;
	need = len - left;

	<span class="enscript-keyword">if</span> (need &gt; mbuf_trailingspace(mbcur)) {
		<span class="enscript-comment">/*
		 * The needed bytes won't fit in the current mbuf so we'll
		 * allocate a new mbuf to hold the contiguous range of data.
		 */</span>
		nfsm_mbuf_get(error, &amp;mb, len);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-comment">/* double check that this mbuf can hold all the data */</span>
		<span class="enscript-keyword">if</span> (mbuf_maxlen(mb) &lt; len) {
			mbuf_free(mb);
			<span class="enscript-keyword">return</span> (EOVERFLOW);
		}

		<span class="enscript-comment">/* the returned pointer will be the new mbuf's data pointer */</span>
		*pptr = ptr = mbuf_data(mb);

		<span class="enscript-comment">/* copy &quot;left&quot; bytes to the new mbuf */</span>
		bcopy(nmc-&gt;nmc_ptr, ptr, left);
		ptr += left;
		mbuf_setlen(mb, left);

		<span class="enscript-comment">/* insert the new mbuf between the current and next mbufs */</span>
		error = mbuf_setnext(mb, mbuf_next(mbcur));
		<span class="enscript-keyword">if</span> (!error)
			error = mbuf_setnext(mbcur, mb);
		<span class="enscript-keyword">if</span> (error) {
			mbuf_free(mb);
			<span class="enscript-keyword">return</span> (error);
		}

		<span class="enscript-comment">/* reduce current mbuf's length by &quot;left&quot; */</span>
		mbuf_setlen(mbcur, mbuf_len(mbcur) - left);

		<span class="enscript-comment">/*
		 * update nmc's state to point at the end of the mbuf
		 * where the needed data will be copied to.
		 */</span>
		nmc-&gt;nmc_mcur = mbcur = mb;
		nmc-&gt;nmc_left = 0;
		nmc-&gt;nmc_ptr = (caddr_t)ptr;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* The rest of the data will fit in this mbuf. */</span>

		<span class="enscript-comment">/* the returned pointer will be the current pointer */</span>
		*pptr = (u_char*)nmc-&gt;nmc_ptr;

		<span class="enscript-comment">/*
		 * update nmc's state to point at the end of the mbuf
		 * where the needed data will be copied to.
		 */</span>
		nmc-&gt;nmc_ptr += left;
		nmc-&gt;nmc_left = 0;
	}

	<span class="enscript-comment">/*
	 * move the next &quot;need&quot; bytes into the current
	 * mbuf from the mbufs that follow
	 */</span>

	<span class="enscript-comment">/* extend current mbuf length */</span>
	mbuf_setlen(mbcur, mbuf_len(mbcur) + need);

	<span class="enscript-comment">/* mb follows mbufs we're copying/compacting data from */</span>
	mb = mbuf_next(mbcur);

	<span class="enscript-keyword">while</span> (need &amp;&amp; mb) {
		<span class="enscript-comment">/* copy as much as we need/can */</span>
		ptr = mbuf_data(mb);
		mblen = mbuf_len(mb);
		cplen = MIN(mblen, need);
		<span class="enscript-keyword">if</span> (cplen) {
			bcopy(ptr, nmc-&gt;nmc_ptr, cplen);
			<span class="enscript-comment">/*
			 * update the mbuf's pointer and length to reflect that
			 * the data was shifted to an earlier mbuf in the chain
			 */</span>
			error = mbuf_setdata(mb, ptr + cplen, mblen - cplen);
			<span class="enscript-keyword">if</span> (error) {
				mbuf_setlen(mbcur, mbuf_len(mbcur) - need);
				<span class="enscript-keyword">return</span> (error);
			}
			<span class="enscript-comment">/* update pointer/need */</span>
			nmc-&gt;nmc_ptr += cplen;
			need -= cplen;
		}
		<span class="enscript-comment">/* if more needed, go to next mbuf */</span>
		<span class="enscript-keyword">if</span> (need)
			mb = mbuf_next(mb);
	}

	<span class="enscript-comment">/* did we run out of data in the mbuf chain? */</span>
	<span class="enscript-keyword">if</span> (need) {
		mbuf_setlen(mbcur, mbuf_len(mbcur) - need);
		<span class="enscript-keyword">return</span> (EBADRPC);
	}

	<span class="enscript-comment">/*
	 * update nmc's state to point after this contiguous data
	 *
	 * &quot;mb&quot; points to the last mbuf we copied data from so we
	 * just set nmc to point at whatever remains in that mbuf.
	 */</span>
	nmc-&gt;nmc_mcur = mb;
	nmc-&gt;nmc_ptr = mbuf_data(mb);
	nmc-&gt;nmc_left = mbuf_len(mb);

	<span class="enscript-comment">/* move past any padding */</span>
	<span class="enscript-keyword">if</span> (padlen)
		error = nfsm_chain_advance(nmc, padlen);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfsm_chain_get_opaque_f()
 *
 * Read the next &quot;len&quot; bytes in the chain into &quot;buf&quot;.
 * The nfsm_chain is advanced by nfsm_rndup(&quot;len&quot;) bytes.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_get_opaque_f</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, uint32_t len, u_char *buf)
{
	uint32_t cplen, padlen;
	<span class="enscript-type">int</span> error = 0;

	padlen = nfsm_rndup(len) - len;

	<span class="enscript-comment">/* loop through mbufs copying all the data we need */</span>
	<span class="enscript-keyword">while</span> (len &amp;&amp; nmc-&gt;nmc_mcur) {
		<span class="enscript-comment">/* copy as much as we need/can */</span>
		cplen = MIN(nmc-&gt;nmc_left, len);
		<span class="enscript-keyword">if</span> (cplen) {
			bcopy(nmc-&gt;nmc_ptr, buf, cplen);
			nmc-&gt;nmc_ptr += cplen;
			nmc-&gt;nmc_left -= cplen;
			buf += cplen;
			len -= cplen;
		}
		<span class="enscript-comment">/* if more needed, go to next mbuf */</span>
		<span class="enscript-keyword">if</span> (len) {
			mbuf_t mb = mbuf_next(nmc-&gt;nmc_mcur);
			nmc-&gt;nmc_mcur = mb;
			nmc-&gt;nmc_ptr = mb ? mbuf_data(mb) : NULL;
			nmc-&gt;nmc_left = mb ? mbuf_len(mb) : 0;
		}
	}

	<span class="enscript-comment">/* did we run out of data in the mbuf chain? */</span>
	<span class="enscript-keyword">if</span> (len)
		<span class="enscript-keyword">return</span> (EBADRPC);

	<span class="enscript-keyword">if</span> (padlen)
		nfsm_chain_adv(error, nmc, padlen);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfsm_chain_get_uio()
 *
 * Read the next &quot;len&quot; bytes in the chain into the given uio.
 * The nfsm_chain is advanced by nfsm_rndup(&quot;len&quot;) bytes.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_get_uio</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, uint32_t len, uio_t uio)
{
	uint32_t cplen, padlen;
	<span class="enscript-type">int</span> error = 0;

	padlen = nfsm_rndup(len) - len;

	<span class="enscript-comment">/* loop through mbufs copying all the data we need */</span>
	<span class="enscript-keyword">while</span> (len &amp;&amp; nmc-&gt;nmc_mcur) {
		<span class="enscript-comment">/* copy as much as we need/can */</span>
		cplen = MIN(nmc-&gt;nmc_left, len);
		<span class="enscript-keyword">if</span> (cplen) {
			error = uiomove(nmc-&gt;nmc_ptr, cplen, uio);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
			nmc-&gt;nmc_ptr += cplen;
			nmc-&gt;nmc_left -= cplen;
			len -= cplen;
		}
		<span class="enscript-comment">/* if more needed, go to next mbuf */</span>
		<span class="enscript-keyword">if</span> (len) {
			mbuf_t mb = mbuf_next(nmc-&gt;nmc_mcur);
			nmc-&gt;nmc_mcur = mb;
			nmc-&gt;nmc_ptr = mb ? mbuf_data(mb) : NULL;
			nmc-&gt;nmc_left = mb ? mbuf_len(mb) : 0;
		}
	}

	<span class="enscript-comment">/* did we run out of data in the mbuf chain? */</span>
	<span class="enscript-keyword">if</span> (len)
		<span class="enscript-keyword">return</span> (EBADRPC);

	<span class="enscript-keyword">if</span> (padlen)
		nfsm_chain_adv(error, nmc, padlen);

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_add_string_nfc</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, <span class="enscript-type">const</span> uint8_t *s, uint32_t slen)
{
	uint8_t smallbuf[64];
	uint8_t *nfcname = smallbuf;
	size_t buflen = <span class="enscript-keyword">sizeof</span>(smallbuf), nfclen;
	<span class="enscript-type">int</span> error;

	error = utf8_normalizestr(s, slen, nfcname, &amp;nfclen, buflen, UTF_PRECOMPOSED|UTF_NO_NULL_TERM);
	<span class="enscript-keyword">if</span> (error == ENAMETOOLONG) {
		buflen = MAXPATHLEN;
		MALLOC_ZONE(nfcname, uint8_t *, MAXPATHLEN, M_NAMEI, M_WAITOK);
		<span class="enscript-keyword">if</span> (nfcname)
			error = utf8_normalizestr(s, slen, nfcname, &amp;nfclen, buflen, UTF_PRECOMPOSED|UTF_NO_NULL_TERM);
	}

	<span class="enscript-comment">/* if we got an error, just use the original string */</span>
	<span class="enscript-keyword">if</span> (error)
		nfsm_chain_add_string(error, nmc, s, slen);
	<span class="enscript-keyword">else</span>
		nfsm_chain_add_string(error, nmc, nfcname, nfclen);

	<span class="enscript-keyword">if</span> (nfcname &amp;&amp; (nfcname != smallbuf))
		FREE_ZONE(nfcname, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Add an NFSv2 &quot;sattr&quot; structure to an mbuf chain
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_add_v2sattr_f</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, <span class="enscript-type">struct</span> vnode_attr *vap, uint32_t szrdev)
{
	<span class="enscript-type">int</span> error = 0;

	nfsm_chain_add_32(error, nmc, vtonfsv2_mode(vap-&gt;va_type,
		(VATTR_IS_ACTIVE(vap, va_mode) ? vap-&gt;va_mode : 0600)));
	nfsm_chain_add_32(error, nmc,
		VATTR_IS_ACTIVE(vap, va_uid) ? vap-&gt;va_uid : (uint32_t)-1);
	nfsm_chain_add_32(error, nmc,
		VATTR_IS_ACTIVE(vap, va_gid) ? vap-&gt;va_gid : (uint32_t)-1);
	nfsm_chain_add_32(error, nmc, szrdev);
	nfsm_chain_add_v2time(error, nmc,
		VATTR_IS_ACTIVE(vap, va_access_time) ?
		&amp;vap-&gt;va_access_time : NULL);
	nfsm_chain_add_v2time(error, nmc,
		VATTR_IS_ACTIVE(vap, va_modify_time) ?
		&amp;vap-&gt;va_modify_time : NULL);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Add an NFSv3 &quot;sattr&quot; structure to an mbuf chain
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_add_v3sattr_f</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, <span class="enscript-type">struct</span> vnode_attr *vap)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_mode)) {
		nfsm_chain_add_32(error, nmc, TRUE);
		nfsm_chain_add_32(error, nmc, vap-&gt;va_mode);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_32(error, nmc, FALSE);
	}
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_uid)) {
		nfsm_chain_add_32(error, nmc, TRUE);
		nfsm_chain_add_32(error, nmc, vap-&gt;va_uid);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_32(error, nmc, FALSE);
	}
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_gid)) {
		nfsm_chain_add_32(error, nmc, TRUE);
		nfsm_chain_add_32(error, nmc, vap-&gt;va_gid);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_32(error, nmc, FALSE);
	}
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_size)) {
		nfsm_chain_add_32(error, nmc, TRUE);
		nfsm_chain_add_64(error, nmc, vap-&gt;va_data_size);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_32(error, nmc, FALSE);
	}
	<span class="enscript-keyword">if</span> (vap-&gt;va_vaflags &amp; VA_UTIMES_NULL) {
		nfsm_chain_add_32(error, nmc, NFS_TIME_SET_TO_SERVER);
		nfsm_chain_add_32(error, nmc, NFS_TIME_SET_TO_SERVER);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_access_time)) {
			nfsm_chain_add_32(error, nmc, NFS_TIME_SET_TO_CLIENT);
			nfsm_chain_add_32(error, nmc, vap-&gt;va_access_time.tv_sec);
			nfsm_chain_add_32(error, nmc, vap-&gt;va_access_time.tv_nsec);
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, nmc, NFS_TIME_DONT_CHANGE);
		}
		<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_modify_time)) {
			nfsm_chain_add_32(error, nmc, NFS_TIME_SET_TO_CLIENT);
			nfsm_chain_add_32(error, nmc, vap-&gt;va_modify_time.tv_sec);
			nfsm_chain_add_32(error, nmc, vap-&gt;va_modify_time.tv_nsec);
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, nmc, NFS_TIME_DONT_CHANGE);
		}
	}

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * nfsm_chain_get_fh_attr()
 *
 * Get the file handle and attributes from an mbuf chain. (NFSv2/v3)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_get_fh_attr</span>(
	<span class="enscript-type">struct</span> nfsm_chain *nmc,
	nfsnode_t dnp,
	vfs_context_t ctx,
	<span class="enscript-type">int</span> nfsvers,
	uint64_t *xidp,
	fhandle_t *fhp,
	<span class="enscript-type">struct</span> nfs_vattr *nvap)
{
	<span class="enscript-type">int</span> error = 0, gotfh, gotattr;

	gotfh = gotattr = 1;

	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) <span class="enscript-comment">/* check for file handle */</span>
		nfsm_chain_get_32(error, nmc, gotfh);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; gotfh) <span class="enscript-comment">/* get file handle */</span>
		nfsm_chain_get_fh(error, nmc, nfsvers, fhp);
	<span class="enscript-keyword">else</span>
		fhp-&gt;fh_len = 0;
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) <span class="enscript-comment">/* check for file attributes */</span>
		nfsm_chain_get_32(error, nmc, gotattr);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (gotattr) {
		<span class="enscript-keyword">if</span> (!gotfh) <span class="enscript-comment">/* skip attributes */</span>
			nfsm_chain_adv(error, nmc, NFSX_V3FATTR);
		<span class="enscript-keyword">else</span> <span class="enscript-comment">/* get attributes */</span>
			error = nfs_parsefattr(nmc, nfsvers, nvap);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (gotfh) {
		<span class="enscript-comment">/* we need valid attributes in order to call nfs_nget() */</span>
		<span class="enscript-keyword">if</span> (nfs3_getattr_rpc(NULL, NFSTOMP(dnp), fhp-&gt;fh_data, fhp-&gt;fh_len, 0, ctx, nvap, xidp)) {
			gotattr = 0;
			fhp-&gt;fh_len = 0;
		}
	}
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Get and process NFSv3 WCC data from an mbuf chain
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_get_wcc_data_f</span>(
	<span class="enscript-type">struct</span> nfsm_chain *nmc,
	nfsnode_t np,
	<span class="enscript-type">struct</span> timespec *premtime,
	<span class="enscript-type">int</span> *newpostattr,
	u_int64_t *xidp)
{
	<span class="enscript-type">int</span> error = 0;
	uint32_t flag = 0;

	nfsm_chain_get_32(error, nmc, flag);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; flag) {
		nfsm_chain_adv(error, nmc, 2 * NFSX_UNSIGNED);
		nfsm_chain_get_32(error, nmc, premtime-&gt;tv_sec);
		nfsm_chain_get_32(error, nmc, premtime-&gt;tv_nsec);
		nfsm_chain_adv(error, nmc, 2 * NFSX_UNSIGNED);
	} <span class="enscript-keyword">else</span> {
		premtime-&gt;tv_sec = 0;
		premtime-&gt;tv_nsec = 0;
	}
	nfsm_chain_postop_attr_update_flag(error, nmc, np, *newpostattr, xidp);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Get the next RPC transaction ID (XID)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_get_xid</span>(uint64_t *xidp)
{
	<span class="enscript-type">struct</span> timeval tv;

	lck_mtx_lock(nfs_request_mutex);
	<span class="enscript-keyword">if</span> (!nfs_xid) {
		<span class="enscript-comment">/*
		 * Derive initial xid from system time.
		 *
		 * Note: it's OK if this code inits nfs_xid to 0 (for example,
		 * due to a broken clock) because we immediately increment it
		 * and we guarantee to never use xid 0.  So, nfs_xid should only
		 * ever be 0 the first time this function is called.
		 */</span>
		microtime(&amp;tv);
		nfs_xid = tv.tv_sec &lt;&lt; 12;
	}
	<span class="enscript-keyword">if</span> (++nfs_xid == 0) {
		<span class="enscript-comment">/* Skip zero xid if it should ever happen. */</span>
		nfs_xidwrap++;
		nfs_xid++;
	}
	*xidp = nfs_xid + ((uint64_t)nfs_xidwrap &lt;&lt; 32);
	lck_mtx_unlock(nfs_request_mutex);
}

<span class="enscript-comment">/*
 * Build the RPC header and fill in the authorization info.
 * Returns the head of the mbuf list and the xid.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_rpchead</span>(
	<span class="enscript-type">struct</span> nfsreq *req,
	mbuf_t mrest,
	u_int64_t *xidp,
	mbuf_t *mreqp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = req-&gt;r_nmp;
	<span class="enscript-type">int</span> nfsvers = nmp-&gt;nm_vers;
	<span class="enscript-type">int</span> proc = ((nfsvers == NFS_VER2) ? nfsv2_procid[req-&gt;r_procnum] : (<span class="enscript-type">int</span>)req-&gt;r_procnum);

	<span class="enscript-keyword">return</span> nfsm_rpchead2(nmp, nmp-&gt;nm_sotype, NFS_PROG, nfsvers, proc,
			req-&gt;r_auth, req-&gt;r_cred, req, mrest, xidp, mreqp);
}

<span class="enscript-comment">/*
 * get_auiliary_groups:	Gets the supplementary groups from a credential.
 *
 * IN:		cred:	credential to get the associated groups from.
 * OUT:		groups:	An array of gids of NGROUPS size.
 * IN:		count:	The number of groups to get; i.e.; the number of groups the server supports
 *
 * returns:	The number of groups found. 
 *
 * Just a wrapper around kauth_cred_getgroups to handle the case of a server supporting less
 * than NGROUPS. 
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">get_auxiliary_groups</span>(kauth_cred_t cred, gid_t groups[NGROUPS], <span class="enscript-type">int</span> count)
{
	gid_t pgid;
	<span class="enscript-type">int</span> maxcount = count &lt; NGROUPS ? count + 1 : NGROUPS;
	<span class="enscript-type">int</span> i;
	
	<span class="enscript-keyword">for</span> (i = 0; i &lt; NGROUPS; i++)
		groups[i] = -2; <span class="enscript-comment">/* Initialize to the nobody group */</span>

	(<span class="enscript-type">void</span>)kauth_cred_getgroups(cred, groups, &amp;maxcount);
	<span class="enscript-keyword">if</span> (maxcount &lt; 1)
		<span class="enscript-keyword">return</span> (maxcount);
	
	<span class="enscript-comment">/*
	 * kauth_get_groups returns the primary group followed by the
	 * users auxiliary groups. If the number of groups the server supports
	 * is less than NGROUPS, then we will drop the first group so that
	 * we can send one more group over the wire.
	 */</span>


	<span class="enscript-keyword">if</span> (count &lt; NGROUPS) {
		pgid = kauth_cred_getgid(cred);
		<span class="enscript-keyword">if</span> (pgid == groups[0]) {
			maxcount -= 1;
			<span class="enscript-keyword">for</span> (i = 0;  i &lt; maxcount; i++) {
				groups[i] = groups[i+1];
			}
		}
	}
	
	<span class="enscript-keyword">return</span> (maxcount);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_rpchead2</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">int</span> sotype, <span class="enscript-type">int</span> prog, <span class="enscript-type">int</span> vers, <span class="enscript-type">int</span> proc, <span class="enscript-type">int</span> auth_type,
	kauth_cred_t cred, <span class="enscript-type">struct</span> nfsreq *req, mbuf_t mrest, u_int64_t *xidp, mbuf_t *mreqp)
{
	mbuf_t mreq, mb;
	<span class="enscript-type">int</span> error, i, auth_len = 0, authsiz, reqlen;
	size_t headlen;
	<span class="enscript-type">struct</span> nfsm_chain nmreq;
	gid_t grouplist[NGROUPS];
	<span class="enscript-type">int</span> groupcount;

	<span class="enscript-comment">/* calculate expected auth length */</span>
	<span class="enscript-keyword">switch</span> (auth_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_NONE</span>:
			auth_len = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_SYS</span>:
		    {
			<span class="enscript-type">int</span> count = nmp-&gt;nm_numgrps &lt; NGROUPS ? nmp-&gt;nm_numgrps : NGROUPS;

			<span class="enscript-keyword">if</span> (!cred)
				<span class="enscript-keyword">return</span> (EINVAL);
  			groupcount = get_auxiliary_groups(cred, grouplist, count);
			<span class="enscript-keyword">if</span> (groupcount &lt; 0)
				<span class="enscript-keyword">return</span> (EINVAL);
 			auth_len = ((uint32_t)groupcount + 5) * NFSX_UNSIGNED;
			<span class="enscript-keyword">break</span>;
		    }
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5I</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5P</span>:
			<span class="enscript-keyword">if</span> (!req || !cred)
				<span class="enscript-keyword">return</span> (EINVAL);
			auth_len = 5 * NFSX_UNSIGNED + 0; <span class="enscript-comment">// zero context handle for now
</span>			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (EINVAL);
		}
	authsiz = nfsm_rndup(auth_len);

	<span class="enscript-comment">/* allocate the packet */</span>
	headlen = authsiz + 10 * NFSX_UNSIGNED;
	<span class="enscript-keyword">if</span> (sotype == SOCK_STREAM) <span class="enscript-comment">/* also include room for any RPC Record Mark */</span>
		headlen += NFSX_UNSIGNED;
	<span class="enscript-keyword">if</span> (headlen &gt;= nfs_mbuf_minclsize) {
		error = mbuf_getpacket(MBUF_WAITOK, &amp;mreq);
	} <span class="enscript-keyword">else</span> {
		error = mbuf_gethdr(MBUF_WAITOK, MBUF_TYPE_DATA, &amp;mreq);
		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-keyword">if</span> (headlen &lt; nfs_mbuf_mhlen)
				mbuf_align_32(mreq, headlen);
			<span class="enscript-keyword">else</span>
				mbuf_align_32(mreq, 8 * NFSX_UNSIGNED);
		}
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/* unable to allocate packet */</span>
		<span class="enscript-comment">/* XXX should we keep statistics for these errors? */</span>
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/*
	 * If the caller gave us a non-zero XID then use it because
	 * it may be a higher-level resend with a GSSAPI credential.
	 * Otherwise, allocate a new one.
	 */</span>
	<span class="enscript-keyword">if</span> (*xidp == 0)
		nfs_get_xid(xidp);

	<span class="enscript-comment">/* build the header(s) */</span>
	nfsm_chain_init(&amp;nmreq, mreq);

	<span class="enscript-comment">/* First, if it's a TCP stream insert space for an RPC record mark */</span>
	<span class="enscript-keyword">if</span> (sotype == SOCK_STREAM)
		nfsm_chain_add_32(error, &amp;nmreq, 0);

	<span class="enscript-comment">/* Then the RPC header. */</span>
	nfsm_chain_add_32(error, &amp;nmreq, (*xidp &amp; 0xffffffff));
	nfsm_chain_add_32(error, &amp;nmreq, RPC_CALL);
	nfsm_chain_add_32(error, &amp;nmreq, RPC_VER2);
	nfsm_chain_add_32(error, &amp;nmreq, prog);
	nfsm_chain_add_32(error, &amp;nmreq, vers);
	nfsm_chain_add_32(error, &amp;nmreq, proc);

<span class="enscript-reference">add_cred</span>:
	<span class="enscript-keyword">switch</span> (auth_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_NONE</span>:
		nfsm_chain_add_32(error, &amp;nmreq, RPCAUTH_NONE); <span class="enscript-comment">/* auth */</span>
		nfsm_chain_add_32(error, &amp;nmreq, 0);		<span class="enscript-comment">/* length */</span>
		nfsm_chain_add_32(error, &amp;nmreq, RPCAUTH_NONE);	<span class="enscript-comment">/* verf */</span>
		nfsm_chain_add_32(error, &amp;nmreq, 0);		<span class="enscript-comment">/* length */</span>
		nfsm_chain_build_done(error, &amp;nmreq);
		<span class="enscript-comment">/* Append the args mbufs */</span>
		<span class="enscript-keyword">if</span> (!error)
			error = mbuf_setnext(nmreq.nmc_mcur, mrest);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_SYS</span>: {
		nfsm_chain_add_32(error, &amp;nmreq, RPCAUTH_SYS);
		nfsm_chain_add_32(error, &amp;nmreq, authsiz);
		nfsm_chain_add_32(error, &amp;nmreq, 0);	<span class="enscript-comment">/* stamp */</span>
		nfsm_chain_add_32(error, &amp;nmreq, 0);	<span class="enscript-comment">/* zero-length hostname */</span>
		nfsm_chain_add_32(error, &amp;nmreq, kauth_cred_getuid(cred));	<span class="enscript-comment">/* UID */</span>
		nfsm_chain_add_32(error, &amp;nmreq, kauth_cred_getgid(cred));	<span class="enscript-comment">/* GID */</span>
		nfsm_chain_add_32(error, &amp;nmreq, groupcount);<span class="enscript-comment">/* additional GIDs */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; groupcount; i++)
			nfsm_chain_add_32(error, &amp;nmreq, grouplist[i]);

		<span class="enscript-comment">/* And the verifier... */</span>
		nfsm_chain_add_32(error, &amp;nmreq, RPCAUTH_NONE);	<span class="enscript-comment">/* flavor */</span>
		nfsm_chain_add_32(error, &amp;nmreq, 0);		<span class="enscript-comment">/* length */</span>
		nfsm_chain_build_done(error, &amp;nmreq);

		<span class="enscript-comment">/* Append the args mbufs */</span>
		<span class="enscript-keyword">if</span> (!error)
			error = mbuf_setnext(nmreq.nmc_mcur, mrest);
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5I</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5P</span>:
		error = nfs_gss_clnt_cred_put(req, &amp;nmreq, mrest);
		<span class="enscript-keyword">if</span> (error == ENEEDAUTH) {
			<span class="enscript-type">int</span> count = nmp-&gt;nm_numgrps &lt; NGROUPS ? nmp-&gt;nm_numgrps : NGROUPS;

			<span class="enscript-comment">/*
			 * Use sec=sys for this user
			 */</span>
			error = 0;
			req-&gt;r_auth = auth_type = RPCAUTH_SYS;
 			groupcount = get_auxiliary_groups(cred, grouplist, count);
			<span class="enscript-keyword">if</span> (groupcount &lt; 0)
				<span class="enscript-keyword">return</span> (EINVAL);
 			auth_len = ((uint32_t)groupcount + 5) * NFSX_UNSIGNED;
			authsiz = nfsm_rndup(auth_len);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">add_cred</span>;
		}
		<span class="enscript-keyword">break</span>;
	};

	<span class="enscript-comment">/* finish setting up the packet */</span>
	<span class="enscript-keyword">if</span> (!error)
		error = mbuf_pkthdr_setrcvif(mreq, 0);

	<span class="enscript-keyword">if</span> (error) {
		mbuf_freem(mreq);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* Calculate the size of the request */</span>
	reqlen = 0;
	<span class="enscript-keyword">for</span> (mb = nmreq.nmc_mhead; mb; mb = mbuf_next(mb))
		reqlen += mbuf_len(mb);

	mbuf_pkthdr_setlen(mreq, reqlen);

	<span class="enscript-comment">/*
	 * If the request goes on a TCP stream,
	 * set its size in the RPC record mark.
	 * The record mark count doesn't include itself
	 * and the last fragment bit is set.
	 */</span>
	<span class="enscript-keyword">if</span> (sotype == SOCK_STREAM)
		nfsm_chain_set_recmark(error, &amp;nmreq,
			(reqlen - NFSX_UNSIGNED) | 0x80000000);

	*mreqp = mreq;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Parse an NFS file attribute structure out of an mbuf chain.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_parsefattr</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, <span class="enscript-type">int</span> nfsvers, <span class="enscript-type">struct</span> nfs_vattr *nvap)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">enum</span> vtype vtype;
	nfstype nvtype;
	u_short vmode;
	uint32_t val, val2;
	dev_t rdev;

	val = val2 = 0;
	NVATTR_INIT(nvap);

	NFS_BITMAP_SET(nvap-&gt;nva_bitmap, NFS_FATTR_TYPE);
	NFS_BITMAP_SET(nvap-&gt;nva_bitmap, NFS_FATTR_MODE);
	NFS_BITMAP_SET(nvap-&gt;nva_bitmap, NFS_FATTR_NUMLINKS);
	NFS_BITMAP_SET(nvap-&gt;nva_bitmap, NFS_FATTR_OWNER);
	NFS_BITMAP_SET(nvap-&gt;nva_bitmap, NFS_FATTR_OWNER_GROUP);
	NFS_BITMAP_SET(nvap-&gt;nva_bitmap, NFS_FATTR_SIZE);
	NFS_BITMAP_SET(nvap-&gt;nva_bitmap, NFS_FATTR_SPACE_USED);
	NFS_BITMAP_SET(nvap-&gt;nva_bitmap, NFS_FATTR_RAWDEV);
	NFS_BITMAP_SET(nvap-&gt;nva_bitmap, NFS_FATTR_FSID);
	NFS_BITMAP_SET(nvap-&gt;nva_bitmap, NFS_FATTR_FILEID);
	NFS_BITMAP_SET(nvap-&gt;nva_bitmap, NFS_FATTR_TIME_ACCESS);
	NFS_BITMAP_SET(nvap-&gt;nva_bitmap, NFS_FATTR_TIME_MODIFY);
	NFS_BITMAP_SET(nvap-&gt;nva_bitmap, NFS_FATTR_TIME_METADATA);

	nfsm_chain_get_32(error, nmc, nvtype);
	nfsm_chain_get_32(error, nmc, vmode);
	nfsmout_if(error);

	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
		nvap-&gt;nva_type = vtype = nfstov_type(nvtype, nfsvers);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * The duplicate information returned in fa_type and fa_mode
		 * is an ambiguity in the NFS version 2 protocol.
		 *
		 * VREG should be taken literally as a regular file.  If a
		 * server intends to return some type information differently
		 * in the upper bits of the mode field (e.g. for sockets, or
		 * FIFOs), NFSv2 mandates fa_type to be VNON.  Anyway, we
		 * leave the examination of the mode bits even in the VREG
		 * case to avoid breakage for bogus servers, but we make sure
		 * that there are actually type bits set in the upper part of
		 * fa_mode (and failing that, trust the va_type field).
		 *
		 * NFSv3 cleared the issue, and requires fa_mode to not
		 * contain any type information (while also introducing
		 * sockets and FIFOs for fa_type).
		 */</span>
		vtype = nfstov_type(nvtype, nfsvers);
		<span class="enscript-keyword">if</span> ((vtype == VNON) || ((vtype == VREG) &amp;&amp; ((vmode &amp; S_IFMT) != 0)))
			vtype = IFTOVT(vmode);
		nvap-&gt;nva_type = vtype;
	}

	nvap-&gt;nva_mode = (vmode &amp; 07777);

	nfsm_chain_get_32(error, nmc, nvap-&gt;nva_nlink);
	nfsm_chain_get_32(error, nmc, nvap-&gt;nva_uid);
	nfsm_chain_get_32(error, nmc, nvap-&gt;nva_gid);

	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
		nfsm_chain_get_64(error, nmc, nvap-&gt;nva_size);
		nfsm_chain_get_64(error, nmc, nvap-&gt;nva_bytes);
		nfsm_chain_get_32(error, nmc, nvap-&gt;nva_rawdev.specdata1);
		nfsm_chain_get_32(error, nmc, nvap-&gt;nva_rawdev.specdata2);
		nfsmout_if(error);
		nfsm_chain_get_64(error, nmc, nvap-&gt;nva_fsid.major);
		nvap-&gt;nva_fsid.minor = 0;
		nfsm_chain_get_64(error, nmc, nvap-&gt;nva_fileid);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_get_32(error, nmc, nvap-&gt;nva_size);
		nfsm_chain_adv(error, nmc, NFSX_UNSIGNED);
		nfsm_chain_get_32(error, nmc, rdev);
		nfsmout_if(error);
		nvap-&gt;nva_rawdev.specdata1 = major(rdev);
		nvap-&gt;nva_rawdev.specdata2 = minor(rdev);
		nfsm_chain_get_32(error, nmc, val); <span class="enscript-comment">/* blocks */</span>
		nfsmout_if(error);
		nvap-&gt;nva_bytes = val * NFS_FABLKSIZE;
		nfsm_chain_get_32(error, nmc, val);
		nfsmout_if(error);
		nvap-&gt;nva_fsid.major = (uint64_t)val;
		nvap-&gt;nva_fsid.minor = 0;
		nfsm_chain_get_32(error, nmc, val);
		nfsmout_if(error);
		nvap-&gt;nva_fileid = (uint64_t)val;
		<span class="enscript-comment">/* Really ugly NFSv2 kludge. */</span>
		<span class="enscript-keyword">if</span> ((vtype == VCHR) &amp;&amp; (rdev == (dev_t)0xffffffff))
			nvap-&gt;nva_type = VFIFO;
	}
	nfsm_chain_get_time(error, nmc, nfsvers,
		nvap-&gt;nva_timesec[NFSTIME_ACCESS],
		nvap-&gt;nva_timensec[NFSTIME_ACCESS]);
	nfsm_chain_get_time(error, nmc, nfsvers,
		nvap-&gt;nva_timesec[NFSTIME_MODIFY],
		nvap-&gt;nva_timensec[NFSTIME_MODIFY]);
	nfsm_chain_get_time(error, nmc, nfsvers,
		nvap-&gt;nva_timesec[NFSTIME_CHANGE],
		nvap-&gt;nva_timensec[NFSTIME_CHANGE]);
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Load the attribute cache (that lives in the nfsnode entry) with
 * the value pointed to by nvap, unless the file type in the attribute
 * cache doesn't match the file type in the nvap, in which case log a
 * warning and return ESTALE.
 *
 * If the dontshrink flag is set, then it's not safe to call ubc_setsize()
 * to shrink the size of the file.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_loadattrcache</span>(
	nfsnode_t np,
	<span class="enscript-type">struct</span> nfs_vattr *nvap,
	u_int64_t *xidp,
	<span class="enscript-type">int</span> dontshrink)
{
	mount_t mp;
	vnode_t vp;
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">struct</span> nfs_vattr *npnvap;
	<span class="enscript-type">int</span> xattr = np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_IS_ATTR;
	<span class="enscript-type">int</span> referral = np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL;
	<span class="enscript-type">int</span> aclbit, monitored, error = 0;
	kauth_acl_t acl;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	uint32_t events = np-&gt;n_events;

	<span class="enscript-keyword">if</span> (np-&gt;n_hflag &amp; NHINIT) {
		vp = NULL;
		mp = np-&gt;n_mount;
	} <span class="enscript-keyword">else</span> {
		vp = NFSTOV(np);
		mp = vnode_mount(vp);
	}
	monitored = vp ? vnode_ismonitored(vp) : 0;

	FSDBG_TOP(527, np, vp, *xidp &gt;&gt; 32, *xidp);

	<span class="enscript-keyword">if</span> (!((nmp = VFSTONFS(mp)))) {
		FSDBG_BOT(527, ENXIO, 1, 0, *xidp);
		<span class="enscript-keyword">return</span> (ENXIO);
	}

	<span class="enscript-keyword">if</span> (*xidp &lt; np-&gt;n_xid) {
		<span class="enscript-comment">/*
		 * We have already updated attributes with a response from
		 * a later request.  The attributes we have here are probably
		 * stale so we drop them (just return).  However, our
		 * out-of-order receipt could be correct - if the requests were
		 * processed out of order at the server.  Given the uncertainty
		 * we invalidate our cached attributes.  *xidp is zeroed here
		 * to indicate the attributes were dropped - only getattr
		 * cares - it needs to retry the rpc.
		 */</span>
		NATTRINVALIDATE(np);
		FSDBG_BOT(527, 0, np, np-&gt;n_xid, *xidp);
		*xidp = 0;
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (vp &amp;&amp; (nvap-&gt;nva_type != vnode_vtype(vp))) {
		<span class="enscript-comment">/*
		 * The filehandle has changed type on us.  This can be
		 * caused by either the server not having unique filehandles
		 * or because another client has removed the previous
		 * filehandle and a new object (of a different type)
		 * has been created with the same filehandle.
		 *
		 * We can't simply switch the type on the vnode because
		 * there may be type-specific fields that need to be
		 * cleaned up or set up.
		 *
		 * So, what should we do with this vnode?
		 *
		 * About the best we can do is log a warning and return
		 * an error.  ESTALE is about the closest error, but it
		 * is a little strange that we come up with this error
		 * internally instead of simply passing it through from
		 * the server.  Hopefully, the vnode will be reclaimed
		 * soon so the filehandle can be reincarnated as the new
		 * object type.
		 */</span>
		printf(<span class="enscript-string">&quot;nfs loadattrcache vnode changed type, was %d now %d\n&quot;</span>,
			vnode_vtype(vp), nvap-&gt;nva_type);
		error = ESTALE;
		<span class="enscript-keyword">if</span> (monitored)
			events |= VNODE_EVENT_DELETE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	npnvap = &amp;np-&gt;n_vattr;

	<span class="enscript-comment">/*
	 * The ACL cache needs special handling because it is not
	 * always updated.  Save current ACL cache state so it can
	 * be restored after copying the new attributes into place.
	 */</span>
	aclbit = NFS_BITMAP_ISSET(npnvap-&gt;nva_bitmap, NFS_FATTR_ACL);
	acl = npnvap-&gt;nva_acl;

	<span class="enscript-keyword">if</span> (monitored) {
		<span class="enscript-comment">/*
		 * For monitored nodes, check for attribute changes that should generate events.
		 */</span>
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nvap-&gt;nva_bitmap, NFS_FATTR_NUMLINKS) &amp;&amp;
		    (nvap-&gt;nva_nlink != npnvap-&gt;nva_nlink))
			events |= VNODE_EVENT_ATTRIB | VNODE_EVENT_LINK;
		<span class="enscript-keyword">if</span> (events &amp; VNODE_EVENT_PERMS)
			<span class="enscript-comment">/* no need to do all the checking if it's already set */</span>;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nvap-&gt;nva_bitmap, NFS_FATTR_MODE) &amp;&amp;
			 (nvap-&gt;nva_mode != npnvap-&gt;nva_mode))
			events |= VNODE_EVENT_ATTRIB | VNODE_EVENT_PERMS;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nvap-&gt;nva_bitmap, NFS_FATTR_OWNER) &amp;&amp;
			 (nvap-&gt;nva_uid != npnvap-&gt;nva_uid))
			events |= VNODE_EVENT_ATTRIB | VNODE_EVENT_PERMS;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nvap-&gt;nva_bitmap, NFS_FATTR_OWNER_GROUP) &amp;&amp;
			 (nvap-&gt;nva_gid != npnvap-&gt;nva_gid))
			events |= VNODE_EVENT_ATTRIB | VNODE_EVENT_PERMS;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4) {
			<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nvap-&gt;nva_bitmap, NFS_FATTR_OWNER) &amp;&amp;
			    !kauth_guid_equal(&amp;nvap-&gt;nva_uuuid, &amp;npnvap-&gt;nva_uuuid))
				events |= VNODE_EVENT_ATTRIB | VNODE_EVENT_PERMS;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nvap-&gt;nva_bitmap, NFS_FATTR_OWNER_GROUP) &amp;&amp;
				 !kauth_guid_equal(&amp;nvap-&gt;nva_guuid, &amp;npnvap-&gt;nva_guuid))
				events |= VNODE_EVENT_ATTRIB | VNODE_EVENT_PERMS;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((NFS_BITMAP_ISSET(nvap-&gt;nva_bitmap, NFS_FATTR_ACL) &amp;&amp;
				 nvap-&gt;nva_acl &amp;&amp; npnvap-&gt;nva_acl &amp;&amp;
			         ((nvap-&gt;nva_acl-&gt;acl_entrycount != npnvap-&gt;nva_acl-&gt;acl_entrycount) ||
			          bcmp(nvap-&gt;nva_acl, npnvap-&gt;nva_acl, KAUTH_ACL_COPYSIZE(nvap-&gt;nva_acl)))))
				events |= VNODE_EVENT_ATTRIB | VNODE_EVENT_PERMS;
		}
		<span class="enscript-keyword">if</span> (((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; (nvap-&gt;nva_change != npnvap-&gt;nva_change)) ||
		   (NFS_BITMAP_ISSET(npnvap-&gt;nva_bitmap, NFS_FATTR_TIME_MODIFY) &amp;&amp;
		    ((nvap-&gt;nva_timesec[NFSTIME_MODIFY] != npnvap-&gt;nva_timesec[NFSTIME_MODIFY]) ||
		     (nvap-&gt;nva_timensec[NFSTIME_MODIFY] != npnvap-&gt;nva_timensec[NFSTIME_MODIFY]))))
			events |= VNODE_EVENT_ATTRIB | VNODE_EVENT_WRITE;
		<span class="enscript-keyword">if</span> (!events &amp;&amp; NFS_BITMAP_ISSET(npnvap-&gt;nva_bitmap, NFS_FATTR_RAWDEV) &amp;&amp;
		    ((nvap-&gt;nva_rawdev.specdata1 != npnvap-&gt;nva_rawdev.specdata1) ||
		     (nvap-&gt;nva_rawdev.specdata2 != npnvap-&gt;nva_rawdev.specdata2)))
			events |= VNODE_EVENT_ATTRIB;
		<span class="enscript-keyword">if</span> (!events &amp;&amp; NFS_BITMAP_ISSET(npnvap-&gt;nva_bitmap, NFS_FATTR_FILEID) &amp;&amp;
		    (nvap-&gt;nva_fileid != npnvap-&gt;nva_fileid))
			events |= VNODE_EVENT_ATTRIB;
		<span class="enscript-keyword">if</span> (!events &amp;&amp; NFS_BITMAP_ISSET(npnvap-&gt;nva_bitmap, NFS_FATTR_ARCHIVE) &amp;&amp;
		    ((nvap-&gt;nva_flags &amp; NFS_FFLAG_ARCHIVED) != (npnvap-&gt;nva_flags &amp; NFS_FFLAG_ARCHIVED)))
			events |= VNODE_EVENT_ATTRIB;
		<span class="enscript-keyword">if</span> (!events &amp;&amp; NFS_BITMAP_ISSET(npnvap-&gt;nva_bitmap, NFS_FATTR_HIDDEN) &amp;&amp;
		    ((nvap-&gt;nva_flags &amp; NFS_FFLAG_HIDDEN) != (npnvap-&gt;nva_flags &amp; NFS_FFLAG_HIDDEN)))
			events |= VNODE_EVENT_ATTRIB;
		<span class="enscript-keyword">if</span> (!events &amp;&amp; NFS_BITMAP_ISSET(npnvap-&gt;nva_bitmap, NFS_FATTR_TIME_CREATE) &amp;&amp;
		    ((nvap-&gt;nva_timesec[NFSTIME_CREATE] != npnvap-&gt;nva_timesec[NFSTIME_CREATE]) ||
		     (nvap-&gt;nva_timensec[NFSTIME_CREATE] != npnvap-&gt;nva_timensec[NFSTIME_CREATE])))
			events |= VNODE_EVENT_ATTRIB;
		<span class="enscript-keyword">if</span> (!events &amp;&amp; NFS_BITMAP_ISSET(npnvap-&gt;nva_bitmap, NFS_FATTR_TIME_BACKUP) &amp;&amp;
		    ((nvap-&gt;nva_timesec[NFSTIME_BACKUP] != npnvap-&gt;nva_timesec[NFSTIME_BACKUP]) ||
		     (nvap-&gt;nva_timensec[NFSTIME_BACKUP] != npnvap-&gt;nva_timensec[NFSTIME_BACKUP])))
			events |= VNODE_EVENT_ATTRIB;
	}

	<span class="enscript-comment">/* Copy the attributes to the attribute cache */</span>
	bcopy((caddr_t)nvap, (caddr_t)npnvap, <span class="enscript-keyword">sizeof</span>(*nvap));

	microuptime(&amp;now);
	np-&gt;n_attrstamp = now.tv_sec;
	np-&gt;n_xid = *xidp;
	<span class="enscript-comment">/* NFS_FFLAG_IS_ATTR and NFS_FFLAG_TRIGGER_REFERRAL need to be sticky... */</span>
	<span class="enscript-keyword">if</span> (vp &amp;&amp; xattr)
		nvap-&gt;nva_flags |= xattr;
	<span class="enscript-keyword">if</span> (vp &amp;&amp; referral)
		nvap-&gt;nva_flags |= referral;

	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(npnvap-&gt;nva_bitmap, NFS_FATTR_ACL)) {
		<span class="enscript-comment">/* we're updating the ACL */</span>
		<span class="enscript-keyword">if</span> (nvap-&gt;nva_acl) {
			<span class="enscript-comment">/* make a copy of the acl for the cache */</span>
			npnvap-&gt;nva_acl = kauth_acl_alloc(nvap-&gt;nva_acl-&gt;acl_entrycount);
			<span class="enscript-keyword">if</span> (npnvap-&gt;nva_acl) {
				bcopy(nvap-&gt;nva_acl, npnvap-&gt;nva_acl, KAUTH_ACL_COPYSIZE(nvap-&gt;nva_acl));
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* can't make a copy to cache, invalidate ACL cache */</span>
				NFS_BITMAP_CLR(npnvap-&gt;nva_bitmap, NFS_FATTR_ACL);
				NACLINVALIDATE(np);
				aclbit = 0;
			}
		}
		<span class="enscript-keyword">if</span> (acl) {
			kauth_acl_free(acl);
			acl = NULL;
		}
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(npnvap-&gt;nva_bitmap, NFS_FATTR_ACL)) {
		<span class="enscript-comment">/* update the ACL timestamp */</span>
		np-&gt;n_aclstamp = now.tv_sec;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* we aren't updating the ACL, so restore original values */</span>
		<span class="enscript-keyword">if</span> (aclbit)
			NFS_BITMAP_SET(npnvap-&gt;nva_bitmap, NFS_FATTR_ACL);
		npnvap-&gt;nva_acl = acl;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
	<span class="enscript-comment">/*
	 * For NFSv4, if the fsid doesn't match the fsid for the mount, then
	 * this node is for a different file system on the server.  So we mark
	 * this node as a trigger node that will trigger the mirror mount.
	 */</span>
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; (nvap-&gt;nva_type == VDIR) &amp;&amp;
	    ((np-&gt;n_vattr.nva_fsid.major != nmp-&gt;nm_fsid.major) ||
	     (np-&gt;n_vattr.nva_fsid.minor != nmp-&gt;nm_fsid.minor)))
		np-&gt;n_vattr.nva_flags |= NFS_FFLAG_TRIGGER;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (!vp || (nvap-&gt;nva_type != VREG)) {
		np-&gt;n_size = nvap-&gt;nva_size;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nvap-&gt;nva_size != np-&gt;n_size) {
		FSDBG(527, np, nvap-&gt;nva_size, np-&gt;n_size, (nvap-&gt;nva_type == VREG) | (np-&gt;n_flag &amp; NMODIFIED ? 6 : 4));
		<span class="enscript-keyword">if</span> (!UBCINFOEXISTS(vp) || (dontshrink &amp;&amp; (nvap-&gt;nva_size &lt; np-&gt;n_size))) {
			<span class="enscript-comment">/* asked not to shrink, so stick with current size */</span>
			FSDBG(527, np, np-&gt;n_size, np-&gt;n_vattr.nva_size, 0xf00d0001);
			nvap-&gt;nva_size = np-&gt;n_size;
			NATTRINVALIDATE(np);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((np-&gt;n_flag &amp; NMODIFIED) &amp;&amp; (nvap-&gt;nva_size &lt; np-&gt;n_size)) {
			<span class="enscript-comment">/* if we've modified, stick with larger size */</span>
			FSDBG(527, np, np-&gt;n_size, np-&gt;n_vattr.nva_size, 0xf00d0002);
			nvap-&gt;nva_size = np-&gt;n_size;
			npnvap-&gt;nva_size = np-&gt;n_size;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * n_size is protected by the data lock, so we need to
			 * defer updating it until it's safe.  We save the new size
			 * and set a flag and it'll get updated the next time we get/drop
			 * the data lock or the next time we do a getattr.
			 */</span>
			np-&gt;n_newsize = nvap-&gt;nva_size;
			SET(np-&gt;n_flag, NUPDATESIZE);
			<span class="enscript-keyword">if</span> (monitored)
				events |= VNODE_EVENT_ATTRIB | VNODE_EVENT_EXTEND;
		}
	}

	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NCHG) {
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NACC) {
			nvap-&gt;nva_timesec[NFSTIME_ACCESS] = np-&gt;n_atim.tv_sec;
			nvap-&gt;nva_timensec[NFSTIME_ACCESS] = np-&gt;n_atim.tv_nsec;
		}
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NUPD) {
			nvap-&gt;nva_timesec[NFSTIME_MODIFY] = np-&gt;n_mtim.tv_sec;
			nvap-&gt;nva_timensec[NFSTIME_MODIFY] = np-&gt;n_mtim.tv_nsec;
		}
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (monitored &amp;&amp; events)
		nfs_vnode_notify(np, events);
	FSDBG_BOT(527, error, np, np-&gt;n_size, *xidp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Calculate the attribute timeout based on
 * how recently the file has been modified.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_attrcachetimeout</span>(nfsnode_t np)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">int</span> isdir;
	uint32_t timeo;

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (0);

	isdir = vnode_isdir(NFSTOV(np));

	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; (np-&gt;n_openflags &amp; N_DELEG_MASK)) {
		<span class="enscript-comment">/* If we have a delegation, we always use the max timeout. */</span>
		timeo = isdir ? nmp-&gt;nm_acdirmax : nmp-&gt;nm_acregmax;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((np)-&gt;n_flag &amp; NMODIFIED) {
		<span class="enscript-comment">/* If we have modifications, we always use the min timeout. */</span>
		timeo = isdir ? nmp-&gt;nm_acdirmin : nmp-&gt;nm_acregmin;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Otherwise, we base the timeout on how old the file seems. */</span>
		<span class="enscript-comment">/* Note that if the client and server clocks are way out of sync, */</span>
		<span class="enscript-comment">/* timeout will probably get clamped to a min or max value */</span>
		microtime(&amp;now);
		timeo = (now.tv_sec - (np)-&gt;n_vattr.nva_timesec[NFSTIME_MODIFY]) / 10;
		<span class="enscript-keyword">if</span> (isdir) {
			<span class="enscript-keyword">if</span> (timeo &lt; nmp-&gt;nm_acdirmin)
				timeo = nmp-&gt;nm_acdirmin;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (timeo &gt; nmp-&gt;nm_acdirmax)
				timeo = nmp-&gt;nm_acdirmax;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (timeo &lt; nmp-&gt;nm_acregmin)
				timeo = nmp-&gt;nm_acregmin;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (timeo &gt; nmp-&gt;nm_acregmax)
				timeo = nmp-&gt;nm_acregmax;
		}
	}

	<span class="enscript-keyword">return</span> (timeo);
}

<span class="enscript-comment">/*
 * Check the attribute cache time stamp.
 * If the cache is valid, copy contents to *nvaper and return 0
 * otherwise return an error.
 * Must be called with the node locked.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_getattrcache</span>(nfsnode_t np, <span class="enscript-type">struct</span> nfs_vattr *nvaper, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> nfs_vattr *nvap;
	<span class="enscript-type">struct</span> timeval nowup;
	int32_t timeo;
	<span class="enscript-type">struct</span> nfsmount *nmp;

	<span class="enscript-comment">/* Check if the attributes are valid. */</span>
	<span class="enscript-keyword">if</span> (!NATTRVALID(np) || ((flags &amp; NGA_ACL) &amp;&amp; !NACLVALID(np))) {
		FSDBG(528, np, 0, 0xffffff01, ENOENT);
		OSAddAtomic64(1, &amp;nfsstats.attrcache_misses);
		<span class="enscript-keyword">return</span> (ENOENT);
	}

	nmp = NFSTONMP(np);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-comment">/*
	 * Verify the cached attributes haven't timed out.
	 * If the server isn't responding, skip the check
	 * and return cached attributes.
	 */</span>
	<span class="enscript-keyword">if</span> (!nfs_use_cache(nmp)) {
		timeo = nfs_attrcachetimeout(np);
		microuptime(&amp;nowup);
		<span class="enscript-keyword">if</span> ((nowup.tv_sec - np-&gt;n_attrstamp) &gt;= timeo) {
			FSDBG(528, np, 0, 0xffffff02, ENOENT);
			OSAddAtomic64(1, &amp;nfsstats.attrcache_misses);
			<span class="enscript-keyword">return</span> (ENOENT);
		}
		<span class="enscript-keyword">if</span> ((flags &amp; NGA_ACL) &amp;&amp; ((nowup.tv_sec - np-&gt;n_aclstamp) &gt;= timeo)) {
			FSDBG(528, np, 0, 0xffffff02, ENOENT);
			OSAddAtomic64(1, &amp;nfsstats.attrcache_misses);
			<span class="enscript-keyword">return</span> (ENOENT);
		}
	}

	nvap = &amp;np-&gt;n_vattr;
	FSDBG(528, np, nvap-&gt;nva_size, np-&gt;n_size, 0xcace);
	OSAddAtomic64(1, &amp;nfsstats.attrcache_hits);

	<span class="enscript-keyword">if</span> (nvap-&gt;nva_type != VREG) {
		np-&gt;n_size = nvap-&gt;nva_size;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nvap-&gt;nva_size != np-&gt;n_size) {
		FSDBG(528, np, nvap-&gt;nva_size, np-&gt;n_size, (nvap-&gt;nva_type == VREG) | (np-&gt;n_flag &amp; NMODIFIED ? 6 : 4));
		<span class="enscript-keyword">if</span> ((np-&gt;n_flag &amp; NMODIFIED) &amp;&amp; (nvap-&gt;nva_size &lt; np-&gt;n_size)) {
			<span class="enscript-comment">/* if we've modified, stick with larger size */</span>
			nvap-&gt;nva_size = np-&gt;n_size;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * n_size is protected by the data lock, so we need to
			 * defer updating it until it's safe.  We save the new size
			 * and set a flag and it'll get updated the next time we get/drop
			 * the data lock or the next time we do a getattr.
			 */</span>
			np-&gt;n_newsize = nvap-&gt;nva_size;
			SET(np-&gt;n_flag, NUPDATESIZE);
		}
	}

	bcopy((caddr_t)nvap, (caddr_t)nvaper, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_vattr));
	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NCHG) {
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NACC) {
			nvaper-&gt;nva_timesec[NFSTIME_ACCESS] = np-&gt;n_atim.tv_sec;
			nvaper-&gt;nva_timensec[NFSTIME_ACCESS] = np-&gt;n_atim.tv_nsec;
		}
		<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NUPD) {
			nvaper-&gt;nva_timesec[NFSTIME_MODIFY] = np-&gt;n_mtim.tv_sec;
			nvaper-&gt;nva_timensec[NFSTIME_MODIFY] = np-&gt;n_mtim.tv_nsec;
		}
	}
	<span class="enscript-keyword">if</span> (nvap-&gt;nva_acl) {
		<span class="enscript-keyword">if</span> (flags &amp; NGA_ACL) {
			nvaper-&gt;nva_acl = kauth_acl_alloc(nvap-&gt;nva_acl-&gt;acl_entrycount);
			<span class="enscript-keyword">if</span> (!nvaper-&gt;nva_acl)
				<span class="enscript-keyword">return</span> (ENOMEM);
			bcopy(nvap-&gt;nva_acl, nvaper-&gt;nva_acl, KAUTH_ACL_COPYSIZE(nvap-&gt;nva_acl));
		} <span class="enscript-keyword">else</span> {
			nvaper-&gt;nva_acl = NULL;
		}
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * When creating file system objects:
 * Don't bother setting UID if it's the same as the credential performing the create.
 * Don't bother setting GID if it's the same as the directory or credential.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_avoid_needless_id_setting_on_create</span>(nfsnode_t dnp, <span class="enscript-type">struct</span> vnode_attr *vap, vfs_context_t ctx)
{
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_uid)) {
		<span class="enscript-keyword">if</span> (kauth_cred_getuid(vfs_context_ucred(ctx)) == vap-&gt;va_uid) {
			VATTR_CLEAR_ACTIVE(vap, va_uid);
			VATTR_CLEAR_ACTIVE(vap, va_uuuid);
		}
	}
	<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_gid)) {
		<span class="enscript-keyword">if</span> ((vap-&gt;va_gid == dnp-&gt;n_vattr.nva_gid) ||
		    (kauth_cred_getgid(vfs_context_ucred(ctx)) == vap-&gt;va_gid)) {
			VATTR_CLEAR_ACTIVE(vap, va_gid);
			VATTR_CLEAR_ACTIVE(vap, va_guuid);
		}
	}
}

<span class="enscript-comment">/*
 * Convert a universal address string to a sockaddr structure.
 *
 * Universal addresses can be in the following formats:
 *
 * d = decimal (IPv4)
 * x = hexadecimal (IPv6)
 * p = port (decimal)
 *
 * d.d.d.d
 * d.d.d.d.p.p
 * x:x:x:x:x:x:x:x
 * x:x:x:x:x:x:x:x.p.p
 * x:x:x:x:x:x:d.d.d.d
 * x:x:x:x:x:x:d.d.d.d.p.p
 *
 * IPv6 strings can also have a series of zeroes elided
 * IPv6 strings can also have a %scope suffix at the end (after any port)
 *
 * rules &amp; exceptions:
 * - value before : is hex
 * - value before . is dec
 * - once . hit, all values are dec
 * - hex+port case means value before first dot is actually hex
 * - . is always preceded by digits except if last hex was double-colon
 *
 * scan, converting #s to bytes
 * first time a . is encountered, scan the rest to count them.
 * 2 dots = just port
 * 3 dots = just IPv4 no port
 * 5 dots = IPv4 and port
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_DIGIT</span>(C) \
	(((C) &gt;= <span class="enscript-string">'0'</span>) &amp;&amp; ((C) &lt;= <span class="enscript-string">'9'</span>))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_XDIGIT</span>(C) \
	(IS_DIGIT(C) || \
	 (((C) &gt;= <span class="enscript-string">'A'</span>) &amp;&amp; ((C) &lt;= <span class="enscript-string">'F'</span>)) || \
	 (((C) &gt;= <span class="enscript-string">'a'</span>) &amp;&amp; ((C) &lt;= <span class="enscript-string">'f'</span>)))

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_uaddr2sockaddr</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *uaddr, <span class="enscript-type">struct</span> sockaddr *addr)
{
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *p, *pd;	<span class="enscript-comment">/* pointers to current character in scan */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *pnum;	<span class="enscript-comment">/* pointer to current number to decode */</span>
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *pscope;	<span class="enscript-comment">/* pointer to IPv6 scope ID */</span>
	uint8_t a[18];		<span class="enscript-comment">/* octet array to store address bytes */</span>
	<span class="enscript-type">int</span> i;			<span class="enscript-comment">/* index of next octet to decode */</span>
	<span class="enscript-type">int</span> dci;		<span class="enscript-comment">/* index of octet to insert double-colon zeroes */</span>
	<span class="enscript-type">int</span> dcount, xdcount;	<span class="enscript-comment">/* count of digits in current number */</span>
	<span class="enscript-type">int</span> needmore;		<span class="enscript-comment">/* set when we know we need more input (e.g. after colon, period) */</span>
	<span class="enscript-type">int</span> dots;		<span class="enscript-comment">/* # of dots */</span>
	<span class="enscript-type">int</span> hex;		<span class="enscript-comment">/* contains hex values */</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> val;	<span class="enscript-comment">/* decoded value */</span>
	<span class="enscript-type">int</span> s;			<span class="enscript-comment">/* index used for sliding array to insert elided zeroes */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HEXVALUE</span>	0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DECIMALVALUE</span>	1
#<span class="enscript-reference">define</span> <span class="enscript-function-name">GET</span>(TYPE) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> ((dcount &lt;= 0) || (dcount &gt; (((TYPE) == DECIMALVALUE) ? 3 : 4))) \
			<span class="enscript-keyword">return</span> (0); \
		<span class="enscript-keyword">if</span> (((TYPE) == DECIMALVALUE) &amp;&amp; xdcount) \
			<span class="enscript-keyword">return</span> (0); \
		val = strtoul(pnum, NULL, ((TYPE) == DECIMALVALUE) ? 10 : 16); \
		<span class="enscript-keyword">if</span> (((TYPE) == DECIMALVALUE) &amp;&amp; (val &gt;= 256)) \
			<span class="enscript-keyword">return</span> (0); \
		<span class="enscript-comment">/* check if there is room left in the array */</span> \
		<span class="enscript-keyword">if</span> (i &gt; (<span class="enscript-type">int</span>)(<span class="enscript-keyword">sizeof</span>(a) - (((TYPE) == HEXVALUE) ? 2 : 1) - ((dci != -1) ? 2 : 0))) \
			<span class="enscript-keyword">return</span> (0); \
		<span class="enscript-keyword">if</span> ((TYPE) == HEXVALUE) \
			a[i++] = ((val &gt;&gt; 8) &amp; 0xff); \
		a[i++] = (val &amp; 0xff); \
	} <span class="enscript-keyword">while</span> (0)

	hex = 0;
	dots = 0;
	dci = -1;
	i = dcount = xdcount = 0;
	pnum = p = uaddr;
	pscope = NULL;
	needmore = 1;
	<span class="enscript-keyword">if</span> ((*p == <span class="enscript-string">':'</span>) &amp;&amp; (*++p != <span class="enscript-string">':'</span>)) <span class="enscript-comment">/* if it starts with colon, gotta be a double */</span>
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">while</span> (*p) {
		<span class="enscript-keyword">if</span> (IS_XDIGIT(*p)) {
			dcount++;
			<span class="enscript-keyword">if</span> (!IS_DIGIT(*p))
				xdcount++;
			needmore = 0;
			p++;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*p == <span class="enscript-string">'.'</span>) {
			<span class="enscript-comment">/* rest is decimal IPv4 dotted quad and/or port */</span>
			<span class="enscript-keyword">if</span> (!dots) {
				<span class="enscript-comment">/* this is the first, so count them */</span>
				<span class="enscript-keyword">for</span> (pd = p; *pd; pd++) {
					<span class="enscript-keyword">if</span> (*pd == <span class="enscript-string">'.'</span>) {
						<span class="enscript-keyword">if</span> (++dots &gt; 5)
							<span class="enscript-keyword">return</span> (0);
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (hex &amp;&amp; (*pd == <span class="enscript-string">'%'</span>)) {
						<span class="enscript-keyword">break</span>;
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((*pd &lt; <span class="enscript-string">'0'</span>) || (*pd &gt; <span class="enscript-string">'9'</span>)) {
						<span class="enscript-keyword">return</span> (0);
					}
				}
				<span class="enscript-keyword">if</span> ((dots != 2) &amp;&amp; (dots != 3) &amp;&amp; (dots != 5))
					<span class="enscript-keyword">return</span> (0);
				<span class="enscript-keyword">if</span> (hex &amp;&amp; (dots == 2)) { <span class="enscript-comment">/* hex+port */</span>
					<span class="enscript-keyword">if</span> (!dcount &amp;&amp; needmore)
						<span class="enscript-keyword">return</span> (0);
					<span class="enscript-keyword">if</span> (dcount) <span class="enscript-comment">/* last hex may be elided zero */</span>
						GET(HEXVALUE);
				} <span class="enscript-keyword">else</span> {
					GET(DECIMALVALUE);
				}
			} <span class="enscript-keyword">else</span> {
				GET(DECIMALVALUE);
			}
			dcount = xdcount = 0;
			needmore = 1;
			pnum = ++p;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*p == <span class="enscript-string">':'</span>) {
			hex = 1;
			<span class="enscript-keyword">if</span> (dots)
				<span class="enscript-keyword">return</span> (0);
			<span class="enscript-keyword">if</span> (!dcount) { <span class="enscript-comment">/* missing number, probably double colon */</span>
				<span class="enscript-keyword">if</span> (dci &gt;= 0) <span class="enscript-comment">/* can only have one double colon */</span>
					<span class="enscript-keyword">return</span> (0);
				dci = i;
				needmore = 0;
			} <span class="enscript-keyword">else</span> {
				GET(HEXVALUE);
				dcount = xdcount = 0;
				needmore = 1;
			}
			pnum = ++p;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*p == <span class="enscript-string">'%'</span>) { <span class="enscript-comment">/* scope ID delimiter */</span>
			<span class="enscript-keyword">if</span> (!hex)
				<span class="enscript-keyword">return</span> (0);
			p++;
			pscope = p;
			<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* unexpected character */</span>
			<span class="enscript-keyword">return</span> (0);
		}
	}
	<span class="enscript-keyword">if</span> (needmore &amp;&amp; !dcount)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> (dcount) <span class="enscript-comment">/* decode trailing number */</span>
		GET(dots ? DECIMALVALUE : HEXVALUE);
	<span class="enscript-keyword">if</span> (dci &gt;= 0) {  <span class="enscript-comment">/* got a double-colon at i, need to insert a range of zeroes */</span>
		<span class="enscript-comment">/* if we got a port, slide to end of array */</span>
		<span class="enscript-comment">/* otherwise, slide to end of address (non-port) values */</span>
		<span class="enscript-type">int</span> end = ((dots == 2) || (dots == 5)) ? <span class="enscript-keyword">sizeof</span>(a) : (<span class="enscript-keyword">sizeof</span>(a) - 2);
		<span class="enscript-keyword">if</span> (i % 2) <span class="enscript-comment">/* length of zero range must be multiple of 2 */</span>
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-keyword">if</span> (i &gt;= end) <span class="enscript-comment">/* no room? */</span>
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-comment">/* slide (i-dci) numbers up from index dci */</span>
		<span class="enscript-keyword">for</span> (s=0; s &lt; (i - dci); s++)
			a[end-1-s] = a[i-1-s];
		<span class="enscript-comment">/* zero (end-i) numbers at index dci */</span>
		<span class="enscript-keyword">for</span> (s=0; s &lt; (end - i); s++)
			a[dci+s] = 0;
		i = end;
	}

	<span class="enscript-comment">/* copy out resulting socket address */</span>
	<span class="enscript-keyword">if</span> (hex) {
		<span class="enscript-type">struct</span> sockaddr_in6 *sin6 = (<span class="enscript-type">struct</span> sockaddr_in6*)addr;
		<span class="enscript-keyword">if</span> ((((dots == 0) || (dots == 3)) &amp;&amp; (i != (<span class="enscript-keyword">sizeof</span>(a)-2))))
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-keyword">if</span> ((((dots == 2) || (dots == 5)) &amp;&amp; (i != <span class="enscript-keyword">sizeof</span>(a))))
			<span class="enscript-keyword">return</span> (0);
		bzero(sin6, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6));
		sin6-&gt;sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
		sin6-&gt;sin6_family = AF_INET6;
		bcopy(a, &amp;sin6-&gt;sin6_addr.s6_addr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in6_addr));
		<span class="enscript-keyword">if</span> ((dots == 5) || (dots == 2))
			sin6-&gt;sin6_port = htons((a[16] &lt;&lt; 8) | a[17]);
		<span class="enscript-keyword">if</span> (pscope) {
			<span class="enscript-keyword">for</span> (p=pscope; IS_DIGIT(*p); p++)
				;
			<span class="enscript-keyword">if</span> (*p &amp;&amp; !IS_DIGIT(*p)) { <span class="enscript-comment">/* name */</span>
				ifnet_t interface = NULL;
				<span class="enscript-keyword">if</span> (ifnet_find_by_name(pscope, &amp;interface) == 0)
					sin6-&gt;sin6_scope_id = ifnet_index(interface);
				<span class="enscript-keyword">if</span> (interface)
					ifnet_release(interface);
			} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* decimal number */</span>
				sin6-&gt;sin6_scope_id = strtoul(pscope, NULL, 10);
			}
			<span class="enscript-comment">/* XXX should we also embed scope id for linklocal? */</span>
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> sockaddr_in *sin = (<span class="enscript-type">struct</span> sockaddr_in*)addr;
		<span class="enscript-keyword">if</span> ((dots != 3) &amp;&amp; (dots != 5))
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-keyword">if</span> ((dots == 3) &amp;&amp; (i != 4))
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-keyword">if</span> ((dots == 5) &amp;&amp; (i != 6))
			<span class="enscript-keyword">return</span> (0);
		bzero(sin, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in));
		sin-&gt;sin_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
		sin-&gt;sin_family = AF_INET;
		bcopy(a, &amp;sin-&gt;sin_addr.s_addr, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> in_addr));
		<span class="enscript-keyword">if</span> (dots == 5)
			sin-&gt;sin_port = htons((a[4] &lt;&lt; 8) | a[5]);
	}
	<span class="enscript-keyword">return</span> (1);
}


<span class="enscript-comment">/* NFS Client debugging support */</span>
uint32_t nfs_debug_ctl;

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdarg.h&gt;</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_printf</span>(<span class="enscript-type">int</span> facility, <span class="enscript-type">int</span> level, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *fmt, ...)
{
	va_list ap;
	
	<span class="enscript-keyword">if</span> ((uint32_t)level &gt; NFS_DEBUG_LEVEL)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> (NFS_DEBUG_FACILITY &amp;&amp; !((uint32_t)facility &amp; NFS_DEBUG_FACILITY))
		<span class="enscript-keyword">return</span>;
	
	va_start(ap, fmt);
	vprintf(fmt, ap);
	va_end(ap);
}

<span class="enscript-comment">/* Is a mount gone away? */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_mount_gone</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-keyword">return</span> (!nmp || vfs_isforce(nmp-&gt;nm_mountp) || (nmp-&gt;nm_state &amp; (NFSSTA_FORCE | NFSSTA_DEAD)));
}

<span class="enscript-comment">/*
 * Return some of the more significant mount options
 * as a string, e.g. &quot;'ro,hard,intr,tcp,vers=3,sec=krb5,deadtimeout=0'
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_mountopts</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">char</span> *buf, <span class="enscript-type">int</span> buflen)
{
	<span class="enscript-type">int</span> c;

	c = snprintf(buf, buflen, <span class="enscript-string">&quot;%s,%s,%s,%s,vers=%d,sec=%s,%sdeadtimeout=%d&quot;</span>,
		(vfs_flags(nmp-&gt;nm_mountp) &amp; MNT_RDONLY) ? <span class="enscript-string">&quot;ro&quot;</span> : <span class="enscript-string">&quot;rw&quot;</span>,
		NMFLAG(nmp, SOFT) ? <span class="enscript-string">&quot;soft&quot;</span> : <span class="enscript-string">&quot;hard&quot;</span>,
		NMFLAG(nmp, INTR) ? <span class="enscript-string">&quot;intr&quot;</span> : <span class="enscript-string">&quot;nointr&quot;</span>,
		nmp-&gt;nm_sotype == SOCK_STREAM ? <span class="enscript-string">&quot;tcp&quot;</span> : <span class="enscript-string">&quot;udp&quot;</span>,
		nmp-&gt;nm_vers,
		nmp-&gt;nm_auth == RPCAUTH_KRB5  ? <span class="enscript-string">&quot;krb5&quot;</span> :
		nmp-&gt;nm_auth == RPCAUTH_KRB5I ? <span class="enscript-string">&quot;krb5i&quot;</span> :
		nmp-&gt;nm_auth == RPCAUTH_KRB5P ? <span class="enscript-string">&quot;krb5p&quot;</span> :
		nmp-&gt;nm_auth == RPCAUTH_SYS   ? <span class="enscript-string">&quot;sys&quot;</span> : <span class="enscript-string">&quot;none&quot;</span>,
		nmp-&gt;nm_lockmode == NFS_LOCK_MODE_ENABLED ?  <span class="enscript-string">&quot;locks,&quot;</span> :
		nmp-&gt;nm_lockmode == NFS_LOCK_MODE_DISABLED ? <span class="enscript-string">&quot;nolocks,&quot;</span> :
		nmp-&gt;nm_lockmode == NFS_LOCK_MODE_LOCAL ? <span class="enscript-string">&quot;locallocks,&quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		nmp-&gt;nm_deadtimeout);

	<span class="enscript-keyword">return</span> (c &gt; buflen ? ENOMEM : 0);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSCLIENT */</span>

<span class="enscript-comment">/*
 * Schedule a callout thread to run an NFS timer function
 * interval milliseconds in the future.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_interval_timer_start</span>(thread_call_t call, <span class="enscript-type">int</span> interval)
{
	uint64_t deadline;

	clock_interval_to_deadline(interval, 1000 * 1000, &amp;deadline);
	thread_call_enter_delayed(call, deadline);
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">nfsrv_cmp_secflavs</span>(<span class="enscript-type">struct</span> nfs_sec *, <span class="enscript-type">struct</span> nfs_sec *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsrv_hang_addrlist</span>(<span class="enscript-type">struct</span> nfs_export *, <span class="enscript-type">struct</span> user_nfs_export_args *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsrv_free_netopt</span>(<span class="enscript-type">struct</span> radix_node *, <span class="enscript-type">void</span> *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsrv_free_addrlist</span>(<span class="enscript-type">struct</span> nfs_export *, <span class="enscript-type">struct</span> user_nfs_export_args *);
<span class="enscript-type">struct</span> nfs_export_options *<span class="enscript-function-name">nfsrv_export_lookup</span>(<span class="enscript-type">struct</span> nfs_export *, mbuf_t);
<span class="enscript-type">struct</span> nfs_export *<span class="enscript-function-name">nfsrv_fhtoexport</span>(<span class="enscript-type">struct</span> nfs_filehandle *);
<span class="enscript-type">struct</span> nfs_user_stat_node *<span class="enscript-function-name">nfsrv_get_user_stat_node</span>(<span class="enscript-type">struct</span> nfs_active_user_list *, <span class="enscript-type">struct</span> sockaddr *, uid_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfsrv_init_user_list</span>(<span class="enscript-type">struct</span> nfs_active_user_list *);
<span class="enscript-type">void</span> <span class="enscript-function-name">nfsrv_free_user_list</span>(<span class="enscript-type">struct</span> nfs_active_user_list *);

<span class="enscript-comment">/*
 * add NFSv3 WCC data to an mbuf chain
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_add_wcc_data_f</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsm_chain *nmc,
	<span class="enscript-type">int</span> preattrerr,
	<span class="enscript-type">struct</span> vnode_attr *prevap,
	<span class="enscript-type">int</span> postattrerr,
	<span class="enscript-type">struct</span> vnode_attr *postvap)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (preattrerr) {
		nfsm_chain_add_32(error, nmc, FALSE);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_32(error, nmc, TRUE);
		nfsm_chain_add_64(error, nmc, prevap-&gt;va_data_size);
		nfsm_chain_add_time(error, nmc, NFS_VER3, &amp;prevap-&gt;va_modify_time);
		nfsm_chain_add_time(error, nmc, NFS_VER3, &amp;prevap-&gt;va_change_time);
	}
	nfsm_chain_add_postop_attr(error, nd, nmc, postattrerr, postvap);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Extract a lookup path from the given mbufs and store it in
 * a newly allocated buffer saved in the given nameidata structure.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_get_path_namei</span>(
	<span class="enscript-type">struct</span> nfsm_chain *nmc,
	uint32_t len,
	<span class="enscript-type">struct</span> nameidata *nip)
{
	<span class="enscript-type">struct</span> componentname *cnp = &amp;nip-&gt;ni_cnd;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">char</span> *cp;

	<span class="enscript-keyword">if</span> (len &gt; (MAXPATHLEN - 1))
		<span class="enscript-keyword">return</span> (ENAMETOOLONG);

	<span class="enscript-comment">/*
	 * Get a buffer for the name to be translated, and copy the
	 * name into the buffer.
	 */</span>
	MALLOC_ZONE(cnp-&gt;cn_pnbuf, caddr_t, MAXPATHLEN, M_NAMEI, M_WAITOK);
	<span class="enscript-keyword">if</span> (!cnp-&gt;cn_pnbuf)
		<span class="enscript-keyword">return</span> (ENOMEM);
	cnp-&gt;cn_pnlen = MAXPATHLEN;
	cnp-&gt;cn_flags |= HASBUF;

	<span class="enscript-comment">/* Copy the name from the mbuf list to the string */</span>
	cp = cnp-&gt;cn_pnbuf;
	nfsm_chain_get_opaque(error, nmc, len, cp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	cnp-&gt;cn_pnbuf[len] = <span class="enscript-string">'\0'</span>;

	<span class="enscript-comment">/* sanity check the string */</span>
	<span class="enscript-keyword">if</span> ((strlen(cp) != len) || strchr(cp, <span class="enscript-string">'/'</span>))
		error = EACCES;
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (cnp-&gt;cn_pnbuf)
			FREE_ZONE(cnp-&gt;cn_pnbuf, MAXPATHLEN, M_NAMEI);
		cnp-&gt;cn_flags &amp;= ~HASBUF;
	} <span class="enscript-keyword">else</span> {
		nip-&gt;ni_pathlen = len;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Set up nameidata for a lookup() call and do it.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_namei</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	vfs_context_t ctx,
	<span class="enscript-type">struct</span> nameidata *nip,
	<span class="enscript-type">struct</span> nfs_filehandle *nfhp,
	vnode_t *retdirp,
	<span class="enscript-type">struct</span> nfs_export **nxp,
	<span class="enscript-type">struct</span> nfs_export_options **nxop)
{
	vnode_t dp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> componentname *cnp = &amp;nip-&gt;ni_cnd;
	uint32_t cnflags;
	<span class="enscript-type">char</span> *tmppn;

	*retdirp = NULL;

	<span class="enscript-comment">/*
	 * Extract and set starting directory.
	 */</span>
	error = nfsrv_fhtovp(nfhp, nd, &amp;dp, nxp, nxop);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	error = nfsrv_credcheck(nd, ctx, *nxp, *nxop);
	<span class="enscript-keyword">if</span> (error || (vnode_vtype(dp) != VDIR)) {
		vnode_put(dp);
		error = ENOTDIR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	*retdirp = dp;

	nip-&gt;ni_cnd.cn_context = ctx;

	<span class="enscript-keyword">if</span> (*nxop &amp;&amp; ((*nxop)-&gt;nxo_flags &amp; NX_READONLY))
		cnp-&gt;cn_flags |= RDONLY;

	cnp-&gt;cn_flags |= NOCROSSMOUNT;
	cnp-&gt;cn_nameptr = cnp-&gt;cn_pnbuf;
	nip-&gt;ni_usedvp = nip-&gt;ni_startdir = dp;

	<span class="enscript-comment">/*
	 * And call lookup() to do the real work
	 */</span>
	cnflags = nip-&gt;ni_cnd.cn_flags; <span class="enscript-comment">/* store in case we have to restore */</span>
	<span class="enscript-keyword">while</span> ((error = lookup(nip)) == ERECYCLE) {
		nip-&gt;ni_cnd.cn_flags = cnflags;
		cnp-&gt;cn_nameptr = cnp-&gt;cn_pnbuf;
		nip-&gt;ni_usedvp = nip-&gt;ni_dvp = nip-&gt;ni_startdir = dp;
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* Check for encountering a symbolic link */</span>
	<span class="enscript-keyword">if</span> (cnp-&gt;cn_flags &amp; ISSYMLINK) {
		<span class="enscript-keyword">if</span> (cnp-&gt;cn_flags &amp; (LOCKPARENT | WANTPARENT))
			vnode_put(nip-&gt;ni_dvp);
		<span class="enscript-keyword">if</span> (nip-&gt;ni_vp) {
			vnode_put(nip-&gt;ni_vp);
			nip-&gt;ni_vp = NULL;
		}
		error = EINVAL;
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error) {
		tmppn = cnp-&gt;cn_pnbuf;
		cnp-&gt;cn_pnbuf = NULL;
		cnp-&gt;cn_flags &amp;= ~HASBUF;
		FREE_ZONE(tmppn, cnp-&gt;cn_pnlen, M_NAMEI);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * A fiddled version of m_adj() that ensures null fill to a 4-byte
 * boundary and only trims off the back end
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsm_adj</span>(mbuf_t mp, <span class="enscript-type">int</span> len, <span class="enscript-type">int</span> nul)
{
	mbuf_t m, mnext;
	<span class="enscript-type">int</span> count, i, mlen;
	<span class="enscript-type">char</span> *cp;

	<span class="enscript-comment">/*
	 * Trim from tail.  Scan the mbuf chain,
	 * calculating its length and finding the last mbuf.
	 * If the adjustment only affects this mbuf, then just
	 * adjust and return.  Otherwise, rescan and truncate
	 * after the remaining size.
	 */</span>
	count = 0;
	m = mp;
	<span class="enscript-keyword">for</span> (;;) {
		mlen = mbuf_len(m);
		count += mlen;
		mnext = mbuf_next(m);
		<span class="enscript-keyword">if</span> (mnext == NULL)
			<span class="enscript-keyword">break</span>;
		m = mnext;
	}
	<span class="enscript-keyword">if</span> (mlen &gt; len) {
		mlen -= len;
		mbuf_setlen(m, mlen);
		<span class="enscript-keyword">if</span> (nul &gt; 0) {
			cp = (caddr_t)mbuf_data(m) + mlen - nul;
			<span class="enscript-keyword">for</span> (i = 0; i &lt; nul; i++)
				*cp++ = <span class="enscript-string">'\0'</span>;
		}
		<span class="enscript-keyword">return</span>;
	}
	count -= len;
	<span class="enscript-keyword">if</span> (count &lt; 0)
		count = 0;
	<span class="enscript-comment">/*
	 * Correct length for chain is &quot;count&quot;.
	 * Find the mbuf with last data, adjust its length,
	 * and toss data from remaining mbufs on chain.
	 */</span>
	<span class="enscript-keyword">for</span> (m = mp; m; m = mbuf_next(m)) {
		mlen = mbuf_len(m);
		<span class="enscript-keyword">if</span> (mlen &gt;= count) {
			mlen = count;
			mbuf_setlen(m, count);
			<span class="enscript-keyword">if</span> (nul &gt; 0) {
				cp = (caddr_t)mbuf_data(m) + mlen - nul;
				<span class="enscript-keyword">for</span> (i = 0; i &lt; nul; i++)
					*cp++ = <span class="enscript-string">'\0'</span>;
			}
			<span class="enscript-keyword">break</span>;
		}
		count -= mlen;
	}
	<span class="enscript-keyword">for</span> (m = mbuf_next(m); m; m = mbuf_next(m))
		mbuf_setlen(m, 0);
}

<span class="enscript-comment">/*
 * Trim the header out of the mbuf list and trim off any trailing
 * junk so that the mbuf list has only the write data.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_trim_data</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, <span class="enscript-type">int</span> len, <span class="enscript-type">int</span> *mlen)
{
	<span class="enscript-type">int</span> cnt = 0, dlen, adjust;
	caddr_t data;
	mbuf_t m;

	<span class="enscript-keyword">if</span> (mlen)
		*mlen = 0;

	<span class="enscript-comment">/* trim header */</span>
	<span class="enscript-keyword">for</span> (m = nmc-&gt;nmc_mhead; m &amp;&amp; (m != nmc-&gt;nmc_mcur); m = mbuf_next(m))
		mbuf_setlen(m, 0);
	<span class="enscript-keyword">if</span> (!m)
		<span class="enscript-keyword">return</span> (EIO);

	<span class="enscript-comment">/* trim current mbuf */</span>
	data = mbuf_data(m);
	dlen = mbuf_len(m);
	adjust = nmc-&gt;nmc_ptr - data;
	dlen -= adjust;
	<span class="enscript-keyword">if</span> ((dlen &gt; 0) &amp;&amp; (adjust &gt; 0)) {
		<span class="enscript-keyword">if</span> (mbuf_setdata(m, nmc-&gt;nmc_ptr, dlen))
			<span class="enscript-keyword">return</span>(EIO);
	} <span class="enscript-keyword">else</span>
		mbuf_setlen(m, dlen);

	<span class="enscript-comment">/* skip next len bytes  */</span>
	<span class="enscript-keyword">for</span> (; m &amp;&amp; (cnt &lt; len); m = mbuf_next(m)) {
		dlen = mbuf_len(m);
		cnt += dlen;
		<span class="enscript-keyword">if</span> (cnt &gt; len) {
			<span class="enscript-comment">/* truncate to end of data */</span>
			mbuf_setlen(m, dlen - (cnt - len));
			<span class="enscript-keyword">if</span> (m == nmc-&gt;nmc_mcur)
				nmc-&gt;nmc_left -= (cnt - len);
			cnt = len;
		}
	}
	<span class="enscript-keyword">if</span> (mlen)
		*mlen = cnt;

	<span class="enscript-comment">/* trim any trailing data */</span>
	<span class="enscript-keyword">if</span> (m == nmc-&gt;nmc_mcur)
		nmc-&gt;nmc_left = 0;
	<span class="enscript-keyword">for</span> (; m; m = mbuf_next(m))
		mbuf_setlen(m, 0);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_add_fattr</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsm_chain *nmc,
	<span class="enscript-type">struct</span> vnode_attr *vap)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">// XXX Should we assert here that all fields are supported?
</span>
	nfsm_chain_add_32(error, nmc, vtonfs_type(vap-&gt;va_type, nd-&gt;nd_vers));
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_chain_add_32(error, nmc, vap-&gt;va_mode &amp; 07777);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_32(error, nmc, vtonfsv2_mode(vap-&gt;va_type, vap-&gt;va_mode));
	}
	nfsm_chain_add_32(error, nmc, vap-&gt;va_nlink);
	nfsm_chain_add_32(error, nmc, vap-&gt;va_uid);
	nfsm_chain_add_32(error, nmc, vap-&gt;va_gid);
	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3) {
		nfsm_chain_add_64(error, nmc, vap-&gt;va_data_size);
		nfsm_chain_add_64(error, nmc, vap-&gt;va_data_alloc);
		nfsm_chain_add_32(error, nmc, major(vap-&gt;va_rdev));
		nfsm_chain_add_32(error, nmc, minor(vap-&gt;va_rdev));
		nfsm_chain_add_64(error, nmc, vap-&gt;va_fsid);
		nfsm_chain_add_64(error, nmc, vap-&gt;va_fileid);
	} <span class="enscript-keyword">else</span> {
		nfsm_chain_add_32(error, nmc, vap-&gt;va_data_size);
		nfsm_chain_add_32(error, nmc, NFS_FABLKSIZE);
		<span class="enscript-keyword">if</span> (vap-&gt;va_type == VFIFO)
			nfsm_chain_add_32(error, nmc, 0xffffffff);
		<span class="enscript-keyword">else</span>
			nfsm_chain_add_32(error, nmc, vap-&gt;va_rdev);
		nfsm_chain_add_32(error, nmc, vap-&gt;va_data_alloc / NFS_FABLKSIZE);
		nfsm_chain_add_32(error, nmc, vap-&gt;va_fsid);
		nfsm_chain_add_32(error, nmc, vap-&gt;va_fileid);
	}
	nfsm_chain_add_time(error, nmc, nd-&gt;nd_vers, &amp;vap-&gt;va_access_time);
	nfsm_chain_add_time(error, nmc, nd-&gt;nd_vers, &amp;vap-&gt;va_modify_time);
	nfsm_chain_add_time(error, nmc, nd-&gt;nd_vers, &amp;vap-&gt;va_change_time);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsm_chain_get_sattr</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	<span class="enscript-type">struct</span> nfsm_chain *nmc,
	<span class="enscript-type">struct</span> vnode_attr *vap)
{
	<span class="enscript-type">int</span> error = 0;
	uint32_t val = 0;
	uint64_t val64 = 0;
	<span class="enscript-type">struct</span> timespec now;

	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER2) {
		<span class="enscript-comment">/*
		 * There is/was a bug in the Sun client that puts 0xffff in the mode
		 * field of sattr when it should put in 0xffffffff.  The u_short
		 * doesn't sign extend.  So check the low order 2 bytes for 0xffff.
		 */</span>
		nfsm_chain_get_32(error, nmc, val);
		<span class="enscript-keyword">if</span> ((val &amp; 0xffff) != 0xffff) {
			VATTR_SET(vap, va_mode, val &amp; 07777);
			<span class="enscript-comment">/* save the &quot;type&quot; bits for NFSv2 create */</span>
			VATTR_SET(vap, va_type, IFTOVT(val));
			VATTR_CLEAR_ACTIVE(vap, va_type);
		}
		nfsm_chain_get_32(error, nmc, val);
		<span class="enscript-keyword">if</span> (val != (uint32_t)-1)
			VATTR_SET(vap, va_uid, val);
		nfsm_chain_get_32(error, nmc, val);
		<span class="enscript-keyword">if</span> (val != (uint32_t)-1)
			VATTR_SET(vap, va_gid, val);
		<span class="enscript-comment">/* save the &quot;size&quot; bits for NFSv2 create (even if they appear unset) */</span>
		nfsm_chain_get_32(error, nmc, val);
		VATTR_SET(vap, va_data_size, val);
		<span class="enscript-keyword">if</span> (val == (uint32_t)-1)
			VATTR_CLEAR_ACTIVE(vap, va_data_size);
		nfsm_chain_get_time(error, nmc, NFS_VER2,
			vap-&gt;va_access_time.tv_sec,
			vap-&gt;va_access_time.tv_nsec);
		<span class="enscript-keyword">if</span> (vap-&gt;va_access_time.tv_sec != -1)
			VATTR_SET_ACTIVE(vap, va_access_time);
		nfsm_chain_get_time(error, nmc, NFS_VER2,
			vap-&gt;va_modify_time.tv_sec,
			vap-&gt;va_modify_time.tv_nsec);
		<span class="enscript-keyword">if</span> (vap-&gt;va_modify_time.tv_sec != -1)
			VATTR_SET_ACTIVE(vap, va_modify_time);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* NFSv3 */</span>
	nfsm_chain_get_32(error, nmc, val);
	<span class="enscript-keyword">if</span> (val) {
		nfsm_chain_get_32(error, nmc, val);
		VATTR_SET(vap, va_mode, val &amp; 07777);
	}
	nfsm_chain_get_32(error, nmc, val);
	<span class="enscript-keyword">if</span> (val) {
		nfsm_chain_get_32(error, nmc, val);
		VATTR_SET(vap, va_uid, val);
	}
	nfsm_chain_get_32(error, nmc, val);
	<span class="enscript-keyword">if</span> (val) {
		nfsm_chain_get_32(error, nmc, val);
		VATTR_SET(vap, va_gid, val);
	}
	nfsm_chain_get_32(error, nmc, val);
	<span class="enscript-keyword">if</span> (val) {
		nfsm_chain_get_64(error, nmc, val64);
		VATTR_SET(vap, va_data_size, val64);
	}
	nanotime(&amp;now);
	nfsm_chain_get_32(error, nmc, val);
	<span class="enscript-keyword">switch</span> (val) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_TIME_SET_TO_CLIENT</span>:
		nfsm_chain_get_time(error, nmc, nd-&gt;nd_vers,
			vap-&gt;va_access_time.tv_sec,
			vap-&gt;va_access_time.tv_nsec);
		VATTR_SET_ACTIVE(vap, va_access_time);
		vap-&gt;va_vaflags &amp;= ~VA_UTIMES_NULL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_TIME_SET_TO_SERVER</span>:
		VATTR_SET(vap, va_access_time, now);
		vap-&gt;va_vaflags |= VA_UTIMES_NULL;
		<span class="enscript-keyword">break</span>;
	}
	nfsm_chain_get_32(error, nmc, val);
	<span class="enscript-keyword">switch</span> (val) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_TIME_SET_TO_CLIENT</span>:
		nfsm_chain_get_time(error, nmc, nd-&gt;nd_vers,
			vap-&gt;va_modify_time.tv_sec,
			vap-&gt;va_modify_time.tv_nsec);
		VATTR_SET_ACTIVE(vap, va_modify_time);
		vap-&gt;va_vaflags &amp;= ~VA_UTIMES_NULL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_TIME_SET_TO_SERVER</span>:
		VATTR_SET(vap, va_modify_time, now);
		<span class="enscript-keyword">if</span> (!VATTR_IS_ACTIVE(vap, va_access_time))
			vap-&gt;va_vaflags |= VA_UTIMES_NULL;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Compare two security flavor structs
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_cmp_secflavs</span>(<span class="enscript-type">struct</span> nfs_sec *sf1, <span class="enscript-type">struct</span> nfs_sec *sf2)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (sf1-&gt;count != sf2-&gt;count)
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; sf1-&gt;count; i++)
		<span class="enscript-keyword">if</span> (sf1-&gt;flavors[i] != sf2-&gt;flavors[i])
			<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Build hash lists of net addresses and hang them off the NFS export.
 * Called by nfsrv_export() to set up the lists of export addresses.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_hang_addrlist</span>(<span class="enscript-type">struct</span> nfs_export *nx, <span class="enscript-type">struct</span> user_nfs_export_args *unxa)
{
	<span class="enscript-type">struct</span> nfs_export_net_args nxna;
	<span class="enscript-type">struct</span> nfs_netopt *no, *rn_no;
	<span class="enscript-type">struct</span> radix_node_head *rnh;
	<span class="enscript-type">struct</span> radix_node *rn;
	<span class="enscript-type">struct</span> sockaddr *saddr, *smask;
	<span class="enscript-type">struct</span> domain *dom;
	<span class="enscript-type">int</span> i, error;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> net;
	user_addr_t uaddr;
	kauth_cred_t cred;

	uaddr = unxa-&gt;nxa_nets;
	<span class="enscript-keyword">for</span> (net = 0; net &lt; unxa-&gt;nxa_netcount; net++, uaddr += <span class="enscript-keyword">sizeof</span>(nxna)) {
		error = copyin(uaddr, &amp;nxna, <span class="enscript-keyword">sizeof</span>(nxna));
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);

		<span class="enscript-keyword">if</span> (nxna.nxna_addr.ss_len &gt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_storage) ||
		    nxna.nxna_mask.ss_len &gt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_storage) ||
		    nxna.nxna_addr.ss_family &gt; AF_MAX ||
		    nxna.nxna_mask.ss_family &gt; AF_MAX)
			<span class="enscript-keyword">return</span> (EINVAL);

		<span class="enscript-keyword">if</span> (nxna.nxna_flags &amp; (NX_MAPROOT|NX_MAPALL)) {
			<span class="enscript-type">struct</span> posix_cred temp_pcred;
		        bzero(&amp;temp_pcred, <span class="enscript-keyword">sizeof</span>(temp_pcred));
			temp_pcred.cr_uid = nxna.nxna_cred.cr_uid;
			temp_pcred.cr_ngroups = nxna.nxna_cred.cr_ngroups;
			<span class="enscript-keyword">for</span> (i=0; i &lt; nxna.nxna_cred.cr_ngroups &amp;&amp; i &lt; NGROUPS; i++)
				temp_pcred.cr_groups[i] = nxna.nxna_cred.cr_groups[i];
			cred = posix_cred_create(&amp;temp_pcred);
			<span class="enscript-keyword">if</span> (!IS_VALID_CRED(cred))
				<span class="enscript-keyword">return</span> (ENOMEM);
		} <span class="enscript-keyword">else</span> {
			cred = NOCRED;
		}

		<span class="enscript-keyword">if</span> (nxna.nxna_addr.ss_len == 0) {
			<span class="enscript-comment">/* No address means this is a default/world export */</span>
			<span class="enscript-keyword">if</span> (nx-&gt;nx_flags &amp; NX_DEFAULTEXPORT) {
			        <span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
				        kauth_cred_unref(&amp;cred);
				<span class="enscript-keyword">return</span> (EEXIST);
			}
			nx-&gt;nx_flags |= NX_DEFAULTEXPORT;
			nx-&gt;nx_defopt.nxo_flags = nxna.nxna_flags;
			nx-&gt;nx_defopt.nxo_cred = cred;
			bcopy(&amp;nxna.nxna_sec, &amp;nx-&gt;nx_defopt.nxo_sec, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_sec));
			nx-&gt;nx_expcnt++;
			<span class="enscript-keyword">continue</span>;
		}

		i = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_netopt);
		i += nxna.nxna_addr.ss_len + nxna.nxna_mask.ss_len;
		MALLOC(no, <span class="enscript-type">struct</span> nfs_netopt *, i, M_NETADDR, M_WAITOK);
		<span class="enscript-keyword">if</span> (!no) {
			<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
				kauth_cred_unref(&amp;cred);
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
		bzero(no, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_netopt));
		no-&gt;no_opt.nxo_flags = nxna.nxna_flags;
		no-&gt;no_opt.nxo_cred = cred;
		bcopy(&amp;nxna.nxna_sec, &amp;no-&gt;no_opt.nxo_sec, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_sec));

		saddr = (<span class="enscript-type">struct</span> sockaddr *)(no + 1);
		bcopy(&amp;nxna.nxna_addr, saddr, nxna.nxna_addr.ss_len);
		<span class="enscript-keyword">if</span> (nxna.nxna_mask.ss_len) {
			smask = (<span class="enscript-type">struct</span> sockaddr *)((caddr_t)saddr + nxna.nxna_addr.ss_len);
			bcopy(&amp;nxna.nxna_mask, smask, nxna.nxna_mask.ss_len);
		} <span class="enscript-keyword">else</span> {
			smask = NULL;
		}
		i = saddr-&gt;sa_family;
		<span class="enscript-keyword">if</span> ((rnh = nx-&gt;nx_rtable[i]) == 0) {
			<span class="enscript-comment">/*
			 * Seems silly to initialize every AF when most are not
			 * used, do so on demand here
			 */</span>
			TAILQ_FOREACH(dom, &amp;domains, dom_entry) {
				<span class="enscript-keyword">if</span> (dom-&gt;dom_family == i &amp;&amp; dom-&gt;dom_rtattach) {
					dom-&gt;dom_rtattach((<span class="enscript-type">void</span> **)&amp;nx-&gt;nx_rtable[i],
						dom-&gt;dom_rtoffset);
					<span class="enscript-keyword">break</span>;
				}
			}
			<span class="enscript-keyword">if</span> ((rnh = nx-&gt;nx_rtable[i]) == 0) {
			        <span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
				        kauth_cred_unref(&amp;cred);
				_FREE(no, M_NETADDR);
				<span class="enscript-keyword">return</span> (ENOBUFS);
			}
		}
		rn = (*rnh-&gt;rnh_addaddr)((caddr_t)saddr, (caddr_t)smask, rnh, no-&gt;no_rnodes);
		<span class="enscript-keyword">if</span> (rn == 0) {
			<span class="enscript-comment">/*
			 * One of the reasons that rnh_addaddr may fail is that
			 * the entry already exists. To check for this case, we
			 * look up the entry to see if it is there. If so, we
			 * do not need to make a new entry but do continue.
			 *
			 * XXX should this be rnh_lookup() instead?
			 */</span>
			<span class="enscript-type">int</span> matched = 0;
			rn = (*rnh-&gt;rnh_matchaddr)((caddr_t)saddr, rnh);
			rn_no = (<span class="enscript-type">struct</span> nfs_netopt *)rn;
			<span class="enscript-keyword">if</span> (rn != 0 &amp;&amp; (rn-&gt;rn_flags &amp; RNF_ROOT) == 0 &amp;&amp;
			    (rn_no-&gt;no_opt.nxo_flags == nxna.nxna_flags) &amp;&amp;
			    (!nfsrv_cmp_secflavs(&amp;rn_no-&gt;no_opt.nxo_sec, &amp;nxna.nxna_sec))) {
				kauth_cred_t cred2 = rn_no-&gt;no_opt.nxo_cred;
				<span class="enscript-keyword">if</span> (cred == cred2) {
					<span class="enscript-comment">/* creds are same (or both NULL) */</span>
					matched = 1;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cred &amp;&amp; cred2 &amp;&amp; (kauth_cred_getuid(cred) == kauth_cred_getuid(cred2))) {
				    <span class="enscript-comment">/*
				     * Now compare the effective and
				     * supplementary groups...
				     *
				     * Note: This comparison, as written,
				     * does not correctly indicate that
				     * the groups are equivalent, since
				     * other than the first supplementary
				     * group, which is also the effective
				     * group, order on the remaining groups
				     * doesn't matter, and this is an
				     * ordered compare.
				     */</span>
				    gid_t groups[NGROUPS];
				    gid_t groups2[NGROUPS];
				    <span class="enscript-type">int</span> groupcount = NGROUPS;
				    <span class="enscript-type">int</span> group2count = NGROUPS;

				    <span class="enscript-keyword">if</span> (!kauth_cred_getgroups(cred, groups, &amp;groupcount) &amp;&amp;
					!kauth_cred_getgroups(cred2, groups2, &amp;group2count) &amp;&amp;
					groupcount == group2count) {
					    <span class="enscript-keyword">for</span> (i=0; i &lt; group2count; i++)
						    <span class="enscript-keyword">if</span> (groups[i] != groups2[i])
							    <span class="enscript-keyword">break</span>;
					    <span class="enscript-keyword">if</span> (i &gt;= group2count || i &gt;= NGROUPS)
					    matched = 1;
				    }
				}
			}
			<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred))
			        kauth_cred_unref(&amp;cred);
			_FREE(no, M_NETADDR);
			<span class="enscript-keyword">if</span> (matched)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">return</span> (EPERM);
		}
		nx-&gt;nx_expcnt++;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * In order to properly track an export's netopt count, we need to pass
 * an additional argument to nfsrv_free_netopt() so that it can decrement
 * the export's netopt count.
 */</span>
<span class="enscript-type">struct</span> nfsrv_free_netopt_arg {
	uint32_t *cnt;
	<span class="enscript-type">struct</span> radix_node_head *rnh;
};

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_free_netopt</span>(<span class="enscript-type">struct</span> radix_node *rn, <span class="enscript-type">void</span> *w)
{
	<span class="enscript-type">struct</span> nfsrv_free_netopt_arg *fna = (<span class="enscript-type">struct</span> nfsrv_free_netopt_arg *)w;
	<span class="enscript-type">struct</span> radix_node_head *rnh = fna-&gt;rnh;
	uint32_t *cnt = fna-&gt;cnt;
	<span class="enscript-type">struct</span> nfs_netopt *nno = (<span class="enscript-type">struct</span> nfs_netopt *)rn;

	(*rnh-&gt;rnh_deladdr)(rn-&gt;rn_key, rn-&gt;rn_mask, rnh);
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(nno-&gt;no_opt.nxo_cred))
		kauth_cred_unref(&amp;nno-&gt;no_opt.nxo_cred);
	_FREE((caddr_t)rn, M_NETADDR);
	*cnt -= 1;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Free the net address hash lists that are hanging off the mount points.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_free_addrlist</span>(<span class="enscript-type">struct</span> nfs_export *nx, <span class="enscript-type">struct</span> user_nfs_export_args *unxa)
{
	<span class="enscript-type">struct</span> nfs_export_net_args nxna;
	<span class="enscript-type">struct</span> radix_node_head *rnh;
	<span class="enscript-type">struct</span> radix_node *rn;
	<span class="enscript-type">struct</span> nfsrv_free_netopt_arg fna;
	<span class="enscript-type">struct</span> nfs_netopt *nno;
	user_addr_t uaddr;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> net;
	<span class="enscript-type">int</span> i, error;

	<span class="enscript-keyword">if</span> (!unxa || !unxa-&gt;nxa_netcount) {
		<span class="enscript-comment">/* delete everything */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt;= AF_MAX; i++)
			<span class="enscript-keyword">if</span> ( (rnh = nx-&gt;nx_rtable[i]) ) {
				fna.rnh = rnh;
				fna.cnt = &amp;nx-&gt;nx_expcnt;
				(*rnh-&gt;rnh_walktree)(rnh, nfsrv_free_netopt, (caddr_t)&amp;fna);
				_FREE((caddr_t)rnh, M_RTABLE);
				nx-&gt;nx_rtable[i] = 0;
			}
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* delete only the exports specified */</span>
	uaddr = unxa-&gt;nxa_nets;
	<span class="enscript-keyword">for</span> (net = 0; net &lt; unxa-&gt;nxa_netcount; net++, uaddr += <span class="enscript-keyword">sizeof</span>(nxna)) {
		error = copyin(uaddr, &amp;nxna, <span class="enscript-keyword">sizeof</span>(nxna));
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);

		<span class="enscript-keyword">if</span> (nxna.nxna_addr.ss_len == 0) {
			<span class="enscript-comment">/* No address means this is a default/world export */</span>
			<span class="enscript-keyword">if</span> (nx-&gt;nx_flags &amp; NX_DEFAULTEXPORT) {
				nx-&gt;nx_flags &amp;= ~NX_DEFAULTEXPORT;
				<span class="enscript-keyword">if</span> (IS_VALID_CRED(nx-&gt;nx_defopt.nxo_cred)) {
					kauth_cred_unref(&amp;nx-&gt;nx_defopt.nxo_cred);
				}
				nx-&gt;nx_expcnt--;
			}
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> ((rnh = nx-&gt;nx_rtable[nxna.nxna_addr.ss_family]) == 0) {
			<span class="enscript-comment">/* AF not initialized? */</span>
			<span class="enscript-keyword">if</span> (!(unxa-&gt;nxa_flags &amp; NXA_ADD))
				printf(<span class="enscript-string">&quot;nfsrv_free_addrlist: address not found (0)\n&quot;</span>);
			<span class="enscript-keyword">continue</span>;
		}

		rn = (*rnh-&gt;rnh_lookup)(&amp;nxna.nxna_addr,
			nxna.nxna_mask.ss_len ? &amp;nxna.nxna_mask : NULL, rnh);
		<span class="enscript-keyword">if</span> (!rn || (rn-&gt;rn_flags &amp; RNF_ROOT)) {
			<span class="enscript-keyword">if</span> (!(unxa-&gt;nxa_flags &amp; NXA_ADD))
				printf(<span class="enscript-string">&quot;nfsrv_free_addrlist: address not found (1)\n&quot;</span>);
			<span class="enscript-keyword">continue</span>;
		}

		(*rnh-&gt;rnh_deladdr)(rn-&gt;rn_key, rn-&gt;rn_mask, rnh);
		nno = (<span class="enscript-type">struct</span> nfs_netopt *)rn;
		<span class="enscript-keyword">if</span> (IS_VALID_CRED(nno-&gt;no_opt.nxo_cred))
			kauth_cred_unref(&amp;nno-&gt;no_opt.nxo_cred);
		_FREE((caddr_t)rn, M_NETADDR);

		nx-&gt;nx_expcnt--;
		<span class="enscript-keyword">if</span> (nx-&gt;nx_expcnt == ((nx-&gt;nx_flags &amp; NX_DEFAULTEXPORT) ? 1 : 0)) {
			<span class="enscript-comment">/* no more entries in rnh, so free it up */</span>
			_FREE((caddr_t)rnh, M_RTABLE);
			nx-&gt;nx_rtable[nxna.nxna_addr.ss_family] = 0;
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">enablequotas</span>(<span class="enscript-type">struct</span> mount *mp, vfs_context_t ctx); <span class="enscript-comment">// XXX
</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_export</span>(<span class="enscript-type">struct</span> user_nfs_export_args *unxa, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error = 0;
	size_t pathlen;
	<span class="enscript-type">struct</span> nfs_exportfs *nxfs, *nxfs2, *nxfs3;
	<span class="enscript-type">struct</span> nfs_export *nx, *nx2, *nx3;
	<span class="enscript-type">struct</span> nfs_filehandle nfh;
	<span class="enscript-type">struct</span> nameidata mnd, xnd;
	vnode_t mvp = NULL, xvp = NULL;
	mount_t mp = NULL;
	<span class="enscript-type">char</span> path[MAXPATHLEN];
	<span class="enscript-type">int</span> expisroot;

	<span class="enscript-keyword">if</span> (unxa-&gt;nxa_flags == NXA_CHECK) {
		<span class="enscript-comment">/* just check if the path is an NFS-exportable file system */</span>
		error = copyinstr(unxa-&gt;nxa_fspath, path, MAXPATHLEN, &amp;pathlen);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		NDINIT(&amp;mnd, LOOKUP, OP_LOOKUP, FOLLOW | LOCKLEAF | AUDITVNPATH1,
			UIO_SYSSPACE, CAST_USER_ADDR_T(path), ctx);
		error = namei(&amp;mnd);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		mvp = mnd.ni_vp;
		mp = vnode_mount(mvp);
		<span class="enscript-comment">/* make sure it's the root of a file system */</span>
		<span class="enscript-keyword">if</span> (!vnode_isvroot(mvp))
			error = EINVAL;
		<span class="enscript-comment">/* make sure the file system is NFS-exportable */</span>
		<span class="enscript-keyword">if</span> (!error) {
			nfh.nfh_len = NFSV3_MAX_FID_SIZE;
			error = VFS_VPTOFH(mvp, (<span class="enscript-type">int</span>*)&amp;nfh.nfh_len, &amp;nfh.nfh_fid[0], NULL);
		}
		<span class="enscript-keyword">if</span> (!error &amp;&amp; (nfh.nfh_len &gt; (<span class="enscript-type">int</span>)NFSV3_MAX_FID_SIZE))
			error = EIO;
		<span class="enscript-keyword">if</span> (!error &amp;&amp; !(mp-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFSREADDIR_EXTENDED))
			error = EISDIR;
		vnode_put(mvp);
		nameidone(&amp;mnd);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* all other operations: must be super user */</span>
	<span class="enscript-keyword">if</span> ((error = vfs_context_suser(ctx)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (unxa-&gt;nxa_flags &amp; NXA_DELETE_ALL) {
		<span class="enscript-comment">/* delete all exports on all file systems */</span>
		lck_rw_lock_exclusive(&amp;nfsrv_export_rwlock);
		<span class="enscript-keyword">while</span> ((nxfs = LIST_FIRST(&amp;nfsrv_exports))) {
			mp = vfs_getvfs_by_mntonname(nxfs-&gt;nxfs_path);
			<span class="enscript-keyword">if</span> (mp) {
				vfs_clearflags(mp, MNT_EXPORTED);
				mount_iterdrop(mp);
				mp = NULL;
			}
			<span class="enscript-comment">/* delete all exports on this file system */</span>
			<span class="enscript-keyword">while</span> ((nx = LIST_FIRST(&amp;nxfs-&gt;nxfs_exports))) {
				LIST_REMOVE(nx, nx_next);
				LIST_REMOVE(nx, nx_hash);
				<span class="enscript-comment">/* delete all netopts for this export */</span>
				nfsrv_free_addrlist(nx, NULL);
				nx-&gt;nx_flags &amp;= ~NX_DEFAULTEXPORT;
				<span class="enscript-keyword">if</span> (IS_VALID_CRED(nx-&gt;nx_defopt.nxo_cred)) {
					kauth_cred_unref(&amp;nx-&gt;nx_defopt.nxo_cred);
				}
				<span class="enscript-comment">/* free active user list for this export */</span>
				nfsrv_free_user_list(&amp;nx-&gt;nx_user_list);
				FREE(nx-&gt;nx_path, M_TEMP);
				FREE(nx, M_TEMP);
			}
			LIST_REMOVE(nxfs, nxfs_next);
			FREE(nxfs-&gt;nxfs_path, M_TEMP);
			FREE(nxfs, M_TEMP);
		}
		<span class="enscript-keyword">if</span> (nfsrv_export_hashtbl) {
			<span class="enscript-comment">/* all exports deleted, clean up export hash table */</span>
			FREE(nfsrv_export_hashtbl, M_TEMP);
			nfsrv_export_hashtbl = NULL;
		}
		lck_rw_done(&amp;nfsrv_export_rwlock);
		<span class="enscript-keyword">return</span> (0);
	}

	error = copyinstr(unxa-&gt;nxa_fspath, path, MAXPATHLEN, &amp;pathlen);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	lck_rw_lock_exclusive(&amp;nfsrv_export_rwlock);

	<span class="enscript-comment">/* init export hash table if not already */</span>
	<span class="enscript-keyword">if</span> (!nfsrv_export_hashtbl) {
		<span class="enscript-keyword">if</span> (nfsrv_export_hash_size &lt;= 0)
			nfsrv_export_hash_size = NFSRVEXPHASHSZ;
		nfsrv_export_hashtbl = hashinit(nfsrv_export_hash_size, M_TEMP, &amp;nfsrv_export_hash);
	}

	<span class="enscript-comment">// first check if we've already got an exportfs with the given ID
</span>	LIST_FOREACH(nxfs, &amp;nfsrv_exports, nxfs_next) {
		<span class="enscript-keyword">if</span> (nxfs-&gt;nxfs_id == unxa-&gt;nxa_fsid)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (nxfs) {
		<span class="enscript-comment">/* verify exported FS path matches given path */</span>
		<span class="enscript-keyword">if</span> (strncmp(path, nxfs-&gt;nxfs_path, MAXPATHLEN)) {
			error = EEXIST;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock_out</span>;
		}
		<span class="enscript-keyword">if</span> ((unxa-&gt;nxa_flags &amp; (NXA_ADD|NXA_OFFLINE)) == NXA_ADD) {
			<span class="enscript-comment">/* if adding, verify that the mount is still what we expect */</span>
			mp = vfs_getvfs_by_mntonname(nxfs-&gt;nxfs_path);
			<span class="enscript-keyword">if</span> (mp) {
				mount_ref(mp, 0);
				mount_iterdrop(mp);
			}
			<span class="enscript-comment">/* find exported FS root vnode */</span>
			NDINIT(&amp;mnd, LOOKUP, OP_LOOKUP, FOLLOW | LOCKLEAF | AUDITVNPATH1,
				UIO_SYSSPACE, CAST_USER_ADDR_T(nxfs-&gt;nxfs_path), ctx);
			error = namei(&amp;mnd);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock_out</span>;
			mvp = mnd.ni_vp;
			<span class="enscript-comment">/* make sure it's (still) the root of a file system */</span>
			<span class="enscript-keyword">if</span> (!vnode_isvroot(mvp)) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-comment">/* sanity check: this should be same mount */</span>
			<span class="enscript-keyword">if</span> (mp != vnode_mount(mvp)) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* no current exported file system with that ID */</span>
		<span class="enscript-keyword">if</span> (!(unxa-&gt;nxa_flags &amp; NXA_ADD)) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock_out</span>;
		}

		<span class="enscript-comment">/* find exported FS root vnode */</span>
		NDINIT(&amp;mnd, LOOKUP, OP_LOOKUP, FOLLOW | LOCKLEAF | AUDITVNPATH1,
			UIO_SYSSPACE, CAST_USER_ADDR_T(path), ctx);
		error = namei(&amp;mnd);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (!(unxa-&gt;nxa_flags &amp; NXA_OFFLINE))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock_out</span>;
		} <span class="enscript-keyword">else</span> {
			mvp = mnd.ni_vp;
			<span class="enscript-comment">/* make sure it's the root of a file system */</span>
			<span class="enscript-keyword">if</span> (!vnode_isvroot(mvp)) {
				<span class="enscript-comment">/* bail if not marked offline */</span>
				<span class="enscript-keyword">if</span> (!(unxa-&gt;nxa_flags &amp; NXA_OFFLINE)) {
					error = EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				vnode_put(mvp);
				nameidone(&amp;mnd);
				mvp = NULL;
			} <span class="enscript-keyword">else</span> {
				mp = vnode_mount(mvp);
				mount_ref(mp, 0);

				<span class="enscript-comment">/* make sure the file system is NFS-exportable */</span>
				nfh.nfh_len = NFSV3_MAX_FID_SIZE;
				error = VFS_VPTOFH(mvp, (<span class="enscript-type">int</span>*)&amp;nfh.nfh_len, &amp;nfh.nfh_fid[0], NULL);
				<span class="enscript-keyword">if</span> (!error &amp;&amp; (nfh.nfh_len &gt; (<span class="enscript-type">int</span>)NFSV3_MAX_FID_SIZE))
					error = EIO;
				<span class="enscript-keyword">if</span> (!error &amp;&amp; !(mp-&gt;mnt_vtable-&gt;vfc_vfsflags &amp; VFC_VFSREADDIR_EXTENDED))
					error = EISDIR;
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}

		<span class="enscript-comment">/* add an exportfs for it */</span>
		MALLOC(nxfs, <span class="enscript-type">struct</span> nfs_exportfs *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_exportfs), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (!nxfs) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		bzero(nxfs, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_exportfs));
		nxfs-&gt;nxfs_id = unxa-&gt;nxa_fsid;
		MALLOC(nxfs-&gt;nxfs_path, <span class="enscript-type">char</span>*, pathlen, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (!nxfs-&gt;nxfs_path) {
			FREE(nxfs, M_TEMP);
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		bcopy(path, nxfs-&gt;nxfs_path, pathlen);
		<span class="enscript-comment">/* insert into list in reverse-sorted order */</span>
		nxfs3 = NULL;
		LIST_FOREACH(nxfs2, &amp;nfsrv_exports, nxfs_next) {
			<span class="enscript-keyword">if</span> (strncmp(nxfs-&gt;nxfs_path, nxfs2-&gt;nxfs_path, MAXPATHLEN) &gt; 0)
				<span class="enscript-keyword">break</span>;
			nxfs3 = nxfs2;
		}
		<span class="enscript-keyword">if</span> (nxfs2)
			LIST_INSERT_BEFORE(nxfs2, nxfs, nxfs_next);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nxfs3)
			LIST_INSERT_AFTER(nxfs3, nxfs, nxfs_next);
		<span class="enscript-keyword">else</span>
			LIST_INSERT_HEAD(&amp;nfsrv_exports, nxfs, nxfs_next);

		<span class="enscript-comment">/* make sure any quotas are enabled before we export the file system */</span>
		<span class="enscript-keyword">if</span> (mp)
			enablequotas(mp, ctx);
	}

	<span class="enscript-keyword">if</span> (unxa-&gt;nxa_exppath) {
		error = copyinstr(unxa-&gt;nxa_exppath, path, MAXPATHLEN, &amp;pathlen);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		LIST_FOREACH(nx, &amp;nxfs-&gt;nxfs_exports, nx_next) {
			<span class="enscript-keyword">if</span> (nx-&gt;nx_id == unxa-&gt;nxa_expid)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (nx) {
			<span class="enscript-comment">/* verify exported FS path matches given path */</span>
			<span class="enscript-keyword">if</span> (strncmp(path, nx-&gt;nx_path, MAXPATHLEN)) {
				error = EEXIST;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* no current export with that ID */</span>
			<span class="enscript-keyword">if</span> (!(unxa-&gt;nxa_flags &amp; NXA_ADD)) {
				error = ENOENT;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-comment">/* add an export for it */</span>
			MALLOC(nx, <span class="enscript-type">struct</span> nfs_export *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_export), M_TEMP, M_WAITOK);
			<span class="enscript-keyword">if</span> (!nx) {
				error = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
			}
			bzero(nx, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_export));
			nx-&gt;nx_id = unxa-&gt;nxa_expid;
			nx-&gt;nx_fs = nxfs;
			microtime(&amp;nx-&gt;nx_exptime);
			MALLOC(nx-&gt;nx_path, <span class="enscript-type">char</span>*, pathlen, M_TEMP, M_WAITOK);
			<span class="enscript-keyword">if</span> (!nx-&gt;nx_path) {
				error = ENOMEM;
				FREE(nx, M_TEMP);
				nx = NULL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
			}
			bcopy(path, nx-&gt;nx_path, pathlen);
			<span class="enscript-comment">/* initialize the active user list */</span>
			nfsrv_init_user_list(&amp;nx-&gt;nx_user_list);
			<span class="enscript-comment">/* insert into list in reverse-sorted order */</span>
			nx3 = NULL;
			LIST_FOREACH(nx2, &amp;nxfs-&gt;nxfs_exports, nx_next) {
				<span class="enscript-keyword">if</span> (strncmp(nx-&gt;nx_path, nx2-&gt;nx_path, MAXPATHLEN) &gt; 0)
					<span class="enscript-keyword">break</span>;
				nx3 = nx2;
			}
			<span class="enscript-keyword">if</span> (nx2)
				LIST_INSERT_BEFORE(nx2, nx, nx_next);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nx3)
				LIST_INSERT_AFTER(nx3, nx, nx_next);
			<span class="enscript-keyword">else</span>
				LIST_INSERT_HEAD(&amp;nxfs-&gt;nxfs_exports, nx, nx_next);
			<span class="enscript-comment">/* insert into hash */</span>
			LIST_INSERT_HEAD(NFSRVEXPHASH(nxfs-&gt;nxfs_id, nx-&gt;nx_id), nx, nx_hash);

			<span class="enscript-comment">/*
			 * We don't allow/support nested exports.  Check if the new entry
			 * nests with the entries before and after or if there's an
			 * entry for the file system root and subdirs.
			 */</span>
			error = 0;
			<span class="enscript-keyword">if</span> ((nx3 &amp;&amp; !strncmp(nx3-&gt;nx_path, nx-&gt;nx_path, pathlen - 1) &amp;&amp;
				    (nx3-&gt;nx_path[pathlen-1] == <span class="enscript-string">'/'</span>)) ||
			    (nx2 &amp;&amp; !strncmp(nx2-&gt;nx_path, nx-&gt;nx_path, strlen(nx2-&gt;nx_path)) &amp;&amp;
			    	    (nx-&gt;nx_path[strlen(nx2-&gt;nx_path)] == <span class="enscript-string">'/'</span>)))
				error = EINVAL;
			<span class="enscript-keyword">if</span> (!error) {
				<span class="enscript-comment">/* check export conflict with fs root export and vice versa */</span>
				expisroot = !nx-&gt;nx_path[0] ||
					    ((nx-&gt;nx_path[0] == <span class="enscript-string">'.'</span>) &amp;&amp; !nx-&gt;nx_path[1]);
				LIST_FOREACH(nx2, &amp;nxfs-&gt;nxfs_exports, nx_next) {
					<span class="enscript-keyword">if</span> (expisroot) {
						<span class="enscript-keyword">if</span> (nx2 != nx)
							<span class="enscript-keyword">break</span>;
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!nx2-&gt;nx_path[0])
						<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((nx2-&gt;nx_path[0] == <span class="enscript-string">'.'</span>) &amp;&amp; !nx2-&gt;nx_path[1])
						<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-keyword">if</span> (nx2)
					error = EINVAL;
			}
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-comment">/*
				 * Don't actually return an error because mountd is
				 * probably about to delete the conflicting export.
				 * This can happen when a new export momentarily conflicts
				 * with an old export while the transition is being made.
				 * Theoretically, mountd could be written to avoid this
				 * transient situation - but it would greatly increase the
				 * complexity of mountd for very little overall benefit.
				 */</span>
				printf(<span class="enscript-string">&quot;nfsrv_export: warning: nested exports: %s/%s\n&quot;</span>,
					nxfs-&gt;nxfs_path, nx-&gt;nx_path);
				error = 0;
			}
			nx-&gt;nx_fh.nfh_xh.nxh_flags = NXHF_INVALIDFH;
		}
		<span class="enscript-comment">/* make sure file handle is set up */</span>
		<span class="enscript-keyword">if</span> ((nx-&gt;nx_fh.nfh_xh.nxh_version != htonl(NFS_FH_VERSION)) ||
		    (nx-&gt;nx_fh.nfh_xh.nxh_flags &amp; NXHF_INVALIDFH)) {
			<span class="enscript-comment">/* try to set up export root file handle */</span>
			nx-&gt;nx_fh.nfh_xh.nxh_version = htonl(NFS_FH_VERSION);
			nx-&gt;nx_fh.nfh_xh.nxh_fsid = htonl(nx-&gt;nx_fs-&gt;nxfs_id);
			nx-&gt;nx_fh.nfh_xh.nxh_expid = htonl(nx-&gt;nx_id);
			nx-&gt;nx_fh.nfh_xh.nxh_flags = 0;
			nx-&gt;nx_fh.nfh_xh.nxh_reserved = 0;
			nx-&gt;nx_fh.nfh_fhp = (u_char*)&amp;nx-&gt;nx_fh.nfh_xh;
			bzero(&amp;nx-&gt;nx_fh.nfh_fid[0], NFSV2_MAX_FID_SIZE);
			<span class="enscript-keyword">if</span> (mvp) {
				<span class="enscript-comment">/* find export root vnode */</span>
				<span class="enscript-keyword">if</span> (!nx-&gt;nx_path[0] || ((nx-&gt;nx_path[0] == <span class="enscript-string">'.'</span>) &amp;&amp; !nx-&gt;nx_path[1])) {
					<span class="enscript-comment">/* exporting file system's root directory */</span>
					xvp = mvp;
					vnode_get(xvp);
				} <span class="enscript-keyword">else</span> {
					xnd.ni_cnd.cn_nameiop = LOOKUP;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>
					xnd.ni_op = OP_LOOKUP;
#<span class="enscript-reference">endif</span>
					xnd.ni_cnd.cn_flags = LOCKLEAF;
					xnd.ni_pathlen = pathlen - 1;
					xnd.ni_cnd.cn_nameptr = xnd.ni_cnd.cn_pnbuf = path;
					xnd.ni_startdir = mvp;
					xnd.ni_usedvp   = mvp;
					xnd.ni_cnd.cn_context = ctx;
					<span class="enscript-keyword">while</span> ((error = lookup(&amp;xnd)) == ERECYCLE) {
						xnd.ni_cnd.cn_flags = LOCKLEAF;
						xnd.ni_cnd.cn_nameptr = xnd.ni_cnd.cn_pnbuf;
						xnd.ni_usedvp = xnd.ni_dvp = xnd.ni_startdir = mvp;
					}
					<span class="enscript-keyword">if</span> (error)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
					xvp = xnd.ni_vp;
				}

				<span class="enscript-keyword">if</span> (vnode_vtype(xvp) != VDIR) {
					error = EINVAL;
					vnode_put(xvp);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
				}

				<span class="enscript-comment">/* grab file handle */</span>
				nx-&gt;nx_fh.nfh_len = NFSV3_MAX_FID_SIZE;
				error = VFS_VPTOFH(xvp, (<span class="enscript-type">int</span>*)&amp;nx-&gt;nx_fh.nfh_len, &amp;nx-&gt;nx_fh.nfh_fid[0], NULL);
				<span class="enscript-keyword">if</span> (!error &amp;&amp; (nx-&gt;nx_fh.nfh_len &gt; (<span class="enscript-type">int</span>)NFSV3_MAX_FID_SIZE)) {
					error = EIO;
				} <span class="enscript-keyword">else</span> {
					nx-&gt;nx_fh.nfh_xh.nxh_fidlen = nx-&gt;nx_fh.nfh_len;
					nx-&gt;nx_fh.nfh_len += <span class="enscript-keyword">sizeof</span>(nx-&gt;nx_fh.nfh_xh);
				}

				vnode_put(xvp);
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
			} <span class="enscript-keyword">else</span> {
				nx-&gt;nx_fh.nfh_xh.nxh_flags = NXHF_INVALIDFH;
				nx-&gt;nx_fh.nfh_xh.nxh_fidlen = 0;
				nx-&gt;nx_fh.nfh_len = <span class="enscript-keyword">sizeof</span>(nx-&gt;nx_fh.nfh_xh);
			}
		}
	} <span class="enscript-keyword">else</span> {
		nx = NULL;
	}

	<span class="enscript-comment">/* perform the export changes */</span>
	<span class="enscript-keyword">if</span> (unxa-&gt;nxa_flags &amp; NXA_DELETE) {
		<span class="enscript-keyword">if</span> (!nx) {
			<span class="enscript-comment">/* delete all exports on this file system */</span>
			<span class="enscript-keyword">while</span> ((nx = LIST_FIRST(&amp;nxfs-&gt;nxfs_exports))) {
				LIST_REMOVE(nx, nx_next);
				LIST_REMOVE(nx, nx_hash);
				<span class="enscript-comment">/* delete all netopts for this export */</span>
				nfsrv_free_addrlist(nx, NULL);
				nx-&gt;nx_flags &amp;= ~NX_DEFAULTEXPORT;
				<span class="enscript-keyword">if</span> (IS_VALID_CRED(nx-&gt;nx_defopt.nxo_cred)) {
					kauth_cred_unref(&amp;nx-&gt;nx_defopt.nxo_cred);
				}
				<span class="enscript-comment">/* delete active user list for this export */</span>
				nfsrv_free_user_list(&amp;nx-&gt;nx_user_list);
				FREE(nx-&gt;nx_path, M_TEMP);
				FREE(nx, M_TEMP);
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!unxa-&gt;nxa_netcount) {
			<span class="enscript-comment">/* delete all netopts for this export */</span>
			nfsrv_free_addrlist(nx, NULL);
			nx-&gt;nx_flags &amp;= ~NX_DEFAULTEXPORT;
			<span class="enscript-keyword">if</span> (IS_VALID_CRED(nx-&gt;nx_defopt.nxo_cred)) {
				kauth_cred_unref(&amp;nx-&gt;nx_defopt.nxo_cred);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* delete only the netopts for the given addresses */</span>
			error = nfsrv_free_addrlist(nx, unxa);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
	}
	<span class="enscript-keyword">if</span> (unxa-&gt;nxa_flags &amp; NXA_ADD) {
		<span class="enscript-comment">/* 
		 * If going offline set the export time so that when
		 * coming back on line we will present a new write verifier
		 * to the client.
		 */</span>
		<span class="enscript-keyword">if</span> (unxa-&gt;nxa_flags &amp; NXA_OFFLINE)
			microtime(&amp;nx-&gt;nx_exptime);

		error = nfsrv_hang_addrlist(nx, unxa);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; mp)
			vfs_setflags(mp, MNT_EXPORTED);
	}

<span class="enscript-reference">out1</span>:
	<span class="enscript-keyword">if</span> (nx &amp;&amp; !nx-&gt;nx_expcnt) {
		<span class="enscript-comment">/* export has no export options */</span>
		LIST_REMOVE(nx, nx_next);
		LIST_REMOVE(nx, nx_hash);
		<span class="enscript-comment">/* delete active user list for this export */</span>
		nfsrv_free_user_list(&amp;nx-&gt;nx_user_list);
		FREE(nx-&gt;nx_path, M_TEMP);
		FREE(nx, M_TEMP);
	}
	<span class="enscript-keyword">if</span> (LIST_EMPTY(&amp;nxfs-&gt;nxfs_exports)) {
		<span class="enscript-comment">/* exported file system has no more exports */</span>
		LIST_REMOVE(nxfs, nxfs_next);
		FREE(nxfs-&gt;nxfs_path, M_TEMP);
		FREE(nxfs, M_TEMP);
		<span class="enscript-keyword">if</span> (mp)
			vfs_clearflags(mp, MNT_EXPORTED);
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (mvp) {
		vnode_put(mvp);
		nameidone(&amp;mnd);
	}
<span class="enscript-reference">unlock_out</span>:
	<span class="enscript-keyword">if</span> (mp)
		mount_drop(mp, 0);
	lck_rw_done(&amp;nfsrv_export_rwlock);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Check if there is a least one export that will allow this address.
 *
 * Return 0, if there is an export that will allow this address,
 * else return EACCES
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_check_exports_allow_address</span>(mbuf_t nam)
{
	<span class="enscript-type">struct</span> nfs_exportfs		*nxfs;
	<span class="enscript-type">struct</span> nfs_export		*nx;
	<span class="enscript-type">struct</span> nfs_export_options	*nxo;

	<span class="enscript-keyword">if</span> (nam == NULL)
		<span class="enscript-keyword">return</span> (EACCES);

	lck_rw_lock_shared(&amp;nfsrv_export_rwlock);
	LIST_FOREACH(nxfs, &amp;nfsrv_exports, nxfs_next) {
		LIST_FOREACH(nx, &amp;nxfs-&gt;nxfs_exports, nx_next) {
			<span class="enscript-comment">/* A little optimizing by checking for the default first */</span>
			<span class="enscript-keyword">if</span> (nx-&gt;nx_flags &amp; NX_DEFAULTEXPORT)
				nxo = &amp;nx-&gt;nx_defopt;
			<span class="enscript-keyword">if</span> (nxo || (nxo = nfsrv_export_lookup(nx, nam)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;
		}
	}
<span class="enscript-reference">found</span>:
	lck_rw_done(&amp;nfsrv_export_rwlock);

	<span class="enscript-keyword">return</span> (nxo ? 0 : EACCES);
}

<span class="enscript-type">struct</span> nfs_export_options *
<span class="enscript-function-name">nfsrv_export_lookup</span>(<span class="enscript-type">struct</span> nfs_export *nx, mbuf_t nam)
{
	<span class="enscript-type">struct</span> nfs_export_options *nxo = NULL;
	<span class="enscript-type">struct</span> nfs_netopt *no = NULL;
	<span class="enscript-type">struct</span> radix_node_head *rnh;
	<span class="enscript-type">struct</span> sockaddr *saddr;

	<span class="enscript-comment">/* Lookup in the export list first. */</span>
	<span class="enscript-keyword">if</span> (nam != NULL) {
		saddr = mbuf_data(nam);
		rnh = nx-&gt;nx_rtable[saddr-&gt;sa_family];
		<span class="enscript-keyword">if</span> (rnh != NULL) {
			no = (<span class="enscript-type">struct</span> nfs_netopt *)
				(*rnh-&gt;rnh_matchaddr)((caddr_t)saddr, rnh);
			<span class="enscript-keyword">if</span> (no &amp;&amp; no-&gt;no_rnodes-&gt;rn_flags &amp; RNF_ROOT)
				no = NULL;
			<span class="enscript-keyword">if</span> (no)
				nxo = &amp;no-&gt;no_opt;
		}
	}
	<span class="enscript-comment">/* If no address match, use the default if it exists. */</span>
	<span class="enscript-keyword">if</span> ((nxo == NULL) &amp;&amp; (nx-&gt;nx_flags &amp; NX_DEFAULTEXPORT))
		nxo = &amp;nx-&gt;nx_defopt;
	<span class="enscript-keyword">return</span> (nxo);
}

<span class="enscript-comment">/* find an export for the given handle */</span>
<span class="enscript-type">struct</span> nfs_export *
<span class="enscript-function-name">nfsrv_fhtoexport</span>(<span class="enscript-type">struct</span> nfs_filehandle *nfhp)
{
	<span class="enscript-type">struct</span> nfs_exphandle *nxh = (<span class="enscript-type">struct</span> nfs_exphandle*)nfhp-&gt;nfh_fhp;
	<span class="enscript-type">struct</span> nfs_export *nx;
	uint32_t fsid, expid;

	<span class="enscript-keyword">if</span> (!nfsrv_export_hashtbl)
		<span class="enscript-keyword">return</span> (NULL);
	fsid = ntohl(nxh-&gt;nxh_fsid);
	expid = ntohl(nxh-&gt;nxh_expid);
	nx = NFSRVEXPHASH(fsid, expid)-&gt;lh_first;
	<span class="enscript-keyword">for</span> (; nx; nx = LIST_NEXT(nx, nx_hash)) {
		<span class="enscript-keyword">if</span> (nx-&gt;nx_fs-&gt;nxfs_id != fsid)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (nx-&gt;nx_id != expid)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (nx);
}

<span class="enscript-comment">/*
 * nfsrv_fhtovp() - convert FH to vnode and export info
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_fhtovp</span>(
	<span class="enscript-type">struct</span> nfs_filehandle *nfhp,
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	vnode_t *vpp,
	<span class="enscript-type">struct</span> nfs_export **nxp,
	<span class="enscript-type">struct</span> nfs_export_options **nxop)
{
	<span class="enscript-type">struct</span> nfs_exphandle *nxh = (<span class="enscript-type">struct</span> nfs_exphandle*)nfhp-&gt;nfh_fhp;
	<span class="enscript-type">struct</span> nfs_export_options *nxo;
	u_char *fidp;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> mount *mp;
	mbuf_t nam = NULL;
	uint32_t v;
	<span class="enscript-type">int</span> i, valid;

	*vpp = NULL;
	*nxp = NULL;
	*nxop = NULL;

	<span class="enscript-keyword">if</span> (nd != NULL)
		nam = nd-&gt;nd_nam;

	v = ntohl(nxh-&gt;nxh_version);
	<span class="enscript-keyword">if</span> (v != NFS_FH_VERSION) {
		<span class="enscript-comment">/* file handle format not supported */</span>
		<span class="enscript-keyword">return</span> (ESTALE);
	}
	<span class="enscript-keyword">if</span> (nfhp-&gt;nfh_len &gt; NFSV3_MAX_FH_SIZE)
		<span class="enscript-keyword">return</span> (EBADRPC);
	<span class="enscript-keyword">if</span> (nfhp-&gt;nfh_len &lt; (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_exphandle))
		<span class="enscript-keyword">return</span> (ESTALE);
	v = ntohs(nxh-&gt;nxh_flags);
	<span class="enscript-keyword">if</span> (v &amp; NXHF_INVALIDFH)
		<span class="enscript-keyword">return</span> (ESTALE);

	*nxp = nfsrv_fhtoexport(nfhp);
	<span class="enscript-keyword">if</span> (!*nxp)
		<span class="enscript-keyword">return</span> (ESTALE);

	<span class="enscript-comment">/* Get the export option structure for this &lt;export, client&gt; tuple. */</span>
	*nxop = nxo = nfsrv_export_lookup(*nxp, nam);
	<span class="enscript-keyword">if</span> (nam &amp;&amp; (*nxop == NULL))
		<span class="enscript-keyword">return</span> (EACCES);

	<span class="enscript-keyword">if</span> (nd != NULL) {
		<span class="enscript-comment">/* Validate the security flavor of the request */</span>
		<span class="enscript-keyword">for</span> (i = 0, valid = 0; i &lt; nxo-&gt;nxo_sec.count; i++) {
			<span class="enscript-keyword">if</span> (nd-&gt;nd_sec == nxo-&gt;nxo_sec.flavors[i]) {
				valid = 1;
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (!valid) {
			<span class="enscript-comment">/*
			 * RFC 2623 section 2.3.2 recommends no authentication
			 * requirement for certain NFS procedures used for mounting.
			 * This allows an unauthenticated superuser on the client
			 * to do mounts for the benefit of authenticated users.
			 */</span>
			<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER2)
				<span class="enscript-keyword">if</span> (nd-&gt;nd_procnum == NFSV2PROC_GETATTR ||
				    nd-&gt;nd_procnum == NFSV2PROC_STATFS)
					valid = 1;
			<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER3)
				<span class="enscript-keyword">if</span> (nd-&gt;nd_procnum == NFSPROC_FSINFO)
					valid = 1;

			<span class="enscript-keyword">if</span> (!valid)
				<span class="enscript-keyword">return</span> (NFSERR_AUTHERR | AUTH_REJECTCRED);
		}
	}

	<span class="enscript-keyword">if</span> (nxo &amp;&amp; (nxo-&gt;nxo_flags &amp; NX_OFFLINE))
		<span class="enscript-keyword">return</span> ((nd == NULL || nd-&gt;nd_vers == NFS_VER2) ? ESTALE : NFSERR_TRYLATER);

	<span class="enscript-comment">/* find mount structure */</span>
	mp = vfs_getvfs_by_mntonname((*nxp)-&gt;nx_fs-&gt;nxfs_path);
	<span class="enscript-keyword">if</span> (mp) {
		error = vfs_busy(mp, LK_NOWAIT);
		mount_iterdrop(mp);
		<span class="enscript-keyword">if</span> (error)
			mp = NULL;
	}
	<span class="enscript-keyword">if</span> (!mp) {
		<span class="enscript-comment">/*
		 * We have an export, but no mount?
		 * Perhaps the export just hasn't been marked offline yet.
		 */</span>
		<span class="enscript-keyword">return</span> ((nd == NULL || nd-&gt;nd_vers == NFS_VER2) ? ESTALE : NFSERR_TRYLATER);
	}

	fidp = nfhp-&gt;nfh_fhp + <span class="enscript-keyword">sizeof</span>(*nxh);
	error = VFS_FHTOVP(mp, nxh-&gt;nxh_fidlen, fidp, vpp, NULL);
	vfs_unbusy(mp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-comment">/* vnode pointer should be good at this point or ... */</span>
	<span class="enscript-keyword">if</span> (*vpp == NULL)
		<span class="enscript-keyword">return</span> (ESTALE);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * nfsrv_credcheck() - check/map credentials according
 * to given export options.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_credcheck</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	vfs_context_t ctx,
	__unused <span class="enscript-type">struct</span> nfs_export *nx,
	<span class="enscript-type">struct</span> nfs_export_options *nxo)
{
	<span class="enscript-keyword">if</span> (nxo &amp;&amp; nxo-&gt;nxo_cred) {
		<span class="enscript-keyword">if</span> ((nxo-&gt;nxo_flags &amp; NX_MAPALL) ||
		    ((nxo-&gt;nxo_flags &amp; NX_MAPROOT) &amp;&amp; !suser(nd-&gt;nd_cr, NULL))) {
			kauth_cred_ref(nxo-&gt;nxo_cred);
			kauth_cred_unref(&amp;nd-&gt;nd_cr);
			nd-&gt;nd_cr = nxo-&gt;nxo_cred;
		}
	}
	ctx-&gt;vc_ucred = nd-&gt;nd_cr;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * nfsrv_vptofh() - convert vnode to file handle for given export
 *
 * If the caller is passing in a vnode for a &quot;..&quot; directory entry,
 * they can pass a directory NFS file handle (dnfhp) which will be
 * checked against the root export file handle.  If it matches, we
 * refuse to provide the file handle for the out-of-export directory.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_vptofh</span>(
	<span class="enscript-type">struct</span> nfs_export *nx,
	<span class="enscript-type">int</span> nfsvers,
	<span class="enscript-type">struct</span> nfs_filehandle *dnfhp,
	vnode_t vp,
	vfs_context_t ctx,
	<span class="enscript-type">struct</span> nfs_filehandle *nfhp)
{
	<span class="enscript-type">int</span> error;
	uint32_t maxfidsize;

	nfhp-&gt;nfh_fhp = (u_char*)&amp;nfhp-&gt;nfh_xh;
	nfhp-&gt;nfh_xh.nxh_version = htonl(NFS_FH_VERSION);
	nfhp-&gt;nfh_xh.nxh_fsid = htonl(nx-&gt;nx_fs-&gt;nxfs_id);
	nfhp-&gt;nfh_xh.nxh_expid = htonl(nx-&gt;nx_id);
	nfhp-&gt;nfh_xh.nxh_flags = 0;
	nfhp-&gt;nfh_xh.nxh_reserved = 0;

	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER2)
		bzero(&amp;nfhp-&gt;nfh_fid[0], NFSV2_MAX_FID_SIZE);

	<span class="enscript-comment">/* if directory FH matches export root, return invalid FH */</span>
	<span class="enscript-keyword">if</span> (dnfhp &amp;&amp; nfsrv_fhmatch(dnfhp, &amp;nx-&gt;nx_fh)) {
		<span class="enscript-keyword">if</span> (nfsvers == NFS_VER2)
			nfhp-&gt;nfh_len = NFSX_V2FH;
		<span class="enscript-keyword">else</span>
			nfhp-&gt;nfh_len = <span class="enscript-keyword">sizeof</span>(nfhp-&gt;nfh_xh);
		nfhp-&gt;nfh_xh.nxh_fidlen = 0;
		nfhp-&gt;nfh_xh.nxh_flags = htons(NXHF_INVALIDFH);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER2)
		maxfidsize = NFSV2_MAX_FID_SIZE;
	<span class="enscript-keyword">else</span>
		maxfidsize = NFSV3_MAX_FID_SIZE;
	nfhp-&gt;nfh_len = maxfidsize;

	error = VFS_VPTOFH(vp, (<span class="enscript-type">int</span>*)&amp;nfhp-&gt;nfh_len, &amp;nfhp-&gt;nfh_fid[0], ctx);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (nfhp-&gt;nfh_len &gt; maxfidsize)
		<span class="enscript-keyword">return</span> (EOVERFLOW);
	nfhp-&gt;nfh_xh.nxh_fidlen = nfhp-&gt;nfh_len;
	nfhp-&gt;nfh_len += <span class="enscript-keyword">sizeof</span>(nfhp-&gt;nfh_xh);
	<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER2) &amp;&amp; (nfhp-&gt;nfh_len &lt; NFSX_V2FH))
		nfhp-&gt;nfh_len = NFSX_V2FH;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Compare two file handles to see it they're the same.
 * Note that we don't use nfh_len because that may include
 * padding in an NFSv2 file handle.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_fhmatch</span>(<span class="enscript-type">struct</span> nfs_filehandle *fh1, <span class="enscript-type">struct</span> nfs_filehandle *fh2)
{
	<span class="enscript-type">struct</span> nfs_exphandle *nxh1, *nxh2;
	<span class="enscript-type">int</span> len1, len2;

	nxh1 = (<span class="enscript-type">struct</span> nfs_exphandle *)fh1-&gt;nfh_fhp;
	nxh2 = (<span class="enscript-type">struct</span> nfs_exphandle *)fh2-&gt;nfh_fhp;
	len1 = <span class="enscript-keyword">sizeof</span>(fh1-&gt;nfh_xh) + nxh1-&gt;nxh_fidlen;
	len2 = <span class="enscript-keyword">sizeof</span>(fh2-&gt;nfh_xh) + nxh2-&gt;nxh_fidlen;
	<span class="enscript-keyword">if</span> (len1 != len2)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> (bcmp(nxh1, nxh2, len1))
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * Functions for dealing with active user lists
 */</span>

<span class="enscript-comment">/*
 * Search the hash table for a user node with a matching IP address and uid field.
 * If found, the node's tm_last timestamp is updated and the node is returned.
 *
 * If not found, a new node is allocated (or reclaimed via LRU), initialized, and returned.
 * Returns NULL if a new node could not be allcoated.
 *
 * The list's user_mutex lock MUST be held.
 */</span>
<span class="enscript-type">struct</span> nfs_user_stat_node *
<span class="enscript-function-name">nfsrv_get_user_stat_node</span>(<span class="enscript-type">struct</span> nfs_active_user_list *list, <span class="enscript-type">struct</span> sockaddr *saddr, uid_t uid)
{
	<span class="enscript-type">struct</span> nfs_user_stat_node		*unode;
	<span class="enscript-type">struct</span> timeval				now;
	<span class="enscript-type">struct</span> nfs_user_stat_hashtbl_head	*head;

	<span class="enscript-comment">/* seach the hash table */</span>
	head = NFS_USER_STAT_HASH(list-&gt;user_hashtbl, uid);
	LIST_FOREACH(unode, head, hash_link) {
		<span class="enscript-keyword">if</span> ((uid == unode-&gt;uid) &amp;&amp; (nfs_sockaddr_cmp(saddr, (<span class="enscript-type">struct</span> sockaddr*)&amp;unode-&gt;sock) == 0)) {
			<span class="enscript-comment">/* found matching node */</span>
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (unode) {
		<span class="enscript-comment">/* found node in the hash table, now update lru position */</span>
		TAILQ_REMOVE(&amp;list-&gt;user_lru, unode, lru_link);
		TAILQ_INSERT_TAIL(&amp;list-&gt;user_lru, unode, lru_link);

		<span class="enscript-comment">/* update time stamp */</span>
		microtime(&amp;now);
		unode-&gt;tm_last = (uint32_t)now.tv_sec;
		<span class="enscript-keyword">return</span> unode;
	}

	<span class="enscript-keyword">if</span> (list-&gt;node_count &lt; nfsrv_user_stat_max_nodes) {
		<span class="enscript-comment">/* Allocate a new node */</span>
		MALLOC(unode, <span class="enscript-type">struct</span> nfs_user_stat_node *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_node),
			M_TEMP, M_WAITOK | M_ZERO);

		<span class="enscript-keyword">if</span> (!unode)
			<span class="enscript-keyword">return</span> NULL;

		<span class="enscript-comment">/* increment node count */</span>
		OSAddAtomic(1, &amp;nfsrv_user_stat_node_count);
		list-&gt;node_count++;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* reuse the oldest node in the lru list */</span>
		unode = TAILQ_FIRST(&amp;list-&gt;user_lru);

		<span class="enscript-keyword">if</span> (!unode)
			<span class="enscript-keyword">return</span> NULL;

		<span class="enscript-comment">/* Remove the node */</span>
		TAILQ_REMOVE(&amp;list-&gt;user_lru, unode, lru_link);
		LIST_REMOVE(unode, hash_link);
	}

	<span class="enscript-comment">/* Initialize the node */</span>
	unode-&gt;uid = uid;
	bcopy(saddr, &amp;unode-&gt;sock, saddr-&gt;sa_len);
	microtime(&amp;now);
	unode-&gt;ops = 0;
	unode-&gt;bytes_read = 0;
	unode-&gt;bytes_written = 0;
	unode-&gt;tm_start = (uint32_t)now.tv_sec;
	unode-&gt;tm_last = (uint32_t)now.tv_sec;

	<span class="enscript-comment">/* insert the node  */</span>
	TAILQ_INSERT_TAIL(&amp;list-&gt;user_lru, unode, lru_link);
	LIST_INSERT_HEAD(head, unode, hash_link);

	<span class="enscript-keyword">return</span> unode;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_update_user_stat</span>(<span class="enscript-type">struct</span> nfs_export *nx, <span class="enscript-type">struct</span> nfsrv_descript *nd, uid_t uid, u_int ops, u_int rd_bytes, u_int wr_bytes)
{
	<span class="enscript-type">struct</span> nfs_user_stat_node	*unode;
	<span class="enscript-type">struct</span> nfs_active_user_list	*ulist;
	<span class="enscript-type">struct</span> sockaddr			*saddr;

	<span class="enscript-keyword">if</span> ((!nfsrv_user_stat_enabled) || (!nx) || (!nd) || (!nd-&gt;nd_nam))
		<span class="enscript-keyword">return</span>;

	saddr = (<span class="enscript-type">struct</span> sockaddr *)mbuf_data(nd-&gt;nd_nam);

	<span class="enscript-comment">/* check address family before going any further */</span>
	<span class="enscript-keyword">if</span> ((saddr-&gt;sa_family != AF_INET) &amp;&amp; (saddr-&gt;sa_family != AF_INET6))
		<span class="enscript-keyword">return</span>;

	ulist = &amp;nx-&gt;nx_user_list;

	<span class="enscript-comment">/* lock the active user list */</span>
	lck_mtx_lock(&amp;ulist-&gt;user_mutex);

	<span class="enscript-comment">/* get the user node */</span>
	unode = nfsrv_get_user_stat_node(ulist, saddr, uid);

	<span class="enscript-keyword">if</span> (!unode) {
		lck_mtx_unlock(&amp;ulist-&gt;user_mutex);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* update counters */</span>
	unode-&gt;ops += ops;
	unode-&gt;bytes_read += rd_bytes;
	unode-&gt;bytes_written += wr_bytes;

	<span class="enscript-comment">/* done */</span>
	lck_mtx_unlock(&amp;ulist-&gt;user_mutex);
}

<span class="enscript-comment">/* initialize an active user list */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_init_user_list</span>(<span class="enscript-type">struct</span> nfs_active_user_list *ulist)
{
	uint i;

	<span class="enscript-comment">/* initialize the lru */</span>
	TAILQ_INIT(&amp;ulist-&gt;user_lru);

	<span class="enscript-comment">/* initialize the hash table */</span>
	<span class="enscript-keyword">for</span>(i = 0; i &lt; NFS_USER_STAT_HASH_SIZE; i++)
		LIST_INIT(&amp;ulist-&gt;user_hashtbl[i]);
	ulist-&gt;node_count = 0;

	lck_mtx_init(&amp;ulist-&gt;user_mutex, nfsrv_active_user_mutex_group, LCK_ATTR_NULL);
}

<span class="enscript-comment">/* Free all nodes in an active user list */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_free_user_list</span>(<span class="enscript-type">struct</span> nfs_active_user_list *ulist)
{
	<span class="enscript-type">struct</span> nfs_user_stat_node *unode;

	<span class="enscript-keyword">if</span> (!ulist)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">while</span> ((unode = TAILQ_FIRST(&amp;ulist-&gt;user_lru))) {
		<span class="enscript-comment">/* Remove node and free */</span>
		TAILQ_REMOVE(&amp;ulist-&gt;user_lru, unode, lru_link);
		LIST_REMOVE(unode, hash_link);
		FREE(unode, M_TEMP);

		<span class="enscript-comment">/* decrement node count */</span>
		OSAddAtomic(-1, &amp;nfsrv_user_stat_node_count);
	}
	ulist-&gt;node_count = 0;

	lck_mtx_destroy(&amp;ulist-&gt;user_mutex, nfsrv_active_user_mutex_group);
}

<span class="enscript-comment">/* Reclaim old expired user nodes from active user lists. */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_active_user_list_reclaim</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> nfs_exportfs			*nxfs;
	<span class="enscript-type">struct</span> nfs_export			*nx;
	<span class="enscript-type">struct</span> nfs_active_user_list		*ulist;
	<span class="enscript-type">struct</span> nfs_user_stat_hashtbl_head	oldlist;
	<span class="enscript-type">struct</span> nfs_user_stat_node		*unode, *unode_next;
	<span class="enscript-type">struct</span> timeval				now;
	uint32_t				tstale;

	LIST_INIT(&amp;oldlist);

	lck_rw_lock_shared(&amp;nfsrv_export_rwlock);
	microtime(&amp;now);
	tstale = now.tv_sec - nfsrv_user_stat_max_idle_sec;
	LIST_FOREACH(nxfs, &amp;nfsrv_exports, nxfs_next) {
		LIST_FOREACH(nx, &amp;nxfs-&gt;nxfs_exports, nx_next) {
			<span class="enscript-comment">/* Scan through all user nodes of this export */</span>
			ulist = &amp;nx-&gt;nx_user_list;
			lck_mtx_lock(&amp;ulist-&gt;user_mutex);
			<span class="enscript-keyword">for</span> (unode = TAILQ_FIRST(&amp;ulist-&gt;user_lru); unode; unode = unode_next) {
				unode_next = TAILQ_NEXT(unode, lru_link);

				<span class="enscript-comment">/* check if this node has expired */</span>
				<span class="enscript-keyword">if</span> (unode-&gt;tm_last &gt;= tstale)
					<span class="enscript-keyword">break</span>;

				<span class="enscript-comment">/* Remove node from the active user list */</span>
				TAILQ_REMOVE(&amp;ulist-&gt;user_lru, unode, lru_link);
				LIST_REMOVE(unode, hash_link);

				<span class="enscript-comment">/* Add node to temp list */</span>
				LIST_INSERT_HEAD(&amp;oldlist, unode, hash_link);

				<span class="enscript-comment">/* decrement node count */</span>
				OSAddAtomic(-1, &amp;nfsrv_user_stat_node_count);
				ulist-&gt;node_count--;
			}
			<span class="enscript-comment">/* can unlock this export's list now */</span>
			lck_mtx_unlock(&amp;ulist-&gt;user_mutex);
		}
	}
        lck_rw_done(&amp;nfsrv_export_rwlock);

	<span class="enscript-comment">/* Free expired nodes */</span>
        <span class="enscript-keyword">while</span> ((unode = LIST_FIRST(&amp;oldlist))) {
		LIST_REMOVE(unode, hash_link);
		FREE(unode, M_TEMP);
	}
}

<span class="enscript-comment">/*
 * Maps errno values to nfs error numbers.
 * Use NFSERR_IO as the catch all for ones not specifically defined in
 * RFC 1094.
 */</span>
<span class="enscript-type">static</span> u_char nfsrv_v2errmap[] = {
  NFSERR_PERM,	NFSERR_NOENT,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_NXIO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_ACCES,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_EXIST,	NFSERR_IO,	NFSERR_NODEV,	NFSERR_NOTDIR,
  NFSERR_ISDIR,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_FBIG,	NFSERR_NOSPC,	NFSERR_IO,	NFSERR_ROFS,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,	NFSERR_IO,
  NFSERR_IO,	NFSERR_IO,	NFSERR_NAMETOL,	NFSERR_IO,	NFSERR_IO,
  NFSERR_NOTEMPTY, NFSERR_IO,	NFSERR_IO,	NFSERR_DQUOT,	NFSERR_STALE,
};

<span class="enscript-comment">/*
 * Maps errno values to nfs error numbers.
 * Although it is not obvious whether or not NFS clients really care if
 * a returned error value is in the specified list for the procedure, the
 * safest thing to do is filter them appropriately. For Version 2, the
 * X/Open XNFS document is the only specification that defines error values
 * for each RPC (The RFC simply lists all possible error values for all RPCs),
 * so I have decided to not do this for Version 2.
 * The first entry is the default error return and the rest are the valid
 * errors for that RPC in increasing numeric order.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_null[] = {
	0,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_getattr[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_setattr[] = {
	NFSERR_IO,
	NFSERR_PERM,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_INVAL,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOT_SYNC,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_lookup[] = {
	NFSERR_IO,
	NFSERR_NOENT,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_NOTDIR,
	NFSERR_NAMETOL,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_access[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_readlink[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_INVAL,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_read[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_NXIO,
	NFSERR_ACCES,
	NFSERR_INVAL,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_write[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_INVAL,
	NFSERR_FBIG,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_create[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_EXIST,
	NFSERR_NOTDIR,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_NAMETOL,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_mkdir[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_EXIST,
	NFSERR_NOTDIR,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_NAMETOL,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_symlink[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_EXIST,
	NFSERR_NOTDIR,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_NAMETOL,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_mknod[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_EXIST,
	NFSERR_NOTDIR,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_NAMETOL,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	NFSERR_BADTYPE,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_remove[] = {
	NFSERR_IO,
	NFSERR_NOENT,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_NOTDIR,
	NFSERR_ROFS,
	NFSERR_NAMETOL,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_rmdir[] = {
	NFSERR_IO,
	NFSERR_NOENT,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_EXIST,
	NFSERR_NOTDIR,
	NFSERR_INVAL,
	NFSERR_ROFS,
	NFSERR_NAMETOL,
	NFSERR_NOTEMPTY,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_rename[] = {
	NFSERR_IO,
	NFSERR_NOENT,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_EXIST,
	NFSERR_XDEV,
	NFSERR_NOTDIR,
	NFSERR_ISDIR,
	NFSERR_INVAL,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_MLINK,
	NFSERR_NAMETOL,
	NFSERR_NOTEMPTY,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_link[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_EXIST,
	NFSERR_XDEV,
	NFSERR_NOTDIR,
	NFSERR_INVAL,
	NFSERR_NOSPC,
	NFSERR_ROFS,
	NFSERR_MLINK,
	NFSERR_NAMETOL,
	NFSERR_DQUOT,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_NOTSUPP,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_readdir[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_NOTDIR,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_BAD_COOKIE,
	NFSERR_TOOSMALL,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_readdirplus[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_ACCES,
	NFSERR_NOTDIR,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_BAD_COOKIE,
	NFSERR_NOTSUPP,
	NFSERR_TOOSMALL,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_fsstat[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_fsinfo[] = {
	NFSERR_STALE,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_pathconf[] = {
	NFSERR_STALE,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> nfsv3err_commit[] = {
	NFSERR_IO,
	NFSERR_IO,
	NFSERR_STALE,
	NFSERR_BADHANDLE,
	NFSERR_SERVERFAULT,
	NFSERR_TRYLATER,
	0,
};

<span class="enscript-type">static</span> <span class="enscript-type">short</span> *nfsrv_v3errmap[] = {
	nfsv3err_null,
	nfsv3err_getattr,
	nfsv3err_setattr,
	nfsv3err_lookup,
	nfsv3err_access,
	nfsv3err_readlink,
	nfsv3err_read,
	nfsv3err_write,
	nfsv3err_create,
	nfsv3err_mkdir,
	nfsv3err_symlink,
	nfsv3err_mknod,
	nfsv3err_remove,
	nfsv3err_rmdir,
	nfsv3err_rename,
	nfsv3err_link,
	nfsv3err_readdir,
	nfsv3err_readdirplus,
	nfsv3err_fsstat,
	nfsv3err_fsinfo,
	nfsv3err_pathconf,
	nfsv3err_commit,
};

<span class="enscript-comment">/*
 * Map errnos to NFS error numbers. For Version 3 also filter out error
 * numbers not specified for the associated procedure.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_errmap</span>(<span class="enscript-type">struct</span> nfsrv_descript *nd, <span class="enscript-type">int</span> err)
{
	<span class="enscript-type">short</span> *defaulterrp, *errp;

	<span class="enscript-keyword">if</span> (nd-&gt;nd_vers == NFS_VER2) {
		<span class="enscript-keyword">if</span> (err &lt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(nfsrv_v2errmap))
			<span class="enscript-keyword">return</span> ((<span class="enscript-type">int</span>)nfsrv_v2errmap[err - 1]);
		<span class="enscript-keyword">return</span> (NFSERR_IO);
	}
	<span class="enscript-comment">/* NFSv3 */</span>
	<span class="enscript-keyword">if</span> (nd-&gt;nd_procnum &gt; NFSPROC_COMMIT)
		<span class="enscript-keyword">return</span> (err &amp; 0xffff);
	errp = defaulterrp = nfsrv_v3errmap[nd-&gt;nd_procnum];
	<span class="enscript-keyword">while</span> (*++errp) {
		<span class="enscript-keyword">if</span> (*errp == err)
			<span class="enscript-keyword">return</span> (err);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*errp &gt; err)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> ((<span class="enscript-type">int</span>)*defaulterrp);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>

</pre>
<hr />
</body></html>