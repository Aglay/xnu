<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nfs_vfsops.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nfs_vfsops.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfs_vfsops.c	8.12 (Berkeley) 5/20/95
 * FreeBSD-Id: nfs_vfsops.c,v 1.52 1997/11/12 05:42:21 julian Exp $
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span> <span class="enscript-comment">/* for fs rooting to update rootdir in fdp */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/quota.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vmparam.h&gt;</span>

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NO_MOUNT_PRIVATE</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_MOUNT_PRIVATE */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/rpcv2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/krpc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_gss.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsmount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/xdr_subs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsm_subs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsdiskless.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_lock.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_VFS_DBG</span>(...) NFS_DBG(NFS_FAC_VFS, 7, ## __VA_ARGS__)

<span class="enscript-comment">/*
 * NFS client globals
 */</span>

<span class="enscript-type">int</span> nfs_ticks;
<span class="enscript-type">static</span> lck_grp_t *nfs_global_grp, *nfs_mount_grp;
lck_mtx_t *nfs_global_mutex;
uint32_t nfs_fs_attr_bitmap[NFS_ATTR_BITMAP_LEN];
uint32_t nfs_object_attr_bitmap[NFS_ATTR_BITMAP_LEN];
uint32_t nfs_getattr_bitmap[NFS_ATTR_BITMAP_LEN];
<span class="enscript-type">struct</span> nfsclientidlist nfsclientids;

<span class="enscript-comment">/* NFS requests */</span>
<span class="enscript-type">struct</span> nfs_reqqhead nfs_reqq;
lck_grp_t *nfs_request_grp;
lck_mtx_t *nfs_request_mutex;
thread_call_t nfs_request_timer_call;
<span class="enscript-type">int</span> nfs_request_timer_on;
u_int32_t nfs_xid = 0;
u_int32_t nfs_xidwrap = 0;		<span class="enscript-comment">/* to build a (non-wrapping) 64 bit xid */</span>

thread_call_t nfs_buf_timer_call;

<span class="enscript-comment">/* NFSv4 */</span>
lck_grp_t *nfs_open_grp;
uint32_t nfs_open_owner_seqnum = 0;
uint32_t nfs_lock_owner_seqnum = 0;
thread_call_t nfs4_callback_timer_call;
<span class="enscript-type">int</span> nfs4_callback_timer_on = 0;

<span class="enscript-comment">/* nfsiod */</span>
lck_grp_t *nfsiod_lck_grp;
lck_mtx_t *nfsiod_mutex;
<span class="enscript-type">struct</span> nfsiodlist nfsiodfree, nfsiodwork;
<span class="enscript-type">struct</span> nfsiodmountlist nfsiodmounts;
<span class="enscript-type">int</span> nfsiod_thread_count = 0;
<span class="enscript-type">int</span> nfsiod_thread_max = NFS_DEFASYNCTHREAD;
<span class="enscript-type">int</span> nfs_max_async_writes = NFS_DEFMAXASYNCWRITES;

<span class="enscript-type">int</span> nfs_iosize = NFS_IOSIZE;
<span class="enscript-type">int</span> nfs_access_cache_timeout = NFS_MAXATTRTIMO;
<span class="enscript-type">int</span> nfs_access_delete = 1; <span class="enscript-comment">/* too many servers get this wrong - workaround on by default */</span>
<span class="enscript-type">int</span> nfs_access_dotzfs = 1;
<span class="enscript-type">int</span> nfs_access_for_getattr = 0;
<span class="enscript-type">int</span> nfs_allow_async = 0;
<span class="enscript-type">int</span> nfs_statfs_rate_limit = NFS_DEFSTATFSRATELIMIT;
<span class="enscript-type">int</span> nfs_lockd_mounts = 0;
<span class="enscript-type">int</span> nfs_lockd_request_sent = 0;
<span class="enscript-type">int</span> nfs_idmap_ctrl = NFS_IDMAP_CTRL_USE_IDMAP_SERVICE;
<span class="enscript-type">int</span> nfs_callback_port = 0;

<span class="enscript-type">int</span> nfs_tprintf_initial_delay = NFS_TPRINTF_INITIAL_DELAY;
<span class="enscript-type">int</span> nfs_tprintf_delay = NFS_TPRINTF_DELAY;


<span class="enscript-type">int</span>		mountnfs(<span class="enscript-type">char</span> *, mount_t, vfs_context_t, vnode_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_mount_diskless(<span class="enscript-type">struct</span> nfs_dlmount *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, vnode_t *, mount_t *, vfs_context_t);
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NO_MOUNT_PRIVATE</span>)
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_mount_diskless_private(<span class="enscript-type">struct</span> nfs_dlmount *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, <span class="enscript-type">int</span>, vnode_t *, mount_t *, vfs_context_t);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_MOUNT_PRIVATE */</span>
<span class="enscript-type">int</span>		nfs_mount_connect(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">void</span>		nfs_mount_drain_and_cleanup(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">void</span>		nfs_mount_cleanup(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">int</span>		nfs_mountinfo_assemble(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">struct</span> xdrbuf *);
<span class="enscript-type">int</span>		nfs4_mount_update_path_with_symlink(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">struct</span> nfs_fs_path *, uint32_t, fhandle_t *, <span class="enscript-type">int</span> *, fhandle_t *, vfs_context_t);

<span class="enscript-comment">/*
 * NFS VFS operations.
 */</span>
<span class="enscript-type">int</span>	nfs_vfs_mount(mount_t, vnode_t, user_addr_t, vfs_context_t);
<span class="enscript-type">int</span>	nfs_vfs_start(mount_t, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">int</span>	nfs_vfs_unmount(mount_t, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">int</span>	nfs_vfs_root(mount_t, vnode_t *, vfs_context_t);
<span class="enscript-type">int</span>	nfs_vfs_quotactl(mount_t, <span class="enscript-type">int</span>, uid_t, caddr_t, vfs_context_t);
<span class="enscript-type">int</span>	nfs_vfs_getattr(mount_t, <span class="enscript-type">struct</span> vfs_attr *, vfs_context_t);
<span class="enscript-type">int</span>	nfs_vfs_sync(mount_t, <span class="enscript-type">int</span>, vfs_context_t);
<span class="enscript-type">int</span>	nfs_vfs_vget(mount_t, ino64_t, vnode_t *, vfs_context_t);
<span class="enscript-type">int</span>	nfs_vfs_vptofh(vnode_t, <span class="enscript-type">int</span> *, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *, vfs_context_t);
<span class="enscript-type">int</span>	nfs_vfs_fhtovp(mount_t, <span class="enscript-type">int</span>, <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *, vnode_t *, vfs_context_t);
<span class="enscript-type">int</span>	nfs_vfs_init(<span class="enscript-type">struct</span> vfsconf *);
<span class="enscript-type">int</span>	nfs_vfs_sysctl(<span class="enscript-type">int</span> *, u_int, user_addr_t, size_t *, user_addr_t, size_t, vfs_context_t);

<span class="enscript-type">struct</span> vfsops nfs_vfsops = {
	nfs_vfs_mount,
	nfs_vfs_start,
	nfs_vfs_unmount,
	nfs_vfs_root,
	nfs_vfs_quotactl,
	nfs_vfs_getattr,
	nfs_vfs_sync,
	nfs_vfs_vget,
	nfs_vfs_fhtovp,
	nfs_vfs_vptofh,
	nfs_vfs_init,
	nfs_vfs_sysctl,
	NULL,		<span class="enscript-comment">/* setattr */</span>
	{ NULL,		<span class="enscript-comment">/* reserved */</span>
	  NULL,		<span class="enscript-comment">/* reserved */</span>
	  NULL,		<span class="enscript-comment">/* reserved */</span>
	  NULL,		<span class="enscript-comment">/* reserved */</span>
	  NULL,		<span class="enscript-comment">/* reserved */</span>
	  NULL,		<span class="enscript-comment">/* reserved */</span>
	  NULL }	<span class="enscript-comment">/* reserved */</span>
};


<span class="enscript-comment">/*
 * version-specific NFS functions
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs3_mount</span>(<span class="enscript-type">struct</span> nfsmount *, vfs_context_t, nfsnode_t *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs4_mount</span>(<span class="enscript-type">struct</span> nfsmount *, vfs_context_t, nfsnode_t *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs3_fsinfo</span>(<span class="enscript-type">struct</span> nfsmount *, nfsnode_t, vfs_context_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs3_update_statfs</span>(<span class="enscript-type">struct</span> nfsmount *, vfs_context_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs4_update_statfs</span>(<span class="enscript-type">struct</span> nfsmount *, vfs_context_t);
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">QUOTA</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">nfs3_getquota</span>	NULL
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">nfs4_getquota</span>	NULL
#<span class="enscript-reference">else</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs3_getquota</span>(<span class="enscript-type">struct</span> nfsmount *, vfs_context_t, uid_t, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> dqblk *);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs4_getquota</span>(<span class="enscript-type">struct</span> nfsmount *, vfs_context_t, uid_t, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> dqblk *);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span> nfs_funcs nfs3_funcs = {
	nfs3_mount,
	nfs3_update_statfs,
	nfs3_getquota,
	nfs3_access_rpc,
	nfs3_getattr_rpc,
	nfs3_setattr_rpc,
	nfs3_read_rpc_async,
	nfs3_read_rpc_async_finish,
	nfs3_readlink_rpc,
	nfs3_write_rpc_async,
	nfs3_write_rpc_async_finish,
	nfs3_commit_rpc,
	nfs3_lookup_rpc_async,
	nfs3_lookup_rpc_async_finish,
	nfs3_remove_rpc,
	nfs3_rename_rpc,
	nfs3_setlock_rpc,
	nfs3_unlock_rpc,
	nfs3_getlock_rpc
	};
<span class="enscript-type">struct</span> nfs_funcs nfs4_funcs = {
	nfs4_mount,
	nfs4_update_statfs,
	nfs4_getquota,
	nfs4_access_rpc,
	nfs4_getattr_rpc,
	nfs4_setattr_rpc,
	nfs4_read_rpc_async,
	nfs4_read_rpc_async_finish,
	nfs4_readlink_rpc,
	nfs4_write_rpc_async,
	nfs4_write_rpc_async_finish,
	nfs4_commit_rpc,
	nfs4_lookup_rpc_async,
	nfs4_lookup_rpc_async_finish,
	nfs4_remove_rpc,
	nfs4_rename_rpc,
	nfs4_setlock_rpc,
	nfs4_unlock_rpc,
	nfs4_getlock_rpc
	};

<span class="enscript-comment">/*
 * Called once to initialize data structures...
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vfs_init</span>(__unused <span class="enscript-type">struct</span> vfsconf *vfsp)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-comment">/*
	 * Check to see if major data structures haven't bloated.
	 */</span>
	<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nfsnode) &gt; NFS_NODEALLOC) {
		printf(<span class="enscript-string">&quot;struct nfsnode bloated (&gt; %dbytes)\n&quot;</span>, NFS_NODEALLOC);
		printf(<span class="enscript-string">&quot;Try reducing NFS_SMALLFH\n&quot;</span>);
	}
	<span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nfsmount) &gt; NFS_MNTALLOC)
		printf(<span class="enscript-string">&quot;struct nfsmount bloated (&gt; %dbytes)\n&quot;</span>, NFS_MNTALLOC);

	nfs_ticks = (hz * NFS_TICKINTVL + 500) / 1000;
	<span class="enscript-keyword">if</span> (nfs_ticks &lt; 1)
		nfs_ticks = 1;

	<span class="enscript-comment">/* init async I/O thread pool state */</span>
	TAILQ_INIT(&amp;nfsiodfree);
	TAILQ_INIT(&amp;nfsiodwork);
	TAILQ_INIT(&amp;nfsiodmounts);
	nfsiod_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;nfsiod&quot;</span>, LCK_GRP_ATTR_NULL);
	nfsiod_mutex = lck_mtx_alloc_init(nfsiod_lck_grp, LCK_ATTR_NULL);

	<span class="enscript-comment">/* init lock groups, etc. */</span>
	nfs_mount_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;nfs_mount&quot;</span>, LCK_GRP_ATTR_NULL);
	nfs_open_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;nfs_open&quot;</span>, LCK_GRP_ATTR_NULL);
	nfs_global_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;nfs_global&quot;</span>, LCK_GRP_ATTR_NULL);

	nfs_global_mutex = lck_mtx_alloc_init(nfs_global_grp, LCK_ATTR_NULL);

	<span class="enscript-comment">/* init request list mutex */</span>
	nfs_request_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;nfs_request&quot;</span>, LCK_GRP_ATTR_NULL);
	nfs_request_mutex = lck_mtx_alloc_init(nfs_request_grp, LCK_ATTR_NULL);

	<span class="enscript-comment">/* initialize NFS request list */</span>
	TAILQ_INIT(&amp;nfs_reqq);

	nfs_nbinit();			<span class="enscript-comment">/* Init the nfsbuf table */</span>
	nfs_nhinit();			<span class="enscript-comment">/* Init the nfsnode table */</span>
	nfs_lockinit();			<span class="enscript-comment">/* Init the nfs lock state */</span>
	nfs_gss_init();			<span class="enscript-comment">/* Init RPCSEC_GSS security */</span>

	<span class="enscript-comment">/* NFSv4 stuff */</span>
	NFS4_PER_FS_ATTRIBUTES(nfs_fs_attr_bitmap);
	NFS4_PER_OBJECT_ATTRIBUTES(nfs_object_attr_bitmap);
	NFS4_DEFAULT_ATTRIBUTES(nfs_getattr_bitmap);
	<span class="enscript-keyword">for</span> (i=0; i &lt; NFS_ATTR_BITMAP_LEN; i++)
		nfs_getattr_bitmap[i] &amp;= nfs_object_attr_bitmap[i];
	TAILQ_INIT(&amp;nfsclientids);

	<span class="enscript-comment">/* initialize NFS timer callouts */</span>
	nfs_request_timer_call = thread_call_allocate(nfs_request_timer, NULL);
	nfs_buf_timer_call = thread_call_allocate(nfs_buf_timer, NULL);
	nfs4_callback_timer_call = thread_call_allocate(nfs4_callback_timer, NULL);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * nfs statfs call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_update_statfs</span>(<span class="enscript-type">struct</span> nfsmount *nmp, vfs_context_t ctx)
{
	nfsnode_t np;
	<span class="enscript-type">int</span> error = 0, lockerror, status, nfsvers;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	uint32_t val = 0;

	nfsvers = nmp-&gt;nm_vers;
	np = nmp-&gt;nm_dnp;
	<span class="enscript-keyword">if</span> (!np)
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> ((error = vnode_get(NFSTOV(np))))
		<span class="enscript-keyword">return</span> (error);

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_build_alloc_init(error, &amp;nmreq, NFSX_FH(nfsvers));
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfs_request2(np, NULL, &amp;nmreq, NFSPROC_FSSTAT, vfs_context_thread(ctx),
		vfs_context_ucred(ctx), NULL, R_SOFT, &amp;nmrep, &amp;xid, &amp;status);
	<span class="enscript-keyword">if</span> (error == ETIMEDOUT)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3)
		nfsm_chain_postop_attr_update(error, &amp;nmrep, np, &amp;xid);
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	<span class="enscript-keyword">if</span> (!error)
		error = status;
	nfsm_assert(error, NFSTONMP(np), ENXIO);
	nfsmout_if(error);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_SPACE_TOTAL);
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_SPACE_FREE);
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_SPACE_AVAIL);
	<span class="enscript-keyword">if</span> (nfsvers == NFS_VER3) {
		NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_FILES_AVAIL);
		NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_FILES_TOTAL);
		NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_FILES_FREE);
		nmp-&gt;nm_fsattr.nfsa_bsize = NFS_FABLKSIZE;
		nfsm_chain_get_64(error, &amp;nmrep, nmp-&gt;nm_fsattr.nfsa_space_total);
		nfsm_chain_get_64(error, &amp;nmrep, nmp-&gt;nm_fsattr.nfsa_space_free);
		nfsm_chain_get_64(error, &amp;nmrep, nmp-&gt;nm_fsattr.nfsa_space_avail);
		nfsm_chain_get_64(error, &amp;nmrep, nmp-&gt;nm_fsattr.nfsa_files_total);
		nfsm_chain_get_64(error, &amp;nmrep, nmp-&gt;nm_fsattr.nfsa_files_free);
		nfsm_chain_get_64(error, &amp;nmrep, nmp-&gt;nm_fsattr.nfsa_files_avail);
		<span class="enscript-comment">// skip invarsec
</span>	} <span class="enscript-keyword">else</span> {
		nfsm_chain_adv(error, &amp;nmrep, NFSX_UNSIGNED); <span class="enscript-comment">// skip tsize?
</span>		nfsm_chain_get_32(error, &amp;nmrep, nmp-&gt;nm_fsattr.nfsa_bsize);
		nfsm_chain_get_32(error, &amp;nmrep, val);
		nfsmout_if(error);
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_fsattr.nfsa_bsize &lt;= 0)
			nmp-&gt;nm_fsattr.nfsa_bsize = NFS_FABLKSIZE;
		nmp-&gt;nm_fsattr.nfsa_space_total = (uint64_t)val * nmp-&gt;nm_fsattr.nfsa_bsize;
		nfsm_chain_get_32(error, &amp;nmrep, val);
		nfsmout_if(error);
		nmp-&gt;nm_fsattr.nfsa_space_free = (uint64_t)val * nmp-&gt;nm_fsattr.nfsa_bsize;
		nfsm_chain_get_32(error, &amp;nmrep, val);
		nfsmout_if(error);
		nmp-&gt;nm_fsattr.nfsa_space_avail = (uint64_t)val * nmp-&gt;nm_fsattr.nfsa_bsize;
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	vnode_put(NFSTOV(np));
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_update_statfs</span>(<span class="enscript-type">struct</span> nfsmount *nmp, vfs_context_t ctx)
{
	nfsnode_t np;
	<span class="enscript-type">int</span> error = 0, lockerror, status, nfsvers, numops;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	uint32_t bitmap[NFS_ATTR_BITMAP_LEN];
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	nfsvers = nmp-&gt;nm_vers;
	np = nmp-&gt;nm_dnp;
	<span class="enscript-keyword">if</span> (!np)
		<span class="enscript-keyword">return</span> (ENXIO);
	<span class="enscript-keyword">if</span> ((error = vnode_get(NFSTOV(np))))
		<span class="enscript-keyword">return</span> (error);

	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	NVATTR_INIT(&amp;nvattr);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH + GETATTR
</span>	numops = 2;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 15 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;statfs&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	NFS_COPY_ATTRIBUTES(nfs_getattr_bitmap, bitmap);
	NFS4_STATFS_ATTRIBUTES(bitmap);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, bitmap, nmp, np);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request2(np, NULL, &amp;nmreq, NFSPROC4_COMPOUND,
		vfs_context_thread(ctx), vfs_context_ucred(ctx),
		NULL, R_SOFT, &amp;nmrep, &amp;xid, &amp;status);
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsm_assert(error, NFSTONMP(np), ENXIO);
	nfsmout_if(error);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	error = nfs4_parsefattr(&amp;nmrep, &amp;nmp-&gt;nm_fsattr, &amp;nvattr, NULL, NULL, NULL);
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	<span class="enscript-keyword">if</span> (!error)
		nfs_loadattrcache(np, &amp;nvattr, &amp;xid, 0);
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	nfsm_assert(error, NFSTONMP(np), ENXIO);
	nfsmout_if(error);
	nmp-&gt;nm_fsattr.nfsa_bsize = NFS_FABLKSIZE;
<span class="enscript-reference">nfsmout</span>:
	NVATTR_CLEANUP(&amp;nvattr);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	vnode_put(NFSTOV(np));
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * The NFS VFS_GETATTR function: &quot;statfs&quot;-type information is retrieved
 * using the nf_update_statfs() function, and other attributes are cobbled
 * together from whatever sources we can (getattr, fsinfo, pathconf).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vfs_getattr</span>(mount_t mp, <span class="enscript-type">struct</span> vfs_attr *fsap, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	uint32_t bsize;
	<span class="enscript-type">int</span> error = 0, nfsvers;

	nmp = VFSTONFS(mp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(fsap, f_bsize)  ||
	    VFSATTR_IS_ACTIVE(fsap, f_iosize) ||
	    VFSATTR_IS_ACTIVE(fsap, f_blocks) ||
	    VFSATTR_IS_ACTIVE(fsap, f_bfree)  ||
	    VFSATTR_IS_ACTIVE(fsap, f_bavail) ||
	    VFSATTR_IS_ACTIVE(fsap, f_bused)  ||
	    VFSATTR_IS_ACTIVE(fsap, f_files)  ||
	    VFSATTR_IS_ACTIVE(fsap, f_ffree)) {
		<span class="enscript-type">int</span> statfsrate = nfs_statfs_rate_limit;
		<span class="enscript-type">int</span> refresh = 1;

		<span class="enscript-comment">/*
		 * Are we rate-limiting statfs RPCs?
		 * (Treat values less than 1 or greater than 1,000,000 as no limit.)
		 */</span>
		<span class="enscript-keyword">if</span> ((statfsrate &gt; 0) &amp;&amp; (statfsrate &lt; 1000000)) {
			<span class="enscript-type">struct</span> timeval now;
			uint32_t stamp;

			microuptime(&amp;now);
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			stamp = (now.tv_sec * statfsrate) + (now.tv_usec / (1000000/statfsrate));
			<span class="enscript-keyword">if</span> (stamp != nmp-&gt;nm_fsattrstamp) {
				refresh = 1;
				nmp-&gt;nm_fsattrstamp = stamp;
			} <span class="enscript-keyword">else</span> {
				refresh = 0;
			}
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		}

		<span class="enscript-keyword">if</span> (refresh &amp;&amp; !nfs_use_cache(nmp))
			error = nmp-&gt;nm_funcs-&gt;nf_update_statfs(nmp, ctx);
		<span class="enscript-keyword">if</span> ((error == ESTALE) || (error == ETIMEDOUT))
			error = 0;
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);

		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		VFSATTR_RETURN(fsap, f_iosize, nfs_iosize);
		VFSATTR_RETURN(fsap, f_bsize, nmp-&gt;nm_fsattr.nfsa_bsize);
		bsize = nmp-&gt;nm_fsattr.nfsa_bsize;
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_SPACE_TOTAL))
			VFSATTR_RETURN(fsap, f_blocks, nmp-&gt;nm_fsattr.nfsa_space_total / bsize);
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_SPACE_FREE))
			VFSATTR_RETURN(fsap, f_bfree, nmp-&gt;nm_fsattr.nfsa_space_free / bsize);
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_SPACE_AVAIL))
			VFSATTR_RETURN(fsap, f_bavail, nmp-&gt;nm_fsattr.nfsa_space_avail / bsize);
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_SPACE_TOTAL) &amp;&amp;
		    NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_SPACE_FREE))
			VFSATTR_RETURN(fsap, f_bused,
				(nmp-&gt;nm_fsattr.nfsa_space_total / bsize) -
				(nmp-&gt;nm_fsattr.nfsa_space_free / bsize));
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_FILES_TOTAL))
			VFSATTR_RETURN(fsap, f_files, nmp-&gt;nm_fsattr.nfsa_files_total);
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_FILES_FREE))
			VFSATTR_RETURN(fsap, f_ffree, nmp-&gt;nm_fsattr.nfsa_files_free);
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	}

	<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(fsap, f_capabilities)) {
		u_int32_t caps, valid;
		nfsnode_t np = nmp-&gt;nm_dnp;

		nfsm_assert(error, VFSTONFS(mp) &amp;&amp; np, ENXIO);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);

		<span class="enscript-comment">/*
		 * The capabilities[] array defines what this volume supports.
		 *
		 * The valid[] array defines which bits this code understands
		 * the meaning of (whether the volume has that capability or not).
		 * Any zero bits here means &quot;I don't know what you're asking about&quot;
		 * and the caller cannot tell whether that capability is
		 * present or not.
		 */</span>
		caps = valid = 0;
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_SYMLINK_SUPPORT)) {
			valid |= VOL_CAP_FMT_SYMBOLICLINKS;
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_SYMLINK)
				caps |= VOL_CAP_FMT_SYMBOLICLINKS;
		}
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_LINK_SUPPORT)) {
			valid |= VOL_CAP_FMT_HARDLINKS;
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_LINK)
				caps |= VOL_CAP_FMT_HARDLINKS;
		}
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_CASE_INSENSITIVE)) {
			valid |= VOL_CAP_FMT_CASE_SENSITIVE;
			<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_CASE_INSENSITIVE))
				caps |= VOL_CAP_FMT_CASE_SENSITIVE;
		}
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_CASE_PRESERVING)) {
			valid |= VOL_CAP_FMT_CASE_PRESERVING;
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_CASE_PRESERVING)
				caps |= VOL_CAP_FMT_CASE_PRESERVING;
		}
		<span class="enscript-comment">/* Note: VOL_CAP_FMT_2TB_FILESIZE is actually used to test for &quot;large file support&quot; */</span>
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_MAXFILESIZE)) {
			<span class="enscript-comment">/* Is server's max file size at least 4GB? */</span>
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_fsattr.nfsa_maxfilesize &gt;= 0x100000000ULL)
				caps |= VOL_CAP_FMT_2TB_FILESIZE;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nfsvers &gt;= NFS_VER3) {
			<span class="enscript-comment">/*
			 * NFSv3 and up supports 64 bits of file size.
			 * So, we'll just assume maxfilesize &gt;= 4GB
			 */</span>
			caps |= VOL_CAP_FMT_2TB_FILESIZE;
		}
		<span class="enscript-keyword">if</span> (nfsvers &gt;= NFS_VER4) {
			caps |= VOL_CAP_FMT_HIDDEN_FILES;
			valid |= VOL_CAP_FMT_HIDDEN_FILES;
			<span class="enscript-comment">// VOL_CAP_FMT_OPENDENYMODES
</span><span class="enscript-comment">//			caps |= VOL_CAP_FMT_OPENDENYMODES;
</span><span class="enscript-comment">//			valid |= VOL_CAP_FMT_OPENDENYMODES;
</span>		}
		fsap-&gt;f_capabilities.capabilities[VOL_CAPABILITIES_FORMAT] =
			<span class="enscript-comment">// VOL_CAP_FMT_PERSISTENTOBJECTIDS |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_SYMBOLICLINKS |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_HARDLINKS |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_JOURNAL |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_JOURNAL_ACTIVE |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_NO_ROOT_TIMES |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_SPARSE_FILES |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_ZERO_RUNS |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_CASE_SENSITIVE |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_CASE_PRESERVING |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_FAST_STATFS |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_2TB_FILESIZE |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_OPENDENYMODES |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_HIDDEN_FILES |
</span>			caps;
		fsap-&gt;f_capabilities.valid[VOL_CAPABILITIES_FORMAT] =
			VOL_CAP_FMT_PERSISTENTOBJECTIDS |
			<span class="enscript-comment">// VOL_CAP_FMT_SYMBOLICLINKS |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_HARDLINKS |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_JOURNAL |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_JOURNAL_ACTIVE |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_NO_ROOT_TIMES |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_SPARSE_FILES |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_ZERO_RUNS |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_CASE_SENSITIVE |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_CASE_PRESERVING |
</span>			VOL_CAP_FMT_FAST_STATFS |
			VOL_CAP_FMT_2TB_FILESIZE |
			<span class="enscript-comment">// VOL_CAP_FMT_OPENDENYMODES |
</span>			<span class="enscript-comment">// VOL_CAP_FMT_HIDDEN_FILES |
</span>			valid;

		<span class="enscript-comment">/*
		 * We don't support most of the interfaces.
		 *
		 * We MAY support locking, but we don't have any easy way of probing.
		 * We can tell if there's no lockd running or if locks have been
		 * disabled for a mount, so we can definitely answer NO in that case.
		 * Any attempt to send a request to lockd to test for locking support
		 * may cause the lazily-launched locking daemons to be started
		 * unnecessarily.  So we avoid that.  However, we do record if we ever
		 * successfully perform a lock operation on a mount point, so if it
		 * looks like lock ops have worked, we do report that we support them.
		 */</span>
		caps = valid = 0;
		<span class="enscript-keyword">if</span> (nfsvers &gt;= NFS_VER4) {
			caps = VOL_CAP_INT_ADVLOCK | VOL_CAP_INT_FLOCK;
			valid = VOL_CAP_INT_ADVLOCK | VOL_CAP_INT_FLOCK;
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_ACL)
				caps |= VOL_CAP_INT_EXTENDED_SECURITY;
			valid |= VOL_CAP_INT_EXTENDED_SECURITY;
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR)
				caps |= VOL_CAP_INT_EXTENDED_ATTR;
			valid |= VOL_CAP_INT_EXTENDED_ATTR;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NAMEDSTREAMS</span>
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_NAMED_ATTR)
				caps |= VOL_CAP_INT_NAMEDSTREAMS;
			valid |= VOL_CAP_INT_NAMEDSTREAMS;
#<span class="enscript-reference">endif</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nmp-&gt;nm_lockmode == NFS_LOCK_MODE_DISABLED) {
			<span class="enscript-comment">/* locks disabled on this mount, so they definitely won't work */</span>
			valid = VOL_CAP_INT_ADVLOCK | VOL_CAP_INT_FLOCK;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; NFSSTA_LOCKSWORK) {
			caps = VOL_CAP_INT_ADVLOCK | VOL_CAP_INT_FLOCK;
			valid = VOL_CAP_INT_ADVLOCK | VOL_CAP_INT_FLOCK;
		}
		fsap-&gt;f_capabilities.capabilities[VOL_CAPABILITIES_INTERFACES] =
			<span class="enscript-comment">// VOL_CAP_INT_SEARCHFS |
</span>			<span class="enscript-comment">// VOL_CAP_INT_ATTRLIST |
</span>			<span class="enscript-comment">// VOL_CAP_INT_NFSEXPORT |
</span>			<span class="enscript-comment">// VOL_CAP_INT_READDIRATTR |
</span>			<span class="enscript-comment">// VOL_CAP_INT_EXCHANGEDATA |
</span>			<span class="enscript-comment">// VOL_CAP_INT_COPYFILE |
</span>			<span class="enscript-comment">// VOL_CAP_INT_ALLOCATE |
</span>			<span class="enscript-comment">// VOL_CAP_INT_VOL_RENAME |
</span>			<span class="enscript-comment">// VOL_CAP_INT_ADVLOCK |
</span>			<span class="enscript-comment">// VOL_CAP_INT_FLOCK |
</span>			<span class="enscript-comment">// VOL_CAP_INT_EXTENDED_SECURITY |
</span>			<span class="enscript-comment">// VOL_CAP_INT_USERACCESS |
</span>			<span class="enscript-comment">// VOL_CAP_INT_MANLOCK |
</span>			<span class="enscript-comment">// VOL_CAP_INT_NAMEDSTREAMS |
</span>			<span class="enscript-comment">// VOL_CAP_INT_EXTENDED_ATTR |
</span>			VOL_CAP_INT_REMOTE_EVENT |
			caps;
		fsap-&gt;f_capabilities.valid[VOL_CAPABILITIES_INTERFACES] =
			VOL_CAP_INT_SEARCHFS |
			VOL_CAP_INT_ATTRLIST |
			VOL_CAP_INT_NFSEXPORT |
			VOL_CAP_INT_READDIRATTR |
			VOL_CAP_INT_EXCHANGEDATA |
			VOL_CAP_INT_COPYFILE |
			VOL_CAP_INT_ALLOCATE |
			VOL_CAP_INT_VOL_RENAME |
			<span class="enscript-comment">// VOL_CAP_INT_ADVLOCK |
</span>			<span class="enscript-comment">// VOL_CAP_INT_FLOCK |
</span>			<span class="enscript-comment">// VOL_CAP_INT_EXTENDED_SECURITY |
</span>			<span class="enscript-comment">// VOL_CAP_INT_USERACCESS |
</span>			<span class="enscript-comment">// VOL_CAP_INT_MANLOCK |
</span>			<span class="enscript-comment">// VOL_CAP_INT_NAMEDSTREAMS |
</span>			<span class="enscript-comment">// VOL_CAP_INT_EXTENDED_ATTR |
</span>			VOL_CAP_INT_REMOTE_EVENT |
			valid;

		fsap-&gt;f_capabilities.capabilities[VOL_CAPABILITIES_RESERVED1] = 0;
		fsap-&gt;f_capabilities.valid[VOL_CAPABILITIES_RESERVED1] = 0;

		fsap-&gt;f_capabilities.capabilities[VOL_CAPABILITIES_RESERVED2] = 0;
		fsap-&gt;f_capabilities.valid[VOL_CAPABILITIES_RESERVED2] = 0;

		VFSATTR_SET_SUPPORTED(fsap, f_capabilities);
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	}

	<span class="enscript-keyword">if</span> (VFSATTR_IS_ACTIVE(fsap, f_attributes)) {
		fsap-&gt;f_attributes.validattr.commonattr = 0;
		fsap-&gt;f_attributes.validattr.volattr =
			ATTR_VOL_CAPABILITIES | ATTR_VOL_ATTRIBUTES;
		fsap-&gt;f_attributes.validattr.dirattr = 0;
		fsap-&gt;f_attributes.validattr.fileattr = 0;
		fsap-&gt;f_attributes.validattr.forkattr = 0;

		fsap-&gt;f_attributes.nativeattr.commonattr = 0;
		fsap-&gt;f_attributes.nativeattr.volattr =
			ATTR_VOL_CAPABILITIES | ATTR_VOL_ATTRIBUTES;
		fsap-&gt;f_attributes.nativeattr.dirattr = 0;
		fsap-&gt;f_attributes.nativeattr.fileattr = 0;
		fsap-&gt;f_attributes.nativeattr.forkattr = 0;

		VFSATTR_SET_SUPPORTED(fsap, f_attributes);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs version 3 fsinfo rpc call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_fsinfo</span>(<span class="enscript-type">struct</span> nfsmount *nmp, nfsnode_t np, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error = 0, lockerror, status, nmlocked = 0;
	u_int64_t xid;
	uint32_t val, prefsize, maxsize;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	nfsm_chain_build_alloc_init(error, &amp;nmreq, NFSX_FH(nmp-&gt;nm_vers));
	nfsm_chain_add_fh(error, &amp;nmreq, nmp-&gt;nm_vers, np-&gt;n_fhp, np-&gt;n_fhsize);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfs_request(np, NULL, &amp;nmreq, NFSPROC_FSINFO, ctx, NULL, &amp;nmrep, &amp;xid, &amp;status);
	<span class="enscript-keyword">if</span> ((lockerror = nfs_node_lock(np)))
		error = lockerror;
	nfsm_chain_postop_attr_update(error, &amp;nmrep, np, &amp;xid);
	<span class="enscript-keyword">if</span> (!lockerror)
		nfs_node_unlock(np);
	<span class="enscript-keyword">if</span> (!error)
		error = status;
	nfsmout_if(error);

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	nmlocked = 1;

	nfsm_chain_get_32(error, &amp;nmrep, maxsize);
	nfsm_chain_get_32(error, &amp;nmrep, prefsize);
	nfsmout_if(error);
	nmp-&gt;nm_fsattr.nfsa_maxread = maxsize;
	<span class="enscript-keyword">if</span> (prefsize &lt; nmp-&gt;nm_rsize)
		nmp-&gt;nm_rsize = (prefsize + NFS_FABLKSIZE - 1) &amp;
			~(NFS_FABLKSIZE - 1);
	<span class="enscript-keyword">if</span> ((maxsize &gt; 0) &amp;&amp; (maxsize &lt; nmp-&gt;nm_rsize)) {
		nmp-&gt;nm_rsize = maxsize &amp; ~(NFS_FABLKSIZE - 1);
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_rsize == 0)
			nmp-&gt;nm_rsize = maxsize;
	}
	nfsm_chain_adv(error, &amp;nmrep, NFSX_UNSIGNED); <span class="enscript-comment">// skip rtmult
</span>
	nfsm_chain_get_32(error, &amp;nmrep, maxsize);
	nfsm_chain_get_32(error, &amp;nmrep, prefsize);
	nfsmout_if(error);
	nmp-&gt;nm_fsattr.nfsa_maxwrite = maxsize;
	<span class="enscript-keyword">if</span> (prefsize &lt; nmp-&gt;nm_wsize)
		nmp-&gt;nm_wsize = (prefsize + NFS_FABLKSIZE - 1) &amp;
			~(NFS_FABLKSIZE - 1);
	<span class="enscript-keyword">if</span> ((maxsize &gt; 0) &amp;&amp; (maxsize &lt; nmp-&gt;nm_wsize)) {
		nmp-&gt;nm_wsize = maxsize &amp; ~(NFS_FABLKSIZE - 1);
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_wsize == 0)
			nmp-&gt;nm_wsize = maxsize;
	}
	nfsm_chain_adv(error, &amp;nmrep, NFSX_UNSIGNED); <span class="enscript-comment">// skip wtmult
</span>
	nfsm_chain_get_32(error, &amp;nmrep, prefsize);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> ((prefsize &gt; 0) &amp;&amp; (prefsize &lt; nmp-&gt;nm_readdirsize))
		nmp-&gt;nm_readdirsize = prefsize;
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_fsattr.nfsa_maxread &gt; 0) &amp;&amp;
	    (nmp-&gt;nm_fsattr.nfsa_maxread &lt; nmp-&gt;nm_readdirsize))
		nmp-&gt;nm_readdirsize = nmp-&gt;nm_fsattr.nfsa_maxread;

	nfsm_chain_get_64(error, &amp;nmrep, nmp-&gt;nm_fsattr.nfsa_maxfilesize);

	nfsm_chain_adv(error, &amp;nmrep, 2 * NFSX_UNSIGNED); <span class="enscript-comment">// skip time_delta
</span>
	<span class="enscript-comment">/* convert FS properties to our own flags */</span>
	nfsm_chain_get_32(error, &amp;nmrep, val);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (val &amp; NFSV3FSINFO_LINK)
		nmp-&gt;nm_fsattr.nfsa_flags |= NFS_FSFLAG_LINK;
	<span class="enscript-keyword">if</span> (val &amp; NFSV3FSINFO_SYMLINK)
		nmp-&gt;nm_fsattr.nfsa_flags |= NFS_FSFLAG_SYMLINK;
	<span class="enscript-keyword">if</span> (val &amp; NFSV3FSINFO_HOMOGENEOUS)
		nmp-&gt;nm_fsattr.nfsa_flags |= NFS_FSFLAG_HOMOGENEOUS;
	<span class="enscript-keyword">if</span> (val &amp; NFSV3FSINFO_CANSETTIME)
		nmp-&gt;nm_fsattr.nfsa_flags |= NFS_FSFLAG_SET_TIME;
	nmp-&gt;nm_state |= NFSSTA_GOTFSINFO;
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_MAXREAD);
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_MAXWRITE);
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_MAXFILESIZE);
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_LINK_SUPPORT);
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_SYMLINK_SUPPORT);
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_HOMOGENEOUS);
	NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_CANSETTIME);
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (nmlocked)
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Mount a remote root fs via. nfs. This depends on the info in the
 * nfs_diskless structure that has been filled in properly by some primary
 * bootstrap.
 * It goes something like this:
 * - do enough of &quot;ifconfig&quot; by calling ifioctl() so that the system
 *   can talk to the server
 * - If nfs_diskless.mygateway is filled in, use that address as
 *   a default gateway.
 * - hand craft the swap nfs vnode hanging off a fake mount point
 *	if swdevt[0].sw_dev == NODEV
 * - build the rootfs mount point and call mountnfs() to do the rest.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_mountroot</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> nfs_diskless nd;
	mount_t mp = NULL;
	vnode_t vp = NULL;
	vfs_context_t ctx;
	<span class="enscript-type">int</span> error;
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NO_MOUNT_PRIVATE</span>)
	mount_t mppriv = NULL;
	vnode_t vppriv = NULL;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_MOUNT_PRIVATE */</span>
	<span class="enscript-type">int</span> v3, sotype;

	<span class="enscript-comment">/*
	 * Call nfs_boot_init() to fill in the nfs_diskless struct.
	 * Note: networking must already have been configured before
	 * we're called.
	 */</span>
	bzero((caddr_t) &amp;nd, <span class="enscript-keyword">sizeof</span>(nd));
	error = nfs_boot_init(&amp;nd);
	<span class="enscript-keyword">if</span> (error)
		panic(<span class="enscript-string">&quot;nfs_boot_init: unable to initialize NFS root system information, &quot;</span>
		      <span class="enscript-string">&quot;error %d, check configuration: %s\n&quot;</span>, error, PE_boot_args());

	<span class="enscript-comment">/*
	 * Try NFSv3 first, then fallback to NFSv2.
	 * Likewise, try TCP first, then fall back to UDP.
	 */</span>
	v3 = 1;
	sotype = SOCK_STREAM;

<span class="enscript-reference">tryagain</span>:
	error = nfs_boot_getfh(&amp;nd, v3, sotype);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (error == EHOSTDOWN || error == EHOSTUNREACH) {
			<span class="enscript-keyword">if</span> (nd.nd_root.ndm_mntfrom)
				FREE_ZONE(nd.nd_root.ndm_mntfrom,
					  MAXPATHLEN, M_NAMEI);
			<span class="enscript-keyword">if</span> (nd.nd_root.ndm_path)
				FREE_ZONE(nd.nd_root.ndm_path,
					  MAXPATHLEN, M_NAMEI);
			<span class="enscript-keyword">if</span> (nd.nd_private.ndm_mntfrom)
				FREE_ZONE(nd.nd_private.ndm_mntfrom,
					  MAXPATHLEN, M_NAMEI);
			<span class="enscript-keyword">if</span> (nd.nd_private.ndm_path)
				FREE_ZONE(nd.nd_private.ndm_path,
					  MAXPATHLEN, M_NAMEI);
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">if</span> (v3) {
			<span class="enscript-keyword">if</span> (sotype == SOCK_STREAM) {
				printf(<span class="enscript-string">&quot;NFS mount (v3,TCP) failed with error %d, trying UDP...\n&quot;</span>, error);
				sotype = SOCK_DGRAM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
			}
			printf(<span class="enscript-string">&quot;NFS mount (v3,UDP) failed with error %d, trying v2...\n&quot;</span>, error);
			v3 = 0;
			sotype = SOCK_STREAM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sotype == SOCK_STREAM) {
			printf(<span class="enscript-string">&quot;NFS mount (v2,TCP) failed with error %d, trying UDP...\n&quot;</span>, error);
			sotype = SOCK_DGRAM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
		} <span class="enscript-keyword">else</span> {
			printf(<span class="enscript-string">&quot;NFS mount (v2,UDP) failed with error %d, giving up...\n&quot;</span>, error);
		}
		<span class="enscript-keyword">switch</span>(error) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EPROGUNAVAIL</span>:
			panic(<span class="enscript-string">&quot;NFS mount failed: NFS server mountd not responding, check server configuration: %s&quot;</span>, PE_boot_args());
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EACCES</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EPERM</span>:
			panic(<span class="enscript-string">&quot;NFS mount failed: NFS server refused mount, check server configuration: %s&quot;</span>, PE_boot_args());
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;NFS mount failed with error %d, check configuration: %s&quot;</span>, error, PE_boot_args());
		}
	}

	ctx = vfs_context_kernel();

	<span class="enscript-comment">/*
	 * Create the root mount point.
	 */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NO_MOUNT_PRIVATE</span>)
	{
		<span class="enscript-comment">//PWC hack until we have a real &quot;mount&quot; tool to remount root rw
</span>		<span class="enscript-type">int</span> rw_root=0;
		<span class="enscript-type">int</span> flags = MNT_ROOTFS|MNT_RDONLY;
		PE_parse_boot_argn(<span class="enscript-string">&quot;-rwroot_hack&quot;</span>, &amp;rw_root, <span class="enscript-keyword">sizeof</span> (rw_root));
		<span class="enscript-keyword">if</span>(rw_root)
		{
			flags = MNT_ROOTFS;
			kprintf(<span class="enscript-string">&quot;-rwroot_hack in effect: mounting root fs read/write\n&quot;</span>);
		}
				
	<span class="enscript-keyword">if</span> ((error = nfs_mount_diskless(&amp;nd.nd_root, <span class="enscript-string">&quot;/&quot;</span>, flags, &amp;vp, &amp;mp, ctx)))
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> ((error = nfs_mount_diskless(&amp;nd.nd_root, <span class="enscript-string">&quot;/&quot;</span>, MNT_ROOTFS, &amp;vp, &amp;mp, ctx)))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_MOUNT_PRIVATE */</span>
	{
		<span class="enscript-keyword">if</span> (v3) {
			<span class="enscript-keyword">if</span> (sotype == SOCK_STREAM) {
				printf(<span class="enscript-string">&quot;NFS root mount (v3,TCP) failed with %d, trying UDP...\n&quot;</span>, error);
				sotype = SOCK_DGRAM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
			}
			printf(<span class="enscript-string">&quot;NFS root mount (v3,UDP) failed with %d, trying v2...\n&quot;</span>, error);
			v3 = 0;
			sotype = SOCK_STREAM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sotype == SOCK_STREAM) {
			printf(<span class="enscript-string">&quot;NFS root mount (v2,TCP) failed with %d, trying UDP...\n&quot;</span>, error);
			sotype = SOCK_DGRAM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
		} <span class="enscript-keyword">else</span> {
			printf(<span class="enscript-string">&quot;NFS root mount (v2,UDP) failed with error %d, giving up...\n&quot;</span>, error);
		}
		panic(<span class="enscript-string">&quot;NFS root mount failed with error %d, check configuration: %s\n&quot;</span>, error, PE_boot_args());
	}
	}
	printf(<span class="enscript-string">&quot;root on %s\n&quot;</span>, nd.nd_root.ndm_mntfrom);

	vfs_unbusy(mp);
	mount_list_add(mp);
	rootvp = vp;
	
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NO_MOUNT_PRIVATE</span>)
	<span class="enscript-keyword">if</span> (nd.nd_private.ndm_saddr.sin_addr.s_addr) {
	    error = nfs_mount_diskless_private(&amp;nd.nd_private, <span class="enscript-string">&quot;/private&quot;</span>,
					       0, &amp;vppriv, &amp;mppriv, ctx);
	    <span class="enscript-keyword">if</span> (error)
		panic(<span class="enscript-string">&quot;NFS /private mount failed with error %d, check configuration: %s\n&quot;</span>, error, PE_boot_args());
	    printf(<span class="enscript-string">&quot;private on %s\n&quot;</span>, nd.nd_private.ndm_mntfrom);

	    vfs_unbusy(mppriv);
	    mount_list_add(mppriv);
	}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_MOUNT_PRIVATE */</span>

	<span class="enscript-keyword">if</span> (nd.nd_root.ndm_mntfrom)
		FREE_ZONE(nd.nd_root.ndm_mntfrom, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">if</span> (nd.nd_root.ndm_path)
		FREE_ZONE(nd.nd_root.ndm_path, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">if</span> (nd.nd_private.ndm_mntfrom)
		FREE_ZONE(nd.nd_private.ndm_mntfrom, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">if</span> (nd.nd_private.ndm_path)
		FREE_ZONE(nd.nd_private.ndm_path, MAXPATHLEN, M_NAMEI);

	<span class="enscript-comment">/* Get root attributes (for the time). */</span>
	error = nfs_getattr(VTONFS(vp), NULL, ctx, NGA_UNCACHED);
	<span class="enscript-keyword">if</span> (error)
		panic(<span class="enscript-string">&quot;NFS mount: failed to get attributes for root directory, error %d, check server&quot;</span>, error);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Internal version of mount system call for diskless setup.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_mount_diskless</span>(
	<span class="enscript-type">struct</span> nfs_dlmount *ndmntp,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *mntname,
	<span class="enscript-type">int</span> mntflag,
	vnode_t *vpp,
	mount_t *mpp,
	vfs_context_t ctx)
{
	mount_t mp;
	<span class="enscript-type">int</span> error, numcomps;
	<span class="enscript-type">char</span> *xdrbuf, *p, *cp, *frompath, *endserverp;
	<span class="enscript-type">char</span> uaddr[MAX_IPv4_STR_LEN];
	<span class="enscript-type">struct</span> xdrbuf xb;
	uint32_t mattrs[NFS_MATTR_BITMAP_LEN];
	uint32_t mflags_mask[NFS_MFLAG_BITMAP_LEN];
	uint32_t mflags[NFS_MFLAG_BITMAP_LEN];
	uint32_t argslength_offset, attrslength_offset, end_offset;

	<span class="enscript-keyword">if</span> ((error = vfs_rootmountalloc(<span class="enscript-string">&quot;nfs&quot;</span>, ndmntp-&gt;ndm_mntfrom, &amp;mp))) {
		printf(<span class="enscript-string">&quot;nfs_mount_diskless: NFS not configured\n&quot;</span>);
		<span class="enscript-keyword">return</span> (error);
	}

	mp-&gt;mnt_flag |= mntflag;
	<span class="enscript-keyword">if</span> (!(mntflag &amp; MNT_RDONLY))
		mp-&gt;mnt_flag &amp;= ~MNT_RDONLY;

	<span class="enscript-comment">/* find the server-side path being mounted */</span>
	frompath = ndmntp-&gt;ndm_mntfrom;
	<span class="enscript-keyword">if</span> (*frompath == <span class="enscript-string">'['</span>) {  <span class="enscript-comment">/* skip IPv6 literal address */</span>
		<span class="enscript-keyword">while</span> (*frompath &amp;&amp; (*frompath != <span class="enscript-string">']'</span>))
			frompath++;
		<span class="enscript-keyword">if</span> (*frompath == <span class="enscript-string">']'</span>)
			frompath++;
	}
	<span class="enscript-keyword">while</span> (*frompath &amp;&amp; (*frompath != <span class="enscript-string">':'</span>))
		frompath++;
	endserverp = frompath;
	<span class="enscript-keyword">while</span> (*frompath &amp;&amp; (*frompath == <span class="enscript-string">':'</span>))
		frompath++;
	<span class="enscript-comment">/* count fs location path components */</span>
	p = frompath;
	<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
		p++;
	numcomps = 0;
	<span class="enscript-keyword">while</span> (*p) {
		numcomps++;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p != <span class="enscript-string">'/'</span>))
			p++;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
			p++;
	}

	<span class="enscript-comment">/* convert address to universal address string */</span>
	<span class="enscript-keyword">if</span> (inet_ntop(AF_INET, &amp;ndmntp-&gt;ndm_saddr.sin_addr, uaddr, <span class="enscript-keyword">sizeof</span>(uaddr)) != uaddr) {
		printf(<span class="enscript-string">&quot;nfs_mount_diskless: bad address\n&quot;</span>);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/* prepare mount attributes */</span>
	NFS_BITMAP_ZERO(mattrs, NFS_MATTR_BITMAP_LEN);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_NFS_VERSION);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_SOCKET_TYPE);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_NFS_PORT);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_FH);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_FS_LOCATIONS);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_MNTFLAGS);

	<span class="enscript-comment">/* prepare mount flags */</span>
	NFS_BITMAP_ZERO(mflags_mask, NFS_MFLAG_BITMAP_LEN);
	NFS_BITMAP_ZERO(mflags, NFS_MFLAG_BITMAP_LEN);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_RESVPORT);
	NFS_BITMAP_SET(mflags, NFS_MFLAG_RESVPORT);

	<span class="enscript-comment">/* build xdr buffer */</span>
	xb_init_buffer(&amp;xb, NULL, 0);
	xb_add_32(error, &amp;xb, NFS_ARGSVERSION_XDR);
	argslength_offset = xb_offset(&amp;xb);
	xb_add_32(error, &amp;xb, 0); <span class="enscript-comment">// args length
</span>	xb_add_32(error, &amp;xb, NFS_XDRARGS_VERSION_0);
	xb_add_bitmap(error, &amp;xb, mattrs, NFS_MATTR_BITMAP_LEN);
	attrslength_offset = xb_offset(&amp;xb);
	xb_add_32(error, &amp;xb, 0); <span class="enscript-comment">// attrs length
</span>	xb_add_32(error, &amp;xb, ndmntp-&gt;ndm_nfsv3 ? 3 : 2); <span class="enscript-comment">// NFS version
</span>	xb_add_string(error, &amp;xb, ((ndmntp-&gt;ndm_sotype == SOCK_DGRAM) ? <span class="enscript-string">&quot;udp&quot;</span> : <span class="enscript-string">&quot;tcp&quot;</span>), 3);
	xb_add_32(error, &amp;xb, ntohs(ndmntp-&gt;ndm_saddr.sin_port)); <span class="enscript-comment">// NFS port
</span>	xb_add_fh(error, &amp;xb, &amp;ndmntp-&gt;ndm_fh[0], ndmntp-&gt;ndm_fhlen);
	<span class="enscript-comment">/* fs location */</span>
	xb_add_32(error, &amp;xb, 1); <span class="enscript-comment">/* fs location count */</span>
	xb_add_32(error, &amp;xb, 1); <span class="enscript-comment">/* server count */</span>
	xb_add_string(error, &amp;xb, ndmntp-&gt;ndm_mntfrom, (endserverp - ndmntp-&gt;ndm_mntfrom)); <span class="enscript-comment">/* server name */</span>
	xb_add_32(error, &amp;xb, 1); <span class="enscript-comment">/* address count */</span>
	xb_add_string(error, &amp;xb, uaddr, strlen(uaddr)); <span class="enscript-comment">/* address */</span>
	xb_add_32(error, &amp;xb, 0); <span class="enscript-comment">/* empty server info */</span>
	xb_add_32(error, &amp;xb, numcomps); <span class="enscript-comment">/* pathname component count */</span>
	p = frompath;
	<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
		p++;
	<span class="enscript-keyword">while</span> (*p) {
		cp = p;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p != <span class="enscript-string">'/'</span>))
			p++;
		xb_add_string(error, &amp;xb, cp, (p - cp)); <span class="enscript-comment">/* component */</span>
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
			p++;
	}
	xb_add_32(error, &amp;xb, 0); <span class="enscript-comment">/* empty fsl info */</span>
	xb_add_32(error, &amp;xb, mntflag); <span class="enscript-comment">/* MNT flags */</span>
	xb_build_done(error, &amp;xb);

	<span class="enscript-comment">/* update opaque counts */</span>
	end_offset = xb_offset(&amp;xb);
	<span class="enscript-keyword">if</span> (!error) {
		error = xb_seek(&amp;xb, argslength_offset);
		xb_add_32(error, &amp;xb, end_offset - argslength_offset + XDRWORD<span class="enscript-comment">/*version*/</span>);
	}
	<span class="enscript-keyword">if</span> (!error) {
		error = xb_seek(&amp;xb, attrslength_offset);
		xb_add_32(error, &amp;xb, end_offset - attrslength_offset - XDRWORD<span class="enscript-comment">/*don't include length field*/</span>);
	}
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;nfs_mount_diskless: error %d assembling mount args\n&quot;</span>, error);
		xb_cleanup(&amp;xb);
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-comment">/* grab the assembled buffer */</span>
	xdrbuf = xb_buffer_base(&amp;xb);
	xb.xb_flags &amp;= ~XB_CLEANUP;

	<span class="enscript-comment">/* do the mount */</span>
	<span class="enscript-keyword">if</span> ((error = mountnfs(xdrbuf, mp, ctx, vpp))) {
		printf(<span class="enscript-string">&quot;nfs_mountroot: mount %s failed: %d\n&quot;</span>, mntname, error);
		<span class="enscript-comment">// XXX vfs_rootmountfailed(mp);
</span>		mount_list_lock();
		mp-&gt;mnt_vtable-&gt;vfc_refcount--;
		mount_list_unlock();
		vfs_unbusy(mp);
		mount_lock_destroy(mp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_mount_label_destroy(mp);
#<span class="enscript-reference">endif</span>
		FREE_ZONE(mp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mount), M_MOUNT);
	} <span class="enscript-keyword">else</span> {
		*mpp = mp;
	}
	xb_cleanup(&amp;xb);
	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">NO_MOUNT_PRIVATE</span>)
<span class="enscript-comment">/*
 * Internal version of mount system call to mount &quot;/private&quot;
 * separately in diskless setup
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_mount_diskless_private</span>(
	<span class="enscript-type">struct</span> nfs_dlmount *ndmntp,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *mntname,
	<span class="enscript-type">int</span> mntflag,
	vnode_t *vpp,
	mount_t *mpp,
	vfs_context_t ctx)
{
	mount_t mp;
	<span class="enscript-type">int</span> error, numcomps;
	proc_t procp;
	<span class="enscript-type">struct</span> vfstable *vfsp;
	<span class="enscript-type">struct</span> nameidata nd;
	vnode_t vp;
	<span class="enscript-type">char</span> *xdrbuf = NULL, *p, *cp, *frompath, *endserverp;
	<span class="enscript-type">char</span> uaddr[MAX_IPv4_STR_LEN];
	<span class="enscript-type">struct</span> xdrbuf xb;
	uint32_t mattrs[NFS_MATTR_BITMAP_LEN];
	uint32_t mflags_mask[NFS_MFLAG_BITMAP_LEN], mflags[NFS_MFLAG_BITMAP_LEN];
	uint32_t argslength_offset, attrslength_offset, end_offset;

	procp = current_proc(); <span class="enscript-comment">/* XXX */</span>
	xb_init(&amp;xb, 0);

	{
	<span class="enscript-comment">/*
	 * mimic main()!. Temporarily set up rootvnode and other stuff so
	 * that namei works. Need to undo this because main() does it, too
	 */</span>
		<span class="enscript-type">struct</span> filedesc *fdp;	<span class="enscript-comment">/* pointer to file descriptor state */</span>
		fdp = procp-&gt;p_fd;
		mountlist.tqh_first-&gt;mnt_flag |= MNT_ROOTFS;

		<span class="enscript-comment">/* Get the vnode for '/'. Set fdp-&gt;fd_cdir to reference it. */</span>
		<span class="enscript-keyword">if</span> (VFS_ROOT(mountlist.tqh_first, &amp;rootvnode, NULL))
			panic(<span class="enscript-string">&quot;cannot find root vnode&quot;</span>);
		error = vnode_ref(rootvnode);
		<span class="enscript-keyword">if</span> (error) {
			printf(<span class="enscript-string">&quot;nfs_mountroot: vnode_ref() failed on root vnode!\n&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		fdp-&gt;fd_cdir = rootvnode;
		fdp-&gt;fd_rdir = NULL;
	}

	<span class="enscript-comment">/*
	 * Get vnode to be covered
	 */</span>
	NDINIT(&amp;nd, LOOKUP, OP_LOOKUP, FOLLOW | LOCKLEAF, UIO_SYSSPACE,
	    CAST_USER_ADDR_T(mntname), ctx);
	<span class="enscript-keyword">if</span> ((error = namei(&amp;nd))) {
		printf(<span class="enscript-string">&quot;nfs_mountroot: private namei failed!\n&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	{
		<span class="enscript-comment">/* undo vnode_ref() in mimic main()! */</span>
		vnode_rele(rootvnode);
	}
	nameidone(&amp;nd);
	vp = nd.ni_vp;

	<span class="enscript-keyword">if</span> ((error = VNOP_FSYNC(vp, MNT_WAIT, ctx)) ||
	    (error = buf_invalidateblks(vp, BUF_WRITE_DATA, 0, 0))) {
		vnode_put(vp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (vnode_vtype(vp) != VDIR) {
		vnode_put(vp);
		error = ENOTDIR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">for</span> (vfsp = vfsconf; vfsp; vfsp = vfsp-&gt;vfc_next)
		<span class="enscript-keyword">if</span> (!strncmp(vfsp-&gt;vfc_name, <span class="enscript-string">&quot;nfs&quot;</span>, <span class="enscript-keyword">sizeof</span>(vfsp-&gt;vfc_name)))
			<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">if</span> (vfsp == NULL) {
		printf(<span class="enscript-string">&quot;nfs_mountroot: private NFS not configured\n&quot;</span>);
		vnode_put(vp);
		error = ENODEV;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (vnode_mountedhere(vp) != NULL) {
		vnode_put(vp);
		error = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Allocate and initialize the filesystem.
	 */</span>
	mp = _MALLOC_ZONE((u_int32_t)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mount), M_MOUNT, M_WAITOK);
	<span class="enscript-keyword">if</span> (!mp) {
		printf(<span class="enscript-string">&quot;nfs_mountroot: unable to allocate mount structure\n&quot;</span>);
		vnode_put(vp);
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	bzero((<span class="enscript-type">char</span> *)mp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> mount));

	<span class="enscript-comment">/* Initialize the default IO constraints */</span>
	mp-&gt;mnt_maxreadcnt = mp-&gt;mnt_maxwritecnt = MAXPHYS;
	mp-&gt;mnt_segreadcnt = mp-&gt;mnt_segwritecnt = 32;
	mp-&gt;mnt_ioflags = 0;
	mp-&gt;mnt_realrootvp = NULLVP;
	mp-&gt;mnt_authcache_ttl = CACHED_LOOKUP_RIGHT_TTL;

	mount_lock_init(mp);
	TAILQ_INIT(&amp;mp-&gt;mnt_vnodelist);
	TAILQ_INIT(&amp;mp-&gt;mnt_workerqueue);
	TAILQ_INIT(&amp;mp-&gt;mnt_newvnodes);
	(<span class="enscript-type">void</span>)vfs_busy(mp, LK_NOWAIT);
	TAILQ_INIT(&amp;mp-&gt;mnt_vnodelist);
	mount_list_lock();
	vfsp-&gt;vfc_refcount++;
	mount_list_unlock();
	mp-&gt;mnt_vtable = vfsp;
	mp-&gt;mnt_op = vfsp-&gt;vfc_vfsops;
	<span class="enscript-comment">// mp-&gt;mnt_stat.f_type = vfsp-&gt;vfc_typenum;
</span>	mp-&gt;mnt_flag = mntflag;
	mp-&gt;mnt_flag |= vfsp-&gt;vfc_flags &amp; MNT_VISFLAGMASK;
	strncpy(mp-&gt;mnt_vfsstat.f_fstypename, vfsp-&gt;vfc_name, MFSNAMELEN-1);
	vp-&gt;v_mountedhere = mp;
	mp-&gt;mnt_vnodecovered = vp;
	vp = NULLVP;
	mp-&gt;mnt_vfsstat.f_owner = kauth_cred_getuid(kauth_cred_get());
	(<span class="enscript-type">void</span>) copystr(mntname, mp-&gt;mnt_vfsstat.f_mntonname, MAXPATHLEN - 1, 0);
	(<span class="enscript-type">void</span>) copystr(ndmntp-&gt;ndm_mntfrom, mp-&gt;mnt_vfsstat.f_mntfromname, MAXPATHLEN - 1, 0);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_mount_label_init(mp);
	mac_mount_label_associate(ctx, mp);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* find the server-side path being mounted */</span>
	frompath = ndmntp-&gt;ndm_mntfrom;
	<span class="enscript-keyword">if</span> (*frompath == <span class="enscript-string">'['</span>) {  <span class="enscript-comment">/* skip IPv6 literal address */</span>
		<span class="enscript-keyword">while</span> (*frompath &amp;&amp; (*frompath != <span class="enscript-string">']'</span>))
			frompath++;
		<span class="enscript-keyword">if</span> (*frompath == <span class="enscript-string">']'</span>)
			frompath++;
	}
	<span class="enscript-keyword">while</span> (*frompath &amp;&amp; (*frompath != <span class="enscript-string">':'</span>))
		frompath++;
	endserverp = frompath;
	<span class="enscript-keyword">while</span> (*frompath &amp;&amp; (*frompath == <span class="enscript-string">':'</span>))
		frompath++;
	<span class="enscript-comment">/* count fs location path components */</span>
	p = frompath;
	<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
		p++;
	numcomps = 0;
	<span class="enscript-keyword">while</span> (*p) {
		numcomps++;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p != <span class="enscript-string">'/'</span>))
			p++;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
			p++;
	}

	<span class="enscript-comment">/* convert address to universal address string */</span>
	<span class="enscript-keyword">if</span> (inet_ntop(AF_INET, &amp;ndmntp-&gt;ndm_saddr.sin_addr, uaddr, <span class="enscript-keyword">sizeof</span>(uaddr)) != uaddr) {
		printf(<span class="enscript-string">&quot;nfs_mountroot: bad address\n&quot;</span>);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* prepare mount attributes */</span>
	NFS_BITMAP_ZERO(mattrs, NFS_MATTR_BITMAP_LEN);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_NFS_VERSION);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_SOCKET_TYPE);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_NFS_PORT);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_FH);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_FS_LOCATIONS);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_MNTFLAGS);

	<span class="enscript-comment">/* prepare mount flags */</span>
	NFS_BITMAP_ZERO(mflags_mask, NFS_MFLAG_BITMAP_LEN);
	NFS_BITMAP_ZERO(mflags, NFS_MFLAG_BITMAP_LEN);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_RESVPORT);
	NFS_BITMAP_SET(mflags, NFS_MFLAG_RESVPORT);

	<span class="enscript-comment">/* build xdr buffer */</span>
	xb_init_buffer(&amp;xb, NULL, 0);
	xb_add_32(error, &amp;xb, NFS_ARGSVERSION_XDR);
	argslength_offset = xb_offset(&amp;xb);
	xb_add_32(error, &amp;xb, 0); <span class="enscript-comment">// args length
</span>	xb_add_32(error, &amp;xb, NFS_XDRARGS_VERSION_0);
	xb_add_bitmap(error, &amp;xb, mattrs, NFS_MATTR_BITMAP_LEN);
	attrslength_offset = xb_offset(&amp;xb);
	xb_add_32(error, &amp;xb, 0); <span class="enscript-comment">// attrs length
</span>	xb_add_32(error, &amp;xb, ndmntp-&gt;ndm_nfsv3 ? 3 : 2); <span class="enscript-comment">// NFS version
</span>	xb_add_string(error, &amp;xb, ((ndmntp-&gt;ndm_sotype == SOCK_DGRAM) ? <span class="enscript-string">&quot;udp&quot;</span> : <span class="enscript-string">&quot;tcp&quot;</span>), 3);
	xb_add_32(error, &amp;xb, ntohs(ndmntp-&gt;ndm_saddr.sin_port)); <span class="enscript-comment">// NFS port
</span>	xb_add_fh(error, &amp;xb, &amp;ndmntp-&gt;ndm_fh[0], ndmntp-&gt;ndm_fhlen);
	<span class="enscript-comment">/* fs location */</span>
	xb_add_32(error, &amp;xb, 1); <span class="enscript-comment">/* fs location count */</span>
	xb_add_32(error, &amp;xb, 1); <span class="enscript-comment">/* server count */</span>
	xb_add_string(error, &amp;xb, ndmntp-&gt;ndm_mntfrom, (endserverp - ndmntp-&gt;ndm_mntfrom)); <span class="enscript-comment">/* server name */</span>
	xb_add_32(error, &amp;xb, 1); <span class="enscript-comment">/* address count */</span>
	xb_add_string(error, &amp;xb, uaddr, strlen(uaddr)); <span class="enscript-comment">/* address */</span>
	xb_add_32(error, &amp;xb, 0); <span class="enscript-comment">/* empty server info */</span>
	xb_add_32(error, &amp;xb, numcomps); <span class="enscript-comment">/* pathname component count */</span>
	p = frompath;
	<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
		p++;
	<span class="enscript-keyword">while</span> (*p) {
		cp = p;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p != <span class="enscript-string">'/'</span>))
			p++;
		xb_add_string(error, &amp;xb, cp, (p - cp)); <span class="enscript-comment">/* component */</span>
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
			p++;
	}
	xb_add_32(error, &amp;xb, 0); <span class="enscript-comment">/* empty fsl info */</span>
	xb_add_32(error, &amp;xb, mntflag); <span class="enscript-comment">/* MNT flags */</span>
	xb_build_done(error, &amp;xb);

	<span class="enscript-comment">/* update opaque counts */</span>
	end_offset = xb_offset(&amp;xb);
	<span class="enscript-keyword">if</span> (!error) {
		error = xb_seek(&amp;xb, argslength_offset);
		xb_add_32(error, &amp;xb, end_offset - argslength_offset + XDRWORD<span class="enscript-comment">/*version*/</span>);
	}
	<span class="enscript-keyword">if</span> (!error) {
		error = xb_seek(&amp;xb, attrslength_offset);
		xb_add_32(error, &amp;xb, end_offset - attrslength_offset - XDRWORD<span class="enscript-comment">/*don't include length field*/</span>);
	}
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;nfs_mountroot: error %d assembling mount args\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/* grab the assembled buffer */</span>
	xdrbuf = xb_buffer_base(&amp;xb);
	xb.xb_flags &amp;= ~XB_CLEANUP;

	<span class="enscript-comment">/* do the mount */</span>
	<span class="enscript-keyword">if</span> ((error = mountnfs(xdrbuf, mp, ctx, &amp;vp))) {
		printf(<span class="enscript-string">&quot;nfs_mountroot: mount %s failed: %d\n&quot;</span>, mntname, error);
		vnode_put(mp-&gt;mnt_vnodecovered);
		mount_list_lock();
		vfsp-&gt;vfc_refcount--;
		mount_list_unlock();
		vfs_unbusy(mp);
		mount_lock_destroy(mp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_mount_label_destroy(mp);
#<span class="enscript-reference">endif</span>
		FREE_ZONE(mp, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mount), M_MOUNT);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	*mpp = mp;
	*vpp = vp;
<span class="enscript-reference">out</span>:
	xb_cleanup(&amp;xb);
	<span class="enscript-keyword">return</span> (error);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NO_MOUNT_PRIVATE */</span>

<span class="enscript-comment">/*
 * Convert old style NFS mount args to XDR.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_convert_old_nfs_args</span>(mount_t mp, user_addr_t data, vfs_context_t ctx, <span class="enscript-type">int</span> argsversion, <span class="enscript-type">int</span> inkernel, <span class="enscript-type">char</span> **xdrbufp)
{
	<span class="enscript-type">int</span> error = 0, args64bit, argsize, numcomps;
	<span class="enscript-type">struct</span> user_nfs_args args;
	<span class="enscript-type">struct</span> nfs_args tempargs;
	caddr_t argsp;
	size_t len;
	u_char nfh[NFS4_FHSIZE];
	<span class="enscript-type">char</span> *mntfrom, *endserverp, *frompath, *p, *cp;
	<span class="enscript-type">struct</span> sockaddr_storage ss;
	<span class="enscript-type">void</span> *sinaddr;
	<span class="enscript-type">char</span> uaddr[MAX_IPv6_STR_LEN];
	uint32_t mattrs[NFS_MATTR_BITMAP_LEN];
	uint32_t mflags_mask[NFS_MFLAG_BITMAP_LEN], mflags[NFS_MFLAG_BITMAP_LEN];
	uint32_t nfsvers, nfslockmode = 0, argslength_offset, attrslength_offset, end_offset;
	<span class="enscript-type">struct</span> xdrbuf xb;

	*xdrbufp = NULL;

	<span class="enscript-comment">/* allocate a temporary buffer for mntfrom */</span>
	MALLOC_ZONE(mntfrom, <span class="enscript-type">char</span>*, MAXPATHLEN, M_NAMEI, M_WAITOK);
	<span class="enscript-keyword">if</span> (!mntfrom)
		<span class="enscript-keyword">return</span> (ENOMEM);

	args64bit = (inkernel || vfs_context_is64bit(ctx));
	argsp = args64bit ? (<span class="enscript-type">void</span>*)&amp;args : (<span class="enscript-type">void</span>*)&amp;tempargs;

	argsize = args64bit ? <span class="enscript-keyword">sizeof</span>(args) : <span class="enscript-keyword">sizeof</span>(tempargs);
	<span class="enscript-keyword">switch</span> (argsversion) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
		argsize -= NFS_ARGSVERSION4_INCSIZE;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
		argsize -= NFS_ARGSVERSION5_INCSIZE;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
		argsize -= NFS_ARGSVERSION6_INCSIZE;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EPROGMISMATCH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}

	<span class="enscript-comment">/* read in the structure */</span>
	<span class="enscript-keyword">if</span> (inkernel)
		bcopy(CAST_DOWN(<span class="enscript-type">void</span> *, data), argsp, argsize);
	<span class="enscript-keyword">else</span>
		error = copyin(data, argsp, argsize);
	nfsmout_if(error);

	<span class="enscript-keyword">if</span> (!args64bit) {
		args.addrlen = tempargs.addrlen;
		args.sotype = tempargs.sotype;
		args.proto = tempargs.proto;
		args.fhsize = tempargs.fhsize;
		args.flags = tempargs.flags;
		args.wsize = tempargs.wsize;
		args.rsize = tempargs.rsize;
		args.readdirsize = tempargs.readdirsize;
		args.timeo = tempargs.timeo;
		args.retrans = tempargs.retrans;
		args.maxgrouplist = tempargs.maxgrouplist;
		args.readahead = tempargs.readahead;
		args.leaseterm = tempargs.leaseterm;
		args.deadthresh = tempargs.deadthresh;
		args.addr = CAST_USER_ADDR_T(tempargs.addr);
		args.fh = CAST_USER_ADDR_T(tempargs.fh);
		args.hostname = CAST_USER_ADDR_T(tempargs.hostname);
		<span class="enscript-keyword">if</span> (args.version &gt;= 4) {
			args.acregmin = tempargs.acregmin;
			args.acregmax = tempargs.acregmax;
			args.acdirmin = tempargs.acdirmin;
			args.acdirmax = tempargs.acdirmax;
		}
		<span class="enscript-keyword">if</span> (args.version &gt;= 5)
			args.auth = tempargs.auth;
		<span class="enscript-keyword">if</span> (args.version &gt;= 6)
			args.deadtimeout = tempargs.deadtimeout;
	}

	<span class="enscript-keyword">if</span> ((args.fhsize &lt; 0) || (args.fhsize &gt; NFS4_FHSIZE)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}
	<span class="enscript-keyword">if</span> (args.fhsize &gt; 0) {
		<span class="enscript-keyword">if</span> (inkernel)
			bcopy(CAST_DOWN(<span class="enscript-type">void</span> *, args.fh), (caddr_t)nfh, args.fhsize);
		<span class="enscript-keyword">else</span>
			error = copyin(args.fh, (caddr_t)nfh, args.fhsize);
		nfsmout_if(error);
	}

	<span class="enscript-keyword">if</span> (inkernel)
		error = copystr(CAST_DOWN(<span class="enscript-type">void</span> *, args.hostname), mntfrom, MAXPATHLEN-1, &amp;len);
	<span class="enscript-keyword">else</span>
		error = copyinstr(args.hostname, mntfrom, MAXPATHLEN-1, &amp;len);
	nfsmout_if(error);
	bzero(&amp;mntfrom[len], MAXPATHLEN - len);

	<span class="enscript-comment">/* find the server-side path being mounted */</span>
	frompath = mntfrom;
	<span class="enscript-keyword">if</span> (*frompath == <span class="enscript-string">'['</span>) {  <span class="enscript-comment">/* skip IPv6 literal address */</span>
		<span class="enscript-keyword">while</span> (*frompath &amp;&amp; (*frompath != <span class="enscript-string">']'</span>))
			frompath++;
		<span class="enscript-keyword">if</span> (*frompath == <span class="enscript-string">']'</span>)
			frompath++;
	}
	<span class="enscript-keyword">while</span> (*frompath &amp;&amp; (*frompath != <span class="enscript-string">':'</span>))
		frompath++;
	endserverp = frompath;
	<span class="enscript-keyword">while</span> (*frompath &amp;&amp; (*frompath == <span class="enscript-string">':'</span>))
		frompath++;
	<span class="enscript-comment">/* count fs location path components */</span>
	p = frompath;
	<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
		p++;
	numcomps = 0;
	<span class="enscript-keyword">while</span> (*p) {
		numcomps++;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p != <span class="enscript-string">'/'</span>))
			p++;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
			p++;
	}

	<span class="enscript-comment">/* copy socket address */</span>
	<span class="enscript-keyword">if</span> (inkernel)
		bcopy(CAST_DOWN(<span class="enscript-type">void</span> *, args.addr), &amp;ss, args.addrlen);
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((size_t)args.addrlen &gt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_storage))
			error = EINVAL;
		<span class="enscript-keyword">else</span>
			error = copyin(args.addr, &amp;ss, args.addrlen);
	}
	nfsmout_if(error);
	ss.ss_len = args.addrlen;

	<span class="enscript-comment">/* convert address to universal address string */</span>
	<span class="enscript-keyword">if</span> (ss.ss_family == AF_INET)
		sinaddr = &amp;((<span class="enscript-type">struct</span> sockaddr_in*)&amp;ss)-&gt;sin_addr;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ss.ss_family == AF_INET6)
		sinaddr = &amp;((<span class="enscript-type">struct</span> sockaddr_in6*)&amp;ss)-&gt;sin6_addr;
	<span class="enscript-keyword">else</span>
		sinaddr = NULL;
	<span class="enscript-keyword">if</span> (!sinaddr || (inet_ntop(ss.ss_family, sinaddr, uaddr, <span class="enscript-keyword">sizeof</span>(uaddr)) != uaddr)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}

	<span class="enscript-comment">/* prepare mount flags */</span>
	NFS_BITMAP_ZERO(mflags_mask, NFS_MFLAG_BITMAP_LEN);
	NFS_BITMAP_ZERO(mflags, NFS_MFLAG_BITMAP_LEN);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_SOFT);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_INTR);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_RESVPORT);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_NOCONNECT);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_DUMBTIMER);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_CALLUMNT);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_RDIRPLUS);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_NONEGNAMECACHE);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_MUTEJUKEBOX);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_NOQUOTA);
	<span class="enscript-keyword">if</span> (args.flags &amp; NFSMNT_SOFT)
		NFS_BITMAP_SET(mflags, NFS_MFLAG_SOFT);
	<span class="enscript-keyword">if</span> (args.flags &amp; NFSMNT_INT)
		NFS_BITMAP_SET(mflags, NFS_MFLAG_INTR);
	<span class="enscript-keyword">if</span> (args.flags &amp; NFSMNT_RESVPORT)
		NFS_BITMAP_SET(mflags, NFS_MFLAG_RESVPORT);
	<span class="enscript-keyword">if</span> (args.flags &amp; NFSMNT_NOCONN)
		NFS_BITMAP_SET(mflags, NFS_MFLAG_NOCONNECT);
	<span class="enscript-keyword">if</span> (args.flags &amp; NFSMNT_DUMBTIMR)
		NFS_BITMAP_SET(mflags, NFS_MFLAG_DUMBTIMER);
	<span class="enscript-keyword">if</span> (args.flags &amp; NFSMNT_CALLUMNT)
		NFS_BITMAP_SET(mflags, NFS_MFLAG_CALLUMNT);
	<span class="enscript-keyword">if</span> (args.flags &amp; NFSMNT_RDIRPLUS)
		NFS_BITMAP_SET(mflags, NFS_MFLAG_RDIRPLUS);
	<span class="enscript-keyword">if</span> (args.flags &amp; NFSMNT_NONEGNAMECACHE)
		NFS_BITMAP_SET(mflags, NFS_MFLAG_NONEGNAMECACHE);
	<span class="enscript-keyword">if</span> (args.flags &amp; NFSMNT_MUTEJUKEBOX)
		NFS_BITMAP_SET(mflags, NFS_MFLAG_MUTEJUKEBOX);
	<span class="enscript-keyword">if</span> (args.flags &amp; NFSMNT_NOQUOTA)
		NFS_BITMAP_SET(mflags, NFS_MFLAG_NOQUOTA);

	<span class="enscript-comment">/* prepare mount attributes */</span>
	NFS_BITMAP_ZERO(mattrs, NFS_MATTR_BITMAP_LEN);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_FLAGS);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_NFS_VERSION);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_SOCKET_TYPE);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_NFS_PORT);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_FH);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_FS_LOCATIONS);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_MNTFLAGS);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_MNTFROM);
	<span class="enscript-keyword">if</span> (args.flags &amp; NFSMNT_NFSV4)
		nfsvers = 4;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (args.flags &amp; NFSMNT_NFSV3)
		nfsvers = 3;
	<span class="enscript-keyword">else</span>
		nfsvers = 2;
	<span class="enscript-keyword">if</span> ((args.flags &amp; NFSMNT_RSIZE) &amp;&amp; (args.rsize &gt; 0))
		NFS_BITMAP_SET(mattrs, NFS_MATTR_READ_SIZE);
	<span class="enscript-keyword">if</span> ((args.flags &amp; NFSMNT_WSIZE) &amp;&amp; (args.wsize &gt; 0))
		NFS_BITMAP_SET(mattrs, NFS_MATTR_WRITE_SIZE);
	<span class="enscript-keyword">if</span> ((args.flags &amp; NFSMNT_TIMEO) &amp;&amp; (args.timeo &gt; 0))
		NFS_BITMAP_SET(mattrs, NFS_MATTR_REQUEST_TIMEOUT);
	<span class="enscript-keyword">if</span> ((args.flags &amp; NFSMNT_RETRANS) &amp;&amp; (args.retrans &gt; 0))
		NFS_BITMAP_SET(mattrs, NFS_MATTR_SOFT_RETRY_COUNT);
	<span class="enscript-keyword">if</span> ((args.flags &amp; NFSMNT_MAXGRPS) &amp;&amp; (args.maxgrouplist &gt; 0))
		NFS_BITMAP_SET(mattrs, NFS_MATTR_MAX_GROUP_LIST);
	<span class="enscript-keyword">if</span> ((args.flags &amp; NFSMNT_READAHEAD) &amp;&amp; (args.readahead &gt; 0))
		NFS_BITMAP_SET(mattrs, NFS_MATTR_READAHEAD);
	<span class="enscript-keyword">if</span> ((args.flags &amp; NFSMNT_READDIRSIZE) &amp;&amp; (args.readdirsize &gt; 0))
		NFS_BITMAP_SET(mattrs, NFS_MATTR_READDIR_SIZE);
	<span class="enscript-keyword">if</span> ((args.flags &amp; NFSMNT_NOLOCKS) ||
	    (args.flags &amp; NFSMNT_LOCALLOCKS)) {
		NFS_BITMAP_SET(mattrs, NFS_MATTR_LOCK_MODE);
		<span class="enscript-keyword">if</span> (args.flags &amp; NFSMNT_NOLOCKS)
			nfslockmode = NFS_LOCK_MODE_DISABLED;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (args.flags &amp; NFSMNT_LOCALLOCKS)
			nfslockmode = NFS_LOCK_MODE_LOCAL;
		<span class="enscript-keyword">else</span>
			nfslockmode = NFS_LOCK_MODE_ENABLED;
	}
	<span class="enscript-keyword">if</span> (args.version &gt;= 4) {
		<span class="enscript-keyword">if</span> ((args.flags &amp; NFSMNT_ACREGMIN) &amp;&amp; (args.acregmin &gt; 0))
			NFS_BITMAP_SET(mattrs, NFS_MATTR_ATTRCACHE_REG_MIN);
		<span class="enscript-keyword">if</span> ((args.flags &amp; NFSMNT_ACREGMAX) &amp;&amp; (args.acregmax &gt; 0))
			NFS_BITMAP_SET(mattrs, NFS_MATTR_ATTRCACHE_REG_MAX);
		<span class="enscript-keyword">if</span> ((args.flags &amp; NFSMNT_ACDIRMIN) &amp;&amp; (args.acdirmin &gt; 0))
			NFS_BITMAP_SET(mattrs, NFS_MATTR_ATTRCACHE_DIR_MIN);
		<span class="enscript-keyword">if</span> ((args.flags &amp; NFSMNT_ACDIRMAX) &amp;&amp; (args.acdirmax &gt; 0))
			NFS_BITMAP_SET(mattrs, NFS_MATTR_ATTRCACHE_DIR_MAX);
	}
	<span class="enscript-keyword">if</span> (args.version &gt;= 5) {
		<span class="enscript-keyword">if</span> ((args.flags &amp; NFSMNT_SECFLAVOR) || (args.flags &amp; NFSMNT_SECSYSOK))
			NFS_BITMAP_SET(mattrs, NFS_MATTR_SECURITY);
	}
	<span class="enscript-keyword">if</span> (args.version &gt;= 6) {
		<span class="enscript-keyword">if</span> ((args.flags &amp; NFSMNT_DEADTIMEOUT) &amp;&amp; (args.deadtimeout &gt; 0))
			NFS_BITMAP_SET(mattrs, NFS_MATTR_DEAD_TIMEOUT);
	}

	<span class="enscript-comment">/* build xdr buffer */</span>
	xb_init_buffer(&amp;xb, NULL, 0);
	xb_add_32(error, &amp;xb, args.version);
	argslength_offset = xb_offset(&amp;xb);
	xb_add_32(error, &amp;xb, 0); <span class="enscript-comment">// args length
</span>	xb_add_32(error, &amp;xb, NFS_XDRARGS_VERSION_0);
	xb_add_bitmap(error, &amp;xb, mattrs, NFS_MATTR_BITMAP_LEN);
	attrslength_offset = xb_offset(&amp;xb);
	xb_add_32(error, &amp;xb, 0); <span class="enscript-comment">// attrs length
</span>	xb_add_bitmap(error, &amp;xb, mflags_mask, NFS_MFLAG_BITMAP_LEN); <span class="enscript-comment">/* mask */</span>
	xb_add_bitmap(error, &amp;xb, mflags, NFS_MFLAG_BITMAP_LEN); <span class="enscript-comment">/* value */</span>
	xb_add_32(error, &amp;xb, nfsvers);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_READ_SIZE))
		xb_add_32(error, &amp;xb, args.rsize);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_WRITE_SIZE))
		xb_add_32(error, &amp;xb, args.wsize);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_READDIR_SIZE))
		xb_add_32(error, &amp;xb, args.readdirsize);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_READAHEAD))
		xb_add_32(error, &amp;xb, args.readahead);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_ATTRCACHE_REG_MIN)) {
		xb_add_32(error, &amp;xb, args.acregmin);
		xb_add_32(error, &amp;xb, 0);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_ATTRCACHE_REG_MAX)) {
		xb_add_32(error, &amp;xb, args.acregmax);
		xb_add_32(error, &amp;xb, 0);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_ATTRCACHE_DIR_MIN)) {
		xb_add_32(error, &amp;xb, args.acdirmin);
		xb_add_32(error, &amp;xb, 0);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_ATTRCACHE_DIR_MAX)) {
		xb_add_32(error, &amp;xb, args.acdirmax);
		xb_add_32(error, &amp;xb, 0);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_LOCK_MODE))
		xb_add_32(error, &amp;xb, nfslockmode);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_SECURITY)) {
		uint32_t flavors[2], i=0;
		<span class="enscript-keyword">if</span> (args.flags &amp; NFSMNT_SECFLAVOR)
			flavors[i++] = args.auth;
		<span class="enscript-keyword">if</span> ((args.flags &amp; NFSMNT_SECSYSOK) &amp;&amp; ((i == 0) || (flavors[0] != RPCAUTH_SYS)))
			flavors[i++] = RPCAUTH_SYS;
		xb_add_word_array(error, &amp;xb, flavors, i);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_MAX_GROUP_LIST))
		xb_add_32(error, &amp;xb, args.maxgrouplist);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_SOCKET_TYPE))
		xb_add_string(error, &amp;xb, ((args.sotype == SOCK_DGRAM) ? <span class="enscript-string">&quot;udp&quot;</span> : <span class="enscript-string">&quot;tcp&quot;</span>), 3);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_NFS_PORT))
		xb_add_32(error, &amp;xb, ((ss.ss_family == AF_INET) ? 
			ntohs(((<span class="enscript-type">struct</span> sockaddr_in*)&amp;ss)-&gt;sin_port) :
			ntohs(((<span class="enscript-type">struct</span> sockaddr_in6*)&amp;ss)-&gt;sin6_port)));
	<span class="enscript-comment">/* NFS_MATTR_MOUNT_PORT (not available in old args) */</span>
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_REQUEST_TIMEOUT)) {
		<span class="enscript-comment">/* convert from .1s increments to time */</span>
		xb_add_32(error, &amp;xb, args.timeo/10);
		xb_add_32(error, &amp;xb, (args.timeo%10)*100000000);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_SOFT_RETRY_COUNT))
		xb_add_32(error, &amp;xb, args.retrans);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_DEAD_TIMEOUT)) {
		xb_add_32(error, &amp;xb, args.deadtimeout);
		xb_add_32(error, &amp;xb, 0);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_FH))
		xb_add_fh(error, &amp;xb, &amp;nfh[0], args.fhsize);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_FS_LOCATIONS)) {
		xb_add_32(error, &amp;xb, 1); <span class="enscript-comment">/* fs location count */</span>
		xb_add_32(error, &amp;xb, 1); <span class="enscript-comment">/* server count */</span>
		xb_add_string(error, &amp;xb, mntfrom, (endserverp - mntfrom)); <span class="enscript-comment">/* server name */</span>
		xb_add_32(error, &amp;xb, 1); <span class="enscript-comment">/* address count */</span>
		xb_add_string(error, &amp;xb, uaddr, strlen(uaddr)); <span class="enscript-comment">/* address */</span>
		xb_add_32(error, &amp;xb, 0); <span class="enscript-comment">/* empty server info */</span>
		xb_add_32(error, &amp;xb, numcomps); <span class="enscript-comment">/* pathname component count */</span>
		nfsmout_if(error);
		p = frompath;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
			p++;
		<span class="enscript-keyword">while</span> (*p) {
			cp = p;
			<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p != <span class="enscript-string">'/'</span>))
				p++;
			xb_add_string(error, &amp;xb, cp, (p - cp)); <span class="enscript-comment">/* component */</span>
			nfsmout_if(error);
			<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
				p++;
		}
		xb_add_32(error, &amp;xb, 0); <span class="enscript-comment">/* empty fsl info */</span>
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_MNTFLAGS))
		xb_add_32(error, &amp;xb, (vfs_flags(mp) &amp; MNT_VISFLAGMASK)); <span class="enscript-comment">/* VFS MNT_* flags */</span>
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_MNTFROM))
		xb_add_string(error, &amp;xb, mntfrom, strlen(mntfrom)); <span class="enscript-comment">/* fixed f_mntfromname */</span>
	xb_build_done(error, &amp;xb);

	<span class="enscript-comment">/* update opaque counts */</span>
	end_offset = xb_offset(&amp;xb);
	error = xb_seek(&amp;xb, argslength_offset);
	xb_add_32(error, &amp;xb, end_offset - argslength_offset + XDRWORD<span class="enscript-comment">/*version*/</span>);
	nfsmout_if(error);
	error = xb_seek(&amp;xb, attrslength_offset);
	xb_add_32(error, &amp;xb, end_offset - attrslength_offset - XDRWORD<span class="enscript-comment">/*don't include length field*/</span>);

	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-comment">/* grab the assembled buffer */</span>
		*xdrbufp = xb_buffer_base(&amp;xb);
		xb.xb_flags &amp;= ~XB_CLEANUP;
	}
<span class="enscript-reference">nfsmout</span>:
	xb_cleanup(&amp;xb);
	FREE_ZONE(mntfrom, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * VFS Operations.
 *
 * mount system call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vfs_mount</span>(mount_t mp, vnode_t vp, user_addr_t data, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error = 0, inkernel = vfs_iskernelmount(mp);
	uint32_t argsversion, argslength;
	<span class="enscript-type">char</span> *xdrbuf = NULL;

	<span class="enscript-comment">/* read in version */</span>
	<span class="enscript-keyword">if</span> (inkernel)
		bcopy(CAST_DOWN(<span class="enscript-type">void</span> *, data), &amp;argsversion, <span class="enscript-keyword">sizeof</span>(argsversion));
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((error = copyin(data, &amp;argsversion, <span class="enscript-keyword">sizeof</span>(argsversion))))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/* If we have XDR args, then all values in the buffer are in network order */</span>
	<span class="enscript-keyword">if</span> (argsversion == htonl(NFS_ARGSVERSION_XDR))
		argsversion = NFS_ARGSVERSION_XDR;

	<span class="enscript-keyword">switch</span> (argsversion) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>:
		<span class="enscript-comment">/* convert old-style args to xdr */</span>
		error = nfs_convert_old_nfs_args(mp, data, ctx, argsversion, inkernel, &amp;xdrbuf);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_ARGSVERSION_XDR</span>:
		<span class="enscript-comment">/* copy in xdr buffer */</span>
		<span class="enscript-keyword">if</span> (inkernel)
			bcopy(CAST_DOWN(<span class="enscript-type">void</span> *, (data + XDRWORD)), &amp;argslength, XDRWORD);
		<span class="enscript-keyword">else</span>
			error = copyin((data + XDRWORD), &amp;argslength, XDRWORD);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		argslength = ntohl(argslength);
		<span class="enscript-comment">/* put a reasonable limit on the size of the XDR args */</span>
		<span class="enscript-keyword">if</span> (argslength &gt; 16*1024) {
			error = E2BIG;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* allocate xdr buffer */</span>
		xdrbuf = xb_malloc(xdr_rndup(argslength));
		<span class="enscript-keyword">if</span> (!xdrbuf) {
			error = ENOMEM;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (inkernel)
			bcopy(CAST_DOWN(<span class="enscript-type">void</span> *, data), xdrbuf, argslength);
		<span class="enscript-keyword">else</span>
			error = copyin(data, xdrbuf, argslength);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EPROGMISMATCH;
	}

	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (xdrbuf)
			xb_free(xdrbuf);
		<span class="enscript-keyword">return</span> (error);
	}
	error = mountnfs(xdrbuf, mp, ctx, &amp;vp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Common code for mount and mountroot
 */</span>

<span class="enscript-comment">/* Set up an NFSv2/v3 mount */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_mount</span>(
	<span class="enscript-type">struct</span> nfsmount *nmp,
	vfs_context_t ctx,
	nfsnode_t *npp)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	u_int64_t xid;

	*npp = NULL;

	<span class="enscript-keyword">if</span> (!nmp-&gt;nm_fh)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/*
	 * Get file attributes for the mountpoint.  These are needed
	 * in order to properly create the root vnode.
	 */</span>
	error = nfs3_getattr_rpc(NULL, nmp-&gt;nm_mountp, nmp-&gt;nm_fh-&gt;fh_data, nmp-&gt;nm_fh-&gt;fh_len, 0,
			ctx, &amp;nvattr, &amp;xid);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	error = nfs_nget(nmp-&gt;nm_mountp, NULL, NULL, nmp-&gt;nm_fh-&gt;fh_data, nmp-&gt;nm_fh-&gt;fh_len,
			&amp;nvattr, &amp;xid, RPCAUTH_UNKNOWN, NG_MARKROOT, npp);
	<span class="enscript-keyword">if</span> (*npp)
		nfs_node_unlock(*npp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/*
	 * Try to make sure we have all the general info from the server.
	 */</span>
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers == NFS_VER2) {
		NFS_BITMAP_SET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_MAXNAME);
		nmp-&gt;nm_fsattr.nfsa_maxname = NFS_MAXNAMLEN;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nmp-&gt;nm_vers == NFS_VER3) {
		<span class="enscript-comment">/* get the NFSv3 FSINFO */</span>
		error = nfs3_fsinfo(nmp, *npp, ctx);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		<span class="enscript-comment">/* If the server indicates all pathconf info is */</span>
		<span class="enscript-comment">/* the same, grab a copy of that info now */</span>
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_HOMOGENEOUS) &amp;&amp;
		    (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_HOMOGENEOUS)) {
			<span class="enscript-type">struct</span> nfs_fsattr nfsa;
			<span class="enscript-keyword">if</span> (!nfs3_pathconf_rpc(*npp, &amp;nfsa, ctx)) {
				<span class="enscript-comment">/* cache a copy of the results */</span>
				lck_mtx_lock(&amp;nmp-&gt;nm_lock);
				nfs3_pathconf_cache(nmp, &amp;nfsa);
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			}
		}
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (*npp &amp;&amp; error) {
		vnode_put(NFSTOV(*npp));
		vnode_recycle(NFSTOV(*npp));
		*npp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Update an NFSv4 mount path with the contents of the symlink.
 *
 * Read the link for the given file handle.
 * Insert the link's components into the path.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_mount_update_path_with_symlink</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">struct</span> nfs_fs_path *nfsp, uint32_t curcomp, fhandle_t *dirfhp, <span class="enscript-type">int</span> *depthp, fhandle_t *fhp, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error = 0, status, numops;
	uint32_t len = 0, comp, newcomp, linkcompcount;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;
	<span class="enscript-type">char</span> *link = NULL, *p, *q, ch;
	<span class="enscript-type">struct</span> nfs_fs_path nfsp2;

	bzero(&amp;nfsp2, <span class="enscript-keyword">sizeof</span>(nfsp2));
	<span class="enscript-keyword">if</span> (dirfhp-&gt;fh_len)
		NFSREQ_SECINFO_SET(&amp;si, NULL, dirfhp-&gt;fh_data, dirfhp-&gt;fh_len, nfsp-&gt;np_components[curcomp], 0);
	<span class="enscript-keyword">else</span>
		NFSREQ_SECINFO_SET(&amp;si, NULL, NULL, 0, nfsp-&gt;np_components[curcomp], 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	MALLOC_ZONE(link, <span class="enscript-type">char</span> *, MAXPATHLEN, M_NAMEI, M_WAITOK); 
	<span class="enscript-keyword">if</span> (!link)
		error = ENOMEM;

	<span class="enscript-comment">// PUTFH, READLINK
</span>	numops = 2;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 12 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;readlink&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, NFS_VER4, fhp-&gt;fh_data, fhp-&gt;fh_len);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_READLINK);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);

	error = nfs_request_async(NULL, nmp-&gt;nm_mountp, &amp;nmreq, NFSPROC4_COMPOUND,
			vfs_context_thread(ctx), vfs_context_ucred(ctx), &amp;si, 0, NULL, &amp;req);
	<span class="enscript-keyword">if</span> (!error)
		error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);

	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_READLINK);
	nfsm_chain_get_32(error, &amp;nmrep, len);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (len == 0)
		error = ENOENT;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (len &gt;= MAXPATHLEN)
		len = MAXPATHLEN - 1;
	nfsm_chain_get_opaque(error, &amp;nmrep, len, link);
	nfsmout_if(error);
	<span class="enscript-comment">/* make sure link string is terminated properly */</span>
	link[len] = <span class="enscript-string">'\0'</span>;

	<span class="enscript-comment">/* count the number of components in link */</span>
	p = link;
	<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
		p++;
	linkcompcount = 0;
	<span class="enscript-keyword">while</span> (*p) {
		linkcompcount++;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p != <span class="enscript-string">'/'</span>))
			p++;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
			p++;
	}

	<span class="enscript-comment">/* free up used components */</span>
	<span class="enscript-keyword">for</span> (comp=0; comp &lt;= curcomp; comp++) {
		<span class="enscript-keyword">if</span> (nfsp-&gt;np_components[comp]) {
			FREE(nfsp-&gt;np_components[comp], M_TEMP);
			nfsp-&gt;np_components[comp] = NULL;
		}
	}

	<span class="enscript-comment">/* set up new path */</span>
	nfsp2.np_compcount = nfsp-&gt;np_compcount - curcomp - 1 + linkcompcount;
	MALLOC(nfsp2.np_components, <span class="enscript-type">char</span> **, nfsp2.np_compcount*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>*), M_TEMP, M_WAITOK|M_ZERO);
	<span class="enscript-keyword">if</span> (!nfsp2.np_components) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}

	<span class="enscript-comment">/* add link components */</span>
	p = link;
	<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
		p++;
	<span class="enscript-keyword">for</span> (newcomp=0; newcomp &lt; linkcompcount; newcomp++) {
		<span class="enscript-comment">/* find end of component */</span>
		q = p;
		<span class="enscript-keyword">while</span> (*q &amp;&amp; (*q != <span class="enscript-string">'/'</span>))
			q++;
		MALLOC(nfsp2.np_components[newcomp], <span class="enscript-type">char</span> *, q-p+1, M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (!nfsp2.np_components[newcomp]) {
			error = ENOMEM;
			<span class="enscript-keyword">break</span>;
		}
		ch = *q;
		*q = <span class="enscript-string">'\0'</span>;
		strlcpy(nfsp2.np_components[newcomp], p, q-p+1);
		*q = ch;
		p = q;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
			p++;
	}
	nfsmout_if(error);

	<span class="enscript-comment">/* add remaining components */</span>
	<span class="enscript-keyword">for</span>(comp = curcomp + 1; comp &lt; nfsp-&gt;np_compcount; comp++,newcomp++) {
		nfsp2.np_components[newcomp] = nfsp-&gt;np_components[comp];
		nfsp-&gt;np_components[comp] = NULL;
	}

	<span class="enscript-comment">/* move new path into place */</span>
	FREE(nfsp-&gt;np_components, M_TEMP);
	nfsp-&gt;np_components = nfsp2.np_components;
	nfsp-&gt;np_compcount = nfsp2.np_compcount;
	nfsp2.np_components = NULL;

	<span class="enscript-comment">/* for absolute link, let the caller now that the next dirfh is root */</span>
	<span class="enscript-keyword">if</span> (link[0] == <span class="enscript-string">'/'</span>) {
		dirfhp-&gt;fh_len = 0;
		*depthp = 0;
	}
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (link)
		FREE_ZONE(link, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">if</span> (nfsp2.np_components) {
		<span class="enscript-keyword">for</span> (comp=0; comp &lt; nfsp2.np_compcount; comp++)
			<span class="enscript-keyword">if</span> (nfsp2.np_components[comp])
				FREE(nfsp2.np_components[comp], M_TEMP);
		FREE(nfsp2.np_components, M_TEMP);
	}
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* Set up an NFSv4 mount */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_mount</span>(
	<span class="enscript-type">struct</span> nfsmount *nmp,
	vfs_context_t ctx,
	nfsnode_t *npp)
{
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">int</span> error = 0, numops, status, interval, isdotdot, loopcnt = 0, depth = 0;
	<span class="enscript-type">struct</span> nfs_fs_path fspath, *nfsp, fspath2;
	uint32_t bitmap[NFS_ATTR_BITMAP_LEN], comp, comp2;
	fhandle_t fh, dirfh;
	<span class="enscript-type">struct</span> nfs_vattr nvattr;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;
	<span class="enscript-type">struct</span> nfs_sec sec;
	<span class="enscript-type">struct</span> nfs_fs_locations nfsls;

	*npp = NULL;
	fh.fh_len = dirfh.fh_len = 0;
	TAILQ_INIT(&amp;nmp-&gt;nm_open_owners);
	TAILQ_INIT(&amp;nmp-&gt;nm_delegations);
	TAILQ_INIT(&amp;nmp-&gt;nm_dreturnq);
	nmp-&gt;nm_stategenid = 1;
	NVATTR_INIT(&amp;nvattr);
	bzero(&amp;nfsls, <span class="enscript-keyword">sizeof</span>(nfsls));
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">/*
	 * If no security flavors were specified we'll want to default to the server's
	 * preferred flavor.  For NFSv4.0 we need a file handle and name to get that via
	 * SECINFO, so we'll do that on the last component of the server path we are
	 * mounting.  If we are mounting the server's root, we'll need to defer the
	 * SECINFO call to the first successful LOOKUP request.
	 */</span>
	<span class="enscript-keyword">if</span> (!nmp-&gt;nm_sec.count)
		nmp-&gt;nm_state |= NFSSTA_NEEDSECINFO;

	<span class="enscript-comment">/* make a copy of the current location's path */</span>
	nfsp = &amp;nmp-&gt;nm_locations.nl_locations[nmp-&gt;nm_locations.nl_current.nli_loc]-&gt;nl_path;
	bzero(&amp;fspath, <span class="enscript-keyword">sizeof</span>(fspath));
	fspath.np_compcount = nfsp-&gt;np_compcount;
	<span class="enscript-keyword">if</span> (fspath.np_compcount &gt; 0) {
		MALLOC(fspath.np_components, <span class="enscript-type">char</span> **, fspath.np_compcount*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>*), M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (!fspath.np_components) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
		<span class="enscript-keyword">for</span> (comp=0; comp &lt; nfsp-&gt;np_compcount; comp++) {
			<span class="enscript-type">int</span> slen = strlen(nfsp-&gt;np_components[comp]);
			MALLOC(fspath.np_components[comp], <span class="enscript-type">char</span> *, slen+1, M_TEMP, M_WAITOK|M_ZERO);
			<span class="enscript-keyword">if</span> (!fspath.np_components[comp]) {
				error = ENOMEM;
				<span class="enscript-keyword">break</span>;
			}
			strlcpy(fspath.np_components[comp], nfsp-&gt;np_components[comp], slen+1);
		}
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}

	<span class="enscript-comment">/* for mirror mounts, we can just use the file handle passed in */</span>
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_fh) {
		dirfh.fh_len = nmp-&gt;nm_fh-&gt;fh_len;
		bcopy(nmp-&gt;nm_fh-&gt;fh_data, dirfh.fh_data, dirfh.fh_len);
		NFSREQ_SECINFO_SET(&amp;si, NULL, dirfh.fh_data, dirfh.fh_len, NULL, 0);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">gotfh</span>;
	}

	<span class="enscript-comment">/* otherwise, we need to get the fh for the directory we are mounting */</span>

	<span class="enscript-comment">/* if no components, just get root */</span>
	<span class="enscript-keyword">if</span> (fspath.np_compcount == 0) {
<span class="enscript-reference">nocomponents</span>:
		<span class="enscript-comment">// PUTROOTFH + GETATTR(FH)
</span>		NFSREQ_SECINFO_SET(&amp;si, NULL, NULL, 0, NULL, 0);
		numops = 2;
		nfsm_chain_build_alloc_init(error, &amp;nmreq, 9 * NFSX_UNSIGNED);
		nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;mount&quot;</span>, nmp-&gt;nm_minor_vers, numops);
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTROOTFH);
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
		NFS_CLEAR_ATTRIBUTES(bitmap);
		NFS4_DEFAULT_ATTRIBUTES(bitmap);
		NFS_BITMAP_SET(bitmap, NFS_FATTR_FILEHANDLE);
		nfsm_chain_add_bitmap(error, &amp;nmreq, bitmap, NFS_ATTR_BITMAP_LEN);
		nfsm_chain_build_done(error, &amp;nmreq);
		nfsm_assert(error, (numops == 0), EPROTO);
		nfsmout_if(error);
		error = nfs_request_async(NULL, nmp-&gt;nm_mountp, &amp;nmreq, NFSPROC4_COMPOUND,
				vfs_context_thread(ctx), vfs_context_ucred(ctx), &amp;si, 0, NULL, &amp;req);
		<span class="enscript-keyword">if</span> (!error)
			error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);
		nfsm_chain_skip_tag(error, &amp;nmrep);
		nfsm_chain_get_32(error, &amp;nmrep, numops);
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTROOTFH);
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
		nfsmout_if(error);
		NFS_CLEAR_ATTRIBUTES(nmp-&gt;nm_fsattr.nfsa_bitmap);
		error = nfs4_parsefattr(&amp;nmrep, &amp;nmp-&gt;nm_fsattr, &amp;nvattr, &amp;dirfh, NULL, NULL);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; !NFS_BITMAP_ISSET(&amp;nvattr.nva_bitmap, NFS_FATTR_FILEHANDLE)) {
			printf(<span class="enscript-string">&quot;nfs: mount didn't return filehandle?\n&quot;</span>);
			error = EBADRPC;
		}
		nfsmout_if(error);
		nfsm_chain_cleanup(&amp;nmrep);
		nfsm_chain_null(&amp;nmreq);
		NVATTR_CLEANUP(&amp;nvattr);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">gotfh</span>;
	}

	<span class="enscript-comment">/* look up each path component */</span>
	<span class="enscript-keyword">for</span> (comp=0; comp &lt; fspath.np_compcount; ) {
		isdotdot = 0;
		<span class="enscript-keyword">if</span> (fspath.np_components[comp][0] == <span class="enscript-string">'.'</span>) {
			<span class="enscript-keyword">if</span> (fspath.np_components[comp][1] == <span class="enscript-string">'\0'</span>) {
				<span class="enscript-comment">/* skip &quot;.&quot; */</span>
				comp++;
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-comment">/* treat &quot;..&quot; specially */</span>
			<span class="enscript-keyword">if</span> ((fspath.np_components[comp][1] == <span class="enscript-string">'.'</span>) &amp;&amp;
			    (fspath.np_components[comp][2] == <span class="enscript-string">'\0'</span>))
			    	isdotdot = 1;
			<span class="enscript-keyword">if</span> (isdotdot &amp;&amp; (dirfh.fh_len == 0)) {
				<span class="enscript-comment">/* &quot;..&quot; in root directory is same as &quot;.&quot; */</span>
				comp++;
				<span class="enscript-keyword">continue</span>;
			}
		}
		<span class="enscript-comment">// PUT(ROOT)FH + LOOKUP(P) + GETFH + GETATTR
</span>		<span class="enscript-keyword">if</span> (dirfh.fh_len == 0)
			NFSREQ_SECINFO_SET(&amp;si, NULL, NULL, 0, isdotdot ? NULL : fspath.np_components[comp], 0);
		<span class="enscript-keyword">else</span>
			NFSREQ_SECINFO_SET(&amp;si, NULL, dirfh.fh_data, dirfh.fh_len, isdotdot ? NULL : fspath.np_components[comp], 0);
		numops = 4;
		nfsm_chain_build_alloc_init(error, &amp;nmreq, 18 * NFSX_UNSIGNED);
		nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;mount&quot;</span>, nmp-&gt;nm_minor_vers, numops);
		numops--;
		<span class="enscript-keyword">if</span> (dirfh.fh_len) {
			nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
			nfsm_chain_add_fh(error, &amp;nmreq, NFS_VER4, dirfh.fh_data, dirfh.fh_len);
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTROOTFH);
		}
		numops--;
		<span class="enscript-keyword">if</span> (isdotdot) {
			nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_LOOKUPP);
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_LOOKUP);
			nfsm_chain_add_name(error, &amp;nmreq,
				fspath.np_components[comp], strlen(fspath.np_components[comp]), nmp);
		}
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETFH);
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
		NFS_CLEAR_ATTRIBUTES(bitmap);
		NFS4_DEFAULT_ATTRIBUTES(bitmap);
		<span class="enscript-comment">/* if no namedattr support or component is &quot;.zfs&quot;, clear NFS_FATTR_NAMED_ATTR */</span>
		<span class="enscript-keyword">if</span> (NMFLAG(nmp, NONAMEDATTR) || !strcmp(fspath.np_components[comp], <span class="enscript-string">&quot;.zfs&quot;</span>))
			NFS_BITMAP_CLR(bitmap, NFS_FATTR_NAMED_ATTR);
		nfsm_chain_add_bitmap(error, &amp;nmreq, bitmap, NFS_ATTR_BITMAP_LEN);
		nfsm_chain_build_done(error, &amp;nmreq);
		nfsm_assert(error, (numops == 0), EPROTO);
		nfsmout_if(error);
		error = nfs_request_async(NULL, nmp-&gt;nm_mountp, &amp;nmreq, NFSPROC4_COMPOUND,
				vfs_context_thread(ctx), vfs_context_ucred(ctx), &amp;si, 0, NULL, &amp;req);
		<span class="enscript-keyword">if</span> (!error)
			error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);
		nfsm_chain_skip_tag(error, &amp;nmrep);
		nfsm_chain_get_32(error, &amp;nmrep, numops);
		nfsm_chain_op_check(error, &amp;nmrep, dirfh.fh_len ? NFS_OP_PUTFH : NFS_OP_PUTROOTFH);
		nfsm_chain_op_check(error, &amp;nmrep, isdotdot ? NFS_OP_LOOKUPP : NFS_OP_LOOKUP);
		nfsmout_if(error);
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETFH);
		nfsm_chain_get_32(error, &amp;nmrep, fh.fh_len);
		nfsm_chain_get_opaque(error, &amp;nmrep, fh.fh_len, fh.fh_data);
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
		<span class="enscript-keyword">if</span> (!error) {
			NFS_CLEAR_ATTRIBUTES(nmp-&gt;nm_fsattr.nfsa_bitmap);
			error = nfs4_parsefattr(&amp;nmrep, &amp;nmp-&gt;nm_fsattr, &amp;nvattr, NULL, NULL, &amp;nfsls);
		}
		nfsm_chain_cleanup(&amp;nmrep);
		nfsm_chain_null(&amp;nmreq);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/* LOOKUP succeeded but GETATTR failed?  This could be a referral. */</span>
			<span class="enscript-comment">/* Try the lookup again with a getattr for fs_locations. */</span>
			nfs_fs_locations_cleanup(&amp;nfsls);
			error = nfs4_get_fs_locations(nmp, NULL, dirfh.fh_data, dirfh.fh_len, fspath.np_components[comp], ctx, &amp;nfsls);
			<span class="enscript-keyword">if</span> (!error &amp;&amp; (nfsls.nl_numlocs &lt; 1))
				error = ENOENT;
			nfsmout_if(error);
			<span class="enscript-keyword">if</span> (++loopcnt &gt; MAXSYMLINKS) {
				<span class="enscript-comment">/* too many symlink/referral redirections */</span>
				error = ELOOP;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}
			<span class="enscript-comment">/* tear down the current connection */</span>
			nfs_disconnect(nmp);
			<span class="enscript-comment">/* replace fs locations */</span>
			nfs_fs_locations_cleanup(&amp;nmp-&gt;nm_locations);
			nmp-&gt;nm_locations = nfsls;
			bzero(&amp;nfsls, <span class="enscript-keyword">sizeof</span>(nfsls));
			<span class="enscript-comment">/* initiate a connection using the new fs locations */</span>
			error = nfs_mount_connect(nmp);
			<span class="enscript-keyword">if</span> (!error &amp;&amp; !(nmp-&gt;nm_locations.nl_current.nli_flags &amp; NLI_VALID))
				error = EIO;
			nfsmout_if(error);
			<span class="enscript-comment">/* add new server's remote path to beginning of our path and continue */</span>
			nfsp = &amp;nmp-&gt;nm_locations.nl_locations[nmp-&gt;nm_locations.nl_current.nli_loc]-&gt;nl_path;
			bzero(&amp;fspath2, <span class="enscript-keyword">sizeof</span>(fspath2));
			fspath2.np_compcount = (fspath.np_compcount - comp - 1) + nfsp-&gt;np_compcount;
			<span class="enscript-keyword">if</span> (fspath2.np_compcount &gt; 0) {
				MALLOC(fspath2.np_components, <span class="enscript-type">char</span> **, fspath2.np_compcount*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>*), M_TEMP, M_WAITOK|M_ZERO);
				<span class="enscript-keyword">if</span> (!fspath2.np_components) {
					error = ENOMEM;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
				}
				<span class="enscript-keyword">for</span> (comp2=0; comp2 &lt; nfsp-&gt;np_compcount; comp2++) {
					<span class="enscript-type">int</span> slen = strlen(nfsp-&gt;np_components[comp2]);
					MALLOC(fspath2.np_components[comp2], <span class="enscript-type">char</span> *, slen+1, M_TEMP, M_WAITOK|M_ZERO);
					<span class="enscript-keyword">if</span> (!fspath2.np_components[comp2]) {
						<span class="enscript-comment">/* clean up fspath2, then error out */</span>
						<span class="enscript-keyword">while</span> (comp2 &gt; 0) {
							comp2--;
							FREE(fspath2.np_components[comp2], M_TEMP);
						}
						FREE(fspath2.np_components, M_TEMP);
						error = ENOMEM;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
					}
					strlcpy(fspath2.np_components[comp2], nfsp-&gt;np_components[comp2], slen+1);
				}
				<span class="enscript-keyword">if</span> ((fspath.np_compcount - comp - 1) &gt; 0)
					bcopy(&amp;fspath.np_components[comp+1], &amp;fspath2.np_components[nfsp-&gt;np_compcount], (fspath.np_compcount - comp - 1)*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>*));
				<span class="enscript-comment">/* free up unused parts of old path (prior components and component array) */</span>
				<span class="enscript-keyword">do</span> {
					FREE(fspath.np_components[comp], M_TEMP);
				} <span class="enscript-keyword">while</span> (comp-- &gt; 0);
				FREE(fspath.np_components, M_TEMP);
				<span class="enscript-comment">/* put new path in place */</span>
				fspath = fspath2;
			}
			<span class="enscript-comment">/* reset dirfh and component index */</span>
			dirfh.fh_len = 0;
			comp = 0;
			NVATTR_CLEANUP(&amp;nvattr);
			<span class="enscript-keyword">if</span> (fspath.np_compcount == 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nocomponents</span>;
			<span class="enscript-keyword">continue</span>;
		}
		nfsmout_if(error);
		<span class="enscript-comment">/* if file handle is for a symlink, then update the path with the symlink contents */</span>
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(&amp;nvattr.nva_bitmap, NFS_FATTR_TYPE) &amp;&amp; (nvattr.nva_type == VLNK)) {
			<span class="enscript-keyword">if</span> (++loopcnt &gt; MAXSYMLINKS)
				error = ELOOP;
			<span class="enscript-keyword">else</span>
				error = nfs4_mount_update_path_with_symlink(nmp, &amp;fspath, comp, &amp;dirfh, &amp;depth, &amp;fh, ctx);
			nfsmout_if(error);
			<span class="enscript-comment">/* directory file handle is either left the same or reset to root (if link was absolute) */</span>
			<span class="enscript-comment">/* path traversal starts at beginning of the path again */</span>
			comp = 0;
			NVATTR_CLEANUP(&amp;nvattr);
			nfs_fs_locations_cleanup(&amp;nfsls);
			<span class="enscript-keyword">continue</span>;
		}
		NVATTR_CLEANUP(&amp;nvattr);
		nfs_fs_locations_cleanup(&amp;nfsls);
		<span class="enscript-comment">/* not a symlink... */</span>
		<span class="enscript-keyword">if</span> ((nmp-&gt;nm_state &amp; NFSSTA_NEEDSECINFO) &amp;&amp; (comp == (fspath.np_compcount-1)) &amp;&amp; !isdotdot) {
			<span class="enscript-comment">/* need to get SECINFO for the directory being mounted */</span>
			<span class="enscript-keyword">if</span> (dirfh.fh_len == 0)
				NFSREQ_SECINFO_SET(&amp;si, NULL, NULL, 0, isdotdot ? NULL : fspath.np_components[comp], 0);
			<span class="enscript-keyword">else</span>
				NFSREQ_SECINFO_SET(&amp;si, NULL, dirfh.fh_data, dirfh.fh_len, isdotdot ? NULL : fspath.np_components[comp], 0);
			sec.count = NX_MAX_SEC_FLAVORS;
			error = nfs4_secinfo_rpc(nmp, &amp;si, vfs_context_ucred(ctx), sec.flavors, &amp;sec.count);
			<span class="enscript-comment">/* [sigh] some implementations return &quot;illegal&quot; error for unsupported ops */</span>
			<span class="enscript-keyword">if</span> (error == NFSERR_OP_ILLEGAL)
				error = 0;
			nfsmout_if(error);
			<span class="enscript-comment">/* set our default security flavor to the first in the list */</span>
			<span class="enscript-keyword">if</span> (sec.count)
				nmp-&gt;nm_auth = sec.flavors[0];
			nmp-&gt;nm_state &amp;= ~NFSSTA_NEEDSECINFO;
		}
		<span class="enscript-comment">/* advance directory file handle, component index, &amp; update depth */</span>
		dirfh = fh;
		comp++;
		<span class="enscript-keyword">if</span> (!isdotdot) <span class="enscript-comment">/* going down the hierarchy */</span>
			depth++;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (--depth &lt;= 0)  <span class="enscript-comment">/* going up the hierarchy */</span>
			dirfh.fh_len = 0; <span class="enscript-comment">/* clear dirfh when we hit root */</span>
	}

<span class="enscript-reference">gotfh</span>:
	<span class="enscript-comment">/* get attrs for mount point root */</span>
	numops = NMFLAG(nmp, NONAMEDATTR) ? 2 : 3; <span class="enscript-comment">// PUTFH + GETATTR + OPENATTR
</span>	nfsm_chain_build_alloc_init(error, &amp;nmreq, 25 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;mount&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, NFS_VER4, dirfh.fh_data, dirfh.fh_len);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	NFS_CLEAR_ATTRIBUTES(bitmap);
	NFS4_DEFAULT_ATTRIBUTES(bitmap);
	<span class="enscript-comment">/* if no namedattr support or last component is &quot;.zfs&quot;, clear NFS_FATTR_NAMED_ATTR */</span>
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, NONAMEDATTR) || ((fspath.np_compcount &gt; 0) &amp;&amp; !strcmp(fspath.np_components[fspath.np_compcount-1], <span class="enscript-string">&quot;.zfs&quot;</span>)))
		NFS_BITMAP_CLR(bitmap, NFS_FATTR_NAMED_ATTR);
	nfsm_chain_add_bitmap(error, &amp;nmreq, bitmap, NFS_ATTR_BITMAP_LEN);
	<span class="enscript-keyword">if</span> (!NMFLAG(nmp, NONAMEDATTR)) {
		numops--;
		nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_OPENATTR);
		nfsm_chain_add_32(error, &amp;nmreq, 0);
	}
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request_async(NULL, nmp-&gt;nm_mountp, &amp;nmreq, NFSPROC4_COMPOUND,
			vfs_context_thread(ctx), vfs_context_ucred(ctx), &amp;si, 0, NULL, &amp;req);
	<span class="enscript-keyword">if</span> (!error)
		error = nfs_request_async_finish(req, &amp;nmrep, &amp;xid, &amp;status);
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsmout_if(error);
	NFS_CLEAR_ATTRIBUTES(nmp-&gt;nm_fsattr.nfsa_bitmap);
	error = nfs4_parsefattr(&amp;nmrep, &amp;nmp-&gt;nm_fsattr, &amp;nvattr, NULL, NULL, NULL);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (!NMFLAG(nmp, NONAMEDATTR)) {
		nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_OPENATTR);
		<span class="enscript-keyword">if</span> (error == ENOENT)
			error = 0;
		<span class="enscript-comment">/* [sigh] some implementations return &quot;illegal&quot; error for unsupported ops */</span>
		<span class="enscript-keyword">if</span> (error || !NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_supp_attr, NFS_FATTR_NAMED_ATTR)) {
			nmp-&gt;nm_fsattr.nfsa_flags &amp;= ~NFS_FSFLAG_NAMED_ATTR;
		} <span class="enscript-keyword">else</span> {
			nmp-&gt;nm_fsattr.nfsa_flags |= NFS_FSFLAG_NAMED_ATTR;
		}
	} <span class="enscript-keyword">else</span> {
		nmp-&gt;nm_fsattr.nfsa_flags &amp;= ~NFS_FSFLAG_NAMED_ATTR;
	}
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, NOACL)) <span class="enscript-comment">/* make sure ACL support is turned off */</span>
		nmp-&gt;nm_fsattr.nfsa_flags &amp;= ~NFS_FSFLAG_ACL;
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, ACLONLY) &amp;&amp; !(nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_ACL))
		NFS_BITMAP_CLR(nmp-&gt;nm_flags, NFS_MFLAG_ACLONLY);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_supp_attr, NFS_FATTR_FH_EXPIRE_TYPE)) {
		uint32_t fhtype = ((nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_FHTYPE_MASK) &gt;&gt; NFS_FSFLAG_FHTYPE_SHIFT);
		<span class="enscript-keyword">if</span> (fhtype != NFS_FH_PERSISTENT)
			printf(<span class="enscript-string">&quot;nfs: warning: non-persistent file handles! for %s\n&quot;</span>, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname);
	}

	<span class="enscript-comment">/* make sure it's a directory */</span>
	<span class="enscript-keyword">if</span> (!NFS_BITMAP_ISSET(&amp;nvattr.nva_bitmap, NFS_FATTR_TYPE) || (nvattr.nva_type != VDIR)) {
		error = ENOTDIR;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}

	<span class="enscript-comment">/* save the NFS fsid */</span>
	nmp-&gt;nm_fsid = nvattr.nva_fsid;

	<span class="enscript-comment">/* create the root node */</span>
	error = nfs_nget(nmp-&gt;nm_mountp, NULL, NULL, dirfh.fh_data, dirfh.fh_len, &amp;nvattr, &amp;xid, rq.r_auth, NG_MARKROOT, npp);
	nfsmout_if(error);

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_fsattr.nfsa_flags &amp; NFS_FSFLAG_ACL)
		vfs_setextendedsecurity(nmp-&gt;nm_mountp);

	<span class="enscript-comment">/* adjust I/O sizes to server limits */</span>
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_MAXREAD) &amp;&amp; (nmp-&gt;nm_fsattr.nfsa_maxread &gt; 0)) {
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_fsattr.nfsa_maxread &lt; (uint64_t)nmp-&gt;nm_rsize) {
			nmp-&gt;nm_rsize = nmp-&gt;nm_fsattr.nfsa_maxread &amp; ~(NFS_FABLKSIZE - 1);
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_rsize == 0)
				nmp-&gt;nm_rsize = nmp-&gt;nm_fsattr.nfsa_maxread;
		}
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_bitmap, NFS_FATTR_MAXWRITE) &amp;&amp; (nmp-&gt;nm_fsattr.nfsa_maxwrite &gt; 0)) {
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_fsattr.nfsa_maxwrite &lt; (uint64_t)nmp-&gt;nm_wsize) {
			nmp-&gt;nm_wsize = nmp-&gt;nm_fsattr.nfsa_maxwrite &amp; ~(NFS_FABLKSIZE - 1);
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_wsize == 0)
				nmp-&gt;nm_wsize = nmp-&gt;nm_fsattr.nfsa_maxwrite;
		}
	}

	<span class="enscript-comment">/* set up lease renew timer */</span>
	nmp-&gt;nm_renew_timer = thread_call_allocate(nfs4_renew_timer, nmp);
	interval = nmp-&gt;nm_fsattr.nfsa_lease / 2;
	<span class="enscript-keyword">if</span> (interval &lt; 1)
		interval = 1;
	nfs_interval_timer_start(nmp-&gt;nm_renew_timer, interval * 1000);

<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (fspath.np_components) {
		<span class="enscript-keyword">for</span> (comp=0; comp &lt; fspath.np_compcount; comp++)
			<span class="enscript-keyword">if</span> (fspath.np_components[comp])
				FREE(fspath.np_components[comp], M_TEMP);
		FREE(fspath.np_components, M_TEMP);
	}
	NVATTR_CLEANUP(&amp;nvattr);
	nfs_fs_locations_cleanup(&amp;nfsls);
	<span class="enscript-keyword">if</span> (*npp)
		nfs_node_unlock(*npp);
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Thread to handle initial NFS mount connection.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_mount_connect_thread</span>(<span class="enscript-type">void</span> *arg, __unused wait_result_t wr)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = arg;
	<span class="enscript-type">int</span> error = 0, savederror = 0, slpflag = (NMFLAG(nmp, INTR) ? PCATCH : 0);
	<span class="enscript-type">int</span> done = 0, timeo, tries, maxtries;

	<span class="enscript-keyword">if</span> (NM_OMFLAG(nmp, MNTQUICK)) {
		timeo = 8;
		maxtries = 1;
	} <span class="enscript-keyword">else</span> {
		timeo = 30;
		maxtries = 2;
	}

	<span class="enscript-keyword">for</span> (tries = 0; tries &lt; maxtries; tries++) {
		error = nfs_connect(nmp, 1, timeo);
		<span class="enscript-keyword">switch</span> (error) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ETIMEDOUT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EAGAIN</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EPIPE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EADDRNOTAVAIL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETDOWN</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETUNREACH</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETRESET</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ECONNABORTED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ECONNRESET</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EISCONN</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOTCONN</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ESHUTDOWN</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">ECONNREFUSED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTDOWN</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTUNREACH</span>:
			<span class="enscript-comment">/* just keep retrying on any of these errors */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* looks like we got an answer... */</span>
			done = 1;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* save the best error */</span>
		<span class="enscript-keyword">if</span> (nfs_connect_error_class(error) &gt;= nfs_connect_error_class(savederror))
			savederror = error;
		<span class="enscript-keyword">if</span> (done) {
			error = savederror;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* pause before next attempt */</span>
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(nmp, NULL, current_thread(), 0)))
			<span class="enscript-keyword">break</span>;
		error = tsleep(nmp, PSOCK|slpflag, <span class="enscript-string">&quot;nfs_mount_connect_retry&quot;</span>, 2*hz);
		<span class="enscript-keyword">if</span> (error &amp;&amp; (error != EWOULDBLOCK))
			<span class="enscript-keyword">break</span>;
		error = savederror;
	}

	<span class="enscript-comment">/* update status of mount connect */</span>
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (!nmp-&gt;nm_mounterror)
		nmp-&gt;nm_mounterror = error;
	nmp-&gt;nm_state &amp;= ~NFSSTA_MOUNT_THREAD;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	wakeup(&amp;nmp-&gt;nm_nss);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_mount_connect</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">int</span> error = 0, slpflag;
	thread_t thd;
	<span class="enscript-type">struct</span> timespec ts = { 2, 0 };

	<span class="enscript-comment">/*
	 * Set up the socket.  Perform initial search for a location/server/address to
	 * connect to and negotiate any unspecified mount parameters.  This work is
	 * done on a kernel thread to satisfy reserved port usage needs.
	 */</span>
	slpflag = NMFLAG(nmp, INTR) ? PCATCH : 0;
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-comment">/* set flag that the thread is running */</span>
	nmp-&gt;nm_state |= NFSSTA_MOUNT_THREAD;
	<span class="enscript-keyword">if</span> (kernel_thread_start(nfs_mount_connect_thread, nmp, &amp;thd) != KERN_SUCCESS) {
		nmp-&gt;nm_state &amp;= ~NFSSTA_MOUNT_THREAD;
		nmp-&gt;nm_mounterror = EIO;
		printf(<span class="enscript-string">&quot;nfs mount %s start socket connect thread failed\n&quot;</span>, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname);
	} <span class="enscript-keyword">else</span> {
		thread_deallocate(thd);
	}

	<span class="enscript-comment">/* wait until mount connect thread is finished/gone */</span>
	<span class="enscript-keyword">while</span> (nmp-&gt;nm_state &amp; NFSSTA_MOUNT_THREAD) {
		error = msleep(&amp;nmp-&gt;nm_nss, &amp;nmp-&gt;nm_lock, slpflag|PSOCK, <span class="enscript-string">&quot;nfsconnectthread&quot;</span>, &amp;ts);
		<span class="enscript-keyword">if</span> ((error &amp;&amp; (error != EWOULDBLOCK)) || ((error = nfs_sigintr(nmp, NULL, current_thread(), 1)))) {
			<span class="enscript-comment">/* record error */</span>
			<span class="enscript-keyword">if</span> (!nmp-&gt;nm_mounterror)
				nmp-&gt;nm_mounterror = error;
			<span class="enscript-comment">/* signal the thread that we are aborting */</span>
			nmp-&gt;nm_sockflags |= NMSOCK_UNMOUNT;
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_nss)
				wakeup(nmp-&gt;nm_nss);
			<span class="enscript-comment">/* and continue waiting on it to finish */</span>
			slpflag = 0;
		}
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-comment">/* grab mount connect status */</span>
	error = nmp-&gt;nm_mounterror;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* Table of maximum minor version for a given version */</span>
uint32_t maxminorverstab[] = {
	0, <span class="enscript-comment">/* Version 0 (does not exist) */</span>
	0, <span class="enscript-comment">/* Version 1 (does not exist) */</span>
	0, <span class="enscript-comment">/* Version 2 */</span>
	0, <span class="enscript-comment">/* Version 3 */</span>
	0, <span class="enscript-comment">/* Version 4 */</span>
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_MAX_SUPPORTED_VERSION</span>  ((long)(sizeof (maxminorverstab) / sizeof (uint32_t) - 1))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_MAX_SUPPORTED_MINOR_VERSION</span>(v) ((long)(maxminorverstab[(v)]))

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_NFS_MIN_VERS</span> VER2PVER(2, 0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEFAULT_NFS_MAX_VERS</span> VER2PVER(3, 0)

<span class="enscript-comment">/*
 * Common code to mount an NFS file system.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">mountnfs</span>(
	<span class="enscript-type">char</span> *xdrbuf,
	mount_t mp,
	vfs_context_t ctx,
	vnode_t *vpp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	nfsnode_t np;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> vfsstatfs *sbp;
	<span class="enscript-type">struct</span> xdrbuf xb;
	uint32_t i, val, maxio, iosize, len;
	uint32_t *mattrs;
	uint32_t *mflags_mask;
	uint32_t *mflags;
	uint32_t argslength, attrslength;
	<span class="enscript-type">struct</span> nfs_location_index firstloc = { NLI_VALID, 0, 0, 0 };

	<span class="enscript-comment">/* make sure mbuf constants are set up */</span>
	<span class="enscript-keyword">if</span> (!nfs_mbuf_mhlen)
		nfs_mbuf_init();

	<span class="enscript-keyword">if</span> (vfs_flags(mp) &amp; MNT_UPDATE) {
		nmp = VFSTONFS(mp);
		<span class="enscript-comment">/* update paths, file handles, etc, here	XXX */</span>
		xb_free(xdrbuf);
		<span class="enscript-keyword">return</span> (0);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* allocate an NFS mount structure for this mount */</span>
		MALLOC_ZONE(nmp, <span class="enscript-type">struct</span> nfsmount *,
				<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nfsmount), M_NFSMNT, M_WAITOK);
		<span class="enscript-keyword">if</span> (!nmp) {
			xb_free(xdrbuf);
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
		bzero((caddr_t)nmp, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nfsmount));
		lck_mtx_init(&amp;nmp-&gt;nm_lock, nfs_mount_grp, LCK_ATTR_NULL);
		TAILQ_INIT(&amp;nmp-&gt;nm_resendq);
		TAILQ_INIT(&amp;nmp-&gt;nm_iodq);
		TAILQ_INIT(&amp;nmp-&gt;nm_gsscl);
		LIST_INIT(&amp;nmp-&gt;nm_monlist);
		vfs_setfsprivate(mp, nmp);
		vfs_getnewfsid(mp);
		nmp-&gt;nm_mountp = mp;
		vfs_setauthopaque(mp);

		nfs_nhinit_finish();

		nmp-&gt;nm_args = xdrbuf;

		<span class="enscript-comment">/* set up defaults */</span>
		nmp-&gt;nm_ref = 0;
		nmp-&gt;nm_vers = 0;
		nmp-&gt;nm_min_vers = DEFAULT_NFS_MIN_VERS;
		nmp-&gt;nm_max_vers = DEFAULT_NFS_MAX_VERS;
		nmp-&gt;nm_timeo = NFS_TIMEO;
		nmp-&gt;nm_retry = NFS_RETRANS;
		nmp-&gt;nm_sotype = 0;
		nmp-&gt;nm_sofamily = 0;
		nmp-&gt;nm_nfsport = 0;
		nmp-&gt;nm_wsize = NFS_WSIZE;
		nmp-&gt;nm_rsize = NFS_RSIZE;
		nmp-&gt;nm_readdirsize = NFS_READDIRSIZE;
		nmp-&gt;nm_numgrps = NFS_MAXGRPS;
		nmp-&gt;nm_readahead = NFS_DEFRAHEAD;
		nmp-&gt;nm_tprintf_delay = nfs_tprintf_delay;
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_tprintf_delay &lt; 0)
			nmp-&gt;nm_tprintf_delay = 0;
		nmp-&gt;nm_tprintf_initial_delay = nfs_tprintf_initial_delay;
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_tprintf_initial_delay &lt; 0)
			nmp-&gt;nm_tprintf_initial_delay = 0;
		nmp-&gt;nm_acregmin = NFS_MINATTRTIMO;
		nmp-&gt;nm_acregmax = NFS_MAXATTRTIMO;
		nmp-&gt;nm_acdirmin = NFS_MINDIRATTRTIMO;
		nmp-&gt;nm_acdirmax = NFS_MAXDIRATTRTIMO;
		nmp-&gt;nm_auth = RPCAUTH_SYS;
		nmp-&gt;nm_iodlink.tqe_next = NFSNOLIST;
		nmp-&gt;nm_deadtimeout = 0;
		nmp-&gt;nm_curdeadtimeout = 0;
		NFS_BITMAP_SET(nmp-&gt;nm_flags, NFS_MFLAG_NOACL);
		nmp-&gt;nm_realm = NULL;
		nmp-&gt;nm_principal = NULL;
		nmp-&gt;nm_sprinc = NULL;
	}

	mattrs = nmp-&gt;nm_mattrs;
	mflags = nmp-&gt;nm_mflags;
	mflags_mask = nmp-&gt;nm_mflags_mask;

	<span class="enscript-comment">/* set up NFS mount with args */</span>
	xb_init_buffer(&amp;xb, xdrbuf, 2*XDRWORD);
	xb_get_32(error, &amp;xb, val); <span class="enscript-comment">/* version */</span>
	xb_get_32(error, &amp;xb, argslength); <span class="enscript-comment">/* args length */</span>
	nfsmerr_if(error);
	xb_init_buffer(&amp;xb, xdrbuf, argslength);	<span class="enscript-comment">/* restart parsing with actual buffer length */</span>
	xb_get_32(error, &amp;xb, val); <span class="enscript-comment">/* version */</span>
	xb_get_32(error, &amp;xb, argslength); <span class="enscript-comment">/* args length */</span>
	xb_get_32(error, &amp;xb, val); <span class="enscript-comment">/* XDR args version */</span>
	<span class="enscript-keyword">if</span> (val != NFS_XDRARGS_VERSION_0)
		error = EINVAL;
	len = NFS_MATTR_BITMAP_LEN;
	xb_get_bitmap(error, &amp;xb, mattrs, len); <span class="enscript-comment">/* mount attribute bitmap */</span>
	attrslength = 0;
	xb_get_32(error, &amp;xb, attrslength); <span class="enscript-comment">/* attrs length */</span>
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (attrslength &gt; (argslength - ((4+NFS_MATTR_BITMAP_LEN+1)*XDRWORD))))
		error = EINVAL;
	nfsmerr_if(error);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_FLAGS)) {
		len = NFS_MFLAG_BITMAP_LEN;
		xb_get_bitmap(error, &amp;xb, mflags_mask, len); <span class="enscript-comment">/* mount flag mask */</span>
		len = NFS_MFLAG_BITMAP_LEN;
		xb_get_bitmap(error, &amp;xb, mflags, len); <span class="enscript-comment">/* mount flag values */</span>
		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-comment">/* clear all mask bits and OR in all the ones that are set */</span>
			nmp-&gt;nm_flags[0] &amp;= ~mflags_mask[0];
			nmp-&gt;nm_flags[0] |= (mflags_mask[0] &amp; mflags[0]);
		}
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_NFS_VERSION)) {
		<span class="enscript-comment">/* Can't specify a single version and a range */</span>
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_NFS_VERSION_RANGE))
			error = EINVAL;
		xb_get_32(error, &amp;xb, nmp-&gt;nm_vers);
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt; NFS_MAX_SUPPORTED_VERSION ||
		    nmp-&gt;nm_vers &lt; NFS_VER2)
			error = EINVAL;
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_NFS_MINOR_VERSION))
			xb_get_32(error, &amp;xb, nmp-&gt;nm_minor_vers);
		<span class="enscript-keyword">else</span>
			nmp-&gt;nm_minor_vers = maxminorverstab[nmp-&gt;nm_vers];
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_minor_vers &gt; maxminorverstab[nmp-&gt;nm_vers])
			error = EINVAL;
		nmp-&gt;nm_max_vers = nmp-&gt;nm_min_vers = 
			VER2PVER(nmp-&gt;nm_vers, nmp-&gt;nm_minor_vers);
	} 
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_NFS_MINOR_VERSION)) {
		<span class="enscript-comment">/* should have also gotten NFS version (and already gotten minor version) */</span>
		<span class="enscript-keyword">if</span> (!NFS_BITMAP_ISSET(mattrs, NFS_MATTR_NFS_VERSION))
			error = EINVAL;
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_NFS_VERSION_RANGE)) {
		xb_get_32(error, &amp;xb, nmp-&gt;nm_min_vers);
		xb_get_32(error, &amp;xb, nmp-&gt;nm_max_vers);
		<span class="enscript-keyword">if</span> ((nmp-&gt;nm_min_vers &gt; nmp-&gt;nm_max_vers) ||
		    (PVER2MAJOR(nmp-&gt;nm_max_vers) &gt; NFS_MAX_SUPPORTED_VERSION) ||
		    (PVER2MINOR(nmp-&gt;nm_min_vers) &gt; maxminorverstab[PVER2MAJOR(nmp-&gt;nm_min_vers)]) ||
		    (PVER2MINOR(nmp-&gt;nm_max_vers) &gt; maxminorverstab[PVER2MAJOR(nmp-&gt;nm_max_vers)]))
			error = EINVAL;
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_READ_SIZE))
		xb_get_32(error, &amp;xb, nmp-&gt;nm_rsize);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_WRITE_SIZE))
		xb_get_32(error, &amp;xb, nmp-&gt;nm_wsize);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_READDIR_SIZE))
		xb_get_32(error, &amp;xb, nmp-&gt;nm_readdirsize);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_READAHEAD))
		xb_get_32(error, &amp;xb, nmp-&gt;nm_readahead);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_ATTRCACHE_REG_MIN)) {
		xb_get_32(error, &amp;xb, nmp-&gt;nm_acregmin);
		xb_skip(error, &amp;xb, XDRWORD);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_ATTRCACHE_REG_MAX)) {
		xb_get_32(error, &amp;xb, nmp-&gt;nm_acregmax);
		xb_skip(error, &amp;xb, XDRWORD);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_ATTRCACHE_DIR_MIN)) {
		xb_get_32(error, &amp;xb, nmp-&gt;nm_acdirmin);
		xb_skip(error, &amp;xb, XDRWORD);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_ATTRCACHE_DIR_MAX)) {
		xb_get_32(error, &amp;xb, nmp-&gt;nm_acdirmax);
		xb_skip(error, &amp;xb, XDRWORD);
	}
	nfsmerr_if(error);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_LOCK_MODE)) {
		xb_get_32(error, &amp;xb, val);
		<span class="enscript-keyword">switch</span> (val) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_LOCK_MODE_DISABLED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_LOCK_MODE_LOCAL</span>:
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4) {
				<span class="enscript-comment">/* disabled/local lock mode only allowed on v2/v3 */</span>
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/* FALLTHROUGH */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_LOCK_MODE_ENABLED</span>:
			nmp-&gt;nm_lockmode = val;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			error = EINVAL;
		}
	}
	nfsmerr_if(error);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_SECURITY)) {
		uint32_t seccnt;
		xb_get_32(error, &amp;xb, seccnt);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; ((seccnt &lt; 1) || (seccnt &gt; NX_MAX_SEC_FLAVORS)))
			error = EINVAL;
		nfsmerr_if(error);
		nmp-&gt;nm_sec.count = seccnt;
		<span class="enscript-keyword">for</span> (i=0; i &lt; seccnt; i++) {
			xb_get_32(error, &amp;xb, nmp-&gt;nm_sec.flavors[i]);
			<span class="enscript-comment">/* Check for valid security flavor */</span>
			<span class="enscript-keyword">switch</span> (nmp-&gt;nm_sec.flavors[i]) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_NONE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_SYS</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5I</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5P</span>:
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				error = EINVAL;
			}
		}
		<span class="enscript-comment">/* start with the first flavor */</span>
		nmp-&gt;nm_auth = nmp-&gt;nm_sec.flavors[0];
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_MAX_GROUP_LIST))
		xb_get_32(error, &amp;xb, nmp-&gt;nm_numgrps);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_SOCKET_TYPE)) {
		<span class="enscript-type">char</span> sotype[6];

		xb_get_32(error, &amp;xb, val);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; ((val &lt; 3) || (val &gt; 5)))
			error = EINVAL;
		nfsmerr_if(error);
		error = xb_get_bytes(&amp;xb, sotype, val, 0);
		nfsmerr_if(error);
		sotype[val] = <span class="enscript-string">'\0'</span>;
		<span class="enscript-keyword">if</span> (!strcmp(sotype, <span class="enscript-string">&quot;tcp&quot;</span>)) {
			nmp-&gt;nm_sotype = SOCK_STREAM;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strcmp(sotype, <span class="enscript-string">&quot;udp&quot;</span>)) {
			nmp-&gt;nm_sotype = SOCK_DGRAM;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strcmp(sotype, <span class="enscript-string">&quot;tcp4&quot;</span>)) {
			nmp-&gt;nm_sotype = SOCK_STREAM;
			nmp-&gt;nm_sofamily = AF_INET;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strcmp(sotype, <span class="enscript-string">&quot;udp4&quot;</span>)) {
			nmp-&gt;nm_sotype = SOCK_DGRAM;
			nmp-&gt;nm_sofamily = AF_INET;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strcmp(sotype, <span class="enscript-string">&quot;tcp6&quot;</span>)) {
			nmp-&gt;nm_sotype = SOCK_STREAM;
			nmp-&gt;nm_sofamily = AF_INET6;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strcmp(sotype, <span class="enscript-string">&quot;udp6&quot;</span>)) {
			nmp-&gt;nm_sotype = SOCK_DGRAM;
			nmp-&gt;nm_sofamily = AF_INET6;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strcmp(sotype, <span class="enscript-string">&quot;inet4&quot;</span>)) {
			nmp-&gt;nm_sofamily = AF_INET;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strcmp(sotype, <span class="enscript-string">&quot;inet6&quot;</span>)) {
			nmp-&gt;nm_sofamily = AF_INET6;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!strcmp(sotype, <span class="enscript-string">&quot;inet&quot;</span>)) {
			nmp-&gt;nm_sofamily = 0; <span class="enscript-comment">/* ok */</span>
		} <span class="enscript-keyword">else</span> {
			error = EINVAL;
		}
		<span class="enscript-keyword">if</span> (!error &amp;&amp; (nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; nmp-&gt;nm_sotype &amp;&amp;
		    (nmp-&gt;nm_sotype != SOCK_STREAM))
			error = EINVAL;		<span class="enscript-comment">/* NFSv4 is only allowed over TCP. */</span>
		nfsmerr_if(error);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_NFS_PORT))
		xb_get_32(error, &amp;xb, nmp-&gt;nm_nfsport);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_MOUNT_PORT))
		xb_get_32(error, &amp;xb, nmp-&gt;nm_mountport);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_REQUEST_TIMEOUT)) {
		<span class="enscript-comment">/* convert from time to 0.1s units */</span>
		xb_get_32(error, &amp;xb, nmp-&gt;nm_timeo);
		xb_get_32(error, &amp;xb, val);
		nfsmerr_if(error);
		<span class="enscript-keyword">if</span> (val &gt;= 1000000000)
			error = EINVAL;
		nfsmerr_if(error);
		nmp-&gt;nm_timeo *= 10;
		nmp-&gt;nm_timeo += (val+100000000-1)/100000000;
		<span class="enscript-comment">/* now convert to ticks */</span>
		nmp-&gt;nm_timeo = (nmp-&gt;nm_timeo * NFS_HZ + 5) / 10;
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_SOFT_RETRY_COUNT)) {
		xb_get_32(error, &amp;xb, val);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; (val &gt; 1))
			nmp-&gt;nm_retry = val;
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_DEAD_TIMEOUT)) {
		xb_get_32(error, &amp;xb, nmp-&gt;nm_deadtimeout);
		xb_skip(error, &amp;xb, XDRWORD);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_FH)) {
		nfsmerr_if(error);
		MALLOC(nmp-&gt;nm_fh, fhandle_t *, <span class="enscript-keyword">sizeof</span>(fhandle_t), M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (!nmp-&gt;nm_fh)
			error = ENOMEM;
		xb_get_32(error, &amp;xb, nmp-&gt;nm_fh-&gt;fh_len);
		nfsmerr_if(error);
		error = xb_get_bytes(&amp;xb, (<span class="enscript-type">char</span>*)&amp;nmp-&gt;nm_fh-&gt;fh_data[0], nmp-&gt;nm_fh-&gt;fh_len, 0);
	}
	nfsmerr_if(error);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_FS_LOCATIONS)) {
		uint32_t loc, serv, addr, comp;
		<span class="enscript-type">struct</span> nfs_fs_location *fsl;
		<span class="enscript-type">struct</span> nfs_fs_server *fss;
		<span class="enscript-type">struct</span> nfs_fs_path *fsp;

		xb_get_32(error, &amp;xb, nmp-&gt;nm_locations.nl_numlocs); <span class="enscript-comment">/* fs location count */</span>
		<span class="enscript-comment">/* sanity check location count */</span>
		<span class="enscript-keyword">if</span> (!error &amp;&amp; ((nmp-&gt;nm_locations.nl_numlocs &lt; 1) || (nmp-&gt;nm_locations.nl_numlocs &gt; 256)))
			error = EINVAL;
		nfsmerr_if(error);
		MALLOC(nmp-&gt;nm_locations.nl_locations, <span class="enscript-type">struct</span> nfs_fs_location **, nmp-&gt;nm_locations.nl_numlocs * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_fs_location*), M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (!nmp-&gt;nm_locations.nl_locations)
			error = ENOMEM;
		<span class="enscript-keyword">for</span> (loc = 0; loc &lt; nmp-&gt;nm_locations.nl_numlocs; loc++) {
			nfsmerr_if(error);
			MALLOC(fsl, <span class="enscript-type">struct</span> nfs_fs_location *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_fs_location), M_TEMP, M_WAITOK|M_ZERO);
			<span class="enscript-keyword">if</span> (!fsl)
				error = ENOMEM;
			nmp-&gt;nm_locations.nl_locations[loc] = fsl;
			xb_get_32(error, &amp;xb, fsl-&gt;nl_servcount); <span class="enscript-comment">/* server count */</span>
			<span class="enscript-comment">/* sanity check server count */</span>
			<span class="enscript-keyword">if</span> (!error &amp;&amp; ((fsl-&gt;nl_servcount &lt; 1) || (fsl-&gt;nl_servcount &gt; 256)))
				error = EINVAL;
			nfsmerr_if(error);
			MALLOC(fsl-&gt;nl_servers, <span class="enscript-type">struct</span> nfs_fs_server **, fsl-&gt;nl_servcount * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_fs_server*), M_TEMP, M_WAITOK|M_ZERO);
			<span class="enscript-keyword">if</span> (!fsl-&gt;nl_servers)
				error = ENOMEM;
			<span class="enscript-keyword">for</span> (serv = 0; serv &lt; fsl-&gt;nl_servcount; serv++) {
				nfsmerr_if(error);
				MALLOC(fss, <span class="enscript-type">struct</span> nfs_fs_server *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_fs_server), M_TEMP, M_WAITOK|M_ZERO);
				<span class="enscript-keyword">if</span> (!fss)
					error = ENOMEM;
				fsl-&gt;nl_servers[serv] = fss;
				xb_get_32(error, &amp;xb, val); <span class="enscript-comment">/* server name length */</span>
				<span class="enscript-comment">/* sanity check server name length */</span>
				<span class="enscript-keyword">if</span> (!error &amp;&amp; ((val &lt; 1) || (val &gt; MAXPATHLEN)))
					error = EINVAL;
				nfsmerr_if(error);
				MALLOC(fss-&gt;ns_name, <span class="enscript-type">char</span> *, val+1, M_TEMP, M_WAITOK|M_ZERO);
				<span class="enscript-keyword">if</span> (!fss-&gt;ns_name)
					error = ENOMEM;
				nfsmerr_if(error);
				error = xb_get_bytes(&amp;xb, fss-&gt;ns_name, val, 0); <span class="enscript-comment">/* server name */</span>
				xb_get_32(error, &amp;xb, fss-&gt;ns_addrcount); <span class="enscript-comment">/* address count */</span>
				<span class="enscript-comment">/* sanity check address count (OK to be zero) */</span>
				<span class="enscript-keyword">if</span> (!error &amp;&amp; (fss-&gt;ns_addrcount &gt; 256))
					error = EINVAL;
				nfsmerr_if(error);
				<span class="enscript-keyword">if</span> (fss-&gt;ns_addrcount &gt; 0) {
					MALLOC(fss-&gt;ns_addresses, <span class="enscript-type">char</span> **, fss-&gt;ns_addrcount * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span> *), M_TEMP, M_WAITOK|M_ZERO);
					<span class="enscript-keyword">if</span> (!fss-&gt;ns_addresses)
						error = ENOMEM;
					<span class="enscript-keyword">for</span> (addr = 0; addr &lt; fss-&gt;ns_addrcount; addr++) {
						xb_get_32(error, &amp;xb, val); <span class="enscript-comment">/* address length */</span>
						<span class="enscript-comment">/* sanity check address length */</span>
						<span class="enscript-keyword">if</span> (!error &amp;&amp; ((val &lt; 1) || (val &gt; 128)))
							error = EINVAL;
						nfsmerr_if(error);
						MALLOC(fss-&gt;ns_addresses[addr], <span class="enscript-type">char</span> *, val+1, M_TEMP, M_WAITOK|M_ZERO);
						<span class="enscript-keyword">if</span> (!fss-&gt;ns_addresses[addr])
							error = ENOMEM;
						nfsmerr_if(error);
						error = xb_get_bytes(&amp;xb, fss-&gt;ns_addresses[addr], val, 0); <span class="enscript-comment">/* address */</span>
					}
				}
				xb_get_32(error, &amp;xb, val); <span class="enscript-comment">/* server info length */</span>
				xb_skip(error, &amp;xb, val); <span class="enscript-comment">/* skip server info */</span>
			}
			<span class="enscript-comment">/* get pathname */</span>
			fsp = &amp;fsl-&gt;nl_path;
			xb_get_32(error, &amp;xb, fsp-&gt;np_compcount); <span class="enscript-comment">/* component count */</span>
			<span class="enscript-comment">/* sanity check component count */</span>
			<span class="enscript-keyword">if</span> (!error &amp;&amp; (fsp-&gt;np_compcount &gt; MAXPATHLEN))
				error = EINVAL;
			nfsmerr_if(error);
			<span class="enscript-keyword">if</span> (fsp-&gt;np_compcount) {
				MALLOC(fsp-&gt;np_components, <span class="enscript-type">char</span> **, fsp-&gt;np_compcount * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">char</span>*), M_TEMP, M_WAITOK|M_ZERO);
				<span class="enscript-keyword">if</span> (!fsp-&gt;np_components)
					error = ENOMEM;
			}
			<span class="enscript-keyword">for</span> (comp = 0; comp &lt; fsp-&gt;np_compcount; comp++) {
				xb_get_32(error, &amp;xb, val); <span class="enscript-comment">/* component length */</span>
				<span class="enscript-comment">/* sanity check component length */</span>
				<span class="enscript-keyword">if</span> (!error &amp;&amp; (val == 0)) {
					<span class="enscript-comment">/*
					 * Apparently some people think a path with zero components should
					 * be encoded with one zero-length component.  So, just ignore any
					 * zero length components.
					 */</span>
					comp--;
					fsp-&gt;np_compcount--;
					<span class="enscript-keyword">if</span> (fsp-&gt;np_compcount == 0) {
						FREE(fsp-&gt;np_components, M_TEMP);
						fsp-&gt;np_components = NULL;
					}
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">if</span> (!error &amp;&amp; ((val &lt; 1) || (val &gt; MAXPATHLEN)))
					error = EINVAL;
				nfsmerr_if(error);
				MALLOC(fsp-&gt;np_components[comp], <span class="enscript-type">char</span> *, val+1, M_TEMP, M_WAITOK|M_ZERO);
				<span class="enscript-keyword">if</span> (!fsp-&gt;np_components[comp])
					error = ENOMEM;
				nfsmerr_if(error);
				error = xb_get_bytes(&amp;xb, fsp-&gt;np_components[comp], val, 0); <span class="enscript-comment">/* component */</span>
			}
			xb_get_32(error, &amp;xb, val); <span class="enscript-comment">/* fs location info length */</span>
			xb_skip(error, &amp;xb, val); <span class="enscript-comment">/* skip fs location info */</span>
		}
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_MNTFLAGS))
		xb_skip(error, &amp;xb, XDRWORD);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_MNTFROM)) {
		xb_get_32(error, &amp;xb, len);
		nfsmerr_if(error);
		val = len;
		<span class="enscript-keyword">if</span> (val &gt;= <span class="enscript-keyword">sizeof</span>(vfs_statfs(mp)-&gt;f_mntfromname))
			val = <span class="enscript-keyword">sizeof</span>(vfs_statfs(mp)-&gt;f_mntfromname) - 1;
		error = xb_get_bytes(&amp;xb, vfs_statfs(mp)-&gt;f_mntfromname, val, 0);
		<span class="enscript-keyword">if</span> ((len - val) &gt; 0)
			xb_skip(error, &amp;xb, len - val);
		nfsmerr_if(error);
		vfs_statfs(mp)-&gt;f_mntfromname[val] = <span class="enscript-string">'\0'</span>;
	}
	nfsmerr_if(error);

	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_REALM)) {
		xb_get_32(error, &amp;xb, len);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; ((len &lt; 1) || (len &gt; MAXPATHLEN)))
			error=EINVAL;
		nfsmerr_if(error);
		<span class="enscript-comment">/* allocate an extra byte for a leading '@' if its not already prepended to the realm */</span>
		MALLOC(nmp-&gt;nm_realm, <span class="enscript-type">char</span> *, len+2, M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (!nmp-&gt;nm_realm)
			error = ENOMEM;
		nfsmerr_if(error);
		error = xb_get_bytes(&amp;xb, nmp-&gt;nm_realm, len, 0);
		<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; *nmp-&gt;nm_realm != <span class="enscript-string">'@'</span>) {
			bcopy(nmp-&gt;nm_realm, &amp;nmp-&gt;nm_realm[1], len);
			nmp-&gt;nm_realm[0] = <span class="enscript-string">'@'</span>;
		}
	}
	nfsmerr_if(error);

	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_PRINCIPAL)) {
		xb_get_32(error, &amp;xb, len);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; ((len &lt; 1) || (len &gt; MAXPATHLEN)))
			error=EINVAL;
		nfsmerr_if(error);
		MALLOC(nmp-&gt;nm_principal, <span class="enscript-type">char</span> *, len+1, M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (!nmp-&gt;nm_principal)
			error = ENOMEM;
		nfsmerr_if(error);
		error = xb_get_bytes(&amp;xb, nmp-&gt;nm_principal, len, 0);
	}
	nfsmerr_if(error);

	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_SVCPRINCIPAL)) {
		xb_get_32(error, &amp;xb, len);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; ((len &lt; 1) || (len &gt; MAXPATHLEN)))
			error=EINVAL;
		nfsmerr_if(error);
		MALLOC(nmp-&gt;nm_sprinc, <span class="enscript-type">char</span> *, len+1, M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (!nmp-&gt;nm_sprinc)
			error = ENOMEM;
		nfsmerr_if(error);
		error = xb_get_bytes(&amp;xb, nmp-&gt;nm_sprinc, len, 0);
	}
	nfsmerr_if(error);

	<span class="enscript-comment">/*
	 * Sanity check/finalize settings.
	 */</span>

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_timeo &lt; NFS_MINTIMEO)
		nmp-&gt;nm_timeo = NFS_MINTIMEO;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nmp-&gt;nm_timeo &gt; NFS_MAXTIMEO)
		nmp-&gt;nm_timeo = NFS_MAXTIMEO;
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_retry &gt; NFS_MAXREXMIT)
		nmp-&gt;nm_retry = NFS_MAXREXMIT;

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_numgrps &gt; NFS_MAXGRPS)
		nmp-&gt;nm_numgrps = NFS_MAXGRPS;
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_readahead &gt; NFS_MAXRAHEAD)
		nmp-&gt;nm_readahead = NFS_MAXRAHEAD;
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_acregmin &gt; nmp-&gt;nm_acregmax)
		nmp-&gt;nm_acregmin = nmp-&gt;nm_acregmax;
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_acdirmin &gt; nmp-&gt;nm_acdirmax)
		nmp-&gt;nm_acdirmin = nmp-&gt;nm_acdirmax;

	<span class="enscript-comment">/* need at least one fs location */</span>
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_locations.nl_numlocs &lt; 1)
		error = EINVAL;
	nfsmerr_if(error);

	<span class="enscript-comment">/* init mount's mntfromname to first location */</span>
	<span class="enscript-keyword">if</span> (!NM_OMATTR_GIVEN(nmp, MNTFROM))
		nfs_location_mntfromname(&amp;nmp-&gt;nm_locations, firstloc,
			vfs_statfs(mp)-&gt;f_mntfromname, <span class="enscript-keyword">sizeof</span>(vfs_statfs(mp)-&gt;f_mntfromname), 0);

	<span class="enscript-comment">/* Need to save the mounting credential for v4. */</span>
	nmp-&gt;nm_mcred = vfs_context_ucred(ctx);
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(nmp-&gt;nm_mcred))
		kauth_cred_ref(nmp-&gt;nm_mcred);

	<span class="enscript-comment">/*
	 * If a reserved port is required, check for that privilege.
	 * (Note that mirror mounts are exempt because the privilege was
	 * already checked for the original mount.)
	 */</span>
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, RESVPORT) &amp;&amp; !vfs_iskernelmount(mp))
		error = priv_check_cred(nmp-&gt;nm_mcred, PRIV_NETINET_RESERVEDPORT, 0);
	nfsmerr_if(error);

	<span class="enscript-comment">/* do mount's initial socket connection */</span>
	error = nfs_mount_connect(nmp);
	nfsmerr_if(error);

	<span class="enscript-comment">/* set up the version-specific function tables */</span>
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &lt; NFS_VER4)
		nmp-&gt;nm_funcs = &amp;nfs3_funcs;
	<span class="enscript-keyword">else</span>
		nmp-&gt;nm_funcs = &amp;nfs4_funcs;

	<span class="enscript-comment">/* sanity check settings now that version/connection is set */</span>
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers == NFS_VER2)		<span class="enscript-comment">/* ignore RDIRPLUS on NFSv2 */</span>
		NFS_BITMAP_CLR(nmp-&gt;nm_flags, NFS_MFLAG_RDIRPLUS);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4) {
		<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(nmp-&gt;nm_flags, NFS_MFLAG_ACLONLY)) <span class="enscript-comment">/* aclonly trumps noacl */</span>
			NFS_BITMAP_CLR(nmp-&gt;nm_flags, NFS_MFLAG_NOACL);
		NFS_BITMAP_CLR(nmp-&gt;nm_flags, NFS_MFLAG_CALLUMNT);
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_lockmode != NFS_LOCK_MODE_ENABLED)
			error = EINVAL; <span class="enscript-comment">/* disabled/local lock mode only allowed on v2/v3 */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* ignore these if not v4 */</span>
		NFS_BITMAP_CLR(nmp-&gt;nm_flags, NFS_MFLAG_NOCALLBACK);
		NFS_BITMAP_CLR(nmp-&gt;nm_flags, NFS_MFLAG_NONAMEDATTR);
		NFS_BITMAP_CLR(nmp-&gt;nm_flags, NFS_MFLAG_NOACL);
		NFS_BITMAP_CLR(nmp-&gt;nm_flags, NFS_MFLAG_ACLONLY);
	}
	nfsmerr_if(error);

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_sotype == SOCK_DGRAM) {
		<span class="enscript-comment">/* I/O size defaults for UDP are different */</span>
		<span class="enscript-keyword">if</span> (!NFS_BITMAP_ISSET(mattrs, NFS_MATTR_READ_SIZE))
			nmp-&gt;nm_rsize = NFS_DGRAM_RSIZE;
		<span class="enscript-keyword">if</span> (!NFS_BITMAP_ISSET(mattrs, NFS_MATTR_WRITE_SIZE))
			nmp-&gt;nm_wsize = NFS_DGRAM_WSIZE;
	}

	<span class="enscript-comment">/* round down I/O sizes to multiple of NFS_FABLKSIZE */</span>
	nmp-&gt;nm_rsize &amp;= ~(NFS_FABLKSIZE - 1);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_rsize &lt;= 0)
		nmp-&gt;nm_rsize = NFS_FABLKSIZE;
	nmp-&gt;nm_wsize &amp;= ~(NFS_FABLKSIZE - 1);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_wsize &lt;= 0)
		nmp-&gt;nm_wsize = NFS_FABLKSIZE;

	<span class="enscript-comment">/* and limit I/O sizes to maximum allowed */</span>
	maxio = (nmp-&gt;nm_vers == NFS_VER2) ? NFS_V2MAXDATA :
		(nmp-&gt;nm_sotype == SOCK_DGRAM) ? NFS_MAXDGRAMDATA : NFS_MAXDATA;
	<span class="enscript-keyword">if</span> (maxio &gt; NFS_MAXBSIZE)
		maxio = NFS_MAXBSIZE;
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_rsize &gt; maxio)
		nmp-&gt;nm_rsize = maxio;
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_wsize &gt; maxio)
		nmp-&gt;nm_wsize = maxio;

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_readdirsize &gt; maxio)
		nmp-&gt;nm_readdirsize = maxio;
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_readdirsize &gt; nmp-&gt;nm_rsize)
		nmp-&gt;nm_readdirsize = nmp-&gt;nm_rsize;

	<span class="enscript-comment">/* Set up the sockets and related info */</span>
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_sotype == SOCK_DGRAM)
		TAILQ_INIT(&amp;nmp-&gt;nm_cwndq);

	<span class="enscript-comment">/*
	 * Get the root node/attributes from the NFS server and
	 * do any basic, version-specific setup.
	 */</span>
	error = nmp-&gt;nm_funcs-&gt;nf_mount(nmp, ctx, &amp;np);
	nfsmerr_if(error);

	<span class="enscript-comment">/*
	 * A reference count is needed on the node representing the
	 * remote root.  If this object is not persistent, then backward
	 * traversals of the mount point (i.e. &quot;..&quot;) will not work if
	 * the node gets flushed out of the cache.
	 */</span>
	nmp-&gt;nm_dnp = np;
	*vpp = NFSTOV(np);
	<span class="enscript-comment">/* get usecount and drop iocount */</span>
	error = vnode_ref(*vpp);
	vnode_put(*vpp);
	<span class="enscript-keyword">if</span> (error) {
		vnode_recycle(*vpp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmerr</span>;
	}

	<span class="enscript-comment">/*
	 * Do statfs to ensure static info gets set to reasonable values.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = nmp-&gt;nm_funcs-&gt;nf_update_statfs(nmp, ctx))) {
		<span class="enscript-type">int</span> error2 = vnode_getwithref(*vpp);
		vnode_rele(*vpp);
		<span class="enscript-keyword">if</span> (!error2)
			vnode_put(*vpp);
		vnode_recycle(*vpp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmerr</span>;
	}
	sbp = vfs_statfs(mp);
	sbp-&gt;f_bsize = nmp-&gt;nm_fsattr.nfsa_bsize;
	sbp-&gt;f_blocks = nmp-&gt;nm_fsattr.nfsa_space_total / sbp-&gt;f_bsize;
	sbp-&gt;f_bfree = nmp-&gt;nm_fsattr.nfsa_space_free / sbp-&gt;f_bsize;
	sbp-&gt;f_bavail = nmp-&gt;nm_fsattr.nfsa_space_avail / sbp-&gt;f_bsize;
	sbp-&gt;f_bused = (nmp-&gt;nm_fsattr.nfsa_space_total / sbp-&gt;f_bsize) -
			(nmp-&gt;nm_fsattr.nfsa_space_free / sbp-&gt;f_bsize);
	sbp-&gt;f_files = nmp-&gt;nm_fsattr.nfsa_files_total;
	sbp-&gt;f_ffree = nmp-&gt;nm_fsattr.nfsa_files_free;
	sbp-&gt;f_iosize = nfs_iosize;

	<span class="enscript-comment">/*
	 * Calculate the size used for I/O buffers.  Use the larger
	 * of the two sizes to minimise NFS requests but make sure
	 * that it is at least one VM page to avoid wasting buffer
	 * space and to allow easy mmapping of I/O buffers.
	 * The read/write RPC calls handle the splitting up of
	 * buffers into multiple requests if the buffer size is
	 * larger than the I/O size.
	 */</span>
	iosize = max(nmp-&gt;nm_rsize, nmp-&gt;nm_wsize);
	<span class="enscript-keyword">if</span> (iosize &lt; PAGE_SIZE)
		iosize = PAGE_SIZE;
	nmp-&gt;nm_biosize = trunc_page_32(iosize);

	<span class="enscript-comment">/* For NFSv3 and greater, there is a (relatively) reliable ACCESS call. */</span>
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt; NFS_VER2)
		vfs_setauthopaqueaccess(mp);

	<span class="enscript-keyword">switch</span> (nmp-&gt;nm_lockmode) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_LOCK_MODE_DISABLED</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_LOCK_MODE_LOCAL</span>:
		vfs_setlocklocal(nmp-&gt;nm_mountp);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_LOCK_MODE_ENABLED</span>:
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &lt;= NFS_VER3)
			nfs_lockd_mount_register(nmp);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* success! */</span>
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	nmp-&gt;nm_state |= NFSSTA_MOUNTED;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">return</span> (0);
<span class="enscript-reference">nfsmerr</span>:
	nfs_mount_cleanup(nmp);
	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_TRIGGERS</span>

<span class="enscript-comment">/*
 * We've detected a file system boundary on the server and
 * need to mount a new file system so that our file systems
 * MIRROR the file systems on the server.
 *
 * Build the mount arguments for the new mount and call kernel_mount().
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_mirror_mount_domount</span>(vnode_t dvp, vnode_t vp, vfs_context_t ctx)
{
	nfsnode_t np = VTONFS(vp);
	nfsnode_t dnp = VTONFS(dvp);
	<span class="enscript-type">struct</span> nfsmount *nmp = NFSTONMP(np);
	<span class="enscript-type">char</span> fstype[MFSTYPENAMELEN], *mntfromname = NULL, *path = NULL, *relpath, *p, *cp;
	<span class="enscript-type">int</span> error = 0, pathbuflen = MAXPATHLEN, i, mntflags = 0, referral, skipcopy = 0;
	size_t nlen;
	<span class="enscript-type">struct</span> xdrbuf xb, xbnew;
	uint32_t mattrs[NFS_MATTR_BITMAP_LEN];
	uint32_t newmattrs[NFS_MATTR_BITMAP_LEN];
	uint32_t newmflags[NFS_MFLAG_BITMAP_LEN];
	uint32_t newmflags_mask[NFS_MFLAG_BITMAP_LEN];
	uint32_t argslength = 0, val, count, mlen, mlen2, rlen, relpathcomps;
	uint32_t argslength_offset, attrslength_offset, end_offset;
	uint32_t numlocs, loc, numserv, serv, numaddr, addr, numcomp, comp;
	<span class="enscript-type">char</span> buf[XDRWORD];
	<span class="enscript-type">struct</span> nfs_fs_locations nfsls;

	referral = (np-&gt;n_vattr.nva_flags &amp; NFS_FFLAG_TRIGGER_REFERRAL);
	<span class="enscript-keyword">if</span> (referral)
		bzero(&amp;nfsls, <span class="enscript-keyword">sizeof</span>(nfsls));

	xb_init(&amp;xbnew, 0);

	<span class="enscript-keyword">if</span> (!nmp || (nmp-&gt;nm_state &amp; (NFSSTA_FORCE|NFSSTA_DEAD)))
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-comment">/* allocate a couple path buffers we need */</span>
	MALLOC_ZONE(mntfromname, <span class="enscript-type">char</span> *, pathbuflen, M_NAMEI, M_WAITOK); 
	<span class="enscript-keyword">if</span> (!mntfromname) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmerr</span>;
	}
	MALLOC_ZONE(path, <span class="enscript-type">char</span> *, pathbuflen, M_NAMEI, M_WAITOK); 
	<span class="enscript-keyword">if</span> (!path) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmerr</span>;
	}

	<span class="enscript-comment">/* get the path for the directory being mounted on */</span>
	error = vn_getpath(vp, path, &amp;pathbuflen);
	<span class="enscript-keyword">if</span> (error) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmerr</span>;
	}

	<span class="enscript-comment">/*
	 * Set up the mntfromname for the new mount based on the
	 * current mount's mntfromname and the directory's path
	 * relative to the current mount's mntonname.
	 * Set up relpath to point at the relative path on the current mount.
	 * Also, count the number of components in relpath.
	 * We'll be adding those to each fs location path in the new args.
	 */</span>
	nlen = strlcpy(mntfromname, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, MAXPATHLEN);
	<span class="enscript-keyword">if</span> ((nlen &gt; 0) &amp;&amp; (mntfromname[nlen-1] == <span class="enscript-string">'/'</span>)) { <span class="enscript-comment">/* avoid double '/' in new name */</span>
		mntfromname[nlen-1] = <span class="enscript-string">'\0'</span>;
		nlen--;
	}
	relpath = mntfromname + nlen;
	nlen = strlcat(mntfromname, path + strlen(vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntonname), MAXPATHLEN);
	<span class="enscript-keyword">if</span> (nlen &gt;= MAXPATHLEN) {
		error = ENAMETOOLONG;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmerr</span>;
	}
	<span class="enscript-comment">/* count the number of components in relpath */</span>
	p = relpath;
	<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
		p++;
	relpathcomps = 0;
	<span class="enscript-keyword">while</span> (*p) {
		relpathcomps++;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p != <span class="enscript-string">'/'</span>))
			p++;
		<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
			p++;
	}

	<span class="enscript-comment">/* grab a copy of the file system type */</span>
	vfs_name(vnode_mount(vp), fstype);

	<span class="enscript-comment">/* for referrals, fetch the fs locations */</span>
	<span class="enscript-keyword">if</span> (referral) {
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *vname = vnode_getname(NFSTOV(np));
		<span class="enscript-keyword">if</span> (!vname) {
			error = ENOENT;
		} <span class="enscript-keyword">else</span> {
			error = nfs4_get_fs_locations(nmp, dnp, NULL, 0, vname, ctx, &amp;nfsls);
			vnode_putname(vname);
			<span class="enscript-keyword">if</span> (!error &amp;&amp; (nfsls.nl_numlocs &lt; 1))
				error = ENOENT;
		}
		nfsmerr_if(error);
	}

	<span class="enscript-comment">/* set up NFS mount args based on current mount args */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">xb_copy_32</span>(E, XBSRC, XBDST, V) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		xb_get_32((E), (XBSRC), (V)); \
		<span class="enscript-keyword">if</span> (skipcopy) <span class="enscript-keyword">break</span>; \
		xb_add_32((E), (XBDST), (V)); \
	} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xb_copy_opaque</span>(E, XBSRC, XBDST) \
	<span class="enscript-keyword">do</span> { \
		uint32_t __count, __val; \
		xb_copy_32((E), (XBSRC), (XBDST), __count); \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		__count = nfsm_rndup(__count); \
		__count /= XDRWORD; \
		<span class="enscript-keyword">while</span> (__count-- &gt; 0) \
			xb_copy_32((E), (XBSRC), (XBDST), __val); \
	} <span class="enscript-keyword">while</span> (0)

	xb_init_buffer(&amp;xb, nmp-&gt;nm_args, 2*XDRWORD);
	xb_get_32(error, &amp;xb, val); <span class="enscript-comment">/* version */</span>
	xb_get_32(error, &amp;xb, argslength); <span class="enscript-comment">/* args length */</span>
	xb_init_buffer(&amp;xb, nmp-&gt;nm_args, argslength);

	xb_init_buffer(&amp;xbnew, NULL, 0);
	xb_copy_32(error, &amp;xb, &amp;xbnew, val); <span class="enscript-comment">/* version */</span>
	argslength_offset = xb_offset(&amp;xbnew);
	xb_copy_32(error, &amp;xb, &amp;xbnew, val); <span class="enscript-comment">/* args length */</span>
	xb_copy_32(error, &amp;xb, &amp;xbnew, val); <span class="enscript-comment">/* XDR args version */</span>
	count = NFS_MATTR_BITMAP_LEN;
	xb_get_bitmap(error, &amp;xb, mattrs, count); <span class="enscript-comment">/* mount attribute bitmap */</span>
	nfsmerr_if(error);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; NFS_MATTR_BITMAP_LEN; i++)
		newmattrs[i] = mattrs[i];
	<span class="enscript-keyword">if</span> (referral)
		NFS_BITMAP_SET(newmattrs, NFS_MATTR_FS_LOCATIONS);
	<span class="enscript-keyword">else</span>
		NFS_BITMAP_SET(newmattrs, NFS_MATTR_FH);
	NFS_BITMAP_SET(newmattrs, NFS_MATTR_FLAGS);
	NFS_BITMAP_SET(newmattrs, NFS_MATTR_MNTFLAGS);
	NFS_BITMAP_CLR(newmattrs, NFS_MATTR_MNTFROM);
	xb_add_bitmap(error, &amp;xbnew, newmattrs, NFS_MATTR_BITMAP_LEN);
	attrslength_offset = xb_offset(&amp;xbnew);
	xb_copy_32(error, &amp;xb, &amp;xbnew, val); <span class="enscript-comment">/* attrs length */</span>
	NFS_BITMAP_ZERO(newmflags_mask, NFS_MFLAG_BITMAP_LEN);
	NFS_BITMAP_ZERO(newmflags, NFS_MFLAG_BITMAP_LEN);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_FLAGS)) {
		count = NFS_MFLAG_BITMAP_LEN;
		xb_get_bitmap(error, &amp;xb, newmflags_mask, count); <span class="enscript-comment">/* mount flag mask bitmap */</span>
		count = NFS_MFLAG_BITMAP_LEN;
		xb_get_bitmap(error, &amp;xb, newmflags, count); <span class="enscript-comment">/* mount flag bitmap */</span>
	}
	NFS_BITMAP_SET(newmflags_mask, NFS_MFLAG_EPHEMERAL);
	NFS_BITMAP_SET(newmflags, NFS_MFLAG_EPHEMERAL);
	xb_add_bitmap(error, &amp;xbnew, newmflags_mask, NFS_MFLAG_BITMAP_LEN);
	xb_add_bitmap(error, &amp;xbnew, newmflags, NFS_MFLAG_BITMAP_LEN);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_NFS_VERSION))
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_NFS_MINOR_VERSION))
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_NFS_VERSION_RANGE)) {
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_READ_SIZE))
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_WRITE_SIZE))
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_READDIR_SIZE))
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_READAHEAD))
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_ATTRCACHE_REG_MIN)) {
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_ATTRCACHE_REG_MAX)) {
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_ATTRCACHE_DIR_MIN)) {
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_ATTRCACHE_DIR_MAX)) {
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_LOCK_MODE))
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_SECURITY)) {
		xb_copy_32(error, &amp;xb, &amp;xbnew, count);
		<span class="enscript-keyword">while</span> (!error &amp;&amp; (count-- &gt; 0))
			xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_MAX_GROUP_LIST))
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_SOCKET_TYPE))
		xb_copy_opaque(error, &amp;xb, &amp;xbnew);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_NFS_PORT))
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_MOUNT_PORT))
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_REQUEST_TIMEOUT)) {
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_SOFT_RETRY_COUNT))
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_DEAD_TIMEOUT)) {
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
		xb_copy_32(error, &amp;xb, &amp;xbnew, val);
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_FH)) {
		xb_get_32(error, &amp;xb, count);
		xb_skip(error, &amp;xb, count);
	}
	<span class="enscript-keyword">if</span> (!referral) {
		<span class="enscript-comment">/* set the initial file handle to the directory's file handle */</span>
		xb_add_fh(error, &amp;xbnew, np-&gt;n_fhp, np-&gt;n_fhsize);
	}
	<span class="enscript-comment">/* copy/extend/skip fs locations */</span>
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_FS_LOCATIONS)) {
		numlocs = numserv = numaddr = numcomp = 0;
		<span class="enscript-keyword">if</span> (referral) <span class="enscript-comment">/* don't copy the fs locations for a referral */</span>
			skipcopy = 1;
		xb_copy_32(error, &amp;xb, &amp;xbnew, numlocs); <span class="enscript-comment">/* location count */</span>
		<span class="enscript-keyword">for</span> (loc = 0; !error &amp;&amp; (loc &lt; numlocs); loc++) {
			xb_copy_32(error, &amp;xb, &amp;xbnew, numserv); <span class="enscript-comment">/* server count */</span>
			<span class="enscript-keyword">for</span> (serv = 0; !error &amp;&amp; (serv &lt; numserv); serv++) {
				xb_copy_opaque(error, &amp;xb, &amp;xbnew); <span class="enscript-comment">/* server name */</span>
				xb_copy_32(error, &amp;xb, &amp;xbnew, numaddr); <span class="enscript-comment">/* address count */</span>
				<span class="enscript-keyword">for</span> (addr = 0; !error &amp;&amp; (addr &lt; numaddr); addr++)
					xb_copy_opaque(error, &amp;xb, &amp;xbnew); <span class="enscript-comment">/* address */</span>
				xb_copy_opaque(error, &amp;xb, &amp;xbnew); <span class="enscript-comment">/* server info */</span>
			}
			<span class="enscript-comment">/* pathname */</span>
			xb_get_32(error, &amp;xb, numcomp); <span class="enscript-comment">/* component count */</span>
			<span class="enscript-keyword">if</span> (!skipcopy)
				xb_add_32(error, &amp;xbnew, numcomp+relpathcomps); <span class="enscript-comment">/* new component count */</span>
			<span class="enscript-keyword">for</span> (comp = 0; !error &amp;&amp; (comp &lt; numcomp); comp++)
				xb_copy_opaque(error, &amp;xb, &amp;xbnew); <span class="enscript-comment">/* component */</span>
			<span class="enscript-comment">/* add additional components */</span>
			<span class="enscript-keyword">for</span> (comp = 0; !skipcopy &amp;&amp; !error &amp;&amp; (comp &lt; relpathcomps); comp++) {
				p = relpath;
				<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
					p++;
				<span class="enscript-keyword">while</span> (*p &amp;&amp; !error) {
					cp = p;
					<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p != <span class="enscript-string">'/'</span>))
						p++;
					xb_add_string(error, &amp;xbnew, cp, (p - cp)); <span class="enscript-comment">/* component */</span>
					<span class="enscript-keyword">while</span> (*p &amp;&amp; (*p == <span class="enscript-string">'/'</span>))
						p++;
				}
			}
			xb_copy_opaque(error, &amp;xb, &amp;xbnew); <span class="enscript-comment">/* fs location info */</span>
		}
		<span class="enscript-keyword">if</span> (referral)
			skipcopy = 0;
	}
	<span class="enscript-keyword">if</span> (referral) {
		<span class="enscript-comment">/* add referral's fs locations */</span>
		xb_add_32(error, &amp;xbnew, nfsls.nl_numlocs);			<span class="enscript-comment">/* FS_LOCATIONS */</span>
		<span class="enscript-keyword">for</span> (loc = 0; !error &amp;&amp; (loc &lt; nfsls.nl_numlocs); loc++) {
			xb_add_32(error, &amp;xbnew, nfsls.nl_locations[loc]-&gt;nl_servcount);
			<span class="enscript-keyword">for</span> (serv = 0; !error &amp;&amp; (serv &lt; nfsls.nl_locations[loc]-&gt;nl_servcount); serv++) {
				xb_add_string(error, &amp;xbnew, nfsls.nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_name,
					strlen(nfsls.nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_name));
				xb_add_32(error, &amp;xbnew, nfsls.nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_addrcount);
				<span class="enscript-keyword">for</span> (addr = 0; !error &amp;&amp; (addr &lt; nfsls.nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_addrcount); addr++)
					xb_add_string(error, &amp;xbnew, nfsls.nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_addresses[addr],
						strlen(nfsls.nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_addresses[addr]));
				xb_add_32(error, &amp;xbnew, 0); <span class="enscript-comment">/* empty server info */</span>
			}
			xb_add_32(error, &amp;xbnew, nfsls.nl_locations[loc]-&gt;nl_path.np_compcount);
			<span class="enscript-keyword">for</span> (comp = 0; !error &amp;&amp; (comp &lt; nfsls.nl_locations[loc]-&gt;nl_path.np_compcount); comp++)
				xb_add_string(error, &amp;xbnew, nfsls.nl_locations[loc]-&gt;nl_path.np_components[comp],
					strlen(nfsls.nl_locations[loc]-&gt;nl_path.np_components[comp]));
			xb_add_32(error, &amp;xbnew, 0); <span class="enscript-comment">/* empty fs location info */</span>
		}
	}
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_MNTFLAGS))
		xb_get_32(error, &amp;xb, mntflags);
	<span class="enscript-comment">/*
	 * We add the following mount flags to the ones for the mounted-on mount:
	 * MNT_DONTBROWSE - to keep the mount from showing up as a separate volume
	 * MNT_AUTOMOUNTED - to keep DiskArb from retriggering the mount after
	 *                   an unmount (looking for /.autodiskmounted)
	 */</span>
	mntflags |= (MNT_AUTOMOUNTED | MNT_DONTBROWSE);
	xb_add_32(error, &amp;xbnew, mntflags);
	<span class="enscript-keyword">if</span> (!referral &amp;&amp; NFS_BITMAP_ISSET(mattrs, NFS_MATTR_MNTFROM)) {
		<span class="enscript-comment">/* copy mntfrom string and add relpath */</span>
		rlen = strlen(relpath);
		xb_get_32(error, &amp;xb, mlen);
		nfsmerr_if(error);
		mlen2 = mlen + ((relpath[0] != <span class="enscript-string">'/'</span>) ? 1 : 0) + rlen;
		xb_add_32(error, &amp;xbnew, mlen2);
		count = mlen/XDRWORD;
		<span class="enscript-comment">/* copy the original string */</span>
		<span class="enscript-keyword">while</span> (count-- &gt; 0)
			xb_copy_32(error, &amp;xb, &amp;xbnew, val);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; (mlen % XDRWORD)) {
			error = xb_get_bytes(&amp;xb, buf, mlen%XDRWORD, 0);
			<span class="enscript-keyword">if</span> (!error)
				error = xb_add_bytes(&amp;xbnew, buf, mlen%XDRWORD, 1);
		}
		<span class="enscript-comment">/* insert a '/' if the relative path doesn't start with one */</span>
		<span class="enscript-keyword">if</span> (!error &amp;&amp; (relpath[0] != <span class="enscript-string">'/'</span>)) {
			buf[0] = <span class="enscript-string">'/'</span>;
			error = xb_add_bytes(&amp;xbnew, buf, 1, 1);
		}
		<span class="enscript-comment">/* add the additional relative path */</span>
		<span class="enscript-keyword">if</span> (!error)
			error = xb_add_bytes(&amp;xbnew, relpath, rlen, 1);
		<span class="enscript-comment">/* make sure the resulting string has the right number of pad bytes */</span>
		<span class="enscript-keyword">if</span> (!error &amp;&amp; (mlen2 != nfsm_rndup(mlen2))) {
			bzero(buf, <span class="enscript-keyword">sizeof</span>(buf));
			count = nfsm_rndup(mlen2) - mlen2;
			error = xb_add_bytes(&amp;xbnew, buf, count, 1);
		}
	}
	xb_build_done(error, &amp;xbnew);

	<span class="enscript-comment">/* update opaque counts */</span>
	end_offset = xb_offset(&amp;xbnew);
	<span class="enscript-keyword">if</span> (!error) {
		error = xb_seek(&amp;xbnew, argslength_offset);
		argslength = end_offset - argslength_offset + XDRWORD<span class="enscript-comment">/*version*/</span>;
		xb_add_32(error, &amp;xbnew, argslength);
	}
	<span class="enscript-keyword">if</span> (!error) {
		error = xb_seek(&amp;xbnew, attrslength_offset);
		xb_add_32(error, &amp;xbnew, end_offset - attrslength_offset - XDRWORD<span class="enscript-comment">/*don't include length field*/</span>);
	}
	nfsmerr_if(error);

	<span class="enscript-comment">/*
	 * For kernel_mount() call, use the existing mount flags (instead of the
	 * original flags) because flags like MNT_NOSUID and MNT_NODEV may have
	 * been silently enforced.
	 */</span>
	mntflags = vnode_vfsvisflags(vp);
	mntflags |= (MNT_AUTOMOUNTED | MNT_DONTBROWSE);

	<span class="enscript-comment">/* do the mount */</span>
	error = kernel_mount(fstype, dvp, vp, path, xb_buffer_base(&amp;xbnew), argslength,
			mntflags, KERNEL_MOUNT_PERMIT_UNMOUNT | KERNEL_MOUNT_NOAUTH, ctx);

<span class="enscript-reference">nfsmerr</span>:
	<span class="enscript-keyword">if</span> (error)
		printf(<span class="enscript-string">&quot;nfs: mirror mount of %s on %s failed (%d)\n&quot;</span>,
			mntfromname, path, error);
	<span class="enscript-comment">/* clean up */</span>
	xb_cleanup(&amp;xbnew);
	<span class="enscript-keyword">if</span> (referral)
		nfs_fs_locations_cleanup(&amp;nfsls);
	<span class="enscript-keyword">if</span> (path)
		FREE_ZONE(path, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">if</span> (mntfromname)
		FREE_ZONE(mntfromname, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">if</span> (!error)
		nfs_ephemeral_mount_harvester_start();
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * trigger vnode functions
 */</span>

resolver_result_t
<span class="enscript-function-name">nfs_mirror_mount_trigger_resolve</span>(
	vnode_t vp,
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> componentname *cnp,
	<span class="enscript-type">enum</span> path_operation pop,
	__unused <span class="enscript-type">int</span> flags,
	__unused <span class="enscript-type">void</span> *data,
	vfs_context_t ctx)
{
	nfsnode_t np = VTONFS(vp);
	vnode_t pvp = NULLVP;
	<span class="enscript-type">int</span> error = 0;
	resolver_result_t result;

	<span class="enscript-comment">/*
	 * We have a trigger node that doesn't have anything mounted on it yet.
	 * We'll do the mount if either:
	 * (a) this isn't the last component of the path OR
	 * (b) this is an op that looks like it should trigger the mount.
	 */</span>
	<span class="enscript-keyword">if</span> (cnp-&gt;cn_flags &amp; ISLASTCN) {
		<span class="enscript-keyword">switch</span> (pop) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_MOUNT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_UNMOUNT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_STATFS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_LINK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_UNLINK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_RENAME</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_MKNOD</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_MKFIFO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_SYMLINK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_ACCESS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_GETATTR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_MKDIR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_RMDIR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_REVOKE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_GETXATTR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_LISTXATTR</span>:
			<span class="enscript-comment">/* don't perform the mount for these operations */</span>
			result = vfs_resolver_result(np-&gt;n_trigseq, RESOLVER_NOCHANGE, 0);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFS_TRIGGER_DEBUG</span>
			NP(np, <span class="enscript-string">&quot;nfs trigger RESOLVE: no change, last %d nameiop %d, seq %d&quot;</span>,
				(cnp-&gt;cn_flags &amp; ISLASTCN) ? 1 : 0, cnp-&gt;cn_nameiop, np-&gt;n_trigseq);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">return</span> (result);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_OPEN</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_CHDIR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_CHROOT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_TRUNCATE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_COPYFILE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_PATHCONF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_READLINK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_SETATTR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_EXCHANGEDATA</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_SEARCHFS</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_FSCTL</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_SETXATTR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OP_REMOVEXATTR</span>:
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* go ahead and do the mount */</span>
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (vnode_mountedhere(vp) != NULL) {
		<span class="enscript-comment">/*
		 * Um... there's already something mounted.
		 * Been there.  Done that.  Let's just say it succeeded.
		 */</span>
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">skipmount</span>;
	}

	<span class="enscript-keyword">if</span> ((error = nfs_node_set_busy(np, vfs_context_thread(ctx)))) {
		result = vfs_resolver_result(np-&gt;n_trigseq, RESOLVER_ERROR, error);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFS_TRIGGER_DEBUG</span>
		NP(np, <span class="enscript-string">&quot;nfs trigger RESOLVE: busy error %d, last %d nameiop %d, seq %d&quot;</span>,
			error, (cnp-&gt;cn_flags &amp; ISLASTCN) ? 1 : 0, cnp-&gt;cn_nameiop, np-&gt;n_trigseq);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span> (result);
	}

	pvp = vnode_getparent(vp);
	<span class="enscript-keyword">if</span> (pvp == NULLVP)
		error = EINVAL;
	<span class="enscript-keyword">if</span> (!error)
		error = nfs_mirror_mount_domount(pvp, vp, ctx);
<span class="enscript-reference">skipmount</span>:
	<span class="enscript-keyword">if</span> (!error)
		np-&gt;n_trigseq++;
	result = vfs_resolver_result(np-&gt;n_trigseq, error ? RESOLVER_ERROR : RESOLVER_RESOLVED, error);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFS_TRIGGER_DEBUG</span>
	NP(np, <span class="enscript-string">&quot;nfs trigger RESOLVE: %s %d, last %d nameiop %d, seq %d&quot;</span>,
		error ? <span class="enscript-string">&quot;error&quot;</span> : <span class="enscript-string">&quot;resolved&quot;</span>, error,
		(cnp-&gt;cn_flags &amp; ISLASTCN) ? 1 : 0, cnp-&gt;cn_nameiop, np-&gt;n_trigseq);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (pvp != NULLVP)
		vnode_put(pvp);
	nfs_node_clear_busy(np);
	<span class="enscript-keyword">return</span> (result);
}

resolver_result_t
<span class="enscript-function-name">nfs_mirror_mount_trigger_unresolve</span>(
	vnode_t vp,
	<span class="enscript-type">int</span> flags,
	__unused <span class="enscript-type">void</span> *data,
	vfs_context_t ctx)
{
	nfsnode_t np = VTONFS(vp);
	mount_t mp;
	<span class="enscript-type">int</span> error;
	resolver_result_t result;

	<span class="enscript-keyword">if</span> ((error = nfs_node_set_busy(np, vfs_context_thread(ctx)))) {
		result = vfs_resolver_result(np-&gt;n_trigseq, RESOLVER_ERROR, error);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFS_TRIGGER_DEBUG</span>
		NP(np, <span class="enscript-string">&quot;nfs trigger UNRESOLVE: busy error %d, seq %d&quot;</span>, error, np-&gt;n_trigseq);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span> (result);
	}

	mp = vnode_mountedhere(vp);
	<span class="enscript-keyword">if</span> (!mp)
		error = EINVAL;
	<span class="enscript-keyword">if</span> (!error)
		error = vfs_unmountbyfsid(&amp;(vfs_statfs(mp)-&gt;f_fsid), flags, ctx);
	<span class="enscript-keyword">if</span> (!error)
		np-&gt;n_trigseq++;
	result = vfs_resolver_result(np-&gt;n_trigseq, error ? RESOLVER_ERROR : RESOLVER_UNRESOLVED, error);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFS_TRIGGER_DEBUG</span>
	NP(np, <span class="enscript-string">&quot;nfs trigger UNRESOLVE: %s %d, seq %d&quot;</span>,
		error ? <span class="enscript-string">&quot;error&quot;</span> : <span class="enscript-string">&quot;unresolved&quot;</span>, error, np-&gt;n_trigseq);
#<span class="enscript-reference">endif</span>
	nfs_node_clear_busy(np);
	<span class="enscript-keyword">return</span> (result);
}

resolver_result_t
<span class="enscript-function-name">nfs_mirror_mount_trigger_rearm</span>(
	vnode_t vp,
	__unused <span class="enscript-type">int</span> flags,
	__unused <span class="enscript-type">void</span> *data,
	vfs_context_t ctx)
{
	nfsnode_t np = VTONFS(vp);
	<span class="enscript-type">int</span> error;
	resolver_result_t result;

	<span class="enscript-keyword">if</span> ((error = nfs_node_set_busy(np, vfs_context_thread(ctx)))) {
		result = vfs_resolver_result(np-&gt;n_trigseq, RESOLVER_ERROR, error);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFS_TRIGGER_DEBUG</span>
		NP(np, <span class="enscript-string">&quot;nfs trigger REARM: busy error %d, seq %d&quot;</span>, error, np-&gt;n_trigseq);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span> (result);
	}

	np-&gt;n_trigseq++;
	result = vfs_resolver_result(np-&gt;n_trigseq,
			vnode_mountedhere(vp) ? RESOLVER_RESOLVED : RESOLVER_UNRESOLVED, 0);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFS_TRIGGER_DEBUG</span>
	NP(np, <span class="enscript-string">&quot;nfs trigger REARM: %s, seq %d&quot;</span>,
		vnode_mountedhere(vp) ? <span class="enscript-string">&quot;resolved&quot;</span> : <span class="enscript-string">&quot;unresolved&quot;</span>, np-&gt;n_trigseq);
#<span class="enscript-reference">endif</span>
	nfs_node_clear_busy(np);
	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">/*
 * Periodically attempt to unmount ephemeral (mirror) mounts in an attempt to limit
 * the number of unused mounts.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_EPHEMERAL_MOUNT_HARVEST_INTERVAL</span>	120	<span class="enscript-comment">/* how often the harvester runs */</span>
<span class="enscript-type">struct</span> nfs_ephemeral_mount_harvester_info {
	fsid_t		fsid;		<span class="enscript-comment">/* FSID that we need to try to unmount */</span>
	uint32_t	mountcount;	<span class="enscript-comment">/* count of ephemeral mounts seen in scan */</span>
 };
<span class="enscript-comment">/* various globals for the harvester */</span>
<span class="enscript-type">static</span> thread_call_t nfs_ephemeral_mount_harvester_timer = NULL;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> nfs_ephemeral_mount_harvester_on = 0;

kern_return_t <span class="enscript-function-name">thread_terminate</span>(thread_t);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_ephemeral_mount_harvester_callback</span>(mount_t mp, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> nfs_ephemeral_mount_harvester_info *hinfo = arg;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> timeval now;

	<span class="enscript-keyword">if</span> (strcmp(mp-&gt;mnt_vfsstat.f_fstypename, <span class="enscript-string">&quot;nfs&quot;</span>))
		<span class="enscript-keyword">return</span> (VFS_RETURNED);
	nmp = VFSTONFS(mp);
	<span class="enscript-keyword">if</span> (!nmp || !NMFLAG(nmp, EPHEMERAL))
		<span class="enscript-keyword">return</span> (VFS_RETURNED);
	hinfo-&gt;mountcount++;

	<span class="enscript-comment">/* avoid unmounting mounts that have been triggered within the last harvest interval */</span>
	microtime(&amp;now);
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_mounttime &gt;&gt; 32) &gt; ((uint32_t)now.tv_sec - NFS_EPHEMERAL_MOUNT_HARVEST_INTERVAL))
		<span class="enscript-keyword">return</span> (VFS_RETURNED);

	<span class="enscript-keyword">if</span> (hinfo-&gt;fsid.val[0] || hinfo-&gt;fsid.val[1]) {
		<span class="enscript-comment">/* attempt to unmount previously-found ephemeral mount */</span>
		vfs_unmountbyfsid(&amp;hinfo-&gt;fsid, 0, vfs_context_kernel());
		hinfo-&gt;fsid.val[0] = hinfo-&gt;fsid.val[1] = 0;
	}

	<span class="enscript-comment">/*
	 * We can't call unmount here since we hold a mount iter ref
	 * on mp so save its fsid for the next call iteration to unmount.
	 */</span>
	hinfo-&gt;fsid.val[0] = mp-&gt;mnt_vfsstat.f_fsid.val[0];
	hinfo-&gt;fsid.val[1] = mp-&gt;mnt_vfsstat.f_fsid.val[1];

	<span class="enscript-keyword">return</span> (VFS_RETURNED);
}

<span class="enscript-comment">/*
 * Spawn a thread to do the ephemeral mount harvesting.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_ephemeral_mount_harvester_timer_func</span>(<span class="enscript-type">void</span>)
{
	thread_t thd;

	<span class="enscript-keyword">if</span> (kernel_thread_start(nfs_ephemeral_mount_harvester, NULL, &amp;thd) == KERN_SUCCESS)
		thread_deallocate(thd);
}

<span class="enscript-comment">/*
 * Iterate all mounts looking for NFS ephemeral mounts to try to unmount.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_ephemeral_mount_harvester</span>(__unused <span class="enscript-type">void</span> *arg, __unused wait_result_t wr)
{
	<span class="enscript-type">struct</span> nfs_ephemeral_mount_harvester_info hinfo;
	uint64_t deadline;

	hinfo.mountcount = 0;
	hinfo.fsid.val[0] = hinfo.fsid.val[1] = 0;
	vfs_iterate(VFS_ITERATE_TAIL_FIRST, nfs_ephemeral_mount_harvester_callback, &amp;hinfo);
	<span class="enscript-keyword">if</span> (hinfo.fsid.val[0] || hinfo.fsid.val[1]) {
		<span class="enscript-comment">/* attempt to unmount last found ephemeral mount */</span>
		vfs_unmountbyfsid(&amp;hinfo.fsid, 0, vfs_context_kernel());
	}

	lck_mtx_lock(nfs_global_mutex);
	<span class="enscript-keyword">if</span> (!hinfo.mountcount) {
		<span class="enscript-comment">/* no more ephemeral mounts - don't need timer */</span>
		nfs_ephemeral_mount_harvester_on = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* re-arm the timer */</span>
		clock_interval_to_deadline(NFS_EPHEMERAL_MOUNT_HARVEST_INTERVAL, NSEC_PER_SEC, &amp;deadline);
		thread_call_enter_delayed(nfs_ephemeral_mount_harvester_timer, deadline);
		nfs_ephemeral_mount_harvester_on = 1;
	}
	lck_mtx_unlock(nfs_global_mutex);

	<span class="enscript-comment">/* thread done */</span>
	thread_terminate(current_thread());
}

<span class="enscript-comment">/*
 * Make sure the NFS ephemeral mount harvester timer is running.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_ephemeral_mount_harvester_start</span>(<span class="enscript-type">void</span>)
{
	uint64_t deadline;

	lck_mtx_lock(nfs_global_mutex);
	<span class="enscript-keyword">if</span> (nfs_ephemeral_mount_harvester_on) {
		lck_mtx_unlock(nfs_global_mutex);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (nfs_ephemeral_mount_harvester_timer == NULL)
		nfs_ephemeral_mount_harvester_timer = thread_call_allocate((thread_call_func_t)nfs_ephemeral_mount_harvester_timer_func, NULL);
	clock_interval_to_deadline(NFS_EPHEMERAL_MOUNT_HARVEST_INTERVAL, NSEC_PER_SEC, &amp;deadline);
	thread_call_enter_delayed(nfs_ephemeral_mount_harvester_timer, deadline);
	nfs_ephemeral_mount_harvester_on = 1;
	lck_mtx_unlock(nfs_global_mutex);
}

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Send a MOUNT protocol MOUNT request to the server to get the initial file handle (and security).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_mount_rpc</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">struct</span> sockaddr *sa, <span class="enscript-type">int</span> sotype, <span class="enscript-type">int</span> nfsvers, <span class="enscript-type">char</span> *path, vfs_context_t ctx, <span class="enscript-type">int</span> timeo, fhandle_t *fh, <span class="enscript-type">struct</span> nfs_sec *sec)
{
	<span class="enscript-type">int</span> error = 0, slen, mntproto;
	thread_t thd = vfs_context_thread(ctx);
	kauth_cred_t cred = vfs_context_ucred(ctx);
	uint64_t xid = 0;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	mbuf_t mreq;
	uint32_t mntvers, mntport, val;
	<span class="enscript-type">struct</span> sockaddr_storage ss;
	<span class="enscript-type">struct</span> sockaddr *saddr = (<span class="enscript-type">struct</span> sockaddr*)&amp;ss;

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	mntvers = (nfsvers == NFS_VER2) ? RPCMNT_VER1 : RPCMNT_VER3;
	mntproto = (NM_OMFLAG(nmp, MNTUDP) || (sotype == SOCK_DGRAM)) ? IPPROTO_UDP : IPPROTO_TCP;
	sec-&gt;count = 0;

	bcopy(sa, saddr, min(<span class="enscript-keyword">sizeof</span>(ss), sa-&gt;sa_len));
	<span class="enscript-keyword">if</span> (saddr-&gt;sa_family == AF_INET) {
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_mountport)
			((<span class="enscript-type">struct</span> sockaddr_in*)saddr)-&gt;sin_port = htons(nmp-&gt;nm_mountport);
		mntport = ntohs(((<span class="enscript-type">struct</span> sockaddr_in*)saddr)-&gt;sin_port);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_mountport)
			((<span class="enscript-type">struct</span> sockaddr_in6*)saddr)-&gt;sin6_port = htons(nmp-&gt;nm_mountport);
		mntport = ntohs(((<span class="enscript-type">struct</span> sockaddr_in6*)saddr)-&gt;sin6_port);
	}

	<span class="enscript-keyword">while</span> (!mntport) {
		error = nfs_portmap_lookup(nmp, ctx, saddr, NULL, RPCPROG_MNT, mntvers, mntproto, timeo);
		nfsmout_if(error);
		<span class="enscript-keyword">if</span> (saddr-&gt;sa_family == AF_INET)
			mntport = ntohs(((<span class="enscript-type">struct</span> sockaddr_in*)saddr)-&gt;sin_port);
		<span class="enscript-keyword">else</span>
			mntport = ntohs(((<span class="enscript-type">struct</span> sockaddr_in6*)saddr)-&gt;sin6_port);
		<span class="enscript-keyword">if</span> (!mntport) {
			<span class="enscript-comment">/* if not found and TCP, then retry with UDP */</span>
			<span class="enscript-keyword">if</span> (mntproto == IPPROTO_UDP) {
				error = EPROGUNAVAIL;
				<span class="enscript-keyword">break</span>;
			}
			mntproto = IPPROTO_UDP;
			bcopy(sa, saddr, min(<span class="enscript-keyword">sizeof</span>(ss), sa-&gt;sa_len));
		}
	}
	nfsmout_if(error || !mntport);

	<span class="enscript-comment">/* MOUNT protocol MOUNT request */</span>
	slen = strlen(path);
	nfsm_chain_build_alloc_init(error, &amp;nmreq, NFSX_UNSIGNED + nfsm_rndup(slen));
	nfsm_chain_add_name(error, &amp;nmreq, path, slen, nmp);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfsm_rpchead2(nmp, (mntproto == IPPROTO_UDP) ? SOCK_DGRAM : SOCK_STREAM,
			RPCPROG_MNT, mntvers, RPCMNT_MOUNT,
			RPCAUTH_SYS, cred, NULL, nmreq.nmc_mhead, &amp;xid, &amp;mreq);
	nfsmout_if(error);
	nmreq.nmc_mhead = NULL;
	error = nfs_aux_request(nmp, thd, saddr, NULL,
			((mntproto == IPPROTO_UDP) ? SOCK_DGRAM : SOCK_STREAM),
			mreq, R_XID32(xid), 1, timeo, &amp;nmrep);
	nfsmout_if(error);
	nfsm_chain_get_32(error, &amp;nmrep, val);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; val)
		error = val;
	nfsm_chain_get_fh(error, &amp;nmrep, nfsvers, fh);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (nfsvers &gt; NFS_VER2)) {
		sec-&gt;count = NX_MAX_SEC_FLAVORS;
		error = nfsm_chain_get_secinfo(&amp;nmrep, &amp;sec-&gt;flavors[0], &amp;sec-&gt;count);
	}
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Send a MOUNT protocol UNMOUNT request to tell the server we've unmounted it.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs3_umount_rpc</span>(<span class="enscript-type">struct</span> nfsmount *nmp, vfs_context_t ctx, <span class="enscript-type">int</span> timeo)
{
	<span class="enscript-type">int</span> error = 0, slen, mntproto;
	thread_t thd = vfs_context_thread(ctx);
	kauth_cred_t cred = vfs_context_ucred(ctx);
	<span class="enscript-type">char</span> *path;
	uint64_t xid = 0;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	mbuf_t mreq;
	uint32_t mntvers, mntport;
	<span class="enscript-type">struct</span> sockaddr_storage ss;
	<span class="enscript-type">struct</span> sockaddr *saddr = (<span class="enscript-type">struct</span> sockaddr*)&amp;ss;

	<span class="enscript-keyword">if</span> (!nmp-&gt;nm_saddr)
		<span class="enscript-keyword">return</span>;

	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	mntvers = (nmp-&gt;nm_vers == NFS_VER2) ? RPCMNT_VER1 : RPCMNT_VER3;
	mntproto = (NM_OMFLAG(nmp, MNTUDP) || (nmp-&gt;nm_sotype == SOCK_DGRAM)) ? IPPROTO_UDP : IPPROTO_TCP;
	mntport = nmp-&gt;nm_mountport;

	bcopy(nmp-&gt;nm_saddr, saddr, min(<span class="enscript-keyword">sizeof</span>(ss), nmp-&gt;nm_saddr-&gt;sa_len));
	<span class="enscript-keyword">if</span> (saddr-&gt;sa_family == AF_INET)
		((<span class="enscript-type">struct</span> sockaddr_in*)saddr)-&gt;sin_port = htons(mntport);
	<span class="enscript-keyword">else</span>
		((<span class="enscript-type">struct</span> sockaddr_in6*)saddr)-&gt;sin6_port = htons(mntport);

	<span class="enscript-keyword">while</span> (!mntport) {
		error = nfs_portmap_lookup(nmp, ctx, saddr, NULL, RPCPROG_MNT, mntvers, mntproto, timeo);
  		nfsmout_if(error);
		<span class="enscript-keyword">if</span> (saddr-&gt;sa_family == AF_INET)
			mntport = ntohs(((<span class="enscript-type">struct</span> sockaddr_in*)saddr)-&gt;sin_port);
		<span class="enscript-keyword">else</span>
			mntport = ntohs(((<span class="enscript-type">struct</span> sockaddr_in6*)saddr)-&gt;sin6_port);
		<span class="enscript-comment">/* if not found and mntvers &gt; VER1, then retry with VER1 */</span>
		<span class="enscript-keyword">if</span> (!mntport) {
			<span class="enscript-keyword">if</span> (mntvers &gt; RPCMNT_VER1) {
				mntvers = RPCMNT_VER1;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mntproto == IPPROTO_TCP) {
				mntproto = IPPROTO_UDP;
				mntvers = (nmp-&gt;nm_vers == NFS_VER2) ? RPCMNT_VER1 : RPCMNT_VER3;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">break</span>;
			}
			bcopy(nmp-&gt;nm_saddr, saddr, min(<span class="enscript-keyword">sizeof</span>(ss), nmp-&gt;nm_saddr-&gt;sa_len));
		}
	}
	nfsmout_if(!mntport);

	<span class="enscript-comment">/* MOUNT protocol UNMOUNT request */</span>
	path = &amp;vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname[0];
	<span class="enscript-keyword">while</span> (*path &amp;&amp; (*path != <span class="enscript-string">'/'</span>))
		path++;
	slen = strlen(path);
	nfsm_chain_build_alloc_init(error, &amp;nmreq, NFSX_UNSIGNED + nfsm_rndup(slen));
	nfsm_chain_add_name(error, &amp;nmreq, path, slen, nmp);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfsm_rpchead2(nmp, (mntproto == IPPROTO_UDP) ? SOCK_DGRAM : SOCK_STREAM,
			RPCPROG_MNT, RPCMNT_VER1, RPCMNT_UMOUNT,
			RPCAUTH_SYS, cred, NULL, nmreq.nmc_mhead, &amp;xid, &amp;mreq);
	nfsmout_if(error);
	nmreq.nmc_mhead = NULL;
	error = nfs_aux_request(nmp, thd, saddr, NULL,
		((mntproto == IPPROTO_UDP) ? SOCK_DGRAM : SOCK_STREAM),
		mreq, R_XID32(xid), 1, timeo, &amp;nmrep);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
}

<span class="enscript-comment">/*
 * unmount system call
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vfs_unmount</span>(
	mount_t mp,
	<span class="enscript-type">int</span> mntflags,
	__unused vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	vnode_t vp;
	<span class="enscript-type">int</span> error, flags = 0;
	<span class="enscript-type">struct</span> timespec ts = { 1, 0 };

	nmp = VFSTONFS(mp);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-comment">/*
	 * Set the flag indicating that an unmount attempt is in progress.
	 */</span>
	nmp-&gt;nm_state |= NFSSTA_UNMOUNTING;
	<span class="enscript-comment">/*
	 * During a force unmount we want to...
	 *   Mark that we are doing a force unmount.
	 *   Make the mountpoint soft.
	 */</span>
	<span class="enscript-keyword">if</span> (mntflags &amp; MNT_FORCE) {
		flags |= FORCECLOSE;
		nmp-&gt;nm_state |= NFSSTA_FORCE;
		NFS_BITMAP_SET(nmp-&gt;nm_flags, NFS_MFLAG_SOFT);
	}
	<span class="enscript-comment">/*
	 * Wait for any in-progress monitored node scan to complete.
	 */</span>
	<span class="enscript-keyword">while</span> (nmp-&gt;nm_state &amp; NFSSTA_MONITOR_SCAN)
		msleep(&amp;nmp-&gt;nm_state, &amp;nmp-&gt;nm_lock, PZERO-1, <span class="enscript-string">&quot;nfswaitmonscan&quot;</span>, &amp;ts);
	<span class="enscript-comment">/*
	 * Goes something like this..
	 * - Call vflush() to clear out vnodes for this file system,
	 *   except for the swap files. Deal with them in 2nd pass.
	 * - Decrement reference on the vnode representing remote root.
	 * - Clean up the NFS mount structure.
	 */</span>
	vp = NFSTOV(nmp-&gt;nm_dnp);
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-comment">/*
	 * vflush will check for busy vnodes on mountpoint.
	 * Will do the right thing for MNT_FORCE. That is, we should
	 * not get EBUSY back.
	 */</span>
	error = vflush(mp, vp, SKIPSWAP | flags);
	<span class="enscript-keyword">if</span> (mntflags &amp; MNT_FORCE) {
		error = vflush(mp, NULLVP, flags); <span class="enscript-comment">/* locks vp in the process */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (vnode_isinuse(vp, 1))
			error = EBUSY;
		<span class="enscript-keyword">else</span>
			error = vflush(mp, vp, flags);
	}
	<span class="enscript-keyword">if</span> (error) {
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		nmp-&gt;nm_state &amp;= ~NFSSTA_UNMOUNTING;
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">return</span> (error);
	}

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	nmp-&gt;nm_dnp = NULL;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-comment">/*
	 * Release the root vnode reference held by mountnfs()
	 */</span>
	error = vnode_get(vp);
	vnode_rele(vp);
	<span class="enscript-keyword">if</span> (!error)
		vnode_put(vp);

	vflush(mp, NULLVP, FORCECLOSE);

	<span class="enscript-comment">/* Wait for all other references to be released and free the mount */</span>
	nfs_mount_drain_and_cleanup(nmp);
	
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * cleanup/destroy NFS fs locations structure
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_fs_locations_cleanup</span>(<span class="enscript-type">struct</span> nfs_fs_locations *nfslsp)
{
	<span class="enscript-type">struct</span> nfs_fs_location *fsl;
	<span class="enscript-type">struct</span> nfs_fs_server *fss;
	<span class="enscript-type">struct</span> nfs_fs_path *fsp;
	uint32_t loc, serv, addr, comp;

	<span class="enscript-comment">/* free up fs locations */</span>
	<span class="enscript-keyword">if</span> (!nfslsp-&gt;nl_numlocs || !nfslsp-&gt;nl_locations)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">for</span> (loc = 0; loc &lt; nfslsp-&gt;nl_numlocs; loc++) {
		fsl = nfslsp-&gt;nl_locations[loc];
		<span class="enscript-keyword">if</span> (!fsl)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> ((fsl-&gt;nl_servcount &gt; 0) &amp;&amp; fsl-&gt;nl_servers) {
			<span class="enscript-keyword">for</span> (serv = 0; serv &lt; fsl-&gt;nl_servcount; serv++) {
				fss = fsl-&gt;nl_servers[serv];
				<span class="enscript-keyword">if</span> (!fss)
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">if</span> ((fss-&gt;ns_addrcount &gt; 0) &amp;&amp; fss-&gt;ns_addresses) {
					<span class="enscript-keyword">for</span> (addr = 0; addr &lt; fss-&gt;ns_addrcount; addr++)
						FREE(fss-&gt;ns_addresses[addr], M_TEMP);
					FREE(fss-&gt;ns_addresses, M_TEMP);
				}
				FREE(fss-&gt;ns_name, M_TEMP);
				FREE(fss, M_TEMP);
			}
			FREE(fsl-&gt;nl_servers, M_TEMP);
		}
		fsp = &amp;fsl-&gt;nl_path;
		<span class="enscript-keyword">if</span> (fsp-&gt;np_compcount &amp;&amp; fsp-&gt;np_components) {
			<span class="enscript-keyword">for</span> (comp = 0; comp &lt; fsp-&gt;np_compcount; comp++)
				<span class="enscript-keyword">if</span> (fsp-&gt;np_components[comp])
					FREE(fsp-&gt;np_components[comp], M_TEMP);
			FREE(fsp-&gt;np_components, M_TEMP);
		}
		FREE(fsl, M_TEMP);
	}
	FREE(nfslsp-&gt;nl_locations, M_TEMP);
	nfslsp-&gt;nl_numlocs = 0;
	nfslsp-&gt;nl_locations = NULL;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_mount_rele</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">int</span> wup = 0;

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_ref &lt; 1)
		panic(<span class="enscript-string">&quot;nfs zombie mount underflow\n&quot;</span>);
	nmp-&gt;nm_ref--;
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_ref == 0)
		wup = nmp-&gt;nm_state &amp; NFSSTA_MOUNT_DRAIN;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (wup)
		wakeup(&amp;nmp-&gt;nm_ref);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_mount_drain_and_cleanup</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	nmp-&gt;nm_state |= NFSSTA_MOUNT_DRAIN;
	<span class="enscript-keyword">while</span> (nmp-&gt;nm_ref &gt; 0) {
		msleep(&amp;nmp-&gt;nm_ref, &amp;nmp-&gt;nm_lock, PZERO-1, <span class="enscript-string">&quot;nfs_mount_drain&quot;</span>, NULL);
	}
	assert(nmp-&gt;nm_ref == 0);
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	nfs_mount_cleanup(nmp);
}

<span class="enscript-comment">/*
 * nfs_mount_zombie
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_mount_zombie</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">int</span> nm_state_flags)
{
	<span class="enscript-type">struct</span> nfsreq *req, *treq;
	<span class="enscript-type">struct</span> nfs_reqqhead iodq, resendq;
	<span class="enscript-type">struct</span> timespec ts = { 1, 0 };
	<span class="enscript-type">struct</span> nfs_open_owner *noop, *nextnoop;
	nfsnode_t np;
	<span class="enscript-type">int</span> docallback;

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	nmp-&gt;nm_state |= nm_state_flags;
	nmp-&gt;nm_ref++;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	
	<span class="enscript-comment">/* stop callbacks */</span>
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; !NMFLAG(nmp, NOCALLBACK) &amp;&amp; nmp-&gt;nm_cbid)
		nfs4_mount_callback_shutdown(nmp);

	<span class="enscript-comment">/* Destroy any RPCSEC_GSS contexts */</span>
	nfs_gss_clnt_ctx_unmount(nmp);

	<span class="enscript-comment">/* mark the socket for termination */</span>
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	nmp-&gt;nm_sockflags |= NMSOCK_UNMOUNT;

	<span class="enscript-comment">/* Have the socket thread send the unmount RPC, if requested/appropriate. */</span>
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &lt; NFS_VER4) &amp;&amp; (nmp-&gt;nm_state &amp; NFSSTA_MOUNTED) &amp;&amp;
	    !(nmp-&gt;nm_state &amp; (NFSSTA_FORCE|NFSSTA_DEAD)) &amp;&amp; NMFLAG(nmp, CALLUMNT))
		nfs_mount_sock_thread_wake(nmp);

	<span class="enscript-comment">/* wait for the socket thread to terminate */</span>
	<span class="enscript-keyword">while</span> (nmp-&gt;nm_sockthd &amp;&amp; current_thread() != nmp-&gt;nm_sockthd) {
		wakeup(&amp;nmp-&gt;nm_sockthd);
		msleep(&amp;nmp-&gt;nm_sockthd, &amp;nmp-&gt;nm_lock, PZERO-1, <span class="enscript-string">&quot;nfswaitsockthd&quot;</span>, &amp;ts);
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-comment">/* tear down the socket */</span>
	nfs_disconnect(nmp);

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; !NMFLAG(nmp, NOCALLBACK) &amp;&amp; nmp-&gt;nm_cbid) {
		<span class="enscript-comment">/* clear out any pending delegation return requests */</span>
		<span class="enscript-keyword">while</span> ((np = TAILQ_FIRST(&amp;nmp-&gt;nm_dreturnq))) {
			TAILQ_REMOVE(&amp;nmp-&gt;nm_dreturnq, np, n_dreturn);
			np-&gt;n_dreturn.tqe_next = NFSNOLIST;
		}
	}

	<span class="enscript-comment">/* cancel any renew timer */</span>
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; nmp-&gt;nm_renew_timer) {
		thread_call_cancel(nmp-&gt;nm_renew_timer);
		thread_call_free(nmp-&gt;nm_renew_timer);
	}

	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; NFSSTA_MOUNTED)
		<span class="enscript-keyword">switch</span> (nmp-&gt;nm_lockmode) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_LOCK_MODE_DISABLED</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_LOCK_MODE_LOCAL</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_LOCK_MODE_ENABLED</span>:
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &lt;= NFS_VER3) {
				nfs_lockd_mount_unregister(nmp);
				nmp-&gt;nm_lockmode = NFS_LOCK_MODE_DISABLED;
			}
			<span class="enscript-keyword">break</span>;
		}

	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; nmp-&gt;nm_longid) {
		<span class="enscript-comment">/* remove/deallocate the client ID data */</span>
		lck_mtx_lock(nfs_global_mutex);
		TAILQ_REMOVE(&amp;nfsclientids, nmp-&gt;nm_longid, nci_link);
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_longid-&gt;nci_id)
			FREE(nmp-&gt;nm_longid-&gt;nci_id, M_TEMP);
		FREE(nmp-&gt;nm_longid, M_TEMP);
		lck_mtx_unlock(nfs_global_mutex);
	}

	<span class="enscript-comment">/*
	 * Be sure all requests for this mount are completed
	 * and removed from the resend queue.
	 */</span>
	TAILQ_INIT(&amp;resendq);
	lck_mtx_lock(nfs_request_mutex);
	TAILQ_FOREACH(req, &amp;nfs_reqq, r_chain) {
		<span class="enscript-keyword">if</span> (req-&gt;r_nmp == nmp) {
			lck_mtx_lock(&amp;req-&gt;r_mtx);
			<span class="enscript-keyword">if</span> (!req-&gt;r_error &amp;&amp; req-&gt;r_nmrep.nmc_mhead == NULL)
				req-&gt;r_error = EIO;
			<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_RESENDQ) {
				lck_mtx_lock(&amp;nmp-&gt;nm_lock);
				req-&gt;r_flags &amp;= ~R_RESENDQ;
				<span class="enscript-keyword">if</span> (req-&gt;r_rchain.tqe_next != NFSREQNOLIST) {
					TAILQ_REMOVE(&amp;nmp-&gt;nm_resendq, req, r_rchain);
					<span class="enscript-comment">/*
					 * Queue up the request so that we can unreference them 
					 * with out holding nfs_request_mutex
					 */</span>
					TAILQ_INSERT_TAIL(&amp;resendq, req, r_rchain);
				}
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			}
			wakeup(req);
			lck_mtx_unlock(&amp;req-&gt;r_mtx);
		}
	}
	lck_mtx_unlock(nfs_request_mutex);

	<span class="enscript-comment">/* Since we've drop the request mutex we can now safely unreference the request */</span>
	TAILQ_FOREACH_SAFE(req, &amp;resendq, r_rchain, treq) {
		TAILQ_REMOVE(&amp;resendq, req, r_rchain);
		nfs_request_rele(req);
	}

	<span class="enscript-comment">/*
	 * Now handle and outstanding async requests. We need to walk the
	 * request queue again this time with the nfsiod_mutex held. No
	 * other iods can grab our requests until we've put them on our own
	 * local iod queue for processing.
	 */</span>
	TAILQ_INIT(&amp;iodq);
	lck_mtx_lock(nfs_request_mutex);
	lck_mtx_lock(nfsiod_mutex);
	TAILQ_FOREACH(req, &amp;nfs_reqq, r_chain) {
		<span class="enscript-keyword">if</span> (req-&gt;r_nmp == nmp) {
			lck_mtx_lock(&amp;req-&gt;r_mtx);
			<span class="enscript-keyword">if</span> (req-&gt;r_callback.rcb_func
			    &amp;&amp; !(req-&gt;r_flags &amp; R_WAITSENT) &amp;&amp; !(req-&gt;r_flags &amp; R_IOD)) {
				<span class="enscript-comment">/* 
				 * Since R_IOD is not set then we need to handle it. If
				 * we're not on a list add it to our iod queue. Otherwise
				 * we must already be on nm_iodq which is added to our
				 * local queue below.
				 * %%% We should really keep a back pointer to our iod queue
				 * that we're on.
				 */</span>
				req-&gt;r_flags |= R_IOD;
				<span class="enscript-keyword">if</span> (req-&gt;r_achain.tqe_next == NFSREQNOLIST) {
					TAILQ_INSERT_TAIL(&amp;iodq, req, r_achain);
				}
			}
			lck_mtx_unlock(&amp;req-&gt;r_mtx);
		}
	}

	<span class="enscript-comment">/* finish any async I/O RPCs queued up */</span>
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_iodlink.tqe_next != NFSNOLIST)
		TAILQ_REMOVE(&amp;nfsiodmounts, nmp, nm_iodlink);
	TAILQ_CONCAT(&amp;iodq, &amp;nmp-&gt;nm_iodq, r_achain);
	lck_mtx_unlock(nfsiod_mutex);
	lck_mtx_unlock(nfs_request_mutex);

	TAILQ_FOREACH_SAFE(req, &amp;iodq, r_achain, treq) {
		TAILQ_REMOVE(&amp;iodq, req, r_achain);
		req-&gt;r_achain.tqe_next = NFSREQNOLIST;
		lck_mtx_lock(&amp;req-&gt;r_mtx);
		docallback = !(req-&gt;r_flags &amp; R_WAITSENT);
		lck_mtx_unlock(&amp;req-&gt;r_mtx);
		<span class="enscript-keyword">if</span> (docallback)
			req-&gt;r_callback.rcb_func(req);
	}

	<span class="enscript-comment">/* clean up common state */</span>
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
 	<span class="enscript-keyword">while</span> ((np = LIST_FIRST(&amp;nmp-&gt;nm_monlist))) {
 		LIST_REMOVE(np, n_monlink);
 		np-&gt;n_monlink.le_next = NFSNOLIST;
 	}
	TAILQ_FOREACH_SAFE(noop, &amp;nmp-&gt;nm_open_owners, noo_link, nextnoop) {
		TAILQ_REMOVE(&amp;nmp-&gt;nm_open_owners, noop, noo_link);
		noop-&gt;noo_flags &amp;= ~NFS_OPEN_OWNER_LINK;
		<span class="enscript-keyword">if</span> (noop-&gt;noo_refcnt)
			<span class="enscript-keyword">continue</span>;
		nfs_open_owner_destroy(noop);
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-comment">/* clean up NFSv4 state */</span>
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4) {
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">while</span> ((np = TAILQ_FIRST(&amp;nmp-&gt;nm_delegations))) {
			TAILQ_REMOVE(&amp;nmp-&gt;nm_delegations, np, n_dlink);
			np-&gt;n_dlink.tqe_next = NFSNOLIST;
		}
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	}

	nfs_mount_rele(nmp);
}

<span class="enscript-comment">/*
 * cleanup/destroy an nfsmount
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_mount_cleanup</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-keyword">if</span> (!nmp)
		<span class="enscript-keyword">return</span>;

	nfs_mount_zombie(nmp, 0);

	NFS_VFS_DBG(<span class="enscript-string">&quot;Unmounting %s from %s\n&quot;</span>,
		    vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname,
		    vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntonname);
	NFS_VFS_DBG(<span class="enscript-string">&quot;nfs state = %x\n&quot;</span>, nmp-&gt;nm_state);
	NFS_VFS_DBG(<span class="enscript-string">&quot;nfs socket flags = %x\n&quot;</span>, nmp-&gt;nm_sockflags);
	NFS_VFS_DBG(<span class="enscript-string">&quot;nfs mount ref count is %d\n&quot;</span>, nmp-&gt;nm_ref);
	NFS_VFS_DBG(<span class="enscript-string">&quot;mount ref count is %d\n&quot;</span>, nmp-&gt;nm_mountp-&gt;mnt_count);
	
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_mountp)
		vfs_setfsprivate(nmp-&gt;nm_mountp, NULL);

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_ref)
		panic(<span class="enscript-string">&quot;Some one has grabbed a ref %d\n&quot;</span>, nmp-&gt;nm_ref);

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_saddr)
		FREE(nmp-&gt;nm_saddr, M_SONAME);
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &lt; NFS_VER4) &amp;&amp; nmp-&gt;nm_rqsaddr)
		FREE(nmp-&gt;nm_rqsaddr, M_SONAME);

	<span class="enscript-keyword">if</span> (IS_VALID_CRED(nmp-&gt;nm_mcred))
		kauth_cred_unref(&amp;nmp-&gt;nm_mcred);

	nfs_fs_locations_cleanup(&amp;nmp-&gt;nm_locations);

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_realm)
		FREE(nmp-&gt;nm_realm, M_TEMP);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_principal)
		FREE(nmp-&gt;nm_principal, M_TEMP);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_sprinc)
		FREE(nmp-&gt;nm_sprinc, M_TEMP);
	
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_args)
		xb_free(nmp-&gt;nm_args);

	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	
	lck_mtx_destroy(&amp;nmp-&gt;nm_lock, nfs_mount_grp);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_fh)
		FREE(nmp-&gt;nm_fh, M_TEMP);
	FREE_ZONE((caddr_t)nmp, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nfsmount), M_NFSMNT);
}

<span class="enscript-comment">/*
 * Return root of a filesystem
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vfs_root</span>(mount_t mp, vnode_t *vpp, __unused vfs_context_t ctx)
{
	vnode_t vp;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error;
	u_int32_t vpid;

	nmp = VFSTONFS(mp);
	<span class="enscript-keyword">if</span> (!nmp || !nmp-&gt;nm_dnp)
		<span class="enscript-keyword">return</span> (ENXIO);
	vp = NFSTOV(nmp-&gt;nm_dnp);
	vpid = vnode_vid(vp);
	<span class="enscript-keyword">while</span> ((error = vnode_getwithvid(vp, vpid))) {
		<span class="enscript-comment">/* vnode_get() may return ENOENT if the dir changes. */</span>
		<span class="enscript-comment">/* If that happens, just try it again, else return the error. */</span>
		<span class="enscript-keyword">if</span> ((error != ENOENT) || (vnode_vid(vp) == vpid))
			<span class="enscript-keyword">return</span> (error);
		vpid = vnode_vid(vp);
	}
	*vpp = vp;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Do operations associated with quotas
 */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">QUOTA</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vfs_quotactl</span>(
	__unused mount_t mp,
	__unused <span class="enscript-type">int</span> cmds,
	__unused uid_t uid,
	__unused caddr_t datap,
	__unused vfs_context_t context)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);
}
#<span class="enscript-reference">else</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs3_getquota</span>(<span class="enscript-type">struct</span> nfsmount *nmp, vfs_context_t ctx, uid_t id, <span class="enscript-type">int</span> type, <span class="enscript-type">struct</span> dqblk *dqb)
{
	<span class="enscript-type">int</span> error = 0, slen, timeo;
	<span class="enscript-type">int</span> rqport = 0, rqproto, rqvers = (type == GRPQUOTA) ? RPCRQUOTA_EXT_VER : RPCRQUOTA_VER;
	thread_t thd = vfs_context_thread(ctx);
	kauth_cred_t cred = vfs_context_ucred(ctx);
	<span class="enscript-type">char</span> *path;
	uint64_t xid = 0;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	mbuf_t mreq;
	uint32_t val = 0, bsize = 0;
	<span class="enscript-type">struct</span> sockaddr *rqsaddr;
	<span class="enscript-type">struct</span> timeval now;

	<span class="enscript-keyword">if</span> (!nmp-&gt;nm_saddr)
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (NMFLAG(nmp, NOQUOTA))
		<span class="enscript-keyword">return</span> (ENOTSUP);

	<span class="enscript-keyword">if</span> (!nmp-&gt;nm_rqsaddr)
		MALLOC(nmp-&gt;nm_rqsaddr, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_storage), M_SONAME, M_WAITOK|M_ZERO);
	<span class="enscript-keyword">if</span> (!nmp-&gt;nm_rqsaddr)
		<span class="enscript-keyword">return</span> (ENOMEM);
	rqsaddr = nmp-&gt;nm_rqsaddr;
	<span class="enscript-keyword">if</span> (rqsaddr-&gt;sa_family == AF_INET6)
		rqport = ntohs(((<span class="enscript-type">struct</span> sockaddr_in6*)rqsaddr)-&gt;sin6_port);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rqsaddr-&gt;sa_family == AF_INET)
		rqport = ntohs(((<span class="enscript-type">struct</span> sockaddr_in*)rqsaddr)-&gt;sin_port);

	timeo = NMFLAG(nmp, SOFT) ? 10 : 60;
	rqproto = IPPROTO_UDP; <span class="enscript-comment">/* XXX should prefer TCP if mount is TCP */</span>

	<span class="enscript-comment">/* check if we have a recently cached rquota port */</span>
	microuptime(&amp;now);
	<span class="enscript-keyword">if</span> (!rqport || ((nmp-&gt;nm_rqsaddrstamp + 60) &gt;= (uint32_t)now.tv_sec)) {
		<span class="enscript-comment">/* send portmap request to get rquota port */</span>
		bcopy(nmp-&gt;nm_saddr, rqsaddr, min(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_storage), nmp-&gt;nm_saddr-&gt;sa_len));
		error = nfs_portmap_lookup(nmp, ctx, rqsaddr, NULL, RPCPROG_RQUOTA, rqvers, rqproto, timeo);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">if</span> (rqsaddr-&gt;sa_family == AF_INET6)
			rqport = ntohs(((<span class="enscript-type">struct</span> sockaddr_in6*)rqsaddr)-&gt;sin6_port);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rqsaddr-&gt;sa_family == AF_INET)
			rqport = ntohs(((<span class="enscript-type">struct</span> sockaddr_in*)rqsaddr)-&gt;sin_port);
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">return</span> (EIO);
		<span class="enscript-keyword">if</span> (!rqport)
			<span class="enscript-keyword">return</span> (ENOTSUP);
		microuptime(&amp;now);
		nmp-&gt;nm_rqsaddrstamp = now.tv_sec;
	}

	<span class="enscript-comment">/* rquota request */</span>
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);
	path = &amp;vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname[0];
	<span class="enscript-keyword">while</span> (*path &amp;&amp; (*path != <span class="enscript-string">'/'</span>))
		path++;
	slen = strlen(path);
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 3 * NFSX_UNSIGNED + nfsm_rndup(slen));
	nfsm_chain_add_name(error, &amp;nmreq, path, slen, nmp);
	<span class="enscript-keyword">if</span> (type == GRPQUOTA)
		nfsm_chain_add_32(error, &amp;nmreq, type);
	nfsm_chain_add_32(error, &amp;nmreq, id);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfsm_rpchead2(nmp, (rqproto == IPPROTO_UDP) ? SOCK_DGRAM : SOCK_STREAM,
			RPCPROG_RQUOTA, rqvers, RPCRQUOTA_GET,
			RPCAUTH_SYS, cred, NULL, nmreq.nmc_mhead, &amp;xid, &amp;mreq);
	nfsmout_if(error);
	nmreq.nmc_mhead = NULL;
	error = nfs_aux_request(nmp, thd, rqsaddr, NULL,
			(rqproto == IPPROTO_UDP) ? SOCK_DGRAM : SOCK_STREAM,
			mreq, R_XID32(xid), 0, timeo, &amp;nmrep);
	nfsmout_if(error);

	<span class="enscript-comment">/* parse rquota response */</span>
	nfsm_chain_get_32(error, &amp;nmrep, val);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (val != RQUOTA_STAT_OK)) {
		<span class="enscript-keyword">if</span> (val == RQUOTA_STAT_NOQUOTA)
			error = ENOENT;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (val == RQUOTA_STAT_EPERM)
			error = EPERM;
		<span class="enscript-keyword">else</span>
			error = EIO;
	}
	nfsm_chain_get_32(error, &amp;nmrep, bsize);
	nfsm_chain_adv(error, &amp;nmrep, NFSX_UNSIGNED);
	nfsm_chain_get_32(error, &amp;nmrep, val);
	nfsmout_if(error);
	dqb-&gt;dqb_bhardlimit = (uint64_t)val * bsize;
	nfsm_chain_get_32(error, &amp;nmrep, val);
	nfsmout_if(error);
	dqb-&gt;dqb_bsoftlimit = (uint64_t)val * bsize;
	nfsm_chain_get_32(error, &amp;nmrep, val);
	nfsmout_if(error);
	dqb-&gt;dqb_curbytes = (uint64_t)val * bsize;
	nfsm_chain_get_32(error, &amp;nmrep, dqb-&gt;dqb_ihardlimit);
	nfsm_chain_get_32(error, &amp;nmrep, dqb-&gt;dqb_isoftlimit);
	nfsm_chain_get_32(error, &amp;nmrep, dqb-&gt;dqb_curinodes);
	nfsm_chain_get_32(error, &amp;nmrep, dqb-&gt;dqb_btime);
	nfsm_chain_get_32(error, &amp;nmrep, dqb-&gt;dqb_itime);
	nfsmout_if(error);
	dqb-&gt;dqb_id = id;
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_getquota</span>(<span class="enscript-type">struct</span> nfsmount *nmp, vfs_context_t ctx, uid_t id, <span class="enscript-type">int</span> type, <span class="enscript-type">struct</span> dqblk *dqb)
{
	nfsnode_t np;
	<span class="enscript-type">int</span> error = 0, status, nfsvers, numops;
	u_int64_t xid;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	uint32_t bitmap[NFS_ATTR_BITMAP_LEN];
	thread_t thd = vfs_context_thread(ctx);
	kauth_cred_t cred = vfs_context_ucred(ctx);
	<span class="enscript-type">struct</span> nfsreq_secinfo_args si;

	<span class="enscript-keyword">if</span> (type != USRQUOTA)  <span class="enscript-comment">/* NFSv4 only supports user quotas */</span>
		<span class="enscript-keyword">return</span> (ENOTSUP);

	<span class="enscript-comment">/* first check that the server supports any of the quota attributes */</span>
	<span class="enscript-keyword">if</span> (!NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_supp_attr, NFS_FATTR_QUOTA_AVAIL_HARD) &amp;&amp;
	    !NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_supp_attr, NFS_FATTR_QUOTA_AVAIL_SOFT) &amp;&amp;
	    !NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_supp_attr, NFS_FATTR_QUOTA_USED))
		<span class="enscript-keyword">return</span> (ENOTSUP);

	<span class="enscript-comment">/*
	 * The credential passed to the server needs to have
	 * an effective uid that matches the given uid.
	 */</span>
	<span class="enscript-keyword">if</span> (id != kauth_cred_getuid(cred)) {
		<span class="enscript-type">struct</span> posix_cred temp_pcred;
		posix_cred_t pcred = posix_cred_get(cred);
		bzero(&amp;temp_pcred, <span class="enscript-keyword">sizeof</span>(temp_pcred));
		temp_pcred.cr_uid = id;
		temp_pcred.cr_ngroups = pcred-&gt;cr_ngroups;
		bcopy(pcred-&gt;cr_groups, temp_pcred.cr_groups, <span class="enscript-keyword">sizeof</span>(temp_pcred.cr_groups));
		cred = posix_cred_create(&amp;temp_pcred);
		<span class="enscript-keyword">if</span> (!IS_VALID_CRED(cred))
			<span class="enscript-keyword">return</span> (ENOMEM);
	} <span class="enscript-keyword">else</span> {
		kauth_cred_ref(cred);
	}

	nfsvers = nmp-&gt;nm_vers;
	np = nmp-&gt;nm_dnp;
	<span class="enscript-keyword">if</span> (!np)
		error = ENXIO;
	<span class="enscript-keyword">if</span> (error || ((error = vnode_get(NFSTOV(np))))) {
		kauth_cred_unref(&amp;cred);
		<span class="enscript-keyword">return</span>(error);
	}

	NFSREQ_SECINFO_SET(&amp;si, np, NULL, 0, NULL, 0);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">// PUTFH + GETATTR
</span>	numops = 2;
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 15 * NFSX_UNSIGNED);
	nfsm_chain_add_compound_header(error, &amp;nmreq, <span class="enscript-string">&quot;quota&quot;</span>, nmp-&gt;nm_minor_vers, numops);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_PUTFH);
	nfsm_chain_add_fh(error, &amp;nmreq, nfsvers, np-&gt;n_fhp, np-&gt;n_fhsize);
	numops--;
	nfsm_chain_add_32(error, &amp;nmreq, NFS_OP_GETATTR);
	NFS_CLEAR_ATTRIBUTES(bitmap);
	NFS_BITMAP_SET(bitmap, NFS_FATTR_QUOTA_AVAIL_HARD);
	NFS_BITMAP_SET(bitmap, NFS_FATTR_QUOTA_AVAIL_SOFT);
	NFS_BITMAP_SET(bitmap, NFS_FATTR_QUOTA_USED);
	nfsm_chain_add_bitmap_supported(error, &amp;nmreq, bitmap, nmp, NULL);
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsm_assert(error, (numops == 0), EPROTO);
	nfsmout_if(error);
	error = nfs_request2(np, NULL, &amp;nmreq, NFSPROC4_COMPOUND, thd, cred, &amp;si, 0, &amp;nmrep, &amp;xid, &amp;status);
	nfsm_chain_skip_tag(error, &amp;nmrep);
	nfsm_chain_get_32(error, &amp;nmrep, numops);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_PUTFH);
	nfsm_chain_op_check(error, &amp;nmrep, NFS_OP_GETATTR);
	nfsm_assert(error, NFSTONMP(np), ENXIO);
	nfsmout_if(error);
	error = nfs4_parsefattr(&amp;nmrep, NULL, NULL, NULL, dqb, NULL);
	nfsmout_if(error);
	nfsm_assert(error, NFSTONMP(np), ENXIO);
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	vnode_put(NFSTOV(np));
	kauth_cred_unref(&amp;cred);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vfs_quotactl</span>(mount_t mp, <span class="enscript-type">int</span> cmds, uid_t uid, caddr_t datap, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> cmd, type, error, nfsvers;
	uid_t euid = kauth_cred_getuid(vfs_context_ucred(ctx));
	<span class="enscript-type">struct</span> dqblk *dqb = (<span class="enscript-type">struct</span> dqblk*)datap;

	nmp = VFSTONFS(mp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsvers = nmp-&gt;nm_vers;

	<span class="enscript-keyword">if</span> (uid == ~0U)
		uid = euid;

	<span class="enscript-comment">/* we can only support Q_GETQUOTA */</span>
	cmd = cmds &gt;&gt; SUBCMDSHIFT;
	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_GETQUOTA</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_QUOTAON</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_QUOTAOFF</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_SETQUOTA</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_SETUSE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_SYNC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">Q_QUOTASTAT</span>:
		<span class="enscript-keyword">return</span> (ENOTSUP);
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	type = cmds &amp; SUBCMDMASK;
	<span class="enscript-keyword">if</span> ((u_int)type &gt;= MAXQUOTAS)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> ((uid != euid) &amp;&amp; ((error = vfs_context_suser(ctx))))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (vfs_busy(mp, LK_NOWAIT))
		<span class="enscript-keyword">return</span> (0);
	bzero(dqb, <span class="enscript-keyword">sizeof</span>(*dqb));
	error = nmp-&gt;nm_funcs-&gt;nf_getquota(nmp, ctx, uid, type, dqb);
	vfs_unbusy(mp);
	<span class="enscript-keyword">return</span> (error);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Flush out the buffer cache
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">nfs_sync_callout</span>(vnode_t, <span class="enscript-type">void</span> *);

<span class="enscript-type">struct</span> nfs_sync_cargs {
	vfs_context_t	ctx;
	<span class="enscript-type">int</span>		waitfor;
	<span class="enscript-type">int</span>		error;
};

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_sync_callout</span>(vnode_t vp, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> nfs_sync_cargs *cargs = (<span class="enscript-type">struct</span> nfs_sync_cargs*)arg;
	nfsnode_t np = VTONFS(vp);
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (np-&gt;n_flag &amp; NREVOKE) {
		vn_revoke(vp, REVOKEALL, cargs-&gt;ctx);
		<span class="enscript-keyword">return</span> (VNODE_RETURNED);
	}

	<span class="enscript-keyword">if</span> (LIST_EMPTY(&amp;np-&gt;n_dirtyblkhd))
		<span class="enscript-keyword">return</span> (VNODE_RETURNED);
	<span class="enscript-keyword">if</span> (np-&gt;n_wrbusy &gt; 0)
		<span class="enscript-keyword">return</span> (VNODE_RETURNED);
	<span class="enscript-keyword">if</span> (np-&gt;n_bflag &amp; (NBFLUSHINPROG|NBINVALINPROG))
		<span class="enscript-keyword">return</span> (VNODE_RETURNED);

	error = nfs_flush(np, cargs-&gt;waitfor, vfs_context_thread(cargs-&gt;ctx), 0);
	<span class="enscript-keyword">if</span> (error)
		cargs-&gt;error = error;

	<span class="enscript-keyword">return</span> (VNODE_RETURNED);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vfs_sync</span>(mount_t mp, <span class="enscript-type">int</span> waitfor, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> nfs_sync_cargs cargs;

	cargs.waitfor = waitfor;
	cargs.ctx = ctx;
	cargs.error = 0;

	vnode_iterate(mp, 0, nfs_sync_callout, &amp;cargs);

	<span class="enscript-keyword">return</span> (cargs.error);
}

<span class="enscript-comment">/*
 * NFS flat namespace lookup.
 * Currently unsupported.
 */</span>
<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vfs_vget</span>(
	__unused mount_t mp,
	__unused ino64_t ino,
	__unused vnode_t *vpp,
	__unused vfs_context_t ctx)
{

	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-comment">/*
 * At this point, this should never happen
 */</span>
<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vfs_fhtovp</span>(
	__unused mount_t mp,
	__unused <span class="enscript-type">int</span> fhlen,
	__unused <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *fhp,
	__unused vnode_t *vpp,
	__unused vfs_context_t ctx)
{

	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-comment">/*
 * Vnode pointer to File handle, should never happen either
 */</span>
<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vfs_vptofh</span>(
	__unused vnode_t vp,
	__unused <span class="enscript-type">int</span> *fhlenp,
	__unused <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *fhp,
	__unused vfs_context_t ctx)
{

	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-comment">/*
 * Vfs start routine, a no-op.
 */</span>
<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vfs_start</span>(
	__unused mount_t mp,
	__unused <span class="enscript-type">int</span> flags,
	__unused vfs_context_t ctx)
{

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Build the mount info buffer for NFS_MOUNTINFO.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_mountinfo_assemble</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">struct</span> xdrbuf *xb)
{
	<span class="enscript-type">struct</span> xdrbuf xbinfo, xborig;
	<span class="enscript-type">char</span> sotype[6];
	uint32_t origargsvers, origargslength;
	uint32_t infolength_offset, curargsopaquelength_offset, curargslength_offset, attrslength_offset, curargs_end_offset, end_offset;
	uint32_t miattrs[NFS_MIATTR_BITMAP_LEN];
	uint32_t miflags_mask[NFS_MIFLAG_BITMAP_LEN];
	uint32_t miflags[NFS_MIFLAG_BITMAP_LEN];
	uint32_t mattrs[NFS_MATTR_BITMAP_LEN];
	uint32_t mflags_mask[NFS_MFLAG_BITMAP_LEN];
	uint32_t mflags[NFS_MFLAG_BITMAP_LEN];
	uint32_t loc, serv, addr, comp;
	<span class="enscript-type">int</span> i, timeo, error = 0;

	<span class="enscript-comment">/* set up mount info attr and flag bitmaps */</span>
	NFS_BITMAP_ZERO(miattrs, NFS_MIATTR_BITMAP_LEN);
	NFS_BITMAP_SET(miattrs, NFS_MIATTR_FLAGS);
	NFS_BITMAP_SET(miattrs, NFS_MIATTR_ORIG_ARGS);
	NFS_BITMAP_SET(miattrs, NFS_MIATTR_CUR_ARGS);
	NFS_BITMAP_SET(miattrs, NFS_MIATTR_CUR_LOC_INDEX);
	NFS_BITMAP_ZERO(miflags_mask, NFS_MIFLAG_BITMAP_LEN);
	NFS_BITMAP_ZERO(miflags, NFS_MIFLAG_BITMAP_LEN);
	NFS_BITMAP_SET(miflags_mask, NFS_MIFLAG_DEAD);
	NFS_BITMAP_SET(miflags_mask, NFS_MIFLAG_NOTRESP);
	NFS_BITMAP_SET(miflags_mask, NFS_MIFLAG_RECOVERY);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; NFSSTA_DEAD)
		NFS_BITMAP_SET(miflags, NFS_MIFLAG_DEAD);
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_state &amp; (NFSSTA_TIMEO|NFSSTA_JUKEBOXTIMEO)) ||
	    ((nmp-&gt;nm_state &amp; NFSSTA_LOCKTIMEO) &amp;&amp; (nmp-&gt;nm_lockmode == NFS_LOCK_MODE_ENABLED)))
		NFS_BITMAP_SET(miflags, NFS_MIFLAG_NOTRESP);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; NFSSTA_RECOVER)
		NFS_BITMAP_SET(miflags, NFS_MIFLAG_RECOVERY);

	<span class="enscript-comment">/* get original mount args length */</span>
	xb_init_buffer(&amp;xborig, nmp-&gt;nm_args, 2*XDRWORD);
	xb_get_32(error, &amp;xborig, origargsvers); <span class="enscript-comment">/* version */</span>
	xb_get_32(error, &amp;xborig, origargslength); <span class="enscript-comment">/* args length */</span>
	nfsmerr_if(error);

	<span class="enscript-comment">/* set up current mount attributes bitmap */</span>
	NFS_BITMAP_ZERO(mattrs, NFS_MATTR_BITMAP_LEN);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_FLAGS);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_NFS_VERSION);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4)
		NFS_BITMAP_SET(mattrs, NFS_MATTR_NFS_MINOR_VERSION);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_READ_SIZE);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_WRITE_SIZE);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_READDIR_SIZE);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_READAHEAD);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_ATTRCACHE_REG_MIN);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_ATTRCACHE_REG_MAX);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_ATTRCACHE_DIR_MIN);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_ATTRCACHE_DIR_MAX);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_LOCK_MODE);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_SECURITY);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_MAX_GROUP_LIST);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_SOCKET_TYPE);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_NFS_PORT);
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &lt; NFS_VER4) &amp;&amp; nmp-&gt;nm_mountport)
		NFS_BITMAP_SET(mattrs, NFS_MATTR_MOUNT_PORT);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_REQUEST_TIMEOUT);
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, SOFT))
		NFS_BITMAP_SET(mattrs, NFS_MATTR_SOFT_RETRY_COUNT);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_deadtimeout)
		NFS_BITMAP_SET(mattrs, NFS_MATTR_DEAD_TIMEOUT);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_fh)
		NFS_BITMAP_SET(mattrs, NFS_MATTR_FH);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_FS_LOCATIONS);
	NFS_BITMAP_SET(mattrs, NFS_MATTR_MNTFLAGS);
	<span class="enscript-keyword">if</span> (origargsvers &lt; NFS_ARGSVERSION_XDR)
		NFS_BITMAP_SET(mattrs, NFS_MATTR_MNTFROM);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_realm)
		NFS_BITMAP_SET(mattrs, NFS_MATTR_REALM);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_principal)
		NFS_BITMAP_SET(mattrs, NFS_MATTR_PRINCIPAL);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_sprinc)
		NFS_BITMAP_SET(mattrs, NFS_MATTR_SVCPRINCIPAL);
	
	<span class="enscript-comment">/* set up current mount flags bitmap */</span>
	<span class="enscript-comment">/* first set the flags that we will be setting - either on OR off */</span>
	NFS_BITMAP_ZERO(mflags_mask, NFS_MFLAG_BITMAP_LEN);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_SOFT);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_INTR);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_RESVPORT);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_sotype == SOCK_DGRAM)
		NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_NOCONNECT);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_DUMBTIMER);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &lt; NFS_VER4)
		NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_CALLUMNT);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER3)
		NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_RDIRPLUS);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_NONEGNAMECACHE);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_MUTEJUKEBOX);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4) {
		NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_EPHEMERAL);
		NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_NOCALLBACK);
		NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_NONAMEDATTR);
		NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_NOACL);
		NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_ACLONLY);
	}
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_NFC);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_NOQUOTA);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &lt; NFS_VER4)
		NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_MNTUDP);
	NFS_BITMAP_SET(mflags_mask, NFS_MFLAG_MNTQUICK);
	<span class="enscript-comment">/* now set the flags that should be set */</span>
	NFS_BITMAP_ZERO(mflags, NFS_MFLAG_BITMAP_LEN);
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, SOFT))
		NFS_BITMAP_SET(mflags, NFS_MFLAG_SOFT);
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, INTR))
		NFS_BITMAP_SET(mflags, NFS_MFLAG_INTR);
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, RESVPORT))
		NFS_BITMAP_SET(mflags, NFS_MFLAG_RESVPORT);
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_sotype == SOCK_DGRAM) &amp;&amp; NMFLAG(nmp, NOCONNECT))
		NFS_BITMAP_SET(mflags, NFS_MFLAG_NOCONNECT);
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, DUMBTIMER))
		NFS_BITMAP_SET(mflags, NFS_MFLAG_DUMBTIMER);
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &lt; NFS_VER4) &amp;&amp; NMFLAG(nmp, CALLUMNT))
		NFS_BITMAP_SET(mflags, NFS_MFLAG_CALLUMNT);
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER3) &amp;&amp; NMFLAG(nmp, RDIRPLUS))
		NFS_BITMAP_SET(mflags, NFS_MFLAG_RDIRPLUS);
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, NONEGNAMECACHE))
		NFS_BITMAP_SET(mflags, NFS_MFLAG_NONEGNAMECACHE);
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, MUTEJUKEBOX))
		NFS_BITMAP_SET(mflags, NFS_MFLAG_MUTEJUKEBOX);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4) {
		<span class="enscript-keyword">if</span> (NMFLAG(nmp, EPHEMERAL))
			NFS_BITMAP_SET(mflags, NFS_MFLAG_EPHEMERAL);
		<span class="enscript-keyword">if</span> (NMFLAG(nmp, NOCALLBACK))
			NFS_BITMAP_SET(mflags, NFS_MFLAG_NOCALLBACK);
		<span class="enscript-keyword">if</span> (NMFLAG(nmp, NONAMEDATTR))
			NFS_BITMAP_SET(mflags, NFS_MFLAG_NONAMEDATTR);
		<span class="enscript-keyword">if</span> (NMFLAG(nmp, NOACL))
			NFS_BITMAP_SET(mflags, NFS_MFLAG_NOACL);
		<span class="enscript-keyword">if</span> (NMFLAG(nmp, ACLONLY))
			NFS_BITMAP_SET(mflags, NFS_MFLAG_ACLONLY);
	}
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, NFC))
		NFS_BITMAP_SET(mflags, NFS_MFLAG_NFC);
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, NOQUOTA) || ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp;
	    !NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_supp_attr, NFS_FATTR_QUOTA_AVAIL_HARD) &amp;&amp;
	    !NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_supp_attr, NFS_FATTR_QUOTA_AVAIL_SOFT) &amp;&amp;
	    !NFS_BITMAP_ISSET(nmp-&gt;nm_fsattr.nfsa_supp_attr, NFS_FATTR_QUOTA_USED)))
		NFS_BITMAP_SET(mflags, NFS_MFLAG_NOQUOTA);
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &lt; NFS_VER4) &amp;&amp; NMFLAG(nmp, MNTUDP))
		NFS_BITMAP_SET(mflags, NFS_MFLAG_MNTUDP);
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, MNTQUICK))
		NFS_BITMAP_SET(mflags, NFS_MFLAG_MNTQUICK);

	<span class="enscript-comment">/* assemble info buffer: */</span>
	xb_init_buffer(&amp;xbinfo, NULL, 0);
	xb_add_32(error, &amp;xbinfo, NFS_MOUNT_INFO_VERSION);
	infolength_offset = xb_offset(&amp;xbinfo);
	xb_add_32(error, &amp;xbinfo, 0);
	xb_add_bitmap(error, &amp;xbinfo, miattrs, NFS_MIATTR_BITMAP_LEN);
	xb_add_bitmap(error, &amp;xbinfo, miflags, NFS_MIFLAG_BITMAP_LEN);
	xb_add_32(error, &amp;xbinfo, origargslength);
	<span class="enscript-keyword">if</span> (!error)
		error = xb_add_bytes(&amp;xbinfo, nmp-&gt;nm_args, origargslength, 0);

	<span class="enscript-comment">/* the opaque byte count for the current mount args values: */</span>
	curargsopaquelength_offset = xb_offset(&amp;xbinfo);
	xb_add_32(error, &amp;xbinfo, 0);

	<span class="enscript-comment">/* Encode current mount args values */</span>
	xb_add_32(error, &amp;xbinfo, NFS_ARGSVERSION_XDR);
	curargslength_offset = xb_offset(&amp;xbinfo);
	xb_add_32(error, &amp;xbinfo, 0);
	xb_add_32(error, &amp;xbinfo, NFS_XDRARGS_VERSION_0);
	xb_add_bitmap(error, &amp;xbinfo, mattrs, NFS_MATTR_BITMAP_LEN);
	attrslength_offset = xb_offset(&amp;xbinfo);
	xb_add_32(error, &amp;xbinfo, 0);
	xb_add_bitmap(error, &amp;xbinfo, mflags_mask, NFS_MFLAG_BITMAP_LEN);
	xb_add_bitmap(error, &amp;xbinfo, mflags, NFS_MFLAG_BITMAP_LEN);
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_vers);		<span class="enscript-comment">/* NFS_VERSION */</span>
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4)
		xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_minor_vers);	<span class="enscript-comment">/* NFS_MINOR_VERSION */</span>
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_rsize);		<span class="enscript-comment">/* READ_SIZE */</span>
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_wsize);		<span class="enscript-comment">/* WRITE_SIZE */</span>
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_readdirsize);		<span class="enscript-comment">/* READDIR_SIZE */</span>
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_readahead);		<span class="enscript-comment">/* READAHEAD */</span>
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_acregmin);		<span class="enscript-comment">/* ATTRCACHE_REG_MIN */</span>
	xb_add_32(error, &amp;xbinfo, 0);				<span class="enscript-comment">/* ATTRCACHE_REG_MIN */</span>
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_acregmax);		<span class="enscript-comment">/* ATTRCACHE_REG_MAX */</span>
	xb_add_32(error, &amp;xbinfo, 0);				<span class="enscript-comment">/* ATTRCACHE_REG_MAX */</span>
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_acdirmin);		<span class="enscript-comment">/* ATTRCACHE_DIR_MIN */</span>
	xb_add_32(error, &amp;xbinfo, 0);				<span class="enscript-comment">/* ATTRCACHE_DIR_MIN */</span>
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_acdirmax);		<span class="enscript-comment">/* ATTRCACHE_DIR_MAX */</span>
	xb_add_32(error, &amp;xbinfo, 0);				<span class="enscript-comment">/* ATTRCACHE_DIR_MAX */</span>
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_lockmode);		<span class="enscript-comment">/* LOCK_MODE */</span>
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_sec.count) {
		xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_sec.count);		<span class="enscript-comment">/* SECURITY */</span>
		nfsmerr_if(error);
		<span class="enscript-keyword">for</span> (i=0; i &lt; nmp-&gt;nm_sec.count; i++)
			xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_sec.flavors[i]);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nmp-&gt;nm_servsec.count) {
		xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_servsec.count);	<span class="enscript-comment">/* SECURITY */</span>
		nfsmerr_if(error);
		<span class="enscript-keyword">for</span> (i=0; i &lt; nmp-&gt;nm_servsec.count; i++)
			xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_servsec.flavors[i]);
	} <span class="enscript-keyword">else</span> {
		xb_add_32(error, &amp;xbinfo, 1);				<span class="enscript-comment">/* SECURITY */</span>
		xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_auth);
	}
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_numgrps);		<span class="enscript-comment">/* MAX_GROUP_LIST */</span>
	nfsmerr_if(error);
	snprintf(sotype, <span class="enscript-keyword">sizeof</span>(sotype), <span class="enscript-string">&quot;%s%s&quot;</span>, (nmp-&gt;nm_sotype == SOCK_DGRAM) ? <span class="enscript-string">&quot;udp&quot;</span> : <span class="enscript-string">&quot;tcp&quot;</span>,
		nmp-&gt;nm_sofamily ? (nmp-&gt;nm_sofamily == AF_INET) ? <span class="enscript-string">&quot;4&quot;</span> : <span class="enscript-string">&quot;6&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
	xb_add_string(error, &amp;xbinfo, sotype, strlen(sotype));	<span class="enscript-comment">/* SOCKET_TYPE */</span>
	xb_add_32(error, &amp;xbinfo, ntohs(((<span class="enscript-type">struct</span> sockaddr_in*)nmp-&gt;nm_saddr)-&gt;sin_port)); <span class="enscript-comment">/* NFS_PORT */</span>
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &lt; NFS_VER4) &amp;&amp; nmp-&gt;nm_mountport)
		xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_mountport);	<span class="enscript-comment">/* MOUNT_PORT */</span>
	timeo = (nmp-&gt;nm_timeo * 10) / NFS_HZ;
	xb_add_32(error, &amp;xbinfo, timeo/10);			<span class="enscript-comment">/* REQUEST_TIMEOUT */</span>
	xb_add_32(error, &amp;xbinfo, (timeo%10)*100000000);	<span class="enscript-comment">/* REQUEST_TIMEOUT */</span>
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, SOFT))
		xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_retry);	<span class="enscript-comment">/* SOFT_RETRY_COUNT */</span>
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_deadtimeout) {
		xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_deadtimeout);	<span class="enscript-comment">/* DEAD_TIMEOUT */</span>
		xb_add_32(error, &amp;xbinfo, 0);			<span class="enscript-comment">/* DEAD_TIMEOUT */</span>
	}
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_fh)
		xb_add_fh(error, &amp;xbinfo, &amp;nmp-&gt;nm_fh-&gt;fh_data[0], nmp-&gt;nm_fh-&gt;fh_len); <span class="enscript-comment">/* FH */</span>
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_locations.nl_numlocs);			<span class="enscript-comment">/* FS_LOCATIONS */</span>
	<span class="enscript-keyword">for</span> (loc = 0; !error &amp;&amp; (loc &lt; nmp-&gt;nm_locations.nl_numlocs); loc++) {
		xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_servcount);
		<span class="enscript-keyword">for</span> (serv = 0; !error &amp;&amp; (serv &lt; nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_servcount); serv++) {
			xb_add_string(error, &amp;xbinfo, nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_name,
				strlen(nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_name));
			xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_addrcount);
			<span class="enscript-keyword">for</span> (addr = 0; !error &amp;&amp; (addr &lt; nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_addrcount); addr++)
				xb_add_string(error, &amp;xbinfo, nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_addresses[addr],
					strlen(nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_addresses[addr]));
			xb_add_32(error, &amp;xbinfo, 0); <span class="enscript-comment">/* empty server info */</span>
		}
		xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_path.np_compcount);
		<span class="enscript-keyword">for</span> (comp = 0; !error &amp;&amp; (comp &lt; nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_path.np_compcount); comp++)
			xb_add_string(error, &amp;xbinfo, nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_path.np_components[comp],
				strlen(nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_path.np_components[comp]));
		xb_add_32(error, &amp;xbinfo, 0); <span class="enscript-comment">/* empty fs location info */</span>
	}
	xb_add_32(error, &amp;xbinfo, vfs_flags(nmp-&gt;nm_mountp));		<span class="enscript-comment">/* MNTFLAGS */</span>
	<span class="enscript-keyword">if</span> (origargsvers &lt; NFS_ARGSVERSION_XDR)
		xb_add_string(error, &amp;xbinfo, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname,
			strlen(vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname));	<span class="enscript-comment">/* MNTFROM */</span>
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_REALM))
		xb_add_string(error, &amp;xbinfo, nmp-&gt;nm_realm, strlen(nmp-&gt;nm_realm));
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_PRINCIPAL))
		xb_add_string(error, &amp;xbinfo, nmp-&gt;nm_principal, strlen(nmp-&gt;nm_principal));
	<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(mattrs, NFS_MATTR_SVCPRINCIPAL))
		xb_add_string(error, &amp;xbinfo, nmp-&gt;nm_sprinc, strlen(nmp-&gt;nm_sprinc));

	curargs_end_offset = xb_offset(&amp;xbinfo);

	<span class="enscript-comment">/* NFS_MIATTR_CUR_LOC_INDEX */</span>
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_locations.nl_current.nli_flags);
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_locations.nl_current.nli_loc);
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_locations.nl_current.nli_serv);
	xb_add_32(error, &amp;xbinfo, nmp-&gt;nm_locations.nl_current.nli_addr);

	xb_build_done(error, &amp;xbinfo);

	<span class="enscript-comment">/* update opaque counts */</span>
	end_offset = xb_offset(&amp;xbinfo);
	<span class="enscript-keyword">if</span> (!error) {
		error = xb_seek(&amp;xbinfo, attrslength_offset);
		xb_add_32(error, &amp;xbinfo, curargs_end_offset - attrslength_offset - XDRWORD<span class="enscript-comment">/*don't include length field*/</span>);
	}
	<span class="enscript-keyword">if</span> (!error) {
		error = xb_seek(&amp;xbinfo, curargslength_offset);
		xb_add_32(error, &amp;xbinfo, curargs_end_offset - curargslength_offset + XDRWORD<span class="enscript-comment">/*version*/</span>);
	}
	<span class="enscript-keyword">if</span> (!error) {
		error = xb_seek(&amp;xbinfo, curargsopaquelength_offset);
		xb_add_32(error, &amp;xbinfo, curargs_end_offset - curargslength_offset + XDRWORD<span class="enscript-comment">/*version*/</span>);
	}
	<span class="enscript-keyword">if</span> (!error) {
		error = xb_seek(&amp;xbinfo, infolength_offset);
		xb_add_32(error, &amp;xbinfo, end_offset - infolength_offset + XDRWORD<span class="enscript-comment">/*version*/</span>);
	}
	nfsmerr_if(error);

	<span class="enscript-comment">/* copy result xdrbuf to caller */</span>
	*xb = xbinfo;

	<span class="enscript-comment">/* and mark the local copy as not needing cleanup */</span>
	xbinfo.xb_flags &amp;= ~XB_CLEANUP;
<span class="enscript-reference">nfsmerr</span>:
	xb_cleanup(&amp;xbinfo);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Do that sysctl thang...
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_vfs_sysctl</span>(<span class="enscript-type">int</span> *name, u_int namelen, user_addr_t oldp, size_t *oldlenp,
           user_addr_t newp, size_t newlen, vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error = 0, val;
	<span class="enscript-type">int</span> softnobrowse;
	<span class="enscript-type">struct</span> sysctl_req *req = NULL;
	<span class="enscript-type">union</span> union_vfsidctl vc;
	mount_t mp;
	<span class="enscript-type">struct</span> nfsmount *nmp = NULL;
	<span class="enscript-type">struct</span> vfsquery vq;
	<span class="enscript-type">struct</span> nfsreq *rq;
	boolean_t is_64_bit;
	fsid_t fsid;
	<span class="enscript-type">struct</span> xdrbuf xb;
	<span class="enscript-type">struct</span> netfs_status *nsp = NULL;
	<span class="enscript-type">int</span> timeoutmask;
	uint pos, totlen, count, numThreads;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>
	<span class="enscript-type">struct</span> nfs_exportfs *nxfs;
	<span class="enscript-type">struct</span> nfs_export *nx;
	<span class="enscript-type">struct</span> nfs_active_user_list *ulist;
	<span class="enscript-type">struct</span> nfs_export_stat_desc stat_desc;
	<span class="enscript-type">struct</span> nfs_export_stat_rec statrec;
	<span class="enscript-type">struct</span> nfs_user_stat_node *unode, *unode_next;
	<span class="enscript-type">struct</span> nfs_user_stat_desc ustat_desc;
	<span class="enscript-type">struct</span> nfs_user_stat_user_rec ustat_rec;
	<span class="enscript-type">struct</span> nfs_user_stat_path_rec upath_rec;
	uint bytes_avail, bytes_total, recs_copied;
	uint numExports, numRecs;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>

	<span class="enscript-comment">/*
	 * All names at this level are terminal.
	 */</span>
	<span class="enscript-keyword">if</span> (namelen &gt; 1)
		<span class="enscript-keyword">return</span> (ENOTDIR);	<span class="enscript-comment">/* overloaded */</span>

	is_64_bit = vfs_context_is64bit(ctx);

	<span class="enscript-comment">/* common code for &quot;new style&quot; VFS_CTL sysctl, get the mount. */</span>
	<span class="enscript-keyword">switch</span> (name[0]) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_TIMEO</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_NOLOCKS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_NSTATUS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_QUERY</span>:
		req = CAST_DOWN(<span class="enscript-type">struct</span> sysctl_req *, oldp);
		<span class="enscript-keyword">if</span> (req == NULL) {
			<span class="enscript-keyword">return</span> EFAULT;
		}
		error = SYSCTL_IN(req, &amp;vc, is_64_bit? <span class="enscript-keyword">sizeof</span>(vc.vc64):<span class="enscript-keyword">sizeof</span>(vc.vc32));
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		mp = vfs_getvfs(&amp;vc.vc32.vc_fsid); <span class="enscript-comment">/* works for 32 and 64 */</span>
		<span class="enscript-keyword">if</span> (mp == NULL)
			<span class="enscript-keyword">return</span> (ENOENT);
		nmp = VFSTONFS(mp);
		<span class="enscript-keyword">if</span> (!nmp)
			<span class="enscript-keyword">return</span> (ENOENT);
		bzero(&amp;vq, <span class="enscript-keyword">sizeof</span>(vq));
		req-&gt;newidx = 0;
		<span class="enscript-keyword">if</span> (is_64_bit) {
			req-&gt;newptr = vc.vc64.vc_ptr;
			req-&gt;newlen = (size_t)vc.vc64.vc_len;
		} <span class="enscript-keyword">else</span> {
			req-&gt;newptr = CAST_USER_ADDR_T(vc.vc32.vc_ptr);
			req-&gt;newlen = vc.vc32.vc_len;
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">switch</span>(name[0]) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_NFSSTATS</span>:
		<span class="enscript-keyword">if</span> (!oldp) {
			*oldlenp = <span class="enscript-keyword">sizeof</span> nfsstats;
			<span class="enscript-keyword">return</span> (0);
		}

		<span class="enscript-keyword">if</span> (*oldlenp &lt; <span class="enscript-keyword">sizeof</span> nfsstats) {
			*oldlenp = <span class="enscript-keyword">sizeof</span> nfsstats;
			<span class="enscript-keyword">return</span> (ENOMEM);
		}

		error = copyout(&amp;nfsstats, oldp, <span class="enscript-keyword">sizeof</span> nfsstats);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);

		<span class="enscript-keyword">if</span> (newp &amp;&amp; newlen != <span class="enscript-keyword">sizeof</span> nfsstats)
			<span class="enscript-keyword">return</span> (EINVAL);

		<span class="enscript-keyword">if</span> (newp)
			<span class="enscript-keyword">return</span> copyin(newp, &amp;nfsstats, <span class="enscript-keyword">sizeof</span> nfsstats);
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_MOUNTINFO</span>:
		<span class="enscript-comment">/* read in the fsid */</span>
		<span class="enscript-keyword">if</span> (*oldlenp &lt; <span class="enscript-keyword">sizeof</span>(fsid))
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-keyword">if</span> ((error = copyin(oldp, &amp;fsid, <span class="enscript-keyword">sizeof</span>(fsid))))
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-comment">/* swizzle it back to host order */</span>
		fsid.val[0] = ntohl(fsid.val[0]);
		fsid.val[1] = ntohl(fsid.val[1]);
		<span class="enscript-comment">/* find mount and make sure it's NFS */</span>
		<span class="enscript-keyword">if</span> (((mp = vfs_getvfs(&amp;fsid))) == NULL)
			<span class="enscript-keyword">return</span> (ENOENT);
		<span class="enscript-keyword">if</span> (strcmp(mp-&gt;mnt_vfsstat.f_fstypename, <span class="enscript-string">&quot;nfs&quot;</span>))
			<span class="enscript-keyword">return</span> (EINVAL);
		<span class="enscript-keyword">if</span> (((nmp = VFSTONFS(mp))) == NULL)
			<span class="enscript-keyword">return</span> (ENOENT);
		xb_init(&amp;xb, 0);
		<span class="enscript-keyword">if</span> ((error = nfs_mountinfo_assemble(nmp, &amp;xb)))
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">if</span> (*oldlenp &lt; xb.xb_u.xb_buffer.xbb_len)
			error = ENOMEM;
		<span class="enscript-keyword">else</span>
			error = copyout(xb_buffer_base(&amp;xb), oldp, xb.xb_u.xb_buffer.xbb_len);
		*oldlenp = xb.xb_u.xb_buffer.xbb_len;
		xb_cleanup(&amp;xb);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_EXPORTSTATS</span>:
		<span class="enscript-comment">/* setup export stat descriptor */</span>
		stat_desc.rec_vers = NFS_EXPORT_STAT_REC_VERSION;

		<span class="enscript-keyword">if</span> (!nfsrv_is_initialized()) {
			stat_desc.rec_count = 0;
			<span class="enscript-keyword">if</span> (oldp &amp;&amp; (*oldlenp &gt;= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_export_stat_desc)))
				error = copyout(&amp;stat_desc, oldp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_export_stat_desc));
			*oldlenp = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_export_stat_desc);
			<span class="enscript-keyword">return</span> (error);
		}

		<span class="enscript-comment">/* Count the number of exported directories */</span>
		lck_rw_lock_shared(&amp;nfsrv_export_rwlock);
		numExports = 0;
		LIST_FOREACH(nxfs, &amp;nfsrv_exports, nxfs_next)
			LIST_FOREACH(nx, &amp;nxfs-&gt;nxfs_exports, nx_next)
					numExports += 1;

		<span class="enscript-comment">/* update stat descriptor's export record count */</span>
		stat_desc.rec_count = numExports;

		<span class="enscript-comment">/* calculate total size of required buffer */</span>
		totlen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_export_stat_desc) + (numExports * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_export_stat_rec));

		<span class="enscript-comment">/* Check caller's buffer */</span>
		<span class="enscript-keyword">if</span> (oldp == 0) {
			lck_rw_done(&amp;nfsrv_export_rwlock);
			<span class="enscript-comment">/* indicate required buffer len */</span>
			*oldlenp = totlen;
			<span class="enscript-keyword">return</span> (0);
		}

		<span class="enscript-comment">/* We require the caller's buffer to be at least large enough to hold the descriptor */</span>
		<span class="enscript-keyword">if</span> (*oldlenp &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_export_stat_desc)) {
			lck_rw_done(&amp;nfsrv_export_rwlock);
			<span class="enscript-comment">/* indicate required buffer len */</span>
			*oldlenp = totlen;
			<span class="enscript-keyword">return</span> (ENOMEM);
		}

		<span class="enscript-comment">/* indicate required buffer len */</span>
		*oldlenp = totlen;

		<span class="enscript-comment">/* check if export table is empty */</span>
		<span class="enscript-keyword">if</span> (!numExports) {
			lck_rw_done(&amp;nfsrv_export_rwlock);
			error = copyout(&amp;stat_desc, oldp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_export_stat_desc));
			<span class="enscript-keyword">return</span> (error);
		}

		<span class="enscript-comment">/* calculate how many actual export stat records fit into caller's buffer */</span>
		numRecs = (*oldlenp - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_export_stat_desc)) / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_export_stat_rec);

		<span class="enscript-keyword">if</span> (!numRecs) {
			<span class="enscript-comment">/* caller's buffer can only accomodate descriptor */</span>
			lck_rw_done(&amp;nfsrv_export_rwlock);
			stat_desc.rec_count = 0;
			error = copyout(&amp;stat_desc, oldp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_export_stat_desc));
			<span class="enscript-keyword">return</span> (error);
		}

		<span class="enscript-comment">/* adjust to actual number of records to copyout to caller's buffer */</span>
		<span class="enscript-keyword">if</span> (numRecs &gt; numExports)
			numRecs = numExports;

		<span class="enscript-comment">/* set actual number of records we are returning */</span>
		stat_desc.rec_count = numRecs;

		<span class="enscript-comment">/* first copy out the stat descriptor */</span>
		pos = 0;
		error = copyout(&amp;stat_desc, oldp + pos, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_export_stat_desc));
		<span class="enscript-keyword">if</span> (error) {
			lck_rw_done(&amp;nfsrv_export_rwlock);
			<span class="enscript-keyword">return</span> (error);
		}
		pos += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_export_stat_desc);

		<span class="enscript-comment">/* Loop through exported directories */</span>
		count = 0;
		LIST_FOREACH(nxfs, &amp;nfsrv_exports, nxfs_next) {
			LIST_FOREACH(nx, &amp;nxfs-&gt;nxfs_exports, nx_next) {

				<span class="enscript-keyword">if</span> (count &gt;= numRecs)
					<span class="enscript-keyword">break</span>;

				<span class="enscript-comment">/* build exported filesystem path */</span>
				snprintf(statrec.path, <span class="enscript-keyword">sizeof</span>(statrec.path), <span class="enscript-string">&quot;%s%s%s&quot;</span>,
					nxfs-&gt;nxfs_path, ((nxfs-&gt;nxfs_path[1] &amp;&amp; nx-&gt;nx_path[0]) ? <span class="enscript-string">&quot;/&quot;</span> : <span class="enscript-string">&quot;&quot;</span>),
					nx-&gt;nx_path);

				<span class="enscript-comment">/* build the 64-bit export stat counters */</span>
				statrec.ops = ((uint64_t)nx-&gt;nx_stats.ops.hi &lt;&lt; 32) |
						nx-&gt;nx_stats.ops.lo;
				statrec.bytes_read = ((uint64_t)nx-&gt;nx_stats.bytes_read.hi &lt;&lt; 32) |
						nx-&gt;nx_stats.bytes_read.lo;
				statrec.bytes_written = ((uint64_t)nx-&gt;nx_stats.bytes_written.hi &lt;&lt; 32) |
						nx-&gt;nx_stats.bytes_written.lo;
				error = copyout(&amp;statrec, oldp + pos, <span class="enscript-keyword">sizeof</span>(statrec));
				<span class="enscript-keyword">if</span> (error) {
					lck_rw_done(&amp;nfsrv_export_rwlock);
					<span class="enscript-keyword">return</span> (error);
				}
				<span class="enscript-comment">/* advance buffer position */</span>
				pos += <span class="enscript-keyword">sizeof</span>(statrec);
			}
		}
		lck_rw_done(&amp;nfsrv_export_rwlock);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_USERSTATS</span>:
		<span class="enscript-comment">/* init structures used for copying out of kernel */</span>
		ustat_desc.rec_vers = NFS_USER_STAT_REC_VERSION;
		ustat_rec.rec_type = NFS_USER_STAT_USER_REC;
		upath_rec.rec_type = NFS_USER_STAT_PATH_REC;

		<span class="enscript-comment">/* initialize counters */</span>
		bytes_total = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_desc);
		bytes_avail  = *oldlenp;
		recs_copied = 0;

		<span class="enscript-keyword">if</span> (!nfsrv_is_initialized()) <span class="enscript-comment">/* NFS server not initialized, so no stats */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ustat_skip</span>;

		<span class="enscript-comment">/* reclaim old expired user nodes */</span>
		nfsrv_active_user_list_reclaim();

		<span class="enscript-comment">/* reserve space for the buffer descriptor */</span>
		<span class="enscript-keyword">if</span> (bytes_avail &gt;= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_desc))
			bytes_avail -= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_desc);
		<span class="enscript-keyword">else</span>
			bytes_avail = 0;

		<span class="enscript-comment">/* put buffer position past the buffer descriptor */</span>
		pos = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_desc);

		<span class="enscript-comment">/* Loop through exported directories */</span>
		lck_rw_lock_shared(&amp;nfsrv_export_rwlock);
		LIST_FOREACH(nxfs, &amp;nfsrv_exports, nxfs_next) {
			LIST_FOREACH(nx, &amp;nxfs-&gt;nxfs_exports, nx_next) {
				<span class="enscript-comment">/* copy out path */</span>
				<span class="enscript-keyword">if</span> (bytes_avail &gt;= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_path_rec)) {
					snprintf(upath_rec.path, <span class="enscript-keyword">sizeof</span>(upath_rec.path), <span class="enscript-string">&quot;%s%s%s&quot;</span>,
					    nxfs-&gt;nxfs_path, ((nxfs-&gt;nxfs_path[1] &amp;&amp; nx-&gt;nx_path[0]) ? <span class="enscript-string">&quot;/&quot;</span> : <span class="enscript-string">&quot;&quot;</span>),
					    nx-&gt;nx_path);

					error = copyout(&amp;upath_rec, oldp + pos, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_path_rec));
					<span class="enscript-keyword">if</span> (error) {
						<span class="enscript-comment">/* punt */</span>
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">ustat_done</span>;
					}

					pos += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_path_rec);
					bytes_avail -= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_path_rec);
					recs_copied++;
				}
				<span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* Caller's buffer is exhausted */</span>
					bytes_avail = 0;
				}

				bytes_total += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_path_rec);

				<span class="enscript-comment">/* Scan through all user nodes of this export */</span>
				ulist = &amp;nx-&gt;nx_user_list;
				lck_mtx_lock(&amp;ulist-&gt;user_mutex);
				<span class="enscript-keyword">for</span> (unode = TAILQ_FIRST(&amp;ulist-&gt;user_lru); unode; unode = unode_next) {
					unode_next = TAILQ_NEXT(unode, lru_link);

					<span class="enscript-comment">/* copy out node if there is space */</span>
					<span class="enscript-keyword">if</span> (bytes_avail &gt;= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_user_rec)) {
						<span class="enscript-comment">/* prepare a user stat rec for copying out */</span>
						ustat_rec.uid = unode-&gt;uid;
						bcopy(&amp;unode-&gt;sock, &amp;ustat_rec.sock, unode-&gt;sock.ss_len);
						ustat_rec.ops = unode-&gt;ops;
						ustat_rec.bytes_read = unode-&gt;bytes_read;
						ustat_rec.bytes_written = unode-&gt;bytes_written;
						ustat_rec.tm_start = unode-&gt;tm_start;
						ustat_rec.tm_last = unode-&gt;tm_last;

						error = copyout(&amp;ustat_rec, oldp + pos, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_user_rec));

						<span class="enscript-keyword">if</span> (error) {
							<span class="enscript-comment">/* punt */</span>
							lck_mtx_unlock(&amp;ulist-&gt;user_mutex);
							<span class="enscript-keyword">goto</span> <span class="enscript-reference">ustat_done</span>;
						}

						pos += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_user_rec);
						bytes_avail -= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_user_rec);
						recs_copied++;
					}
					<span class="enscript-keyword">else</span> {
						<span class="enscript-comment">/* Caller's buffer is exhausted */</span>
						bytes_avail = 0;
					}
					bytes_total += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_user_rec);
				}
				<span class="enscript-comment">/* can unlock this export's list now */</span>
				lck_mtx_unlock(&amp;ulist-&gt;user_mutex);
			}
		}

<span class="enscript-reference">ustat_done</span>:
		<span class="enscript-comment">/* unlock the export table */</span>
		lck_rw_done(&amp;nfsrv_export_rwlock);

<span class="enscript-reference">ustat_skip</span>:
		<span class="enscript-comment">/* indicate number of actual records copied */</span>
		ustat_desc.rec_count = recs_copied;

		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-comment">/* check if there was enough room for the buffer descriptor */</span>
			<span class="enscript-keyword">if</span> (*oldlenp &gt;= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_desc))
				error = copyout(&amp;ustat_desc, oldp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_user_stat_desc));
			<span class="enscript-keyword">else</span>
				error = ENOMEM;

			<span class="enscript-comment">/* always indicate required buffer size */</span>
			*oldlenp = bytes_total;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_USERCOUNT</span>:
		<span class="enscript-keyword">if</span> (!oldp) {
			*oldlenp = <span class="enscript-keyword">sizeof</span>(nfsrv_user_stat_node_count);
			<span class="enscript-keyword">return</span> (0);
		}

		<span class="enscript-keyword">if</span> (*oldlenp &lt; <span class="enscript-keyword">sizeof</span>(nfsrv_user_stat_node_count)) {
			*oldlenp = <span class="enscript-keyword">sizeof</span>(nfsrv_user_stat_node_count);
			<span class="enscript-keyword">return</span> (ENOMEM);
		}

		<span class="enscript-keyword">if</span> (nfsrv_is_initialized()) {
			<span class="enscript-comment">/* reclaim old expired user nodes */</span>
			nfsrv_active_user_list_reclaim();
		}

		error = copyout(&amp;nfsrv_user_stat_node_count, oldp, <span class="enscript-keyword">sizeof</span>(nfsrv_user_stat_node_count));
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_NOLOCKS</span>:
 		<span class="enscript-keyword">if</span> (req-&gt;oldptr != USER_ADDR_NULL) {
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			val = (nmp-&gt;nm_lockmode == NFS_LOCK_MODE_DISABLED) ? 1 : 0;
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
 			error = SYSCTL_OUT(req, &amp;val, <span class="enscript-keyword">sizeof</span>(val));
 			<span class="enscript-keyword">if</span> (error)
 				<span class="enscript-keyword">return</span> (error);
 		}
 		<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL) {
 			error = SYSCTL_IN(req, &amp;val, <span class="enscript-keyword">sizeof</span>(val));
 			<span class="enscript-keyword">if</span> (error)
 				<span class="enscript-keyword">return</span> (error);
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_lockmode == NFS_LOCK_MODE_LOCAL) {
				<span class="enscript-comment">/* can't toggle locks when using local locks */</span>
				error = EINVAL;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; val) {
				<span class="enscript-comment">/* can't disable locks for NFSv4 */</span>
				error = EINVAL;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (val) {
				<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &lt;= NFS_VER3) &amp;&amp; (nmp-&gt;nm_lockmode == NFS_LOCK_MODE_ENABLED))
					nfs_lockd_mount_unregister(nmp);
				nmp-&gt;nm_lockmode = NFS_LOCK_MODE_DISABLED;
				nmp-&gt;nm_state &amp;= ~NFSSTA_LOCKTIMEO;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &lt;= NFS_VER3) &amp;&amp; (nmp-&gt;nm_lockmode == NFS_LOCK_MODE_DISABLED))
					nfs_lockd_mount_register(nmp);
				nmp-&gt;nm_lockmode = NFS_LOCK_MODE_ENABLED;
			}
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
 		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_QUERY</span>:
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-comment">/* XXX don't allow users to know about/disconnect unresponsive, soft, nobrowse mounts */</span>
		softnobrowse = (NMFLAG(nmp, SOFT) &amp;&amp; (vfs_flags(nmp-&gt;nm_mountp) &amp; MNT_DONTBROWSE));
		<span class="enscript-keyword">if</span> (!softnobrowse &amp;&amp; (nmp-&gt;nm_state &amp; NFSSTA_TIMEO))
			vq.vq_flags |= VQ_NOTRESP;
		<span class="enscript-keyword">if</span> (!softnobrowse &amp;&amp; (nmp-&gt;nm_state &amp; NFSSTA_JUKEBOXTIMEO) &amp;&amp; !NMFLAG(nmp, MUTEJUKEBOX))
			vq.vq_flags |= VQ_NOTRESP;
		<span class="enscript-keyword">if</span> (!softnobrowse &amp;&amp; (nmp-&gt;nm_state &amp; NFSSTA_LOCKTIMEO) &amp;&amp;
		    (nmp-&gt;nm_lockmode == NFS_LOCK_MODE_ENABLED))
			vq.vq_flags |= VQ_NOTRESP;
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; NFSSTA_DEAD)
			vq.vq_flags |= VQ_DEAD;
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		error = SYSCTL_OUT(req, &amp;vq, <span class="enscript-keyword">sizeof</span>(vq));
		<span class="enscript-keyword">break</span>;
 	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_TIMEO</span>:
 		<span class="enscript-keyword">if</span> (req-&gt;oldptr != USER_ADDR_NULL) {
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			val = nmp-&gt;nm_tprintf_initial_delay;
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
 			error = SYSCTL_OUT(req, &amp;val, <span class="enscript-keyword">sizeof</span>(val));
 			<span class="enscript-keyword">if</span> (error)
 				<span class="enscript-keyword">return</span> (error);
 		}
 		<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL) {
 			error = SYSCTL_IN(req, &amp;val, <span class="enscript-keyword">sizeof</span>(val));
 			<span class="enscript-keyword">if</span> (error)
 				<span class="enscript-keyword">return</span> (error);
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
 			<span class="enscript-keyword">if</span> (val &lt; 0)
 				nmp-&gt;nm_tprintf_initial_delay = 0;
			<span class="enscript-keyword">else</span>
				nmp-&gt;nm_tprintf_initial_delay = val;
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
 		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">VFS_CTL_NSTATUS</span>:
		<span class="enscript-comment">/*
		 * Return the status of this mount.  This is much more
		 * information than VFS_CTL_QUERY.  In addition to the
		 * vq_flags return the significant mount options along
		 * with the list of threads blocked on the mount and
		 * how long the threads have been waiting.
		 */</span>

		lck_mtx_lock(nfs_request_mutex);
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);

		<span class="enscript-comment">/*
		 * Count the number of requests waiting for a reply.
		 * Note: there could be multiple requests from the same thread.
		 */</span>
		numThreads = 0;
		TAILQ_FOREACH(rq, &amp;nfs_reqq, r_chain) {
			<span class="enscript-keyword">if</span> (rq-&gt;r_nmp == nmp)
				numThreads++;
		}

		<span class="enscript-comment">/* Calculate total size of result buffer */</span>
		totlen = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> netfs_status) + (numThreads * <span class="enscript-keyword">sizeof</span>(uint64_t));

		<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {		<span class="enscript-comment">// Caller is querying buffer size
</span>			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			lck_mtx_unlock(nfs_request_mutex);
			<span class="enscript-keyword">return</span> SYSCTL_OUT(req, NULL, totlen);
		}
		<span class="enscript-keyword">if</span> (req-&gt;oldlen &lt; totlen) {	<span class="enscript-comment">// Check if caller's buffer is big enough
</span>			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			lck_mtx_unlock(nfs_request_mutex);
			<span class="enscript-keyword">return</span> (ERANGE);
		}

		MALLOC(nsp, <span class="enscript-type">struct</span> netfs_status *, totlen, M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (nsp == NULL) {
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			lck_mtx_unlock(nfs_request_mutex);
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
		timeoutmask = NFSSTA_TIMEO | NFSSTA_LOCKTIMEO | NFSSTA_JUKEBOXTIMEO;
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; timeoutmask)
			nsp-&gt;ns_status |= VQ_NOTRESP;
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; NFSSTA_DEAD)
			nsp-&gt;ns_status |= VQ_DEAD;

		(<span class="enscript-type">void</span>) nfs_mountopts(nmp, nsp-&gt;ns_mountopts, <span class="enscript-keyword">sizeof</span>(nsp-&gt;ns_mountopts));
		nsp-&gt;ns_threadcount = numThreads;
		
		<span class="enscript-comment">/*
		 * Get the thread ids of threads waiting for a reply
		 * and find the longest wait time.
		 */</span>
		<span class="enscript-keyword">if</span> (numThreads &gt; 0) {
			<span class="enscript-type">struct</span> timeval now;
			time_t sendtime;

			microuptime(&amp;now);
			count = 0;
			sendtime = now.tv_sec;
			TAILQ_FOREACH(rq, &amp;nfs_reqq, r_chain) {
				<span class="enscript-keyword">if</span> (rq-&gt;r_nmp == nmp) {
					<span class="enscript-keyword">if</span> (rq-&gt;r_start &lt; sendtime)
						sendtime = rq-&gt;r_start;
		 			<span class="enscript-comment">// A thread_id of zero is used to represent an async I/O request.
</span>					nsp-&gt;ns_threadids[count] =
						rq-&gt;r_thread ? thread_tid(rq-&gt;r_thread) : 0;
					<span class="enscript-keyword">if</span> (++count &gt;= numThreads)
						<span class="enscript-keyword">break</span>;
				}
			}
			nsp-&gt;ns_waittime = now.tv_sec - sendtime;
		}

		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		lck_mtx_unlock(nfs_request_mutex);

 		error = SYSCTL_OUT(req, nsp, totlen);
		FREE(nsp, M_TEMP);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}
	<span class="enscript-keyword">return</span> (error);
}
</pre>
<hr />
</body></html>