<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>xdr_subs.h</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">xdr_subs.h&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1993
 *     The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *     This product includes software developed by the University of
 *     California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *     @(#)xdr_subs.h  8.3 (Berkeley) 3/30/95
 * FreeBSD-Id: xdr_subs.h,v 1.9 1997/02/22 09:42:53 peter Exp $
 */</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">_NFS_XDR_SUBS_H_</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_NFS_XDR_SUBS_H_</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/appleapiopts.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE_API_PRIVATE</span>
<span class="enscript-comment">/*
 * Macros used for conversion to/from xdr representation by nfs...
 * These use the MACHINE DEPENDENT routines ntohl, htonl
 * As defined by &quot;XDR: External Data Representation Standard&quot; RFC1014
 *
 * To simplify the implementation, we use ntohl/htonl even on big-endian
 * machines, and count on them being `#define'd away.  Some of these
 * might be slightly more efficient as quad_t copies on a big-endian,
 * but we cannot count on their alignment anyway.
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">fxdr_unsigned</span>(t, v)	((t)ntohl((uint32_t)(v)))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">txdr_unsigned</span>(v)	(htonl((uint32_t)(v)))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">fxdr_hyper</span>(f, t) { \
	((uint32_t *)(t))[_QUAD_HIGHWORD] = ntohl(((uint32_t *)(f))[0]); \
	((uint32_t *)(t))[_QUAD_LOWWORD] = ntohl(((uint32_t *)(f))[1]); \
}
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">txdr_hyper</span>(f, t) { \
	((uint32_t *)(t))[0] = htonl(((uint32_t *)(f))[_QUAD_HIGHWORD]); \
	((uint32_t *)(t))[1] = htonl(((uint32_t *)(f))[_QUAD_LOWWORD]); \
}


<span class="enscript-comment">/*
 * xdrbuf
 *
 * generalized functionality for managing the building/dissecting of XDR data
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> xdrbuf_type { XDRBUF_BUFFER=1 } xdrbuf_type;

<span class="enscript-type">struct</span> xdrbuf {
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> {
			<span class="enscript-type">char</span> *			xbb_base;	<span class="enscript-comment">/* base address of buffer */</span>
			uint32_t		xbb_size;	<span class="enscript-comment">/* size of buffer */</span>
			uint32_t		xbb_len;	<span class="enscript-comment">/* length of data in buffer */</span>
		} xb_buffer;
	} xb_u;
	<span class="enscript-type">char</span> *		xb_ptr;		<span class="enscript-comment">/* pointer to current position */</span>
	size_t		xb_left;	<span class="enscript-comment">/* bytes remaining in current buffer */</span>
	size_t		xb_growsize;	<span class="enscript-comment">/* bytes to allocate when growing */</span>
	xdrbuf_type	xb_type;	<span class="enscript-comment">/* type of xdr buffer */</span>
	uint32_t	xb_flags;	<span class="enscript-comment">/* XB_* (see below) */</span>
};

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">XB_CLEANUP</span>	0x0001	<span class="enscript-comment">/* needs cleanup */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">XDRWORD</span>		4	<span class="enscript-comment">/* the basic XDR building block is a 4 byte (32 bit) word */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xdr_rndup</span>(a)	(((a)+3)&amp;(~0x3))	<span class="enscript-comment">/* round up to XDRWORD size */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xdr_pad</span>(a)	(xdr_rndup(a) - (a))	<span class="enscript-comment">/* calculate round up padding */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">xb_init</span>(<span class="enscript-type">struct</span> xdrbuf *, xdrbuf_type);
<span class="enscript-type">void</span> <span class="enscript-function-name">xb_init_buffer</span>(<span class="enscript-type">struct</span> xdrbuf *, <span class="enscript-type">char</span> *, size_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">xb_cleanup</span>(<span class="enscript-type">struct</span> xdrbuf *);
<span class="enscript-type">void</span> *<span class="enscript-function-name">xb_malloc</span>(size_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">xb_free</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">int</span> <span class="enscript-function-name">xb_grow</span>(<span class="enscript-type">struct</span> xdrbuf *);
<span class="enscript-type">void</span> <span class="enscript-function-name">xb_set_cur_buf_len</span>(<span class="enscript-type">struct</span> xdrbuf *);
<span class="enscript-type">char</span> *<span class="enscript-function-name">xb_buffer_base</span>(<span class="enscript-type">struct</span> xdrbuf *);
<span class="enscript-type">int</span> <span class="enscript-function-name">xb_advance</span>(<span class="enscript-type">struct</span> xdrbuf *, uint32_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">xb_offset</span>(<span class="enscript-type">struct</span> xdrbuf *);
<span class="enscript-type">int</span> <span class="enscript-function-name">xb_seek</span>(<span class="enscript-type">struct</span> xdrbuf *, uint32_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">xb_add_bytes</span>(<span class="enscript-type">struct</span> xdrbuf *, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *, uint32_t, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">xb_get_bytes</span>(<span class="enscript-type">struct</span> xdrbuf *, <span class="enscript-type">char</span> *, uint32_t, <span class="enscript-type">int</span>);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_NFS_XDR_SUBS_FUNCS_</span>

<span class="enscript-comment">/*
 * basic initialization of xdrbuf structure
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">xb_init</span>(<span class="enscript-type">struct</span> xdrbuf *xbp, xdrbuf_type type)
{
	bzero(xbp, <span class="enscript-keyword">sizeof</span>(*xbp));
	xbp-&gt;xb_type = type;
	xbp-&gt;xb_flags |= XB_CLEANUP;
}

<span class="enscript-comment">/*
 * initialize a single-buffer xdrbuf
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">xb_init_buffer</span>(<span class="enscript-type">struct</span> xdrbuf *xbp, <span class="enscript-type">char</span> *buf, size_t buflen)
{
	xb_init(xbp, XDRBUF_BUFFER);
	xbp-&gt;xb_u.xb_buffer.xbb_base = buf;
	xbp-&gt;xb_u.xb_buffer.xbb_size = buflen;
	xbp-&gt;xb_u.xb_buffer.xbb_len = buflen;
	xbp-&gt;xb_growsize = 512;
	xbp-&gt;xb_ptr = buf;
	xbp-&gt;xb_left = buflen;
	<span class="enscript-keyword">if</span> (buf) <span class="enscript-comment">/* when using an existing buffer, xb code should skip cleanup */</span>
		xbp-&gt;xb_flags &amp;= ~XB_CLEANUP;
}

<span class="enscript-comment">/*
 * get the pointer to the single-buffer xdrbuf's buffer
 */</span>
<span class="enscript-type">char</span> *
<span class="enscript-function-name">xb_buffer_base</span>(<span class="enscript-type">struct</span> xdrbuf *xbp)
{
	<span class="enscript-keyword">return</span> (xbp-&gt;xb_u.xb_buffer.xbb_base);
}

<span class="enscript-comment">/*
 * clean up any resources held by an xdrbuf
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">xb_cleanup</span>(<span class="enscript-type">struct</span> xdrbuf *xbp)
{
	<span class="enscript-keyword">if</span> (!(xbp-&gt;xb_flags &amp; XB_CLEANUP))
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">switch</span> (xbp-&gt;xb_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">XDRBUF_BUFFER</span>:
		<span class="enscript-keyword">if</span> (xbp-&gt;xb_u.xb_buffer.xbb_base)
			xb_free(xbp-&gt;xb_u.xb_buffer.xbb_base);
		<span class="enscript-keyword">break</span>;
	}
	xbp-&gt;xb_flags &amp;= ~XB_CLEANUP;
}

<span class="enscript-comment">/*
 * set the length of valid data in the current buffer to
 * be up to the current location within the buffer
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">xb_set_cur_buf_len</span>(<span class="enscript-type">struct</span> xdrbuf *xbp)
{
	<span class="enscript-keyword">switch</span> (xbp-&gt;xb_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">XDRBUF_BUFFER</span>:
		xbp-&gt;xb_u.xb_buffer.xbb_len = xbp-&gt;xb_ptr - xbp-&gt;xb_u.xb_buffer.xbb_base;
		<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-comment">/*
 * advance forward through existing data in xdrbuf
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">xb_advance</span>(<span class="enscript-type">struct</span> xdrbuf *xbp, uint32_t len)
{
	uint32_t tlen;

	<span class="enscript-keyword">while</span> (len) {
		<span class="enscript-keyword">if</span> (xbp-&gt;xb_left &lt;= 0)
			<span class="enscript-keyword">return</span> (EBADRPC);
		tlen = MIN(xbp-&gt;xb_left, len);
		<span class="enscript-keyword">if</span> (tlen) {
			xbp-&gt;xb_ptr += tlen;
			xbp-&gt;xb_left -= tlen;
			len -= tlen;
		}
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Calculate the current offset in the XDR buffer.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">xb_offset</span>(<span class="enscript-type">struct</span> xdrbuf *xbp)
{
	uint32_t offset = 0;

	<span class="enscript-keyword">switch</span> (xbp-&gt;xb_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">XDRBUF_BUFFER</span>:
		offset = xbp-&gt;xb_ptr - xbp-&gt;xb_u.xb_buffer.xbb_base;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (offset);
}

<span class="enscript-comment">/*
 * Seek to the given offset in the existing data in the XDR buffer.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">xb_seek</span>(<span class="enscript-type">struct</span> xdrbuf *xbp, uint32_t offset)
{

	<span class="enscript-keyword">switch</span> (xbp-&gt;xb_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">XDRBUF_BUFFER</span>:
		xbp-&gt;xb_ptr = xbp-&gt;xb_u.xb_buffer.xbb_base + offset;
		xbp-&gt;xb_left = xbp-&gt;xb_u.xb_buffer.xbb_len - offset;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * allocate memory
 */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">xb_malloc</span>(size_t size)
{
	<span class="enscript-type">void</span> *buf = NULL;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
	MALLOC(buf, <span class="enscript-type">void</span> *, size, M_TEMP, M_WAITOK);
#<span class="enscript-reference">else</span>
	buf = malloc(size);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (buf);
}
<span class="enscript-comment">/*
 * free a chunk of memory allocated with xb_malloc()
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">xb_free</span>(<span class="enscript-type">void</span> *buf)
{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KERNEL</span>
	FREE(buf, M_TEMP);
#<span class="enscript-reference">else</span>
	free(buf);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 * Increase space available for new data in XDR buffer.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">xb_grow</span>(<span class="enscript-type">struct</span> xdrbuf *xbp)
{
	<span class="enscript-type">char</span> *newbuf, *oldbuf;
	size_t newsize, oldsize;

	<span class="enscript-keyword">switch</span> (xbp-&gt;xb_type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">XDRBUF_BUFFER</span>:
		oldsize = xbp-&gt;xb_u.xb_buffer.xbb_size;
		oldbuf = xbp-&gt;xb_u.xb_buffer.xbb_base;
		newsize = oldsize + xbp-&gt;xb_growsize;
		newbuf = xb_malloc(newsize);
		<span class="enscript-keyword">if</span> (newbuf == NULL)
			<span class="enscript-keyword">return</span> (ENOMEM);
		<span class="enscript-keyword">if</span> (oldbuf != NULL) {
			bcopy(oldbuf, newbuf, oldsize);
			xb_free(oldbuf);
		}
		xbp-&gt;xb_u.xb_buffer.xbb_base = newbuf;
		xbp-&gt;xb_u.xb_buffer.xbb_size = newsize;
		xbp-&gt;xb_ptr = newbuf + oldsize;
		xbp-&gt;xb_left = xbp-&gt;xb_growsize;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * xb_add_bytes()
 *
 * Add &quot;count&quot; bytes of opaque data pointed to by &quot;buf&quot; to the given XDR buffer.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">xb_add_bytes</span>(<span class="enscript-type">struct</span> xdrbuf *xbp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *buf, uint32_t count, <span class="enscript-type">int</span> nopad)
{
	uint32_t len, tlen;
	<span class="enscript-type">int</span> error;

	len = nopad ? count : xdr_rndup(count);

	<span class="enscript-comment">/* copy in &quot;count&quot; bytes and zero out any pad bytes */</span>
	<span class="enscript-keyword">while</span> (len) {
		<span class="enscript-keyword">if</span> (xbp-&gt;xb_left &lt;= 0) {
			<span class="enscript-comment">/* need more space */</span>
			<span class="enscript-keyword">if</span> ((error = xb_grow(xbp)))
				<span class="enscript-keyword">return</span> (error);
			<span class="enscript-keyword">if</span> (xbp-&gt;xb_left &lt;= 0)
				<span class="enscript-keyword">return</span> (ENOMEM);
		}
		tlen = MIN(xbp-&gt;xb_left, len);
		<span class="enscript-keyword">if</span> (tlen) {
			<span class="enscript-keyword">if</span> (count) {
				<span class="enscript-keyword">if</span> (tlen &gt; count)
					tlen = count;
				bcopy(buf, xbp-&gt;xb_ptr, tlen);
			} <span class="enscript-keyword">else</span> {
				bzero(xbp-&gt;xb_ptr, tlen);
			}
			xbp-&gt;xb_ptr += tlen;
			xbp-&gt;xb_left -= tlen;
			len -= tlen;
			<span class="enscript-keyword">if</span> (count) {
				buf += tlen;
				count -= tlen;
			}
		}
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * xb_get_bytes()
 *
 * Get &quot;count&quot; bytes of opaque data from the given XDR buffer.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">xb_get_bytes</span>(<span class="enscript-type">struct</span> xdrbuf *xbp, <span class="enscript-type">char</span> *buf, uint32_t count, <span class="enscript-type">int</span> nopad)
{
	uint32_t len, tlen;

	len = nopad ? count : xdr_rndup(count);

	<span class="enscript-comment">/* copy in &quot;count&quot; bytes and zero out any pad bytes */</span>
	<span class="enscript-keyword">while</span> (len) {
		<span class="enscript-keyword">if</span> (xbp-&gt;xb_left &lt;= 0)
			<span class="enscript-keyword">return</span> (ENOMEM);
		tlen = MIN(xbp-&gt;xb_left, len);
		<span class="enscript-keyword">if</span> (tlen) {
			<span class="enscript-keyword">if</span> (count) {
				<span class="enscript-keyword">if</span> (tlen &gt; count)
					tlen = count;
				bcopy(xbp-&gt;xb_ptr, buf, tlen);
			}
			xbp-&gt;xb_ptr += tlen;
			xbp-&gt;xb_left -= tlen;
			len -= tlen;
			<span class="enscript-keyword">if</span> (count) {
				buf += tlen;
				count -= tlen;
			}
		}
	}
	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _NFS_XDR_SUBS_FUNCS_ */</span>


<span class="enscript-comment">/*
 * macros for building XDR data
 */</span>

<span class="enscript-comment">/* finalize the data that has been added to the buffer */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xb_build_done</span>(E, XB) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		xb_set_cur_buf_len(XB); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add a 32-bit value */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xb_add_32</span>(E, XB, VAL) \
	<span class="enscript-keyword">do</span> { \
		uint32_t __tmp; \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		__tmp = txdr_unsigned(VAL); \
		(E) = xb_add_bytes((XB), (<span class="enscript-type">void</span>*)&amp;__tmp, XDRWORD, 0); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add a 64-bit value */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xb_add_64</span>(E, XB, VAL) \
	<span class="enscript-keyword">do</span> { \
		uint64_t __tmp1, __tmp2; \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		__tmp1 = (VAL); \
		txdr_hyper(&amp;__tmp1, &amp;__tmp2); \
		(E) = xb_add_bytes((XB), (<span class="enscript-type">char</span>*)&amp;__tmp2, 2 * XDRWORD, 0); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add an array of XDR words */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xb_add_word_array</span>(E, XB, A, LEN) \
	<span class="enscript-keyword">do</span> { \
		uint32_t __i; \
		xb_add_32((E), (XB), (LEN)); \
		<span class="enscript-keyword">for</span> (__i=0; __i &lt; (uint32_t)(LEN); __i++) \
			xb_add_32((E), (XB), (A)[__i]); \
	} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xb_add_bitmap</span>(E, XB, B, LEN)	xb_add_word_array((E), (XB), (B), (LEN))

<span class="enscript-comment">/* add a file handle */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xb_add_fh</span>(E, XB, FHP, FHLEN) \
	<span class="enscript-keyword">do</span> { \
		xb_add_32((E), (XB), (FHLEN)); \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		(E) = xb_add_bytes((XB), (<span class="enscript-type">char</span>*)(FHP), (FHLEN), 0); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* add a string */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xb_add_string</span>(E, XB, S, LEN) \
	<span class="enscript-keyword">do</span> { \
		xb_add_32((E), (XB), (LEN)); \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		(E) = xb_add_bytes((XB), (<span class="enscript-type">const</span> <span class="enscript-type">char</span>*)(S), (LEN), 0); \
	} <span class="enscript-keyword">while</span> (0)


<span class="enscript-comment">/*
 * macros for decoding XDR data
 */</span>

<span class="enscript-comment">/* skip past data in the buffer */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xb_skip</span>(E, XB, LEN) \
	<span class="enscript-keyword">do</span> { \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		(E) = xb_advance((XB), (LEN)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* get a 32-bit value */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xb_get_32</span>(E, XB, LVAL) \
	<span class="enscript-keyword">do</span> { \
		uint32_t __tmp; \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		(E) = xb_get_bytes((XB), (<span class="enscript-type">char</span>*)&amp;__tmp, XDRWORD, 0); \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		(LVAL) = fxdr_unsigned(uint32_t, __tmp); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* get a 64-bit value */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xb_get_64</span>(E, XB, LVAL) \
	<span class="enscript-keyword">do</span> { \
		uint64_t __tmp; \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		(E) = xb_get_bytes((XB), (<span class="enscript-type">char</span>*)&amp;__tmp, 2 * XDRWORD, 0); \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		fxdr_hyper(&amp;__tmp, &amp;(LVAL)); \
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-comment">/* get an array of XDR words (of a given expected/maximum length) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xb_get_word_array</span>(E, XB, A, LEN) \
	<span class="enscript-keyword">do</span> { \
		uint32_t __len = 0, __i; \
		xb_get_32((E), (XB), __len); \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">for</span> (__i=0; __i &lt; MIN(__len, (uint32_t)(LEN)); __i++) \
			xb_get_32((E), (XB), (A)[__i]); \
		<span class="enscript-keyword">if</span> (E) <span class="enscript-keyword">break</span>; \
		<span class="enscript-keyword">for</span> (; __i &lt; __len; __i++) \
			xb_skip((E), (XB), XDRWORD); \
		<span class="enscript-keyword">for</span> (; __i &lt; (uint32_t)(LEN); __i++) \
			(A)[__i] = 0; \
		(LEN) = __len; \
	} <span class="enscript-keyword">while</span> (0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">xb_get_bitmap</span>(E, XB, B, LEN)	xb_get_word_array((E), (XB), (B), (LEN))

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE_API_PRIVATE */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* _NFS_XDR_SUBS_H_ */</span>
</pre>
<hr />
</body></html>