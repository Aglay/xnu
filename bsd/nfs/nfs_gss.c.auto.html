<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nfs_gss.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nfs_gss.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2007-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*************
 * These functions implement RPCSEC_GSS security for the NFS client and server.
 * The code is specific to the use of Kerberos v5 and the use of DES MAC MD5
 * protection as described in Internet RFC 2203 and 2623.
 *
 * In contrast to the original AUTH_SYS authentication, RPCSEC_GSS is stateful.
 * It requires the client and server negotiate a secure connection as part of a
 * security context. The context state is maintained in client and server structures.
 * On the client side, each user of an NFS mount is assigned their own context,
 * identified by UID, on their first use of the mount, and it persists until the
 * unmount or until the context is renewed.  Each user context has a corresponding
 * server context which the server maintains until the client destroys it, or
 * until the context expires.
 *
 * The client and server contexts are set up dynamically.  When a user attempts
 * to send an NFS request, if there is no context for the user, then one is
 * set up via an exchange of NFS null procedure calls as described in RFC 2203.
 * During this exchange, the client and server pass a security token that is
 * forwarded via Mach upcall to the gssd, which invokes the GSS-API to authenticate
 * the user to the server (and vice-versa). The client and server also receive
 * a unique session key that can be used to digitally sign the credentials and
 * verifier or optionally to provide data integrity and/or privacy.
 *
 * Once the context is complete, the client and server enter a normal data
 * exchange phase - beginning with the NFS request that prompted the context
 * creation. During this phase, the client's RPC header contains an RPCSEC_GSS
 * credential and verifier, and the server returns a verifier as well.
 * For simple authentication, the verifier contains a signed checksum of the
 * RPC header, including the credential.  The server's verifier has a signed
 * checksum of the current sequence number.
 *
 * Each client call contains a sequence number that nominally increases by one
 * on each request.  The sequence number is intended to prevent replay attacks.
 * Since the protocol can be used over UDP, there is some allowance for
 * out-of-sequence requests, so the server checks whether the sequence numbers
 * are within a sequence &quot;window&quot;. If a sequence number is outside the lower
 * bound of the window, the server silently drops the request. This has some
 * implications for retransmission. If a request needs to be retransmitted, the
 * client must bump the sequence number even if the request XID is unchanged.
 *
 * When the NFS mount is unmounted, the client sends a &quot;destroy&quot; credential
 * to delete the server's context for each user of the mount. Since it's
 * possible for the client to crash or disconnect without sending the destroy
 * message, the server has a thread that reaps contexts that have been idle
 * too long.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdint.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ucred.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_special_ports.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_act.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mig_errors.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;gssd/gssd_mach.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/rpcv2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_gss.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsmount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/xdr_subs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsm_subs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_gss.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;nfs_gss_crypto.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach_assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ASSERT</span>(EX) assert(EX)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_GSS_MACH_MAX_RETRIES</span> 3

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_GSS_DBG</span>(...) NFS_DBG(NFS_FAC_GSS, 7, ## __VA_ARGS__)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_GSS_ISDBG</span>  (NFS_DEBUG_FACILITY &amp;  NFS_FAC_GSS)

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	<span class="enscript-type">int</span> type;
	<span class="enscript-type">union</span> {
		MD5_DESCBC_CTX m_ctx;
		HMAC_SHA1_DES3KD_CTX h_ctx;
	};
} GSS_DIGEST_CTX;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_DIGEST</span> SHA_DIGEST_LENGTH
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFS_KERNEL_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HASHLEN</span>(ki)  (((ki)-&gt;hash_len &gt; MAX_DIGEST) ? \
		(panic(<span class="enscript-string">&quot;nfs_gss.c:%d ki-&gt;hash_len is invalid = %d\n&quot;</span>, __LINE__, (ki)-&gt;hash_len), MAX_DIGEST) : (ki)-&gt;hash_len)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">HASHLEN</span>(ki)  (((ki)-&gt;hash_len &gt; MAX_DIGEST) ? \
		(printf(<span class="enscript-string">&quot;nfs_gss.c:%d ki-&gt;hash_len is invalid = %d\n&quot;</span>, __LINE__, (ki)-&gt;hash_len), MAX_DIGEST) : (ki)-&gt;hash_len)
#<span class="enscript-reference">endif</span>	

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>
u_long nfs_gss_svc_ctx_hash;
<span class="enscript-type">struct</span> nfs_gss_svc_ctx_hashhead *nfs_gss_svc_ctx_hashtbl;
lck_mtx_t *nfs_gss_svc_ctx_mutex;
lck_grp_t *nfs_gss_svc_grp;
uint32_t nfsrv_gss_context_ttl = GSS_CTX_EXPIRE;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GSS_SVC_CTX_TTL</span> ((uint64_t)max(2*GSS_CTX_PEND, nfsrv_gss_context_ttl) * NSEC_PER_SEC)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
lck_grp_t *nfs_gss_clnt_grp;
<span class="enscript-type">int</span> nfs_single_des;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSCLIENT */</span>

<span class="enscript-comment">/*
 * These octet strings are used to encode/decode ASN.1 tokens
 * in the RPCSEC_GSS verifiers.
 */</span>
<span class="enscript-type">static</span> u_char krb5_tokhead[] __attribute__((unused)) = { 0x60, 0x23 };
       u_char krb5_mech[11] = { 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x12, 0x01, 0x02, 0x02 };
<span class="enscript-type">static</span> u_char krb5_mic[]  = { 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff };
<span class="enscript-type">static</span> u_char krb5_mic3[]  = { 0x01, 0x01, 0x04, 0x00, 0xff, 0xff, 0xff, 0xff };
<span class="enscript-type">static</span> u_char krb5_wrap[] = { 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff };
<span class="enscript-type">static</span> u_char krb5_wrap3[] = { 0x02, 0x01, 0x04, 0x00, 0x02, 0x00, 0xff, 0xff };
<span class="enscript-type">static</span> u_char iv0[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; <span class="enscript-comment">// DES MAC Initialization Vector
</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ALG_MIC</span>(ki) (((ki)-&gt;type == NFS_GSS_1DES) ? krb5_mic : krb5_mic3)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ALG_WRAP</span>(ki) (((ki)-&gt;type == NFS_GSS_1DES) ? krb5_wrap : krb5_wrap3)

<span class="enscript-comment">/*
 * The size of the Kerberos v5 ASN.1 token
 * in the verifier.
 *
 * Note that the second octet of the krb5_tokhead (0x23) is a
 * DER-encoded size field that has variable length.  If the size
 * is 128 bytes or greater, then it uses two bytes, three bytes
 * if 65536 or greater, and so on.  Since the MIC tokens are
 * separate from the data, the size is always the same: 35 bytes (0x23).
 * However, the wrap token is different. Its size field includes the
 * size of the token + the encrypted data that follows. So the size
 * field may be two, three or four bytes.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KRB5_SZ_TOKHEAD</span> sizeof(krb5_tokhead)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KRB5_SZ_MECH</span>	sizeof(krb5_mech)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KRB5_SZ_ALG</span>	sizeof(krb5_mic) // 8 - same as krb5_wrap
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KRB5_SZ_SEQ</span>	8
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KRB5_SZ_EXTRA</span>	3  // a wrap token may be longer by up to this many octets
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KRB5_SZ_TOKEN_NOSUM</span>	(KRB5_SZ_TOKHEAD + KRB5_SZ_MECH + KRB5_SZ_ALG + KRB5_SZ_SEQ)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KRB5_SZ_TOKEN</span>(cksumlen)		((cksumlen) + KRB5_SZ_TOKEN_NOSUM)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KRB5_SZ_TOKMAX</span>(cksumlen)	(KRB5_SZ_TOKEN(cksumlen) + KRB5_SZ_EXTRA)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_gss_clnt_ctx_find(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_gss_clnt_ctx_init(<span class="enscript-type">struct</span> nfsreq *, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_gss_clnt_ctx_init_retry(<span class="enscript-type">struct</span> nfsreq *, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_gss_clnt_ctx_callserver(<span class="enscript-type">struct</span> nfsreq *, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx *);
<span class="enscript-type">static</span> uint8_t	*nfs_gss_clnt_svcname(<span class="enscript-type">struct</span> nfsmount *, gssd_nametype *, uint32_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_gss_clnt_gssd_upcall(<span class="enscript-type">struct</span> nfsreq *, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx *);
<span class="enscript-type">void</span>		nfs_gss_clnt_ctx_neg_cache_reap(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	nfs_gss_clnt_ctx_clean(<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_gss_clnt_ctx_copy(<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx **, gss_key_info *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	nfs_gss_clnt_ctx_destroy(<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	nfs_gss_clnt_log_error(<span class="enscript-type">struct</span> nfsreq *, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx *, uint32_t, uint32_t);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSCLIENT */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nfs_gss_svc_ctx *<span class="enscript-function-name">nfs_gss_svc_ctx_find</span>(uint32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	nfs_gss_svc_ctx_insert(<span class="enscript-type">struct</span> nfs_gss_svc_ctx *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	nfs_gss_svc_ctx_timer(<span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_gss_svc_gssd_upcall(<span class="enscript-type">struct</span> nfs_gss_svc_ctx *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_gss_svc_seqnum_valid(<span class="enscript-type">struct</span> nfs_gss_svc_ctx *, uint32_t);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	host_release_special_port(mach_port_t);
<span class="enscript-type">static</span> mach_port_t <span class="enscript-function-name">host_copy_special_port</span>(mach_port_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	nfs_gss_mach_alloc_buffer(u_char *, uint32_t, vm_map_copy_t *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_gss_mach_vmcopyout(vm_map_copy_t, uint32_t, u_char *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_gss_token_get(gss_key_info *ki, u_char *, u_char *, <span class="enscript-type">int</span>, uint32_t *, u_char *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_gss_token_put(gss_key_info *ki, u_char *, u_char *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, u_char *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_gss_der_length_size(<span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	nfs_gss_der_length_put(u_char **, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_gss_der_length_get(u_char **);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_gss_mchain_length(mbuf_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	nfs_gss_append_chain(<span class="enscript-type">struct</span> nfsm_chain *, mbuf_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	nfs_gss_nfsm_chain(<span class="enscript-type">struct</span> nfsm_chain *, mbuf_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	nfs_gss_cksum_mchain(gss_key_info *, mbuf_t, u_char *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, u_char *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	nfs_gss_cksum_chain(gss_key_info *, <span class="enscript-type">struct</span> nfsm_chain *, u_char *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, u_char *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	nfs_gss_cksum_rep(gss_key_info *, uint32_t, u_char *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	nfs_gss_encrypt_mchain(gss_key_info *, mbuf_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	nfs_gss_encrypt_chain(gss_key_info *, <span class="enscript-type">struct</span> nfsm_chain *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	gss_digest_Init(GSS_DIGEST_CTX *, gss_key_info *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	gss_digest_Update(GSS_DIGEST_CTX *, <span class="enscript-type">void</span> *, size_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	gss_digest_Final(GSS_DIGEST_CTX *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	gss_des_crypt(gss_key_info *, des_cblock *, des_cblock *,
				int32_t, des_cblock *, des_cblock *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	gss_key_init(gss_key_info *, uint32_t);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>
thread_call_t nfs_gss_svc_ctx_timer_call;
<span class="enscript-type">int</span> nfs_gss_timer_on = 0;
uint32_t nfs_gss_ctx_count = 0;
<span class="enscript-type">const</span> uint32_t nfs_gss_ctx_max = GSS_SVC_MAXCONTEXTS;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>

<span class="enscript-comment">/*
 * Initialization when NFS starts
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_init</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
	nfs_gss_clnt_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;rpcsec_gss_clnt&quot;</span>, LCK_GRP_ATTR_NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSCLIENT */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>
	nfs_gss_svc_grp  = lck_grp_alloc_init(<span class="enscript-string">&quot;rpcsec_gss_svc&quot;</span>,  LCK_GRP_ATTR_NULL);

	nfs_gss_svc_ctx_hashtbl = hashinit(SVC_CTX_HASHSZ, M_TEMP, &amp;nfs_gss_svc_ctx_hash);
	nfs_gss_svc_ctx_mutex = lck_mtx_alloc_init(nfs_gss_svc_grp, LCK_ATTR_NULL);

	nfs_gss_svc_ctx_timer_call = thread_call_allocate(nfs_gss_svc_ctx_timer, NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>

<span class="enscript-comment">/*
 * Find the context for a particular user.
 *
 * If the context doesn't already exist
 * then create a new context for this user.
 *
 * Note that the code allows superuser (uid == 0)
 * to adopt the context of another user.
 *
 * We'll match on the audit session ids, since those
 * processes will have acccess to the same credential cache.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">kauth_cred_getasid</span>(cred) ((cred)-&gt;cr_audit.as_aia_p-&gt;ai_asid)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">kauth_cred_getauid</span>(cred) ((cred)-&gt;cr_audit.as_aia_p-&gt;ai_auid)

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SAFE_CAST_INTTYPE</span>( type, intval ) \
	( (type)(intval)/(<span class="enscript-keyword">sizeof</span>(type) &lt; <span class="enscript-keyword">sizeof</span>(intval) ? 0 : 1) )

uid_t
<span class="enscript-function-name">nfs_cred_getasid2uid</span>(kauth_cred_t cred)
{
	uid_t result = SAFE_CAST_INTTYPE(uid_t, kauth_cred_getasid(cred));
	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-comment">/*
 * Debugging
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_dump</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp;

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	NFS_GSS_DBG(<span class="enscript-string">&quot;Enter\n&quot;</span>);
	TAILQ_FOREACH(cp, &amp;nmp-&gt;nm_gsscl, gss_clnt_entries) {
		lck_mtx_lock(cp-&gt;gss_clnt_mtx);
		printf(<span class="enscript-string">&quot;context %d/%d: refcnt = %d, flags = %x\n&quot;</span>,
		       kauth_cred_getasid(cp-&gt;gss_clnt_cred),
		       kauth_cred_getauid(cp-&gt;gss_clnt_cred),
		       cp-&gt;gss_clnt_refcnt, cp-&gt;gss_clnt_flags);
		lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
	}
	NFS_GSS_DBG(<span class="enscript-string">&quot;Exit\n&quot;</span>);
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">nfs_gss_clnt_ctx_name</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp, <span class="enscript-type">char</span> *buf, <span class="enscript-type">int</span> len)
{
	<span class="enscript-type">char</span> *np;
	<span class="enscript-type">int</span> nlen;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *server = <span class="enscript-string">&quot;&quot;</span>;

	<span class="enscript-keyword">if</span> (nmp &amp;&amp; nmp-&gt;nm_mountp)
		server = vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname;

	<span class="enscript-keyword">if</span> (cp == NULL) {
		snprintf(buf, len, <span class="enscript-string">&quot;[%s] NULL context&quot;</span>, server);
		<span class="enscript-keyword">return</span> (buf);
	}

	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_principal &amp;&amp; !cp-&gt;gss_clnt_display) {
		np = (<span class="enscript-type">char</span> *)cp-&gt;gss_clnt_principal;
		nlen = cp-&gt;gss_clnt_prinlen;
	} <span class="enscript-keyword">else</span> {
		np = cp-&gt;gss_clnt_display;
		nlen = np ? strlen(cp-&gt;gss_clnt_display) : 0;
	}
	<span class="enscript-keyword">if</span> (nlen)
		snprintf(buf, len, <span class="enscript-string">&quot;[%s] %.*s %d/%d %s&quot;</span>, server, nlen, np,
			 kauth_cred_getasid(cp-&gt;gss_clnt_cred),
			 kauth_cred_getuid(cp-&gt;gss_clnt_cred),
			 cp-&gt;gss_clnt_principal ? <span class="enscript-string">&quot;&quot;</span> : <span class="enscript-string">&quot;[from default cred] &quot;</span>);
	<span class="enscript-keyword">else</span>
		snprintf(buf, len, <span class="enscript-string">&quot;[%s] using default %d/%d &quot;</span>, server,
			 kauth_cred_getasid(cp-&gt;gss_clnt_cred),
			 kauth_cred_getuid(cp-&gt;gss_clnt_cred));
	<span class="enscript-keyword">return</span> (buf);
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_CTXBUFSZ</span> 80
#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_GSS_CTX</span>(req, cp) nfs_gss_clnt_ctx_name((req)-&gt;r_nmp, cp ? cp : (req)-&gt;r_gss_ctx, CTXBUF, sizeof(CTXBUF))

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_GSS_CLNT_CTX_DUMP</span>(nmp)		\
	<span class="enscript-keyword">do</span> {		      \
		<span class="enscript-keyword">if</span> (NFS_GSS_ISDBG &amp;&amp; (NFS_DEBUG_FLAGS &amp; 0x2))	\
			nfs_gss_clnt_ctx_dump((nmp));	\
	} <span class="enscript-keyword">while</span> (0)

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_cred_match</span>(kauth_cred_t cred1, kauth_cred_t cred2)
{
	<span class="enscript-keyword">if</span> (kauth_cred_getasid(cred1) == kauth_cred_getasid(cred2))
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Busy the mount for each principal set on the mount
 * so that the automounter will not unmount the file
 * system underneath us. With out this, if an unmount
 * occurs the principal that is set for an audit session
 * will be lost and we may end up with a different identity.
 *
 * Note setting principals on the mount is a bad idea. This
 * really should be handle by KIM (Kerberos Identity Management)
 * so that defaults can be set by service identities.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_clnt_mnt_ref</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">int</span> error;
	vnode_t rvp;

	<span class="enscript-keyword">if</span> (nmp == NULL ||
	    !(vfs_flags(nmp-&gt;nm_mountp) &amp; MNT_AUTOMOUNTED))
		<span class="enscript-keyword">return</span>;

	error = VFS_ROOT(nmp-&gt;nm_mountp, &amp;rvp, NULL);
	<span class="enscript-keyword">if</span> (!error) {
		vnode_ref(rvp);
		vnode_put(rvp);
	}
}

<span class="enscript-comment">/*
 * Unbusy the mout. See above comment,
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_clnt_mnt_rele</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">int</span> error;
	vnode_t rvp;

	<span class="enscript-keyword">if</span> (nmp == NULL ||
	    !(vfs_flags(nmp-&gt;nm_mountp) &amp; MNT_AUTOMOUNTED))
		<span class="enscript-keyword">return</span>;

	error = VFS_ROOT(nmp-&gt;nm_mountp, &amp;rvp, NULL);
	<span class="enscript-keyword">if</span> (!error) {
		vnode_rele(rvp);
		vnode_put(rvp);
	}
}

<span class="enscript-type">int</span> nfs_root_steals_ctx = 1;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_find_principal</span>(<span class="enscript-type">struct</span> nfsreq *req, uint8_t *principal, uint32_t plen, uint32_t nt)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = req-&gt;r_nmp;
	<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp;
	<span class="enscript-type">struct</span> nfsreq treq;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> timeval now;
	gss_key_info *ki;
	<span class="enscript-type">char</span> CTXBUF[NFS_CTXBUFSZ];

	bzero(&amp;treq, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nfsreq));
	treq.r_nmp = nmp;

	microuptime(&amp;now);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	TAILQ_FOREACH(cp, &amp;nmp-&gt;nm_gsscl, gss_clnt_entries) {
		lck_mtx_lock(cp-&gt;gss_clnt_mtx);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_flags &amp; GSS_CTX_DESTROY) {
			NFS_GSS_DBG(<span class="enscript-string">&quot;Found destroyed context %s refcnt = %d continuing\n&quot;</span>,
				    NFS_GSS_CTX(req, cp),
				    cp-&gt;gss_clnt_refcnt);
			lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (nfs_gss_clnt_ctx_cred_match(cp-&gt;gss_clnt_cred, req-&gt;r_cred)) {
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_gsscl.tqh_first != cp) {
				TAILQ_REMOVE(&amp;nmp-&gt;nm_gsscl, cp, gss_clnt_entries);
				TAILQ_INSERT_HEAD(&amp;nmp-&gt;nm_gsscl, cp, gss_clnt_entries);
			}
			<span class="enscript-keyword">if</span> (principal) {
				<span class="enscript-comment">/*
				 * If we have a principal, but it does not match the current cred
				 * mark it for removal
				 */</span>
				<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_prinlen != plen || cp-&gt;gss_clnt_prinnt != nt ||
				    bcmp(cp-&gt;gss_clnt_principal, principal, plen) != 0) {
					cp-&gt;gss_clnt_flags |= (GSS_CTX_INVAL | GSS_CTX_DESTROY);
					cp-&gt;gss_clnt_refcnt++;
					lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
					NFS_GSS_DBG(<span class="enscript-string">&quot;Marking %s for deletion because %s does not match\n&quot;</span>,
						    NFS_GSS_CTX(req, cp), principal);
					NFS_GSS_DBG(<span class="enscript-string">&quot;len = (%d,%d), nt = (%d,%d)\n&quot;</span>, cp-&gt;gss_clnt_prinlen, plen,
						    cp-&gt;gss_clnt_prinnt, nt);
					treq.r_gss_ctx  = cp;
					cp = NULL;
					<span class="enscript-keyword">break</span>;
				}
			}
			<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_flags &amp; GSS_CTX_INVAL) {
				<span class="enscript-comment">/*
				 * If we're still being used and we're not expired
				 * just return and don't bother gssd again. Note if
				 * gss_clnt_nctime is zero it is about to be set to now.
				 */</span>
				<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_nctime + GSS_NEG_CACHE_TO &gt;= now.tv_sec || cp-&gt;gss_clnt_nctime == 0) {
					NFS_GSS_DBG(<span class="enscript-string">&quot;Context %s (refcnt = %d) not expired returning EAUTH nctime = %ld now = %ld\n&quot;</span>,
						    NFS_GSS_CTX(req, cp), cp-&gt;gss_clnt_refcnt, cp-&gt;gss_clnt_nctime, now.tv_sec);
					lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
					lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
					<span class="enscript-keyword">return</span> (NFSERR_EAUTH);
				}
				<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_refcnt) {
					<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *ncp;
					<span class="enscript-comment">/*
					 * If this context has references, we can't use it so we mark if for
					 * destruction and create a new context based on this one in the
					 * same manner as renewing one.
					 */</span>
					cp-&gt;gss_clnt_flags |= GSS_CTX_DESTROY;
					NFS_GSS_DBG(<span class="enscript-string">&quot;Context %s has expired but we still have %d references\n&quot;</span>,
						    NFS_GSS_CTX(req, cp), cp-&gt;gss_clnt_refcnt);
					error = nfs_gss_clnt_ctx_copy(cp, &amp;ncp, NULL);
					lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
					<span class="enscript-keyword">if</span> (error) {
						lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
						<span class="enscript-keyword">return</span> (error);
					}
					cp = ncp;
					<span class="enscript-keyword">break</span>;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* cp-&gt;gss_clnt_kinfo should be NULL here */</span>
					<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_kinfo) {
						FREE(cp-&gt;gss_clnt_kinfo, M_TEMP);
						cp-&gt;gss_clnt_kinfo = NULL;
					}
					<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_nctime)
						nmp-&gt;nm_ncentries--;
					lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
					TAILQ_REMOVE(&amp;nmp-&gt;nm_gsscl, cp, gss_clnt_entries);
					<span class="enscript-keyword">break</span>;
				}
			}
			<span class="enscript-comment">/* Found a valid context to return */</span>
			cp-&gt;gss_clnt_refcnt++;
			req-&gt;r_gss_ctx = cp;
			lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">return</span> (0);
		}
		lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
	}

	MALLOC(ki, gss_key_info *, <span class="enscript-keyword">sizeof</span> (gss_key_info), M_TEMP, M_WAITOK|M_ZERO);
	<span class="enscript-keyword">if</span> (ki == NULL) {
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	<span class="enscript-keyword">if</span> (cp) {
		cp-&gt;gss_clnt_kinfo = ki;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nfs_root_steals_ctx &amp;&amp; principal == NULL &amp;&amp; kauth_cred_getuid(req-&gt;r_cred) == 0) {
		<span class="enscript-comment">/*
		 * If superuser is trying to get access, then co-opt
		 * the first valid context in the list.
		 * XXX Ultimately, we need to allow superuser to
		 * go ahead and attempt to set up its own context
		 * in case one is set up for it.
		 */</span>
		TAILQ_FOREACH(cp, &amp;nmp-&gt;nm_gsscl, gss_clnt_entries) {
			<span class="enscript-keyword">if</span> (!(cp-&gt;gss_clnt_flags &amp; (GSS_CTX_INVAL|GSS_CTX_DESTROY))) {
				nfs_gss_clnt_ctx_ref(req, cp);
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
				NFS_GSS_DBG(<span class="enscript-string">&quot;Root stole context %s\n&quot;</span>, NFS_GSS_CTX(req, NULL));
				<span class="enscript-keyword">return</span> (0);
			}
		}
	}

	NFS_GSS_DBG(<span class="enscript-string">&quot;Context %s%sfound in Neg Cache @  %ld\n&quot;</span>,
		    NFS_GSS_CTX(req, cp),
		    cp == NULL ? <span class="enscript-string">&quot; not &quot;</span> : <span class="enscript-string">&quot;&quot;</span>,
		    cp == NULL ? 0L : cp-&gt;gss_clnt_nctime);

	<span class="enscript-comment">/*
	 * Not found - create a new context
	 */</span>

	<span class="enscript-keyword">if</span> (cp == NULL) {
		MALLOC(cp, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx *, <span class="enscript-keyword">sizeof</span>(*cp), M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (cp == NULL) {
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
		cp-&gt;gss_clnt_kinfo = ki;
		cp-&gt;gss_clnt_cred = req-&gt;r_cred;
		kauth_cred_ref(cp-&gt;gss_clnt_cred);
		cp-&gt;gss_clnt_mtx = lck_mtx_alloc_init(nfs_gss_clnt_grp, LCK_ATTR_NULL);
		cp-&gt;gss_clnt_ptime = now.tv_sec - GSS_PRINT_DELAY;
		<span class="enscript-keyword">if</span> (principal) {
			MALLOC(cp-&gt;gss_clnt_principal, uint8_t *, plen+1, M_TEMP, M_WAITOK|M_ZERO);
			memcpy(cp-&gt;gss_clnt_principal, principal, plen);
			cp-&gt;gss_clnt_prinlen = plen;
			cp-&gt;gss_clnt_prinnt = nt;
			cp-&gt;gss_clnt_flags |= GSS_CTX_STICKY;
			nfs_gss_clnt_mnt_ref(nmp);
		}
	} <span class="enscript-keyword">else</span> {
		nfs_gss_clnt_ctx_clean(cp);
		<span class="enscript-keyword">if</span> (principal) {
			<span class="enscript-comment">/*
			 * If we have a principal and we found a matching audit
			 * session, then to get here, the principal had to match.
			 * In walking the context list if it has a principal
			 * or the principal is not set then we mark the context
			 * for destruction and set cp to NULL and we fall to the
			 * if clause above. If the context still has references
			 * again we copy the context which will preserve the principal
			 * and we end up here with the correct principal set.
			 * If we don't have references the the principal must have
			 * match and we will fall through here.
			 */</span>
			cp-&gt;gss_clnt_flags |= GSS_CTX_STICKY;
		}
	}

	cp-&gt;gss_clnt_thread = current_thread();
	nfs_gss_clnt_ctx_ref(req, cp);
	TAILQ_INSERT_HEAD(&amp;nmp-&gt;nm_gsscl, cp, gss_clnt_entries);
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	error = nfs_gss_clnt_ctx_init_retry(req, cp); <span class="enscript-comment">// Initialize new context
</span>	<span class="enscript-keyword">if</span> (error) {
		NFS_GSS_DBG(<span class="enscript-string">&quot;nfs_gss_clnt_ctx_init_retry returned %d for %s\n&quot;</span>, error, NFS_GSS_CTX(req, cp));
		nfs_gss_clnt_ctx_unref(req);
	}

	<span class="enscript-comment">/* Remove any old matching contex that had a different principal */</span>
	nfs_gss_clnt_ctx_unref(&amp;treq);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_find</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-keyword">return</span> (nfs_gss_clnt_ctx_find_principal(req, NULL, 0, 0));
}

<span class="enscript-comment">/*
 * Inserts an RPCSEC_GSS credential into an RPC header.
 * After the credential is inserted, the code continues
 * to build the verifier which contains a signed checksum
 * of the RPC header.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_clnt_cred_put</span>(<span class="enscript-type">struct</span> nfsreq *req, <span class="enscript-type">struct</span> nfsm_chain *nmc, mbuf_t args)
{
	<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp;
	uint32_t seqnum = 0;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> slpflag, recordmark = 0;
	<span class="enscript-type">int</span> start, len, offset = 0;
	<span class="enscript-type">int</span> pad, toklen;
	<span class="enscript-type">struct</span> nfsm_chain nmc_tmp;
	<span class="enscript-type">struct</span> gss_seq *gsp;
	u_char tokbuf[KRB5_SZ_TOKMAX(MAX_DIGEST)];
	u_char cksum[MAX_DIGEST];
	gss_key_info *ki;

	slpflag = (PZERO-1);
	<span class="enscript-keyword">if</span> (req-&gt;r_nmp) {
		slpflag |= (NMFLAG(req-&gt;r_nmp, INTR) &amp;&amp; req-&gt;r_thread &amp;&amp; !(req-&gt;r_flags &amp; R_NOINTR)) ? PCATCH : 0;
		recordmark = (req-&gt;r_nmp-&gt;nm_sotype == SOCK_STREAM);
	}

<span class="enscript-reference">retry</span>:
	<span class="enscript-keyword">if</span> (req-&gt;r_gss_ctx == NULL) {
		<span class="enscript-comment">/*
		 * Find the context for this user.
		 * If no context is found, one will
		 * be created.
		 */</span>
		error = nfs_gss_clnt_ctx_find(req);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
	}
	cp = req-&gt;r_gss_ctx;

	<span class="enscript-comment">/*
	 * If the context thread isn't null, then the context isn't
	 * yet complete and is for the exclusive use of the thread
	 * doing the context setup. Wait until the context thread
	 * is null.
	 */</span>
	lck_mtx_lock(cp-&gt;gss_clnt_mtx);
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_thread &amp;&amp; cp-&gt;gss_clnt_thread != current_thread()) {
		cp-&gt;gss_clnt_flags |= GSS_NEEDCTX;
		msleep(cp, cp-&gt;gss_clnt_mtx, slpflag | PDROP, <span class="enscript-string">&quot;ctxwait&quot;</span>, NULL);
		slpflag &amp;= ~PCATCH;
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(req-&gt;r_nmp, req, req-&gt;r_thread, 0)))
			<span class="enscript-keyword">return</span> (error);
		nfs_gss_clnt_ctx_unref(req);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
	}
	lck_mtx_unlock(cp-&gt;gss_clnt_mtx);

	ki = cp-&gt;gss_clnt_kinfo;
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_flags &amp; GSS_CTX_COMPLETE) {
		<span class="enscript-comment">/*
		 * Get a sequence number for this request.
		 * Check whether the oldest request in the window is complete.
		 * If it's still pending, then wait until it's done before
		 * we allocate a new sequence number and allow this request
		 * to proceed.
		 */</span>
		lck_mtx_lock(cp-&gt;gss_clnt_mtx);
		<span class="enscript-keyword">while</span> (win_getbit(cp-&gt;gss_clnt_seqbits, 
			((cp-&gt;gss_clnt_seqnum - cp-&gt;gss_clnt_seqwin) + 1) % cp-&gt;gss_clnt_seqwin)) {
			cp-&gt;gss_clnt_flags |= GSS_NEEDSEQ;
			msleep(cp, cp-&gt;gss_clnt_mtx, slpflag | PDROP, <span class="enscript-string">&quot;seqwin&quot;</span>, NULL);
			slpflag &amp;= ~PCATCH;
			<span class="enscript-keyword">if</span> ((error = nfs_sigintr(req-&gt;r_nmp, req, req-&gt;r_thread, 0))) {
				<span class="enscript-keyword">return</span> (error);
			}
			lck_mtx_lock(cp-&gt;gss_clnt_mtx);
			<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_flags &amp; GSS_CTX_INVAL) {
				<span class="enscript-comment">/* Renewed while while we were waiting */</span>
				lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
				nfs_gss_clnt_ctx_unref(req);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
			}
		}
		seqnum = ++cp-&gt;gss_clnt_seqnum;
		win_setbit(cp-&gt;gss_clnt_seqbits, seqnum % cp-&gt;gss_clnt_seqwin);
		lck_mtx_unlock(cp-&gt;gss_clnt_mtx);

		MALLOC(gsp, <span class="enscript-type">struct</span> gss_seq *, <span class="enscript-keyword">sizeof</span>(*gsp), M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (gsp == NULL)
			<span class="enscript-keyword">return</span> (ENOMEM);
		gsp-&gt;gss_seqnum = seqnum;
		SLIST_INSERT_HEAD(&amp;req-&gt;r_gss_seqlist, gsp, gss_seqnext);
	}

	<span class="enscript-comment">/* Insert the credential */</span>
	nfsm_chain_add_32(error, nmc, RPCSEC_GSS);
	nfsm_chain_add_32(error, nmc, 5 * NFSX_UNSIGNED + cp-&gt;gss_clnt_handle_len);
	nfsm_chain_add_32(error, nmc, RPCSEC_GSS_VERS_1);
	nfsm_chain_add_32(error, nmc, cp-&gt;gss_clnt_proc);
	nfsm_chain_add_32(error, nmc, seqnum);
	nfsm_chain_add_32(error, nmc, cp-&gt;gss_clnt_service);
	nfsm_chain_add_32(error, nmc, cp-&gt;gss_clnt_handle_len);
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_handle_len &gt; 0) {
	   	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_handle == NULL)
		  	<span class="enscript-keyword">return</span> (EBADRPC); 
		nfsm_chain_add_opaque(error, nmc, cp-&gt;gss_clnt_handle, cp-&gt;gss_clnt_handle_len);
	}
	<span class="enscript-keyword">if</span> (error)
	    <span class="enscript-keyword">return</span>(error);
	<span class="enscript-comment">/*
	 * Now add the verifier
	 */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_proc == RPCSEC_GSS_INIT ||
		cp-&gt;gss_clnt_proc == RPCSEC_GSS_CONTINUE_INIT) {
		<span class="enscript-comment">/*
		 * If the context is still being created
		 * then use a null verifier.
		 */</span>
		nfsm_chain_add_32(error, nmc, RPCAUTH_NULL);	<span class="enscript-comment">// flavor
</span>		nfsm_chain_add_32(error, nmc, 0);		<span class="enscript-comment">// length
</span>		nfsm_chain_build_done(error, nmc);
		<span class="enscript-keyword">if</span> (!error)
			nfs_gss_append_chain(nmc, args);
		<span class="enscript-keyword">return</span> (error);
	}

	offset = recordmark ? NFSX_UNSIGNED : 0; <span class="enscript-comment">// record mark
</span>	nfsm_chain_build_done(error, nmc);
	nfs_gss_cksum_chain(ki, nmc, ALG_MIC(ki), offset, 0, cksum);

	toklen = nfs_gss_token_put(ki, ALG_MIC(ki), tokbuf, 1, 0, cksum);
	nfsm_chain_add_32(error, nmc, RPCSEC_GSS);	<span class="enscript-comment">// flavor
</span>	nfsm_chain_add_32(error, nmc, toklen);		<span class="enscript-comment">// length
</span>	nfsm_chain_add_opaque(error, nmc, tokbuf, toklen);
	nfsm_chain_build_done(error, nmc);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * Now we may have to compute integrity or encrypt the call args
	 * per RFC 2203 Section 5.3.2
	 */</span>
	<span class="enscript-keyword">switch</span> (cp-&gt;gss_clnt_service) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_SVC_NONE</span>:
		nfs_gss_append_chain(nmc, args);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_SVC_INTEGRITY</span>:
		len = nfs_gss_mchain_length(args);	<span class="enscript-comment">// Find args length
</span>		req-&gt;r_gss_arglen = len;		<span class="enscript-comment">// Stash the args len
</span>		len += NFSX_UNSIGNED;			<span class="enscript-comment">// Add seqnum length
</span>		nfsm_chain_add_32(error, nmc, len);	<span class="enscript-comment">// and insert it
</span>		start = nfsm_chain_offset(nmc);
		nfsm_chain_add_32(error, nmc, seqnum);	<span class="enscript-comment">// Insert seqnum
</span>		req-&gt;r_gss_argoff = nfsm_chain_offset(nmc); <span class="enscript-comment">// Offset to args
</span>		nfsm_chain_build_done(error, nmc);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		nfs_gss_append_chain(nmc, args);	<span class="enscript-comment">// Append the args mbufs
</span>
		<span class="enscript-comment">/* Now compute a checksum over the seqnum + args */</span>
		nfs_gss_cksum_chain(ki, nmc, ALG_MIC(ki), start, len, cksum);

		<span class="enscript-comment">/* Insert it into a token and append to the request */</span>
		toklen = nfs_gss_token_put(ki, ALG_MIC(ki), tokbuf, 1, 0, cksum);
		nfsm_chain_finish_mbuf(error, nmc);	<span class="enscript-comment">// force checksum into new mbuf
</span>		nfsm_chain_add_32(error, nmc, toklen);
		nfsm_chain_add_opaque(error, nmc, tokbuf, toklen);
		nfsm_chain_build_done(error, nmc);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_SVC_PRIVACY</span>:
		<span class="enscript-comment">/* Prepend a new mbuf with the confounder &amp; sequence number */</span>
		nfsm_chain_build_alloc_init(error, &amp;nmc_tmp, 3 * NFSX_UNSIGNED);
		nfsm_chain_add_32(error, &amp;nmc_tmp, random());	<span class="enscript-comment">// confounder bytes 1-4
</span>		nfsm_chain_add_32(error, &amp;nmc_tmp, random());	<span class="enscript-comment">// confounder bytes 4-8
</span>		nfsm_chain_add_32(error, &amp;nmc_tmp, seqnum);
		nfsm_chain_build_done(error, &amp;nmc_tmp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		nfs_gss_append_chain(&amp;nmc_tmp, args);		<span class="enscript-comment">// Append the args mbufs
</span>
		len = nfs_gss_mchain_length(args);		<span class="enscript-comment">// Find args length
</span>		len += 3 * NFSX_UNSIGNED;			<span class="enscript-comment">// add confounder &amp; seqnum
</span>		req-&gt;r_gss_arglen = len;			<span class="enscript-comment">// Stash length
</span>
		<span class="enscript-comment">/*
		 * Append a pad trailer - per RFC 1964 section 1.2.2.3
		 * Since XDR data is always 32-bit aligned, it
		 * needs to be padded either by 4 bytes or 8 bytes.
		 */</span>
		nfsm_chain_finish_mbuf(error, &amp;nmc_tmp);	<span class="enscript-comment">// force padding into new mbuf
</span>		<span class="enscript-keyword">if</span> (len % 8 &gt; 0) {
			nfsm_chain_add_32(error, &amp;nmc_tmp, 0x04040404);
			len += NFSX_UNSIGNED;
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, &amp;nmc_tmp, 0x08080808);
			nfsm_chain_add_32(error, &amp;nmc_tmp, 0x08080808);
			len +=  2 * NFSX_UNSIGNED;
		}
		nfsm_chain_build_done(error, &amp;nmc_tmp);

		<span class="enscript-comment">/* Now compute a checksum over the confounder + seqnum + args */</span>
		nfs_gss_cksum_chain(ki, &amp;nmc_tmp, ALG_WRAP(ki), 0, len, cksum);

		<span class="enscript-comment">/* Insert it into a token */</span>
		toklen = nfs_gss_token_put(ki, ALG_WRAP(ki), tokbuf, 1, len, cksum);
		nfsm_chain_add_32(error, nmc, toklen + len);	<span class="enscript-comment">// token + args length
</span>		nfsm_chain_add_opaque_nopad(error, nmc, tokbuf, toklen);
		req-&gt;r_gss_argoff = nfsm_chain_offset(nmc);	<span class="enscript-comment">// Stash offset
</span>		nfsm_chain_build_done(error, nmc);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		nfs_gss_append_chain(nmc, nmc_tmp.nmc_mhead);	<span class="enscript-comment">// Append the args mbufs
</span>
		<span class="enscript-comment">/* Finally, encrypt the args */</span>
		nfs_gss_encrypt_chain(ki, &amp;nmc_tmp, 0, len, DES_ENCRYPT);

		<span class="enscript-comment">/* Add null XDR pad if the ASN.1 token misaligned the data */</span>
		pad = nfsm_pad(toklen + len);
		<span class="enscript-keyword">if</span> (pad &gt; 0) {
			nfsm_chain_add_opaque_nopad(error, nmc, iv0, pad);
			nfsm_chain_build_done(error, nmc);
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * When receiving a reply, the client checks the verifier
 * returned by the server. Check that the verifier is the
 * correct type, then extract the sequence number checksum
 * from the token in the credential and compare it with a
 * computed checksum of the sequence number in the request
 * that was sent.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_clnt_verf_get</span>(
	<span class="enscript-type">struct</span> nfsreq *req,
	<span class="enscript-type">struct</span> nfsm_chain *nmc,
	uint32_t verftype,
	uint32_t verflen,
	uint32_t *accepted_statusp)
{
	u_char tokbuf[KRB5_SZ_TOKMAX(MAX_DIGEST)];
	u_char cksum1[MAX_DIGEST], cksum2[MAX_DIGEST];
	uint32_t seqnum = 0;
	<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp = req-&gt;r_gss_ctx;
	<span class="enscript-type">struct</span> nfsm_chain nmc_tmp;
	<span class="enscript-type">struct</span> gss_seq *gsp;
	uint32_t reslen, start, cksumlen, toklen;
	<span class="enscript-type">int</span> error = 0;
	gss_key_info *ki = cp-&gt;gss_clnt_kinfo;

	reslen = cksumlen = 0;
	*accepted_statusp = 0;

	<span class="enscript-keyword">if</span> (cp == NULL)
		<span class="enscript-keyword">return</span> (NFSERR_EAUTH);
	<span class="enscript-comment">/*
	 * If it's not an RPCSEC_GSS verifier, then it has to
	 * be a null verifier that resulted from either
	 * a CONTINUE_NEEDED reply during context setup or
	 * from the reply to an AUTH_UNIX call from a dummy
	 * context that resulted from a fallback to sec=sys.
	 */</span>
	<span class="enscript-keyword">if</span> (verftype != RPCSEC_GSS) {
		<span class="enscript-keyword">if</span> (verftype != RPCAUTH_NULL)
			<span class="enscript-keyword">return</span> (NFSERR_EAUTH);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_flags &amp; GSS_CTX_COMPLETE)
			<span class="enscript-keyword">return</span> (NFSERR_EAUTH);
		<span class="enscript-keyword">if</span> (verflen &gt; 0)
			nfsm_chain_adv(error, nmc, nfsm_rndup(verflen));
		nfsm_chain_get_32(error, nmc, *accepted_statusp);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/*
	 * If we received an RPCSEC_GSS verifier but the
	 * context isn't yet complete, then it must be
	 * the context complete message from the server.
	 * The verifier will contain an encrypted checksum
	 * of the window but we don't have the session key
	 * yet so we can't decrypt it. Stash the verifier
	 * and check it later in nfs_gss_clnt_ctx_init() when
	 * the context is complete.
	 */</span>
	<span class="enscript-keyword">if</span> (!(cp-&gt;gss_clnt_flags &amp; GSS_CTX_COMPLETE)) {
		MALLOC(cp-&gt;gss_clnt_verf, u_char *, verflen, M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_verf == NULL)
			<span class="enscript-keyword">return</span> (ENOMEM);
		nfsm_chain_get_opaque(error, nmc, verflen, cp-&gt;gss_clnt_verf);
		nfsm_chain_get_32(error, nmc, *accepted_statusp);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> (verflen != KRB5_SZ_TOKEN(ki-&gt;hash_len))
		<span class="enscript-keyword">return</span> (NFSERR_EAUTH);

	<span class="enscript-comment">/*
	 * Get the 8 octet sequence number
	 * checksum out of the verifier token.
	 */</span>
	nfsm_chain_get_opaque(error, nmc, verflen, tokbuf);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	error = nfs_gss_token_get(ki, ALG_MIC(ki), tokbuf, 0, NULL, cksum1);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;

	<span class="enscript-comment">/*
	 * Search the request sequence numbers for this reply, starting
	 * with the most recent, looking for a checksum that matches
	 * the one in the verifier returned by the server.
	 */</span>
	SLIST_FOREACH(gsp, &amp;req-&gt;r_gss_seqlist, gss_seqnext) {
		nfs_gss_cksum_rep(ki, gsp-&gt;gss_seqnum, cksum2);
		<span class="enscript-keyword">if</span> (bcmp(cksum1, cksum2, HASHLEN(ki)) == 0)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (gsp == NULL)
		<span class="enscript-keyword">return</span> (NFSERR_EAUTH);

	<span class="enscript-comment">/*
	 * Get the RPC accepted status
	 */</span>
	nfsm_chain_get_32(error, nmc, *accepted_statusp);
	<span class="enscript-keyword">if</span> (*accepted_statusp != RPC_SUCCESS)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/*
	 * Now we may have to check integrity or decrypt the results
	 * per RFC 2203 Section 5.3.2
	 */</span>
	<span class="enscript-keyword">switch</span> (cp-&gt;gss_clnt_service) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_SVC_NONE</span>:
		<span class="enscript-comment">/* nothing to do */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_SVC_INTEGRITY</span>:
		<span class="enscript-comment">/*
		 * Here's what we expect in the integrity results:
		 *
		 * - length of seq num + results (4 bytes)
		 * - sequence number (4 bytes)
		 * - results (variable bytes)
		 * - length of checksum token (37)
		 * - checksum of seqnum + results (37 bytes)
		 */</span>
		nfsm_chain_get_32(error, nmc, reslen);		<span class="enscript-comment">// length of results
</span>		<span class="enscript-keyword">if</span> (reslen &gt; NFS_MAXPACKET) {
			error = EBADRPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}

		<span class="enscript-comment">/* Compute a checksum over the sequence number + results */</span>
		start = nfsm_chain_offset(nmc);
		nfs_gss_cksum_chain(ki, nmc, ALG_MIC(ki), start, reslen, cksum1);

		<span class="enscript-comment">/*
		 * Get the sequence number prepended to the results
		 * and compare it against the list in the request.
		 */</span>
		nfsm_chain_get_32(error, nmc, seqnum);
		SLIST_FOREACH(gsp, &amp;req-&gt;r_gss_seqlist, gss_seqnext) {
			<span class="enscript-keyword">if</span> (seqnum == gsp-&gt;gss_seqnum)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (gsp == NULL) {
			error = EBADRPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}

		<span class="enscript-comment">/*
		 * Advance to the end of the results and
		 * fetch the checksum computed by the server.
		 */</span>
		nmc_tmp = *nmc;	
		reslen -= NFSX_UNSIGNED;			<span class="enscript-comment">// already skipped seqnum
</span>		nfsm_chain_adv(error, &amp;nmc_tmp, reslen);	<span class="enscript-comment">// skip over the results
</span>		nfsm_chain_get_32(error, &amp;nmc_tmp, cksumlen);	<span class="enscript-comment">// length of checksum
</span>		<span class="enscript-keyword">if</span> (cksumlen != KRB5_SZ_TOKEN(ki-&gt;hash_len)) {
			error = EBADRPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
		nfsm_chain_get_opaque(error, &amp;nmc_tmp, cksumlen, tokbuf);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		error = nfs_gss_token_get(ki, ALG_MIC(ki), tokbuf, 0, NULL, cksum2);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;

		<span class="enscript-comment">/* Verify that the checksums are the same */</span>
		<span class="enscript-keyword">if</span> (bcmp(cksum1, cksum2, HASHLEN(ki)) != 0) {
			error = EBADRPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_SVC_PRIVACY</span>:
		<span class="enscript-comment">/*
		 * Here's what we expect in the privacy results:
		 *
		 * - length of confounder + seq num + token + results
		 * - wrap token (37-40 bytes)
		 * - confounder (8 bytes)
		 * - sequence number (4 bytes)
		 * - results (encrypted)
		 */</span>
		nfsm_chain_get_32(error, nmc, reslen);		<span class="enscript-comment">// length of results
</span>		<span class="enscript-keyword">if</span> (reslen &gt; NFS_MAXPACKET) {
			error = EBADRPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}

		<span class="enscript-comment">/* Get the token that prepends the encrypted results */</span>
		nfsm_chain_get_opaque(error, nmc, KRB5_SZ_TOKMAX(ki-&gt;hash_len), tokbuf);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		error = nfs_gss_token_get(ki, ALG_WRAP(ki), tokbuf, 0,
			&amp;toklen, cksum1);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		nfsm_chain_reverse(nmc, nfsm_pad(toklen));
		reslen -= toklen;				<span class="enscript-comment">// size of confounder + seqnum + results
</span>
		<span class="enscript-comment">/* decrypt the confounder + sequence number + results */</span>
		start = nfsm_chain_offset(nmc);
		nfs_gss_encrypt_chain(ki, nmc, start, reslen, DES_DECRYPT);

		<span class="enscript-comment">/* Compute a checksum over the confounder + sequence number + results */</span>
		nfs_gss_cksum_chain(ki, nmc, ALG_WRAP(ki), start, reslen, cksum2);

		<span class="enscript-comment">/* Verify that the checksums are the same */</span>
		<span class="enscript-keyword">if</span> (bcmp(cksum1, cksum2, HASHLEN(ki)) != 0) {
			error = EBADRPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}

		nfsm_chain_adv(error, nmc, 8);	<span class="enscript-comment">// skip over the confounder
</span>
		<span class="enscript-comment">/*
		 * Get the sequence number prepended to the results
		 * and compare it against the list in the request.
		 */</span>
		nfsm_chain_get_32(error, nmc, seqnum);
		SLIST_FOREACH(gsp, &amp;req-&gt;r_gss_seqlist, gss_seqnext) {
			<span class="enscript-keyword">if</span> (seqnum == gsp-&gt;gss_seqnum)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (gsp == NULL) {
			error = EBADRPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}

		<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * An RPCSEC_GSS request with no integrity or privacy consists
 * of just the header mbufs followed by the arg mbufs.
 *
 * However, integrity or privacy both trailer mbufs to the args,
 * which means we have to do some work to restore the arg mbuf
 * chain to its previous state in case we need to retransmit.
 *
 * The location and length of the args is marked by two fields
 * in the request structure: r_gss_argoff and r_gss_arglen,
 * which are stashed when the NFS request is built.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_clnt_args_restore</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp = req-&gt;r_gss_ctx;
	<span class="enscript-type">struct</span> nfsm_chain mchain, *nmc = &amp;mchain;
	<span class="enscript-type">int</span> len, error = 0;

	<span class="enscript-keyword">if</span> (cp == NULL)
		<span class="enscript-keyword">return</span> (NFSERR_EAUTH);

	<span class="enscript-keyword">if</span> ((cp-&gt;gss_clnt_flags &amp; GSS_CTX_COMPLETE) == 0)
		<span class="enscript-keyword">return</span> (ENEEDAUTH);

	nfsm_chain_dissect_init(error, nmc, req-&gt;r_mhead);	<span class="enscript-comment">// start at RPC header
</span>	nfsm_chain_adv(error, nmc, req-&gt;r_gss_argoff);		<span class="enscript-comment">// advance to args
</span>	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">switch</span> (cp-&gt;gss_clnt_service) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_SVC_NONE</span>:
		<span class="enscript-comment">/* nothing to do */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_SVC_INTEGRITY</span>:
		<span class="enscript-comment">/*
		 * All we have to do here is remove the appended checksum mbufs.
		 * We know that the checksum starts in a new mbuf beyond the end
		 * of the args.
		 */</span>
		nfsm_chain_adv(error, nmc, req-&gt;r_gss_arglen);	<span class="enscript-comment">// adv to last args mbuf
</span>		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);

		mbuf_freem(mbuf_next(nmc-&gt;nmc_mcur));		<span class="enscript-comment">// free the cksum mbuf
</span>		error = mbuf_setnext(nmc-&gt;nmc_mcur, NULL);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_SVC_PRIVACY</span>:
		<span class="enscript-comment">/*
		 * The args are encrypted along with prepended confounders and seqnum.
		 * First we decrypt, the confounder, seqnum and args then skip to the
		 * final mbuf of the args.
		 * The arglen includes 8 bytes of confounder and 4 bytes of seqnum.
		 * Finally, we remove between 4 and 8 bytes of encryption padding
		 * as well as any alignment padding in the trailing mbuf.
		 */</span>
		len = req-&gt;r_gss_arglen;
		len += len % 8 &gt; 0 ? 4 : 8;			<span class="enscript-comment">// add DES padding length
</span>		nfs_gss_encrypt_chain(cp-&gt;gss_clnt_kinfo, nmc,
					req-&gt;r_gss_argoff, len, DES_DECRYPT);
		nfsm_chain_adv(error, nmc, req-&gt;r_gss_arglen);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		mbuf_freem(mbuf_next(nmc-&gt;nmc_mcur));		<span class="enscript-comment">// free the pad mbuf
</span>		error = mbuf_setnext(nmc-&gt;nmc_mcur, NULL);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * This function sets up  a new context on the client.
 * Context setup alternates upcalls to the gssd with NFS nullproc calls
 * to the server.  Each of these calls exchanges an opaque token, obtained
 * via the gssd's calls into the GSS-API on either the client or the server.
 * This cycle of calls ends when the client's upcall to the gssd and the
 * server's response both return GSS_S_COMPLETE.  At this point, the client
 * should have its session key and a handle that it can use to refer to its
 * new context on the server.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_init</span>(<span class="enscript-type">struct</span> nfsreq *req, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = req-&gt;r_nmp;
	<span class="enscript-type">int</span> client_complete = 0;
	<span class="enscript-type">int</span> server_complete = 0;
	u_char cksum1[MAX_DIGEST], cksum2[MAX_DIGEST];
	<span class="enscript-type">int</span> error = 0;
	gss_key_info *ki = cp-&gt;gss_clnt_kinfo;

	<span class="enscript-comment">/* Initialize a new client context */</span>

	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_svcname == NULL) {
		cp-&gt;gss_clnt_svcname = nfs_gss_clnt_svcname(nmp, &amp;cp-&gt;gss_clnt_svcnt, &amp;cp-&gt;gss_clnt_svcnamlen);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_svcname == NULL) {
			error = NFSERR_EAUTH;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
	}

	cp-&gt;gss_clnt_proc = RPCSEC_GSS_INIT;

	cp-&gt;gss_clnt_service =
		req-&gt;r_auth == RPCAUTH_KRB5  ? RPCSEC_GSS_SVC_NONE :
		req-&gt;r_auth == RPCAUTH_KRB5I ? RPCSEC_GSS_SVC_INTEGRITY :
		req-&gt;r_auth == RPCAUTH_KRB5P ? RPCSEC_GSS_SVC_PRIVACY : 0;

	cp-&gt;gss_clnt_gssd_flags = (nfs_single_des ? GSSD_NFS_1DES : 0);
	<span class="enscript-comment">/*
	 * Now loop around alternating gss_init_sec_context and
	 * gss_accept_sec_context upcalls to the gssd on the client
	 * and server side until the context is complete - or fails.
	 */</span>
	<span class="enscript-keyword">for</span> (;;) {

<span class="enscript-reference">retry</span>:
		<span class="enscript-comment">/* Upcall to the gss_init_sec_context in the gssd */</span>
		error = nfs_gss_clnt_gssd_upcall(req, cp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;

		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_major == GSS_S_COMPLETE) {
			client_complete = 1;
			<span class="enscript-keyword">if</span> (server_complete)
				<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_major != GSS_S_CONTINUE_NEEDED) {
			error = NFSERR_EAUTH;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}

		<span class="enscript-comment">/*
		 * Pass the token to the server.
		 */</span>
		error = nfs_gss_clnt_ctx_callserver(req, cp);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error == ENEEDAUTH &amp;&amp; cp-&gt;gss_clnt_proc == RPCSEC_GSS_INIT &amp;&amp;
				(cp-&gt;gss_clnt_gssd_flags &amp; (GSSD_RESTART | GSSD_NFS_1DES)) == 0) {
				NFS_GSS_DBG(<span class="enscript-string">&quot;Retrying with single DES for req %p\n&quot;</span>, req);
				cp-&gt;gss_clnt_gssd_flags = (GSSD_RESTART | GSSD_NFS_1DES);
				<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_token)
					FREE(cp-&gt;gss_clnt_token, M_TEMP);
				cp-&gt;gss_clnt_token = NULL;
				cp-&gt;gss_clnt_tokenlen = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
			}
			<span class="enscript-comment">// Reset flags, if error = ENEEDAUTH we will try 3des again
</span>			cp-&gt;gss_clnt_gssd_flags = 0; 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_major == GSS_S_COMPLETE) {
			server_complete = 1;
			<span class="enscript-keyword">if</span> (client_complete)
				<span class="enscript-keyword">break</span>;
		}
		cp-&gt;gss_clnt_proc = RPCSEC_GSS_CONTINUE_INIT;
	}

	<span class="enscript-comment">/*
	 * The context is apparently established successfully
	 */</span>
	lck_mtx_lock(cp-&gt;gss_clnt_mtx);
	cp-&gt;gss_clnt_flags |= GSS_CTX_COMPLETE;
	lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
	cp-&gt;gss_clnt_proc = RPCSEC_GSS_DATA;

	<span class="enscript-comment">/*
	 * Compute checksum of the server's window
	 */</span>
	nfs_gss_cksum_rep(ki, cp-&gt;gss_clnt_seqwin, cksum1);

	<span class="enscript-comment">/*
	 * and see if it matches the one in the
	 * verifier the server returned.
	 */</span>
	error = nfs_gss_token_get(ki, ALG_MIC(ki), cp-&gt;gss_clnt_verf, 0,
		NULL, cksum2);
	FREE(cp-&gt;gss_clnt_verf, M_TEMP);
	cp-&gt;gss_clnt_verf = NULL;

	<span class="enscript-keyword">if</span> (error || bcmp(cksum1, cksum2, HASHLEN(ki)) != 0) {
		error = NFSERR_EAUTH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}

	<span class="enscript-comment">/*
	 * Set an initial sequence number somewhat randomized.
	 * Start small so we don't overflow GSS_MAXSEQ too quickly.
	 * Add the size of the sequence window so seqbits arithmetic
	 * doesn't go negative.
	 */</span>
	cp-&gt;gss_clnt_seqnum = (random() &amp; 0xffff) + cp-&gt;gss_clnt_seqwin;

	<span class="enscript-comment">/*
	 * Allocate a bitmap to keep track of which requests
	 * are pending within the sequence number window.
	 */</span>
	MALLOC(cp-&gt;gss_clnt_seqbits, uint32_t *,
		nfsm_rndup((cp-&gt;gss_clnt_seqwin + 7) / 8), M_TEMP, M_WAITOK|M_ZERO);
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_seqbits == NULL)
		error = NFSERR_EAUTH;
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-comment">/*
	 * If the error is ENEEDAUTH we're not done, so no need
	 * to wake up other threads again. This thread will retry in
	 * the find or renew routines.
	 */</span>
	<span class="enscript-keyword">if</span> (error == ENEEDAUTH)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * If there's an error, just mark it as invalid.
	 * It will be removed when the reference count
	 * drops to zero.
	 */</span>
	lck_mtx_lock(cp-&gt;gss_clnt_mtx);
	<span class="enscript-keyword">if</span> (error)
		cp-&gt;gss_clnt_flags |= GSS_CTX_INVAL;

	<span class="enscript-comment">/*
	 * Wake any threads waiting to use the context
	 */</span>
	cp-&gt;gss_clnt_thread = NULL;
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_flags &amp; GSS_NEEDCTX) {
		cp-&gt;gss_clnt_flags &amp;= ~GSS_NEEDCTX;
		wakeup(cp);
	}
	lck_mtx_unlock(cp-&gt;gss_clnt_mtx);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * This function calls nfs_gss_clnt_ctx_init() to set up a new context.
 * But if there's a failure in trying to establish the context it keeps
 * retrying at progressively longer intervals in case the failure is
 * due to some transient condition.  For instance, the server might be
 * failing the context setup because directory services is not coming
 * up in a timely fashion.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_init_retry</span>(<span class="enscript-type">struct</span> nfsreq *req, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = req-&gt;r_nmp;
	<span class="enscript-type">struct</span> timeval now;
	time_t waituntil;
	<span class="enscript-type">int</span> error, slpflag;
	<span class="enscript-type">int</span> retries = 0;
	<span class="enscript-type">int</span> timeo = NFS_TRYLATERDEL;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* For an &quot;intr&quot; mount allow a signal to interrupt the retries */</span>
	slpflag = (NMFLAG(nmp, INTR) &amp;&amp; !(req-&gt;r_flags &amp; R_NOINTR)) ? PCATCH : 0;

	<span class="enscript-keyword">while</span> ((error = nfs_gss_clnt_ctx_init(req, cp)) == ENEEDAUTH) {
		microuptime(&amp;now);
		waituntil = now.tv_sec + timeo;
		<span class="enscript-keyword">while</span> (now.tv_sec &lt; waituntil) {
			tsleep(NULL, PSOCK | slpflag, <span class="enscript-string">&quot;nfs_gss_clnt_ctx_init_retry&quot;</span>, hz);
			slpflag = 0;
			error = nfs_sigintr(req-&gt;r_nmp, req, current_thread(), 0);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			microuptime(&amp;now);
		}

		retries++;
		<span class="enscript-comment">/* If it's a soft mount just give up after a while */</span>
		<span class="enscript-keyword">if</span> ((NMFLAG(nmp, SOFT) || (req-&gt;r_flags &amp; R_SOFT)) &amp;&amp; (retries &gt; nmp-&gt;nm_retry)) {
			error = ETIMEDOUT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		timeo *= 2;
		<span class="enscript-keyword">if</span> (timeo &gt; 60)
			timeo = 60;
	}

	<span class="enscript-keyword">if</span> (error == 0)
		<span class="enscript-keyword">return</span> 0;	<span class="enscript-comment">// success
</span><span class="enscript-reference">bad</span>:
	<span class="enscript-comment">/*
	 * Give up on this context
	 */</span>
	lck_mtx_lock(cp-&gt;gss_clnt_mtx);
	cp-&gt;gss_clnt_flags |= GSS_CTX_INVAL;

	<span class="enscript-comment">/*
	 * Wake any threads waiting to use the context
	 */</span>
	cp-&gt;gss_clnt_thread = NULL;
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_flags &amp; GSS_NEEDCTX) {
		cp-&gt;gss_clnt_flags &amp;= ~GSS_NEEDCTX;
		wakeup(cp);
	}
	lck_mtx_unlock(cp-&gt;gss_clnt_mtx);				

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Call the NFS server using a null procedure for context setup.
 * Even though it's a null procedure and nominally has no arguments
 * RFC 2203 requires that the GSS-API token be passed as an argument
 * and received as a reply.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_callserver</span>(<span class="enscript-type">struct</span> nfsreq *req, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp)
{
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">int</span> error = 0, status;
	uint32_t major = cp-&gt;gss_clnt_major, minor = cp-&gt;gss_clnt_minor;
	<span class="enscript-type">int</span> sz;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(req-&gt;r_nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);
	sz = NFSX_UNSIGNED + nfsm_rndup(cp-&gt;gss_clnt_tokenlen);
	nfsm_chain_build_alloc_init(error, &amp;nmreq, sz);
	nfsm_chain_add_32(error, &amp;nmreq, cp-&gt;gss_clnt_tokenlen);
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_tokenlen &gt; 0)
		nfsm_chain_add_opaque(error, &amp;nmreq, cp-&gt;gss_clnt_token, cp-&gt;gss_clnt_tokenlen);
	nfsm_chain_build_done(error, &amp;nmreq);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;

	<span class="enscript-comment">/* Call the server */</span>
	error = nfs_request_gss(req-&gt;r_nmp-&gt;nm_mountp, &amp;nmreq, req-&gt;r_thread, req-&gt;r_cred, 
				(req-&gt;r_flags &amp; R_OPTMASK), cp, &amp;nmrep, &amp;status);
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_token != NULL) {
		FREE(cp-&gt;gss_clnt_token, M_TEMP);
		cp-&gt;gss_clnt_token = NULL;
	}
	<span class="enscript-keyword">if</span> (!error)
		error = status;
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;

	<span class="enscript-comment">/* Get the server's reply */</span>

	nfsm_chain_get_32(error, &amp;nmrep, cp-&gt;gss_clnt_handle_len);
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_handle != NULL) {
		FREE(cp-&gt;gss_clnt_handle, M_TEMP);
		cp-&gt;gss_clnt_handle = NULL;
	}
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_handle_len &gt; 0) {
		MALLOC(cp-&gt;gss_clnt_handle, u_char *, cp-&gt;gss_clnt_handle_len, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_handle == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
		nfsm_chain_get_opaque(error, &amp;nmrep, cp-&gt;gss_clnt_handle_len, cp-&gt;gss_clnt_handle);
	}
	nfsm_chain_get_32(error, &amp;nmrep, cp-&gt;gss_clnt_major);
	nfsm_chain_get_32(error, &amp;nmrep, cp-&gt;gss_clnt_minor);
	nfsm_chain_get_32(error, &amp;nmrep, cp-&gt;gss_clnt_seqwin);
	nfsm_chain_get_32(error, &amp;nmrep, cp-&gt;gss_clnt_tokenlen);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_tokenlen &gt; 0) {
		MALLOC(cp-&gt;gss_clnt_token, u_char *, cp-&gt;gss_clnt_tokenlen, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_token == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
		nfsm_chain_get_opaque(error, &amp;nmrep, cp-&gt;gss_clnt_tokenlen, cp-&gt;gss_clnt_token);
	}

	<span class="enscript-comment">/*
	 * Make sure any unusual errors are expanded and logged by gssd
	 */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_major != GSS_S_COMPLETE &amp;&amp;
	    cp-&gt;gss_clnt_major != GSS_S_CONTINUE_NEEDED) {

		printf(<span class="enscript-string">&quot;nfs_gss_clnt_ctx_callserver: gss_clnt_major = %d\n&quot;</span>, cp-&gt;gss_clnt_major);
		nfs_gss_clnt_log_error(req, cp, major, minor);
		
	}

<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * We construct the service principal as a gss hostbased service principal of
 * the form nfs@&lt;server&gt;, unless the servers principal was passed down in the
 * mount arguments. If the arguments don't specify the service principal, the
 * server name is extracted the location passed in the mount argument if
 * available.  Otherwise assume a format of &lt;server&gt;:&lt;path&gt; in the
 * mntfromname. We don't currently support url's or other bizarre formats like
 * path@server. Mount_url will convert the nfs url into &lt;server&gt;:&lt;path&gt; when
 * calling mount, so this works out well in practice.
 *
 */</span>

<span class="enscript-type">static</span> uint8_t *
<span class="enscript-function-name">nfs_gss_clnt_svcname</span>(<span class="enscript-type">struct</span> nfsmount *nmp, gssd_nametype *nt, uint32_t *len)
{
	<span class="enscript-type">char</span> *svcname, *d, *server;
	<span class="enscript-type">int</span> lindx, sindx;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_sprinc) {
		*len = strlen(nmp-&gt;nm_sprinc) + 1;
		MALLOC(svcname, <span class="enscript-type">char</span> *, *len, M_TEMP, M_WAITOK);
		*nt = GSSD_HOSTBASED;
		<span class="enscript-keyword">if</span> (svcname == NULL)
			<span class="enscript-keyword">return</span> (NULL);
		strlcpy(svcname, nmp-&gt;nm_sprinc, *len);

		<span class="enscript-keyword">return</span> ((uint8_t *)svcname);
	}

	*nt = GSSD_HOSTBASED;
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_locations.nl_numlocs &amp;&amp; !(NFS_GSS_ISDBG &amp;&amp; (NFS_DEBUG_FLAGS &amp; 0x1))) {
		lindx = nmp-&gt;nm_locations.nl_current.nli_loc;
		sindx = nmp-&gt;nm_locations.nl_current.nli_serv;
		server = nmp-&gt;nm_locations.nl_locations[lindx]-&gt;nl_servers[sindx]-&gt;ns_name;
		*len = (uint32_t)strlen(server);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Older binaries using older mount args end up here */</span>
		server = vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname;
		NFS_GSS_DBG(<span class="enscript-string">&quot;nfs getting gss svcname from %s\n&quot;</span>, server);
		d = strchr(server, <span class="enscript-string">':'</span>);
		*len = (uint32_t)(d ? (d - server) : strlen(server));
	}
	
	*len +=  5; <span class="enscript-comment">/* &quot;nfs@&quot; plus null */</span>
	MALLOC(svcname, <span class="enscript-type">char</span> *, *len, M_TEMP, M_WAITOK);
	strlcpy(svcname, <span class="enscript-string">&quot;nfs&quot;</span>, *len);
	strlcat(svcname, <span class="enscript-string">&quot;@&quot;</span>, *len);
	strlcat(svcname, server, *len);
	NFS_GSS_DBG(<span class="enscript-string">&quot;nfs svcname = %s\n&quot;</span>, svcname);

	<span class="enscript-keyword">return</span> ((uint8_t *)svcname);
}

<span class="enscript-comment">/*
 * Get a mach port to talk to gssd.
 * gssd lives in the root bootstrap, so we call gssd's lookup routine
 * to get a send right to talk to a new gssd instance that launchd has launched
 * based on the cred's uid and audit session id.
 */</span>

<span class="enscript-type">static</span> mach_port_t
<span class="enscript-function-name">nfs_gss_clnt_get_upcall_port</span>(kauth_cred_t credp)
{
	mach_port_t gssd_host_port, uc_port = IPC_PORT_NULL;
	kern_return_t kr;
	au_asid_t asid;
	uid_t uid;

	kr = host_get_gssd_port(host_priv_self(), &amp;gssd_host_port);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		printf(<span class="enscript-string">&quot;nfs_gss_get_upcall_port: can't get gssd port, status %x (%d)\n&quot;</span>, kr, kr);
		<span class="enscript-keyword">return</span> (IPC_PORT_NULL);
	}
	<span class="enscript-keyword">if</span> (!IPC_PORT_VALID(gssd_host_port)) {
		printf(<span class="enscript-string">&quot;nfs_gss_get_upcall_port: gssd port not valid\n&quot;</span>);
		<span class="enscript-keyword">return</span> (IPC_PORT_NULL);
	}

	asid = kauth_cred_getasid(credp);
	uid = kauth_cred_getauid(credp);
	<span class="enscript-keyword">if</span> (uid == AU_DEFAUDITID)
		uid = kauth_cred_getuid(credp);
	kr = mach_gss_lookup(gssd_host_port, uid, asid, &amp;uc_port);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
		printf(<span class="enscript-string">&quot;nfs_gss_clnt_get_upcall_port: mach_gssd_lookup failed: status %x (%d)\n&quot;</span>, kr, kr);
	host_release_special_port(gssd_host_port);

	<span class="enscript-keyword">return</span> (uc_port);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_clnt_log_error</span>(<span class="enscript-type">struct</span> nfsreq *req, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp, uint32_t major, uint32_t minor)
{
#<span class="enscript-reference">define</span> <span class="enscript-function-name">GETMAJERROR</span>(x) (((x) &gt;&gt; GSS_C_ROUTINE_ERROR_OFFSET) &amp; GSS_C_ROUTINE_ERROR_MASK)	
	<span class="enscript-type">struct</span> nfsmount *nmp = req-&gt;r_nmp;
	<span class="enscript-type">char</span> who[] = <span class="enscript-string">&quot;client&quot;</span>;
	uint32_t gss_error = GETMAJERROR(cp-&gt;gss_clnt_major);
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *procn = <span class="enscript-string">&quot;unkown&quot;</span>;
	proc_t proc;
	pid_t pid = -1;
	<span class="enscript-type">struct</span> timeval now;

	<span class="enscript-keyword">if</span> (req-&gt;r_thread) {
		proc = (proc_t)get_bsdthreadtask_info(req-&gt;r_thread);
		<span class="enscript-keyword">if</span> (proc != NULL &amp;&amp; (proc-&gt;p_fd == NULL || (proc-&gt;p_lflag &amp; P_LVFORK)))
			proc = NULL;
		<span class="enscript-keyword">if</span> (proc) {
			<span class="enscript-keyword">if</span> (*proc-&gt;p_comm)
				procn = proc-&gt;p_comm;
			pid = proc-&gt;p_pid;
		}
	} <span class="enscript-keyword">else</span> {
		procn = <span class="enscript-string">&quot;kernproc&quot;</span>;
		pid = 0;
	}
		
	microuptime(&amp;now);
	<span class="enscript-keyword">if</span> ((cp-&gt;gss_clnt_major != major || cp-&gt;gss_clnt_minor != minor ||
	     cp-&gt;gss_clnt_ptime + GSS_PRINT_DELAY &lt; now.tv_sec) &amp;&amp;
	    (nmp-&gt;nm_state &amp; NFSSTA_MOUNTED)) {
		<span class="enscript-comment">/* 
		 * Will let gssd do some logging in hopes that it can translate
		 * the minor code.
		 */</span>
		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_minor &amp;&amp; cp-&gt;gss_clnt_minor != minor) {
			(<span class="enscript-type">void</span>) mach_gss_log_error(
				cp-&gt;gss_clnt_mport,
				vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname,
				kauth_cred_getuid(cp-&gt;gss_clnt_cred),
				who,
				cp-&gt;gss_clnt_major,
				cp-&gt;gss_clnt_minor);
		}
		gss_error = gss_error ? gss_error : cp-&gt;gss_clnt_major;

		<span class="enscript-comment">/*
		 *%%% It would be really nice to get the terminal from the proc or auditinfo_addr struct and print that here.
		 */</span>
		printf(<span class="enscript-string">&quot;NFS: gssd auth failure by %s on audit session %d uid %d proc %s/%d for mount %s. Error: major = %d minor = %d\n&quot;</span>,
		       cp-&gt;gss_clnt_display ? cp-&gt;gss_clnt_display : who, kauth_cred_getasid(req-&gt;r_cred), kauth_cred_getuid(req-&gt;r_cred),
		       procn, pid, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, gss_error, (int32_t)cp-&gt;gss_clnt_minor);
		cp-&gt;gss_clnt_ptime = now.tv_sec;
		<span class="enscript-keyword">switch</span> (gss_error) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">7</span>: printf(<span class="enscript-string">&quot;NFS: gssd does not have credentials for session %d/%d, (kinit)?\n&quot;</span>,
			       kauth_cred_getasid(req-&gt;r_cred), kauth_cred_getauid(req-&gt;r_cred));
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">11</span>: printf(<span class="enscript-string">&quot;NFS: gssd has expired credentals for session %d/%d, (kinit)?\n&quot;</span>,
			       kauth_cred_getasid(req-&gt;r_cred), kauth_cred_getauid(req-&gt;r_cred));
			<span class="enscript-keyword">break</span>;
		}
	} <span class="enscript-keyword">else</span> {
		NFS_GSS_DBG(<span class="enscript-string">&quot;NFS: gssd auth failure by %s on audit session %d uid %d proc %s/%d for mount %s. Error: major = %d minor = %d\n&quot;</span>,
			    cp-&gt;gss_clnt_display ? cp-&gt;gss_clnt_display : who, kauth_cred_getasid(req-&gt;r_cred), kauth_cred_getuid(req-&gt;r_cred),
			    procn, pid, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, gss_error, (int32_t)cp-&gt;gss_clnt_minor);
	}
}

<span class="enscript-comment">/*
 * Make an upcall to the gssd using Mach RPC
 * The upcall is made using a host special port.
 * This allows launchd to fire up the gssd in the
 * user's session.  This is important, since gssd
 * must have access to the user's credential cache.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_clnt_gssd_upcall</span>(<span class="enscript-type">struct</span> nfsreq *req, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp)
{
	kern_return_t kr;
	gssd_byte_buffer okey = NULL;
	uint32_t skeylen = 0;
	<span class="enscript-type">int</span> retry_cnt = 0;
	vm_map_copy_t itoken = NULL;
	gssd_byte_buffer otoken = NULL;
	mach_msg_type_number_t otokenlen;
	<span class="enscript-type">int</span> error = 0;
	uint8_t *principal = NULL;
	uint32_t plen = 0;
	int32_t nt = GSSD_STRING_NAME;
	vm_map_copy_t pname = NULL;
	vm_map_copy_t svcname = NULL;
	<span class="enscript-type">char</span> display_name[MAX_DISPLAY_STR] = <span class="enscript-string">&quot;&quot;</span>;
	uint32_t ret_flags;
	uint32_t nfs_1des = (cp-&gt;gss_clnt_gssd_flags &amp; GSSD_NFS_1DES);
	<span class="enscript-type">struct</span> nfsmount *nmp;
	uint32_t major = cp-&gt;gss_clnt_major, minor = cp-&gt;gss_clnt_minor;
	
	<span class="enscript-comment">/*
	 * NFS currently only supports default principals or
	 * principals based on the uid of the caller, unless
	 * the principal to use for the mounting cred was specified
	 * in the mount argmuments. If the realm to use was specified
	 * then will send that up as the principal since the realm is
	 * preceed by an &quot;@&quot; gssd that will try and select the default
	 * principal for that realm.
	 */</span>

	nmp = req-&gt;r_nmp;
	<span class="enscript-keyword">if</span> (nmp == NULL || vfs_isforce(nmp-&gt;nm_mountp) || (nmp-&gt;nm_state &amp; (NFSSTA_FORCE | NFSSTA_DEAD)))
		<span class="enscript-keyword">return</span> (ENXIO);
	
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_principal &amp;&amp; cp-&gt;gss_clnt_prinlen) {
		principal = cp-&gt;gss_clnt_principal;
		plen = cp-&gt;gss_clnt_prinlen;
		nt = cp-&gt;gss_clnt_prinnt;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nmp-&gt;nm_principal &amp;&amp; IS_VALID_CRED(nmp-&gt;nm_mcred) &amp;&amp; req-&gt;r_cred == nmp-&gt;nm_mcred) {
		plen = (uint32_t)strlen(nmp-&gt;nm_principal);
		MALLOC(principal, uint8_t *, plen, M_TEMP, M_WAITOK | M_ZERO);
		<span class="enscript-keyword">if</span> (principal == NULL)
			<span class="enscript-keyword">return</span> (ENOMEM);
		bcopy(nmp-&gt;nm_principal, principal, plen);
		cp-&gt;gss_clnt_prinnt = nt = GSSD_USER;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nmp-&gt;nm_realm) {
		plen = (uint32_t)strlen(nmp-&gt;nm_realm);
		principal = (uint8_t *)nmp-&gt;nm_realm;
		nt = GSSD_USER;
	}

	<span class="enscript-keyword">if</span> (!IPC_PORT_VALID(cp-&gt;gss_clnt_mport)) {
		cp-&gt;gss_clnt_mport = nfs_gss_clnt_get_upcall_port(req-&gt;r_cred);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_mport == IPC_PORT_NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (plen)
		nfs_gss_mach_alloc_buffer(principal, plen, &amp;pname);
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_svcnamlen)
		nfs_gss_mach_alloc_buffer(cp-&gt;gss_clnt_svcname, cp-&gt;gss_clnt_svcnamlen, &amp;svcname);
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_tokenlen)
		nfs_gss_mach_alloc_buffer(cp-&gt;gss_clnt_token, cp-&gt;gss_clnt_tokenlen, &amp;itoken);

<span class="enscript-reference">retry</span>:
	kr = mach_gss_init_sec_context_v2(
		cp-&gt;gss_clnt_mport,
		GSSD_KRB5_MECH,
		(gssd_byte_buffer) itoken, (mach_msg_type_number_t) cp-&gt;gss_clnt_tokenlen,
		kauth_cred_getuid(cp-&gt;gss_clnt_cred),
		nt,
		(gssd_byte_buffer)pname, (mach_msg_type_number_t) plen,
		cp-&gt;gss_clnt_svcnt,
		(gssd_byte_buffer)svcname, (mach_msg_type_number_t) cp-&gt;gss_clnt_svcnamlen,
		GSSD_MUTUAL_FLAG,
		&amp;cp-&gt;gss_clnt_gssd_flags,
		&amp;cp-&gt;gss_clnt_context,
		&amp;cp-&gt;gss_clnt_cred_handle,
		&amp;ret_flags,
		&amp;okey,  (mach_msg_type_number_t *) &amp;skeylen,
		&amp;otoken, &amp;otokenlen,
		cp-&gt;gss_clnt_display ? NULL : display_name,
		&amp;cp-&gt;gss_clnt_major,
		&amp;cp-&gt;gss_clnt_minor);

	<span class="enscript-comment">/* Should be cleared and set in gssd ? */</span>
	cp-&gt;gss_clnt_gssd_flags &amp;= ~GSSD_RESTART;
	cp-&gt;gss_clnt_gssd_flags |= nfs_1des;

	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		printf(<span class="enscript-string">&quot;nfs_gss_clnt_gssd_upcall: mach_gss_init_sec_context failed: %x (%d)\n&quot;</span>, kr, kr);
		<span class="enscript-keyword">if</span> (kr == MIG_SERVER_DIED &amp;&amp; cp-&gt;gss_clnt_cred_handle == 0 &amp;&amp;
			retry_cnt++ &lt; NFS_GSS_MACH_MAX_RETRIES &amp;&amp;
			!vfs_isforce(nmp-&gt;nm_mountp) &amp;&amp; (nmp-&gt;nm_state &amp; (NFSSTA_FORCE | NFSSTA_DEAD)) == 0) {
			<span class="enscript-keyword">if</span> (plen)
				nfs_gss_mach_alloc_buffer(principal, plen, &amp;pname);
			<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_svcnamlen)
				nfs_gss_mach_alloc_buffer(cp-&gt;gss_clnt_svcname, cp-&gt;gss_clnt_svcnamlen, &amp;svcname);
			<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_tokenlen &gt; 0)
				nfs_gss_mach_alloc_buffer(cp-&gt;gss_clnt_token, cp-&gt;gss_clnt_tokenlen, &amp;itoken);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}

		host_release_special_port(cp-&gt;gss_clnt_mport);
		cp-&gt;gss_clnt_mport = IPC_PORT_NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_display == NULL &amp;&amp; *display_name != <span class="enscript-string">'\0'</span>) {
		<span class="enscript-type">int</span> dlen = strnlen(display_name, MAX_DISPLAY_STR) + 1;  <span class="enscript-comment">/* Add extra byte to include '\0' */</span>
		
		<span class="enscript-keyword">if</span> (dlen &lt; MAX_DISPLAY_STR) {
			MALLOC(cp-&gt;gss_clnt_display, <span class="enscript-type">char</span> *, dlen, M_TEMP, M_WAITOK);
			<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_display == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip</span>;
			bcopy(display_name, cp-&gt;gss_clnt_display, dlen); 
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">skip</span>;
		}
	}
<span class="enscript-reference">skip</span>:
	<span class="enscript-comment">/*
	 * Make sure any unusual errors are expanded and logged by gssd
	 *
	 * XXXX, we need to rethink this and just have gssd return a string for the major and minor codes.
	 */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_major != GSS_S_COMPLETE &amp;&amp;
	    cp-&gt;gss_clnt_major != GSS_S_CONTINUE_NEEDED) {
		nfs_gss_clnt_log_error(req, cp, major, minor);
	}

	<span class="enscript-keyword">if</span> (skeylen &gt; 0) {
		<span class="enscript-keyword">if</span> (skeylen != SKEYLEN &amp;&amp; skeylen != SKEYLEN3) {
			printf(<span class="enscript-string">&quot;nfs_gss_clnt_gssd_upcall: bad key length (%d)\n&quot;</span>, skeylen);
			vm_map_copy_discard((vm_map_copy_t) okey);
			vm_map_copy_discard((vm_map_copy_t) otoken);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		error = nfs_gss_mach_vmcopyout((vm_map_copy_t) okey, skeylen, 
				cp-&gt;gss_clnt_kinfo-&gt;skey);
		<span class="enscript-keyword">if</span> (error) {
			vm_map_copy_discard((vm_map_copy_t) otoken);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		
		error = gss_key_init(cp-&gt;gss_clnt_kinfo, skeylen);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Free context token used as input */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_token)
		FREE(cp-&gt;gss_clnt_token, M_TEMP);
	cp-&gt;gss_clnt_token = NULL;
	cp-&gt;gss_clnt_tokenlen = 0;

	<span class="enscript-keyword">if</span> (otokenlen &gt; 0) {
		<span class="enscript-comment">/* Set context token to gss output token */</span>
		MALLOC(cp-&gt;gss_clnt_token, u_char *, otokenlen, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_token == NULL) {
			printf(<span class="enscript-string">&quot;nfs_gss_clnt_gssd_upcall: could not allocate %d bytes\n&quot;</span>, otokenlen);
			vm_map_copy_discard((vm_map_copy_t) otoken);
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
		error = nfs_gss_mach_vmcopyout((vm_map_copy_t) otoken, otokenlen, cp-&gt;gss_clnt_token);
		<span class="enscript-keyword">if</span> (error) {
			FREE(cp-&gt;gss_clnt_token, M_TEMP);
			cp-&gt;gss_clnt_token = NULL;
			<span class="enscript-keyword">return</span> (NFSERR_EAUTH);
		}
		cp-&gt;gss_clnt_tokenlen = otokenlen;
	}

	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_token)
		FREE(cp-&gt;gss_clnt_token, M_TEMP);
	cp-&gt;gss_clnt_token = NULL;
	cp-&gt;gss_clnt_tokenlen = 0;
	
	<span class="enscript-keyword">return</span> (NFSERR_EAUTH);
}

<span class="enscript-comment">/*
 * Invoked at the completion of an RPC call that uses an RPCSEC_GSS
 * credential. The sequence number window that the server returns
 * at context setup indicates the maximum number of client calls that
 * can be outstanding on a context. The client maintains a bitmap that
 * represents the server's window.  Each pending request has a bit set
 * in the window bitmap.  When a reply comes in or times out, we reset
 * the bit in the bitmap and if there are any other threads waiting for
 * a context slot we notify the waiting thread(s).
 *
 * Note that if a request is retransmitted, it will have a single XID
 * but it may be associated with multiple sequence numbers.  So we
 * may have to reset multiple sequence number bits in the window bitmap.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_clnt_rpcdone</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp = req-&gt;r_gss_ctx;
	<span class="enscript-type">struct</span> gss_seq *gsp, *ngsp;
	<span class="enscript-type">int</span> i = 0;

	<span class="enscript-keyword">if</span> (cp == NULL || !(cp-&gt;gss_clnt_flags &amp; GSS_CTX_COMPLETE))
		<span class="enscript-keyword">return</span>;	<span class="enscript-comment">// no context - don't bother
</span>	<span class="enscript-comment">/*
	 * Reset the bit for this request in the
	 * sequence number window to indicate it's done.
	 * We do this even if the request timed out.
	 */</span>
	lck_mtx_lock(cp-&gt;gss_clnt_mtx);
	gsp = SLIST_FIRST(&amp;req-&gt;r_gss_seqlist);
	<span class="enscript-keyword">if</span> (gsp &amp;&amp; gsp-&gt;gss_seqnum &gt; (cp-&gt;gss_clnt_seqnum - cp-&gt;gss_clnt_seqwin))
		win_resetbit(cp-&gt;gss_clnt_seqbits,
			gsp-&gt;gss_seqnum % cp-&gt;gss_clnt_seqwin);

	<span class="enscript-comment">/*
	 * Limit the seqnum list to GSS_CLNT_SEQLISTMAX entries
	 */</span>
	SLIST_FOREACH_SAFE(gsp, &amp;req-&gt;r_gss_seqlist, gss_seqnext, ngsp) {
		<span class="enscript-keyword">if</span> (++i &gt; GSS_CLNT_SEQLISTMAX) {
			SLIST_REMOVE(&amp;req-&gt;r_gss_seqlist, gsp, gss_seq, gss_seqnext);
			FREE(gsp, M_TEMP);
		}
	}

	<span class="enscript-comment">/*
	 * If there's a thread waiting for
	 * the window to advance, wake it up.
	 */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_flags &amp; GSS_NEEDSEQ) {
		cp-&gt;gss_clnt_flags &amp;= ~GSS_NEEDSEQ;
		wakeup(cp);
	}
	lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
}

<span class="enscript-comment">/*
 * Create a reference to a context from a request
 * and bump the reference count
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_ref</span>(<span class="enscript-type">struct</span> nfsreq *req, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp)
{
	req-&gt;r_gss_ctx = cp;

	lck_mtx_lock(cp-&gt;gss_clnt_mtx);
	cp-&gt;gss_clnt_refcnt++;
	lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
}

<span class="enscript-comment">/*
 * Remove a context reference from a request
 * If the reference count drops to zero, and the
 * context is invalid, destroy the context
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_unref</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = req-&gt;r_nmp;
	<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp = req-&gt;r_gss_ctx;
	<span class="enscript-type">int</span> on_neg_cache = 0;
	<span class="enscript-type">int</span> neg_cache = 0;
	<span class="enscript-type">int</span> destroy = 0;
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">char</span> CTXBUF[NFS_CTXBUFSZ];

	<span class="enscript-keyword">if</span> (cp == NULL)
		<span class="enscript-keyword">return</span>;

	req-&gt;r_gss_ctx = NULL;

	lck_mtx_lock(cp-&gt;gss_clnt_mtx);
	<span class="enscript-keyword">if</span> (--cp-&gt;gss_clnt_refcnt &lt; 0)
		panic(<span class="enscript-string">&quot;Over release of gss context!\n&quot;</span>);

	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_refcnt == 0) {
		<span class="enscript-keyword">if</span> ((cp-&gt;gss_clnt_flags &amp; GSS_CTX_INVAL) &amp;&amp;
		    cp-&gt;gss_clnt_kinfo) {
			FREE(cp-&gt;gss_clnt_kinfo, M_TEMP);
			cp-&gt;gss_clnt_kinfo = NULL;
		}
		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_flags &amp; GSS_CTX_DESTROY) {
			destroy = 1;
			<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_flags &amp; GSS_CTX_STICKY)
				nfs_gss_clnt_mnt_rele(nmp);
			<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_nctime)
				on_neg_cache = 1;
		}
	}
	<span class="enscript-keyword">if</span> (!destroy &amp;&amp; cp-&gt;gss_clnt_nctime == 0 &amp;&amp;
	    (cp-&gt;gss_clnt_flags &amp; GSS_CTX_INVAL)) {
		microuptime(&amp;now);
		cp-&gt;gss_clnt_nctime = now.tv_sec;
		neg_cache = 1;
	}
	lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
	<span class="enscript-keyword">if</span> (destroy) {
		NFS_GSS_DBG(<span class="enscript-string">&quot;Destroying context %s\n&quot;</span>, NFS_GSS_CTX(req, cp));
		<span class="enscript-keyword">if</span> (nmp) {
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_entries.tqe_next != NFSNOLIST) {
				TAILQ_REMOVE(&amp;nmp-&gt;nm_gsscl, cp, gss_clnt_entries);
			}
			<span class="enscript-keyword">if</span> (on_neg_cache) {
				nmp-&gt;nm_ncentries--;
			}
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		}
		nfs_gss_clnt_ctx_destroy(cp);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (neg_cache) {
		NFS_GSS_DBG(<span class="enscript-string">&quot;Entering context %s into negative cache\n&quot;</span>, NFS_GSS_CTX(req, cp));
		<span class="enscript-keyword">if</span> (nmp) {
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			nmp-&gt;nm_ncentries++;
			nfs_gss_clnt_ctx_neg_cache_reap(nmp);
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		}
	}
	NFS_GSS_CLNT_CTX_DUMP(nmp);
}

<span class="enscript-comment">/*
 * Try and reap any old negative cache entries.
 * cache queue.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_neg_cache_reap</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp, *tcp;
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">int</span> reaped = 0;

	NFS_GSS_DBG(<span class="enscript-string">&quot;Reaping contexts ncentries = %d\n&quot;</span>, nmp-&gt;nm_ncentries);
	<span class="enscript-comment">/* Try and reap old, unreferenced, expired contexts */</span>

	TAILQ_FOREACH_SAFE(cp, &amp;nmp-&gt;nm_gsscl, gss_clnt_entries, tcp) {
		<span class="enscript-type">int</span> destroy = 0;

		<span class="enscript-comment">/* Don't reap STICKY contexts */</span>
		<span class="enscript-keyword">if</span> ((cp-&gt;gss_clnt_flags &amp; GSS_CTX_STICKY) ||
		    !(cp-&gt;gss_clnt_flags &amp; GSS_CTX_INVAL))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-comment">/* Keep up to GSS_MAX_NEG_CACHE_ENTRIES */</span>
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_ncentries &lt;= GSS_MAX_NEG_CACHE_ENTRIES)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* Contexts too young */</span>
		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_nctime + GSS_NEG_CACHE_TO &gt;= now.tv_sec)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-comment">/* Not referenced, remove it. */</span>
		lck_mtx_lock(cp-&gt;gss_clnt_mtx);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_refcnt == 0) {
			cp-&gt;gss_clnt_flags |= GSS_CTX_DESTROY;
			destroy = 1;
		}
		lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
		<span class="enscript-keyword">if</span> (destroy) {
			TAILQ_REMOVE(&amp;nmp-&gt;nm_gsscl, cp, gss_clnt_entries);
			nmp-&gt;nm_ncentries++;
			reaped++;
			nfs_gss_clnt_ctx_destroy(cp);
		}
	}
	NFS_GSS_DBG(<span class="enscript-string">&quot;Reaped %d contexts ncentries = %d\n&quot;</span>, reaped, nmp-&gt;nm_ncentries);
}

<span class="enscript-comment">/*
 * Clean a context to be cached
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_clean</span>(<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp)
{
	<span class="enscript-comment">/* Preserve gss_clnt_mtx */</span>
	assert(cp-&gt;gss_clnt_thread == NULL);  <span class="enscript-comment">/* Will be set to this thread */</span>
	<span class="enscript-comment">/* gss_clnt_entries  we should not be on any list at this point */</span>
	cp-&gt;gss_clnt_flags = 0;
	<span class="enscript-comment">/* gss_clnt_refcnt should be zero */</span>
	assert(cp-&gt;gss_clnt_refcnt == 0);
	<span class="enscript-comment">/*
	 * We are who we are preserve:
	 * gss_clnt_cred
	 * gss_clnt_principal
	 * gss_clnt_prinlen
	 * gss_clnt_prinnt
	 * gss_clnt_desplay
	 */</span>
	<span class="enscript-comment">/* gss_clnt_proc will be set in nfs_gss_clnt_ctx_init */</span>
	cp-&gt;gss_clnt_seqnum = 0;
	<span class="enscript-comment">/* Preserve gss_clnt_service, we're not changing flavors */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_handle) {
		FREE(cp-&gt;gss_clnt_handle, M_TEMP);
		cp-&gt;gss_clnt_handle = NULL;
	}
	cp-&gt;gss_clnt_handle_len = 0;
	cp-&gt;gss_clnt_nctime = 0;
	cp-&gt;gss_clnt_seqwin = 0;
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_seqbits) {
		FREE(cp-&gt;gss_clnt_seqbits, M_TEMP);
		cp-&gt;gss_clnt_seqbits = NULL;
	}
	<span class="enscript-comment">/* Preserve gss_clnt_mport. Still talking to the same gssd */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_verf) {
		FREE(cp-&gt;gss_clnt_verf, M_TEMP);
		cp-&gt;gss_clnt_verf = NULL;
	}
	<span class="enscript-comment">/* Service name might change on failover, so reset it */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_svcname) {
		FREE(cp-&gt;gss_clnt_svcname, M_TEMP);
		cp-&gt;gss_clnt_svcname = NULL;
		cp-&gt;gss_clnt_svcnt = 0;
	}
	cp-&gt;gss_clnt_svcnamlen = 0;
	cp-&gt;gss_clnt_cred_handle = 0;
	cp-&gt;gss_clnt_context = 0;
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_token) {
		FREE(cp-&gt;gss_clnt_token, M_TEMP);
		cp-&gt;gss_clnt_token = NULL;
	}
	cp-&gt;gss_clnt_tokenlen = 0;
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_kinfo)
		bzero(cp-&gt;gss_clnt_kinfo, <span class="enscript-keyword">sizeof</span>(gss_key_info));
	<span class="enscript-comment">/*
	 * Preserve:
	 * gss_clnt_gssd_flags
	 * gss_clnt_major
	 * gss_clnt_minor
	 * gss_clnt_ptime
	 */</span>
}

<span class="enscript-comment">/*
 * Copy a source context to a new context. This is used to create a new context
 * with the identity of the old context for renewal. The old context is invalid
 * at this point but may have reference still to it, so it is not safe to use that
 * context.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_copy</span>(<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *scp, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx **dcpp, gss_key_info *ki)
{
	<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *dcp;

	*dcpp = (<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *)NULL;
	MALLOC(dcp, <span class="enscript-type">struct</span> nfs_gss_clnt_ctx *, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nfs_gss_clnt_ctx), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (dcp == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);
	bzero(dcp, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nfs_gss_clnt_ctx));
	<span class="enscript-keyword">if</span> (ki == NULL) {
		MALLOC(dcp-&gt;gss_clnt_kinfo, gss_key_info *, <span class="enscript-keyword">sizeof</span> (gss_key_info), M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (dcp-&gt;gss_clnt_kinfo == NULL) {
			FREE(dcp, M_TEMP);
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
	} <span class="enscript-keyword">else</span> {
		dcp-&gt;gss_clnt_kinfo = ki;
	}
	bzero(dcp-&gt;gss_clnt_kinfo, <span class="enscript-keyword">sizeof</span> (gss_key_info));
	dcp-&gt;gss_clnt_mtx = lck_mtx_alloc_init(nfs_gss_clnt_grp, LCK_ATTR_NULL);
	dcp-&gt;gss_clnt_cred = scp-&gt;gss_clnt_cred;
	kauth_cred_ref(dcp-&gt;gss_clnt_cred);
	dcp-&gt;gss_clnt_prinlen = scp-&gt;gss_clnt_prinlen;
	dcp-&gt;gss_clnt_prinnt = scp-&gt;gss_clnt_prinnt;
	<span class="enscript-keyword">if</span> (scp-&gt;gss_clnt_principal) {
		MALLOC(dcp-&gt;gss_clnt_principal, uint8_t *, dcp-&gt;gss_clnt_prinlen, M_TEMP, M_WAITOK | M_ZERO);
		<span class="enscript-keyword">if</span> (dcp-&gt;gss_clnt_principal == NULL) {
			FREE(dcp-&gt;gss_clnt_kinfo, M_TEMP);
			FREE(dcp, M_TEMP);
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
		bcopy(scp-&gt;gss_clnt_principal, dcp-&gt;gss_clnt_principal, dcp-&gt;gss_clnt_prinlen);
	}
	<span class="enscript-comment">/* Note we don't preserve the display name, that will be set by a successful up call */</span>
	dcp-&gt;gss_clnt_service = scp-&gt;gss_clnt_service;
	dcp-&gt;gss_clnt_mport = host_copy_special_port(scp-&gt;gss_clnt_mport);
	<span class="enscript-comment">/*  gss_clnt_kinfo allocated above */</span>
	dcp-&gt;gss_clnt_gssd_flags = scp-&gt;gss_clnt_gssd_flags;
	dcp-&gt;gss_clnt_major = scp-&gt;gss_clnt_major;
	dcp-&gt;gss_clnt_minor = scp-&gt;gss_clnt_minor;
	dcp-&gt;gss_clnt_ptime = scp-&gt;gss_clnt_ptime;

	*dcpp = dcp;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Remove a context
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_destroy</span>(<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp)
{
	NFS_GSS_DBG(<span class="enscript-string">&quot;Destroying context %d/%d\n&quot;</span>,
		    kauth_cred_getasid(cp-&gt;gss_clnt_cred),
		    kauth_cred_getauid(cp-&gt;gss_clnt_cred));

	host_release_special_port(cp-&gt;gss_clnt_mport);
	cp-&gt;gss_clnt_mport = IPC_PORT_NULL;

	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_mtx) {
		lck_mtx_destroy(cp-&gt;gss_clnt_mtx, nfs_gss_clnt_grp);
		cp-&gt;gss_clnt_mtx = (lck_mtx_t *)NULL;
	}
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(cp-&gt;gss_clnt_cred))
		kauth_cred_unref(&amp;cp-&gt;gss_clnt_cred);
	cp-&gt;gss_clnt_entries.tqe_next = NFSNOLIST;
	cp-&gt;gss_clnt_entries.tqe_prev = NFSNOLIST;
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_principal) {
		FREE(cp-&gt;gss_clnt_principal, M_TEMP);
		cp-&gt;gss_clnt_principal = NULL;
	}
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_display) {
		FREE(cp-&gt;gss_clnt_display, M_TEMP);
		cp-&gt;gss_clnt_display = NULL;
	}
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_kinfo) {
		FREE(cp-&gt;gss_clnt_kinfo, M_TEMP);
		cp-&gt;gss_clnt_kinfo = NULL;
	}

	nfs_gss_clnt_ctx_clean(cp);

	FREE(cp, M_TEMP);
}

<span class="enscript-comment">/*
 * The context for a user is invalid.
 * Mark the context as invalid, then
 * create a new context.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_renew</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp = req-&gt;r_gss_ctx;
	<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *ncp;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">char</span> CTXBUF[NFS_CTXBUFSZ];

	<span class="enscript-keyword">if</span> (cp == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> (req-&gt;r_nmp == NULL)
		<span class="enscript-keyword">return</span> (ENXIO);
	nmp = req-&gt;r_nmp;

	lck_mtx_lock(cp-&gt;gss_clnt_mtx);
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_flags &amp; GSS_CTX_INVAL) {
		lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
		nfs_gss_clnt_ctx_unref(req);
		<span class="enscript-keyword">return</span> (0);	<span class="enscript-comment">// already being renewed
</span>	}

	cp-&gt;gss_clnt_flags |= (GSS_CTX_INVAL | GSS_CTX_DESTROY);

	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_flags &amp; (GSS_NEEDCTX | GSS_NEEDSEQ)) {
		cp-&gt;gss_clnt_flags &amp;= ~GSS_NEEDSEQ;
		wakeup(cp);
	}
	lck_mtx_unlock(cp-&gt;gss_clnt_mtx);

	error =  nfs_gss_clnt_ctx_copy(cp, &amp;ncp, NULL);
	NFS_GSS_DBG(<span class="enscript-string">&quot;Renewing context %s\n&quot;</span>, NFS_GSS_CTX(req, ncp));
	nfs_gss_clnt_ctx_unref(req);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-comment">/*
	 * Note we don't bother taking the new context mutex as we're
	 * not findable at the moment.
	 */</span>
	ncp-&gt;gss_clnt_thread = current_thread();
	nfs_gss_clnt_ctx_ref(req, ncp);
	TAILQ_INSERT_HEAD(&amp;nmp-&gt;nm_gsscl, ncp, gss_clnt_entries);
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	error = nfs_gss_clnt_ctx_init_retry(req, ncp); <span class="enscript-comment">// Initialize new context
</span>	<span class="enscript-keyword">if</span> (error)
		nfs_gss_clnt_ctx_unref(req);

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Destroy all the contexts associated with a mount.
 * The contexts are also destroyed by the server.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_unmount</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	<span class="enscript-type">int</span> error, status;
	<span class="enscript-type">struct</span> nfsreq req;
	req.r_nmp = nmp;

	<span class="enscript-keyword">if</span> (!nmp)
		<span class="enscript-keyword">return</span>;


	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">while</span>((cp = TAILQ_FIRST(&amp;nmp-&gt;nm_gsscl))) {
		TAILQ_REMOVE(&amp;nmp-&gt;nm_gsscl, cp, gss_clnt_entries);
		cp-&gt;gss_clnt_entries.tqe_next = NFSNOLIST;
		lck_mtx_lock(cp-&gt;gss_clnt_mtx);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_flags &amp; GSS_CTX_DESTROY) {
			lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
			<span class="enscript-keyword">continue</span>;
		}
		cp-&gt;gss_clnt_refcnt++;
		lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
		req.r_gss_ctx = cp;

		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-comment">/*
		 * Tell the server to destroy its context.
		 * But don't bother if it's a forced unmount.
		 */</span>
		<span class="enscript-keyword">if</span> (!nfs_mount_gone(nmp) &amp;&amp;
		    (cp-&gt;gss_clnt_flags &amp; (GSS_CTX_INVAL | GSS_CTX_DESTROY | GSS_CTX_COMPLETE)) == GSS_CTX_COMPLETE) {
			cp-&gt;gss_clnt_proc = RPCSEC_GSS_DESTROY;

			error = 0;
			nfsm_chain_null(&amp;nmreq);
			nfsm_chain_null(&amp;nmrep);
			nfsm_chain_build_alloc_init(error, &amp;nmreq, 0);
			nfsm_chain_build_done(error, &amp;nmreq);
			<span class="enscript-keyword">if</span> (!error)
				nfs_request_gss(nmp-&gt;nm_mountp, &amp;nmreq,
					current_thread(), cp-&gt;gss_clnt_cred, 0, cp, &amp;nmrep, &amp;status);
			nfsm_chain_cleanup(&amp;nmreq);
			nfsm_chain_cleanup(&amp;nmrep);
		}

		<span class="enscript-comment">/*
		 * Mark the context invalid then drop
		 * the reference to remove it if its
		 * refcount is zero.
		 */</span>
		lck_mtx_lock(cp-&gt;gss_clnt_mtx);
		cp-&gt;gss_clnt_flags |= (GSS_CTX_INVAL | GSS_CTX_DESTROY);
		lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
		nfs_gss_clnt_ctx_unref(&amp;req);
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	assert(TAILQ_EMPTY(&amp;nmp-&gt;nm_gsscl));
}


<span class="enscript-comment">/*
 * Removes a mounts context for a credential
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_remove</span>(<span class="enscript-type">struct</span> nfsmount *nmp, kauth_cred_t cred)
{
	<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp;
	<span class="enscript-type">struct</span> nfsreq req;

	req.r_nmp = nmp;

	NFS_GSS_DBG(<span class="enscript-string">&quot;Enter\n&quot;</span>);
	NFS_GSS_CLNT_CTX_DUMP(nmp);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	TAILQ_FOREACH(cp, &amp;nmp-&gt;nm_gsscl, gss_clnt_entries) {
		lck_mtx_lock(cp-&gt;gss_clnt_mtx);
		<span class="enscript-keyword">if</span> (nfs_gss_clnt_ctx_cred_match(cp-&gt;gss_clnt_cred, cred)) {
			<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_flags &amp; GSS_CTX_DESTROY) {
				NFS_GSS_DBG(<span class="enscript-string">&quot;Found destroyed context %d/%d. refcnt = %d continuing\n&quot;</span>,
					    kauth_cred_getasid(cp-&gt;gss_clnt_cred),
					    kauth_cred_getauid(cp-&gt;gss_clnt_cred),
					    cp-&gt;gss_clnt_refcnt);
				lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
				<span class="enscript-keyword">continue</span>;
			}
			cp-&gt;gss_clnt_refcnt++;
			cp-&gt;gss_clnt_flags |= (GSS_CTX_INVAL | GSS_CTX_DESTROY);
			lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
			req.r_gss_ctx = cp;
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-comment">/*
			 * Drop the reference to remove it if its
			 * refcount is zero.
			 */</span>
			NFS_GSS_DBG(<span class="enscript-string">&quot;Removed context %d/%d refcnt = %d\n&quot;</span>,
				    kauth_cred_getasid(cp-&gt;gss_clnt_cred),
				    kauth_cred_getuid(cp-&gt;gss_clnt_cred),
				    cp-&gt;gss_clnt_refcnt);
			nfs_gss_clnt_ctx_unref(&amp;req);
			<span class="enscript-keyword">return</span> (0);
		}
		lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
	}

	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	
	NFS_GSS_DBG(<span class="enscript-string">&quot;Returning ENOENT\n&quot;</span>);
	<span class="enscript-keyword">return</span> (ENOENT);
}

<span class="enscript-comment">/*
 * Sets a mounts principal for a session associated with cred.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_set_principal</span>(<span class="enscript-type">struct</span> nfsmount *nmp, vfs_context_t ctx,
			       uint8_t *principal, uint32_t princlen, uint32_t nametype)

{
	<span class="enscript-type">struct</span> nfsreq req;
	<span class="enscript-type">int</span> error;

	NFS_GSS_DBG(<span class="enscript-string">&quot;Enter:\n&quot;</span>);

	bzero(&amp;req, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfsreq));
	req.r_nmp = nmp;
	req.r_gss_ctx = NULL;
	req.r_auth = nmp-&gt;nm_auth;
	req.r_thread = vfs_context_thread(ctx);
	req.r_cred = vfs_context_ucred(ctx);

	error = nfs_gss_clnt_ctx_find_principal(&amp;req, principal, princlen, nametype);
	NFS_GSS_DBG(<span class="enscript-string">&quot;nfs_gss_clnt_ctx_find_principal returned %d\n&quot;</span>, error);
	<span class="enscript-comment">/*
	 * We don't care about auth errors. Those would indicate that the context is in the
	 * neagative cache and if and when the user has credentials for the principal
	 * we should be good to go in that we will select those credentials for this principal.
	 */</span>
	<span class="enscript-keyword">if</span> (error == EACCES || error == EAUTH || error == ENEEDAUTH)
		error = 0;

	<span class="enscript-comment">/* We're done with this request */</span>
	nfs_gss_clnt_ctx_unref(&amp;req);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Gets a mounts principal from a session associated with cred
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_clnt_ctx_get_principal</span>(<span class="enscript-type">struct</span> nfsmount *nmp, vfs_context_t ctx,
			       <span class="enscript-type">struct</span> user_nfs_gss_principal *p)
{
	<span class="enscript-type">struct</span> nfsreq req;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp;
	kauth_cred_t cred = vfs_context_ucred(ctx);
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *princ;
	<span class="enscript-type">char</span> CTXBUF[NFS_CTXBUFSZ];

	req.r_nmp = nmp;
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	TAILQ_FOREACH(cp, &amp;nmp-&gt;nm_gsscl, gss_clnt_entries) {
		lck_mtx_lock(cp-&gt;gss_clnt_mtx);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_flags &amp; GSS_CTX_DESTROY) {
			NFS_GSS_DBG(<span class="enscript-string">&quot;Found destroyed context %s refcnt = %d continuing\n&quot;</span>,
				    NFS_GSS_CTX(&amp;req, cp),
				    cp-&gt;gss_clnt_refcnt);
			lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (nfs_gss_clnt_ctx_cred_match(cp-&gt;gss_clnt_cred, cred)) {
			cp-&gt;gss_clnt_refcnt++;
			lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		lck_mtx_unlock(cp-&gt;gss_clnt_mtx);
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (cp == NULL) {
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		p-&gt;princlen = 0;
		p-&gt;principal = USER_ADDR_NULL;
		p-&gt;nametype = GSSD_STRING_NAME;
		p-&gt;flags |= NFS_IOC_NO_CRED_FLAG;
		NFS_GSS_DBG(<span class="enscript-string">&quot;No context found for session %d by uid %d\n&quot;</span>,
			    kauth_cred_getasid(cred), kauth_cred_getuid(cred));
		<span class="enscript-keyword">return</span> (0);
	}

	princ = cp-&gt;gss_clnt_principal ? (<span class="enscript-type">char</span> *)cp-&gt;gss_clnt_principal : cp-&gt;gss_clnt_display;
	p-&gt;princlen = cp-&gt;gss_clnt_principal ? cp-&gt;gss_clnt_prinlen :
		(cp-&gt;gss_clnt_display ? strlen(cp-&gt;gss_clnt_display) : 0);
	p-&gt;nametype = cp-&gt;gss_clnt_prinnt;
	<span class="enscript-keyword">if</span> (princ) {
		<span class="enscript-type">char</span> *pp;

		MALLOC(pp, <span class="enscript-type">char</span> *, p-&gt;princlen, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (pp) {
			bcopy(princ, pp, p-&gt;princlen);
			p-&gt;principal = CAST_USER_ADDR_T(pp);
		}
		<span class="enscript-keyword">else</span>
			error = ENOMEM;
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	req.r_gss_ctx = cp;
	NFS_GSS_DBG(<span class="enscript-string">&quot;Found context %s\n&quot;</span>, NFS_GSS_CTX(&amp;req, NULL));
	nfs_gss_clnt_ctx_unref(&amp;req);
	<span class="enscript-keyword">return</span> (error);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSCLIENT */</span>

<span class="enscript-comment">/*************
 *
 * Server functions
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>

<span class="enscript-comment">/*
 * Find a server context based on a handle value received
 * in an RPCSEC_GSS credential.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> nfs_gss_svc_ctx *
<span class="enscript-function-name">nfs_gss_svc_ctx_find</span>(uint32_t handle)
{
	<span class="enscript-type">struct</span> nfs_gss_svc_ctx_hashhead *head;
	<span class="enscript-type">struct</span> nfs_gss_svc_ctx *cp;
	uint64_t timenow;

	<span class="enscript-keyword">if</span> (handle == 0)
		<span class="enscript-keyword">return</span> (NULL);
		
	head = &amp;nfs_gss_svc_ctx_hashtbl[SVC_CTX_HASH(handle)];
	<span class="enscript-comment">/*
	 * Don't return a context that is going to expire in GSS_CTX_PEND seconds
	 */</span>
	clock_interval_to_deadline(GSS_CTX_PEND, NSEC_PER_SEC, &amp;timenow);

	lck_mtx_lock(nfs_gss_svc_ctx_mutex);

	LIST_FOREACH(cp, head, gss_svc_entries) {
		<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_handle == handle) {
			<span class="enscript-keyword">if</span> (timenow &gt; cp-&gt;gss_svc_incarnation + GSS_SVC_CTX_TTL) {
				<span class="enscript-comment">/* 
				 * Context has or is about to expire. Don't use.
				 * We'll return null and the client will have to create
				 * a new context.
				 */</span>
				cp-&gt;gss_svc_handle = 0;
				<span class="enscript-comment">/*
				 * Make sure though that we stay around for GSS_CTX_PEND seconds 
				 * for other threads that might be using the context.
				 */</span>
				cp-&gt;gss_svc_incarnation = timenow;

				cp = NULL;
				<span class="enscript-keyword">break</span>;
			}
			lck_mtx_lock(cp-&gt;gss_svc_mtx);				
			cp-&gt;gss_svc_refcnt++;
			lck_mtx_unlock(cp-&gt;gss_svc_mtx);				
			<span class="enscript-keyword">break</span>;
		}
	}

	lck_mtx_unlock(nfs_gss_svc_ctx_mutex);

	<span class="enscript-keyword">return</span> (cp);
}

<span class="enscript-comment">/*
 * Insert a new server context into the hash table
 * and start the context reap thread if necessary.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_svc_ctx_insert</span>(<span class="enscript-type">struct</span> nfs_gss_svc_ctx *cp)
{
	<span class="enscript-type">struct</span> nfs_gss_svc_ctx_hashhead *head;
	<span class="enscript-type">struct</span> nfs_gss_svc_ctx *p;
	
	lck_mtx_lock(nfs_gss_svc_ctx_mutex);

	<span class="enscript-comment">/*
	 * Give the client a random handle so that if we reboot
	 * it's unlikely the client will get a bad context match.
	 * Make sure it's not zero or already assigned.
	 */</span>
<span class="enscript-reference">retry</span>:
	cp-&gt;gss_svc_handle = random();
	<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_handle == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
	head = &amp;nfs_gss_svc_ctx_hashtbl[SVC_CTX_HASH(cp-&gt;gss_svc_handle)];
	LIST_FOREACH(p, head, gss_svc_entries)
		<span class="enscript-keyword">if</span> (p-&gt;gss_svc_handle == cp-&gt;gss_svc_handle)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;

	clock_interval_to_deadline(GSS_CTX_PEND, NSEC_PER_SEC,
		&amp;cp-&gt;gss_svc_incarnation);
	LIST_INSERT_HEAD(head, cp, gss_svc_entries);
	nfs_gss_ctx_count++;

	<span class="enscript-keyword">if</span> (!nfs_gss_timer_on) {
		nfs_gss_timer_on = 1;

		nfs_interval_timer_start(nfs_gss_svc_ctx_timer_call,
			min(GSS_TIMER_PERIOD, max(GSS_CTX_TTL_MIN, nfsrv_gss_context_ttl)) * MSECS_PER_SEC);
	}

	lck_mtx_unlock(nfs_gss_svc_ctx_mutex);
}

<span class="enscript-comment">/*
 * This function is called via the kernel's callout
 * mechanism.  It runs only when there are
 * cached RPCSEC_GSS contexts.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_svc_ctx_timer</span>(__unused <span class="enscript-type">void</span> *param1, __unused <span class="enscript-type">void</span> *param2)
{
	<span class="enscript-type">struct</span> nfs_gss_svc_ctx *cp, *next;
	uint64_t timenow;
	<span class="enscript-type">int</span> contexts = 0;
	<span class="enscript-type">int</span> i;

	lck_mtx_lock(nfs_gss_svc_ctx_mutex);
	clock_get_uptime(&amp;timenow);

	NFS_GSS_DBG(<span class="enscript-string">&quot;is running\n&quot;</span>);

	<span class="enscript-comment">/*
	 * Scan all the hash chains
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; SVC_CTX_HASHSZ; i++) {
		<span class="enscript-comment">/*
		 * For each hash chain, look for entries
		 * that haven't been used in a while.
		 */</span>
		LIST_FOREACH_SAFE(cp, &amp;nfs_gss_svc_ctx_hashtbl[i], gss_svc_entries, next) {
			contexts++;
			<span class="enscript-keyword">if</span> (timenow &gt; cp-&gt;gss_svc_incarnation + 
				(cp-&gt;gss_svc_handle ? GSS_SVC_CTX_TTL : 0)
				&amp;&amp; cp-&gt;gss_svc_refcnt == 0) {
				<span class="enscript-comment">/*
				 * A stale context - remove it
				 */</span>
				LIST_REMOVE(cp, gss_svc_entries);
				NFS_GSS_DBG(<span class="enscript-string">&quot;Removing contex for %d\n&quot;</span>, cp-&gt;gss_svc_uid);
				<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_seqbits)
					FREE(cp-&gt;gss_svc_seqbits, M_TEMP);
				lck_mtx_destroy(cp-&gt;gss_svc_mtx, nfs_gss_svc_grp);
				FREE(cp, M_TEMP);
				contexts--;
			}
		}
	}

	nfs_gss_ctx_count = contexts;

	<span class="enscript-comment">/*
	 * If there are still some cached contexts left,
	 * set up another callout to check on them later.
	 */</span>
	nfs_gss_timer_on = nfs_gss_ctx_count &gt; 0;
	<span class="enscript-keyword">if</span> (nfs_gss_timer_on)
		nfs_interval_timer_start(nfs_gss_svc_ctx_timer_call,
			min(GSS_TIMER_PERIOD, max(GSS_CTX_TTL_MIN, nfsrv_gss_context_ttl)) * MSECS_PER_SEC);

	lck_mtx_unlock(nfs_gss_svc_ctx_mutex);
}

<span class="enscript-comment">/*
 * Here the server receives an RPCSEC_GSS credential in an
 * RPC call header.  First there's some checking to make sure
 * the credential is appropriate - whether the context is still
 * being set up, or is complete.  Then we use the handle to find
 * the server's context and validate the verifier, which contains
 * a signed checksum of the RPC header. If the verifier checks
 * out, we extract the user's UID and groups from the context
 * and use it to set up a UNIX credential for the user's request.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_svc_cred_get</span>(<span class="enscript-type">struct</span> nfsrv_descript *nd, <span class="enscript-type">struct</span> nfsm_chain *nmc)
{
	uint32_t vers, proc, seqnum, service;
	uint32_t handle, handle_len;
	<span class="enscript-type">struct</span> nfs_gss_svc_ctx *cp = NULL;
	uint32_t flavor = 0, verflen = 0;
	<span class="enscript-type">int</span> error = 0;
	uint32_t arglen, start, toklen, cksumlen;
	u_char tokbuf[KRB5_SZ_TOKMAX(MAX_DIGEST)];
	u_char cksum1[MAX_DIGEST], cksum2[MAX_DIGEST];
	<span class="enscript-type">struct</span> nfsm_chain nmc_tmp;
	gss_key_info *ki;
	
	vers = proc = seqnum = service = handle_len = 0;
	arglen = cksumlen = 0;

	nfsm_chain_get_32(error, nmc, vers);
	<span class="enscript-keyword">if</span> (vers != RPCSEC_GSS_VERS_1) {
		error = NFSERR_AUTHERR | AUTH_REJECTCRED;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}

	nfsm_chain_get_32(error, nmc, proc);
	nfsm_chain_get_32(error, nmc, seqnum);
	nfsm_chain_get_32(error, nmc, service);
	nfsm_chain_get_32(error, nmc, handle_len);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;

	<span class="enscript-comment">/*
	 * Make sure context setup/destroy is being done with a nullproc
	 */</span>
	<span class="enscript-keyword">if</span> (proc != RPCSEC_GSS_DATA &amp;&amp; nd-&gt;nd_procnum != NFSPROC_NULL) {
		error = NFSERR_AUTHERR | RPCSEC_GSS_CREDPROBLEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}

	<span class="enscript-comment">/*
	 * If the sequence number is greater than the max
	 * allowable, reject and have the client init a
	 * new context.
	 */</span>
	<span class="enscript-keyword">if</span> (seqnum &gt; GSS_MAXSEQ) {
		error = NFSERR_AUTHERR | RPCSEC_GSS_CTXPROBLEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}

	nd-&gt;nd_sec = 
		service == RPCSEC_GSS_SVC_NONE ?      RPCAUTH_KRB5 :
		service == RPCSEC_GSS_SVC_INTEGRITY ? RPCAUTH_KRB5I :
		service == RPCSEC_GSS_SVC_PRIVACY ?   RPCAUTH_KRB5P : 0;

	<span class="enscript-keyword">if</span> (proc == RPCSEC_GSS_INIT) {
		<span class="enscript-comment">/*
		 * Limit the total number of contexts
		 */</span>
		<span class="enscript-keyword">if</span> (nfs_gss_ctx_count &gt; nfs_gss_ctx_max) {
			error = NFSERR_AUTHERR | RPCSEC_GSS_CTXPROBLEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}

		<span class="enscript-comment">/*
		 * Set up a new context
		 */</span>
		MALLOC(cp, <span class="enscript-type">struct</span> nfs_gss_svc_ctx *, <span class="enscript-keyword">sizeof</span>(*cp), M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (cp == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
		cp-&gt;gss_svc_mtx = lck_mtx_alloc_init(nfs_gss_svc_grp, LCK_ATTR_NULL);
		cp-&gt;gss_svc_refcnt = 1;
	} <span class="enscript-keyword">else</span> {

		<span class="enscript-comment">/*
		 * Use the handle to find the context
		 */</span>
		<span class="enscript-keyword">if</span> (handle_len != <span class="enscript-keyword">sizeof</span>(handle)) {
			error = NFSERR_AUTHERR | RPCSEC_GSS_CREDPROBLEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
		nfsm_chain_get_32(error, nmc, handle);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		cp = nfs_gss_svc_ctx_find(handle);
		<span class="enscript-keyword">if</span> (cp == NULL) {
			error = NFSERR_AUTHERR | RPCSEC_GSS_CTXPROBLEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
	}

	cp-&gt;gss_svc_proc = proc;
	ki = &amp;cp-&gt;gss_svc_kinfo;

	<span class="enscript-keyword">if</span> (proc == RPCSEC_GSS_DATA || proc == RPCSEC_GSS_DESTROY) {
		<span class="enscript-type">struct</span> posix_cred temp_pcred;

		<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_seqwin == 0) {
			<span class="enscript-comment">/*
			 * Context isn't complete
			 */</span>
			error = NFSERR_AUTHERR | RPCSEC_GSS_CTXPROBLEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}

		<span class="enscript-keyword">if</span> (!nfs_gss_svc_seqnum_valid(cp, seqnum)) {
			<span class="enscript-comment">/*
			 * Sequence number is bad
			 */</span>
			error = EINVAL;	<span class="enscript-comment">// drop the request
</span>			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}

		<span class="enscript-comment">/* Now compute the client's call header checksum */</span>
		nfs_gss_cksum_chain(ki, nmc, ALG_MIC(ki), 0, 0, cksum1);

		<span class="enscript-comment">/*
		 * Validate the verifier.
		 * The verifier contains an encrypted checksum
		 * of the call header from the XID up to and
		 * including the credential.  We compute the
		 * checksum and compare it with what came in
		 * the verifier.
		 */</span>
		nfsm_chain_get_32(error, nmc, flavor);
		nfsm_chain_get_32(error, nmc, verflen);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		<span class="enscript-keyword">if</span> (flavor != RPCSEC_GSS || verflen != KRB5_SZ_TOKEN(ki-&gt;hash_len))
			error = NFSERR_AUTHERR | AUTH_BADVERF;
		nfsm_chain_get_opaque(error, nmc, verflen, tokbuf);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;

		<span class="enscript-comment">/* Get the checksum from the token inside the verifier */</span>
		error = nfs_gss_token_get(ki, ALG_MIC(ki), tokbuf, 1,
			NULL, cksum2);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;

		<span class="enscript-keyword">if</span> (bcmp(cksum1, cksum2, HASHLEN(ki)) != 0) {
			error = NFSERR_AUTHERR | RPCSEC_GSS_CTXPROBLEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}

		nd-&gt;nd_gss_seqnum = seqnum;

		<span class="enscript-comment">/*
		 * Set up the user's cred
		 */</span>
		bzero(&amp;temp_pcred, <span class="enscript-keyword">sizeof</span>(temp_pcred));
		temp_pcred.cr_uid = cp-&gt;gss_svc_uid;
		bcopy(cp-&gt;gss_svc_gids, temp_pcred.cr_groups,
				<span class="enscript-keyword">sizeof</span>(gid_t) * cp-&gt;gss_svc_ngroups);
		temp_pcred.cr_ngroups = cp-&gt;gss_svc_ngroups;

		nd-&gt;nd_cr = posix_cred_create(&amp;temp_pcred);
		<span class="enscript-keyword">if</span> (nd-&gt;nd_cr == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
		clock_get_uptime(&amp;cp-&gt;gss_svc_incarnation);

		<span class="enscript-comment">/*
		 * If the call arguments are integrity or privacy protected
		 * then we need to check them here.
		 */</span>
		<span class="enscript-keyword">switch</span> (service) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_SVC_NONE</span>:
			<span class="enscript-comment">/* nothing to do */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_SVC_INTEGRITY</span>:
			<span class="enscript-comment">/*
			 * Here's what we expect in the integrity call args:
			 *
			 * - length of seq num + call args (4 bytes)
			 * - sequence number (4 bytes)
			 * - call args (variable bytes)
			 * - length of checksum token (37)
			 * - checksum of seqnum + call args (37 bytes)
			 */</span>
			nfsm_chain_get_32(error, nmc, arglen);		<span class="enscript-comment">// length of args
</span>			<span class="enscript-keyword">if</span> (arglen &gt; NFS_MAXPACKET) {
				error = EBADRPC;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}

			<span class="enscript-comment">/* Compute the checksum over the call args */</span>
			start = nfsm_chain_offset(nmc);
			nfs_gss_cksum_chain(ki, nmc, ALG_MIC(ki), start, arglen, cksum1);
	
			<span class="enscript-comment">/*
			 * Get the sequence number prepended to the args
			 * and compare it against the one sent in the
			 * call credential.
			 */</span>
			nfsm_chain_get_32(error, nmc, seqnum);
			<span class="enscript-keyword">if</span> (seqnum != nd-&gt;nd_gss_seqnum) {
				error = EBADRPC;			<span class="enscript-comment">// returns as GARBAGEARGS
</span>				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}
	
			<span class="enscript-comment">/*
			 * Advance to the end of the args and
			 * fetch the checksum computed by the client.
			 */</span>
			nmc_tmp = *nmc;	
			arglen -= NFSX_UNSIGNED;			<span class="enscript-comment">// skipped seqnum
</span>			nfsm_chain_adv(error, &amp;nmc_tmp, arglen);	<span class="enscript-comment">// skip args
</span>			nfsm_chain_get_32(error, &amp;nmc_tmp, cksumlen);	<span class="enscript-comment">// length of checksum
</span>			<span class="enscript-keyword">if</span> (cksumlen != KRB5_SZ_TOKEN(ki-&gt;hash_len)) {
				error = EBADRPC;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}
			nfsm_chain_get_opaque(error, &amp;nmc_tmp, cksumlen, tokbuf);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			error = nfs_gss_token_get(ki, ALG_MIC(ki), tokbuf, 1,
				NULL, cksum2);
	
			<span class="enscript-comment">/* Verify that the checksums are the same */</span>
			<span class="enscript-keyword">if</span> (error || bcmp(cksum1, cksum2, HASHLEN(ki)) != 0) {
				error = EBADRPC;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_SVC_PRIVACY</span>:
			<span class="enscript-comment">/*
			 * Here's what we expect in the privacy call args:
			 *
			 * - length of confounder + seq num + token + call args
			 * - wrap token (37-40 bytes)
			 * - confounder (8 bytes)
			 * - sequence number (4 bytes)
			 * - call args (encrypted)
			 */</span>
			nfsm_chain_get_32(error, nmc, arglen);		<span class="enscript-comment">// length of args
</span>			<span class="enscript-keyword">if</span> (arglen &gt; NFS_MAXPACKET) {
				error = EBADRPC;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}
	
			<span class="enscript-comment">/* Get the token that prepends the encrypted args */</span>
			nfsm_chain_get_opaque(error, nmc, KRB5_SZ_TOKMAX(ki-&gt;hash_len), tokbuf);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			error = nfs_gss_token_get(ki, ALG_WRAP(ki), tokbuf, 1,
							&amp;toklen, cksum1);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			nfsm_chain_reverse(nmc, nfsm_pad(toklen));
	
			<span class="enscript-comment">/* decrypt the 8 byte confounder + seqnum + args */</span>
			start = nfsm_chain_offset(nmc);
			arglen -= toklen;
			nfs_gss_encrypt_chain(ki, nmc, start, arglen, DES_DECRYPT);
	
			<span class="enscript-comment">/* Compute a checksum over the sequence number + results */</span>
			nfs_gss_cksum_chain(ki, nmc, ALG_WRAP(ki), start, arglen, cksum2);
	
			<span class="enscript-comment">/* Verify that the checksums are the same */</span>
			<span class="enscript-keyword">if</span> (bcmp(cksum1, cksum2, HASHLEN(ki)) != 0) {
				error = EBADRPC;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}

			<span class="enscript-comment">/*
			 * Get the sequence number prepended to the args
			 * and compare it against the one sent in the
			 * call credential.
			 */</span>
			nfsm_chain_adv(error, nmc, 8);			<span class="enscript-comment">// skip over the confounder
</span>			nfsm_chain_get_32(error, nmc, seqnum);
			<span class="enscript-keyword">if</span> (seqnum != nd-&gt;nd_gss_seqnum) {
				error = EBADRPC;			<span class="enscript-comment">// returns as GARBAGEARGS
</span>				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}
			<span class="enscript-keyword">break</span>;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * If the proc is RPCSEC_GSS_INIT or RPCSEC_GSS_CONTINUE_INIT
		 * then we expect a null verifier.
		 */</span>
		nfsm_chain_get_32(error, nmc, flavor);
		nfsm_chain_get_32(error, nmc, verflen);
		<span class="enscript-keyword">if</span> (error || flavor != RPCAUTH_NULL || verflen &gt; 0)
			error = NFSERR_AUTHERR | RPCSEC_GSS_CREDPROBLEM;
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (proc == RPCSEC_GSS_INIT) {
				lck_mtx_destroy(cp-&gt;gss_svc_mtx, nfs_gss_svc_grp);
				FREE(cp, M_TEMP);
				cp = NULL;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
	}

	nd-&gt;nd_gss_context = cp;
	<span class="enscript-keyword">return</span> 0;
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (cp)
		nfs_gss_svc_ctx_deref(cp);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Insert the server's verifier into the RPC reply header.
 * It contains a signed checksum of the sequence number that
 * was received in the RPC call.
 * Then go on to add integrity or privacy if necessary.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_svc_verf_put</span>(<span class="enscript-type">struct</span> nfsrv_descript *nd, <span class="enscript-type">struct</span> nfsm_chain *nmc)
{
	<span class="enscript-type">struct</span> nfs_gss_svc_ctx *cp;
	<span class="enscript-type">int</span> error = 0;
	u_char tokbuf[KRB5_SZ_TOKEN(MAX_DIGEST)];
	<span class="enscript-type">int</span> toklen;
	u_char cksum[MAX_DIGEST];
	gss_key_info *ki;

	cp = nd-&gt;nd_gss_context;
	ki = &amp;cp-&gt;gss_svc_kinfo;
	
	<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_major != GSS_S_COMPLETE) {
		<span class="enscript-comment">/*
		 * If the context isn't yet complete
		 * then return a null verifier.
		 */</span>
		nfsm_chain_add_32(error, nmc, RPCAUTH_NULL);
		nfsm_chain_add_32(error, nmc, 0);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/*
	 * Compute checksum of the request seq number
	 * If it's the final reply of context setup
	 * then return the checksum of the context
	 * window size.
	 */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_proc == RPCSEC_GSS_INIT ||
	    cp-&gt;gss_svc_proc == RPCSEC_GSS_CONTINUE_INIT)
		nfs_gss_cksum_rep(ki, cp-&gt;gss_svc_seqwin, cksum);
	<span class="enscript-keyword">else</span>
		nfs_gss_cksum_rep(ki, nd-&gt;nd_gss_seqnum, cksum);
	<span class="enscript-comment">/*
	 * Now wrap it in a token and add
	 * the verifier to the reply.
	 */</span>
	toklen = nfs_gss_token_put(ki, ALG_MIC(ki), tokbuf, 0, 0, cksum);
	nfsm_chain_add_32(error, nmc, RPCSEC_GSS);
	nfsm_chain_add_32(error, nmc, toklen);
	nfsm_chain_add_opaque(error, nmc, tokbuf, toklen);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * The results aren't available yet, but if they need to be
 * checksummed for integrity protection or encrypted, then
 * we can record the start offset here, insert a place-holder
 * for the results length, as well as the sequence number.
 * The rest of the work is done later by nfs_gss_svc_protect_reply()
 * when the results are available.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_svc_prepare_reply</span>(<span class="enscript-type">struct</span> nfsrv_descript *nd, <span class="enscript-type">struct</span> nfsm_chain *nmc)
{
	<span class="enscript-type">struct</span> nfs_gss_svc_ctx *cp = nd-&gt;nd_gss_context;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_proc == RPCSEC_GSS_INIT ||
	    cp-&gt;gss_svc_proc == RPCSEC_GSS_CONTINUE_INIT)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">switch</span> (nd-&gt;nd_sec) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5</span>:
		<span class="enscript-comment">/* Nothing to do */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5I</span>:
		nd-&gt;nd_gss_mb = nmc-&gt;nmc_mcur;			<span class="enscript-comment">// record current mbuf
</span>		nfsm_chain_finish_mbuf(error, nmc);		<span class="enscript-comment">// split the chain here
</span>		nfsm_chain_add_32(error, nmc, nd-&gt;nd_gss_seqnum); <span class="enscript-comment">// req sequence number
</span>		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5P</span>:
		nd-&gt;nd_gss_mb = nmc-&gt;nmc_mcur;			<span class="enscript-comment">// record current mbuf
</span>		nfsm_chain_finish_mbuf(error, nmc);		<span class="enscript-comment">// split the chain here
</span>		nfsm_chain_add_32(error, nmc, random());	<span class="enscript-comment">// confounder bytes 1-4
</span>		nfsm_chain_add_32(error, nmc, random());	<span class="enscript-comment">// confounder bytes 5-8
</span>		nfsm_chain_add_32(error, nmc, nd-&gt;nd_gss_seqnum); <span class="enscript-comment">// req sequence number
</span>		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * The results are checksummed or encrypted for return to the client
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_svc_protect_reply</span>(<span class="enscript-type">struct</span> nfsrv_descript *nd, mbuf_t mrep)
{
	<span class="enscript-type">struct</span> nfs_gss_svc_ctx *cp = nd-&gt;nd_gss_context;
	<span class="enscript-type">struct</span> nfsm_chain nmrep_res, *nmc_res = &amp;nmrep_res;
	<span class="enscript-type">struct</span> nfsm_chain nmrep_pre, *nmc_pre = &amp;nmrep_pre;
	mbuf_t mb, results;
	uint32_t reslen;
	u_char tokbuf[KRB5_SZ_TOKMAX(MAX_DIGEST)];
	<span class="enscript-type">int</span> pad, toklen;
	u_char cksum[MAX_DIGEST];
	<span class="enscript-type">int</span> error = 0;
	gss_key_info *ki = &amp;cp-&gt;gss_svc_kinfo;

	<span class="enscript-comment">/*
	 * Using a reference to the mbuf where we previously split the reply
	 * mbuf chain, we split the mbuf chain argument into two mbuf chains,
	 * one that allows us to prepend a length field or token, (nmc_pre)
	 * and the second which holds just the results that we're going to
	 * checksum and/or encrypt.  When we're done, we join the chains back
	 * together.
	 */</span>
	nfs_gss_nfsm_chain(nmc_res, mrep);		<span class="enscript-comment">// set up the results chain
</span>	mb = nd-&gt;nd_gss_mb;				<span class="enscript-comment">// the mbuf where we split
</span>	results = mbuf_next(mb);			<span class="enscript-comment">// first mbuf in the results
</span>	reslen = nfs_gss_mchain_length(results);	<span class="enscript-comment">// length of results
</span>	error = mbuf_setnext(mb, NULL);			<span class="enscript-comment">// disconnect the chains
</span>	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	nfs_gss_nfsm_chain(nmc_pre, mb);		<span class="enscript-comment">// set up the prepend chain
</span>
	<span class="enscript-keyword">if</span> (nd-&gt;nd_sec == RPCAUTH_KRB5I) {
		nfsm_chain_add_32(error, nmc_pre, reslen);
		nfsm_chain_build_done(error, nmc_pre);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		nfs_gss_append_chain(nmc_pre, results);	<span class="enscript-comment">// Append the results mbufs
</span>
		<span class="enscript-comment">/* Now compute the checksum over the results data */</span>
		nfs_gss_cksum_mchain(ki, results, ALG_MIC(ki), 0, reslen, cksum);

		<span class="enscript-comment">/* Put it into a token and append to the request */</span>
		toklen = nfs_gss_token_put(ki, ALG_MIC(ki), tokbuf, 0, 0, cksum);
		nfsm_chain_add_32(error, nmc_res, toklen);
		nfsm_chain_add_opaque(error, nmc_res, tokbuf, toklen);
		nfsm_chain_build_done(error, nmc_res);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* RPCAUTH_KRB5P */</span>
		<span class="enscript-comment">/*
		 * Append a pad trailer - per RFC 1964 section 1.2.2.3
		 * Since XDR data is always 32-bit aligned, it
		 * needs to be padded either by 4 bytes or 8 bytes.
		 */</span>
		<span class="enscript-keyword">if</span> (reslen % 8 &gt; 0) {
			nfsm_chain_add_32(error, nmc_res, 0x04040404);
			reslen += NFSX_UNSIGNED;
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, nmc_res, 0x08080808);
			nfsm_chain_add_32(error, nmc_res, 0x08080808);
			reslen +=  2 * NFSX_UNSIGNED;
		}
		nfsm_chain_build_done(error, nmc_res);

		<span class="enscript-comment">/* Now compute the checksum over the results data */</span>
		nfs_gss_cksum_mchain(ki, results, ALG_WRAP(ki), 0, reslen, cksum);

		<span class="enscript-comment">/* Put it into a token and insert in the reply */</span>
		toklen = nfs_gss_token_put(ki, ALG_WRAP(ki), tokbuf, 0, reslen, cksum);
		nfsm_chain_add_32(error, nmc_pre, toklen + reslen);
		nfsm_chain_add_opaque_nopad(error, nmc_pre, tokbuf, toklen);
		nfsm_chain_build_done(error, nmc_pre);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		nfs_gss_append_chain(nmc_pre, results);	<span class="enscript-comment">// Append the results mbufs
</span>
		<span class="enscript-comment">/* Encrypt the confounder + seqnum + results */</span>
		nfs_gss_encrypt_mchain(ki, results, 0, reslen, DES_ENCRYPT);

		<span class="enscript-comment">/* Add null XDR pad if the ASN.1 token misaligned the data */</span>
		pad = nfsm_pad(toklen + reslen);
		<span class="enscript-keyword">if</span> (pad &gt; 0) {
			nfsm_chain_add_opaque_nopad(error, nmc_pre, iv0, pad);
			nfsm_chain_build_done(error, nmc_pre);
		}
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * This function handles the context setup calls from the client.
 * Essentially, it implements the NFS null procedure calls when
 * an RPCSEC_GSS credential is used.
 * This is the context maintenance function.  It creates and
 * destroys server contexts at the whim of the client.
 * During context creation, it receives GSS-API tokens from the
 * client, passes them up to gssd, and returns a received token
 * back to the client in the null procedure reply.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_svc_ctx_init</span>(<span class="enscript-type">struct</span> nfsrv_descript *nd, <span class="enscript-type">struct</span> nfsrv_sock *slp, mbuf_t *mrepp)
{
	<span class="enscript-type">struct</span> nfs_gss_svc_ctx *cp = NULL;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> autherr = 0;
	<span class="enscript-type">struct</span> nfsm_chain *nmreq, nmrep;
	<span class="enscript-type">int</span> sz;

	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_null(&amp;nmrep);
	*mrepp = NULL;
	cp = nd-&gt;nd_gss_context;
	nd-&gt;nd_repstat = 0;

	<span class="enscript-keyword">switch</span> (cp-&gt;gss_svc_proc) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_INIT</span>:
		nfs_gss_svc_ctx_insert(cp);
		<span class="enscript-comment">/* FALLTHRU */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_CONTINUE_INIT</span>:
		<span class="enscript-comment">/* Get the token from the request */</span>
		nfsm_chain_get_32(error, nmreq, cp-&gt;gss_svc_tokenlen);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_tokenlen == 0) {
			autherr = RPCSEC_GSS_CREDPROBLEM;
			<span class="enscript-keyword">break</span>;
		}
		MALLOC(cp-&gt;gss_svc_token, u_char *, cp-&gt;gss_svc_tokenlen, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_token == NULL) {
			autherr = RPCSEC_GSS_CREDPROBLEM;
			<span class="enscript-keyword">break</span>;
		}
		nfsm_chain_get_opaque(error, nmreq, cp-&gt;gss_svc_tokenlen, cp-&gt;gss_svc_token);

		<span class="enscript-comment">/* Use the token in a gss_accept_sec_context upcall */</span>
		error = nfs_gss_svc_gssd_upcall(cp);
		<span class="enscript-keyword">if</span> (error) {
			autherr = RPCSEC_GSS_CREDPROBLEM;
			<span class="enscript-keyword">if</span> (error == NFSERR_EAUTH)
				error = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * If the context isn't complete, pass the new token
		 * back to the client for another round.
		 */</span>
		<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_major != GSS_S_COMPLETE)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * Now the server context is complete.
		 * Finish setup.
		 */</span>
		clock_get_uptime(&amp;cp-&gt;gss_svc_incarnation);

		cp-&gt;gss_svc_seqwin = GSS_SVC_SEQWINDOW;
		MALLOC(cp-&gt;gss_svc_seqbits, uint32_t *,
			nfsm_rndup((cp-&gt;gss_svc_seqwin + 7) / 8), M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_seqbits == NULL) {
			autherr = RPCSEC_GSS_CREDPROBLEM;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_DATA</span>:
		<span class="enscript-comment">/* Just a nullproc ping - do nothing */</span>
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_DESTROY</span>:
		<span class="enscript-comment">/*
		 * Don't destroy the context immediately because
		 * other active requests might still be using it.
		 * Instead, schedule it for destruction after
		 * GSS_CTX_PEND time has elapsed.
		 */</span>
		cp = nfs_gss_svc_ctx_find(cp-&gt;gss_svc_handle);
		<span class="enscript-keyword">if</span> (cp != NULL) {
			cp-&gt;gss_svc_handle = 0;	<span class="enscript-comment">// so it can't be found
</span>			lck_mtx_lock(cp-&gt;gss_svc_mtx);
			clock_interval_to_deadline(GSS_CTX_PEND, NSEC_PER_SEC,
				&amp;cp-&gt;gss_svc_incarnation);
			lck_mtx_unlock(cp-&gt;gss_svc_mtx);
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		autherr = RPCSEC_GSS_CREDPROBLEM;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* Now build the reply  */</span>

	<span class="enscript-keyword">if</span> (nd-&gt;nd_repstat == 0)
		nd-&gt;nd_repstat = autherr ? (NFSERR_AUTHERR | autherr) : NFSERR_RETVOID;
	sz = 7 * NFSX_UNSIGNED + nfsm_rndup(cp-&gt;gss_svc_tokenlen); <span class="enscript-comment">// size of results
</span>	error = nfsrv_rephead(nd, slp, &amp;nmrep, sz);
	*mrepp = nmrep.nmc_mhead;
	<span class="enscript-keyword">if</span> (error || autherr)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;

	<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_proc == RPCSEC_GSS_INIT ||
	    cp-&gt;gss_svc_proc == RPCSEC_GSS_CONTINUE_INIT) {
		nfsm_chain_add_32(error, &amp;nmrep, <span class="enscript-keyword">sizeof</span>(cp-&gt;gss_svc_handle));
		nfsm_chain_add_32(error, &amp;nmrep, cp-&gt;gss_svc_handle);
	
		nfsm_chain_add_32(error, &amp;nmrep, cp-&gt;gss_svc_major);
		nfsm_chain_add_32(error, &amp;nmrep, cp-&gt;gss_svc_minor);
		nfsm_chain_add_32(error, &amp;nmrep, cp-&gt;gss_svc_seqwin);
	
		nfsm_chain_add_32(error, &amp;nmrep, cp-&gt;gss_svc_tokenlen);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_token != NULL) {
			nfsm_chain_add_opaque(error, &amp;nmrep, cp-&gt;gss_svc_token, cp-&gt;gss_svc_tokenlen);
			FREE(cp-&gt;gss_svc_token, M_TEMP);
			cp-&gt;gss_svc_token = NULL;
		}
	}

<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (autherr != 0) {
		nd-&gt;nd_gss_context = NULL;
		LIST_REMOVE(cp, gss_svc_entries);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_seqbits != NULL)
			FREE(cp-&gt;gss_svc_seqbits, M_TEMP);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_token != NULL)
			FREE(cp-&gt;gss_svc_token, M_TEMP);
		lck_mtx_destroy(cp-&gt;gss_svc_mtx, nfs_gss_svc_grp);
		FREE(cp, M_TEMP);
	}

	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_cleanup(&amp;nmrep);
		*mrepp = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * This is almost a mirror-image of the client side upcall.
 * It passes and receives a token, but invokes gss_accept_sec_context.
 * If it's the final call of the context setup, then gssd also returns
 * the session key and the user's UID.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_svc_gssd_upcall</span>(<span class="enscript-type">struct</span> nfs_gss_svc_ctx *cp)
{
	kern_return_t kr;
	mach_port_t mp;
	<span class="enscript-type">int</span> retry_cnt = 0;
	gssd_byte_buffer okey = NULL;
	uint32_t skeylen = 0;
	uint32_t ret_flags;
	vm_map_copy_t itoken = NULL;
	gssd_byte_buffer otoken = NULL;
	mach_msg_type_number_t otokenlen;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">char</span> svcname[] = <span class="enscript-string">&quot;nfs&quot;</span>;

	kr = host_get_gssd_port(host_priv_self(), &amp;mp);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		printf(<span class="enscript-string">&quot;nfs_gss_svc_gssd_upcall: can't get gssd port, status %x (%d)\n&quot;</span>, kr, kr);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (!IPC_PORT_VALID(mp)) {
		printf(<span class="enscript-string">&quot;nfs_gss_svc_gssd_upcall: gssd port not valid\n&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_tokenlen &gt; 0)
		nfs_gss_mach_alloc_buffer(cp-&gt;gss_svc_token, cp-&gt;gss_svc_tokenlen, &amp;itoken);

<span class="enscript-reference">retry</span>:
	kr = mach_gss_accept_sec_context(
		mp,
		(gssd_byte_buffer) itoken, (mach_msg_type_number_t) cp-&gt;gss_svc_tokenlen,
		svcname,
		0,
		&amp;cp-&gt;gss_svc_context,
		&amp;cp-&gt;gss_svc_cred_handle,
		&amp;ret_flags,
		&amp;cp-&gt;gss_svc_uid,
		cp-&gt;gss_svc_gids,
		&amp;cp-&gt;gss_svc_ngroups,
		&amp;okey, (mach_msg_type_number_t *) &amp;skeylen,
		&amp;otoken, &amp;otokenlen,
		&amp;cp-&gt;gss_svc_major,
		&amp;cp-&gt;gss_svc_minor);

	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) { 
		printf(<span class="enscript-string">&quot;nfs_gss_svc_gssd_upcall failed: %x (%d)\n&quot;</span>, kr, kr);
		<span class="enscript-keyword">if</span> (kr == MIG_SERVER_DIED &amp;&amp; cp-&gt;gss_svc_context == 0 &amp;&amp;
			retry_cnt++ &lt; NFS_GSS_MACH_MAX_RETRIES) {
			<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_tokenlen &gt; 0)
				nfs_gss_mach_alloc_buffer(cp-&gt;gss_svc_token, cp-&gt;gss_svc_tokenlen, &amp;itoken);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}
		host_release_special_port(mp);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	host_release_special_port(mp);

	<span class="enscript-keyword">if</span> (skeylen &gt; 0) {
		<span class="enscript-keyword">if</span> (skeylen != SKEYLEN &amp;&amp; skeylen != SKEYLEN3) {
			printf(<span class="enscript-string">&quot;nfs_gss_svc_gssd_upcall: bad key length (%d)\n&quot;</span>, skeylen);
			vm_map_copy_discard((vm_map_copy_t) okey);
			vm_map_copy_discard((vm_map_copy_t) otoken);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		error = nfs_gss_mach_vmcopyout((vm_map_copy_t) okey, skeylen, cp-&gt;gss_svc_kinfo.skey);
		<span class="enscript-keyword">if</span> (error) {
			vm_map_copy_discard((vm_map_copy_t) otoken);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		error = gss_key_init(&amp;cp-&gt;gss_svc_kinfo, skeylen);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	}

	<span class="enscript-comment">/* Free context token used as input */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_token)
		FREE(cp-&gt;gss_svc_token, M_TEMP);
	cp-&gt;gss_svc_token = NULL;
	cp-&gt;gss_svc_tokenlen = 0;
	
	<span class="enscript-keyword">if</span> (otokenlen &gt; 0) {
		<span class="enscript-comment">/* Set context token to gss output token */</span>
		MALLOC(cp-&gt;gss_svc_token, u_char *, otokenlen, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_token == NULL) {
			printf(<span class="enscript-string">&quot;nfs_gss_svc_gssd_upcall: could not allocate %d bytes\n&quot;</span>, otokenlen);
			vm_map_copy_discard((vm_map_copy_t) otoken);
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
		error = nfs_gss_mach_vmcopyout((vm_map_copy_t) otoken, otokenlen, cp-&gt;gss_svc_token);
		<span class="enscript-keyword">if</span> (error) {
			FREE(cp-&gt;gss_svc_token, M_TEMP);
			cp-&gt;gss_svc_token = NULL;
			<span class="enscript-keyword">return</span> (NFSERR_EAUTH);
		}
		cp-&gt;gss_svc_tokenlen = otokenlen;
	}

	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">out</span>:
	FREE(cp-&gt;gss_svc_token, M_TEMP);
	cp-&gt;gss_svc_tokenlen = 0;
	cp-&gt;gss_svc_token = NULL;

	<span class="enscript-keyword">return</span> (NFSERR_EAUTH);	
}

<span class="enscript-comment">/*
 * Validate the sequence number in the credential as described
 * in RFC 2203 Section 5.3.3.1
 *
 * Here the window of valid sequence numbers is represented by
 * a bitmap.  As each sequence number is received, its bit is
 * set in the bitmap.  An invalid sequence number lies below
 * the lower bound of the window, or is within the window but
 * has its bit already set.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_svc_seqnum_valid</span>(<span class="enscript-type">struct</span> nfs_gss_svc_ctx *cp, uint32_t seq)
{
	uint32_t *bits = cp-&gt;gss_svc_seqbits;
	uint32_t win = cp-&gt;gss_svc_seqwin;
	uint32_t i;

	lck_mtx_lock(cp-&gt;gss_svc_mtx);

	<span class="enscript-comment">/*
	 * If greater than the window upper bound,
	 * move the window up, and set the bit.
	 */</span>
	<span class="enscript-keyword">if</span> (seq &gt; cp-&gt;gss_svc_seqmax) {
		<span class="enscript-keyword">if</span> (seq - cp-&gt;gss_svc_seqmax &gt; win)
			bzero(bits, nfsm_rndup((win + 7) / 8));
		<span class="enscript-keyword">else</span>
			<span class="enscript-keyword">for</span> (i = cp-&gt;gss_svc_seqmax + 1; i &lt; seq; i++)
				win_resetbit(bits, i % win);
		win_setbit(bits, seq % win);
		cp-&gt;gss_svc_seqmax = seq;
		lck_mtx_unlock(cp-&gt;gss_svc_mtx);
		<span class="enscript-keyword">return</span> (1);
	}

	<span class="enscript-comment">/*
	 * Invalid if below the lower bound of the window
	 */</span>
	<span class="enscript-keyword">if</span> (seq &lt;= cp-&gt;gss_svc_seqmax - win) {
		lck_mtx_unlock(cp-&gt;gss_svc_mtx);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * In the window, invalid if the bit is already set
	 */</span>
	<span class="enscript-keyword">if</span> (win_getbit(bits, seq % win)) {
		lck_mtx_unlock(cp-&gt;gss_svc_mtx);
		<span class="enscript-keyword">return</span> (0);
	}
	win_setbit(bits, seq % win);
	lck_mtx_unlock(cp-&gt;gss_svc_mtx);
	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * Drop a reference to a context
 *
 * Note that it's OK for the context to exist
 * with a refcount of zero.  The refcount isn't
 * checked until we're about to reap an expired one.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_svc_ctx_deref</span>(<span class="enscript-type">struct</span> nfs_gss_svc_ctx *cp)
{
	lck_mtx_lock(cp-&gt;gss_svc_mtx);				
	<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_refcnt &gt; 0)
		cp-&gt;gss_svc_refcnt--;
	<span class="enscript-keyword">else</span>
		printf(<span class="enscript-string">&quot;nfs_gss_ctx_deref: zero refcount\n&quot;</span>);
	lck_mtx_unlock(cp-&gt;gss_svc_mtx);				
}

<span class="enscript-comment">/*
 * Called at NFS server shutdown - destroy all contexts
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_svc_cleanup</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> nfs_gss_svc_ctx_hashhead *head;
	<span class="enscript-type">struct</span> nfs_gss_svc_ctx *cp, *ncp;
	<span class="enscript-type">int</span> i;
	
	lck_mtx_lock(nfs_gss_svc_ctx_mutex);

	<span class="enscript-comment">/*
	 * Run through all the buckets
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; SVC_CTX_HASHSZ; i++) {
		<span class="enscript-comment">/*
		 * Remove and free all entries in the bucket
		 */</span>
		head = &amp;nfs_gss_svc_ctx_hashtbl[i];
		LIST_FOREACH_SAFE(cp, head, gss_svc_entries, ncp) {
			LIST_REMOVE(cp, gss_svc_entries);
			<span class="enscript-keyword">if</span> (cp-&gt;gss_svc_seqbits)
				FREE(cp-&gt;gss_svc_seqbits, M_TEMP);
			lck_mtx_destroy(cp-&gt;gss_svc_mtx, nfs_gss_svc_grp);
			FREE(cp, M_TEMP);
		}
	}

	lck_mtx_unlock(nfs_gss_svc_ctx_mutex);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>


<span class="enscript-comment">/*************
 * The following functions are used by both client and server.
 */</span>

<span class="enscript-comment">/*
 * Release a host special port that was obtained by host_get_special_port
 * or one of its macros (host_get_gssd_port in this case).
 * This really should be in a public kpi. 
 */</span>

<span class="enscript-comment">/* This should be in a public header if this routine is not */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ipc_port_release_send</span>(ipc_port_t);
<span class="enscript-type">extern</span> ipc_port_t <span class="enscript-function-name">ipc_port_copy_send</span>(ipc_port_t);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">host_release_special_port</span>(mach_port_t mp)
{
	<span class="enscript-keyword">if</span> (IPC_PORT_VALID(mp))
		ipc_port_release_send(mp);
}

<span class="enscript-type">static</span> mach_port_t
<span class="enscript-function-name">host_copy_special_port</span>(mach_port_t mp)
{
	<span class="enscript-keyword">return</span> (ipc_port_copy_send(mp));
}

<span class="enscript-comment">/*
 * The token that is sent and received in the gssd upcall
 * has unbounded variable length.  Mach RPC does not pass
 * the token in-line.  Instead it uses page mapping to handle
 * these parameters.  This function allocates a VM buffer
 * to hold the token for an upcall and copies the token
 * (received from the client) into it.  The VM buffer is
 * marked with a src_destroy flag so that the upcall will
 * automatically de-allocate the buffer when the upcall is
 * complete.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_mach_alloc_buffer</span>(u_char *buf, uint32_t buflen, vm_map_copy_t *addr)
{
	kern_return_t kr;
	vm_offset_t kmem_buf;
	vm_size_t tbuflen;

	*addr = NULL;
	<span class="enscript-keyword">if</span> (buf == NULL || buflen == 0)
		<span class="enscript-keyword">return</span>;

	tbuflen = vm_map_round_page(buflen,
				    vm_map_page_mask(ipc_kernel_map));
	kr = vm_allocate(ipc_kernel_map, &amp;kmem_buf, tbuflen, VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_KERN_MEMORY_FILE));
	<span class="enscript-keyword">if</span> (kr != 0) {
		printf(<span class="enscript-string">&quot;nfs_gss_mach_alloc_buffer: vm_allocate failed\n&quot;</span>);
		<span class="enscript-keyword">return</span>;
	}

	kr = vm_map_wire(ipc_kernel_map,
			 vm_map_trunc_page(kmem_buf,
					   vm_map_page_mask(ipc_kernel_map)),
			 vm_map_round_page(kmem_buf + tbuflen,
					   vm_map_page_mask(ipc_kernel_map)),
		VM_PROT_READ|VM_PROT_WRITE|VM_PROT_MEMORY_TAG_MAKE(VM_KERN_MEMORY_FILE), FALSE);
	<span class="enscript-keyword">if</span> (kr != 0) {
		printf(<span class="enscript-string">&quot;nfs_gss_mach_alloc_buffer: vm_map_wire failed\n&quot;</span>);
		<span class="enscript-keyword">return</span>;
	}
	
	bcopy(buf, (<span class="enscript-type">void</span> *) kmem_buf, buflen);
	<span class="enscript-comment">// Shouldn't need to bzero below since vm_allocate returns zeroed pages
</span>	<span class="enscript-comment">// bzero(kmem_buf + buflen, tbuflen - buflen);
</span>	
	kr = vm_map_unwire(ipc_kernel_map,
			   vm_map_trunc_page(kmem_buf,
					     vm_map_page_mask(ipc_kernel_map)),
			   vm_map_round_page(kmem_buf + tbuflen,
					     vm_map_page_mask(ipc_kernel_map)),
			   FALSE);
	<span class="enscript-keyword">if</span> (kr != 0) {
		printf(<span class="enscript-string">&quot;nfs_gss_mach_alloc_buffer: vm_map_unwire failed\n&quot;</span>);
		<span class="enscript-keyword">return</span>;
	}

	kr = vm_map_copyin(ipc_kernel_map, (vm_map_address_t) kmem_buf,
		(vm_map_size_t) buflen, TRUE, addr);
	<span class="enscript-keyword">if</span> (kr != 0) {
		printf(<span class="enscript-string">&quot;nfs_gss_mach_alloc_buffer: vm_map_copyin failed\n&quot;</span>);
		<span class="enscript-keyword">return</span>;
	}
}

<span class="enscript-comment">/*
 * Here we handle a token received from the gssd via an upcall.
 * The received token resides in an allocate VM buffer.
 * We copy the token out of this buffer to a chunk of malloc'ed
 * memory of the right size, then de-allocate the VM buffer.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_mach_vmcopyout</span>(vm_map_copy_t in, uint32_t len, u_char *out)
{
	vm_map_offset_t map_data;
	vm_offset_t data;
	<span class="enscript-type">int</span> error;

	error = vm_map_copyout(ipc_kernel_map, &amp;map_data, in);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	data = CAST_DOWN(vm_offset_t, map_data);
	bcopy((<span class="enscript-type">void</span> *) data, out, len);
	vm_deallocate(ipc_kernel_map, data, len);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Encode an ASN.1 token to be wrapped in an RPCSEC_GSS verifier.
 * Returns the size of the token, since it contains a variable
 * length DER encoded size field.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_token_put</span>(
	gss_key_info *ki,
	u_char *alg,
	u_char *p,
	<span class="enscript-type">int</span> initiator,
	<span class="enscript-type">int</span> datalen,
	u_char *cksum)
{
	<span class="enscript-type">static</span> uint32_t seqnum = 0;
	u_char *psave = p;
	u_char plain[8];
	<span class="enscript-type">int</span> toklen, i;

	<span class="enscript-comment">/*
	 * Fill in the token header: 2 octets.
	 * This is 0x06 - an ASN.1 tag for APPLICATION, 0, SEQUENCE
	 * followed by the length of the token: 35 + 0 octets for a
	 * MIC token, or 35 + encrypted octets for a wrap token;
	 */</span>
	*p++ = 0x060;
	toklen = KRB5_SZ_MECH + KRB5_SZ_ALG + KRB5_SZ_SEQ + HASHLEN(ki);
	nfs_gss_der_length_put(&amp;p, toklen + datalen);

	<span class="enscript-comment">/*
	 * Fill in the DER encoded mech OID for Kerberos v5.
	 * This represents the Kerberos OID 1.2.840.113554.1.2.2
	 * described in RFC 2623, section 4.2
	 */</span>
	bcopy(krb5_mech, p, <span class="enscript-keyword">sizeof</span>(krb5_mech));
	p += <span class="enscript-keyword">sizeof</span>(krb5_mech);

	<span class="enscript-comment">/*
	 * Now at the token described in RFC 1964, section 1.2.1
	 * Fill in the token ID, integrity algorithm indicator,
	 * for DES MAC MD5, and four filler octets.
	 * The alg string encodes the bytes to represent either
	 * a MIC token or a WRAP token for Kerberos.
	 */</span>
	bcopy(alg, p, KRB5_SZ_ALG);
	p += KRB5_SZ_ALG;

	<span class="enscript-comment">/*
	 * Now encode the sequence number according to
	 * RFC 1964, section 1.2.1.2 which dictates 4 octets
	 * of sequence number followed by 4 bytes of direction
	 * indicator: 0x00 for initiator or 0xff for acceptor.
	 * We DES CBC encrypt the sequence number using the first
	 * 8 octets of the checksum field as an initialization
	 * vector.
	 * Note that this sequence number is not at all related
	 * to the RPCSEC_GSS protocol sequence number.  This
	 * number is private to the ASN.1 token.  The only
	 * requirement is that it not be repeated in case the
	 * server has replay detection on, which normally should
	 * not be the case, since RFC 2203 section 5.2.3 says that
	 * replay detection and sequence checking must be turned off.
	 */</span>
	seqnum++;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; 4; i++)
		plain[i] = (u_char) ((seqnum &gt;&gt; (i * 8)) &amp; 0xff);
	<span class="enscript-keyword">for</span> (i = 4; i &lt; 8; i++)
		plain[i] = initiator ? 0x00 : 0xff;
	gss_des_crypt(ki, (des_cblock *) plain, (des_cblock *) p, 8,
			(des_cblock *) cksum, NULL, DES_ENCRYPT, KG_USAGE_SEQ);
	p += 8;

	<span class="enscript-comment">/*
	 * Finally, append the octets of the 
	 * checksum of the alg + plaintext data.
	 * The plaintext could be an RPC call header,
	 * the window value, or a sequence number.
	 */</span>
	bcopy(cksum, p, HASHLEN(ki));
	p += HASHLEN(ki);

	<span class="enscript-keyword">return</span> (p - psave);
}

<span class="enscript-comment">/*
 * Determine size of ASN.1 DER length
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_der_length_size</span>(<span class="enscript-type">int</span> len)
{
	<span class="enscript-keyword">return</span>
		len &lt; (1 &lt;&lt;  7) ? 1 :
		len &lt; (1 &lt;&lt;  8) ? 2 :
		len &lt; (1 &lt;&lt; 16) ? 3 :
		len &lt; (1 &lt;&lt; 24) ? 4 : 5;
}

<span class="enscript-comment">/*
 * Encode an ASN.1 DER length field
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_der_length_put</span>(u_char **pp, <span class="enscript-type">int</span> len)
{
	<span class="enscript-type">int</span> sz = nfs_gss_der_length_size(len);
	u_char *p = *pp;

	<span class="enscript-keyword">if</span> (sz == 1) {
		*p++ = (u_char) len;
	} <span class="enscript-keyword">else</span> {
		*p++ = (u_char) ((sz-1) | 0x80);
		sz -= 1;
		<span class="enscript-keyword">while</span> (sz--)
			*p++ = (u_char) ((len &gt;&gt; (sz * 8)) &amp; 0xff);
	}

	*pp = p;
}

<span class="enscript-comment">/*
 * Decode an ASN.1 DER length field
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_der_length_get</span>(u_char **pp)
{
	u_char *p = *pp;
	uint32_t flen, len = 0;

	flen = *p &amp; 0x7f;

	<span class="enscript-keyword">if</span> ((*p++ &amp; 0x80) == 0)
		len = flen;
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (flen &gt; <span class="enscript-keyword">sizeof</span>(uint32_t))
			<span class="enscript-keyword">return</span> (-1);
		<span class="enscript-keyword">while</span> (flen--)
			len = (len &lt;&lt; 8) + *p++;
	}
	*pp = p;
	<span class="enscript-keyword">return</span> (len);
}

<span class="enscript-comment">/*
 * Decode an ASN.1 token from an RPCSEC_GSS verifier.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_token_get</span>(
	gss_key_info *ki,
	u_char *alg,
	u_char *p,
	<span class="enscript-type">int</span> initiator,
	uint32_t *len,
	u_char *cksum)
{
	u_char d, plain[8];
	u_char *psave = p;
	<span class="enscript-type">int</span> seqnum, i;

	<span class="enscript-comment">/*
	 * Check that we have a valid token header
	 */</span>
	<span class="enscript-keyword">if</span> (*p++ != 0x60)
		<span class="enscript-keyword">return</span> (AUTH_BADCRED);
	(<span class="enscript-type">void</span>) nfs_gss_der_length_get(&amp;p);	<span class="enscript-comment">// ignore the size
</span>
	<span class="enscript-comment">/*
	 * Check that we have the DER encoded Kerberos v5 mech OID
	 */</span>
	<span class="enscript-keyword">if</span> (bcmp(p, krb5_mech, <span class="enscript-keyword">sizeof</span>(krb5_mech) != 0))
		<span class="enscript-keyword">return</span> (AUTH_BADCRED);
	p += <span class="enscript-keyword">sizeof</span>(krb5_mech);

	<span class="enscript-comment">/*
	 * Now check the token ID, DES MAC MD5 algorithm
	 * indicator, and filler octets.
	 */</span>
	<span class="enscript-keyword">if</span> (bcmp(p, alg, KRB5_SZ_ALG) != 0)
		<span class="enscript-keyword">return</span> (AUTH_BADCRED);
	p += KRB5_SZ_ALG;

	<span class="enscript-comment">/*
	 * Now decrypt the sequence number.
	 * Note that the gss decryption uses the first 8 octets
	 * of the checksum field as an initialization vector (p + 8).
	 * Per RFC 2203 section 5.2.2 we don't check the sequence number
	 * in the ASN.1 token because the RPCSEC_GSS protocol has its
	 * own sequence number described in section 5.3.3.1
	 */</span>
	seqnum = 0;
	gss_des_crypt(ki, (des_cblock *)p, (des_cblock *) plain, 8,
			(des_cblock *) (p + 8), NULL, DES_DECRYPT, KG_USAGE_SEQ);
	p += 8;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; 4; i++)
		seqnum |= plain[i] &lt;&lt; (i * 8);

	<span class="enscript-comment">/*
	 * Make sure the direction
	 * indicator octets are correct.
	 */</span>
	d = initiator ? 0x00 : 0xff;
	<span class="enscript-keyword">for</span> (i = 4; i &lt; 8; i++)
		<span class="enscript-keyword">if</span> (plain[i] != d)
			<span class="enscript-keyword">return</span> (AUTH_BADCRED);

	<span class="enscript-comment">/*
	 * Finally, get the checksum
	 */</span>
	bcopy(p, cksum, HASHLEN(ki));
	p += HASHLEN(ki);

	<span class="enscript-keyword">if</span> (len != NULL)
		*len = p - psave;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Return the number of bytes in an mbuf chain.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_mchain_length</span>(mbuf_t mhead)
{
	mbuf_t mb;
	<span class="enscript-type">int</span> len = 0;

	<span class="enscript-keyword">for</span> (mb = mhead; mb; mb = mbuf_next(mb))
		len += mbuf_len(mb);

	<span class="enscript-keyword">return</span> (len);
}

<span class="enscript-comment">/*
 * Append an args or results mbuf chain to the header chain
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_gss_append_chain</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, mbuf_t mc)
{
	<span class="enscript-type">int</span> error = 0;
	mbuf_t mb, tail;

	<span class="enscript-comment">/* Connect the mbuf chains */</span>
	error = mbuf_setnext(nmc-&gt;nmc_mcur, mc);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/* Find the last mbuf in the chain */</span>
	tail = NULL;
	<span class="enscript-keyword">for</span> (mb = mc; mb; mb = mbuf_next(mb))
		tail = mb;

	nmc-&gt;nmc_mcur = tail;
	nmc-&gt;nmc_ptr = (caddr_t) mbuf_data(tail) + mbuf_len(tail);
	nmc-&gt;nmc_left = mbuf_trailingspace(tail);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Convert an mbuf chain to an NFS mbuf chain
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_nfsm_chain</span>(<span class="enscript-type">struct</span> nfsm_chain *nmc, mbuf_t mc)
{
	mbuf_t mb, tail;

	<span class="enscript-comment">/* Find the last mbuf in the chain */</span>
	tail = NULL;
	<span class="enscript-keyword">for</span> (mb = mc; mb; mb = mbuf_next(mb))
		tail = mb;

	nmc-&gt;nmc_mhead = mc;
	nmc-&gt;nmc_mcur = tail;
	nmc-&gt;nmc_ptr = (caddr_t) mbuf_data(tail) + mbuf_len(tail);
	nmc-&gt;nmc_left = mbuf_trailingspace(tail);
	nmc-&gt;nmc_flags = 0;
}


<span class="enscript-comment">/*
 * Compute a checksum over an mbuf chain.
 * Start building an MD5 digest at the given offset and keep
 * going until the end of data in the current mbuf is reached.
 * Then convert the 16 byte MD5 digest to an 8 byte DES CBC
 * checksum.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_cksum_mchain</span>(
	gss_key_info *ki,
	mbuf_t mhead,
	u_char *alg,
	<span class="enscript-type">int</span> offset,
	<span class="enscript-type">int</span> len,
	u_char *digest)
{
	mbuf_t mb;
	u_char *ptr;
	<span class="enscript-type">int</span> left, bytes;
	GSS_DIGEST_CTX context;

	gss_digest_Init(&amp;context, ki);

	<span class="enscript-comment">/*
	 * Logically prepend the first 8 bytes of the algorithm
	 * field as required by RFC 1964, section 1.2.1.1
	 */</span>
	gss_digest_Update(&amp;context, alg, KRB5_SZ_ALG);

	<span class="enscript-comment">/*
	 * Move down the mbuf chain until we reach the given
	 * byte offset, then start MD5 on the mbuf data until
	 * we've done len bytes.
	 */</span>

	<span class="enscript-keyword">for</span> (mb = mhead; mb &amp;&amp; len &gt; 0; mb = mbuf_next(mb)) {
		ptr  = mbuf_data(mb);
		left = mbuf_len(mb);
		<span class="enscript-keyword">if</span> (offset &gt;= left) {
			<span class="enscript-comment">/* Offset not yet reached */</span>
			offset -= left;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/* At or beyond offset - checksum data */</span>
		ptr += offset;
		left -= offset;
		offset = 0;
			
		bytes = left &lt; len ? left : len;
		<span class="enscript-keyword">if</span> (bytes &gt; 0)
			gss_digest_Update(&amp;context, ptr, bytes);
		len -= bytes;
	}

	gss_digest_Final(&amp;context, digest);
}

<span class="enscript-comment">/*
 * Compute a checksum over an NFS mbuf chain.
 * Start building an MD5 digest at the given offset and keep
 * going until the end of data in the current mbuf is reached.
 * Then convert the 16 byte MD5 digest to an 8 byte DES CBC
 * checksum.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_cksum_chain</span>(
	gss_key_info *ki,
	<span class="enscript-type">struct</span> nfsm_chain *nmc,
	u_char *alg,
	<span class="enscript-type">int</span> offset,
	<span class="enscript-type">int</span> len,
	u_char *cksum)
{
	<span class="enscript-comment">/*
	 * If the length parameter is zero, then we need
	 * to use the length from the offset to the current
	 * encode/decode offset.
	 */</span>
	<span class="enscript-keyword">if</span> (len == 0)
		len = nfsm_chain_offset(nmc) - offset;

	<span class="enscript-keyword">return</span> (nfs_gss_cksum_mchain(ki, nmc-&gt;nmc_mhead, alg, offset, len, cksum));
}

<span class="enscript-comment">/*
 * Compute a checksum of the sequence number (or sequence window)
 * of an RPCSEC_GSS reply.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_cksum_rep</span>(gss_key_info *ki, uint32_t seqnum, u_char *cksum)
{
	GSS_DIGEST_CTX context;
	uint32_t val = htonl(seqnum);

	gss_digest_Init(&amp;context, ki);

	<span class="enscript-comment">/*
	 * Logically prepend the first 8 bytes of the MIC
	 * token as required by RFC 1964, section 1.2.1.1
	 */</span>
	gss_digest_Update(&amp;context, ALG_MIC(ki), KRB5_SZ_ALG);

	<span class="enscript-comment">/*
	 * Compute the digest of the seqnum in network order
	 */</span>
	gss_digest_Update(&amp;context, &amp;val, 4);
	gss_digest_Final(&amp;context, cksum);
}

<span class="enscript-comment">/*
 * Encrypt or decrypt data in an mbuf chain with des-cbc.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_encrypt_mchain</span>(
	gss_key_info *ki,
	mbuf_t mhead,
	<span class="enscript-type">int</span> offset,
	<span class="enscript-type">int</span> len,
	<span class="enscript-type">int</span> encrypt)
{
	mbuf_t mb, mbn;
	u_char *ptr, *nptr;
	u_char tmp[8], ivec[8];
	<span class="enscript-type">int</span> left, left8, remain;


	bzero(ivec, 8);

	<span class="enscript-comment">/*
	 * Move down the mbuf chain until we reach the given
	 * byte offset, then start encrypting the mbuf data until
	 * we've done len bytes.
	 */</span>

	<span class="enscript-keyword">for</span> (mb = mhead; mb &amp;&amp; len &gt; 0; mb = mbn) {
		mbn  = mbuf_next(mb);
		ptr  = mbuf_data(mb);
		left = mbuf_len(mb);
		<span class="enscript-keyword">if</span> (offset &gt;= left) {
			<span class="enscript-comment">/* Offset not yet reached */</span>
			offset -= left;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/* At or beyond offset - encrypt data */</span>
		ptr += offset;
		left -= offset;
		offset = 0;
			
		<span class="enscript-comment">/*
		 * DES or DES3 CBC has to encrypt 8 bytes at a time.
		 * If the number of bytes to be encrypted in this
		 * mbuf isn't some multiple of 8 bytes, encrypt all
		 * the 8 byte blocks, then combine the remaining
		 * bytes with enough from the next mbuf to make up
		 * an 8 byte block and encrypt that block separately,
		 * i.e. that block is split across two mbufs.
		 */</span>
		remain = left % 8;
		left8 = left - remain;
		left = left8 &lt; len ? left8 : len;
		<span class="enscript-keyword">if</span> (left &gt; 0) {
			gss_des_crypt(ki, (des_cblock *) ptr, (des_cblock *) ptr,
					left, &amp;ivec, &amp;ivec, encrypt, KG_USAGE_SEAL);
			len -= left;
		}

		<span class="enscript-keyword">if</span> (mbn &amp;&amp; remain &gt; 0) {
			nptr = mbuf_data(mbn);
			offset = 8 - remain;
			bcopy(ptr + left, tmp, remain);		<span class="enscript-comment">// grab from this mbuf
</span>			bcopy(nptr, tmp + remain, offset);	<span class="enscript-comment">// grab from next mbuf
</span>			gss_des_crypt(ki, (des_cblock *) tmp, (des_cblock *) tmp, 8,
					&amp;ivec, &amp;ivec, encrypt, KG_USAGE_SEAL);
			bcopy(tmp, ptr + left, remain);		<span class="enscript-comment">// return to this mbuf
</span>			bcopy(tmp + remain, nptr, offset);	<span class="enscript-comment">// return to next mbuf
</span>			len -= 8;
		}
	}
}

<span class="enscript-comment">/*
 * Encrypt or decrypt data in an NFS mbuf chain with des-cbc.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_gss_encrypt_chain</span>(
	gss_key_info *ki,
	<span class="enscript-type">struct</span> nfsm_chain *nmc,
	<span class="enscript-type">int</span> offset,
	<span class="enscript-type">int</span> len,
	<span class="enscript-type">int</span> encrypt)
{
	<span class="enscript-comment">/*
	 * If the length parameter is zero, then we need
	 * to use the length from the offset to the current
	 * encode/decode offset.
	 */</span>
	<span class="enscript-keyword">if</span> (len == 0)
		len = nfsm_chain_offset(nmc) - offset;

	<span class="enscript-keyword">return</span> (nfs_gss_encrypt_mchain(ki, nmc-&gt;nmc_mhead, offset, len, encrypt));
}

<span class="enscript-comment">/*
 * The routines that follow provide abstractions for doing digests and crypto.
 */</span>
 
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gss_digest_Init</span>(GSS_DIGEST_CTX *ctx, gss_key_info *ki)
{
	ctx-&gt;type = ki-&gt;type;
	<span class="enscript-keyword">switch</span> (ki-&gt;type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_GSS_1DES</span>:	MD5_DESCBC_Init(&amp;ctx-&gt;m_ctx, &amp;ki-&gt;ks_u.des.gss_sched);
				<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_GSS_3DES</span>:	HMAC_SHA1_DES3KD_Init(&amp;ctx-&gt;h_ctx, ki-&gt;ks_u.des3.ckey, 0);
				<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
			printf(<span class="enscript-string">&quot;gss_digest_Init: Unknown key info type %d\n&quot;</span>, ki-&gt;type);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gss_digest_Update</span>(GSS_DIGEST_CTX *ctx, <span class="enscript-type">void</span> *data, size_t len)
{
	<span class="enscript-keyword">switch</span> (ctx-&gt;type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_GSS_1DES</span>:	MD5_DESCBC_Update(&amp;ctx-&gt;m_ctx, data, len);
				<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_GSS_3DES</span>:	HMAC_SHA1_DES3KD_Update(&amp;ctx-&gt;h_ctx, data, len);
				<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gss_digest_Final</span>(GSS_DIGEST_CTX *ctx, <span class="enscript-type">void</span> *digest)
{
	<span class="enscript-keyword">switch</span> (ctx-&gt;type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_GSS_1DES</span>:	MD5_DESCBC_Final(digest, &amp;ctx-&gt;m_ctx);
				<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_GSS_3DES</span>:	HMAC_SHA1_DES3KD_Final(digest, &amp;ctx-&gt;h_ctx);
				<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">gss_des_crypt</span>(gss_key_info *ki, des_cblock *in, des_cblock *out,
		int32_t len, des_cblock *iv, des_cblock *retiv, <span class="enscript-type">int</span> encrypt, <span class="enscript-type">int</span> usage)
{
	<span class="enscript-keyword">switch</span> (ki-&gt;type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_GSS_1DES</span>:
			{
				des_cbc_key_schedule *sched = ((usage == KG_USAGE_SEAL) ?
							&amp;ki-&gt;ks_u.des.gss_sched_Ke :
							&amp;ki-&gt;ks_u.des.gss_sched);
				des_cbc_encrypt(in, out, len, sched, iv, retiv, encrypt);
			}
			<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_GSS_3DES</span>:

			des3_cbc_encrypt(in, out, len, &amp;ki-&gt;ks_u.des3.gss_sched, iv, retiv, encrypt);
			<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">gss_key_init</span>(gss_key_info *ki, uint32_t skeylen)
{
	size_t i;
	<span class="enscript-type">int</span> rc;
	des_cblock k[3];

	ki-&gt;keybytes = skeylen;
	<span class="enscript-keyword">switch</span> (skeylen) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">sizeof</span>(des_cblock):
				ki-&gt;type = NFS_GSS_1DES;
				ki-&gt;hash_len = MD5_DESCBC_DIGEST_LENGTH;
				ki-&gt;ks_u.des.key = (des_cblock *)ki-&gt;skey;
				rc = des_cbc_key_sched(ki-&gt;ks_u.des.key, &amp;ki-&gt;ks_u.des.gss_sched);
				<span class="enscript-keyword">if</span> (rc)
					<span class="enscript-keyword">return</span> (rc);
				<span class="enscript-keyword">for</span> (i = 0; i &lt; ki-&gt;keybytes; i++)
					k[0][i] = 0xf0 ^ (*ki-&gt;ks_u.des.key)[i];
				rc = des_cbc_key_sched(&amp;k[0], &amp;ki-&gt;ks_u.des.gss_sched_Ke);
				<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>*<span class="enscript-keyword">sizeof</span>(des_cblock):	
				ki-&gt;type = NFS_GSS_3DES;
				ki-&gt;hash_len = SHA_DIGEST_LENGTH;
				ki-&gt;ks_u.des3.key = (des_cblock (*)[3])ki-&gt;skey;
				des3_derive_key(*ki-&gt;ks_u.des3.key, ki-&gt;ks_u.des3.ckey,
						KEY_USAGE_DES3_SIGN, KEY_USAGE_LEN);
				rc = des3_cbc_key_sched(*ki-&gt;ks_u.des3.key, &amp;ki-&gt;ks_u.des3.gss_sched);
				<span class="enscript-keyword">if</span> (rc)
					<span class="enscript-keyword">return</span> (rc);
				<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
				printf(<span class="enscript-string">&quot;gss_key_init: Invalid key length %d\n&quot;</span>, skeylen);
				rc = EINVAL;
				<span class="enscript-keyword">break</span>;
	}
	
	<span class="enscript-keyword">return</span> (rc);
}

#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DISPLAYLEN</span> 16
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAXDISPLAYLEN</span> 256

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">hexdump</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg, <span class="enscript-type">void</span> *data, size_t len)
{
	size_t i, j;
	u_char *d = data;
	<span class="enscript-type">char</span> *p, disbuf[3*DISPLAYLEN+1];
	
	printf(<span class="enscript-string">&quot;NFS DEBUG %s len=%d:\n&quot;</span>, msg, (uint32_t)len);
	<span class="enscript-keyword">if</span> (len &gt; MAXDISPLAYLEN)
		len = MAXDISPLAYLEN;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; len; i += DISPLAYLEN) {
		<span class="enscript-keyword">for</span> (p = disbuf, j = 0; (j + i) &lt; len &amp;&amp; j &lt; DISPLAYLEN; j++, p += 3)
			snprintf(p, 4, <span class="enscript-string">&quot;%02x &quot;</span>, d[i + j]);
		printf(<span class="enscript-string">&quot;\t%s\n&quot;</span>, disbuf);
	}
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>