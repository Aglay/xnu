<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nfs_gss_crypto.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nfs_gss_crypto.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>


<span class="enscript-comment">/*
 * Copyright (C) 1998 by the FundsXpress, INC.
 * 
 * All rights reserved.
 * 
 * Export of this software from the United States of America may require
 * a specific license from the United States Government.  It is the
 * responsibility of any person or organization contemplating export to
 * obtain such a license before exporting.
 * 
 * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and
 * distribute this software and its documentation for any purpose and
 * without fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation, and that
 * the name of FundsXpress. not be used in advertising or publicity pertaining
 * to distribution of the software without specific, written prior
 * permission.  FundsXpress makes no representations about the suitability of
 * this software for any purpose.  It is provided &quot;as is&quot; without express
 * or implied warranty.
 * 
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;nfs_gss_crypto.h&quot;</span>


<span class="enscript-comment">/*
n-fold(k-bits):
  l = lcm(n,k)
  r = l/k
  s = k-bits | k-bits rot 13 | k-bits rot 13*2 | ... | k-bits rot 13*(r-1)
  compute the 1's complement sum:
	n-fold = s[0..n-1]+s[n..2n-1]+s[2n..3n-1]+..+s[(k-1)*n..k*n-1]
*/</span>

<span class="enscript-comment">/* representation: msb first, assume n and k are multiples of 8, and
   that k&gt;=16.  this is the case of all the cryptosystems which are
   likely to be used.  this function can be replaced if that
   assumption ever fails.  */</span>

<span class="enscript-comment">/* input length is in bits */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">krb5_nfold</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> inbits, <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *in, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> outbits,
	   <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *out)
{
    <span class="enscript-type">int</span> a,b,c,lcm;
    <span class="enscript-type">int</span> byte, i, msbit;

    <span class="enscript-comment">/* the code below is more readable if I make these bytes
       instead of bits */</span>

    inbits &gt;&gt;= 3;
    outbits &gt;&gt;= 3;

    <span class="enscript-comment">/* first compute lcm(n,k) */</span>

    a = outbits;
    b = inbits;

    <span class="enscript-keyword">while</span>(b != 0) {
	c = b;
	b = a%b;
	a = c;
    }

    lcm = outbits*inbits/a;

    <span class="enscript-comment">/* now do the real work */</span>

    memset(out, 0, outbits);
    byte = 0;

    <span class="enscript-comment">/* this will end up cycling through k lcm(k,n)/k times, which
       is correct */</span>
    <span class="enscript-keyword">for</span> (i=lcm-1; i&gt;=0; i--) {
	<span class="enscript-comment">/* compute the msbit in k which gets added into this byte */</span>
	msbit = (<span class="enscript-comment">/* first, start with the msbit in the first, unrotated
		    byte */</span>
		 ((inbits&lt;&lt;3)-1)
		 <span class="enscript-comment">/* then, for each byte, shift to the right for each
		    repetition */</span>
		 +(((inbits&lt;&lt;3)+13)*(i/inbits))
		 <span class="enscript-comment">/* last, pick out the correct byte within that
		    shifted repetition */</span>
		 +((inbits-(i%inbits))&lt;&lt;3)
		 )%(inbits&lt;&lt;3);

	<span class="enscript-comment">/* pull out the byte value itself */</span>
	byte += (((in[((inbits-1)-(msbit&gt;&gt;3))%inbits]&lt;&lt;8)|
		  (in[((inbits)-(msbit&gt;&gt;3))%inbits]))
		 &gt;&gt;((msbit&amp;7)+1))&amp;0xff;

	<span class="enscript-comment">/* do the addition */</span>
	byte += out[i%outbits];
	out[i%outbits] = byte&amp;0xff;

#<span class="enscript-reference">if</span> 0
	printf(<span class="enscript-string">&quot;msbit[%d] = %d\tbyte = %02x\tsum = %03x\n&quot;</span>, i, msbit,
	       (((in[((inbits-1)-(msbit&gt;&gt;3))%inbits]&lt;&lt;8)|
		 (in[((inbits)-(msbit&gt;&gt;3))%inbits]))
		&gt;&gt;((msbit&amp;7)+1))&amp;0xff, byte);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* keep around the carry bit, if any */</span>
	byte &gt;&gt;= 8;

#<span class="enscript-reference">if</span> 0
	printf(<span class="enscript-string">&quot;carry=%d\n&quot;</span>, byte);
#<span class="enscript-reference">endif</span>
    }

    <span class="enscript-comment">/* if there's a carry bit left over, add it back in */</span>
    <span class="enscript-keyword">if</span> (byte) {
	<span class="enscript-keyword">for</span> (i=outbits-1; i&gt;=0; i--) {
	    <span class="enscript-comment">/* do the addition */</span>
	    byte += out[i];
	    out[i] = byte&amp;0xff;

	    <span class="enscript-comment">/* keep around the carry bit, if any */</span>
	    byte &gt;&gt;= 8;
	}
    }
}

<span class="enscript-comment">/*
 * Given 21 bytes of random bits, make a triple DES key.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">des3_make_key</span>(<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> randombits[21], des_cblock key[3])
{
	<span class="enscript-type">int</span> i;
	
	<span class="enscript-keyword">for</span> (i = 0; i &lt; 3; i++) {
		memcpy(&amp;key[i], &amp;randombits[i*7], 7);
		key[i][7] = (((key[i][0] &amp; 1) &lt;&lt; 1) |
			     ((key[i][1] &amp; 1) &lt;&lt; 2) |
			     ((key[i][2] &amp; 1) &lt;&lt; 3) |
			     ((key[i][3] &amp; 1) &lt;&lt; 4) |
			     ((key[i][4] &amp; 1) &lt;&lt; 5) |
			     ((key[i][5] &amp; 1) &lt;&lt; 6) |
			     ((key[i][6] &amp; 1) &lt;&lt; 7));
		des_fixup_key_parity(&amp;key[i]);
	}
}

<span class="enscript-comment">/*
 * Key derivation for triple DES.
 * Given the session key in in key, produce a new key in out key using
 * the supplied constant.
 */</span>
 
<span class="enscript-type">int</span>
<span class="enscript-function-name">des3_derive_key</span>(des_cblock inkey[3], des_cblock outkey[3],
		<span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *constant, <span class="enscript-type">int</span> clen)
{
	des_cblock inblock, outblock, ivec;
	des3_cbc_key_schedule sched;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> rawkey[21];
	size_t n, keybytes = <span class="enscript-keyword">sizeof</span>(rawkey);

	<span class="enscript-comment">/* initialize the input block */</span>

	<span class="enscript-keyword">if</span> (clen == <span class="enscript-keyword">sizeof</span>(des_cblock)) {
		memcpy(inblock, constant, clen);
	} <span class="enscript-keyword">else</span> {
		krb5_nfold(clen*8, constant, <span class="enscript-keyword">sizeof</span>(des_cblock)*8, inblock);
	}

	<span class="enscript-comment">/* loop encrypting the blocks until enough key bytes are generated */</span>

	bzero(ivec, <span class="enscript-keyword">sizeof</span>(ivec));
	des3_cbc_key_sched(inkey, &amp;sched);
	<span class="enscript-keyword">for</span> (n = 0; n &lt; <span class="enscript-keyword">sizeof</span>(rawkey); n += <span class="enscript-keyword">sizeof</span>(des_cblock)) {
		des3_cbc_encrypt(&amp;inblock, &amp;outblock, <span class="enscript-keyword">sizeof</span>(outblock), &amp;sched, &amp;ivec, NULL, 1);
		<span class="enscript-keyword">if</span> ((keybytes - n) &lt;= <span class="enscript-keyword">sizeof</span> (des_cblock)) {
			memcpy(rawkey+n, outblock, (keybytes - n));
			<span class="enscript-keyword">break</span>;
		}
		memcpy(rawkey+n, outblock, <span class="enscript-keyword">sizeof</span>(des_cblock));
		memcpy(inblock, outblock, <span class="enscript-keyword">sizeof</span>(des_cblock));
	}

	<span class="enscript-comment">/* postprocess the key */</span>
	des3_make_key(rawkey, outkey);

	<span class="enscript-comment">/* clean memory, free resources and exit */</span>

	bzero(inblock, <span class="enscript-keyword">sizeof</span> (des_cblock));
	bzero(outblock, <span class="enscript-keyword">sizeof</span> (des_cblock));
	bzero(rawkey, keybytes);
	bzero(&amp;sched, <span class="enscript-keyword">sizeof</span> (sched));

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Initialize a context for HMAC SHA1
 * if drived is true we derive a new key
 * based on KG_USAGE_SIGN
 */</span>
 
<span class="enscript-type">void</span>
<span class="enscript-function-name">HMAC_SHA1_DES3KD_Init</span>(HMAC_SHA1_DES3KD_CTX *ctx, des_cblock key[3], <span class="enscript-type">int</span> derive)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> ipad[64];
	size_t i, j;
	
	SHA1Init(&amp;ctx-&gt;sha1_ctx);
	<span class="enscript-keyword">if</span> (derive)
		des3_derive_key(key, ctx-&gt;dk, KEY_USAGE_DES3_SIGN, KEY_USAGE_LEN);
	<span class="enscript-keyword">else</span>
		memcpy(ctx-&gt;dk, key, 3*<span class="enscript-keyword">sizeof</span>(des_cblock));
	memset(ipad, 0x36, <span class="enscript-keyword">sizeof</span>(ipad));
	<span class="enscript-keyword">for</span> (i = 0; i &lt; 3; i++)
		<span class="enscript-keyword">for</span> (j = 0; j &lt; <span class="enscript-keyword">sizeof</span>(des_cblock); j++)
			ipad[j + i * <span class="enscript-keyword">sizeof</span>(des_cblock)] ^= ctx-&gt;dk[i][j];
	SHA1Update(&amp;ctx-&gt;sha1_ctx, ipad, <span class="enscript-keyword">sizeof</span>(ipad));
}

<span class="enscript-comment">/*
 * Update the HMAC SHA1 context with the supplied data.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">HMAC_SHA1_DES3KD_Update</span>(HMAC_SHA1_DES3KD_CTX *ctx, <span class="enscript-type">void</span> *data, size_t len)
{
	SHA1Update(&amp;ctx-&gt;sha1_ctx, data, len);
}

<span class="enscript-comment">/*
 * Finish the context and produce the HMAC SHA1 digest.
 */</span>
 
<span class="enscript-type">void</span>
<span class="enscript-function-name">HMAC_SHA1_DES3KD_Final</span>(<span class="enscript-type">void</span> *digest, HMAC_SHA1_DES3KD_CTX *ctx)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> opad[64];
	size_t i, j;

	SHA1Final(digest, &amp;ctx-&gt;sha1_ctx);
	memset(opad, 0x5c, <span class="enscript-keyword">sizeof</span>(opad));
	<span class="enscript-keyword">for</span> (i = 0; i &lt; 3; i++)
		<span class="enscript-keyword">for</span> (j = 0; j &lt; <span class="enscript-keyword">sizeof</span>(des_cblock); j++)
			opad[j + i * <span class="enscript-keyword">sizeof</span>(des_cblock)] ^= ctx-&gt;dk[i][j];
	SHA1Init(&amp;ctx-&gt;sha1_ctx);
	SHA1Update(&amp;ctx-&gt;sha1_ctx, opad, <span class="enscript-keyword">sizeof</span>(opad));
	SHA1Update(&amp;ctx-&gt;sha1_ctx, digest, SHA1_RESULTLEN);
	SHA1Final(digest, &amp;ctx-&gt;sha1_ctx);
}

<span class="enscript-comment">/*
 * Initialize an MD5 DES CBC context with a schedule.
 */</span>
 
<span class="enscript-type">void</span> <span class="enscript-function-name">MD5_DESCBC_Init</span>(MD5_DESCBC_CTX *ctx, des_cbc_key_schedule *sched)
{
	MD5Init(&amp;ctx-&gt;md5_ctx);
	ctx-&gt;sched = sched;
}

<span class="enscript-comment">/*
 * Update MD5 DES CBC context with the supplied data.
 */</span>
 
<span class="enscript-type">void</span> <span class="enscript-function-name">MD5_DESCBC_Update</span>(MD5_DESCBC_CTX *ctx, <span class="enscript-type">void</span> *data, size_t len)
{
	MD5Update(&amp;ctx-&gt;md5_ctx, data, len);
}

<span class="enscript-comment">/*
 * Finalize the context and extract the digest.
 */</span>
 
<span class="enscript-type">void</span> <span class="enscript-function-name">MD5_DESCBC_Final</span>(<span class="enscript-type">void</span> *digest, MD5_DESCBC_CTX *ctx)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> md5_digest[MD5_DIGEST_LENGTH];
	
	MD5Final(md5_digest, &amp;ctx-&gt;md5_ctx);
	
	<span class="enscript-comment">/*
	 * Now get the DES CBC checksum for the digest.
	 */</span>
	des_cbc_cksum((des_cblock *) md5_digest, (des_cblock *)digest,
				<span class="enscript-keyword">sizeof</span> (md5_digest), ctx-&gt;sched);
}	

</pre>
<hr />
</body></html>