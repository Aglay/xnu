<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>nfs_socket.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">nfs_socket.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1989, 1991, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Rick Macklem at The University of Guelph.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)nfs_socket.c	8.5 (Berkeley) 3/30/95
 * FreeBSD-Id: nfs_socket.c,v 1.30 1997/10/28 15:59:07 bde Exp $
 */</span>

<span class="enscript-comment">/*
 * Socket operations for use by nfs
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/tprintf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/acct.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/rpcv2.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/krpc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/xdr_subs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsm_subs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfs_gss.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsmount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;nfs/nfsnode.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">NFS_SOCK_DBG</span>(...) NFS_DBG(NFS_FAC_SOCK, 7, ## __VA_ARGS__)

<span class="enscript-comment">/* XXX */</span>
boolean_t	current_thread_aborted(<span class="enscript-type">void</span>);
kern_return_t	thread_terminate(thread_t);


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>
<span class="enscript-type">int</span> nfsrv_sock_max_rec_queue_length = 128; <span class="enscript-comment">/* max # RPC records queued on (UDP) socket */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">nfsrv_getstream</span>(<span class="enscript-type">struct</span> nfsrv_sock *,<span class="enscript-type">int</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">nfsrv_getreq</span>(<span class="enscript-type">struct</span> nfsrv_descript *);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nfsv3_procid[NFS_NPROCS];
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>

<span class="enscript-comment">/*
 * compare two sockaddr structures
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_sockaddr_cmp</span>(<span class="enscript-type">struct</span> sockaddr *sa1, <span class="enscript-type">struct</span> sockaddr *sa2)
{
	<span class="enscript-keyword">if</span> (!sa1)
		<span class="enscript-keyword">return</span> (-1);
	<span class="enscript-keyword">if</span> (!sa2)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">if</span> (sa1-&gt;sa_family != sa2-&gt;sa_family)
		<span class="enscript-keyword">return</span> ((sa1-&gt;sa_family &lt; sa2-&gt;sa_family) ? -1 : 1);
	<span class="enscript-keyword">if</span> (sa1-&gt;sa_len != sa2-&gt;sa_len)
		<span class="enscript-keyword">return</span> ((sa1-&gt;sa_len &lt; sa2-&gt;sa_len) ? -1 : 1);
	<span class="enscript-keyword">if</span> (sa1-&gt;sa_family == AF_INET)
		<span class="enscript-keyword">return</span> (bcmp(&amp;((<span class="enscript-type">struct</span> sockaddr_in*)sa1)-&gt;sin_addr,
			     &amp;((<span class="enscript-type">struct</span> sockaddr_in*)sa2)-&gt;sin_addr, <span class="enscript-keyword">sizeof</span>(((<span class="enscript-type">struct</span> sockaddr_in*)sa1)-&gt;sin_addr)));
	<span class="enscript-keyword">if</span> (sa1-&gt;sa_family == AF_INET6)
		<span class="enscript-keyword">return</span> (bcmp(&amp;((<span class="enscript-type">struct</span> sockaddr_in6*)sa1)-&gt;sin6_addr,
			     &amp;((<span class="enscript-type">struct</span> sockaddr_in6*)sa2)-&gt;sin6_addr, <span class="enscript-keyword">sizeof</span>(((<span class="enscript-type">struct</span> sockaddr_in6*)sa1)-&gt;sin6_addr)));
	<span class="enscript-keyword">return</span> (-1);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>

<span class="enscript-type">int</span>	nfs_connect_search_new_socket(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">struct</span> nfs_socket_search *, <span class="enscript-type">struct</span> timeval *);
<span class="enscript-type">int</span>	nfs_connect_search_socket_connect(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">struct</span> nfs_socket *, <span class="enscript-type">int</span>);
<span class="enscript-type">int</span>	nfs_connect_search_ping(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">struct</span> nfs_socket *, <span class="enscript-type">struct</span> timeval *);
<span class="enscript-type">void</span>	nfs_connect_search_socket_found(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">struct</span> nfs_socket_search *, <span class="enscript-type">struct</span> nfs_socket *);
<span class="enscript-type">void</span>	nfs_connect_search_socket_reap(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">struct</span> nfs_socket_search *, <span class="enscript-type">struct</span> timeval *);
<span class="enscript-type">int</span>	nfs_connect_search_check(<span class="enscript-type">struct</span> nfsmount *, <span class="enscript-type">struct</span> nfs_socket_search *, <span class="enscript-type">struct</span> timeval *);
<span class="enscript-type">int</span>	nfs_reconnect(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">int</span>	nfs_connect_setup(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">void</span>	nfs_mount_sock_thread(<span class="enscript-type">void</span> *, wait_result_t);
<span class="enscript-type">void</span>	nfs_udp_rcv(socket_t, <span class="enscript-type">void</span>*, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs_tcp_rcv(socket_t, <span class="enscript-type">void</span>*, <span class="enscript-type">int</span>);
<span class="enscript-type">void</span>	nfs_sock_poke(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">void</span>	nfs_request_match_reply(<span class="enscript-type">struct</span> nfsmount *, mbuf_t);
<span class="enscript-type">void</span>	nfs_reqdequeue(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">void</span>	nfs_reqbusy(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">struct</span> nfsreq *<span class="enscript-function-name">nfs_reqnext</span>(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">int</span>	nfs_wait_reply(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">void</span>	nfs_softterm(<span class="enscript-type">struct</span> nfsreq *);
<span class="enscript-type">int</span>	nfs_can_squish(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">int</span>	nfs_is_squishy(<span class="enscript-type">struct</span> nfsmount *);
<span class="enscript-type">int</span>	nfs_is_dead(<span class="enscript-type">int</span>, <span class="enscript-type">struct</span> nfsmount *);

<span class="enscript-comment">/*
 * Estimate rto for an nfs rpc sent via. an unreliable datagram.
 * Use the mean and mean deviation of rtt for the appropriate type of rpc
 * for the frequent rpcs and a default for the others.
 * The justification for doing &quot;other&quot; this way is that these rpcs
 * happen so infrequently that timer est. would probably be stale.
 * Also, since many of these rpcs are
 * non-idempotent, a conservative timeout is desired.
 * getattr, lookup - A+2D
 * read, write     - A+4D
 * other	   - nm_timeo
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NFS_RTO</span>(n, t) \
	((t) == 0 ? (n)-&gt;nm_timeo : \
	 ((t) &lt; 3 ? \
	  (((((n)-&gt;nm_srtt[t-1] + 3) &gt;&gt; 2) + (n)-&gt;nm_sdrtt[t-1] + 1) &gt;&gt; 1) : \
	  ((((n)-&gt;nm_srtt[t-1] + 7) &gt;&gt; 3) + (n)-&gt;nm_sdrtt[t-1] + 1)))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NFS_SRTT</span>(r)	(r)-&gt;r_nmp-&gt;nm_srtt[proct[(r)-&gt;r_procnum] - 1]
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NFS_SDRTT</span>(r)	(r)-&gt;r_nmp-&gt;nm_sdrtt[proct[(r)-&gt;r_procnum] - 1]

<span class="enscript-comment">/*
 * Defines which timer to use for the procnum.
 * 0 - default
 * 1 - getattr
 * 2 - lookup
 * 3 - read
 * 4 - write
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> proct[NFS_NPROCS] = {
	0, 1, 0, 2, 1, 3, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0
};

<span class="enscript-comment">/*
 * There is a congestion window for outstanding rpcs maintained per mount
 * point. The cwnd size is adjusted in roughly the way that:
 * Van Jacobson, Congestion avoidance and Control, In &quot;Proceedings of
 * SIGCOMM '88&quot;. ACM, August 1988.
 * describes for TCP. The cwnd size is chopped in half on a retransmit timeout
 * and incremented by 1/cwnd when each rpc reply is received and a full cwnd
 * of rpcs is in progress.
 * (The sent count and cwnd are scaled for integer arith.)
 * Variants of &quot;slow start&quot; were tried and were found to be too much of a
 * performance hit (ave. rtt 3 times larger),
 * I suspect due to the large rtt that nfs rpcs have.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_CWNDSCALE</span>	256
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_MAXCWND</span>	(NFS_CWNDSCALE * 32)
<span class="enscript-type">static</span> <span class="enscript-type">int</span> nfs_backoff[8] = { 2, 4, 8, 16, 32, 64, 128, 256, };

<span class="enscript-comment">/*
 * Increment location index to next address/server/location.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_location_next</span>(<span class="enscript-type">struct</span> nfs_fs_locations *nlp, <span class="enscript-type">struct</span> nfs_location_index *nlip)
{
	uint8_t loc = nlip-&gt;nli_loc;
	uint8_t serv = nlip-&gt;nli_serv;
	uint8_t addr = nlip-&gt;nli_addr;

	<span class="enscript-comment">/* move to next address */</span>
	addr++;
	<span class="enscript-keyword">if</span> (addr &gt;= nlp-&gt;nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_addrcount) {
		<span class="enscript-comment">/* no more addresses on current server, go to first address of next server */</span>
<span class="enscript-reference">next_server</span>:
		addr = 0;
		serv++;
		<span class="enscript-keyword">if</span> (serv &gt;= nlp-&gt;nl_locations[loc]-&gt;nl_servcount) {
			<span class="enscript-comment">/* no more servers on current location, go to first server of next location */</span>
			serv = 0;
			loc++;
			<span class="enscript-keyword">if</span> (loc &gt;= nlp-&gt;nl_numlocs)
				loc = 0; <span class="enscript-comment">/* after last location, wrap back around to first location */</span>
		}
	}
	<span class="enscript-comment">/*
	 * It's possible for this next server to not have any addresses.
	 * Check for that here and go to the next server.
	 * But bail out if we've managed to come back around to the original
	 * location that was passed in. (That would mean no servers had any
	 * addresses.  And we don't want to spin here forever.)
	 */</span>
	<span class="enscript-keyword">if</span> ((loc == nlip-&gt;nli_loc) &amp;&amp; (serv == nlip-&gt;nli_serv) &amp;&amp; (addr == nlip-&gt;nli_addr))
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> (addr &gt;= nlp-&gt;nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_addrcount)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">next_server</span>;

	nlip-&gt;nli_loc = loc;
	nlip-&gt;nli_serv = serv;
	nlip-&gt;nli_addr = addr;
}

<span class="enscript-comment">/*
 * Compare two location indices.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_location_index_cmp</span>(<span class="enscript-type">struct</span> nfs_location_index *nlip1, <span class="enscript-type">struct</span> nfs_location_index *nlip2)
{
	<span class="enscript-keyword">if</span> (nlip1-&gt;nli_loc != nlip2-&gt;nli_loc)
		<span class="enscript-keyword">return</span> (nlip1-&gt;nli_loc - nlip2-&gt;nli_loc);
	<span class="enscript-keyword">if</span> (nlip1-&gt;nli_serv != nlip2-&gt;nli_serv)
		<span class="enscript-keyword">return</span> (nlip1-&gt;nli_serv - nlip2-&gt;nli_serv);
	<span class="enscript-keyword">return</span> (nlip1-&gt;nli_addr - nlip2-&gt;nli_addr);
}

<span class="enscript-comment">/*
 * Get the mntfromname (or path portion only) for a given location.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_location_mntfromname</span>(<span class="enscript-type">struct</span> nfs_fs_locations *locs, <span class="enscript-type">struct</span> nfs_location_index idx, <span class="enscript-type">char</span> *s, <span class="enscript-type">int</span> size, <span class="enscript-type">int</span> pathonly)
{
	<span class="enscript-type">struct</span> nfs_fs_location *fsl = locs-&gt;nl_locations[idx.nli_loc];
	<span class="enscript-type">char</span> *p;
	<span class="enscript-type">int</span> cnt, i;

	p = s;
	<span class="enscript-keyword">if</span> (!pathonly) {
		cnt = snprintf(p, size, <span class="enscript-string">&quot;%s:&quot;</span>, fsl-&gt;nl_servers[idx.nli_serv]-&gt;ns_name);
		p += cnt;
		size -= cnt;
	}
	<span class="enscript-keyword">if</span> (fsl-&gt;nl_path.np_compcount == 0) {
		<span class="enscript-comment">/* mounting root export on server */</span>
		<span class="enscript-keyword">if</span> (size &gt; 0) {
			*p++ = <span class="enscript-string">'/'</span>;
			*p++ = <span class="enscript-string">'\0'</span>;
		}
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">/* append each server path component */</span>
	<span class="enscript-keyword">for</span> (i=0; (size &gt; 0) &amp;&amp; (i &lt; (<span class="enscript-type">int</span>)fsl-&gt;nl_path.np_compcount); i++) {
		cnt = snprintf(p, size, <span class="enscript-string">&quot;/%s&quot;</span>, fsl-&gt;nl_path.np_components[i]);
		p += cnt;
		size -= cnt;
	}
}

<span class="enscript-comment">/*
 * NFS client connect socket upcall.
 * (Used only during socket connect/search.)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_connect_upcall</span>(socket_t so, <span class="enscript-type">void</span> *arg, __unused <span class="enscript-type">int</span> waitflag)
{
	<span class="enscript-type">struct</span> nfs_socket *nso = arg;
	size_t rcvlen;
	mbuf_t m;
	<span class="enscript-type">int</span> error = 0, recv = 1;

	<span class="enscript-keyword">if</span> (nso-&gt;nso_flags &amp; NSO_CONNECTING) {
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect - socket %p upcall - connecting\n&quot;</span>, nso);
		wakeup(nso-&gt;nso_wake);
		<span class="enscript-keyword">return</span>;
	}

	lck_mtx_lock(&amp;nso-&gt;nso_lock);
	<span class="enscript-keyword">if</span> ((nso-&gt;nso_flags &amp; (NSO_UPCALL|NSO_DISCONNECTING|NSO_DEAD)) || !(nso-&gt;nso_flags &amp; NSO_PINGING)) {
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect - socket %p upcall - nevermind\n&quot;</span>, nso);
		lck_mtx_unlock(&amp;nso-&gt;nso_lock);
		<span class="enscript-keyword">return</span>;
	}
	NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect - socket %p upcall\n&quot;</span>, nso);
	nso-&gt;nso_flags |= NSO_UPCALL;

	<span class="enscript-comment">/* loop while we make error-free progress */</span>
	<span class="enscript-keyword">while</span> (!error &amp;&amp; recv) {
		<span class="enscript-comment">/* make sure we're still interested in this socket */</span>
		<span class="enscript-keyword">if</span> (nso-&gt;nso_flags &amp; (NSO_DISCONNECTING|NSO_DEAD))
			<span class="enscript-keyword">break</span>;
		lck_mtx_unlock(&amp;nso-&gt;nso_lock);
		m = NULL;
		<span class="enscript-keyword">if</span> (nso-&gt;nso_sotype == SOCK_STREAM) {
			error = nfs_rpc_record_read(so, &amp;nso-&gt;nso_rrs, MSG_DONTWAIT, &amp;recv, &amp;m);
		} <span class="enscript-keyword">else</span> {
			rcvlen = 1000000;
			error = sock_receivembuf(so, NULL, &amp;m, MSG_DONTWAIT, &amp;rcvlen);
			recv = m ? 1 : 0;
		}
		lck_mtx_lock(&amp;nso-&gt;nso_lock);
		<span class="enscript-keyword">if</span> (m) {
			<span class="enscript-comment">/* match response with request */</span>
			<span class="enscript-type">struct</span> nfsm_chain nmrep;
			uint32_t reply = 0, rxid = 0, verf_type, verf_len;
			uint32_t reply_status, rejected_status, accepted_status;

			nfsm_chain_dissect_init(error, &amp;nmrep, m);
			nfsm_chain_get_32(error, &amp;nmrep, rxid);
			nfsm_chain_get_32(error, &amp;nmrep, reply);
			<span class="enscript-keyword">if</span> (!error &amp;&amp; ((reply != RPC_REPLY) || (rxid != nso-&gt;nso_pingxid)))
				error = EBADRPC;
			nfsm_chain_get_32(error, &amp;nmrep, reply_status);
			<span class="enscript-keyword">if</span> (!error &amp;&amp; (reply_status == RPC_MSGDENIED)) {
				nfsm_chain_get_32(error, &amp;nmrep, rejected_status);
				<span class="enscript-keyword">if</span> (!error)
					error = (rejected_status == RPC_MISMATCH) ? ERPCMISMATCH : EACCES;
			}
			nfsm_chain_get_32(error, &amp;nmrep, verf_type); <span class="enscript-comment">/* verifier flavor */</span>
			nfsm_chain_get_32(error, &amp;nmrep, verf_len); <span class="enscript-comment">/* verifier length */</span>
			nfsmout_if(error);
			<span class="enscript-keyword">if</span> (verf_len)
				nfsm_chain_adv(error, &amp;nmrep, nfsm_rndup(verf_len));
			nfsm_chain_get_32(error, &amp;nmrep, accepted_status);
			nfsmout_if(error);
			<span class="enscript-keyword">if</span> ((accepted_status == RPC_PROGMISMATCH) &amp;&amp; !nso-&gt;nso_version) {
				uint32_t minvers, maxvers;
				nfsm_chain_get_32(error, &amp;nmrep, minvers);
				nfsm_chain_get_32(error, &amp;nmrep, maxvers);
				nfsmout_if(error);
				<span class="enscript-keyword">if</span> (nso-&gt;nso_protocol == PMAPPROG) {
					<span class="enscript-keyword">if</span> ((minvers &gt; RPCBVERS4) || (maxvers &lt; PMAPVERS))
						error = EPROGMISMATCH;
					<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((nso-&gt;nso_saddr-&gt;sa_family == AF_INET) &amp;&amp;
						 (PMAPVERS &gt;= minvers) &amp;&amp; (PMAPVERS &lt;= maxvers))
						nso-&gt;nso_version = PMAPVERS;
					<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nso-&gt;nso_saddr-&gt;sa_family == AF_INET6) {
						<span class="enscript-keyword">if</span> ((RPCBVERS4 &gt;= minvers) &amp;&amp; (RPCBVERS4 &lt;= maxvers))
							nso-&gt;nso_version = RPCBVERS4;
						<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((RPCBVERS3 &gt;= minvers) &amp;&amp; (RPCBVERS3 &lt;= maxvers))
							nso-&gt;nso_version = RPCBVERS3;
					}
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nso-&gt;nso_protocol == NFS_PROG) {
					<span class="enscript-type">int</span> vers;

					<span class="enscript-comment">/*
					 * N.B. Both portmapper and rpcbind V3 are happy to return
					 * addresses for other versions than the one you ask (getport or
					 * getaddr) and thus we may have fallen to this code path. So if
					 * we get a version that we support, use highest supported
					 * version.  This assumes that the server supports all versions
					 * between minvers and maxvers.  Note for IPv6 we will try and
					 * use rpcbind V4 which has getversaddr and we should not get
					 * here if that was successful.
					 */</span>
					<span class="enscript-keyword">for</span> (vers = nso-&gt;nso_nfs_max_vers; vers &gt;= (<span class="enscript-type">int</span>)nso-&gt;nso_nfs_min_vers; vers--) {
						<span class="enscript-keyword">if</span> (vers &gt;= (<span class="enscript-type">int</span>)minvers &amp;&amp; vers &lt;= (<span class="enscript-type">int</span>)maxvers)
								<span class="enscript-keyword">break</span>;
					}
					nso-&gt;nso_version = (vers &lt; (<span class="enscript-type">int</span>)nso-&gt;nso_nfs_min_vers) ? 0 : vers;
				}
				<span class="enscript-keyword">if</span> (!error &amp;&amp; nso-&gt;nso_version)
					accepted_status = RPC_SUCCESS;
			}
			<span class="enscript-keyword">if</span> (!error) {
				<span class="enscript-keyword">switch</span> (accepted_status) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_SUCCESS</span>:
					error = 0;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_PROGUNAVAIL</span>:
					error = EPROGUNAVAIL;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_PROGMISMATCH</span>:
					error = EPROGMISMATCH;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_PROCUNAVAIL</span>:
					error = EPROCUNAVAIL;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_GARBAGE</span>:
					error = EBADRPC;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_SYSTEM_ERR</span>:
				<span class="enscript-reference">default</span>:
					error = EIO;
					<span class="enscript-keyword">break</span>;
				}
			}
<span class="enscript-reference">nfsmout</span>:
			nso-&gt;nso_flags &amp;= ~NSO_PINGING;
			<span class="enscript-keyword">if</span> (error) {
				nso-&gt;nso_error = error;
				nso-&gt;nso_flags |= NSO_DEAD;
			} <span class="enscript-keyword">else</span> {
				nso-&gt;nso_flags |= NSO_VERIFIED;
			}
			mbuf_freem(m);
			<span class="enscript-comment">/* wake up search thread */</span>
			wakeup(nso-&gt;nso_wake);
			<span class="enscript-keyword">break</span>;
		}
	}

	nso-&gt;nso_flags &amp;= ~NSO_UPCALL;
	<span class="enscript-keyword">if</span> ((error != EWOULDBLOCK) &amp;&amp; (error || !recv)) {
		<span class="enscript-comment">/* problems with the socket... */</span>
		nso-&gt;nso_error = error ? error : EPIPE;
		nso-&gt;nso_flags |= NSO_DEAD;
		wakeup(nso-&gt;nso_wake);
	}
	<span class="enscript-keyword">if</span> (nso-&gt;nso_flags &amp; NSO_DISCONNECTING)
		wakeup(&amp;nso-&gt;nso_flags);
	lck_mtx_unlock(&amp;nso-&gt;nso_lock);
}

<span class="enscript-comment">/*
 * Create/initialize an nfs_socket structure.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_socket_create</span>(
	<span class="enscript-type">struct</span> nfsmount *nmp,
	<span class="enscript-type">struct</span> sockaddr *sa,
	<span class="enscript-type">int</span> sotype,
	in_port_t port,
	uint32_t protocol,
	uint32_t vers,
	<span class="enscript-type">int</span> resvport,
	<span class="enscript-type">struct</span> nfs_socket **nsop)
{
	<span class="enscript-type">struct</span> nfs_socket *nso;
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">int</span> error;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFS_SOCKET_DEBUGGING</span>
	<span class="enscript-type">char</span> naddr[MAX_IPv6_STR_LEN];
	<span class="enscript-type">void</span> *sinaddr;

	<span class="enscript-keyword">if</span> (sa-&gt;sa_family == AF_INET)
		sinaddr = &amp;((<span class="enscript-type">struct</span> sockaddr_in*)sa)-&gt;sin_addr;
	<span class="enscript-keyword">else</span>
		sinaddr = &amp;((<span class="enscript-type">struct</span> sockaddr_in6*)sa)-&gt;sin6_addr;
	<span class="enscript-keyword">if</span> (inet_ntop(sa-&gt;sa_family, sinaddr, naddr, <span class="enscript-keyword">sizeof</span>(naddr)) != naddr)
		strlcpy(naddr, <span class="enscript-string">&quot;&lt;unknown&gt;&quot;</span>, <span class="enscript-keyword">sizeof</span>(naddr));
#<span class="enscript-reference">else</span>
	<span class="enscript-type">char</span> naddr[1] =  { 0 };
#<span class="enscript-reference">endif</span>

	*nsop = NULL;

	<span class="enscript-comment">/* Create the socket. */</span>
	MALLOC(nso, <span class="enscript-type">struct</span> nfs_socket *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_socket), M_TEMP, M_WAITOK|M_ZERO);
	<span class="enscript-keyword">if</span> (nso)
		MALLOC(nso-&gt;nso_saddr, <span class="enscript-type">struct</span> sockaddr *, sa-&gt;sa_len, M_SONAME, M_WAITOK|M_ZERO);
	<span class="enscript-keyword">if</span> (!nso || !nso-&gt;nso_saddr) {
		<span class="enscript-keyword">if</span> (nso)
			FREE(nso, M_TEMP);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	lck_mtx_init(&amp;nso-&gt;nso_lock, nfs_request_grp, LCK_ATTR_NULL);
	nso-&gt;nso_sotype = sotype;
	<span class="enscript-keyword">if</span> (nso-&gt;nso_sotype == SOCK_STREAM)
		nfs_rpc_record_state_init(&amp;nso-&gt;nso_rrs);
	microuptime(&amp;now);
	nso-&gt;nso_timestamp = now.tv_sec;
	bcopy(sa, nso-&gt;nso_saddr, sa-&gt;sa_len);
	<span class="enscript-keyword">if</span> (sa-&gt;sa_family == AF_INET)
		((<span class="enscript-type">struct</span> sockaddr_in*)nso-&gt;nso_saddr)-&gt;sin_port = htons(port);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sa-&gt;sa_family == AF_INET6)
		((<span class="enscript-type">struct</span> sockaddr_in6*)nso-&gt;nso_saddr)-&gt;sin6_port = htons(port);
	nso-&gt;nso_protocol = protocol;
	nso-&gt;nso_version = vers;
	nso-&gt;nso_nfs_min_vers = PVER2MAJOR(nmp-&gt;nm_min_vers);
	nso-&gt;nso_nfs_max_vers = PVER2MAJOR(nmp-&gt;nm_max_vers);

	error = sock_socket(sa-&gt;sa_family, nso-&gt;nso_sotype, 0, NULL, NULL, &amp;nso-&gt;nso_so);

	<span class="enscript-comment">/* Some servers require that the client port be a reserved port number. */</span>
	<span class="enscript-keyword">if</span> (!error &amp;&amp; resvport &amp;&amp; ((sa-&gt;sa_family == AF_INET) || (sa-&gt;sa_family == AF_INET6))) {
		<span class="enscript-type">struct</span> sockaddr_storage ss;
		<span class="enscript-type">int</span> level = (sa-&gt;sa_family == AF_INET) ? IPPROTO_IP : IPPROTO_IPV6;
		<span class="enscript-type">int</span> optname = (sa-&gt;sa_family == AF_INET) ? IP_PORTRANGE : IPV6_PORTRANGE;
		<span class="enscript-type">int</span> portrange = IP_PORTRANGE_LOW;

		error = sock_setsockopt(nso-&gt;nso_so, level, optname, &amp;portrange, <span class="enscript-keyword">sizeof</span>(portrange));
		<span class="enscript-keyword">if</span> (!error) {	<span class="enscript-comment">/* bind now to check for failure */</span>
			ss.ss_len = sa-&gt;sa_len;
			ss.ss_family = sa-&gt;sa_family;
			<span class="enscript-keyword">if</span> (ss.ss_family == AF_INET) {
				((<span class="enscript-type">struct</span> sockaddr_in*)&amp;ss)-&gt;sin_addr.s_addr = INADDR_ANY;
				((<span class="enscript-type">struct</span> sockaddr_in*)&amp;ss)-&gt;sin_port = htons(0);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ss.ss_family == AF_INET6) {
				((<span class="enscript-type">struct</span> sockaddr_in6*)&amp;ss)-&gt;sin6_addr = in6addr_any;
				((<span class="enscript-type">struct</span> sockaddr_in6*)&amp;ss)-&gt;sin6_port = htons(0);
			} <span class="enscript-keyword">else</span> {
				error = EINVAL;
			}
			<span class="enscript-keyword">if</span> (!error)
				error = sock_bind(nso-&gt;nso_so, (<span class="enscript-type">struct</span> sockaddr*)&amp;ss);
		}
	}

	<span class="enscript-keyword">if</span> (error) {
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s error %d creating socket %p %s type %d%s port %d prot %d %d\n&quot;</span>,
			vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, error, nso, naddr, sotype,
			resvport ? <span class="enscript-string">&quot;r&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, port, protocol, vers);
		nfs_socket_destroy(nso);
	} <span class="enscript-keyword">else</span> {
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s created socket %p %s type %d%s port %d prot %d %d\n&quot;</span>,
			vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nso, naddr,
			sotype, resvport ? <span class="enscript-string">&quot;r&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, port, protocol, vers);
		*nsop = nso;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Destroy an nfs_socket structure.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_socket_destroy</span>(<span class="enscript-type">struct</span> nfs_socket *nso)
{
	<span class="enscript-type">struct</span> timespec ts = { 4, 0 };

	lck_mtx_lock(&amp;nso-&gt;nso_lock);
	nso-&gt;nso_flags |= NSO_DISCONNECTING;
	<span class="enscript-keyword">if</span> (nso-&gt;nso_flags &amp; NSO_UPCALL) <span class="enscript-comment">/* give upcall a chance to complete */</span>
		msleep(&amp;nso-&gt;nso_flags, &amp;nso-&gt;nso_lock, PZERO-1, <span class="enscript-string">&quot;nfswaitupcall&quot;</span>, &amp;ts);
	lck_mtx_unlock(&amp;nso-&gt;nso_lock);
	sock_shutdown(nso-&gt;nso_so, SHUT_RDWR);
	sock_close(nso-&gt;nso_so);
	<span class="enscript-keyword">if</span> (nso-&gt;nso_sotype == SOCK_STREAM)
		nfs_rpc_record_state_cleanup(&amp;nso-&gt;nso_rrs);
	lck_mtx_destroy(&amp;nso-&gt;nso_lock, nfs_request_grp);
	<span class="enscript-keyword">if</span> (nso-&gt;nso_saddr)
		FREE(nso-&gt;nso_saddr, M_SONAME);
	<span class="enscript-keyword">if</span> (nso-&gt;nso_saddr2)
		FREE(nso-&gt;nso_saddr2, M_SONAME);
	NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect - socket %p destroyed\n&quot;</span>, nso);
	FREE(nso, M_TEMP);
}

<span class="enscript-comment">/*
 * Set common socket options on an nfs_socket.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_socket_options</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">struct</span> nfs_socket *nso)
{
	<span class="enscript-comment">/*
	 * Set socket send/receive timeouts
	 * - Receive timeout shouldn't matter because most receives are performed
	 *   in the socket upcall non-blocking.
	 * - Send timeout should allow us to react to a blocked socket.
	 *   Soft mounts will want to abort sooner.
	 */</span>
	<span class="enscript-type">struct</span> timeval timeo;
	<span class="enscript-type">int</span> on = 1, proto;

	timeo.tv_usec = 0;
	timeo.tv_sec = (NMFLAG(nmp, SOFT) || nfs_can_squish(nmp)) ? 5 : 60;
	sock_setsockopt(nso-&gt;nso_so, SOL_SOCKET, SO_RCVTIMEO, &amp;timeo, <span class="enscript-keyword">sizeof</span>(timeo));
	sock_setsockopt(nso-&gt;nso_so, SOL_SOCKET, SO_SNDTIMEO, &amp;timeo, <span class="enscript-keyword">sizeof</span>(timeo));
	<span class="enscript-keyword">if</span> (nso-&gt;nso_sotype == SOCK_STREAM) {
		<span class="enscript-comment">/* Assume that SOCK_STREAM always requires a connection */</span>
		sock_setsockopt(nso-&gt;nso_so, SOL_SOCKET, SO_KEEPALIVE, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
		<span class="enscript-comment">/* set nodelay for TCP */</span>
		sock_gettype(nso-&gt;nso_so, NULL, NULL, &amp;proto);
		<span class="enscript-keyword">if</span> (proto == IPPROTO_TCP)
			sock_setsockopt(nso-&gt;nso_so, IPPROTO_TCP, TCP_NODELAY, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	}
	<span class="enscript-keyword">if</span> (nso-&gt;nso_sotype == SOCK_DGRAM) { <span class="enscript-comment">/* set socket buffer sizes for UDP */</span>
		<span class="enscript-type">int</span> reserve = NFS_UDPSOCKBUF;
		sock_setsockopt(nso-&gt;nso_so, SOL_SOCKET, SO_SNDBUF, &amp;reserve, <span class="enscript-keyword">sizeof</span>(reserve));
		sock_setsockopt(nso-&gt;nso_so, SOL_SOCKET, SO_RCVBUF, &amp;reserve, <span class="enscript-keyword">sizeof</span>(reserve));
	}
	<span class="enscript-comment">/* set SO_NOADDRERR to detect network changes ASAP */</span>
	sock_setsockopt(nso-&gt;nso_so, SOL_SOCKET, SO_NOADDRERR, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	<span class="enscript-comment">/* just playin' it safe with upcalls */</span>
	sock_setsockopt(nso-&gt;nso_so, SOL_SOCKET, SO_UPCALLCLOSEWAIT, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	<span class="enscript-comment">/* socket should be interruptible if the mount is */</span>
	<span class="enscript-keyword">if</span> (!NMFLAG(nmp, INTR))
		sock_nointerrupt(nso-&gt;nso_so, 1);
}

<span class="enscript-comment">/*
 * Release resources held in an nfs_socket_search.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_socket_search_cleanup</span>(<span class="enscript-type">struct</span> nfs_socket_search *nss)
{
	<span class="enscript-type">struct</span> nfs_socket *nso, *nsonext;

	TAILQ_FOREACH_SAFE(nso, &amp;nss-&gt;nss_socklist, nso_link, nsonext) {
		TAILQ_REMOVE(&amp;nss-&gt;nss_socklist, nso, nso_link);
		nss-&gt;nss_sockcnt--;
		nfs_socket_destroy(nso);
	}
	<span class="enscript-keyword">if</span> (nss-&gt;nss_sock) {
		nfs_socket_destroy(nss-&gt;nss_sock);
		nss-&gt;nss_sock = NULL;
	}
}

<span class="enscript-comment">/*
 * Prefer returning certain errors over others.
 * This function returns a ranking of the given error.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_connect_error_class</span>(<span class="enscript-type">int</span> error)
{
	<span class="enscript-keyword">switch</span> (error) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ETIMEDOUT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EAGAIN</span>:
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EPIPE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EADDRNOTAVAIL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETDOWN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETUNREACH</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETRESET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ECONNABORTED</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ECONNRESET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EISCONN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOTCONN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ESHUTDOWN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ECONNREFUSED</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTDOWN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTUNREACH</span>:
		<span class="enscript-keyword">return</span> (2);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ERPCMISMATCH</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EPROCUNAVAIL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EPROGMISMATCH</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EPROGUNAVAIL</span>:
		<span class="enscript-keyword">return</span> (3);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EBADRPC</span>:
		<span class="enscript-keyword">return</span> (4);
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (5);
	}
}

<span class="enscript-comment">/*
 * Make sure a socket search returns the best error.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_socket_search_update_error</span>(<span class="enscript-type">struct</span> nfs_socket_search *nss, <span class="enscript-type">int</span> error)
{
	<span class="enscript-keyword">if</span> (nfs_connect_error_class(error) &gt;= nfs_connect_error_class(nss-&gt;nss_error))
		nss-&gt;nss_error = error;
}

<span class="enscript-comment">/* nfs_connect_search_new_socket:
 * 	Given a socket search structure for an nfs mount try to find a new socket from the set of addresses specified
 *	by nss.
 *
 *	nss_last is set to -1 at initialization to indicate the first time. Its set to -2 if address was found but
 *	could not be used or if a socket timed out.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_connect_search_new_socket</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">struct</span> nfs_socket_search *nss, <span class="enscript-type">struct</span> timeval *now)
{
	<span class="enscript-type">struct</span> nfs_fs_location *fsl;
	<span class="enscript-type">struct</span> nfs_fs_server *fss;
	<span class="enscript-type">struct</span> sockaddr_storage ss;
	<span class="enscript-type">struct</span> nfs_socket *nso;
	<span class="enscript-type">char</span> *addrstr;
	<span class="enscript-type">int</span> error = 0;
	

	NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s nss_addrcnt = %d\n&quot;</span>,
			      vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nss-&gt;nss_addrcnt);

	<span class="enscript-comment">/*
	 * while there are addresses and:
	 *	we have no sockets or
	 *	the last address failed and did not produce a socket (nss_last &lt; 0) or
	 *	Its been a while (2 seconds) and we have less than the max number of concurrent sockets to search (4)
	 *	then attempt to create a socket with the current address.
	 */</span>
	<span class="enscript-keyword">while</span> (nss-&gt;nss_addrcnt &gt; 0 &amp;&amp; ((nss-&gt;nss_last &lt; 0) || (nss-&gt;nss_sockcnt == 0) ||
				    ((nss-&gt;nss_sockcnt &lt; 4) &amp;&amp; (now-&gt;tv_sec &gt;= (nss-&gt;nss_last + 2))))) {
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_sockflags &amp; NMSOCK_UNMOUNT)
			<span class="enscript-keyword">return</span> (EINTR);
		<span class="enscript-comment">/* Can we convert the address to a sockaddr? */</span>
		fsl = nmp-&gt;nm_locations.nl_locations[nss-&gt;nss_nextloc.nli_loc];
		fss = fsl-&gt;nl_servers[nss-&gt;nss_nextloc.nli_serv];
		addrstr = fss-&gt;ns_addresses[nss-&gt;nss_nextloc.nli_addr];
		<span class="enscript-keyword">if</span> (!nfs_uaddr2sockaddr(addrstr, (<span class="enscript-type">struct</span> sockaddr*)&amp;ss)) {
			nfs_location_next(&amp;nmp-&gt;nm_locations, &amp;nss-&gt;nss_nextloc);
			nss-&gt;nss_addrcnt -= 1;
			nss-&gt;nss_last = -2;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/* Check that socket family is acceptable. */</span>
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_sofamily &amp;&amp; (ss.ss_family != nmp-&gt;nm_sofamily)) {
			nfs_location_next(&amp;nmp-&gt;nm_locations, &amp;nss-&gt;nss_nextloc);
			nss-&gt;nss_addrcnt -= 1;
			nss-&gt;nss_last = -2;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/* Create the socket. */</span>
		error = nfs_socket_create(nmp, (<span class="enscript-type">struct</span> sockaddr*)&amp;ss, nss-&gt;nss_sotype,
				nss-&gt;nss_port, nss-&gt;nss_protocol, nss-&gt;nss_version,
				((nss-&gt;nss_protocol == NFS_PROG) &amp;&amp; NMFLAG(nmp, RESVPORT)), &amp;nso);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);

		nso-&gt;nso_location = nss-&gt;nss_nextloc;
		nso-&gt;nso_wake = nss;
		error = sock_setupcall(nso-&gt;nso_so, nfs_connect_upcall, nso);
		<span class="enscript-keyword">if</span> (error) {
			lck_mtx_lock(&amp;nso-&gt;nso_lock);
			nso-&gt;nso_error = error;
			nso-&gt;nso_flags |= NSO_DEAD;
			lck_mtx_unlock(&amp;nso-&gt;nso_lock);
		}

		TAILQ_INSERT_TAIL(&amp;nss-&gt;nss_socklist, nso, nso_link);
		nss-&gt;nss_sockcnt++;
		nfs_location_next(&amp;nmp-&gt;nm_locations, &amp;nss-&gt;nss_nextloc);
		nss-&gt;nss_addrcnt -= 1;
		
		nss-&gt;nss_last = now-&gt;tv_sec;
	}

	<span class="enscript-keyword">if</span> (nss-&gt;nss_addrcnt == 0 &amp;&amp; nss-&gt;nss_last &lt; 0)
		nss-&gt;nss_last = now-&gt;tv_sec;
	
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * nfs_connect_search_socket_connect:	Connect an nfs socket nso for nfsmount nmp.
 *					If successful set the socket options for the socket as require from the mount.
 *
 * Assumes:				nso-&gt;nso_lock is held on entry and return.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_connect_search_socket_connect</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">struct</span> nfs_socket *nso, <span class="enscript-type">int</span> verbose)
{
	<span class="enscript-type">int</span> error;
	
	<span class="enscript-keyword">if</span> ((nso-&gt;nso_sotype != SOCK_STREAM) &amp;&amp; NMFLAG(nmp, NOCONNECT)) {
		<span class="enscript-comment">/* no connection needed, just say it's already connected */</span>
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s UDP socket %p noconnect\n&quot;</span>,
			      vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nso);
		nso-&gt;nso_flags |= NSO_CONNECTED;
		nfs_socket_options(nmp, nso);
		<span class="enscript-keyword">return</span> (1);   <span class="enscript-comment">/* Socket is connected and setup */</span>
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(nso-&gt;nso_flags &amp; NSO_CONNECTING)) {
		<span class="enscript-comment">/* initiate the connection */</span>
		nso-&gt;nso_flags |= NSO_CONNECTING;
		lck_mtx_unlock(&amp;nso-&gt;nso_lock);
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s connecting socket %p\n&quot;</span>,
			      vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nso);
		error = sock_connect(nso-&gt;nso_so, nso-&gt;nso_saddr, MSG_DONTWAIT);
		lck_mtx_lock(&amp;nso-&gt;nso_lock);
		<span class="enscript-keyword">if</span> (error &amp;&amp; (error != EINPROGRESS)) {
			nso-&gt;nso_error = error;
			nso-&gt;nso_flags |= NSO_DEAD;
			<span class="enscript-keyword">return</span> (0);
		}
	}
	<span class="enscript-keyword">if</span> (nso-&gt;nso_flags &amp; NSO_CONNECTING) {
		<span class="enscript-comment">/* check the connection */</span>
		<span class="enscript-keyword">if</span> (sock_isconnected(nso-&gt;nso_so)) {
			NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s socket %p is connected\n&quot;</span>,
				      vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nso);
			nso-&gt;nso_flags &amp;= ~NSO_CONNECTING;
			nso-&gt;nso_flags |= NSO_CONNECTED;
			nfs_socket_options(nmp, nso);
			<span class="enscript-keyword">return</span> (1);   <span class="enscript-comment">/* Socket is connected and setup */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">int</span> optlen = <span class="enscript-keyword">sizeof</span>(error);
			error = 0;
			sock_getsockopt(nso-&gt;nso_so, SOL_SOCKET, SO_ERROR, &amp;error, &amp;optlen);
			<span class="enscript-keyword">if</span> (error) { <span class="enscript-comment">/* we got an error on the socket */</span>
				NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s socket %p connection error %d\n&quot;</span>,
					      vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nso, error);
				<span class="enscript-keyword">if</span> (verbose)
					printf(<span class="enscript-string">&quot;nfs connect socket error %d for %s\n&quot;</span>,
					    error, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname);
				nso-&gt;nso_error = error;
				nso-&gt;nso_flags |= NSO_DEAD;
				<span class="enscript-keyword">return</span> (0);
			}
		}
	}
	
	<span class="enscript-keyword">return</span> (0);  <span class="enscript-comment">/* Waiting to be connected */</span>
}

<span class="enscript-comment">/*
 * nfs_connect_search_ping:	Send a null proc on the nso socket.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_connect_search_ping</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">struct</span> nfs_socket *nso, <span class="enscript-type">struct</span> timeval *now)
{
	<span class="enscript-comment">/* initiate a NULL RPC request */</span>
	uint64_t xid = nso-&gt;nso_pingxid;
	mbuf_t m, mreq = NULL;
	<span class="enscript-type">struct</span> msghdr msg;
	size_t reqlen, sentlen;
	uint32_t vers = nso-&gt;nso_version;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (!vers) {
		<span class="enscript-keyword">if</span> (nso-&gt;nso_protocol == PMAPPROG)
			vers = (nso-&gt;nso_saddr-&gt;sa_family == AF_INET) ? PMAPVERS : RPCBVERS4;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nso-&gt;nso_protocol == NFS_PROG)
			vers = PVER2MAJOR(nmp-&gt;nm_max_vers);
	}
	lck_mtx_unlock(&amp;nso-&gt;nso_lock);
	error = nfsm_rpchead2(nmp, nso-&gt;nso_sotype, nso-&gt;nso_protocol, vers, 0, RPCAUTH_SYS,
			      vfs_context_ucred(vfs_context_kernel()), NULL, NULL, &amp;xid, &amp;mreq);
	lck_mtx_lock(&amp;nso-&gt;nso_lock);
	<span class="enscript-keyword">if</span> (!error) {
		nso-&gt;nso_flags |= NSO_PINGING;
		nso-&gt;nso_pingxid = R_XID32(xid);
		nso-&gt;nso_reqtimestamp = now-&gt;tv_sec;
		bzero(&amp;msg, <span class="enscript-keyword">sizeof</span>(msg));
		<span class="enscript-keyword">if</span> ((nso-&gt;nso_sotype != SOCK_STREAM) &amp;&amp; !sock_isconnected(nso-&gt;nso_so)) {
			msg.msg_name = nso-&gt;nso_saddr;
			msg.msg_namelen = nso-&gt;nso_saddr-&gt;sa_len;
		}
		<span class="enscript-keyword">for</span> (reqlen=0, m=mreq; m; m = mbuf_next(m))
			reqlen += mbuf_len(m);
		lck_mtx_unlock(&amp;nso-&gt;nso_lock);
		error = sock_sendmbuf(nso-&gt;nso_so, &amp;msg, mreq, 0, &amp;sentlen);
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s verifying socket %p send rv %d\n&quot;</span>,
			      vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nso, error);
		lck_mtx_lock(&amp;nso-&gt;nso_lock);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; (sentlen != reqlen))
			error = ETIMEDOUT;
	}
	<span class="enscript-keyword">if</span> (error) {
		nso-&gt;nso_error = error;
		nso-&gt;nso_flags |= NSO_DEAD;
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * nfs_connect_search_socket_found:	Take the found socket of the socket search list and assign it to the searched socket.
 *					Set the nfs socket protocol and version if needed. 
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_connect_search_socket_found</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">struct</span> nfs_socket_search *nss, <span class="enscript-type">struct</span> nfs_socket *nso)
{
	NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s socket %p verified\n&quot;</span>,
		      vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nso);
	<span class="enscript-keyword">if</span> (!nso-&gt;nso_version) {
		<span class="enscript-comment">/* If the version isn't set, the default must have worked. */</span>
		<span class="enscript-keyword">if</span> (nso-&gt;nso_protocol == PMAPPROG)
			nso-&gt;nso_version = (nso-&gt;nso_saddr-&gt;sa_family == AF_INET) ? PMAPVERS : RPCBVERS4;
		<span class="enscript-keyword">if</span> (nso-&gt;nso_protocol == NFS_PROG)
			nso-&gt;nso_version = PVER2MAJOR(nmp-&gt;nm_max_vers);
	}
	TAILQ_REMOVE(&amp;nss-&gt;nss_socklist, nso, nso_link);
	nss-&gt;nss_sockcnt--;
	nss-&gt;nss_sock = nso;
}

<span class="enscript-comment">/*
 * nfs_connect_search_socket_reap:	For each socket in the search list mark any timed out socket as dead and remove from
 *					the list. Dead socket are then destroyed.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_connect_search_socket_reap</span>(<span class="enscript-type">struct</span> nfsmount *nmp __unused, <span class="enscript-type">struct</span> nfs_socket_search *nss, <span class="enscript-type">struct</span> timeval *now)
{
	<span class="enscript-type">struct</span> nfs_socket *nso, *nsonext;
	
	TAILQ_FOREACH_SAFE(nso, &amp;nss-&gt;nss_socklist, nso_link, nsonext) {
		lck_mtx_lock(&amp;nso-&gt;nso_lock);
		<span class="enscript-keyword">if</span> (now-&gt;tv_sec &gt;= (nso-&gt;nso_timestamp + nss-&gt;nss_timeo)) {
			<span class="enscript-comment">/* took too long */</span>
			NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s socket %p timed out\n&quot;</span>,
				vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nso);
			nso-&gt;nso_error = ETIMEDOUT;
			nso-&gt;nso_flags |= NSO_DEAD;
		}
		<span class="enscript-keyword">if</span> (!(nso-&gt;nso_flags &amp; NSO_DEAD)) {
			lck_mtx_unlock(&amp;nso-&gt;nso_lock);
			<span class="enscript-keyword">continue</span>;
		}
		lck_mtx_unlock(&amp;nso-&gt;nso_lock);
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s reaping socket %p %d\n&quot;</span>,
			vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nso, nso-&gt;nso_error);
		nfs_socket_search_update_error(nss, nso-&gt;nso_error);
		TAILQ_REMOVE(&amp;nss-&gt;nss_socklist, nso, nso_link);
		nss-&gt;nss_sockcnt--;
		nfs_socket_destroy(nso);
		<span class="enscript-comment">/* If there are more sockets to try, force the starting of another socket */</span>
		<span class="enscript-keyword">if</span> (nss-&gt;nss_addrcnt &gt; 0)
			nss-&gt;nss_last = -2;
	}
}

<span class="enscript-comment">/*
 * nfs_connect_search_check:	Check on the status of search and wait for replies if needed.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_connect_search_check</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">struct</span> nfs_socket_search *nss, <span class="enscript-type">struct</span> timeval *now)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* log a warning if connect is taking a while */</span>
	<span class="enscript-keyword">if</span> (((now-&gt;tv_sec - nss-&gt;nss_timestamp) &gt;= 8) &amp;&amp; ((nss-&gt;nss_flags &amp; (NSS_VERBOSE|NSS_WARNED)) == NSS_VERBOSE)) {
		printf(<span class="enscript-string">&quot;nfs_connect: socket connect taking a while for %s\n&quot;</span>, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname);
		nss-&gt;nss_flags |= NSS_WARNED;
	}
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_sockflags &amp; NMSOCK_UNMOUNT)
		<span class="enscript-keyword">return</span> (EINTR);
	<span class="enscript-keyword">if</span> ((error = nfs_sigintr(nmp, NULL, current_thread(), 0)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/* If we were succesfull at sending a ping, wait up to a second for a reply  */</span>
	<span class="enscript-keyword">if</span> (nss-&gt;nss_last &gt;= 0)
		tsleep(nss, PSOCK, <span class="enscript-string">&quot;nfs_connect_search_wait&quot;</span>, hz);
	
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Continue the socket search until we have something to report.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_connect_search_loop</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">struct</span> nfs_socket_search *nss)
{
	<span class="enscript-type">struct</span> nfs_socket *nso;
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> verbose = (nss-&gt;nss_flags &amp; NSS_VERBOSE);
	
<span class="enscript-reference">loop</span>:
	microuptime(&amp;now);
	NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s search %ld\n&quot;</span>, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, now.tv_sec);

	<span class="enscript-comment">/* add a new socket to the socket list if needed and available */</span>
	error = nfs_connect_search_new_socket(nmp, nss, &amp;now);
	<span class="enscript-keyword">if</span> (error) {
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect returned %d\n&quot;</span>, error);
		<span class="enscript-keyword">return</span> (error);
	}
	
	<span class="enscript-comment">/* check each active socket on the list and try to push it along */</span>
	TAILQ_FOREACH(nso, &amp;nss-&gt;nss_socklist, nso_link) {
		lck_mtx_lock(&amp;nso-&gt;nso_lock);

		<span class="enscript-comment">/* If not connected connect it */</span>
		<span class="enscript-keyword">if</span> (!(nso-&gt;nso_flags &amp; NSO_CONNECTED)) {
			<span class="enscript-keyword">if</span> (!nfs_connect_search_socket_connect(nmp, nso, verbose)) {
				lck_mtx_unlock(&amp;nso-&gt;nso_lock);
				<span class="enscript-keyword">continue</span>;
			}
		}

		<span class="enscript-comment">/* If the socket hasn't been verified or in a ping, ping it. We also handle UDP retransmits */</span>
		<span class="enscript-keyword">if</span> (!(nso-&gt;nso_flags &amp; (NSO_PINGING|NSO_VERIFIED)) ||
		    ((nso-&gt;nso_sotype == SOCK_DGRAM) &amp;&amp; (now.tv_sec &gt;= nso-&gt;nso_reqtimestamp+2))) {
			<span class="enscript-keyword">if</span> (!nfs_connect_search_ping(nmp, nso, &amp;now)) {
				lck_mtx_unlock(&amp;nso-&gt;nso_lock);
				<span class="enscript-keyword">continue</span>;
			}
		}

		<span class="enscript-comment">/* Has the socket been verified by the up call routine? */</span>
		<span class="enscript-keyword">if</span> (nso-&gt;nso_flags &amp; NSO_VERIFIED) {
			<span class="enscript-comment">/* WOOHOO!! This socket looks good! */</span>
			nfs_connect_search_socket_found(nmp, nss, nso);
			lck_mtx_unlock(&amp;nso-&gt;nso_lock);
			<span class="enscript-keyword">break</span>;
		}
		lck_mtx_unlock(&amp;nso-&gt;nso_lock);
	}
	
	<span class="enscript-comment">/* Check for timed out sockets and mark as dead and then remove all dead sockets. */</span>
	nfs_connect_search_socket_reap(nmp, nss, &amp;now);
	
	<span class="enscript-comment">/*
	 * Keep looping if we haven't found a socket yet and we have more
	 * sockets to (continue to) try.
	 */</span>
	error = 0;
	<span class="enscript-keyword">if</span> (!nss-&gt;nss_sock &amp;&amp; (!TAILQ_EMPTY(&amp;nss-&gt;nss_socklist) || nss-&gt;nss_addrcnt)) {
		error = nfs_connect_search_check(nmp, nss, &amp;now);
		<span class="enscript-keyword">if</span> (!error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
	}

	NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s returning %d\n&quot;</span>, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, error);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Initialize a new NFS connection.
 *
 * Search for a location to connect a socket to and initialize the connection.
 *
 * An NFS mount may have multiple locations/servers/addresses available.
 * We attempt to connect to each one asynchronously and will start
 * several sockets in parallel if other locations are slow to answer.
 * We'll use the first NFS socket we can successfully set up.
 *
 * The search may involve contacting the portmapper service first.
 *
 * A mount's initial connection may require negotiating some parameters such
 * as socket type and NFS version.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_connect</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">int</span> verbose, <span class="enscript-type">int</span> timeo)
{
	<span class="enscript-type">struct</span> nfs_socket_search nss;
	<span class="enscript-type">struct</span> nfs_socket *nso, *nsonfs;
	<span class="enscript-type">struct</span> sockaddr_storage ss;
	<span class="enscript-type">struct</span> sockaddr *saddr, *oldsaddr;
	sock_upcall upcall;
	<span class="enscript-type">struct</span> timeval now, start;
	<span class="enscript-type">int</span> error, savederror, nfsvers;
	<span class="enscript-type">int</span> tryv4 = 1;
	uint8_t	sotype = nmp-&gt;nm_sotype ? nmp-&gt;nm_sotype : SOCK_STREAM;
	fhandle_t *fh = NULL;
	<span class="enscript-type">char</span> *path = NULL;
	in_port_t port;
	<span class="enscript-type">int</span> addrtotal = 0;
	
	<span class="enscript-comment">/* paranoia... check that we have at least one address in the locations */</span>
	uint32_t loc, serv;
	<span class="enscript-keyword">for</span> (loc=0; loc &lt; nmp-&gt;nm_locations.nl_numlocs; loc++) {
		<span class="enscript-keyword">for</span> (serv=0; serv &lt; nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_servcount; serv++) {
			addrtotal += nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_addrcount;
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_addrcount == 0)
				NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s search, server %s has no addresses\n&quot;</span>,
					      vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname,
					      nmp-&gt;nm_locations.nl_locations[loc]-&gt;nl_servers[serv]-&gt;ns_name);
		}
	}

	<span class="enscript-keyword">if</span> (addrtotal == 0) {
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s search failed, no addresses\n&quot;</span>,
			vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname);
		<span class="enscript-keyword">return</span> (EINVAL);
	} <span class="enscript-keyword">else</span> 
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s has %d addresses\n&quot;</span>,
			      vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, addrtotal);

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	nmp-&gt;nm_sockflags |= NMSOCK_CONNECTING;
	nmp-&gt;nm_nss = &amp;nss;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	microuptime(&amp;start);
	savederror = error = 0;

<span class="enscript-reference">tryagain</span>:
	<span class="enscript-comment">/* initialize socket search state */</span>
	bzero(&amp;nss, <span class="enscript-keyword">sizeof</span>(nss));
	nss.nss_addrcnt = addrtotal;
	nss.nss_error = savederror;
	TAILQ_INIT(&amp;nss.nss_socklist);
	nss.nss_sotype = sotype;
	nss.nss_startloc = nmp-&gt;nm_locations.nl_current;
	nss.nss_timestamp = start.tv_sec;
	nss.nss_timeo = timeo;
	<span class="enscript-keyword">if</span> (verbose)
		nss.nss_flags |= NSS_VERBOSE;

	<span class="enscript-comment">/* First time connecting, we may need to negotiate some things */</span>
	<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_sockflags &amp; NMSOCK_HASCONNECTED)) {
		<span class="enscript-keyword">if</span> (!nmp-&gt;nm_vers) {
			<span class="enscript-comment">/* No NFS version specified... */</span>
			<span class="enscript-keyword">if</span> (!nmp-&gt;nm_nfsport || (!NM_OMATTR_GIVEN(nmp, FH) &amp;&amp; !nmp-&gt;nm_mountport)) {
				<span class="enscript-keyword">if</span> (PVER2MAJOR(nmp-&gt;nm_max_vers) &gt;= NFS_VER4 &amp;&amp; tryv4) {
					nss.nss_port = NFS_PORT;
					nss.nss_protocol = NFS_PROG;
					nss.nss_version = 4;
					nss.nss_flags |= NSS_FALLBACK2PMAP;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* ...connect to portmapper first if we (may) need any ports. */</span>
					nss.nss_port = PMAPPORT;
					nss.nss_protocol = PMAPPROG;
					nss.nss_version = 0;
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* ...connect to NFS port first. */</span>
				nss.nss_port = nmp-&gt;nm_nfsport;
				nss.nss_protocol = NFS_PROG;
				nss.nss_version = 0;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4) {
			<span class="enscript-keyword">if</span> (tryv4) {
				<span class="enscript-comment">/* For NFSv4, we use the given (or default) port. */</span>
				nss.nss_port = nmp-&gt;nm_nfsport ? nmp-&gt;nm_nfsport : NFS_PORT;
				nss.nss_protocol = NFS_PROG;
				nss.nss_version = 4;
				<span class="enscript-comment">/*
				 * set NSS_FALLBACK2PMAP here to pick up any non standard port
				 * if no port is specified on the mount;
				 * Note nm_vers is set so we will only try NFS_VER4.
				 */</span>
				<span class="enscript-keyword">if</span> (!nmp-&gt;nm_nfsport)
					nss.nss_flags |= NSS_FALLBACK2PMAP;
			} <span class="enscript-keyword">else</span> {
				nss.nss_port = PMAPPORT;
				nss.nss_protocol = PMAPPROG;
				nss.nss_version = 0;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* For NFSv3/v2... */</span>
			<span class="enscript-keyword">if</span> (!nmp-&gt;nm_nfsport || (!NM_OMATTR_GIVEN(nmp, FH) &amp;&amp; !nmp-&gt;nm_mountport)) {
				<span class="enscript-comment">/* ...connect to portmapper first if we need any ports. */</span>
				nss.nss_port = PMAPPORT;
				nss.nss_protocol = PMAPPROG;
				nss.nss_version = 0;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* ...connect to NFS port first. */</span>
				nss.nss_port = nmp-&gt;nm_nfsport;
				nss.nss_protocol = NFS_PROG;
				nss.nss_version = nmp-&gt;nm_vers;
			}
		}
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect first %s, so type %d port %d prot %d %d\n&quot;</span>,
			vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nss.nss_sotype, nss.nss_port,
			nss.nss_protocol, nss.nss_version);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* we've connected before, just connect to NFS port */</span>
		<span class="enscript-keyword">if</span> (!nmp-&gt;nm_nfsport) {
			<span class="enscript-comment">/* need to ask portmapper which port that would be */</span>
			nss.nss_port = PMAPPORT;
			nss.nss_protocol = PMAPPROG;
			nss.nss_version = 0;
		} <span class="enscript-keyword">else</span> {
			nss.nss_port = nmp-&gt;nm_nfsport;
			nss.nss_protocol = NFS_PROG;
			nss.nss_version = nmp-&gt;nm_vers;
		}
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s, so type %d port %d prot %d %d\n&quot;</span>,
			vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nss.nss_sotype, nss.nss_port,
			nss.nss_protocol, nss.nss_version);
	}

	<span class="enscript-comment">/* Set next location to first valid location. */</span>
	<span class="enscript-comment">/* If start location is invalid, find next location. */</span>
	nss.nss_nextloc = nss.nss_startloc;
	<span class="enscript-keyword">if</span> ((nss.nss_nextloc.nli_serv &gt;= nmp-&gt;nm_locations.nl_locations[nss.nss_nextloc.nli_loc]-&gt;nl_servcount) ||
	    (nss.nss_nextloc.nli_addr &gt;= nmp-&gt;nm_locations.nl_locations[nss.nss_nextloc.nli_loc]-&gt;nl_servers[nss.nss_nextloc.nli_serv]-&gt;ns_addrcount)) {
		nfs_location_next(&amp;nmp-&gt;nm_locations, &amp;nss.nss_nextloc);
		<span class="enscript-keyword">if</span> (!nfs_location_index_cmp(&amp;nss.nss_nextloc, &amp;nss.nss_startloc)) {
			NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s search failed, couldn't find a valid location index\n&quot;</span>,
				vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname);
			<span class="enscript-keyword">return</span> (ENOENT);
		}
	}
	nss.nss_last = -1;

<span class="enscript-reference">keepsearching</span>:

	error = nfs_connect_search_loop(nmp, &amp;nss);
	<span class="enscript-keyword">if</span> (error || !nss.nss_sock) {
		<span class="enscript-comment">/* search failed */</span>
		nfs_socket_search_cleanup(&amp;nss);
		<span class="enscript-keyword">if</span> (nss.nss_flags &amp; NSS_FALLBACK2PMAP) {
			tryv4 = 0;
			NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s TCP failed for V4 %d %d, trying PORTMAP\n&quot;</span>,
				vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, error, nss.nss_error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
		}

		<span class="enscript-keyword">if</span> (!error &amp;&amp; (nss.nss_sotype == SOCK_STREAM) &amp;&amp; !nmp-&gt;nm_sotype &amp;&amp; (nmp-&gt;nm_vers &lt; NFS_VER4)) {
			<span class="enscript-comment">/* Try using UDP */</span>
			sotype = SOCK_DGRAM;
			savederror = nss.nss_error;
			NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s TCP failed %d %d, trying UDP\n&quot;</span>,
				vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, error, nss.nss_error);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
		}
		<span class="enscript-keyword">if</span> (!error)
			error = nss.nss_error ? nss.nss_error : ETIMEDOUT;
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		nmp-&gt;nm_sockflags &amp;= ~NMSOCK_CONNECTING;
		nmp-&gt;nm_nss = NULL;
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">if</span> (nss.nss_flags &amp; NSS_WARNED)
			log(LOG_INFO, <span class="enscript-string">&quot;nfs_connect: socket connect aborted for %s\n&quot;</span>,
				vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname);
		<span class="enscript-keyword">if</span> (fh)
			FREE(fh, M_TEMP);
		<span class="enscript-keyword">if</span> (path)
			FREE_ZONE(path, MAXPATHLEN, M_NAMEI);
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s search failed, returning %d\n&quot;</span>,
			vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, error);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* try to use nss_sock */</span>
	nso = nss.nss_sock;
	nss.nss_sock = NULL;

	<span class="enscript-comment">/* We may be speaking to portmap first... to determine port(s). */</span>
	<span class="enscript-keyword">if</span> (nso-&gt;nso_saddr-&gt;sa_family == AF_INET)
		port = ntohs(((<span class="enscript-type">struct</span> sockaddr_in*)nso-&gt;nso_saddr)-&gt;sin_port);
	<span class="enscript-keyword">else</span>
		port = ntohs(((<span class="enscript-type">struct</span> sockaddr_in6*)nso-&gt;nso_saddr)-&gt;sin6_port);
	<span class="enscript-keyword">if</span> (port == PMAPPORT) {
		<span class="enscript-comment">/* Use this portmapper port to get the port #s we need. */</span>
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s got portmapper socket %p\n&quot;</span>,
			vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nso);

		<span class="enscript-comment">/* remove the connect upcall so nfs_portmap_lookup() can use this socket */</span>
		sock_setupcall(nso-&gt;nso_so, NULL, NULL);

		<span class="enscript-comment">/* Set up socket address and port for NFS socket. */</span>
		bcopy(nso-&gt;nso_saddr, &amp;ss, nso-&gt;nso_saddr-&gt;sa_len);

		<span class="enscript-comment">/* If NFS version not set, try nm_max_vers down to nm_min_vers */</span>
		nfsvers = nmp-&gt;nm_vers ? nmp-&gt;nm_vers : PVER2MAJOR(nmp-&gt;nm_max_vers);
		<span class="enscript-keyword">if</span> (!(port = nmp-&gt;nm_nfsport)) {
			<span class="enscript-keyword">if</span> (ss.ss_family == AF_INET)
				((<span class="enscript-type">struct</span> sockaddr_in*)&amp;ss)-&gt;sin_port = htons(0);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ss.ss_family == AF_INET6)
				((<span class="enscript-type">struct</span> sockaddr_in6*)&amp;ss)-&gt;sin6_port = htons(0);
			<span class="enscript-keyword">for</span> (; nfsvers &gt;= (<span class="enscript-type">int</span>)PVER2MAJOR(nmp-&gt;nm_min_vers); nfsvers--) {
				<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &amp;&amp; nmp-&gt;nm_vers != nfsvers)
					<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* Wrong version */</span>
				<span class="enscript-keyword">if</span> (nfsvers == NFS_VER4 &amp;&amp; nso-&gt;nso_sotype == SOCK_DGRAM)
					<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* NFSv4 does not do UDP */</span>
				error = nfs_portmap_lookup(nmp, vfs_context_current(), (<span class="enscript-type">struct</span> sockaddr*)&amp;ss,
							   nso-&gt;nso_so, NFS_PROG, nfsvers,
							   (nso-&gt;nso_sotype == SOCK_DGRAM) ? IPPROTO_UDP : IPPROTO_TCP, timeo);
				<span class="enscript-keyword">if</span> (!error) {
					<span class="enscript-keyword">if</span> (ss.ss_family == AF_INET)
						port = ntohs(((<span class="enscript-type">struct</span> sockaddr_in*)&amp;ss)-&gt;sin_port);
					<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ss.ss_family == AF_INET6)
						port = ntohs(((<span class="enscript-type">struct</span> sockaddr_in6*)&amp;ss)-&gt;sin6_port);
					<span class="enscript-keyword">if</span> (!port)
						error = EPROGUNAVAIL;
					<span class="enscript-keyword">if</span> (port == NFS_PORT &amp;&amp; nfsvers == NFS_VER4 &amp;&amp; tryv4 == 0)
						<span class="enscript-keyword">continue</span>; <span class="enscript-comment">/* We already tried this */</span>
				}
				<span class="enscript-keyword">if</span> (!error)
					<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (nfsvers &lt; (<span class="enscript-type">int</span>)PVER2MAJOR(nmp-&gt;nm_min_vers) &amp;&amp; error == 0)
				error = EPROGUNAVAIL;
			<span class="enscript-keyword">if</span> (error) {
				nfs_socket_search_update_error(&amp;nss, error);
				nfs_socket_destroy(nso);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">keepsearching</span>;
			}
		}
		<span class="enscript-comment">/* Create NFS protocol socket and add it to the list of sockets. */</span>
		<span class="enscript-comment">/* N.B. If nfsvers is NFS_VER4 at this point then we're on a non standard port */</span>
		error = nfs_socket_create(nmp, (<span class="enscript-type">struct</span> sockaddr*)&amp;ss, nso-&gt;nso_sotype, port,
				NFS_PROG, nfsvers, NMFLAG(nmp, RESVPORT), &amp;nsonfs);
		<span class="enscript-keyword">if</span> (error) {
			nfs_socket_search_update_error(&amp;nss, error);
			nfs_socket_destroy(nso);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">keepsearching</span>;
		}
		nsonfs-&gt;nso_location = nso-&gt;nso_location;
		nsonfs-&gt;nso_wake = &amp;nss;
		error = sock_setupcall(nsonfs-&gt;nso_so, nfs_connect_upcall, nsonfs);
		<span class="enscript-keyword">if</span> (error) {
			nfs_socket_search_update_error(&amp;nss, error);
			nfs_socket_destroy(nsonfs);
			nfs_socket_destroy(nso);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">keepsearching</span>;
		}
		TAILQ_INSERT_TAIL(&amp;nss.nss_socklist, nsonfs, nso_link);
		nss.nss_sockcnt++;
		<span class="enscript-keyword">if</span> ((nfsvers &lt; NFS_VER4) &amp;&amp; !(nmp-&gt;nm_sockflags &amp; NMSOCK_HASCONNECTED) &amp;&amp; !NM_OMATTR_GIVEN(nmp, FH)) {
			<span class="enscript-comment">/* Set up socket address and port for MOUNT socket. */</span>
			error = 0;
			bcopy(nso-&gt;nso_saddr, &amp;ss, nso-&gt;nso_saddr-&gt;sa_len);
			port = nmp-&gt;nm_mountport;
			<span class="enscript-keyword">if</span> (ss.ss_family == AF_INET)
				((<span class="enscript-type">struct</span> sockaddr_in*)&amp;ss)-&gt;sin_port = htons(port);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ss.ss_family == AF_INET6)
				((<span class="enscript-type">struct</span> sockaddr_in6*)&amp;ss)-&gt;sin6_port = htons(port);
			<span class="enscript-keyword">if</span> (!port) {
				<span class="enscript-comment">/* Get port/sockaddr for MOUNT version corresponding to NFS version. */</span>
				<span class="enscript-comment">/* If NFS version is unknown, optimistically choose for NFSv3. */</span>
				<span class="enscript-type">int</span> mntvers = (nfsvers == NFS_VER2) ? RPCMNT_VER1 : RPCMNT_VER3;
				<span class="enscript-type">int</span> mntproto = (NM_OMFLAG(nmp, MNTUDP) || (nso-&gt;nso_sotype == SOCK_DGRAM)) ? IPPROTO_UDP : IPPROTO_TCP;
				error = nfs_portmap_lookup(nmp, vfs_context_current(), (<span class="enscript-type">struct</span> sockaddr*)&amp;ss,
						nso-&gt;nso_so, RPCPROG_MNT, mntvers, mntproto, timeo);
			}
			<span class="enscript-keyword">if</span> (!error) {
				<span class="enscript-keyword">if</span> (ss.ss_family == AF_INET)
					port = ntohs(((<span class="enscript-type">struct</span> sockaddr_in*)&amp;ss)-&gt;sin_port);
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ss.ss_family == AF_INET6)
					port = ntohs(((<span class="enscript-type">struct</span> sockaddr_in6*)&amp;ss)-&gt;sin6_port);
				<span class="enscript-keyword">if</span> (!port)
					error = EPROGUNAVAIL;
			}
			<span class="enscript-comment">/* create sockaddr for MOUNT */</span>
			<span class="enscript-keyword">if</span> (!error)
				MALLOC(nsonfs-&gt;nso_saddr2, <span class="enscript-type">struct</span> sockaddr *, ss.ss_len, M_SONAME, M_WAITOK|M_ZERO);
			<span class="enscript-keyword">if</span> (!error &amp;&amp; !nsonfs-&gt;nso_saddr2)
				error = ENOMEM;
			<span class="enscript-keyword">if</span> (!error)
				bcopy(&amp;ss, nsonfs-&gt;nso_saddr2, ss.ss_len);
			<span class="enscript-keyword">if</span> (error) {
				lck_mtx_lock(&amp;nsonfs-&gt;nso_lock);
				nsonfs-&gt;nso_error = error;
				nsonfs-&gt;nso_flags |= NSO_DEAD;
				lck_mtx_unlock(&amp;nsonfs-&gt;nso_lock);
			}
		}
		nfs_socket_destroy(nso);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">keepsearching</span>;
	}

	<span class="enscript-comment">/* nso is an NFS socket */</span>
	NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s got NFS socket %p\n&quot;</span>, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nso);

	<span class="enscript-comment">/* If NFS version wasn't specified, it was determined during the connect. */</span>
	nfsvers = nmp-&gt;nm_vers ? nmp-&gt;nm_vers : (<span class="enscript-type">int</span>)nso-&gt;nso_version;

	<span class="enscript-comment">/* Perform MOUNT call for initial NFSv2/v3 connection/mount. */</span>
	<span class="enscript-keyword">if</span> ((nfsvers &lt; NFS_VER4) &amp;&amp; !(nmp-&gt;nm_sockflags &amp; NMSOCK_HASCONNECTED) &amp;&amp; !NM_OMATTR_GIVEN(nmp, FH)) {
		error = 0;
		saddr = nso-&gt;nso_saddr2;
		<span class="enscript-keyword">if</span> (!saddr) {
			<span class="enscript-comment">/* Need sockaddr for MOUNT port */</span>
			bcopy(nso-&gt;nso_saddr, &amp;ss, nso-&gt;nso_saddr-&gt;sa_len);
			port = nmp-&gt;nm_mountport;
			<span class="enscript-keyword">if</span> (ss.ss_family == AF_INET)
				((<span class="enscript-type">struct</span> sockaddr_in*)&amp;ss)-&gt;sin_port = htons(port);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ss.ss_family == AF_INET6)
				((<span class="enscript-type">struct</span> sockaddr_in6*)&amp;ss)-&gt;sin6_port = htons(port);
			<span class="enscript-keyword">if</span> (!port) {
				<span class="enscript-comment">/* Get port/sockaddr for MOUNT version corresponding to NFS version. */</span>
				<span class="enscript-type">int</span> mntvers = (nfsvers == NFS_VER2) ? RPCMNT_VER1 : RPCMNT_VER3;
				<span class="enscript-type">int</span> mntproto = (NM_OMFLAG(nmp, MNTUDP) || (nso-&gt;nso_sotype == SOCK_DGRAM)) ? IPPROTO_UDP : IPPROTO_TCP;
				error = nfs_portmap_lookup(nmp, vfs_context_current(), (<span class="enscript-type">struct</span> sockaddr*)&amp;ss,
						NULL, RPCPROG_MNT, mntvers, mntproto, timeo);
				<span class="enscript-keyword">if</span> (ss.ss_family == AF_INET)
					port = ntohs(((<span class="enscript-type">struct</span> sockaddr_in*)&amp;ss)-&gt;sin_port);
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ss.ss_family == AF_INET6)
					port = ntohs(((<span class="enscript-type">struct</span> sockaddr_in6*)&amp;ss)-&gt;sin6_port);
			}
			<span class="enscript-keyword">if</span> (!error) {
				<span class="enscript-keyword">if</span> (port)
					saddr = (<span class="enscript-type">struct</span> sockaddr*)&amp;ss;
				<span class="enscript-keyword">else</span>
					error = EPROGUNAVAIL;
			}
		}
		<span class="enscript-keyword">if</span> (saddr)
			MALLOC(fh, fhandle_t *, <span class="enscript-keyword">sizeof</span>(fhandle_t), M_TEMP, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (saddr &amp;&amp; fh)
			MALLOC_ZONE(path, <span class="enscript-type">char</span> *, MAXPATHLEN, M_NAMEI, M_WAITOK);
		<span class="enscript-keyword">if</span> (!saddr || !fh || !path) {
			<span class="enscript-keyword">if</span> (!error)
				error = ENOMEM;
			<span class="enscript-keyword">if</span> (fh)
				FREE(fh, M_TEMP);
			<span class="enscript-keyword">if</span> (path)
				FREE_ZONE(path, MAXPATHLEN, M_NAMEI);
			fh = NULL;
			path = NULL;
			nfs_socket_search_update_error(&amp;nss, error);
			nfs_socket_destroy(nso);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">keepsearching</span>;
		}
		nfs_location_mntfromname(&amp;nmp-&gt;nm_locations, nso-&gt;nso_location, path, MAXPATHLEN, 1);
		error = nfs3_mount_rpc(nmp, saddr, nso-&gt;nso_sotype, nfsvers,
				path, vfs_context_current(), timeo, fh, &amp;nmp-&gt;nm_servsec);
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s socket %p mount %d\n&quot;</span>,
			vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nso, error);
		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-comment">/* Make sure we can agree on a security flavor. */</span>
			<span class="enscript-type">int</span> o, s;  <span class="enscript-comment">/* indices into mount option and server security flavor lists */</span>
			<span class="enscript-type">int</span> found = 0;

			<span class="enscript-keyword">if</span> ((nfsvers == NFS_VER3) &amp;&amp; !nmp-&gt;nm_servsec.count) {
				<span class="enscript-comment">/* Some servers return an empty list to indicate RPCAUTH_SYS? */</span>
				nmp-&gt;nm_servsec.count = 1;
				nmp-&gt;nm_servsec.flavors[0] = RPCAUTH_SYS;
			}
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_sec.count) {
				<span class="enscript-comment">/* Choose the first flavor in our list that the server supports. */</span>
				<span class="enscript-keyword">if</span> (!nmp-&gt;nm_servsec.count) {
					<span class="enscript-comment">/* we don't know what the server supports, just use our first choice */</span>
					nmp-&gt;nm_auth = nmp-&gt;nm_sec.flavors[0];
					found = 1;
				}
				<span class="enscript-keyword">for</span> (o=0; !found &amp;&amp; (o &lt; nmp-&gt;nm_sec.count); o++)
					<span class="enscript-keyword">for</span> (s=0; !found &amp;&amp; (s &lt; nmp-&gt;nm_servsec.count); s++)
						<span class="enscript-keyword">if</span> (nmp-&gt;nm_sec.flavors[o] == nmp-&gt;nm_servsec.flavors[s]) {
							nmp-&gt;nm_auth = nmp-&gt;nm_sec.flavors[o];
							found = 1;
						}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* Choose the first one we support from the server's list. */</span>
				<span class="enscript-keyword">if</span> (!nmp-&gt;nm_servsec.count) {
					nmp-&gt;nm_auth = RPCAUTH_SYS;
					found = 1;
				}
				<span class="enscript-keyword">for</span> (s=0; s &lt; nmp-&gt;nm_servsec.count; s++)
					<span class="enscript-keyword">switch</span> (nmp-&gt;nm_servsec.flavors[s]) {
					<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_SYS</span>:
						<span class="enscript-comment">/* prefer RPCAUTH_SYS to RPCAUTH_NONE */</span>
						<span class="enscript-keyword">if</span> (found &amp;&amp; (nmp-&gt;nm_auth == RPCAUTH_NONE))
							found = 0;
					<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_NONE</span>:
					<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5</span>:
					<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5I</span>:
					<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5P</span>:
						<span class="enscript-keyword">if</span> (!found) {
							nmp-&gt;nm_auth = nmp-&gt;nm_servsec.flavors[s];
							found = 1;
						}
						<span class="enscript-keyword">break</span>;
					}
			}
			error = !found ? EAUTH : 0;
		}
		FREE_ZONE(path, MAXPATHLEN, M_NAMEI);
		path = NULL;
		<span class="enscript-keyword">if</span> (error) {
			nfs_socket_search_update_error(&amp;nss, error);
			FREE(fh, M_TEMP);
			fh = NULL;
			nfs_socket_destroy(nso);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">keepsearching</span>;
		}
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_fh)
			FREE(nmp-&gt;nm_fh, M_TEMP);
		nmp-&gt;nm_fh = fh;
		fh = NULL;
		NFS_BITMAP_SET(nmp-&gt;nm_flags, NFS_MFLAG_CALLUMNT);
	}

	<span class="enscript-comment">/* put the real upcall in place */</span>
	upcall = (nso-&gt;nso_sotype == SOCK_STREAM) ? nfs_tcp_rcv : nfs_udp_rcv;
	error = sock_setupcall(nso-&gt;nso_so, upcall, nmp);
	<span class="enscript-keyword">if</span> (error) {
		nfs_socket_search_update_error(&amp;nss, error);
		nfs_socket_destroy(nso);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">keepsearching</span>;
	}

	<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_sockflags &amp; NMSOCK_HASCONNECTED)) {
		<span class="enscript-comment">/* set mntfromname to this location */</span>
		<span class="enscript-keyword">if</span> (!NM_OMATTR_GIVEN(nmp, MNTFROM))
			nfs_location_mntfromname(&amp;nmp-&gt;nm_locations, nso-&gt;nso_location,
				vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname,
				<span class="enscript-keyword">sizeof</span>(vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname), 0);
		<span class="enscript-comment">/* some negotiated values need to remain unchanged for the life of the mount */</span>
		<span class="enscript-keyword">if</span> (!nmp-&gt;nm_sotype)
			nmp-&gt;nm_sotype = nso-&gt;nso_sotype;
		<span class="enscript-keyword">if</span> (!nmp-&gt;nm_vers) {
			nmp-&gt;nm_vers = nfsvers;
			<span class="enscript-comment">/* If we negotiated NFSv4, set nm_nfsport if we ended up on the standard NFS port */</span>
			<span class="enscript-keyword">if</span> ((nfsvers &gt;= NFS_VER4) &amp;&amp; !NFS_BITMAP_ISSET(nmp-&gt;nm_mattrs, NFS_MATTR_NFS_PORT)) {
				<span class="enscript-keyword">if</span> (nso-&gt;nso_saddr-&gt;sa_family == AF_INET)
					port = ((<span class="enscript-type">struct</span> sockaddr_in*)nso-&gt;nso_saddr)-&gt;sin_port = htons(port);
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nso-&gt;nso_saddr-&gt;sa_family == AF_INET6)
					port = ((<span class="enscript-type">struct</span> sockaddr_in6*)nso-&gt;nso_saddr)-&gt;sin6_port = htons(port);
				<span class="enscript-keyword">else</span>
					port = 0;
				<span class="enscript-keyword">if</span> (port == NFS_PORT)
					nmp-&gt;nm_nfsport = NFS_PORT;
			}
		}
		<span class="enscript-comment">/* do some version-specific pre-mount set up */</span>
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4) {
			microtime(&amp;now);
			nmp-&gt;nm_mounttime = ((uint64_t)now.tv_sec &lt;&lt; 32) | now.tv_usec;
			<span class="enscript-keyword">if</span> (!NMFLAG(nmp, NOCALLBACK))
				nfs4_mount_callback_setup(nmp);
		}
	}

	<span class="enscript-comment">/* Initialize NFS socket state variables */</span>
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	nmp-&gt;nm_srtt[0] = nmp-&gt;nm_srtt[1] = nmp-&gt;nm_srtt[2] =
		nmp-&gt;nm_srtt[3] = (NFS_TIMEO &lt;&lt; 3);
	nmp-&gt;nm_sdrtt[0] = nmp-&gt;nm_sdrtt[1] = nmp-&gt;nm_sdrtt[2] =
		nmp-&gt;nm_sdrtt[3] = 0;
	<span class="enscript-keyword">if</span> (nso-&gt;nso_sotype == SOCK_DGRAM) {
		nmp-&gt;nm_cwnd = NFS_MAXCWND / 2;	    <span class="enscript-comment">/* Initial send window */</span>
		nmp-&gt;nm_sent = 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nso-&gt;nso_sotype == SOCK_STREAM) {
		nmp-&gt;nm_timeouts = 0;
	}
	nmp-&gt;nm_sockflags &amp;= ~NMSOCK_CONNECTING;
	nmp-&gt;nm_sockflags |= NMSOCK_SETUP;
	<span class="enscript-comment">/* move the socket to the mount structure */</span>
	nmp-&gt;nm_nso = nso;
	oldsaddr = nmp-&gt;nm_saddr;
	nmp-&gt;nm_saddr = nso-&gt;nso_saddr;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	error = nfs_connect_setup(nmp);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	nmp-&gt;nm_sockflags &amp;= ~NMSOCK_SETUP;
	<span class="enscript-keyword">if</span> (!error) {
		nmp-&gt;nm_sockflags |= NMSOCK_READY;
		wakeup(&amp;nmp-&gt;nm_sockflags);
	}
	<span class="enscript-keyword">if</span> (error) {
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s socket %p setup failed %d\n&quot;</span>,
			vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, nso, error);
		nfs_socket_search_update_error(&amp;nss, error);
		nmp-&gt;nm_saddr = oldsaddr;
		<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_sockflags &amp; NMSOCK_HASCONNECTED)) {
			<span class="enscript-comment">/* undo settings made prior to setup */</span>
			<span class="enscript-keyword">if</span> (!NFS_BITMAP_ISSET(nmp-&gt;nm_mattrs, NFS_MATTR_SOCKET_TYPE))
				nmp-&gt;nm_sotype = 0;
			<span class="enscript-keyword">if</span> (!NFS_BITMAP_ISSET(nmp-&gt;nm_mattrs, NFS_MATTR_NFS_VERSION)) {
				<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4) {
					<span class="enscript-keyword">if</span> (!NFS_BITMAP_ISSET(nmp-&gt;nm_mattrs, NFS_MATTR_NFS_PORT))
						nmp-&gt;nm_nfsport = 0;
					<span class="enscript-keyword">if</span> (nmp-&gt;nm_cbid)
						nfs4_mount_callback_shutdown(nmp);
					<span class="enscript-keyword">if</span> (IS_VALID_CRED(nmp-&gt;nm_mcred))
						kauth_cred_unref(&amp;nmp-&gt;nm_mcred);
					bzero(&amp;nmp-&gt;nm_un, <span class="enscript-keyword">sizeof</span>(nmp-&gt;nm_un));
				}
				nmp-&gt;nm_vers = 0;
			}
		}
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		nmp-&gt;nm_nso = NULL;
		nfs_socket_destroy(nso);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">keepsearching</span>;
	}

	<span class="enscript-comment">/* update current location */</span>
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_locations.nl_current.nli_flags &amp; NLI_VALID) &amp;&amp;
	    (nmp-&gt;nm_locations.nl_current.nli_serv != nso-&gt;nso_location.nli_serv)) {
		<span class="enscript-comment">/* server has changed, we should initiate failover/recovery */</span>
		<span class="enscript-comment">// XXX
</span>	}
	nmp-&gt;nm_locations.nl_current = nso-&gt;nso_location;
	nmp-&gt;nm_locations.nl_current.nli_flags |= NLI_VALID;

	<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_sockflags &amp; NMSOCK_HASCONNECTED)) {
		<span class="enscript-comment">/* We have now successfully connected... make a note of it. */</span>
		nmp-&gt;nm_sockflags |= NMSOCK_HASCONNECTED;
	}

	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (oldsaddr)
		FREE(oldsaddr, M_SONAME);

	<span class="enscript-keyword">if</span> (nss.nss_flags &amp; NSS_WARNED)
		log(LOG_INFO, <span class="enscript-string">&quot;nfs_connect: socket connect completed for %s\n&quot;</span>,
			vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname);

	nmp-&gt;nm_nss = NULL;
	nfs_socket_search_cleanup(&amp;nss);
	<span class="enscript-keyword">if</span> (fh)
		FREE(fh, M_TEMP);
	<span class="enscript-keyword">if</span> (path)
		FREE_ZONE(path, MAXPATHLEN, M_NAMEI);
	NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs connect %s success\n&quot;</span>, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/* setup &amp; confirm socket connection is functional */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_connect_setup</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers &gt;= NFS_VER4) {
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; NFSSTA_CLIENTID) {
			<span class="enscript-comment">/* first, try to renew our current state */</span>
			error = nfs4_renew(nmp, R_SETUP);
			<span class="enscript-keyword">if</span> ((error == NFSERR_ADMIN_REVOKED) ||
			    (error == NFSERR_CB_PATH_DOWN) ||
			    (error == NFSERR_EXPIRED) ||
			    (error == NFSERR_LEASE_MOVED) ||
			    (error == NFSERR_STALE_CLIENTID)) {
				lck_mtx_lock(&amp;nmp-&gt;nm_lock);
				nfs_need_recover(nmp, error);
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			}
		}
		error = nfs4_setclientid(nmp);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS socket reconnect routine:
 * Called when a connection is broken.
 * - disconnect the old socket
 * - nfs_connect() again
 * - set R_MUSTRESEND for all outstanding requests on mount point
 * If this fails the mount point is DEAD!
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_reconnect</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">struct</span> nfsreq *rq;
	<span class="enscript-type">struct</span> timeval now;
	thread_t thd = current_thread();
	<span class="enscript-type">int</span> error, wentdown = 0, verbose = 1;
	time_t lastmsg;
	<span class="enscript-type">int</span> timeo;

	microuptime(&amp;now);
	lastmsg = now.tv_sec - (nmp-&gt;nm_tprintf_delay - nmp-&gt;nm_tprintf_initial_delay);

	nfs_disconnect(nmp);


	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	timeo = nfs_is_squishy(nmp) ? 8 : 30;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-keyword">while</span> ((error = nfs_connect(nmp, verbose, timeo))) {
		verbose = 0;
		nfs_disconnect(nmp);
		<span class="enscript-keyword">if</span> ((error == EINTR) || (error == ERESTART))
			<span class="enscript-keyword">return</span> (EINTR);
		<span class="enscript-keyword">if</span> (error == EIO)
			<span class="enscript-keyword">return</span> (EIO);
		microuptime(&amp;now);
		<span class="enscript-keyword">if</span> ((lastmsg + nmp-&gt;nm_tprintf_delay) &lt; now.tv_sec) {
			lastmsg = now.tv_sec;
			nfs_down(nmp, thd, error, NFSSTA_TIMEO, <span class="enscript-string">&quot;can not connect&quot;</span>, 0);
			wentdown = 1;
		}
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_state &amp; NFSSTA_MOUNTED)) {
			<span class="enscript-comment">/* we're not yet completely mounted and */</span>
			<span class="enscript-comment">/* we can't reconnect, so we fail */</span>
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			NFS_SOCK_DBG(<span class="enscript-string">&quot;Not mounted returning %d\n&quot;</span>, error);
			<span class="enscript-keyword">return</span> (error);
		}

		<span class="enscript-keyword">if</span> (nfs_mount_check_dead_timeout(nmp)) {
			nfs_mount_make_zombie(nmp);
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">return</span> (ENXIO);
		}
		
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(nmp, NULL, thd, 1))) {
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">return</span> (error);
		}
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		tsleep(nfs_reconnect, PSOCK, <span class="enscript-string">&quot;nfs_reconnect_delay&quot;</span>, 2*hz);
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(nmp, NULL, thd, 0)))
			<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> (wentdown)
		nfs_up(nmp, thd, NFSSTA_TIMEO, <span class="enscript-string">&quot;connected&quot;</span>);

	<span class="enscript-comment">/*
	 * Loop through outstanding request list and mark all requests
	 * as needing a resend.  (Though nfs_need_reconnect() probably
	 * marked them all already.)
	 */</span>
	lck_mtx_lock(nfs_request_mutex);
	TAILQ_FOREACH(rq, &amp;nfs_reqq, r_chain) {
		<span class="enscript-keyword">if</span> (rq-&gt;r_nmp == nmp) {
			lck_mtx_lock(&amp;rq-&gt;r_mtx);
			<span class="enscript-keyword">if</span> (!rq-&gt;r_error &amp;&amp; !rq-&gt;r_nmrep.nmc_mhead &amp;&amp; !(rq-&gt;r_flags &amp; R_MUSTRESEND)) {
				rq-&gt;r_flags |= R_MUSTRESEND;
				rq-&gt;r_rtt = -1;
				wakeup(rq);
				<span class="enscript-keyword">if</span> ((rq-&gt;r_flags &amp; (R_IOD|R_ASYNC|R_ASYNCWAIT|R_SENDING)) == R_ASYNC)
					nfs_asyncio_resend(rq);
			}
			lck_mtx_unlock(&amp;rq-&gt;r_mtx);
		}
	}
	lck_mtx_unlock(nfs_request_mutex);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * NFS disconnect. Clean up and unlink.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_disconnect</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">struct</span> nfs_socket *nso;

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
<span class="enscript-reference">tryagain</span>:
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_nso) {
		<span class="enscript-type">struct</span> timespec ts = { 1, 0 };
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; NFSSTA_SENDING) { <span class="enscript-comment">/* wait for sending to complete */</span>
			nmp-&gt;nm_state |= NFSSTA_WANTSND;
			msleep(&amp;nmp-&gt;nm_state, &amp;nmp-&gt;nm_lock, PZERO-1, <span class="enscript-string">&quot;nfswaitsending&quot;</span>, &amp;ts);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
		}
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_sockflags &amp; NMSOCK_POKE) { <span class="enscript-comment">/* wait for poking to complete */</span>
			msleep(&amp;nmp-&gt;nm_sockflags, &amp;nmp-&gt;nm_lock, PZERO-1, <span class="enscript-string">&quot;nfswaitpoke&quot;</span>, &amp;ts);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
		}
		nmp-&gt;nm_sockflags |= NMSOCK_DISCONNECTING;
		nmp-&gt;nm_sockflags &amp;= ~NMSOCK_READY;
		nso = nmp-&gt;nm_nso;
		nmp-&gt;nm_nso = NULL;
		<span class="enscript-keyword">if</span> (nso-&gt;nso_saddr == nmp-&gt;nm_saddr)
			nso-&gt;nso_saddr = NULL;
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		nfs_socket_destroy(nso);
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		nmp-&gt;nm_sockflags &amp;= ~NMSOCK_DISCONNECTING;
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	} <span class="enscript-keyword">else</span> {
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	}
}

<span class="enscript-comment">/*
 * mark an NFS mount as needing a reconnect/resends.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_need_reconnect</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">struct</span> nfsreq *rq;

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	nmp-&gt;nm_sockflags &amp;= ~(NMSOCK_READY|NMSOCK_SETUP);
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-comment">/*
	 * Loop through outstanding request list and
	 * mark all requests as needing a resend.
	 */</span>
	lck_mtx_lock(nfs_request_mutex);
	TAILQ_FOREACH(rq, &amp;nfs_reqq, r_chain) {
		<span class="enscript-keyword">if</span> (rq-&gt;r_nmp == nmp) {
			lck_mtx_lock(&amp;rq-&gt;r_mtx);
			<span class="enscript-keyword">if</span> (!rq-&gt;r_error &amp;&amp; !rq-&gt;r_nmrep.nmc_mhead &amp;&amp; !(rq-&gt;r_flags &amp; R_MUSTRESEND)) {
				rq-&gt;r_flags |= R_MUSTRESEND;
				rq-&gt;r_rtt = -1;
				wakeup(rq);
				<span class="enscript-keyword">if</span> ((rq-&gt;r_flags &amp; (R_IOD|R_ASYNC|R_ASYNCWAIT|R_SENDING)) == R_ASYNC)
					nfs_asyncio_resend(rq);
			}
			lck_mtx_unlock(&amp;rq-&gt;r_mtx);
		}
	}
	lck_mtx_unlock(nfs_request_mutex);
}


<span class="enscript-comment">/*
 * thread to handle miscellaneous async NFS socket work (reconnects/resends)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_mount_sock_thread</span>(<span class="enscript-type">void</span> *arg, __unused wait_result_t wr)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = arg;
	<span class="enscript-type">struct</span> timespec ts = { 30, 0 };
	thread_t thd = current_thread();
	<span class="enscript-type">struct</span> nfsreq *req;
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">int</span> error, dofinish;
	nfsnode_t np;
	<span class="enscript-type">int</span> do_reconnect_sleep = 0;

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">while</span> (!(nmp-&gt;nm_sockflags &amp; NMSOCK_READY) ||
	       !TAILQ_EMPTY(&amp;nmp-&gt;nm_resendq) ||
	       !LIST_EMPTY(&amp;nmp-&gt;nm_monlist) ||
	       nmp-&gt;nm_deadto_start ||
	       (nmp-&gt;nm_state &amp; NFSSTA_RECOVER) ||
	       ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; !TAILQ_EMPTY(&amp;nmp-&gt;nm_dreturnq)))
	{
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_sockflags &amp; NMSOCK_UNMOUNT)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* do reconnect, if necessary */</span>
		<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_sockflags &amp; NMSOCK_READY) &amp;&amp; !(nmp-&gt;nm_state &amp; (NFSSTA_FORCE|NFSSTA_DEAD))) {
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_reconnect_start &lt;= 0) {
				microuptime(&amp;now);
				nmp-&gt;nm_reconnect_start = now.tv_sec;
			}
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs reconnect %s\n&quot;</span>, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname);
			<span class="enscript-comment">/*
			 * XXX We don't want to call reconnect again right away if returned errors 
			 * before that may not have blocked. This has caused spamming null procs
			 * from machines in the pass.
			 */</span>
			<span class="enscript-keyword">if</span> (do_reconnect_sleep)
				tsleep(nfs_mount_sock_thread, PSOCK, <span class="enscript-string">&quot;nfs_reconnect_sock_thread_delay&quot;</span>, hz);
			error = nfs_reconnect(nmp);
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-type">int</span> lvl = 7;
				<span class="enscript-keyword">if</span> (error == EIO || error == EINTR) {
					lvl = (do_reconnect_sleep++ % 600) ? 7 : 0;
				}
				nfs_printf(NFS_FAC_SOCK, lvl, <span class="enscript-string">&quot;nfs reconnect %s: returned %d\n&quot;</span>,
					   vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, error);
			} <span class="enscript-keyword">else</span> {
				nmp-&gt;nm_reconnect_start = 0;
				do_reconnect_sleep = 0;
			}
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		}
		<span class="enscript-keyword">if</span> ((nmp-&gt;nm_sockflags &amp; NMSOCK_READY) &amp;&amp;
		    (nmp-&gt;nm_state &amp; NFSSTA_RECOVER) &amp;&amp;
		    !(nmp-&gt;nm_sockflags &amp; NMSOCK_UNMOUNT) &amp;&amp;
		    !(nmp-&gt;nm_state &amp; (NFSSTA_FORCE|NFSSTA_DEAD))) {
			<span class="enscript-comment">/* perform state recovery */</span>
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			nfs_recover(nmp);
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		}
		<span class="enscript-comment">/* handle NFSv4 delegation returns */</span>
		<span class="enscript-keyword">while</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; !(nmp-&gt;nm_state &amp; (NFSSTA_FORCE|NFSSTA_DEAD)) &amp;&amp;
		       (nmp-&gt;nm_sockflags &amp; NMSOCK_READY) &amp;&amp; !(nmp-&gt;nm_state &amp; NFSSTA_RECOVER) &amp;&amp;
		       ((np = TAILQ_FIRST(&amp;nmp-&gt;nm_dreturnq)))) {
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			nfs4_delegation_return(np, R_RECOVER, thd, nmp-&gt;nm_mcred);
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		}
		<span class="enscript-comment">/* do resends, if necessary/possible */</span>
		<span class="enscript-keyword">while</span> ((((nmp-&gt;nm_sockflags &amp; NMSOCK_READY) &amp;&amp; !(nmp-&gt;nm_state &amp; NFSSTA_RECOVER)) ||
			(nmp-&gt;nm_state &amp; (NFSSTA_FORCE|NFSSTA_DEAD))) &amp;&amp;
		       ((req = TAILQ_FIRST(&amp;nmp-&gt;nm_resendq)))) {
			<span class="enscript-keyword">if</span> (req-&gt;r_resendtime)
				microuptime(&amp;now);
			<span class="enscript-keyword">while</span> (req &amp;&amp; !(nmp-&gt;nm_state &amp; (NFSSTA_FORCE|NFSSTA_DEAD)) &amp;&amp; req-&gt;r_resendtime &amp;&amp; (now.tv_sec &lt; req-&gt;r_resendtime))
				req = TAILQ_NEXT(req, r_rchain);
			<span class="enscript-keyword">if</span> (!req)
				<span class="enscript-keyword">break</span>;
			TAILQ_REMOVE(&amp;nmp-&gt;nm_resendq, req, r_rchain);
			req-&gt;r_rchain.tqe_next = NFSREQNOLIST;
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			lck_mtx_lock(&amp;req-&gt;r_mtx);
			<span class="enscript-comment">/* Note that we have a reference on the request that was taken nfs_asyncio_resend */</span>
			<span class="enscript-keyword">if</span> (req-&gt;r_error || req-&gt;r_nmrep.nmc_mhead) {
				dofinish = req-&gt;r_callback.rcb_func &amp;&amp; !(req-&gt;r_flags &amp; R_WAITSENT);
				req-&gt;r_flags &amp;= ~R_RESENDQ;
				wakeup(req);
				lck_mtx_unlock(&amp;req-&gt;r_mtx);
				<span class="enscript-keyword">if</span> (dofinish)
					nfs_asyncio_finish(req);
				nfs_request_rele(req);
				lck_mtx_lock(&amp;nmp-&gt;nm_lock);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-keyword">if</span> ((req-&gt;r_flags &amp; R_RESTART) || nfs_request_using_gss(req)) {
				req-&gt;r_flags &amp;= ~R_RESTART;
				req-&gt;r_resendtime = 0;
				lck_mtx_unlock(&amp;req-&gt;r_mtx);
				<span class="enscript-comment">/* async RPCs on GSS mounts need to be rebuilt and resent. */</span>
				nfs_reqdequeue(req);
				<span class="enscript-keyword">if</span> (nfs_request_using_gss(req)) {
					nfs_gss_clnt_rpcdone(req);
					error = nfs_gss_clnt_args_restore(req);
					<span class="enscript-keyword">if</span> (error == ENEEDAUTH)
						req-&gt;r_xid = 0;
				}
				NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs async%s restart: p %d x 0x%llx f 0x%x rtt %d\n&quot;</span>,
					nfs_request_using_gss(req) ? <span class="enscript-string">&quot; gss&quot;</span> : <span class="enscript-string">&quot;&quot;</span>, req-&gt;r_procnum, req-&gt;r_xid,
					req-&gt;r_flags, req-&gt;r_rtt);
				error = nfs_sigintr(nmp, req, req-&gt;r_thread, 0);
				<span class="enscript-keyword">if</span> (!error)
					error = nfs_request_add_header(req);
				<span class="enscript-keyword">if</span> (!error)
					error = nfs_request_send(req, 0);
				lck_mtx_lock(&amp;req-&gt;r_mtx);
				<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_RESENDQ)
					req-&gt;r_flags &amp;= ~R_RESENDQ;
				<span class="enscript-keyword">if</span> (error)
					req-&gt;r_error = error;
				wakeup(req);
				dofinish = error &amp;&amp; req-&gt;r_callback.rcb_func &amp;&amp; !(req-&gt;r_flags &amp; R_WAITSENT);
				lck_mtx_unlock(&amp;req-&gt;r_mtx);
				<span class="enscript-keyword">if</span> (dofinish)
					nfs_asyncio_finish(req);
				nfs_request_rele(req);
				lck_mtx_lock(&amp;nmp-&gt;nm_lock);
				error = 0;
				<span class="enscript-keyword">continue</span>;
			}
			NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs async resend: p %d x 0x%llx f 0x%x rtt %d\n&quot;</span>,
				req-&gt;r_procnum, req-&gt;r_xid, req-&gt;r_flags, req-&gt;r_rtt);
			error = nfs_sigintr(nmp, req, req-&gt;r_thread, 0);
			<span class="enscript-keyword">if</span> (!error) {
				req-&gt;r_flags |= R_SENDING;
				lck_mtx_unlock(&amp;req-&gt;r_mtx);
				error = nfs_send(req, 0);
				lck_mtx_lock(&amp;req-&gt;r_mtx);
				<span class="enscript-keyword">if</span> (!error) {
					<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_RESENDQ)
						req-&gt;r_flags &amp;= ~R_RESENDQ;
					wakeup(req);
					lck_mtx_unlock(&amp;req-&gt;r_mtx);
					nfs_request_rele(req);
					lck_mtx_lock(&amp;nmp-&gt;nm_lock);
					<span class="enscript-keyword">continue</span>;
				}
			}
			req-&gt;r_error = error;
			<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_RESENDQ)
				req-&gt;r_flags &amp;= ~R_RESENDQ;
			wakeup(req);
			dofinish = req-&gt;r_callback.rcb_func &amp;&amp; !(req-&gt;r_flags &amp; R_WAITSENT);
			lck_mtx_unlock(&amp;req-&gt;r_mtx);
			<span class="enscript-keyword">if</span> (dofinish)
				nfs_asyncio_finish(req);
			nfs_request_rele(req);
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		}
		<span class="enscript-keyword">if</span> (nfs_mount_check_dead_timeout(nmp)) {
			nfs_mount_make_zombie(nmp);
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; (NFSSTA_FORCE|NFSSTA_DEAD))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* check monitored nodes, if necessary/possible */</span>
		<span class="enscript-keyword">if</span> (!LIST_EMPTY(&amp;nmp-&gt;nm_monlist)) {
			nmp-&gt;nm_state |= NFSSTA_MONITOR_SCAN;
			LIST_FOREACH(np, &amp;nmp-&gt;nm_monlist, n_monlink) {
				<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_sockflags &amp; NMSOCK_READY) ||
				    (nmp-&gt;nm_state &amp; (NFSSTA_RECOVER|NFSSTA_UNMOUNTING|NFSSTA_FORCE|NFSSTA_DEAD)))
					<span class="enscript-keyword">break</span>;
				np-&gt;n_mflag |= NMMONSCANINPROG;
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
				error = nfs_getattr(np, NULL, vfs_context_kernel(), (NGA_UNCACHED|NGA_MONITOR));
				<span class="enscript-keyword">if</span> (!error &amp;&amp; ISSET(np-&gt;n_flag, NUPDATESIZE)) <span class="enscript-comment">/* update quickly to avoid multiple events */</span>
					nfs_data_update_size(np, 0);
				lck_mtx_lock(&amp;nmp-&gt;nm_lock);
				np-&gt;n_mflag &amp;= ~NMMONSCANINPROG;
				<span class="enscript-keyword">if</span> (np-&gt;n_mflag &amp; NMMONSCANWANT) {
					np-&gt;n_mflag &amp;= ~NMMONSCANWANT;
					wakeup(&amp;np-&gt;n_mflag);
				}
				<span class="enscript-keyword">if</span> (error || !(nmp-&gt;nm_sockflags &amp; NMSOCK_READY) ||
				    (nmp-&gt;nm_state &amp; (NFSSTA_RECOVER|NFSSTA_UNMOUNTING|NFSSTA_FORCE|NFSSTA_DEAD)))
					<span class="enscript-keyword">break</span>;
			}
			nmp-&gt;nm_state &amp;= ~NFSSTA_MONITOR_SCAN;
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; NFSSTA_UNMOUNTING)
				wakeup(&amp;nmp-&gt;nm_state); <span class="enscript-comment">/* let unmounting thread know scan is done */</span>
		}
		<span class="enscript-keyword">if</span> ((nmp-&gt;nm_sockflags &amp; NMSOCK_READY) || (nmp-&gt;nm_state &amp; (NFSSTA_RECOVER|NFSSTA_UNMOUNTING))) {
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_deadto_start || !TAILQ_EMPTY(&amp;nmp-&gt;nm_resendq) ||
			    (nmp-&gt;nm_state &amp; NFSSTA_RECOVER))
				ts.tv_sec = 1;
			<span class="enscript-keyword">else</span>
				ts.tv_sec = 5;
			msleep(&amp;nmp-&gt;nm_sockthd, &amp;nmp-&gt;nm_lock, PSOCK, <span class="enscript-string">&quot;nfssockthread&quot;</span>, &amp;ts);
		}
	}

	<span class="enscript-comment">/* If we're unmounting, send the unmount RPC, if requested/appropriate. */</span>
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_sockflags &amp; NMSOCK_UNMOUNT) &amp;&amp;
	    (nmp-&gt;nm_state &amp; NFSSTA_MOUNTED) &amp;&amp; NMFLAG(nmp, CALLUMNT) &amp;&amp;
	    (nmp-&gt;nm_vers &lt; NFS_VER4) &amp;&amp; !(nmp-&gt;nm_state &amp; (NFSSTA_FORCE|NFSSTA_DEAD))) {
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		nfs3_umount_rpc(nmp, vfs_context_kernel(),
			(nmp-&gt;nm_sockflags &amp; NMSOCK_READY) ? 6 : 2);
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	}

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_sockthd == thd)
		nmp-&gt;nm_sockthd = NULL;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	wakeup(&amp;nmp-&gt;nm_sockthd);
	thread_terminate(thd);
}

<span class="enscript-comment">/* start or wake a mount's socket thread */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_mount_sock_thread_wake</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_sockthd)
		wakeup(&amp;nmp-&gt;nm_sockthd);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kernel_thread_start(nfs_mount_sock_thread, nmp, &amp;nmp-&gt;nm_sockthd) == KERN_SUCCESS)
		thread_deallocate(nmp-&gt;nm_sockthd);
}

<span class="enscript-comment">/*
 * Check if we should mark the mount dead because the
 * unresponsive mount has reached the dead timeout.
 * (must be called with nmp locked)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_mount_check_dead_timeout</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">struct</span> timeval now;

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; NFSSTA_DEAD)
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_deadto_start == 0)
		<span class="enscript-keyword">return</span> 0;
	nfs_is_squishy(nmp);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_curdeadtimeout &lt;= 0)
		<span class="enscript-keyword">return</span> 0;
	microuptime(&amp;now);
	<span class="enscript-keyword">if</span> ((now.tv_sec - nmp-&gt;nm_deadto_start) &lt; nmp-&gt;nm_curdeadtimeout)
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">return</span> 1;
}

<span class="enscript-comment">/*
 * Call nfs_mount_zombie to remove most of the
 * nfs state for the mount, and then ask to be forcibly unmounted.
 *
 * Assumes the nfs mount structure lock nm_lock is held.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_mount_make_zombie</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	fsid_t fsid;
	
	<span class="enscript-keyword">if</span> (!nmp)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; NFSSTA_DEAD)
		<span class="enscript-keyword">return</span>;

	printf(<span class="enscript-string">&quot;nfs server %s: %sdead\n&quot;</span>, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname,
	       (nmp-&gt;nm_curdeadtimeout != nmp-&gt;nm_deadtimeout) ? <span class="enscript-string">&quot;squished &quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
	fsid = vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_fsid;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	nfs_mount_zombie(nmp, NFSSTA_DEAD);
	vfs_event_signal(&amp;fsid, VQ_DEAD, 0);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
}


<span class="enscript-comment">/*
 * NFS callback channel socket state
 */</span>
<span class="enscript-type">struct</span> nfs_callback_socket
{
	TAILQ_ENTRY(nfs_callback_socket) ncbs_link;
	socket_t			ncbs_so;	<span class="enscript-comment">/* the socket */</span>
	<span class="enscript-type">struct</span> sockaddr_storage		ncbs_saddr;	<span class="enscript-comment">/* socket address */</span>
	<span class="enscript-type">struct</span> nfs_rpc_record_state	ncbs_rrs;	<span class="enscript-comment">/* RPC record parsing state */</span>
	time_t				ncbs_stamp;	<span class="enscript-comment">/* last accessed at */</span>
	uint32_t			ncbs_flags;	<span class="enscript-comment">/* see below */</span>
};
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NCBSOCK_UPCALL</span>		0x0001
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NCBSOCK_UPCALLWANT</span>	0x0002
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NCBSOCK_DEAD</span>		0x0004

<span class="enscript-comment">/*
 * NFS callback channel state
 *
 * One listening socket for accepting socket connections from servers and
 * a list of connected sockets to handle callback requests on.
 * Mounts registered with the callback channel are assigned IDs and
 * put on a list so that the callback request handling code can match
 * the requests up with mounts.
 */</span>
socket_t nfs4_cb_so = NULL;
socket_t nfs4_cb_so6 = NULL;
in_port_t nfs4_cb_port = 0;
in_port_t nfs4_cb_port6 = 0;
uint32_t nfs4_cb_id = 0;
uint32_t nfs4_cb_so_usecount = 0;
<span class="enscript-function-name">TAILQ_HEAD</span>(nfs4_cb_sock_list,nfs_callback_socket) nfs4_cb_socks;
<span class="enscript-function-name">TAILQ_HEAD</span>(nfs4_cb_mount_list,nfsmount) nfs4_cb_mounts;

<span class="enscript-type">int</span> <span class="enscript-function-name">nfs4_cb_handler</span>(<span class="enscript-type">struct</span> nfs_callback_socket *, mbuf_t);

<span class="enscript-comment">/*
 * Set up the callback channel for the NFS mount.
 *
 * Initializes the callback channel socket state and
 * assigns a callback ID to the mount.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs4_mount_callback_setup</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">struct</span> sockaddr_in sin;
	<span class="enscript-type">struct</span> sockaddr_in6 sin6;
	socket_t so = NULL;
	socket_t so6 = NULL;
	<span class="enscript-type">struct</span> timeval timeo;
	<span class="enscript-type">int</span> error, on = 1;
	in_port_t port;

	lck_mtx_lock(nfs_global_mutex);
	<span class="enscript-keyword">if</span> (nfs4_cb_id == 0) {
		TAILQ_INIT(&amp;nfs4_cb_mounts);
		TAILQ_INIT(&amp;nfs4_cb_socks);
		nfs4_cb_id++;
	}
	nmp-&gt;nm_cbid = nfs4_cb_id++;
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_cbid == 0)
		nmp-&gt;nm_cbid = nfs4_cb_id++;
	nfs4_cb_so_usecount++;
	TAILQ_INSERT_HEAD(&amp;nfs4_cb_mounts, nmp, nm_cblink);

	<span class="enscript-keyword">if</span> (nfs4_cb_so) {
		lck_mtx_unlock(nfs_global_mutex);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* IPv4 */</span>
	error = sock_socket(AF_INET, SOCK_STREAM, IPPROTO_TCP, nfs4_cb_accept, NULL, &amp;nfs4_cb_so);
	<span class="enscript-keyword">if</span> (error) {
		log(LOG_INFO, <span class="enscript-string">&quot;nfs callback setup: error %d creating listening IPv4 socket\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	so = nfs4_cb_so;

	sock_setsockopt(so, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	sin.sin_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in);
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = htonl(INADDR_ANY);
	sin.sin_port = htons(nfs_callback_port); <span class="enscript-comment">/* try to use specified port */</span>
	error = sock_bind(so, (<span class="enscript-type">struct</span> sockaddr *)&amp;sin);
	<span class="enscript-keyword">if</span> (error) {
		log(LOG_INFO, <span class="enscript-string">&quot;nfs callback setup: error %d binding listening IPv4 socket\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	error = sock_getsockname(so, (<span class="enscript-type">struct</span> sockaddr *)&amp;sin, sin.sin_len);
	<span class="enscript-keyword">if</span> (error) {
		log(LOG_INFO, <span class="enscript-string">&quot;nfs callback setup: error %d getting listening IPv4 socket port\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	nfs4_cb_port = ntohs(sin.sin_port);

	error = sock_listen(so, 32);
	<span class="enscript-keyword">if</span> (error) {
		log(LOG_INFO, <span class="enscript-string">&quot;nfs callback setup: error %d on IPv4 listen\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-comment">/* receive timeout shouldn't matter.  If timeout on send, we'll want to drop the socket */</span>
	timeo.tv_usec = 0;
	timeo.tv_sec = 60;
	error = sock_setsockopt(so, SOL_SOCKET, SO_RCVTIMEO, &amp;timeo, <span class="enscript-keyword">sizeof</span>(timeo));
	<span class="enscript-keyword">if</span> (error)
		log(LOG_INFO, <span class="enscript-string">&quot;nfs callback setup: error %d setting IPv4 socket rx timeout\n&quot;</span>, error);
	error = sock_setsockopt(so, SOL_SOCKET, SO_SNDTIMEO, &amp;timeo, <span class="enscript-keyword">sizeof</span>(timeo));
	<span class="enscript-keyword">if</span> (error)
		log(LOG_INFO, <span class="enscript-string">&quot;nfs callback setup: error %d setting IPv4 socket tx timeout\n&quot;</span>, error);
	sock_setsockopt(so, IPPROTO_TCP, TCP_NODELAY, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	sock_setsockopt(so, SOL_SOCKET, SO_NOADDRERR, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	sock_setsockopt(so, SOL_SOCKET, SO_UPCALLCLOSEWAIT, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	error = 0;

	<span class="enscript-comment">/* IPv6 */</span>
	error = sock_socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP, nfs4_cb_accept, NULL, &amp;nfs4_cb_so6);
	<span class="enscript-keyword">if</span> (error) {
		log(LOG_INFO, <span class="enscript-string">&quot;nfs callback setup: error %d creating listening IPv6 socket\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	so6 = nfs4_cb_so6;

	sock_setsockopt(so6, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	sock_setsockopt(so6, IPPROTO_IPV6, IPV6_V6ONLY, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	<span class="enscript-comment">/* try to use specified port or same port as IPv4 */</span>
	port = nfs_callback_port ? nfs_callback_port : nfs4_cb_port;
<span class="enscript-reference">ipv6_bind_again</span>:
	sin6.sin6_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
	sin6.sin6_family = AF_INET6;
	sin6.sin6_addr = in6addr_any;
	sin6.sin6_port = htons(port);
	error = sock_bind(so6, (<span class="enscript-type">struct</span> sockaddr *)&amp;sin6);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (port != nfs_callback_port) {
			<span class="enscript-comment">/* if we simply tried to match the IPv4 port, then try any port */</span>
			port = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">ipv6_bind_again</span>;
		}
		log(LOG_INFO, <span class="enscript-string">&quot;nfs callback setup: error %d binding listening IPv6 socket\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	error = sock_getsockname(so6, (<span class="enscript-type">struct</span> sockaddr *)&amp;sin6, sin6.sin6_len);
	<span class="enscript-keyword">if</span> (error) {
		log(LOG_INFO, <span class="enscript-string">&quot;nfs callback setup: error %d getting listening IPv6 socket port\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}
	nfs4_cb_port6 = ntohs(sin6.sin6_port);

	error = sock_listen(so6, 32);
	<span class="enscript-keyword">if</span> (error) {
		log(LOG_INFO, <span class="enscript-string">&quot;nfs callback setup: error %d on IPv6 listen\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-comment">/* receive timeout shouldn't matter.  If timeout on send, we'll want to drop the socket */</span>
	timeo.tv_usec = 0;
	timeo.tv_sec = 60;
	error = sock_setsockopt(so6, SOL_SOCKET, SO_RCVTIMEO, &amp;timeo, <span class="enscript-keyword">sizeof</span>(timeo));
	<span class="enscript-keyword">if</span> (error)
		log(LOG_INFO, <span class="enscript-string">&quot;nfs callback setup: error %d setting IPv6 socket rx timeout\n&quot;</span>, error);
	error = sock_setsockopt(so6, SOL_SOCKET, SO_SNDTIMEO, &amp;timeo, <span class="enscript-keyword">sizeof</span>(timeo));
	<span class="enscript-keyword">if</span> (error)
		log(LOG_INFO, <span class="enscript-string">&quot;nfs callback setup: error %d setting IPv6 socket tx timeout\n&quot;</span>, error);
	sock_setsockopt(so6, IPPROTO_TCP, TCP_NODELAY, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	sock_setsockopt(so6, SOL_SOCKET, SO_NOADDRERR, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	sock_setsockopt(so6, SOL_SOCKET, SO_UPCALLCLOSEWAIT, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	error = 0;

<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">if</span> (error) {
		nfs4_cb_so = nfs4_cb_so6 = NULL;
		lck_mtx_unlock(nfs_global_mutex);
		<span class="enscript-keyword">if</span> (so) {
			sock_shutdown(so, SHUT_RDWR);
			sock_close(so);
		}
		<span class="enscript-keyword">if</span> (so6) {
			sock_shutdown(so6, SHUT_RDWR);
			sock_close(so6);
		}
	} <span class="enscript-keyword">else</span> {
		lck_mtx_unlock(nfs_global_mutex);
	}
}

<span class="enscript-comment">/*
 * Shut down the callback channel for the NFS mount.
 *
 * Clears the mount's callback ID and releases the mounts
 * reference on the callback socket.  Last reference dropped
 * will also shut down the callback socket(s).
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs4_mount_callback_shutdown</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">struct</span> nfs_callback_socket *ncbsp;
	socket_t so, so6;
	<span class="enscript-type">struct</span> nfs4_cb_sock_list cb_socks;
	<span class="enscript-type">struct</span> timespec ts = {1,0};

	lck_mtx_lock(nfs_global_mutex);
	TAILQ_REMOVE(&amp;nfs4_cb_mounts, nmp, nm_cblink);
	<span class="enscript-comment">/* wait for any callbacks in progress to complete */</span>
	<span class="enscript-keyword">while</span> (nmp-&gt;nm_cbrefs)
		msleep(&amp;nmp-&gt;nm_cbrefs, nfs_global_mutex, PSOCK, <span class="enscript-string">&quot;cbshutwait&quot;</span>, &amp;ts);
	nmp-&gt;nm_cbid = 0;
	<span class="enscript-keyword">if</span> (--nfs4_cb_so_usecount) {
		lck_mtx_unlock(nfs_global_mutex);
		<span class="enscript-keyword">return</span>;
	}
	so = nfs4_cb_so;
	so6 = nfs4_cb_so6;
	nfs4_cb_so = nfs4_cb_so6 = NULL;
	TAILQ_INIT(&amp;cb_socks);
	TAILQ_CONCAT(&amp;cb_socks, &amp;nfs4_cb_socks, ncbs_link);
	lck_mtx_unlock(nfs_global_mutex);
	<span class="enscript-keyword">if</span> (so) {
		sock_shutdown(so, SHUT_RDWR);
		sock_close(so);
	}
	<span class="enscript-keyword">if</span> (so6) {
		sock_shutdown(so6, SHUT_RDWR);
		sock_close(so6);
	}
	<span class="enscript-keyword">while</span> ((ncbsp = TAILQ_FIRST(&amp;cb_socks))) {
		TAILQ_REMOVE(&amp;cb_socks, ncbsp, ncbs_link);
		sock_shutdown(ncbsp-&gt;ncbs_so, SHUT_RDWR);
		sock_close(ncbsp-&gt;ncbs_so);
		nfs_rpc_record_state_cleanup(&amp;ncbsp-&gt;ncbs_rrs);
		FREE(ncbsp, M_TEMP);
	}
}

<span class="enscript-comment">/*
 * Check periodically for stale/unused nfs callback sockets
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS4_CB_TIMER_PERIOD</span>	30
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS4_CB_IDLE_MAX</span>	300
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs4_callback_timer</span>(__unused <span class="enscript-type">void</span> *param0, __unused <span class="enscript-type">void</span> *param1)
{
	<span class="enscript-type">struct</span> nfs_callback_socket *ncbsp, *nextncbsp;
	<span class="enscript-type">struct</span> timeval now;

<span class="enscript-reference">loop</span>:
	lck_mtx_lock(nfs_global_mutex);
	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;nfs4_cb_socks)) {
		nfs4_callback_timer_on = 0;
		lck_mtx_unlock(nfs_global_mutex);
		<span class="enscript-keyword">return</span>;
	}
	microuptime(&amp;now);
	TAILQ_FOREACH_SAFE(ncbsp, &amp;nfs4_cb_socks, ncbs_link, nextncbsp) {
		<span class="enscript-keyword">if</span> (!(ncbsp-&gt;ncbs_flags &amp; NCBSOCK_DEAD) &amp;&amp;
		     (now.tv_sec &lt; (ncbsp-&gt;ncbs_stamp + NFS4_CB_IDLE_MAX)))
			<span class="enscript-keyword">continue</span>;
		TAILQ_REMOVE(&amp;nfs4_cb_socks, ncbsp, ncbs_link);
		lck_mtx_unlock(nfs_global_mutex);
		sock_shutdown(ncbsp-&gt;ncbs_so, SHUT_RDWR);
		sock_close(ncbsp-&gt;ncbs_so);
		nfs_rpc_record_state_cleanup(&amp;ncbsp-&gt;ncbs_rrs);
		FREE(ncbsp, M_TEMP);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">loop</span>;
	}
	nfs4_callback_timer_on = 1;
	nfs_interval_timer_start(nfs4_callback_timer_call,
		NFS4_CB_TIMER_PERIOD * 1000);
	lck_mtx_unlock(nfs_global_mutex);
}

<span class="enscript-comment">/*
 * Accept a new callback socket.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs4_cb_accept</span>(socket_t so, __unused <span class="enscript-type">void</span> *arg, __unused <span class="enscript-type">int</span> waitflag)
{
	socket_t newso = NULL;
	<span class="enscript-type">struct</span> nfs_callback_socket *ncbsp;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> timeval timeo, now;
	<span class="enscript-type">int</span> error, on = 1, ip;

	<span class="enscript-keyword">if</span> (so == nfs4_cb_so)
		ip = 4;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (so == nfs4_cb_so6)
		ip = 6;
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* allocate/initialize a new nfs_callback_socket */</span>
	MALLOC(ncbsp, <span class="enscript-type">struct</span> nfs_callback_socket *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> nfs_callback_socket), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (!ncbsp) {
		log(LOG_ERR, <span class="enscript-string">&quot;nfs callback accept: no memory for new socket\n&quot;</span>);
		<span class="enscript-keyword">return</span>;
	}
	bzero(ncbsp, <span class="enscript-keyword">sizeof</span>(*ncbsp));
	ncbsp-&gt;ncbs_saddr.ss_len = (ip == 4) ? <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in) : <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in6);
	nfs_rpc_record_state_init(&amp;ncbsp-&gt;ncbs_rrs);

	<span class="enscript-comment">/* accept a new socket */</span>
	error = sock_accept(so, (<span class="enscript-type">struct</span> sockaddr*)&amp;ncbsp-&gt;ncbs_saddr,
			ncbsp-&gt;ncbs_saddr.ss_len, MSG_DONTWAIT,
			nfs4_cb_rcv, ncbsp, &amp;newso);
	<span class="enscript-keyword">if</span> (error) {
		log(LOG_INFO, <span class="enscript-string">&quot;nfs callback accept: error %d accepting IPv%d socket\n&quot;</span>, error, ip);
		FREE(ncbsp, M_TEMP);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* set up the new socket */</span>
	<span class="enscript-comment">/* receive timeout shouldn't matter.  If timeout on send, we'll want to drop the socket */</span>
	timeo.tv_usec = 0;
	timeo.tv_sec = 60;
	error = sock_setsockopt(newso, SOL_SOCKET, SO_RCVTIMEO, &amp;timeo, <span class="enscript-keyword">sizeof</span>(timeo));
	<span class="enscript-keyword">if</span> (error)
		log(LOG_INFO, <span class="enscript-string">&quot;nfs callback socket: error %d setting IPv%d socket rx timeout\n&quot;</span>, error, ip);
	error = sock_setsockopt(newso, SOL_SOCKET, SO_SNDTIMEO, &amp;timeo, <span class="enscript-keyword">sizeof</span>(timeo));
	<span class="enscript-keyword">if</span> (error)
		log(LOG_INFO, <span class="enscript-string">&quot;nfs callback socket: error %d setting IPv%d socket tx timeout\n&quot;</span>, error, ip);
	sock_setsockopt(newso, IPPROTO_TCP, TCP_NODELAY, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	sock_setsockopt(newso, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	sock_setsockopt(newso, SOL_SOCKET, SO_NOADDRERR, &amp;on, <span class="enscript-keyword">sizeof</span>(on));
	sock_setsockopt(newso, SOL_SOCKET, SO_UPCALLCLOSEWAIT, &amp;on, <span class="enscript-keyword">sizeof</span>(on));

	ncbsp-&gt;ncbs_so = newso;
	microuptime(&amp;now);
	ncbsp-&gt;ncbs_stamp = now.tv_sec;

	lck_mtx_lock(nfs_global_mutex);

	<span class="enscript-comment">/* add it to the list */</span>
	TAILQ_INSERT_HEAD(&amp;nfs4_cb_socks, ncbsp, ncbs_link);

	<span class="enscript-comment">/* verify it's from a host we have mounted */</span>
	TAILQ_FOREACH(nmp, &amp;nfs4_cb_mounts, nm_cblink) {
		<span class="enscript-comment">/* check if socket's source address matches this mount's server address */</span>
		<span class="enscript-keyword">if</span> (!nmp-&gt;nm_saddr)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (nfs_sockaddr_cmp((<span class="enscript-type">struct</span> sockaddr*)&amp;ncbsp-&gt;ncbs_saddr, nmp-&gt;nm_saddr) == 0)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (!nmp) <span class="enscript-comment">/* we don't want this socket, mark it dead */</span>
		ncbsp-&gt;ncbs_flags |= NCBSOCK_DEAD;

	<span class="enscript-comment">/* make sure the callback socket cleanup timer is running */</span>
	<span class="enscript-comment">/* (shorten the timer if we've got a socket we don't want) */</span>
	<span class="enscript-keyword">if</span> (!nfs4_callback_timer_on) {
		nfs4_callback_timer_on = 1;
		nfs_interval_timer_start(nfs4_callback_timer_call,
			!nmp ? 500 : (NFS4_CB_TIMER_PERIOD * 1000));
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!nmp &amp;&amp; (nfs4_callback_timer_on &lt; 2)) {
		nfs4_callback_timer_on = 2;
		thread_call_cancel(nfs4_callback_timer_call);
		nfs_interval_timer_start(nfs4_callback_timer_call, 500);
	}

	lck_mtx_unlock(nfs_global_mutex);
}

<span class="enscript-comment">/*
 * Receive mbufs from callback sockets into RPC records and process each record.
 * Detect connection has been closed and shut down.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs4_cb_rcv</span>(socket_t so, <span class="enscript-type">void</span> *arg, __unused <span class="enscript-type">int</span> waitflag)
{
	<span class="enscript-type">struct</span> nfs_callback_socket *ncbsp = arg;
	<span class="enscript-type">struct</span> timespec ts = {1,0};
	<span class="enscript-type">struct</span> timeval now;
	mbuf_t m;
	<span class="enscript-type">int</span> error = 0, recv = 1;

	lck_mtx_lock(nfs_global_mutex);
	<span class="enscript-keyword">while</span> (ncbsp-&gt;ncbs_flags &amp; NCBSOCK_UPCALL) {
		<span class="enscript-comment">/* wait if upcall is already in progress */</span>
		ncbsp-&gt;ncbs_flags |= NCBSOCK_UPCALLWANT;
		msleep(ncbsp, nfs_global_mutex, PSOCK, <span class="enscript-string">&quot;cbupcall&quot;</span>, &amp;ts);
	}
	ncbsp-&gt;ncbs_flags |= NCBSOCK_UPCALL;
	lck_mtx_unlock(nfs_global_mutex);

	<span class="enscript-comment">/* loop while we make error-free progress */</span>
	<span class="enscript-keyword">while</span> (!error &amp;&amp; recv) {
		error = nfs_rpc_record_read(so, &amp;ncbsp-&gt;ncbs_rrs, MSG_DONTWAIT, &amp;recv, &amp;m);
		<span class="enscript-keyword">if</span> (m) <span class="enscript-comment">/* handle the request */</span>
			error = nfs4_cb_handler(ncbsp, m);
	}

	<span class="enscript-comment">/* note: no error and no data indicates server closed its end */</span>
	<span class="enscript-keyword">if</span> ((error != EWOULDBLOCK) &amp;&amp; (error || !recv)) {
		<span class="enscript-comment">/*
		 * Socket is either being closed or should be.
		 * We can't close the socket in the context of the upcall.
		 * So we mark it as dead and leave it for the cleanup timer to reap.
		 */</span>
		ncbsp-&gt;ncbs_stamp = 0;
		ncbsp-&gt;ncbs_flags |= NCBSOCK_DEAD;
	} <span class="enscript-keyword">else</span> {
		microuptime(&amp;now);
		ncbsp-&gt;ncbs_stamp = now.tv_sec;
	}

	lck_mtx_lock(nfs_global_mutex);
	ncbsp-&gt;ncbs_flags &amp;= ~NCBSOCK_UPCALL;
	lck_mtx_unlock(nfs_global_mutex);
	wakeup(ncbsp);
}

<span class="enscript-comment">/*
 * Handle an NFS callback channel request.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs4_cb_handler</span>(<span class="enscript-type">struct</span> nfs_callback_socket *ncbsp, mbuf_t mreq)
{
	socket_t so = ncbsp-&gt;ncbs_so;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	mbuf_t mhead = NULL, mrest = NULL, m;
	<span class="enscript-type">struct</span> msghdr msg;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	fhandle_t fh;
	nfsnode_t np;
	nfs_stateid stateid;
	uint32_t bitmap[NFS_ATTR_BITMAP_LEN], rbitmap[NFS_ATTR_BITMAP_LEN], bmlen, truncate, attrbytes;
	uint32_t val, xid, procnum, taglen, cbid, numops, op, status;
	uint32_t auth_type, auth_len;
	uint32_t numres, *pnumres;
	<span class="enscript-type">int</span> error = 0, replen, len;
	size_t sentlen = 0;

	xid = numops = op = status = procnum = taglen = cbid = 0;

	nfsm_chain_dissect_init(error, &amp;nmreq, mreq);
	nfsm_chain_get_32(error, &amp;nmreq, xid);		<span class="enscript-comment">// RPC XID
</span>	nfsm_chain_get_32(error, &amp;nmreq, val);		<span class="enscript-comment">// RPC Call
</span>	nfsm_assert(error, (val == RPC_CALL), EBADRPC);
	nfsm_chain_get_32(error, &amp;nmreq, val);		<span class="enscript-comment">// RPC Version
</span>	nfsm_assert(error, (val == RPC_VER2), ERPCMISMATCH);
	nfsm_chain_get_32(error, &amp;nmreq, val);		<span class="enscript-comment">// RPC Program Number
</span>	nfsm_assert(error, (val == NFS4_CALLBACK_PROG), EPROGUNAVAIL);
	nfsm_chain_get_32(error, &amp;nmreq, val);		<span class="enscript-comment">// NFS Callback Program Version Number
</span>	nfsm_assert(error, (val == NFS4_CALLBACK_PROG_VERSION), EPROGMISMATCH);
	nfsm_chain_get_32(error, &amp;nmreq, procnum);	<span class="enscript-comment">// NFS Callback Procedure Number
</span>	nfsm_assert(error, (procnum &lt;= NFSPROC4_CB_COMPOUND), EPROCUNAVAIL);

	<span class="enscript-comment">/* Handle authentication */</span>
	<span class="enscript-comment">/* XXX just ignore auth for now - handling kerberos may be tricky */</span>
	nfsm_chain_get_32(error, &amp;nmreq, auth_type);	<span class="enscript-comment">// RPC Auth Flavor
</span>	nfsm_chain_get_32(error, &amp;nmreq, auth_len);	<span class="enscript-comment">// RPC Auth Length
</span>	nfsm_assert(error, (auth_len &lt;= RPCAUTH_MAXSIZ), EBADRPC);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (auth_len &gt; 0))
		nfsm_chain_adv(error, &amp;nmreq, nfsm_rndup(auth_len));
	nfsm_chain_adv(error, &amp;nmreq, NFSX_UNSIGNED);	<span class="enscript-comment">// verifier flavor (should be AUTH_NONE)
</span>	nfsm_chain_get_32(error, &amp;nmreq, auth_len);	<span class="enscript-comment">// verifier length
</span>	nfsm_assert(error, (auth_len &lt;= RPCAUTH_MAXSIZ), EBADRPC);
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (auth_len &gt; 0))
		nfsm_chain_adv(error, &amp;nmreq, nfsm_rndup(auth_len));
	<span class="enscript-keyword">if</span> (error) {
		status = error;
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}

	<span class="enscript-keyword">switch</span> (procnum) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSPROC4_CB_NULL</span>:
		status = NFSERR_RETVOID;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NFSPROC4_CB_COMPOUND</span>:
		<span class="enscript-comment">/* tag, minorversion, cb ident, numops, op array */</span>
		nfsm_chain_get_32(error, &amp;nmreq, taglen);	<span class="enscript-comment">/* tag length */</span>
		nfsm_assert(error, (val &lt;= NFS4_OPAQUE_LIMIT), EBADRPC);

		<span class="enscript-comment">/* start building the body of the response */</span>
		nfsm_mbuf_get(error, &amp;mrest, nfsm_rndup(taglen) + 5*NFSX_UNSIGNED);
		nfsm_chain_init(&amp;nmrep, mrest);

		<span class="enscript-comment">/* copy tag from request to response */</span>
		nfsm_chain_add_32(error, &amp;nmrep, taglen);	<span class="enscript-comment">/* tag length */</span>
		<span class="enscript-keyword">for</span> (len = (<span class="enscript-type">int</span>)taglen; !error &amp;&amp; (len &gt; 0); len -= NFSX_UNSIGNED) {
			nfsm_chain_get_32(error, &amp;nmreq, val);
			nfsm_chain_add_32(error, &amp;nmrep, val);
		}

		<span class="enscript-comment">/* insert number of results placeholder */</span>
		numres = 0;
		nfsm_chain_add_32(error, &amp;nmrep, numres);
		pnumres = (uint32_t*)(nmrep.nmc_ptr - NFSX_UNSIGNED);

		nfsm_chain_get_32(error, &amp;nmreq, val);		<span class="enscript-comment">/* minorversion */</span>
		nfsm_assert(error, (val == 0), NFSERR_MINOR_VERS_MISMATCH);
		nfsm_chain_get_32(error, &amp;nmreq, cbid);		<span class="enscript-comment">/* callback ID */</span>
		nfsm_chain_get_32(error, &amp;nmreq, numops);	<span class="enscript-comment">/* number of operations */</span>
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> ((error == EBADRPC) || (error == NFSERR_MINOR_VERS_MISMATCH))
				status = error;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((error == ENOBUFS) || (error == ENOMEM))
				status = NFSERR_RESOURCE;
			<span class="enscript-keyword">else</span>
				status = NFSERR_SERVERFAULT;
			error = 0;
			nfsm_chain_null(&amp;nmrep);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
		<span class="enscript-comment">/* match the callback ID to a registered mount */</span>
		lck_mtx_lock(nfs_global_mutex);
		TAILQ_FOREACH(nmp, &amp;nfs4_cb_mounts, nm_cblink) {
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_cbid != cbid)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-comment">/* verify socket's source address matches this mount's server address */</span>
			<span class="enscript-keyword">if</span> (!nmp-&gt;nm_saddr)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (nfs_sockaddr_cmp((<span class="enscript-type">struct</span> sockaddr*)&amp;ncbsp-&gt;ncbs_saddr, nmp-&gt;nm_saddr) == 0)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* mark the NFS mount as busy */</span>
		<span class="enscript-keyword">if</span> (nmp)
			nmp-&gt;nm_cbrefs++;
		lck_mtx_unlock(nfs_global_mutex);
		<span class="enscript-keyword">if</span> (!nmp) {
			<span class="enscript-comment">/* if no mount match, just drop socket. */</span>
			error = EPERM;
			nfsm_chain_null(&amp;nmrep);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-comment">/* process ops, adding results to mrest */</span>
		<span class="enscript-keyword">while</span> (numops &gt; 0) {
			numops--;
			nfsm_chain_get_32(error, &amp;nmreq, op);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">switch</span> (op) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_OP_CB_GETATTR</span>:
				<span class="enscript-comment">// (FH, BITMAP) -&gt; (STATUS, BITMAP, ATTRS)
</span>				np = NULL;
				nfsm_chain_get_fh(error, &amp;nmreq, NFS_VER4, &amp;fh);
				bmlen = NFS_ATTR_BITMAP_LEN;
				nfsm_chain_get_bitmap(error, &amp;nmreq, bitmap, bmlen);
				<span class="enscript-keyword">if</span> (error) {
					status = error;
					error = 0;
					numops = 0; <span class="enscript-comment">/* don't process any more ops */</span>
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* find the node for the file handle */</span>
					error = nfs_nget(nmp-&gt;nm_mountp, NULL, NULL, fh.fh_data, fh.fh_len, NULL, NULL, RPCAUTH_UNKNOWN, NG_NOCREATE, &amp;np);
					<span class="enscript-keyword">if</span> (error || !np) {
						status = NFSERR_BADHANDLE;
						error = 0;
						np = NULL;
						numops = 0; <span class="enscript-comment">/* don't process any more ops */</span>
					}
				}
				nfsm_chain_add_32(error, &amp;nmrep, op);
				nfsm_chain_add_32(error, &amp;nmrep, status);
				<span class="enscript-keyword">if</span> (!error &amp;&amp; (status == EBADRPC))
					error = status;
				<span class="enscript-keyword">if</span> (np) {
					<span class="enscript-comment">/* only allow returning size, change, and mtime attrs */</span>
					NFS_CLEAR_ATTRIBUTES(&amp;rbitmap);
					attrbytes = 0;
					<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(&amp;bitmap, NFS_FATTR_CHANGE)) {
						NFS_BITMAP_SET(&amp;rbitmap, NFS_FATTR_CHANGE);
						attrbytes += 2 * NFSX_UNSIGNED;
					}
					<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(&amp;bitmap, NFS_FATTR_SIZE)) {
						NFS_BITMAP_SET(&amp;rbitmap, NFS_FATTR_SIZE);
						attrbytes += 2 * NFSX_UNSIGNED;
					}
					<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(&amp;bitmap, NFS_FATTR_TIME_MODIFY)) {
						NFS_BITMAP_SET(&amp;rbitmap, NFS_FATTR_TIME_MODIFY);
						attrbytes += 3 * NFSX_UNSIGNED;
					}
					nfsm_chain_add_bitmap(error, &amp;nmrep, rbitmap, NFS_ATTR_BITMAP_LEN);
					nfsm_chain_add_32(error, &amp;nmrep, attrbytes);
					<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(&amp;bitmap, NFS_FATTR_CHANGE))
						nfsm_chain_add_64(error, &amp;nmrep,
							np-&gt;n_vattr.nva_change + ((np-&gt;n_flag &amp; NMODIFIED) ? 1 : 0));
					<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(&amp;bitmap, NFS_FATTR_SIZE))
						nfsm_chain_add_64(error, &amp;nmrep, np-&gt;n_size);
					<span class="enscript-keyword">if</span> (NFS_BITMAP_ISSET(&amp;bitmap, NFS_FATTR_TIME_MODIFY)) {
						nfsm_chain_add_64(error, &amp;nmrep, np-&gt;n_vattr.nva_timesec[NFSTIME_MODIFY]);
						nfsm_chain_add_32(error, &amp;nmrep, np-&gt;n_vattr.nva_timensec[NFSTIME_MODIFY]);
					}
					nfs_node_unlock(np);
					vnode_put(NFSTOV(np));
					np = NULL;
				}
				<span class="enscript-comment">/*
				 * If we hit an error building the reply, we can't easily back up.
				 * So we'll just update the status and hope the server ignores the
				 * extra garbage.
				 */</span>
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_OP_CB_RECALL</span>:
				<span class="enscript-comment">// (STATEID, TRUNCATE, FH) -&gt; (STATUS)
</span>				np = NULL;
				nfsm_chain_get_stateid(error, &amp;nmreq, &amp;stateid);
				nfsm_chain_get_32(error, &amp;nmreq, truncate);
				nfsm_chain_get_fh(error, &amp;nmreq, NFS_VER4, &amp;fh);
				<span class="enscript-keyword">if</span> (error) {
					status = error;
					error = 0;
					numops = 0; <span class="enscript-comment">/* don't process any more ops */</span>
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* find the node for the file handle */</span>
					error = nfs_nget(nmp-&gt;nm_mountp, NULL, NULL, fh.fh_data, fh.fh_len, NULL, NULL, RPCAUTH_UNKNOWN, NG_NOCREATE, &amp;np);
					<span class="enscript-keyword">if</span> (error || !np) {
						status = NFSERR_BADHANDLE;
						error = 0;
						np = NULL;
						numops = 0; <span class="enscript-comment">/* don't process any more ops */</span>
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!(np-&gt;n_openflags &amp; N_DELEG_MASK) ||
						    bcmp(&amp;np-&gt;n_dstateid, &amp;stateid, <span class="enscript-keyword">sizeof</span>(stateid))) {
						<span class="enscript-comment">/* delegation stateid state doesn't match */</span>
						status = NFSERR_BAD_STATEID;
						numops = 0; <span class="enscript-comment">/* don't process any more ops */</span>
					}
					<span class="enscript-keyword">if</span> (!status) <span class="enscript-comment">/* add node to recall queue, and wake socket thread */</span>
						nfs4_delegation_return_enqueue(np);
					<span class="enscript-keyword">if</span> (np) {
						nfs_node_unlock(np);
						vnode_put(NFSTOV(np));
					}
				}
				nfsm_chain_add_32(error, &amp;nmrep, op);
				nfsm_chain_add_32(error, &amp;nmrep, status);
				<span class="enscript-keyword">if</span> (!error &amp;&amp; (status == EBADRPC))
					error = status;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">NFS_OP_CB_ILLEGAL</span>:
			<span class="enscript-reference">default</span>:
				nfsm_chain_add_32(error, &amp;nmrep, NFS_OP_CB_ILLEGAL);
				status = NFSERR_OP_ILLEGAL;
				nfsm_chain_add_32(error, &amp;nmrep, status);
				numops = 0; <span class="enscript-comment">/* don't process any more ops */</span>
				<span class="enscript-keyword">break</span>;
			}
			numres++;
		}

		<span class="enscript-keyword">if</span> (!status &amp;&amp; error) {
			<span class="enscript-keyword">if</span> (error == EBADRPC)
				status = error;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((error == ENOBUFS) || (error == ENOMEM))
				status = NFSERR_RESOURCE;
			<span class="enscript-keyword">else</span>
				status = NFSERR_SERVERFAULT;
			error = 0;
		}

		<span class="enscript-comment">/* Now, set the numres field */</span>
		*pnumres = txdr_unsigned(numres);
		nfsm_chain_build_done(error, &amp;nmrep);
		nfsm_chain_null(&amp;nmrep);

		<span class="enscript-comment">/* drop the callback reference on the mount */</span>
		lck_mtx_lock(nfs_global_mutex);
		nmp-&gt;nm_cbrefs--;
		<span class="enscript-keyword">if</span> (!nmp-&gt;nm_cbid)
			wakeup(&amp;nmp-&gt;nm_cbrefs);
		lck_mtx_unlock(nfs_global_mutex);
		<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (status == EBADRPC)
		OSAddAtomic64(1, &amp;nfsstats.rpcinvalid);

	<span class="enscript-comment">/* build reply header */</span>
	error = mbuf_gethdr(MBUF_WAITOK, MBUF_TYPE_DATA, &amp;mhead);
	nfsm_chain_init(&amp;nmrep, mhead);
	nfsm_chain_add_32(error, &amp;nmrep, 0); <span class="enscript-comment">/* insert space for an RPC record mark */</span>
	nfsm_chain_add_32(error, &amp;nmrep, xid);
	nfsm_chain_add_32(error, &amp;nmrep, RPC_REPLY);
	<span class="enscript-keyword">if</span> ((status == ERPCMISMATCH) || (status &amp; NFSERR_AUTHERR)) {
		nfsm_chain_add_32(error, &amp;nmrep, RPC_MSGDENIED);
		<span class="enscript-keyword">if</span> (status &amp; NFSERR_AUTHERR) {
			nfsm_chain_add_32(error, &amp;nmrep, RPC_AUTHERR);
			nfsm_chain_add_32(error, &amp;nmrep, (status &amp; ~NFSERR_AUTHERR));
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, &amp;nmrep, RPC_MISMATCH);
			nfsm_chain_add_32(error, &amp;nmrep, RPC_VER2);
			nfsm_chain_add_32(error, &amp;nmrep, RPC_VER2);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* reply status */</span>
		nfsm_chain_add_32(error, &amp;nmrep, RPC_MSGACCEPTED);
		<span class="enscript-comment">/* XXX RPCAUTH_NULL verifier */</span>
		nfsm_chain_add_32(error, &amp;nmrep, RPCAUTH_NULL);
		nfsm_chain_add_32(error, &amp;nmrep, 0);
		<span class="enscript-comment">/* accepted status */</span>
		<span class="enscript-keyword">switch</span> (status) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EPROGUNAVAIL</span>:
			nfsm_chain_add_32(error, &amp;nmrep, RPC_PROGUNAVAIL);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EPROGMISMATCH</span>:
			nfsm_chain_add_32(error, &amp;nmrep, RPC_PROGMISMATCH);
			nfsm_chain_add_32(error, &amp;nmrep, NFS4_CALLBACK_PROG_VERSION);
			nfsm_chain_add_32(error, &amp;nmrep, NFS4_CALLBACK_PROG_VERSION);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EPROCUNAVAIL</span>:
			nfsm_chain_add_32(error, &amp;nmrep, RPC_PROCUNAVAIL);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EBADRPC</span>:
			nfsm_chain_add_32(error, &amp;nmrep, RPC_GARBAGE);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			nfsm_chain_add_32(error, &amp;nmrep, RPC_SUCCESS);
			<span class="enscript-keyword">if</span> (status != NFSERR_RETVOID)
				nfsm_chain_add_32(error, &amp;nmrep, status);
			<span class="enscript-keyword">break</span>;
		}
	}
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (error) {
		nfsm_chain_null(&amp;nmrep);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	error = mbuf_setnext(nmrep.nmc_mcur, mrest);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;nfs cb: mbuf_setnext failed %d\n&quot;</span>, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	mrest = NULL;
	<span class="enscript-comment">/* Calculate the size of the reply */</span>
	replen = 0;
	<span class="enscript-keyword">for</span> (m = nmrep.nmc_mhead; m; m = mbuf_next(m))
		replen += mbuf_len(m);
	mbuf_pkthdr_setlen(mhead, replen);
	error = mbuf_pkthdr_setrcvif(mhead, NULL);
	nfsm_chain_set_recmark(error, &amp;nmrep, (replen - NFSX_UNSIGNED) | 0x80000000);
	nfsm_chain_null(&amp;nmrep);

	<span class="enscript-comment">/* send the reply */</span>
	bzero(&amp;msg, <span class="enscript-keyword">sizeof</span>(msg));
	error = sock_sendmbuf(so, &amp;msg, mhead, 0, &amp;sentlen);
	mhead = NULL;
	<span class="enscript-keyword">if</span> (!error &amp;&amp; ((<span class="enscript-type">int</span>)sentlen != replen))
		error = EWOULDBLOCK;
	<span class="enscript-keyword">if</span> (error == EWOULDBLOCK) <span class="enscript-comment">/* inability to send response is considered fatal */</span>
		error = ETIMEDOUT;
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error)
		nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">if</span> (mhead)
		mbuf_freem(mhead);
	<span class="enscript-keyword">if</span> (mrest)
		mbuf_freem(mrest);
	<span class="enscript-keyword">if</span> (mreq)
		mbuf_freem(mreq);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Initialize an nfs_rpc_record_state structure.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_rpc_record_state_init</span>(<span class="enscript-type">struct</span> nfs_rpc_record_state *nrrsp)
{
	bzero(nrrsp, <span class="enscript-keyword">sizeof</span>(*nrrsp));
	nrrsp-&gt;nrrs_markerleft = <span class="enscript-keyword">sizeof</span>(nrrsp-&gt;nrrs_fragleft);
}

<span class="enscript-comment">/*
 * Clean up an nfs_rpc_record_state structure.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_rpc_record_state_cleanup</span>(<span class="enscript-type">struct</span> nfs_rpc_record_state *nrrsp)
{
	<span class="enscript-keyword">if</span> (nrrsp-&gt;nrrs_m) {
		mbuf_freem(nrrsp-&gt;nrrs_m);
		nrrsp-&gt;nrrs_m = nrrsp-&gt;nrrs_mlast = NULL;
	}
}

<span class="enscript-comment">/*
 * Read the next (marked) RPC record from the socket.
 *
 * *recvp returns if any data was received.
 * *mp returns the next complete RPC record
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_rpc_record_read</span>(socket_t so, <span class="enscript-type">struct</span> nfs_rpc_record_state *nrrsp, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> *recvp, mbuf_t *mp)
{
	<span class="enscript-type">struct</span> iovec aio;
	<span class="enscript-type">struct</span> msghdr msg;
	size_t rcvlen;
	<span class="enscript-type">int</span> error = 0;
	mbuf_t m;

	*recvp = 0;
	*mp = NULL;

	<span class="enscript-comment">/* read the TCP RPC record marker */</span>
	<span class="enscript-keyword">while</span> (!error &amp;&amp; nrrsp-&gt;nrrs_markerleft) {
		aio.iov_base = ((<span class="enscript-type">char</span>*)&amp;nrrsp-&gt;nrrs_fragleft +
				<span class="enscript-keyword">sizeof</span>(nrrsp-&gt;nrrs_fragleft) - nrrsp-&gt;nrrs_markerleft);
		aio.iov_len = nrrsp-&gt;nrrs_markerleft;
		bzero(&amp;msg, <span class="enscript-keyword">sizeof</span>(msg));
		msg.msg_iov = &amp;aio;
		msg.msg_iovlen = 1;
		error = sock_receive(so, &amp;msg, flags, &amp;rcvlen);
		<span class="enscript-keyword">if</span> (error || !rcvlen)
			<span class="enscript-keyword">break</span>;
		*recvp = 1;
		nrrsp-&gt;nrrs_markerleft -= rcvlen;
		<span class="enscript-keyword">if</span> (nrrsp-&gt;nrrs_markerleft)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-comment">/* record marker complete */</span>
		nrrsp-&gt;nrrs_fragleft = ntohl(nrrsp-&gt;nrrs_fragleft);
		<span class="enscript-keyword">if</span> (nrrsp-&gt;nrrs_fragleft &amp; 0x80000000) {
			nrrsp-&gt;nrrs_lastfrag = 1;
			nrrsp-&gt;nrrs_fragleft &amp;= ~0x80000000;
		}
		nrrsp-&gt;nrrs_reclen += nrrsp-&gt;nrrs_fragleft;
		<span class="enscript-keyword">if</span> (nrrsp-&gt;nrrs_reclen &gt; NFS_MAXPACKET) {
			<span class="enscript-comment">/* This is SERIOUS! We are out of sync with the sender. */</span>
			log(LOG_ERR, <span class="enscript-string">&quot;impossible RPC record length (%d) on callback&quot;</span>, nrrsp-&gt;nrrs_reclen);
			error = EFBIG;
		}
	}

	<span class="enscript-comment">/* read the TCP RPC record fragment */</span>
	<span class="enscript-keyword">while</span> (!error &amp;&amp; !nrrsp-&gt;nrrs_markerleft &amp;&amp; nrrsp-&gt;nrrs_fragleft) {
		m = NULL;
		rcvlen = nrrsp-&gt;nrrs_fragleft;
		error = sock_receivembuf(so, NULL, &amp;m, flags, &amp;rcvlen);
		<span class="enscript-keyword">if</span> (error || !rcvlen || !m)
			<span class="enscript-keyword">break</span>;
		*recvp = 1;
		<span class="enscript-comment">/* append mbufs to list */</span>
		nrrsp-&gt;nrrs_fragleft -= rcvlen;
		<span class="enscript-keyword">if</span> (!nrrsp-&gt;nrrs_m) {
			nrrsp-&gt;nrrs_m = m;
		} <span class="enscript-keyword">else</span> {
			error = mbuf_setnext(nrrsp-&gt;nrrs_mlast, m);
			<span class="enscript-keyword">if</span> (error) {
				printf(<span class="enscript-string">&quot;nfs tcp rcv: mbuf_setnext failed %d\n&quot;</span>, error);
				mbuf_freem(m);
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">while</span> (mbuf_next(m))
			m = mbuf_next(m);
		nrrsp-&gt;nrrs_mlast = m;
	}

	<span class="enscript-comment">/* done reading fragment? */</span>
	<span class="enscript-keyword">if</span> (!error &amp;&amp; !nrrsp-&gt;nrrs_markerleft &amp;&amp; !nrrsp-&gt;nrrs_fragleft) {
		<span class="enscript-comment">/* reset socket fragment parsing state */</span>
		nrrsp-&gt;nrrs_markerleft = <span class="enscript-keyword">sizeof</span>(nrrsp-&gt;nrrs_fragleft);
		<span class="enscript-keyword">if</span> (nrrsp-&gt;nrrs_lastfrag) {
			<span class="enscript-comment">/* RPC record complete */</span>
			*mp = nrrsp-&gt;nrrs_m;
			<span class="enscript-comment">/* reset socket record parsing state */</span>
			nrrsp-&gt;nrrs_reclen = 0;
			nrrsp-&gt;nrrs_m = nrrsp-&gt;nrrs_mlast = NULL;
			nrrsp-&gt;nrrs_lastfrag = 0;
		}
	}

	<span class="enscript-keyword">return</span> (error);
}



<span class="enscript-comment">/*
 * The NFS client send routine.
 *
 * Send the given NFS request out the mount's socket.
 * Holds nfs_sndlock() for the duration of this call.
 *
 * - check for request termination (sigintr)
 * - wait for reconnect, if necessary
 * - UDP: check the congestion window
 * - make a copy of the request to send
 * - UDP: update the congestion window
 * - send the request
 *
 * If sent successfully, R_MUSTRESEND and R_RESENDERR are cleared.
 * rexmit count is also updated if this isn't the first send.
 *
 * If the send is not successful, make sure R_MUSTRESEND is set.
 * If this wasn't the first transmit, set R_RESENDERR.
 * Also, undo any UDP congestion window changes made.
 *
 * If the error appears to indicate that the socket should
 * be reconnected, mark the socket for reconnection.
 *
 * Only return errors when the request should be aborted.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_send</span>(<span class="enscript-type">struct</span> nfsreq *req, <span class="enscript-type">int</span> wait)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> nfs_socket *nso;
	<span class="enscript-type">int</span> error, error2, sotype, rexmit, slpflag = 0, needrecon;
	<span class="enscript-type">struct</span> msghdr msg;
	<span class="enscript-type">struct</span> sockaddr *sendnam;
	mbuf_t mreqcopy;
	size_t sentlen = 0;
	<span class="enscript-type">struct</span> timespec ts = { 2, 0 };

<span class="enscript-reference">again</span>:
	error = nfs_sndlock(req);
	<span class="enscript-keyword">if</span> (error) {
		lck_mtx_lock(&amp;req-&gt;r_mtx);
		req-&gt;r_error = error;
		req-&gt;r_flags &amp;= ~R_SENDING;
		lck_mtx_unlock(&amp;req-&gt;r_mtx);
		<span class="enscript-keyword">return</span> (error);
	}

	error = nfs_sigintr(req-&gt;r_nmp, req, NULL, 0);
	<span class="enscript-keyword">if</span> (error) {
		nfs_sndunlock(req);
		lck_mtx_lock(&amp;req-&gt;r_mtx);
		req-&gt;r_error = error;
		req-&gt;r_flags &amp;= ~R_SENDING;
		lck_mtx_unlock(&amp;req-&gt;r_mtx);
		<span class="enscript-keyword">return</span> (error);
	}
	nmp = req-&gt;r_nmp;
	sotype = nmp-&gt;nm_sotype;

	<span class="enscript-comment">/*
	 * If it's a setup RPC but we're not in SETUP... must need reconnect.
	 * If it's a recovery RPC but the socket's not ready... must need reconnect.
	 */</span>
	<span class="enscript-keyword">if</span> (((req-&gt;r_flags &amp; R_SETUP) &amp;&amp; !(nmp-&gt;nm_sockflags &amp; NMSOCK_SETUP)) ||
	    ((req-&gt;r_flags &amp; R_RECOVER) &amp;&amp; !(nmp-&gt;nm_sockflags &amp; NMSOCK_READY))) {
		error = ETIMEDOUT;
		nfs_sndunlock(req);
		lck_mtx_lock(&amp;req-&gt;r_mtx);
		req-&gt;r_error = error;
		req-&gt;r_flags &amp;= ~R_SENDING;
		lck_mtx_unlock(&amp;req-&gt;r_mtx);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* If the socket needs reconnection, do that now. */</span>
	<span class="enscript-comment">/* wait until socket is ready - unless this request is part of setup */</span>
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_sockflags &amp; NMSOCK_READY) &amp;&amp;
	    !((nmp-&gt;nm_sockflags &amp; NMSOCK_SETUP) &amp;&amp; (req-&gt;r_flags &amp; R_SETUP))) {
		<span class="enscript-keyword">if</span> (NMFLAG(nmp, INTR) &amp;&amp; !(req-&gt;r_flags &amp; R_NOINTR))
			slpflag |= PCATCH;
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		nfs_sndunlock(req);
		<span class="enscript-keyword">if</span> (!wait) {
			lck_mtx_lock(&amp;req-&gt;r_mtx);
			req-&gt;r_flags &amp;= ~R_SENDING;
			req-&gt;r_flags |= R_MUSTRESEND;
			req-&gt;r_rtt = 0;
			lck_mtx_unlock(&amp;req-&gt;r_mtx);
			<span class="enscript-keyword">return</span> (0);
		}
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs_send: 0x%llx wait reconnect\n&quot;</span>, req-&gt;r_xid);
		lck_mtx_lock(&amp;req-&gt;r_mtx);
		req-&gt;r_flags &amp;= ~R_MUSTRESEND;
		req-&gt;r_rtt = 0;
		lck_mtx_unlock(&amp;req-&gt;r_mtx);
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">while</span> (!(nmp-&gt;nm_sockflags &amp; NMSOCK_READY)) {
			<span class="enscript-comment">/* don't bother waiting if the socket thread won't be reconnecting it */</span>
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; (NFSSTA_FORCE|NFSSTA_DEAD)) {
				error = EIO;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> ((NMFLAG(nmp, SOFT) || (req-&gt;r_flags &amp; R_SOFT)) &amp;&amp; (nmp-&gt;nm_reconnect_start &gt; 0)) {
				<span class="enscript-type">struct</span> timeval now;
				microuptime(&amp;now);
				<span class="enscript-keyword">if</span> ((now.tv_sec - nmp-&gt;nm_reconnect_start) &gt;= 8) {
					<span class="enscript-comment">/* soft mount in reconnect for a while... terminate ASAP */</span>
					OSAddAtomic64(1, &amp;nfsstats.rpctimeouts);
					req-&gt;r_flags |= R_SOFTTERM;
					req-&gt;r_error = error = ETIMEDOUT;
					<span class="enscript-keyword">break</span>;
				}
			}
			<span class="enscript-comment">/* make sure socket thread is running, then wait */</span>
			nfs_mount_sock_thread_wake(nmp);
			<span class="enscript-keyword">if</span> ((error = nfs_sigintr(req-&gt;r_nmp, req, req-&gt;r_thread, 1)))
				<span class="enscript-keyword">break</span>;
			msleep(req, &amp;nmp-&gt;nm_lock, slpflag|PSOCK, <span class="enscript-string">&quot;nfsconnectwait&quot;</span>, &amp;ts);
			slpflag = 0;
		}
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">if</span> (error) {
			lck_mtx_lock(&amp;req-&gt;r_mtx);
			req-&gt;r_error = error;
			req-&gt;r_flags &amp;= ~R_SENDING;
			lck_mtx_unlock(&amp;req-&gt;r_mtx);
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
	}
	nso = nmp-&gt;nm_nso;
	<span class="enscript-comment">/* note that we're using the mount's socket to do the send */</span>
	nmp-&gt;nm_state |= NFSSTA_SENDING;  <span class="enscript-comment">/* will be cleared by nfs_sndunlock() */</span>
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (!nso) {
		nfs_sndunlock(req);
		lck_mtx_lock(&amp;req-&gt;r_mtx);
		req-&gt;r_flags &amp;= ~R_SENDING;
		req-&gt;r_flags |= R_MUSTRESEND;
		req-&gt;r_rtt = 0;
		lck_mtx_unlock(&amp;req-&gt;r_mtx);
		<span class="enscript-keyword">return</span> (0);
	}

	lck_mtx_lock(&amp;req-&gt;r_mtx);
	rexmit = (req-&gt;r_flags &amp; R_SENT);

	<span class="enscript-keyword">if</span> (sotype == SOCK_DGRAM) {
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">if</span> (!(req-&gt;r_flags &amp; R_CWND) &amp;&amp; (nmp-&gt;nm_sent &gt;= nmp-&gt;nm_cwnd)) {
			<span class="enscript-comment">/* if we can't send this out yet, wait on the cwnd queue */</span>
			slpflag = (NMFLAG(nmp, INTR) &amp;&amp; req-&gt;r_thread) ? PCATCH : 0;
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			nfs_sndunlock(req);
			req-&gt;r_flags &amp;= ~R_SENDING;
			req-&gt;r_flags |= R_MUSTRESEND;
			lck_mtx_unlock(&amp;req-&gt;r_mtx);
			<span class="enscript-keyword">if</span> (!wait) {
				req-&gt;r_rtt = 0;
				<span class="enscript-keyword">return</span> (0);
			}
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">while</span> (nmp-&gt;nm_sent &gt;= nmp-&gt;nm_cwnd) {
				<span class="enscript-keyword">if</span> ((error = nfs_sigintr(req-&gt;r_nmp, req, req-&gt;r_thread, 1)))
					<span class="enscript-keyword">break</span>;
				TAILQ_INSERT_TAIL(&amp;nmp-&gt;nm_cwndq, req, r_cchain);
				msleep(req, &amp;nmp-&gt;nm_lock, slpflag | (PZERO - 1), <span class="enscript-string">&quot;nfswaitcwnd&quot;</span>, &amp;ts);
				slpflag = 0;
				<span class="enscript-keyword">if</span> ((req-&gt;r_cchain.tqe_next != NFSREQNOLIST)) {
					TAILQ_REMOVE(&amp;nmp-&gt;nm_cwndq, req, r_cchain);
					req-&gt;r_cchain.tqe_next = NFSREQNOLIST;
				}
			}
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;
		}
		<span class="enscript-comment">/*
		 * We update these *before* the send to avoid racing
		 * against others who may be looking to send requests.
		 */</span>
		<span class="enscript-keyword">if</span> (!rexmit) {
			<span class="enscript-comment">/* first transmit */</span>
			req-&gt;r_flags |= R_CWND;
			nmp-&gt;nm_sent += NFS_CWNDSCALE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * When retransmitting, turn timing off
			 * and divide congestion window by 2.
			 */</span>
			req-&gt;r_flags &amp;= ~R_TIMING;
			nmp-&gt;nm_cwnd &gt;&gt;= 1;
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_cwnd &lt; NFS_CWNDSCALE)
				nmp-&gt;nm_cwnd = NFS_CWNDSCALE;
		}
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	}

	req-&gt;r_flags &amp;= ~R_MUSTRESEND;
	lck_mtx_unlock(&amp;req-&gt;r_mtx);

	error = mbuf_copym(req-&gt;r_mhead, 0, MBUF_COPYALL,
			wait ? MBUF_WAITOK : MBUF_DONTWAIT, &amp;mreqcopy);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (wait)
			log(LOG_INFO, <span class="enscript-string">&quot;nfs_send: mbuf copy failed %d\n&quot;</span>, error);
		nfs_sndunlock(req);
		lck_mtx_lock(&amp;req-&gt;r_mtx);
		req-&gt;r_flags &amp;= ~R_SENDING;
		req-&gt;r_flags |= R_MUSTRESEND;
		req-&gt;r_rtt = 0;
		lck_mtx_unlock(&amp;req-&gt;r_mtx);
		<span class="enscript-keyword">return</span> (0);
	}

	bzero(&amp;msg, <span class="enscript-keyword">sizeof</span>(msg));
	<span class="enscript-keyword">if</span> ((sotype != SOCK_STREAM) &amp;&amp; !sock_isconnected(nso-&gt;nso_so) &amp;&amp; ((sendnam = nmp-&gt;nm_saddr))) {
		msg.msg_name = (caddr_t)sendnam;
		msg.msg_namelen = sendnam-&gt;sa_len;
	}
	error = sock_sendmbuf(nso-&gt;nso_so, &amp;msg, mreqcopy, 0, &amp;sentlen);
	<span class="enscript-keyword">if</span> (error || (sentlen != req-&gt;r_mreqlen)) {
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs_send: 0x%llx sent %d/%d error %d\n&quot;</span>,
			     req-&gt;r_xid, (<span class="enscript-type">int</span>)sentlen, (<span class="enscript-type">int</span>)req-&gt;r_mreqlen, error);
	}
	
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (sentlen != req-&gt;r_mreqlen))
		error = EWOULDBLOCK;
	needrecon = ((sotype == SOCK_STREAM) &amp;&amp; sentlen &amp;&amp; (sentlen != req-&gt;r_mreqlen));

	lck_mtx_lock(&amp;req-&gt;r_mtx);
	req-&gt;r_flags &amp;= ~R_SENDING;
	req-&gt;r_rtt = 0;
	<span class="enscript-keyword">if</span> (rexmit &amp;&amp; (++req-&gt;r_rexmit &gt; NFS_MAXREXMIT))
		req-&gt;r_rexmit = NFS_MAXREXMIT;

	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-comment">/* SUCCESS */</span>
		req-&gt;r_flags &amp;= ~R_RESENDERR;
		<span class="enscript-keyword">if</span> (rexmit)
			OSAddAtomic64(1, &amp;nfsstats.rpcretries);
		req-&gt;r_flags |= R_SENT;
		<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_WAITSENT) {
			req-&gt;r_flags &amp;= ~R_WAITSENT;
			wakeup(req);
		}
		nfs_sndunlock(req);
		lck_mtx_unlock(&amp;req-&gt;r_mtx);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* send failed */</span>
	req-&gt;r_flags |= R_MUSTRESEND;
	<span class="enscript-keyword">if</span> (rexmit)
		req-&gt;r_flags |= R_RESENDERR;
	<span class="enscript-keyword">if</span> ((error == EINTR) || (error == ERESTART))
		req-&gt;r_error = error;
	lck_mtx_unlock(&amp;req-&gt;r_mtx);

	<span class="enscript-keyword">if</span> (sotype == SOCK_DGRAM) {
		<span class="enscript-comment">/*
		 * Note: even though a first send may fail, we consider
		 * the request sent for congestion window purposes.
		 * So we don't need to undo any of the changes made above.
		 */</span>
		<span class="enscript-comment">/*
		 * Socket errors ignored for connectionless sockets??
		 * For now, ignore them all
		 */</span>
		<span class="enscript-keyword">if</span> ((error != EINTR) &amp;&amp; (error != ERESTART) &amp;&amp;
		    (error != EWOULDBLOCK) &amp;&amp; (error != EIO) &amp;&amp; (nso == nmp-&gt;nm_nso)) {
			<span class="enscript-type">int</span> clearerror = 0, optlen = <span class="enscript-keyword">sizeof</span>(clearerror);
			sock_getsockopt(nso-&gt;nso_so, SOL_SOCKET, SO_ERROR, &amp;clearerror, &amp;optlen);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFS_SOCKET_DEBUGGING</span>
			<span class="enscript-keyword">if</span> (clearerror)
				NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs_send: ignoring UDP socket error %d so %d\n&quot;</span>,
					error, clearerror);
#<span class="enscript-reference">endif</span>
		}
	}

	<span class="enscript-comment">/* check if it appears we should reconnect the socket */</span>
	<span class="enscript-keyword">switch</span> (error) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EWOULDBLOCK</span>:
		<span class="enscript-comment">/* if send timed out, reconnect if on TCP */</span>
		<span class="enscript-keyword">if</span> (sotype != SOCK_STREAM)
			<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EPIPE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EADDRNOTAVAIL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETDOWN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETUNREACH</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENETRESET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ECONNABORTED</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ECONNRESET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ENOTCONN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ESHUTDOWN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">ECONNREFUSED</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTDOWN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTUNREACH</span>:
		needrecon = 1;
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (needrecon &amp;&amp; (nso == nmp-&gt;nm_nso)) { <span class="enscript-comment">/* mark socket as needing reconnect */</span>
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs_send: 0x%llx need reconnect %d\n&quot;</span>, req-&gt;r_xid, error);
		nfs_need_reconnect(nmp);
	}

	nfs_sndunlock(req);

	<span class="enscript-keyword">if</span> (nfs_is_dead(error, nmp))
		error = EIO;

	<span class="enscript-comment">/*
	 * Don't log some errors:
	 * EPIPE errors may be common with servers that drop idle connections.
	 * EADDRNOTAVAIL may occur on network transitions.
	 * ENOTCONN may occur under some network conditions.
	 */</span>
	<span class="enscript-keyword">if</span> ((error == EPIPE) || (error == EADDRNOTAVAIL) || (error == ENOTCONN))
		error = 0;
	<span class="enscript-keyword">if</span> (error &amp;&amp; (error != EINTR) &amp;&amp; (error != ERESTART))
		log(LOG_INFO, <span class="enscript-string">&quot;nfs send error %d for server %s\n&quot;</span>, error,
			!req-&gt;r_nmp ? <span class="enscript-string">&quot;&lt;unmounted&gt;&quot;</span> :
			vfs_statfs(req-&gt;r_nmp-&gt;nm_mountp)-&gt;f_mntfromname);

	<span class="enscript-comment">/* prefer request termination error over other errors */</span>
	error2 = nfs_sigintr(req-&gt;r_nmp, req, req-&gt;r_thread, 0);
	<span class="enscript-keyword">if</span> (error2)
		error = error2;

	<span class="enscript-comment">/* only allow the following errors to be returned */</span>
	<span class="enscript-keyword">if</span> ((error != EINTR) &amp;&amp; (error != ERESTART) &amp;&amp; (error != EIO) &amp;&amp;
	    (error != ENXIO) &amp;&amp; (error != ETIMEDOUT))
		error = 0;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS client socket upcalls
 *
 * Pull RPC replies out of an NFS mount's socket and match them
 * up with the pending request.
 *
 * The datagram code is simple because we always get whole
 * messages out of the socket.
 *
 * The stream code is more involved because we have to parse
 * the RPC records out of the stream.
 */</span>

<span class="enscript-comment">/* NFS client UDP socket upcall */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_udp_rcv</span>(socket_t so, <span class="enscript-type">void</span> *arg, __unused <span class="enscript-type">int</span> waitflag)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = arg;
	<span class="enscript-type">struct</span> nfs_socket *nso = nmp-&gt;nm_nso;
	size_t rcvlen;
	mbuf_t m;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_sockflags &amp; NMSOCK_CONNECTING)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">do</span> {
		<span class="enscript-comment">/* make sure we're on the current socket */</span>
		<span class="enscript-keyword">if</span> (!nso || (nso-&gt;nso_so != so))
			<span class="enscript-keyword">return</span>;

		m = NULL;
		rcvlen = 1000000;
		error = sock_receivembuf(so, NULL, &amp;m, MSG_DONTWAIT, &amp;rcvlen);
		<span class="enscript-keyword">if</span> (m)
			nfs_request_match_reply(nmp, m);
	} <span class="enscript-keyword">while</span> (m &amp;&amp; !error);

	<span class="enscript-keyword">if</span> (error &amp;&amp; (error != EWOULDBLOCK)) {
		<span class="enscript-comment">/* problems with the socket... mark for reconnection */</span>
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs_udp_rcv: need reconnect %d\n&quot;</span>, error);
		nfs_need_reconnect(nmp);
	}
}

<span class="enscript-comment">/* NFS client TCP socket upcall */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_tcp_rcv</span>(socket_t so, <span class="enscript-type">void</span> *arg, __unused <span class="enscript-type">int</span> waitflag)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = arg;
	<span class="enscript-type">struct</span> nfs_socket *nso = nmp-&gt;nm_nso;
	<span class="enscript-type">struct</span> nfs_rpc_record_state nrrs;
	mbuf_t m;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> recv = 1;
	<span class="enscript-type">int</span> wup = 0;

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_sockflags &amp; NMSOCK_CONNECTING)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* make sure we're on the current socket */</span>
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	nso = nmp-&gt;nm_nso;
	<span class="enscript-keyword">if</span> (!nso || (nso-&gt;nso_so != so) || (nmp-&gt;nm_sockflags &amp; (NMSOCK_DISCONNECTING))) {
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">return</span>;
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-comment">/* make sure this upcall should be trying to do work */</span>
	lck_mtx_lock(&amp;nso-&gt;nso_lock);
	<span class="enscript-keyword">if</span> (nso-&gt;nso_flags &amp; (NSO_UPCALL|NSO_DISCONNECTING|NSO_DEAD)) {
		lck_mtx_unlock(&amp;nso-&gt;nso_lock);
		<span class="enscript-keyword">return</span>;
	}
	nso-&gt;nso_flags |= NSO_UPCALL;
	nrrs = nso-&gt;nso_rrs;
	lck_mtx_unlock(&amp;nso-&gt;nso_lock);

	<span class="enscript-comment">/* loop while we make error-free progress */</span>
	<span class="enscript-keyword">while</span> (!error &amp;&amp; recv) {
		error = nfs_rpc_record_read(so, &amp;nrrs, MSG_DONTWAIT, &amp;recv, &amp;m);
		<span class="enscript-keyword">if</span> (m) <span class="enscript-comment">/* match completed response with request */</span>
			nfs_request_match_reply(nmp, m);
	}

	<span class="enscript-comment">/* Update the sockets's rpc parsing state */</span>
	lck_mtx_lock(&amp;nso-&gt;nso_lock);
	nso-&gt;nso_rrs = nrrs;
	<span class="enscript-keyword">if</span> (nso-&gt;nso_flags &amp; NSO_DISCONNECTING)
		wup = 1;
	nso-&gt;nso_flags &amp;= ~NSO_UPCALL;
	lck_mtx_unlock(&amp;nso-&gt;nso_lock);
	<span class="enscript-keyword">if</span> (wup)
		wakeup(&amp;nso-&gt;nso_flags);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">NFS_SOCKET_DEBUGGING</span>
	<span class="enscript-keyword">if</span> (!recv &amp;&amp; (error != EWOULDBLOCK))
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs_tcp_rcv: got nothing, error %d, got FIN?\n&quot;</span>, error);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* note: no error and no data indicates server closed its end */</span>
	<span class="enscript-keyword">if</span> ((error != EWOULDBLOCK) &amp;&amp; (error || !recv)) {
		<span class="enscript-comment">/* problems with the socket... mark for reconnection */</span>
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs_tcp_rcv: need reconnect %d\n&quot;</span>, error);
		nfs_need_reconnect(nmp);
	}
}

<span class="enscript-comment">/*
 * &quot;poke&quot; a socket to try to provoke any pending errors
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_sock_poke</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-type">struct</span> iovec aio;
	<span class="enscript-type">struct</span> msghdr msg;
	size_t len;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> dummy;

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_sockflags &amp; NMSOCK_UNMOUNT) ||
	    !(nmp-&gt;nm_sockflags &amp; NMSOCK_READY) || !nmp-&gt;nm_nso || !nmp-&gt;nm_nso-&gt;nso_so) {
		<span class="enscript-comment">/* Nothing to poke */</span>
		nmp-&gt;nm_sockflags &amp;= ~NMSOCK_POKE;
		wakeup(&amp;nmp-&gt;nm_sockflags);
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">return</span>;
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	aio.iov_base = &amp;dummy;
	aio.iov_len = 0;
	len = 0;
	bzero(&amp;msg, <span class="enscript-keyword">sizeof</span>(msg));
	msg.msg_iov = &amp;aio;
	msg.msg_iovlen = 1;
	error = sock_send(nmp-&gt;nm_nso-&gt;nso_so, &amp;msg, MSG_DONTWAIT, &amp;len);
	NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs_sock_poke: error %d\n&quot;</span>, error);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	nmp-&gt;nm_sockflags &amp;= ~NMSOCK_POKE;
	wakeup(&amp;nmp-&gt;nm_sockflags);
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	nfs_is_dead(error, nmp);
}

<span class="enscript-comment">/*
 * Match an RPC reply with the corresponding request
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_request_match_reply</span>(<span class="enscript-type">struct</span> nfsmount *nmp, mbuf_t mrep)
{
	<span class="enscript-type">struct</span> nfsreq *req;
	<span class="enscript-type">struct</span> nfsm_chain nmrep;
	u_int32_t reply = 0, rxid = 0;
	<span class="enscript-type">int</span> error = 0, asyncioq, t1;

	<span class="enscript-comment">/* Get the xid and check that it is an rpc reply */</span>
	nfsm_chain_dissect_init(error, &amp;nmrep, mrep);
	nfsm_chain_get_32(error, &amp;nmrep, rxid);
	nfsm_chain_get_32(error, &amp;nmrep, reply);
	<span class="enscript-keyword">if</span> (error || (reply != RPC_REPLY)) {
		OSAddAtomic64(1, &amp;nfsstats.rpcinvalid);
		mbuf_freem(mrep);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * Loop through the request list to match up the reply
	 * Iff no match, just drop it.
	 */</span>
	lck_mtx_lock(nfs_request_mutex);
	TAILQ_FOREACH(req, &amp;nfs_reqq, r_chain) {
		<span class="enscript-keyword">if</span> (req-&gt;r_nmrep.nmc_mhead || (rxid != R_XID32(req-&gt;r_xid)))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-comment">/* looks like we have it, grab lock and double check */</span>
		lck_mtx_lock(&amp;req-&gt;r_mtx);
		<span class="enscript-keyword">if</span> (req-&gt;r_nmrep.nmc_mhead || (rxid != R_XID32(req-&gt;r_xid))) {
			lck_mtx_unlock(&amp;req-&gt;r_mtx);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/* Found it.. */</span>
		req-&gt;r_nmrep = nmrep;
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_sotype == SOCK_DGRAM) {
			<span class="enscript-comment">/*
			 * Update congestion window.
			 * Do the additive increase of one rpc/rtt.
			 */</span>
			FSDBG(530, R_XID32(req-&gt;r_xid), req, nmp-&gt;nm_sent, nmp-&gt;nm_cwnd);
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_cwnd &lt;= nmp-&gt;nm_sent) {
				nmp-&gt;nm_cwnd +=
				   ((NFS_CWNDSCALE * NFS_CWNDSCALE) +
				    (nmp-&gt;nm_cwnd &gt;&gt; 1)) / nmp-&gt;nm_cwnd;
				<span class="enscript-keyword">if</span> (nmp-&gt;nm_cwnd &gt; NFS_MAXCWND)
					nmp-&gt;nm_cwnd = NFS_MAXCWND;
			}
			<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_CWND) {
				nmp-&gt;nm_sent -= NFS_CWNDSCALE;
				req-&gt;r_flags &amp;= ~R_CWND;
			}
			<span class="enscript-keyword">if</span> ((nmp-&gt;nm_sent &lt; nmp-&gt;nm_cwnd) &amp;&amp; !TAILQ_EMPTY(&amp;nmp-&gt;nm_cwndq)) {
				<span class="enscript-comment">/* congestion window is open, poke the cwnd queue */</span>
				<span class="enscript-type">struct</span> nfsreq *req2 = TAILQ_FIRST(&amp;nmp-&gt;nm_cwndq);
				TAILQ_REMOVE(&amp;nmp-&gt;nm_cwndq, req2, r_cchain);
				req2-&gt;r_cchain.tqe_next = NFSREQNOLIST;
				wakeup(req2);
			}
		}
		<span class="enscript-comment">/*
		 * Update rtt using a gain of 0.125 on the mean
		 * and a gain of 0.25 on the deviation.
		 */</span>
		<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_TIMING) {
			<span class="enscript-comment">/*
			 * Since the timer resolution of
			 * NFS_HZ is so course, it can often
			 * result in r_rtt == 0. Since
			 * r_rtt == N means that the actual
			 * rtt is between N+dt and N+2-dt ticks,
			 * add 1.
			 */</span>
			<span class="enscript-keyword">if</span> (proct[req-&gt;r_procnum] == 0)
				panic(<span class="enscript-string">&quot;nfs_request_match_reply: proct[%d] is zero&quot;</span>, req-&gt;r_procnum);
			t1 = req-&gt;r_rtt + 1;
			t1 -= (NFS_SRTT(req) &gt;&gt; 3);
			NFS_SRTT(req) += t1;
			<span class="enscript-keyword">if</span> (t1 &lt; 0)
				t1 = -t1;
			t1 -= (NFS_SDRTT(req) &gt;&gt; 2);
			NFS_SDRTT(req) += t1;
		}
		nmp-&gt;nm_timeouts = 0;
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-comment">/* signal anyone waiting on this request */</span>
		wakeup(req);
		asyncioq = (req-&gt;r_callback.rcb_func != NULL);
		<span class="enscript-keyword">if</span> (nfs_request_using_gss(req))
			nfs_gss_clnt_rpcdone(req);
		lck_mtx_unlock(&amp;req-&gt;r_mtx);
		lck_mtx_unlock(nfs_request_mutex);
		<span class="enscript-comment">/* if it's an async RPC with a callback, queue it up */</span>
		<span class="enscript-keyword">if</span> (asyncioq)
			nfs_asyncio_finish(req);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (!req) {
		<span class="enscript-comment">/* not matched to a request, so drop it. */</span>
		lck_mtx_unlock(nfs_request_mutex);
		OSAddAtomic64(1, &amp;nfsstats.rpcunexpected);
		mbuf_freem(mrep);
	}
}

<span class="enscript-comment">/*
 * Wait for the reply for a given request...
 * ...potentially resending the request if necessary.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_wait_reply</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">struct</span> timespec ts = { 2, 0 };
	<span class="enscript-type">int</span> error = 0, slpflag, first = 1;

	<span class="enscript-keyword">if</span> (req-&gt;r_nmp &amp;&amp; NMFLAG(req-&gt;r_nmp, INTR) &amp;&amp; req-&gt;r_thread &amp;&amp; !(req-&gt;r_flags &amp; R_NOINTR))
		slpflag = PCATCH;
	<span class="enscript-keyword">else</span>
		slpflag = 0;

	lck_mtx_lock(&amp;req-&gt;r_mtx);
	<span class="enscript-keyword">while</span> (!req-&gt;r_nmrep.nmc_mhead) {
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(req-&gt;r_nmp, req, first ? NULL : req-&gt;r_thread, 0)))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (((error = req-&gt;r_error)) || req-&gt;r_nmrep.nmc_mhead)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* check if we need to resend */</span>
		<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_MUSTRESEND) {
			NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs wait resend: p %d x 0x%llx f 0x%x rtt %d\n&quot;</span>,
				req-&gt;r_procnum, req-&gt;r_xid, req-&gt;r_flags, req-&gt;r_rtt);
			req-&gt;r_flags |= R_SENDING;
			lck_mtx_unlock(&amp;req-&gt;r_mtx);
			<span class="enscript-keyword">if</span> (nfs_request_using_gss(req)) {
				<span class="enscript-comment">/*
				 * It's an RPCSEC_GSS request.
				 * Can't just resend the original request
				 * without bumping the cred sequence number.
				 * Go back and re-build the request.
				 */</span>
				lck_mtx_lock(&amp;req-&gt;r_mtx);
				req-&gt;r_flags &amp;= ~R_SENDING;
				lck_mtx_unlock(&amp;req-&gt;r_mtx);
				<span class="enscript-keyword">return</span> (EAGAIN);
			}
			error = nfs_send(req, 1);
			lck_mtx_lock(&amp;req-&gt;r_mtx);
			NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs wait resend: p %d x 0x%llx f 0x%x rtt %d err %d\n&quot;</span>,
				req-&gt;r_procnum, req-&gt;r_xid, req-&gt;r_flags, req-&gt;r_rtt, error);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">if</span> (((error = req-&gt;r_error)) || req-&gt;r_nmrep.nmc_mhead)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* need to poll if we're P_NOREMOTEHANG */</span>
		<span class="enscript-keyword">if</span> (nfs_noremotehang(req-&gt;r_thread))
			ts.tv_sec = 1;
		msleep(req, &amp;req-&gt;r_mtx, slpflag | (PZERO - 1), <span class="enscript-string">&quot;nfswaitreply&quot;</span>, &amp;ts);
		first = slpflag = 0;
	}
	lck_mtx_unlock(&amp;req-&gt;r_mtx);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * An NFS request goes something like this:
 * (nb: always frees up mreq mbuf list)
 * nfs_request_create()
 *	- allocates a request struct if one is not provided
 *	- initial fill-in of the request struct
 * nfs_request_add_header()
 *	- add the RPC header
 * nfs_request_send()
 *	- link it into list
 *	- call nfs_send() for first transmit
 * nfs_request_wait()
 *	- call nfs_wait_reply() to wait for the reply
 * nfs_request_finish()
 *	- break down rpc header and return with error or nfs reply
 *	  pointed to by nmrep.
 * nfs_request_rele()
 * nfs_request_destroy()
 *      - clean up the request struct
 *      - free the request struct if it was allocated by nfs_request_create()
 */</span>

<span class="enscript-comment">/*
 * Set up an NFS request struct (allocating if no request passed in).
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_request_create</span>(
	nfsnode_t np,
	mount_t mp,	<span class="enscript-comment">/* used only if !np */</span>
	<span class="enscript-type">struct</span> nfsm_chain *nmrest,
	<span class="enscript-type">int</span> procnum,
	thread_t thd,
	kauth_cred_t cred,
	<span class="enscript-type">struct</span> nfsreq **reqp)
{
	<span class="enscript-type">struct</span> nfsreq *req, *newreq = NULL;
	<span class="enscript-type">struct</span> nfsmount *nmp;

	req = *reqp;
	<span class="enscript-keyword">if</span> (!req) {
		<span class="enscript-comment">/* allocate a new NFS request structure */</span>
		MALLOC_ZONE(newreq, <span class="enscript-type">struct</span> nfsreq*, <span class="enscript-keyword">sizeof</span>(*newreq), M_NFSREQ, M_WAITOK);
		<span class="enscript-keyword">if</span> (!newreq) {
			mbuf_freem(nmrest-&gt;nmc_mhead);
			nmrest-&gt;nmc_mhead = NULL;
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
		req = newreq;
	}

	bzero(req, <span class="enscript-keyword">sizeof</span>(*req));
	<span class="enscript-keyword">if</span> (req == newreq)
		req-&gt;r_flags = R_ALLOCATED;

	nmp = VFSTONFS(np ? NFSTOMP(np) : mp);
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		<span class="enscript-keyword">if</span> (newreq)
			FREE_ZONE(newreq, <span class="enscript-keyword">sizeof</span>(*newreq), M_NFSREQ);
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_state &amp; (NFSSTA_FORCE|NFSSTA_DEAD)) &amp;&amp;
	    (nmp-&gt;nm_state &amp; NFSSTA_TIMEO)) {
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		mbuf_freem(nmrest-&gt;nmc_mhead);
		nmrest-&gt;nmc_mhead = NULL;
		<span class="enscript-keyword">if</span> (newreq)
			FREE_ZONE(newreq, <span class="enscript-keyword">sizeof</span>(*newreq), M_NFSREQ);
		<span class="enscript-keyword">return</span> (ENXIO);
	}
	
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers != NFS_VER4) &amp;&amp; (procnum &gt;= 0) &amp;&amp; (procnum &lt; NFS_NPROCS))
		OSAddAtomic64(1, &amp;nfsstats.rpccnt[procnum]);
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers == NFS_VER4) &amp;&amp; (procnum != NFSPROC4_COMPOUND) &amp;&amp; (procnum != NFSPROC4_NULL))
		panic(<span class="enscript-string">&quot;nfs_request: invalid NFSv4 RPC request %d\n&quot;</span>, procnum);

	lck_mtx_init(&amp;req-&gt;r_mtx, nfs_request_grp, LCK_ATTR_NULL);
	req-&gt;r_nmp = nmp;
	nmp-&gt;nm_ref++;
	req-&gt;r_np = np;
	req-&gt;r_thread = thd;
	<span class="enscript-keyword">if</span> (!thd)
		req-&gt;r_flags |= R_NOINTR;
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(cred)) {
		kauth_cred_ref(cred);
		req-&gt;r_cred = cred;
	}
	req-&gt;r_procnum = procnum;
	<span class="enscript-keyword">if</span> (proct[procnum] &gt; 0)
		req-&gt;r_flags |= R_TIMING;
	req-&gt;r_nmrep.nmc_mhead = NULL;
	SLIST_INIT(&amp;req-&gt;r_gss_seqlist);
	req-&gt;r_achain.tqe_next = NFSREQNOLIST;
	req-&gt;r_rchain.tqe_next = NFSREQNOLIST;
	req-&gt;r_cchain.tqe_next = NFSREQNOLIST;

	<span class="enscript-comment">/* set auth flavor to use for request */</span>
	<span class="enscript-keyword">if</span> (!req-&gt;r_cred)
		req-&gt;r_auth = RPCAUTH_NONE;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;r_np &amp;&amp; (req-&gt;r_np-&gt;n_auth != RPCAUTH_INVALID))
		req-&gt;r_auth = req-&gt;r_np-&gt;n_auth;
	<span class="enscript-keyword">else</span>
		req-&gt;r_auth = nmp-&gt;nm_auth;

	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-comment">/* move the request mbuf chain to the nfsreq */</span>
	req-&gt;r_mrest = nmrest-&gt;nmc_mhead;
	nmrest-&gt;nmc_mhead = NULL;

	req-&gt;r_flags |= R_INITTED;
	req-&gt;r_refs = 1;
	<span class="enscript-keyword">if</span> (newreq)
		*reqp = req;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Clean up and free an NFS request structure.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_request_destroy</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> gss_seq *gsp, *ngsp;
	<span class="enscript-type">int</span> clearjbtimeo = 0;

	<span class="enscript-keyword">if</span> (!req || !(req-&gt;r_flags &amp; R_INITTED))
		<span class="enscript-keyword">return</span>;
	nmp  = req-&gt;r_np ? NFSTONMP(req-&gt;r_np) : req-&gt;r_nmp;
	req-&gt;r_flags &amp;= ~R_INITTED;
	<span class="enscript-keyword">if</span> (req-&gt;r_lflags &amp; RL_QUEUED)
		nfs_reqdequeue(req);

	<span class="enscript-keyword">if</span> (req-&gt;r_achain.tqe_next != NFSREQNOLIST) {
		<span class="enscript-comment">/* 
		 * Still on an async I/O queue?
		 * %%% But which one, we may be on a local iod.
		 */</span>
		lck_mtx_lock(nfsiod_mutex);
		<span class="enscript-keyword">if</span> (nmp &amp;&amp; req-&gt;r_achain.tqe_next != NFSREQNOLIST) {
			TAILQ_REMOVE(&amp;nmp-&gt;nm_iodq, req, r_achain);
			req-&gt;r_achain.tqe_next = NFSREQNOLIST;
		}
		lck_mtx_unlock(nfsiod_mutex);
	}

	lck_mtx_lock(&amp;req-&gt;r_mtx);
	<span class="enscript-keyword">if</span> (nmp) {
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_CWND) {
			<span class="enscript-comment">/* Decrement the outstanding request count.  */</span>
			req-&gt;r_flags &amp;= ~R_CWND;
			nmp-&gt;nm_sent -= NFS_CWNDSCALE;
			<span class="enscript-keyword">if</span> ((nmp-&gt;nm_sent &lt; nmp-&gt;nm_cwnd) &amp;&amp; !TAILQ_EMPTY(&amp;nmp-&gt;nm_cwndq)) {
				<span class="enscript-comment">/* congestion window is open, poke the cwnd queue */</span>
				<span class="enscript-type">struct</span> nfsreq *req2 = TAILQ_FIRST(&amp;nmp-&gt;nm_cwndq);
				TAILQ_REMOVE(&amp;nmp-&gt;nm_cwndq, req2, r_cchain);
				req2-&gt;r_cchain.tqe_next = NFSREQNOLIST;
				wakeup(req2);
			}
		}
		assert((req-&gt;r_flags &amp; R_RESENDQ) == 0);
		<span class="enscript-comment">/* XXX should we just remove this conditional, we should have a reference if we're resending */</span>
		<span class="enscript-keyword">if</span> (req-&gt;r_rchain.tqe_next != NFSREQNOLIST) {
			TAILQ_REMOVE(&amp;nmp-&gt;nm_resendq, req, r_rchain);
			req-&gt;r_rchain.tqe_next = NFSREQNOLIST;
			<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_RESENDQ)
				req-&gt;r_flags &amp;= ~R_RESENDQ;
		}
		<span class="enscript-keyword">if</span> (req-&gt;r_cchain.tqe_next != NFSREQNOLIST) {
			TAILQ_REMOVE(&amp;nmp-&gt;nm_cwndq, req, r_cchain);
			req-&gt;r_cchain.tqe_next = NFSREQNOLIST;
		}
		<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_JBTPRINTFMSG) {
			req-&gt;r_flags &amp;= ~R_JBTPRINTFMSG;
			nmp-&gt;nm_jbreqs--;
			clearjbtimeo = (nmp-&gt;nm_jbreqs == 0) ? NFSSTA_JUKEBOXTIMEO : 0;
		}
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	}
	lck_mtx_unlock(&amp;req-&gt;r_mtx);

	<span class="enscript-keyword">if</span> (clearjbtimeo)
		nfs_up(nmp, req-&gt;r_thread, clearjbtimeo, NULL);
	<span class="enscript-keyword">if</span> (req-&gt;r_mhead)
		mbuf_freem(req-&gt;r_mhead);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (req-&gt;r_mrest)
		mbuf_freem(req-&gt;r_mrest);
	<span class="enscript-keyword">if</span> (req-&gt;r_nmrep.nmc_mhead)
		mbuf_freem(req-&gt;r_nmrep.nmc_mhead);
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(req-&gt;r_cred))
		kauth_cred_unref(&amp;req-&gt;r_cred);
	<span class="enscript-keyword">if</span> (nfs_request_using_gss(req))
		nfs_gss_clnt_rpcdone(req);
	SLIST_FOREACH_SAFE(gsp, &amp;req-&gt;r_gss_seqlist, gss_seqnext, ngsp)
		FREE(gsp, M_TEMP);
	<span class="enscript-keyword">if</span> (req-&gt;r_gss_ctx)
		nfs_gss_clnt_ctx_unref(req);
	<span class="enscript-keyword">if</span> (req-&gt;r_wrongsec)
		FREE(req-&gt;r_wrongsec, M_TEMP);
	<span class="enscript-keyword">if</span> (nmp)
		nfs_mount_rele(nmp);
	lck_mtx_destroy(&amp;req-&gt;r_mtx, nfs_request_grp);
	<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_ALLOCATED)
		FREE_ZONE(req, <span class="enscript-keyword">sizeof</span>(*req), M_NFSREQ);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_request_ref</span>(<span class="enscript-type">struct</span> nfsreq *req, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-keyword">if</span> (!locked)
		lck_mtx_lock(&amp;req-&gt;r_mtx);
	<span class="enscript-keyword">if</span> (req-&gt;r_refs &lt;= 0)
		panic(<span class="enscript-string">&quot;nfsreq reference error&quot;</span>);
	req-&gt;r_refs++;
	<span class="enscript-keyword">if</span> (!locked)
		lck_mtx_unlock(&amp;req-&gt;r_mtx);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_request_rele</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">int</span> destroy;

	lck_mtx_lock(&amp;req-&gt;r_mtx);
	<span class="enscript-keyword">if</span> (req-&gt;r_refs &lt;= 0)
		panic(<span class="enscript-string">&quot;nfsreq reference underflow&quot;</span>);
	req-&gt;r_refs--;
	destroy = (req-&gt;r_refs == 0);
	lck_mtx_unlock(&amp;req-&gt;r_mtx);
	<span class="enscript-keyword">if</span> (destroy)
		nfs_request_destroy(req);
}


<span class="enscript-comment">/*
 * Add an (updated) RPC header with authorization to an NFS request.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_request_add_header</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error = 0;
	mbuf_t m;

	<span class="enscript-comment">/* free up any previous header */</span>
	<span class="enscript-keyword">if</span> ((m = req-&gt;r_mhead)) {
		<span class="enscript-keyword">while</span> (m &amp;&amp; (m != req-&gt;r_mrest))
			m = mbuf_free(m);
		req-&gt;r_mhead = NULL;
	}

	nmp = req-&gt;r_np ? NFSTONMP(req-&gt;r_np) : req-&gt;r_nmp;
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	error = nfsm_rpchead(req, req-&gt;r_mrest, &amp;req-&gt;r_xid, &amp;req-&gt;r_mhead);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	req-&gt;r_mreqlen = mbuf_pkthdr_len(req-&gt;r_mhead);
	nmp = req-&gt;r_np ? NFSTONMP(req-&gt;r_np) : req-&gt;r_nmp;
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, SOFT) || (req-&gt;r_flags &amp; R_SOFT))
		req-&gt;r_retry = nmp-&gt;nm_retry;
	<span class="enscript-keyword">else</span>
		req-&gt;r_retry = NFS_MAXREXMIT + 1;	<span class="enscript-comment">/* past clip limit */</span>
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Queue an NFS request up and send it out.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_request_send</span>(<span class="enscript-type">struct</span> nfsreq *req, <span class="enscript-type">int</span> wait)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">struct</span> timeval now;

	lck_mtx_lock(&amp;req-&gt;r_mtx);
	req-&gt;r_flags |= R_SENDING;
	lck_mtx_unlock(&amp;req-&gt;r_mtx);

	lck_mtx_lock(nfs_request_mutex);

	nmp = req-&gt;r_np ? NFSTONMP(req-&gt;r_np) : req-&gt;r_nmp;
	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp)) {
		lck_mtx_unlock(nfs_request_mutex);
		<span class="enscript-keyword">return</span> (ENXIO);
	}

	microuptime(&amp;now);
	<span class="enscript-keyword">if</span> (!req-&gt;r_start) {
		req-&gt;r_start = now.tv_sec;
		req-&gt;r_lastmsg = now.tv_sec -
		    ((nmp-&gt;nm_tprintf_delay) - (nmp-&gt;nm_tprintf_initial_delay));
	}

	OSAddAtomic64(1, &amp;nfsstats.rpcrequests);

	<span class="enscript-comment">/*
	 * Chain request into list of outstanding requests. Be sure
	 * to put it LAST so timer finds oldest requests first.
	 * Make sure that the request queue timer is running
	 * to check for possible request timeout.
	 */</span>
	TAILQ_INSERT_TAIL(&amp;nfs_reqq, req, r_chain);
	req-&gt;r_lflags |= RL_QUEUED;
	<span class="enscript-keyword">if</span> (!nfs_request_timer_on) {
		nfs_request_timer_on = 1;
		nfs_interval_timer_start(nfs_request_timer_call,
			NFS_REQUESTDELAY);
	}
	lck_mtx_unlock(nfs_request_mutex);

	<span class="enscript-comment">/* Send the request... */</span>
	<span class="enscript-keyword">return</span> (nfs_send(req, wait));
}

<span class="enscript-comment">/*
 * Call nfs_wait_reply() to wait for the reply.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_request_wait</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	req-&gt;r_error = nfs_wait_reply(req);
}

<span class="enscript-comment">/*
 * Finish up an NFS request by dequeueing it and
 * doing the initial NFS request reply processing.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_request_finish</span>(
	<span class="enscript-type">struct</span> nfsreq *req,
	<span class="enscript-type">struct</span> nfsm_chain *nmrepp,
	<span class="enscript-type">int</span> *status)
{
	<span class="enscript-type">struct</span> nfsmount *nmp;
	mbuf_t mrep;
	<span class="enscript-type">int</span> verf_type = 0;
	uint32_t verf_len = 0;
	uint32_t reply_status = 0;
	uint32_t rejected_status = 0;
	uint32_t auth_status = 0;
	uint32_t accepted_status = 0;
	<span class="enscript-type">struct</span> nfsm_chain nmrep;
	<span class="enscript-type">int</span> error, clearjbtimeo;

	error = req-&gt;r_error;

	<span class="enscript-keyword">if</span> (nmrepp)
		nmrepp-&gt;nmc_mhead = NULL;

	<span class="enscript-comment">/* RPC done, unlink the request. */</span>
	nfs_reqdequeue(req);

	mrep = req-&gt;r_nmrep.nmc_mhead;

	nmp = req-&gt;r_np ? NFSTONMP(req-&gt;r_np) : req-&gt;r_nmp;

	<span class="enscript-keyword">if</span> ((req-&gt;r_flags &amp; R_CWND) &amp;&amp; nmp) {
		<span class="enscript-comment">/*
		 * Decrement the outstanding request count.
		 */</span>
		req-&gt;r_flags &amp;= ~R_CWND;
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		FSDBG(273, R_XID32(req-&gt;r_xid), req, nmp-&gt;nm_sent, nmp-&gt;nm_cwnd);
		nmp-&gt;nm_sent -= NFS_CWNDSCALE;
		<span class="enscript-keyword">if</span> ((nmp-&gt;nm_sent &lt; nmp-&gt;nm_cwnd) &amp;&amp; !TAILQ_EMPTY(&amp;nmp-&gt;nm_cwndq)) {
			<span class="enscript-comment">/* congestion window is open, poke the cwnd queue */</span>
			<span class="enscript-type">struct</span> nfsreq *req2 = TAILQ_FIRST(&amp;nmp-&gt;nm_cwndq);
			TAILQ_REMOVE(&amp;nmp-&gt;nm_cwndq, req2, r_cchain);
			req2-&gt;r_cchain.tqe_next = NFSREQNOLIST;
			wakeup(req2);
		}
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	}

	<span class="enscript-keyword">if</span> (nfs_request_using_gss(req)) {
		<span class="enscript-comment">/*
		 * If the request used an RPCSEC_GSS credential
		 * then reset its sequence number bit in the
		 * request window.
		 */</span>
		nfs_gss_clnt_rpcdone(req);

		<span class="enscript-comment">/*
		 * If we need to re-send, go back and re-build the
		 * request based on a new sequence number.
		 * Note that we're using the original XID.
		 */</span>
		<span class="enscript-keyword">if</span> (error == EAGAIN) {
			req-&gt;r_error = 0;
			<span class="enscript-keyword">if</span> (mrep)
				mbuf_freem(mrep);
			error = nfs_gss_clnt_args_restore(req);	<span class="enscript-comment">// remove any trailer mbufs
</span>			req-&gt;r_nmrep.nmc_mhead = NULL;
			req-&gt;r_flags |= R_RESTART;
			<span class="enscript-keyword">if</span> (error == ENEEDAUTH) {
				req-&gt;r_xid = 0;		<span class="enscript-comment">// get a new XID
</span>				error = 0;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
	}

	<span class="enscript-comment">/*
	 * If there was a successful reply, make sure to mark the mount as up.
	 * If a tprintf message was given (or if this is a timed-out soft mount)
	 * then post a tprintf message indicating the server is alive again.
	 */</span>
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-keyword">if</span> ((req-&gt;r_flags &amp; R_TPRINTFMSG) ||
		    (nmp &amp;&amp; (NMFLAG(nmp, SOFT) || (req-&gt;r_flags &amp; R_SOFT)) &amp;&amp;
		     ((nmp-&gt;nm_state &amp; (NFSSTA_TIMEO|NFSSTA_FORCE|NFSSTA_DEAD)) == NFSSTA_TIMEO)))
			nfs_up(nmp, req-&gt;r_thread, NFSSTA_TIMEO, <span class="enscript-string">&quot;is alive again&quot;</span>);
		<span class="enscript-keyword">else</span>
			nfs_up(nmp, req-&gt;r_thread, NFSSTA_TIMEO, NULL);
	}
	<span class="enscript-keyword">if</span> (!error &amp;&amp; !nmp)
		error = ENXIO;
	nfsmout_if(error);

	<span class="enscript-comment">/*
	 * break down the RPC header and check if ok
	 */</span>
	nmrep = req-&gt;r_nmrep;
	nfsm_chain_get_32(error, &amp;nmrep, reply_status);
	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (reply_status == RPC_MSGDENIED) {
		nfsm_chain_get_32(error, &amp;nmrep, rejected_status);
		nfsmout_if(error);
		<span class="enscript-keyword">if</span> (rejected_status == RPC_MISMATCH) {
			error = ENOTSUP;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
		nfsm_chain_get_32(error, &amp;nmrep, auth_status);
		nfsmout_if(error);
		<span class="enscript-keyword">switch</span> (auth_status) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_CREDPROBLEM</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCSEC_GSS_CTXPROBLEM</span>:
			<span class="enscript-comment">/*
			 * An RPCSEC_GSS cred or context problem.
			 * We can't use it anymore.
			 * Restore the args, renew the context
			 * and set up for a resend.
			 */</span>
			error = nfs_gss_clnt_args_restore(req);
			<span class="enscript-keyword">if</span> (error &amp;&amp; error != ENEEDAUTH)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> (!error) {
				error = nfs_gss_clnt_ctx_renew(req);
				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">break</span>;
			}
			mbuf_freem(mrep);
			req-&gt;r_nmrep.nmc_mhead = NULL;
			req-&gt;r_xid = 0;		<span class="enscript-comment">// get a new XID
</span>			req-&gt;r_flags |= R_RESTART;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		<span class="enscript-reference">default</span>:
			error = EACCES;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
	}

	<span class="enscript-comment">/* Now check the verifier */</span>
	nfsm_chain_get_32(error, &amp;nmrep, verf_type); <span class="enscript-comment">// verifier flavor
</span>	nfsm_chain_get_32(error, &amp;nmrep, verf_len);  <span class="enscript-comment">// verifier length
</span>	nfsmout_if(error);

	<span class="enscript-keyword">switch</span> (req-&gt;r_auth) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_NONE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_SYS</span>:
		<span class="enscript-comment">/* Any AUTH_SYS verifier is ignored */</span>
		<span class="enscript-keyword">if</span> (verf_len &gt; 0)
			nfsm_chain_adv(error, &amp;nmrep, nfsm_rndup(verf_len));
		nfsm_chain_get_32(error, &amp;nmrep, accepted_status);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5I</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5P</span>:
		error = nfs_gss_clnt_verf_get(req, &amp;nmrep,
			verf_type, verf_len, &amp;accepted_status);
		<span class="enscript-keyword">break</span>;
	}
	nfsmout_if(error);

	<span class="enscript-keyword">switch</span> (accepted_status) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_SUCCESS</span>:
		<span class="enscript-keyword">if</span> (req-&gt;r_procnum == NFSPROC_NULL) {
			<span class="enscript-comment">/*
			 * The NFS null procedure is unique,
			 * in not returning an NFS status.
			 */</span>
			*status = NFS_OK;
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_get_32(error, &amp;nmrep, *status);
			nfsmout_if(error);
		}

		<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers != NFS_VER2) &amp;&amp; (*status == NFSERR_TRYLATER)) {
			<span class="enscript-comment">/*
			 * It's a JUKEBOX error - delay and try again
			 */</span>
			<span class="enscript-type">int</span> delay, slpflag = (NMFLAG(nmp, INTR) &amp;&amp; !(req-&gt;r_flags &amp; R_NOINTR)) ? PCATCH : 0;

			mbuf_freem(mrep);
			req-&gt;r_nmrep.nmc_mhead = NULL;
			<span class="enscript-keyword">if</span> ((req-&gt;r_delay &gt;= 30) &amp;&amp; !(nmp-&gt;nm_state &amp; NFSSTA_MOUNTED)) {
				<span class="enscript-comment">/* we're not yet completely mounted and */</span>
				<span class="enscript-comment">/* we can't complete an RPC, so we fail */</span>
				OSAddAtomic64(1, &amp;nfsstats.rpctimeouts);
				nfs_softterm(req);
				error = req-&gt;r_error;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}
			req-&gt;r_delay = !req-&gt;r_delay ? NFS_TRYLATERDEL : (req-&gt;r_delay * 2);
			<span class="enscript-keyword">if</span> (req-&gt;r_delay &gt; 30)
				req-&gt;r_delay = 30;
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_tprintf_initial_delay &amp;&amp; (req-&gt;r_delay &gt;= nmp-&gt;nm_tprintf_initial_delay)) {
				<span class="enscript-keyword">if</span> (!(req-&gt;r_flags &amp; R_JBTPRINTFMSG)) {
					req-&gt;r_flags |= R_JBTPRINTFMSG;
					lck_mtx_lock(&amp;nmp-&gt;nm_lock);
					nmp-&gt;nm_jbreqs++;
					lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
				}
				nfs_down(req-&gt;r_nmp, req-&gt;r_thread, 0, NFSSTA_JUKEBOXTIMEO,
					 <span class="enscript-string">&quot;resource temporarily unavailable (jukebox)&quot;</span>, 0);
			}
			<span class="enscript-keyword">if</span> ((NMFLAG(nmp, SOFT) || (req-&gt;r_flags &amp; R_SOFT)) &amp;&amp; (req-&gt;r_delay == 30) &amp;&amp;
				!(req-&gt;r_flags &amp; R_NOINTR)) {
				<span class="enscript-comment">/* for soft mounts, just give up after a short while */</span>
				OSAddAtomic64(1, &amp;nfsstats.rpctimeouts);
				nfs_softterm(req);
				error = req-&gt;r_error;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}
			delay = req-&gt;r_delay;
			<span class="enscript-keyword">if</span> (req-&gt;r_callback.rcb_func) {
				<span class="enscript-type">struct</span> timeval now;
				microuptime(&amp;now);
				req-&gt;r_resendtime = now.tv_sec + delay;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">do</span> {
					<span class="enscript-keyword">if</span> ((error = nfs_sigintr(req-&gt;r_nmp, req, req-&gt;r_thread, 0)))
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
					tsleep(nfs_request_finish, PSOCK|slpflag, <span class="enscript-string">&quot;nfs_jukebox_trylater&quot;</span>, hz);
					slpflag = 0;
				} <span class="enscript-keyword">while</span> (--delay &gt; 0);
			}
			req-&gt;r_xid = 0;			<span class="enscript-comment">// get a new XID
</span>			req-&gt;r_flags |= R_RESTART;
			req-&gt;r_start = 0;
			FSDBG(273, R_XID32(req-&gt;r_xid), nmp, req, NFSERR_TRYLATER);
			<span class="enscript-keyword">return</span> (0);
		}

		<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_JBTPRINTFMSG) {
			req-&gt;r_flags &amp;= ~R_JBTPRINTFMSG;
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			nmp-&gt;nm_jbreqs--;
			clearjbtimeo = (nmp-&gt;nm_jbreqs == 0) ? NFSSTA_JUKEBOXTIMEO : 0;
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			nfs_up(nmp, req-&gt;r_thread, clearjbtimeo, <span class="enscript-string">&quot;resource available again&quot;</span>);
		}

		<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; (*status == NFSERR_WRONGSEC)) {
			<span class="enscript-comment">/*
			 * Hmmm... we need to try a different security flavor.
			 * The first time a request hits this, we will allocate an array
			 * to track flavors to try.  We fill the array with the mount's
			 * preferred flavors or the server's preferred flavors or just the
			 * flavors we support.
			 */</span>
			uint32_t srvflavors[NX_MAX_SEC_FLAVORS];
			<span class="enscript-type">int</span> srvcount, i, j;

			<span class="enscript-comment">/* Call SECINFO to try to get list of flavors from server. */</span>
			srvcount = NX_MAX_SEC_FLAVORS;
			nfs4_secinfo_rpc(nmp, &amp;req-&gt;r_secinfo, req-&gt;r_cred, srvflavors, &amp;srvcount);

			<span class="enscript-keyword">if</span> (!req-&gt;r_wrongsec) {
				<span class="enscript-comment">/* first time... set up flavor array */</span>
				MALLOC(req-&gt;r_wrongsec, uint32_t*, NX_MAX_SEC_FLAVORS*<span class="enscript-keyword">sizeof</span>(uint32_t), M_TEMP, M_WAITOK);
				<span class="enscript-keyword">if</span> (!req-&gt;r_wrongsec) {
					error = EACCES;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
				}
				i=0;
				<span class="enscript-keyword">if</span> (nmp-&gt;nm_sec.count) { <span class="enscript-comment">/* use the mount's preferred list of flavors */</span>
					<span class="enscript-keyword">for</span>(; i &lt; nmp-&gt;nm_sec.count; i++)
						req-&gt;r_wrongsec[i] = nmp-&gt;nm_sec.flavors[i];
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (srvcount) { <span class="enscript-comment">/* otherwise use the server's list of flavors */</span>
					<span class="enscript-keyword">for</span>(; i &lt; srvcount; i++)
						req-&gt;r_wrongsec[i] = srvflavors[i];
				} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* otherwise, just try the flavors we support. */</span>
					req-&gt;r_wrongsec[i++] = RPCAUTH_KRB5P;
					req-&gt;r_wrongsec[i++] = RPCAUTH_KRB5I;
					req-&gt;r_wrongsec[i++] = RPCAUTH_KRB5;
					req-&gt;r_wrongsec[i++] = RPCAUTH_SYS;
					req-&gt;r_wrongsec[i++] = RPCAUTH_NONE;
				}
				<span class="enscript-keyword">for</span>(; i &lt; NX_MAX_SEC_FLAVORS; i++) <span class="enscript-comment">/* invalidate any remaining slots */</span>
					req-&gt;r_wrongsec[i] = RPCAUTH_INVALID;
			}

			<span class="enscript-comment">/* clear the current flavor from the list */</span>
			<span class="enscript-keyword">for</span>(i=0; i &lt; NX_MAX_SEC_FLAVORS; i++)
				<span class="enscript-keyword">if</span> (req-&gt;r_wrongsec[i] == req-&gt;r_auth)
					req-&gt;r_wrongsec[i] = RPCAUTH_INVALID;

			<span class="enscript-comment">/* find the next flavor to try */</span>
			<span class="enscript-keyword">for</span>(i=0; i &lt; NX_MAX_SEC_FLAVORS; i++)
				<span class="enscript-keyword">if</span> (req-&gt;r_wrongsec[i] != RPCAUTH_INVALID) {
					<span class="enscript-keyword">if</span> (!srvcount) <span class="enscript-comment">/* no server list, just try it */</span>
						<span class="enscript-keyword">break</span>;
					<span class="enscript-comment">/* check that it's in the server's list */</span>
					<span class="enscript-keyword">for</span>(j=0; j &lt; srvcount; j++)
						<span class="enscript-keyword">if</span> (req-&gt;r_wrongsec[i] == srvflavors[j])
							<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">if</span> (j &lt; srvcount) <span class="enscript-comment">/* found */</span>
						<span class="enscript-keyword">break</span>;
					<span class="enscript-comment">/* not found in server list */</span>
					req-&gt;r_wrongsec[i] = RPCAUTH_INVALID;
				}
			<span class="enscript-keyword">if</span> (i == NX_MAX_SEC_FLAVORS) {
				<span class="enscript-comment">/* nothing left to try! */</span>
				error = EACCES;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			}

			<span class="enscript-comment">/* retry with the next auth flavor */</span>
			req-&gt;r_auth = req-&gt;r_wrongsec[i];
			req-&gt;r_xid = 0;			<span class="enscript-comment">// get a new XID
</span>			req-&gt;r_flags |= R_RESTART;
			req-&gt;r_start = 0;
			FSDBG(273, R_XID32(req-&gt;r_xid), nmp, req, NFSERR_WRONGSEC);
			<span class="enscript-keyword">return</span> (0);
		}
		<span class="enscript-keyword">if</span> ((nmp-&gt;nm_vers &gt;= NFS_VER4) &amp;&amp; req-&gt;r_wrongsec) {
			<span class="enscript-comment">/*
			 * We renegotiated security for this request; so update the
			 * default security flavor for the associated node.
			 */</span>
			<span class="enscript-keyword">if</span> (req-&gt;r_np)
				req-&gt;r_np-&gt;n_auth = req-&gt;r_auth;
		}

		<span class="enscript-keyword">if</span> (*status == NFS_OK) {
			<span class="enscript-comment">/*
			 * Successful NFS request
			 */</span>
			*nmrepp = nmrep;
			req-&gt;r_nmrep.nmc_mhead = NULL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* Got an NFS error of some kind */</span>

		<span class="enscript-comment">/*
		 * If the File Handle was stale, invalidate the
		 * lookup cache, just in case.
		 */</span>
		<span class="enscript-keyword">if</span> ((*status == ESTALE) &amp;&amp; req-&gt;r_np) {
			cache_purge(NFSTOV(req-&gt;r_np));
			<span class="enscript-comment">/* if monitored, also send delete event */</span>
			<span class="enscript-keyword">if</span> (vnode_ismonitored(NFSTOV(req-&gt;r_np)))
				nfs_vnode_notify(req-&gt;r_np, (VNODE_EVENT_ATTRIB|VNODE_EVENT_DELETE));
		}
		<span class="enscript-keyword">if</span> (nmp-&gt;nm_vers == NFS_VER2)
			mbuf_freem(mrep);
		<span class="enscript-keyword">else</span>
			*nmrepp = nmrep;
		req-&gt;r_nmrep.nmc_mhead = NULL;
		error = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_PROGUNAVAIL</span>:
		error = EPROGUNAVAIL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_PROGMISMATCH</span>:
		error = ERPCMISMATCH;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_PROCUNAVAIL</span>:
		error = EPROCUNAVAIL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_GARBAGE</span>:
		error = EBADRPC;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_SYSTEM_ERR</span>:
	<span class="enscript-reference">default</span>:
		error = EIO;
		<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_JBTPRINTFMSG) {
		req-&gt;r_flags &amp;= ~R_JBTPRINTFMSG;
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
		nmp-&gt;nm_jbreqs--;
		clearjbtimeo = (nmp-&gt;nm_jbreqs == 0) ? NFSSTA_JUKEBOXTIMEO : 0;
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">if</span> (clearjbtimeo)
			nfs_up(nmp, req-&gt;r_thread, clearjbtimeo, NULL);
	}
	FSDBG(273, R_XID32(req-&gt;r_xid), nmp, req,
		(!error &amp;&amp; (*status == NFS_OK)) ? 0xf0f0f0f0 : error);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * NFS request using a GSS/Kerberos security flavor?
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_request_using_gss</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-keyword">if</span> (!req-&gt;r_gss_ctx)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">switch</span> (req-&gt;r_auth) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5I</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPCAUTH_KRB5P</span>:
			<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Perform an NFS request synchronously.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_request</span>(
	nfsnode_t np,
	mount_t mp,	<span class="enscript-comment">/* used only if !np */</span>
	<span class="enscript-type">struct</span> nfsm_chain *nmrest,
	<span class="enscript-type">int</span> procnum,
	vfs_context_t ctx,
	<span class="enscript-type">struct</span> nfsreq_secinfo_args *si,
	<span class="enscript-type">struct</span> nfsm_chain *nmrepp,
	u_int64_t *xidp,
	<span class="enscript-type">int</span> *status)
{
	<span class="enscript-keyword">return</span> nfs_request2(np, mp, nmrest, procnum,
		vfs_context_thread(ctx), vfs_context_ucred(ctx),
		si, 0, nmrepp, xidp, status);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_request2</span>(
	nfsnode_t np,
	mount_t mp,	<span class="enscript-comment">/* used only if !np */</span>
	<span class="enscript-type">struct</span> nfsm_chain *nmrest,
	<span class="enscript-type">int</span> procnum,
	thread_t thd,
	kauth_cred_t cred,
	<span class="enscript-type">struct</span> nfsreq_secinfo_args *si,
	<span class="enscript-type">int</span> flags,
	<span class="enscript-type">struct</span> nfsm_chain *nmrepp,
	u_int64_t *xidp,
	<span class="enscript-type">int</span> *status)
{
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((error = nfs_request_create(np, mp, nmrest, procnum, thd, cred, &amp;req)))
		<span class="enscript-keyword">return</span> (error);
	req-&gt;r_flags |= (flags &amp; (R_OPTMASK | R_SOFT));
	<span class="enscript-keyword">if</span> (si)
		req-&gt;r_secinfo = *si;

	FSDBG_TOP(273, R_XID32(req-&gt;r_xid), np, procnum, 0);
	<span class="enscript-keyword">do</span> {
		req-&gt;r_error = 0;
		req-&gt;r_flags &amp;= ~R_RESTART;
		<span class="enscript-keyword">if</span> ((error = nfs_request_add_header(req)))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (xidp)
			*xidp = req-&gt;r_xid;
		<span class="enscript-keyword">if</span> ((error = nfs_request_send(req, 1)))
			<span class="enscript-keyword">break</span>;
		nfs_request_wait(req);
		<span class="enscript-keyword">if</span> ((error = nfs_request_finish(req, nmrepp, status)))
			<span class="enscript-keyword">break</span>;
	} <span class="enscript-keyword">while</span> (req-&gt;r_flags &amp; R_RESTART);

	FSDBG_BOT(273, R_XID32(req-&gt;r_xid), np, procnum, error);
	nfs_request_rele(req);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Set up a new null proc request to exchange GSS context tokens with the
 * server. Associate the context that we are setting up with the request that we
 * are sending.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_request_gss</span>(
		mount_t mp,
		<span class="enscript-type">struct</span> nfsm_chain *nmrest,
		thread_t thd,
		kauth_cred_t cred,
		<span class="enscript-type">int</span> flags,
		<span class="enscript-type">struct</span> nfs_gss_clnt_ctx *cp,   <span class="enscript-comment">/* Set to gss context to renew or setup */</span>
		<span class="enscript-type">struct</span> nfsm_chain *nmrepp,
		<span class="enscript-type">int</span> *status)
{
	<span class="enscript-type">struct</span> nfsreq rq, *req = &amp;rq;
	<span class="enscript-type">int</span> error, wait = 1;

	<span class="enscript-keyword">if</span> ((error = nfs_request_create(NULL, mp, nmrest, NFSPROC_NULL, thd, cred, &amp;req)))
		<span class="enscript-keyword">return</span> (error);
	req-&gt;r_flags |= (flags &amp; R_OPTMASK);

	<span class="enscript-keyword">if</span> (cp == NULL) {
		printf(<span class="enscript-string">&quot;nfs_request_gss request has no context\n&quot;</span>);
		nfs_request_rele(req);
		<span class="enscript-keyword">return</span> (NFSERR_EAUTH);
	}
	nfs_gss_clnt_ctx_ref(req, cp);

	<span class="enscript-comment">/*
	 * Don't wait for a reply to a context destroy advisory
	 * to avoid hanging on a dead server.
	 */</span>
	<span class="enscript-keyword">if</span> (cp-&gt;gss_clnt_proc == RPCSEC_GSS_DESTROY)
		wait = 0;

	FSDBG_TOP(273, R_XID32(req-&gt;r_xid), NULL, NFSPROC_NULL, 0);
	<span class="enscript-keyword">do</span> {
		req-&gt;r_error = 0;
		req-&gt;r_flags &amp;= ~R_RESTART;
		<span class="enscript-keyword">if</span> ((error = nfs_request_add_header(req)))
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> ((error = nfs_request_send(req, wait)))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (!wait)
			<span class="enscript-keyword">break</span>;

		nfs_request_wait(req);
		<span class="enscript-keyword">if</span> ((error = nfs_request_finish(req, nmrepp, status)))
			<span class="enscript-keyword">break</span>;
	} <span class="enscript-keyword">while</span> (req-&gt;r_flags &amp; R_RESTART);

	FSDBG_BOT(273, R_XID32(req-&gt;r_xid), NULL, NFSPROC_NULL, error);

	nfs_gss_clnt_ctx_unref(req);
	nfs_request_rele(req);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Create and start an asynchronous NFS request.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_request_async</span>(
	nfsnode_t np,
	mount_t mp,	<span class="enscript-comment">/* used only if !np */</span>
	<span class="enscript-type">struct</span> nfsm_chain *nmrest,
	<span class="enscript-type">int</span> procnum,
	thread_t thd,
	kauth_cred_t cred,
	<span class="enscript-type">struct</span> nfsreq_secinfo_args *si,
	<span class="enscript-type">int</span> flags,
	<span class="enscript-type">struct</span> nfsreq_cbinfo *cb,
	<span class="enscript-type">struct</span> nfsreq **reqp)
{
	<span class="enscript-type">struct</span> nfsreq *req;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> error, sent;

	error = nfs_request_create(np, mp, nmrest, procnum, thd, cred, reqp);
	req = *reqp;
	FSDBG(274, (req ? R_XID32(req-&gt;r_xid) : 0), np, procnum, error);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	req-&gt;r_flags |= (flags &amp; R_OPTMASK);
	req-&gt;r_flags |= R_ASYNC;
	<span class="enscript-keyword">if</span> (si)
		req-&gt;r_secinfo = *si;
	<span class="enscript-keyword">if</span> (cb)
		req-&gt;r_callback = *cb;
	error = nfs_request_add_header(req);
	<span class="enscript-keyword">if</span> (!error) {
		req-&gt;r_flags |= R_WAITSENT;
		<span class="enscript-keyword">if</span> (req-&gt;r_callback.rcb_func)
			nfs_request_ref(req, 0);
		error = nfs_request_send(req, 1);
		lck_mtx_lock(&amp;req-&gt;r_mtx);
		<span class="enscript-keyword">if</span> (!error &amp;&amp; !(req-&gt;r_flags &amp; R_SENT) &amp;&amp; req-&gt;r_callback.rcb_func) {
			<span class="enscript-comment">/* make sure to wait until this async I/O request gets sent */</span>
			<span class="enscript-type">int</span> slpflag = (req-&gt;r_nmp &amp;&amp; NMFLAG(req-&gt;r_nmp, INTR) &amp;&amp; req-&gt;r_thread &amp;&amp; !(req-&gt;r_flags &amp; R_NOINTR)) ? PCATCH : 0;
			<span class="enscript-type">struct</span> timespec ts = { 2, 0 };
			<span class="enscript-keyword">while</span> (!(req-&gt;r_flags &amp; R_SENT)) {
				nmp = req-&gt;r_nmp;
				<span class="enscript-keyword">if</span> ((req-&gt;r_flags &amp; R_RESENDQ) &amp;&amp; !nfs_mount_gone(nmp)) {
					lck_mtx_lock(&amp;nmp-&gt;nm_lock);
					<span class="enscript-keyword">if</span> ((nmp-&gt;nm_state &amp; NFSSTA_RECOVER) &amp;&amp; (req-&gt;r_rchain.tqe_next != NFSREQNOLIST)) {
						<span class="enscript-comment">/*
						 * It's not going to get off the resend queue if we're in recovery.
						 * So, just take it off ourselves.  We could be holding mount state
						 * busy and thus holding up the start of recovery.
						 */</span>
						TAILQ_REMOVE(&amp;nmp-&gt;nm_resendq, req, r_rchain);
						req-&gt;r_rchain.tqe_next = NFSREQNOLIST;
						<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_RESENDQ)
							req-&gt;r_flags &amp;= ~R_RESENDQ;
						lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
						req-&gt;r_flags |= R_SENDING;
						lck_mtx_unlock(&amp;req-&gt;r_mtx);
						error = nfs_send(req, 1);
						<span class="enscript-comment">/* Remove the R_RESENDQ reference */</span>
						nfs_request_rele(req);
						lck_mtx_lock(&amp;req-&gt;r_mtx);
						<span class="enscript-keyword">if</span> (error)
							<span class="enscript-keyword">break</span>;
						<span class="enscript-keyword">continue</span>;
					}
					lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
				}
				<span class="enscript-keyword">if</span> ((error = nfs_sigintr(req-&gt;r_nmp, req, req-&gt;r_thread, 0)))
					<span class="enscript-keyword">break</span>;
				msleep(req, &amp;req-&gt;r_mtx, slpflag | (PZERO - 1), <span class="enscript-string">&quot;nfswaitsent&quot;</span>, &amp;ts);
				slpflag = 0;
			}
		}
		sent = req-&gt;r_flags &amp; R_SENT;
		lck_mtx_unlock(&amp;req-&gt;r_mtx);
		<span class="enscript-keyword">if</span> (error &amp;&amp; req-&gt;r_callback.rcb_func &amp;&amp; !sent) {
			nfs_request_rele(req);
		}
	}
	FSDBG(274, R_XID32(req-&gt;r_xid), np, procnum, error);
	<span class="enscript-keyword">if</span> (error || req-&gt;r_callback.rcb_func)
		nfs_request_rele(req);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Wait for and finish an asynchronous NFS request.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_request_async_finish</span>(
	<span class="enscript-type">struct</span> nfsreq *req,
	<span class="enscript-type">struct</span> nfsm_chain *nmrepp,
	u_int64_t *xidp,
	<span class="enscript-type">int</span> *status)
{
	<span class="enscript-type">int</span> error = 0, asyncio = req-&gt;r_callback.rcb_func ? 1 : 0;
	<span class="enscript-type">struct</span> nfsmount *nmp;

	lck_mtx_lock(&amp;req-&gt;r_mtx);
	<span class="enscript-keyword">if</span> (!asyncio)
		req-&gt;r_flags |= R_ASYNCWAIT;
	<span class="enscript-keyword">while</span> (req-&gt;r_flags &amp; R_RESENDQ) {  <span class="enscript-comment">/* wait until the request is off the resend queue */</span>
		<span class="enscript-type">struct</span> timespec ts = { 2, 0 };

		<span class="enscript-keyword">if</span> ((nmp = req-&gt;r_nmp)) {
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">if</span> ((nmp-&gt;nm_state &amp; NFSSTA_RECOVER) &amp;&amp; (req-&gt;r_rchain.tqe_next != NFSREQNOLIST)) {
				<span class="enscript-comment">/*
				 * It's not going to get off the resend queue if we're in recovery.
				 * So, just take it off ourselves.  We could be holding mount state
				 * busy and thus holding up the start of recovery.
				 */</span>
				TAILQ_REMOVE(&amp;nmp-&gt;nm_resendq, req, r_rchain);
				req-&gt;r_rchain.tqe_next = NFSREQNOLIST;
				<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_RESENDQ)
					req-&gt;r_flags &amp;= ~R_RESENDQ;
				<span class="enscript-comment">/* Remove the R_RESENDQ reference */</span>
				assert(req-&gt;r_refs &gt; 0);
				req-&gt;r_refs--;
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
				<span class="enscript-keyword">break</span>;
			}
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		}
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(req-&gt;r_nmp, req, req-&gt;r_thread, 0)))
			<span class="enscript-keyword">break</span>;
		msleep(req, &amp;req-&gt;r_mtx, PZERO-1, <span class="enscript-string">&quot;nfsresendqwait&quot;</span>, &amp;ts);
	}
	lck_mtx_unlock(&amp;req-&gt;r_mtx);

	<span class="enscript-keyword">if</span> (!error) {
		nfs_request_wait(req);
		error = nfs_request_finish(req, nmrepp, status);
	}

	<span class="enscript-keyword">while</span> (!error &amp;&amp; (req-&gt;r_flags &amp; R_RESTART)) {
		<span class="enscript-keyword">if</span> (asyncio) {
			assert(req-&gt;r_achain.tqe_next == NFSREQNOLIST);
			lck_mtx_lock(&amp;req-&gt;r_mtx);
			req-&gt;r_flags &amp;= ~R_IOD;
			<span class="enscript-keyword">if</span> (req-&gt;r_resendtime) {  <span class="enscript-comment">/* send later */</span>
				nfs_asyncio_resend(req);
				lck_mtx_unlock(&amp;req-&gt;r_mtx);
				<span class="enscript-keyword">return</span> (EINPROGRESS);
			}
			lck_mtx_unlock(&amp;req-&gt;r_mtx);
		}
		req-&gt;r_error = 0;
		req-&gt;r_flags &amp;= ~R_RESTART;
		<span class="enscript-keyword">if</span> ((error = nfs_request_add_header(req)))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> ((error = nfs_request_send(req, !asyncio)))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (asyncio)
			<span class="enscript-keyword">return</span> (EINPROGRESS);
		nfs_request_wait(req);
		<span class="enscript-keyword">if</span> ((error = nfs_request_finish(req, nmrepp, status)))
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (xidp)
		*xidp = req-&gt;r_xid;

	FSDBG(275, R_XID32(req-&gt;r_xid), req-&gt;r_np, req-&gt;r_procnum, error);
	nfs_request_rele(req);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Cancel a pending asynchronous NFS request.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_request_async_cancel</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	FSDBG(275, R_XID32(req-&gt;r_xid), req-&gt;r_np, req-&gt;r_procnum, 0xD1ED1E);
	nfs_request_rele(req);
}

<span class="enscript-comment">/*
 * Flag a request as being terminated.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_softterm</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = req-&gt;r_nmp;
	req-&gt;r_flags |= R_SOFTTERM;
	req-&gt;r_error = ETIMEDOUT;
	<span class="enscript-keyword">if</span> (!(req-&gt;r_flags &amp; R_CWND) || nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span>;
	<span class="enscript-comment">/* update congestion window */</span>
	req-&gt;r_flags &amp;= ~R_CWND;
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	FSDBG(532, R_XID32(req-&gt;r_xid), req, nmp-&gt;nm_sent, nmp-&gt;nm_cwnd);
	nmp-&gt;nm_sent -= NFS_CWNDSCALE;
	<span class="enscript-keyword">if</span> ((nmp-&gt;nm_sent &lt; nmp-&gt;nm_cwnd) &amp;&amp; !TAILQ_EMPTY(&amp;nmp-&gt;nm_cwndq)) {
		<span class="enscript-comment">/* congestion window is open, poke the cwnd queue */</span>
		<span class="enscript-type">struct</span> nfsreq *req2 = TAILQ_FIRST(&amp;nmp-&gt;nm_cwndq);
		TAILQ_REMOVE(&amp;nmp-&gt;nm_cwndq, req2, r_cchain);
		req2-&gt;r_cchain.tqe_next = NFSREQNOLIST;
		wakeup(req2);
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
}

<span class="enscript-comment">/*
 * Ensure req isn't in use by the timer, then dequeue it.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_reqdequeue</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	lck_mtx_lock(nfs_request_mutex);
	<span class="enscript-keyword">while</span> (req-&gt;r_lflags &amp; RL_BUSY) {
		req-&gt;r_lflags |= RL_WAITING;
		msleep(&amp;req-&gt;r_lflags, nfs_request_mutex, PSOCK, <span class="enscript-string">&quot;reqdeq&quot;</span>, NULL);
	}
	<span class="enscript-keyword">if</span> (req-&gt;r_lflags &amp; RL_QUEUED) {
		TAILQ_REMOVE(&amp;nfs_reqq, req, r_chain);
		req-&gt;r_lflags &amp;= ~RL_QUEUED;
	}
	lck_mtx_unlock(nfs_request_mutex);
}

<span class="enscript-comment">/*
 * Busy (lock) a nfsreq, used by the nfs timer to make sure it's not
 * free()'d out from under it.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_reqbusy</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-keyword">if</span> (req-&gt;r_lflags &amp; RL_BUSY)
		panic(<span class="enscript-string">&quot;req locked&quot;</span>);
	req-&gt;r_lflags |= RL_BUSY;
}

<span class="enscript-comment">/*
 * Unbusy the nfsreq passed in, return the next nfsreq in the chain busied.
 */</span>
<span class="enscript-type">struct</span> nfsreq *
<span class="enscript-function-name">nfs_reqnext</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">struct</span> nfsreq * nextreq;

	<span class="enscript-keyword">if</span> (req == NULL)
		<span class="enscript-keyword">return</span> (NULL);
	<span class="enscript-comment">/*
	 * We need to get and busy the next req before signalling the
	 * current one, otherwise wakeup() may block us and we'll race to
	 * grab the next req.
	 */</span>
	nextreq = TAILQ_NEXT(req, r_chain);
	<span class="enscript-keyword">if</span> (nextreq != NULL)
		nfs_reqbusy(nextreq);
	<span class="enscript-comment">/* unbusy and signal. */</span>
	req-&gt;r_lflags &amp;= ~RL_BUSY;
	<span class="enscript-keyword">if</span> (req-&gt;r_lflags &amp; RL_WAITING) {
		req-&gt;r_lflags &amp;= ~RL_WAITING;
		wakeup(&amp;req-&gt;r_lflags);
	}
	<span class="enscript-keyword">return</span> (nextreq);
}

<span class="enscript-comment">/*
 * NFS request queue timer routine
 *
 * Scan the NFS request queue for any requests that have timed out.
 *
 * Alert the system of unresponsive servers.
 * Mark expired requests on soft mounts as terminated.
 * For UDP, mark/signal requests for retransmission.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_request_timer</span>(__unused <span class="enscript-type">void</span> *param0, __unused <span class="enscript-type">void</span> *param1)
{
	<span class="enscript-type">struct</span> nfsreq *req;
	<span class="enscript-type">struct</span> nfsmount *nmp;
	<span class="enscript-type">int</span> timeo, maxtime, finish_asyncio, error;
	<span class="enscript-type">struct</span> timeval now;
	TAILQ_HEAD(nfs_mount_pokeq, nfsmount) nfs_mount_poke_queue;

<span class="enscript-reference">restart</span>:
	lck_mtx_lock(nfs_request_mutex);
	req = TAILQ_FIRST(&amp;nfs_reqq);
	<span class="enscript-keyword">if</span> (req == NULL) {	<span class="enscript-comment">/* no requests - turn timer off */</span>
		nfs_request_timer_on = 0;
		lck_mtx_unlock(nfs_request_mutex);
		<span class="enscript-keyword">return</span>;
	}

	nfs_reqbusy(req);
	TAILQ_INIT(&amp;nfs_mount_poke_queue);

	microuptime(&amp;now);
	<span class="enscript-keyword">for</span> ( ; req != NULL ; req = nfs_reqnext(req)) {
		nmp = req-&gt;r_nmp;
		<span class="enscript-keyword">if</span> (nmp == NULL) {
			NFS_SOCK_DBG(<span class="enscript-string">&quot;Found a request with out a mount!\n&quot;</span>);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (req-&gt;r_error || req-&gt;r_nmrep.nmc_mhead)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(nmp, req, req-&gt;r_thread, 0))) {
			<span class="enscript-keyword">if</span> (req-&gt;r_callback.rcb_func != NULL) {
				<span class="enscript-comment">/* async I/O RPC needs to be finished */</span>
				lck_mtx_lock(&amp;req-&gt;r_mtx);
				req-&gt;r_error = error;
				finish_asyncio = !(req-&gt;r_flags &amp; R_WAITSENT);
				wakeup(req);
				lck_mtx_unlock(&amp;req-&gt;r_mtx);
				<span class="enscript-keyword">if</span> (finish_asyncio)
					nfs_asyncio_finish(req);
			}
			<span class="enscript-keyword">continue</span>;
		}

		lck_mtx_lock(&amp;req-&gt;r_mtx);

		<span class="enscript-keyword">if</span> (nmp-&gt;nm_tprintf_initial_delay &amp;&amp;
		    ((req-&gt;r_rexmit &gt; 2) || (req-&gt;r_flags &amp; R_RESENDERR)) &amp;&amp;
		    ((req-&gt;r_lastmsg + nmp-&gt;nm_tprintf_delay) &lt; now.tv_sec)) {
			req-&gt;r_lastmsg = now.tv_sec;
			nfs_down(req-&gt;r_nmp, req-&gt;r_thread, 0, NFSSTA_TIMEO,
				 <span class="enscript-string">&quot;not responding&quot;</span>, 1);
			req-&gt;r_flags |= R_TPRINTFMSG;
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_state &amp; NFSSTA_MOUNTED)) {
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
				<span class="enscript-comment">/* we're not yet completely mounted and */</span>
				<span class="enscript-comment">/* we can't complete an RPC, so we fail */</span>
				OSAddAtomic64(1, &amp;nfsstats.rpctimeouts);
				nfs_softterm(req);
				finish_asyncio = ((req-&gt;r_callback.rcb_func != NULL) &amp;&amp; !(req-&gt;r_flags &amp; R_WAITSENT));
				wakeup(req);
				lck_mtx_unlock(&amp;req-&gt;r_mtx);
				<span class="enscript-keyword">if</span> (finish_asyncio)
					nfs_asyncio_finish(req);
				<span class="enscript-keyword">continue</span>;
			}
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		}

		<span class="enscript-comment">/*
		 * Put a reasonable limit on the maximum timeout,
		 * and reduce that limit when soft mounts get timeouts or are in reconnect.
		 */</span>
		<span class="enscript-keyword">if</span> (!(NMFLAG(nmp, SOFT) || (req-&gt;r_flags &amp; R_SOFT)) &amp;&amp; !nfs_can_squish(nmp))
			maxtime = NFS_MAXTIMEO;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((req-&gt;r_flags &amp; (R_SETUP|R_RECOVER)) ||
			 ((nmp-&gt;nm_reconnect_start &lt;= 0) || ((now.tv_sec - nmp-&gt;nm_reconnect_start) &lt; 8)))
			maxtime = (NFS_MAXTIMEO / (nmp-&gt;nm_timeouts+1))/2;
		<span class="enscript-keyword">else</span>
			maxtime = NFS_MINTIMEO/4;

		<span class="enscript-comment">/*
		 * Check for request timeout.
		 */</span>
		<span class="enscript-keyword">if</span> (req-&gt;r_rtt &gt;= 0) {
			req-&gt;r_rtt++;
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_RESENDERR) {
				<span class="enscript-comment">/* with resend errors, retry every few seconds */</span>
				timeo = 4*hz;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (req-&gt;r_procnum == NFSPROC_NULL &amp;&amp; req-&gt;r_gss_ctx != NULL)
					timeo = NFS_MINIDEMTIMEO; <span class="enscript-comment">// gss context setup
</span>				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (NMFLAG(nmp, DUMBTIMER))
					timeo = nmp-&gt;nm_timeo;
				<span class="enscript-keyword">else</span>
					timeo = NFS_RTO(nmp, proct[req-&gt;r_procnum]);

				<span class="enscript-comment">/* ensure 62.5 ms floor */</span>
				<span class="enscript-keyword">while</span> (16 * timeo &lt; hz)
					timeo *= 2;
				<span class="enscript-keyword">if</span> (nmp-&gt;nm_timeouts &gt; 0)
					timeo *= nfs_backoff[nmp-&gt;nm_timeouts - 1];
			}
			<span class="enscript-comment">/* limit timeout to max */</span>
			<span class="enscript-keyword">if</span> (timeo &gt; maxtime)
				timeo = maxtime;
			<span class="enscript-keyword">if</span> (req-&gt;r_rtt &lt;= timeo) {
				NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs timeout: req time %d and timeo is %d continue\n&quot;</span>, req-&gt;r_rtt, timeo);
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
				lck_mtx_unlock(&amp;req-&gt;r_mtx);
				<span class="enscript-keyword">continue</span>;
			}
			<span class="enscript-comment">/* The request has timed out */</span>
			NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs timeout: proc %d %d xid %llx rtt %d to %d # %d, t %ld/%d\n&quot;</span>,
				req-&gt;r_procnum, proct[req-&gt;r_procnum],
				req-&gt;r_xid, req-&gt;r_rtt, timeo, nmp-&gt;nm_timeouts,
				(now.tv_sec - req-&gt;r_start)*NFS_HZ, maxtime);
			<span class="enscript-keyword">if</span> (nmp-&gt;nm_timeouts &lt; 8)
				nmp-&gt;nm_timeouts++;
			<span class="enscript-keyword">if</span> (nfs_mount_check_dead_timeout(nmp)) {
				<span class="enscript-comment">/* Unbusy this request */</span>
				req-&gt;r_lflags &amp;= ~RL_BUSY;
				<span class="enscript-keyword">if</span> (req-&gt;r_lflags &amp; RL_WAITING) {
					req-&gt;r_lflags &amp;= ~RL_WAITING;
					wakeup(&amp;req-&gt;r_lflags);
				}
				lck_mtx_unlock(&amp;req-&gt;r_mtx);

		 		<span class="enscript-comment">/* No need to poke this mount */</span>
				<span class="enscript-keyword">if</span> (nmp-&gt;nm_sockflags &amp; NMSOCK_POKE) {
					nmp-&gt;nm_sockflags &amp;= ~NMSOCK_POKE;
					TAILQ_REMOVE(&amp;nfs_mount_poke_queue, nmp, nm_pokeq);
				}
				<span class="enscript-comment">/* Release our lock state, so we can become a zombie */</span>
				lck_mtx_unlock(nfs_request_mutex);

				<span class="enscript-comment">/*
				 * Note nfs_mount_make zombie(nmp) must be
				 * called with nm_lock held. After doing some
				 * work we release nm_lock in
				 * nfs_make_mount_zombie with out acquiring any
				 * other locks. (Later, in nfs_mount_zombie we
				 * will acquire nfs_request_mutex, r_mtx,
				 * nm_lock in that order). So we should not be
				 * introducing deadlock here. We take a reference
				 * on the mount so that its still there when we
				 * release the lock.
				 */</span>
				nmp-&gt;nm_ref++;
				nfs_mount_make_zombie(nmp);
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
				nfs_mount_rele(nmp);

				<span class="enscript-comment">/*
				 * All the request for this mount have now been
				 * removed from the request queue. Restart to
				 * process the remaining mounts
				 */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
			}
			
			<span class="enscript-comment">/* if it's been a few seconds, try poking the socket */</span>
			<span class="enscript-keyword">if</span> ((nmp-&gt;nm_sotype == SOCK_STREAM) &amp;&amp;
			    ((now.tv_sec - req-&gt;r_start) &gt;= 3) &amp;&amp;
			    !(nmp-&gt;nm_sockflags &amp; (NMSOCK_POKE|NMSOCK_UNMOUNT)) &amp;&amp;
			    (nmp-&gt;nm_sockflags &amp; NMSOCK_READY)) {
				nmp-&gt;nm_sockflags |= NMSOCK_POKE;
				TAILQ_INSERT_TAIL(&amp;nfs_mount_poke_queue, nmp, nm_pokeq);
			}
			lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		}

		<span class="enscript-comment">/* For soft mounts (&amp; SETUPs/RECOVERs), check for too many retransmits/timeout. */</span>
		<span class="enscript-keyword">if</span> ((NMFLAG(nmp, SOFT) ||  (req-&gt;r_flags &amp; (R_SETUP|R_RECOVER|R_SOFT))) &amp;&amp;
		    ((req-&gt;r_rexmit &gt;= req-&gt;r_retry) || <span class="enscript-comment">/* too many */</span>
		     ((now.tv_sec - req-&gt;r_start)*NFS_HZ &gt; maxtime))) { <span class="enscript-comment">/* too long */</span>
			OSAddAtomic64(1, &amp;nfsstats.rpctimeouts);
			lck_mtx_lock(&amp;nmp-&gt;nm_lock);
			<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_state &amp; NFSSTA_TIMEO)) {
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
				<span class="enscript-comment">/* make sure we note the unresponsive server */</span>
				<span class="enscript-comment">/* (maxtime may be less than tprintf delay) */</span>
				nfs_down(req-&gt;r_nmp, req-&gt;r_thread, 0, NFSSTA_TIMEO,
					 <span class="enscript-string">&quot;not responding&quot;</span>, 1);
				req-&gt;r_lastmsg = now.tv_sec;
				req-&gt;r_flags |= R_TPRINTFMSG;
			} <span class="enscript-keyword">else</span> {
				lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
			}
			<span class="enscript-keyword">if</span> (req-&gt;r_flags &amp; R_NOINTR) {
				<span class="enscript-comment">/* don't terminate nointr requests on timeout */</span>
				lck_mtx_unlock(&amp;req-&gt;r_mtx);
				<span class="enscript-keyword">continue</span>;
			}
			NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs timer TERMINATE: p %d x 0x%llx f 0x%x rtt %d t %ld\n&quot;</span>,
				req-&gt;r_procnum, req-&gt;r_xid, req-&gt;r_flags, req-&gt;r_rtt,
				now.tv_sec - req-&gt;r_start);
			nfs_softterm(req);
			finish_asyncio = ((req-&gt;r_callback.rcb_func != NULL) &amp;&amp; !(req-&gt;r_flags &amp; R_WAITSENT));
			wakeup(req);
			lck_mtx_unlock(&amp;req-&gt;r_mtx);
			<span class="enscript-keyword">if</span> (finish_asyncio)
				nfs_asyncio_finish(req);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/* for TCP, only resend if explicitly requested */</span>
		<span class="enscript-keyword">if</span> ((nmp-&gt;nm_sotype == SOCK_STREAM) &amp;&amp; !(req-&gt;r_flags &amp; R_MUSTRESEND)) {
			<span class="enscript-keyword">if</span> (++req-&gt;r_rexmit &gt; NFS_MAXREXMIT)
				req-&gt;r_rexmit = NFS_MAXREXMIT;
			req-&gt;r_rtt = 0;
			lck_mtx_unlock(&amp;req-&gt;r_mtx);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * The request needs to be (re)sent.  Kick the requester to resend it.
		 * (unless it's already marked as needing a resend)
		 */</span>
		<span class="enscript-keyword">if</span> ((req-&gt;r_flags &amp; R_MUSTRESEND) &amp;&amp; (req-&gt;r_rtt == -1)) {
			lck_mtx_unlock(&amp;req-&gt;r_mtx);
			<span class="enscript-keyword">continue</span>;
		}
		NFS_SOCK_DBG(<span class="enscript-string">&quot;nfs timer mark resend: p %d x 0x%llx f 0x%x rtt %d\n&quot;</span>,
			req-&gt;r_procnum, req-&gt;r_xid, req-&gt;r_flags, req-&gt;r_rtt);
		req-&gt;r_flags |= R_MUSTRESEND;
		req-&gt;r_rtt = -1;
		wakeup(req);
		<span class="enscript-keyword">if</span> ((req-&gt;r_flags &amp; (R_IOD|R_ASYNC|R_ASYNCWAIT|R_SENDING)) == R_ASYNC)
			nfs_asyncio_resend(req);
		lck_mtx_unlock(&amp;req-&gt;r_mtx);
	}

	lck_mtx_unlock(nfs_request_mutex);

	<span class="enscript-comment">/* poke any sockets */</span>
	<span class="enscript-keyword">while</span> ((nmp = TAILQ_FIRST(&amp;nfs_mount_poke_queue))) {
		TAILQ_REMOVE(&amp;nfs_mount_poke_queue, nmp, nm_pokeq);
		nfs_sock_poke(nmp);
	}

	nfs_interval_timer_start(nfs_request_timer_call, NFS_REQUESTDELAY);
}

<span class="enscript-comment">/*
 * check a thread's proc for the &quot;noremotehang&quot; flag.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_noremotehang</span>(thread_t thd)
{
	proc_t p = thd ? get_bsdthreadtask_info(thd) : NULL;
	<span class="enscript-keyword">return</span> (p &amp;&amp; proc_noremotehang(p));
}

<span class="enscript-comment">/*
 * Test for a termination condition pending on the process.
 * This is used to determine if we need to bail on a mount.
 * ETIMEDOUT is returned if there has been a soft timeout.
 * EINTR is returned if there is a signal pending that is not being ignored
 * and the mount is interruptable, or if we are a thread that is in the process
 * of cancellation (also SIGKILL posted).
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> sigprop[NSIG+1];
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_sigintr</span>(<span class="enscript-type">struct</span> nfsmount *nmp, <span class="enscript-type">struct</span> nfsreq *req, thread_t thd, <span class="enscript-type">int</span> nmplocked)
{
	proc_t p;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (!nmp)
		<span class="enscript-keyword">return</span> (ENXIO);

	<span class="enscript-keyword">if</span> (req &amp;&amp; (req-&gt;r_flags &amp; R_SOFTTERM))
		<span class="enscript-keyword">return</span> (ETIMEDOUT); <span class="enscript-comment">/* request has been terminated. */</span>
	<span class="enscript-keyword">if</span> (req &amp;&amp; (req-&gt;r_flags &amp; R_NOINTR))
		thd = NULL; <span class="enscript-comment">/* don't check for signal on R_NOINTR */</span>

	<span class="enscript-keyword">if</span> (!nmplocked)
		lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; NFSSTA_FORCE) {
		<span class="enscript-comment">/* If a force unmount is in progress then fail. */</span>
		error = EIO;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (vfs_isforce(nmp-&gt;nm_mountp)) {
		<span class="enscript-comment">/* Someone is unmounting us, go soft and mark it. */</span>
		NFS_BITMAP_SET(nmp-&gt;nm_flags, NFS_MFLAG_SOFT);
		nmp-&gt;nm_state |= NFSSTA_FORCE;
	}

	<span class="enscript-comment">/* Check if the mount is marked dead. */</span>
	<span class="enscript-keyword">if</span> (!error &amp;&amp; (nmp-&gt;nm_state &amp; NFSSTA_DEAD))
		error = ENXIO;

	<span class="enscript-comment">/*
	 * If the mount is hung and we've requested not to hang
	 * on remote filesystems, then bail now.
	 */</span>
	<span class="enscript-keyword">if</span> (current_proc() != kernproc &amp;&amp;
	    !error &amp;&amp; (nmp-&gt;nm_state &amp; NFSSTA_TIMEO) &amp;&amp; nfs_noremotehang(thd))
		error = EIO;

	<span class="enscript-keyword">if</span> (!nmplocked)
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/* may not have a thread for async I/O */</span>
	<span class="enscript-keyword">if</span> (thd == NULL || current_proc() == kernproc)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/*
	 * Check if the process is aborted, but don't interrupt if we
	 * were killed by a signal and this is the exiting thread which
	 * is attempting to dump core.
	 */</span>
	<span class="enscript-keyword">if</span> (((p = current_proc()) != kernproc) &amp;&amp; current_thread_aborted() &amp;&amp;
	    (!(p-&gt;p_acflag &amp; AXSIG) || (p-&gt;exit_thread != current_thread()) ||
	     (p-&gt;p_sigacts == NULL) ||
	     (p-&gt;p_sigacts-&gt;ps_sig &lt; 1) || (p-&gt;p_sigacts-&gt;ps_sig &gt; NSIG) ||
	     !(sigprop[p-&gt;p_sigacts-&gt;ps_sig] &amp; SA_CORE)))
		<span class="enscript-keyword">return</span> (EINTR);

	<span class="enscript-comment">/* mask off thread and process blocked signals. */</span>
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, INTR) &amp;&amp; ((p = get_bsdthreadtask_info(thd))) &amp;&amp;
	    proc_pendingsignals(p, NFSINT_SIGMASK))
		<span class="enscript-keyword">return</span> (EINTR);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Lock a socket against others.
 * Necessary for STREAM sockets to ensure you get an entire rpc request/reply
 * and also to avoid race conditions between the processes with nfs requests
 * in progress when a reconnect is necessary.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_sndlock</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = req-&gt;r_nmp;
	<span class="enscript-type">int</span> *statep;
	<span class="enscript-type">int</span> error = 0, slpflag = 0;
	<span class="enscript-type">struct</span> timespec ts = { 0, 0 };

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span> (ENXIO);

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	statep = &amp;nmp-&gt;nm_state;

	<span class="enscript-keyword">if</span> (NMFLAG(nmp, INTR) &amp;&amp; req-&gt;r_thread &amp;&amp; !(req-&gt;r_flags &amp; R_NOINTR))
		slpflag = PCATCH;
	<span class="enscript-keyword">while</span> (*statep &amp; NFSSTA_SNDLOCK) {
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(nmp, req, req-&gt;r_thread, 1)))
			<span class="enscript-keyword">break</span>;
		*statep |= NFSSTA_WANTSND;
		<span class="enscript-keyword">if</span> (nfs_noremotehang(req-&gt;r_thread))
			ts.tv_sec = 1;
		msleep(statep, &amp;nmp-&gt;nm_lock, slpflag | (PZERO - 1), <span class="enscript-string">&quot;nfsndlck&quot;</span>, &amp;ts);
		<span class="enscript-keyword">if</span> (slpflag == PCATCH) {
			slpflag = 0;
			ts.tv_sec = 2;
		}
	}
	<span class="enscript-keyword">if</span> (!error)
		*statep |= NFSSTA_SNDLOCK;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Unlock the stream socket for others.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_sndunlock</span>(<span class="enscript-type">struct</span> nfsreq *req)
{
	<span class="enscript-type">struct</span> nfsmount *nmp = req-&gt;r_nmp;
	<span class="enscript-type">int</span> *statep, wake = 0;

	<span class="enscript-keyword">if</span> (!nmp)
		<span class="enscript-keyword">return</span>;
	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	statep = &amp;nmp-&gt;nm_state;
	<span class="enscript-keyword">if</span> ((*statep &amp; NFSSTA_SNDLOCK) == 0)
		panic(<span class="enscript-string">&quot;nfs sndunlock&quot;</span>);
	*statep &amp;= ~(NFSSTA_SNDLOCK|NFSSTA_SENDING);
	<span class="enscript-keyword">if</span> (*statep &amp; NFSSTA_WANTSND) {
		*statep &amp;= ~NFSSTA_WANTSND;
		wake = 1;
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (wake)
		wakeup(statep);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_aux_request</span>(
	<span class="enscript-type">struct</span> nfsmount *nmp,
	thread_t thd,
	<span class="enscript-type">struct</span> sockaddr *saddr,
	socket_t so,
	<span class="enscript-type">int</span> sotype,
	mbuf_t mreq,
	uint32_t xid,
	<span class="enscript-type">int</span> bindresv,
	<span class="enscript-type">int</span> timeo,
	<span class="enscript-type">struct</span> nfsm_chain *nmrep)
{
	<span class="enscript-type">int</span> error = 0, on = 1, try, sendat = 2, soproto, recv, optlen, restoreto = 0;
	socket_t newso = NULL;
	<span class="enscript-type">struct</span> sockaddr_storage ss;
	<span class="enscript-type">struct</span> timeval orig_rcvto, orig_sndto, tv = { 1, 0 };
	mbuf_t m, mrep = NULL;
	<span class="enscript-type">struct</span> msghdr msg;
	uint32_t rxid = 0, reply = 0, reply_status, rejected_status;
	uint32_t verf_type, verf_len, accepted_status;
	size_t readlen, sentlen;
	<span class="enscript-type">struct</span> nfs_rpc_record_state nrrs;

	<span class="enscript-keyword">if</span> (!so) {
		<span class="enscript-comment">/* create socket and set options */</span>
		soproto = (sotype == SOCK_DGRAM) ? IPPROTO_UDP : IPPROTO_TCP;
		<span class="enscript-keyword">if</span> ((error = sock_socket(saddr-&gt;sa_family, sotype, soproto, NULL, NULL, &amp;newso)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;

		<span class="enscript-keyword">if</span> (bindresv) {
			<span class="enscript-type">int</span> level = (saddr-&gt;sa_family == AF_INET) ? IPPROTO_IP : IPPROTO_IPV6;
			<span class="enscript-type">int</span> optname = (saddr-&gt;sa_family == AF_INET) ? IP_PORTRANGE : IPV6_PORTRANGE;
			<span class="enscript-type">int</span> portrange = IP_PORTRANGE_LOW;
			error = sock_setsockopt(newso, level, optname, &amp;portrange, <span class="enscript-keyword">sizeof</span>(portrange));
			nfsmout_if(error);
			ss.ss_len = saddr-&gt;sa_len;
			ss.ss_family = saddr-&gt;sa_family;
			<span class="enscript-keyword">if</span> (ss.ss_family == AF_INET) {
				((<span class="enscript-type">struct</span> sockaddr_in*)&amp;ss)-&gt;sin_addr.s_addr = INADDR_ANY;
				((<span class="enscript-type">struct</span> sockaddr_in*)&amp;ss)-&gt;sin_port = htons(0);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ss.ss_family == AF_INET6) {
				((<span class="enscript-type">struct</span> sockaddr_in6*)&amp;ss)-&gt;sin6_addr = in6addr_any;
				((<span class="enscript-type">struct</span> sockaddr_in6*)&amp;ss)-&gt;sin6_port = htons(0);
			} <span class="enscript-keyword">else</span> {
				error = EINVAL;
			}
			<span class="enscript-keyword">if</span> (!error)
				error = sock_bind(newso, (<span class="enscript-type">struct</span> sockaddr *)&amp;ss);
			nfsmout_if(error);
		}

		<span class="enscript-keyword">if</span> (sotype == SOCK_STREAM) {
#			<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_AUX_CONNECTION_TIMEOUT</span> 4   <span class="enscript-comment">/* 4 second timeout for connections */</span>
			<span class="enscript-type">int</span> count = 0;
			
			error = sock_connect(newso, saddr, MSG_DONTWAIT);
			<span class="enscript-keyword">if</span> (error == EINPROGRESS)
				error = 0;
			nfsmout_if(error);

			<span class="enscript-keyword">while</span> ((error = sock_connectwait(newso, &amp;tv)) == EINPROGRESS) {
				<span class="enscript-comment">/* After NFS_AUX_CONNECTION_TIMEOUT bail */</span>
				<span class="enscript-keyword">if</span> (++count &gt;= NFS_AUX_CONNECTION_TIMEOUT) {
					error = ETIMEDOUT;
					<span class="enscript-keyword">break</span>;
				}
			}
			nfsmout_if(error);
		}
		<span class="enscript-keyword">if</span> (((error = sock_setsockopt(newso, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, <span class="enscript-keyword">sizeof</span>(tv)))) ||
		    ((error = sock_setsockopt(newso, SOL_SOCKET, SO_SNDTIMEO, &amp;tv, <span class="enscript-keyword">sizeof</span>(tv)))) ||
		    ((error = sock_setsockopt(newso, SOL_SOCKET, SO_NOADDRERR, &amp;on, <span class="enscript-keyword">sizeof</span>(on)))))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		so = newso;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* make sure socket is using a one second timeout in this function */</span>
		optlen = <span class="enscript-keyword">sizeof</span>(orig_rcvto);
		error = sock_getsockopt(so, SOL_SOCKET, SO_RCVTIMEO, &amp;orig_rcvto, &amp;optlen);
		<span class="enscript-keyword">if</span> (!error) {
			optlen = <span class="enscript-keyword">sizeof</span>(orig_sndto);
			error = sock_getsockopt(so, SOL_SOCKET, SO_SNDTIMEO, &amp;orig_sndto, &amp;optlen);
		}
		<span class="enscript-keyword">if</span> (!error) {
			sock_setsockopt(so, SOL_SOCKET, SO_RCVTIMEO, &amp;tv, <span class="enscript-keyword">sizeof</span>(tv));
			sock_setsockopt(so, SOL_SOCKET, SO_SNDTIMEO, &amp;tv, <span class="enscript-keyword">sizeof</span>(tv));
			restoreto = 1;
		}
	}

	<span class="enscript-keyword">if</span> (sotype == SOCK_STREAM) {
		sendat = 0; <span class="enscript-comment">/* we only resend the request for UDP */</span>
		nfs_rpc_record_state_init(&amp;nrrs);
	}

	<span class="enscript-keyword">for</span> (try=0; try &lt; timeo; try++) {
		<span class="enscript-keyword">if</span> ((error = nfs_sigintr(nmp, NULL, !try ? NULL : thd, 0)))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (!try || (try == sendat)) {
			<span class="enscript-comment">/* send the request (resending periodically for UDP) */</span>
			<span class="enscript-keyword">if</span> ((error = mbuf_copym(mreq, 0, MBUF_COPYALL, MBUF_WAITOK, &amp;m)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			bzero(&amp;msg, <span class="enscript-keyword">sizeof</span>(msg));
			<span class="enscript-keyword">if</span> ((sotype == SOCK_DGRAM) &amp;&amp; !sock_isconnected(so)) {
				msg.msg_name = saddr;
				msg.msg_namelen = saddr-&gt;sa_len;
			}
			<span class="enscript-keyword">if</span> ((error = sock_sendmbuf(so, &amp;msg, m, 0, &amp;sentlen)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
			sendat *= 2;
			<span class="enscript-keyword">if</span> (sendat &gt; 30)
				sendat = 30;
		}
		<span class="enscript-comment">/* wait for the response */</span>
		<span class="enscript-keyword">if</span> (sotype == SOCK_STREAM) {
			<span class="enscript-comment">/* try to read (more of) record */</span>
			error = nfs_rpc_record_read(so, &amp;nrrs, 0, &amp;recv, &amp;mrep);
			<span class="enscript-comment">/* if we don't have the whole record yet, we'll keep trying */</span>
		} <span class="enscript-keyword">else</span> {
			readlen = 1&lt;&lt;18;
			bzero(&amp;msg, <span class="enscript-keyword">sizeof</span>(msg));
			error = sock_receivembuf(so, &amp;msg, &amp;mrep, 0, &amp;readlen);
		}
		<span class="enscript-keyword">if</span> (error == EWOULDBLOCK)
			<span class="enscript-keyword">continue</span>;
		nfsmout_if(error);
		<span class="enscript-comment">/* parse the response */</span>
		nfsm_chain_dissect_init(error, nmrep, mrep);
		nfsm_chain_get_32(error, nmrep, rxid);
		nfsm_chain_get_32(error, nmrep, reply);
		nfsmout_if(error);
		<span class="enscript-keyword">if</span> ((rxid != xid) || (reply != RPC_REPLY))
			error = EBADRPC;
		nfsm_chain_get_32(error, nmrep, reply_status);
		nfsmout_if(error);
		<span class="enscript-keyword">if</span> (reply_status == RPC_MSGDENIED) {
			nfsm_chain_get_32(error, nmrep, rejected_status);
			nfsmout_if(error);
			error = (rejected_status == RPC_MISMATCH) ? ERPCMISMATCH : EACCES;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;
		}
		nfsm_chain_get_32(error, nmrep, verf_type); <span class="enscript-comment">/* verifier flavor */</span>
		nfsm_chain_get_32(error, nmrep, verf_len); <span class="enscript-comment">/* verifier length */</span>
		nfsmout_if(error);
		<span class="enscript-keyword">if</span> (verf_len)
			nfsm_chain_adv(error, nmrep, nfsm_rndup(verf_len));
		nfsm_chain_get_32(error, nmrep, accepted_status);
		nfsmout_if(error);
		<span class="enscript-keyword">switch</span> (accepted_status) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_SUCCESS</span>:
			error = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_PROGUNAVAIL</span>:
			error = EPROGUNAVAIL;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_PROGMISMATCH</span>:
			error = EPROGMISMATCH;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_PROCUNAVAIL</span>:
			error = EPROCUNAVAIL;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_GARBAGE</span>:
			error = EBADRPC;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">RPC_SYSTEM_ERR</span>:
		<span class="enscript-reference">default</span>:
			error = EIO;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (restoreto) {
		sock_setsockopt(so, SOL_SOCKET, SO_RCVTIMEO, &amp;orig_rcvto, <span class="enscript-keyword">sizeof</span>(tv));
		sock_setsockopt(so, SOL_SOCKET, SO_SNDTIMEO, &amp;orig_sndto, <span class="enscript-keyword">sizeof</span>(tv));
	}
	<span class="enscript-keyword">if</span> (newso) {
		sock_shutdown(newso, SHUT_RDWR);
		sock_close(newso);
	}
	mbuf_freem(mreq);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_portmap_lookup</span>(
	<span class="enscript-type">struct</span> nfsmount *nmp,
	vfs_context_t ctx,
	<span class="enscript-type">struct</span> sockaddr *sa,
	socket_t so,
	uint32_t protocol,
	uint32_t vers,
	uint32_t ipproto,
	<span class="enscript-type">int</span> timeo)
{
	thread_t thd = vfs_context_thread(ctx);
	kauth_cred_t cred = vfs_context_ucred(ctx);
	<span class="enscript-type">struct</span> sockaddr_storage ss;
	<span class="enscript-type">struct</span> sockaddr *saddr = (<span class="enscript-type">struct</span> sockaddr*)&amp;ss;
	<span class="enscript-type">struct</span> nfsm_chain nmreq, nmrep;
	mbuf_t mreq;
	<span class="enscript-type">int</span> error = 0, ip, pmprog, pmvers, pmproc, ualen = 0;
	uint32_t port;
	uint64_t xid = 0;
	<span class="enscript-type">char</span> uaddr[MAX_IPv6_STR_LEN+16];

	bcopy(sa, saddr, min(<span class="enscript-keyword">sizeof</span>(ss), sa-&gt;sa_len));
	<span class="enscript-keyword">if</span> (saddr-&gt;sa_family == AF_INET) {
		ip = 4;
		pmprog = PMAPPROG;
		pmvers = PMAPVERS;
		pmproc = PMAPPROC_GETPORT;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (saddr-&gt;sa_family == AF_INET6) {
		ip = 6;
		pmprog = RPCBPROG;
		pmvers = RPCBVERS4;
		pmproc = RPCBPROC_GETVERSADDR;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	nfsm_chain_null(&amp;nmreq);
	nfsm_chain_null(&amp;nmrep);

<span class="enscript-reference">tryagain</span>:
	<span class="enscript-comment">/* send portmapper request to get port/uaddr */</span>
	<span class="enscript-keyword">if</span> (ip == 4)
		((<span class="enscript-type">struct</span> sockaddr_in*)saddr)-&gt;sin_port = htons(PMAPPORT);
	<span class="enscript-keyword">else</span>
		((<span class="enscript-type">struct</span> sockaddr_in6*)saddr)-&gt;sin6_port = htons(PMAPPORT);
	nfsm_chain_build_alloc_init(error, &amp;nmreq, 8*NFSX_UNSIGNED);
	nfsm_chain_add_32(error, &amp;nmreq, protocol);
	nfsm_chain_add_32(error, &amp;nmreq, vers);
	<span class="enscript-keyword">if</span> (ip == 4) {
		nfsm_chain_add_32(error, &amp;nmreq, ipproto);
		nfsm_chain_add_32(error, &amp;nmreq, 0);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (ipproto == IPPROTO_TCP)
			nfsm_chain_add_string(error, &amp;nmreq, <span class="enscript-string">&quot;tcp6&quot;</span>, 4);
		<span class="enscript-keyword">else</span>
			nfsm_chain_add_string(error, &amp;nmreq, <span class="enscript-string">&quot;udp6&quot;</span>, 4);
		nfsm_chain_add_string(error, &amp;nmreq, <span class="enscript-string">&quot;&quot;</span>, 0); <span class="enscript-comment">/* uaddr */</span>
		nfsm_chain_add_string(error, &amp;nmreq, <span class="enscript-string">&quot;&quot;</span>, 0); <span class="enscript-comment">/* owner */</span>
	}
	nfsm_chain_build_done(error, &amp;nmreq);
	nfsmout_if(error);
	error = nfsm_rpchead2(nmp, (ipproto == IPPROTO_UDP) ? SOCK_DGRAM : SOCK_STREAM,
			pmprog, pmvers, pmproc, RPCAUTH_SYS, cred, NULL, nmreq.nmc_mhead,
			&amp;xid, &amp;mreq);
	nfsmout_if(error);
	nmreq.nmc_mhead = NULL;
	error = nfs_aux_request(nmp, thd, saddr, so, (ipproto == IPPROTO_UDP) ? SOCK_DGRAM : SOCK_STREAM,
			mreq, R_XID32(xid), 0, timeo, &amp;nmrep);

	<span class="enscript-comment">/* grab port from portmap response */</span>
	<span class="enscript-keyword">if</span> (ip == 4) {
		nfsm_chain_get_32(error, &amp;nmrep, port);
		<span class="enscript-keyword">if</span> (!error)
			((<span class="enscript-type">struct</span> sockaddr_in*)sa)-&gt;sin_port = htons(port);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* get uaddr string and convert to sockaddr */</span>
		nfsm_chain_get_32(error, &amp;nmrep, ualen);
		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-keyword">if</span> (ualen &gt; ((<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(uaddr)-1))
				error = EIO;
			<span class="enscript-keyword">if</span> (ualen &lt; 1) {
				<span class="enscript-comment">/* program is not available, just return a zero port */</span>
				bcopy(sa, saddr, min(<span class="enscript-keyword">sizeof</span>(ss), sa-&gt;sa_len));
				((<span class="enscript-type">struct</span> sockaddr_in6*)saddr)-&gt;sin6_port = htons(0);
			} <span class="enscript-keyword">else</span> {
				nfsm_chain_get_opaque(error, &amp;nmrep, ualen, uaddr);
				<span class="enscript-keyword">if</span> (!error) {
					uaddr[ualen] = <span class="enscript-string">'\0'</span>;
					<span class="enscript-keyword">if</span> (!nfs_uaddr2sockaddr(uaddr, saddr))
						error = EIO;
				}
			}
		}
		<span class="enscript-keyword">if</span> ((error == EPROGMISMATCH) || (error == EPROCUNAVAIL) || (error == EIO) || (error == EBADRPC)) {
			<span class="enscript-comment">/* remote doesn't support rpcbind version or proc (or we couldn't parse uaddr) */</span>
			<span class="enscript-keyword">if</span> (pmvers == RPCBVERS4) {
				<span class="enscript-comment">/* fall back to v3 and GETADDR */</span>
				pmvers = RPCBVERS3;
				pmproc = RPCBPROC_GETADDR;
				nfsm_chain_cleanup(&amp;nmreq);
				nfsm_chain_cleanup(&amp;nmrep);
				bcopy(sa, saddr, min(<span class="enscript-keyword">sizeof</span>(ss), sa-&gt;sa_len));
				xid = 0;
				error = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">tryagain</span>;
			}
		}
		<span class="enscript-keyword">if</span> (!error)
			bcopy(saddr, sa, min(saddr-&gt;sa_len, sa-&gt;sa_len));
	}
<span class="enscript-reference">nfsmout</span>:
	nfsm_chain_cleanup(&amp;nmreq);
	nfsm_chain_cleanup(&amp;nmrep);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_msg</span>(thread_t thd,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *server,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg,
	<span class="enscript-type">int</span> error)
{
	proc_t p = thd ? get_bsdthreadtask_info(thd) : NULL;
	tpr_t tpr;

	<span class="enscript-keyword">if</span> (p)
		tpr = tprintf_open(p);
	<span class="enscript-keyword">else</span>
		tpr = NULL;
	<span class="enscript-keyword">if</span> (error)
		tprintf(tpr, <span class="enscript-string">&quot;nfs server %s: %s, error %d\n&quot;</span>, server, msg, error);
	<span class="enscript-keyword">else</span>
		tprintf(tpr, <span class="enscript-string">&quot;nfs server %s: %s\n&quot;</span>, server, msg);
	tprintf_close(tpr);
	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_SQUISH_MOBILE_ONLY</span>		0x0001		<span class="enscript-comment">/* Squish mounts only on mobile machines */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_SQUISH_AUTOMOUNTED_ONLY</span>	0x0002		<span class="enscript-comment">/* Squish mounts only if the are automounted */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_SQUISH_SOFT</span>			0x0004		<span class="enscript-comment">/* Treat all soft mounts as though they were on a mobile machine */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_SQUISH_QUICK</span>		0x0008		<span class="enscript-comment">/* Try to squish mounts more quickly. */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_SQUISH_SHUTDOWN</span>		0x1000		<span class="enscript-comment">/* Squish all mounts on shutdown. Currently not implemented */</span>

uint32_t nfs_squishy_flags = NFS_SQUISH_MOBILE_ONLY | NFS_SQUISH_AUTOMOUNTED_ONLY | NFS_SQUISH_QUICK;
int32_t nfs_is_mobile;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NFS_SQUISHY_DEADTIMEOUT</span>		8	<span class="enscript-comment">/* Dead time out for squishy mounts */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NFS_SQUISHY_QUICKTIMEOUT</span>	4	<span class="enscript-comment">/* Quicker dead time out when nfs_squish_flags NFS_SQUISH_QUICK bit is set*/</span>

<span class="enscript-comment">/*
 * Could this mount be squished?
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_can_squish</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	uint64_t flags = vfs_flags(nmp-&gt;nm_mountp);
	<span class="enscript-type">int</span> softsquish = ((nfs_squishy_flags &amp; NFS_SQUISH_SOFT) &amp; NMFLAG(nmp, SOFT));

	<span class="enscript-keyword">if</span> (!softsquish &amp;&amp; (nfs_squishy_flags &amp; NFS_SQUISH_MOBILE_ONLY) &amp;&amp; nfs_is_mobile == 0)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">if</span> ((nfs_squishy_flags &amp; NFS_SQUISH_AUTOMOUNTED_ONLY) &amp;&amp; (flags &amp; MNT_AUTOMOUNTED) == 0)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * NFS mounts default to &quot;rw,hard&quot; - but frequently on mobile clients
 * the mount may become &quot;not responding&quot;.  It's desirable to be able
 * to unmount these dead mounts, but only if there is no risk of
 * losing data or crashing applications.  A &quot;squishy&quot; NFS mount is one
 * that can be force unmounted with little risk of harm.
 *
 * nfs_is_squishy checks if a mount is in a squishy state.  A mount is
 * in a squishy state iff it is allowed to be squishy and there are no
 * dirty pages and there are no mmapped files and there are no files
 * open for write. Mounts are allowed to be squishy is controlled by
 * the settings of the nfs_squishy_flags and its mobility state. These
 * flags can be set by sysctls.
 *
 * If nfs_is_squishy determines that we are in a squishy state we will
 * update the current dead timeout to at least NFS_SQUISHY_DEADTIMEOUT
 * (or NFS_SQUISHY_QUICKTIMEOUT if NFS_SQUISH_QUICK is set) (see
 * above) or 1/8th of the mount's nm_deadtimeout value, otherwise we just
 * update the current dead timeout with the mount's nm_deadtimeout
 * value set at mount time.
 *
 * Assumes that nm_lock is held.
 *
 * Note this routine is racey, but its effects on setting the
 * dead timeout only have effects when we're in trouble and are likely
 * to stay that way. Since by default its only for automounted
 * volumes on mobile machines; this is a reasonable trade off between
 * data integrity and user experience. It can be disabled or set via
 * nfs.conf file.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_is_squishy</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	mount_t mp = nmp-&gt;nm_mountp;
	<span class="enscript-type">int</span> squishy = 0;
	<span class="enscript-type">int</span> timeo = (nfs_squishy_flags &amp; NFS_SQUISH_QUICK) ? NFS_SQUISHY_QUICKTIMEOUT : NFS_SQUISHY_DEADTIMEOUT;

	NFS_SOCK_DBG(<span class="enscript-string">&quot;%s: nm_curdeadtimeout = %d, nfs_is_mobile = %d\n&quot;</span>,
		      vfs_statfs(mp)-&gt;f_mntfromname, nmp-&gt;nm_curdeadtimeout,  nfs_is_mobile);

	<span class="enscript-keyword">if</span> (!nfs_can_squish(nmp))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	timeo =  (nmp-&gt;nm_deadtimeout &gt; timeo) ? max(nmp-&gt;nm_deadtimeout/8, timeo) : timeo;
	NFS_SOCK_DBG(<span class="enscript-string">&quot;nm_writers = %d  nm_mappers = %d timeo = %d\n&quot;</span>, nmp-&gt;nm_writers, nmp-&gt;nm_mappers, timeo);

	<span class="enscript-keyword">if</span> (nmp-&gt;nm_writers == 0 &amp;&amp; nmp-&gt;nm_mappers == 0) {
		uint64_t flags = mp ? vfs_flags(mp) : 0;
		squishy = 1;
		
		<span class="enscript-comment">/* 
		 * Walk the nfs nodes and check for dirty buffers it we're not 
		 * RDONLY and we've not already been declared as squishy since
		 * this can be a bit expensive.
		 */</span>
		<span class="enscript-keyword">if</span> (!(flags &amp; MNT_RDONLY) &amp;&amp; !(nmp-&gt;nm_state &amp; NFSSTA_SQUISHY)) 
			squishy = !nfs_mount_is_dirty(mp);
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (squishy)
		nmp-&gt;nm_state |= NFSSTA_SQUISHY;
	<span class="enscript-keyword">else</span>
		nmp-&gt;nm_state &amp;= ~NFSSTA_SQUISHY;

	nmp-&gt;nm_curdeadtimeout = squishy ? timeo : nmp-&gt;nm_deadtimeout;
			
	NFS_SOCK_DBG(<span class="enscript-string">&quot;nm_curdeadtimeout = %d\n&quot;</span>, nmp-&gt;nm_curdeadtimeout);

	<span class="enscript-keyword">return</span> (squishy);
}

<span class="enscript-comment">/*
 * On a send operation, if we can't reach the server and we've got only one server to talk to
 * and NFS_SQUISH_QUICK flag is set and we are in a squishy state then mark the mount as dead
 * and ask to be forcibly unmounted. Return 1 if we're dead and 0 otherwise.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_is_dead</span>(<span class="enscript-type">int</span> error, <span class="enscript-type">struct</span> nfsmount *nmp)
{
	fsid_t fsid;

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">if</span> (nmp-&gt;nm_state &amp; NFSSTA_DEAD) {
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">return</span> (1);
	}

	<span class="enscript-keyword">if</span> ((error != ENETUNREACH &amp;&amp; error != EHOSTUNREACH &amp;&amp; error != EADDRNOTAVAIL) ||
	    !(nmp-&gt;nm_locations.nl_numlocs == 1 &amp;&amp; nmp-&gt;nm_locations.nl_locations[0]-&gt;nl_servcount == 1)) {
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> ((nfs_squishy_flags &amp; NFS_SQUISH_QUICK) &amp;&amp; nfs_is_squishy(nmp)) {
		printf(<span class="enscript-string">&quot;nfs_is_dead: nfs server %s: unreachable. Squished dead\n&quot;</span>, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname);
		fsid = vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_fsid;
		lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
		nfs_mount_zombie(nmp, NFSSTA_DEAD);
		vfs_event_signal(&amp;fsid, VQ_DEAD, 0);
		<span class="enscript-keyword">return</span> (1);
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * If we've experienced timeouts and we're not really a
 * classic hard mount, then just return cached data to
 * the caller instead of likely hanging on an RPC.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfs_use_cache</span>(<span class="enscript-type">struct</span> nfsmount *nmp)
{
	<span class="enscript-comment">/*
	 *%%% We always let mobile users goto the cache,
	 * perhaps we should not even require them to have
	 * a timeout?
	 */</span>
	<span class="enscript-type">int</span> cache_ok = (nfs_is_mobile || NMFLAG(nmp, SOFT) ||
			nfs_can_squish(nmp) || nmp-&gt;nm_deadtimeout);

	<span class="enscript-type">int</span> timeoutmask = NFSSTA_TIMEO | NFSSTA_LOCKTIMEO | NFSSTA_JUKEBOXTIMEO;

	<span class="enscript-comment">/*
	 * So if we have a timeout and we're not really a hard hard-mount,
	 * return 1 to not get things out of the cache.
	 */</span>

	<span class="enscript-keyword">return</span> ((nmp-&gt;nm_state &amp; timeoutmask) &amp;&amp; cache_ok);
}

<span class="enscript-comment">/*
 * Log a message that nfs or lockd server is unresponsive. Check if we
 * can be squished and if we can, or that our dead timeout has
 * expired, and we're not holding state, set our mount as dead, remove
 * our mount state and ask to be unmounted. If we are holding state
 * we're being called from the nfs_request_timer and will soon detect
 * that we need to unmount.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_down</span>(<span class="enscript-type">struct</span> nfsmount *nmp, thread_t thd, <span class="enscript-type">int</span> error, <span class="enscript-type">int</span> flags, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg, <span class="enscript-type">int</span> holding_state)
{
	<span class="enscript-type">int</span> timeoutmask, wasunresponsive, unresponsive, softnobrowse;
	uint32_t do_vfs_signal = 0;
	<span class="enscript-type">struct</span> timeval now;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span>;

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);

	timeoutmask = NFSSTA_TIMEO | NFSSTA_LOCKTIMEO | NFSSTA_JUKEBOXTIMEO;
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, MUTEJUKEBOX)) <span class="enscript-comment">/* jukebox timeouts don't count as unresponsive if muted */</span>
		   timeoutmask &amp;= ~NFSSTA_JUKEBOXTIMEO;
	wasunresponsive = (nmp-&gt;nm_state &amp; timeoutmask);

	<span class="enscript-comment">/* XXX don't allow users to know about/disconnect unresponsive, soft, nobrowse mounts */</span>
	softnobrowse = (NMFLAG(nmp, SOFT) &amp;&amp; (vfs_flags(nmp-&gt;nm_mountp) &amp; MNT_DONTBROWSE));

	<span class="enscript-keyword">if</span> ((flags &amp; NFSSTA_TIMEO) &amp;&amp; !(nmp-&gt;nm_state &amp; NFSSTA_TIMEO))
		nmp-&gt;nm_state |= NFSSTA_TIMEO;
	<span class="enscript-keyword">if</span> ((flags &amp; NFSSTA_LOCKTIMEO) &amp;&amp; !(nmp-&gt;nm_state &amp; NFSSTA_LOCKTIMEO))
		nmp-&gt;nm_state |= NFSSTA_LOCKTIMEO;
	<span class="enscript-keyword">if</span> ((flags &amp; NFSSTA_JUKEBOXTIMEO) &amp;&amp; !(nmp-&gt;nm_state &amp; NFSSTA_JUKEBOXTIMEO))
		nmp-&gt;nm_state |= NFSSTA_JUKEBOXTIMEO;

	unresponsive = (nmp-&gt;nm_state &amp; timeoutmask);

	nfs_is_squishy(nmp);

	<span class="enscript-keyword">if</span> (unresponsive &amp;&amp; (nmp-&gt;nm_curdeadtimeout &gt; 0)) {
		microuptime(&amp;now);
		<span class="enscript-keyword">if</span> (!wasunresponsive) {
			nmp-&gt;nm_deadto_start = now.tv_sec;
			nfs_mount_sock_thread_wake(nmp);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((now.tv_sec - nmp-&gt;nm_deadto_start) &gt; nmp-&gt;nm_curdeadtimeout &amp;&amp; !holding_state) {
			<span class="enscript-keyword">if</span> (!(nmp-&gt;nm_state &amp; NFSSTA_DEAD))
				printf(<span class="enscript-string">&quot;nfs server %s: %sdead\n&quot;</span>, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname,
				       (nmp-&gt;nm_curdeadtimeout != nmp-&gt;nm_deadtimeout) ? <span class="enscript-string">&quot;squished &quot;</span> : <span class="enscript-string">&quot;&quot;</span>);
			do_vfs_signal = VQ_DEAD;
		}
	}
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-keyword">if</span> (do_vfs_signal == VQ_DEAD &amp;&amp; !(nmp-&gt;nm_state &amp; NFSSTA_DEAD))
		nfs_mount_zombie(nmp, NFSSTA_DEAD);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (softnobrowse || wasunresponsive || !unresponsive)
		do_vfs_signal = 0;
	<span class="enscript-keyword">else</span>
		do_vfs_signal = VQ_NOTRESP;
	<span class="enscript-keyword">if</span> (do_vfs_signal)
		vfs_event_signal(&amp;vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_fsid, do_vfs_signal, 0);

	nfs_msg(thd, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, msg, error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nfs_up</span>(<span class="enscript-type">struct</span> nfsmount *nmp, thread_t thd, <span class="enscript-type">int</span> flags, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *msg)
{
	<span class="enscript-type">int</span> timeoutmask, wasunresponsive, unresponsive, softnobrowse;
	<span class="enscript-type">int</span> do_vfs_signal;

	<span class="enscript-keyword">if</span> (nfs_mount_gone(nmp))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (msg)
		nfs_msg(thd, vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_mntfromname, msg, 0);

	lck_mtx_lock(&amp;nmp-&gt;nm_lock);

	timeoutmask = NFSSTA_TIMEO | NFSSTA_LOCKTIMEO | NFSSTA_JUKEBOXTIMEO;
	<span class="enscript-keyword">if</span> (NMFLAG(nmp, MUTEJUKEBOX)) <span class="enscript-comment">/* jukebox timeouts don't count as unresponsive if muted */</span>
		   timeoutmask &amp;= ~NFSSTA_JUKEBOXTIMEO;
	wasunresponsive = (nmp-&gt;nm_state &amp; timeoutmask);

	<span class="enscript-comment">/* XXX don't allow users to know about/disconnect unresponsive, soft, nobrowse mounts */</span>
	softnobrowse = (NMFLAG(nmp, SOFT) &amp;&amp; (vfs_flags(nmp-&gt;nm_mountp) &amp; MNT_DONTBROWSE));

	<span class="enscript-keyword">if</span> ((flags &amp; NFSSTA_TIMEO) &amp;&amp; (nmp-&gt;nm_state &amp; NFSSTA_TIMEO))
		nmp-&gt;nm_state &amp;= ~NFSSTA_TIMEO;
	<span class="enscript-keyword">if</span> ((flags &amp; NFSSTA_LOCKTIMEO) &amp;&amp; (nmp-&gt;nm_state &amp; NFSSTA_LOCKTIMEO))
		nmp-&gt;nm_state &amp;= ~NFSSTA_LOCKTIMEO;
	<span class="enscript-keyword">if</span> ((flags &amp; NFSSTA_JUKEBOXTIMEO) &amp;&amp; (nmp-&gt;nm_state &amp; NFSSTA_JUKEBOXTIMEO))
		nmp-&gt;nm_state &amp;= ~NFSSTA_JUKEBOXTIMEO;

	unresponsive = (nmp-&gt;nm_state &amp; timeoutmask);

	nmp-&gt;nm_deadto_start = 0;
	nmp-&gt;nm_curdeadtimeout = nmp-&gt;nm_deadtimeout;
	nmp-&gt;nm_state &amp;= ~NFSSTA_SQUISHY;
	lck_mtx_unlock(&amp;nmp-&gt;nm_lock);

	<span class="enscript-keyword">if</span> (softnobrowse)
		do_vfs_signal = 0;
	<span class="enscript-keyword">else</span>
		do_vfs_signal = (wasunresponsive &amp;&amp; !unresponsive);
	<span class="enscript-keyword">if</span> (do_vfs_signal)
		vfs_event_signal(&amp;vfs_statfs(nmp-&gt;nm_mountp)-&gt;f_fsid, VQ_NOTRESP, 1);
}


#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSCLIENT */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSSERVER</span>

<span class="enscript-comment">/*
 * Generate the rpc reply header
 * siz arg. is used to decide if adding a cluster is worthwhile
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_rephead</span>(
	<span class="enscript-type">struct</span> nfsrv_descript *nd,
	__unused <span class="enscript-type">struct</span> nfsrv_sock *slp,
	<span class="enscript-type">struct</span> nfsm_chain *nmrepp,
	size_t siz)
{
	mbuf_t mrep;
	u_int32_t *tl;
	<span class="enscript-type">struct</span> nfsm_chain nmrep;
	<span class="enscript-type">int</span> err, error;

	err = nd-&gt;nd_repstat;
	<span class="enscript-keyword">if</span> (err &amp;&amp; (nd-&gt;nd_vers == NFS_VER2))
		siz = 0;

	<span class="enscript-comment">/*
	 * If this is a big reply, use a cluster else
	 * try and leave leading space for the lower level headers.
	 */</span>
	siz += RPC_REPLYSIZ;
	<span class="enscript-keyword">if</span> (siz &gt;= nfs_mbuf_minclsize) {
		error = mbuf_getpacket(MBUF_WAITOK, &amp;mrep);
	} <span class="enscript-keyword">else</span> {
		error = mbuf_gethdr(MBUF_WAITOK, MBUF_TYPE_DATA, &amp;mrep);
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/* unable to allocate packet */</span>
		<span class="enscript-comment">/* XXX should we keep statistics for these errors? */</span>
		<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (siz &lt; nfs_mbuf_minclsize) {
		<span class="enscript-comment">/* leave space for lower level headers */</span>
		tl = mbuf_data(mrep);
		tl += 80/<span class="enscript-keyword">sizeof</span>(*tl);  <span class="enscript-comment">/* XXX max_hdr? XXX */</span>
		mbuf_setdata(mrep, tl, 6 * NFSX_UNSIGNED);
	}
	nfsm_chain_init(&amp;nmrep, mrep);
	nfsm_chain_add_32(error, &amp;nmrep, nd-&gt;nd_retxid);
	nfsm_chain_add_32(error, &amp;nmrep, RPC_REPLY);
	<span class="enscript-keyword">if</span> (err == ERPCMISMATCH || (err &amp; NFSERR_AUTHERR)) {
		nfsm_chain_add_32(error, &amp;nmrep, RPC_MSGDENIED);
		<span class="enscript-keyword">if</span> (err &amp; NFSERR_AUTHERR) {
			nfsm_chain_add_32(error, &amp;nmrep, RPC_AUTHERR);
			nfsm_chain_add_32(error, &amp;nmrep, (err &amp; ~NFSERR_AUTHERR));
		} <span class="enscript-keyword">else</span> {
			nfsm_chain_add_32(error, &amp;nmrep, RPC_MISMATCH);
			nfsm_chain_add_32(error, &amp;nmrep, RPC_VER2);
			nfsm_chain_add_32(error, &amp;nmrep, RPC_VER2);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* reply status */</span>
		nfsm_chain_add_32(error, &amp;nmrep, RPC_MSGACCEPTED);
		<span class="enscript-keyword">if</span> (nd-&gt;nd_gss_context != NULL) {
			<span class="enscript-comment">/* RPCSEC_GSS verifier */</span>
			error = nfs_gss_svc_verf_put(nd, &amp;nmrep);
			<span class="enscript-keyword">if</span> (error) {
				nfsm_chain_add_32(error, &amp;nmrep, RPC_SYSTEM_ERR);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* RPCAUTH_NULL verifier */</span>
			nfsm_chain_add_32(error, &amp;nmrep, RPCAUTH_NULL);
			nfsm_chain_add_32(error, &amp;nmrep, 0);
		}
		<span class="enscript-comment">/* accepted status */</span>
		<span class="enscript-keyword">switch</span> (err) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EPROGUNAVAIL</span>:
			nfsm_chain_add_32(error, &amp;nmrep, RPC_PROGUNAVAIL);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EPROGMISMATCH</span>:
			nfsm_chain_add_32(error, &amp;nmrep, RPC_PROGMISMATCH);
			<span class="enscript-comment">/* XXX hard coded versions? */</span>
			nfsm_chain_add_32(error, &amp;nmrep, NFS_VER2);
			nfsm_chain_add_32(error, &amp;nmrep, NFS_VER3);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EPROCUNAVAIL</span>:
			nfsm_chain_add_32(error, &amp;nmrep, RPC_PROCUNAVAIL);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EBADRPC</span>:
			nfsm_chain_add_32(error, &amp;nmrep, RPC_GARBAGE);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			nfsm_chain_add_32(error, &amp;nmrep, RPC_SUCCESS);
			<span class="enscript-keyword">if</span> (nd-&gt;nd_gss_context != NULL)
				error = nfs_gss_svc_prepare_reply(nd, &amp;nmrep);
			<span class="enscript-keyword">if</span> (err != NFSERR_RETVOID)
				nfsm_chain_add_32(error, &amp;nmrep,
					(err ? nfsrv_errmap(nd, err) : 0));
			<span class="enscript-keyword">break</span>;
		}
	}

<span class="enscript-reference">done</span>:
	nfsm_chain_build_done(error, &amp;nmrep);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/* error composing reply header */</span>
		<span class="enscript-comment">/* XXX should we keep statistics for these errors? */</span>
		mbuf_freem(mrep);
		<span class="enscript-keyword">return</span> (error);
	}

	*nmrepp = nmrep;
	<span class="enscript-keyword">if</span> ((err != 0) &amp;&amp; (err != NFSERR_RETVOID))
		OSAddAtomic64(1, &amp;nfsstats.srvrpc_errs);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * The nfs server send routine.
 *
 * - return EINTR or ERESTART if interrupted by a signal
 * - return EPIPE if a connection is lost for connection based sockets (TCP...)
 * - do any cleanup required by recoverable socket errors (???)
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_send</span>(<span class="enscript-type">struct</span> nfsrv_sock *slp, mbuf_t nam, mbuf_t top)
{
	<span class="enscript-type">int</span> error;
	socket_t so = slp-&gt;ns_so;
	<span class="enscript-type">struct</span> sockaddr *sendnam;
	<span class="enscript-type">struct</span> msghdr msg;

	bzero(&amp;msg, <span class="enscript-keyword">sizeof</span>(msg));
	<span class="enscript-keyword">if</span> (nam &amp;&amp; !sock_isconnected(so) &amp;&amp; (slp-&gt;ns_sotype != SOCK_STREAM)) {
		<span class="enscript-keyword">if</span> ((sendnam = mbuf_data(nam))) {
			msg.msg_name = (caddr_t)sendnam;
			msg.msg_namelen = sendnam-&gt;sa_len;
		}
	}
	error = sock_sendmbuf(so, &amp;msg, top, 0, NULL);
	<span class="enscript-keyword">if</span> (!error)
		<span class="enscript-keyword">return</span> (0);
	log(LOG_INFO, <span class="enscript-string">&quot;nfsd send error %d\n&quot;</span>, error);

	<span class="enscript-keyword">if</span> ((error == EWOULDBLOCK) &amp;&amp; (slp-&gt;ns_sotype == SOCK_STREAM))
		error = EPIPE;  <span class="enscript-comment">/* zap TCP sockets if they time out on send */</span>

	<span class="enscript-comment">/* Handle any recoverable (soft) socket errors here. (???) */</span>
	<span class="enscript-keyword">if</span> (error != EINTR &amp;&amp; error != ERESTART &amp;&amp; error != EIO &amp;&amp;
		error != EWOULDBLOCK &amp;&amp; error != EPIPE)
		error = 0;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Socket upcall routine for the nfsd sockets.
 * The caddr_t arg is a pointer to the &quot;struct nfsrv_sock&quot;.
 * Essentially do as much as possible non-blocking, else punt and it will
 * be called with MBUF_WAITOK from an nfsd.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_rcv</span>(socket_t so, <span class="enscript-type">void</span> *arg, <span class="enscript-type">int</span> waitflag)
{
	<span class="enscript-type">struct</span> nfsrv_sock *slp = arg;

	<span class="enscript-keyword">if</span> (!nfsd_thread_count || !(slp-&gt;ns_flag &amp; SLP_VALID))
		<span class="enscript-keyword">return</span>;

	lck_rw_lock_exclusive(&amp;slp-&gt;ns_rwlock);
	nfsrv_rcv_locked(so, slp, waitflag);
	<span class="enscript-comment">/* Note: ns_rwlock gets dropped when called with MBUF_DONTWAIT */</span>
}
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_rcv_locked</span>(socket_t so, <span class="enscript-type">struct</span> nfsrv_sock *slp, <span class="enscript-type">int</span> waitflag)
{
	mbuf_t m, mp, mhck, m2;
	<span class="enscript-type">int</span> ns_flag=0, error;
	<span class="enscript-type">struct</span> msghdr	msg;
	size_t bytes_read;

	<span class="enscript-keyword">if</span> ((slp-&gt;ns_flag &amp; SLP_VALID) == 0) {
		<span class="enscript-keyword">if</span> (waitflag == MBUF_DONTWAIT)
			lck_rw_done(&amp;slp-&gt;ns_rwlock);
		<span class="enscript-keyword">return</span>;
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">notdef</span>
	<span class="enscript-comment">/*
	 * Define this to test for nfsds handling this under heavy load.
	 */</span>
	<span class="enscript-keyword">if</span> (waitflag == MBUF_DONTWAIT) {
		ns_flag = SLP_NEEDQ;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">dorecs</span>;
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (slp-&gt;ns_sotype == SOCK_STREAM) {
		<span class="enscript-comment">/*
		 * If there are already records on the queue, defer soreceive()
		 * to an(other) nfsd so that there is feedback to the TCP layer that
		 * the nfs servers are heavily loaded.
		 */</span>
		<span class="enscript-keyword">if</span> (slp-&gt;ns_rec) {
			ns_flag = SLP_NEEDQ;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dorecs</span>;
		}

		<span class="enscript-comment">/*
		 * Do soreceive().
		 */</span>
		bytes_read = 1000000000;
		error = sock_receivembuf(so, NULL, &amp;mp, MSG_DONTWAIT, &amp;bytes_read);
		<span class="enscript-keyword">if</span> (error || mp == NULL) {
			<span class="enscript-keyword">if</span> (error == EWOULDBLOCK)
				ns_flag = (waitflag == MBUF_DONTWAIT) ? SLP_NEEDQ : 0;
			<span class="enscript-keyword">else</span>
				ns_flag = SLP_DISCONN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dorecs</span>;
		}
		m = mp;
		<span class="enscript-keyword">if</span> (slp-&gt;ns_rawend) {
			<span class="enscript-keyword">if</span> ((error = mbuf_setnext(slp-&gt;ns_rawend, m)))
				panic(<span class="enscript-string">&quot;nfsrv_rcv: mbuf_setnext failed %d\n&quot;</span>, error);
			slp-&gt;ns_cc += bytes_read;
		} <span class="enscript-keyword">else</span> {
			slp-&gt;ns_raw = m;
			slp-&gt;ns_cc = bytes_read;
		}
		<span class="enscript-keyword">while</span> ((m2 = mbuf_next(m)))
			m = m2;
		slp-&gt;ns_rawend = m;

		<span class="enscript-comment">/*
		 * Now try and parse record(s) out of the raw stream data.
		 */</span>
		error = nfsrv_getstream(slp, waitflag);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error == EPERM)
				ns_flag = SLP_DISCONN;
			<span class="enscript-keyword">else</span>
				ns_flag = SLP_NEEDQ;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> sockaddr_storage	nam;

		<span class="enscript-keyword">if</span> (slp-&gt;ns_reccnt &gt;= nfsrv_sock_max_rec_queue_length) {
			<span class="enscript-comment">/* already have max # RPC records queued on this socket */</span>
			ns_flag = SLP_NEEDQ;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dorecs</span>;
		}

		bzero(&amp;msg, <span class="enscript-keyword">sizeof</span>(msg));
		msg.msg_name = (caddr_t)&amp;nam;
		msg.msg_namelen = <span class="enscript-keyword">sizeof</span>(nam);

		<span class="enscript-keyword">do</span> {
			bytes_read = 1000000000;
			error = sock_receivembuf(so, &amp;msg, &amp;mp, MSG_DONTWAIT | MSG_NEEDSA, &amp;bytes_read);
			<span class="enscript-keyword">if</span> (mp) {
				<span class="enscript-keyword">if</span> (msg.msg_name &amp;&amp; (mbuf_get(MBUF_WAITOK, MBUF_TYPE_SONAME, &amp;mhck) == 0)) {
					mbuf_setlen(mhck, nam.ss_len);
					bcopy(&amp;nam, mbuf_data(mhck), nam.ss_len);
					m = mhck;
					<span class="enscript-keyword">if</span> (mbuf_setnext(m, mp)) {
						<span class="enscript-comment">/* trouble... just drop it */</span>
						printf(<span class="enscript-string">&quot;nfsrv_rcv: mbuf_setnext failed\n&quot;</span>);
						mbuf_free(mhck);
						m = mp;
					}
				} <span class="enscript-keyword">else</span> {
					m = mp;
				}
				<span class="enscript-keyword">if</span> (slp-&gt;ns_recend)
					mbuf_setnextpkt(slp-&gt;ns_recend, m);
				<span class="enscript-keyword">else</span> {
					slp-&gt;ns_rec = m;
					slp-&gt;ns_flag |= SLP_DOREC;
				}
				slp-&gt;ns_recend = m;
				mbuf_setnextpkt(m, NULL);
				slp-&gt;ns_reccnt++;
			}
		} <span class="enscript-keyword">while</span> (mp);
	}

	<span class="enscript-comment">/*
	 * Now try and process the request records, non-blocking.
	 */</span>
<span class="enscript-reference">dorecs</span>:
	<span class="enscript-keyword">if</span> (ns_flag)
		slp-&gt;ns_flag |= ns_flag;
	<span class="enscript-keyword">if</span> (waitflag == MBUF_DONTWAIT) {
		<span class="enscript-type">int</span> wake = (slp-&gt;ns_flag &amp; SLP_WORKTODO);
		lck_rw_done(&amp;slp-&gt;ns_rwlock);
		<span class="enscript-keyword">if</span> (wake &amp;&amp; nfsd_thread_count) {
			lck_mtx_lock(nfsd_mutex);
			nfsrv_wakenfsd(slp);
			lck_mtx_unlock(nfsd_mutex);
		}
	}
}

<span class="enscript-comment">/*
 * Try and extract an RPC request from the mbuf data list received on a
 * stream socket. The &quot;waitflag&quot; argument indicates whether or not it
 * can sleep.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_getstream</span>(<span class="enscript-type">struct</span> nfsrv_sock *slp, <span class="enscript-type">int</span> waitflag)
{
	mbuf_t m;
	<span class="enscript-type">char</span> *cp1, *cp2, *mdata;
	<span class="enscript-type">int</span> len, mlen, error;
	mbuf_t om, m2, recm;
	u_int32_t recmark;

	<span class="enscript-keyword">if</span> (slp-&gt;ns_flag &amp; SLP_GETSTREAM)
		panic(<span class="enscript-string">&quot;nfs getstream&quot;</span>);
	slp-&gt;ns_flag |= SLP_GETSTREAM;
	<span class="enscript-keyword">for</span> (;;) {
	    <span class="enscript-keyword">if</span> (slp-&gt;ns_reclen == 0) {
		<span class="enscript-keyword">if</span> (slp-&gt;ns_cc &lt; NFSX_UNSIGNED) {
			slp-&gt;ns_flag &amp;= ~SLP_GETSTREAM;
			<span class="enscript-keyword">return</span> (0);
		}
		m = slp-&gt;ns_raw;
		mdata = mbuf_data(m);
		mlen = mbuf_len(m);
		<span class="enscript-keyword">if</span> (mlen &gt;= NFSX_UNSIGNED) {
			bcopy(mdata, (caddr_t)&amp;recmark, NFSX_UNSIGNED);
			mdata += NFSX_UNSIGNED;
			mlen -= NFSX_UNSIGNED;
			mbuf_setdata(m, mdata, mlen);
		} <span class="enscript-keyword">else</span> {
			cp1 = (caddr_t)&amp;recmark;
			cp2 = mdata;
			<span class="enscript-keyword">while</span> (cp1 &lt; ((caddr_t)&amp;recmark) + NFSX_UNSIGNED) {
				<span class="enscript-keyword">while</span> (mlen == 0) {
					m = mbuf_next(m);
					cp2 = mbuf_data(m);
					mlen = mbuf_len(m);
				}
				*cp1++ = *cp2++;
				mlen--;
				mbuf_setdata(m, cp2, mlen);
			}
		}
		slp-&gt;ns_cc -= NFSX_UNSIGNED;
		recmark = ntohl(recmark);
		slp-&gt;ns_reclen = recmark &amp; ~0x80000000;
		<span class="enscript-keyword">if</span> (recmark &amp; 0x80000000)
			slp-&gt;ns_flag |= SLP_LASTFRAG;
		<span class="enscript-keyword">else</span>
			slp-&gt;ns_flag &amp;= ~SLP_LASTFRAG;
		<span class="enscript-keyword">if</span> (slp-&gt;ns_reclen &lt;= 0 || slp-&gt;ns_reclen &gt; NFS_MAXPACKET) {
			slp-&gt;ns_flag &amp;= ~SLP_GETSTREAM;
			<span class="enscript-keyword">return</span> (EPERM);
		}
	    }

	    <span class="enscript-comment">/*
	     * Now get the record part.
	     *
	     * Note that slp-&gt;ns_reclen may be 0.  Linux sometimes
	     * generates 0-length RPCs
	     */</span>
	    recm = NULL;
	    <span class="enscript-keyword">if</span> (slp-&gt;ns_cc == slp-&gt;ns_reclen) {
		recm = slp-&gt;ns_raw;
		slp-&gt;ns_raw = slp-&gt;ns_rawend = NULL;
		slp-&gt;ns_cc = slp-&gt;ns_reclen = 0;
	    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (slp-&gt;ns_cc &gt; slp-&gt;ns_reclen) {
		len = 0;
		m = slp-&gt;ns_raw;
		mlen = mbuf_len(m);
		mdata = mbuf_data(m);
		om = NULL;
		<span class="enscript-keyword">while</span> (len &lt; slp-&gt;ns_reclen) {
			<span class="enscript-keyword">if</span> ((len + mlen) &gt; slp-&gt;ns_reclen) {
				<span class="enscript-keyword">if</span> (mbuf_copym(m, 0, slp-&gt;ns_reclen - len, waitflag, &amp;m2)) {
					slp-&gt;ns_flag &amp;= ~SLP_GETSTREAM;
					<span class="enscript-keyword">return</span> (EWOULDBLOCK);
				}
				<span class="enscript-keyword">if</span> (om) {
					<span class="enscript-keyword">if</span> (mbuf_setnext(om, m2)) {
						<span class="enscript-comment">/* trouble... just drop it */</span>
						printf(<span class="enscript-string">&quot;nfsrv_getstream: mbuf_setnext failed\n&quot;</span>);
						mbuf_freem(m2);
						slp-&gt;ns_flag &amp;= ~SLP_GETSTREAM;
						<span class="enscript-keyword">return</span> (EWOULDBLOCK);
					}
					recm = slp-&gt;ns_raw;
				} <span class="enscript-keyword">else</span> {
					recm = m2;
				}
				mdata += slp-&gt;ns_reclen - len;
				mlen -= slp-&gt;ns_reclen - len;
				mbuf_setdata(m, mdata, mlen);
				len = slp-&gt;ns_reclen;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((len + mlen) == slp-&gt;ns_reclen) {
				om = m;
				len += mlen;
				m = mbuf_next(m);
				recm = slp-&gt;ns_raw;
				<span class="enscript-keyword">if</span> (mbuf_setnext(om, NULL)) {
					printf(<span class="enscript-string">&quot;nfsrv_getstream: mbuf_setnext failed 2\n&quot;</span>);
					slp-&gt;ns_flag &amp;= ~SLP_GETSTREAM;
					<span class="enscript-keyword">return</span> (EWOULDBLOCK);
				}
				mlen = mbuf_len(m);
				mdata = mbuf_data(m);
			} <span class="enscript-keyword">else</span> {
				om = m;
				len += mlen;
				m = mbuf_next(m);
				mlen = mbuf_len(m);
				mdata = mbuf_data(m);
			}
		}
		slp-&gt;ns_raw = m;
		slp-&gt;ns_cc -= len;
		slp-&gt;ns_reclen = 0;
	    } <span class="enscript-keyword">else</span> {
		slp-&gt;ns_flag &amp;= ~SLP_GETSTREAM;
		<span class="enscript-keyword">return</span> (0);
	    }

	    <span class="enscript-comment">/*
	     * Accumulate the fragments into a record.
	     */</span>
	    <span class="enscript-keyword">if</span> (slp-&gt;ns_frag == NULL) {
		slp-&gt;ns_frag = recm;
	    } <span class="enscript-keyword">else</span> {
		m = slp-&gt;ns_frag;
		<span class="enscript-keyword">while</span> ((m2 = mbuf_next(m)))
		    m = m2;
		<span class="enscript-keyword">if</span> ((error = mbuf_setnext(m, recm)))
		    panic(<span class="enscript-string">&quot;nfsrv_getstream: mbuf_setnext failed 3, %d\n&quot;</span>, error);
	    }
	    <span class="enscript-keyword">if</span> (slp-&gt;ns_flag &amp; SLP_LASTFRAG) {
		<span class="enscript-keyword">if</span> (slp-&gt;ns_recend)
		    mbuf_setnextpkt(slp-&gt;ns_recend, slp-&gt;ns_frag);
		<span class="enscript-keyword">else</span> {
		    slp-&gt;ns_rec = slp-&gt;ns_frag;
		    slp-&gt;ns_flag |= SLP_DOREC;
		}
		slp-&gt;ns_recend = slp-&gt;ns_frag;
		slp-&gt;ns_frag = NULL;
	    }
	}
}

<span class="enscript-comment">/*
 * Parse an RPC header.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_dorec</span>(
	<span class="enscript-type">struct</span> nfsrv_sock *slp,
	<span class="enscript-type">struct</span> nfsd *nfsd,
	<span class="enscript-type">struct</span> nfsrv_descript **ndp)
{
	mbuf_t m;
	mbuf_t nam;
	<span class="enscript-type">struct</span> nfsrv_descript *nd;
	<span class="enscript-type">int</span> error = 0;

	*ndp = NULL;
	<span class="enscript-keyword">if</span> (!(slp-&gt;ns_flag &amp; (SLP_VALID|SLP_DOREC)) || (slp-&gt;ns_rec == NULL))
		<span class="enscript-keyword">return</span> (ENOBUFS);
	MALLOC_ZONE(nd, <span class="enscript-type">struct</span> nfsrv_descript *,
			<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> nfsrv_descript), M_NFSRVDESC, M_WAITOK);
	<span class="enscript-keyword">if</span> (!nd)
		<span class="enscript-keyword">return</span> (ENOMEM);
	m = slp-&gt;ns_rec;
	slp-&gt;ns_rec = mbuf_nextpkt(m);
	<span class="enscript-keyword">if</span> (slp-&gt;ns_rec)
		mbuf_setnextpkt(m, NULL);
	<span class="enscript-keyword">else</span> {
		slp-&gt;ns_flag &amp;= ~SLP_DOREC;
		slp-&gt;ns_recend = NULL;
	}
	slp-&gt;ns_reccnt--;
	<span class="enscript-keyword">if</span> (mbuf_type(m) == MBUF_TYPE_SONAME) {
		nam = m;
		m = mbuf_next(m);
		<span class="enscript-keyword">if</span> ((error = mbuf_setnext(nam, NULL)))
			panic(<span class="enscript-string">&quot;nfsrv_dorec: mbuf_setnext failed %d\n&quot;</span>, error);
	} <span class="enscript-keyword">else</span>
		nam = NULL;
	nd-&gt;nd_nam2 = nam;
	nfsm_chain_dissect_init(error, &amp;nd-&gt;nd_nmreq, m);
	<span class="enscript-keyword">if</span> (!error)
		error = nfsrv_getreq(nd);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (nam)
			mbuf_freem(nam);
		<span class="enscript-keyword">if</span> (nd-&gt;nd_gss_context)
			nfs_gss_svc_ctx_deref(nd-&gt;nd_gss_context);
		FREE_ZONE(nd, <span class="enscript-keyword">sizeof</span>(*nd), M_NFSRVDESC);
		<span class="enscript-keyword">return</span> (error);
	}
	nd-&gt;nd_mrep = NULL;
	*ndp = nd;
	nfsd-&gt;nfsd_nd = nd;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Parse an RPC request
 * - verify it
 * - fill in the cred struct.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">nfsrv_getreq</span>(<span class="enscript-type">struct</span> nfsrv_descript *nd)
{
	<span class="enscript-type">struct</span> nfsm_chain *nmreq;
	<span class="enscript-type">int</span> len, i;
	u_int32_t nfsvers, auth_type;
	<span class="enscript-type">int</span> error = 0;
	uid_t user_id;
	gid_t group_id;
	<span class="enscript-type">int</span> ngroups;
	uint32_t val;

	nd-&gt;nd_cr = NULL;
	nd-&gt;nd_gss_context = NULL;
	nd-&gt;nd_gss_seqnum = 0;
	nd-&gt;nd_gss_mb = NULL;

	user_id = group_id = -2;
	val = auth_type = len = 0;

	nmreq = &amp;nd-&gt;nd_nmreq;
	nfsm_chain_get_32(error, nmreq, nd-&gt;nd_retxid);	<span class="enscript-comment">// XID
</span>	nfsm_chain_get_32(error, nmreq, val);		<span class="enscript-comment">// RPC Call
</span>	<span class="enscript-keyword">if</span> (!error &amp;&amp; (val != RPC_CALL))
		error = EBADRPC;
	nfsmout_if(error);
	nd-&gt;nd_repstat = 0;
	nfsm_chain_get_32(error, nmreq, val);	<span class="enscript-comment">// RPC Version
</span>	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (val != RPC_VER2) {
		nd-&gt;nd_repstat = ERPCMISMATCH;
		nd-&gt;nd_procnum = NFSPROC_NOOP;
		<span class="enscript-keyword">return</span> (0);
	}
	nfsm_chain_get_32(error, nmreq, val);	<span class="enscript-comment">// RPC Program Number
</span>	nfsmout_if(error);
	<span class="enscript-keyword">if</span> (val != NFS_PROG) {
		nd-&gt;nd_repstat = EPROGUNAVAIL;
		nd-&gt;nd_procnum = NFSPROC_NOOP;
		<span class="enscript-keyword">return</span> (0);
	}
	nfsm_chain_get_32(error, nmreq, nfsvers);<span class="enscript-comment">// NFS Version Number
</span>	nfsmout_if(error);
	<span class="enscript-keyword">if</span> ((nfsvers &lt; NFS_VER2) || (nfsvers &gt; NFS_VER3)) {
		nd-&gt;nd_repstat = EPROGMISMATCH;
		nd-&gt;nd_procnum = NFSPROC_NOOP;
		<span class="enscript-keyword">return</span> (0);
	}
	nd-&gt;nd_vers = nfsvers;
	nfsm_chain_get_32(error, nmreq, nd-&gt;nd_procnum);<span class="enscript-comment">// NFS Procedure Number
</span>	nfsmout_if(error);
	<span class="enscript-keyword">if</span> ((nd-&gt;nd_procnum &gt;= NFS_NPROCS) ||
		((nd-&gt;nd_vers == NFS_VER2) &amp;&amp; (nd-&gt;nd_procnum &gt; NFSV2PROC_STATFS))) {
		nd-&gt;nd_repstat = EPROCUNAVAIL;
		nd-&gt;nd_procnum = NFSPROC_NOOP;
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">if</span> (nfsvers != NFS_VER3)
		nd-&gt;nd_procnum = nfsv3_procid[nd-&gt;nd_procnum];
	nfsm_chain_get_32(error, nmreq, auth_type);	<span class="enscript-comment">// Auth Flavor
</span>	nfsm_chain_get_32(error, nmreq, len);		<span class="enscript-comment">// Auth Length
</span>	<span class="enscript-keyword">if</span> (!error &amp;&amp; (len &lt; 0 || len &gt; RPCAUTH_MAXSIZ))
		error = EBADRPC;
	nfsmout_if(error);

	<span class="enscript-comment">/* Handle authentication */</span>
	<span class="enscript-keyword">if</span> (auth_type == RPCAUTH_SYS) {
		<span class="enscript-type">struct</span> posix_cred temp_pcred;
		<span class="enscript-keyword">if</span> (nd-&gt;nd_procnum == NFSPROC_NULL)
			<span class="enscript-keyword">return</span> (0);
		nd-&gt;nd_sec = RPCAUTH_SYS;
		nfsm_chain_adv(error, nmreq, NFSX_UNSIGNED);	<span class="enscript-comment">// skip stamp
</span>		nfsm_chain_get_32(error, nmreq, len);		<span class="enscript-comment">// hostname length
</span>		<span class="enscript-keyword">if</span> (len &lt; 0 || len &gt; NFS_MAXNAMLEN)
			error = EBADRPC;
		nfsm_chain_adv(error, nmreq, nfsm_rndup(len));	<span class="enscript-comment">// skip hostname
</span>		nfsmout_if(error);

		<span class="enscript-comment">/* create a temporary credential using the bits from the wire */</span>
		bzero(&amp;temp_pcred, <span class="enscript-keyword">sizeof</span>(temp_pcred));
		nfsm_chain_get_32(error, nmreq, user_id);
		nfsm_chain_get_32(error, nmreq, group_id);
		temp_pcred.cr_groups[0] = group_id;
		nfsm_chain_get_32(error, nmreq, len);		<span class="enscript-comment">// extra GID count
</span>		<span class="enscript-keyword">if</span> ((len &lt; 0) || (len &gt; RPCAUTH_UNIXGIDS))
			error = EBADRPC;
		nfsmout_if(error);
		<span class="enscript-keyword">for</span> (i = 1; i &lt;= len; i++)
			<span class="enscript-keyword">if</span> (i &lt; NGROUPS)
				nfsm_chain_get_32(error, nmreq, temp_pcred.cr_groups[i]);
			<span class="enscript-keyword">else</span>
				nfsm_chain_adv(error, nmreq, NFSX_UNSIGNED);
		nfsmout_if(error);
		ngroups = (len &gt;= NGROUPS) ? NGROUPS : (len + 1);
		<span class="enscript-keyword">if</span> (ngroups &gt; 1)
			nfsrv_group_sort(&amp;temp_pcred.cr_groups[0], ngroups);
		nfsm_chain_adv(error, nmreq, NFSX_UNSIGNED);	<span class="enscript-comment">// verifier flavor (should be AUTH_NONE)
</span>		nfsm_chain_get_32(error, nmreq, len);		<span class="enscript-comment">// verifier length
</span>		<span class="enscript-keyword">if</span> (len &lt; 0 || len &gt; RPCAUTH_MAXSIZ)
			error = EBADRPC;
		<span class="enscript-keyword">if</span> (len &gt; 0)
			nfsm_chain_adv(error, nmreq, nfsm_rndup(len));

		<span class="enscript-comment">/* request creation of a real credential */</span>
		temp_pcred.cr_uid = user_id;
		temp_pcred.cr_ngroups = ngroups;
		nd-&gt;nd_cr = posix_cred_create(&amp;temp_pcred);
		<span class="enscript-keyword">if</span> (nd-&gt;nd_cr == NULL) {
			nd-&gt;nd_repstat = ENOMEM;
			nd-&gt;nd_procnum = NFSPROC_NOOP;
			<span class="enscript-keyword">return</span> (0);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (auth_type == RPCSEC_GSS) {
		error = nfs_gss_svc_cred_get(nd, nmreq);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (error == EINVAL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nfsmout</span>;	<span class="enscript-comment">// drop the request
</span>			nd-&gt;nd_repstat = error;
			nd-&gt;nd_procnum = NFSPROC_NOOP;
			<span class="enscript-keyword">return</span> (0);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (nd-&gt;nd_procnum == NFSPROC_NULL)	<span class="enscript-comment">// assume it's AUTH_NONE
</span>			<span class="enscript-keyword">return</span> (0);
		nd-&gt;nd_repstat = (NFSERR_AUTHERR | AUTH_REJECTCRED);
		nd-&gt;nd_procnum = NFSPROC_NOOP;
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">return</span> (0);
<span class="enscript-reference">nfsmout</span>:
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(nd-&gt;nd_cr))
		kauth_cred_unref(&amp;nd-&gt;nd_cr);
	nfsm_chain_cleanup(nmreq);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Search for a sleeping nfsd and wake it up.
 * SIDE EFFECT: If none found, make sure the socket is queued up so that one
 * of the running nfsds will go look for the work in the nfsrv_sockwait list.
 * Note: Must be called with nfsd_mutex held.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nfsrv_wakenfsd</span>(<span class="enscript-type">struct</span> nfsrv_sock *slp)
{
	<span class="enscript-type">struct</span> nfsd *nd;

	<span class="enscript-keyword">if</span> ((slp-&gt;ns_flag &amp; SLP_VALID) == 0)
		<span class="enscript-keyword">return</span>;

	lck_rw_lock_exclusive(&amp;slp-&gt;ns_rwlock);
	<span class="enscript-comment">/* if there's work to do on this socket, make sure it's queued up */</span>
	<span class="enscript-keyword">if</span> ((slp-&gt;ns_flag &amp; SLP_WORKTODO) &amp;&amp; !(slp-&gt;ns_flag &amp; SLP_QUEUED)) {
		TAILQ_INSERT_TAIL(&amp;nfsrv_sockwait, slp, ns_svcq);
		slp-&gt;ns_flag |= SLP_WAITQ;
	}
	lck_rw_done(&amp;slp-&gt;ns_rwlock);

	<span class="enscript-comment">/* wake up a waiting nfsd, if possible */</span>
	nd = TAILQ_FIRST(&amp;nfsd_queue);
	<span class="enscript-keyword">if</span> (!nd)
		<span class="enscript-keyword">return</span>;

	TAILQ_REMOVE(&amp;nfsd_queue, nd, nfsd_queue);
	nd-&gt;nfsd_flag &amp;= ~NFSD_WAITING;
	wakeup(nd);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NFSSERVER */</span>
</pre>
<hr />
</body></html>