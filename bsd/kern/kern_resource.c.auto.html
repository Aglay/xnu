<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_resource.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_resource.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995, 1997 Apple Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*-
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)kern_resource.c	8.5 (Berkeley) 1/21/94
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/spl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/vmparam.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/time_value.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_act.h&gt;</span>  <span class="enscript-comment">/* for thread_policy_set( ) */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>		<span class="enscript-comment">/* for absolutetime_to_microtime() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>		<span class="enscript-comment">/* for TRAFFIC_MGT_SO_* */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>	<span class="enscript-comment">/* for struct socket */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resource.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOBSD.h&gt;</span>

<span class="enscript-type">int</span>	donice(<span class="enscript-type">struct</span> proc *curp, <span class="enscript-type">struct</span> proc *chgp, <span class="enscript-type">int</span> n);
<span class="enscript-type">int</span>	dosetrlimit(<span class="enscript-type">struct</span> proc *p, u_int which, <span class="enscript-type">struct</span> rlimit *limp);
<span class="enscript-type">int</span>	uthread_get_background_state(uthread_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">do_background_socket</span>(<span class="enscript-type">struct</span> proc *p, thread_t thread);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">do_background_thread</span>(<span class="enscript-type">struct</span> proc *curp, thread_t thread, <span class="enscript-type">int</span> priority);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">do_background_proc</span>(<span class="enscript-type">struct</span> proc *curp, <span class="enscript-type">struct</span> proc *targetp, <span class="enscript-type">int</span> priority);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">set_gpudeny_proc</span>(<span class="enscript-type">struct</span> proc *curp, <span class="enscript-type">struct</span> proc *targetp, <span class="enscript-type">int</span> priority);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_set_darwin_role</span>(proc_t curp, proc_t targetp, <span class="enscript-type">int</span> priority);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_get_darwin_role</span>(proc_t curp, proc_t targetp, <span class="enscript-type">int</span> *priority);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">get_background_proc</span>(<span class="enscript-type">struct</span> proc *curp, <span class="enscript-type">struct</span> proc *targetp, <span class="enscript-type">int</span> *priority);
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_apply_task_networkbg_internal</span>(proc_t, thread_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_restore_task_networkbg_internal</span>(proc_t, thread_t);
<span class="enscript-type">int</span> <span class="enscript-function-name">proc_pid_rusage</span>(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor, user_addr_t buf, int32_t *retval);
<span class="enscript-type">void</span> <span class="enscript-function-name">gather_rusage_info</span>(proc_t p, rusage_info_current *ru, <span class="enscript-type">int</span> flavor);
<span class="enscript-type">int</span> <span class="enscript-function-name">fill_task_rusage</span>(task_t task, rusage_info_current *ri);
<span class="enscript-type">void</span> <span class="enscript-function-name">fill_task_billed_usage</span>(task_t task, rusage_info_current *ri);
<span class="enscript-type">int</span> <span class="enscript-function-name">fill_task_io_rusage</span>(task_t task, rusage_info_current *ri);
<span class="enscript-type">int</span> <span class="enscript-function-name">fill_task_qos_rusage</span>(task_t task, rusage_info_current *ri);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">rusage_info_conversion</span>(rusage_info_t ri_info, rusage_info_current *ri_current, <span class="enscript-type">int</span> flavor);

<span class="enscript-type">int</span> <span class="enscript-function-name">proc_get_rusage</span>(proc_t p, <span class="enscript-type">int</span> flavor, user_addr_t buffer, __unused <span class="enscript-type">int</span> is_zombie);

rlim_t maxdmap = MAXDSIZ;	<span class="enscript-comment">/* XXX */</span> 
rlim_t maxsmap = MAXSSIZ - PAGE_MAX_SIZE;	<span class="enscript-comment">/* XXX */</span> 

<span class="enscript-comment">/*
 * Limits on the number of open files per process, and the number
 * of child processes per process.
 *
 * Note: would be in kern/subr_param.c in FreeBSD.
 */</span>
__private_extern__ <span class="enscript-type">int</span> maxfilesperproc = OPEN_MAX;		<span class="enscript-comment">/* per-proc open files limit */</span>

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, KERN_MAXPROCPERUID, maxprocperuid, CTLFLAG_RW | CTLFLAG_LOCKED,
    		&amp;maxprocperuid, 0, <span class="enscript-string">&quot;Maximum processes allowed per userid&quot;</span> );

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, KERN_MAXFILESPERPROC, maxfilesperproc, CTLFLAG_RW | CTLFLAG_LOCKED,
    		&amp;maxfilesperproc, 0, <span class="enscript-string">&quot;Maximum files allowed open per process&quot;</span> );

<span class="enscript-comment">/* Args and fn for proc_iteration callback used in setpriority */</span>
<span class="enscript-type">struct</span> puser_nice_args {
	proc_t curp;
	<span class="enscript-type">int</span>	prio;
	id_t	who;
	<span class="enscript-type">int</span> *	foundp;
	<span class="enscript-type">int</span> *	errorp;
};
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">puser_donice_callback</span>(proc_t p, <span class="enscript-type">void</span> * arg);


<span class="enscript-comment">/* Args and fn for proc_iteration callback used in setpriority */</span>
<span class="enscript-type">struct</span> ppgrp_nice_args {
	proc_t curp;
	<span class="enscript-type">int</span>	prio;
	<span class="enscript-type">int</span> *	foundp;
	<span class="enscript-type">int</span> *	errorp;
};
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ppgrp_donice_callback</span>(proc_t p, <span class="enscript-type">void</span> * arg);

<span class="enscript-comment">/*
 * Resource controls and accounting.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getpriority</span>(<span class="enscript-type">struct</span> proc *curp, <span class="enscript-type">struct</span> getpriority_args *uap, int32_t *retval)
{
	<span class="enscript-type">struct</span> proc *p;
	<span class="enscript-type">int</span> low = PRIO_MAX + 1;
	kauth_cred_t my_cred;
	<span class="enscript-type">int</span> refheld = 0;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/* would also test (uap-&gt;who &lt; 0), but id_t is unsigned */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;who &gt; 0x7fffffff)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">switch</span> (uap-&gt;which) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_PROCESS</span>:
		<span class="enscript-keyword">if</span> (uap-&gt;who == 0) {
			p = curp;
			low = p-&gt;p_nice;
		} <span class="enscript-keyword">else</span> {
			p = proc_find(uap-&gt;who);
			<span class="enscript-keyword">if</span> (p == 0)
				<span class="enscript-keyword">break</span>;
			low = p-&gt;p_nice;
			proc_rele(p);

		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_PGRP</span>: {
		<span class="enscript-type">struct</span> pgrp *pg = PGRP_NULL;

		<span class="enscript-keyword">if</span> (uap-&gt;who == 0) {
			<span class="enscript-comment">/* returns the pgrp to ref */</span>
			pg = proc_pgrp(curp);
		 } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((pg = pgfind(uap-&gt;who)) == PGRP_NULL) {
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* No need for iteration as it is a simple scan */</span>
		pgrp_lock(pg);
		<span class="enscript-keyword">for</span> (p = pg-&gt;pg_members.lh_first; p != 0; p = p-&gt;p_pglist.le_next) {
			<span class="enscript-keyword">if</span> (p-&gt;p_nice &lt; low)
				low = p-&gt;p_nice;
		}
		pgrp_unlock(pg);
		pg_rele(pg);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_USER</span>:
		<span class="enscript-keyword">if</span> (uap-&gt;who == 0)
			uap-&gt;who = kauth_cred_getuid(kauth_cred_get());

		proc_list_lock();

		<span class="enscript-keyword">for</span> (p = allproc.lh_first; p != 0; p = p-&gt;p_list.le_next) {
			my_cred = kauth_cred_proc_ref(p);
			<span class="enscript-keyword">if</span> (kauth_cred_getuid(my_cred) == uap-&gt;who &amp;&amp;
			    p-&gt;p_nice &lt; low)
				low = p-&gt;p_nice;
			kauth_cred_unref(&amp;my_cred);
		}

		proc_list_unlock();

		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_THREAD</span>:
		<span class="enscript-comment">/* we currently only support the current thread */</span>
		<span class="enscript-keyword">if</span> (uap-&gt;who != 0)
			<span class="enscript-keyword">return</span> (EINVAL);

		low = proc_get_task_policy(current_task(), current_thread(), TASK_POLICY_INTERNAL, TASK_POLICY_DARWIN_BG);

		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_PROCESS</span>:
		<span class="enscript-keyword">if</span> (uap-&gt;who == 0) {
			p = curp;
		} <span class="enscript-keyword">else</span> {
			p = proc_find(uap-&gt;who);
			<span class="enscript-keyword">if</span> (p == PROC_NULL)
				<span class="enscript-keyword">break</span>;
			refheld = 1;
		}

		error = get_background_proc(curp, p, &amp;low);

		<span class="enscript-keyword">if</span> (refheld)
			proc_rele(p);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_ROLE</span>:
		<span class="enscript-keyword">if</span> (uap-&gt;who == 0) {
			p = curp;
		} <span class="enscript-keyword">else</span> {
			p = proc_find(uap-&gt;who);
			<span class="enscript-keyword">if</span> (p == PROC_NULL)
				<span class="enscript-keyword">break</span>;
			refheld = 1;
		}

		error = proc_get_darwin_role(curp, p, &amp;low);

		<span class="enscript-keyword">if</span> (refheld)
			proc_rele(p);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> (low == PRIO_MAX + 1)
		<span class="enscript-keyword">return</span> (ESRCH);
	*retval = low;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/* call back function used for proc iteration in PRIO_USER */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">puser_donice_callback</span>(proc_t p, <span class="enscript-type">void</span> * arg)
{
	<span class="enscript-type">int</span> error, n;
	<span class="enscript-type">struct</span> puser_nice_args * pun = (<span class="enscript-type">struct</span> puser_nice_args *)arg;
	kauth_cred_t my_cred;

	my_cred = kauth_cred_proc_ref(p);
	<span class="enscript-keyword">if</span> (kauth_cred_getuid(my_cred) == pun-&gt;who) {
		error = donice(pun-&gt;curp, p, pun-&gt;prio);
		<span class="enscript-keyword">if</span> (pun-&gt;errorp != NULL)
			*pun-&gt;errorp = error;
		<span class="enscript-keyword">if</span> (pun-&gt;foundp != NULL) {
			n = *pun-&gt;foundp;
			*pun-&gt;foundp = n+1;
		}
	}
	kauth_cred_unref(&amp;my_cred);

	<span class="enscript-keyword">return</span>(PROC_RETURNED);
}

<span class="enscript-comment">/* call back function used for proc iteration in PRIO_PGRP */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ppgrp_donice_callback</span>(proc_t p, <span class="enscript-type">void</span> * arg)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> ppgrp_nice_args * pun = (<span class="enscript-type">struct</span> ppgrp_nice_args *)arg;
	<span class="enscript-type">int</span> n;

	error = donice(pun-&gt;curp, p, pun-&gt;prio);
	<span class="enscript-keyword">if</span> (pun-&gt;errorp != NULL)
		*pun-&gt;errorp = error;
	<span class="enscript-keyword">if</span> (pun-&gt;foundp!= NULL) {
		n = *pun-&gt;foundp;
		*pun-&gt;foundp = n+1;
	}

	<span class="enscript-keyword">return</span>(PROC_RETURNED);
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *		EINVAL
 *		ESRCH
 *	donice:EPERM
 *	donice:EACCES
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setpriority</span>(<span class="enscript-type">struct</span> proc *curp, <span class="enscript-type">struct</span> setpriority_args *uap, int32_t *retval)
{
	<span class="enscript-type">struct</span> proc *p;
	<span class="enscript-type">int</span> found = 0, error = 0;
	<span class="enscript-type">int</span> refheld = 0;

	AUDIT_ARG(cmd, uap-&gt;which);
	AUDIT_ARG(owner, uap-&gt;who, 0);
	AUDIT_ARG(value32, uap-&gt;prio);

	<span class="enscript-comment">/* would also test (uap-&gt;who &lt; 0), but id_t is unsigned */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;who &gt; 0x7fffffff)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">switch</span> (uap-&gt;which) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_PROCESS</span>:
		<span class="enscript-keyword">if</span> (uap-&gt;who == 0)
			p = curp;
		<span class="enscript-keyword">else</span> {
			p = proc_find(uap-&gt;who);
			<span class="enscript-keyword">if</span> (p == 0)
				<span class="enscript-keyword">break</span>;
			refheld = 1;
		}
		error = donice(curp, p, uap-&gt;prio);
		found++;
		<span class="enscript-keyword">if</span> (refheld != 0)
			proc_rele(p);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_PGRP</span>: {
		<span class="enscript-type">struct</span> pgrp *pg = PGRP_NULL;
		<span class="enscript-type">struct</span> ppgrp_nice_args ppgrp;
		 
		<span class="enscript-keyword">if</span> (uap-&gt;who == 0) {
			pg = proc_pgrp(curp);
		 } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((pg = pgfind(uap-&gt;who)) == PGRP_NULL)
			<span class="enscript-keyword">break</span>;

		ppgrp.curp = curp;
		ppgrp.prio = uap-&gt;prio;
		ppgrp.foundp = &amp;found;
		ppgrp.errorp = &amp;error;
		
		<span class="enscript-comment">/* PGRP_DROPREF drops the reference on process group */</span>
		pgrp_iterate(pg, PGRP_DROPREF, ppgrp_donice_callback, (<span class="enscript-type">void</span> *)&amp;ppgrp, NULL, NULL);

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_USER</span>: {
		<span class="enscript-type">struct</span> puser_nice_args punice;

		<span class="enscript-keyword">if</span> (uap-&gt;who == 0)
			uap-&gt;who = kauth_cred_getuid(kauth_cred_get());

		punice.curp = curp;
		punice.prio = uap-&gt;prio;
		punice.who = uap-&gt;who;
		punice.foundp = &amp;found;
		error = 0;
		punice.errorp = &amp;error;
		proc_iterate(PROC_ALLPROCLIST, puser_donice_callback, (<span class="enscript-type">void</span> *)&amp;punice, NULL, NULL);

		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_THREAD</span>: {
		<span class="enscript-comment">/* we currently only support the current thread */</span>
		<span class="enscript-keyword">if</span> (uap-&gt;who != 0)
			<span class="enscript-keyword">return</span> (EINVAL);

		error = do_background_thread(curp, current_thread(), uap-&gt;prio);
		found++;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_PROCESS</span>: {
		<span class="enscript-keyword">if</span> (uap-&gt;who == 0)
			p = curp;
		<span class="enscript-keyword">else</span> {
			p = proc_find(uap-&gt;who);
			<span class="enscript-keyword">if</span> (p == 0)
				<span class="enscript-keyword">break</span>;
			refheld = 1;
		}

		error = do_background_proc(curp, p, uap-&gt;prio);

		found++;
		<span class="enscript-keyword">if</span> (refheld != 0)
			proc_rele(p);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_GPU</span>: {
		<span class="enscript-keyword">if</span> (uap-&gt;who == 0)
			<span class="enscript-keyword">return</span> (EINVAL);

		p = proc_find(uap-&gt;who);
		<span class="enscript-keyword">if</span> (p == PROC_NULL)
			<span class="enscript-keyword">break</span>;

		error = set_gpudeny_proc(curp, p, uap-&gt;prio);

		found++;
		proc_rele(p);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_ROLE</span>: {
		<span class="enscript-keyword">if</span> (uap-&gt;who == 0) {
			p = curp;
		} <span class="enscript-keyword">else</span> {
			p = proc_find(uap-&gt;who);
			<span class="enscript-keyword">if</span> (p == PROC_NULL)
				<span class="enscript-keyword">break</span>;
			refheld = 1;
		}

		error = proc_set_darwin_role(curp, p, uap-&gt;prio);

		found++;
		<span class="enscript-keyword">if</span> (refheld != 0)
			proc_rele(p);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> (found == 0)
		<span class="enscript-keyword">return</span> (ESRCH);
	<span class="enscript-keyword">if</span> (error == EIDRM) {
		*retval = -2;
		error = 0;
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * Returns:	0			Success
 *		EPERM
 *		EACCES
 *	mac_check_proc_sched:???
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">donice</span>(<span class="enscript-type">struct</span> proc *curp, <span class="enscript-type">struct</span> proc *chgp, <span class="enscript-type">int</span> n)
{
	<span class="enscript-type">int</span> error = 0;
	kauth_cred_t ucred;
	kauth_cred_t my_cred;

	ucred = kauth_cred_proc_ref(curp);
	my_cred = kauth_cred_proc_ref(chgp);

	<span class="enscript-keyword">if</span> (suser(ucred, NULL) &amp;&amp; kauth_cred_getruid(ucred) &amp;&amp;
	    kauth_cred_getuid(ucred) != kauth_cred_getuid(my_cred) &amp;&amp;
	    kauth_cred_getruid(ucred) != kauth_cred_getuid(my_cred)) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (n &gt; PRIO_MAX)
		n = PRIO_MAX;
	<span class="enscript-keyword">if</span> (n &lt; PRIO_MIN)
		n = PRIO_MIN;
	<span class="enscript-keyword">if</span> (n &lt; chgp-&gt;p_nice &amp;&amp; suser(ucred, &amp;curp-&gt;p_acflag)) {
		error = EACCES;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_proc_check_sched(curp, chgp);
	<span class="enscript-keyword">if</span> (error) 
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>
	proc_lock(chgp);
	chgp-&gt;p_nice = n;
	proc_unlock(chgp);
	(<span class="enscript-type">void</span>)resetpriority(chgp);
<span class="enscript-reference">out</span>:
	kauth_cred_unref(&amp;ucred);
	kauth_cred_unref(&amp;my_cred);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">set_gpudeny_proc</span>(<span class="enscript-type">struct</span> proc *curp, <span class="enscript-type">struct</span> proc *targetp, <span class="enscript-type">int</span> priority)
{
	<span class="enscript-type">int</span> error = 0;
	kauth_cred_t ucred;
	kauth_cred_t target_cred;

	ucred = kauth_cred_get();
	target_cred = kauth_cred_proc_ref(targetp);

	<span class="enscript-comment">/* TODO: Entitlement instead of uid check */</span>

	<span class="enscript-keyword">if</span> (!kauth_cred_issuser(ucred) &amp;&amp; kauth_cred_getruid(ucred) &amp;&amp;
	    kauth_cred_getuid(ucred)   != kauth_cred_getuid(target_cred) &amp;&amp;
	    kauth_cred_getruid(ucred)  != kauth_cred_getuid(target_cred)) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (curp == targetp) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_proc_check_sched(curp, targetp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">switch</span> (priority) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_GPU_DENY</span>:
			task_set_gpu_denied(proc_task(targetp), TRUE);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_GPU_ALLOW</span>:
			task_set_gpu_denied(proc_task(targetp), FALSE);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

<span class="enscript-reference">out</span>:
	kauth_cred_unref(&amp;target_cred);
	<span class="enscript-keyword">return</span> (error);

}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">proc_set_darwin_role</span>(proc_t curp, proc_t targetp, <span class="enscript-type">int</span> priority)
{
	<span class="enscript-type">int</span> error = 0;
	uint32_t flagsp;

	kauth_cred_t ucred, target_cred;

	ucred = kauth_cred_get();
	target_cred = kauth_cred_proc_ref(targetp);

	<span class="enscript-keyword">if</span> (!kauth_cred_issuser(ucred) &amp;&amp; kauth_cred_getruid(ucred) &amp;&amp;
	    kauth_cred_getuid(ucred)  != kauth_cred_getuid(target_cred) &amp;&amp;
	    kauth_cred_getruid(ucred) != kauth_cred_getuid(target_cred)) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (curp != targetp) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-keyword">if</span> ((error = mac_proc_check_sched(curp, targetp)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>
	}

	proc_get_darwinbgstate(proc_task(targetp), &amp;flagsp);
	<span class="enscript-keyword">if</span> ((flagsp &amp; PROC_FLAG_APPLICATION) != PROC_FLAG_APPLICATION) {
		error = ENOTSUP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	integer_t role = 0;

	<span class="enscript-keyword">if</span> ((error = proc_darwin_role_to_task_role(priority, &amp;role)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	proc_set_task_policy(proc_task(targetp), THREAD_NULL,
	                     TASK_POLICY_ATTRIBUTE, TASK_POLICY_ROLE, role);

<span class="enscript-reference">out</span>:
	kauth_cred_unref(&amp;target_cred);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">proc_get_darwin_role</span>(proc_t curp, proc_t targetp, <span class="enscript-type">int</span> *priority)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> role = 0;

	kauth_cred_t ucred, target_cred;

	ucred = kauth_cred_get();
	target_cred = kauth_cred_proc_ref(targetp);

	<span class="enscript-keyword">if</span> (!kauth_cred_issuser(ucred) &amp;&amp; kauth_cred_getruid(ucred) &amp;&amp;
	    kauth_cred_getuid(ucred)  != kauth_cred_getuid(target_cred) &amp;&amp;
	    kauth_cred_getruid(ucred) != kauth_cred_getuid(target_cred)) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (curp != targetp) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-keyword">if</span> ((error = mac_proc_check_sched(curp, targetp)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>
	}

	role = proc_get_task_policy(proc_task(targetp), THREAD_NULL,
	                            TASK_POLICY_ATTRIBUTE, TASK_POLICY_ROLE);

	*priority = proc_task_role_to_darwin_role(role);

<span class="enscript-reference">out</span>:
	kauth_cred_unref(&amp;target_cred);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">get_background_proc</span>(<span class="enscript-type">struct</span> proc *curp, <span class="enscript-type">struct</span> proc *targetp, <span class="enscript-type">int</span> *priority)
{
	<span class="enscript-type">int</span> external = 0;
	<span class="enscript-type">int</span> error = 0;
	kauth_cred_t ucred, target_cred;

	ucred = kauth_cred_get();
	target_cred = kauth_cred_proc_ref(targetp);

	<span class="enscript-keyword">if</span> (!kauth_cred_issuser(ucred) &amp;&amp; kauth_cred_getruid(ucred) &amp;&amp;
	    kauth_cred_getuid(ucred) != kauth_cred_getuid(target_cred) &amp;&amp;
	    kauth_cred_getruid(ucred) != kauth_cred_getuid(target_cred)) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	external = (curp == targetp) ? TASK_POLICY_INTERNAL : TASK_POLICY_EXTERNAL;

	*priority = proc_get_task_policy(current_task(), THREAD_NULL, external, TASK_POLICY_DARWIN_BG);

<span class="enscript-reference">out</span>:
	kauth_cred_unref(&amp;target_cred);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">do_background_proc</span>(<span class="enscript-type">struct</span> proc *curp, <span class="enscript-type">struct</span> proc *targetp, <span class="enscript-type">int</span> priority)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">curp</span>)
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span> error = 0;
	kauth_cred_t ucred;
	kauth_cred_t target_cred;
	<span class="enscript-type">int</span> external;
	<span class="enscript-type">int</span> enable;

	ucred = kauth_cred_get();
	target_cred = kauth_cred_proc_ref(targetp);

	<span class="enscript-keyword">if</span> (!kauth_cred_issuser(ucred) &amp;&amp; kauth_cred_getruid(ucred) &amp;&amp;
		kauth_cred_getuid(ucred) != kauth_cred_getuid(target_cred) &amp;&amp;
		kauth_cred_getruid(ucred) != kauth_cred_getuid(target_cred))
	{
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_proc_check_sched(curp, targetp);
	<span class="enscript-keyword">if</span> (error) 
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
#<span class="enscript-reference">endif</span>

	external = (curp == targetp) ? TASK_POLICY_INTERNAL : TASK_POLICY_EXTERNAL;

	<span class="enscript-keyword">switch</span> (priority) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_BG</span>:
			enable = TASK_POLICY_ENABLE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PRIO_DARWIN_NONUI</span>:
			<span class="enscript-comment">/* ignored for compatibility */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* TODO: EINVAL if priority != 0 */</span>
			enable = TASK_POLICY_DISABLE;
			<span class="enscript-keyword">break</span>;
	}

	proc_set_task_policy(proc_task(targetp), THREAD_NULL, external, TASK_POLICY_DARWIN_BG, enable);

<span class="enscript-reference">out</span>:
	kauth_cred_unref(&amp;target_cred);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">do_background_socket</span>(<span class="enscript-type">struct</span> proc *p, thread_t thread)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SOCKETS</span>
	<span class="enscript-type">struct</span> filedesc                     *fdp;
	<span class="enscript-type">struct</span> fileproc                     *fp;
	<span class="enscript-type">int</span>                                 i, background;

	proc_fdlock(p);

	<span class="enscript-keyword">if</span> (thread != THREAD_NULL)
		background = proc_get_effective_thread_policy(thread, TASK_POLICY_ALL_SOCKETS_BG);
	<span class="enscript-keyword">else</span>
		background = proc_get_effective_task_policy(proc_task(p), TASK_POLICY_ALL_SOCKETS_BG);

	<span class="enscript-keyword">if</span> (background) {
		<span class="enscript-comment">/*
		 * For PRIO_DARWIN_PROCESS (thread is NULL), simply mark
		 * the sockets with the background flag.  There's nothing
		 * to do here for the PRIO_DARWIN_THREAD case.
		 */</span>
		<span class="enscript-keyword">if</span> (thread == THREAD_NULL) {
			fdp = p-&gt;p_fd;

			<span class="enscript-keyword">for</span> (i = 0; i &lt; fdp-&gt;fd_nfiles; i++) {
				<span class="enscript-type">struct</span> socket       *sockp;

				fp = fdp-&gt;fd_ofiles[i];
				<span class="enscript-keyword">if</span> (fp == NULL || (fdp-&gt;fd_ofileflags[i] &amp; UF_RESERVED) != 0 ||
				    FILEGLOB_DTYPE(fp-&gt;f_fglob) != DTYPE_SOCKET) {
					<span class="enscript-keyword">continue</span>;
				}
				sockp = (<span class="enscript-type">struct</span> socket *)fp-&gt;f_fglob-&gt;fg_data;
				socket_set_traffic_mgt_flags(sockp, TRAFFIC_MGT_SO_BACKGROUND);
				sockp-&gt;so_background_thread = NULL;
			}
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* disable networking IO throttle.
		 * NOTE - It is a known limitation of the current design that we 
		 * could potentially clear TRAFFIC_MGT_SO_BACKGROUND bit for 
		 * sockets created by other threads within this process.  
		 */</span>
		fdp = p-&gt;p_fd;
		<span class="enscript-keyword">for</span> ( i = 0; i &lt; fdp-&gt;fd_nfiles; i++ ) {
			<span class="enscript-type">struct</span> socket       *sockp;

			fp = fdp-&gt;fd_ofiles[ i ];
			<span class="enscript-keyword">if</span> ( fp == NULL || (fdp-&gt;fd_ofileflags[ i ] &amp; UF_RESERVED) != 0 ||
			    FILEGLOB_DTYPE(fp-&gt;f_fglob) != DTYPE_SOCKET ) {
				<span class="enscript-keyword">continue</span>;
			}
			sockp = (<span class="enscript-type">struct</span> socket *)fp-&gt;f_fglob-&gt;fg_data;
			<span class="enscript-comment">/* skip if only clearing this thread's sockets */</span>
			<span class="enscript-keyword">if</span> ((thread) &amp;&amp; (sockp-&gt;so_background_thread != thread)) {
				<span class="enscript-keyword">continue</span>;
			}
			socket_clear_traffic_mgt_flags(sockp, TRAFFIC_MGT_SO_BACKGROUND);
			sockp-&gt;so_background_thread = NULL;
		}
	}

	proc_fdunlock(p);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">thread</span>)
#<span class="enscript-reference">endif</span>
}


<span class="enscript-comment">/*
 * do_background_thread
 * Returns:     0                       Success
 *              EPERM                   Tried to background while in vfork
 * XXX - todo - does this need a MACF hook?
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">do_background_thread</span>(<span class="enscript-type">struct</span> proc *curp, thread_t thread, <span class="enscript-type">int</span> priority)
{
	<span class="enscript-type">struct</span> uthread *ut;
	<span class="enscript-type">int</span> enable, external;
	<span class="enscript-type">int</span> rv = 0;

	ut = get_bsdthread_info(thread);

	<span class="enscript-comment">/* Backgrounding is unsupported for threads in vfork */</span>
	<span class="enscript-keyword">if</span> ((ut-&gt;uu_flag &amp; UT_VFORK) != 0)
		<span class="enscript-keyword">return</span>(EPERM);

	<span class="enscript-keyword">if</span> (thread_is_static_param(thread)) {
		<span class="enscript-keyword">return</span>(EPERM);
	}

	<span class="enscript-comment">/* Not allowed to combine QoS and DARWIN_BG, doing so strips the QoS */</span>
	<span class="enscript-keyword">if</span> (thread_has_qos_policy(thread)) {
		thread_remove_qos_policy(thread);
		rv = EIDRM;
	}

	<span class="enscript-comment">/* TODO: Fail if someone passes something besides 0 or PRIO_DARWIN_BG */</span>
	enable   = (priority == PRIO_DARWIN_BG) ? TASK_POLICY_ENABLE   : TASK_POLICY_DISABLE;
	external = (current_thread() == thread) ? TASK_POLICY_INTERNAL : TASK_POLICY_EXTERNAL;

	proc_set_task_policy_thread(curp-&gt;task, thread_tid(thread), external,
	                            TASK_POLICY_DARWIN_BG, enable);

	<span class="enscript-keyword">return</span> rv;
}


<span class="enscript-comment">/*
 * Returns:	0			Success
 *	copyin:EFAULT
 *	dosetrlimit:
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setrlimit</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> setrlimit_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> rlimit alim;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;rlp, (caddr_t)&amp;alim,
	    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> rlimit))))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">return</span> (dosetrlimit(p, uap-&gt;which, &amp;alim));
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *		EINVAL
 *		ENOMEM			Cannot copy limit structure
 *	suser:EPERM
 *
 * Notes:	EINVAL is returned both for invalid arguments, and in the
 *		case that the current usage (e.g. RLIMIT_STACK) is already
 *		in excess of the requested limit.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">dosetrlimit</span>(<span class="enscript-type">struct</span> proc *p, u_int which, <span class="enscript-type">struct</span> rlimit *limp)
{
	<span class="enscript-type">struct</span> rlimit *alimp;
	<span class="enscript-type">int</span> error;
	kern_return_t	kr;
	<span class="enscript-type">int</span> posix = (which &amp; _RLIMIT_POSIX_FLAG) ? 1 : 0;

	<span class="enscript-comment">/* Mask out POSIX flag, saved above */</span>
	which &amp;= ~_RLIMIT_POSIX_FLAG;

	<span class="enscript-keyword">if</span> (which &gt;= RLIM_NLIMITS)
		<span class="enscript-keyword">return</span> (EINVAL);

	alimp = &amp;p-&gt;p_rlimit[which];
	<span class="enscript-keyword">if</span> (limp-&gt;rlim_cur &gt; limp-&gt;rlim_max)
		<span class="enscript-keyword">return</span> EINVAL;

	<span class="enscript-keyword">if</span> (limp-&gt;rlim_cur &gt; alimp-&gt;rlim_max || 
	    limp-&gt;rlim_max &gt; alimp-&gt;rlim_max)
		<span class="enscript-keyword">if</span> ((error = suser(kauth_cred_get(), &amp;p-&gt;p_acflag))) {
			<span class="enscript-keyword">return</span> (error);
	}

	proc_limitblock(p);

	<span class="enscript-keyword">if</span> ((error = proc_limitreplace(p)) != 0) {
		proc_limitunblock(p);
		<span class="enscript-keyword">return</span>(error);
	}

	alimp = &amp;p-&gt;p_rlimit[which];
	
	<span class="enscript-keyword">switch</span> (which) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RLIMIT_CPU</span>:
		<span class="enscript-keyword">if</span> (limp-&gt;rlim_cur == RLIM_INFINITY) {
			task_vtimer_clear(p-&gt;task, TASK_VTIMER_RLIM);
			timerclear(&amp;p-&gt;p_rlim_cpu);
		}
		<span class="enscript-keyword">else</span> {
			task_absolutetime_info_data_t	tinfo;
			mach_msg_type_number_t			count;
			<span class="enscript-type">struct</span> timeval					ttv, tv;
			clock_sec_t						tv_sec;
			clock_usec_t					tv_usec;

			count = TASK_ABSOLUTETIME_INFO_COUNT;
			task_info(p-&gt;task, TASK_ABSOLUTETIME_INFO,
							  	(task_info_t)&amp;tinfo, &amp;count);
			absolutetime_to_microtime(tinfo.total_user + tinfo.total_system,
									  &amp;tv_sec, &amp;tv_usec);
			ttv.tv_sec = tv_sec;
			ttv.tv_usec = tv_usec;

			tv.tv_sec = (limp-&gt;rlim_cur &gt; __INT_MAX__ ? __INT_MAX__ : limp-&gt;rlim_cur);
			tv.tv_usec = 0;
			timersub(&amp;tv, &amp;ttv, &amp;p-&gt;p_rlim_cpu);

			timerclear(&amp;tv);
			<span class="enscript-keyword">if</span> (timercmp(&amp;p-&gt;p_rlim_cpu, &amp;tv, &gt;))
				task_vtimer_set(p-&gt;task, TASK_VTIMER_RLIM);
			<span class="enscript-keyword">else</span> {
				task_vtimer_clear(p-&gt;task, TASK_VTIMER_RLIM);

				timerclear(&amp;p-&gt;p_rlim_cpu);

				psignal(p, SIGXCPU);
			}
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RLIMIT_DATA</span>:
		<span class="enscript-keyword">if</span> (limp-&gt;rlim_cur &gt; maxdmap)
			limp-&gt;rlim_cur = maxdmap;
		<span class="enscript-keyword">if</span> (limp-&gt;rlim_max &gt; maxdmap)
			limp-&gt;rlim_max = maxdmap;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RLIMIT_STACK</span>:
		<span class="enscript-comment">/* Disallow illegal stack size instead of clipping */</span>
		<span class="enscript-keyword">if</span> (limp-&gt;rlim_cur &gt; maxsmap ||
		    limp-&gt;rlim_max &gt; maxsmap) {
			<span class="enscript-keyword">if</span> (posix) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* 
				 * 4797860 - workaround poorly written installers by 
				 * doing previous implementation (&lt; 10.5) when caller 
				 * is non-POSIX conforming.
				 */</span>
				<span class="enscript-keyword">if</span> (limp-&gt;rlim_cur &gt; maxsmap) 
					limp-&gt;rlim_cur = maxsmap;
				<span class="enscript-keyword">if</span> (limp-&gt;rlim_max &gt; maxsmap) 
					limp-&gt;rlim_max = maxsmap;
			}
		}

		<span class="enscript-comment">/*
		 * Stack is allocated to the max at exec time with only
		 * &quot;rlim_cur&quot; bytes accessible.  If stack limit is going
		 * up make more accessible, if going down make inaccessible.
		 */</span>
		<span class="enscript-keyword">if</span> (limp-&gt;rlim_cur &gt; alimp-&gt;rlim_cur) {
			user_addr_t addr;
			user_size_t size;
			
				<span class="enscript-comment">/* grow stack */</span>
				size = round_page_64(limp-&gt;rlim_cur);
				size -= round_page_64(alimp-&gt;rlim_cur);

			addr = p-&gt;user_stack - round_page_64(limp-&gt;rlim_cur);
			kr = mach_vm_protect(current_map(), 
					     addr, size,
					     FALSE, VM_PROT_DEFAULT);
			<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
				error =  EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (limp-&gt;rlim_cur &lt; alimp-&gt;rlim_cur) {
			user_addr_t addr;
			user_size_t size;
			user_addr_t cur_sp;

				<span class="enscript-comment">/* shrink stack */</span>

			<span class="enscript-comment">/*
			 * First check if new stack limit would agree
			 * with current stack usage.
			 * Get the current thread's stack pointer...
			 */</span>
			cur_sp = thread_adjuserstack(current_thread(),
						     0);
			<span class="enscript-keyword">if</span> (cur_sp &lt;= p-&gt;user_stack &amp;&amp;
			    cur_sp &gt; (p-&gt;user_stack -
				      round_page_64(alimp-&gt;rlim_cur))) {
				<span class="enscript-comment">/* stack pointer is in main stack */</span>
				<span class="enscript-keyword">if</span> (cur_sp &lt;= (p-&gt;user_stack -
					       round_page_64(limp-&gt;rlim_cur))) {
					<span class="enscript-comment">/*
					 * New limit would cause
					 * current usage to be invalid:
					 * reject new limit.
					 */</span>
					error =  EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* not on the main stack: reject */</span>
				error =  EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
				
			size = round_page_64(alimp-&gt;rlim_cur);
			size -= round_page_64(limp-&gt;rlim_cur);

			addr = p-&gt;user_stack - round_page_64(alimp-&gt;rlim_cur);

			kr = mach_vm_protect(current_map(),
					     addr, size,
					     FALSE, VM_PROT_NONE);
			<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
				error =  EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* no change ... */</span>
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RLIMIT_NOFILE</span>:
		<span class="enscript-comment">/* 
		 * Only root can set the maxfiles limits, as it is
		 * systemwide resource.  If we are expecting POSIX behavior,
		 * instead of clamping the value, return EINVAL.  We do this
		 * because historically, people have been able to attempt to
		 * set RLIM_INFINITY to get &quot;whatever the maximum is&quot;.
		*/</span>
		<span class="enscript-keyword">if</span> ( kauth_cred_issuser(kauth_cred_get()) ) {
			<span class="enscript-keyword">if</span> (limp-&gt;rlim_cur != alimp-&gt;rlim_cur &amp;&amp;
			    limp-&gt;rlim_cur &gt; (rlim_t)maxfiles) {
			    	<span class="enscript-keyword">if</span> (posix) {
					error =  EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				limp-&gt;rlim_cur = maxfiles;
			}
			<span class="enscript-keyword">if</span> (limp-&gt;rlim_max != alimp-&gt;rlim_max &amp;&amp;
			    limp-&gt;rlim_max &gt; (rlim_t)maxfiles)
				limp-&gt;rlim_max = maxfiles;
		}
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (limp-&gt;rlim_cur != alimp-&gt;rlim_cur &amp;&amp;
			    limp-&gt;rlim_cur &gt; (rlim_t)maxfilesperproc) {
			    	<span class="enscript-keyword">if</span> (posix) {
					error =  EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				limp-&gt;rlim_cur = maxfilesperproc;
			}
			<span class="enscript-keyword">if</span> (limp-&gt;rlim_max != alimp-&gt;rlim_max &amp;&amp;
			    limp-&gt;rlim_max &gt; (rlim_t)maxfilesperproc)
				limp-&gt;rlim_max = maxfilesperproc;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RLIMIT_NPROC</span>:
		<span class="enscript-comment">/* 
		 * Only root can set to the maxproc limits, as it is
		 * systemwide resource; all others are limited to
		 * maxprocperuid (presumably less than maxproc).
		 */</span>
		<span class="enscript-keyword">if</span> ( kauth_cred_issuser(kauth_cred_get()) ) {
			<span class="enscript-keyword">if</span> (limp-&gt;rlim_cur &gt; (rlim_t)maxproc)
				limp-&gt;rlim_cur = maxproc;
			<span class="enscript-keyword">if</span> (limp-&gt;rlim_max &gt; (rlim_t)maxproc)
				limp-&gt;rlim_max = maxproc;
		} 
		<span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (limp-&gt;rlim_cur &gt; (rlim_t)maxprocperuid)
				limp-&gt;rlim_cur = maxprocperuid;
			<span class="enscript-keyword">if</span> (limp-&gt;rlim_max &gt; (rlim_t)maxprocperuid)
				limp-&gt;rlim_max = maxprocperuid;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RLIMIT_MEMLOCK</span>:
		<span class="enscript-comment">/*
		 * Tell the Mach VM layer about the new limit value.
		 */</span>

		vm_map_set_user_wire_limit(current_map(), limp-&gt;rlim_cur);
		<span class="enscript-keyword">break</span>;
		
	} <span class="enscript-comment">/* switch... */</span>
	proc_lock(p);
	*alimp = *limp;
	proc_unlock(p);
	error = 0;
<span class="enscript-reference">out</span>:
	proc_limitunblock(p);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getrlimit</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> getrlimit_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> rlimit lim;

	<span class="enscript-comment">/*
	 * Take out flag now in case we need to use it to trigger variant
	 * behaviour later.
	 */</span>
	uap-&gt;which &amp;= ~_RLIMIT_POSIX_FLAG;

	<span class="enscript-keyword">if</span> (uap-&gt;which &gt;= RLIM_NLIMITS)
		<span class="enscript-keyword">return</span> (EINVAL);
	proc_limitget(p, uap-&gt;which, &amp;lim);
	<span class="enscript-keyword">return</span> (copyout((caddr_t)&amp;lim,
	    		uap-&gt;rlp, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> rlimit)));
}

<span class="enscript-comment">/*
 * Transform the running time and tick information in proc p into user,
 * system, and interrupt time usage.
 */</span>
<span class="enscript-comment">/* No lock on proc is held for this.. */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">calcru</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> timeval *up, <span class="enscript-type">struct</span> timeval *sp, <span class="enscript-type">struct</span> timeval *ip)
{
	task_t			task;

	timerclear(up);
	timerclear(sp);
	<span class="enscript-keyword">if</span> (ip != NULL)
		timerclear(ip);

	task = p-&gt;task;
	<span class="enscript-keyword">if</span> (task) {
		mach_task_basic_info_data_t tinfo;
		task_thread_times_info_data_t ttimesinfo;
		task_events_info_data_t teventsinfo;
		mach_msg_type_number_t task_info_count, task_ttimes_count;
		mach_msg_type_number_t task_events_count;
		<span class="enscript-type">struct</span> timeval ut,st;

		task_info_count	= MACH_TASK_BASIC_INFO_COUNT;
		task_info(task, MACH_TASK_BASIC_INFO,
			  (task_info_t)&amp;tinfo, &amp;task_info_count);
		ut.tv_sec = tinfo.user_time.seconds;
		ut.tv_usec = tinfo.user_time.microseconds;
		st.tv_sec = tinfo.system_time.seconds;
		st.tv_usec = tinfo.system_time.microseconds;
		timeradd(&amp;ut, up, up);
		timeradd(&amp;st, sp, sp);

		task_ttimes_count = TASK_THREAD_TIMES_INFO_COUNT;
		task_info(task, TASK_THREAD_TIMES_INFO,
			  (task_info_t)&amp;ttimesinfo, &amp;task_ttimes_count);

		ut.tv_sec = ttimesinfo.user_time.seconds;
		ut.tv_usec = ttimesinfo.user_time.microseconds;
		st.tv_sec = ttimesinfo.system_time.seconds;
		st.tv_usec = ttimesinfo.system_time.microseconds;
		timeradd(&amp;ut, up, up);
		timeradd(&amp;st, sp, sp);

		task_events_count = TASK_EVENTS_INFO_COUNT;
		task_info(task, TASK_EVENTS_INFO,
			  (task_info_t)&amp;teventsinfo, &amp;task_events_count);

		<span class="enscript-comment">/*
		 * No need to lock &quot;p&quot;:  this does not need to be
		 * completely consistent, right ?
		 */</span>
		p-&gt;p_stats-&gt;p_ru.ru_minflt = (teventsinfo.faults -
					      teventsinfo.pageins);
		p-&gt;p_stats-&gt;p_ru.ru_majflt = teventsinfo.pageins;
		p-&gt;p_stats-&gt;p_ru.ru_nivcsw = (teventsinfo.csw -
					      p-&gt;p_stats-&gt;p_ru.ru_nvcsw);
		<span class="enscript-keyword">if</span> (p-&gt;p_stats-&gt;p_ru.ru_nivcsw &lt; 0)
			p-&gt;p_stats-&gt;p_ru.ru_nivcsw = 0;

		p-&gt;p_stats-&gt;p_ru.ru_maxrss = tinfo.resident_size_max;
	}
}

__private_extern__ <span class="enscript-type">void</span> munge_user64_rusage(<span class="enscript-type">struct</span> rusage *a_rusage_p, <span class="enscript-type">struct</span> user64_rusage *a_user_rusage_p);
__private_extern__ <span class="enscript-type">void</span> munge_user32_rusage(<span class="enscript-type">struct</span> rusage *a_rusage_p, <span class="enscript-type">struct</span> user32_rusage *a_user_rusage_p);

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getrusage</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> getrusage_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> rusage *rup, rubuf;
	<span class="enscript-type">struct</span> user64_rusage rubuf64;
	<span class="enscript-type">struct</span> user32_rusage rubuf32;
	size_t retsize = <span class="enscript-keyword">sizeof</span>(rubuf);			<span class="enscript-comment">/* default: 32 bits */</span>
	caddr_t retbuf = (caddr_t)&amp;rubuf;		<span class="enscript-comment">/* default: 32 bits */</span>
	<span class="enscript-type">struct</span> timeval utime;
	<span class="enscript-type">struct</span> timeval stime;


	<span class="enscript-keyword">switch</span> (uap-&gt;who) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RUSAGE_SELF</span>:
		calcru(p, &amp;utime, &amp;stime, NULL);
		proc_lock(p);
		rup = &amp;p-&gt;p_stats-&gt;p_ru;
		rup-&gt;ru_utime = utime;
		rup-&gt;ru_stime = stime;

		rubuf = *rup;
		proc_unlock(p);

		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RUSAGE_CHILDREN</span>:
		proc_lock(p);
		rup = &amp;p-&gt;p_stats-&gt;p_cru;
		rubuf = *rup;
		proc_unlock(p);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		retsize = <span class="enscript-keyword">sizeof</span>(rubuf64);
		retbuf = (caddr_t)&amp;rubuf64;
		munge_user64_rusage(&amp;rubuf, &amp;rubuf64);
	} <span class="enscript-keyword">else</span> {
		retsize = <span class="enscript-keyword">sizeof</span>(rubuf32);
		retbuf = (caddr_t)&amp;rubuf32;
		munge_user32_rusage(&amp;rubuf, &amp;rubuf32);
	}

	<span class="enscript-keyword">return</span> (copyout(retbuf, uap-&gt;rusage, retsize));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ruadd</span>(<span class="enscript-type">struct</span> rusage *ru, <span class="enscript-type">struct</span> rusage *ru2)
{
	<span class="enscript-type">long</span> *ip, *ip2;
	<span class="enscript-type">long</span> i;

	timeradd(&amp;ru-&gt;ru_utime, &amp;ru2-&gt;ru_utime, &amp;ru-&gt;ru_utime);
	timeradd(&amp;ru-&gt;ru_stime, &amp;ru2-&gt;ru_stime, &amp;ru-&gt;ru_stime);
	<span class="enscript-keyword">if</span> (ru-&gt;ru_maxrss &lt; ru2-&gt;ru_maxrss)
		ru-&gt;ru_maxrss = ru2-&gt;ru_maxrss;
	ip = &amp;ru-&gt;ru_first; ip2 = &amp;ru2-&gt;ru_first;
	<span class="enscript-keyword">for</span> (i = &amp;ru-&gt;ru_last - &amp;ru-&gt;ru_first; i &gt;= 0; i--)
		*ip++ += *ip2++;
}

<span class="enscript-comment">/*
 * Add the rusage stats of child in parent.
 * 
 * It adds rusage statistics of child process and statistics of all its
 * children to its parent.
 *
 * Note: proc lock of parent should be held while calling this function.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">update_rusage_info_child</span>(<span class="enscript-type">struct</span> rusage_info_child *ri, rusage_info_current *ri_current)
{
	ri-&gt;ri_child_user_time += (ri_current-&gt;ri_user_time +
					ri_current-&gt;ri_child_user_time);
	ri-&gt;ri_child_system_time += (ri_current-&gt;ri_system_time +
					ri_current-&gt;ri_child_system_time);
	ri-&gt;ri_child_pkg_idle_wkups += (ri_current-&gt;ri_pkg_idle_wkups +
					ri_current-&gt;ri_child_pkg_idle_wkups);
	ri-&gt;ri_child_interrupt_wkups += (ri_current-&gt;ri_interrupt_wkups +
					ri_current-&gt;ri_child_interrupt_wkups);
	ri-&gt;ri_child_pageins += (ri_current-&gt;ri_pageins +
					ri_current-&gt;ri_child_pageins);
	ri-&gt;ri_child_elapsed_abstime += ((ri_current-&gt;ri_proc_exit_abstime -
		ri_current-&gt;ri_proc_start_abstime) + ri_current-&gt;ri_child_elapsed_abstime);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_limitget</span>(proc_t p, <span class="enscript-type">int</span> which, <span class="enscript-type">struct</span> rlimit * limp)
{
	proc_list_lock();
	limp-&gt;rlim_cur = p-&gt;p_rlimit[which].rlim_cur;
	limp-&gt;rlim_max = p-&gt;p_rlimit[which].rlim_max;
	proc_list_unlock();
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_limitdrop</span>(proc_t p, <span class="enscript-type">int</span> exiting)
{
	<span class="enscript-type">struct</span>  plimit * freelim = NULL;
	<span class="enscript-type">struct</span>  plimit * freeoldlim = NULL;

	proc_list_lock();

	<span class="enscript-keyword">if</span> (--p-&gt;p_limit-&gt;pl_refcnt == 0) { 
		freelim = p-&gt;p_limit;
		p-&gt;p_limit = NULL;
	}
	<span class="enscript-keyword">if</span> ((exiting != 0) &amp;&amp; (p-&gt;p_olimit != NULL) &amp;&amp; (--p-&gt;p_olimit-&gt;pl_refcnt == 0)) {
		freeoldlim =  p-&gt;p_olimit;
		p-&gt;p_olimit = NULL;
	}

	proc_list_unlock();
	<span class="enscript-keyword">if</span> (freelim != NULL)
		FREE_ZONE(freelim, <span class="enscript-keyword">sizeof</span> *p-&gt;p_limit, M_PLIMIT);
	<span class="enscript-keyword">if</span> (freeoldlim != NULL)
		FREE_ZONE(freeoldlim, <span class="enscript-keyword">sizeof</span> *p-&gt;p_olimit, M_PLIMIT);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_limitfork</span>(proc_t parent, proc_t child)
{
	proc_list_lock();
	child-&gt;p_limit = parent-&gt;p_limit;
	child-&gt;p_limit-&gt;pl_refcnt++;
	child-&gt;p_olimit = NULL;
	proc_list_unlock();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_limitblock</span>(proc_t p)
{
	proc_lock(p);
	<span class="enscript-keyword">while</span> (p-&gt;p_lflag &amp; P_LLIMCHANGE) {
		p-&gt;p_lflag |= P_LLIMWAIT;
		msleep(&amp;p-&gt;p_olimit, &amp;p-&gt;p_mlock, 0, <span class="enscript-string">&quot;proc_limitblock&quot;</span>, NULL);
	}
	p-&gt;p_lflag |= P_LLIMCHANGE;
	proc_unlock(p);

}


<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_limitunblock</span>(proc_t p)
{
	proc_lock(p);
	p-&gt;p_lflag &amp;= ~P_LLIMCHANGE;
	<span class="enscript-keyword">if</span> (p-&gt;p_lflag &amp; P_LLIMWAIT) {
		p-&gt;p_lflag &amp;= ~P_LLIMWAIT;
		wakeup(&amp;p-&gt;p_olimit);
	}
	proc_unlock(p);
}

<span class="enscript-comment">/* This is called behind serialization provided by proc_limitblock/unlbock */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_limitreplace</span>(proc_t p)
{
	<span class="enscript-type">struct</span> plimit *copy;


	proc_list_lock();

	<span class="enscript-keyword">if</span> (p-&gt;p_limit-&gt;pl_refcnt == 1) {
		proc_list_unlock();
		<span class="enscript-keyword">return</span>(0);
	}
		
	proc_list_unlock();

	MALLOC_ZONE(copy, <span class="enscript-type">struct</span> plimit *,
			<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> plimit), M_PLIMIT, M_WAITOK);
	<span class="enscript-keyword">if</span> (copy == NULL) {
		<span class="enscript-keyword">return</span>(ENOMEM);
	}

	proc_list_lock();
	bcopy(p-&gt;p_limit-&gt;pl_rlimit, copy-&gt;pl_rlimit,
	    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> rlimit) * RLIM_NLIMITS);
	copy-&gt;pl_refcnt = 1;
	<span class="enscript-comment">/* hang on to reference to old till process exits */</span>
	p-&gt;p_olimit = p-&gt;p_limit;
	p-&gt;p_limit = copy;
	proc_list_unlock();

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * iopolicysys
 *
 * Description:	System call MUX for use in manipulating I/O policy attributes of the current process or thread
 *
 * Parameters:	cmd				Policy command
 *		arg				Pointer to policy arguments
 *
 * Returns:	0				Success
 *		EINVAL				Invalid command or invalid policy arguments
 *
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">iopolicysys_disk</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">int</span> cmd, <span class="enscript-type">int</span> scope, <span class="enscript-type">int</span> policy, <span class="enscript-type">struct</span> _iopol_param_t *iop_param);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">iopolicysys_vfs</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">int</span> cmd, <span class="enscript-type">int</span> scope, <span class="enscript-type">int</span> policy, <span class="enscript-type">struct</span> _iopol_param_t *iop_param);

<span class="enscript-type">int</span>
<span class="enscript-function-name">iopolicysys</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> iopolicysys_args *uap, int32_t *retval)
{
	<span class="enscript-type">int</span>     error = 0;
	<span class="enscript-type">struct</span> _iopol_param_t iop_param;

	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;arg, &amp;iop_param, <span class="enscript-keyword">sizeof</span>(iop_param))) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">switch</span> (iop_param.iop_iotype) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_TYPE_DISK</span>:
			error = iopolicysys_disk(p, uap-&gt;cmd, iop_param.iop_scope, iop_param.iop_policy, &amp;iop_param);
			<span class="enscript-keyword">if</span> (error == EIDRM) {
				*retval = -2;
				error = 0;
			}
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_TYPE_VFS_HFS_CASE_SENSITIVITY</span>:
			error = iopolicysys_vfs(p, uap-&gt;cmd, iop_param.iop_scope, iop_param.iop_policy, &amp;iop_param);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Individual iotype handlers are expected to update iop_param, if requested with a GET command */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;cmd == IOPOL_CMD_GET) {
		error = copyout((caddr_t)&amp;iop_param, uap-&gt;arg, <span class="enscript-keyword">sizeof</span>(iop_param));
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">iopolicysys_disk</span>(<span class="enscript-type">struct</span> proc *p __unused, <span class="enscript-type">int</span> cmd, <span class="enscript-type">int</span> scope, <span class="enscript-type">int</span> policy, <span class="enscript-type">struct</span> _iopol_param_t *iop_param)
{
	<span class="enscript-type">int</span>			error = 0;
	thread_t	thread;
	<span class="enscript-type">int</span>			policy_flavor;

	<span class="enscript-comment">/* Validate scope */</span>
	<span class="enscript-keyword">switch</span> (scope) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_SCOPE_PROCESS</span>:
			thread = THREAD_NULL;
			policy_flavor = TASK_POLICY_IOPOL;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_SCOPE_THREAD</span>:
			thread = current_thread();
			policy_flavor = TASK_POLICY_IOPOL;

			<span class="enscript-comment">/* Not allowed to combine QoS and (non-PASSIVE) IO policy, doing so strips the QoS */</span>
			<span class="enscript-keyword">if</span> (cmd == IOPOL_CMD_SET &amp;&amp; thread_has_qos_policy(thread)) {
				<span class="enscript-keyword">switch</span> (policy) {
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_DEFAULT</span>:
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_PASSIVE</span>:
						<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_UTILITY</span>:
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_THROTTLE</span>:
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_IMPORTANT</span>:
					<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_STANDARD</span>:
						<span class="enscript-keyword">if</span> (!thread_is_static_param(thread)) {
							thread_remove_qos_policy(thread);
							<span class="enscript-comment">/*
							 * This is not an error case, this is to return a marker to user-space that
							 * we stripped the thread of its QoS class.
							 */</span>
							error = EIDRM;
							<span class="enscript-keyword">break</span>;
						}
						<span class="enscript-comment">/* otherwise, fall through to the error case. */</span>
					<span class="enscript-reference">default</span>:
						error = EINVAL;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_SCOPE_DARWIN_BG</span>:
			thread = THREAD_NULL;
			policy_flavor = TASK_POLICY_DARWIN_BG_IOPOL;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Validate policy */</span>
	<span class="enscript-keyword">if</span> (cmd == IOPOL_CMD_SET) {
		<span class="enscript-keyword">switch</span> (policy) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_DEFAULT</span>:
				<span class="enscript-keyword">if</span> (scope == IOPOL_SCOPE_DARWIN_BG) {
					<span class="enscript-comment">/* the current default BG throttle level is UTILITY */</span>
					policy = IOPOL_UTILITY;
				} <span class="enscript-keyword">else</span> {
					policy = IOPOL_IMPORTANT;
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_UTILITY</span>:
				<span class="enscript-comment">/* fall-through */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_THROTTLE</span>:
				<span class="enscript-comment">/* These levels are OK */</span>
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_IMPORTANT</span>:
				<span class="enscript-comment">/* fall-through */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_STANDARD</span>:
				<span class="enscript-comment">/* fall-through */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_PASSIVE</span>:
				<span class="enscript-keyword">if</span> (scope == IOPOL_SCOPE_DARWIN_BG) {
					<span class="enscript-comment">/* These levels are invalid for BG */</span>
					error = EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* OK for other scopes */</span>
				}
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-comment">/* Perform command */</span>
	<span class="enscript-keyword">switch</span>(cmd) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_CMD_SET</span>:
			proc_set_task_policy(current_task(), thread,
								 TASK_POLICY_INTERNAL, policy_flavor,
								 policy);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_CMD_GET</span>:
			policy = proc_get_task_policy(current_task(), thread,
										  TASK_POLICY_INTERNAL, policy_flavor);

			iop_param-&gt;iop_policy = policy;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			error = EINVAL; <span class="enscript-comment">/* unknown command */</span>
			<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">iopolicysys_vfs</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">int</span> cmd, <span class="enscript-type">int</span> scope, <span class="enscript-type">int</span> policy, <span class="enscript-type">struct</span> _iopol_param_t *iop_param)
{
	<span class="enscript-type">int</span>			error = 0;

	<span class="enscript-comment">/* Validate scope */</span>
	<span class="enscript-keyword">switch</span> (scope) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_SCOPE_PROCESS</span>:
			<span class="enscript-comment">/* Only process OK */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Validate policy */</span>
	<span class="enscript-keyword">if</span> (cmd == IOPOL_CMD_SET) {
		<span class="enscript-keyword">switch</span> (policy) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_VFS_HFS_CASE_SENSITIVITY_DEFAULT</span>:
				<span class="enscript-comment">/* fall-through */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_VFS_HFS_CASE_SENSITIVITY_FORCE_CASE_SENSITIVE</span>:
				<span class="enscript-comment">/* These policies are OK */</span>
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-comment">/* Perform command */</span>
	<span class="enscript-keyword">switch</span>(cmd) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_CMD_SET</span>:
			<span class="enscript-keyword">if</span> (0 == kauth_cred_issuser(kauth_cred_get())) {
				<span class="enscript-comment">/* If it's a non-root process, it needs to have the entitlement to set the policy */</span>
				boolean_t entitled = FALSE;
				entitled = IOTaskHasEntitlement(current_task(), <span class="enscript-string">&quot;com.apple.private.iopol.case_sensitivity&quot;</span>);
				<span class="enscript-keyword">if</span> (!entitled) {
					error = EPERM;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			}

			<span class="enscript-keyword">switch</span> (policy) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_VFS_HFS_CASE_SENSITIVITY_DEFAULT</span>:
					OSBitAndAtomic16(~((uint32_t)P_VFS_IOPOLICY_FORCE_HFS_CASE_SENSITIVITY), &amp;p-&gt;p_vfs_iopolicy);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_VFS_HFS_CASE_SENSITIVITY_FORCE_CASE_SENSITIVE</span>:
					OSBitOrAtomic16((uint32_t)P_VFS_IOPOLICY_FORCE_HFS_CASE_SENSITIVITY, &amp;p-&gt;p_vfs_iopolicy);
					<span class="enscript-keyword">break</span>;
				<span class="enscript-reference">default</span>:
					error = EINVAL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">IOPOL_CMD_GET</span>:
			iop_param-&gt;iop_policy = (p-&gt;p_vfs_iopolicy &amp; P_VFS_IOPOLICY_FORCE_HFS_CASE_SENSITIVITY)
				? IOPOL_VFS_HFS_CASE_SENSITIVITY_FORCE_CASE_SENSITIVE
				: IOPOL_VFS_HFS_CASE_SENSITIVITY_DEFAULT;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			error = EINVAL; <span class="enscript-comment">/* unknown command */</span>
			<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* BSD call back function for task_policy */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_apply_task_networkbg</span>(<span class="enscript-type">void</span> * bsd_info, thread_t thread);

<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_apply_task_networkbg</span>(<span class="enscript-type">void</span> * bsd_info, thread_t thread)
{
	assert(bsd_info != PROC_NULL);

	pid_t pid = proc_pid((proc_t)bsd_info);

	proc_t p = proc_find(pid);

	<span class="enscript-keyword">if</span> (p != PROC_NULL) {
		assert(p == (proc_t)bsd_info);

		do_background_socket(p, thread);
		proc_rele(p);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">gather_rusage_info</span>(proc_t p, rusage_info_current *ru, <span class="enscript-type">int</span> flavor)
{
	<span class="enscript-type">struct</span> rusage_info_child *ri_child;

	assert(p-&gt;p_stats != NULL);
	<span class="enscript-keyword">switch</span>(flavor) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RUSAGE_INFO_V3</span>:
		fill_task_qos_rusage(p-&gt;task, ru);
		fill_task_billed_usage(p-&gt;task, ru);
		<span class="enscript-comment">/* fall through */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RUSAGE_INFO_V2</span>:
		fill_task_io_rusage(p-&gt;task, ru);
		<span class="enscript-comment">/* fall through */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RUSAGE_INFO_V1</span>:
		<span class="enscript-comment">/*
		 * p-&gt;p_stats-&gt;ri_child statistics are protected under proc lock.
		 */</span>
		proc_lock(p);
		
		ri_child = &amp;(p-&gt;p_stats-&gt;ri_child);
		ru-&gt;ri_child_user_time = ri_child-&gt;ri_child_user_time;
		ru-&gt;ri_child_system_time = ri_child-&gt;ri_child_system_time;
		ru-&gt;ri_child_pkg_idle_wkups = ri_child-&gt;ri_child_pkg_idle_wkups;
		ru-&gt;ri_child_interrupt_wkups = ri_child-&gt;ri_child_interrupt_wkups;
		ru-&gt;ri_child_pageins = ri_child-&gt;ri_child_pageins;
		ru-&gt;ri_child_elapsed_abstime = ri_child-&gt;ri_child_elapsed_abstime;

		proc_unlock(p);
		<span class="enscript-comment">/* fall through */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RUSAGE_INFO_V0</span>:
		proc_getexecutableuuid(p, (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)&amp;ru-&gt;ri_uuid, <span class="enscript-keyword">sizeof</span> (ru-&gt;ri_uuid));
		fill_task_rusage(p-&gt;task, ru);
		ru-&gt;ri_proc_start_abstime = p-&gt;p_stats-&gt;ps_start;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">rusage_info_conversion</span>(rusage_info_t ri_info, rusage_info_current *ri_current, <span class="enscript-type">int</span> flavor)
{
	<span class="enscript-type">struct</span> rusage_info_v0 *ri_v0;
	<span class="enscript-type">struct</span> rusage_info_v1 *ri_v1;
	<span class="enscript-type">struct</span> rusage_info_v2 *ri_v2;

	<span class="enscript-keyword">switch</span> (flavor) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RUSAGE_INFO_V2</span>:
		ri_v2 = (<span class="enscript-type">struct</span> rusage_info_v2 *)ri_info;
		ri_v2-&gt;ri_diskio_bytesread = ri_current-&gt;ri_diskio_bytesread;
		ri_v2-&gt;ri_diskio_byteswritten = ri_current-&gt;ri_diskio_byteswritten;
		<span class="enscript-comment">/* fall through */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RUSAGE_INFO_V1</span>:
		ri_v1 = (<span class="enscript-type">struct</span> rusage_info_v1 *)ri_info;
		ri_v1-&gt;ri_child_user_time = ri_current-&gt;ri_child_user_time;
		ri_v1-&gt;ri_child_system_time = ri_current-&gt;ri_child_system_time;
		ri_v1-&gt;ri_child_pkg_idle_wkups = ri_current-&gt;ri_child_pkg_idle_wkups;
		ri_v1-&gt;ri_child_interrupt_wkups = ri_current-&gt;ri_child_interrupt_wkups; 
		ri_v1-&gt;ri_child_pageins = ri_current-&gt;ri_child_pageins;
		ri_v1-&gt;ri_child_elapsed_abstime = ri_current-&gt;ri_child_elapsed_abstime;
		<span class="enscript-comment">/* fall through */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RUSAGE_INFO_V0</span>:
		ri_v0 = (<span class="enscript-type">struct</span> rusage_info_v0 *)ri_info;
		memcpy(&amp;ri_v0-&gt;ri_uuid[0], &amp;ri_current-&gt;ri_uuid[0], <span class="enscript-keyword">sizeof</span>(ri_v0-&gt;ri_uuid));	
		ri_v0-&gt;ri_user_time = ri_current-&gt;ri_user_time;
		ri_v0-&gt;ri_system_time = ri_current-&gt;ri_system_time;
		ri_v0-&gt;ri_pkg_idle_wkups = ri_current-&gt;ri_pkg_idle_wkups;
		ri_v0-&gt;ri_interrupt_wkups = ri_current-&gt;ri_interrupt_wkups;
		ri_v0-&gt;ri_pageins = ri_current-&gt;ri_pageins;
		ri_v0-&gt;ri_wired_size = ri_current-&gt;ri_wired_size;
		ri_v0-&gt;ri_resident_size = ri_current-&gt;ri_resident_size;
		ri_v0-&gt;ri_phys_footprint = ri_current-&gt;ri_phys_footprint;
		ri_v0-&gt;ri_proc_start_abstime = ri_current-&gt;ri_proc_start_abstime;
		ri_v0-&gt;ri_proc_exit_abstime = ri_current-&gt;ri_proc_exit_abstime;

		<span class="enscript-keyword">break</span>;
	
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_get_rusage</span>(proc_t p, <span class="enscript-type">int</span> flavor, user_addr_t buffer, __unused <span class="enscript-type">int</span> is_zombie)
{
	<span class="enscript-type">struct</span> rusage_info_v0 ri_v0;
	<span class="enscript-type">struct</span> rusage_info_v1 ri_v1;
	<span class="enscript-type">struct</span> rusage_info_v2 ri_v2;
	<span class="enscript-type">struct</span> rusage_info_v3 ri_v3;

	rusage_info_current ri_current;

	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (flavor) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RUSAGE_INFO_V0</span>:
		<span class="enscript-comment">/*
		 * If task is still alive, collect info from the live task itself.
		 * Otherwise, look to the cached info in the zombie proc.
		 */</span>
		<span class="enscript-keyword">if</span> (p-&gt;p_ru == NULL) {
			gather_rusage_info(p, &amp;ri_current, flavor);
			ri_current.ri_proc_exit_abstime = 0;
			rusage_info_conversion(&amp;ri_v0, &amp;ri_current, flavor);
		} <span class="enscript-keyword">else</span> {
			rusage_info_conversion(&amp;ri_v0, &amp;p-&gt;p_ru-&gt;ri, flavor);
		}
		error = copyout(&amp;ri_v0, buffer, <span class="enscript-keyword">sizeof</span> (ri_v0));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RUSAGE_INFO_V1</span>:
		<span class="enscript-comment">/*
		 * If task is still alive, collect info from the live task itself.
		 * Otherwise, look to the cached info in the zombie proc.
		 */</span>
		<span class="enscript-keyword">if</span> (p-&gt;p_ru == NULL) {
			gather_rusage_info(p, &amp;ri_current, flavor);
			ri_current.ri_proc_exit_abstime = 0;
			rusage_info_conversion(&amp;ri_v1, &amp;ri_current, flavor);
		} <span class="enscript-keyword">else</span> {
			rusage_info_conversion(&amp;ri_v1, &amp;p-&gt;p_ru-&gt;ri, flavor);
		}
		error = copyout(&amp;ri_v1, buffer, <span class="enscript-keyword">sizeof</span> (ri_v1));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RUSAGE_INFO_V2</span>:
		<span class="enscript-comment">/*
		 * If task is still alive, collect info from the live task itself.
		 * Otherwise, look to the cached info in the zombie proc.
		 */</span>
		<span class="enscript-keyword">if</span> (p-&gt;p_ru == NULL) {
			gather_rusage_info(p, &amp;ri_current, flavor);
			ri_current.ri_proc_exit_abstime = 0;
			rusage_info_conversion(&amp;ri_v2, &amp;ri_current, flavor);
		} <span class="enscript-keyword">else</span> {
			rusage_info_conversion(&amp;ri_v2, &amp;p-&gt;p_ru-&gt;ri, flavor);
		}
		error = copyout(&amp;ri_v2, buffer, <span class="enscript-keyword">sizeof</span> (ri_v2));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">RUSAGE_INFO_V3</span>:
		<span class="enscript-comment">/*
		 * If task is still alive, collect info from the live task itself.
		 * Otherwise, look to the cached info in the zombie proc.
		 */</span>
		<span class="enscript-keyword">if</span> (p-&gt;p_ru == NULL) {
			gather_rusage_info(p, &amp;ri_v3, flavor);
			ri_v3.ri_proc_exit_abstime = 0;
		} <span class="enscript-keyword">else</span> {
			ri_v3 = p-&gt;p_ru-&gt;ri;
		}
		error = copyout(&amp;ri_v3, buffer, <span class="enscript-keyword">sizeof</span> (ri_v3));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);	
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mach_to_bsd_rv</span>(<span class="enscript-type">int</span> mach_rv)
{
	<span class="enscript-type">int</span> bsd_rv = 0;

	<span class="enscript-keyword">switch</span> (mach_rv) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SUCCESS</span>:
		bsd_rv = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_INVALID_ARGUMENT</span>:
		bsd_rv = EINVAL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;unknown error %#x&quot;</span>, mach_rv);
	}

	<span class="enscript-keyword">return</span> bsd_rv;
}

<span class="enscript-comment">/*
 * Resource limit controls
 *
 * uap-&gt;flavor available flavors:
 *
 *     RLIMIT_WAKEUPS_MONITOR
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_rlimit_control</span>(__unused <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> proc_rlimit_control_args *uap, __unused int32_t *retval)
{
	proc_t	targetp;
	<span class="enscript-type">int</span> 	error = 0;
	<span class="enscript-type">struct</span>	proc_rlimit_control_wakeupmon wakeupmon_args;
	uint32_t cpumon_flags;
	uint32_t cpulimits_flags;
	kauth_cred_t my_cred, target_cred;

	<span class="enscript-comment">/* -1 implicitly means our own process (perhaps even the current thread for per-thread attributes) */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;pid == -1) {
		targetp = proc_self();
	} <span class="enscript-keyword">else</span> {
		targetp = proc_find(uap-&gt;pid);
	}

	<span class="enscript-comment">/* proc_self() can return NULL for an exiting process */</span>
	<span class="enscript-keyword">if</span> (targetp == PROC_NULL) {
		<span class="enscript-keyword">return</span> (ESRCH);
	}

	my_cred = kauth_cred_get();
	target_cred = kauth_cred_proc_ref(targetp);

	<span class="enscript-keyword">if</span> (!kauth_cred_issuser(my_cred) &amp;&amp; kauth_cred_getruid(my_cred) &amp;&amp;
	    kauth_cred_getuid(my_cred) != kauth_cred_getuid(target_cred) &amp;&amp;
	    kauth_cred_getruid(my_cred) != kauth_cred_getuid(target_cred)) {
		proc_rele(targetp);
		kauth_cred_unref(&amp;target_cred);
		<span class="enscript-keyword">return</span> (EACCES);
	}

	<span class="enscript-keyword">switch</span> (uap-&gt;flavor) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RLIMIT_WAKEUPS_MONITOR</span>:
		<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;arg, &amp;wakeupmon_args, <span class="enscript-keyword">sizeof</span> (wakeupmon_args))) != 0) {
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> ((error = mach_to_bsd_rv(task_wakeups_monitor_ctl(targetp-&gt;task, &amp;wakeupmon_args.wm_flags,
		     &amp;wakeupmon_args.wm_rate))) != 0) {
			<span class="enscript-keyword">break</span>;
		}
		error = copyout(&amp;wakeupmon_args, uap-&gt;arg, <span class="enscript-keyword">sizeof</span> (wakeupmon_args));
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RLIMIT_CPU_USAGE_MONITOR</span>:
		cpumon_flags = uap-&gt;arg; <span class="enscript-comment">// XXX temporarily stashing flags in argp (12592127)
</span>		error = mach_to_bsd_rv(task_cpu_usage_monitor_ctl(targetp-&gt;task, &amp;cpumon_flags));
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">RLIMIT_THREAD_CPULIMITS</span>:
		cpulimits_flags = (uint32_t)uap-&gt;arg; <span class="enscript-comment">// only need a limited set of bits, pass in void * argument
</span>
		<span class="enscript-keyword">if</span> (uap-&gt;pid != -1) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}

		uint8_t percent = 0;
		uint32_t ms_refill = 0;
		uint64_t ns_refill;

		percent = (uint8_t)(cpulimits_flags &amp; 0xffU);					<span class="enscript-comment">/* low 8 bits for percent */</span>
		ms_refill = (cpulimits_flags &gt;&gt; 8) &amp; 0xffffff;		<span class="enscript-comment">/* next 24 bits represent ms refill value */</span>
		<span class="enscript-keyword">if</span> (percent &gt;= 100) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}

		ns_refill = ((uint64_t)ms_refill) * NSEC_PER_MSEC;

		error = mach_to_bsd_rv(thread_set_cpulimit(THREAD_CPULIMIT_BLOCK, percent, ns_refill));
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}

	proc_rele(targetp);
	kauth_cred_unref(&amp;target_cred);

	<span class="enscript-comment">/*
	 * Return value from this function becomes errno to userland caller.
	 */</span>
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Return the current amount of CPU consumed by this thread (in either user or kernel mode)
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">thread_selfusage</span>(<span class="enscript-type">struct</span> proc *p __unused, <span class="enscript-type">struct</span> thread_selfusage_args *uap __unused, uint64_t *retval)
{
	uint64_t runtime;

	runtime = thread_get_runtime_self();
	*retval = runtime;

	<span class="enscript-keyword">return</span> (0);
}
</pre>
<hr />
</body></html>