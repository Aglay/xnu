<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_event.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_event.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *
 */</span>
<span class="enscript-comment">/*-
 * Copyright (c) 1999,2000,2001 Jonathan Lemon &lt;<a href="mailto:jlemon@FreeBSD.org">jlemon@FreeBSD.org</a>&gt;
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */</span>
<span class="enscript-comment">/*
 *	@(#)kern_event.c       1.0 (3/31/2000)
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdint.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/select.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/eventvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/codesign.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/pthread_shims.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/waitq.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;net/net_str_id.h&quot;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PRESSURE_EVENTS</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/vm_pressure.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_memorystatus.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-function-name">MALLOC_DEFINE</span>(M_KQUEUE, <span class="enscript-string">&quot;kqueue&quot;</span>, <span class="enscript-string">&quot;memory for kqueue system&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KQ_EVENT</span>	NO_EVENT64

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">kqlock</span>(<span class="enscript-type">struct</span> kqueue *kq);
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">kqunlock</span>(<span class="enscript-type">struct</span> kqueue *kq);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kqlock2knoteuse</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kqlock2knoteusewait</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kqlock2knotedrop</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">knoteuse2kqlock</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">struct</span> knote *kn);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kqueue_wakeup</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">int</span> closed);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kqueue_read</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio,
    <span class="enscript-type">int</span> flags, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kqueue_write</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio,
    <span class="enscript-type">int</span> flags, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kqueue_ioctl</span>(<span class="enscript-type">struct</span> fileproc *fp, u_long com, caddr_t data,
    vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kqueue_select</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">int</span> which, <span class="enscript-type">void</span> *wq_link_id,
    vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kqueue_close</span>(<span class="enscript-type">struct</span> fileglob *fg, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kqueue_kqfilter</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> knote *kn,
	vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kqueue_drain</span>(<span class="enscript-type">struct</span> fileproc *fp, vfs_context_t ctx);

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> fileops kqueueops = {
	.fo_type = DTYPE_KQUEUE,
	.fo_read = kqueue_read,
	.fo_write = kqueue_write,
	.fo_ioctl = kqueue_ioctl,
	.fo_select = kqueue_select,
	.fo_close = kqueue_close,
	.fo_kqfilter = kqueue_kqfilter,
	.fo_drain = kqueue_drain,
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kevent_internal</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">int</span> fd, 
			   user_addr_t changelist, <span class="enscript-type">int</span> nchanges,
			   user_addr_t eventlist, <span class="enscript-type">int</span> nevents, 
			   user_addr_t data_out, user_size_t *data_available,
			   <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags, user_addr_t utimeout,
			   kqueue_continue_t continuation,
			   int32_t *retval);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kevent_copyin</span>(user_addr_t *addrp, <span class="enscript-type">struct</span> kevent_internal_s *kevp,
			 <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kevent_copyout</span>(<span class="enscript-type">struct</span> kevent_internal_s *kevp, user_addr_t *addrp,
			  <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags);
<span class="enscript-type">char</span> * <span class="enscript-function-name">kevent_description</span>(<span class="enscript-type">struct</span> kevent_internal_s *kevp, <span class="enscript-type">char</span> *s, size_t n);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kevent_callback</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">struct</span> kevent_internal_s *kevp,
			   <span class="enscript-type">void</span> *data);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kevent_continue</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">void</span> *data, <span class="enscript-type">int</span> error);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kqueue_scan_continue</span>(<span class="enscript-type">void</span> *contp, wait_result_t wait_result);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kqueue_process</span>(<span class="enscript-type">struct</span> kqueue *kq, kevent_callback_t callback,
			  <span class="enscript-type">void</span> *data, <span class="enscript-type">int</span> *countp, <span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kqueue_begin_processing</span>(<span class="enscript-type">struct</span> kqueue *kq);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kqueue_end_processing</span>(<span class="enscript-type">struct</span> kqueue *kq);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">knote_process</span>(<span class="enscript-type">struct</span> knote *kn, kevent_callback_t callback,
			 <span class="enscript-type">void</span> *data, <span class="enscript-type">struct</span> kqtailq *inprocessp, <span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">knote_put</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">knote_fdpattach</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">struct</span> filedesc *fdp,
			   <span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">knote_drop</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">knote_activate</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">knote_deactivate</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">knote_enqueue</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">knote_dequeue</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> knote *<span class="enscript-function-name">knote_alloc</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">knote_free</span>(<span class="enscript-type">struct</span> knote *kn);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">filt_fileattach</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> filterops file_filtops = {
	.f_isfd = 1,
	.f_attach = filt_fileattach,
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">filt_kqdetach</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">filt_kqueue</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> filterops kqread_filtops = {
	.f_isfd = 1,
	.f_detach = filt_kqdetach,
	.f_event = filt_kqueue,
};

<span class="enscript-comment">/* placeholder for not-yet-implemented filters */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">filt_badattach</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> filterops bad_filtops = {
	.f_attach = filt_badattach,
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">filt_procattach</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">filt_procdetach</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">filt_proc</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> filterops proc_filtops = {
	.f_attach = filt_procattach,
	.f_detach = filt_procdetach,
	.f_event = filt_proc,
};

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PRESSURE_EVENTS</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">filt_vmattach</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">filt_vmdetach</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">filt_vm</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> filterops vm_filtops = {
	.f_attach = filt_vmattach,
	.f_detach = filt_vmdetach,
	.f_event = filt_vm,
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PRESSURE_EVENTS */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> filterops memorystatus_filtops;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MEMORYSTATUS */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> filterops fs_filtops;

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> filterops sig_filtops;

<span class="enscript-comment">/* Timer filter */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">filt_timerattach</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">filt_timerdetach</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">filt_timer</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">filt_timertouch</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">struct</span> kevent_internal_s *kev,
    <span class="enscript-type">long</span> type);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> filterops timer_filtops = {
	.f_attach = filt_timerattach,
	.f_detach = filt_timerdetach,
	.f_event = filt_timer,
	.f_touch = filt_timertouch,
};

<span class="enscript-comment">/* Helpers */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">filt_timerexpire</span>(<span class="enscript-type">void</span> *knx, <span class="enscript-type">void</span> *param1);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">filt_timervalidate</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">filt_timerupdate</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">filt_timercancel</span>(<span class="enscript-type">struct</span> knote *kn);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TIMER_RUNNING</span>		0x1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">TIMER_CANCELWAIT</span>	0x2

<span class="enscript-type">static</span> lck_mtx_t _filt_timerlock;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">filt_timerlock</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">filt_timerunlock</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> zone_t knote_zone;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">KN_HASH</span>(val, mask)	(((val) ^ (val &gt;&gt; 8)) &amp; (mask))

#<span class="enscript-reference">if</span> 0
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> filterops aio_filtops;
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Mach portset filter */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> filterops machport_filtops;

<span class="enscript-comment">/* User filter */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">filt_userattach</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">filt_userdetach</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">filt_user</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">filt_usertouch</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">struct</span> kevent_internal_s *kev,
    <span class="enscript-type">long</span> type);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> filterops user_filtops = {
	.f_attach = filt_userattach,
	.f_detach = filt_userdetach,
	.f_event = filt_user,
	.f_touch = filt_usertouch,
};

<span class="enscript-comment">/*
 * Table for all system-defined filters.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> filterops *sysfilt_ops[] = {
	&amp;file_filtops,			<span class="enscript-comment">/* EVFILT_READ */</span>
	&amp;file_filtops,			<span class="enscript-comment">/* EVFILT_WRITE */</span>
#<span class="enscript-reference">if</span> 0
	&amp;aio_filtops,			<span class="enscript-comment">/* EVFILT_AIO */</span>
#<span class="enscript-reference">else</span>
	&amp;bad_filtops,			<span class="enscript-comment">/* EVFILT_AIO */</span>
#<span class="enscript-reference">endif</span>
	&amp;file_filtops,			<span class="enscript-comment">/* EVFILT_VNODE */</span>
	&amp;proc_filtops,			<span class="enscript-comment">/* EVFILT_PROC */</span>
	&amp;sig_filtops,			<span class="enscript-comment">/* EVFILT_SIGNAL */</span>
	&amp;timer_filtops,			<span class="enscript-comment">/* EVFILT_TIMER */</span>
	&amp;machport_filtops,		<span class="enscript-comment">/* EVFILT_MACHPORT */</span>
	&amp;fs_filtops,			<span class="enscript-comment">/* EVFILT_FS */</span>
	&amp;user_filtops,			<span class="enscript-comment">/* EVFILT_USER */</span>
	&amp;bad_filtops,			<span class="enscript-comment">/* unused */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PRESSURE_EVENTS</span>
	&amp;vm_filtops,			<span class="enscript-comment">/* EVFILT_VM */</span>
#<span class="enscript-reference">else</span>
	&amp;bad_filtops,			<span class="enscript-comment">/* EVFILT_VM */</span>
#<span class="enscript-reference">endif</span>
	&amp;file_filtops,			<span class="enscript-comment">/* EVFILT_SOCK */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>
	&amp;memorystatus_filtops,  <span class="enscript-comment">/* EVFILT_MEMORYSTATUS */</span>
#<span class="enscript-reference">else</span>
	&amp;bad_filtops,			<span class="enscript-comment">/* EVFILT_MEMORYSTATUS */</span>
#<span class="enscript-reference">endif</span>
};

<span class="enscript-comment">/*
 * kqueue/note lock attributes and implementations
 *
 *	kqueues have locks, while knotes have use counts
 *	Most of the knote state is guarded by the object lock.
 *	the knote &quot;inuse&quot; count and status use the kqueue lock.
 */</span>
lck_grp_attr_t * kq_lck_grp_attr;
lck_grp_t * kq_lck_grp;
lck_attr_t * kq_lck_attr;

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">kqlock</span>(<span class="enscript-type">struct</span> kqueue *kq)
{
	lck_spin_lock(&amp;kq-&gt;kq_lock);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">kqunlock</span>(<span class="enscript-type">struct</span> kqueue *kq)
{
	lck_spin_unlock(&amp;kq-&gt;kq_lock);
}

<span class="enscript-comment">/*
 * Convert a kq lock to a knote use referece.
 *
 *	If the knote is being dropped, we can't get
 *	a use reference, so just return with it
 *	still locked.
 *	- kq locked at entry
 *	- unlock on exit if we get the use reference
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kqlock2knoteuse</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-keyword">if</span> (kn-&gt;kn_status &amp; KN_DROPPING)
		<span class="enscript-keyword">return</span> (0);
	kn-&gt;kn_inuse++;
	kqunlock(kq);
	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * Convert a kq lock to a knote use referece,
 * but wait for attach and drop events to complete.
 *
 *	If the knote is being dropped, we can't get
 *	a use reference, so just return with it
 *	still locked.
 *	- kq locked at entry
 *	- kq always unlocked on exit
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kqlock2knoteusewait</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-keyword">if</span> ((kn-&gt;kn_status &amp; (KN_DROPPING | KN_ATTACHING)) != 0) {
		kn-&gt;kn_status |= KN_USEWAIT;
		waitq_assert_wait64((<span class="enscript-type">struct</span> waitq *)kq-&gt;kq_wqs,
				    CAST_EVENT64_T(&amp;kn-&gt;kn_status),
				    THREAD_UNINT, TIMEOUT_WAIT_FOREVER);
		kqunlock(kq);
		thread_block(THREAD_CONTINUE_NULL);
		<span class="enscript-keyword">return</span> (0);
	}
	kn-&gt;kn_inuse++;
	kqunlock(kq);
	<span class="enscript-keyword">return</span> (1);
}

<span class="enscript-comment">/*
 * Convert from a knote use reference back to kq lock.
 *
 *	Drop a use reference and wake any waiters if
 *	this is the last one.
 *
 *	The exit return indicates if the knote is
 *	still alive - but the kqueue lock is taken
 *	unconditionally.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">knoteuse2kqlock</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">struct</span> knote *kn)
{
	kqlock(kq);
	<span class="enscript-keyword">if</span> (--kn-&gt;kn_inuse == 0) {
		<span class="enscript-keyword">if</span> ((kn-&gt;kn_status &amp; KN_ATTACHING) != 0) {
			kn-&gt;kn_status &amp;= ~KN_ATTACHING;
		}
		<span class="enscript-keyword">if</span> ((kn-&gt;kn_status &amp; KN_USEWAIT) != 0) {
			kn-&gt;kn_status &amp;= ~KN_USEWAIT;
			waitq_wakeup64_all((<span class="enscript-type">struct</span> waitq *)kq-&gt;kq_wqs,
					   CAST_EVENT64_T(&amp;kn-&gt;kn_status),
					   THREAD_AWAKENED,
					   WAITQ_ALL_PRIORITIES);
		}
	}
	<span class="enscript-keyword">return</span> ((kn-&gt;kn_status &amp; KN_DROPPING) == 0);
}

<span class="enscript-comment">/*
 * Convert a kq lock to a knote drop reference.
 *
 *	If the knote is in use, wait for the use count
 *	to subside.  We first mark our intention to drop
 *	it - keeping other users from &quot;piling on.&quot;
 *	If we are too late, we have to wait for the
 *	other drop to complete.
 *
 *	- kq locked at entry
 *	- always unlocked on exit.
 *	- caller can't hold any locks that would prevent
 *	  the other dropper from completing.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kqlock2knotedrop</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-type">int</span> oktodrop;

	oktodrop = ((kn-&gt;kn_status &amp; (KN_DROPPING | KN_ATTACHING)) == 0);
	kn-&gt;kn_status &amp;= ~KN_STAYQUEUED;
	kn-&gt;kn_status |= KN_DROPPING;
	<span class="enscript-keyword">if</span> (oktodrop) {
		<span class="enscript-keyword">if</span> (kn-&gt;kn_inuse == 0) {
			kqunlock(kq);
			<span class="enscript-keyword">return</span> (oktodrop);
		}
	}
	kn-&gt;kn_status |= KN_USEWAIT;
	waitq_assert_wait64((<span class="enscript-type">struct</span> waitq *)kq-&gt;kq_wqs,
			    CAST_EVENT64_T(&amp;kn-&gt;kn_status),
			    THREAD_UNINT, TIMEOUT_WAIT_FOREVER);
	kqunlock(kq);
	thread_block(THREAD_CONTINUE_NULL);
	<span class="enscript-keyword">return</span> (oktodrop);
}

<span class="enscript-comment">/*
 * Release a knote use count reference.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">knote_put</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-type">struct</span> kqueue *kq = kn-&gt;kn_kq;

	kqlock(kq);
	<span class="enscript-keyword">if</span> (--kn-&gt;kn_inuse == 0) {
		<span class="enscript-keyword">if</span> ((kn-&gt;kn_status &amp; KN_USEWAIT) != 0) {
			kn-&gt;kn_status &amp;= ~KN_USEWAIT;
			waitq_wakeup64_all((<span class="enscript-type">struct</span> waitq *)kq-&gt;kq_wqs,
					   CAST_EVENT64_T(&amp;kn-&gt;kn_status),
					   THREAD_AWAKENED,
					   WAITQ_ALL_PRIORITIES);
		}
	}
	kqunlock(kq);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_fileattach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-keyword">return</span> (fo_kqfilter(kn-&gt;kn_fp, kn, vfs_context_current()));
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">f_flag</span> f_fglob-&gt;fg_flag
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">f_msgcount</span> f_fglob-&gt;fg_msgcount
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">f_cred</span> f_fglob-&gt;fg_cred
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">f_ops</span> f_fglob-&gt;fg_ops
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">f_offset</span> f_fglob-&gt;fg_offset
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">f_data</span> f_fglob-&gt;fg_data

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_kqdetach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-type">struct</span> kqueue *kq = (<span class="enscript-type">struct</span> kqueue *)kn-&gt;kn_fp-&gt;f_data;

	kqlock(kq);
	KNOTE_DETACH(&amp;kq-&gt;kq_sel.si_note, kn);
	kqunlock(kq);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_kqueue</span>(<span class="enscript-type">struct</span> knote *kn, __unused <span class="enscript-type">long</span> hint)
{
	<span class="enscript-type">struct</span> kqueue *kq = (<span class="enscript-type">struct</span> kqueue *)kn-&gt;kn_fp-&gt;f_data;

	kn-&gt;kn_data = kq-&gt;kq_count;
	<span class="enscript-keyword">return</span> (kn-&gt;kn_data &gt; 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_procattach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-type">struct</span> proc *p;

	assert(PID_MAX &lt; NOTE_PDATAMASK);

	<span class="enscript-keyword">if</span> ((kn-&gt;kn_sfflags &amp; (NOTE_TRACK | NOTE_TRACKERR | NOTE_CHILD)) != 0)
		<span class="enscript-keyword">return</span> (ENOTSUP);

	p = proc_find(kn-&gt;kn_id);
	<span class="enscript-keyword">if</span> (p == NULL) {
		<span class="enscript-keyword">return</span> (ESRCH);
	}

	<span class="enscript-type">const</span> <span class="enscript-type">int</span> NoteExitStatusBits = NOTE_EXIT | NOTE_EXITSTATUS;

	<span class="enscript-keyword">if</span> ((kn-&gt;kn_sfflags &amp; NoteExitStatusBits) == NoteExitStatusBits)
		<span class="enscript-keyword">do</span> {
			pid_t selfpid = proc_selfpid();

			<span class="enscript-keyword">if</span> (p-&gt;p_ppid == selfpid)
				<span class="enscript-keyword">break</span>;	<span class="enscript-comment">/* parent =&gt; ok */</span>

			<span class="enscript-keyword">if</span> ((p-&gt;p_lflag &amp; P_LTRACED) != 0 &amp;&amp;
			    (p-&gt;p_oppid == selfpid))
				<span class="enscript-keyword">break</span>;	<span class="enscript-comment">/* parent-in-waiting =&gt; ok */</span>

			proc_rele(p);
			<span class="enscript-keyword">return</span> (EACCES);
		} <span class="enscript-keyword">while</span> (0);

	proc_klist_lock();

	kn-&gt;kn_flags |= EV_CLEAR;	<span class="enscript-comment">/* automatically set */</span>
	kn-&gt;kn_ptr.p_proc = p;		<span class="enscript-comment">/* store the proc handle */</span>

	KNOTE_ATTACH(&amp;p-&gt;p_klist, kn);

	proc_klist_unlock();

	proc_rele(p);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * The knote may be attached to a different process, which may exit,
 * leaving nothing for the knote to be attached to.  In that case,
 * the pointer to the process will have already been nulled out.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_procdetach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-type">struct</span> proc *p;

	proc_klist_lock();

	p = kn-&gt;kn_ptr.p_proc;
	<span class="enscript-keyword">if</span> (p != PROC_NULL) {
		kn-&gt;kn_ptr.p_proc = PROC_NULL;
		KNOTE_DETACH(&amp;p-&gt;p_klist, kn);
	}

	proc_klist_unlock();
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_proc</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint)
{
	<span class="enscript-comment">/*
	 * Note: a lot of bits in hint may be obtained from the knote
	 * To free some of those bits, see &lt;rdar://problem/12592988&gt; Freeing up
	 * bits in hint for filt_proc
	 */</span>
	<span class="enscript-comment">/* hint is 0 when called from above */</span>
	<span class="enscript-keyword">if</span> (hint != 0) {
		u_int event;

		<span class="enscript-comment">/* ALWAYS CALLED WITH proc_klist_lock when (hint != 0) */</span>

		<span class="enscript-comment">/*
		 * mask off extra data
		 */</span>
		event = (u_int)hint &amp; NOTE_PCTRLMASK;

		<span class="enscript-comment">/*
		 * termination lifecycle events can happen while a debugger
		 * has reparented a process, in which case notifications
		 * should be quashed except to the tracing parent. When
		 * the debugger reaps the child (either via wait4(2) or
		 * process exit), the child will be reparented to the original
		 * parent and these knotes re-fired.
		 */</span>
		<span class="enscript-keyword">if</span> (event &amp; NOTE_EXIT) {
			<span class="enscript-keyword">if</span> ((kn-&gt;kn_ptr.p_proc-&gt;p_oppid != 0)
				&amp;&amp; (kn-&gt;kn_kq-&gt;kq_p-&gt;p_pid != kn-&gt;kn_ptr.p_proc-&gt;p_ppid)) {
				<span class="enscript-comment">/*
				 * This knote is not for the current ptrace(2) parent, ignore.
				 */</span>
				<span class="enscript-keyword">return</span> 0;
			}
		}					

		<span class="enscript-comment">/*
		 * if the user is interested in this event, record it.
		 */</span>
		<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; event)
			kn-&gt;kn_fflags |= event;

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">push</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">ignored</span> <span class="enscript-string">&quot;-Wdeprecated-declarations&quot;</span>
		<span class="enscript-keyword">if</span> ((event == NOTE_REAP) || ((event == NOTE_EXIT) &amp;&amp; !(kn-&gt;kn_sfflags &amp; NOTE_REAP))) {
			kn-&gt;kn_flags |= (EV_EOF | EV_ONESHOT);
		}
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">clang</span> <span class="enscript-variable-name">diagnostic</span> <span class="enscript-variable-name">pop</span>


		<span class="enscript-comment">/*
		 * The kernel has a wrapper in place that returns the same data
		 * as is collected here, in kn_data.  Any changes to how 
		 * NOTE_EXITSTATUS and NOTE_EXIT_DETAIL are collected
		 * should also be reflected in the proc_pidnoteexit() wrapper.
		 */</span>
		<span class="enscript-keyword">if</span> (event == NOTE_EXIT) {
			kn-&gt;kn_data = 0;
			<span class="enscript-keyword">if</span> ((kn-&gt;kn_sfflags &amp; NOTE_EXITSTATUS) != 0) {
				kn-&gt;kn_fflags |= NOTE_EXITSTATUS;
				kn-&gt;kn_data |= (hint &amp; NOTE_PDATAMASK);
			}
			<span class="enscript-keyword">if</span> ((kn-&gt;kn_sfflags &amp; NOTE_EXIT_DETAIL) != 0) {
				kn-&gt;kn_fflags |= NOTE_EXIT_DETAIL;
				<span class="enscript-keyword">if</span> ((kn-&gt;kn_ptr.p_proc-&gt;p_lflag &amp;
				    P_LTERM_DECRYPTFAIL) != 0) {
					kn-&gt;kn_data |= NOTE_EXIT_DECRYPTFAIL; 
				}
				<span class="enscript-keyword">if</span> ((kn-&gt;kn_ptr.p_proc-&gt;p_lflag &amp;
				    P_LTERM_JETSAM) != 0) {
					kn-&gt;kn_data |= NOTE_EXIT_MEMORY;
					<span class="enscript-keyword">switch</span> (kn-&gt;kn_ptr.p_proc-&gt;p_lflag &amp;
					    P_JETSAM_MASK) {
						<span class="enscript-keyword">case</span> <span class="enscript-reference">P_JETSAM_VMPAGESHORTAGE</span>:
							kn-&gt;kn_data |= NOTE_EXIT_MEMORY_VMPAGESHORTAGE;
							<span class="enscript-keyword">break</span>;
						<span class="enscript-keyword">case</span> <span class="enscript-reference">P_JETSAM_VMTHRASHING</span>:
							kn-&gt;kn_data |= NOTE_EXIT_MEMORY_VMTHRASHING;
							<span class="enscript-keyword">break</span>;
						<span class="enscript-keyword">case</span> <span class="enscript-reference">P_JETSAM_FCTHRASHING</span>:
							kn-&gt;kn_data |= NOTE_EXIT_MEMORY_FCTHRASHING;
							<span class="enscript-keyword">break</span>;
						<span class="enscript-keyword">case</span> <span class="enscript-reference">P_JETSAM_VNODE</span>:
							kn-&gt;kn_data |= NOTE_EXIT_MEMORY_VNODE;
							<span class="enscript-keyword">break</span>;
						<span class="enscript-keyword">case</span> <span class="enscript-reference">P_JETSAM_HIWAT</span>:
							kn-&gt;kn_data |= NOTE_EXIT_MEMORY_HIWAT;
							<span class="enscript-keyword">break</span>;
						<span class="enscript-keyword">case</span> <span class="enscript-reference">P_JETSAM_PID</span>:
							kn-&gt;kn_data |= NOTE_EXIT_MEMORY_PID;
							<span class="enscript-keyword">break</span>;
						<span class="enscript-keyword">case</span> <span class="enscript-reference">P_JETSAM_IDLEEXIT</span>:
							kn-&gt;kn_data |= NOTE_EXIT_MEMORY_IDLE;
							<span class="enscript-keyword">break</span>;
					}
				}
				<span class="enscript-keyword">if</span> ((kn-&gt;kn_ptr.p_proc-&gt;p_csflags &amp;
				    CS_KILLED) != 0) {
					kn-&gt;kn_data |= NOTE_EXIT_CSERROR;
				}
			}
		}
	}

	<span class="enscript-comment">/* atomic check, no locking need when called from above */</span>
	<span class="enscript-keyword">return</span> (kn-&gt;kn_fflags != 0);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PRESSURE_EVENTS</span>
<span class="enscript-comment">/*
 * Virtual memory kevents
 *
 * author: Matt Jacobson [<a href="mailto:matthew_jacobson@apple.com">matthew_jacobson@apple.com</a>]
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_vmattach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-comment">/*
	 * The note will be cleared once the information has been flushed to
	 * the client. If there is still pressure, we will be re-alerted.
	 */</span>
	kn-&gt;kn_flags |= EV_CLEAR;
	<span class="enscript-keyword">return</span> (vm_knote_register(kn));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_vmdetach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	vm_knote_unregister(kn);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_vm</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint)
{
	<span class="enscript-comment">/* hint == 0 means this is just an alive? check (always true) */</span>
	<span class="enscript-keyword">if</span> (hint != 0) {
		<span class="enscript-type">const</span> pid_t pid = (pid_t)hint;
		<span class="enscript-keyword">if</span> ((kn-&gt;kn_sfflags &amp; NOTE_VM_PRESSURE) &amp;&amp;
		    (kn-&gt;kn_kq-&gt;kq_p-&gt;p_pid == pid)) {
			kn-&gt;kn_fflags |= NOTE_VM_PRESSURE;
		}
	}

	<span class="enscript-keyword">return</span> (kn-&gt;kn_fflags != 0);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PRESSURE_EVENTS */</span>

<span class="enscript-comment">/*
 * filt_timervalidate - process data from user
 *
 *	Converts to either interval or deadline format.
 *
 *	The saved-data field in the knote contains the
 *	time value.  The saved filter-flags indicates
 *	the unit of measurement.
 *
 *	After validation, either the saved-data field
 *	contains the interval in absolute time, or ext[0]
 *	contains the expected deadline. If that deadline
 *	is in the past, ext[0] is 0.
 *
 *	Returns EINVAL for unrecognized units of time.
 *
 *	Timer filter lock is held.
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_timervalidate</span>(<span class="enscript-type">struct</span> knote *kn)
{
	uint64_t multiplier;
	uint64_t raw = 0;

	<span class="enscript-keyword">switch</span> (kn-&gt;kn_sfflags &amp; (NOTE_SECONDS|NOTE_USECONDS|NOTE_NSECONDS)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NOTE_SECONDS</span>:
		multiplier = NSEC_PER_SEC;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NOTE_USECONDS</span>:
		multiplier = NSEC_PER_USEC;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NOTE_NSECONDS</span>:
		multiplier = 1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>: <span class="enscript-comment">/* milliseconds (default) */</span>
		multiplier = NSEC_PER_SEC / 1000;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-comment">/* transform the slop delta(leeway) in kn_ext[1] if passed to same time scale */</span>
	<span class="enscript-keyword">if</span>(kn-&gt;kn_sfflags &amp; NOTE_LEEWAY){
		nanoseconds_to_absolutetime((uint64_t)kn-&gt;kn_ext[1] * multiplier, &amp;raw);
		kn-&gt;kn_ext[1] = raw;
	}

	nanoseconds_to_absolutetime((uint64_t)kn-&gt;kn_sdata * multiplier, &amp;raw);

	kn-&gt;kn_ext[0] = 0;
	kn-&gt;kn_sdata = 0;

	<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_ABSOLUTE) {
		clock_sec_t seconds;
		clock_nsec_t nanoseconds;
		uint64_t now;

		clock_get_calendar_nanotime(&amp;seconds, &amp;nanoseconds);
		nanoseconds_to_absolutetime((uint64_t)seconds * NSEC_PER_SEC +
		    nanoseconds, &amp;now);

		<span class="enscript-keyword">if</span> (raw &lt; now) {
			<span class="enscript-comment">/* time has already passed */</span>
			kn-&gt;kn_ext[0] = 0;
		} <span class="enscript-keyword">else</span> {
			raw -= now;
			clock_absolutetime_interval_to_deadline(raw,
			    &amp;kn-&gt;kn_ext[0]);
		}
	} <span class="enscript-keyword">else</span> {
		kn-&gt;kn_sdata = raw;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * filt_timerupdate - compute the next deadline
 *
 * 	Repeating timers store their interval in kn_sdata. Absolute
 * 	timers have already calculated the deadline, stored in ext[0].
 *
 * 	On return, the next deadline (or zero if no deadline is needed)
 * 	is stored in kn_ext[0].
 *
 * 	Timer filter lock is held.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_timerupdate</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-comment">/* if there's no interval, deadline is just in kn_ext[0] */</span>
	<span class="enscript-keyword">if</span> (kn-&gt;kn_sdata == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* if timer hasn't fired before, fire in interval nsecs */</span>
	<span class="enscript-keyword">if</span> (kn-&gt;kn_ext[0] == 0) {
		clock_absolutetime_interval_to_deadline(kn-&gt;kn_sdata,
		    &amp;kn-&gt;kn_ext[0]);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * If timer has fired before, schedule the next pop
		 * relative to the last intended deadline.
		 *
		 * We could check for whether the deadline has expired,
		 * but the thread call layer can handle that.
		 */</span>
		kn-&gt;kn_ext[0] += kn-&gt;kn_sdata;
	}
}

<span class="enscript-comment">/*
 * filt_timerexpire - the timer callout routine
 *
 * Just propagate the timer event into the knote
 * filter routine (by going through the knote
 * synchronization point).  Pass a hint to
 * indicate this is a real event, not just a
 * query from above.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_timerexpire</span>(<span class="enscript-type">void</span> *knx, __unused <span class="enscript-type">void</span> *spare)
{
	<span class="enscript-type">struct</span> klist timer_list;
	<span class="enscript-type">struct</span> knote *kn = knx;

	filt_timerlock();

	kn-&gt;kn_hookid &amp;= ~TIMER_RUNNING;

	<span class="enscript-comment">/* no &quot;object&quot; for timers, so fake a list */</span>
	SLIST_INIT(&amp;timer_list);
	SLIST_INSERT_HEAD(&amp;timer_list, kn, kn_selnext);
	KNOTE(&amp;timer_list, 1);

	<span class="enscript-comment">/* if someone is waiting for timer to pop */</span>
	<span class="enscript-keyword">if</span> (kn-&gt;kn_hookid &amp; TIMER_CANCELWAIT) {
		<span class="enscript-type">struct</span> kqueue *kq = kn-&gt;kn_kq;
		waitq_wakeup64_all((<span class="enscript-type">struct</span> waitq *)kq-&gt;kq_wqs,
				   CAST_EVENT64_T(&amp;kn-&gt;kn_hook),
				   THREAD_AWAKENED,
				   WAITQ_ALL_PRIORITIES);
	}

	filt_timerunlock();
}

<span class="enscript-comment">/*
 * Cancel a running timer (or wait for the pop).
 * Timer filter lock is held.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_timercancel</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-type">struct</span> kqueue *kq = kn-&gt;kn_kq;
	thread_call_t callout = kn-&gt;kn_hook;
	boolean_t cancelled;

	<span class="enscript-keyword">if</span> (kn-&gt;kn_hookid &amp; TIMER_RUNNING) {
		<span class="enscript-comment">/* cancel the callout if we can */</span>
		cancelled = thread_call_cancel(callout);
		<span class="enscript-keyword">if</span> (cancelled) {
			kn-&gt;kn_hookid &amp;= ~TIMER_RUNNING;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* we have to wait for the expire routine.  */</span>
			kn-&gt;kn_hookid |= TIMER_CANCELWAIT;
			waitq_assert_wait64((<span class="enscript-type">struct</span> waitq *)kq-&gt;kq_wqs,
					    CAST_EVENT64_T(&amp;kn-&gt;kn_hook),
					    THREAD_UNINT, TIMEOUT_WAIT_FOREVER);
			filt_timerunlock();
			thread_block(THREAD_CONTINUE_NULL);
			filt_timerlock();
			assert((kn-&gt;kn_hookid &amp; TIMER_RUNNING) == 0);
		}
	}
}

<span class="enscript-comment">/*
 * Allocate a thread call for the knote's lifetime, and kick off the timer.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_timerattach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	thread_call_t callout;
	<span class="enscript-type">int</span> error;

	callout = thread_call_allocate(filt_timerexpire, kn);
	<span class="enscript-keyword">if</span> (NULL == callout)
		<span class="enscript-keyword">return</span> (ENOMEM);

	filt_timerlock();
	error = filt_timervalidate(kn);
	<span class="enscript-keyword">if</span> (error != 0) {
		filt_timerunlock();
		<span class="enscript-keyword">return</span> (error);
	}

	kn-&gt;kn_hook = (<span class="enscript-type">void</span>*)callout;
	kn-&gt;kn_hookid = 0;

	<span class="enscript-comment">/* absolute=EV_ONESHOT */</span>
	<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_ABSOLUTE)
		kn-&gt;kn_flags |= EV_ONESHOT;

	filt_timerupdate(kn);
	<span class="enscript-keyword">if</span> (kn-&gt;kn_ext[0]) {
		kn-&gt;kn_flags |= EV_CLEAR;
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> timer_flags = 0;
		<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_CRITICAL)
			timer_flags |= THREAD_CALL_DELAY_USER_CRITICAL;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_BACKGROUND)
			timer_flags |= THREAD_CALL_DELAY_USER_BACKGROUND;
		<span class="enscript-keyword">else</span>
			timer_flags |= THREAD_CALL_DELAY_USER_NORMAL;

		<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_LEEWAY)
			timer_flags |= THREAD_CALL_DELAY_LEEWAY;

		thread_call_enter_delayed_with_leeway(callout, NULL,
				kn-&gt;kn_ext[0], kn-&gt;kn_ext[1], timer_flags);

		kn-&gt;kn_hookid |= TIMER_RUNNING;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* fake immediate */</span>
		kn-&gt;kn_data = 1;
	}

	filt_timerunlock();
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Shut down the timer if it's running, and free the callout.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_timerdetach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	thread_call_t callout;

	filt_timerlock();

	callout = (thread_call_t)kn-&gt;kn_hook;
	filt_timercancel(kn);

	filt_timerunlock();

	thread_call_free(callout);
}



<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_timer</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint)
{
	<span class="enscript-type">int</span> result;

	<span class="enscript-keyword">if</span> (hint) {
		<span class="enscript-comment">/* real timer pop -- timer lock held by filt_timerexpire */</span>
		kn-&gt;kn_data++;

		<span class="enscript-keyword">if</span> (((kn-&gt;kn_hookid &amp; TIMER_CANCELWAIT) == 0) &amp;&amp;
				((kn-&gt;kn_flags &amp; EV_ONESHOT) == 0)) {

			<span class="enscript-comment">/* evaluate next time to fire */</span>
			filt_timerupdate(kn);

			<span class="enscript-keyword">if</span> (kn-&gt;kn_ext[0]) {
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> timer_flags = 0;

				<span class="enscript-comment">/* keep the callout and re-arm */</span>
				<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_CRITICAL)
					timer_flags |= THREAD_CALL_DELAY_USER_CRITICAL;
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_BACKGROUND)
					timer_flags |= THREAD_CALL_DELAY_USER_BACKGROUND;
				<span class="enscript-keyword">else</span>
					timer_flags |= THREAD_CALL_DELAY_USER_NORMAL;

				<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_LEEWAY)
					timer_flags |= THREAD_CALL_DELAY_LEEWAY;

				thread_call_enter_delayed_with_leeway(kn-&gt;kn_hook, NULL,
						kn-&gt;kn_ext[0], kn-&gt;kn_ext[1], timer_flags);

				kn-&gt;kn_hookid |= TIMER_RUNNING;
			}
		}

		<span class="enscript-keyword">return</span> (1);
	}

	<span class="enscript-comment">/* user-query */</span>
	filt_timerlock();

	result = (kn-&gt;kn_data != 0);

	filt_timerunlock();

	<span class="enscript-keyword">return</span> (result);
}


<span class="enscript-comment">/*
 * filt_timertouch - update knote with new user input
 *
 * Cancel and restart the timer based on new user data. When
 * the user picks up a knote, clear the count of how many timer
 * pops have gone off (in kn_data).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_timertouch</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">struct</span> kevent_internal_s *kev, <span class="enscript-type">long</span> type)
{
	<span class="enscript-type">int</span> error;
	filt_timerlock();

	<span class="enscript-keyword">switch</span> (type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EVENT_REGISTER</span>:
		<span class="enscript-comment">/* cancel current call */</span>
		filt_timercancel(kn);

		<span class="enscript-comment">/* recalculate deadline */</span>
		kn-&gt;kn_sdata = kev-&gt;data;
		kn-&gt;kn_sfflags = kev-&gt;fflags;
		kn-&gt;kn_ext[0] = kev-&gt;ext[0];
		kn-&gt;kn_ext[1] = kev-&gt;ext[1];

		error = filt_timervalidate(kn);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/* no way to report error, so mark it in the knote */</span>
			kn-&gt;kn_flags |= EV_ERROR;
			kn-&gt;kn_data = error;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* start timer if necessary */</span>
		filt_timerupdate(kn);

		<span class="enscript-keyword">if</span> (kn-&gt;kn_ext[0]) {
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> timer_flags = 0;
			<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_CRITICAL)
				timer_flags |= THREAD_CALL_DELAY_USER_CRITICAL;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_BACKGROUND)
				timer_flags |= THREAD_CALL_DELAY_USER_BACKGROUND;
			<span class="enscript-keyword">else</span>
				timer_flags |= THREAD_CALL_DELAY_USER_NORMAL;

			<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_LEEWAY)
				timer_flags |= THREAD_CALL_DELAY_LEEWAY;

			thread_call_enter_delayed_with_leeway(kn-&gt;kn_hook, NULL,
					kn-&gt;kn_ext[0], kn-&gt;kn_ext[1], timer_flags);

			kn-&gt;kn_hookid |= TIMER_RUNNING;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* pretend the timer has fired */</span>
			kn-&gt;kn_data = 1;
		}

		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">EVENT_PROCESS</span>:
		<span class="enscript-comment">/* reset the timer pop count in kn_data */</span>
		*kev = kn-&gt;kn_kevent;
		kev-&gt;ext[0] = 0;
		kn-&gt;kn_data = 0;
		<span class="enscript-keyword">if</span> (kn-&gt;kn_flags &amp; EV_CLEAR)
			kn-&gt;kn_fflags = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;%s: - invalid type (%ld)&quot;</span>, __func__, type);
		<span class="enscript-keyword">break</span>;
	}

	filt_timerunlock();
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_timerlock</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_lock(&amp;_filt_timerlock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_timerunlock</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_unlock(&amp;_filt_timerlock);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_userattach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-comment">/* EVFILT_USER knotes are not attached to anything in the kernel */</span>
	kn-&gt;kn_hook = NULL;
	<span class="enscript-keyword">if</span> (kn-&gt;kn_fflags &amp; NOTE_TRIGGER) {
		kn-&gt;kn_hookid = 1;
	} <span class="enscript-keyword">else</span> {
		kn-&gt;kn_hookid = 0;
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_userdetach</span>(__unused <span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-comment">/* EVFILT_USER knotes are not attached to anything in the kernel */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_user</span>(<span class="enscript-type">struct</span> knote *kn, __unused <span class="enscript-type">long</span> hint)
{
	<span class="enscript-keyword">return</span> (kn-&gt;kn_hookid);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_usertouch</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">struct</span> kevent_internal_s *kev, <span class="enscript-type">long</span> type)
{
	uint32_t ffctrl;
	<span class="enscript-keyword">switch</span> (type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EVENT_REGISTER</span>:
		<span class="enscript-keyword">if</span> (kev-&gt;fflags &amp; NOTE_TRIGGER) {
			kn-&gt;kn_hookid = 1;
		}

		ffctrl = kev-&gt;fflags &amp; NOTE_FFCTRLMASK;
		kev-&gt;fflags &amp;= NOTE_FFLAGSMASK;
		<span class="enscript-keyword">switch</span> (ffctrl) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NOTE_FFNOP</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NOTE_FFAND</span>:
			OSBitAndAtomic(kev-&gt;fflags, &amp;kn-&gt;kn_sfflags);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NOTE_FFOR</span>:
			OSBitOrAtomic(kev-&gt;fflags, &amp;kn-&gt;kn_sfflags);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">NOTE_FFCOPY</span>:
			kn-&gt;kn_sfflags = kev-&gt;fflags;
			<span class="enscript-keyword">break</span>;
		}
		kn-&gt;kn_sdata = kev-&gt;data;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EVENT_PROCESS</span>:
		*kev = kn-&gt;kn_kevent;
		kev-&gt;fflags = (<span class="enscript-type">volatile</span> UInt32)kn-&gt;kn_sfflags;
		kev-&gt;data = kn-&gt;kn_sdata;
		<span class="enscript-keyword">if</span> (kn-&gt;kn_flags &amp; EV_CLEAR) {
			kn-&gt;kn_hookid = 0;
			kn-&gt;kn_data = 0;
			kn-&gt;kn_fflags = 0;
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;%s: - invalid type (%ld)&quot;</span>, __func__, type);
		<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-comment">/*
 * JMM - placeholder for not-yet-implemented filters
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_badattach</span>(__unused <span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-type">struct</span> kqueue *
<span class="enscript-function-name">kqueue_alloc</span>(<span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> kqueue *kq;

	MALLOC_ZONE(kq, <span class="enscript-type">struct</span> kqueue *, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kqueue), M_KQUEUE,
	    M_WAITOK);
	<span class="enscript-keyword">if</span> (kq != NULL) {
		<span class="enscript-type">struct</span> waitq_set *wqs;

		wqs = waitq_set_alloc(SYNC_POLICY_FIFO | SYNC_POLICY_PREPOST | SYNC_POLICY_DISABLE_IRQ);
		<span class="enscript-keyword">if</span> (wqs != NULL) {
			bzero(kq, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kqueue));
			lck_spin_init(&amp;kq-&gt;kq_lock, kq_lck_grp, kq_lck_attr);
			TAILQ_INIT(&amp;kq-&gt;kq_head);
			kq-&gt;kq_wqs = wqs;
			kq-&gt;kq_p = p;
		} <span class="enscript-keyword">else</span> {
			FREE_ZONE(kq, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kqueue), M_KQUEUE);
			kq = NULL;
		}
	}

	<span class="enscript-keyword">if</span> (fdp-&gt;fd_knlistsize &lt; 0) {
		proc_fdlock(p);
		<span class="enscript-keyword">if</span> (fdp-&gt;fd_knlistsize &lt; 0)
			fdp-&gt;fd_knlistsize = 0;	<span class="enscript-comment">/* this process has had a kq */</span>
		proc_fdunlock(p);
	}

	<span class="enscript-keyword">return</span> (kq);
}

<span class="enscript-comment">/*
 * kqueue_dealloc - detach all knotes from a kqueue and free it
 *
 * 	We walk each list looking for knotes referencing this
 *	this kqueue.  If we find one, we try to drop it.  But
 *	if we fail to get a drop reference, that will wait
 *	until it is dropped.  So, we can just restart again
 *	safe in the assumption that the list will eventually
 *	not contain any more references to this kqueue (either
 *	we dropped them all, or someone else did).
 *
 *	Assumes no new events are being added to the kqueue.
 *	Nothing locked on entry or exit.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kqueue_dealloc</span>(<span class="enscript-type">struct</span> kqueue *kq)
{
	<span class="enscript-type">struct</span> proc *p;
	<span class="enscript-type">struct</span> filedesc *fdp;
	<span class="enscript-type">struct</span> knote *kn;
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (kq == NULL)
		<span class="enscript-keyword">return</span>;

	p = kq-&gt;kq_p;
	fdp = p-&gt;p_fd;

	proc_fdlock(p);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; fdp-&gt;fd_knlistsize; i++) {
		kn = SLIST_FIRST(&amp;fdp-&gt;fd_knlist[i]);
		<span class="enscript-keyword">while</span> (kn != NULL) {
			<span class="enscript-keyword">if</span> (kq == kn-&gt;kn_kq) {
				kqlock(kq);
				proc_fdunlock(p);
				<span class="enscript-comment">/* drop it ourselves or wait */</span>
				<span class="enscript-keyword">if</span> (kqlock2knotedrop(kq, kn)) {
					kn-&gt;kn_fop-&gt;f_detach(kn);
					knote_drop(kn, p);
				}
				proc_fdlock(p);
				<span class="enscript-comment">/* start over at beginning of list */</span>
				kn = SLIST_FIRST(&amp;fdp-&gt;fd_knlist[i]);
				<span class="enscript-keyword">continue</span>;
			}
			kn = SLIST_NEXT(kn, kn_link);
		}
	}
	<span class="enscript-keyword">if</span> (fdp-&gt;fd_knhashmask != 0) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)fdp-&gt;fd_knhashmask + 1; i++) {
			kn = SLIST_FIRST(&amp;fdp-&gt;fd_knhash[i]);
			<span class="enscript-keyword">while</span> (kn != NULL) {
				<span class="enscript-keyword">if</span> (kq == kn-&gt;kn_kq) {
					kqlock(kq);
					proc_fdunlock(p);
					<span class="enscript-comment">/* drop it ourselves or wait */</span>
					<span class="enscript-keyword">if</span> (kqlock2knotedrop(kq, kn)) {
						kn-&gt;kn_fop-&gt;f_detach(kn);
						knote_drop(kn, p);
					}
					proc_fdlock(p);
					<span class="enscript-comment">/* start over at beginning of list */</span>
					kn = SLIST_FIRST(&amp;fdp-&gt;fd_knhash[i]);
					<span class="enscript-keyword">continue</span>;
				}
				kn = SLIST_NEXT(kn, kn_link);
			}
		}
	}
	proc_fdunlock(p);

	<span class="enscript-comment">/*
	 * waitq_set_free() clears all preposts and also remove the KQ's
	 * waitq set from any select sets to which it may belong.
	 */</span>
	waitq_set_free(kq-&gt;kq_wqs);
	kq-&gt;kq_wqs = NULL;
	lck_spin_destroy(&amp;kq-&gt;kq_lock, kq_lck_grp);
	FREE_ZONE(kq, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kqueue), M_KQUEUE);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kqueue_body</span>(<span class="enscript-type">struct</span> proc *p, fp_allocfn_t fp_zalloc, <span class="enscript-type">void</span> *cra, int32_t *retval)
{
	<span class="enscript-type">struct</span> kqueue *kq;
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">int</span> fd, error;

	error = falloc_withalloc(p,
	    &amp;fp, &amp;fd, vfs_context_current(), fp_zalloc, cra);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> (error);
	}

	kq = kqueue_alloc(p);
	<span class="enscript-keyword">if</span> (kq == NULL) {
		fp_free(p, fd, fp);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	fp-&gt;f_flag = FREAD | FWRITE;
	fp-&gt;f_ops = &amp;kqueueops;
	fp-&gt;f_data = kq;

	proc_fdlock(p);
	*fdflags(p, fd) |= UF_EXCLOSE;
	procfdtbl_releasefd(p, fd, NULL);
	fp_drop(p, fd, fp, 1);
	proc_fdunlock(p);

	*retval = fd;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kqueue</span>(<span class="enscript-type">struct</span> proc *p, __unused <span class="enscript-type">struct</span> kqueue_args *uap, int32_t *retval)
{
	<span class="enscript-keyword">return</span> (kqueue_body(p, fileproc_alloc_init, NULL, retval));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kevent_copyin</span>(user_addr_t *addrp, <span class="enscript-type">struct</span> kevent_internal_s *kevp, <span class="enscript-type">struct</span> proc *p,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">int</span> advance;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (flags &amp; KEVENT_FLAG_LEGACY32) {
		bzero(kevp, <span class="enscript-keyword">sizeof</span> (*kevp));

		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			<span class="enscript-type">struct</span> user64_kevent kev64;

			advance = <span class="enscript-keyword">sizeof</span> (kev64);
			error = copyin(*addrp, (caddr_t)&amp;kev64, advance);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
			kevp-&gt;ident = kev64.ident;
			kevp-&gt;filter = kev64.filter;
			kevp-&gt;flags = kev64.flags;
			kevp-&gt;udata = kev64.udata;
			kevp-&gt;fflags = kev64.fflags;
			kevp-&gt;data = kev64.data;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_kevent kev32;

			advance = <span class="enscript-keyword">sizeof</span> (kev32);
			error = copyin(*addrp, (caddr_t)&amp;kev32, advance);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> (error);
			kevp-&gt;ident = (uintptr_t)kev32.ident;
			kevp-&gt;filter = kev32.filter;
			kevp-&gt;flags = kev32.flags;
			kevp-&gt;udata = CAST_USER_ADDR_T(kev32.udata);
			kevp-&gt;fflags = kev32.fflags;
			kevp-&gt;data = (intptr_t)kev32.data;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; KEVENT_FLAG_LEGACY64) {
		<span class="enscript-type">struct</span> kevent64_s kev64;

		bzero(kevp, <span class="enscript-keyword">sizeof</span> (*kevp));

		advance = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kevent64_s);
		error = copyin(*addrp, (caddr_t)&amp;kev64, advance);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span>(error);
		kevp-&gt;ident = kev64.ident;
		kevp-&gt;filter = kev64.filter;
		kevp-&gt;flags = kev64.flags;
		kevp-&gt;udata = kev64.udata;
		kevp-&gt;fflags = kev64.fflags;
		kevp-&gt;data = kev64.data;
		kevp-&gt;ext[0] = kev64.ext[0];
		kevp-&gt;ext[1] = kev64.ext[1];
		
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> kevent_qos_s kevqos;

		bzero(kevp, <span class="enscript-keyword">sizeof</span> (*kevp));

		advance = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kevent_qos_s);
		error = copyin(*addrp, (caddr_t)&amp;kevqos, advance);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> error;
		kevp-&gt;ident = kevqos.ident;
		kevp-&gt;filter = kevqos.filter;
		kevp-&gt;flags = kevqos.flags;
		kevp-&gt;udata = kevqos.udata;
		kevp-&gt;fflags = kevqos.fflags;
		kevp-&gt;data = kevqos.data;
		kevp-&gt;ext[0] = kevqos.ext[0];
		kevp-&gt;ext[1] = kevqos.ext[1];
	}
	<span class="enscript-keyword">if</span> (!error)
		*addrp += advance;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kevent_copyout</span>(<span class="enscript-type">struct</span> kevent_internal_s *kevp, user_addr_t *addrp, <span class="enscript-type">struct</span> proc *p,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags)
{
	user_addr_t addr = *addrp;
	<span class="enscript-type">int</span> advance;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (flags &amp; KEVENT_FLAG_LEGACY32) {
		assert((flags &amp; KEVENT_FLAG_STACK_EVENTS) == 0);

		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			<span class="enscript-type">struct</span> user64_kevent kev64;

			<span class="enscript-comment">/*
			 * deal with the special case of a user-supplied
			 * value of (uintptr_t)-1.
			 */</span>
			kev64.ident = (kevp-&gt;ident == (uintptr_t)-1) ?
				(uint64_t)-1LL : (uint64_t)kevp-&gt;ident;

			kev64.filter = kevp-&gt;filter;
			kev64.flags = kevp-&gt;flags;
			kev64.fflags = kevp-&gt;fflags;
			kev64.data = (int64_t) kevp-&gt;data;
			kev64.udata = kevp-&gt;udata;
			advance = <span class="enscript-keyword">sizeof</span> (kev64);
			error = copyout((caddr_t)&amp;kev64, addr, advance);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_kevent kev32;

			kev32.ident = (uint32_t)kevp-&gt;ident;
			kev32.filter = kevp-&gt;filter;
			kev32.flags = kevp-&gt;flags;
			kev32.fflags = kevp-&gt;fflags;
			kev32.data = (int32_t)kevp-&gt;data;
			kev32.udata = kevp-&gt;udata;
			advance = <span class="enscript-keyword">sizeof</span> (kev32);
			error = copyout((caddr_t)&amp;kev32, addr, advance);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; KEVENT_FLAG_LEGACY64) {
		<span class="enscript-type">struct</span> kevent64_s kev64;

		advance = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kevent64_s);
		<span class="enscript-keyword">if</span> (flags &amp; KEVENT_FLAG_STACK_EVENTS) {
			addr -= advance;
		}
		kev64.ident = kevp-&gt;ident;
		kev64.filter = kevp-&gt;filter;
		kev64.flags = kevp-&gt;flags;
		kev64.fflags = kevp-&gt;fflags;
		kev64.data = (int64_t) kevp-&gt;data;
		kev64.udata = kevp-&gt;udata;
		kev64.ext[0] = kevp-&gt;ext[0];
		kev64.ext[1] = kevp-&gt;ext[1];
		error = copyout((caddr_t)&amp;kev64, addr, advance);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> kevent_qos_s kevqos;
	
		bzero(&amp;kevqos, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kevent_qos_s));
		advance = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> kevent_qos_s);
		<span class="enscript-keyword">if</span> (flags &amp; KEVENT_FLAG_STACK_EVENTS) {
			addr -= advance;
		}
		kevqos.ident = kevp-&gt;ident;
		kevqos.filter = kevp-&gt;filter;
		kevqos.flags = kevp-&gt;flags;
		kevqos.fflags = kevp-&gt;fflags;
		kevqos.data = (int64_t) kevp-&gt;data;
		kevqos.udata = kevp-&gt;udata;
		kevqos.ext[0] = kevp-&gt;ext[0];
		kevqos.ext[1] = kevp-&gt;ext[1];
		error = copyout((caddr_t)&amp;kevqos, addr, advance);
	}
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-keyword">if</span> (flags &amp; KEVENT_FLAG_STACK_EVENTS)
			*addrp = addr;
		<span class="enscript-keyword">else</span>
			*addrp = addr + advance;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * kevent_continue - continue a kevent syscall after blocking
 *
 *	assume we inherit a use count on the kq fileglob.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kevent_continue</span>(__unused <span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">void</span> *data, <span class="enscript-type">int</span> error)
{
	<span class="enscript-type">struct</span> _kevent *cont_args;
	<span class="enscript-type">struct</span> fileproc *fp;
	int32_t *retval;
	<span class="enscript-type">int</span> noutputs;
	<span class="enscript-type">int</span> fd;
	<span class="enscript-type">struct</span> proc *p = current_proc();

	cont_args = (<span class="enscript-type">struct</span> _kevent *)data;
	noutputs = cont_args-&gt;eventout;
	retval = cont_args-&gt;retval;
	fd = cont_args-&gt;fd;
	fp = cont_args-&gt;fp;

	<span class="enscript-keyword">if</span> (fp != NULL)
		fp_drop(p, fd, fp, 0);

	<span class="enscript-comment">/* don't restart after signals... */</span>
	<span class="enscript-keyword">if</span> (error == ERESTART)
		error = EINTR;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == EWOULDBLOCK)
		error = 0;
	<span class="enscript-keyword">if</span> (error == 0)
		*retval = noutputs;
	unix_syscall_return(error);
}

<span class="enscript-comment">/*
 * kevent - [syscall] register and wait for kernel events
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kevent</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> kevent_args *uap, int32_t *retval)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags = KEVENT_FLAG_LEGACY32;

	<span class="enscript-keyword">return</span> kevent_internal(p,
			       uap-&gt;fd,
			       uap-&gt;changelist, uap-&gt;nchanges,
			       uap-&gt;eventlist, uap-&gt;nevents,
			       0ULL, 0ULL,
			       flags,
			       uap-&gt;timeout,
			       kevent_continue,
			       retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kevent64</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> kevent64_args *uap, int32_t *retval)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags;

	<span class="enscript-comment">/* restrict to user flags and set legacy64 */</span>
	flags = uap-&gt;flags &amp; KEVENT_FLAG_USER;
	flags |= KEVENT_FLAG_LEGACY64;

	<span class="enscript-keyword">return</span> kevent_internal(p,
			       uap-&gt;fd,
			       uap-&gt;changelist, uap-&gt;nchanges,
			       uap-&gt;eventlist, uap-&gt;nevents,
			       0ULL, 0ULL,
			       flags,
			       uap-&gt;timeout,
			       kevent_continue,
			       retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kevent_qos</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> kevent_qos_args *uap, int32_t *retval)
{
	user_size_t usize = 0;
	user_size_t ssize;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* restrict to user flags */</span>
	uap-&gt;flags &amp;= KEVENT_FLAG_USER;

	<span class="enscript-keyword">if</span> (uap-&gt;data_available) {
		<span class="enscript-keyword">if</span> (!IS_64BIT_PROCESS(p)) {
			uint32_t csize;

			error = copyin(uap-&gt;data_available, (caddr_t)&amp;csize, <span class="enscript-keyword">sizeof</span>(csize));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> error;
			usize = csize;
		} <span class="enscript-keyword">else</span> {
			uint64_t csize;
			error = copyin(uap-&gt;data_available, (caddr_t)&amp;csize, <span class="enscript-keyword">sizeof</span>(csize));
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">return</span> error;
			usize = csize;
		}
	}
	ssize = usize;

	error = kevent_internal(p,
				uap-&gt;fd,
				uap-&gt;changelist, uap-&gt;nchanges,
				uap-&gt;eventlist,	uap-&gt;nevents,
				uap-&gt;data_out, &amp;usize,
				uap-&gt;flags,
				0ULL,
				kevent_continue,
				retval);

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; uap-&gt;data_available &amp;&amp; usize != ssize) {
		<span class="enscript-keyword">if</span> (!IS_64BIT_PROCESS(p)) {
			uint32_t csize = (uint32_t)usize;

			error = copyout((caddr_t)&amp;csize, uap-&gt;data_available, <span class="enscript-keyword">sizeof</span>(csize));
		} <span class="enscript-keyword">else</span> {
			error = copyout((caddr_t)&amp;usize, uap-&gt;data_available, <span class="enscript-keyword">sizeof</span>(usize));
		}
	}
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">kevent_qos_internal</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">int</span> fd, 
		    user_addr_t changelist, <span class="enscript-type">int</span> nchanges,
		    user_addr_t eventlist, <span class="enscript-type">int</span> nevents,
		    user_addr_t data_out, user_size_t *data_available,
		    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags, 
		    int32_t *retval) 
{
	<span class="enscript-keyword">return</span> kevent_internal(p,
			       fd,
			       changelist, nchanges,
			       eventlist, nevents,
			       data_out, data_available,
			       flags,
			       0ULL,
			       NULL,
			       retval);
}
 
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kevent_internal</span>(<span class="enscript-type">struct</span> proc *p, 
		<span class="enscript-type">int</span> fd,
		user_addr_t changelist, <span class="enscript-type">int</span> nchanges,
		user_addr_t ueventlist, <span class="enscript-type">int</span> nevents,
		user_addr_t data_out, user_size_t *data_available,
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> flags, 
		user_addr_t utimeout,
		kqueue_continue_t continuation,
		int32_t *retval)
{
	<span class="enscript-type">struct</span> _kevent *cont_args;
	uthread_t ut;
	<span class="enscript-type">struct</span> kqueue *kq;
	<span class="enscript-type">struct</span> fileproc *fp = NULL;
	<span class="enscript-type">struct</span> kevent_internal_s kev;
	<span class="enscript-type">int</span> error, noutputs;
	<span class="enscript-type">struct</span> timeval atv;

#<span class="enscript-reference">if</span> 1
	<span class="enscript-comment">/* temporarily ignore these fields */</span>
	(<span class="enscript-type">void</span>)data_out;
	(<span class="enscript-type">void</span>)data_available;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* prepare to deal with stack-wise allocation of out events */</span>
	<span class="enscript-keyword">if</span> (flags &amp; KEVENT_FLAG_STACK_EVENTS) {
		<span class="enscript-type">int</span> scale = ((flags &amp; KEVENT_FLAG_LEGACY32) ? 
			     (IS_64BIT_PROCESS(p) ? <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user64_kevent) :
			                            <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_kevent)) :
			     ((flags &amp; KEVENT_FLAG_LEGACY64) ? <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevent64_s) :
			                                       <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevent_qos_s)));
		ueventlist += nevents * scale;
	}

	<span class="enscript-comment">/* convert timeout to absolute - if we have one (and not immediate) */</span>
	<span class="enscript-keyword">if</span> (flags &amp; KEVENT_FLAG_IMMEDIATE) {
		getmicrouptime(&amp;atv);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (utimeout != USER_ADDR_NULL) {
		<span class="enscript-type">struct</span> timeval rtv;
		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			<span class="enscript-type">struct</span> user64_timespec ts;
			error = copyin(utimeout, &amp;ts, <span class="enscript-keyword">sizeof</span>(ts));
			<span class="enscript-keyword">if</span> ((ts.tv_sec &amp; 0xFFFFFFFF00000000ull) != 0)
				error = EINVAL;
			<span class="enscript-keyword">else</span>
				TIMESPEC_TO_TIMEVAL(&amp;rtv, &amp;ts);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_timespec ts;
			error = copyin(utimeout, &amp;ts, <span class="enscript-keyword">sizeof</span>(ts));
			TIMESPEC_TO_TIMEVAL(&amp;rtv, &amp;ts);
		}
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
		<span class="enscript-keyword">if</span> (itimerfix(&amp;rtv))
			<span class="enscript-keyword">return</span> (EINVAL);
		getmicrouptime(&amp;atv);
		timevaladd(&amp;atv, &amp;rtv);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* wait forever value */</span>
		atv.tv_sec = 0;
		atv.tv_usec = 0;
	}

	<span class="enscript-keyword">if</span> (flags &amp; KEVENT_FLAG_WORKQ) {
		<span class="enscript-comment">/*
		 * use the private kq associated with the proc workq.
		 * Just being a thread within the process (and not
		 * being the exit/exec thread) is enough to hold a
		 * reference on this special kq.
		 */</span>
		kq = p-&gt;p_wqkqueue;
		<span class="enscript-keyword">if</span> (kq == NULL) {
			<span class="enscript-type">struct</span> kqueue *alloc_kq = kqueue_alloc(p);
			<span class="enscript-keyword">if</span> (alloc_kq == NULL)
				<span class="enscript-keyword">return</span> ENOMEM;

			proc_fdlock(p);
			<span class="enscript-keyword">if</span> (p-&gt;p_wqkqueue == NULL) {
				<span class="enscript-comment">/*
				 * The kq is marked as special -
				 * with unique interactions with
				 * the workq for this process.
				 */</span>
				alloc_kq-&gt;kq_state |= KQ_WORKQ;
				kq = p-&gt;p_wqkqueue = alloc_kq;
				proc_fdunlock(p);
			} <span class="enscript-keyword">else</span> {
				proc_fdunlock(p);
				kq = p-&gt;p_wqkqueue;
				kqueue_dealloc(alloc_kq);
			}
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* get a usecount for the kq itself */</span>
		<span class="enscript-keyword">if</span> ((error = fp_getfkq(p, fd, &amp;fp, &amp;kq)) != 0)
			<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-comment">/* each kq should only be used for events of one type */</span>
	kqlock(kq);
	<span class="enscript-keyword">if</span> (kq-&gt;kq_state &amp; (KQ_KEV32 | KQ_KEV64 | KQ_KEV_QOS)) {
		<span class="enscript-keyword">if</span> (flags &amp; KEVENT_FLAG_LEGACY32) {
			<span class="enscript-keyword">if</span> ((kq-&gt;kq_state &amp; KQ_KEV32) == 0) {
				error = EINVAL;
				kqunlock(kq);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">errorout</span>;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kq-&gt;kq_state &amp; KQ_KEV32) {
			error = EINVAL;
			kqunlock(kq);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">errorout</span>;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; KEVENT_FLAG_LEGACY32) {
		kq-&gt;kq_state |= KQ_KEV32;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* JMM - set KQ_KEVQOS when we are ready for exclusive */</span>
		kq-&gt;kq_state |= KQ_KEV64;
	}
	kqunlock(kq);

	<span class="enscript-comment">/* register all the change requests the user provided... */</span>
	noutputs = 0;
	<span class="enscript-keyword">while</span> (nchanges &gt; 0 &amp;&amp; error == 0) {
		error = kevent_copyin(&amp;changelist, &amp;kev, p, flags);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;

		kev.flags &amp;= ~EV_SYSFLAGS;
		error = kevent_register(kq, &amp;kev, p);
		<span class="enscript-keyword">if</span> ((error || (kev.flags &amp; EV_RECEIPT)) &amp;&amp; nevents &gt; 0) {
			kev.flags = EV_ERROR;
			kev.data = error;
			error = kevent_copyout(&amp;kev, &amp;ueventlist, p, flags);
			<span class="enscript-keyword">if</span> (error == 0) {
				nevents--;
				noutputs++;
			}
		}
		nchanges--;
	}

	<span class="enscript-comment">/* short-circuit the scan if we only want error events */</span>
	<span class="enscript-keyword">if</span> (flags &amp; KEVENT_FLAG_ERROR_EVENTS) 
		nevents = 0;

	<span class="enscript-keyword">if</span> (nevents &gt; 0 &amp;&amp; noutputs == 0 &amp;&amp; error == 0) {

		<span class="enscript-comment">/* store the continuation/completion data in the uthread */</span>
		ut = (uthread_t)get_bsdthread_info(current_thread());
		cont_args = &amp;ut-&gt;uu_kevent.ss_kevent;
		cont_args-&gt;fp = fp;
		cont_args-&gt;fd = fd;
		cont_args-&gt;retval = retval;
		cont_args-&gt;eventlist = ueventlist;
		cont_args-&gt;eventcount = nevents;
		cont_args-&gt;eventout = noutputs;
		cont_args-&gt;eventflags = flags;

		error = kqueue_scan(kq, kevent_callback,
		                    continuation, cont_args,
		                    &amp;atv, p);

		noutputs = cont_args-&gt;eventout;
	}

	<span class="enscript-comment">/* don't restart after signals... */</span>
	<span class="enscript-keyword">if</span> (error == ERESTART)
		error = EINTR;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == EWOULDBLOCK)
		error = 0;
	<span class="enscript-keyword">if</span> (error == 0)
		*retval = noutputs;
<span class="enscript-reference">errorout</span>:
	<span class="enscript-keyword">if</span> (fp != NULL)
		fp_drop(p, fd, fp, 0);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * kevent_callback - callback for each individual event
 *
 * called with nothing locked
 * caller holds a reference on the kqueue
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kevent_callback</span>(__unused <span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">struct</span> kevent_internal_s *kevp,
    <span class="enscript-type">void</span> *data)
{
	<span class="enscript-type">struct</span> _kevent *cont_args;
	<span class="enscript-type">int</span> error;

	cont_args = (<span class="enscript-type">struct</span> _kevent *)data;
	assert(cont_args-&gt;eventout &lt; cont_args-&gt;eventcount);

	<span class="enscript-comment">/*
	 * Copy out the appropriate amount of event data for this user.
	 */</span>
	error = kevent_copyout(kevp, &amp;cont_args-&gt;eventlist, current_proc(),
			       cont_args-&gt;eventflags);

	<span class="enscript-comment">/*
	 * If there isn't space for additional events, return
	 * a harmless error to stop the processing here
	 */</span>
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; ++cont_args-&gt;eventout == cont_args-&gt;eventcount)
		error = EWOULDBLOCK;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * kevent_description - format a description of a kevent for diagnostic output
 *
 * called with a 256-byte string buffer
 */</span>

<span class="enscript-type">char</span> *
<span class="enscript-function-name">kevent_description</span>(<span class="enscript-type">struct</span> kevent_internal_s *kevp, <span class="enscript-type">char</span> *s, size_t n)
{
	snprintf(s, n,
	    <span class="enscript-string">&quot;kevent=&quot;</span>
	    <span class="enscript-string">&quot;{.ident=%#llx, .filter=%d, .flags=%#x, .udata=%#llx, .fflags=%#x, .data=%#llx, .ext[0]=%#llx, .ext[1]=%#llx}&quot;</span>,
	    kevp-&gt;ident,
	    kevp-&gt;filter,
	    kevp-&gt;flags,
	    kevp-&gt;udata,
	    kevp-&gt;fflags,
	    kevp-&gt;data,
	    kevp-&gt;ext[0],
	    kevp-&gt;ext[1] );

	<span class="enscript-keyword">return</span> (s);
}

<span class="enscript-comment">/*
 * kevent_register - add a new event to a kqueue
 *
 *	Creates a mapping between the event source and
 *	the kqueue via a knote data structure.
 *
 *	Because many/most the event sources are file
 *	descriptor related, the knote is linked off
 *	the filedescriptor table for quick access.
 *
 *	called with nothing locked
 *	caller holds a reference on the kqueue
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">kevent_register</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">struct</span> kevent_internal_s *kev,
    __unused <span class="enscript-type">struct</span> proc *ctxp)
{
	<span class="enscript-type">struct</span> proc *p = kq-&gt;kq_p;
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> filterops *fops;
	<span class="enscript-type">struct</span> fileproc *fp = NULL;
	<span class="enscript-type">struct</span> knote *kn = NULL;
	<span class="enscript-type">struct</span> klist *list;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (kev-&gt;filter &lt; 0) {
		<span class="enscript-keyword">if</span> (kev-&gt;filter + EVFILT_SYSCOUNT &lt; 0)
			<span class="enscript-keyword">return</span> (EINVAL);
		fops = sysfilt_ops[~kev-&gt;filter];	<span class="enscript-comment">/* to 0-base index */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

<span class="enscript-reference">restart</span>:
	<span class="enscript-comment">/* this iocount needs to be dropped if it is not registered */</span>
	list = NULL;
	proc_fdlock(p);

	<span class="enscript-comment">/* 
	 * determine where to look for the knote
	 */</span>
	<span class="enscript-keyword">if</span> (fops-&gt;f_isfd) {
		<span class="enscript-keyword">if</span> ((error = fp_lookup(p, kev-&gt;ident, &amp;fp, 1)) != 0) {
			proc_fdunlock(p);
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-comment">/* fd-based knotes are linked off the fd table */</span>
		<span class="enscript-keyword">if</span> (kev-&gt;ident &lt; (u_int)fdp-&gt;fd_knlistsize) {
			list = &amp;fdp-&gt;fd_knlist[kev-&gt;ident];
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fdp-&gt;fd_knhashmask != 0) {
		<span class="enscript-comment">/* hash non-fd knotes here too */</span>
		list = &amp;fdp-&gt;fd_knhash[KN_HASH((u_long)kev-&gt;ident, fdp-&gt;fd_knhashmask)];
	}

	<span class="enscript-comment">/*
	 * scan the selected list looking for a match
	 */</span>
	<span class="enscript-keyword">if</span> (list != NULL) {
		SLIST_FOREACH(kn, list, kn_link) {
			<span class="enscript-keyword">if</span> (kq == kn-&gt;kn_kq &amp;&amp;
			    kev-&gt;ident == kn-&gt;kn_id &amp;&amp; 
			    kev-&gt;filter == kn-&gt;kn_filter) {
				<span class="enscript-keyword">if</span> (kev-&gt;flags &amp; EV_UDATA_SPECIFIC) {
					<span class="enscript-keyword">if</span> ((kn-&gt;kn_flags &amp; EV_UDATA_SPECIFIC) &amp;&amp;
					    kev-&gt;udata == kn-&gt;kn_udata) {
						<span class="enscript-keyword">break</span>; <span class="enscript-comment">/* matching udata-specific knote */</span>
					}
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((kn-&gt;kn_flags &amp; EV_UDATA_SPECIFIC) == 0) {
					<span class="enscript-keyword">break</span>; <span class="enscript-comment">/* matching non-udata-specific knote */</span>
				}
			}
		}
	}

	<span class="enscript-comment">/*
	 * kn now contains the matching knote, or NULL if no match
	 */</span>
	<span class="enscript-keyword">if</span> (kn == NULL) {
		<span class="enscript-keyword">if</span> ((kev-&gt;flags &amp; (EV_ADD|EV_DELETE)) == EV_ADD) {
			kn = knote_alloc();
			<span class="enscript-keyword">if</span> (kn == NULL) {
				proc_fdunlock(p);
				error = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			kn-&gt;kn_fp = fp;
			kn-&gt;kn_kq = kq;
			kn-&gt;kn_tq = &amp;kq-&gt;kq_head;
			kn-&gt;kn_fop = fops;
			kn-&gt;kn_sfflags = kev-&gt;fflags;
			kn-&gt;kn_sdata = kev-&gt;data;
			kev-&gt;fflags = 0;
			kev-&gt;data = 0;
			kn-&gt;kn_kevent = *kev;
			kn-&gt;kn_inuse = 1;  <span class="enscript-comment">/* for f_attach() */</span>
			kn-&gt;kn_status = KN_ATTACHING;

			<span class="enscript-comment">/* before anyone can find it */</span>
			<span class="enscript-keyword">if</span> (kev-&gt;flags &amp; EV_DISABLE)
				kn-&gt;kn_status |= KN_DISABLED;

			error = knote_fdpattach(kn, fdp, p);
			proc_fdunlock(p);

			<span class="enscript-keyword">if</span> (error) {
				knote_free(kn);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}

			<span class="enscript-comment">/*
			 * apply reference count to knote structure, and
			 * do not release it at the end of this routine.
			 */</span>
			fp = NULL;

			error = fops-&gt;f_attach(kn);

			kqlock(kq);

			<span class="enscript-keyword">if</span> (error != 0) {
				<span class="enscript-comment">/*
				 * Failed to attach correctly, so drop.
				 * All other possible users/droppers
				 * have deferred to us.
				 */</span>
				kn-&gt;kn_status |= KN_DROPPING;
				kqunlock(kq);
				knote_drop(kn, p);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kn-&gt;kn_status &amp; KN_DROPPING) {
				<span class="enscript-comment">/*
				 * Attach succeeded, but someone else
				 * deferred their drop - now we have
				 * to do it for them (after detaching).
				 */</span>
				kqunlock(kq);
				kn-&gt;kn_fop-&gt;f_detach(kn);
				knote_drop(kn, p);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}
			kn-&gt;kn_status &amp;= ~KN_ATTACHING;
			kqunlock(kq);
		} <span class="enscript-keyword">else</span> {
			proc_fdunlock(p);
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* existing knote - get kqueue lock */</span>
		kqlock(kq);
		proc_fdunlock(p);

		<span class="enscript-keyword">if</span> (kev-&gt;flags &amp; EV_DELETE) {
			<span class="enscript-keyword">if</span> ((kev-&gt;flags &amp; EV_ENABLE) == 0 &amp;&amp;
			    (kev-&gt;flags &amp; EV_DISPATCH2) == EV_DISPATCH2 &amp;&amp;
			    (kn-&gt;kn_status &amp; KN_DISABLED) == KN_DISABLED) {
				<span class="enscript-comment">/* mark for deferred drop */</span>
				kn-&gt;kn_status |= KN_DEFERDROP;
				kqunlock(kq);
				error = EINPROGRESS;
			} <span class="enscript-keyword">else</span> {
				knote_dequeue(kn);
				kn-&gt;kn_status |= KN_DISABLED;
				<span class="enscript-keyword">if</span> (kqlock2knotedrop(kq, kn)) {
					kn-&gt;kn_fop-&gt;f_detach(kn);
					knote_drop(kn, p);
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/* pretend we didn't find it */</span>
					error = ENOENT;
				}
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		<span class="enscript-comment">/* update status flags for existing knote */</span>
		<span class="enscript-keyword">if</span> (kev-&gt;flags &amp; EV_DISABLE) {
			knote_dequeue(kn);
			kn-&gt;kn_status |= KN_DISABLED;

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((kev-&gt;flags &amp; EV_ENABLE) &amp;&amp;
			   (kn-&gt;kn_status &amp; KN_DISABLED)) {
			kn-&gt;kn_status &amp;= ~KN_DISABLED;

			<span class="enscript-comment">/* handle deferred drop */</span>
			<span class="enscript-keyword">if</span> (kn-&gt;kn_status &amp; KN_DEFERDROP) {
				kn-&gt;kn_status &amp;= ~KN_DEFERDROP;
				kn-&gt;kn_flags |= (EV_DELETE | EV_ONESHOT);
				knote_activate(kn, 0);
				kqunlock(kq);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
			}

			<span class="enscript-keyword">if</span> (kn-&gt;kn_status &amp; KN_ACTIVE) {
				<span class="enscript-comment">/* force re-activate if previously active */</span>
				knote_activate(kn, 1);
			}
		}

		<span class="enscript-comment">/*
		 * The user may change some filter values after the
		 * initial EV_ADD, but doing so will not reset any
		 * filter which have already been triggered.
		 */</span>
		kn-&gt;kn_kevent.udata = kev-&gt;udata;
		<span class="enscript-keyword">if</span> (fops-&gt;f_isfd || fops-&gt;f_touch == NULL) {
			kn-&gt;kn_sfflags = kev-&gt;fflags;
			kn-&gt;kn_sdata = kev-&gt;data;
		}

		<span class="enscript-comment">/*
		 * If somebody is in the middle of dropping this
		 * knote - go find/insert a new one.  But we have
		 * wait for this one to go away first. Attaches
		 * running in parallel may also drop/modify the
		 * knote.  Wait for those to complete as well and
		 * then start over if we encounter one.
		 */</span>
		<span class="enscript-keyword">if</span> (!kqlock2knoteusewait(kq, kn)) {
			<span class="enscript-comment">/* kqueue, proc_fdlock both unlocked */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		}

		<span class="enscript-comment">/*
		 * Call touch routine to notify filter of changes
		 * in filter values.
		 */</span>
		<span class="enscript-keyword">if</span> (!fops-&gt;f_isfd &amp;&amp; fops-&gt;f_touch != NULL)
			fops-&gt;f_touch(kn, kev, EVENT_REGISTER);
	}
	<span class="enscript-comment">/* still have use ref on knote */</span>

	<span class="enscript-comment">/*
	 * Invoke the filter routine to see if it should be enqueued now.
	 */</span>
#<span class="enscript-reference">if</span> 0
	<span class="enscript-keyword">if</span> (kn-&gt;kn_fop-&gt;f_event(kn, 0)) {
#<span class="enscript-reference">else</span>
	<span class="enscript-comment">/*
	 * JMM - temporary workaround until rdar://problem/19986199 
	 * This potentially results in extra wakeups for KN_STAYQUEUED event types,
	 * but waking up only truly active ones (yet trying below to determine
	 * active status, by invoking the filter routine, is having side-effects).
	 */</span>
	<span class="enscript-keyword">if</span> ((kn-&gt;kn_status &amp; KN_STAYQUEUED) || kn-&gt;kn_fop-&gt;f_event(kn, 0)) {
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (knoteuse2kqlock(kq, kn))
			knote_activate(kn, (kn-&gt;kn_status &amp; KN_STAYQUEUED));
		kqunlock(kq);
	} <span class="enscript-keyword">else</span> {
		knote_put(kn);
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (fp != NULL)
		fp_drop(p, kev-&gt;ident, fp, 0);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * knote_process - process a triggered event
 *
 *	Validate that it is really still a triggered event
 *	by calling the filter routines (if necessary).  Hold
 *	a use reference on the knote to avoid it being detached.
 *	If it is still considered triggered, invoke the callback
 *	routine provided and move it to the provided inprocess
 *	queue.
 *
 *	caller holds a reference on the kqueue.
 *	kqueue locked on entry and exit - but may be dropped
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">knote_process</span>(<span class="enscript-type">struct</span> knote *kn,
    kevent_callback_t callback,
    <span class="enscript-type">void</span> *data,
    <span class="enscript-type">struct</span> kqtailq *inprocessp,
    <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> kqueue *kq = kn-&gt;kn_kq;
	<span class="enscript-type">struct</span> kevent_internal_s kev;
	<span class="enscript-type">int</span> touch;
	<span class="enscript-type">int</span> result;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * Determine the kevent state we want to return.
	 *
	 * Some event states need to be revalidated before returning
	 * them, others we take the snapshot at the time the event
	 * was enqueued.
	 *
	 * Events with non-NULL f_touch operations must be touched.
	 * Triggered events must fill in kev for the callback.
	 *
	 * Convert our lock to a use-count and call the event's
	 * filter routine(s) to update.
	 */</span>
	<span class="enscript-keyword">if</span> ((kn-&gt;kn_status &amp; KN_DISABLED) != 0) {
		result = 0;
		touch = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span> revalidate;

		result = 1;
		revalidate = ((kn-&gt;kn_status &amp; KN_STAYQUEUED) != 0 ||
		    (kn-&gt;kn_flags &amp; EV_ONESHOT) == 0);
		touch = (!kn-&gt;kn_fop-&gt;f_isfd &amp;&amp; kn-&gt;kn_fop-&gt;f_touch != NULL);

		<span class="enscript-keyword">if</span> (revalidate || touch) {
			<span class="enscript-keyword">if</span> (revalidate)
				knote_deactivate(kn);

			<span class="enscript-comment">/* call the filter/touch routines with just a ref */</span>
			<span class="enscript-keyword">if</span> (kqlock2knoteuse(kq, kn)) {
				<span class="enscript-comment">/* if we have to revalidate, call the filter */</span>
				<span class="enscript-keyword">if</span> (revalidate) {
					result = kn-&gt;kn_fop-&gt;f_event(kn, 0);
				}

				<span class="enscript-comment">/*
				 * capture the kevent data - using touch if
				 * specified
				 */</span>
				<span class="enscript-keyword">if</span> (result &amp;&amp; touch) {
					kn-&gt;kn_fop-&gt;f_touch(kn, &amp;kev,
					    EVENT_PROCESS);
				}
				<span class="enscript-keyword">if</span> (result &amp;&amp; (kn-&gt;kn_status &amp; KN_TOUCH))
					kn-&gt;kn_fop-&gt;f_touch(kn, &amp;kev,
					    EVENT_PROCESS);

				<span class="enscript-comment">/*
				 * convert back to a kqlock - bail if the knote
				 * went away
				 */</span>
				<span class="enscript-keyword">if</span> (!knoteuse2kqlock(kq, kn)) {
					<span class="enscript-keyword">return</span> (EJUSTRETURN);
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (result) {
					<span class="enscript-comment">/*
					 * if revalidated as alive, make sure
					 * it's active
					 */</span>
					knote_activate(kn, 0);

					<span class="enscript-comment">/*
					 * capture all events that occurred
					 * during filter
					 */</span>
					<span class="enscript-keyword">if</span> (!touch) {
						kev = kn-&gt;kn_kevent;
					}

				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((kn-&gt;kn_status &amp; KN_STAYQUEUED) == 0) {
					<span class="enscript-comment">/*
					 * was already dequeued, so just bail on
					 * this one
					 */</span>
					<span class="enscript-keyword">return</span> (EJUSTRETURN);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">return</span> (EJUSTRETURN);
			}
		} <span class="enscript-keyword">else</span> {
			kev = kn-&gt;kn_kevent;
		}
	}

	<span class="enscript-comment">/* move knote onto inprocess queue */</span>
	assert(kn-&gt;kn_tq == &amp;kq-&gt;kq_head);
	TAILQ_REMOVE(&amp;kq-&gt;kq_head, kn, kn_tqe);
	kn-&gt;kn_tq = inprocessp;
	TAILQ_INSERT_TAIL(inprocessp, kn, kn_tqe);

	<span class="enscript-comment">/*
	 * Determine how to dispatch the knote for future event handling.
	 * not-fired: just return (do not callout).
	 * One-shot: If dispatch2, enter deferred-delete mode (unless this is
	 *           is the deferred delete event delivery itself).  Otherwise,
	 *           deactivate and drop it.
	 * Clear: deactivate and clear the state.
	 * Dispatch: don't clear state, just deactivate it and mark it disabled.
	 * All others: just leave where they are.
	 */</span>

	<span class="enscript-keyword">if</span> (result == 0) {
		<span class="enscript-keyword">return</span> (EJUSTRETURN);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((kn-&gt;kn_flags &amp; EV_ONESHOT) != 0) {
		knote_deactivate(kn);
		<span class="enscript-keyword">if</span> ((kn-&gt;kn_flags &amp; (EV_DISPATCH2|EV_DELETE)) == EV_DISPATCH2) {
			<span class="enscript-comment">/* defer dropping non-delete oneshot dispatch2 events */</span>
			kn-&gt;kn_status |= (KN_DISABLED | KN_DEFERDROP);
			kqunlock(kq);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kqlock2knotedrop(kq, kn)) {
			kn-&gt;kn_fop-&gt;f_detach(kn);
			knote_drop(kn, p);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((kn-&gt;kn_flags &amp; (EV_CLEAR | EV_DISPATCH)) != 0) {
		<span class="enscript-keyword">if</span> ((kn-&gt;kn_flags &amp; EV_DISPATCH) != 0) {
			<span class="enscript-comment">/* deactivate and disable all dispatch knotes */</span>
			knote_deactivate(kn);
			kn-&gt;kn_status |= KN_DISABLED;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!touch || kn-&gt;kn_fflags == 0) {
			<span class="enscript-comment">/* only deactivate if nothing since the touch */</span>
			knote_deactivate(kn);
		}
		<span class="enscript-keyword">if</span> (!touch &amp;&amp; (kn-&gt;kn_flags &amp; EV_CLEAR) != 0) {
			<span class="enscript-comment">/* manually clear non-touch knotes */</span>
			kn-&gt;kn_data = 0;
			kn-&gt;kn_fflags = 0;
		}
		kqunlock(kq);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * leave on inprocess queue.  We'll
		 * move all the remaining ones back
		 * the kq queue and wakeup any
		 * waiters when we are done.
		 */</span>
		kqunlock(kq);
	}

	<span class="enscript-comment">/* callback to handle each event as we find it */</span>
	error = (callback)(kq, &amp;kev, data);

	kqlock(kq);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Return 0 to indicate that processing should proceed,
 * -1 if there is nothing to process.
 *
 * Called with kqueue locked and returns the same way,
 * but may drop lock temporarily.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kqueue_begin_processing</span>(<span class="enscript-type">struct</span> kqueue *kq)
{
	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> (kq-&gt;kq_count == 0) {
			<span class="enscript-keyword">return</span> (-1);
		}

		<span class="enscript-comment">/* if someone else is processing the queue, wait */</span>
		<span class="enscript-keyword">if</span> (kq-&gt;kq_nprocess != 0) {
			waitq_assert_wait64((<span class="enscript-type">struct</span> waitq *)kq-&gt;kq_wqs,
					    CAST_EVENT64_T(&amp;kq-&gt;kq_nprocess),
					    THREAD_UNINT, TIMEOUT_WAIT_FOREVER);
			kq-&gt;kq_state |= KQ_PROCWAIT;
			kqunlock(kq);
			thread_block(THREAD_CONTINUE_NULL);
			kqlock(kq);
		} <span class="enscript-keyword">else</span> {
			kq-&gt;kq_nprocess = 1;
			<span class="enscript-keyword">return</span> (0);
		}
	}
}

<span class="enscript-comment">/*
 * Called with kqueue lock held.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kqueue_end_processing</span>(<span class="enscript-type">struct</span> kqueue *kq)
{
	kq-&gt;kq_nprocess = 0;
	<span class="enscript-keyword">if</span> (kq-&gt;kq_state &amp; KQ_PROCWAIT) {
		kq-&gt;kq_state &amp;= ~KQ_PROCWAIT;
		waitq_wakeup64_all((<span class="enscript-type">struct</span> waitq *)kq-&gt;kq_wqs,
				   CAST_EVENT64_T(&amp;kq-&gt;kq_nprocess),
				   THREAD_AWAKENED,
				   WAITQ_ALL_PRIORITIES);
	}
}

<span class="enscript-comment">/*
 * kqueue_process - process the triggered events in a kqueue
 *
 *	Walk the queued knotes and validate that they are
 *	really still triggered events by calling the filter
 *	routines (if necessary).  Hold a use reference on
 *	the knote to avoid it being detached. For each event
 *	that is still considered triggered, invoke the
 *	callback routine provided.
 *
 *	caller holds a reference on the kqueue.
 *	kqueue locked on entry and exit - but may be dropped
 *	kqueue list locked (held for duration of call)
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kqueue_process</span>(<span class="enscript-type">struct</span> kqueue *kq,
    kevent_callback_t callback,
    <span class="enscript-type">void</span> *data,
    <span class="enscript-type">int</span> *countp,
    <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> kqtailq inprocess;
	<span class="enscript-type">struct</span> knote *kn;
	<span class="enscript-type">int</span> nevents;
	<span class="enscript-type">int</span> error;

	TAILQ_INIT(&amp;inprocess);

	<span class="enscript-keyword">if</span> (kqueue_begin_processing(kq) == -1) {
		*countp = 0;
		<span class="enscript-comment">/* Nothing to process */</span>
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * Clear any pre-posted status from previous runs, so we
	 * only detect events that occur during this run.
	 */</span>
	waitq_set_clear_preposts(kq-&gt;kq_wqs);

	<span class="enscript-comment">/*
	 * loop through the enqueued knotes, processing each one and
	 * revalidating those that need it. As they are processed,
	 * they get moved to the inprocess queue (so the loop can end).
	 */</span>
	error = 0;
	nevents = 0;

	<span class="enscript-keyword">while</span> (error == 0 &amp;&amp;
	    (kn = TAILQ_FIRST(&amp;kq-&gt;kq_head)) != NULL) {
		error = knote_process(kn, callback, data, &amp;inprocess, p);
		<span class="enscript-keyword">if</span> (error == EJUSTRETURN)
			error = 0;
		<span class="enscript-keyword">else</span>
			nevents++;
	}

	<span class="enscript-comment">/*
	 * With the kqueue still locked, move any knotes
	 * remaining on the inprocess queue back to the
	 * kq's queue and wake up any waiters.
	 */</span>
	<span class="enscript-keyword">while</span> ((kn = TAILQ_FIRST(&amp;inprocess)) != NULL) {
		assert(kn-&gt;kn_tq == &amp;inprocess);
		TAILQ_REMOVE(&amp;inprocess, kn, kn_tqe);
		kn-&gt;kn_tq = &amp;kq-&gt;kq_head;
		TAILQ_INSERT_TAIL(&amp;kq-&gt;kq_head, kn, kn_tqe);
	}

	kqueue_end_processing(kq);

	*countp = nevents;
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kqueue_scan_continue</span>(<span class="enscript-type">void</span> *data, wait_result_t wait_result)
{
	thread_t self = current_thread();
	uthread_t ut = (uthread_t)get_bsdthread_info(self);
	<span class="enscript-type">struct</span> _kqueue_scan * cont_args = &amp;ut-&gt;uu_kevent.ss_kqueue_scan;
	<span class="enscript-type">struct</span> kqueue *kq = (<span class="enscript-type">struct</span> kqueue *)data;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> count;

	<span class="enscript-comment">/* convert the (previous) wait_result to a proper error */</span>
	<span class="enscript-keyword">switch</span> (wait_result) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_AWAKENED</span>:
		kqlock(kq);
		error = kqueue_process(kq, cont_args-&gt;call, cont_args, &amp;count,
		    current_proc());
		<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; count == 0) {
			waitq_assert_wait64((<span class="enscript-type">struct</span> waitq *)kq-&gt;kq_wqs,
					    KQ_EVENT, THREAD_ABORTSAFE,
					    cont_args-&gt;deadline);
			kq-&gt;kq_state |= KQ_SLEEP;
			kqunlock(kq);
			thread_block_parameter(kqueue_scan_continue, kq);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		kqunlock(kq);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_TIMED_OUT</span>:
		error = EWOULDBLOCK;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_INTERRUPTED</span>:
		error = EINTR;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;%s: - invalid wait_result (%d)&quot;</span>, __func__,
		    wait_result);
		error = 0;
	}

	<span class="enscript-comment">/* call the continuation with the results */</span>
	assert(cont_args-&gt;cont != NULL);
	(cont_args-&gt;cont)(kq, cont_args-&gt;data, error);
}


<span class="enscript-comment">/*
 * kqueue_scan - scan and wait for events in a kqueue
 *
 *	Process the triggered events in a kqueue.
 *
 *	If there are no events triggered arrange to
 *	wait for them. If the caller provided a
 *	continuation routine, then kevent_scan will
 *	also.
 *
 *	The callback routine must be valid.
 *	The caller must hold a use-count reference on the kq.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">kqueue_scan</span>(<span class="enscript-type">struct</span> kqueue *kq,
	    kevent_callback_t callback,
	    kqueue_continue_t continuation,
	    <span class="enscript-type">void</span> *data,
	    <span class="enscript-type">struct</span> timeval *atvp,
	    <span class="enscript-type">struct</span> proc *p)
{
	thread_continue_t cont = THREAD_CONTINUE_NULL;
	uint64_t deadline;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> first;

	assert(callback != NULL);

	first = 1;
	<span class="enscript-keyword">for</span> (;;) {
		wait_result_t wait_result;
		<span class="enscript-type">int</span> count;

		<span class="enscript-comment">/*
		 * Make a pass through the kq to find events already
		 * triggered.
		 */</span>
		kqlock(kq);
		error = kqueue_process(kq, callback, data, &amp;count, p);
		<span class="enscript-keyword">if</span> (error || count)
			<span class="enscript-keyword">break</span>; <span class="enscript-comment">/* lock still held */</span>

		<span class="enscript-comment">/* looks like we have to consider blocking */</span>
		<span class="enscript-keyword">if</span> (first) {
			first = 0;
			<span class="enscript-comment">/* convert the timeout to a deadline once */</span>
			<span class="enscript-keyword">if</span> (atvp-&gt;tv_sec || atvp-&gt;tv_usec) {
				uint64_t now;

				clock_get_uptime(&amp;now);
				nanoseconds_to_absolutetime((uint64_t)atvp-&gt;tv_sec * NSEC_PER_SEC +
							    atvp-&gt;tv_usec * (<span class="enscript-type">long</span>)NSEC_PER_USEC,
							    &amp;deadline);
				<span class="enscript-keyword">if</span> (now &gt;= deadline) {
					<span class="enscript-comment">/* non-blocking call */</span>
					error = EWOULDBLOCK;
					<span class="enscript-keyword">break</span>; <span class="enscript-comment">/* lock still held */</span>
				}
				deadline -= now;
				clock_absolutetime_interval_to_deadline(deadline, &amp;deadline);
			} <span class="enscript-keyword">else</span> {
				deadline = 0; 	<span class="enscript-comment">/* block forever */</span>
			}

			<span class="enscript-keyword">if</span> (continuation) {
				uthread_t ut = (uthread_t)get_bsdthread_info(current_thread());
				<span class="enscript-type">struct</span> _kqueue_scan *cont_args = &amp;ut-&gt;uu_kevent.ss_kqueue_scan;

				cont_args-&gt;call = callback;
				cont_args-&gt;cont = continuation;
				cont_args-&gt;deadline = deadline;
				cont_args-&gt;data = data;
				cont = kqueue_scan_continue;
			}
		}

		<span class="enscript-comment">/* go ahead and wait */</span>
		waitq_assert_wait64_leeway((<span class="enscript-type">struct</span> waitq *)kq-&gt;kq_wqs,
					   KQ_EVENT, THREAD_ABORTSAFE,
					   TIMEOUT_URGENCY_USER_NORMAL,
					   deadline, TIMEOUT_NO_LEEWAY);
		kq-&gt;kq_state |= KQ_SLEEP;
		kqunlock(kq);
		wait_result = thread_block_parameter(cont, kq);
		<span class="enscript-comment">/* NOTREACHED if (continuation != NULL) */</span>

		<span class="enscript-keyword">switch</span> (wait_result) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_AWAKENED</span>:
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_TIMED_OUT</span>:
			<span class="enscript-keyword">return</span> (EWOULDBLOCK);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_INTERRUPTED</span>:
			<span class="enscript-keyword">return</span> (EINTR);
		<span class="enscript-reference">default</span>:
			panic(<span class="enscript-string">&quot;%s: - bad wait_result (%d)&quot;</span>, __func__,
			    wait_result);
			error = 0;
		}
	}
	kqunlock(kq);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * XXX
 * This could be expanded to call kqueue_scan, if desired.
 */</span>
<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kqueue_read</span>(__unused <span class="enscript-type">struct</span> fileproc *fp,
    __unused <span class="enscript-type">struct</span> uio *uio,
    __unused <span class="enscript-type">int</span> flags,
    __unused vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span> (ENXIO);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kqueue_write</span>(__unused <span class="enscript-type">struct</span> fileproc *fp,
    __unused <span class="enscript-type">struct</span> uio *uio,
    __unused <span class="enscript-type">int</span> flags,
    __unused vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span> (ENXIO);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kqueue_ioctl</span>(__unused <span class="enscript-type">struct</span> fileproc *fp,
    __unused u_long com,
    __unused caddr_t data,
    __unused vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span> (ENOTTY);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kqueue_select</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">int</span> which, <span class="enscript-type">void</span> *wq_link_id,
    __unused vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> kqueue *kq = (<span class="enscript-type">struct</span> kqueue *)fp-&gt;f_data;
	<span class="enscript-type">struct</span> knote *kn;
	<span class="enscript-type">struct</span> kqtailq inprocessq;
	<span class="enscript-type">int</span> retnum = 0;

	<span class="enscript-keyword">if</span> (which != FREAD)
		<span class="enscript-keyword">return</span> (0);

	TAILQ_INIT(&amp;inprocessq);

	kqlock(kq);
	<span class="enscript-comment">/*
	 * If this is the first pass, link the wait queue associated with the
	 * the kqueue onto the wait queue set for the select().  Normally we
	 * use selrecord() for this, but it uses the wait queue within the
	 * selinfo structure and we need to use the main one for the kqueue to
	 * catch events from KN_STAYQUEUED sources. So we do the linkage manually.
	 * (The select() call will unlink them when it ends).
	 */</span>
	<span class="enscript-keyword">if</span> (wq_link_id != NULL) {
		thread_t cur_act = current_thread();
		<span class="enscript-type">struct</span> uthread * ut = get_bsdthread_info(cur_act);

		kq-&gt;kq_state |= KQ_SEL;
		waitq_link((<span class="enscript-type">struct</span> waitq *)kq-&gt;kq_wqs, ut-&gt;uu_wqset,
			   WAITQ_SHOULD_LOCK, (uint64_t *)wq_link_id);

		<span class="enscript-comment">/* always consume the reserved link object */</span>
		waitq_link_release(*(uint64_t *)wq_link_id);
		*(uint64_t *)wq_link_id = 0;

		<span class="enscript-comment">/*
		 * selprocess() is expecting that we send it back the waitq
		 * that was just added to the thread's waitq set. In order
		 * to not change the selrecord() API (which is exported to
		 * kexts), we pass this value back through the
		 * void *wq_link_id pointer we were passed. We need to use
		 * memcpy here because the pointer may not be properly aligned
		 * on 32-bit systems.
		 */</span>
		memcpy(wq_link_id, (<span class="enscript-type">void</span> *)&amp;(kq-&gt;kq_wqs), <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span> *));
	}

	<span class="enscript-keyword">if</span> (kqueue_begin_processing(kq) == -1) {
		kqunlock(kq);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (kq-&gt;kq_count != 0) {
		<span class="enscript-comment">/*
		 * there is something queued - but it might be a
		 * KN_STAYQUEUED knote, which may or may not have
		 * any events pending.  So, we have to walk the
		 * list of knotes to see, and peek at the stay-
		 * queued ones to be really sure.
		 */</span>
		<span class="enscript-keyword">while</span> ((kn = (<span class="enscript-type">struct</span> knote *)TAILQ_FIRST(&amp;kq-&gt;kq_head)) != NULL) {
			<span class="enscript-keyword">if</span> ((kn-&gt;kn_status &amp; KN_STAYQUEUED) == 0) {
				retnum = 1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			TAILQ_REMOVE(&amp;kq-&gt;kq_head, kn, kn_tqe);
			TAILQ_INSERT_TAIL(&amp;inprocessq, kn, kn_tqe);

			<span class="enscript-keyword">if</span> (kqlock2knoteuse(kq, kn)) {
				<span class="enscript-type">unsigned</span> peek;

				peek = kn-&gt;kn_fop-&gt;f_peek(kn);
				<span class="enscript-keyword">if</span> (knoteuse2kqlock(kq, kn)) {
					<span class="enscript-keyword">if</span> (peek &gt; 0) {
						retnum = 1;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
					}
				} <span class="enscript-keyword">else</span> {
					retnum = 0;
				}
			}
		}
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/* Return knotes to active queue */</span>
	<span class="enscript-keyword">while</span> ((kn = TAILQ_FIRST(&amp;inprocessq)) != NULL) {
		TAILQ_REMOVE(&amp;inprocessq, kn, kn_tqe);
		kn-&gt;kn_tq = &amp;kq-&gt;kq_head;
		TAILQ_INSERT_TAIL(&amp;kq-&gt;kq_head, kn, kn_tqe);
	}

	kqueue_end_processing(kq);
	kqunlock(kq);
	<span class="enscript-keyword">return</span> (retnum);
}

<span class="enscript-comment">/*
 * kqueue_close -
 */</span>
<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kqueue_close</span>(<span class="enscript-type">struct</span> fileglob *fg, __unused vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> kqueue *kq = (<span class="enscript-type">struct</span> kqueue *)fg-&gt;fg_data;

	kqueue_dealloc(kq);
	fg-&gt;fg_data = NULL;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-comment">/*
 * The callers has taken a use-count reference on this kqueue and will donate it
 * to the kqueue we are being added to.  This keeps the kqueue from closing until
 * that relationship is torn down.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kqueue_kqfilter</span>(__unused <span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> knote *kn, __unused vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> kqueue *kq = (<span class="enscript-type">struct</span> kqueue *)kn-&gt;kn_fp-&gt;f_data;
	<span class="enscript-type">struct</span> kqueue *parentkq = kn-&gt;kn_kq;

	<span class="enscript-keyword">if</span> (parentkq == kq ||
	    kn-&gt;kn_filter != EVFILT_READ)
		<span class="enscript-keyword">return</span> (1);

	<span class="enscript-comment">/*
	 * We have to avoid creating a cycle when nesting kqueues
	 * inside another.  Rather than trying to walk the whole
	 * potential DAG of nested kqueues, we just use a simple
	 * ceiling protocol.  When a kqueue is inserted into another,
	 * we check that the (future) parent is not already nested
	 * into another kqueue at a lower level than the potenial
	 * child (because it could indicate a cycle).  If that test
	 * passes, we just mark the nesting levels accordingly.
	 */</span>

	kqlock(parentkq);
	<span class="enscript-keyword">if</span> (parentkq-&gt;kq_level &gt; 0 &amp;&amp;
	    parentkq-&gt;kq_level &lt; kq-&gt;kq_level)
	{
		kqunlock(parentkq);
		<span class="enscript-keyword">return</span> (1);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* set parent level appropriately */</span>
		<span class="enscript-keyword">if</span> (parentkq-&gt;kq_level == 0)
			parentkq-&gt;kq_level = 2;
		<span class="enscript-keyword">if</span> (parentkq-&gt;kq_level &lt; kq-&gt;kq_level + 1)
			parentkq-&gt;kq_level = kq-&gt;kq_level + 1;
		kqunlock(parentkq);

		kn-&gt;kn_fop = &amp;kqread_filtops;
		kqlock(kq);
		KNOTE_ATTACH(&amp;kq-&gt;kq_sel.si_note, kn);
		<span class="enscript-comment">/* indicate nesting in child, if needed */</span>
		<span class="enscript-keyword">if</span> (kq-&gt;kq_level == 0)
			kq-&gt;kq_level = 1;
		kqunlock(kq);
		<span class="enscript-keyword">return</span> (0);
	}
}

<span class="enscript-comment">/*
 * kqueue_drain - called when kq is closed
 */</span>
<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kqueue_drain</span>(<span class="enscript-type">struct</span> fileproc *fp, __unused vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> kqueue *kq = (<span class="enscript-type">struct</span> kqueue *)fp-&gt;f_fglob-&gt;fg_data;
	kqlock(kq);
	kqueue_wakeup(kq, 1);
	kqunlock(kq);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kqueue_stat</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">void</span> *ub, <span class="enscript-type">int</span> isstat64, proc_t p)
{
	kqlock(kq);
	<span class="enscript-keyword">if</span> (isstat64 != 0) {
		<span class="enscript-type">struct</span> stat64 *sb64 = (<span class="enscript-type">struct</span> stat64 *)ub;

		bzero((<span class="enscript-type">void</span> *)sb64, <span class="enscript-keyword">sizeof</span>(*sb64));
		sb64-&gt;st_size = kq-&gt;kq_count;
		<span class="enscript-keyword">if</span> (kq-&gt;kq_state &amp; KQ_KEV_QOS)
			sb64-&gt;st_blksize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevent_qos_s);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kq-&gt;kq_state &amp; KQ_KEV64)
			sb64-&gt;st_blksize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevent64_s);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p))
			sb64-&gt;st_blksize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user64_kevent);
		<span class="enscript-keyword">else</span>
			sb64-&gt;st_blksize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_kevent);
		sb64-&gt;st_mode = S_IFIFO;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> stat *sb = (<span class="enscript-type">struct</span> stat *)ub;

		bzero((<span class="enscript-type">void</span> *)sb, <span class="enscript-keyword">sizeof</span>(*sb));
		sb-&gt;st_size = kq-&gt;kq_count;
		<span class="enscript-keyword">if</span> (kq-&gt;kq_state &amp; KQ_KEV_QOS)
			sb-&gt;st_blksize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevent_qos_s);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kq-&gt;kq_state &amp; KQ_KEV64)
			sb-&gt;st_blksize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevent64_s);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p))
			sb-&gt;st_blksize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user64_kevent);
		<span class="enscript-keyword">else</span>
			sb-&gt;st_blksize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_kevent);
		sb-&gt;st_mode = S_IFIFO;
	}
	kqunlock(kq);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Called with the kqueue locked
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kqueue_wakeup</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">int</span> closed)
{
	wait_result_t res = THREAD_NOT_WAITING;

	<span class="enscript-keyword">if</span> ((kq-&gt;kq_state &amp; (KQ_SLEEP | KQ_SEL)) != 0 || kq-&gt;kq_nprocess &gt; 0) {
		kq-&gt;kq_state &amp;= ~(KQ_SLEEP | KQ_SEL);
		res = waitq_wakeup64_all((<span class="enscript-type">struct</span> waitq *)kq-&gt;kq_wqs, KQ_EVENT,
					 (closed) ? THREAD_INTERRUPTED : THREAD_AWAKENED,
					 WAITQ_ALL_PRIORITIES);
	}

	<span class="enscript-comment">/* request additional workq threads if appropriate */</span>
	<span class="enscript-keyword">if</span> (res == THREAD_NOT_WAITING &amp;&amp; (kq-&gt;kq_state &amp; KQ_WORKQ) &amp;&amp;
	    pthread_functions != NULL &amp;&amp; pthread_functions-&gt;workq_reqthreads != NULL) {
		<span class="enscript-comment">/*
		 * The special workq kq should be accumulating the counts of
		 * queued sources on a pthread_priority_t basis and we should
		 * be providing that here.  For now, just hard-code a single
		 * entry request at a fixed (default) QOS.
		 */</span>
		<span class="enscript-type">struct</span> workq_reqthreads_req_s request = { 
		                      .priority = 0x020004ff,  <span class="enscript-comment">/* legacy event manager */</span>
							  .count = kq-&gt;kq_count };
		thread_t wqthread;

		wqthread = (*pthread_functions-&gt;workq_reqthreads)(kq-&gt;kq_p, 1, &amp;request);
		assert(wqthread == THREAD_NULL);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">klist_init</span>(<span class="enscript-type">struct</span> klist *list)
{
	SLIST_INIT(list);
}


<span class="enscript-comment">/*
 * Query/Post each knote in the object's list
 *
 *	The object lock protects the list. It is assumed
 *	that the filter/event routine for the object can
 *	determine that the object is already locked (via
 *	the hint) and not deadlock itself.
 *
 *	The object lock should also hold off pending
 *	detach/drop operations.  But we'll prevent it here
 *	too - just in case.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">knote</span>(<span class="enscript-type">struct</span> klist *list, <span class="enscript-type">long</span> hint)
{
	<span class="enscript-type">struct</span> knote *kn;

	SLIST_FOREACH(kn, list, kn_selnext) {
		<span class="enscript-type">struct</span> kqueue *kq = kn-&gt;kn_kq;

		kqlock(kq);
		<span class="enscript-keyword">if</span> (kqlock2knoteuse(kq, kn)) {
			<span class="enscript-type">int</span> result;

			<span class="enscript-comment">/* call the event with only a use count */</span>
			result = kn-&gt;kn_fop-&gt;f_event(kn, hint);

			<span class="enscript-comment">/* if its not going away and triggered */</span>
			<span class="enscript-keyword">if</span> (knoteuse2kqlock(kq, kn) &amp;&amp; result)
				knote_activate(kn, 0);
			<span class="enscript-comment">/* lock held again */</span>
		}
		kqunlock(kq);
	}
}

<span class="enscript-comment">/*
 * attach a knote to the specified list.  Return true if this is the first entry.
 * The list is protected by whatever lock the object it is associated with uses.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">knote_attach</span>(<span class="enscript-type">struct</span> klist *list, <span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-type">int</span> ret = SLIST_EMPTY(list);
	SLIST_INSERT_HEAD(list, kn, kn_selnext);
	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-comment">/*
 * detach a knote from the specified list.  Return true if that was the last entry.
 * The list is protected by whatever lock the object it is associated with uses.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">knote_detach</span>(<span class="enscript-type">struct</span> klist *list, <span class="enscript-type">struct</span> knote *kn)
{
	SLIST_REMOVE(list, kn, knote, kn_selnext);
	<span class="enscript-keyword">return</span> (SLIST_EMPTY(list));
}

<span class="enscript-comment">/*
 * For a given knote, link a provided wait queue directly with the kqueue.
 * Wakeups will happen via recursive wait queue support.  But nothing will move
 * the knote to the active list at wakeup (nothing calls knote()).  Instead,
 * we permanently enqueue them here.
 *
 * kqueue and knote references are held by caller.
 *
 * caller provides the wait queue link structure.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">knote_link_waitq</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">struct</span> waitq *wq, uint64_t *reserved_link)
{
	<span class="enscript-type">struct</span> kqueue *kq = kn-&gt;kn_kq;
	kern_return_t kr;

	kr = waitq_link(wq, kq-&gt;kq_wqs, WAITQ_SHOULD_LOCK, reserved_link);
	<span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {
		knote_markstayqueued(kn);
		<span class="enscript-keyword">return</span> (0);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> (EINVAL);
	}
}

<span class="enscript-comment">/*
 * Unlink the provided wait queue from the kqueue associated with a knote.
 * Also remove it from the magic list of directly attached knotes.
 *
 * Note that the unlink may have already happened from the other side, so
 * ignore any failures to unlink and just remove it from the kqueue list.
 *
 * On success, caller is responsible for the link structure
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">knote_unlink_waitq</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">struct</span> waitq *wq)
{
	<span class="enscript-type">struct</span> kqueue *kq = kn-&gt;kn_kq;
	kern_return_t kr;

	kr = waitq_unlink(wq, kq-&gt;kq_wqs);
	knote_clearstayqueued(kn);
	<span class="enscript-keyword">return</span> ((kr != KERN_SUCCESS) ? EINVAL : 0);
}

<span class="enscript-comment">/*
 * remove all knotes referencing a specified fd
 *
 * Essentially an inlined knote_remove &amp; knote_drop
 * when we know for sure that the thing is a file
 *
 * Entered with the proc_fd lock already held.
 * It returns the same way, but may drop it temporarily.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">knote_fdclose</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">int</span> fd)
{
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> klist *list;
	<span class="enscript-type">struct</span> knote *kn;

	list = &amp;fdp-&gt;fd_knlist[fd];
	<span class="enscript-keyword">while</span> ((kn = SLIST_FIRST(list)) != NULL) {
		<span class="enscript-type">struct</span> kqueue *kq = kn-&gt;kn_kq;

		<span class="enscript-keyword">if</span> (kq-&gt;kq_p != p)
			panic(<span class="enscript-string">&quot;%s: proc mismatch (kq-&gt;kq_p=%p != p=%p)&quot;</span>,
			    __func__, kq-&gt;kq_p, p);

		kqlock(kq);
		proc_fdunlock(p);

		<span class="enscript-comment">/*
		 * Convert the lock to a drop ref.
		 * If we get it, go ahead and drop it.
		 * Otherwise, we waited for it to
		 * be dropped by the other guy, so
		 * it is safe to move on in the list.
		 */</span>
		<span class="enscript-keyword">if</span> (kqlock2knotedrop(kq, kn)) {
			kn-&gt;kn_fop-&gt;f_detach(kn);
			knote_drop(kn, p);
		}

		proc_fdlock(p);

		<span class="enscript-comment">/* the fd tables may have changed - start over */</span>
		list = &amp;fdp-&gt;fd_knlist[fd];
	}
}

<span class="enscript-comment">/* proc_fdlock held on entry (and exit) */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">knote_fdpattach</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">struct</span> filedesc *fdp, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> klist *list = NULL;

	<span class="enscript-keyword">if</span> (! kn-&gt;kn_fop-&gt;f_isfd) {
		<span class="enscript-keyword">if</span> (fdp-&gt;fd_knhashmask == 0)
			fdp-&gt;fd_knhash = hashinit(CONFIG_KN_HASHSIZE, M_KQUEUE,
			    &amp;fdp-&gt;fd_knhashmask);
		list = &amp;fdp-&gt;fd_knhash[KN_HASH(kn-&gt;kn_id, fdp-&gt;fd_knhashmask)];
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((u_int)fdp-&gt;fd_knlistsize &lt;= kn-&gt;kn_id) {
			u_int size = 0;

			<span class="enscript-keyword">if</span> (kn-&gt;kn_id &gt;= (uint64_t)p-&gt;p_rlimit[RLIMIT_NOFILE].rlim_cur
			    || kn-&gt;kn_id &gt;= (uint64_t)maxfiles)
				<span class="enscript-keyword">return</span> (EINVAL);

			<span class="enscript-comment">/* have to grow the fd_knlist */</span>
			size = fdp-&gt;fd_knlistsize;
			<span class="enscript-keyword">while</span> (size &lt;= kn-&gt;kn_id)
				size += KQEXTENT;

			<span class="enscript-keyword">if</span> (size &gt;= (UINT_MAX/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> klist *)))
				<span class="enscript-keyword">return</span> (EINVAL);

			MALLOC(list, <span class="enscript-type">struct</span> klist *,
			    size * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> klist *), M_KQUEUE, M_WAITOK);
			<span class="enscript-keyword">if</span> (list == NULL)
				<span class="enscript-keyword">return</span> (ENOMEM);

			bcopy((caddr_t)fdp-&gt;fd_knlist, (caddr_t)list,
			    fdp-&gt;fd_knlistsize * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> klist *));
			bzero((caddr_t)list +
			    fdp-&gt;fd_knlistsize * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> klist *),
			    (size - fdp-&gt;fd_knlistsize) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> klist *));
			FREE(fdp-&gt;fd_knlist, M_KQUEUE);
			fdp-&gt;fd_knlist = list;
			fdp-&gt;fd_knlistsize = size;
		}
		list = &amp;fdp-&gt;fd_knlist[kn-&gt;kn_id];
	}
	SLIST_INSERT_HEAD(list, kn, kn_link);
	<span class="enscript-keyword">return</span> (0);
}



<span class="enscript-comment">/*
 * should be called at spl == 0, since we don't want to hold spl
 * while calling fdrop and free.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">knote_drop</span>(<span class="enscript-type">struct</span> knote *kn, __unused <span class="enscript-type">struct</span> proc *ctxp)
{
	<span class="enscript-type">struct</span> kqueue *kq = kn-&gt;kn_kq;
	<span class="enscript-type">struct</span> proc *p = kq-&gt;kq_p;
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> klist *list;
	<span class="enscript-type">int</span> needswakeup;

	proc_fdlock(p);
	<span class="enscript-keyword">if</span> (kn-&gt;kn_fop-&gt;f_isfd)
		list = &amp;fdp-&gt;fd_knlist[kn-&gt;kn_id];
	<span class="enscript-keyword">else</span>
		list = &amp;fdp-&gt;fd_knhash[KN_HASH(kn-&gt;kn_id, fdp-&gt;fd_knhashmask)];

	SLIST_REMOVE(list, kn, knote, kn_link);
	kqlock(kq);
	knote_dequeue(kn);
	needswakeup = (kn-&gt;kn_status &amp; KN_USEWAIT);
	kqunlock(kq);
	proc_fdunlock(p);

	<span class="enscript-keyword">if</span> (needswakeup)
		waitq_wakeup64_all((<span class="enscript-type">struct</span> waitq *)kq-&gt;kq_wqs,
				   CAST_EVENT64_T(&amp;kn-&gt;kn_status),
				   THREAD_AWAKENED,
				   WAITQ_ALL_PRIORITIES);

	<span class="enscript-keyword">if</span> (kn-&gt;kn_fop-&gt;f_isfd)
		fp_drop(p, kn-&gt;kn_id, kn-&gt;kn_fp, 0);

	knote_free(kn);
}

<span class="enscript-comment">/* called with kqueue lock held */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">knote_activate</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">int</span> force)
{
	<span class="enscript-type">struct</span> kqueue *kq = kn-&gt;kn_kq;

	<span class="enscript-keyword">if</span> (!force &amp;&amp; (kn-&gt;kn_status &amp; KN_ACTIVE))
		<span class="enscript-keyword">return</span>;

	kn-&gt;kn_status |= KN_ACTIVE;
	knote_enqueue(kn);
	kqueue_wakeup(kq, 0);

	<span class="enscript-comment">/* wake up the parent kq, too */</span>
	KNOTE(&amp;kq-&gt;kq_sel.si_note, 0);
}

<span class="enscript-comment">/* called with kqueue lock held */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">knote_deactivate</span>(<span class="enscript-type">struct</span> knote *kn)
{
	kn-&gt;kn_status &amp;= ~KN_ACTIVE;
	knote_dequeue(kn);
}

<span class="enscript-comment">/* called with kqueue lock held */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">knote_enqueue</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-keyword">if</span> ((kn-&gt;kn_status &amp; (KN_QUEUED | KN_STAYQUEUED)) == KN_STAYQUEUED ||
	    (kn-&gt;kn_status &amp; (KN_QUEUED | KN_STAYQUEUED | KN_DISABLED)) == 0) {
		<span class="enscript-type">struct</span> kqtailq *tq = kn-&gt;kn_tq;
		<span class="enscript-type">struct</span> kqueue *kq = kn-&gt;kn_kq;

		TAILQ_INSERT_TAIL(tq, kn, kn_tqe);
		kn-&gt;kn_status |= KN_QUEUED;
		kq-&gt;kq_count++;
	}
}

<span class="enscript-comment">/* called with kqueue lock held */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">knote_dequeue</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-type">struct</span> kqueue *kq = kn-&gt;kn_kq;

	<span class="enscript-keyword">if</span> ((kn-&gt;kn_status &amp; (KN_QUEUED | KN_STAYQUEUED)) == KN_QUEUED) {
		<span class="enscript-type">struct</span> kqtailq *tq = kn-&gt;kn_tq;

		TAILQ_REMOVE(tq, kn, kn_tqe);
		kn-&gt;kn_tq = &amp;kq-&gt;kq_head;
		kn-&gt;kn_status &amp;= ~KN_QUEUED;
		kq-&gt;kq_count--;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">knote_init</span>(<span class="enscript-type">void</span>)
{
	knote_zone = zinit(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> knote), 8192*<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> knote),
	    8192, <span class="enscript-string">&quot;knote zone&quot;</span>);

	<span class="enscript-comment">/* allocate kq lock group attribute and group */</span>
	kq_lck_grp_attr = lck_grp_attr_alloc_init();

	kq_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;kqueue&quot;</span>,  kq_lck_grp_attr);

	<span class="enscript-comment">/* Allocate kq lock attribute */</span>
	kq_lck_attr = lck_attr_alloc_init();

	<span class="enscript-comment">/* Initialize the timer filter lock */</span>
	lck_mtx_init(&amp;_filt_timerlock, kq_lck_grp, kq_lck_attr);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PRESSURE_EVENTS</span>
	<span class="enscript-comment">/* Initialize the vm pressure list lock */</span>
	vm_pressure_init(kq_lck_grp, kq_lck_attr);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>
	<span class="enscript-comment">/* Initialize the memorystatus list lock */</span>
	memorystatus_kevent_init(kq_lck_grp, kq_lck_attr);
#<span class="enscript-reference">endif</span>
}
<span class="enscript-function-name">SYSINIT</span>(knote, SI_SUB_PSEUDO, SI_ORDER_ANY, knote_init, NULL)

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> knote *
<span class="enscript-function-name">knote_alloc</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> ((<span class="enscript-type">struct</span> knote *)zalloc(knote_zone));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">knote_free</span>(<span class="enscript-type">struct</span> knote *kn)
{
	zfree(knote_zone, kn);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SOCKETS</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sys_domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">ROUNDUP64</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ROUNDUP64</span>(x) P2ROUNDUP((x), sizeof (u_int64_t))
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">ADVANCE64</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ADVANCE64</span>(p, n) (void*)((char *)(p) + ROUNDUP64(n))
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> lck_grp_attr_t *kev_lck_grp_attr;
<span class="enscript-type">static</span> lck_attr_t *kev_lck_attr;
<span class="enscript-type">static</span> lck_grp_t *kev_lck_grp;
<span class="enscript-type">static</span> <span class="enscript-function-name">decl_lck_rw_data</span>(,kev_lck_data);
<span class="enscript-type">static</span> lck_rw_t *kev_rwlock = &amp;kev_lck_data;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kev_attach</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> proto, <span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kev_detach</span>(<span class="enscript-type">struct</span> socket *so);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kev_control</span>(<span class="enscript-type">struct</span> socket *so, u_long cmd, caddr_t data,
    <span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">static</span> lck_mtx_t * <span class="enscript-function-name">event_getlock</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">event_lock</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">event_unlock</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">void</span> *);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">event_sofreelastref</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kev_delete</span>(<span class="enscript-type">struct</span> kern_event_pcb *);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pr_usrreqs event_usrreqs = {
	.pru_attach =		kev_attach,
	.pru_control =		kev_control,
	.pru_detach =		kev_detach,
	.pru_soreceive =	soreceive,
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> protosw eventsw[] = {
{
	.pr_type =		SOCK_RAW,
	.pr_protocol =		SYSPROTO_EVENT,
	.pr_flags =		PR_ATOMIC,
	.pr_usrreqs =		&amp;event_usrreqs,
	.pr_lock =		event_lock,
	.pr_unlock =		event_unlock,
	.pr_getlock =		event_getlock,
}
};

__private_extern__ <span class="enscript-type">int</span> kevt_getstat SYSCTL_HANDLER_ARGS;
__private_extern__ <span class="enscript-type">int</span> kevt_pcblist SYSCTL_HANDLER_ARGS;

<span class="enscript-function-name">SYSCTL_NODE</span>(_net_systm, OID_AUTO, kevt,
	CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;Kernel event family&quot;</span>);

<span class="enscript-type">struct</span> kevtstat kevtstat;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_systm_kevt, OID_AUTO, stats,
    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0,
    kevt_getstat, <span class="enscript-string">&quot;S,kevtstat&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_systm_kevt, OID_AUTO, pcblist,
	CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0,
	kevt_pcblist, <span class="enscript-string">&quot;S,xkevtpcb&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> lck_mtx_t *
<span class="enscript-function-name">event_getlock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> locktype)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">locktype</span>)
	<span class="enscript-type">struct</span> kern_event_pcb *ev_pcb = (<span class="enscript-type">struct</span> kern_event_pcb *)so-&gt;so_pcb;

	<span class="enscript-keyword">if</span> (so-&gt;so_pcb != NULL)  {
		<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt; 0)
			panic(<span class="enscript-string">&quot;%s: so=%p usecount=%d lrh= %s\n&quot;</span>, __func__,
			    so, so-&gt;so_usecount, solockhistory_nr(so));
			<span class="enscript-comment">/* NOTREACHED */</span>
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;%s: so=%p NULL NO so_pcb %s\n&quot;</span>, __func__,
		    so, solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">return</span> (&amp;ev_pcb-&gt;evp_mtx);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">event_lock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> refcount, <span class="enscript-type">void</span> *lr)
{
	<span class="enscript-type">void</span> *lr_saved;

	<span class="enscript-keyword">if</span> (lr == NULL)
		lr_saved = __builtin_return_address(0);
	<span class="enscript-keyword">else</span>
		lr_saved = lr;

	<span class="enscript-keyword">if</span> (so-&gt;so_pcb != NULL) {
		lck_mtx_lock(&amp;((<span class="enscript-type">struct</span> kern_event_pcb *)so-&gt;so_pcb)-&gt;evp_mtx);
	} <span class="enscript-keyword">else</span>  {
		panic(<span class="enscript-string">&quot;%s: so=%p NO PCB! lr=%p lrh= %s\n&quot;</span>, __func__,
		    so, lr_saved, solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt; 0) {
		panic(<span class="enscript-string">&quot;%s: so=%p so_pcb=%p lr=%p ref=%d lrh= %s\n&quot;</span>, __func__,
		    so, so-&gt;so_pcb, lr_saved, so-&gt;so_usecount,
		    solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (refcount)
		so-&gt;so_usecount++;

	so-&gt;lock_lr[so-&gt;next_lock_lr] = lr_saved;
	so-&gt;next_lock_lr = (so-&gt;next_lock_lr+1) % SO_LCKDBG_MAX;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">event_unlock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> refcount, <span class="enscript-type">void</span> *lr)
{
	<span class="enscript-type">void</span> *lr_saved;
	lck_mtx_t *mutex_held;

	<span class="enscript-keyword">if</span> (lr == NULL)
		lr_saved = __builtin_return_address(0);
	<span class="enscript-keyword">else</span>
		lr_saved = lr;

	<span class="enscript-keyword">if</span> (refcount)
		so-&gt;so_usecount--;

	<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt; 0) {
		panic(<span class="enscript-string">&quot;%s: so=%p usecount=%d lrh= %s\n&quot;</span>, __func__,
		    so, so-&gt;so_usecount, solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (so-&gt;so_pcb == NULL) {
		panic(<span class="enscript-string">&quot;%s: so=%p NO PCB usecount=%d lr=%p lrh= %s\n&quot;</span>, __func__,
		    so, so-&gt;so_usecount, (<span class="enscript-type">void</span> *)lr_saved,
		    solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	mutex_held = (&amp;((<span class="enscript-type">struct</span> kern_event_pcb *)so-&gt;so_pcb)-&gt;evp_mtx);

	lck_mtx_assert(mutex_held, LCK_MTX_ASSERT_OWNED);
	so-&gt;unlock_lr[so-&gt;next_unlock_lr] = lr_saved;
	so-&gt;next_unlock_lr = (so-&gt;next_unlock_lr+1) % SO_LCKDBG_MAX;

	<span class="enscript-keyword">if</span> (so-&gt;so_usecount == 0) {
		VERIFY(so-&gt;so_flags &amp; SOF_PCBCLEARING);
		event_sofreelastref(so);
	} <span class="enscript-keyword">else</span> {
		lck_mtx_unlock(mutex_held);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">event_sofreelastref</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> kern_event_pcb *ev_pcb = (<span class="enscript-type">struct</span> kern_event_pcb *)so-&gt;so_pcb;

	lck_mtx_assert(&amp;(ev_pcb-&gt;evp_mtx), LCK_MTX_ASSERT_OWNED);

	so-&gt;so_pcb = NULL;

	<span class="enscript-comment">/*
	 * Disable upcall in the event another thread is in kev_post_msg()
	 * appending record to the receive socket buffer, since sbwakeup()
	 * may release the socket lock otherwise.
	 */</span>
	so-&gt;so_rcv.sb_flags &amp;= ~SB_UPCALL;
	so-&gt;so_snd.sb_flags &amp;= ~SB_UPCALL;
	so-&gt;so_event = sonullevent;
	lck_mtx_unlock(&amp;(ev_pcb-&gt;evp_mtx));

	lck_mtx_assert(&amp;(ev_pcb-&gt;evp_mtx), LCK_MTX_ASSERT_NOTOWNED);
	lck_rw_lock_exclusive(kev_rwlock);
	LIST_REMOVE(ev_pcb, evp_link);
	kevtstat.kes_pcbcount--;
	kevtstat.kes_gencnt++;
	lck_rw_done(kev_rwlock);
	kev_delete(ev_pcb);

	sofreelastref(so, 1);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> event_proto_count = (<span class="enscript-keyword">sizeof</span> (eventsw) / <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> protosw));

<span class="enscript-type">static</span>
<span class="enscript-type">struct</span> kern_event_head kern_event_head;

<span class="enscript-type">static</span> u_int32_t static_event_id = 0;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">EVPCB_ZONE_MAX</span>		65536
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">EVPCB_ZONE_NAME</span>		<span class="enscript-string">&quot;kerneventpcb&quot;</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *ev_pcb_zone;

<span class="enscript-comment">/*
 * Install the protosw's for the NKE manager.  Invoked at extension load time
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kern_event_init</span>(<span class="enscript-type">struct</span> domain *dp)
{
	<span class="enscript-type">struct</span> protosw *pr;
	<span class="enscript-type">int</span> i;

	VERIFY(!(dp-&gt;dom_flags &amp; DOM_INITIALIZED));
	VERIFY(dp == systemdomain);

	kev_lck_grp_attr = lck_grp_attr_alloc_init();
	<span class="enscript-keyword">if</span> (kev_lck_grp_attr == NULL) {
		panic(<span class="enscript-string">&quot;%s: lck_grp_attr_alloc_init failed\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	kev_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;Kernel Event Protocol&quot;</span>,
	    kev_lck_grp_attr);
	<span class="enscript-keyword">if</span> (kev_lck_grp == NULL) {
		panic(<span class="enscript-string">&quot;%s: lck_grp_alloc_init failed\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	kev_lck_attr = lck_attr_alloc_init();
	<span class="enscript-keyword">if</span> (kev_lck_attr == NULL) {
		panic(<span class="enscript-string">&quot;%s: lck_attr_alloc_init failed\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	lck_rw_init(kev_rwlock, kev_lck_grp, kev_lck_attr);
	<span class="enscript-keyword">if</span> (kev_rwlock == NULL) {
		panic(<span class="enscript-string">&quot;%s: lck_mtx_alloc_init failed\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">for</span> (i = 0, pr = &amp;eventsw[0]; i &lt; event_proto_count; i++, pr++)
		net_add_proto(pr, dp, 1);

	ev_pcb_zone = zinit(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kern_event_pcb),
	    EVPCB_ZONE_MAX * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kern_event_pcb), 0, EVPCB_ZONE_NAME);
	<span class="enscript-keyword">if</span> (ev_pcb_zone == NULL) {
		panic(<span class="enscript-string">&quot;%s: failed allocating ev_pcb_zone&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(ev_pcb_zone, Z_EXPAND, TRUE);
	zone_change(ev_pcb_zone, Z_CALLERACCT, TRUE);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kev_attach</span>(<span class="enscript-type">struct</span> socket *so, __unused <span class="enscript-type">int</span> proto, __unused <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> kern_event_pcb *ev_pcb;

	error = soreserve(so, KEV_SNDSPACE, KEV_RECVSPACE);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> ((ev_pcb = (<span class="enscript-type">struct</span> kern_event_pcb *)zalloc(ev_pcb_zone)) == NULL) {
		<span class="enscript-keyword">return</span> (ENOBUFS);
	}
	bzero(ev_pcb, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kern_event_pcb));
	lck_mtx_init(&amp;ev_pcb-&gt;evp_mtx, kev_lck_grp, kev_lck_attr);

	ev_pcb-&gt;evp_socket = so;
	ev_pcb-&gt;evp_vendor_code_filter = 0xffffffff;

	so-&gt;so_pcb = (caddr_t) ev_pcb;
	lck_rw_lock_exclusive(kev_rwlock);
	LIST_INSERT_HEAD(&amp;kern_event_head, ev_pcb, evp_link);
	kevtstat.kes_pcbcount++;
	kevtstat.kes_gencnt++;
	lck_rw_done(kev_rwlock);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kev_delete</span>(<span class="enscript-type">struct</span> kern_event_pcb *ev_pcb)
{
	VERIFY(ev_pcb != NULL);
	lck_mtx_destroy(&amp;ev_pcb-&gt;evp_mtx, kev_lck_grp);
	zfree(ev_pcb_zone, ev_pcb);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kev_detach</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> kern_event_pcb *ev_pcb = (<span class="enscript-type">struct</span> kern_event_pcb *) so-&gt;so_pcb;

	<span class="enscript-keyword">if</span> (ev_pcb != NULL) {
		soisdisconnected(so);
		so-&gt;so_flags |= SOF_PCBCLEARING;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * For now, kev_vendor_code and mbuf_tags use the same
 * mechanism.
 */</span>
errno_t <span class="enscript-function-name">kev_vendor_code_find</span>(
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*string,
	u_int32_t 	*out_vendor_code)
{
	<span class="enscript-keyword">if</span> (strlen(string) &gt;= KEV_VENDOR_CODE_MAX_STR_LEN) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">return</span> (net_str_id_find_internal(string, out_vendor_code,
	    NSI_VENDOR_CODE, 1));
}

errno_t
<span class="enscript-function-name">kev_msg_post</span>(<span class="enscript-type">struct</span> kev_msg *event_msg)
{
	mbuf_tag_id_t min_vendor, max_vendor;

	net_str_id_first_last(&amp;min_vendor, &amp;max_vendor, NSI_VENDOR_CODE);

	<span class="enscript-keyword">if</span> (event_msg == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* 
	 * Limit third parties to posting events for registered vendor codes
	 * only
	 */</span>
	<span class="enscript-keyword">if</span> (event_msg-&gt;vendor_code &lt; min_vendor ||
	    event_msg-&gt;vendor_code &gt; max_vendor) {
		OSIncrementAtomic64((SInt64 *)&amp;kevtstat.kes_badvendor);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">return</span> (kev_post_msg(event_msg));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kev_post_msg</span>(<span class="enscript-type">struct</span> kev_msg *event_msg)
{
	<span class="enscript-type">struct</span> mbuf *m, *m2;
	<span class="enscript-type">struct</span> kern_event_pcb *ev_pcb;
	<span class="enscript-type">struct</span> kern_event_msg *ev;
	<span class="enscript-type">char</span> *tmp;
	u_int32_t total_size;
	<span class="enscript-type">int</span> i;

	<span class="enscript-comment">/* Verify the message is small enough to fit in one mbuf w/o cluster */</span>
	total_size = KEV_MSG_HEADER_SIZE;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; 5; i++) {
		<span class="enscript-keyword">if</span> (event_msg-&gt;dv[i].data_length == 0)
			<span class="enscript-keyword">break</span>;
		total_size += event_msg-&gt;dv[i].data_length;
	}

	<span class="enscript-keyword">if</span> (total_size &gt; MLEN) {
		OSIncrementAtomic64((SInt64 *)&amp;kevtstat.kes_toobig);
		<span class="enscript-keyword">return</span> (EMSGSIZE);
	}

	m = m_get(M_DONTWAIT, MT_DATA);
	<span class="enscript-keyword">if</span> (m == 0) {
		OSIncrementAtomic64((SInt64 *)&amp;kevtstat.kes_nomem);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	ev = mtod(m, <span class="enscript-type">struct</span> kern_event_msg *);
	total_size = KEV_MSG_HEADER_SIZE;

	tmp = (<span class="enscript-type">char</span> *) &amp;ev-&gt;event_data[0];
	<span class="enscript-keyword">for</span> (i = 0; i &lt; 5; i++) {
		<span class="enscript-keyword">if</span> (event_msg-&gt;dv[i].data_length == 0)
			<span class="enscript-keyword">break</span>;

		total_size += event_msg-&gt;dv[i].data_length;
		bcopy(event_msg-&gt;dv[i].data_ptr, tmp,
		    event_msg-&gt;dv[i].data_length);
		tmp += event_msg-&gt;dv[i].data_length;
	}

	ev-&gt;id = ++static_event_id;
	ev-&gt;total_size   = total_size;
	ev-&gt;vendor_code  = event_msg-&gt;vendor_code;
	ev-&gt;kev_class    = event_msg-&gt;kev_class;
	ev-&gt;kev_subclass = event_msg-&gt;kev_subclass;
	ev-&gt;event_code   = event_msg-&gt;event_code;

	m-&gt;m_len = total_size;
	lck_rw_lock_shared(kev_rwlock);
	<span class="enscript-keyword">for</span> (ev_pcb = LIST_FIRST(&amp;kern_event_head);
	    ev_pcb;
	    ev_pcb = LIST_NEXT(ev_pcb, evp_link)) {
		lck_mtx_lock(&amp;ev_pcb-&gt;evp_mtx);
		<span class="enscript-keyword">if</span> (ev_pcb-&gt;evp_socket-&gt;so_pcb == NULL) {
			lck_mtx_unlock(&amp;ev_pcb-&gt;evp_mtx);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (ev_pcb-&gt;evp_vendor_code_filter != KEV_ANY_VENDOR) {
			<span class="enscript-keyword">if</span> (ev_pcb-&gt;evp_vendor_code_filter != ev-&gt;vendor_code) {
				lck_mtx_unlock(&amp;ev_pcb-&gt;evp_mtx);
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-keyword">if</span> (ev_pcb-&gt;evp_class_filter != KEV_ANY_CLASS) {
				<span class="enscript-keyword">if</span> (ev_pcb-&gt;evp_class_filter != ev-&gt;kev_class) {
					lck_mtx_unlock(&amp;ev_pcb-&gt;evp_mtx);
					<span class="enscript-keyword">continue</span>;
				}

				<span class="enscript-keyword">if</span> ((ev_pcb-&gt;evp_subclass_filter !=
				    KEV_ANY_SUBCLASS) &amp;&amp;
				    (ev_pcb-&gt;evp_subclass_filter !=
				    ev-&gt;kev_subclass)) {
					lck_mtx_unlock(&amp;ev_pcb-&gt;evp_mtx);
					<span class="enscript-keyword">continue</span>;
				}
			}
		}

		m2 = m_copym(m, 0, m-&gt;m_len, M_NOWAIT);
		<span class="enscript-keyword">if</span> (m2 == 0) {
			OSIncrementAtomic64((SInt64 *)&amp;kevtstat.kes_nomem);
			m_free(m);
			lck_mtx_unlock(&amp;ev_pcb-&gt;evp_mtx);
			lck_rw_done(kev_rwlock);
			<span class="enscript-keyword">return</span> (ENOMEM);
		}
		<span class="enscript-keyword">if</span> (sbappendrecord(&amp;ev_pcb-&gt;evp_socket-&gt;so_rcv, m2)) {
			<span class="enscript-comment">/*
			 * We use &quot;m&quot; for the socket stats as it would be
			 * unsafe to use &quot;m2&quot;
			 */</span>
			so_inc_recv_data_stat(ev_pcb-&gt;evp_socket,
			    1, m-&gt;m_len, SO_TC_BE);

			sorwakeup(ev_pcb-&gt;evp_socket);
			OSIncrementAtomic64((SInt64 *)&amp;kevtstat.kes_posted);
		} <span class="enscript-keyword">else</span> {
			OSIncrementAtomic64((SInt64 *)&amp;kevtstat.kes_fullsock);
		}
		lck_mtx_unlock(&amp;ev_pcb-&gt;evp_mtx);
	}
	m_free(m);
	lck_rw_done(kev_rwlock);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kev_control</span>(<span class="enscript-type">struct</span> socket *so,
    u_long cmd,
    caddr_t data,
    __unused <span class="enscript-type">struct</span> ifnet *ifp,
    __unused <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> kev_request *kev_req = (<span class="enscript-type">struct</span> kev_request *) data;
	<span class="enscript-type">struct</span> kern_event_pcb  *ev_pcb;
	<span class="enscript-type">struct</span> kev_vendor_code *kev_vendor;
	u_int32_t  *id_value = (u_int32_t *) data;

	<span class="enscript-keyword">switch</span> (cmd) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGKEVID</span>:
			*id_value = static_event_id;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSKEVFILT</span>:
			ev_pcb = (<span class="enscript-type">struct</span> kern_event_pcb *) so-&gt;so_pcb;
			ev_pcb-&gt;evp_vendor_code_filter = kev_req-&gt;vendor_code;
			ev_pcb-&gt;evp_class_filter = kev_req-&gt;kev_class;
			ev_pcb-&gt;evp_subclass_filter  = kev_req-&gt;kev_subclass;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGKEVFILT</span>:
			ev_pcb = (<span class="enscript-type">struct</span> kern_event_pcb *) so-&gt;so_pcb;
			kev_req-&gt;vendor_code = ev_pcb-&gt;evp_vendor_code_filter;
			kev_req-&gt;kev_class   = ev_pcb-&gt;evp_class_filter;
			kev_req-&gt;kev_subclass = ev_pcb-&gt;evp_subclass_filter;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGKEVVENDOR</span>:
			kev_vendor = (<span class="enscript-type">struct</span> kev_vendor_code *)data;
			<span class="enscript-comment">/* Make sure string is NULL terminated */</span>
			kev_vendor-&gt;vendor_string[KEV_VENDOR_CODE_MAX_STR_LEN-1] = 0;
			<span class="enscript-keyword">return</span> (net_str_id_find_internal(kev_vendor-&gt;vendor_string,
			    &amp;kev_vendor-&gt;vendor_code, NSI_VENDOR_CODE, 0));
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (ENOTSUP);
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
kevt_getstat SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error = 0;

	lck_rw_lock_shared(kev_rwlock);

	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		req-&gt;oldidx = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevtstat);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = SYSCTL_OUT(req, &amp;kevtstat,
	    MIN(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevtstat), req-&gt;oldlen));
<span class="enscript-reference">done</span>:
	lck_rw_done(kev_rwlock);

	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
kevt_pcblist SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> n, i;
	<span class="enscript-type">struct</span> xsystmgen xsg;
	<span class="enscript-type">void</span> *buf = NULL;
	size_t item_size = ROUNDUP64(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xkevtpcb)) +
		ROUNDUP64(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xsocket_n)) +
		2 * ROUNDUP64(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xsockbuf_n)) +
		ROUNDUP64(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xsockstat_n));
	<span class="enscript-type">struct</span> kern_event_pcb  *ev_pcb;

	buf = _MALLOC(item_size, M_TEMP, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (buf == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	lck_rw_lock_shared(kev_rwlock);

	n = kevtstat.kes_pcbcount;

	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		req-&gt;oldidx = (n + n/8) * item_size;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	bzero(&amp;xsg, <span class="enscript-keyword">sizeof</span> (xsg));
	xsg.xg_len = <span class="enscript-keyword">sizeof</span> (xsg);
	xsg.xg_count = n;
	xsg.xg_gen = kevtstat.kes_gencnt;
	xsg.xg_sogen = so_gencnt;
	error = SYSCTL_OUT(req, &amp;xsg, <span class="enscript-keyword">sizeof</span> (xsg));
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/*
	 * We are done if there is no pcb
	 */</span>
	<span class="enscript-keyword">if</span> (n == 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	i = 0;
	<span class="enscript-keyword">for</span> (i = 0, ev_pcb = LIST_FIRST(&amp;kern_event_head);
	    i &lt; n &amp;&amp; ev_pcb != NULL;
	    i++, ev_pcb = LIST_NEXT(ev_pcb, evp_link)) {
		<span class="enscript-type">struct</span> xkevtpcb *xk = (<span class="enscript-type">struct</span> xkevtpcb *)buf;
		<span class="enscript-type">struct</span> xsocket_n *xso = (<span class="enscript-type">struct</span> xsocket_n *)
			ADVANCE64(xk, <span class="enscript-keyword">sizeof</span> (*xk));
		<span class="enscript-type">struct</span> xsockbuf_n *xsbrcv = (<span class="enscript-type">struct</span> xsockbuf_n *)
			ADVANCE64(xso, <span class="enscript-keyword">sizeof</span> (*xso));
		<span class="enscript-type">struct</span> xsockbuf_n *xsbsnd = (<span class="enscript-type">struct</span> xsockbuf_n *)
			ADVANCE64(xsbrcv, <span class="enscript-keyword">sizeof</span> (*xsbrcv));
		<span class="enscript-type">struct</span> xsockstat_n *xsostats = (<span class="enscript-type">struct</span> xsockstat_n *)
			ADVANCE64(xsbsnd, <span class="enscript-keyword">sizeof</span> (*xsbsnd));

		bzero(buf, item_size);

		lck_mtx_lock(&amp;ev_pcb-&gt;evp_mtx);

		xk-&gt;kep_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> xkevtpcb);
		xk-&gt;kep_kind = XSO_EVT;
		xk-&gt;kep_evtpcb = (uint64_t)VM_KERNEL_ADDRPERM(ev_pcb);
		xk-&gt;kep_vendor_code_filter = ev_pcb-&gt;evp_vendor_code_filter;
		xk-&gt;kep_class_filter = ev_pcb-&gt;evp_class_filter;
		xk-&gt;kep_subclass_filter = ev_pcb-&gt;evp_subclass_filter;

		sotoxsocket_n(ev_pcb-&gt;evp_socket, xso);
		sbtoxsockbuf_n(ev_pcb-&gt;evp_socket ?
			&amp;ev_pcb-&gt;evp_socket-&gt;so_rcv : NULL, xsbrcv);
		sbtoxsockbuf_n(ev_pcb-&gt;evp_socket ?
			&amp;ev_pcb-&gt;evp_socket-&gt;so_snd : NULL, xsbsnd);
		sbtoxsockstat_n(ev_pcb-&gt;evp_socket, xsostats);

		lck_mtx_unlock(&amp;ev_pcb-&gt;evp_mtx);

		error = SYSCTL_OUT(req, buf, item_size);
	}

	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-comment">/*
		 * Give the user an updated idea of our state.
		 * If the generation differs from what we told
		 * her before, she knows that something happened
		 * while we were processing this request, and it
		 * might be necessary to retry.
		 */</span>
		bzero(&amp;xsg, <span class="enscript-keyword">sizeof</span> (xsg));
		xsg.xg_len = <span class="enscript-keyword">sizeof</span> (xsg);
		xsg.xg_count = n;
		xsg.xg_gen = kevtstat.kes_gencnt;
		xsg.xg_sogen = so_gencnt;
		error = SYSCTL_OUT(req, &amp;xsg, <span class="enscript-keyword">sizeof</span> (xsg));
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

<span class="enscript-reference">done</span>:
	lck_rw_done(kev_rwlock);

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* SOCKETS */</span>


<span class="enscript-type">int</span>
<span class="enscript-function-name">fill_kqueueinfo</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">struct</span> kqueue_info * kinfo)
{
	<span class="enscript-type">struct</span> vinfo_stat * st;

	st = &amp;kinfo-&gt;kq_stat;

	st-&gt;vst_size = kq-&gt;kq_count;
	<span class="enscript-keyword">if</span> (kq-&gt;kq_state &amp; KQ_KEV_QOS)
		st-&gt;vst_blksize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevent_qos_s);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kq-&gt;kq_state &amp; KQ_KEV64)
		st-&gt;vst_blksize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevent64_s);
	<span class="enscript-keyword">else</span>
		st-&gt;vst_blksize = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevent);
	st-&gt;vst_mode = S_IFIFO;

	<span class="enscript-comment">/* flags exported to libproc as PROC_KQUEUE_* (sys/proc_info.h) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PROC_KQUEUE_MASK</span> (KQ_SEL|KQ_SLEEP|KQ_KEV32|KQ_KEV64|KQ_KEV_QOS)
	kinfo-&gt;kq_state = kq-&gt;kq_state &amp; PROC_KQUEUE_MASK;

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">knote_markstayqueued</span>(<span class="enscript-type">struct</span> knote *kn)
{
	kqlock(kn-&gt;kn_kq);
	kn-&gt;kn_status |= KN_STAYQUEUED;
	knote_enqueue(kn);
	kqunlock(kn-&gt;kn_kq);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">knote_clearstayqueued</span>(<span class="enscript-type">struct</span> knote *kn)
{
	kqlock(kn-&gt;kn_kq);
	kn-&gt;kn_status &amp;= ~KN_STAYQUEUED;
	knote_dequeue(kn);
	kqunlock(kn-&gt;kn_kq);
}

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">kevent_extinfo_emit</span>(<span class="enscript-type">struct</span> kqueue *kq, <span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">struct</span> kevent_extinfo *buf,
		<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> buflen, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> nknotes)
{
	<span class="enscript-type">struct</span> kevent_qos_s kevqos;
	<span class="enscript-type">struct</span> kevent_internal_s *kevp;
	<span class="enscript-keyword">for</span> (; kn; kn = SLIST_NEXT(kn, kn_link)) {
		<span class="enscript-keyword">if</span> (kq == kn-&gt;kn_kq) {
			<span class="enscript-keyword">if</span> (nknotes &lt; buflen) {
				<span class="enscript-type">struct</span> kevent_extinfo *info = &amp;buf[nknotes];

				kqlock(kq);
				bzero(&amp;kevqos, <span class="enscript-keyword">sizeof</span>(kevqos));
				kevp = &amp;(kn-&gt;kn_kevent);

				kevqos.ident = kevp-&gt;ident;
				kevqos.filter = kevp-&gt;filter;
				kevqos.flags = kevp-&gt;flags;
				kevqos.fflags = kevp-&gt;fflags;
				kevqos.data = (int64_t) kevp-&gt;data;
				kevqos.udata = kevp-&gt;udata;
				kevqos.ext[0] = kevp-&gt;ext[0];
				kevqos.ext[1] = kevp-&gt;ext[1];

				memcpy(&amp;info-&gt;kqext_kev, &amp;kevqos, <span class="enscript-keyword">sizeof</span>(info-&gt;kqext_kev));
				info-&gt;kqext_sdata = kn-&gt;kn_sdata;

				<span class="enscript-comment">/* status flags exported to userspace/libproc */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KQEXT_STATUS_MASK</span> (KN_ACTIVE|KN_QUEUED|KN_DISABLED|KN_STAYQUEUED)
				info-&gt;kqext_status = kn-&gt;kn_status &amp; KQEXT_STATUS_MASK;
				info-&gt;kqext_sfflags = kn-&gt;kn_sfflags;

				kqunlock(kq);
			}

			<span class="enscript-comment">/* we return total number of knotes, which may be more than requested */</span>
			nknotes++;
		}
	}

	<span class="enscript-keyword">return</span> nknotes;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pid_kqueue_extinfo</span>(proc_t p, <span class="enscript-type">struct</span> kqueue *kq, user_addr_t ubuf,
		uint32_t bufsize, int32_t *retval)
{
	<span class="enscript-type">struct</span> knote *kn;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> err = 0;
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> nknotes = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> buflen = bufsize / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevent_extinfo);
	<span class="enscript-type">struct</span> kevent_extinfo *kqext = NULL;

	kqext = kalloc(buflen * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevent_extinfo));
	<span class="enscript-keyword">if</span> (kqext == NULL) {
		err = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	bzero(kqext, buflen * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevent_extinfo));

	proc_fdlock(p);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; fdp-&gt;fd_knlistsize; i++) {
		kn = SLIST_FIRST(&amp;fdp-&gt;fd_knlist[i]);
		nknotes = kevent_extinfo_emit(kq, kn, kqext, buflen, nknotes);
	}

	<span class="enscript-keyword">if</span> (fdp-&gt;fd_knhashmask != 0) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; (<span class="enscript-type">int</span>)fdp-&gt;fd_knhashmask + 1; i++) {
			kn = SLIST_FIRST(&amp;fdp-&gt;fd_knhash[i]);
			nknotes = kevent_extinfo_emit(kq, kn, kqext, buflen, nknotes);
		}
	}

	proc_fdunlock(p);

	assert(bufsize &gt;= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevent_extinfo) * min(buflen, nknotes));
	err = copyout(kqext, ubuf, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevent_extinfo) * min(buflen, nknotes));

 <span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (kqext) {
		kfree(kqext, buflen * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kevent_extinfo));
		kqext = NULL;
	}

	<span class="enscript-keyword">if</span> (!err)
		*retval = nknotes;
	<span class="enscript-keyword">return</span> err;
}
</pre>
<hr />
</body></html>