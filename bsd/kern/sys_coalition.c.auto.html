<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>sys_coalition.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">sys_coalition.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/coalition.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/coalition.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>

<span class="enscript-comment">/* Coalitions syscalls */</span>

<span class="enscript-comment">/*
 * Create a new, empty coalition and return its ID.
 *
 * Returns:
 * EINVAL	Flags parameter was invalid
 * ENOMEM	Unable to allocate kernel resources for a new coalition
 * EFAULT	cidp parameter pointed to invalid memory.
 *
 * Returns with reference held for userspace caller.
 */</span>
<span class="enscript-type">static</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">coalition_create_syscall</span>(user_addr_t cidp, uint32_t flags)
{
	<span class="enscript-type">int</span> error = 0;
	kern_return_t kr;
	uint64_t cid;
	coalition_t coal;
	<span class="enscript-type">int</span> type = COALITION_CREATE_FLAGS_GET_TYPE(flags);
	boolean_t privileged = !!(flags &amp; COALITION_CREATE_FLAGS_PRIVILEGED);

	<span class="enscript-keyword">if</span> ((flags &amp; (~COALITION_CREATE_FLAGS_MASK)) != 0)
		<span class="enscript-keyword">return</span> EINVAL;
	<span class="enscript-keyword">if</span> (type &lt; 0 || type &gt; COALITION_TYPE_MAX)
		<span class="enscript-keyword">return</span> EINVAL;

	kr = coalition_create_internal(type, privileged, &amp;coal);
	<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
		<span class="enscript-comment">/* for now, the only kr is KERN_RESOURCE_SHORTAGE */</span>
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	cid = coalition_id(coal);

	coal_dbg(<span class="enscript-string">&quot;(addr, %u) -&gt; %llu&quot;</span>, flags, cid);
	error = copyout(&amp;cid, cidp, <span class="enscript-keyword">sizeof</span>(cid));
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Request to terminate the coalition identified by ID.
 * Attempts to spawn into this coalition using the posix_spawnattr will begin
 * failing. Processes already within the coalition may still fork.
 * Arms the 'coalition is empty' notification when the coalition's active
 * count reaches zero.
 *
 * Returns:
 * ESRCH	No coalition with that ID could be found.
 * EALREADY	The coalition with that ID has already been terminated.
 * EFAULT	cidp parameter pointed to invalid memory.
 * EPERM	Caller doesn't have permission to terminate that coalition.
 */</span>
<span class="enscript-type">static</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">coalition_request_terminate_syscall</span>(user_addr_t cidp, uint32_t flags)
{
	kern_return_t kr;
	<span class="enscript-type">int</span> error = 0;
	uint64_t cid;
	coalition_t coal;

	<span class="enscript-keyword">if</span> (flags != 0) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	error = copyin(cidp, &amp;cid, <span class="enscript-keyword">sizeof</span>(cid));
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> error;
	}

	coal = coalition_find_by_id(cid);
	<span class="enscript-keyword">if</span> (coal == COALITION_NULL) {
		<span class="enscript-keyword">return</span> ESRCH;
	}

	kr = coalition_request_terminate_internal(coal);
	coalition_release(coal);

	<span class="enscript-keyword">switch</span> (kr) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SUCCESS</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_DEFAULT_SET</span>:
		error = EPERM;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_TERMINATED</span>:
		error = EALREADY;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_INVALID_NAME</span>:
		error = ESRCH;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EIO;
		<span class="enscript-keyword">break</span>;
	}

	coal_dbg(<span class="enscript-string">&quot;(%llu, %u) -&gt; %d&quot;</span>, cid, flags, error);

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Request the kernel to deallocate the coalition identified by ID, which
 * must be both terminated and empty. This balances the reference taken
 * in coalition_create.
 * The memory containig the coalition object may not be freed just yet, if
 * other kernel operations still hold references to it.
 *
 * Returns:
 * EINVAL	Flags parameter was invalid
 * ESRCH	Coalition ID refers to a coalition that doesn't exist.
 * EBUSY	Coalition has not yet been terminated.
 * EBUSY	Coalition is still active.
 * EFAULT	cidp parameter pointed to invalid memory.
 * EPERM	Caller doesn't have permission to terminate that coalition.
 * Consumes one reference, &quot;held&quot; by caller since coalition_create
 */</span>
<span class="enscript-type">static</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">coalition_reap_syscall</span>(user_addr_t cidp, uint32_t flags)
{
	kern_return_t kr;
	<span class="enscript-type">int</span> error = 0;
	uint64_t cid;
	coalition_t coal;

	<span class="enscript-keyword">if</span> (flags != 0) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	error = copyin(cidp, &amp;cid, <span class="enscript-keyword">sizeof</span>(cid));
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> error;
	}

	coal = coalition_find_by_id(cid);
	<span class="enscript-keyword">if</span> (coal == COALITION_NULL) {
		<span class="enscript-keyword">return</span> ESRCH;
	}

	kr = coalition_reap_internal(coal);
	coalition_release(coal);

	<span class="enscript-keyword">switch</span> (kr) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SUCCESS</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_DEFAULT_SET</span>:
		error = EPERM;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_TERMINATED</span>:
		error = ESRCH;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_FAILURE</span>:
		error = EBUSY;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EIO;
		<span class="enscript-keyword">break</span>;
	}

	coal_dbg(<span class="enscript-string">&quot;(%llu, %u) -&gt; %d&quot;</span>, cid, flags, error);

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/* Syscall demux.
 * Returns EPERM if the calling process is not privileged to make this call.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">coalition</span>(proc_t p, <span class="enscript-type">struct</span> coalition_args *cap, __unused int32_t *retval)
{
	uint32_t operation = cap-&gt;operation;
	user_addr_t cidp = cap-&gt;cid;
	uint32_t flags = cap-&gt;flags;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> type = COALITION_CREATE_FLAGS_GET_TYPE(flags);

	<span class="enscript-keyword">if</span> (!task_is_in_privileged_coalition(p-&gt;task, type)) {
		<span class="enscript-keyword">return</span> EPERM;
	}

	<span class="enscript-keyword">switch</span> (operation) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_OP_CREATE</span>:
		error = coalition_create_syscall(cidp, flags);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_OP_REAP</span>:
		error = coalition_reap_syscall(cidp, flags);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_OP_TERMINATE</span>:
		error = coalition_request_terminate_syscall(cidp, flags);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = ENOSYS;
	}
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/* This is a temporary interface, likely to be changed by 15385642. */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline))
<span class="enscript-function-name">coalition_info_resource_usage</span>(coalition_t coal, user_addr_t buffer, user_size_t bufsize)
{
	kern_return_t kr;
	<span class="enscript-type">struct</span> coalition_resource_usage cru;

	<span class="enscript-keyword">if</span> (bufsize != <span class="enscript-keyword">sizeof</span>(cru)) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	kr = coalition_resource_usage_internal(coal, &amp;cru);

	<span class="enscript-keyword">switch</span> (kr) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_INVALID_ARGUMENT</span>:
		<span class="enscript-keyword">return</span> EINVAL;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_RESOURCE_SHORTAGE</span>:
		<span class="enscript-keyword">return</span> ENOMEM;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SUCCESS</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> EIO; <span class="enscript-comment">/* shrug */</span>
	}

	<span class="enscript-keyword">return</span> copyout(&amp;cru, buffer, bufsize);
}

<span class="enscript-type">int</span> <span class="enscript-function-name">coalition_info</span>(proc_t p, <span class="enscript-type">struct</span> coalition_info_args *uap, __unused int32_t *retval)
{
	user_addr_t cidp = uap-&gt;cid;
	user_addr_t buffer = uap-&gt;buffer;
	user_addr_t bufsizep = uap-&gt;bufsize;
	user_size_t bufsize;
	uint32_t flavor = uap-&gt;flavor;
	<span class="enscript-type">int</span> error;
	uint64_t cid;
	coalition_t coal;

	error = copyin(cidp, &amp;cid, <span class="enscript-keyword">sizeof</span>(cid));
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> error;
	}

	coal = coalition_find_by_id(cid);
	<span class="enscript-keyword">if</span> (coal == COALITION_NULL) {
		<span class="enscript-keyword">return</span> ESRCH;
	}
	<span class="enscript-comment">/* TODO: priv check? EPERM or ESRCH? */</span>

	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		user64_size_t size64;
		error = copyin(bufsizep, &amp;size64, <span class="enscript-keyword">sizeof</span>(size64));
		bufsize = (user_size_t)size64;
	} <span class="enscript-keyword">else</span> {
		user32_size_t size32;
		error = copyin(bufsizep, &amp;size32, <span class="enscript-keyword">sizeof</span>(size32));
		bufsize = (user_size_t)size32;
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">switch</span> (flavor) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">COALITION_INFO_RESOURCE_USAGE</span>:
		error = coalition_info_resource_usage(coal, buffer, bufsize);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EINVAL;
	}

<span class="enscript-reference">bad</span>:
	coalition_release(coal);
	<span class="enscript-keyword">return</span> error;
}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEVELOPMENT</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEBUG</span>)
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_coalition_get_ids SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, pid;
	proc_t tproc;
	uint64_t value;
	uint64_t ids[COALITION_NUM_TYPES];


	error = SYSCTL_IN(req, &amp;value, <span class="enscript-keyword">sizeof</span>(value));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;
	<span class="enscript-keyword">if</span> (!req-&gt;newptr)
		pid = req-&gt;p-&gt;p_pid;
	<span class="enscript-keyword">else</span>
		pid = (<span class="enscript-type">int</span>)value;

	coal_dbg(<span class="enscript-string">&quot;looking up coalitions for pid:%d&quot;</span>, pid);
	tproc = proc_find(pid);
	<span class="enscript-keyword">if</span> (tproc == NULL) {
		coal_dbg(<span class="enscript-string">&quot;ERROR: Couldn't find pid:%d&quot;</span>, pid);
		<span class="enscript-keyword">return</span> ESRCH;
	}

	task_coalition_ids(tproc-&gt;task, ids);
	proc_rele(tproc);

	<span class="enscript-keyword">return</span> SYSCTL_OUT(req, ids, <span class="enscript-keyword">sizeof</span>(ids));
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, coalitions, CTLTYPE_QUAD | CTLFLAG_RW | CTLFLAG_LOCKED,
	    0, 0, sysctl_coalition_get_ids, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;coalition ids of a given process&quot;</span>);


<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_coalition_get_roles SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, pid;
	proc_t tproc;
	<span class="enscript-type">int</span> value;
	<span class="enscript-type">int</span> roles[COALITION_NUM_TYPES];


	error = SYSCTL_IN(req, &amp;value, <span class="enscript-keyword">sizeof</span>(value));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;
	<span class="enscript-keyword">if</span> (!req-&gt;newptr)
		pid = req-&gt;p-&gt;p_pid;
	<span class="enscript-keyword">else</span>
		pid = (<span class="enscript-type">int</span>)value;

	coal_dbg(<span class="enscript-string">&quot;looking up coalitions for pid:%d&quot;</span>, pid);
	tproc = proc_find(pid);
	<span class="enscript-keyword">if</span> (tproc == NULL) {
		coal_dbg(<span class="enscript-string">&quot;ERROR: Couldn't find pid:%d&quot;</span>, pid);
		<span class="enscript-keyword">return</span> ESRCH;
	}

	task_coalition_roles(tproc-&gt;task, roles);
	proc_rele(tproc);

	<span class="enscript-keyword">return</span> SYSCTL_OUT(req, roles, <span class="enscript-keyword">sizeof</span>(roles));
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, coalition_roles, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
	    0, 0, sysctl_coalition_get_roles, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;coalition roles of a given process&quot;</span>);


<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_coalition_get_page_count SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, pid;
	proc_t tproc;
	coalition_t coal;
	uint64_t value;
	uint64_t pgcount[COALITION_NUM_TYPES];


	error = SYSCTL_IN(req, &amp;value, <span class="enscript-keyword">sizeof</span>(value));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;
	<span class="enscript-keyword">if</span> (!req-&gt;newptr)
		pid = req-&gt;p-&gt;p_pid;
	<span class="enscript-keyword">else</span>
		pid = (<span class="enscript-type">int</span>)value;

	coal_dbg(<span class="enscript-string">&quot;looking up coalitions for pid:%d&quot;</span>, pid);
	tproc = proc_find(pid);
	<span class="enscript-keyword">if</span> (tproc == NULL) {
		coal_dbg(<span class="enscript-string">&quot;ERROR: Couldn't find pid:%d&quot;</span>, pid);
		<span class="enscript-keyword">return</span> ESRCH;
	}

	memset(pgcount, 0, <span class="enscript-keyword">sizeof</span>(pgcount));

	<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> t = 0; t &lt; COALITION_NUM_TYPES; t++) {
		coal = COALITION_NULL;
		coalition_is_leader(tproc-&gt;task, t, &amp;coal);
		<span class="enscript-keyword">if</span> (coal != COALITION_NULL) {
			<span class="enscript-type">int</span> ntasks = 0;
			pgcount[t] = coalition_get_page_count(coal, &amp;ntasks);
			coal_dbg(<span class="enscript-string">&quot;PID:%d, Coalition:%lld, type:%d, pgcount:%lld&quot;</span>,
				 pid, coalition_id(coal), t, pgcount[t]);
		}
	}

	proc_rele(tproc);

	<span class="enscript-keyword">return</span> SYSCTL_OUT(req, pgcount, <span class="enscript-keyword">sizeof</span>(pgcount));
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, coalition_page_count, CTLTYPE_QUAD | CTLFLAG_RW | CTLFLAG_LOCKED,
	    0, 0, sysctl_coalition_get_page_count, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;coalition page count of a specified process&quot;</span>);


<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_coalition_get_pid_list SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, type, sort_order, pid;
	<span class="enscript-type">int</span> value[3];
	<span class="enscript-type">int</span> has_pid = 1;

	coalition_t coal = COALITION_NULL;
	proc_t tproc = PROC_NULL;
	<span class="enscript-type">int</span> npids = 0;
	<span class="enscript-type">int</span> pidlist[100] = { 0, };


	error = SYSCTL_IN(req, &amp;value, <span class="enscript-keyword">sizeof</span>(value));
	<span class="enscript-keyword">if</span> (error) {
		has_pid = 0;
		error = SYSCTL_IN(req, &amp;value, <span class="enscript-keyword">sizeof</span>(value) - <span class="enscript-keyword">sizeof</span>(value[0]));
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;
	<span class="enscript-keyword">if</span> (!req-&gt;newptr) {
		type = COALITION_TYPE_RESOURCE;
		sort_order = COALITION_SORT_DEFAULT;
		pid = req-&gt;p-&gt;p_pid;
	} <span class="enscript-keyword">else</span> {
		type = value[0];
		sort_order = value[1];
		<span class="enscript-keyword">if</span> (has_pid)
			pid = value[2];
		<span class="enscript-keyword">else</span>
			pid = req-&gt;p-&gt;p_pid;
	}

	<span class="enscript-keyword">if</span> (type &lt; 0 || type &gt;= COALITION_NUM_TYPES)
		<span class="enscript-keyword">return</span> EINVAL;

	coal_dbg(<span class="enscript-string">&quot;getting constituent PIDS for coalition of type %d &quot;</span>
		 <span class="enscript-string">&quot;containing pid:%d (sort:%d)&quot;</span>, type, pid, sort_order);
	tproc = proc_find(pid);
	<span class="enscript-keyword">if</span> (tproc == NULL) {
		coal_dbg(<span class="enscript-string">&quot;ERROR: Couldn't find pid:%d&quot;</span>, pid);
		<span class="enscript-keyword">return</span> ESRCH;
	}

	(<span class="enscript-type">void</span>)coalition_is_leader(tproc-&gt;task, type, &amp;coal);
	<span class="enscript-keyword">if</span> (coal == COALITION_NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	npids = coalition_get_pid_list(coal, COALITION_ROLEMASK_ALLROLES, sort_order,
				       pidlist, <span class="enscript-keyword">sizeof</span>(pidlist) / <span class="enscript-keyword">sizeof</span>(pidlist[0]));
	<span class="enscript-keyword">if</span> (npids &gt; (<span class="enscript-type">int</span>)(<span class="enscript-keyword">sizeof</span>(pidlist) / <span class="enscript-keyword">sizeof</span>(pidlist[0]))) {
		coal_dbg(<span class="enscript-string">&quot;Too many members in coalition %llu (from pid:%d): %d!&quot;</span>,
			 coalition_id(coal), pid, npids);
		npids = <span class="enscript-keyword">sizeof</span>(pidlist) / <span class="enscript-keyword">sizeof</span>(pidlist[0]);
	}

<span class="enscript-reference">out</span>:
	proc_rele(tproc);

	<span class="enscript-keyword">if</span> (npids == 0)
		<span class="enscript-keyword">return</span> ENOENT;

	<span class="enscript-keyword">return</span> SYSCTL_OUT(req, pidlist, <span class="enscript-keyword">sizeof</span>(pidlist[0]) * npids);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, coalition_pid_list, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
	    0, 0, sysctl_coalition_get_pid_list, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;list of PIDS which are members of the coalition of the current process&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_coalition_notify SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, should_set;
	coalition_t coal;
	uint64_t value[2];

	should_set = 1;
	error = SYSCTL_IN(req, value, <span class="enscript-keyword">sizeof</span>(value));
	<span class="enscript-keyword">if</span> (error) {
		error = SYSCTL_IN(req, value, <span class="enscript-keyword">sizeof</span>(value) - <span class="enscript-keyword">sizeof</span>(value[0]));
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> error;
		should_set = 0;
	}
	<span class="enscript-keyword">if</span> (!req-&gt;newptr)
		<span class="enscript-keyword">return</span> error;

	coal = coalition_find_by_id(value[0]);
	<span class="enscript-keyword">if</span> (coal == COALITION_NULL) {
		coal_dbg(<span class="enscript-string">&quot;Can't find coalition with ID:%lld&quot;</span>, value[0]);
		<span class="enscript-keyword">return</span> ESRCH;
	}

	<span class="enscript-keyword">if</span> (should_set)
		coalition_set_notify(coal, (<span class="enscript-type">int</span>)value[1]);

	value[0] = (uint64_t)coalition_should_notify(coal);

	coalition_release(coal);

	<span class="enscript-keyword">return</span> SYSCTL_OUT(req, value, <span class="enscript-keyword">sizeof</span>(value[0]));
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, coalition_notify, CTLTYPE_QUAD | CTLFLAG_RW | CTLFLAG_LOCKED,
	    0, 0, sysctl_coalition_notify, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;get/set coalition notification flag&quot;</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> unrestrict_coalition_syscalls;
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, unrestrict_coalitions,
	   CTLFLAG_RW, &amp;unrestrict_coalition_syscalls, 0,
	   <span class="enscript-string">&quot;unrestrict the coalition interface&quot;</span>);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
</pre>
<hr />
</body></html>