<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_synch.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_synch.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* 
 * Mach Operating System
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/spl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ast.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_number.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/time_value.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>			<span class="enscript-comment">/* for unix_syscall_return() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">compute_averunnable</span>(<span class="enscript-type">void</span> *);	<span class="enscript-comment">/* XXX */</span>



<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_sleep_continue</span>( __unused <span class="enscript-type">void</span> *parameter, wait_result_t wresult)
{
	<span class="enscript-type">struct</span> proc *p = current_proc();
	thread_t self  = current_thread();
	<span class="enscript-type">struct</span> uthread * ut;
	<span class="enscript-type">int</span> sig, catch;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> dropmutex, spinmutex;

	ut = get_bsdthread_info(self);
	catch     = ut-&gt;uu_pri &amp; PCATCH;
	dropmutex = ut-&gt;uu_pri &amp; PDROP;
	spinmutex = ut-&gt;uu_pri &amp; PSPIN;

	<span class="enscript-keyword">switch</span> (wresult) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_TIMED_OUT</span>:
			error = EWOULDBLOCK;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_AWAKENED</span>:
			<span class="enscript-comment">/*
			 * Posix implies any signal should be delivered
			 * first, regardless of whether awakened due
			 * to receiving event.
			 */</span>
			<span class="enscript-keyword">if</span> (!catch)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-comment">/* else fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_INTERRUPTED</span>:
			<span class="enscript-keyword">if</span> (catch) {
				<span class="enscript-keyword">if</span> (thread_should_abort(self)) {
					error = EINTR;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SHOULDissignal(p,ut)) {
					<span class="enscript-keyword">if</span> ((sig = CURSIG(p)) != 0) {
						<span class="enscript-keyword">if</span> (p-&gt;p_sigacts-&gt;ps_sigintr &amp; sigmask(sig))
							error = EINTR;
						<span class="enscript-keyword">else</span>
							error = ERESTART;
					}
					<span class="enscript-keyword">if</span> (thread_should_abort(self)) {
						error = EINTR;
					}
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( (ut-&gt;uu_flag &amp; ( UT_CANCELDISABLE | UT_CANCEL | UT_CANCELED)) == UT_CANCEL) {
                                        <span class="enscript-comment">/* due to thread cancel */</span>
                                        error = EINTR;
                                }
			}  <span class="enscript-keyword">else</span>
				error = EINTR;
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (error == EINTR || error == ERESTART)
		act_set_astbsd(self);

	<span class="enscript-keyword">if</span> (ut-&gt;uu_mtx &amp;&amp; !dropmutex) {
		<span class="enscript-keyword">if</span> (spinmutex)
			lck_mtx_lock_spin(ut-&gt;uu_mtx);
		<span class="enscript-keyword">else</span>
			lck_mtx_lock(ut-&gt;uu_mtx);
	}
	ut-&gt;uu_wchan = NULL;
	ut-&gt;uu_wmesg = NULL;

	unix_syscall_return((*ut-&gt;uu_continuation)(error));
}

<span class="enscript-comment">/*
 * Give up the processor till a wakeup occurs
 * on chan, at which time the process
 * enters the scheduling queue at priority pri.
 * The most important effect of pri is that when
 * pri&lt;=PZERO a signal cannot disturb the sleep;
 * if pri&gt;PZERO signals will be processed.
 * If pri&amp;PCATCH is set, signals will cause sleep
 * to return 1, rather than longjmp.
 * Callers of this routine must be prepared for
 * premature return, and check that the reason for
 * sleeping has gone away.
 *
 * if msleep was the entry point, than we have a mutex to deal with
 *
 * The mutex is unlocked before the caller is blocked, and
 * relocked before msleep returns unless the priority includes the PDROP
 * flag... if PDROP is specified, _sleep returns with the mutex unlocked
 * regardless of whether it actually blocked or not.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">_sleep</span>(
	caddr_t		chan,
	<span class="enscript-type">int</span>		pri,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*wmsg,
	u_int64_t	abstime,
	<span class="enscript-type">int</span>		(*continuation)(<span class="enscript-type">int</span>),
        lck_mtx_t	*mtx)
{
	<span class="enscript-type">struct</span> proc *p;
	thread_t self = current_thread();
	<span class="enscript-type">struct</span> uthread * ut;
	<span class="enscript-type">int</span> sig, catch;
	<span class="enscript-type">int</span> dropmutex  = pri &amp; PDROP;
	<span class="enscript-type">int</span> spinmutex  = pri &amp; PSPIN;
	<span class="enscript-type">int</span> wait_result;
	<span class="enscript-type">int</span> error = 0;

	ut = get_bsdthread_info(self);

	p = current_proc();
	p-&gt;p_priority = pri &amp; PRIMASK;
	<span class="enscript-comment">/* It can still block in proc_exit() after the teardown. */</span>
	<span class="enscript-keyword">if</span> (p-&gt;p_stats != NULL)
		OSIncrementAtomicLong(&amp;p-&gt;p_stats-&gt;p_ru.ru_nvcsw);
	
	<span class="enscript-keyword">if</span> (pri &amp; PCATCH)
		catch = THREAD_ABORTSAFE;
	<span class="enscript-keyword">else</span>
		catch = THREAD_UNINT;

	<span class="enscript-comment">/* set wait message &amp; channel */</span>
	ut-&gt;uu_wchan = chan;
	ut-&gt;uu_wmesg = wmsg ? wmsg : <span class="enscript-string">&quot;unknown&quot;</span>;

	<span class="enscript-keyword">if</span> (mtx != NULL &amp;&amp; chan != NULL &amp;&amp; (thread_continue_t)continuation == THREAD_CONTINUE_NULL) {
		<span class="enscript-type">int</span>	flags;

		<span class="enscript-keyword">if</span> (dropmutex)
			flags = LCK_SLEEP_UNLOCK;
		<span class="enscript-keyword">else</span>
			flags = LCK_SLEEP_DEFAULT;

		<span class="enscript-keyword">if</span> (spinmutex)
			flags |= LCK_SLEEP_SPIN;

		<span class="enscript-keyword">if</span> (abstime)
			wait_result = lck_mtx_sleep_deadline(mtx, flags, chan, catch, abstime);
		<span class="enscript-keyword">else</span>
			wait_result = lck_mtx_sleep(mtx, flags, chan, catch);
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (chan != NULL)
			assert_wait_deadline(chan, catch, abstime);
		<span class="enscript-keyword">if</span> (mtx)
			lck_mtx_unlock(mtx);

		<span class="enscript-keyword">if</span> (catch == THREAD_ABORTSAFE) {
			<span class="enscript-keyword">if</span> (SHOULDissignal(p,ut)) {
				<span class="enscript-keyword">if</span> ((sig = CURSIG(p)) != 0) {
					<span class="enscript-keyword">if</span> (clear_wait(self, THREAD_INTERRUPTED) == KERN_FAILURE)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">block</span>;
					<span class="enscript-keyword">if</span> (p-&gt;p_sigacts-&gt;ps_sigintr &amp; sigmask(sig))
						error = EINTR;
					<span class="enscript-keyword">else</span>
						error = ERESTART;
					<span class="enscript-keyword">if</span> (mtx &amp;&amp; !dropmutex) {
						<span class="enscript-keyword">if</span> (spinmutex)
							lck_mtx_lock_spin(mtx);
						<span class="enscript-keyword">else</span>
							lck_mtx_lock(mtx);
					}
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
			}
			<span class="enscript-keyword">if</span> (thread_should_abort(self)) {
				<span class="enscript-keyword">if</span> (clear_wait(self, THREAD_INTERRUPTED) == KERN_FAILURE)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">block</span>;
				error = EINTR;

				<span class="enscript-keyword">if</span> (mtx &amp;&amp; !dropmutex) {
					<span class="enscript-keyword">if</span> (spinmutex)
						lck_mtx_lock_spin(mtx);
					<span class="enscript-keyword">else</span>
						lck_mtx_lock(mtx);
				}
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		}		


<span class="enscript-reference">block</span>:
		<span class="enscript-keyword">if</span> ((thread_continue_t)continuation != THREAD_CONTINUE_NULL) {
		        ut-&gt;uu_continuation = continuation;
			ut-&gt;uu_pri  = pri;
			ut-&gt;uu_timo = abstime? 1: 0;
			ut-&gt;uu_mtx  = mtx;
			(<span class="enscript-type">void</span>) thread_block(_sleep_continue);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		
		wait_result = thread_block(THREAD_CONTINUE_NULL);

		<span class="enscript-keyword">if</span> (mtx &amp;&amp; !dropmutex) {
			<span class="enscript-keyword">if</span> (spinmutex)
				lck_mtx_lock_spin(mtx);
			<span class="enscript-keyword">else</span>
				lck_mtx_lock(mtx);
		}
	}

	<span class="enscript-keyword">switch</span> (wait_result) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_TIMED_OUT</span>:
			error = EWOULDBLOCK;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_AWAKENED</span>:
			<span class="enscript-comment">/*
			 * Posix implies any signal should be delivered
			 * first, regardless of whether awakened due
			 * to receiving event.
			 */</span>
			<span class="enscript-keyword">if</span> (catch != THREAD_ABORTSAFE)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-comment">/* else fall through */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">THREAD_INTERRUPTED</span>:
			<span class="enscript-keyword">if</span> (catch == THREAD_ABORTSAFE) {
				<span class="enscript-keyword">if</span> (thread_should_abort(self)) {
					error = EINTR;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SHOULDissignal(p, ut)) {
					<span class="enscript-keyword">if</span> ((sig = CURSIG(p)) != 0) {
						<span class="enscript-keyword">if</span> (p-&gt;p_sigacts-&gt;ps_sigintr &amp; sigmask(sig))
							error = EINTR;
						<span class="enscript-keyword">else</span>
							error = ERESTART;
					}
					<span class="enscript-keyword">if</span> (thread_should_abort(self)) {
						error = EINTR;
					}
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span>( (ut-&gt;uu_flag &amp; ( UT_CANCELDISABLE | UT_CANCEL | UT_CANCELED)) == UT_CANCEL) {
                                        <span class="enscript-comment">/* due to thread cancel */</span>
                                        error = EINTR;
                                }
			}  <span class="enscript-keyword">else</span>
				error = EINTR;
			<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (error == EINTR || error == ERESTART)
		act_set_astbsd(self);
	ut-&gt;uu_wchan = NULL;
	ut-&gt;uu_wmesg = NULL;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sleep</span>(
	<span class="enscript-type">void</span>	*chan,
	<span class="enscript-type">int</span>		pri)
{
	<span class="enscript-keyword">return</span> _sleep((caddr_t)chan, pri, (<span class="enscript-type">char</span> *)NULL, 0, (<span class="enscript-type">int</span> (*)(<span class="enscript-type">int</span>))0, (lck_mtx_t *)0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">msleep0</span>(
	<span class="enscript-type">void</span>		*chan,
	lck_mtx_t	*mtx,
	<span class="enscript-type">int</span>		pri,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*wmsg,
	<span class="enscript-type">int</span>		timo,
	<span class="enscript-type">int</span>		(*continuation)(<span class="enscript-type">int</span>))
{
	u_int64_t	abstime = 0;

	<span class="enscript-keyword">if</span> (timo)
		clock_interval_to_deadline(timo, NSEC_PER_SEC / hz, &amp;abstime);

	<span class="enscript-keyword">return</span> _sleep((caddr_t)chan, pri, wmsg, abstime, continuation, mtx);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">msleep</span>(
	<span class="enscript-type">void</span>		*chan,
	lck_mtx_t	*mtx,
	<span class="enscript-type">int</span>		pri,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*wmsg,
	<span class="enscript-type">struct</span> timespec		*ts)
{
	u_int64_t	abstime = 0;

	<span class="enscript-keyword">if</span> (ts &amp;&amp; (ts-&gt;tv_sec || ts-&gt;tv_nsec)) {
		nanoseconds_to_absolutetime((uint64_t)ts-&gt;tv_sec * NSEC_PER_SEC + ts-&gt;tv_nsec,  &amp;abstime );
		clock_absolutetime_interval_to_deadline( abstime, &amp;abstime );
	}

	<span class="enscript-keyword">return</span> _sleep((caddr_t)chan, pri, wmsg, abstime, (<span class="enscript-type">int</span> (*)(<span class="enscript-type">int</span>))0, mtx);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">msleep1</span>(
	<span class="enscript-type">void</span>		*chan,
	lck_mtx_t	*mtx,
	<span class="enscript-type">int</span>		pri,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*wmsg,
	u_int64_t	abstime)
{
	<span class="enscript-keyword">return</span> _sleep((caddr_t)chan, pri, wmsg, abstime, (<span class="enscript-type">int</span> (*)(<span class="enscript-type">int</span>))0, mtx);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">tsleep</span>(
	<span class="enscript-type">void</span>		*chan,
	<span class="enscript-type">int</span>		pri,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*wmsg,
	<span class="enscript-type">int</span>		timo)
{
	u_int64_t	abstime = 0;

	<span class="enscript-keyword">if</span> (timo)
		clock_interval_to_deadline(timo, NSEC_PER_SEC / hz, &amp;abstime);
	<span class="enscript-keyword">return</span> _sleep((caddr_t)chan, pri, wmsg, abstime, (<span class="enscript-type">int</span> (*)(<span class="enscript-type">int</span>))0, (lck_mtx_t *)0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">tsleep0</span>(
	<span class="enscript-type">void</span>		*chan,
	<span class="enscript-type">int</span>		pri,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*wmsg,
	<span class="enscript-type">int</span>		timo,
	<span class="enscript-type">int</span>		(*continuation)(<span class="enscript-type">int</span>))
{			
	u_int64_t	abstime = 0;

	<span class="enscript-keyword">if</span> (timo)
		clock_interval_to_deadline(timo, NSEC_PER_SEC / hz, &amp;abstime);
	<span class="enscript-keyword">return</span> _sleep((caddr_t)chan, pri, wmsg, abstime, continuation, (lck_mtx_t *)0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">tsleep1</span>(
	<span class="enscript-type">void</span>		*chan,
	<span class="enscript-type">int</span>		pri,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*wmsg,
	u_int64_t	abstime,
	<span class="enscript-type">int</span>		(*continuation)(<span class="enscript-type">int</span>))
{			
	<span class="enscript-keyword">return</span> _sleep((caddr_t)chan, pri, wmsg, abstime, continuation, (lck_mtx_t *)0);
}

<span class="enscript-comment">/*
 * Wake up all processes sleeping on chan.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">wakeup</span>(<span class="enscript-type">void</span> *chan)
{
	thread_wakeup((caddr_t)chan);
}

<span class="enscript-comment">/*
 * Wake up the first process sleeping on chan.
 *
 * Be very sure that the first process is really
 * the right one to wakeup.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">wakeup_one</span>(caddr_t chan)
{
	thread_wakeup_one((caddr_t)chan);
}

<span class="enscript-comment">/*
 * Compute the priority of a process when running in user mode.
 * Arrange to reschedule if the resulting priority is better
 * than that of the current process.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">resetpriority</span>(<span class="enscript-type">struct</span> proc *p)
{
	(<span class="enscript-type">void</span>)task_importance(p-&gt;task, -p-&gt;p_nice);
}

<span class="enscript-type">struct</span> loadavg averunnable =
	{ {0, 0, 0}, FSCALE };		<span class="enscript-comment">/* load average, of runnable procs */</span>
<span class="enscript-comment">/*
 * Constants for averages over 1, 5, and 15 minutes
 * when sampling at 5 second intervals.
 */</span>
<span class="enscript-type">static</span> fixpt_t cexp[3] = {
    (fixpt_t)(0.9200444146293232 * FSCALE),    <span class="enscript-comment">/* exp(-1/12) */</span>
    (fixpt_t)(0.9834714538216174 * FSCALE),    <span class="enscript-comment">/* exp(-1/60) */</span>
    (fixpt_t)(0.9944598480048967 * FSCALE),    <span class="enscript-comment">/* exp(-1/180) */</span>
};

<span class="enscript-type">void</span>
<span class="enscript-function-name">compute_averunnable</span>(<span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		nrun = *(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)arg;
	<span class="enscript-type">struct</span> loadavg		*avg = &amp;averunnable;
	<span class="enscript-type">int</span>		i;

    <span class="enscript-keyword">for</span> (i = 0; i &lt; 3; i++)
        avg-&gt;ldavg[i] = (cexp[i] * avg-&gt;ldavg[i] +
            nrun * FSCALE * (FSCALE - cexp[i])) &gt;&gt; FSHIFT;
}
</pre>
<hr />
</body></html>