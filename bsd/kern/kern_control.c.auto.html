<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_control.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_control.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1999-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * Kernel Control domain - allows control connections to
 *  and to read/write data.
 *
 * Vincent Lubet, 040506
 * Christophe Allie, 010928
 * Justin C. Walker, 990319
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sys_domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_control.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_var.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>

<span class="enscript-type">struct</span> kctl {
	TAILQ_ENTRY(kctl)	next;		<span class="enscript-comment">/* controller chain */</span>
	kern_ctl_ref		kctlref;

	<span class="enscript-comment">/* controller information provided when registering */</span>
	<span class="enscript-type">char</span>			name[MAX_KCTL_NAME];	<span class="enscript-comment">/* unique identifier */</span>
	u_int32_t		id;
	u_int32_t		reg_unit;

	<span class="enscript-comment">/* misc communication information */</span>
	u_int32_t		flags;		<span class="enscript-comment">/* support flags */</span>
	u_int32_t		recvbufsize;	<span class="enscript-comment">/* request more than the default buffer size */</span>
	u_int32_t		sendbufsize;	<span class="enscript-comment">/* request more than the default buffer size */</span>

	<span class="enscript-comment">/* Dispatch functions */</span>
	ctl_connect_func	connect;	<span class="enscript-comment">/* Make contact */</span>
	ctl_disconnect_func	disconnect;	<span class="enscript-comment">/* Break contact */</span>
	ctl_send_func		send;		<span class="enscript-comment">/* Send data to nke */</span>
	ctl_send_list_func	send_list;	<span class="enscript-comment">/* Send list of packets */</span>
	ctl_setopt_func		setopt;		<span class="enscript-comment">/* set kctl configuration */</span>
	ctl_getopt_func		getopt;		<span class="enscript-comment">/* get kctl configuration */</span>
	ctl_rcvd_func		rcvd;		<span class="enscript-comment">/* Notify nke when client reads data */</span>

	TAILQ_HEAD(, ctl_cb)	kcb_head;
	u_int32_t		lastunit;
};

<span class="enscript-type">struct</span> ctl_cb {
	TAILQ_ENTRY(ctl_cb)	next;		<span class="enscript-comment">/* controller chain */</span>
	lck_mtx_t		*mtx;
	<span class="enscript-type">struct</span> socket		*so;		<span class="enscript-comment">/* controlling socket */</span>
	<span class="enscript-type">struct</span> kctl		*kctl;		<span class="enscript-comment">/* back pointer to controller */</span>
	<span class="enscript-type">void</span>			*userdata;
	u_int32_t		unit;
	u_int32_t		usecount;
};

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">ROUNDUP64</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ROUNDUP64</span>(x) P2ROUNDUP((x), sizeof (u_int64_t))
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">ADVANCE64</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">ADVANCE64</span>(p, n) (void*)((char *)(p) + ROUNDUP64(n))
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Definitions and vars for we support
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CTL_SENDSIZE</span>	(2 * 1024)	<span class="enscript-comment">/* default buffer size */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">CTL_RECVSIZE</span> 	(8 * 1024)	<span class="enscript-comment">/* default buffer size */</span>

<span class="enscript-comment">/*
 * Definitions and vars for we support
 */</span>

<span class="enscript-type">static</span> u_int32_t	ctl_maxunit = 65536;
<span class="enscript-type">static</span> lck_grp_attr_t	*ctl_lck_grp_attr = 0;
<span class="enscript-type">static</span> lck_attr_t	*ctl_lck_attr = 0;
<span class="enscript-type">static</span> lck_grp_t	*ctl_lck_grp = 0;
<span class="enscript-type">static</span> lck_mtx_t 	*ctl_mtx;

<span class="enscript-comment">/* all the controllers are chained */</span>
<span class="enscript-function-name">TAILQ_HEAD</span>(kctl_list, kctl) 	ctl_head;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ctl_attach</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ctl_detach</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ctl_sofreelastref</span>(<span class="enscript-type">struct</span> socket *so);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ctl_connect</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ctl_disconnect</span>(<span class="enscript-type">struct</span> socket *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ctl_ioctl</span>(<span class="enscript-type">struct</span> socket *so, u_long cmd, caddr_t data,
			<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ctl_send</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> mbuf *,
	    <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ctl_send_list</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> mbuf *,
	    <span class="enscript-type">struct</span> sockaddr *, <span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">struct</span> proc *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ctl_ctloutput</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> sockopt *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ctl_peeraddr</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **nam);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ctl_usr_rcvd</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> kctl *<span class="enscript-function-name">ctl_find_by_name</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> kctl *<span class="enscript-function-name">ctl_find_by_id_unit</span>(u_int32_t id, u_int32_t unit);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> socket *<span class="enscript-function-name">kcb_find_socket</span>(kern_ctl_ref kctlref, u_int32_t unit,
	u_int32_t *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ctl_cb *<span class="enscript-function-name">kcb_find</span>(<span class="enscript-type">struct</span> kctl *, u_int32_t unit);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ctl_post_msg</span>(u_int32_t event_code, u_int32_t id);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ctl_lock</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ctl_unlock</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> lck_mtx_t * <span class="enscript-function-name">ctl_getlock</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pr_usrreqs ctl_usrreqs = {
	.pru_attach =		ctl_attach,
	.pru_connect =		ctl_connect,
	.pru_control =		ctl_ioctl,
	.pru_detach =		ctl_detach,
	.pru_disconnect =	ctl_disconnect,
	.pru_peeraddr =		ctl_peeraddr,
	.pru_rcvd =		ctl_usr_rcvd,
	.pru_send =		ctl_send,
	.pru_send_list =	ctl_send_list,
	.pru_sosend =		sosend,
	.pru_sosend_list =	sosend_list,
	.pru_soreceive =	soreceive,
	.pru_soreceive_list =	soreceive_list,
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> protosw kctlsw[] = {
{
	.pr_type =	SOCK_DGRAM,
	.pr_protocol =	SYSPROTO_CONTROL,
	.pr_flags =	PR_ATOMIC|PR_CONNREQUIRED|PR_PCBLOCK|PR_WANTRCVD,
	.pr_ctloutput =	ctl_ctloutput,
	.pr_usrreqs =	&amp;ctl_usrreqs,
	.pr_lock =	ctl_lock,
	.pr_unlock =	ctl_unlock,
	.pr_getlock =	ctl_getlock,
},
{
	.pr_type =	SOCK_STREAM,
	.pr_protocol =	SYSPROTO_CONTROL,
	.pr_flags =	PR_CONNREQUIRED|PR_PCBLOCK|PR_WANTRCVD,
	.pr_ctloutput =	ctl_ctloutput,
	.pr_usrreqs =	&amp;ctl_usrreqs,
	.pr_lock =	ctl_lock,
	.pr_unlock =	ctl_unlock,
	.pr_getlock =	ctl_getlock,
}
};

__private_extern__ <span class="enscript-type">int</span> kctl_reg_list SYSCTL_HANDLER_ARGS;
__private_extern__ <span class="enscript-type">int</span> kctl_pcblist SYSCTL_HANDLER_ARGS;
__private_extern__ <span class="enscript-type">int</span> kctl_getstat SYSCTL_HANDLER_ARGS;


<span class="enscript-function-name">SYSCTL_NODE</span>(_net_systm, OID_AUTO, kctl,
	CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;Kernel control family&quot;</span>);

<span class="enscript-type">struct</span> kctlstat kctlstat;
<span class="enscript-function-name">SYSCTL_PROC</span>(_net_systm_kctl, OID_AUTO, stats,
    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0,
    kctl_getstat, <span class="enscript-string">&quot;S,kctlstat&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_systm_kctl, OID_AUTO, reg_list,
	CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0,
	kctl_reg_list, <span class="enscript-string">&quot;S,xkctl_reg&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_net_systm_kctl, OID_AUTO, pcblist,
	CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0,
	kctl_pcblist, <span class="enscript-string">&quot;S,xkctlpcb&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

u_int32_t ctl_autorcvbuf_max = 256 * 1024;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_systm_kctl, OID_AUTO, autorcvbufmax,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ctl_autorcvbuf_max, 0, <span class="enscript-string">&quot;&quot;</span>);

u_int32_t ctl_autorcvbuf_high = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_systm_kctl, OID_AUTO, autorcvbufhigh,
	CTLFLAG_RD | CTLFLAG_LOCKED, &amp;ctl_autorcvbuf_high, 0, <span class="enscript-string">&quot;&quot;</span>);

u_int32_t ctl_debug = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_net_systm_kctl, OID_AUTO, debug,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ctl_debug, 0, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KCTL_TBL_INC</span> 16

<span class="enscript-type">static</span> uintptr_t kctl_tbl_size = 0;
<span class="enscript-type">static</span> u_int32_t kctl_tbl_growing = 0;
<span class="enscript-type">static</span> uintptr_t kctl_tbl_count = 0;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> kctl **kctl_table = NULL;
<span class="enscript-type">static</span> uintptr_t kctl_ref_gencnt = 0;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kctl_tbl_grow</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> kern_ctl_ref <span class="enscript-function-name">kctl_make_ref</span>(<span class="enscript-type">struct</span> kctl *kctl);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kctl_delete_ref</span>(kern_ctl_ref);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> kctl *<span class="enscript-function-name">kctl_from_ref</span>(kern_ctl_ref);

<span class="enscript-comment">/*
 * Install the protosw's for the Kernel Control manager.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">kern_control_init</span>(<span class="enscript-type">struct</span> domain *dp)
{
	<span class="enscript-type">struct</span> protosw *pr;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> kctl_proto_count = (<span class="enscript-keyword">sizeof</span> (kctlsw) / <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> protosw));

	VERIFY(!(dp-&gt;dom_flags &amp; DOM_INITIALIZED));
	VERIFY(dp == systemdomain);

	ctl_lck_grp_attr = lck_grp_attr_alloc_init();
	<span class="enscript-keyword">if</span> (ctl_lck_grp_attr == NULL) {
		panic(<span class="enscript-string">&quot;%s: lck_grp_attr_alloc_init failed\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	ctl_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;Kernel Control Protocol&quot;</span>,
	    ctl_lck_grp_attr);
	<span class="enscript-keyword">if</span> (ctl_lck_grp == NULL) {
		panic(<span class="enscript-string">&quot;%s: lck_grp_alloc_init failed\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	ctl_lck_attr = lck_attr_alloc_init();
	<span class="enscript-keyword">if</span> (ctl_lck_attr == NULL) {
		panic(<span class="enscript-string">&quot;%s: lck_attr_alloc_init failed\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	ctl_mtx = lck_mtx_alloc_init(ctl_lck_grp, ctl_lck_attr);
	<span class="enscript-keyword">if</span> (ctl_mtx == NULL) {
		panic(<span class="enscript-string">&quot;%s: lck_mtx_alloc_init failed\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	TAILQ_INIT(&amp;ctl_head);

	<span class="enscript-keyword">for</span> (i = 0, pr = &amp;kctlsw[0]; i &lt; kctl_proto_count; i++, pr++)
		net_add_proto(pr, dp, 1);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kcb_delete</span>(<span class="enscript-type">struct</span> ctl_cb *kcb)
{
	<span class="enscript-keyword">if</span> (kcb != 0) {
		<span class="enscript-keyword">if</span> (kcb-&gt;mtx != 0)
			lck_mtx_free(kcb-&gt;mtx, ctl_lck_grp);
		FREE(kcb, M_TEMP);
	}
}

<span class="enscript-comment">/*
 * Kernel Controller user-request functions
 * attach function must exist and succeed
 * detach not necessary
 * we need a pcb for the per socket mutex
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ctl_attach</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> proto, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">proto</span>, <span class="enscript-variable-name">p</span>)
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> ctl_cb			*kcb = 0;

	MALLOC(kcb, <span class="enscript-type">struct</span> ctl_cb *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ctl_cb), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (kcb == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">quit</span>;
	}
	bzero(kcb, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ctl_cb));

	kcb-&gt;mtx = lck_mtx_alloc_init(ctl_lck_grp, ctl_lck_attr);
	<span class="enscript-keyword">if</span> (kcb-&gt;mtx == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">quit</span>;
	}
	kcb-&gt;so = so;
	so-&gt;so_pcb = (caddr_t)kcb;

<span class="enscript-reference">quit</span>:
	<span class="enscript-keyword">if</span> (error != 0) {
		kcb_delete(kcb);
		kcb = 0;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ctl_sofreelastref</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> ctl_cb 	*kcb = (<span class="enscript-type">struct</span> ctl_cb *)so-&gt;so_pcb;

	so-&gt;so_pcb = 0;

	<span class="enscript-keyword">if</span> (kcb != 0) {
		<span class="enscript-type">struct</span> kctl		*kctl;
		<span class="enscript-keyword">if</span> ((kctl = kcb-&gt;kctl) != 0) {
			lck_mtx_lock(ctl_mtx);
			TAILQ_REMOVE(&amp;kctl-&gt;kcb_head, kcb, next);
			kctlstat.kcs_pcbcount--;
			kctlstat.kcs_gencnt++;
			lck_mtx_unlock(ctl_mtx);
		}
		kcb_delete(kcb);
	}
	sofreelastref(so, 1);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ctl_detach</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> ctl_cb 	*kcb = (<span class="enscript-type">struct</span> ctl_cb *)so-&gt;so_pcb;

	<span class="enscript-keyword">if</span> (kcb == 0)
		<span class="enscript-keyword">return</span> (0);

	soisdisconnected(so);
	so-&gt;so_flags |= SOF_PCBCLEARING;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ctl_connect</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
	<span class="enscript-type">struct</span> kctl		*kctl;
	<span class="enscript-type">int</span>			error = 0;
	<span class="enscript-type">struct</span> sockaddr_ctl	sa;
	<span class="enscript-type">struct</span> ctl_cb		*kcb = (<span class="enscript-type">struct</span> ctl_cb *)so-&gt;so_pcb;
	<span class="enscript-type">struct</span> ctl_cb		*kcb_next = NULL;
	u_quad_t		sbmaxsize;
	u_int32_t		recvbufsize, sendbufsize;

	<span class="enscript-keyword">if</span> (kcb == 0)
		panic(<span class="enscript-string">&quot;ctl_connect so_pcb null\n&quot;</span>);

	<span class="enscript-keyword">if</span> (nam-&gt;sa_len !=  <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_ctl))
		<span class="enscript-keyword">return</span> (EINVAL);

	bcopy(nam, &amp;sa, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_ctl));

	lck_mtx_lock(ctl_mtx);
	kctl = ctl_find_by_id_unit(sa.sc_id, sa.sc_unit);
	<span class="enscript-keyword">if</span> (kctl == NULL) {
		lck_mtx_unlock(ctl_mtx);
		<span class="enscript-keyword">return</span> (ENOENT);
	}

	<span class="enscript-keyword">if</span> (((kctl-&gt;flags &amp; CTL_FLAG_REG_SOCK_STREAM) &amp;&amp;
			(so-&gt;so_type != SOCK_STREAM)) ||
		(!(kctl-&gt;flags &amp; CTL_FLAG_REG_SOCK_STREAM) &amp;&amp;
			(so-&gt;so_type != SOCK_DGRAM))) {
		lck_mtx_unlock(ctl_mtx);
		<span class="enscript-keyword">return</span> (EPROTOTYPE);
	}

	<span class="enscript-keyword">if</span> (kctl-&gt;flags &amp; CTL_FLAG_PRIVILEGED) {
		<span class="enscript-keyword">if</span> (p == 0) {
			lck_mtx_unlock(ctl_mtx);
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		<span class="enscript-keyword">if</span> (kauth_cred_issuser(kauth_cred_get()) == 0) {
			lck_mtx_unlock(ctl_mtx);
			<span class="enscript-keyword">return</span> (EPERM);
		}
	}

	<span class="enscript-keyword">if</span> ((kctl-&gt;flags &amp; CTL_FLAG_REG_ID_UNIT) || sa.sc_unit != 0) {
		<span class="enscript-keyword">if</span> (kcb_find(kctl, sa.sc_unit) != NULL) {
			lck_mtx_unlock(ctl_mtx);
			<span class="enscript-keyword">return</span> (EBUSY);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Find an unused ID, assumes control IDs are in order */</span>
		u_int32_t	unit = 1;

		TAILQ_FOREACH(kcb_next, &amp;kctl-&gt;kcb_head, next) {
			<span class="enscript-keyword">if</span> (kcb_next-&gt;unit &gt; unit) {
				<span class="enscript-comment">/* Found a gap, lets fill it in */</span>
				<span class="enscript-keyword">break</span>;
			}
			unit = kcb_next-&gt;unit + 1;
			<span class="enscript-keyword">if</span> (unit == ctl_maxunit)
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (unit == ctl_maxunit) {
			lck_mtx_unlock(ctl_mtx);
			<span class="enscript-keyword">return</span> (EBUSY);
		}

		sa.sc_unit = unit;
	}

	kcb-&gt;unit = sa.sc_unit;
	kcb-&gt;kctl = kctl;
	<span class="enscript-keyword">if</span> (kcb_next != NULL) {
		TAILQ_INSERT_BEFORE(kcb_next, kcb, next);
	} <span class="enscript-keyword">else</span> {
		TAILQ_INSERT_TAIL(&amp;kctl-&gt;kcb_head, kcb, next);
	}
	kctlstat.kcs_pcbcount++;
	kctlstat.kcs_gencnt++;
	kctlstat.kcs_connections++;
	lck_mtx_unlock(ctl_mtx);

	<span class="enscript-comment">/*
	 * rdar://15526688: Limit the send and receive sizes to sb_max
	 * by using the same scaling as sbreserve()
	 */</span>
	sbmaxsize = (u_quad_t)sb_max * MCLBYTES / (MSIZE + MCLBYTES);

	<span class="enscript-keyword">if</span> (kctl-&gt;sendbufsize &gt; sbmaxsize)
		sendbufsize = sbmaxsize;
	<span class="enscript-keyword">else</span>
		sendbufsize = kctl-&gt;sendbufsize;

	<span class="enscript-keyword">if</span> (kctl-&gt;recvbufsize &gt; sbmaxsize)
		recvbufsize = sbmaxsize;
	<span class="enscript-keyword">else</span>
		recvbufsize = kctl-&gt;recvbufsize;

	error = soreserve(so, sendbufsize, recvbufsize);
	<span class="enscript-keyword">if</span> (error) {
		printf(<span class="enscript-string">&quot;%s - soreserve(%llx, %u, %u) error %d\n&quot;</span>, __func__,
			(uint64_t)VM_KERNEL_ADDRPERM(so),
			sendbufsize, recvbufsize, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	soisconnecting(so);

	socket_unlock(so, 0);
	error = (*kctl-&gt;connect)(kctl-&gt;kctlref, &amp;sa, &amp;kcb-&gt;userdata);
	socket_lock(so, 0);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">end</span>;

	soisconnected(so);

<span class="enscript-reference">end</span>:
	<span class="enscript-keyword">if</span> (error &amp;&amp; kctl-&gt;disconnect) {
		socket_unlock(so, 0);
		(*kctl-&gt;disconnect)(kctl-&gt;kctlref, kcb-&gt;unit, kcb-&gt;userdata);
		socket_lock(so, 0);
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (error) {
		soisdisconnected(so);
		lck_mtx_lock(ctl_mtx);
		kcb-&gt;kctl = 0;
		kcb-&gt;unit = 0;
		TAILQ_REMOVE(&amp;kctl-&gt;kcb_head, kcb, next);
		kctlstat.kcs_pcbcount--;
		kctlstat.kcs_gencnt++;
		kctlstat.kcs_conn_fail++;
		lck_mtx_unlock(ctl_mtx);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ctl_disconnect</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> ctl_cb 	*kcb = (<span class="enscript-type">struct</span> ctl_cb *)so-&gt;so_pcb;

	<span class="enscript-keyword">if</span> ((kcb = (<span class="enscript-type">struct</span> ctl_cb *)so-&gt;so_pcb)) {
		<span class="enscript-type">struct</span> kctl		*kctl = kcb-&gt;kctl;

		<span class="enscript-keyword">if</span> (kctl &amp;&amp; kctl-&gt;disconnect) {
			socket_unlock(so, 0);
			(*kctl-&gt;disconnect)(kctl-&gt;kctlref, kcb-&gt;unit,
			    kcb-&gt;userdata);
			socket_lock(so, 0);
		}

		soisdisconnected(so);

		socket_unlock(so, 0);
		lck_mtx_lock(ctl_mtx);
		kcb-&gt;kctl = 0;
		kcb-&gt;unit = 0;
		<span class="enscript-keyword">while</span> (kcb-&gt;usecount != 0) {
			msleep(&amp;kcb-&gt;usecount, ctl_mtx, 0, <span class="enscript-string">&quot;kcb-&gt;usecount&quot;</span>, 0);
		}
		TAILQ_REMOVE(&amp;kctl-&gt;kcb_head, kcb, next);
		kctlstat.kcs_pcbcount--;
		kctlstat.kcs_gencnt++;
		lck_mtx_unlock(ctl_mtx);
		socket_lock(so, 0);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ctl_peeraddr</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **nam)
{
	<span class="enscript-type">struct</span> ctl_cb 		*kcb = (<span class="enscript-type">struct</span> ctl_cb *)so-&gt;so_pcb;
	<span class="enscript-type">struct</span> kctl			*kctl;
	<span class="enscript-type">struct</span> sockaddr_ctl	sc;

	<span class="enscript-keyword">if</span> (kcb == NULL)	<span class="enscript-comment">/* sanity check */</span>
		<span class="enscript-keyword">return</span> (ENOTCONN);

	<span class="enscript-keyword">if</span> ((kctl = kcb-&gt;kctl) == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	bzero(&amp;sc, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_ctl));
	sc.sc_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_ctl);
	sc.sc_family = AF_SYSTEM;
	sc.ss_sysaddr = AF_SYS_CONTROL;
	sc.sc_id =  kctl-&gt;id;
	sc.sc_unit = kcb-&gt;unit;

	*nam = dup_sockaddr((<span class="enscript-type">struct</span> sockaddr *)&amp;sc, 1);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ctl_sbrcv_trim</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> sockbuf *sb = &amp;so-&gt;so_rcv;

	<span class="enscript-keyword">if</span> (sb-&gt;sb_hiwat &gt; sb-&gt;sb_idealsize) {
		u_int32_t diff;
		int32_t trim;

		<span class="enscript-comment">/*
		 * The difference between the ideal size and the
		 * current size is the upper bound of the trimage
		 */</span>
		diff = sb-&gt;sb_hiwat - sb-&gt;sb_idealsize;
		<span class="enscript-comment">/*
		 * We cannot trim below the outstanding data
		 */</span>
		trim = sb-&gt;sb_hiwat - sb-&gt;sb_cc;

		trim = imin(trim, (int32_t)diff);

		<span class="enscript-keyword">if</span> (trim &gt; 0) {
			sbreserve(sb, (sb-&gt;sb_hiwat - trim));

			<span class="enscript-keyword">if</span> (ctl_debug)
				printf(<span class="enscript-string">&quot;%s - shrunk to %d\n&quot;</span>,
				    __func__, sb-&gt;sb_hiwat);
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ctl_usr_rcvd</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> ctl_cb		*kcb = (<span class="enscript-type">struct</span> ctl_cb *)so-&gt;so_pcb;
	<span class="enscript-type">struct</span> kctl			*kctl;

	<span class="enscript-keyword">if</span> ((kctl = kcb-&gt;kctl) == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (kctl-&gt;rcvd) {
		socket_unlock(so, 0);
		(*kctl-&gt;rcvd)(kctl-&gt;kctlref, kcb-&gt;unit, kcb-&gt;userdata, flags);
		socket_lock(so, 0);
	}

	ctl_sbrcv_trim(so);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ctl_send</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> mbuf *m,
	<span class="enscript-type">struct</span> sockaddr *addr, <span class="enscript-type">struct</span> mbuf *control,
	<span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">addr</span>, <span class="enscript-variable-name">p</span>)
	<span class="enscript-type">int</span>		error = 0;
	<span class="enscript-type">struct</span> ctl_cb 	*kcb = (<span class="enscript-type">struct</span> ctl_cb *)so-&gt;so_pcb;
	<span class="enscript-type">struct</span> kctl	*kctl;

	<span class="enscript-keyword">if</span> (control)
		m_freem(control);

	<span class="enscript-keyword">if</span> (kcb == NULL)	<span class="enscript-comment">/* sanity check */</span>
		error = ENOTCONN;

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; (kctl = kcb-&gt;kctl) == NULL)
		error = EINVAL;

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; kctl-&gt;send) {
		so_tc_update_stats(m, so, m_get_service_class(m));
		socket_unlock(so, 0);
		error = (*kctl-&gt;send)(kctl-&gt;kctlref, kcb-&gt;unit, kcb-&gt;userdata,
		    m, flags);
		socket_lock(so, 0);
	} <span class="enscript-keyword">else</span> {
		m_freem(m);
		<span class="enscript-keyword">if</span> (error == 0)
			error = ENOTSUP;
	}
	<span class="enscript-keyword">if</span> (error != 0)
		OSIncrementAtomic64((SInt64 *)&amp;kctlstat.kcs_send_fail);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ctl_send_list</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> mbuf *m,
	    __unused <span class="enscript-type">struct</span> sockaddr *addr, <span class="enscript-type">struct</span> mbuf *control,
	    __unused <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span>		error = 0;
	<span class="enscript-type">struct</span> ctl_cb 	*kcb = (<span class="enscript-type">struct</span> ctl_cb *)so-&gt;so_pcb;
	<span class="enscript-type">struct</span> kctl	*kctl;

	<span class="enscript-keyword">if</span> (control)
		m_freem_list(control);

	<span class="enscript-keyword">if</span> (kcb == NULL)	<span class="enscript-comment">/* sanity check */</span>
		error = ENOTCONN;

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; (kctl = kcb-&gt;kctl) == NULL)
		error = EINVAL;

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; kctl-&gt;send_list) {
		<span class="enscript-type">struct</span> mbuf *nxt;

		<span class="enscript-keyword">for</span> (nxt = m; nxt != NULL; nxt = nxt-&gt;m_nextpkt)
			so_tc_update_stats(nxt, so, m_get_service_class(nxt));

		socket_unlock(so, 0);
		error = (*kctl-&gt;send_list)(kctl-&gt;kctlref, kcb-&gt;unit,
		    kcb-&gt;userdata, m, flags);
		socket_lock(so, 0);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == 0 &amp;&amp; kctl-&gt;send) {
		<span class="enscript-keyword">while</span> (m != NULL &amp;&amp; error == 0) {
			<span class="enscript-type">struct</span> mbuf *nextpkt = m-&gt;m_nextpkt;

			m-&gt;m_nextpkt = NULL;
			so_tc_update_stats(m, so, m_get_service_class(m));
			socket_unlock(so, 0);
			error = (*kctl-&gt;send)(kctl-&gt;kctlref, kcb-&gt;unit,
			    kcb-&gt;userdata, m, flags);
			socket_lock(so, 0);
			m = nextpkt;
		}
		<span class="enscript-keyword">if</span> (m != NULL)
			m_freem_list(m);
	} <span class="enscript-keyword">else</span> {
		m_freem_list(m);
		<span class="enscript-keyword">if</span> (error == 0)
			error = ENOTSUP;
	}
	<span class="enscript-keyword">if</span> (error != 0)
		OSIncrementAtomic64((SInt64 *)&amp;kctlstat.kcs_send_list_fail);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">ctl_rcvbspace</span>(<span class="enscript-type">struct</span> socket *so, u_int32_t datasize,
	u_int32_t kctlflags, u_int32_t flags)
{
	<span class="enscript-type">struct</span> sockbuf *sb = &amp;so-&gt;so_rcv;
	u_int32_t space = sbspace(sb);
	errno_t error;

	<span class="enscript-keyword">if</span> ((kctlflags &amp; CTL_FLAG_REG_CRIT) == 0) {
		<span class="enscript-keyword">if</span> ((u_int32_t) space &gt;= datasize)
			error = 0;
		<span class="enscript-keyword">else</span>
			error = ENOBUFS;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((flags &amp; CTL_DATA_CRIT) == 0) {
		<span class="enscript-comment">/*
		 * Reserve 25% for critical messages
		 */</span>
		<span class="enscript-keyword">if</span> (space &lt; (sb-&gt;sb_hiwat &gt;&gt; 2) ||
		    space  &lt; datasize)
			error = ENOBUFS;
		<span class="enscript-keyword">else</span>
			error = 0;
	} <span class="enscript-keyword">else</span> {
		u_int32_t autorcvbuf_max;

		<span class="enscript-comment">/*
		 * Allow overcommit of 25%
		 */</span>
		autorcvbuf_max = min(sb-&gt;sb_idealsize + (sb-&gt;sb_idealsize &gt;&gt; 2),
			ctl_autorcvbuf_max);

		<span class="enscript-keyword">if</span> ((u_int32_t) space &gt;= datasize) {
			error = 0;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (tcp_cansbgrow(sb) &amp;&amp;
		    sb-&gt;sb_hiwat &lt; autorcvbuf_max) {
			<span class="enscript-comment">/*
			 * Grow with a little bit of leeway
			 */</span>
			u_int32_t grow = datasize - space + MSIZE;

			<span class="enscript-keyword">if</span> (sbreserve(sb,
			    min((sb-&gt;sb_hiwat + grow), autorcvbuf_max)) == 1) {

				<span class="enscript-keyword">if</span> (sb-&gt;sb_hiwat &gt; ctl_autorcvbuf_high)
					ctl_autorcvbuf_high = sb-&gt;sb_hiwat;

				<span class="enscript-comment">/*
				 * A final check
				 */</span>
				<span class="enscript-keyword">if</span> ((u_int32_t) sbspace(sb) &gt;= datasize) {
					error = 0;
				} <span class="enscript-keyword">else</span> {
					error = ENOBUFS;
				}

				<span class="enscript-keyword">if</span> (ctl_debug)
					printf(<span class="enscript-string">&quot;%s - grown to %d error %d\n&quot;</span>,
					    __func__, sb-&gt;sb_hiwat, error);
			} <span class="enscript-keyword">else</span> {
				error = ENOBUFS;
			}
		} <span class="enscript-keyword">else</span> {
			error = ENOBUFS;
		}
	}
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">ctl_enqueuembuf</span>(kern_ctl_ref kctlref, u_int32_t unit, <span class="enscript-type">struct</span> mbuf *m,
    u_int32_t flags)
{
	<span class="enscript-type">struct</span> socket 	*so;
	errno_t 	error = 0;
	<span class="enscript-type">int</span>		len = m-&gt;m_pkthdr.len;
	u_int32_t	kctlflags;

	so = kcb_find_socket(kctlref, unit, &amp;kctlflags);
	<span class="enscript-keyword">if</span> (so == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (ctl_rcvbspace(so, len, kctlflags, flags) != 0) {
		error = ENOBUFS;
		OSIncrementAtomic64((SInt64 *)&amp;kctlstat.kcs_enqueue_fullsock);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bye</span>;
	}
	<span class="enscript-keyword">if</span> ((flags &amp; CTL_DATA_EOR))
		m-&gt;m_flags |= M_EOR;

	so_recv_data_stat(so, m, 0);
	<span class="enscript-keyword">if</span> (sbappend(&amp;so-&gt;so_rcv, m) != 0) {
		<span class="enscript-keyword">if</span> ((flags &amp; CTL_DATA_NOWAKEUP) == 0)
			sorwakeup(so);
	} <span class="enscript-keyword">else</span> {
		error = ENOBUFS;
		OSIncrementAtomic64((SInt64 *)&amp;kctlstat.kcs_enqueue_fullsock);
	}
<span class="enscript-reference">bye</span>:
	<span class="enscript-keyword">if</span> (ctl_debug &amp;&amp; error != 0 &amp;&amp; (flags &amp; CTL_DATA_CRIT))
		printf(<span class="enscript-string">&quot;%s - crit data err %d len %d hiwat %d cc: %d\n&quot;</span>,
			__func__, error, len,
			so-&gt;so_rcv.sb_hiwat, so-&gt;so_rcv.sb_cc);

	socket_unlock(so, 1);
	<span class="enscript-keyword">if</span> (error != 0)
		OSIncrementAtomic64((SInt64 *)&amp;kctlstat.kcs_enqueue_fail);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Compute space occupied by mbuf like sbappendrecord
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">m_space</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">int</span> space = 0;
	<span class="enscript-type">struct</span> mbuf *nxt;

	<span class="enscript-keyword">for</span> (nxt = m; nxt != NULL; nxt = nxt-&gt;m_next)
		space += nxt-&gt;m_len;

	<span class="enscript-keyword">return</span> (space);
}

errno_t
<span class="enscript-function-name">ctl_enqueuembuf_list</span>(<span class="enscript-type">void</span> *kctlref, u_int32_t unit, <span class="enscript-type">struct</span> mbuf *m_list,
	u_int32_t flags, <span class="enscript-type">struct</span> mbuf **m_remain)
{
	<span class="enscript-type">struct</span> socket *so = NULL;
	errno_t error = 0;
	<span class="enscript-type">struct</span> mbuf *m, *nextpkt;
	<span class="enscript-type">int</span> needwakeup = 0;
	<span class="enscript-type">int</span> len;
	u_int32_t kctlflags;

	<span class="enscript-comment">/*
	 * Need to point the beginning of the list in case of early exit
	 */</span>
	m = m_list;

	<span class="enscript-comment">/*
	 * kcb_find_socket takes the socket lock with a reference
	 */</span>
	so = kcb_find_socket(kctlref, unit, &amp;kctlflags);
	<span class="enscript-keyword">if</span> (so == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (kctlflags &amp; CTL_FLAG_REG_SOCK_STREAM) {
		error = EOPNOTSUPP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (flags &amp; CTL_DATA_EOR) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">for</span> (m = m_list; m != NULL; m = nextpkt) {
		nextpkt = m-&gt;m_nextpkt;

		<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len == 0)
			printf(<span class="enscript-string">&quot;%s: %llx m_pkthdr.len is 0&quot;</span>,
				__func__, (uint64_t)VM_KERNEL_ADDRPERM(m));

		<span class="enscript-comment">/*
		 * The mbuf is either appended or freed by sbappendrecord()
		 * so it's not reliable from a data standpoint
		 */</span>
		len = m_space(m);
		<span class="enscript-keyword">if</span> (ctl_rcvbspace(so, len, kctlflags, flags) != 0) {
			error = ENOBUFS;
			OSIncrementAtomic64(
			    (SInt64 *)&amp;kctlstat.kcs_enqueue_fullsock);
			<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Unlink from the list, m is on its own
			 */</span>
			m-&gt;m_nextpkt = NULL;
			so_recv_data_stat(so, m, 0);
			<span class="enscript-keyword">if</span> (sbappendrecord(&amp;so-&gt;so_rcv, m) != 0) {
				needwakeup = 1;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * We free or return the remaining
				 * mbufs in the list
				 */</span>
				m = nextpkt;
				error = ENOBUFS;
				OSIncrementAtomic64(
				    (SInt64 *)&amp;kctlstat.kcs_enqueue_fullsock);
				<span class="enscript-keyword">break</span>;
			}
		}
	}
	<span class="enscript-keyword">if</span> (needwakeup &amp;&amp; (flags &amp; CTL_DATA_NOWAKEUP) == 0)
		sorwakeup(so);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (so != NULL) {
		<span class="enscript-keyword">if</span> (ctl_debug &amp;&amp; error != 0 &amp;&amp; (flags &amp; CTL_DATA_CRIT))
			printf(<span class="enscript-string">&quot;%s - crit data err %d len %d hiwat %d cc: %d\n&quot;</span>,
				__func__, error, len,
				so-&gt;so_rcv.sb_hiwat, so-&gt;so_rcv.sb_cc);

		socket_unlock(so, 1);
	}
	<span class="enscript-keyword">if</span> (m_remain) {
		*m_remain = m;

		<span class="enscript-keyword">if</span> (m != NULL &amp;&amp; socket_debug &amp;&amp; so != NULL &amp;&amp;
		    (so-&gt;so_options &amp; SO_DEBUG)) {
			<span class="enscript-type">struct</span> mbuf *n;

			printf(<span class="enscript-string">&quot;%s m_list %llx\n&quot;</span>, __func__,
			    (uint64_t) VM_KERNEL_ADDRPERM(m_list));
			<span class="enscript-keyword">for</span> (n = m; n != NULL; n = n-&gt;m_nextpkt)
				printf(<span class="enscript-string">&quot; remain %llx m_next %llx\n&quot;</span>,
				    (uint64_t) VM_KERNEL_ADDRPERM(n),
				    (uint64_t) VM_KERNEL_ADDRPERM(n-&gt;m_next));
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (m != NULL)
			m_freem_list(m);
	}
	<span class="enscript-keyword">if</span> (error != 0)
		OSIncrementAtomic64((SInt64 *)&amp;kctlstat.kcs_enqueue_fail);
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">ctl_enqueuedata</span>(<span class="enscript-type">void</span> *kctlref, u_int32_t unit, <span class="enscript-type">void</span> *data, size_t len,
    u_int32_t flags)
{
	<span class="enscript-type">struct</span> socket 	*so;
	<span class="enscript-type">struct</span> mbuf 	*m;
	errno_t		error = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> 	num_needed;
	<span class="enscript-type">struct</span> mbuf 	*n;
	size_t		curlen = 0;
	u_int32_t	kctlflags;

	so = kcb_find_socket(kctlref, unit, &amp;kctlflags);
	<span class="enscript-keyword">if</span> (so == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (ctl_rcvbspace(so, len, kctlflags, flags) != 0) {
		error = ENOBUFS;
		OSIncrementAtomic64((SInt64 *)&amp;kctlstat.kcs_enqueue_fullsock);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bye</span>;
	}

	num_needed = 1;
	m = m_allocpacket_internal(&amp;num_needed, len, NULL, M_NOWAIT, 1, 0);
	<span class="enscript-keyword">if</span> (m == NULL) {
		printf(<span class="enscript-string">&quot;ctl_enqueuedata: m_allocpacket_internal(%lu) failed\n&quot;</span>,
			len);
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bye</span>;
	}

	<span class="enscript-keyword">for</span> (n = m; n != NULL; n = n-&gt;m_next) {
		size_t mlen = mbuf_maxlen(n);

		<span class="enscript-keyword">if</span> (mlen + curlen &gt; len)
			mlen = len - curlen;
		n-&gt;m_len = mlen;
		bcopy((<span class="enscript-type">char</span> *)data + curlen, n-&gt;m_data, mlen);
		curlen += mlen;
	}
	mbuf_pkthdr_setlen(m, curlen);

	<span class="enscript-keyword">if</span> ((flags &amp; CTL_DATA_EOR))
		m-&gt;m_flags |= M_EOR;
	so_recv_data_stat(so, m, 0);
	<span class="enscript-keyword">if</span> (sbappend(&amp;so-&gt;so_rcv, m) != 0) {
		<span class="enscript-keyword">if</span> ((flags &amp; CTL_DATA_NOWAKEUP) == 0)
			sorwakeup(so);
	} <span class="enscript-keyword">else</span> {
		error = ENOBUFS;
		OSIncrementAtomic64((SInt64 *)&amp;kctlstat.kcs_enqueue_fullsock);
	}

<span class="enscript-reference">bye</span>:
	<span class="enscript-keyword">if</span> (ctl_debug &amp;&amp; error != 0 &amp;&amp; (flags &amp; CTL_DATA_CRIT))
		printf(<span class="enscript-string">&quot;%s - crit data err %d len %d hiwat %d cc: %d\n&quot;</span>,
			__func__, error, (<span class="enscript-type">int</span>)len,
			so-&gt;so_rcv.sb_hiwat, so-&gt;so_rcv.sb_cc);

	socket_unlock(so, 1);
	<span class="enscript-keyword">if</span> (error != 0)
		OSIncrementAtomic64((SInt64 *)&amp;kctlstat.kcs_enqueue_fail);
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">ctl_getenqueuepacketcount</span>(kern_ctl_ref kctlref, u_int32_t unit, u_int32_t *pcnt)
{
	<span class="enscript-type">struct</span> socket 	*so;
	u_int32_t cnt;
	<span class="enscript-type">struct</span> mbuf *m1;

	<span class="enscript-keyword">if</span> (pcnt == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	so = kcb_find_socket(kctlref, unit, NULL);
	<span class="enscript-keyword">if</span> (so == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	cnt = 0;
	m1 = so-&gt;so_rcv.sb_mb;
	<span class="enscript-keyword">while</span> (m1 != NULL) {
		<span class="enscript-keyword">if</span> (m1-&gt;m_type == MT_DATA ||
		    m1-&gt;m_type == MT_HEADER ||
		    m1-&gt;m_type == MT_OOBDATA)
			cnt += 1;
		m1 = m1-&gt;m_nextpkt;
	}
	*pcnt = cnt;

	socket_unlock(so, 1);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ctl_getenqueuespace</span>(kern_ctl_ref kctlref, u_int32_t unit, size_t *space)
{
	<span class="enscript-type">struct</span> socket 	*so;
	<span class="enscript-type">long</span> avail;

	<span class="enscript-keyword">if</span> (space == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	so = kcb_find_socket(kctlref, unit, NULL);
	<span class="enscript-keyword">if</span> (so == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	avail = sbspace(&amp;so-&gt;so_rcv);
	*space = (avail &lt; 0) ? 0 : avail;
	socket_unlock(so, 1);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ctl_getenqueuereadable</span>(kern_ctl_ref kctlref, u_int32_t unit,
    u_int32_t *difference)
{
	<span class="enscript-type">struct</span> socket 	*so;

	<span class="enscript-keyword">if</span> (difference == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	so = kcb_find_socket(kctlref, unit, NULL);
	<span class="enscript-keyword">if</span> (so == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (so-&gt;so_rcv.sb_cc &gt;= so-&gt;so_rcv.sb_lowat) {
		*difference = 0;
	} <span class="enscript-keyword">else</span> {
		*difference = (so-&gt;so_rcv.sb_lowat - so-&gt;so_rcv.sb_cc);
	}
	socket_unlock(so, 1);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ctl_ctloutput</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-type">struct</span> ctl_cb 	*kcb = (<span class="enscript-type">struct</span> ctl_cb *)so-&gt;so_pcb;
	<span class="enscript-type">struct</span> kctl	*kctl;
	<span class="enscript-type">int</span> 	error = 0;
	<span class="enscript-type">void</span> 	*data;
	size_t	len;

	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_level != SYSPROTO_CONTROL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (kcb == NULL)	<span class="enscript-comment">/* sanity check */</span>
		<span class="enscript-keyword">return</span> (ENOTCONN);

	<span class="enscript-keyword">if</span> ((kctl = kcb-&gt;kctl) == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_dir) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_SET</span>:
			<span class="enscript-keyword">if</span> (kctl-&gt;setopt == NULL)
				<span class="enscript-keyword">return</span> (ENOTSUP);
			<span class="enscript-keyword">if</span> (sopt-&gt;sopt_valsize == 0) {
				data = NULL;
			} <span class="enscript-keyword">else</span> {
				MALLOC(data, <span class="enscript-type">void</span> *, sopt-&gt;sopt_valsize, M_TEMP,
					M_WAITOK);
				<span class="enscript-keyword">if</span> (data == NULL)
					<span class="enscript-keyword">return</span> (ENOMEM);
				error = sooptcopyin(sopt, data,
				    sopt-&gt;sopt_valsize, sopt-&gt;sopt_valsize);
			}
			<span class="enscript-keyword">if</span> (error == 0) {
				socket_unlock(so, 0);
				error = (*kctl-&gt;setopt)(kctl-&gt;kctlref,
				    kcb-&gt;unit, kcb-&gt;userdata, sopt-&gt;sopt_name,
				    data, sopt-&gt;sopt_valsize);
				socket_lock(so, 0);
			}
			FREE(data, M_TEMP);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SOPT_GET</span>:
			<span class="enscript-keyword">if</span> (kctl-&gt;getopt == NULL)
				<span class="enscript-keyword">return</span> (ENOTSUP);
			data = NULL;
			<span class="enscript-keyword">if</span> (sopt-&gt;sopt_valsize &amp;&amp; sopt-&gt;sopt_val) {
				MALLOC(data, <span class="enscript-type">void</span> *, sopt-&gt;sopt_valsize, M_TEMP,
					M_WAITOK);
				<span class="enscript-keyword">if</span> (data == NULL)
					<span class="enscript-keyword">return</span> (ENOMEM);
				<span class="enscript-comment">/*
				 * 4108337 - copy user data in case the
				 * kernel control needs it
				 */</span>
				error = sooptcopyin(sopt, data,
					sopt-&gt;sopt_valsize, sopt-&gt;sopt_valsize);
			}
			len = sopt-&gt;sopt_valsize;
			socket_unlock(so, 0);
			error = (*kctl-&gt;getopt)(kctl-&gt;kctlref, kcb-&gt;unit,
					kcb-&gt;userdata, sopt-&gt;sopt_name,
						data, &amp;len);
			<span class="enscript-keyword">if</span> (data != NULL &amp;&amp; len &gt; sopt-&gt;sopt_valsize)
				panic_plain(<span class="enscript-string">&quot;ctl_ctloutput: ctl %s returned &quot;</span>
					<span class="enscript-string">&quot;len (%lu) &gt; sopt_valsize (%lu)\n&quot;</span>,
						kcb-&gt;kctl-&gt;name, len,
						sopt-&gt;sopt_valsize);
			socket_lock(so, 0);
			<span class="enscript-keyword">if</span> (error == 0) {
				<span class="enscript-keyword">if</span> (data != NULL)
					error = sooptcopyout(sopt, data, len);
				<span class="enscript-keyword">else</span>
					sopt-&gt;sopt_valsize = len;
			}
			<span class="enscript-keyword">if</span> (data != NULL)
				FREE(data, M_TEMP);
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ctl_ioctl</span>(<span class="enscript-type">struct</span> socket *so, u_long cmd, caddr_t data,
	<span class="enscript-type">struct</span> ifnet *ifp, <span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">so</span>, <span class="enscript-variable-name">ifp</span>, <span class="enscript-variable-name">p</span>)
	<span class="enscript-type">int</span> 	error = ENOTSUP;

	<span class="enscript-keyword">switch</span> (cmd) {
		<span class="enscript-comment">/* get the number of controllers */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CTLIOCGCOUNT</span>: {
			<span class="enscript-type">struct</span> kctl	*kctl;
			u_int32_t n = 0;

			lck_mtx_lock(ctl_mtx);
			TAILQ_FOREACH(kctl, &amp;ctl_head, next)
				n++;
			lck_mtx_unlock(ctl_mtx);

			bcopy(&amp;n, data, <span class="enscript-keyword">sizeof</span> (n));
			error = 0;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">CTLIOCGINFO</span>: {
			<span class="enscript-type">struct</span> ctl_info ctl_info;
			<span class="enscript-type">struct</span> kctl 	*kctl = 0;
			size_t name_len;

			bcopy(data, &amp;ctl_info, <span class="enscript-keyword">sizeof</span> (ctl_info));
			name_len = strnlen(ctl_info.ctl_name, MAX_KCTL_NAME);

			<span class="enscript-keyword">if</span> (name_len == 0 || name_len + 1 &gt; MAX_KCTL_NAME) {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}
			lck_mtx_lock(ctl_mtx);
			kctl = ctl_find_by_name(ctl_info.ctl_name);
			lck_mtx_unlock(ctl_mtx);
			<span class="enscript-keyword">if</span> (kctl == 0) {
				error = ENOENT;
				<span class="enscript-keyword">break</span>;
			}
			ctl_info.ctl_id = kctl-&gt;id;
			bcopy(&amp;ctl_info, data, <span class="enscript-keyword">sizeof</span> (ctl_info));
			error = 0;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* add controls to get list of NKEs */</span>

	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kctl_tbl_grow</span>()
{
	<span class="enscript-type">struct</span> kctl **new_table;
	uintptr_t new_size;

	lck_mtx_assert(ctl_mtx, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">while</span> (kctl_tbl_growing) {
		<span class="enscript-comment">/* Another thread is allocating */</span>
		(<span class="enscript-type">void</span>) msleep((caddr_t) &amp;kctl_tbl_growing, ctl_mtx,
		    PSOCK | PCATCH, <span class="enscript-string">&quot;kctl_tbl_growing&quot;</span>, 0);
	}
	<span class="enscript-comment">/* Another thread grew the table */</span>
	<span class="enscript-keyword">if</span> (kctl_table != NULL &amp;&amp; kctl_tbl_count &lt; kctl_tbl_size)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* Verify we have a sane size */</span>
	<span class="enscript-keyword">if</span> (kctl_tbl_size + KCTL_TBL_INC &gt;= UINT16_MAX) {
		printf(<span class="enscript-string">&quot;%s kctl_tbl_size %lu too big\n&quot;</span>,
		    __func__, kctl_tbl_size);
		<span class="enscript-keyword">return</span>;
	}
	kctl_tbl_growing = 1;

	new_size = kctl_tbl_size + KCTL_TBL_INC;

	lck_mtx_unlock(ctl_mtx);
	new_table = _MALLOC(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kctl *) * new_size,
	    M_TEMP, M_WAIT | M_ZERO);
	lck_mtx_lock(ctl_mtx);

	<span class="enscript-keyword">if</span> (new_table != NULL) {
		<span class="enscript-keyword">if</span> (kctl_table != NULL) {
			bcopy(kctl_table, new_table,
			    kctl_tbl_size * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kctl *));

			_FREE(kctl_table, M_TEMP);
		}
		kctl_table = new_table;
		kctl_tbl_size = new_size;
	}

	kctl_tbl_growing = 0;
}

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KCTLREF_INDEX_MASK</span> 0x0000FFFF
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KCTLREF_GENCNT_MASK</span> 0xFFFF0000
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KCTLREF_GENCNT_SHIFT</span> 16

<span class="enscript-type">static</span> kern_ctl_ref
<span class="enscript-function-name">kctl_make_ref</span>(<span class="enscript-type">struct</span> kctl *kctl)
{
	uintptr_t i;

	lck_mtx_assert(ctl_mtx, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (kctl_tbl_count &gt;= kctl_tbl_size)
		kctl_tbl_grow();

	kctl-&gt;kctlref = NULL;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; kctl_tbl_size; i++) {
		<span class="enscript-keyword">if</span> (kctl_table[i] == NULL) {
			uintptr_t ref;

			<span class="enscript-comment">/*
			 * Reference is index plus one
			 */</span>
			kctl_ref_gencnt += 1;

			<span class="enscript-comment">/*
			 * Add generation count as salt to reference to prevent
			 * use after deregister
			 */</span>
			ref = ((kctl_ref_gencnt &lt;&lt; KCTLREF_GENCNT_SHIFT) &amp; 
			    KCTLREF_GENCNT_MASK) +
			    ((i + 1) &amp; KCTLREF_INDEX_MASK);

			kctl-&gt;kctlref = (<span class="enscript-type">void</span> *)(ref);
			kctl_table[i] = kctl;
			kctl_tbl_count++;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (kctl-&gt;kctlref == NULL)
		panic(<span class="enscript-string">&quot;%s no space in table&quot;</span>, __func__);

	<span class="enscript-keyword">if</span> (ctl_debug &gt; 0)
		printf(<span class="enscript-string">&quot;%s %p for %p\n&quot;</span>,
			__func__, kctl-&gt;kctlref, kctl);

	<span class="enscript-keyword">return</span> (kctl-&gt;kctlref);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kctl_delete_ref</span>(kern_ctl_ref kctlref)
{
	<span class="enscript-comment">/*
	 * Reference is index plus one
	 */</span>
	uintptr_t i = (((uintptr_t)kctlref) &amp; KCTLREF_INDEX_MASK) - 1;

	lck_mtx_assert(ctl_mtx, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (i &lt; kctl_tbl_size) {
		<span class="enscript-type">struct</span> kctl *kctl = kctl_table[i];

		<span class="enscript-keyword">if</span> (kctl-&gt;kctlref == kctlref) {
			kctl_table[i] = NULL;
			kctl_tbl_count--;
		} <span class="enscript-keyword">else</span> {
			kctlstat.kcs_bad_kctlref++;
		}
	} <span class="enscript-keyword">else</span> {
		kctlstat.kcs_bad_kctlref++;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> kctl *
<span class="enscript-function-name">kctl_from_ref</span>(kern_ctl_ref kctlref)
{
	<span class="enscript-comment">/*
	 * Reference is index plus one
	 */</span>
	uintptr_t i = (((uintptr_t)kctlref) &amp; KCTLREF_INDEX_MASK) - 1;
	<span class="enscript-type">struct</span> kctl *kctl = NULL;

	lck_mtx_assert(ctl_mtx, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (i &gt;= kctl_tbl_size) {
		kctlstat.kcs_bad_kctlref++;
		<span class="enscript-keyword">return</span> (NULL);
	}
	kctl = kctl_table[i];
	<span class="enscript-keyword">if</span> (kctl-&gt;kctlref != kctlref) {
		kctlstat.kcs_bad_kctlref++;
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-keyword">return</span> (kctl);
}

<span class="enscript-comment">/*
 * Register/unregister a NKE
 */</span>
errno_t
<span class="enscript-function-name">ctl_register</span>(<span class="enscript-type">struct</span> kern_ctl_reg *userkctl, kern_ctl_ref *kctlref)
{
	<span class="enscript-type">struct</span> kctl 	*kctl = NULL;
	<span class="enscript-type">struct</span> kctl 	*kctl_next = NULL;
	u_int32_t	id = 1;
	size_t		name_len;
	<span class="enscript-type">int</span>		is_extended = 0;

	<span class="enscript-keyword">if</span> (userkctl == NULL)	<span class="enscript-comment">/* sanity check */</span>
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (userkctl-&gt;ctl_connect == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);
	name_len = strlen(userkctl-&gt;ctl_name);
	<span class="enscript-keyword">if</span> (name_len == 0 || name_len + 1 &gt; MAX_KCTL_NAME)
		<span class="enscript-keyword">return</span> (EINVAL);

	MALLOC(kctl, <span class="enscript-type">struct</span> kctl *, <span class="enscript-keyword">sizeof</span>(*kctl), M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (kctl == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);
	bzero((<span class="enscript-type">char</span> *)kctl, <span class="enscript-keyword">sizeof</span>(*kctl));

	lck_mtx_lock(ctl_mtx);

	<span class="enscript-keyword">if</span> (kctl_make_ref(kctl) == NULL) {
		lck_mtx_unlock(ctl_mtx);
		FREE(kctl, M_TEMP);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	<span class="enscript-comment">/*
	 * Kernel Control IDs
	 *
	 * CTL_FLAG_REG_ID_UNIT indicates the control ID and unit number are
	 * static. If they do not exist, add them to the list in order. If the
	 * flag is not set, we must find a new unique value. We assume the
	 * list is in order. We find the last item in the list and add one. If
	 * this leads to wrapping the id around, we start at the front of the
	 * list and look for a gap.
	 */</span>

	<span class="enscript-keyword">if</span> ((userkctl-&gt;ctl_flags &amp; CTL_FLAG_REG_ID_UNIT) == 0) {
		<span class="enscript-comment">/* Must dynamically assign an unused ID */</span>

		<span class="enscript-comment">/* Verify the same name isn't already registered */</span>
		<span class="enscript-keyword">if</span> (ctl_find_by_name(userkctl-&gt;ctl_name) != NULL) {
			kctl_delete_ref(kctl-&gt;kctlref);
			lck_mtx_unlock(ctl_mtx);
			FREE(kctl, M_TEMP);
			<span class="enscript-keyword">return</span> (EEXIST);
		}

		<span class="enscript-comment">/* Start with 1 in case the list is empty */</span>
		id = 1;
		kctl_next = TAILQ_LAST(&amp;ctl_head, kctl_list);

		<span class="enscript-keyword">if</span> (kctl_next != NULL) {
			<span class="enscript-comment">/* List was not empty, add one to the last item */</span>
			id = kctl_next-&gt;id + 1;
			kctl_next = NULL;

			<span class="enscript-comment">/*
			 * If this wrapped the id number, start looking at
			 * the front of the list for an unused id.
			 */</span>
			<span class="enscript-keyword">if</span> (id == 0) {
				<span class="enscript-comment">/* Find the next unused ID */</span>
				id = 1;

				TAILQ_FOREACH(kctl_next, &amp;ctl_head, next) {
					<span class="enscript-keyword">if</span> (kctl_next-&gt;id &gt; id) {
						<span class="enscript-comment">/* We found a gap */</span>
						<span class="enscript-keyword">break</span>;
					}

					id = kctl_next-&gt;id + 1;
				}
			}
		}

		userkctl-&gt;ctl_id = id;
		kctl-&gt;id = id;
		kctl-&gt;reg_unit = -1;
	} <span class="enscript-keyword">else</span> {
		TAILQ_FOREACH(kctl_next, &amp;ctl_head, next) {
			<span class="enscript-keyword">if</span> (kctl_next-&gt;id &gt; userkctl-&gt;ctl_id)
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (ctl_find_by_id_unit(userkctl-&gt;ctl_id, userkctl-&gt;ctl_unit)) {
			kctl_delete_ref(kctl-&gt;kctlref);
			lck_mtx_unlock(ctl_mtx);
			FREE(kctl, M_TEMP);
			<span class="enscript-keyword">return</span> (EEXIST);
		}
		kctl-&gt;id = userkctl-&gt;ctl_id;
		kctl-&gt;reg_unit = userkctl-&gt;ctl_unit;
	}

	is_extended = (userkctl-&gt;ctl_flags &amp; CTL_FLAG_REG_EXTENDED);

	strlcpy(kctl-&gt;name, userkctl-&gt;ctl_name, MAX_KCTL_NAME);
	kctl-&gt;flags = userkctl-&gt;ctl_flags;

	<span class="enscript-comment">/*
	 * Let the caller know the default send and receive sizes
	 */</span>
	<span class="enscript-keyword">if</span> (userkctl-&gt;ctl_sendsize == 0) {
		kctl-&gt;sendbufsize = CTL_SENDSIZE;
		userkctl-&gt;ctl_sendsize = kctl-&gt;sendbufsize;
	} <span class="enscript-keyword">else</span> {
		kctl-&gt;sendbufsize = userkctl-&gt;ctl_sendsize;
	}
	<span class="enscript-keyword">if</span> (userkctl-&gt;ctl_recvsize == 0) {
		kctl-&gt;recvbufsize = CTL_RECVSIZE;
		userkctl-&gt;ctl_recvsize = kctl-&gt;recvbufsize;
	} <span class="enscript-keyword">else</span> {
		kctl-&gt;recvbufsize = userkctl-&gt;ctl_recvsize;
	}

	kctl-&gt;connect = userkctl-&gt;ctl_connect;
	kctl-&gt;disconnect = userkctl-&gt;ctl_disconnect;
	kctl-&gt;send = userkctl-&gt;ctl_send;
	kctl-&gt;setopt = userkctl-&gt;ctl_setopt;
	kctl-&gt;getopt = userkctl-&gt;ctl_getopt;
	<span class="enscript-keyword">if</span> (is_extended) {
		kctl-&gt;rcvd = userkctl-&gt;ctl_rcvd;
		kctl-&gt;send_list = userkctl-&gt;ctl_send_list;
	}

	TAILQ_INIT(&amp;kctl-&gt;kcb_head);

	<span class="enscript-keyword">if</span> (kctl_next)
		TAILQ_INSERT_BEFORE(kctl_next, kctl, next);
	<span class="enscript-keyword">else</span>
		TAILQ_INSERT_TAIL(&amp;ctl_head, kctl, next);

	kctlstat.kcs_reg_count++;
	kctlstat.kcs_gencnt++;

	lck_mtx_unlock(ctl_mtx);

	*kctlref = kctl-&gt;kctlref;

	ctl_post_msg(KEV_CTL_REGISTERED, kctl-&gt;id);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">ctl_deregister</span>(<span class="enscript-type">void</span> *kctlref)
{
	<span class="enscript-type">struct</span> kctl		*kctl;

	lck_mtx_lock(ctl_mtx);
	<span class="enscript-keyword">if</span> ((kctl = kctl_from_ref(kctlref)) == NULL) {
		kctlstat.kcs_bad_kctlref++;
		lck_mtx_unlock(ctl_mtx);
		<span class="enscript-keyword">if</span> (ctl_debug != 0)
			printf(<span class="enscript-string">&quot;%s invalid kctlref %p\n&quot;</span>,
				__func__, kctlref);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;kctl-&gt;kcb_head)) {
		lck_mtx_unlock(ctl_mtx);
		<span class="enscript-keyword">return</span> (EBUSY);
	}

	TAILQ_REMOVE(&amp;ctl_head, kctl, next);

	kctlstat.kcs_reg_count--;
	kctlstat.kcs_gencnt++;

	kctl_delete_ref(kctl-&gt;kctlref);
	lck_mtx_unlock(ctl_mtx);

	ctl_post_msg(KEV_CTL_DEREGISTERED, kctl-&gt;id);
	FREE(kctl, M_TEMP);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Must be called with global ctl_mtx lock taked
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> kctl *
<span class="enscript-function-name">ctl_find_by_name</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name)
{
	<span class="enscript-type">struct</span> kctl 	*kctl;

	lck_mtx_assert(ctl_mtx, LCK_MTX_ASSERT_OWNED);

	TAILQ_FOREACH(kctl, &amp;ctl_head, next)
		<span class="enscript-keyword">if</span> (strncmp(kctl-&gt;name, name, <span class="enscript-keyword">sizeof</span>(kctl-&gt;name)) == 0)
			<span class="enscript-keyword">return</span> (kctl);

	<span class="enscript-keyword">return</span> (NULL);
}

u_int32_t
<span class="enscript-function-name">ctl_id_by_name</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name)
{
	u_int32_t	ctl_id = 0;
	<span class="enscript-type">struct</span> kctl	*kctl;

	lck_mtx_lock(ctl_mtx);
	kctl = ctl_find_by_name(name);
	<span class="enscript-keyword">if</span> (kctl)
		ctl_id = kctl-&gt;id;
	lck_mtx_unlock(ctl_mtx);

	<span class="enscript-keyword">return</span> (ctl_id);
}

errno_t
<span class="enscript-function-name">ctl_name_by_id</span>(u_int32_t id, <span class="enscript-type">char</span> *out_name, size_t maxsize)
{
	<span class="enscript-type">int</span> 		found = 0;
	<span class="enscript-type">struct</span> kctl *kctl;

	lck_mtx_lock(ctl_mtx);
	TAILQ_FOREACH(kctl, &amp;ctl_head, next) {
		<span class="enscript-keyword">if</span> (kctl-&gt;id == id)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (kctl) {
		<span class="enscript-keyword">if</span> (maxsize &gt; MAX_KCTL_NAME)
			maxsize = MAX_KCTL_NAME;
		strlcpy(out_name, kctl-&gt;name, maxsize);
		found = 1;
	}
	lck_mtx_unlock(ctl_mtx);

	<span class="enscript-keyword">return</span> (found ? 0 : ENOENT);
}

<span class="enscript-comment">/*
 * Must be called with global ctl_mtx lock taked
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> kctl *
<span class="enscript-function-name">ctl_find_by_id_unit</span>(u_int32_t id, u_int32_t unit)
{
	<span class="enscript-type">struct</span> kctl 	*kctl;

	lck_mtx_assert(ctl_mtx, LCK_MTX_ASSERT_OWNED);

	TAILQ_FOREACH(kctl, &amp;ctl_head, next) {
		<span class="enscript-keyword">if</span> (kctl-&gt;id == id &amp;&amp; (kctl-&gt;flags &amp; CTL_FLAG_REG_ID_UNIT) == 0)
			<span class="enscript-keyword">return</span> (kctl);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kctl-&gt;id == id &amp;&amp; kctl-&gt;reg_unit == unit)
			<span class="enscript-keyword">return</span> (kctl);
	}
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * Must be called with kernel controller lock taken
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ctl_cb *
<span class="enscript-function-name">kcb_find</span>(<span class="enscript-type">struct</span> kctl *kctl, u_int32_t unit)
{
	<span class="enscript-type">struct</span> ctl_cb 	*kcb;

	lck_mtx_assert(ctl_mtx, LCK_MTX_ASSERT_OWNED);

	TAILQ_FOREACH(kcb, &amp;kctl-&gt;kcb_head, next)
		<span class="enscript-keyword">if</span> (kcb-&gt;unit == unit)
			<span class="enscript-keyword">return</span> (kcb);

	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> socket *
<span class="enscript-function-name">kcb_find_socket</span>(kern_ctl_ref kctlref, u_int32_t unit, u_int32_t *kctlflags)
{
	<span class="enscript-type">struct</span> socket *so = NULL;
	<span class="enscript-type">struct</span> ctl_cb	*kcb;
	<span class="enscript-type">void</span> *lr_saved;
	<span class="enscript-type">struct</span> kctl *kctl;
	<span class="enscript-type">int</span> i;

	lr_saved = __builtin_return_address(0);

	lck_mtx_lock(ctl_mtx);
	<span class="enscript-comment">/*
	 * First validate the kctlref
	 */</span>
	<span class="enscript-keyword">if</span> ((kctl = kctl_from_ref(kctlref)) == NULL) {
		kctlstat.kcs_bad_kctlref++;
		lck_mtx_unlock(ctl_mtx);
		<span class="enscript-keyword">if</span> (ctl_debug != 0)
			printf(<span class="enscript-string">&quot;%s invalid kctlref %p\n&quot;</span>,
				__func__, kctlref);
		<span class="enscript-keyword">return</span> (NULL);
	}

	kcb = kcb_find(kctl, unit);
	<span class="enscript-keyword">if</span> (kcb == NULL || kcb-&gt;kctl != kctl || (so = kcb-&gt;so) == NULL) {
		lck_mtx_unlock(ctl_mtx);
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-comment">/*
	 * This prevents the socket from being closed
	 */</span>
	kcb-&gt;usecount++;
	<span class="enscript-comment">/*
	 * Respect lock ordering: socket before ctl_mtx
	 */</span>
	lck_mtx_unlock(ctl_mtx);

	socket_lock(so, 1);
	<span class="enscript-comment">/*
	 * The socket lock history is more useful if we store
	 * the address of the caller.
	 */</span>
	i = (so-&gt;next_lock_lr + SO_LCKDBG_MAX - 1) % SO_LCKDBG_MAX;
	so-&gt;lock_lr[i] = lr_saved;

	lck_mtx_lock(ctl_mtx);

	<span class="enscript-keyword">if</span> ((kctl = kctl_from_ref(kctlref)) == NULL || kcb-&gt;kctl == NULL) {
		lck_mtx_unlock(ctl_mtx);
		socket_unlock(so, 1);
		so = NULL;
		lck_mtx_lock(ctl_mtx);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kctlflags != NULL) {
		*kctlflags = kctl-&gt;flags;
	}

	kcb-&gt;usecount--;
	<span class="enscript-keyword">if</span> (kcb-&gt;usecount == 0)
		wakeup((event_t)&amp;kcb-&gt;usecount);

	lck_mtx_unlock(ctl_mtx);

	<span class="enscript-keyword">return</span> (so);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ctl_post_msg</span>(u_int32_t event_code, u_int32_t id)
{
	<span class="enscript-type">struct</span> ctl_event_data  	ctl_ev_data;
	<span class="enscript-type">struct</span> kev_msg  		ev_msg;

	lck_mtx_assert(ctl_mtx, LCK_MTX_ASSERT_NOTOWNED);

	bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kev_msg));
	ev_msg.vendor_code = KEV_VENDOR_APPLE;

	ev_msg.kev_class = KEV_SYSTEM_CLASS;
	ev_msg.kev_subclass = KEV_CTL_SUBCLASS;
	ev_msg.event_code = event_code;

	<span class="enscript-comment">/* common nke subclass data */</span>
	bzero(&amp;ctl_ev_data, <span class="enscript-keyword">sizeof</span>(ctl_ev_data));
	ctl_ev_data.ctl_id = id;
	ev_msg.dv[0].data_ptr = &amp;ctl_ev_data;
	ev_msg.dv[0].data_length = <span class="enscript-keyword">sizeof</span>(ctl_ev_data);

	ev_msg.dv[1].data_length = 0;

	kev_post_msg(&amp;ev_msg);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ctl_lock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> refcount, <span class="enscript-type">void</span> *lr)
{
	<span class="enscript-type">void</span> *lr_saved;

	<span class="enscript-keyword">if</span> (lr == NULL)
		lr_saved = __builtin_return_address(0);
	<span class="enscript-keyword">else</span>
		lr_saved = lr;

	<span class="enscript-keyword">if</span> (so-&gt;so_pcb != NULL) {
		lck_mtx_lock(((<span class="enscript-type">struct</span> ctl_cb *)so-&gt;so_pcb)-&gt;mtx);
	} <span class="enscript-keyword">else</span>  {
		panic(<span class="enscript-string">&quot;ctl_lock: so=%p NO PCB! lr=%p lrh= %s\n&quot;</span>,
		    so, lr_saved, solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt; 0) {
		panic(<span class="enscript-string">&quot;ctl_lock: so=%p so_pcb=%p lr=%p ref=%x lrh= %s\n&quot;</span>,
			so, so-&gt;so_pcb, lr_saved, so-&gt;so_usecount,
			solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (refcount)
		so-&gt;so_usecount++;

	so-&gt;lock_lr[so-&gt;next_lock_lr] = lr_saved;
	so-&gt;next_lock_lr = (so-&gt;next_lock_lr+1) % SO_LCKDBG_MAX;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ctl_unlock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> refcount, <span class="enscript-type">void</span> *lr)
{
	<span class="enscript-type">void</span> *lr_saved;
	lck_mtx_t *mutex_held;

	<span class="enscript-keyword">if</span> (lr == NULL)
		lr_saved = __builtin_return_address(0);
	<span class="enscript-keyword">else</span>
		lr_saved = lr;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MORE_KCTLLOCK_DEBUG</span>
	printf(<span class="enscript-string">&quot;ctl_unlock: so=%llx sopcb=%x lock=%llx ref=%u lr=%llx\n&quot;</span>,
	    (uint64_t)VM_KERNEL_ADDRPERM(so),
	    (uint64_t)VM_KERNEL_ADDRPERM(so-&gt;so_pcb,
	    (uint64_t)VM_KERNEL_ADDRPERM(((<span class="enscript-type">struct</span> ctl_cb *)so-&gt;so_pcb)-&gt;mtx),
	    so-&gt;so_usecount, (uint64_t)VM_KERNEL_ADDRPERM(lr_saved));
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (refcount)
		so-&gt;so_usecount--;

	<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt; 0) {
		panic(<span class="enscript-string">&quot;ctl_unlock: so=%p usecount=%x lrh= %s\n&quot;</span>,
		    so, so-&gt;so_usecount, solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (so-&gt;so_pcb == NULL) {
		panic(<span class="enscript-string">&quot;ctl_unlock: so=%p NO PCB usecount=%x lr=%p lrh= %s\n&quot;</span>,
			so, so-&gt;so_usecount, (<span class="enscript-type">void</span> *)lr_saved,
			solockhistory_nr(so));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	mutex_held = ((<span class="enscript-type">struct</span> ctl_cb *)so-&gt;so_pcb)-&gt;mtx;

	lck_mtx_assert(mutex_held, LCK_MTX_ASSERT_OWNED);
	so-&gt;unlock_lr[so-&gt;next_unlock_lr] = lr_saved;
	so-&gt;next_unlock_lr = (so-&gt;next_unlock_lr+1) % SO_LCKDBG_MAX;
	lck_mtx_unlock(mutex_held);

	<span class="enscript-keyword">if</span> (so-&gt;so_usecount == 0)
		ctl_sofreelastref(so);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> lck_mtx_t *
<span class="enscript-function-name">ctl_getlock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> locktype)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">locktype</span>)
	<span class="enscript-type">struct</span> ctl_cb *kcb = (<span class="enscript-type">struct</span> ctl_cb *)so-&gt;so_pcb;

	<span class="enscript-keyword">if</span> (so-&gt;so_pcb)  {
		<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt; 0)
			panic(<span class="enscript-string">&quot;ctl_getlock: so=%p usecount=%x lrh= %s\n&quot;</span>,
			    so, so-&gt;so_usecount, solockhistory_nr(so));
		<span class="enscript-keyword">return</span> (kcb-&gt;mtx);
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;ctl_getlock: so=%p NULL NO so_pcb %s\n&quot;</span>,
		    so, solockhistory_nr(so));
		<span class="enscript-keyword">return</span> (so-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx);
	}
}

__private_extern__ <span class="enscript-type">int</span>
kctl_reg_list SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> n, i;
	<span class="enscript-type">struct</span> xsystmgen xsg;
	<span class="enscript-type">void</span> *buf = NULL;
	<span class="enscript-type">struct</span> kctl *kctl;
	size_t item_size = ROUNDUP64(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xkctl_reg));

	buf = _MALLOC(item_size, M_TEMP, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (buf == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	lck_mtx_lock(ctl_mtx);

	n = kctlstat.kcs_reg_count;

	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		req-&gt;oldidx = (n + n/8) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> xkctl_reg);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	bzero(&amp;xsg, <span class="enscript-keyword">sizeof</span> (xsg));
	xsg.xg_len = <span class="enscript-keyword">sizeof</span> (xsg);
	xsg.xg_count = n;
	xsg.xg_gen = kctlstat.kcs_gencnt;
	xsg.xg_sogen = so_gencnt;
	error = SYSCTL_OUT(req, &amp;xsg, <span class="enscript-keyword">sizeof</span> (xsg));
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/*
	 * We are done if there is no pcb
	 */</span>
	<span class="enscript-keyword">if</span> (n == 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	i = 0;
	<span class="enscript-keyword">for</span> (i = 0, kctl = TAILQ_FIRST(&amp;ctl_head);
	    i &lt; n &amp;&amp; kctl != NULL;
	    i++, kctl = TAILQ_NEXT(kctl, next)) {
		<span class="enscript-type">struct</span> xkctl_reg *xkr = (<span class="enscript-type">struct</span> xkctl_reg *)buf;
		<span class="enscript-type">struct</span> ctl_cb *kcb;
		u_int32_t pcbcount = 0;

		TAILQ_FOREACH(kcb, &amp;kctl-&gt;kcb_head, next)
			pcbcount++;

		bzero(buf, item_size);

		xkr-&gt;xkr_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> xkctl_reg);
		xkr-&gt;xkr_kind = XSO_KCREG;
		xkr-&gt;xkr_id = kctl-&gt;id;
		xkr-&gt;xkr_reg_unit = kctl-&gt;reg_unit;
		xkr-&gt;xkr_flags = kctl-&gt;flags;
		xkr-&gt;xkr_kctlref = (uint64_t)(kctl-&gt;kctlref);
		xkr-&gt;xkr_recvbufsize = kctl-&gt;recvbufsize;
		xkr-&gt;xkr_sendbufsize = kctl-&gt;sendbufsize;
		xkr-&gt;xkr_lastunit = kctl-&gt;lastunit;
		xkr-&gt;xkr_pcbcount = pcbcount;
		xkr-&gt;xkr_connect = (uint64_t)VM_KERNEL_ADDRPERM(kctl-&gt;connect);
		xkr-&gt;xkr_disconnect =
		    (uint64_t)VM_KERNEL_ADDRPERM(kctl-&gt;disconnect);
		xkr-&gt;xkr_send = (uint64_t)VM_KERNEL_ADDRPERM(kctl-&gt;send);
		xkr-&gt;xkr_send_list =
		    (uint64_t)VM_KERNEL_ADDRPERM(kctl-&gt;send_list);
		xkr-&gt;xkr_setopt = (uint64_t)VM_KERNEL_ADDRPERM(kctl-&gt;setopt);
		xkr-&gt;xkr_getopt = (uint64_t)VM_KERNEL_ADDRPERM(kctl-&gt;getopt);
		xkr-&gt;xkr_rcvd = (uint64_t)VM_KERNEL_ADDRPERM(kctl-&gt;rcvd);
		strlcpy(xkr-&gt;xkr_name, kctl-&gt;name, <span class="enscript-keyword">sizeof</span>(xkr-&gt;xkr_name));

		error = SYSCTL_OUT(req, buf, item_size);
	}

	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-comment">/*
		 * Give the user an updated idea of our state.
		 * If the generation differs from what we told
		 * her before, she knows that something happened
		 * while we were processing this request, and it
		 * might be necessary to retry.
		 */</span>
		bzero(&amp;xsg, <span class="enscript-keyword">sizeof</span> (xsg));
		xsg.xg_len = <span class="enscript-keyword">sizeof</span> (xsg);
		xsg.xg_count = n;
		xsg.xg_gen = kctlstat.kcs_gencnt;
		xsg.xg_sogen = so_gencnt;
		error = SYSCTL_OUT(req, &amp;xsg, <span class="enscript-keyword">sizeof</span> (xsg));
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

<span class="enscript-reference">done</span>:
	lck_mtx_unlock(ctl_mtx);

	<span class="enscript-keyword">if</span> (buf != NULL)
		FREE(buf, M_TEMP);

	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
kctl_pcblist SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> n, i;
	<span class="enscript-type">struct</span> xsystmgen xsg;
	<span class="enscript-type">void</span> *buf = NULL;
	<span class="enscript-type">struct</span> kctl *kctl;
	size_t item_size = ROUNDUP64(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xkctlpcb)) +
		ROUNDUP64(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xsocket_n)) +
		2 * ROUNDUP64(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xsockbuf_n)) +
		ROUNDUP64(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> xsockstat_n));

	buf = _MALLOC(item_size, M_TEMP, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (buf == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	lck_mtx_lock(ctl_mtx);

	n = kctlstat.kcs_pcbcount;

	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		req-&gt;oldidx = (n + n/8) * item_size;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	bzero(&amp;xsg, <span class="enscript-keyword">sizeof</span> (xsg));
	xsg.xg_len = <span class="enscript-keyword">sizeof</span> (xsg);
	xsg.xg_count = n;
	xsg.xg_gen = kctlstat.kcs_gencnt;
	xsg.xg_sogen = so_gencnt;
	error = SYSCTL_OUT(req, &amp;xsg, <span class="enscript-keyword">sizeof</span> (xsg));
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-comment">/*
	 * We are done if there is no pcb
	 */</span>
	<span class="enscript-keyword">if</span> (n == 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	i = 0;
	<span class="enscript-keyword">for</span> (i = 0, kctl = TAILQ_FIRST(&amp;ctl_head);
	    i &lt; n &amp;&amp; kctl != NULL;
	    kctl = TAILQ_NEXT(kctl, next)) {
		<span class="enscript-type">struct</span> ctl_cb *kcb;

		<span class="enscript-keyword">for</span> (kcb = TAILQ_FIRST(&amp;kctl-&gt;kcb_head);
		    i &lt; n &amp;&amp; kcb != NULL;
		    i++, kcb = TAILQ_NEXT(kcb, next)) {
			<span class="enscript-type">struct</span> xkctlpcb *xk = (<span class="enscript-type">struct</span> xkctlpcb *)buf;
			<span class="enscript-type">struct</span> xsocket_n *xso = (<span class="enscript-type">struct</span> xsocket_n *)
				ADVANCE64(xk, <span class="enscript-keyword">sizeof</span> (*xk));
			<span class="enscript-type">struct</span> xsockbuf_n *xsbrcv = (<span class="enscript-type">struct</span> xsockbuf_n *)
				ADVANCE64(xso, <span class="enscript-keyword">sizeof</span> (*xso));
			<span class="enscript-type">struct</span> xsockbuf_n *xsbsnd = (<span class="enscript-type">struct</span> xsockbuf_n *)
				ADVANCE64(xsbrcv, <span class="enscript-keyword">sizeof</span> (*xsbrcv));
			<span class="enscript-type">struct</span> xsockstat_n *xsostats = (<span class="enscript-type">struct</span> xsockstat_n *)
				ADVANCE64(xsbsnd, <span class="enscript-keyword">sizeof</span> (*xsbsnd));

			bzero(buf, item_size);

			xk-&gt;xkp_len = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> xkctlpcb);
			xk-&gt;xkp_kind = XSO_KCB;
			xk-&gt;xkp_unit = kcb-&gt;unit;
			xk-&gt;xkp_kctpcb = (uint64_t)VM_KERNEL_ADDRPERM(kcb);
			xk-&gt;xkp_kctlref = (uint64_t)VM_KERNEL_ADDRPERM(kctl);
			xk-&gt;xkp_kctlid = kctl-&gt;id;
			strlcpy(xk-&gt;xkp_kctlname, kctl-&gt;name,
			    <span class="enscript-keyword">sizeof</span>(xk-&gt;xkp_kctlname));

			sotoxsocket_n(kcb-&gt;so, xso);
			sbtoxsockbuf_n(kcb-&gt;so ?
				&amp;kcb-&gt;so-&gt;so_rcv : NULL, xsbrcv);
			sbtoxsockbuf_n(kcb-&gt;so ?
				&amp;kcb-&gt;so-&gt;so_snd : NULL, xsbsnd);
			sbtoxsockstat_n(kcb-&gt;so, xsostats);

			error = SYSCTL_OUT(req, buf, item_size);
		}
	}

	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-comment">/*
		 * Give the user an updated idea of our state.
		 * If the generation differs from what we told
		 * her before, she knows that something happened
		 * while we were processing this request, and it
		 * might be necessary to retry.
		 */</span>
		bzero(&amp;xsg, <span class="enscript-keyword">sizeof</span> (xsg));
		xsg.xg_len = <span class="enscript-keyword">sizeof</span> (xsg);
		xsg.xg_count = n;
		xsg.xg_gen = kctlstat.kcs_gencnt;
		xsg.xg_sogen = so_gencnt;
		error = SYSCTL_OUT(req, &amp;xsg, <span class="enscript-keyword">sizeof</span> (xsg));
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

<span class="enscript-reference">done</span>:
	lck_mtx_unlock(ctl_mtx);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
kctl_getstat SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error = 0;

	lck_mtx_lock(ctl_mtx);

	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		req-&gt;oldidx = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kctlstat);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = SYSCTL_OUT(req, &amp;kctlstat,
	    MIN(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kctlstat), req-&gt;oldlen));
<span class="enscript-reference">done</span>:
	lck_mtx_unlock(ctl_mtx);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kctl_fill_socketinfo</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> socket_info *si)
{
	<span class="enscript-type">struct</span> ctl_cb *kcb = (<span class="enscript-type">struct</span> ctl_cb *)so-&gt;so_pcb;
	<span class="enscript-type">struct</span> kern_ctl_info *kcsi =
	    &amp;si-&gt;soi_proto.pri_kern_ctl;
	<span class="enscript-type">struct</span> kctl *kctl = kcb-&gt;kctl;

	si-&gt;soi_kind = SOCKINFO_KERN_CTL;

	<span class="enscript-keyword">if</span> (kctl == 0)
		<span class="enscript-keyword">return</span>;

	kcsi-&gt;kcsi_id = kctl-&gt;id;
	kcsi-&gt;kcsi_reg_unit = kctl-&gt;reg_unit;
	kcsi-&gt;kcsi_flags = kctl-&gt;flags;
	kcsi-&gt;kcsi_recvbufsize = kctl-&gt;recvbufsize;
	kcsi-&gt;kcsi_sendbufsize = kctl-&gt;sendbufsize;
	kcsi-&gt;kcsi_unit = kcb-&gt;unit;
	strlcpy(kcsi-&gt;kcsi_name, kctl-&gt;name, MAX_KCTL_NAME);
}
</pre>
<hr />
</body></html>