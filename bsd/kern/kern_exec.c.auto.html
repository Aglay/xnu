<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_exec.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_exec.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Mach Operating System
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */</span>
 
<span class="enscript-comment">/*-
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @(#)kern_exec.c	8.1 (Berkeley) 6/10/93
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/reg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/cpu_capabilities.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>		
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/acct.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/exec.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/aio_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SYSV_SHM</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/shm_internal.h&gt;</span>		<span class="enscript-comment">/* shmexec() */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>		<span class="enscript-comment">/* ubc_map() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/spawn.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/spawn_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/process_policy.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/codesign.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;crypto/sha1.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ipc/ipc_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/port.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task_access.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_act.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span> <span class="enscript-comment">/* thread_wakeup() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/affinity.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/coalition.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_mach_internal.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_fault.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kdp/kdp_dyld.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/pal_routines.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_memorystatus.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
<span class="enscript-comment">/* Do not include dtrace.h, it redefines kmem_[alloc/free] */</span>
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_fasttrap_exec_ptr)(proc_t);
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_proc_waitfor_exec_ptr)(proc_t);
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_helpers_cleanup)(proc_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_lazy_dofs_destroy</span>(proc_t);

<span class="enscript-comment">/*
 * Since dtrace_proc_waitfor_exec_ptr can be added/removed in dtrace_subr.c,
 * we will store its value before actually calling it.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">void</span> (*dtrace_proc_waitfor_hook)(proc_t) = NULL;

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace_ptss.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* support for child creation in exec after vfork */</span>
thread_t <span class="enscript-function-name">fork_create_child</span>(task_t parent_task, coalition_t *parent_coalition, proc_t child_proc, <span class="enscript-type">int</span> inherit_memory, <span class="enscript-type">int</span> is64bit);
<span class="enscript-type">void</span> <span class="enscript-function-name">vfork_exit</span>(proc_t p, <span class="enscript-type">int</span> rv);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">proc_apply_task_networkbg_internal</span>(proc_t, thread_t);

<span class="enscript-comment">/*
 * Mach things for which prototypes are unavailable from Mach headers
 */</span>
<span class="enscript-type">void</span>		ipc_task_reset(
			task_t		task);
<span class="enscript-type">void</span>		ipc_thread_reset(
			thread_t	thread);
kern_return_t <span class="enscript-function-name">ipc_object_copyin</span>(
	ipc_space_t		space,
	mach_port_name_t	name,
	mach_msg_type_name_t	msgt_name,
	ipc_object_t		*objectp);
<span class="enscript-type">void</span> <span class="enscript-function-name">ipc_port_release_send</span>(ipc_port_t);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">task_importance_update_owner_info</span>(task_t);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> savearea *<span class="enscript-function-name">get_user_regs</span>(thread_t);

<span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span> __EXEC_WAITING_ON_TASKGATED_CODE_SIGNATURE_UPCALL__(mach_port_t task_access_port, int32_t new_pid);

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ast.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_loader.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_fat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/fat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/loader.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/vmparam.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/imgact.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sdt.h&gt;</span>


<span class="enscript-comment">/*
 * EAI_ITERLIMIT	The maximum number of times to iterate an image
 *			activator in exec_activate_image() before treating
 *			it as malformed/corrupt.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">EAI_ITERLIMIT</span>		3

<span class="enscript-comment">/*
 * For #! interpreter parsing
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_WHITESPACE</span>(ch) ((ch == <span class="enscript-string">' '</span>) || (ch == <span class="enscript-string">'\t'</span>))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IS_EOL</span>(ch) ((ch == <span class="enscript-string">'#'</span>) || (ch == <span class="enscript-string">'\n'</span>))

<span class="enscript-type">extern</span> vm_map_t bsd_pageable_map;
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> fileops vnops;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">USER_ADDR_ALIGN</span>(addr, val) \
	( ( (user_addr_t)(addr) + (val) - 1) \
		&amp; ~((val) - 1) )

<span class="enscript-type">struct</span> image_params;	<span class="enscript-comment">/* Forward */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">exec_activate_image</span>(<span class="enscript-type">struct</span> image_params *imgp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">exec_copyout_strings</span>(<span class="enscript-type">struct</span> image_params *imgp, user_addr_t *stackp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">load_return_to_errno</span>(load_return_t lrtn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">execargs_alloc</span>(<span class="enscript-type">struct</span> image_params *imgp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">execargs_free</span>(<span class="enscript-type">struct</span> image_params *imgp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">exec_check_permissions</span>(<span class="enscript-type">struct</span> image_params *imgp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">exec_extract_strings</span>(<span class="enscript-type">struct</span> image_params *imgp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">exec_add_apple_strings</span>(<span class="enscript-type">struct</span> image_params *imgp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">exec_handle_sugid</span>(<span class="enscript-type">struct</span> image_params *imgp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sugid_scripts = 0;
<span class="enscript-function-name">SYSCTL_INT</span> (_kern, OID_AUTO, sugid_scripts, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;sugid_scripts, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-type">static</span> kern_return_t <span class="enscript-function-name">create_unix_stack</span>(vm_map_t map, load_result_t* load_result, proc_t p);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">copyoutptr</span>(user_addr_t ua, user_addr_t ptr, <span class="enscript-type">int</span> ptr_size);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">exec_resettextvp</span>(proc_t, <span class="enscript-type">struct</span> image_params *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">check_for_signature</span>(proc_t, <span class="enscript-type">struct</span> image_params *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">exec_prefault_data</span>(proc_t, <span class="enscript-type">struct</span> image_params *, load_result_t *);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">exec_handle_port_actions</span>(<span class="enscript-type">struct</span> image_params *imgp, <span class="enscript-type">short</span> psa_flags, boolean_t * portwatch_present, ipc_port_t * portwatch_ports);
<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">exec_handle_spawnattr_policy</span>(proc_t p, <span class="enscript-type">int</span> psa_apptype, uint64_t psa_qos_clamp, uint64_t psa_darwin_role,
                             ipc_port_t * portwatch_ports, <span class="enscript-type">int</span> portwatch_count);

<span class="enscript-comment">/*
 * exec_add_user_string
 *
 * Add the requested string to the string space area.
 *
 * Parameters;	struct image_params *		image parameter block
 *		user_addr_t			string to add to strings area
 *		int				segment from which string comes
 *		boolean_t			TRUE if string contributes to NCARGS
 *
 * Returns:	0			Success
 *		!0			Failure errno from copyinstr()
 *
 * Implicit returns:
 *		(imgp-&gt;ip_strendp)	updated location of next add, if any
 *		(imgp-&gt;ip_strspace)	updated byte count of space remaining
 *		(imgp-&gt;ip_argspace) updated byte count of space in NCARGS
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">exec_add_user_string</span>(<span class="enscript-type">struct</span> image_params *imgp, user_addr_t str, <span class="enscript-type">int</span> seg, boolean_t is_ncargs)
{
	<span class="enscript-type">int</span> error = 0;
	
	<span class="enscript-keyword">do</span> {
		size_t len = 0;
		<span class="enscript-type">int</span> space;
		
		<span class="enscript-keyword">if</span> (is_ncargs)
			space = imgp-&gt;ip_argspace; <span class="enscript-comment">/* by definition smaller than ip_strspace */</span>
		<span class="enscript-keyword">else</span>
			space = imgp-&gt;ip_strspace;
		
		<span class="enscript-keyword">if</span> (space &lt;= 0) {
			error = E2BIG;
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-keyword">if</span> (!UIO_SEG_IS_USER_SPACE(seg)) {
			<span class="enscript-type">char</span> *kstr = CAST_DOWN(<span class="enscript-type">char</span> *,str);	<span class="enscript-comment">/* SAFE */</span>
			error = copystr(kstr, imgp-&gt;ip_strendp, space, &amp;len);
		} <span class="enscript-keyword">else</span>  {
			error = copyinstr(str, imgp-&gt;ip_strendp, space, &amp;len);
		}

		imgp-&gt;ip_strendp += len;
		imgp-&gt;ip_strspace -= len;
		<span class="enscript-keyword">if</span> (is_ncargs)
			imgp-&gt;ip_argspace -= len;
		
	} <span class="enscript-keyword">while</span> (error == ENAMETOOLONG);
	
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * dyld is now passed the executable path as a getenv-like variable
 * in the same fashion as the stack_guard and malloc_entropy keys.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">EXECUTABLE_KEY</span> <span class="enscript-string">&quot;executable_path=&quot;</span>

<span class="enscript-comment">/*
 * exec_save_path
 *
 * To support new app package launching for Mac OS X, the dyld needs the
 * first argument to execve() stored on the user stack.
 *
 * Save the executable path name at the bottom of the strings area and set
 * the argument vector pointer to the location following that to indicate
 * the start of the argument and environment tuples, setting the remaining
 * string space count to the size of the string area minus the path length.
 *
 * Parameters;	struct image_params *		image parameter block
 *		char *				path used to invoke program
 *		int				segment from which path comes
 *
 * Returns:	int			0	Success
 *		EFAULT				Bad address
 *	copy[in]str:EFAULT			Bad address
 *	copy[in]str:ENAMETOOLONG		Filename too long
 *
 * Implicit returns:
 *		(imgp-&gt;ip_strings)		saved path
 *		(imgp-&gt;ip_strspace)		space remaining in ip_strings
 *		(imgp-&gt;ip_strendp)		start of remaining copy area
 *		(imgp-&gt;ip_argspace)		space remaining of NCARGS
 *		(imgp-&gt;ip_applec)		Initial applev[0]
 *
 * Note:	We have to do this before the initial namei() since in the
 *		path contains symbolic links, namei() will overwrite the
 *		original path buffer contents.  If the last symbolic link
 *		resolved was a relative pathname, we would lose the original
 *		&quot;path&quot;, which could be an absolute pathname. This might be
 *		unacceptable for dyld.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">exec_save_path</span>(<span class="enscript-type">struct</span> image_params *imgp, user_addr_t path, <span class="enscript-type">int</span> seg, <span class="enscript-type">const</span> <span class="enscript-type">char</span> **excpath)
{
	<span class="enscript-type">int</span> error;
	size_t len;
	<span class="enscript-type">char</span> *kpath;

	<span class="enscript-comment">// imgp-&gt;ip_strings can come out of a cache, so we need to obliterate the
</span>	<span class="enscript-comment">// old path.
</span>	memset(imgp-&gt;ip_strings, <span class="enscript-string">'\0'</span>, strlen(EXECUTABLE_KEY) + MAXPATHLEN);

	len = MIN(MAXPATHLEN, imgp-&gt;ip_strspace);

	<span class="enscript-keyword">switch</span>(seg) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_USERSPACE64</span>:	<span class="enscript-comment">/* Same for copyin()... */</span>
		error = copyinstr(path, imgp-&gt;ip_strings + strlen(EXECUTABLE_KEY), len, &amp;len);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">UIO_SYSSPACE</span>:
		kpath = CAST_DOWN(<span class="enscript-type">char</span> *,path);	<span class="enscript-comment">/* SAFE */</span>
		error = copystr(kpath, imgp-&gt;ip_strings + strlen(EXECUTABLE_KEY), len, &amp;len);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EFAULT;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (!error) {
		bcopy(EXECUTABLE_KEY, imgp-&gt;ip_strings, strlen(EXECUTABLE_KEY));
		len += strlen(EXECUTABLE_KEY);

		imgp-&gt;ip_strendp += len;
		imgp-&gt;ip_strspace -= len;

		<span class="enscript-keyword">if</span> (excpath) {
			*excpath = imgp-&gt;ip_strings + strlen(EXECUTABLE_KEY);
		}
	}

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * exec_reset_save_path
 *
 * If we detect a shell script, we need to reset the string area
 * state so that the interpreter can be saved onto the stack.

 * Parameters;	struct image_params *		image parameter block
 *
 * Returns:	int			0	Success
 *
 * Implicit returns:
 *		(imgp-&gt;ip_strings)		saved path
 *		(imgp-&gt;ip_strspace)		space remaining in ip_strings
 *		(imgp-&gt;ip_strendp)		start of remaining copy area
 *		(imgp-&gt;ip_argspace)		space remaining of NCARGS
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">exec_reset_save_path</span>(<span class="enscript-type">struct</span> image_params *imgp)
{
	imgp-&gt;ip_strendp = imgp-&gt;ip_strings;
	imgp-&gt;ip_argspace = NCARGS;
	imgp-&gt;ip_strspace = ( NCARGS + PAGE_SIZE );

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * exec_shell_imgact
 *
 * Image activator for interpreter scripts.  If the image begins with
 * the characters &quot;#!&quot;, then it is an interpreter script.  Verify the
 * length of the script line indicating the interpreter is not in
 * excess of the maximum allowed size.  If this is the case, then
 * break out the arguments, if any, which are separated by white
 * space, and copy them into the argument save area as if they were
 * provided on the command line before all other arguments.  The line
 * ends when we encounter a comment character ('#') or newline.
 *
 * Parameters;	struct image_params *	image parameter block
 *
 * Returns:	-1			not an interpreter (keep looking)
 *		-3			Success: interpreter: relookup
 *		&gt;0			Failure: interpreter: error number
 *
 * A return value other than -1 indicates subsequent image activators should
 * not be given the opportunity to attempt to activate the image.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">exec_shell_imgact</span>(<span class="enscript-type">struct</span> image_params *imgp)
{
	<span class="enscript-type">char</span> *vdata = imgp-&gt;ip_vdata;
	<span class="enscript-type">char</span> *ihp;
	<span class="enscript-type">char</span> *line_startp, *line_endp;
	<span class="enscript-type">char</span> *interp;
	proc_t p;
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">int</span> fd;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * Make sure it's a shell script.  If we've already redirected
	 * from an interpreted file once, don't do it again.
	 */</span>
	<span class="enscript-keyword">if</span> (vdata[0] != <span class="enscript-string">'#'</span> ||
	    vdata[1] != <span class="enscript-string">'!'</span> ||
	    (imgp-&gt;ip_flags &amp; IMGPF_INTERPRET) != 0) {
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-keyword">if</span> (imgp-&gt;ip_origcputype != 0) {
		<span class="enscript-comment">/* Fat header previously matched, don't allow shell script inside */</span>
		<span class="enscript-keyword">return</span> (-1);
	}

	imgp-&gt;ip_flags |= IMGPF_INTERPRET;
	imgp-&gt;ip_interp_sugid_fd = -1;
	imgp-&gt;ip_interp_buffer[0] = <span class="enscript-string">'\0'</span>;

	<span class="enscript-comment">/* Check to see if SUGID scripts are permitted.  If they aren't then
	 * clear the SUGID bits.
	 * imgp-&gt;ip_vattr is known to be valid.
	 */</span>
	<span class="enscript-keyword">if</span> (sugid_scripts == 0) {
		imgp-&gt;ip_origvattr-&gt;va_mode &amp;= ~(VSUID | VSGID);
	}

	<span class="enscript-comment">/* Try to find the first non-whitespace character */</span>
	<span class="enscript-keyword">for</span>( ihp = &amp;vdata[2]; ihp &lt; &amp;vdata[IMG_SHSIZE]; ihp++ ) {
		<span class="enscript-keyword">if</span> (IS_EOL(*ihp)) {
			<span class="enscript-comment">/* Did not find interpreter, &quot;#!\n&quot; */</span>
			<span class="enscript-keyword">return</span> (ENOEXEC);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (IS_WHITESPACE(*ihp)) {
			<span class="enscript-comment">/* Whitespace, like &quot;#!    /bin/sh\n&quot;, keep going. */</span>
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Found start of interpreter */</span>
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (ihp == &amp;vdata[IMG_SHSIZE]) {
		<span class="enscript-comment">/* All whitespace, like &quot;#!           &quot; */</span>
		<span class="enscript-keyword">return</span> (ENOEXEC);
	}

	line_startp = ihp;

	<span class="enscript-comment">/* Try to find the end of the interpreter+args string */</span>
	<span class="enscript-keyword">for</span> ( ; ihp &lt; &amp;vdata[IMG_SHSIZE]; ihp++ ) {
		<span class="enscript-keyword">if</span> (IS_EOL(*ihp)) {
			<span class="enscript-comment">/* Got it */</span>
			<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Still part of interpreter or args */</span>
		}
	}

	<span class="enscript-keyword">if</span> (ihp == &amp;vdata[IMG_SHSIZE]) {
		<span class="enscript-comment">/* A long line, like &quot;#! blah blah blah&quot; without end */</span>
		<span class="enscript-keyword">return</span> (ENOEXEC);
	}

	<span class="enscript-comment">/* Backtrack until we find the last non-whitespace */</span>
	<span class="enscript-keyword">while</span> (IS_EOL(*ihp) || IS_WHITESPACE(*ihp)) {
		ihp--;
	}

	<span class="enscript-comment">/* The character after the last non-whitespace is our logical end of line */</span>
	line_endp = ihp + 1;

	<span class="enscript-comment">/*
	 * Now we have pointers to the usable part of:
	 *
	 * &quot;#!  /usr/bin/int first    second   third    \n&quot;
	 *      ^ line_startp                       ^ line_endp
	 */</span>

	<span class="enscript-comment">/* copy the interpreter name */</span>
	interp = imgp-&gt;ip_interp_buffer;
	<span class="enscript-keyword">for</span> ( ihp = line_startp; (ihp &lt; line_endp) &amp;&amp; !IS_WHITESPACE(*ihp); ihp++)
		*interp++ = *ihp;
	*interp = <span class="enscript-string">'\0'</span>;

	exec_reset_save_path(imgp);
	exec_save_path(imgp, CAST_USER_ADDR_T(imgp-&gt;ip_interp_buffer),
							UIO_SYSSPACE, NULL);

	<span class="enscript-comment">/* Copy the entire interpreter + args for later processing into argv[] */</span>
	interp = imgp-&gt;ip_interp_buffer;
	<span class="enscript-keyword">for</span> ( ihp = line_startp; (ihp &lt; line_endp); ihp++)
		*interp++ = *ihp;
	*interp = <span class="enscript-string">'\0'</span>;

	<span class="enscript-comment">/*
	 * If we have a SUID oder SGID script, create a file descriptor
	 * from the vnode and pass /dev/fd/%d instead of the actual
	 * path name so that the script does not get opened twice
	 */</span>
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_origvattr-&gt;va_mode &amp; (VSUID | VSGID)) {
		p = vfs_context_proc(imgp-&gt;ip_vfs_context);
		error = falloc(p, &amp;fp, &amp;fd, imgp-&gt;ip_vfs_context);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span>(error);

		fp-&gt;f_fglob-&gt;fg_flag = FREAD;
		fp-&gt;f_fglob-&gt;fg_ops = &amp;vnops;
		fp-&gt;f_fglob-&gt;fg_data = (caddr_t)imgp-&gt;ip_vp;
		
		proc_fdlock(p);
		procfdtbl_releasefd(p, fd, NULL);
		fp_drop(p, fd, fp, 1);
		proc_fdunlock(p);
		vnode_ref(imgp-&gt;ip_vp);

		imgp-&gt;ip_interp_sugid_fd = fd;
	}

	<span class="enscript-keyword">return</span> (-3);
}



<span class="enscript-comment">/*
 * exec_fat_imgact
 *
 * Image activator for fat 1.0 binaries.  If the binary is fat, then we
 * need to select an image from it internally, and make that the image
 * we are going to attempt to execute.  At present, this consists of
 * reloading the first page for the image with a first page from the
 * offset location indicated by the fat header.
 *
 * Parameters;	struct image_params *	image parameter block
 *
 * Returns:	-1			not a fat binary (keep looking)
 *		-2			Success: encapsulated binary: reread
 *		&gt;0			Failure: error number
 *
 * Important:	This image activator is byte order neutral.
 *
 * Note:	A return value other than -1 indicates subsequent image
 *		activators should not be given the opportunity to attempt
 *		to activate the image.
 *
 * 		If we find an encapsulated binary, we make no assertions
 *		about its  validity; instead, we leave that up to a rescan
 *		for an activator to claim it, and, if it is claimed by one,
 *		that activator is responsible for determining validity.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">exec_fat_imgact</span>(<span class="enscript-type">struct</span> image_params *imgp)
{
	proc_t p = vfs_context_proc(imgp-&gt;ip_vfs_context);
	kauth_cred_t cred = kauth_cred_proc_ref(p);
	<span class="enscript-type">struct</span> fat_header *fat_header = (<span class="enscript-type">struct</span> fat_header *)imgp-&gt;ip_vdata;
	<span class="enscript-type">struct</span> _posix_spawnattr *psa = NULL;
	<span class="enscript-type">struct</span> fat_arch fat_arch;
	<span class="enscript-type">int</span> resid, error;
	load_return_t lret;

	<span class="enscript-keyword">if</span> (imgp-&gt;ip_origcputype != 0) {
		<span class="enscript-comment">/* Fat header previously matched, don't allow another fat file inside */</span>
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-comment">/* Make sure it's a fat binary */</span>
	<span class="enscript-keyword">if</span> (OSSwapBigToHostInt32(fat_header-&gt;magic) != FAT_MAGIC) {
		error = -1; <span class="enscript-comment">/* not claimed */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* imgp-&gt;ip_vdata has PAGE_SIZE, zerofilled if the file is smaller */</span>
	lret = fatfile_validate_fatarches((vm_offset_t)fat_header, PAGE_SIZE);
	<span class="enscript-keyword">if</span> (lret != LOAD_SUCCESS) {
		error = load_return_to_errno(lret);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* If posix_spawn binprefs exist, respect those prefs. */</span>
	psa = (<span class="enscript-type">struct</span> _posix_spawnattr *) imgp-&gt;ip_px_sa;
	<span class="enscript-keyword">if</span> (psa != NULL &amp;&amp; psa-&gt;psa_binprefs[0] != 0) {
		uint32_t pr = 0;

		<span class="enscript-comment">/* Check each preference listed against all arches in header */</span>
		<span class="enscript-keyword">for</span> (pr = 0; pr &lt; NBINPREFS; pr++) {
			cpu_type_t pref = psa-&gt;psa_binprefs[pr];
			<span class="enscript-keyword">if</span> (pref == 0) {
				<span class="enscript-comment">/* No suitable arch in the pref list */</span>
				error = EBADARCH;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}

			<span class="enscript-keyword">if</span> (pref == CPU_TYPE_ANY) {
				<span class="enscript-comment">/* Fall through to regular grading */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">regular_grading</span>;
			}

			lret = fatfile_getbestarch_for_cputype(pref,
							(vm_offset_t)fat_header,
							PAGE_SIZE,
							&amp;fat_arch);
			<span class="enscript-keyword">if</span> (lret == LOAD_SUCCESS) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">use_arch</span>;
			}
		}

		<span class="enscript-comment">/* Requested binary preference was not honored */</span>
		error = EBADEXEC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

<span class="enscript-reference">regular_grading</span>:
	<span class="enscript-comment">/* Look up our preferred architecture in the fat file. */</span>
	lret = fatfile_getbestarch((vm_offset_t)fat_header,
				PAGE_SIZE,
				&amp;fat_arch);
	<span class="enscript-keyword">if</span> (lret != LOAD_SUCCESS) {
		error = load_return_to_errno(lret);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

<span class="enscript-reference">use_arch</span>:
	<span class="enscript-comment">/* Read the Mach-O header out of fat_arch */</span>
	error = vn_rdwr(UIO_READ, imgp-&gt;ip_vp, imgp-&gt;ip_vdata,
			PAGE_SIZE, fat_arch.offset,
			UIO_SYSSPACE, (IO_UNIT|IO_NODELOCKED),
			cred, &amp;resid, p);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> (resid) {
		memset(imgp-&gt;ip_vdata + (PAGE_SIZE - resid), 0x0, resid);
	}

	<span class="enscript-comment">/* Success.  Indicate we have identified an encapsulated binary */</span>
	error = -2;
	imgp-&gt;ip_arch_offset = (user_size_t)fat_arch.offset;
	imgp-&gt;ip_arch_size = (user_size_t)fat_arch.size;
	imgp-&gt;ip_origcputype = fat_arch.cputype;
	imgp-&gt;ip_origcpusubtype = fat_arch.cpusubtype;

<span class="enscript-reference">bad</span>:
	kauth_cred_unref(&amp;cred);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * exec_mach_imgact
 *
 * Image activator for mach-o 1.0 binaries.
 *
 * Parameters;	struct image_params *	image parameter block
 *
 * Returns:	-1			not a fat binary (keep looking)
 *		-2			Success: encapsulated binary: reread
 *		&gt;0			Failure: error number
 *		EBADARCH		Mach-o binary, but with an unrecognized
 *					architecture
 *		ENOMEM			No memory for child process after -
 *					can only happen after vfork()
 *
 * Important:	This image activator is NOT byte order neutral.
 *
 * Note:	A return value other than -1 indicates subsequent image
 *		activators should not be given the opportunity to attempt
 *		to activate the image.
 *
 * TODO:	More gracefully handle failures after vfork
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">exec_mach_imgact</span>(<span class="enscript-type">struct</span> image_params *imgp)
{
	<span class="enscript-type">struct</span> mach_header *mach_header = (<span class="enscript-type">struct</span> mach_header *)imgp-&gt;ip_vdata;
	proc_t			p = vfs_context_proc(imgp-&gt;ip_vfs_context);
	<span class="enscript-type">int</span>			error = 0;
	task_t			task;
	task_t			new_task = NULL; <span class="enscript-comment">/* protected by vfexec */</span>
	thread_t		thread;
	<span class="enscript-type">struct</span> uthread		*uthread;
	vm_map_t old_map = VM_MAP_NULL;
	vm_map_t map;
	load_return_t		lret;
	load_result_t		load_result;
	<span class="enscript-type">struct</span> _posix_spawnattr *psa = NULL;
	<span class="enscript-type">int</span>			spawn = (imgp-&gt;ip_flags &amp; IMGPF_SPAWN);
	<span class="enscript-type">int</span>			vfexec = (imgp-&gt;ip_flags &amp; IMGPF_VFORK_EXEC);
	<span class="enscript-type">int</span>			p_name_len;

	<span class="enscript-comment">/*
	 * make sure it's a Mach-O 1.0 or Mach-O 2.0 binary; the difference
	 * is a reserved field on the end, so for the most part, we can
	 * treat them as if they were identical. Reverse-endian Mach-O
	 * binaries are recognized but not compatible.
 	 */</span>
	<span class="enscript-keyword">if</span> ((mach_header-&gt;magic == MH_CIGAM) ||
	    (mach_header-&gt;magic == MH_CIGAM_64)) {
		error = EBADARCH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> ((mach_header-&gt;magic != MH_MAGIC) &amp;&amp;
	    (mach_header-&gt;magic != MH_MAGIC_64)) {
		error = -1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> (mach_header-&gt;filetype != MH_EXECUTE) {
		error = -1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> (imgp-&gt;ip_origcputype != 0) {
		<span class="enscript-comment">/* Fat header previously had an idea about this thin file */</span>
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_origcputype != mach_header-&gt;cputype ||
			imgp-&gt;ip_origcpusubtype != mach_header-&gt;cpusubtype) {
			error = EBADARCH;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	} <span class="enscript-keyword">else</span> {
		imgp-&gt;ip_origcputype = mach_header-&gt;cputype;
		imgp-&gt;ip_origcpusubtype = mach_header-&gt;cpusubtype;
	}

	task = current_task();
	thread = current_thread();
	uthread = get_bsdthread_info(thread);

	<span class="enscript-keyword">if</span> ((mach_header-&gt;cputype &amp; CPU_ARCH_ABI64) == CPU_ARCH_ABI64)
		imgp-&gt;ip_flags |= IMGPF_IS_64BIT;

	<span class="enscript-comment">/* If posix_spawn binprefs exist, respect those prefs. */</span>
	psa = (<span class="enscript-type">struct</span> _posix_spawnattr *) imgp-&gt;ip_px_sa;
	<span class="enscript-keyword">if</span> (psa != NULL &amp;&amp; psa-&gt;psa_binprefs[0] != 0) {
		<span class="enscript-type">int</span> pr = 0;
		<span class="enscript-keyword">for</span> (pr = 0; pr &lt; NBINPREFS; pr++) {
			cpu_type_t pref = psa-&gt;psa_binprefs[pr];
			<span class="enscript-keyword">if</span> (pref == 0) {
				<span class="enscript-comment">/* No suitable arch in the pref list */</span>
				error = EBADARCH;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}

			<span class="enscript-keyword">if</span> (pref == CPU_TYPE_ANY) {
				<span class="enscript-comment">/* Jump to regular grading */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">grade</span>;
			}

			<span class="enscript-keyword">if</span> (pref == imgp-&gt;ip_origcputype) {
				<span class="enscript-comment">/* We have a match! */</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">grade</span>;
			}
		}
		error = EBADARCH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
<span class="enscript-reference">grade</span>:
	<span class="enscript-keyword">if</span> (!grade_binary(imgp-&gt;ip_origcputype, imgp-&gt;ip_origcpusubtype &amp; ~CPU_SUBTYPE_MASK)) {
		error = EBADARCH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* Copy in arguments/environment from the old process */</span>
	error = exec_extract_strings(imgp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	error = exec_add_apple_strings(imgp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	AUDIT_ARG(argv, imgp-&gt;ip_startargv, imgp-&gt;ip_argc, 
	    imgp-&gt;ip_endargv - imgp-&gt;ip_startargv);
	AUDIT_ARG(envv, imgp-&gt;ip_endargv, imgp-&gt;ip_envc,
	    imgp-&gt;ip_endenvv - imgp-&gt;ip_endargv);

	<span class="enscript-comment">/*
	 * We are being called to activate an image subsequent to a vfork()
	 * operation; in this case, we know that our task, thread, and
	 * uthread are actually those of our parent, and our proc, which we
	 * obtained indirectly from the image_params vfs_context_t, is the
	 * new child process.
	 */</span>
	<span class="enscript-keyword">if</span> (vfexec || spawn) {
		<span class="enscript-keyword">if</span> (vfexec) {
			imgp-&gt;ip_new_thread = fork_create_child(task, NULL, p, FALSE, (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT));
			<span class="enscript-keyword">if</span> (imgp-&gt;ip_new_thread == NULL) {
				error = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
		}

		<span class="enscript-comment">/* reset local idea of thread, uthread, task */</span>
		thread = imgp-&gt;ip_new_thread;
		uthread = get_bsdthread_info(thread);
		task = new_task = get_threadtask(thread);
		map = get_task_map(task);
	} <span class="enscript-keyword">else</span> {
		map = VM_MAP_NULL;
	}

	<span class="enscript-comment">/*
	 * We set these flags here; this is OK, since if we fail after
	 * this point, we have already destroyed the parent process anyway.
	 */</span>
	task_set_dyld_info(task, MACH_VM_MIN_ADDRESS, 0);
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) {
		task_set_64bit(task, TRUE);
		OSBitOrAtomic(P_LP64, &amp;p-&gt;p_flag);
	} <span class="enscript-keyword">else</span> {
		task_set_64bit(task, FALSE);
		OSBitAndAtomic(~((uint32_t)P_LP64), &amp;p-&gt;p_flag);
	}

	<span class="enscript-comment">/*
	 *	Load the Mach-O file.
	 *
	 * NOTE: An error after this point  indicates we have potentially
	 * destroyed or overwritten some process state while attempting an
	 * execve() following a vfork(), which is an unrecoverable condition.
	 * We send the new process an immediate SIGKILL to avoid it executing
	 * any instructions in the mutated address space. For true spawns,
	 * this is not the case, and &quot;too late&quot; is still not too late to
	 * return an error code to the parent process.
	 */</span>

	<span class="enscript-comment">/*
	 * Actually load the image file we previously decided to load.
	 */</span>
	lret = load_machfile(imgp, mach_header, thread, map, &amp;load_result);

	<span class="enscript-keyword">if</span> (lret != LOAD_SUCCESS) {
		error = load_return_to_errno(lret);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">badtoolate</span>;
	}

	proc_lock(p);
	p-&gt;p_cputype = imgp-&gt;ip_origcputype;
	p-&gt;p_cpusubtype = imgp-&gt;ip_origcpusubtype;
	proc_unlock(p);

	vm_map_set_user_wire_limit(get_task_map(task), p-&gt;p_rlimit[RLIMIT_MEMLOCK].rlim_cur);

	<span class="enscript-comment">/* 
	 * Set code-signing flags if this binary is signed, or if parent has
	 * requested them on exec.
	 */</span>
	<span class="enscript-keyword">if</span> (load_result.csflags &amp; CS_VALID) {
		imgp-&gt;ip_csflags |= load_result.csflags &amp; 
			(CS_VALID|
			 CS_HARD|CS_KILL|CS_RESTRICT|CS_ENFORCEMENT|CS_REQUIRE_LV|CS_DYLD_PLATFORM|
			 CS_EXEC_SET_HARD|CS_EXEC_SET_KILL|CS_EXEC_SET_ENFORCEMENT);
	} <span class="enscript-keyword">else</span> {
		imgp-&gt;ip_csflags &amp;= ~CS_VALID;
	}

	<span class="enscript-keyword">if</span> (p-&gt;p_csflags &amp; CS_EXEC_SET_HARD)
		imgp-&gt;ip_csflags |= CS_HARD;
	<span class="enscript-keyword">if</span> (p-&gt;p_csflags &amp; CS_EXEC_SET_KILL)
		imgp-&gt;ip_csflags |= CS_KILL;
	<span class="enscript-keyword">if</span> (p-&gt;p_csflags &amp; CS_EXEC_SET_ENFORCEMENT)
		imgp-&gt;ip_csflags |= CS_ENFORCEMENT;
	<span class="enscript-keyword">if</span> (p-&gt;p_csflags &amp; CS_EXEC_SET_INSTALLER)
		imgp-&gt;ip_csflags |= CS_INSTALLER;


	<span class="enscript-comment">/*
	 * Set up the system reserved areas in the new address space.
	 */</span>
	vm_map_exec(get_task_map(task),
		    task,
		    (<span class="enscript-type">void</span> *) p-&gt;p_fd-&gt;fd_rdir,
		    cpu_type());
	
	<span class="enscript-comment">/*
	 * Close file descriptors which specify close-on-exec.
	 */</span>
	fdexec(p, psa != NULL ? psa-&gt;psa_flags : 0);

	<span class="enscript-comment">/*
	 * deal with set[ug]id.
	 */</span>
	error = exec_handle_sugid(imgp);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">badtoolate</span>;
	}	

	<span class="enscript-comment">/*
	 * deal with voucher on exec-calling thread.
	 */</span>
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_new_thread == NULL)
		thread_set_mach_voucher(current_thread(), IPC_VOUCHER_NULL);

	<span class="enscript-comment">/* Make sure we won't interrupt ourself signalling a partial process */</span>
	<span class="enscript-keyword">if</span> (!vfexec &amp;&amp; !spawn &amp;&amp; (p-&gt;p_lflag &amp; P_LTRACED))
		psignal(p, SIGTRAP);

	<span class="enscript-keyword">if</span> (load_result.unixproc &amp;&amp;
		create_unix_stack(get_task_map(task),
				  &amp;load_result,
				  p) != KERN_SUCCESS) {
		error = load_return_to_errno(LOAD_NOSPACE);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">badtoolate</span>;
	}

	<span class="enscript-keyword">if</span> (vfexec || spawn) {
		old_map = vm_map_switch(get_task_map(task));
	}

	<span class="enscript-keyword">if</span> (load_result.unixproc) {
		user_addr_t	ap;

		<span class="enscript-comment">/*
		 * Copy the strings area out into the new process address
		 * space.
		 */</span>
		ap = p-&gt;user_stack;
		error = exec_copyout_strings(imgp, &amp;ap);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (vfexec || spawn)
				vm_map_switch(old_map);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badtoolate</span>;
		}
		<span class="enscript-comment">/* Set the stack */</span>
		thread_setuserstack(thread, ap);
	}
	
	<span class="enscript-keyword">if</span> (load_result.dynlinker) {
		uint64_t	ap;
		<span class="enscript-type">int</span>			new_ptr_size = (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) ? 8 : 4;

		<span class="enscript-comment">/* Adjust the stack */</span>
		ap = thread_adjuserstack(thread, -new_ptr_size);
		error = copyoutptr(load_result.mach_header, ap, new_ptr_size);

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (vfexec || spawn)
				vm_map_switch(old_map);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">badtoolate</span>;
		}
		task_set_dyld_info(task, load_result.all_image_info_addr,
		    load_result.all_image_info_size);
	}

	<span class="enscript-comment">/* Avoid immediate VM faults back into kernel */</span>
	exec_prefault_data(p, imgp, &amp;load_result);

	<span class="enscript-keyword">if</span> (vfexec || spawn) {
		vm_map_switch(old_map);
	}
	<span class="enscript-comment">/* Set the entry point */</span>
	thread_setentrypoint(thread, load_result.entry_point);

	<span class="enscript-comment">/* Stop profiling */</span>
	stopprofclock(p);

	<span class="enscript-comment">/*
	 * Reset signal state.
	 */</span>
	execsigs(p, thread);

	<span class="enscript-comment">/*
	 * need to cancel async IO requests that can be cancelled and wait for those
	 * already active.  MAY BLOCK!
	 */</span>
	_aio_exec( p );

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SYSV_SHM</span>
	<span class="enscript-comment">/* FIXME: Till vmspace inherit is fixed: */</span>
	<span class="enscript-keyword">if</span> (!vfexec &amp;&amp; p-&gt;vm_shm)
		shmexec(p);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SYSV_SEM</span>
	<span class="enscript-comment">/* Clean up the semaphores */</span>
	semexit(p);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Remember file name for accounting.
	 */</span>
	p-&gt;p_acflag &amp;= ~AFORK;

	<span class="enscript-comment">/*
	 * Set p-&gt;p_comm and p-&gt;p_name to the name passed to exec
	 */</span>
	p_name_len = <span class="enscript-keyword">sizeof</span>(p-&gt;p_name) - 1;
	<span class="enscript-keyword">if</span>(imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen &gt; p_name_len)
		imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen = p_name_len;
	bcopy((caddr_t)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_nameptr, (caddr_t)p-&gt;p_name,
		(<span class="enscript-type">unsigned</span>)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen);
	p-&gt;p_name[imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen] = <span class="enscript-string">'\0'</span>;

	<span class="enscript-keyword">if</span> (imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen &gt; MAXCOMLEN)
		imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen = MAXCOMLEN;
	bcopy((caddr_t)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_nameptr, (caddr_t)p-&gt;p_comm,
		(<span class="enscript-type">unsigned</span>)imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen);
	p-&gt;p_comm[imgp-&gt;ip_ndp-&gt;ni_cnd.cn_namelen] = <span class="enscript-string">'\0'</span>;

	pal_dbg_set_task_name( p-&gt;task );

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-comment">/* 
	 * Update the pid an proc name for importance base if any
	 */</span>
	task_importance_update_owner_info(p-&gt;task);
#<span class="enscript-reference">endif</span>

	memcpy(&amp;p-&gt;p_uuid[0], &amp;load_result.uuid[0], <span class="enscript-keyword">sizeof</span>(p-&gt;p_uuid));

<span class="enscript-comment">// &lt;rdar://6598155&gt; dtrace code cleanup needed
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-comment">/*
	 * Invalidate any predicate evaluation already cached for this thread by DTrace.
	 * That's because we've just stored to p_comm and DTrace refers to that when it
	 * evaluates the &quot;execname&quot; special variable. uid and gid may have changed as well.
	 */</span>
	dtrace_set_thread_predcache(current_thread(), 0);

	<span class="enscript-comment">/*
	 * Free any outstanding lazy dof entries. It is imperative we
	 * always call dtrace_lazy_dofs_destroy, rather than null check
	 * and call if !NULL. If we NULL test, during lazy dof faulting
	 * we can race with the faulting code and proceed from here to
	 * beyond the helpers cleanup. The lazy dof faulting will then
	 * install new helpers which no longer belong to this process!
	 */</span>
	dtrace_lazy_dofs_destroy(p);


	<span class="enscript-comment">/*
    	 * Clean up any DTrace helpers for the process.
    	 */</span>
    	<span class="enscript-keyword">if</span> (p-&gt;p_dtrace_helpers != NULL &amp;&amp; dtrace_helpers_cleanup) {
    		(*dtrace_helpers_cleanup)(p);
    	}
	
    	<span class="enscript-comment">/*
    	 * Cleanup the DTrace provider associated with this process.
    	 */</span>
	proc_lock(p);
	<span class="enscript-keyword">if</span> (p-&gt;p_dtrace_probes &amp;&amp; dtrace_fasttrap_exec_ptr) {
		(*dtrace_fasttrap_exec_ptr)(p);
	}
	proc_unlock(p);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (kdebug_enable) {
		<span class="enscript-type">long</span> dbg_arg1, dbg_arg2, dbg_arg3, dbg_arg4;

		<span class="enscript-comment">/*
		 * Collect the pathname for tracing
		 */</span>
		kdbg_trace_string(p, &amp;dbg_arg1, &amp;dbg_arg2, &amp;dbg_arg3, &amp;dbg_arg4);

		<span class="enscript-keyword">if</span> (vfexec || spawn) {
			KERNEL_DEBUG_CONSTANT1(TRACE_DATA_EXEC | DBG_FUNC_NONE,
					p-&gt;p_pid ,0,0,0, (uintptr_t)thread_tid(thread));
			KERNEL_DEBUG_CONSTANT1(TRACE_STRING_EXEC | DBG_FUNC_NONE,
					dbg_arg1, dbg_arg2, dbg_arg3, dbg_arg4, (uintptr_t)thread_tid(thread));
		} <span class="enscript-keyword">else</span> {
			KERNEL_DEBUG_CONSTANT(TRACE_DATA_EXEC | DBG_FUNC_NONE,
					p-&gt;p_pid ,0,0,0,0);
			KERNEL_DEBUG_CONSTANT(TRACE_STRING_EXEC | DBG_FUNC_NONE,
					dbg_arg1, dbg_arg2, dbg_arg3, dbg_arg4, 0);
		}
	}

	<span class="enscript-comment">/*
	 * If posix_spawned with the START_SUSPENDED flag, stop the
	 * process before it runs.
	 */</span>
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_px_sa != NULL) {
		psa = (<span class="enscript-type">struct</span> _posix_spawnattr *) imgp-&gt;ip_px_sa;
		<span class="enscript-keyword">if</span> (psa-&gt;psa_flags &amp; POSIX_SPAWN_START_SUSPENDED) {
			proc_lock(p);
			p-&gt;p_stat = SSTOP;
			proc_unlock(p);
			(<span class="enscript-type">void</span>) task_suspend_internal(p-&gt;task);
		}
	}

	<span class="enscript-comment">/*
	 * mark as execed, wakeup the process that vforked (if any) and tell
	 * it that it now has its own resources back
	 */</span>
	OSBitOrAtomic(P_EXEC, &amp;p-&gt;p_flag);
	proc_resetregister(p);
	<span class="enscript-keyword">if</span> (p-&gt;p_pptr &amp;&amp; (p-&gt;p_lflag &amp; P_LPPWAIT)) {
		proc_lock(p);
		p-&gt;p_lflag &amp;= ~P_LPPWAIT;
		proc_unlock(p);
		wakeup((caddr_t)p-&gt;p_pptr);
	}

	<span class="enscript-comment">/*
	 * Pay for our earlier safety; deliver the delayed signals from
	 * the incomplete vfexec process now that it's complete.
	 */</span>
	<span class="enscript-keyword">if</span> (vfexec &amp;&amp; (p-&gt;p_lflag &amp; P_LTRACED)) {
		psignal_vfork(p, new_task, thread, SIGTRAP);
	}

	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

<span class="enscript-reference">badtoolate</span>:
	<span class="enscript-comment">/* Don't allow child process to execute any instructions */</span>
	<span class="enscript-keyword">if</span> (!spawn) {
		<span class="enscript-keyword">if</span> (vfexec) {
			psignal_vfork(p, new_task, thread, SIGKILL);
		} <span class="enscript-keyword">else</span> {
			psignal(p, SIGKILL);
		}

		<span class="enscript-comment">/* We can't stop this system call at this point, so just pretend we succeeded */</span>
		error = 0;
	}
	
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (!spawn) {
		<span class="enscript-comment">/* notify only if it has not failed due to FP Key error */</span>
		<span class="enscript-keyword">if</span> ((p-&gt;p_lflag &amp; P_LTERM_DECRYPTFAIL) == 0)
			proc_knote(p, NOTE_EXEC);
	}

	<span class="enscript-comment">/* Drop extra references for cases where we don't expect the caller to clean up */</span>
	<span class="enscript-keyword">if</span> (vfexec || (spawn &amp;&amp; error == 0)) {
		task_deallocate(new_task);
		thread_deallocate(thread);
	}

<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">return</span>(error);
}




<span class="enscript-comment">/*
 * Our image activator table; this is the table of the image types we are
 * capable of loading.  We list them in order of preference to ensure the
 * fastest image load speed.
 *
 * XXX hardcoded, for now; should use linker sets
 */</span>
<span class="enscript-type">struct</span> execsw {
	<span class="enscript-type">int</span> (*ex_imgact)(<span class="enscript-type">struct</span> image_params *);
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *ex_name;
} execsw[] = {
	{ exec_mach_imgact,		<span class="enscript-string">&quot;Mach-o Binary&quot;</span> },
	{ exec_fat_imgact,		<span class="enscript-string">&quot;Fat Binary&quot;</span> },
	{ exec_shell_imgact,		<span class="enscript-string">&quot;Interpreter Script&quot;</span> },
	{ NULL, NULL}
};


<span class="enscript-comment">/*
 * exec_activate_image
 *
 * Description:	Iterate through the available image activators, and activate
 *		the image associated with the imgp structure.  We start with
 *		the
 *
 * Parameters:	struct image_params *	Image parameter block
 *
 * Returns:	0			Success
 *		EBADEXEC		The executable is corrupt/unknown
 *	execargs_alloc:EINVAL		Invalid argument
 *	execargs_alloc:EACCES		Permission denied
 *	execargs_alloc:EINTR		Interrupted function
 *	execargs_alloc:ENOMEM		Not enough space
 *	exec_save_path:EFAULT		Bad address
 *	exec_save_path:ENAMETOOLONG	Filename too long
 *	exec_check_permissions:EACCES	Permission denied
 *	exec_check_permissions:ENOEXEC	Executable file format error
 *	exec_check_permissions:ETXTBSY	Text file busy [misuse of error code]
 *	exec_check_permissions:???
 *	namei:???
 *	vn_rdwr:???			[anything vn_rdwr can return]
 *	&lt;ex_imgact&gt;:???			[anything an imgact can return]
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">exec_activate_image</span>(<span class="enscript-type">struct</span> image_params *imgp)
{
	<span class="enscript-type">struct</span> nameidata *ndp = NULL;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *excpath;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> resid;
	<span class="enscript-type">int</span> once = 1;	<span class="enscript-comment">/* save SGUID-ness for interpreted files */</span>
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> itercount = 0;
	proc_t p = vfs_context_proc(imgp-&gt;ip_vfs_context);

	error = execargs_alloc(imgp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_notrans</span>;
	
	error = exec_save_path(imgp, imgp-&gt;ip_user_fname, imgp-&gt;ip_seg, &amp;excpath);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_notrans</span>;
	}

	<span class="enscript-comment">/* Use excpath, which contains the copyin-ed exec path */</span>
	DTRACE_PROC1(exec, uintptr_t, excpath);

	MALLOC(ndp, <span class="enscript-type">struct</span> nameidata *, <span class="enscript-keyword">sizeof</span>(*ndp), M_TEMP, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (ndp == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_notrans</span>;
	}

	NDINIT(ndp, LOOKUP, OP_LOOKUP, FOLLOW | LOCKLEAF | AUDITVNPATH1,
		   UIO_SYSSPACE, CAST_USER_ADDR_T(excpath), imgp-&gt;ip_vfs_context);

<span class="enscript-reference">again</span>:
	error = namei(ndp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_notrans</span>;
	imgp-&gt;ip_ndp = ndp;	<span class="enscript-comment">/* successful namei(); call nameidone() later */</span>
	imgp-&gt;ip_vp = ndp-&gt;ni_vp;	<span class="enscript-comment">/* if set, need to vnode_put() at some point */</span>

	<span class="enscript-comment">/*
	 * Before we start the transition from binary A to binary B, make
	 * sure another thread hasn't started exiting the process.  We grab
	 * the proc lock to check p_lflag initially, and the transition
	 * mechanism ensures that the value doesn't change after we release
	 * the lock.
	 */</span>
	proc_lock(p);
	<span class="enscript-keyword">if</span> (p-&gt;p_lflag &amp; P_LEXIT) {
		proc_unlock(p);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_notrans</span>;
	}
	error = proc_transstart(p, 1, 0);
	proc_unlock(p);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_notrans</span>;

	error = exec_check_permissions(imgp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-comment">/* Copy; avoid invocation of an interpreter overwriting the original */</span>
	<span class="enscript-keyword">if</span> (once) {
		once = 0;
		*imgp-&gt;ip_origvattr = *imgp-&gt;ip_vattr;
	}

	error = vn_rdwr(UIO_READ, imgp-&gt;ip_vp, imgp-&gt;ip_vdata, PAGE_SIZE, 0,
			UIO_SYSSPACE, IO_NODELOCKED,
			vfs_context_ucred(imgp-&gt;ip_vfs_context),
			&amp;resid, vfs_context_proc(imgp-&gt;ip_vfs_context));
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (resid) {
		memset(imgp-&gt;ip_vdata + (PAGE_SIZE - resid), 0x0, resid);
	}

<span class="enscript-reference">encapsulated_binary</span>:
	<span class="enscript-comment">/* Limit the number of iterations we will attempt on each binary */</span>
	<span class="enscript-keyword">if</span> (++itercount &gt; EAI_ITERLIMIT) {
		error = EBADEXEC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	error = -1;
	<span class="enscript-keyword">for</span>(i = 0; error == -1 &amp;&amp; execsw[i].ex_imgact != NULL; i++) {

		error = (*execsw[i].ex_imgact)(imgp);

		<span class="enscript-keyword">switch</span> (error) {
		<span class="enscript-comment">/* case -1: not claimed: continue */</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">-2</span>:		<span class="enscript-comment">/* Encapsulated binary, imgp-&gt;ip_XXX set for next iteration */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">encapsulated_binary</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">-3</span>:		<span class="enscript-comment">/* Interpreter */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
			<span class="enscript-comment">/*
			 * Copy the script label for later use. Note that
			 * the label can be different when the script is
			 * actually read by the interpreter.
			 */</span>
			<span class="enscript-keyword">if</span> (imgp-&gt;ip_scriptlabelp)
				mac_vnode_label_free(imgp-&gt;ip_scriptlabelp);
			imgp-&gt;ip_scriptlabelp = mac_vnode_label_alloc();
			<span class="enscript-keyword">if</span> (imgp-&gt;ip_scriptlabelp == NULL) {
				error = ENOMEM;
				<span class="enscript-keyword">break</span>;
			}
			mac_vnode_label_copy(imgp-&gt;ip_vp-&gt;v_label,
					     imgp-&gt;ip_scriptlabelp);

			<span class="enscript-comment">/*
			 * Take a ref of the script vnode for later use.
			 */</span>
			<span class="enscript-keyword">if</span> (imgp-&gt;ip_scriptvp)
				vnode_put(imgp-&gt;ip_scriptvp);
			<span class="enscript-keyword">if</span> (vnode_getwithref(imgp-&gt;ip_vp) == 0)
				imgp-&gt;ip_scriptvp = imgp-&gt;ip_vp;
#<span class="enscript-reference">endif</span>

			nameidone(ndp);

			vnode_put(imgp-&gt;ip_vp);
			imgp-&gt;ip_vp = NULL;	<span class="enscript-comment">/* already put */</span>
			imgp-&gt;ip_ndp = NULL; <span class="enscript-comment">/* already nameidone */</span>

			<span class="enscript-comment">/* Use excpath, which exec_shell_imgact reset to the interpreter */</span>
			NDINIT(ndp, LOOKUP, OP_LOOKUP, FOLLOW | LOCKLEAF,
				   UIO_SYSSPACE, CAST_USER_ADDR_T(excpath), imgp-&gt;ip_vfs_context);

			proc_transend(p, 0);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">again</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-comment">/*
	 * Call out to allow 3rd party notification of exec. 
	 * Ignore result of kauth_authorize_fileop call.
	 */</span>
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; kauth_authorize_fileop_has_listeners()) {
		kauth_authorize_fileop(vfs_context_ucred(imgp-&gt;ip_vfs_context),
					KAUTH_FILEOP_EXEC,
					(uintptr_t)ndp-&gt;ni_vp, 0);
	}

<span class="enscript-reference">bad</span>:
	proc_transend(p, 0);

<span class="enscript-reference">bad_notrans</span>:
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_strings)
		execargs_free(imgp);
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_ndp)
		nameidone(imgp-&gt;ip_ndp);
	<span class="enscript-keyword">if</span> (ndp)
		FREE(ndp, M_TEMP);

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * exec_handle_spawnattr_policy
 *
 * Description: Decode and apply the posix_spawn apptype, qos clamp, and watchport ports to the task.
 *
 * Parameters:  proc_t p                process to apply attributes to
 *              int psa_apptype         posix spawn attribute apptype
 *
 * Returns:     0                       Success
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">exec_handle_spawnattr_policy</span>(proc_t p, <span class="enscript-type">int</span> psa_apptype, uint64_t psa_qos_clamp, uint64_t psa_darwin_role,
                             ipc_port_t * portwatch_ports, <span class="enscript-type">int</span> portwatch_count)
{
	<span class="enscript-type">int</span> apptype     = TASK_APPTYPE_NONE;
	<span class="enscript-type">int</span> qos_clamp   = THREAD_QOS_UNSPECIFIED;
	<span class="enscript-type">int</span> role        = TASK_UNSPECIFIED;

	<span class="enscript-keyword">if</span> ((psa_apptype &amp; POSIX_SPAWN_PROC_TYPE_MASK) != 0) {
		<span class="enscript-type">int</span> proctype = psa_apptype &amp; POSIX_SPAWN_PROC_TYPE_MASK;

		<span class="enscript-keyword">switch</span>(proctype) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">POSIX_SPAWN_PROC_TYPE_DAEMON_INTERACTIVE</span>:
				apptype = TASK_APPTYPE_DAEMON_INTERACTIVE;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">POSIX_SPAWN_PROC_TYPE_DAEMON_STANDARD</span>:
				apptype = TASK_APPTYPE_DAEMON_STANDARD;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">POSIX_SPAWN_PROC_TYPE_DAEMON_ADAPTIVE</span>:
				apptype = TASK_APPTYPE_DAEMON_ADAPTIVE;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">POSIX_SPAWN_PROC_TYPE_DAEMON_BACKGROUND</span>:
				apptype = TASK_APPTYPE_DAEMON_BACKGROUND;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">POSIX_SPAWN_PROC_TYPE_APP_DEFAULT</span>:
				apptype = TASK_APPTYPE_APP_DEFAULT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">POSIX_SPAWN_PROC_TYPE_APP_TAL</span>:
				apptype = TASK_APPTYPE_APP_TAL;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				apptype = TASK_APPTYPE_NONE;
				<span class="enscript-comment">/* TODO: Should an invalid value here fail the spawn? */</span>
				<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (psa_qos_clamp != POSIX_SPAWN_PROC_CLAMP_NONE) {
		<span class="enscript-keyword">switch</span> (psa_qos_clamp) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">POSIX_SPAWN_PROC_CLAMP_UTILITY</span>:
				qos_clamp = THREAD_QOS_UTILITY;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">POSIX_SPAWN_PROC_CLAMP_BACKGROUND</span>:
				qos_clamp = THREAD_QOS_BACKGROUND;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">POSIX_SPAWN_PROC_CLAMP_MAINTENANCE</span>:
				qos_clamp = THREAD_QOS_MAINTENANCE;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				qos_clamp = THREAD_QOS_UNSPECIFIED;
				<span class="enscript-comment">/* TODO: Should an invalid value here fail the spawn? */</span>
				<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (psa_darwin_role != PRIO_DARWIN_ROLE_DEFAULT) {
		proc_darwin_role_to_task_role(psa_darwin_role, &amp;role);
	}

	<span class="enscript-keyword">if</span> (apptype   != TASK_APPTYPE_NONE      ||
	    qos_clamp != THREAD_QOS_UNSPECIFIED ||
	    role      != TASK_UNSPECIFIED) {
		proc_set_task_spawnpolicy(p-&gt;task, apptype, qos_clamp, role,
		                          portwatch_ports, portwatch_count);
	}

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * exec_handle_port_actions
 *
 * Description:	Go through the _posix_port_actions_t contents, 
 * 		calling task_set_special_port, task_set_exception_ports
 * 		and/or audit_session_spawnjoin for the current task.
 *
 * Parameters:	struct image_params *	Image parameter block
 * 		short psa_flags		posix spawn attribute flags
 *
 * Returns:	0			Success
 * 		EINVAL			Failure
 * 		ENOTSUP			Illegal posix_spawn attr flag was set
 */</span>
<span class="enscript-type">static</span> errno_t
<span class="enscript-function-name">exec_handle_port_actions</span>(<span class="enscript-type">struct</span> image_params *imgp, <span class="enscript-type">short</span> psa_flags, boolean_t * portwatch_present, ipc_port_t * portwatch_ports)
{
	_posix_spawn_port_actions_t pacts = imgp-&gt;ip_px_spa;
	proc_t p = vfs_context_proc(imgp-&gt;ip_vfs_context);
	_ps_port_action_t *act = NULL;
	task_t task = p-&gt;task;
	ipc_port_t port = NULL;
	errno_t ret = 0;
	<span class="enscript-type">int</span> i;

	*portwatch_present = FALSE;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; pacts-&gt;pspa_count; i++) {
		act = &amp;pacts-&gt;pspa_actions[i];

		<span class="enscript-keyword">if</span> (ipc_object_copyin(get_task_ipcspace(current_task()),
		    act-&gt;new_port, MACH_MSG_TYPE_COPY_SEND,
		    (ipc_object_t *) &amp;port) != KERN_SUCCESS) {
			ret = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}

		<span class="enscript-keyword">switch</span> (act-&gt;port_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PSPA_SPECIAL</span>:
			<span class="enscript-comment">/* Only allowed when not under vfork */</span>
			<span class="enscript-keyword">if</span> (!(psa_flags &amp; POSIX_SPAWN_SETEXEC))
				ret = ENOTSUP;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (task_set_special_port(task,
			act-&gt;which, port) != KERN_SUCCESS)
				ret = EINVAL;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PSPA_EXCEPTION</span>:
			<span class="enscript-comment">/* Only allowed when not under vfork */</span>
			<span class="enscript-keyword">if</span> (!(psa_flags &amp; POSIX_SPAWN_SETEXEC))
				ret = ENOTSUP;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (task_set_exception_ports(task, 
			act-&gt;mask, port, act-&gt;behavior, 
			act-&gt;flavor) != KERN_SUCCESS)
				ret = EINVAL;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_AUDIT</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PSPA_AU_SESSION</span>:
			ret = audit_session_spawnjoin(p, port);
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PSPA_IMP_WATCHPORTS</span>:
			<span class="enscript-keyword">if</span> (portwatch_ports != NULL) {
				*portwatch_present = TRUE;
				<span class="enscript-comment">/* hold on to this till end of spawn */</span>
				portwatch_ports[i] = port;
				ret = 0;
			} <span class="enscript-keyword">else</span>
				ipc_port_release_send(port);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			ret = EINVAL;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* action failed, so release port resources */</span>

		<span class="enscript-keyword">if</span> (ret) { 
			ipc_port_release_send(port);
			<span class="enscript-keyword">break</span>;
		}
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (0 != ret)
		DTRACE_PROC1(spawn__port__failure, mach_port_name_t, act-&gt;new_port);
	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-comment">/*
 * exec_handle_file_actions
 *
 * Description:	Go through the _posix_file_actions_t contents applying the
 *		open, close, and dup2 operations to the open file table for
 *		the current process.
 *
 * Parameters:	struct image_params *	Image parameter block
 *
 * Returns:	0			Success
 *		???
 *
 * Note:	Actions are applied in the order specified, with the credential
 *		of the parent process.  This is done to permit the parent
 *		process to utilize POSIX_SPAWN_RESETIDS to drop privilege in
 *		the child following operations the child may in fact not be
 *		normally permitted to perform.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">exec_handle_file_actions</span>(<span class="enscript-type">struct</span> image_params *imgp, <span class="enscript-type">short</span> psa_flags)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> action;
	proc_t p = vfs_context_proc(imgp-&gt;ip_vfs_context);
	_posix_spawn_file_actions_t px_sfap = imgp-&gt;ip_px_sfa;
	<span class="enscript-type">int</span> ival[2];		<span class="enscript-comment">/* dummy retval for system calls) */</span>

	<span class="enscript-keyword">for</span> (action = 0; action &lt; px_sfap-&gt;psfa_act_count; action++) {
		_psfa_action_t *psfa = &amp;px_sfap-&gt;psfa_act_acts[ action];

		<span class="enscript-keyword">switch</span>(psfa-&gt;psfaa_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PSFA_OPEN</span>: {
			<span class="enscript-comment">/*
			 * Open is different, in that it requires the use of
			 * a path argument, which is normally copied in from
			 * user space; because of this, we have to support an
			 * open from kernel space that passes an address space
			 * context of UIO_SYSSPACE, and casts the address
			 * argument to a user_addr_t.
			 */</span>
			<span class="enscript-type">char</span> *bufp = NULL;
			<span class="enscript-type">struct</span> vnode_attr *vap;
			<span class="enscript-type">struct</span> nameidata *ndp;
			<span class="enscript-type">int</span> mode = psfa-&gt;psfaa_openargs.psfao_mode;
			<span class="enscript-type">struct</span> dup2_args dup2a;
			<span class="enscript-type">struct</span> close_nocancel_args ca;
			<span class="enscript-type">int</span> origfd;

			MALLOC(bufp, <span class="enscript-type">char</span> *, <span class="enscript-keyword">sizeof</span>(*vap) + <span class="enscript-keyword">sizeof</span>(*ndp), M_TEMP, M_WAITOK | M_ZERO);
			<span class="enscript-keyword">if</span> (bufp == NULL) {
				error = ENOMEM;
				<span class="enscript-keyword">break</span>;
			}

			vap = (<span class="enscript-type">struct</span> vnode_attr *) bufp;
			ndp = (<span class="enscript-type">struct</span> nameidata *) (bufp + <span class="enscript-keyword">sizeof</span>(*vap));

			VATTR_INIT(vap);
			<span class="enscript-comment">/* Mask off all but regular access permissions */</span>
			mode = ((mode &amp;~ p-&gt;p_fd-&gt;fd_cmask) &amp; ALLPERMS) &amp; ~S_ISTXT;
			VATTR_SET(vap, va_mode, mode &amp; ACCESSPERMS);

			NDINIT(ndp, LOOKUP, OP_OPEN, FOLLOW | AUDITVNPATH1, UIO_SYSSPACE,
			       CAST_USER_ADDR_T(psfa-&gt;psfaa_openargs.psfao_path),
			       imgp-&gt;ip_vfs_context);

			error = open1(imgp-&gt;ip_vfs_context, 
					ndp,
					psfa-&gt;psfaa_openargs.psfao_oflag,
					vap,
					fileproc_alloc_init, NULL,
					ival);

			FREE(bufp, M_TEMP);

			<span class="enscript-comment">/*
			 * If there's an error, or we get the right fd by
			 * accident, then drop out here.  This is easier than
			 * reworking all the open code to preallocate fd
			 * slots, and internally taking one as an argument.
			 */</span>
			<span class="enscript-keyword">if</span> (error || ival[0] == psfa-&gt;psfaa_filedes)
				<span class="enscript-keyword">break</span>;

			origfd = ival[0];
			<span class="enscript-comment">/*
			 * If we didn't fall out from an error, we ended up
			 * with the wrong fd; so now we've got to try to dup2
			 * it to the right one.
			 */</span>
			dup2a.from = origfd;
			dup2a.to = psfa-&gt;psfaa_filedes;

			<span class="enscript-comment">/*
			 * The dup2() system call implementation sets
			 * ival to newfd in the success case, but we
			 * can ignore that, since if we didn't get the
			 * fd we wanted, the error will stop us.
			 */</span>
			error = dup2(p, &amp;dup2a, ival);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-comment">/*
			 * Finally, close the original fd.
			 */</span>
			ca.fd = origfd;

			error = close_nocancel(p, &amp;ca, ival);
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PSFA_DUP2</span>: {
			<span class="enscript-type">struct</span> dup2_args dup2a;

			dup2a.from = psfa-&gt;psfaa_filedes;
			dup2a.to = psfa-&gt;psfaa_openargs.psfao_oflag;

			<span class="enscript-comment">/*
			 * The dup2() system call implementation sets
			 * ival to newfd in the success case, but we
			 * can ignore that, since if we didn't get the
			 * fd we wanted, the error will stop us.
			 */</span>
			error = dup2(p, &amp;dup2a, ival);
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PSFA_CLOSE</span>: {
			<span class="enscript-type">struct</span> close_nocancel_args ca;

			ca.fd = psfa-&gt;psfaa_filedes;

			error = close_nocancel(p, &amp;ca, ival);
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PSFA_INHERIT</span>: {
			<span class="enscript-type">struct</span> fcntl_nocancel_args fcntla;

			<span class="enscript-comment">/*
			 * Check to see if the descriptor exists, and
			 * ensure it's -not- marked as close-on-exec.
			 *
			 * Attempting to &quot;inherit&quot; a guarded fd will
			 * result in a error.
			 */</span>
			fcntla.fd = psfa-&gt;psfaa_filedes;
			fcntla.cmd = F_GETFD;
			<span class="enscript-keyword">if</span> ((error = fcntl_nocancel(p, &amp;fcntla, ival)) != 0)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">if</span> ((ival[0] &amp; FD_CLOEXEC) == FD_CLOEXEC) {
				fcntla.fd = psfa-&gt;psfaa_filedes;
				fcntla.cmd = F_SETFD;
				fcntla.arg = ival[0] &amp; ~FD_CLOEXEC;
				error = fcntl_nocancel(p, &amp;fcntla, ival);
			}

			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/* All file actions failures are considered fatal, per POSIX */</span>

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (PSFA_OPEN == psfa-&gt;psfaa_type) {
				DTRACE_PROC1(spawn__open__failure, uintptr_t,
			            psfa-&gt;psfaa_openargs.psfao_path);
			} <span class="enscript-keyword">else</span> {
				DTRACE_PROC1(spawn__fd__failure, <span class="enscript-type">int</span>, psfa-&gt;psfaa_filedes);
			}
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (error != 0 || (psa_flags &amp; POSIX_SPAWN_CLOEXEC_DEFAULT) == 0)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * If POSIX_SPAWN_CLOEXEC_DEFAULT is set, behave (during
	 * this spawn only) as if &quot;close on exec&quot; is the default
	 * disposition of all pre-existing file descriptors.  In this case,
	 * the list of file descriptors mentioned in the file actions
	 * are the only ones that can be inherited, so mark them now.
	 *
	 * The actual closing part comes later, in fdexec().
	 */</span>
	proc_fdlock(p);
	<span class="enscript-keyword">for</span> (action = 0; action &lt; px_sfap-&gt;psfa_act_count; action++) {
		_psfa_action_t *psfa = &amp;px_sfap-&gt;psfa_act_acts[action];
		<span class="enscript-type">int</span> fd = psfa-&gt;psfaa_filedes;

		<span class="enscript-keyword">switch</span> (psfa-&gt;psfaa_type) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PSFA_DUP2</span>:
			fd = psfa-&gt;psfaa_openargs.psfao_oflag;
			<span class="enscript-comment">/*FALLTHROUGH*/</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PSFA_OPEN</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PSFA_INHERIT</span>:
			*fdflags(p, fd) |= UF_INHERIT;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PSFA_CLOSE</span>:
			<span class="enscript-keyword">break</span>;
		}
	}
	proc_fdunlock(p);

	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
<span class="enscript-comment">/*
 * exec_spawnattr_getmacpolicyinfo
 */</span>
<span class="enscript-type">void</span> *
<span class="enscript-function-name">exec_spawnattr_getmacpolicyinfo</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *macextensions, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *policyname, size_t *lenp)
{
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> _posix_spawn_mac_policy_extensions *psmx = macextensions;
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (psmx == NULL)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; psmx-&gt;psmx_count; i++) {
		<span class="enscript-type">const</span> _ps_mac_policy_extension_t *extension = &amp;psmx-&gt;psmx_extensions[i];
		<span class="enscript-keyword">if</span> (strncmp(extension-&gt;policyname, policyname, <span class="enscript-keyword">sizeof</span>(extension-&gt;policyname)) == 0) {
			<span class="enscript-keyword">if</span> (lenp != NULL)
				*lenp = extension-&gt;datalen;
			<span class="enscript-keyword">return</span> extension-&gt;datap;
		}
	}

	<span class="enscript-keyword">if</span> (lenp != NULL)
		*lenp = 0;
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">spawn_copyin_macpolicyinfo</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> user__posix_spawn_args_desc *px_args, _posix_spawn_mac_policy_extensions_t *psmxp)
{
	_posix_spawn_mac_policy_extensions_t psmx = NULL;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> copycnt = 0;
	<span class="enscript-type">int</span> i = 0;

	*psmxp = NULL;

	<span class="enscript-keyword">if</span> (px_args-&gt;mac_extensions_size &lt; PS_MAC_EXTENSIONS_SIZE(1) ||
	    px_args-&gt;mac_extensions_size &gt; PAGE_SIZE) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	MALLOC(psmx, _posix_spawn_mac_policy_extensions_t, px_args-&gt;mac_extensions_size, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> ((error = copyin(px_args-&gt;mac_extensions, psmx, px_args-&gt;mac_extensions_size)) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">if</span> (PS_MAC_EXTENSIONS_SIZE(psmx-&gt;psmx_count) &gt; px_args-&gt;mac_extensions_size) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">for</span> (i = 0; i &lt; psmx-&gt;psmx_count; i++) {
		_ps_mac_policy_extension_t *extension = &amp;psmx-&gt;psmx_extensions[i];
		<span class="enscript-keyword">if</span> (extension-&gt;datalen == 0 || extension-&gt;datalen &gt; PAGE_SIZE) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}

	<span class="enscript-keyword">for</span> (copycnt = 0; copycnt &lt; psmx-&gt;psmx_count; copycnt++) {
		_ps_mac_policy_extension_t *extension = &amp;psmx-&gt;psmx_extensions[copycnt];
		<span class="enscript-type">void</span> *data = NULL;

		MALLOC(data, <span class="enscript-type">void</span> *, extension-&gt;datalen, M_TEMP, M_WAITOK);
		<span class="enscript-keyword">if</span> ((error = copyin(extension-&gt;data, data, extension-&gt;datalen)) != 0) {
			FREE(data, M_TEMP);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		extension-&gt;datap = data;
	}

	*psmxp = psmx;
	<span class="enscript-keyword">return</span> 0;

<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">if</span> (psmx != NULL) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; copycnt; i++)
			FREE(psmx-&gt;psmx_extensions[i].datap, M_TEMP);
		FREE(psmx, M_TEMP);
	}
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">spawn_free_macpolicyinfo</span>(_posix_spawn_mac_policy_extensions_t psmx)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (psmx == NULL)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; psmx-&gt;psmx_count; i++)
		FREE(psmx-&gt;psmx_extensions[i].datap, M_TEMP);
	FREE(psmx, M_TEMP);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_COALITIONS</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">spawn_coalitions_release_all</span>(coalition_t coal[COALITION_NUM_TYPES])
{
	<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> c = 0; c &lt; COALITION_NUM_TYPES; c++) {
		<span class="enscript-keyword">if</span> (coal[c]) {
			coalition_remove_active(coal[c]);
			coalition_release(coal[c]);
		}
	}
}
#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_set_return_wait</span>(proc_t p)
{
	proc_lock(p);
	p-&gt;p_lflag |= P_LRETURNWAIT;
	proc_unlock(p);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_clear_return_wait</span>(proc_t p, thread_t child_thread)
{
	proc_lock(p);

	p-&gt;p_lflag &amp;= ~P_LRETURNWAIT;
	<span class="enscript-keyword">if</span> (p-&gt;p_lflag &amp; P_LRETURNWAITER) {
		wakeup(&amp;p-&gt;p_lflag);
	}

	proc_unlock(p);

	(<span class="enscript-type">void</span>)thread_resume(child_thread);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_wait_to_return</span>()
{
	proc_t	p;

	p = current_proc();
	proc_lock(p);

	<span class="enscript-keyword">if</span> (p-&gt;p_lflag &amp; P_LRETURNWAIT) {
		p-&gt;p_lflag |= P_LRETURNWAITER;
		<span class="enscript-keyword">do</span> {
			msleep(&amp;p-&gt;p_lflag, &amp;p-&gt;p_mlock, 0,
				<span class="enscript-string">&quot;thread_check_setup_complete&quot;</span>, NULL);
		} <span class="enscript-keyword">while</span> (p-&gt;p_lflag &amp; P_LRETURNWAIT);
		p-&gt;p_lflag &amp;= ~P_LRETURNWAITER;
	}

	proc_unlock(p);
	thread_bootstrap_return();
}

<span class="enscript-comment">/*
 * posix_spawn
 *
 * Parameters:	uap-&gt;pid		Pointer to pid return area
 *		uap-&gt;fname		File name to exec
 *		uap-&gt;argp		Argument list
 *		uap-&gt;envp		Environment list
 *
 * Returns:	0			Success
 *		EINVAL			Invalid argument
 *		ENOTSUP			Not supported
 *		ENOEXEC			Executable file format error
 *	exec_activate_image:EINVAL	Invalid argument
 *	exec_activate_image:EACCES	Permission denied
 *	exec_activate_image:EINTR	Interrupted function
 *	exec_activate_image:ENOMEM	Not enough space
 *	exec_activate_image:EFAULT	Bad address
 *	exec_activate_image:ENAMETOOLONG	Filename too long
 *	exec_activate_image:ENOEXEC	Executable file format error
 *	exec_activate_image:ETXTBSY	Text file busy [misuse of error code]
 *	exec_activate_image:EBADEXEC	The executable is corrupt/unknown
 *	exec_activate_image:???
 *	mac_execve_enter:???
 *
 * TODO:	Expect to need __mac_posix_spawn() at some point...
 *		Handle posix_spawnattr_t
 *		Handle posix_spawn_file_actions_t
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">posix_spawn</span>(proc_t ap, <span class="enscript-type">struct</span> posix_spawn_args *uap, int32_t *retval)
{
	proc_t p = ap;		<span class="enscript-comment">/* quiet bogus GCC vfork() warning */</span>
	user_addr_t pid = uap-&gt;pid;
	<span class="enscript-type">int</span> ival[2];		<span class="enscript-comment">/* dummy retval for setpgid() */</span>
	<span class="enscript-type">char</span> *bufp = NULL; 
	<span class="enscript-type">struct</span> image_params *imgp;
	<span class="enscript-type">struct</span> vnode_attr *vap;
	<span class="enscript-type">struct</span> vnode_attr *origvap;
	<span class="enscript-type">struct</span> uthread	*uthread = 0;	<span class="enscript-comment">/* compiler complains if not set to 0*/</span>
	<span class="enscript-type">int</span> error, sig;
	<span class="enscript-type">int</span> is_64 = IS_64BIT_PROCESS(p);
	<span class="enscript-type">struct</span> vfs_context context;
	<span class="enscript-type">struct</span> user__posix_spawn_args_desc px_args;
	<span class="enscript-type">struct</span> _posix_spawnattr px_sa;
	_posix_spawn_file_actions_t px_sfap = NULL;
	_posix_spawn_port_actions_t px_spap = NULL;
	<span class="enscript-type">struct</span> __kern_sigaction vec;
	boolean_t spawn_no_exec = FALSE;
	boolean_t proc_transit_set = TRUE;
	boolean_t exec_done = FALSE;
	<span class="enscript-type">int</span> portwatch_count = 0;
	ipc_port_t * portwatch_ports = NULL;
	vm_size_t px_sa_offset = offsetof(<span class="enscript-type">struct</span> _posix_spawnattr, psa_ports); 

	<span class="enscript-comment">/*
	 * Allocate a big chunk for locals instead of using stack since these  
	 * structures are pretty big.
	 */</span>
	MALLOC(bufp, <span class="enscript-type">char</span> *, (<span class="enscript-keyword">sizeof</span>(*imgp) + <span class="enscript-keyword">sizeof</span>(*vap) + <span class="enscript-keyword">sizeof</span>(*origvap)), M_TEMP, M_WAITOK | M_ZERO);
	imgp = (<span class="enscript-type">struct</span> image_params *) bufp;
	<span class="enscript-keyword">if</span> (bufp == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	vap = (<span class="enscript-type">struct</span> vnode_attr *) (bufp + <span class="enscript-keyword">sizeof</span>(*imgp));
	origvap = (<span class="enscript-type">struct</span> vnode_attr *) (bufp + <span class="enscript-keyword">sizeof</span>(*imgp) + <span class="enscript-keyword">sizeof</span>(*vap));

	<span class="enscript-comment">/* Initialize the common data in the image_params structure */</span>
	imgp-&gt;ip_user_fname = uap-&gt;path;
	imgp-&gt;ip_user_argv = uap-&gt;argv;
	imgp-&gt;ip_user_envv = uap-&gt;envp;
	imgp-&gt;ip_vattr = vap;
	imgp-&gt;ip_origvattr = origvap;
	imgp-&gt;ip_vfs_context = &amp;context;
	imgp-&gt;ip_flags = (is_64 ? IMGPF_WAS_64BIT : IMGPF_NONE);
	imgp-&gt;ip_seg = (is_64 ? UIO_USERSPACE64 : UIO_USERSPACE32);
	imgp-&gt;ip_mac_return = 0;
	imgp-&gt;ip_reserved = NULL;

	<span class="enscript-keyword">if</span> (uap-&gt;adesc != USER_ADDR_NULL) {
		<span class="enscript-keyword">if</span>(is_64) {
			error = copyin(uap-&gt;adesc, &amp;px_args, <span class="enscript-keyword">sizeof</span>(px_args));
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32__posix_spawn_args_desc px_args32;

			error = copyin(uap-&gt;adesc, &amp;px_args32, <span class="enscript-keyword">sizeof</span>(px_args32));

			<span class="enscript-comment">/*
			 * Convert arguments descriptor from external 32 bit
			 * representation to internal 64 bit representation
			 */</span>
			px_args.attr_size = px_args32.attr_size;
			px_args.attrp = CAST_USER_ADDR_T(px_args32.attrp);
			px_args.file_actions_size = px_args32.file_actions_size;
			px_args.file_actions = CAST_USER_ADDR_T(px_args32.file_actions);
			px_args.port_actions_size = px_args32.port_actions_size;
			px_args.port_actions = CAST_USER_ADDR_T(px_args32.port_actions);
			px_args.mac_extensions_size = px_args32.mac_extensions_size;
			px_args.mac_extensions = CAST_USER_ADDR_T(px_args32.mac_extensions);
			px_args.coal_info_size = px_args32.coal_info_size;
			px_args.coal_info = CAST_USER_ADDR_T(px_args32.coal_info);
			px_args.reserved = 0;
			px_args.reserved_size = 0;
		}
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

		<span class="enscript-keyword">if</span> (px_args.attr_size != 0) {
			<span class="enscript-comment">/* 
			 * We are not copying the port_actions pointer, 
			 * because we already have it from px_args. 
			 * This is a bit fragile: &lt;rdar://problem/16427422&gt;
			 */</span>

			<span class="enscript-keyword">if</span> ((error = copyin(px_args.attrp, &amp;px_sa, px_sa_offset) != 0)) 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		
			bzero( (<span class="enscript-type">void</span> *)( (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>) &amp;px_sa + px_sa_offset), <span class="enscript-keyword">sizeof</span>(px_sa) - px_sa_offset );  	

			imgp-&gt;ip_px_sa = &amp;px_sa;
		}
		<span class="enscript-keyword">if</span> (px_args.file_actions_size != 0) {
			<span class="enscript-comment">/* Limit file_actions to allowed number of open files */</span>
			<span class="enscript-type">int</span> maxfa = (p-&gt;p_limit ? p-&gt;p_rlimit[RLIMIT_NOFILE].rlim_cur : NOFILE);
			<span class="enscript-keyword">if</span> (px_args.file_actions_size &lt; PSF_ACTIONS_SIZE(1) ||
				px_args.file_actions_size &gt; PSF_ACTIONS_SIZE(maxfa)) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			MALLOC(px_sfap, _posix_spawn_file_actions_t, px_args.file_actions_size, M_TEMP, M_WAITOK);
			<span class="enscript-keyword">if</span> (px_sfap == NULL) {
				error = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			imgp-&gt;ip_px_sfa = px_sfap;

			<span class="enscript-keyword">if</span> ((error = copyin(px_args.file_actions, px_sfap, 
							px_args.file_actions_size)) != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

			<span class="enscript-comment">/* Verify that the action count matches the struct size */</span>
			<span class="enscript-keyword">if</span> (PSF_ACTIONS_SIZE(px_sfap-&gt;psfa_act_count) != px_args.file_actions_size) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
		}
		<span class="enscript-keyword">if</span> (px_args.port_actions_size != 0) {
			<span class="enscript-comment">/* Limit port_actions to one page of data */</span>
			<span class="enscript-keyword">if</span> (px_args.port_actions_size &lt; PS_PORT_ACTIONS_SIZE(1) ||
				px_args.port_actions_size &gt; PAGE_SIZE) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}

			MALLOC(px_spap, _posix_spawn_port_actions_t, 
					px_args.port_actions_size, M_TEMP, M_WAITOK);
			<span class="enscript-keyword">if</span> (px_spap == NULL) {
				error = ENOMEM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			imgp-&gt;ip_px_spa = px_spap;

			<span class="enscript-keyword">if</span> ((error = copyin(px_args.port_actions, px_spap, 
							px_args.port_actions_size)) != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

			<span class="enscript-comment">/* Verify that the action count matches the struct size */</span>
			<span class="enscript-keyword">if</span> (PS_PORT_ACTIONS_SIZE(px_spap-&gt;pspa_count) != px_args.port_actions_size) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-keyword">if</span> (px_args.mac_extensions_size != 0) {
			<span class="enscript-keyword">if</span> ((error = spawn_copyin_macpolicyinfo(&amp;px_args, (_posix_spawn_mac_policy_extensions_t *)&amp;imgp-&gt;ip_px_smpx)) != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF */</span>
	}

	<span class="enscript-comment">/* set uthread to parent */</span>
	uthread = get_bsdthread_info(current_thread());

	<span class="enscript-comment">/*
	 * &lt;rdar://6640530&gt;; this does not result in a behaviour change
	 * relative to Leopard, so there should not be any existing code
	 * which depends on it.
	 */</span>
	<span class="enscript-keyword">if</span> (uthread-&gt;uu_flag &amp; UT_VFORK) {
	    error = EINVAL;
	    <span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/*
	 * If we don't have the extension flag that turns &quot;posix_spawn()&quot;
	 * into &quot;execve() with options&quot;, then we will be creating a new
	 * process which does not inherit memory from the parent process,
	 * which is one of the most expensive things about using fork()
	 * and execve().
	 */</span>
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_px_sa == NULL || !(px_sa.psa_flags &amp; POSIX_SPAWN_SETEXEC)){

		<span class="enscript-comment">/* Set the new task's coalition, if it is requested.  */</span>
		coalition_t coal[COALITION_NUM_TYPES] = { COALITION_NULL };
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_COALITIONS</span>
		<span class="enscript-type">int</span> i, ncoals;
		kern_return_t kr = KERN_SUCCESS;
		<span class="enscript-type">struct</span> _posix_spawn_coalition_info coal_info;
		<span class="enscript-type">int</span> coal_role[COALITION_NUM_TYPES];

		<span class="enscript-keyword">if</span> (imgp-&gt;ip_px_sa == NULL || !px_args.coal_info)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">do_fork1</span>;

		memset(&amp;coal_info, 0, <span class="enscript-keyword">sizeof</span>(coal_info));

		<span class="enscript-keyword">if</span> (px_args.coal_info_size &gt; <span class="enscript-keyword">sizeof</span>(coal_info))
			px_args.coal_info_size = <span class="enscript-keyword">sizeof</span>(coal_info);
		error = copyin(px_args.coal_info,
			       &amp;coal_info, px_args.coal_info_size);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

		ncoals = 0;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; COALITION_NUM_TYPES; i++) {
			uint64_t cid = coal_info.psci_info[i].psci_id;
			<span class="enscript-keyword">if</span> (cid != 0) {
				<span class="enscript-comment">/*
				 * don't allow tasks which are not in a
				 * privileged coalition to spawn processes
				 * into coalitions other than their own
				 */</span>
				<span class="enscript-keyword">if</span> (!task_is_in_privileged_coalition(p-&gt;task, i)) {
					coal_dbg(<span class="enscript-string">&quot;ERROR: %d not in privilegd &quot;</span>
						 <span class="enscript-string">&quot;coalition of type %d&quot;</span>,
						 p-&gt;p_pid, i);
					spawn_coalitions_release_all(coal);
					error = EPERM;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
				}

				coal_dbg(<span class="enscript-string">&quot;searching for coalition id:%llu&quot;</span>, cid);
				<span class="enscript-comment">/*
				 * take a reference and activation on the
				 * coalition to guard against free-while-spawn
				 * races
				 */</span>
				coal[i] = coalition_find_and_activate_by_id(cid);
				<span class="enscript-keyword">if</span> (coal[i] == COALITION_NULL) {
					coal_dbg(<span class="enscript-string">&quot;could not find coalition id:%llu &quot;</span>
						 <span class="enscript-string">&quot;(perhaps it has been terminated or reaped)&quot;</span>, cid);
					<span class="enscript-comment">/*
					 * release any other coalition's we
					 * may have a reference to
					 */</span>
					spawn_coalitions_release_all(coal);
					error = ESRCH;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
				}
				<span class="enscript-keyword">if</span> (coalition_type(coal[i]) != i) {
					coal_dbg(<span class="enscript-string">&quot;coalition with id:%lld is not of type:%d&quot;</span>
						 <span class="enscript-string">&quot; (it's type:%d)&quot;</span>, cid, i, coalition_type(coal[i]));
					error = ESRCH;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
				}
				coal_role[i] = coal_info.psci_info[i].psci_role;
				ncoals++;
			}
		}
		<span class="enscript-keyword">if</span> (ncoals &lt; COALITION_NUM_TYPES) {
			<span class="enscript-comment">/*
			 * If the user is attempting to spawn into a subset of
			 * the known coalition types, then make sure they have
			 * _at_least_ specified a resource coalition. If not,
			 * the following fork1() call will implicitly force an
			 * inheritance from 'p' and won't actually spawn the
			 * new task into the coalitions the user specified.
			 * (also the call to coalitions_set_roles will panic)
			 */</span>
			<span class="enscript-keyword">if</span> (coal[COALITION_TYPE_RESOURCE] == COALITION_NULL) {
				spawn_coalitions_release_all(coal);
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
		}
<span class="enscript-reference">do_fork1</span>:
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_COALITIONS */</span>

		error = fork1(p, &amp;imgp-&gt;ip_new_thread, PROC_CREATE_SPAWN, coal);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_COALITIONS</span>
		<span class="enscript-comment">/* set the roles of this task within each given coalition */</span>
		<span class="enscript-keyword">if</span> (error == 0) {
			kr = coalitions_set_roles(coal, get_threadtask(imgp-&gt;ip_new_thread), coal_role);
			<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
				error = EINVAL;
		}

		<span class="enscript-comment">/* drop our references and activations - fork1() now holds them */</span>
		spawn_coalitions_release_all(coal);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_COALITIONS */</span>
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		imgp-&gt;ip_flags |= IMGPF_SPAWN;	<span class="enscript-comment">/* spawn w/o exec */</span>
		spawn_no_exec = TRUE;		<span class="enscript-comment">/* used in later tests */</span>

	}

	<span class="enscript-keyword">if</span> (spawn_no_exec) {
		p = (proc_t)get_bsdthreadtask_info(imgp-&gt;ip_new_thread);
		
		<span class="enscript-comment">/*
		 * We had to wait until this point before firing the
		 * proc:::create probe, otherwise p would not point to the
		 * child process.
		 */</span>
		DTRACE_PROC1(create, proc_t, p);
	}
	assert(p != NULL);

	<span class="enscript-comment">/* By default, the thread everyone plays with is the parent */</span>
	context.vc_thread = current_thread();
	context.vc_ucred = p-&gt;p_ucred;	<span class="enscript-comment">/* XXX must NOT be kauth_cred_get() */</span>

	<span class="enscript-comment">/*
	 * However, if we're not in the setexec case, redirect the context
	 * to the newly created process instead
	 */</span>
	<span class="enscript-keyword">if</span> (spawn_no_exec)
		context.vc_thread = imgp-&gt;ip_new_thread;

	<span class="enscript-comment">/*
	 * Post fdcopy(), pre exec_handle_sugid() - this is where we want
	 * to handle the file_actions.  Since vfork() also ends up setting
	 * us into the parent process group, and saved off the signal flags,
	 * this is also where we want to handle the spawn flags.
	 */</span>

	<span class="enscript-comment">/* Has spawn file actions? */</span>
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_px_sfa != NULL) {
		<span class="enscript-comment">/*
		 * The POSIX_SPAWN_CLOEXEC_DEFAULT flag
		 * is handled in exec_handle_file_actions().
		 */</span>
		<span class="enscript-keyword">if</span> ((error = exec_handle_file_actions(imgp,
		    imgp-&gt;ip_px_sa != NULL ? px_sa.psa_flags : 0)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* Has spawn port actions? */</span>
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_px_spa != NULL) {
		boolean_t is_adaptive = FALSE;
		boolean_t portwatch_present = FALSE;

		<span class="enscript-comment">/* Will this process become adaptive? The apptype isn't ready yet, so we can't look there. */</span>
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_px_sa != NULL &amp;&amp; px_sa.psa_apptype == POSIX_SPAWN_PROC_TYPE_DAEMON_ADAPTIVE)
			is_adaptive = TRUE;

		<span class="enscript-comment">/*
		 * portwatch only:
		 * Allocate a place to store the ports we want to bind to the new task
		 * We can't bind them until after the apptype is set.
		 */</span>
		<span class="enscript-keyword">if</span> (px_spap-&gt;pspa_count != 0 &amp;&amp; is_adaptive) {
			portwatch_count = px_spap-&gt;pspa_count;
			MALLOC(portwatch_ports, ipc_port_t *, (<span class="enscript-keyword">sizeof</span>(ipc_port_t) * portwatch_count), M_TEMP, M_WAITOK | M_ZERO);
		} <span class="enscript-keyword">else</span> {
			portwatch_ports = NULL;
		}

		<span class="enscript-keyword">if</span> ((error = exec_handle_port_actions(imgp,
		    imgp-&gt;ip_px_sa != NULL ? px_sa.psa_flags : 0, &amp;portwatch_present, portwatch_ports)) != 0) 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

		<span class="enscript-keyword">if</span> (portwatch_present == FALSE &amp;&amp; portwatch_ports != NULL) {
			FREE(portwatch_ports, M_TEMP);
			portwatch_ports = NULL;
			portwatch_count = 0;
		}
	}

	<span class="enscript-comment">/* Has spawn attr? */</span>
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_px_sa != NULL) {
		<span class="enscript-comment">/*
		 * Set the process group ID of the child process; this has
		 * to happen before the image activation.
		 */</span>
		<span class="enscript-keyword">if</span> (px_sa.psa_flags &amp; POSIX_SPAWN_SETPGROUP) {
			<span class="enscript-type">struct</span> setpgid_args spga;
			spga.pid = p-&gt;p_pid;
			spga.pgid = px_sa.psa_pgroup;
			<span class="enscript-comment">/*
			 * Effectively, call setpgid() system call; works
			 * because there are no pointer arguments.
			 */</span>
			<span class="enscript-keyword">if</span>((error = setpgid(p, &amp;spga, ival)) != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

		<span class="enscript-comment">/*
		 * Reset UID/GID to parent's RUID/RGID; This works only
		 * because the operation occurs *after* the vfork() and
		 * before the call to exec_handle_sugid() by the image
		 * activator called from exec_activate_image().  POSIX
		 * requires that any setuid/setgid bits on the process
		 * image will take precedence over the spawn attributes
		 * (re)setting them.
		 *
		 * The use of p_ucred is safe, since we are acting on the
		 * new process, and it has no threads other than the one
		 * we are creating for it.
		 */</span>
		<span class="enscript-keyword">if</span> (px_sa.psa_flags &amp; POSIX_SPAWN_RESETIDS) {
			kauth_cred_t my_cred = p-&gt;p_ucred;
			kauth_cred_t my_new_cred = kauth_cred_setuidgid(my_cred, kauth_cred_getruid(my_cred), kauth_cred_getrgid(my_cred));
			<span class="enscript-keyword">if</span> (my_new_cred != my_cred) {
				p-&gt;p_ucred = my_new_cred;
				<span class="enscript-comment">/* update cred on proc */</span>
				PROC_UPDATE_CREDS_ONPROC(p);
			}
		}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">SECURE_KERNEL</span>
		<span class="enscript-comment">/*
		 * Disable ASLR for the spawned process.
		 *
		 * But only do so if we are not embedded + RELEASE.
		 * While embedded allows for a boot-arg (-disable_aslr)
		 * to deal with this (which itself is only honored on
		 * DEVELOPMENT or DEBUG builds of xnu), it is often
		 * useful or necessary to disable ASLR on a per-process
		 * basis for unit testing and debugging.
		 */</span>
		<span class="enscript-keyword">if</span> (px_sa.psa_flags &amp; _POSIX_SPAWN_DISABLE_ASLR)
			OSBitOrAtomic(P_DISABLE_ASLR, &amp;p-&gt;p_flag);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !SECURE_KERNEL */</span>

		<span class="enscript-comment">/*
		 * Forcibly disallow execution from data pages for the spawned process
		 * even if it would otherwise be permitted by the architecture default.
		 */</span>
		<span class="enscript-keyword">if</span> (px_sa.psa_flags &amp; _POSIX_SPAWN_ALLOW_DATA_EXEC)
			imgp-&gt;ip_flags |= IMGPF_ALLOW_DATA_EXEC;
	}

	<span class="enscript-comment">/*
	 * Disable ASLR during image activation.  This occurs either if the
	 * _POSIX_SPAWN_DISABLE_ASLR attribute was found above or if
	 * P_DISABLE_ASLR was inherited from the parent process.
	 */</span>
	<span class="enscript-keyword">if</span> (p-&gt;p_flag &amp; P_DISABLE_ASLR)
		imgp-&gt;ip_flags |= IMGPF_DISABLE_ASLR;

	<span class="enscript-comment">/* 
	 * Clear transition flag so we won't hang if exec_activate_image() causes
	 * an automount (and launchd does a proc sysctl to service it).
	 *
	 * &lt;rdar://problem/6848672&gt;, &lt;rdar://problem/5959568&gt;.
	 */</span>
	<span class="enscript-keyword">if</span> (spawn_no_exec) {
		proc_transend(p, 0);
		proc_transit_set = 0;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MAC_SPAWN</span>	<span class="enscript-comment">/* XXX */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;mac_p != USER_ADDR_NULL) {
		error = mac_execve_enter(uap-&gt;mac_p, imgp);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Activate the image
	 */</span>
	error = exec_activate_image(imgp);
	
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-comment">/* process completed the exec */</span>
		exec_done = TRUE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == -1) {
		<span class="enscript-comment">/* Image not claimed by any activator? */</span>
		error = ENOEXEC;
	}

	<span class="enscript-comment">/*
	 * If we have a spawn attr, and it contains signal related flags,
	 * the we need to process them in the &quot;context&quot; of the new child
	 * process, so we have to process it following image activation,
	 * prior to making the thread runnable in user space.  This is
	 * necessitated by some signal information being per-thread rather
	 * than per-process, and we don't have the new allocation in hand
	 * until after the image is activated.
	 */</span>
	<span class="enscript-keyword">if</span> (!error &amp;&amp; imgp-&gt;ip_px_sa != NULL) {
		thread_t child_thread = current_thread();
		uthread_t child_uthread = uthread;

		<span class="enscript-comment">/*
		 * If we created a new child thread, then the thread and
		 * uthread are different than the current ones; otherwise,
		 * we leave them, since we are in the exec case instead.
		 */</span>
		<span class="enscript-keyword">if</span> (spawn_no_exec) {
			child_thread = imgp-&gt;ip_new_thread;
			child_uthread = get_bsdthread_info(child_thread);
		}

		<span class="enscript-comment">/*
		 * Mask a list of signals, instead of them being unmasked, if
		 * they were unmasked in the parent; note that some signals
		 * are not maskable.
		 */</span>
		<span class="enscript-keyword">if</span> (px_sa.psa_flags &amp; POSIX_SPAWN_SETSIGMASK)
			child_uthread-&gt;uu_sigmask = (px_sa.psa_sigmask &amp; ~sigcantmask);
		<span class="enscript-comment">/*
		 * Default a list of signals instead of ignoring them, if
		 * they were ignored in the parent.  Note that we pass
		 * spawn_no_exec to setsigvec() to indicate that we called
		 * fork1() and therefore do not need to call proc_signalstart()
		 * internally.
		 */</span>
		<span class="enscript-keyword">if</span> (px_sa.psa_flags &amp; POSIX_SPAWN_SETSIGDEF) {
			vec.sa_handler = SIG_DFL;
			vec.sa_tramp = 0;
			vec.sa_mask = 0;
			vec.sa_flags = 0;
			<span class="enscript-keyword">for</span> (sig = 0; sig &lt; NSIG; sig++)
				<span class="enscript-keyword">if</span> (px_sa.psa_sigdefault &amp; (1 &lt;&lt; sig)) {
					error = setsigvec(p, child_thread, sig + 1, &amp;vec, spawn_no_exec);
			}
		}

		<span class="enscript-comment">/*
		 * Activate the CPU usage monitor, if requested. This is done via a task-wide, per-thread CPU
		 * usage limit, which will generate a resource exceeded exception if any one thread exceeds the
		 * limit.
		 *
		 * Userland gives us interval in seconds, and the kernel SPI expects nanoseconds.
		 */</span>
		<span class="enscript-keyword">if</span> (px_sa.psa_cpumonitor_percent != 0) {
			<span class="enscript-comment">/*
			 * Always treat a CPU monitor activation coming from spawn as entitled. Requiring
			 * an entitlement to configure the monitor a certain way seems silly, since
			 * whomever is turning it on could just as easily choose not to do so.
			 */</span>
			error = proc_set_task_ruse_cpu(p-&gt;task,
					TASK_POLICY_RESOURCE_ATTRIBUTE_NOTIFY_EXC,
					px_sa.psa_cpumonitor_percent,
					px_sa.psa_cpumonitor_interval * NSEC_PER_SEC,
					0, TRUE);
		}
	}

<span class="enscript-reference">bad</span>:

	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-comment">/* reset delay idle sleep status if set */</span>
		<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_DELAYIDLESLEEP) == P_DELAYIDLESLEEP)
			OSBitAndAtomic(~((uint32_t)P_DELAYIDLESLEEP), &amp;p-&gt;p_flag);
		<span class="enscript-comment">/* upon  successful spawn, re/set the proc control state */</span>
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_px_sa != NULL) {
			<span class="enscript-keyword">switch</span> (px_sa.psa_pcontrol) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">POSIX_SPAWN_PCONTROL_THROTTLE</span>:
					p-&gt;p_pcaction = P_PCTHROTTLE;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">POSIX_SPAWN_PCONTROL_SUSPEND</span>:
					p-&gt;p_pcaction = P_PCSUSP;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">POSIX_SPAWN_PCONTROL_KILL</span>:
					p-&gt;p_pcaction = P_PCKILL;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">POSIX_SPAWN_PCONTROL_NONE</span>:
				<span class="enscript-reference">default</span>:
					p-&gt;p_pcaction = 0;
					<span class="enscript-keyword">break</span>;
			};
		}
		exec_resettextvp(p, imgp);
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span> &amp;&amp; <span class="enscript-variable-name">CONFIG_JETSAM</span>
		<span class="enscript-comment">/* Has jetsam attributes? */</span>
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_px_sa != NULL &amp;&amp; (px_sa.psa_jetsam_flags &amp; POSIX_SPAWN_JETSAM_SET)) {
			<span class="enscript-comment">/*
			 * With 2-level high-water-mark support, POSIX_SPAWN_JETSAM_HIWATER_BACKGROUND is no
			 * longer relevant, as background limits are described via the inactive limit slots.
			 * At the kernel layer, the flag is ignored.
			 *
			 * That said, however, if the POSIX_SPAWN_JETSAM_HIWATER_BACKGROUND is passed in,
			 * we attempt to mimic previous behavior by forcing the BG limit data into the
			 * inactive/non-fatal mode and force the active slots to hold system_wide/fatal mode.
			 * The kernel layer will flag this mapping.
			 */</span>
			<span class="enscript-keyword">if</span> (px_sa.psa_jetsam_flags &amp; POSIX_SPAWN_JETSAM_HIWATER_BACKGROUND) {
				memorystatus_update(p, px_sa.psa_priority, 0,
					    (px_sa.psa_jetsam_flags &amp; POSIX_SPAWN_JETSAM_USE_EFFECTIVE_PRIORITY),
					    TRUE,
					    -1, TRUE,
					    px_sa.psa_memlimit_inactive, FALSE,
					    (px_sa.psa_jetsam_flags &amp; POSIX_SPAWN_JETSAM_HIWATER_BACKGROUND));
			} <span class="enscript-keyword">else</span> {
				memorystatus_update(p, px_sa.psa_priority, 0,
					    (px_sa.psa_jetsam_flags &amp; POSIX_SPAWN_JETSAM_USE_EFFECTIVE_PRIORITY),
					    TRUE,
					    px_sa.psa_memlimit_active,
					    (px_sa.psa_jetsam_flags &amp; POSIX_SPAWN_JETSAM_MEMLIMIT_ACTIVE_FATAL),
					    px_sa.psa_memlimit_inactive,
					    (px_sa.psa_jetsam_flags &amp; POSIX_SPAWN_JETSAM_MEMLIMIT_INACTIVE_FATAL),
					    (px_sa.psa_jetsam_flags &amp; POSIX_SPAWN_JETSAM_HIWATER_BACKGROUND));
			}

		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MEMORYSTATUS &amp;&amp; CONFIG_JETSAM*/</span>
	}

	<span class="enscript-comment">/*
	 * If we successfully called fork1(), we always need to do this;
	 * we identify this case by noting the IMGPF_SPAWN flag.  This is
	 * because we come back from that call with signals blocked in the
	 * child, and we have to unblock them, but we want to wait until
	 * after we've performed any spawn actions.  This has to happen
	 * before check_for_signature(), which uses psignal.
	 */</span>
	<span class="enscript-keyword">if</span> (spawn_no_exec) {
		<span class="enscript-keyword">if</span> (proc_transit_set)
			proc_transend(p, 0);

		<span class="enscript-comment">/*
		 * Drop the signal lock on the child which was taken on our
		 * behalf by forkproc()/cloneproc() to prevent signals being
		 * received by the child in a partially constructed state.
		 */</span>
		proc_signalend(p, 0);

		<span class="enscript-comment">/* flag the 'fork' has occurred */</span>
		proc_knote(p-&gt;p_pptr, NOTE_FORK | p-&gt;p_pid);
		<span class="enscript-comment">/* then flag exec has occurred */</span>
		<span class="enscript-comment">/* notify only if it has not failed due to FP Key error */</span>
		<span class="enscript-keyword">if</span> ((p-&gt;p_lflag &amp; P_LTERM_DECRYPTFAIL) == 0)
			proc_knote(p, NOTE_EXEC);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-comment">/* reset the importance attribute from our previous life */</span>
		task_importance_reset(p-&gt;task);

		<span class="enscript-comment">/* reset atm context from task */</span>
		task_atm_reset(p-&gt;task);
	}

	<span class="enscript-comment">/*
	 * Apply the spawnattr policy, apptype (which primes the task for importance donation),
	 * and bind any portwatch ports to the new task.
	 * This must be done after the exec so that the child's thread is ready,
	 * and after the in transit state has been released, because priority is
	 * dropped here so we need to be prepared for a potentially long preemption interval
	 *
	 * TODO: Consider splitting this up into separate phases
	 */</span>
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; imgp-&gt;ip_px_sa != NULL) {
		<span class="enscript-type">struct</span> _posix_spawnattr *psa = (<span class="enscript-type">struct</span> _posix_spawnattr *) imgp-&gt;ip_px_sa;

		exec_handle_spawnattr_policy(p, psa-&gt;psa_apptype, psa-&gt;psa_qos_clamp, psa-&gt;psa_darwin_role,
		                              portwatch_ports, portwatch_count);
	}

	<span class="enscript-comment">/* Apply the main thread qos */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		thread_t main_thread = (imgp-&gt;ip_new_thread != NULL) ? imgp-&gt;ip_new_thread : current_thread();

		task_set_main_thread_qos(p-&gt;task, main_thread);
	}

	<span class="enscript-comment">/*
	 * Release any ports we kept around for binding to the new task
	 * We need to release the rights even if the posix_spawn has failed.
	 */</span>
	<span class="enscript-keyword">if</span> (portwatch_ports != NULL) {
		<span class="enscript-keyword">for</span> (<span class="enscript-type">int</span> i = 0; i &lt; portwatch_count; i++) {
			ipc_port_t port = NULL;
			<span class="enscript-keyword">if</span> ((port = portwatch_ports[i]) != NULL) {
				ipc_port_release_send(port);
			}
		}
		FREE(portwatch_ports, M_TEMP);
		portwatch_ports = NULL;
		portwatch_count = 0;
	}

	<span class="enscript-comment">/*
	 * We have to delay operations which might throw a signal until after
	 * the signals have been unblocked; however, we want that to happen
	 * after exec_resettextvp() so that the textvp is correct when they
	 * fire.
	 */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		error = check_for_signature(p, imgp);

		<span class="enscript-comment">/*
		 * Pay for our earlier safety; deliver the delayed signals from
		 * the incomplete spawn process now that it's complete.
		 */</span>
		<span class="enscript-keyword">if</span> (imgp != NULL &amp;&amp; spawn_no_exec &amp;&amp; (p-&gt;p_lflag &amp; P_LTRACED)) {
			psignal_vfork(p, p-&gt;task, imgp-&gt;ip_new_thread, SIGTRAP);
		}
	}


	<span class="enscript-keyword">if</span> (imgp != NULL) {
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_vp)
			vnode_put(imgp-&gt;ip_vp);
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_scriptvp)
			vnode_put(imgp-&gt;ip_scriptvp);
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_strings)
			execargs_free(imgp);
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_px_sfa != NULL)
			FREE(imgp-&gt;ip_px_sfa, M_TEMP);
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_px_spa != NULL)
			FREE(imgp-&gt;ip_px_spa, M_TEMP);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_px_smpx != NULL)
			spawn_free_macpolicyinfo(imgp-&gt;ip_px_smpx);
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_execlabelp)
			mac_cred_label_free(imgp-&gt;ip_execlabelp);
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_scriptlabelp)
			mac_vnode_label_free(imgp-&gt;ip_scriptlabelp);
#<span class="enscript-reference">endif</span>
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-keyword">if</span> (spawn_no_exec) {
		<span class="enscript-comment">/*
		 * In the original DTrace reference implementation,
		 * posix_spawn() was a libc routine that just
		 * did vfork(2) then exec(2).  Thus the proc::: probes
		 * are very fork/exec oriented.  The details of this
		 * in-kernel implementation of posix_spawn() is different
		 * (while producing the same process-observable effects)
		 * particularly w.r.t. errors, and which thread/process
		 * is constructing what on behalf of whom.
		 */</span>
		<span class="enscript-keyword">if</span> (error) {
			DTRACE_PROC1(spawn__failure, <span class="enscript-type">int</span>, error);
		} <span class="enscript-keyword">else</span> {
			DTRACE_PROC(spawn__success);
			<span class="enscript-comment">/*
			 * Some DTrace scripts, e.g. newproc.d in
			 * /usr/bin, rely on the the 'exec-success'
			 * probe being fired in the child after the
			 * new process image has been constructed
			 * in order to determine the associated pid.
			 *
			 * So, even though the parent built the image
			 * here, for compatibility, mark the new thread
			 * so 'exec-success' fires on it as it leaves
			 * the kernel.
			 */</span>
			dtrace_thread_didexec(imgp-&gt;ip_new_thread);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (error) {
			DTRACE_PROC1(exec__failure, <span class="enscript-type">int</span>, error);
		} <span class="enscript-keyword">else</span> {
			DTRACE_PROC(exec__success);
		}
	}

	<span class="enscript-keyword">if</span> ((dtrace_proc_waitfor_hook = dtrace_proc_waitfor_exec_ptr) != NULL)
		(*dtrace_proc_waitfor_hook)(p);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Return to both the parent and the child? */</span>
	<span class="enscript-keyword">if</span> (imgp != NULL &amp;&amp; spawn_no_exec) {
		<span class="enscript-comment">/*
		 * If the parent wants the pid, copy it out
		 */</span>
		<span class="enscript-keyword">if</span> (pid != USER_ADDR_NULL)
			(<span class="enscript-type">void</span>)suword(pid, p-&gt;p_pid);
		retval[0] = error;

		<span class="enscript-comment">/*
		 * If we had an error, perform an internal reap ; this is
		 * entirely safe, as we have a real process backing us.
		 */</span>
		<span class="enscript-keyword">if</span> (error) {
			proc_list_lock();
			p-&gt;p_listflag |= P_LIST_DEADPARENT;
			proc_list_unlock();
			proc_lock(p);
			<span class="enscript-comment">/* make sure no one else has killed it off... */</span>
			<span class="enscript-keyword">if</span> (p-&gt;p_stat != SZOMB &amp;&amp; p-&gt;exit_thread == NULL) {
				p-&gt;exit_thread = current_thread();
				proc_unlock(p);
				exit1(p, 1, (<span class="enscript-type">int</span> *)NULL);
				proc_clear_return_wait(p, imgp-&gt;ip_new_thread);
				<span class="enscript-keyword">if</span> (exec_done == FALSE) {
					task_deallocate(get_threadtask(imgp-&gt;ip_new_thread));
					thread_deallocate(imgp-&gt;ip_new_thread);
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* someone is doing it for us; just skip it */</span>
				proc_unlock(p);
				proc_clear_return_wait(p, imgp-&gt;ip_new_thread);
			}
		} <span class="enscript-keyword">else</span> {

			<span class="enscript-comment">/*
			 * Return to the child
			 *
			 * Note: the image activator earlier dropped the
			 * task/thread references to the newly spawned
			 * process; this is OK, since we still have suspended
			 * queue references on them, so we should be fine
			 * with the delayed resume of the thread here.
			 */</span>
			proc_clear_return_wait(p, imgp-&gt;ip_new_thread);
		}
	}
	<span class="enscript-keyword">if</span> (bufp != NULL) {
		FREE(bufp, M_TEMP);
	}
	
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * execve
 *
 * Parameters:	uap-&gt;fname		File name to exec
 *		uap-&gt;argp		Argument list
 *		uap-&gt;envp		Environment list
 *
 * Returns:	0			Success
 *	__mac_execve:EINVAL		Invalid argument
 *	__mac_execve:ENOTSUP		Invalid argument
 *	__mac_execve:EACCES		Permission denied
 *	__mac_execve:EINTR		Interrupted function
 *	__mac_execve:ENOMEM		Not enough space
 *	__mac_execve:EFAULT		Bad address
 *	__mac_execve:ENAMETOOLONG	Filename too long
 *	__mac_execve:ENOEXEC		Executable file format error
 *	__mac_execve:ETXTBSY		Text file busy [misuse of error code]
 *	__mac_execve:???
 *
 * TODO:	Dynamic linker header address on stack is copied via suword()
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">execve</span>(proc_t p, <span class="enscript-type">struct</span> execve_args *uap, int32_t *retval)
{
	<span class="enscript-type">struct</span> __mac_execve_args muap;
	<span class="enscript-type">int</span> err;

	memoryshot(VM_EXECVE, DBG_FUNC_NONE);

	muap.fname = uap-&gt;fname;
	muap.argp = uap-&gt;argp;
	muap.envp = uap-&gt;envp;
	muap.mac_p = USER_ADDR_NULL;
	err = __mac_execve(p, &amp;muap, retval);

	<span class="enscript-keyword">return</span>(err);
}

<span class="enscript-comment">/*
 * __mac_execve
 *
 * Parameters:	uap-&gt;fname		File name to exec
 *		uap-&gt;argp		Argument list
 *		uap-&gt;envp		Environment list
 *		uap-&gt;mac_p		MAC label supplied by caller
 *
 * Returns:	0			Success
 *		EINVAL			Invalid argument
 *		ENOTSUP			Not supported
 *		ENOEXEC			Executable file format error
 *	exec_activate_image:EINVAL	Invalid argument
 *	exec_activate_image:EACCES	Permission denied
 *	exec_activate_image:EINTR	Interrupted function
 *	exec_activate_image:ENOMEM	Not enough space
 *	exec_activate_image:EFAULT	Bad address
 *	exec_activate_image:ENAMETOOLONG	Filename too long
 *	exec_activate_image:ENOEXEC	Executable file format error
 *	exec_activate_image:ETXTBSY	Text file busy [misuse of error code]
 *	exec_activate_image:EBADEXEC	The executable is corrupt/unknown
 *	exec_activate_image:???
 *	mac_execve_enter:???
 *
 * TODO:	Dynamic linker header address on stack is copied via suword()
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">__mac_execve</span>(proc_t p, <span class="enscript-type">struct</span> __mac_execve_args *uap, int32_t *retval)
{
	<span class="enscript-type">char</span> *bufp = NULL; 
	<span class="enscript-type">struct</span> image_params *imgp;
	<span class="enscript-type">struct</span> vnode_attr *vap;
	<span class="enscript-type">struct</span> vnode_attr *origvap;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> is_64 = IS_64BIT_PROCESS(p);
	<span class="enscript-type">struct</span> vfs_context context;
	<span class="enscript-type">struct</span> uthread	*uthread;

	context.vc_thread = current_thread();
	context.vc_ucred = kauth_cred_proc_ref(p);	<span class="enscript-comment">/* XXX must NOT be kauth_cred_get() */</span>

	<span class="enscript-comment">/* Allocate a big chunk for locals instead of using stack since these  
	 * structures a pretty big.
	 */</span>
	MALLOC(bufp, <span class="enscript-type">char</span> *, (<span class="enscript-keyword">sizeof</span>(*imgp) + <span class="enscript-keyword">sizeof</span>(*vap) + <span class="enscript-keyword">sizeof</span>(*origvap)), M_TEMP, M_WAITOK | M_ZERO);
	imgp = (<span class="enscript-type">struct</span> image_params *) bufp;
	<span class="enscript-keyword">if</span> (bufp == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit_with_error</span>;
	}
	vap = (<span class="enscript-type">struct</span> vnode_attr *) (bufp + <span class="enscript-keyword">sizeof</span>(*imgp));
	origvap = (<span class="enscript-type">struct</span> vnode_attr *) (bufp + <span class="enscript-keyword">sizeof</span>(*imgp) + <span class="enscript-keyword">sizeof</span>(*vap));
	
	<span class="enscript-comment">/* Initialize the common data in the image_params structure */</span>
	imgp-&gt;ip_user_fname = uap-&gt;fname;
	imgp-&gt;ip_user_argv = uap-&gt;argp;
	imgp-&gt;ip_user_envv = uap-&gt;envp;
	imgp-&gt;ip_vattr = vap;
	imgp-&gt;ip_origvattr = origvap;
	imgp-&gt;ip_vfs_context = &amp;context;
	imgp-&gt;ip_flags = (is_64 ? IMGPF_WAS_64BIT : IMGPF_NONE) | ((p-&gt;p_flag &amp; P_DISABLE_ASLR) ? IMGPF_DISABLE_ASLR : IMGPF_NONE);
	imgp-&gt;ip_seg = (is_64 ? UIO_USERSPACE64 : UIO_USERSPACE32);
	imgp-&gt;ip_mac_return = 0;

	uthread = get_bsdthread_info(current_thread());
	<span class="enscript-keyword">if</span> (uthread-&gt;uu_flag &amp; UT_VFORK) {
		imgp-&gt;ip_flags |= IMGPF_VFORK_EXEC;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (uap-&gt;mac_p != USER_ADDR_NULL) {
		error = mac_execve_enter(uap-&gt;mac_p, imgp);
		<span class="enscript-keyword">if</span> (error) {
			kauth_cred_unref(&amp;context.vc_ucred);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit_with_error</span>;
		}
	}
#<span class="enscript-reference">endif</span>

	error = exec_activate_image(imgp);

	kauth_cred_unref(&amp;context.vc_ucred);
	
	<span class="enscript-comment">/* Image not claimed by any activator? */</span>
	<span class="enscript-keyword">if</span> (error == -1)
		error = ENOEXEC;

	<span class="enscript-keyword">if</span> (error == 0) {
		exec_resettextvp(p, imgp);
		error = check_for_signature(p, imgp);
	}	
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_vp != NULLVP)
		vnode_put(imgp-&gt;ip_vp);
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_scriptvp != NULLVP)
		vnode_put(imgp-&gt;ip_scriptvp);
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_strings)
		execargs_free(imgp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_execlabelp)
		mac_cred_label_free(imgp-&gt;ip_execlabelp);
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_scriptlabelp)
		mac_vnode_label_free(imgp-&gt;ip_scriptlabelp);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-comment">/* Sever any extant thread affinity */</span>
		thread_affinity_exec(current_thread());

		thread_t main_thread = (imgp-&gt;ip_new_thread != NULL) ? imgp-&gt;ip_new_thread : current_thread();		

		task_set_main_thread_qos(p-&gt;task, main_thread);

		<span class="enscript-comment">/* reset task importance */</span>
		task_importance_reset(p-&gt;task);

		<span class="enscript-comment">/* reset atm context from task */</span>
		task_atm_reset(p-&gt;task);

		DTRACE_PROC(exec__success);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-keyword">if</span> ((dtrace_proc_waitfor_hook = dtrace_proc_waitfor_exec_ptr) != NULL)
			(*dtrace_proc_waitfor_hook)(p);
#<span class="enscript-reference">endif</span>

		<span class="enscript-keyword">if</span> (imgp-&gt;ip_flags &amp; IMGPF_VFORK_EXEC) {
			vfork_return(p, retval, p-&gt;p_pid);
			proc_clear_return_wait(p, imgp-&gt;ip_new_thread);
		}
	} <span class="enscript-keyword">else</span> {
		DTRACE_PROC1(exec__failure, <span class="enscript-type">int</span>, error);
	}

<span class="enscript-reference">exit_with_error</span>:
	<span class="enscript-keyword">if</span> (bufp != NULL) {
		FREE(bufp, M_TEMP);
	}
	
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * copyinptr
 *
 * Description:	Copy a pointer in from user space to a user_addr_t in kernel
 *		space, based on 32/64 bitness of the user space
 *
 * Parameters:	froma			User space address
 *		toptr			Address of kernel space user_addr_t
 *		ptr_size		4/8, based on 'froma' address space
 *
 * Returns:	0			Success
 *		EFAULT			Bad 'froma'
 *
 * Implicit returns:
 *		*ptr_size		Modified
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">copyinptr</span>(user_addr_t froma, user_addr_t *toptr, <span class="enscript-type">int</span> ptr_size)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (ptr_size == 4) {
		<span class="enscript-comment">/* 64 bit value containing 32 bit address */</span>
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;

		error = copyin(froma, &amp;i, 4);
		*toptr = CAST_USER_ADDR_T(i);	<span class="enscript-comment">/* SAFE */</span>
	} <span class="enscript-keyword">else</span> {
		error = copyin(froma, toptr, 8);
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * copyoutptr
 *
 * Description:	Copy a pointer out from a user_addr_t in kernel space to
 *		user space, based on 32/64 bitness of the user space
 *
 * Parameters:	ua			User space address to copy to
 *		ptr			Address of kernel space user_addr_t
 *		ptr_size		4/8, based on 'ua' address space
 *
 * Returns:	0			Success
 *		EFAULT			Bad 'ua'
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">copyoutptr</span>(user_addr_t ua, user_addr_t ptr, <span class="enscript-type">int</span> ptr_size)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (ptr_size == 4) {
		<span class="enscript-comment">/* 64 bit value containing 32 bit address */</span>
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i = CAST_DOWN_EXPLICIT(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>,ua);	<span class="enscript-comment">/* SAFE */</span>

		error = copyout(&amp;i, ptr, 4);
	} <span class="enscript-keyword">else</span> {
		error = copyout(&amp;ua, ptr, 8);
	}
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * exec_copyout_strings
 *
 * Copy out the strings segment to user space.  The strings segment is put
 * on a preinitialized stack frame.
 *
 * Parameters:	struct image_params *	the image parameter block
 *		int *			a pointer to the stack offset variable
 *
 * Returns:	0			Success
 *		!0			Faiure: errno
 *
 * Implicit returns:
 *		(*stackp)		The stack offset, modified
 *
 * Note:	The strings segment layout is backward, from the beginning
 *		of the top of the stack to consume the minimal amount of
 *		space possible; the returned stack pointer points to the
 *		end of the area consumed (stacks grow downward).
 *
 *		argc is an int; arg[i] are pointers; env[i] are pointers;
 *		the 0's are (void *)NULL's
 *
 * The stack frame layout is:
 *
 *      +-------------+ &lt;- p-&gt;user_stack
 *      |     16b     |
 *      +-------------+
 *      | STRING AREA |
 *      |      :      |
 *      |      :      |
 *      |      :      |
 *      +- -- -- -- --+
 *      |  PATH AREA  |
 *      +-------------+
 *      |      0      |
 *      +-------------+
 *      |  applev[n]  |
 *      +-------------+
 *             :
 *             :
 *      +-------------+
 *      |  applev[1]  |
 *      +-------------+
 *      | exec_path / |
 *      |  applev[0]  |
 *      +-------------+
 *      |      0      |
 *      +-------------+
 *      |    env[n]   |
 *      +-------------+
 *             :
 *             :
 *      +-------------+
 *      |    env[0]   |
 *      +-------------+
 *      |      0      |
 *      +-------------+
 *      | arg[argc-1] |
 *      +-------------+
 *             :
 *             :
 *      +-------------+
 *      |    arg[0]   |
 *      +-------------+
 *      |     argc    |
 * sp-&gt; +-------------+
 *
 * Although technically a part of the STRING AREA, we treat the PATH AREA as
 * a separate entity.  This allows us to align the beginning of the PATH AREA
 * to a pointer boundary so that the exec_path, env[i], and argv[i] pointers
 * which preceed it on the stack are properly aligned.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">exec_copyout_strings</span>(<span class="enscript-type">struct</span> image_params *imgp, user_addr_t *stackp)
{
	proc_t p = vfs_context_proc(imgp-&gt;ip_vfs_context);
	<span class="enscript-type">int</span>	ptr_size = (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) ? 8 : 4;
	<span class="enscript-type">int</span>	ptr_area_size;
	<span class="enscript-type">void</span> *ptr_buffer_start, *ptr_buffer;
	<span class="enscript-type">int</span> string_size;

	user_addr_t	string_area;	<span class="enscript-comment">/* *argv[], *env[] */</span>
	user_addr_t	ptr_area;	<span class="enscript-comment">/* argv[], env[], applev[] */</span>
	user_addr_t argc_area;	<span class="enscript-comment">/* argc */</span>
	user_addr_t	stack;
	<span class="enscript-type">int</span> error;

	<span class="enscript-type">unsigned</span> i;
	<span class="enscript-type">struct</span> copyout_desc {
		<span class="enscript-type">char</span>	*start_string;
		<span class="enscript-type">int</span>		count;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
		user_addr_t	*dtrace_cookie;
#<span class="enscript-reference">endif</span>
		boolean_t	null_term;
	} descriptors[] = {
		{
			.start_string = imgp-&gt;ip_startargv,
			.count = imgp-&gt;ip_argc,
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
			.dtrace_cookie = &amp;p-&gt;p_dtrace_argv,
#<span class="enscript-reference">endif</span>
			.null_term = TRUE
		},
		{
			.start_string = imgp-&gt;ip_endargv,
			.count = imgp-&gt;ip_envc,
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
			.dtrace_cookie = &amp;p-&gt;p_dtrace_envp,
#<span class="enscript-reference">endif</span>
			.null_term = TRUE
		},
		{
			.start_string = imgp-&gt;ip_strings,
			.count = 1,
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
			.dtrace_cookie = NULL,
#<span class="enscript-reference">endif</span>
			.null_term = FALSE
		},
		{
			.start_string = imgp-&gt;ip_endenvv,
			.count = imgp-&gt;ip_applec - 1, <span class="enscript-comment">/* exec_path handled above */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
			.dtrace_cookie = NULL,
#<span class="enscript-reference">endif</span>
			.null_term = TRUE
		}
	};

	stack = *stackp;

	<span class="enscript-comment">/*
	 * All previous contributors to the string area
	 * should have aligned their sub-area
	 */</span>
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_strspace % ptr_size != 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* Grow the stack down for the strings we've been building up */</span>
	string_size = imgp-&gt;ip_strendp - imgp-&gt;ip_strings;
	stack -= string_size;
	string_area = stack;

	<span class="enscript-comment">/*
	 * Need room for one pointer for each string, plus
	 * one for the NULLs terminating the argv, envv, and apple areas.
	 */</span>
	ptr_area_size = (imgp-&gt;ip_argc + imgp-&gt;ip_envc + imgp-&gt;ip_applec + 3) *
	    ptr_size;
	stack -= ptr_area_size;
	ptr_area = stack;

	<span class="enscript-comment">/* We'll construct all the pointer arrays in our string buffer,
	 * which we already know is aligned properly, and ip_argspace
	 * was used to verify we have enough space.
	 */</span>
	ptr_buffer_start = ptr_buffer = (<span class="enscript-type">void</span> *)imgp-&gt;ip_strendp;

	<span class="enscript-comment">/*
	 * Need room for pointer-aligned argc slot.
	 */</span>
	stack -= ptr_size;
	argc_area = stack;

	<span class="enscript-comment">/*
	 * Record the size of the arguments area so that sysctl_procargs()
	 * can return the argument area without having to parse the arguments.
	 */</span>
	proc_lock(p);
	p-&gt;p_argc = imgp-&gt;ip_argc;
	p-&gt;p_argslen = (<span class="enscript-type">int</span>)(*stackp - string_area);
	proc_unlock(p);

	<span class="enscript-comment">/* Return the initial stack address: the location of argc */</span>
	*stackp = stack;

	<span class="enscript-comment">/*
	 * Copy out the entire strings area.
	 */</span>
	error = copyout(imgp-&gt;ip_strings, string_area,
						   string_size);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; <span class="enscript-keyword">sizeof</span>(descriptors)/<span class="enscript-keyword">sizeof</span>(descriptors[0]); i++) {
		<span class="enscript-type">char</span> *cur_string = descriptors[i].start_string;
		<span class="enscript-type">int</span> j;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-keyword">if</span> (descriptors[i].dtrace_cookie) {
			proc_lock(p);
			*descriptors[i].dtrace_cookie = ptr_area + ((uintptr_t)ptr_buffer - (uintptr_t)ptr_buffer_start); <span class="enscript-comment">/* dtrace convenience */</span>
			proc_unlock(p);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_DTRACE */</span>

		<span class="enscript-comment">/*
		 * For each segment (argv, envv, applev), copy as many pointers as requested
		 * to our pointer buffer.
		 */</span>
		<span class="enscript-keyword">for</span> (j = 0; j &lt; descriptors[i].count; j++) {
			user_addr_t cur_address = string_area + (cur_string - imgp-&gt;ip_strings);
			
			<span class="enscript-comment">/* Copy out the pointer to the current string. Alignment has been verified  */</span>
			<span class="enscript-keyword">if</span> (ptr_size == 8) {
				*(uint64_t *)ptr_buffer = (uint64_t)cur_address;
			} <span class="enscript-keyword">else</span> {
				*(uint32_t *)ptr_buffer = (uint32_t)cur_address;
			}
			
			ptr_buffer = (<span class="enscript-type">void</span> *)((uintptr_t)ptr_buffer + ptr_size);
			cur_string += strlen(cur_string) + 1; <span class="enscript-comment">/* Only a NUL between strings in the same area */</span>
		}

		<span class="enscript-keyword">if</span> (descriptors[i].null_term) {
			<span class="enscript-keyword">if</span> (ptr_size == 8) {
				*(uint64_t *)ptr_buffer = 0ULL;
			} <span class="enscript-keyword">else</span> {
				*(uint32_t *)ptr_buffer = 0;
			}
			
			ptr_buffer = (<span class="enscript-type">void</span> *)((uintptr_t)ptr_buffer + ptr_size);
		}
	}

	<span class="enscript-comment">/*
	 * Copy out all our pointer arrays in bulk.
	 */</span>
	error = copyout(ptr_buffer_start, ptr_area,
					ptr_area_size);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-comment">/* argc (int32, stored in a ptr_size area) */</span>
	error = copyoutptr((user_addr_t)imgp-&gt;ip_argc, argc_area, ptr_size);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * exec_extract_strings
 *
 * Copy arguments and environment from user space into work area; we may
 * have already copied some early arguments into the work area, and if
 * so, any arguments opied in are appended to those already there.
 * This function is the primary manipulator of ip_argspace, since
 * these are the arguments the client of execve(2) knows about. After
 * each argv[]/envv[] string is copied, we charge the string length
 * and argv[]/envv[] pointer slot to ip_argspace, so that we can
 * full preflight the arg list size.
 *
 * Parameters:	struct image_params *	the image parameter block
 *
 * Returns:	0			Success
 *		!0			Failure: errno
 *
 * Implicit returns;
 *		(imgp-&gt;ip_argc)		Count of arguments, updated
 *		(imgp-&gt;ip_envc)		Count of environment strings, updated
 *		(imgp-&gt;ip_argspace)	Count of remaining of NCARGS
 *		(imgp-&gt;ip_interp_buffer)	Interpreter and args (mutated in place)
 *
 *
 * Note:	The argument and environment vectors are user space pointers
 *		to arrays of user space pointers.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">exec_extract_strings</span>(<span class="enscript-type">struct</span> image_params *imgp)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span>	ptr_size = (imgp-&gt;ip_flags &amp; IMGPF_WAS_64BIT) ? 8 : 4;
	<span class="enscript-type">int</span> new_ptr_size = (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) ? 8 : 4;
	user_addr_t	argv = imgp-&gt;ip_user_argv;
	user_addr_t	envv = imgp-&gt;ip_user_envv;

	<span class="enscript-comment">/*
	 * Adjust space reserved for the path name by however much padding it
	 * needs. Doing this here since we didn't know if this would be a 32- 
	 * or 64-bit process back in exec_save_path.
	 */</span>
	<span class="enscript-keyword">while</span> (imgp-&gt;ip_strspace % new_ptr_size != 0) {
		*imgp-&gt;ip_strendp++ = <span class="enscript-string">'\0'</span>;
		imgp-&gt;ip_strspace--;
		<span class="enscript-comment">/* imgp-&gt;ip_argspace--; not counted towards exec args total */</span>
	}

	<span class="enscript-comment">/*
	 * From now on, we start attributing string space to ip_argspace
	 */</span>
	imgp-&gt;ip_startargv = imgp-&gt;ip_strendp;
	imgp-&gt;ip_argc = 0;

	<span class="enscript-keyword">if</span>((imgp-&gt;ip_flags &amp; IMGPF_INTERPRET) != 0) {
		user_addr_t	arg;
		<span class="enscript-type">char</span> *argstart, *ch;

		<span class="enscript-comment">/* First, the arguments in the &quot;#!&quot; string are tokenized and extracted. */</span>
		argstart = imgp-&gt;ip_interp_buffer;
		<span class="enscript-keyword">while</span> (argstart) {
			ch = argstart;
			<span class="enscript-keyword">while</span> (*ch &amp;&amp; !IS_WHITESPACE(*ch)) {
				ch++;
			}

			<span class="enscript-keyword">if</span> (*ch == <span class="enscript-string">'\0'</span>) {
				<span class="enscript-comment">/* last argument, no need to NUL-terminate */</span>
				error = exec_add_user_string(imgp, CAST_USER_ADDR_T(argstart), UIO_SYSSPACE, TRUE);
				argstart = NULL;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* NUL-terminate */</span>
				*ch = <span class="enscript-string">'\0'</span>;
				error = exec_add_user_string(imgp, CAST_USER_ADDR_T(argstart), UIO_SYSSPACE, TRUE);

				<span class="enscript-comment">/*
				 * Find the next string. We know spaces at the end of the string have already
				 * been stripped.
				 */</span>
				argstart = ch + 1;
				<span class="enscript-keyword">while</span> (IS_WHITESPACE(*argstart)) {
					argstart++;
				}
			}

			<span class="enscript-comment">/* Error-check, regardless of whether this is the last interpreter arg or not */</span>
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			<span class="enscript-keyword">if</span> (imgp-&gt;ip_argspace &lt; new_ptr_size) {
				error = E2BIG;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			}
			imgp-&gt;ip_argspace -= new_ptr_size; <span class="enscript-comment">/* to hold argv[] entry */</span>
			imgp-&gt;ip_argc++;
		}

		<span class="enscript-keyword">if</span> (argv != 0LL) {
			<span class="enscript-comment">/*
			 * If we are running an interpreter, replace the av[0] that was
			 * passed to execve() with the path name that was
			 * passed to execve() for interpreters which do not use the PATH
			 * to locate their script arguments.
			 */</span>
			error = copyinptr(argv, &amp;arg, ptr_size);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			<span class="enscript-keyword">if</span> (arg != 0LL) {
				argv += ptr_size; <span class="enscript-comment">/* consume without using */</span>
			}
		}

		<span class="enscript-keyword">if</span> (imgp-&gt;ip_interp_sugid_fd != -1) {
			<span class="enscript-type">char</span> temp[19]; <span class="enscript-comment">/* &quot;/dev/fd/&quot; + 10 digits + NUL */</span>
			snprintf(temp, <span class="enscript-keyword">sizeof</span>(temp), <span class="enscript-string">&quot;/dev/fd/%d&quot;</span>, imgp-&gt;ip_interp_sugid_fd);
			error = exec_add_user_string(imgp, CAST_USER_ADDR_T(temp), UIO_SYSSPACE, TRUE);
		} <span class="enscript-keyword">else</span> {
			error = exec_add_user_string(imgp, imgp-&gt;ip_user_fname, imgp-&gt;ip_seg, TRUE);
		}
		
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_argspace &lt; new_ptr_size) {
			error = E2BIG;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		imgp-&gt;ip_argspace -= new_ptr_size; <span class="enscript-comment">/* to hold argv[] entry */</span>
		imgp-&gt;ip_argc++;
	}

	<span class="enscript-keyword">while</span> (argv != 0LL) {
		user_addr_t	arg;

		error = copyinptr(argv, &amp;arg, ptr_size);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

		<span class="enscript-keyword">if</span> (arg == 0LL) {
			<span class="enscript-keyword">break</span>;
		}

		argv += ptr_size;

		<span class="enscript-comment">/*
		* av[n...] = arg[n]
		*/</span>
		error = exec_add_user_string(imgp, arg, imgp-&gt;ip_seg, TRUE);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_argspace &lt; new_ptr_size) {
			error = E2BIG;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		imgp-&gt;ip_argspace -= new_ptr_size; <span class="enscript-comment">/* to hold argv[] entry */</span>
		imgp-&gt;ip_argc++;
	}	 

	<span class="enscript-comment">/* Save space for argv[] NULL terminator */</span>
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_argspace &lt; new_ptr_size) {
		error = E2BIG;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	imgp-&gt;ip_argspace -= new_ptr_size;
	
	<span class="enscript-comment">/* Note where the args ends and env begins. */</span>
	imgp-&gt;ip_endargv = imgp-&gt;ip_strendp;
	imgp-&gt;ip_envc = 0;

	<span class="enscript-comment">/* Now, get the environment */</span>
	<span class="enscript-keyword">while</span> (envv != 0LL) {
		user_addr_t	env;

		error = copyinptr(envv, &amp;env, ptr_size);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

		envv += ptr_size;
		<span class="enscript-keyword">if</span> (env == 0LL) {
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		* av[n...] = env[n]
		*/</span>
		error = exec_add_user_string(imgp, env, imgp-&gt;ip_seg, TRUE);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_argspace &lt; new_ptr_size) {
			error = E2BIG;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		imgp-&gt;ip_argspace -= new_ptr_size; <span class="enscript-comment">/* to hold envv[] entry */</span>
		imgp-&gt;ip_envc++;
	}

	<span class="enscript-comment">/* Save space for envv[] NULL terminator */</span>
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_argspace &lt; new_ptr_size) {
		error = E2BIG;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	imgp-&gt;ip_argspace -= new_ptr_size;

	<span class="enscript-comment">/* Align the tail of the combined argv+envv area */</span>
	<span class="enscript-keyword">while</span> (imgp-&gt;ip_strspace % new_ptr_size != 0) {
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_argspace &lt; 1) {
			error = E2BIG;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		*imgp-&gt;ip_strendp++ = <span class="enscript-string">'\0'</span>;
		imgp-&gt;ip_strspace--;
		imgp-&gt;ip_argspace--;
	}
	
	<span class="enscript-comment">/* Note where the envv ends and applev begins. */</span>
	imgp-&gt;ip_endenvv = imgp-&gt;ip_strendp;

	<span class="enscript-comment">/*
	 * From now on, we are no longer charging argument
	 * space to ip_argspace.
	 */</span>

<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">random_hex_str</span>(<span class="enscript-type">char</span> *str, <span class="enscript-type">int</span> len, boolean_t embedNUL)
{
	uint64_t low, high, value;
	<span class="enscript-type">int</span> idx;
	<span class="enscript-type">char</span> digit;

	<span class="enscript-comment">/* A 64-bit value will only take 16 characters, plus '0x' and NULL. */</span>
	<span class="enscript-keyword">if</span> (len &gt; 19)
		len = 19;

	<span class="enscript-comment">/* We need enough room for at least 1 digit */</span>
	<span class="enscript-keyword">if</span> (len &lt; 4)
		<span class="enscript-keyword">return</span> (NULL);

	low = random();
	high = random();
	value = high &lt;&lt; 32 | low;

	<span class="enscript-keyword">if</span> (embedNUL) {
		<span class="enscript-comment">/*
		 * Zero a byte to protect against C string vulnerabilities
		 * e.g. for userland __stack_chk_guard.
		 */</span> 
		value &amp;= ~(0xffull &lt;&lt; 8);
	}

	str[0] = <span class="enscript-string">'0'</span>;
	str[1] = <span class="enscript-string">'x'</span>;
	<span class="enscript-keyword">for</span> (idx = 2; idx &lt; len - 1; idx++) {
		digit = value &amp; 0xf;
		value = value &gt;&gt; 4;
		<span class="enscript-keyword">if</span> (digit &lt; 10)
			str[idx] = <span class="enscript-string">'0'</span> + digit;
		<span class="enscript-keyword">else</span>
			str[idx] = <span class="enscript-string">'a'</span> + (digit - 10);
	}
	str[idx] = <span class="enscript-string">'\0'</span>;
	<span class="enscript-keyword">return</span> (str);
}

<span class="enscript-comment">/*
 * Libc has an 8-element array set up for stack guard values.  It only fills
 * in one of those entries, and both gcc and llvm seem to use only a single
 * 8-byte guard.  Until somebody needs more than an 8-byte guard value, don't
 * do the work to construct them.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">GUARD_VALUES</span> 1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">GUARD_KEY</span> <span class="enscript-string">&quot;stack_guard=&quot;</span>

<span class="enscript-comment">/*
 * System malloc needs some entropy when it is initialized.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">ENTROPY_VALUES</span> 2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">ENTROPY_KEY</span> <span class="enscript-string">&quot;malloc_entropy=&quot;</span>

<span class="enscript-comment">/*
 * System malloc engages nanozone for UIAPP.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NANO_ENGAGE_KEY</span> <span class="enscript-string">&quot;MallocNanoZone=1&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PFZ_KEY</span> <span class="enscript-string">&quot;pfz=&quot;</span>
<span class="enscript-type">extern</span> user32_addr_t commpage_text32_location;
<span class="enscript-type">extern</span> user64_addr_t commpage_text64_location;
<span class="enscript-comment">/*
 * Build up the contents of the apple[] string vector
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">exec_add_apple_strings</span>(<span class="enscript-type">struct</span> image_params *imgp)
{
	<span class="enscript-type">int</span> i, error;
	<span class="enscript-type">int</span> new_ptr_size=4;
	<span class="enscript-type">char</span> guard[19];
	<span class="enscript-type">char</span> guard_vec[strlen(GUARD_KEY) + 19 * GUARD_VALUES + 1];

	<span class="enscript-type">char</span> entropy[19];
	<span class="enscript-type">char</span> entropy_vec[strlen(ENTROPY_KEY) + 19 * ENTROPY_VALUES + 1];

	<span class="enscript-type">char</span> pfz_string[strlen(PFZ_KEY) + 16 + 4 +1];
	
	<span class="enscript-keyword">if</span>( imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) {
		new_ptr_size = 8;
		snprintf(pfz_string, <span class="enscript-keyword">sizeof</span>(pfz_string),PFZ_KEY <span class="enscript-string">&quot;0x%llx&quot;</span>,commpage_text64_location);
	} <span class="enscript-keyword">else</span> {
		snprintf(pfz_string, <span class="enscript-keyword">sizeof</span>(pfz_string),PFZ_KEY <span class="enscript-string">&quot;0x%x&quot;</span>,commpage_text32_location);
	}

	<span class="enscript-comment">/* exec_save_path stored the first string */</span>
	imgp-&gt;ip_applec = 1;

	<span class="enscript-comment">/* adding the pfz string */</span>
	error = exec_add_user_string(imgp, CAST_USER_ADDR_T(pfz_string),UIO_SYSSPACE,FALSE);
	<span class="enscript-keyword">if</span>(error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	imgp-&gt;ip_applec++;

	<span class="enscript-comment">/* adding the NANO_ENGAGE_KEY key */</span>
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_px_sa) {
		<span class="enscript-type">int</span> proc_flags = (((<span class="enscript-type">struct</span> _posix_spawnattr *) imgp-&gt;ip_px_sa)-&gt;psa_flags);

		<span class="enscript-keyword">if</span> ((proc_flags &amp; _POSIX_SPAWN_NANO_ALLOCATOR) == _POSIX_SPAWN_NANO_ALLOCATOR) {
			<span class="enscript-type">char</span> uiapp_string[strlen(NANO_ENGAGE_KEY) + 1];

			snprintf(uiapp_string, <span class="enscript-keyword">sizeof</span>(uiapp_string), NANO_ENGAGE_KEY);
			error = exec_add_user_string(imgp, CAST_USER_ADDR_T(uiapp_string),UIO_SYSSPACE,FALSE);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
			imgp-&gt;ip_applec++;
		}
	}

	<span class="enscript-comment">/*
	 * Supply libc with a collection of random values to use when
	 * implementing -fstack-protector.
	 *
	 * (The first random string always contains an embedded NUL so that
	 * __stack_chk_guard also protects against C string vulnerabilities)
	 */</span>
	(<span class="enscript-type">void</span>)strlcpy(guard_vec, GUARD_KEY, <span class="enscript-keyword">sizeof</span> (guard_vec));
	<span class="enscript-keyword">for</span> (i = 0; i &lt; GUARD_VALUES; i++) {
		random_hex_str(guard, <span class="enscript-keyword">sizeof</span> (guard), i == 0);
		<span class="enscript-keyword">if</span> (i)
			(<span class="enscript-type">void</span>)strlcat(guard_vec, <span class="enscript-string">&quot;,&quot;</span>, <span class="enscript-keyword">sizeof</span> (guard_vec));
		(<span class="enscript-type">void</span>)strlcat(guard_vec, guard, <span class="enscript-keyword">sizeof</span> (guard_vec));
	}

	error = exec_add_user_string(imgp, CAST_USER_ADDR_T(guard_vec), UIO_SYSSPACE, FALSE);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	imgp-&gt;ip_applec++;

	<span class="enscript-comment">/*
	 * Supply libc with entropy for system malloc.
	 */</span>
	(<span class="enscript-type">void</span>)strlcpy(entropy_vec, ENTROPY_KEY, <span class="enscript-keyword">sizeof</span>(entropy_vec));
	<span class="enscript-keyword">for</span> (i = 0; i &lt; ENTROPY_VALUES; i++) {
		random_hex_str(entropy, <span class="enscript-keyword">sizeof</span> (entropy), FALSE);
		<span class="enscript-keyword">if</span> (i)
			(<span class="enscript-type">void</span>)strlcat(entropy_vec, <span class="enscript-string">&quot;,&quot;</span>, <span class="enscript-keyword">sizeof</span> (entropy_vec));
		(<span class="enscript-type">void</span>)strlcat(entropy_vec, entropy, <span class="enscript-keyword">sizeof</span> (entropy_vec));
	}
	
	error = exec_add_user_string(imgp, CAST_USER_ADDR_T(entropy_vec), UIO_SYSSPACE, FALSE);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	imgp-&gt;ip_applec++;

	<span class="enscript-comment">/* Align the tail of the combined applev area */</span>
	<span class="enscript-keyword">while</span> (imgp-&gt;ip_strspace % new_ptr_size != 0) {
		*imgp-&gt;ip_strendp++ = <span class="enscript-string">'\0'</span>;
		imgp-&gt;ip_strspace--;
	}

<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">return</span> error;
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">unix_stack_size</span>(p)	(p-&gt;p_rlimit[RLIMIT_STACK].rlim_cur)

<span class="enscript-comment">/*
 * exec_check_permissions
 *
 * Description:	Verify that the file that is being attempted to be executed
 *		is in fact allowed to be executed based on it POSIX file
 *		permissions and other access control criteria
 *
 * Parameters:	struct image_params *	the image parameter block
 *
 * Returns:	0			Success
 *		EACCES			Permission denied
 *		ENOEXEC			Executable file format error
 *		ETXTBSY			Text file busy [misuse of error code]
 *	vnode_getattr:???
 *	vnode_authorize:???
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">exec_check_permissions</span>(<span class="enscript-type">struct</span> image_params *imgp)
{
	<span class="enscript-type">struct</span> vnode *vp = imgp-&gt;ip_vp;
	<span class="enscript-type">struct</span> vnode_attr *vap = imgp-&gt;ip_vattr;
	proc_t p = vfs_context_proc(imgp-&gt;ip_vfs_context);
	<span class="enscript-type">int</span> error;
	kauth_action_t action;

	<span class="enscript-comment">/* Only allow execution of regular files */</span>
	<span class="enscript-keyword">if</span> (!vnode_isreg(vp))
		<span class="enscript-keyword">return</span> (EACCES);
	
	<span class="enscript-comment">/* Get the file attributes that we will be using here and elsewhere */</span>
	VATTR_INIT(vap);
	VATTR_WANTED(vap, va_uid);
	VATTR_WANTED(vap, va_gid);
	VATTR_WANTED(vap, va_mode);
	VATTR_WANTED(vap, va_fsid);
	VATTR_WANTED(vap, va_fileid);
	VATTR_WANTED(vap, va_data_size);
	<span class="enscript-keyword">if</span> ((error = vnode_getattr(vp, vap, imgp-&gt;ip_vfs_context)) != 0)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * Ensure that at least one execute bit is on - otherwise root
	 * will always succeed, and we don't want to happen unless the
	 * file really is executable.
	 */</span>
	<span class="enscript-keyword">if</span> (!vfs_authopaque(vnode_mount(vp)) &amp;&amp; ((vap-&gt;va_mode &amp; (S_IXUSR | S_IXGRP | S_IXOTH)) == 0))
		<span class="enscript-keyword">return</span> (EACCES);

	<span class="enscript-comment">/* Disallow zero length files */</span>
	<span class="enscript-keyword">if</span> (vap-&gt;va_data_size == 0)
		<span class="enscript-keyword">return</span> (ENOEXEC);

	imgp-&gt;ip_arch_offset = (user_size_t)0;
	imgp-&gt;ip_arch_size = vap-&gt;va_data_size;

	<span class="enscript-comment">/* Disable setuid-ness for traced programs or if MNT_NOSUID */</span>
	<span class="enscript-keyword">if</span> ((vp-&gt;v_mount-&gt;mnt_flag &amp; MNT_NOSUID) || (p-&gt;p_lflag &amp; P_LTRACED))
		vap-&gt;va_mode &amp;= ~(VSUID | VSGID);

	<span class="enscript-comment">/*
	 * Disable _POSIX_SPAWN_ALLOW_DATA_EXEC and _POSIX_SPAWN_DISABLE_ASLR
	 * flags for setuid/setgid binaries.
	 */</span>
	<span class="enscript-keyword">if</span> (vap-&gt;va_mode &amp; (VSUID | VSGID))
		imgp-&gt;ip_flags &amp;= ~(IMGPF_ALLOW_DATA_EXEC | IMGPF_DISABLE_ASLR);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_vnode_check_exec(imgp-&gt;ip_vfs_context, vp, imgp);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span>

  	<span class="enscript-comment">/* Check for execute permission */</span>
 	action = KAUTH_VNODE_EXECUTE;
  	<span class="enscript-comment">/* Traced images must also be readable */</span>
 	<span class="enscript-keyword">if</span> (p-&gt;p_lflag &amp; P_LTRACED)
 		action |= KAUTH_VNODE_READ_DATA;
 	<span class="enscript-keyword">if</span> ((error = vnode_authorize(vp, NULL, action, imgp-&gt;ip_vfs_context)) != 0)
		<span class="enscript-keyword">return</span> (error);

#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/* Don't let it run if anyone had it open for writing */</span>
	vnode_lock(vp);
	<span class="enscript-keyword">if</span> (vp-&gt;v_writecount) {
		panic(<span class="enscript-string">&quot;going to return ETXTBSY %x&quot;</span>, vp);
		vnode_unlock(vp);
		<span class="enscript-keyword">return</span> (ETXTBSY);
	}
	vnode_unlock(vp);
#<span class="enscript-reference">endif</span>


	<span class="enscript-comment">/* XXX May want to indicate to underlying FS that vnode is open */</span>

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * exec_handle_sugid
 *
 * Initially clear the P_SUGID in the process flags; if an SUGID process is
 * exec'ing a non-SUGID image, then  this is the point of no return.
 *
 * If the image being activated is SUGID, then replace the credential with a
 * copy, disable tracing (unless the tracing process is root), reset the
 * mach task port to revoke it, set the P_SUGID bit,
 *
 * If the saved user and group ID will be changing, then make sure it happens
 * to a new credential, rather than a shared one.
 *
 * Set the security token (this is probably obsolete, given that the token
 * should not technically be separate from the credential itself).
 *
 * Parameters:	struct image_params *	the image parameter block
 *
 * Returns:	void			No failure indication
 *
 * Implicit returns:
 *		&lt;process credential&gt;	Potentially modified/replaced
 *		&lt;task port&gt;		Potentially revoked
 *		&lt;process flags&gt;		P_SUGID bit potentially modified
 *		&lt;security token&gt;	Potentially modified
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">exec_handle_sugid</span>(<span class="enscript-type">struct</span> image_params *imgp)
{
	kauth_cred_t		cred = vfs_context_ucred(imgp-&gt;ip_vfs_context);
	proc_t			p = vfs_context_proc(imgp-&gt;ip_vfs_context);
	<span class="enscript-type">int</span>			i;
	<span class="enscript-type">int</span>			leave_sugid_clear = 0;
	<span class="enscript-type">int</span>			mac_reset_ipc = 0;
	<span class="enscript-type">int</span>			error = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-type">int</span>			mac_transition, disjoint_cred = 0;
	<span class="enscript-type">int</span> 		label_update_return = 0;

	<span class="enscript-comment">/*
	 * Determine whether a call to update the MAC label will result in the
	 * credential changing.
	 *
	 * Note:	MAC policies which do not actually end up modifying
	 *		the label subsequently are strongly encouraged to
	 *		return 0 for this check, since a non-zero answer will
	 *		slow down the exec fast path for normal binaries.
	 */</span>
	mac_transition = mac_cred_check_label_update_execve(
							imgp-&gt;ip_vfs_context,
							imgp-&gt;ip_vp,
							imgp-&gt;ip_arch_offset,
							imgp-&gt;ip_scriptvp,
							imgp-&gt;ip_scriptlabelp,
							imgp-&gt;ip_execlabelp,
							p,
							imgp-&gt;ip_px_smpx);
#<span class="enscript-reference">endif</span>

	OSBitAndAtomic(~((uint32_t)P_SUGID), &amp;p-&gt;p_flag);

	<span class="enscript-comment">/*
	 * Order of the following is important; group checks must go last,
	 * as we use the success of the 'ismember' check combined with the
	 * failure of the explicit match to indicate that we will be setting
	 * the egid of the process even though the new process did not
	 * require VSUID/VSGID bits in order for it to set the new group as
	 * its egid.
	 *
	 * Note:	Technically, by this we are implying a call to
	 *		setegid() in the new process, rather than implying
	 *		it used its VSGID bit to set the effective group,
	 *		even though there is no code in that process to make
	 *		such a call.
	 */</span>
	<span class="enscript-keyword">if</span> (((imgp-&gt;ip_origvattr-&gt;va_mode &amp; VSUID) != 0 &amp;&amp;
	     kauth_cred_getuid(cred) != imgp-&gt;ip_origvattr-&gt;va_uid) ||
	    ((imgp-&gt;ip_origvattr-&gt;va_mode &amp; VSGID) != 0 &amp;&amp;
		 ((kauth_cred_ismember_gid(cred, imgp-&gt;ip_origvattr-&gt;va_gid, &amp;leave_sugid_clear) || !leave_sugid_clear) ||
		 (kauth_cred_getgid(cred) != imgp-&gt;ip_origvattr-&gt;va_gid)))) {

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
<span class="enscript-comment">/* label for MAC transition and neither VSUID nor VSGID */</span>
<span class="enscript-reference">handle_mac_transition</span>:
#<span class="enscript-reference">endif</span>

		<span class="enscript-comment">/*
		 * Replace the credential with a copy of itself if euid or
		 * egid change.
		 *
		 * Note:	setuid binaries will automatically opt out of
		 *		group resolver participation as a side effect
		 *		of this operation.  This is an intentional
		 *		part of the security model, which requires a
		 *		participating credential be established by
		 *		escalating privilege, setting up all other
		 *		aspects of the credential including whether
		 *		or not to participate in external group
		 *		membership resolution, then dropping their
		 *		effective privilege to that of the desired
		 *		final credential state.
		 */</span>
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_origvattr-&gt;va_mode &amp; VSUID) {
			p-&gt;p_ucred  = kauth_cred_setresuid(p-&gt;p_ucred, KAUTH_UID_NONE, imgp-&gt;ip_origvattr-&gt;va_uid, imgp-&gt;ip_origvattr-&gt;va_uid, KAUTH_UID_NONE);
			<span class="enscript-comment">/* update cred on proc */</span>
			PROC_UPDATE_CREDS_ONPROC(p);
		}
		<span class="enscript-keyword">if</span> (imgp-&gt;ip_origvattr-&gt;va_mode &amp; VSGID) {
			p-&gt;p_ucred = kauth_cred_setresgid(p-&gt;p_ucred, KAUTH_GID_NONE, imgp-&gt;ip_origvattr-&gt;va_gid, imgp-&gt;ip_origvattr-&gt;va_gid);
			<span class="enscript-comment">/* update cred on proc */</span>
			PROC_UPDATE_CREDS_ONPROC(p);
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-comment">/* 
		 * If a policy has indicated that it will transition the label,
		 * before making the call into the MAC policies, get a new
		 * duplicate credential, so they can modify it without
		 * modifying any others sharing it.
		 */</span>
		<span class="enscript-keyword">if</span> (mac_transition) { 
			kauth_proc_label_update_execve(p,
						imgp-&gt;ip_vfs_context,
						imgp-&gt;ip_vp, 
						imgp-&gt;ip_arch_offset,
						imgp-&gt;ip_scriptvp,
						imgp-&gt;ip_scriptlabelp,
						imgp-&gt;ip_execlabelp,
						&amp;imgp-&gt;ip_csflags,
						imgp-&gt;ip_px_smpx,
						&amp;disjoint_cred, <span class="enscript-comment">/* will be non zero if disjoint */</span>
						&amp;label_update_return);

			<span class="enscript-keyword">if</span> (disjoint_cred) {
				<span class="enscript-comment">/*
				 * If updating the MAC label resulted in a
				 * disjoint credential, flag that we need to
				 * set the P_SUGID bit.  This protects
				 * against debuggers being attached by an
				 * insufficiently privileged process onto the
				 * result of a transition to a more privileged
				 * credential.
				 */</span>
				leave_sugid_clear = 0;
			}
			
			imgp-&gt;ip_mac_return = label_update_return;
		}
		
		mac_reset_ipc = mac_proc_check_inherit_ipc_ports(p, p-&gt;p_textvp, p-&gt;p_textoff, imgp-&gt;ip_vp, imgp-&gt;ip_arch_offset, imgp-&gt;ip_scriptvp);

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* CONFIG_MACF */</span>

		<span class="enscript-comment">/*
		 * If 'leave_sugid_clear' is non-zero, then we passed the
		 * VSUID and MACF checks, and successfully determined that
		 * the previous cred was a member of the VSGID group, but
		 * that it was not the default at the time of the execve,
		 * and that the post-labelling credential was not disjoint.
		 * So we don't set the P_SUGID or reset mach ports and fds 
		 * on the basis of simply running this code.
		 */</span>
		<span class="enscript-keyword">if</span> (mac_reset_ipc || !leave_sugid_clear) {
			<span class="enscript-comment">/*
			 * Have mach reset the task and thread ports.
			 * We don't want anyone who had the ports before
			 * a setuid exec to be able to access/control the
			 * task/thread after.
			 */</span>
			ipc_task_reset(p-&gt;task);
			ipc_thread_reset((imgp-&gt;ip_new_thread != NULL) ?
				 	 imgp-&gt;ip_new_thread : current_thread());
		}

		<span class="enscript-keyword">if</span> (!leave_sugid_clear) {
			<span class="enscript-comment">/*
			 * Flag the process as setuid.
			 */</span>
			OSBitOrAtomic(P_SUGID, &amp;p-&gt;p_flag);

			<span class="enscript-comment">/*
			 * Radar 2261856; setuid security hole fix
			 * XXX For setuid processes, attempt to ensure that
			 * stdin, stdout, and stderr are already allocated.
			 * We do not want userland to accidentally allocate
			 * descriptors in this range which has implied meaning
			 * to libc.
			 */</span>
			<span class="enscript-keyword">for</span> (i = 0; i &lt; 3; i++) {

				<span class="enscript-keyword">if</span> (p-&gt;p_fd-&gt;fd_ofiles[i] != NULL)
					<span class="enscript-keyword">continue</span>;

				<span class="enscript-comment">/*
				 * Do the kernel equivalent of
				 *
				 * 	if i == 0
				 * 		(void) open(&quot;/dev/null&quot;, O_RDONLY);
				 * 	else 
				 * 		(void) open(&quot;/dev/null&quot;, O_WRONLY);
				 */</span>

				<span class="enscript-type">struct</span> fileproc *fp;
				<span class="enscript-type">int</span> indx;
				<span class="enscript-type">int</span> flag;
				<span class="enscript-type">struct</span> nameidata *ndp = NULL;

				<span class="enscript-keyword">if</span> (i == 0)
					flag = FREAD;
				<span class="enscript-keyword">else</span> 
					flag = FWRITE;

				<span class="enscript-keyword">if</span> ((error = falloc(p,
				    &amp;fp, &amp;indx, imgp-&gt;ip_vfs_context)) != 0)
					<span class="enscript-keyword">continue</span>;

				MALLOC(ndp, <span class="enscript-type">struct</span> nameidata *, <span class="enscript-keyword">sizeof</span>(*ndp), M_TEMP, M_WAITOK | M_ZERO);
				<span class="enscript-keyword">if</span> (ndp == NULL) {
					error = ENOMEM;
					<span class="enscript-keyword">break</span>;
				}

				NDINIT(ndp, LOOKUP, OP_OPEN, FOLLOW, UIO_SYSSPACE,
				    CAST_USER_ADDR_T(<span class="enscript-string">&quot;/dev/null&quot;</span>),
				    imgp-&gt;ip_vfs_context);

				<span class="enscript-keyword">if</span> ((error = vn_open(ndp, flag, 0)) != 0) {
					fp_free(p, indx, fp);
					<span class="enscript-keyword">break</span>;
				}

				<span class="enscript-type">struct</span> fileglob *fg = fp-&gt;f_fglob;

				fg-&gt;fg_flag = flag;
				fg-&gt;fg_ops = &amp;vnops;
				fg-&gt;fg_data = ndp-&gt;ni_vp;

				vnode_put(ndp-&gt;ni_vp);

				proc_fdlock(p);
				procfdtbl_releasefd(p, indx, NULL);
				fp_drop(p, indx, fp, 1);
				proc_fdunlock(p);

				FREE(ndp, M_TEMP);
			}
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * We are here because we were told that the MAC label will
		 * be transitioned, and the binary is not VSUID or VSGID; to
		 * deal with this case, we could either duplicate a lot of
		 * code, or we can indicate we want to default the P_SUGID
		 * bit clear and jump back up.
		 */</span>
		<span class="enscript-keyword">if</span> (mac_transition) {
			leave_sugid_clear = 1;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">handle_mac_transition</span>;
		}
	}

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* CONFIG_MACF */</span>

	<span class="enscript-comment">/*
	 * Implement the semantic where the effective user and group become
	 * the saved user and group in exec'ed programs.
	 */</span>
	p-&gt;p_ucred = kauth_cred_setsvuidgid(p-&gt;p_ucred, kauth_cred_getuid(p-&gt;p_ucred),  kauth_cred_getgid(p-&gt;p_ucred));
	<span class="enscript-comment">/* update cred on proc */</span>
	PROC_UPDATE_CREDS_ONPROC(p);
	
	<span class="enscript-comment">/* Update the process' identity version and set the security token */</span>
	p-&gt;p_idversion++;
	set_security_token(p);

	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * create_unix_stack
 *
 * Description:	Set the user stack address for the process to the provided
 *		address.  If a custom stack was not set as a result of the
 *		load process (i.e. as specified by the image file for the
 *		executable), then allocate the stack in the provided map and
 *		set up appropriate guard pages for enforcing administrative
 *		limits on stack growth, if they end up being needed.
 *
 * Parameters:	p			Process to set stack on
 *		load_result		Information from mach-o load commands
 *		map			Address map in which to allocate the new stack
 *
 * Returns:	KERN_SUCCESS		Stack successfully created
 *		!KERN_SUCCESS		Mach failure code
 */</span>
<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">create_unix_stack</span>(vm_map_t map, load_result_t* load_result, 
			proc_t p)
{
	mach_vm_size_t		size, prot_size;
	mach_vm_offset_t	addr, prot_addr;
	kern_return_t		kr;

	mach_vm_address_t	user_stack = load_result-&gt;user_stack;
	
	proc_lock(p);
	p-&gt;user_stack = user_stack;
	proc_unlock(p);

	<span class="enscript-keyword">if</span> (!load_result-&gt;prog_allocated_stack) {
		<span class="enscript-comment">/*
		 * Allocate enough space for the maximum stack size we
		 * will ever authorize and an extra page to act as
		 * a guard page for stack overflows. For default stacks,
		 * vm_initial_limit_stack takes care of the extra guard page.
		 * Otherwise we must allocate it ourselves.
		 */</span>

		size = mach_vm_round_page(load_result-&gt;user_stack_size);
		<span class="enscript-keyword">if</span> (load_result-&gt;prog_stack_size)
			size += PAGE_SIZE;
		addr = mach_vm_trunc_page(load_result-&gt;user_stack - size);
		kr = mach_vm_allocate(map, &amp;addr, size,
					VM_MAKE_TAG(VM_MEMORY_STACK) |
					VM_FLAGS_FIXED);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			<span class="enscript-comment">/* If can't allocate at default location, try anywhere */</span>
			addr = 0;
			kr = mach_vm_allocate(map, &amp;addr, size,
								  VM_MAKE_TAG(VM_MEMORY_STACK) |
								  VM_FLAGS_ANYWHERE);
			<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
				<span class="enscript-keyword">return</span> kr;

			user_stack = addr + size;
			load_result-&gt;user_stack = user_stack;

			proc_lock(p);
			p-&gt;user_stack = user_stack;
			proc_unlock(p);
		}

		<span class="enscript-comment">/*
		 * And prevent access to what's above the current stack
		 * size limit for this process.
		 */</span>
		prot_addr = addr;
		<span class="enscript-keyword">if</span> (load_result-&gt;prog_stack_size)
			prot_size = PAGE_SIZE;
		<span class="enscript-keyword">else</span>
			prot_size = mach_vm_trunc_page(size - unix_stack_size(p));
		kr = mach_vm_protect(map,
							 prot_addr,
							 prot_size,
							 FALSE,
							 VM_PROT_NONE);
		<span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
			(<span class="enscript-type">void</span>) mach_vm_deallocate(map, addr, size);
			<span class="enscript-keyword">return</span> kr;
		}
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/reboot.h&gt;</span>

<span class="enscript-comment">/*
 * load_init_program_at_path
 *
 * Description:	Load the &quot;init&quot; program; in most cases, this will be &quot;launchd&quot;
 *
 * Parameters:	p			Process to call execve() to create
 *					the &quot;init&quot; program
 *		scratch_addr		Page in p, scratch space
 *		path			NULL terminated path
 *
 * Returns:	KERN_SUCCESS		Success
 *		!KERN_SUCCESS 		See execve/mac_execve for error codes
 *
 * Notes:	The process that is passed in is the first manufactured
 *		process on the system, and gets here via bsd_ast() firing
 *		for the first time.  This is done to ensure that bsd_init()
 *		has run to completion.
 *
 *		The address map of the first manufactured process is 32 bit.
 *		WHEN this becomes 64b, this code will fail; it needs to be
 *		made 64b capable.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">load_init_program_at_path</span>(proc_t p, user_addr_t scratch_addr, <span class="enscript-type">const</span> <span class="enscript-type">char</span>* path)
{
	uint32_t argv[3];
 	uint32_t argc = 0;
	<span class="enscript-type">int</span> retval[2];
	<span class="enscript-type">struct</span> execve_args init_exec_args;

	<span class="enscript-comment">/*
	 * Validate inputs and pre-conditions
	 */</span>
	assert(p);
	assert(scratch_addr);
	assert(path);

	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		panic(<span class="enscript-string">&quot;Init against 64b primordial proc not implemented&quot;</span>);
	}

	<span class="enscript-comment">/*
	 * Copy out program name.
	 */</span>
	size_t path_length = strlen(path) + 1;
	(<span class="enscript-type">void</span>) copyout(path, scratch_addr, path_length);

	argv[argc++] = (uint32_t)scratch_addr;
	scratch_addr = USER_ADDR_ALIGN(scratch_addr + path_length, 16);

	<span class="enscript-comment">/*
	 * Put out first (and only) argument, similarly.
	 * Assumes everything fits in a page as allocated above.
	 */</span>
	<span class="enscript-keyword">if</span> (boothowto &amp; RB_SINGLE) {
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *init_args = <span class="enscript-string">&quot;-s&quot;</span>;
		size_t init_args_length = strlen(init_args)+1;

		copyout(init_args, scratch_addr, init_args_length);

		argv[argc++] = (uint32_t)scratch_addr;
		scratch_addr = USER_ADDR_ALIGN(scratch_addr + init_args_length, 16);
	}

	<span class="enscript-comment">/*
	 * Null-end the argument list
	 */</span>
	argv[argc] = 0;
	
	<span class="enscript-comment">/*
	 * Copy out the argument list.
	 */</span>
	(<span class="enscript-type">void</span>) copyout(argv, scratch_addr, <span class="enscript-keyword">sizeof</span>(argv));

	<span class="enscript-comment">/*
	 * Set up argument block for fake call to execve.
	 */</span>
	init_exec_args.fname = CAST_USER_ADDR_T(argv[0]);
	init_exec_args.argp = scratch_addr;
	init_exec_args.envp = USER_ADDR_NULL;

	<span class="enscript-comment">/*
	 * So that init task is set with uid,gid 0 token
	 */</span>
	set_security_token(p);

	<span class="enscript-keyword">return</span> execve(p, &amp;init_exec_args, retval);
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> * init_programs[] = {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-string">&quot;/usr/local/sbin/launchd.debug&quot;</span>,
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-comment">/* Remove DEBUG conditional when &lt;rdar://problem/17931977&gt; is fixed */</span>
	<span class="enscript-string">&quot;/usr/local/sbin/launchd.development&quot;</span>,
#<span class="enscript-reference">endif</span>
	<span class="enscript-string">&quot;/sbin/launchd&quot;</span>,
};

<span class="enscript-comment">/*
 * load_init_program
 *
 * Description:	Load the &quot;init&quot; program; in most cases, this will be &quot;launchd&quot;
 *
 * Parameters:	p			Process to call execve() to create
 *					the &quot;init&quot; program
 *
 * Returns:	(void)
 *
 * Notes:	The process that is passed in is the first manufactured
 *		process on the system, and gets here via bsd_ast() firing
 *		for the first time.  This is done to ensure that bsd_init()
 *		has run to completion.
 *
 *		In DEBUG &amp; DEVELOPMENT builds, the launchdsuffix boot-arg
 *		may be used to select a specific launchd executable. As with
 *		the kcsuffix boot-arg, setting launchdsuffix to &quot;&quot; or &quot;release&quot;
 *		will force /sbin/launchd to be selected.
 *
 *		The DEBUG kernel will continue to check for a .development
 *		version until &lt;rdar://problem/17931977&gt; is fixed.
 *
 *              Search order by build:
 *
 * DEBUG	DEVELOPMENT	RELEASE		PATH
 * ----------------------------------------------------------------------------------
 * 1		1		NA		/usr/local/sbin/launchd.$LAUNCHDSUFFIX
 * 2		NA		NA		/usr/local/sbin/launchd.debug
 * 3		2		NA		/usr/local/sbin/launchd.development
 * 4		3		1		/sbin/launchd
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">load_init_program</span>(proc_t p)
{
	uint32_t i;
	<span class="enscript-type">int</span> error;
	vm_offset_t scratch_addr = VM_MIN_ADDRESS;

	(<span class="enscript-type">void</span>) vm_allocate(current_map(), &amp;scratch_addr, PAGE_SIZE, VM_FLAGS_ANYWHERE);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span> &amp;&amp; <span class="enscript-variable-name">CONFIG_JETSAM</span>
	(<span class="enscript-type">void</span>) memorystatus_init_at_boot_snapshot();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MEMORYSTATUS &amp;&amp; CONFIG_JETSAM */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span> || <span class="enscript-variable-name">DEVELOPMENT</span>
	<span class="enscript-comment">/* Check for boot-arg suffix first */</span>
	<span class="enscript-type">char</span> launchd_suffix[64];
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;launchdsuffix&quot;</span>, launchd_suffix, <span class="enscript-keyword">sizeof</span>(launchd_suffix))) {
		<span class="enscript-type">char</span> launchd_path[128];
		boolean_t is_release_suffix = ((launchd_suffix[0] == 0) ||
					       (strcmp(launchd_suffix, <span class="enscript-string">&quot;release&quot;</span>) == 0));

		<span class="enscript-keyword">if</span> (is_release_suffix) {
			error = load_init_program_at_path(p, CAST_USER_ADDR_T(scratch_addr), <span class="enscript-string">&quot;/sbin/launchd&quot;</span>);
			<span class="enscript-keyword">if</span> (!error)
				<span class="enscript-keyword">return</span>;

			panic(<span class="enscript-string">&quot;Process 1 exec of launchd.release failed, errno %d&quot;</span>, error);
		} <span class="enscript-keyword">else</span> {
			strlcpy(launchd_path, <span class="enscript-string">&quot;/usr/local/sbin/launchd.&quot;</span>, <span class="enscript-keyword">sizeof</span>(launchd_path));
			strlcat(launchd_path, launchd_suffix, <span class="enscript-keyword">sizeof</span>(launchd_path));

			<span class="enscript-comment">/* All the error data is lost in the loop below, don't
			 * attempt to save it. */</span>
			<span class="enscript-keyword">if</span> (!load_init_program_at_path(p, CAST_USER_ADDR_T(scratch_addr), launchd_path)) {
				<span class="enscript-keyword">return</span>;
			}
		}
	}
#<span class="enscript-reference">endif</span>

	error = ENOENT;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; <span class="enscript-keyword">sizeof</span>(init_programs)/<span class="enscript-keyword">sizeof</span>(init_programs[0]); i++) {
		error = load_init_program_at_path(p, CAST_USER_ADDR_T(scratch_addr), init_programs[i]);
		<span class="enscript-keyword">if</span> (!error)
			<span class="enscript-keyword">return</span>;
	}

	panic(<span class="enscript-string">&quot;Process 1 exec of %s failed, errno %d&quot;</span>, ((i == 0) ? <span class="enscript-string">&quot;&lt;null&gt;&quot;</span> : init_programs[i-1]), error);
}

<span class="enscript-comment">/*
 * load_return_to_errno
 *
 * Description:	Convert a load_return_t (Mach error) to an errno (BSD error)
 *
 * Parameters:	lrtn			Mach error number
 *
 * Returns:	(int)			BSD error number
 *		0			Success
 *		EBADARCH		Bad architecture
 *		EBADMACHO		Bad Mach object file
 *		ESHLIBVERS		Bad shared library version
 *		ENOMEM			Out of memory/resource shortage
 *		EACCES			Access denied
 *		ENOENT			Entry not found (usually &quot;file does
 *					does not exist&quot;)
 *		EIO			An I/O error occurred
 *		EBADEXEC		The executable is corrupt/unknown
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">load_return_to_errno</span>(load_return_t lrtn)
{
	<span class="enscript-keyword">switch</span> (lrtn) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LOAD_SUCCESS</span>:
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LOAD_BADARCH</span>:
		<span class="enscript-keyword">return</span> EBADARCH;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LOAD_BADMACHO</span>:
		<span class="enscript-keyword">return</span> EBADMACHO;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LOAD_SHLIB</span>:
		<span class="enscript-keyword">return</span> ESHLIBVERS;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LOAD_NOSPACE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LOAD_RESOURCE</span>:
		<span class="enscript-keyword">return</span> ENOMEM;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LOAD_PROTECT</span>:
		<span class="enscript-keyword">return</span> EACCES;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LOAD_ENOENT</span>:
		<span class="enscript-keyword">return</span> ENOENT;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LOAD_IOERROR</span>:
		<span class="enscript-keyword">return</span> EIO;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LOAD_FAILURE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LOAD_DECRYPTFAIL</span>:
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> EBADEXEC;
	}
}

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/semaphore.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sync_policy.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>

<span class="enscript-comment">/*
 * execargs_alloc
 *
 * Description:	Allocate the block of memory used by the execve arguments.
 *		At the same time, we allocate a page so that we can read in
 *		the first page of the image.
 *
 * Parameters:	struct image_params *	the image parameter block
 *
 * Returns:	0			Success
 *		EINVAL			Invalid argument
 *		EACCES			Permission denied
 *		EINTR			Interrupted function
 *		ENOMEM			Not enough space
 *
 * Notes:	This is a temporary allocation into the kernel address space
 *		to enable us to copy arguments in from user space.  This is
 *		necessitated by not mapping the process calling execve() into
 *		the kernel address space during the execve() system call.
 *
 *		We assemble the argument and environment, etc., into this
 *		region before copying it as a single block into the child
 *		process address space (at the top or bottom of the stack,
 *		depending on which way the stack grows; see the function
 *		exec_copyout_strings() for details).
 *
 *		This ends up with a second (possibly unnecessary) copy compared
 *		with assembing the data directly into the child address space,
 *		instead, but since we cannot be guaranteed that the parent has
 *		not modified its environment, we can't really know that it's
 *		really a block there as well.
 */</span>


<span class="enscript-type">static</span> <span class="enscript-type">int</span> execargs_waiters = 0;
lck_mtx_t *execargs_cache_lock;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">execargs_lock_lock</span>(<span class="enscript-type">void</span>) {
	lck_mtx_lock_spin(execargs_cache_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">execargs_lock_unlock</span>(<span class="enscript-type">void</span>) {
	lck_mtx_unlock(execargs_cache_lock);
}

<span class="enscript-type">static</span> wait_result_t
<span class="enscript-function-name">execargs_lock_sleep</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-keyword">return</span>(lck_mtx_sleep(execargs_cache_lock, LCK_SLEEP_DEFAULT, &amp;execargs_free_count, THREAD_INTERRUPTIBLE));
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">execargs_purgeable_allocate</span>(<span class="enscript-type">char</span> **execarg_address) {
	kern_return_t kr = vm_allocate(bsd_pageable_map, (vm_offset_t *)execarg_address, BSD_PAGEABLE_SIZE_PER_EXEC, VM_FLAGS_ANYWHERE | VM_FLAGS_PURGABLE);
	assert(kr == KERN_SUCCESS);
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">execargs_purgeable_reference</span>(<span class="enscript-type">void</span> *execarg_address) {
	<span class="enscript-type">int</span> state = VM_PURGABLE_NONVOLATILE;
	kern_return_t kr = vm_purgable_control(bsd_pageable_map, (vm_offset_t) execarg_address, VM_PURGABLE_SET_STATE, &amp;state);

	assert(kr == KERN_SUCCESS);
	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">execargs_purgeable_volatilize</span>(<span class="enscript-type">void</span> *execarg_address) {
	<span class="enscript-type">int</span> state = VM_PURGABLE_VOLATILE | VM_PURGABLE_ORDERING_OBSOLETE;
	kern_return_t kr;
	kr = vm_purgable_control(bsd_pageable_map, (vm_offset_t) execarg_address, VM_PURGABLE_SET_STATE, &amp;state);

	assert(kr == KERN_SUCCESS);

	<span class="enscript-keyword">return</span> kr;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">execargs_wakeup_waiters</span>(<span class="enscript-type">void</span>) {
	thread_wakeup(&amp;execargs_free_count);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">execargs_alloc</span>(<span class="enscript-type">struct</span> image_params *imgp)
{
	kern_return_t kret;
	wait_result_t res;
	<span class="enscript-type">int</span> i, cache_index = -1;

	execargs_lock_lock();

	<span class="enscript-keyword">while</span> (execargs_free_count == 0) {
		execargs_waiters++;
		res = execargs_lock_sleep();
		execargs_waiters--;
		<span class="enscript-keyword">if</span> (res != THREAD_AWAKENED) {
			execargs_lock_unlock();
			<span class="enscript-keyword">return</span> (EINTR);
		}
	}

	execargs_free_count--;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; execargs_cache_size; i++) {
		vm_offset_t element = execargs_cache[i];
		<span class="enscript-keyword">if</span> (element) {
			cache_index = i;
			imgp-&gt;ip_strings = (<span class="enscript-type">char</span> *)(execargs_cache[i]);
			execargs_cache[i] = 0;
			<span class="enscript-keyword">break</span>;
		}
	}

	assert(execargs_free_count &gt;= 0);

	execargs_lock_unlock();
	
	<span class="enscript-keyword">if</span> (cache_index == -1) {
		kret = execargs_purgeable_allocate(&amp;imgp-&gt;ip_strings);
	}
	<span class="enscript-keyword">else</span>
		kret = execargs_purgeable_reference(imgp-&gt;ip_strings);

	assert(kret == KERN_SUCCESS);
	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	<span class="enscript-comment">/* last page used to read in file headers */</span>
	imgp-&gt;ip_vdata = imgp-&gt;ip_strings + ( NCARGS + PAGE_SIZE );
	imgp-&gt;ip_strendp = imgp-&gt;ip_strings;
	imgp-&gt;ip_argspace = NCARGS;
	imgp-&gt;ip_strspace = ( NCARGS + PAGE_SIZE );

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * execargs_free
 *
 * Description:	Free the block of memory used by the execve arguments and the
 *		first page of the executable by a previous call to the function
 *		execargs_alloc().
 *
 * Parameters:	struct image_params *	the image parameter block
 *
 * Returns:	0			Success
 *		EINVAL			Invalid argument
 *		EINTR			Oeration interrupted
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">execargs_free</span>(<span class="enscript-type">struct</span> image_params *imgp)
{
	kern_return_t kret;
	<span class="enscript-type">int</span> i;
	boolean_t needs_wakeup = FALSE;
	
	kret = execargs_purgeable_volatilize(imgp-&gt;ip_strings);

	execargs_lock_lock();
	execargs_free_count++;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; execargs_cache_size; i++) {
		vm_offset_t element = execargs_cache[i];
		<span class="enscript-keyword">if</span> (element == 0) {
			execargs_cache[i] = (vm_offset_t) imgp-&gt;ip_strings;
			imgp-&gt;ip_strings = NULL;
			<span class="enscript-keyword">break</span>;
		}
	}

	assert(imgp-&gt;ip_strings == NULL);

	<span class="enscript-keyword">if</span> (execargs_waiters &gt; 0)
		needs_wakeup = TRUE;
	
	execargs_lock_unlock();

	<span class="enscript-keyword">if</span> (needs_wakeup == TRUE)
		execargs_wakeup_waiters();

	<span class="enscript-keyword">return</span> ((kret == KERN_SUCCESS ? 0 : EINVAL));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">exec_resettextvp</span>(proc_t p, <span class="enscript-type">struct</span> image_params *imgp)
{
	vnode_t vp;
	off_t offset;
	vnode_t tvp  = p-&gt;p_textvp;
	<span class="enscript-type">int</span> ret;

	vp = imgp-&gt;ip_vp;
	offset = imgp-&gt;ip_arch_offset;

	<span class="enscript-keyword">if</span> (vp == NULLVP)
		panic(<span class="enscript-string">&quot;exec_resettextvp: expected valid vp&quot;</span>);

	ret = vnode_ref(vp);
	proc_lock(p);
	<span class="enscript-keyword">if</span> (ret == 0) {
		p-&gt;p_textvp = vp;
		p-&gt;p_textoff = offset;
	} <span class="enscript-keyword">else</span> {
		p-&gt;p_textvp = NULLVP;	<span class="enscript-comment">/* this is paranoia */</span>
		p-&gt;p_textoff = 0;
	}
	proc_unlock(p);

	<span class="enscript-keyword">if</span> ( tvp != NULLVP) {
		<span class="enscript-keyword">if</span> (vnode_getwithref(tvp) == 0) {
			vnode_rele(tvp);
			vnode_put(tvp);
		}
	}	

}

<span class="enscript-comment">/*
 * If the process is not signed or if it contains entitlements, we
 * need to communicate through the task_access_port to taskgated.
 *
 * taskgated will provide a detached code signature if present, and
 * will enforce any restrictions on entitlements.
 */</span>

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">taskgated_required</span>(proc_t p, boolean_t *require_success)
{
	size_t length;
	<span class="enscript-type">void</span> *blob;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (cs_debug &gt; 2)
		csvnode_print_debug(p-&gt;p_textvp);

	<span class="enscript-type">const</span> <span class="enscript-type">int</span> can_skip_taskgated = csproc_get_platform_binary(p) &amp;&amp; !csproc_get_platform_path(p);
	<span class="enscript-keyword">if</span> (can_skip_taskgated) {
		<span class="enscript-keyword">if</span> (cs_debug) printf(<span class="enscript-string">&quot;taskgated not required for: %s\n&quot;</span>, p-&gt;p_name);
		*require_success = FALSE;
		<span class="enscript-keyword">return</span> FALSE;
	}

	<span class="enscript-keyword">if</span> ((p-&gt;p_csflags &amp; CS_VALID) == 0) {
		*require_success = FALSE;
		<span class="enscript-keyword">return</span> TRUE;
	}

	error = cs_entitlements_blob_get(p, &amp;blob, &amp;length);
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; blob != NULL) {
		<span class="enscript-comment">/*
		 * fatal on the desktop when entitlements are present,
		 * unless we started in single-user mode 
		 */</span>
		<span class="enscript-keyword">if</span> ((boothowto &amp; RB_SINGLE) == 0)
			*require_success = TRUE;
		<span class="enscript-comment">/*
		 * Allow initproc to run without causing taskgated to launch
		 */</span>
		<span class="enscript-keyword">if</span> (p == initproc) {
			*require_success = FALSE;
			<span class="enscript-keyword">return</span> FALSE;
		}

		<span class="enscript-keyword">if</span> (cs_debug) printf(<span class="enscript-string">&quot;taskgated required for: %s\n&quot;</span>, p-&gt;p_name);

		<span class="enscript-keyword">return</span> TRUE;
	}

	*require_success = FALSE;
	<span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-comment">/*
 * __EXEC_WAITING_ON_TASKGATED_CODE_SIGNATURE_UPCALL__
 * 
 * Description: Waits for the userspace daemon to respond to the request
 * 		we made. Function declared non inline to be visible in
 *		stackshots and spindumps as well as debugging.
 */</span>
<span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span> 
<span class="enscript-function-name">__EXEC_WAITING_ON_TASKGATED_CODE_SIGNATURE_UPCALL__</span>(mach_port_t task_access_port, int32_t new_pid)
{
	<span class="enscript-keyword">return</span> find_code_signature(task_access_port, new_pid);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">check_for_signature</span>(proc_t p, <span class="enscript-type">struct</span> image_params *imgp)
{
	mach_port_t port = NULL;
	kern_return_t kr = KERN_FAILURE;
	<span class="enscript-type">int</span> error = EACCES;
	boolean_t unexpected_failure = FALSE;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> hash[SHA1_RESULTLEN];
	boolean_t require_success = FALSE;
	<span class="enscript-type">int</span> spawn = (imgp-&gt;ip_flags &amp; IMGPF_SPAWN);
	<span class="enscript-type">int</span> vfexec = (imgp-&gt;ip_flags &amp; IMGPF_VFORK_EXEC);

	<span class="enscript-comment">/*
	 * Override inherited code signing flags with the
	 * ones for the process that is being successfully
	 * loaded
	 */</span>
	proc_lock(p);
	p-&gt;p_csflags = imgp-&gt;ip_csflags;
	proc_unlock(p);

	<span class="enscript-comment">/* Set the switch_protect flag on the map */</span>
	<span class="enscript-keyword">if</span>(p-&gt;p_csflags &amp; (CS_HARD|CS_KILL)) {
		vm_map_switch_protect(get_task_map(p-&gt;task), TRUE);
	}
	
	<span class="enscript-comment">/*
	 * image activation may be failed due to policy
	 * which is unexpected but security framework does not
	 * approve of exec, kill and return immediately.
	 */</span>
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_mac_return != 0) {
		error = imgp-&gt;ip_mac_return;
		unexpected_failure = TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* check if callout to taskgated is needed */</span>
	<span class="enscript-keyword">if</span> (!taskgated_required(p, &amp;require_success)) {
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	kr = task_get_task_access_port(p-&gt;task, &amp;port);
	<span class="enscript-keyword">if</span> (KERN_SUCCESS != kr || !IPC_PORT_VALID(port)) {
		error = 0;
		<span class="enscript-keyword">if</span> (require_success)
			error = EACCES;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * taskgated returns KERN_SUCCESS if it has completed its work
	 * and the exec should continue, KERN_FAILURE if the exec should 
	 * fail, or it may error out with different error code in an 
	 * event of mig failure (e.g. process was signalled during the 
	 * rpc call, taskgated died, mig server died etc.).
	 */</span>

	kr = __EXEC_WAITING_ON_TASKGATED_CODE_SIGNATURE_UPCALL__(port, p-&gt;p_pid);
	<span class="enscript-keyword">switch</span> (kr) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SUCCESS</span>:
		error = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_FAILURE</span>:
		error = EACCES;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	<span class="enscript-reference">default</span>:
		error = EACCES;
		unexpected_failure = TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* Only do this if exec_resettextvp() did not fail */</span>
	<span class="enscript-keyword">if</span> (p-&gt;p_textvp != NULLVP) {
		<span class="enscript-comment">/*
		 * If there's a new code directory, mark this process
		 * as signed.
		 */</span>
		<span class="enscript-keyword">if</span> (0 == ubc_cs_getcdhash(p-&gt;p_textvp, p-&gt;p_textoff, hash)) {
			proc_lock(p);
			p-&gt;p_csflags |= CS_VALID;
			proc_unlock(p);
		}
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (0 != error) {
		<span class="enscript-keyword">if</span> (!unexpected_failure)
			p-&gt;p_csflags |= CS_KILLED;
		<span class="enscript-comment">/* make very sure execution fails */</span>
		<span class="enscript-keyword">if</span> (vfexec || spawn) {
			psignal_vfork(p, p-&gt;task, imgp-&gt;ip_new_thread, SIGKILL);
			error = 0;
		} <span class="enscript-keyword">else</span> {
			psignal(p, SIGKILL);
		}
	}
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Typically as soon as we start executing this process, the
 * first instruction will trigger a VM fault to bring the text
 * pages (as executable) into the address space, followed soon
 * thereafter by dyld data structures (for dynamic executable).
 * To optimize this, as well as improve support for hardware
 * debuggers that can only access resident pages present
 * in the process' page tables, we prefault some pages if
 * possible. Errors are non-fatal.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">exec_prefault_data</span>(proc_t p __unused, <span class="enscript-type">struct</span> image_params *imgp, load_result_t *load_result)
{
	<span class="enscript-type">int</span> ret;
	size_t expected_all_image_infos_size;

	<span class="enscript-comment">/*
	 * Prefault executable or dyld entry point.
	 */</span>
	vm_fault(current_map(),
		 vm_map_trunc_page(load_result-&gt;entry_point,
				   vm_map_page_mask(current_map())),
		 VM_PROT_READ | VM_PROT_EXECUTE,
		 FALSE,
		 THREAD_UNINT, NULL, 0);
	
	<span class="enscript-keyword">if</span> (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) {
		expected_all_image_infos_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user64_dyld_all_image_infos);
	} <span class="enscript-keyword">else</span> {
		expected_all_image_infos_size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_dyld_all_image_infos);
	}

	<span class="enscript-comment">/* Decode dyld anchor structure from &lt;mach-o/dyld_images.h&gt; */</span>
	<span class="enscript-keyword">if</span> (load_result-&gt;dynlinker &amp;&amp;
		load_result-&gt;all_image_info_addr &amp;&amp;
		load_result-&gt;all_image_info_size &gt;= expected_all_image_infos_size) {
		<span class="enscript-type">union</span> {
			<span class="enscript-type">struct</span> user64_dyld_all_image_infos	infos64;
			<span class="enscript-type">struct</span> user32_dyld_all_image_infos	infos32;
		} all_image_infos;

		<span class="enscript-comment">/*
		 * Pre-fault to avoid copyin() going through the trap handler
		 * and recovery path.
		 */</span>
		vm_fault(current_map(),
			 vm_map_trunc_page(load_result-&gt;all_image_info_addr,
					   vm_map_page_mask(current_map())),
			 VM_PROT_READ | VM_PROT_WRITE,
			 FALSE,
			 THREAD_UNINT, NULL, 0);
		<span class="enscript-keyword">if</span> ((load_result-&gt;all_image_info_addr &amp; PAGE_MASK) + expected_all_image_infos_size &gt; PAGE_SIZE) {
			<span class="enscript-comment">/* all_image_infos straddles a page */</span>
			vm_fault(current_map(),
				 vm_map_trunc_page(load_result-&gt;all_image_info_addr + expected_all_image_infos_size - 1,
						   vm_map_page_mask(current_map())),
				 VM_PROT_READ | VM_PROT_WRITE,
				 FALSE,
				 THREAD_UNINT, NULL, 0);
		}

		ret = copyin(load_result-&gt;all_image_info_addr,
					 &amp;all_image_infos,
					 expected_all_image_infos_size);
		<span class="enscript-keyword">if</span> (ret == 0 &amp;&amp; all_image_infos.infos32.version &gt;= 9) {

			user_addr_t notification_address;
			user_addr_t dyld_image_address;
			user_addr_t dyld_version_address;
			user_addr_t dyld_all_image_infos_address;
			user_addr_t dyld_slide_amount;

			<span class="enscript-keyword">if</span> (imgp-&gt;ip_flags &amp; IMGPF_IS_64BIT) {
				notification_address = all_image_infos.infos64.notification;
				dyld_image_address = all_image_infos.infos64.dyldImageLoadAddress;
				dyld_version_address = all_image_infos.infos64.dyldVersion;
				dyld_all_image_infos_address = all_image_infos.infos64.dyldAllImageInfosAddress;
			} <span class="enscript-keyword">else</span> {
				notification_address = all_image_infos.infos32.notification;
				dyld_image_address = all_image_infos.infos32.dyldImageLoadAddress;
				dyld_version_address = all_image_infos.infos32.dyldVersion;
				dyld_all_image_infos_address = all_image_infos.infos32.dyldAllImageInfosAddress;
			}

			<span class="enscript-comment">/*
			 * dyld statically sets up the all_image_infos in its Mach-O
			 * binary at static link time, with pointers relative to its default
			 * load address. Since ASLR might slide dyld before its first
			 * instruction is executed, &quot;dyld_slide_amount&quot; tells us how far
			 * dyld was loaded compared to its default expected load address.
			 * All other pointers into dyld's image should be adjusted by this
			 * amount. At some point later, dyld will fix up pointers to take
			 * into account the slide, at which point the all_image_infos_address
			 * field in the structure will match the runtime load address, and
			 * &quot;dyld_slide_amount&quot; will be 0, if we were to consult it again.
			 */</span>

			dyld_slide_amount = load_result-&gt;all_image_info_addr - dyld_all_image_infos_address;

#<span class="enscript-reference">if</span> 0
			kprintf(<span class="enscript-string">&quot;exec_prefault: 0x%016llx 0x%08x 0x%016llx 0x%016llx 0x%016llx 0x%016llx\n&quot;</span>,
					(uint64_t)load_result-&gt;all_image_info_addr,
					all_image_infos.infos32.version,
					(uint64_t)notification_address,
					(uint64_t)dyld_image_address,
					(uint64_t)dyld_version_address,
					(uint64_t)dyld_all_image_infos_address);
#<span class="enscript-reference">endif</span>

			vm_fault(current_map(),
				 vm_map_trunc_page(notification_address + dyld_slide_amount,
						   vm_map_page_mask(current_map())),
				 VM_PROT_READ | VM_PROT_EXECUTE,
				 FALSE,
				 THREAD_UNINT, NULL, 0);
			vm_fault(current_map(),
				 vm_map_trunc_page(dyld_image_address + dyld_slide_amount,
						   vm_map_page_mask(current_map())),
				 VM_PROT_READ | VM_PROT_EXECUTE,
				 FALSE,
				 THREAD_UNINT, NULL, 0);
			vm_fault(current_map(),
				 vm_map_trunc_page(dyld_version_address + dyld_slide_amount,
						   vm_map_page_mask(current_map())),
				 VM_PROT_READ,
				 FALSE,
				 THREAD_UNINT, NULL, 0);
			vm_fault(current_map(),
				 vm_map_trunc_page(dyld_all_image_infos_address + dyld_slide_amount,
						   vm_map_page_mask(current_map())),
				 VM_PROT_READ | VM_PROT_WRITE,
				 FALSE,
				 THREAD_UNINT, NULL, 0);
		}
	}
}
</pre>
<hr />
</body></html>