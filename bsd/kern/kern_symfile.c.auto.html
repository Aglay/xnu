<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_symfile.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_symfile.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1998 Apple Computer, Inc.  All rights reserved.
 *
 *	File:	bsd/kern/kern_symfile.c
 *
 * HISTORY
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/timeb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/times.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/acct.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disk.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/content_protection.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/loader.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach-o/nlist.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOPolledInterface.h&gt;</span>

<span class="enscript-comment">/* This function is called from kern_sysctl in the current process context;
 * it is exported with the System6.0.exports, but this appears to be a legacy
 * export, as there are no internal consumers.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">get_kernel_symfile</span>(__unused proc_t p, __unused <span class="enscript-type">char</span> <span class="enscript-type">const</span> **symfile);
<span class="enscript-type">int</span>
<span class="enscript-function-name">get_kernel_symfile</span>(__unused proc_t p, __unused <span class="enscript-type">char</span> <span class="enscript-type">const</span> **symfile)
{
    <span class="enscript-keyword">return</span> KERN_FAILURE;
}

<span class="enscript-type">struct</span> kern_direct_file_io_ref_t
{
    vfs_context_t  ctx;
    <span class="enscript-type">struct</span> vnode * vp;
    dev_t          device;
    uint32_t	   blksize;
    off_t          filelength;
    <span class="enscript-type">char</span>           cf;
    <span class="enscript-type">char</span>           pinned;
};


<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">file_ioctl</span>(<span class="enscript-type">void</span> * p1, <span class="enscript-type">void</span> * p2, u_long theIoctl, caddr_t result)
{
    dev_t device = *(dev_t*) p1;

    <span class="enscript-keyword">return</span> ((*bdevsw[major(device)].d_ioctl)
		    (device, theIoctl, result, S_IFBLK, p2));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">device_ioctl</span>(<span class="enscript-type">void</span> * p1, __unused <span class="enscript-type">void</span> * p2, u_long theIoctl, caddr_t result)
{
    <span class="enscript-keyword">return</span> (VNOP_IOCTL(p1, theIoctl, result, 0, p2));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kern_ioctl_file_extents</span>(<span class="enscript-type">struct</span> kern_direct_file_io_ref_t * ref, u_long theIoctl, off_t offset, off_t end)
{
    <span class="enscript-type">int</span> error = 0;
    <span class="enscript-type">int</span> (*do_ioctl)(<span class="enscript-type">void</span> * p1, <span class="enscript-type">void</span> * p2, u_long theIoctl, caddr_t result);
    <span class="enscript-type">void</span> * p1;
    <span class="enscript-type">void</span> * p2;
    uint64_t    fileblk;
    size_t      filechunk;
    dk_extent_t  extent;
    dk_unmap_t   unmap;
    _dk_cs_pin_t pin;

    bzero(&amp;extent, <span class="enscript-keyword">sizeof</span>(dk_extent_t));
    bzero(&amp;unmap, <span class="enscript-keyword">sizeof</span>(dk_unmap_t));
    bzero(&amp;pin, <span class="enscript-keyword">sizeof</span>(pin));
    <span class="enscript-keyword">if</span> (ref-&gt;vp-&gt;v_type == VREG)
    {
	 p1 = &amp;ref-&gt;device;
	 p2 = kernproc;
	 do_ioctl = &amp;file_ioctl;
    }
    <span class="enscript-keyword">else</span>
    {
	<span class="enscript-comment">/* Partition. */</span>
	p1 = ref-&gt;vp;
	p2 = ref-&gt;ctx;
	do_ioctl = &amp;device_ioctl;
    }

    <span class="enscript-keyword">if</span> (_DKIOCCSPINEXTENT == theIoctl) {
	    <span class="enscript-comment">/* Tell CS the image size, so it knows whether to place the subsequent pins SSD/HDD */</span>
	    pin.cp_extent.length = end;
	    pin.cp_flags = _DKIOCCSHIBERNATEIMGSIZE;
	    (<span class="enscript-type">void</span>) do_ioctl(p1, p2, _DKIOCCSPINEXTENT, (caddr_t)&amp;pin);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (_DKIOCCSUNPINEXTENT == theIoctl) {
	    <span class="enscript-comment">/* Tell CS hibernation is done, so it can stop blocking overlapping writes */</span>
	    pin.cp_flags = _DKIOCCSPINDISCARDBLACKLIST;
	    (<span class="enscript-type">void</span>) do_ioctl(p1, p2, _DKIOCCSUNPINEXTENT, (caddr_t)&amp;pin);
    }

    <span class="enscript-keyword">while</span> (offset &lt; end) 
    {
        <span class="enscript-keyword">if</span> (ref-&gt;vp-&gt;v_type == VREG)
        {
            daddr64_t blkno;
	    filechunk = 1*1024*1024*1024;
	    <span class="enscript-keyword">if</span> (filechunk &gt; (size_t)(end - offset))
	    filechunk = (size_t)(end - offset);
            error = VNOP_BLOCKMAP(ref-&gt;vp, offset, filechunk, &amp;blkno,
								  &amp;filechunk, NULL, VNODE_WRITE, NULL);
			<span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">break</span>;
            fileblk = blkno * ref-&gt;blksize;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ref-&gt;vp-&gt;v_type == VBLK) || (ref-&gt;vp-&gt;v_type == VCHR))
        {
            fileblk = offset;
            filechunk = ref-&gt;filelength;
        }

	<span class="enscript-keyword">if</span> (DKIOCUNMAP == theIoctl)
	{
	    extent.offset = fileblk;
	    extent.length = filechunk;
	    unmap.extents = &amp;extent;
	    unmap.extentsCount = 1;
	    error = do_ioctl(p1, p2, theIoctl, (caddr_t)&amp;unmap);
<span class="enscript-comment">// 	    printf(&quot;DKIOCUNMAP(%d) 0x%qx, 0x%qx\n&quot;, error, extent.offset, extent.length);
</span>	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (_DKIOCCSPINEXTENT == theIoctl)
	{
	    pin.cp_extent.offset = fileblk;
	    pin.cp_extent.length = filechunk;
	    pin.cp_flags = _DKIOCCSPINFORHIBERNATION;
	    error = do_ioctl(p1, p2, theIoctl, (caddr_t)&amp;pin);
	    <span class="enscript-keyword">if</span> (error &amp;&amp; (ENOTTY != error))
	    {
		printf(<span class="enscript-string">&quot;_DKIOCCSPINEXTENT(%d) 0x%qx, 0x%qx\n&quot;</span>, error, pin.cp_extent.offset, pin.cp_extent.length);
	    }
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (_DKIOCCSUNPINEXTENT == theIoctl)
	{
	    pin.cp_extent.offset = fileblk;
	    pin.cp_extent.length = filechunk;
	    pin.cp_flags = _DKIOCCSPINFORHIBERNATION;
	    error = do_ioctl(p1, p2, theIoctl, (caddr_t)&amp;pin);
	    <span class="enscript-keyword">if</span> (error &amp;&amp; (ENOTTY != error))
	    {
		printf(<span class="enscript-string">&quot;_DKIOCCSUNPINEXTENT(%d) 0x%qx, 0x%qx\n&quot;</span>, error, pin.cp_extent.offset, pin.cp_extent.length);
	    }
	}
	<span class="enscript-keyword">else</span> error = EINVAL;

        <span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">break</span>;
        offset += filechunk;
    }
    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">extern</span> uint32_t <span class="enscript-function-name">freespace_mb</span>(vnode_t vp);

<span class="enscript-type">struct</span> kern_direct_file_io_ref_t *
<span class="enscript-function-name">kern_open_file_for_direct_io</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * name, 
			     boolean_t create_file,
			     kern_get_file_extents_callback_t callback, 
			     <span class="enscript-type">void</span> * callback_ref,
                             off_t set_file_size,
                             off_t fs_free_size,
                             off_t write_file_offset,
                             <span class="enscript-type">void</span> * write_file_addr,
                             size_t write_file_len,
			     dev_t * partition_device_result,
			     dev_t * image_device_result,
                             uint64_t * partitionbase_result,
                             uint64_t * maxiocount_result,
                             uint32_t * oflags)
{
    <span class="enscript-type">struct</span> kern_direct_file_io_ref_t * ref;

    proc_t            p;
    <span class="enscript-type">struct</span> vnode_attr va;
    <span class="enscript-type">int</span>               error;
    off_t             f_offset;
    uint64_t          fileblk;
    size_t            filechunk;
    uint64_t          physoffset;
    dev_t             device;
    dev_t             target = 0;
    <span class="enscript-type">int</span>               isssd = 0;
    uint32_t          flags = 0;
    uint32_t          blksize;
    off_t             maxiocount, count, segcount;
    boolean_t         locked = FALSE;
    <span class="enscript-type">int</span>               fmode, cmode;
    <span class="enscript-type">struct</span>            nameidata nd;
    u_int32_t         ndflags;
    off_t             mpFree;

    <span class="enscript-type">int</span> (*do_ioctl)(<span class="enscript-type">void</span> * p1, <span class="enscript-type">void</span> * p2, u_long theIoctl, caddr_t result);
    <span class="enscript-type">void</span> * p1 = NULL;
    <span class="enscript-type">void</span> * p2 = NULL;

    error = EFAULT;

    ref = (<span class="enscript-type">struct</span> kern_direct_file_io_ref_t *) kalloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kern_direct_file_io_ref_t));
    <span class="enscript-keyword">if</span> (!ref)
    {
	error = EFAULT;
    	<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }

    bzero(ref, <span class="enscript-keyword">sizeof</span>(*ref));
    p = kernproc;
    ref-&gt;ctx = vfs_context_create(vfs_context_kernel());

    fmode  = (create_file) ? (O_CREAT | FWRITE) : FWRITE;
    cmode =  S_IRUSR | S_IWUSR;
    ndflags = NOFOLLOW;
    NDINIT(&amp;nd, LOOKUP, OP_OPEN, ndflags, UIO_SYSSPACE, CAST_USER_ADDR_T(name), ref-&gt;ctx);
    VATTR_INIT(&amp;va);
    VATTR_SET(&amp;va, va_mode, cmode);
    VATTR_SET(&amp;va, va_dataprotect_flags, VA_DP_RAWENCRYPTED);
    VATTR_SET(&amp;va, va_dataprotect_class, PROTECTION_CLASS_D);
    <span class="enscript-keyword">if</span> ((error = vn_open_auth(&amp;nd, &amp;fmode, &amp;va))) <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

    ref-&gt;vp = nd.ni_vp;
    <span class="enscript-keyword">if</span> (ref-&gt;vp-&gt;v_type == VREG)
    {
        vnode_lock_spin(ref-&gt;vp);
        SET(ref-&gt;vp-&gt;v_flag, VSWAP);
        vnode_unlock(ref-&gt;vp);
    }

    <span class="enscript-keyword">if</span> (write_file_addr &amp;&amp; write_file_len)
    {
	<span class="enscript-keyword">if</span> ((error = kern_write_file(ref, write_file_offset, write_file_addr, write_file_len, 0))) <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }

    VATTR_INIT(&amp;va);
    VATTR_WANTED(&amp;va, va_rdev);
    VATTR_WANTED(&amp;va, va_fsid);
    VATTR_WANTED(&amp;va, va_data_size);
    VATTR_WANTED(&amp;va, va_data_alloc);
    VATTR_WANTED(&amp;va, va_nlink);
    error = EFAULT;
    <span class="enscript-keyword">if</span> (vnode_getattr(ref-&gt;vp, &amp;va, ref-&gt;ctx)) <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

    mpFree = freespace_mb(ref-&gt;vp);
    mpFree &lt;&lt;= 20;
    kprintf(<span class="enscript-string">&quot;kern_direct_file(%s): vp size %qd, alloc %qd, mp free %qd, keep free %qd\n&quot;</span>, 
    		name, va.va_data_size, va.va_data_alloc, mpFree, fs_free_size);

    <span class="enscript-keyword">if</span> (ref-&gt;vp-&gt;v_type == VREG)
    {
        <span class="enscript-comment">/* Don't dump files with links. */</span>
        <span class="enscript-keyword">if</span> (va.va_nlink != 1) <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

        device = va.va_fsid;
        ref-&gt;filelength = va.va_data_size;

        p1 = &amp;device;
        p2 = p;
        do_ioctl = &amp;file_ioctl;

        <span class="enscript-keyword">if</span> (set_file_size)
        {
            <span class="enscript-keyword">if</span> (fs_free_size)
            {
		mpFree += va.va_data_alloc;
		<span class="enscript-keyword">if</span> ((mpFree &lt; set_file_size) || ((mpFree - set_file_size) &lt; fs_free_size))
		{
		    error = ENOSPC;
		    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	    }
	    error = vnode_setsize(ref-&gt;vp, set_file_size, IO_NOZEROFILL | IO_NOAUTH, ref-&gt;ctx);
	    <span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	    ref-&gt;filelength = set_file_size;
        }
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ref-&gt;vp-&gt;v_type == VBLK) || (ref-&gt;vp-&gt;v_type == VCHR))
    {
	<span class="enscript-comment">/* Partition. */</span>
        device = va.va_rdev;

        p1 = ref-&gt;vp;
        p2 = ref-&gt;ctx;
        do_ioctl = &amp;device_ioctl;
    }
    <span class="enscript-keyword">else</span>
    {
	<span class="enscript-comment">/* Don't dump to non-regular files. */</span>
        error = EFAULT;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    ref-&gt;device = device;

    <span class="enscript-comment">// probe for CF
</span>    dk_corestorage_info_t cs_info;
    memset(&amp;cs_info, 0, <span class="enscript-keyword">sizeof</span>(dk_corestorage_info_t));
    error = do_ioctl(p1, p2, DKIOCCORESTORAGE, (caddr_t)&amp;cs_info);
    ref-&gt;cf = (error == 0) &amp;&amp; (cs_info.flags &amp; DK_CORESTORAGE_ENABLE_HOTFILES);

    <span class="enscript-comment">// get block size
</span>
    error = do_ioctl(p1, p2, DKIOCGETBLOCKSIZE, (caddr_t) &amp;ref-&gt;blksize);
    <span class="enscript-keyword">if</span> (error)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

    <span class="enscript-keyword">if</span> (ref-&gt;vp-&gt;v_type != VREG)
    {
        error = do_ioctl(p1, p2, DKIOCGETBLOCKCOUNT, (caddr_t) &amp;fileblk);
        <span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	ref-&gt;filelength = fileblk * ref-&gt;blksize;    
    }

    <span class="enscript-comment">// pin logical extents
</span>
    error = kern_ioctl_file_extents(ref, _DKIOCCSPINEXTENT, 0, ref-&gt;filelength);
    <span class="enscript-keyword">if</span> (error &amp;&amp; (ENOTTY != error)) <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    ref-&gt;pinned = (error == 0);

    <span class="enscript-comment">// generate the block list
</span>
    error = do_ioctl(p1, p2, DKIOCLOCKPHYSICALEXTENTS, NULL);
    <span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    locked = TRUE;

    f_offset = 0;
    <span class="enscript-keyword">while</span> (f_offset &lt; ref-&gt;filelength) 
    {
        <span class="enscript-keyword">if</span> (ref-&gt;vp-&gt;v_type == VREG)
        {
            filechunk = 1*1024*1024*1024;
            daddr64_t blkno;

            error = VNOP_BLOCKMAP(ref-&gt;vp, f_offset, filechunk, &amp;blkno,
								  &amp;filechunk, NULL, VNODE_WRITE, NULL);
            <span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

            fileblk = blkno * ref-&gt;blksize;
        }
        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((ref-&gt;vp-&gt;v_type == VBLK) || (ref-&gt;vp-&gt;v_type == VCHR))
        {
            fileblk = f_offset;
            filechunk = f_offset ? 0 : ref-&gt;filelength;
        }

        physoffset = 0;
        <span class="enscript-keyword">while</span> (physoffset &lt; filechunk)
        {
            dk_physical_extent_t getphysreq;
            bzero(&amp;getphysreq, <span class="enscript-keyword">sizeof</span>(getphysreq));

            getphysreq.offset = fileblk + physoffset;
            getphysreq.length = (filechunk - physoffset);
            error = do_ioctl(p1, p2, DKIOCGETPHYSICALEXTENT, (caddr_t) &amp;getphysreq);
            <span class="enscript-keyword">if</span> (error) <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
            <span class="enscript-keyword">if</span> (!target)
            {
                target = getphysreq.dev;
            }
            <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (target != getphysreq.dev)
            {
                error = ENOTSUP;
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
            }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HIBFRAGMENT</span>
	    uint64_t rev;
	    <span class="enscript-keyword">for</span> (rev = 4096; rev &lt;= getphysreq.length; rev += 4096)
	    {
		callback(callback_ref, getphysreq.offset + getphysreq.length - rev, 4096);
	    }
#<span class="enscript-reference">else</span>
            callback(callback_ref, getphysreq.offset, getphysreq.length);
#<span class="enscript-reference">endif</span>
            physoffset += getphysreq.length;
        }
        f_offset += filechunk;
    }
    callback(callback_ref, 0ULL, 0ULL);

    <span class="enscript-keyword">if</span> (ref-&gt;vp-&gt;v_type == VREG) p1 = &amp;target;
    <span class="enscript-keyword">else</span>
    {
	p1 = &amp;target;
	p2 = p;
	do_ioctl = &amp;file_ioctl;
    }

    <span class="enscript-comment">// get partition base
</span>
    <span class="enscript-keyword">if</span> (partitionbase_result) 
    {
        error = do_ioctl(p1, p2, DKIOCGETBASE, (caddr_t) partitionbase_result);
        <span class="enscript-keyword">if</span> (error)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }

    <span class="enscript-comment">// get block size &amp; constraints
</span>
    error = do_ioctl(p1, p2, DKIOCGETBLOCKSIZE, (caddr_t) &amp;blksize);
    <span class="enscript-keyword">if</span> (error)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

    maxiocount = 1*1024*1024*1024;

    error = do_ioctl(p1, p2, DKIOCGETMAXBLOCKCOUNTREAD, (caddr_t) &amp;count);
    <span class="enscript-keyword">if</span> (error)
        count = 0;
    count *= blksize;
    <span class="enscript-keyword">if</span> (count &amp;&amp; (count &lt; maxiocount))
        maxiocount = count;

    error = do_ioctl(p1, p2, DKIOCGETMAXBLOCKCOUNTWRITE, (caddr_t) &amp;count);
    <span class="enscript-keyword">if</span> (error)
        count = 0;
    count *= blksize;
    <span class="enscript-keyword">if</span> (count &amp;&amp; (count &lt; maxiocount))
        maxiocount = count;

    error = do_ioctl(p1, p2, DKIOCGETMAXBYTECOUNTREAD, (caddr_t) &amp;count);
    <span class="enscript-keyword">if</span> (error)
        count = 0;
    <span class="enscript-keyword">if</span> (count &amp;&amp; (count &lt; maxiocount))
        maxiocount = count;

    error = do_ioctl(p1, p2, DKIOCGETMAXBYTECOUNTWRITE, (caddr_t) &amp;count);
    <span class="enscript-keyword">if</span> (error)
        count = 0;
    <span class="enscript-keyword">if</span> (count &amp;&amp; (count &lt; maxiocount))
        maxiocount = count;

    error = do_ioctl(p1, p2, DKIOCGETMAXSEGMENTBYTECOUNTREAD, (caddr_t) &amp;count);
    <span class="enscript-keyword">if</span> (!error)
	error = do_ioctl(p1, p2, DKIOCGETMAXSEGMENTCOUNTREAD, (caddr_t) &amp;segcount);
    <span class="enscript-keyword">if</span> (error)
        count = segcount = 0;
    count *= segcount;
    <span class="enscript-keyword">if</span> (count &amp;&amp; (count &lt; maxiocount))
        maxiocount = count;

    error = do_ioctl(p1, p2, DKIOCGETMAXSEGMENTBYTECOUNTWRITE, (caddr_t) &amp;count);
    <span class="enscript-keyword">if</span> (!error)
	error = do_ioctl(p1, p2, DKIOCGETMAXSEGMENTCOUNTWRITE, (caddr_t) &amp;segcount);
    <span class="enscript-keyword">if</span> (error)
        count = segcount = 0;
    count *= segcount;
    <span class="enscript-keyword">if</span> (count &amp;&amp; (count &lt; maxiocount))
        maxiocount = count;

    kprintf(<span class="enscript-string">&quot;max io 0x%qx bytes\n&quot;</span>, maxiocount);
    <span class="enscript-keyword">if</span> (maxiocount_result)
        *maxiocount_result = maxiocount;

    error = do_ioctl(p1, p2, DKIOCISSOLIDSTATE, (caddr_t)&amp;isssd);
    <span class="enscript-keyword">if</span> (!error &amp;&amp; isssd)
        flags |= kIOPolledFileSSD;

    <span class="enscript-keyword">if</span> (partition_device_result)
        *partition_device_result = device;
    <span class="enscript-keyword">if</span> (image_device_result)
        *image_device_result = target;
    <span class="enscript-keyword">if</span> (oflags)
        *oflags = flags;

    <span class="enscript-keyword">if</span> ((ref-&gt;vp-&gt;v_type == VBLK) || (ref-&gt;vp-&gt;v_type == VCHR))
    {
        vnode_close(ref-&gt;vp, FWRITE, ref-&gt;ctx);
        ref-&gt;vp = NULLVP;
	vfs_context_rele(ref-&gt;ctx);
	ref-&gt;ctx = NULL;
    }

<span class="enscript-reference">out</span>:
    printf(<span class="enscript-string">&quot;kern_open_file_for_direct_io(%d)\n&quot;</span>, error);

    <span class="enscript-keyword">if</span> (error &amp;&amp; locked)
    {
        p1 = &amp;device;
        (<span class="enscript-type">void</span>) do_ioctl(p1, p2, DKIOCUNLOCKPHYSICALEXTENTS, NULL);
    }

    <span class="enscript-keyword">if</span> (error &amp;&amp; ref)
    {
	<span class="enscript-keyword">if</span> (ref-&gt;vp)
	{
	    (<span class="enscript-type">void</span>) kern_ioctl_file_extents(ref, _DKIOCCSUNPINEXTENT, 0, (ref-&gt;pinned &amp;&amp; ref-&gt;cf) ? ref-&gt;filelength : 0);
	    vnode_close(ref-&gt;vp, FWRITE, ref-&gt;ctx);
	    ref-&gt;vp = NULLVP;
	}
	vfs_context_rele(ref-&gt;ctx);
	kfree(ref, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kern_direct_file_io_ref_t));
	ref = NULL;
    }

    <span class="enscript-keyword">return</span>(ref);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kern_write_file</span>(<span class="enscript-type">struct</span> kern_direct_file_io_ref_t * ref, off_t offset, <span class="enscript-type">void</span> * addr, size_t len, <span class="enscript-type">int</span> ioflag)
{
    <span class="enscript-keyword">return</span> (vn_rdwr(UIO_WRITE, ref-&gt;vp,
			addr, len, offset,
			UIO_SYSSPACE, ioflag|IO_SYNC|IO_NODELOCKED|IO_UNIT, 
                        vfs_context_ucred(ref-&gt;ctx), (<span class="enscript-type">int</span> *) 0,
			vfs_context_proc(ref-&gt;ctx)));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kern_read_file</span>(<span class="enscript-type">struct</span> kern_direct_file_io_ref_t * ref, off_t offset, <span class="enscript-type">void</span> * addr, size_t len, <span class="enscript-type">int</span> ioflag)
{
    <span class="enscript-keyword">return</span> (vn_rdwr(UIO_READ, ref-&gt;vp,
			addr, len, offset,
			UIO_SYSSPACE, ioflag|IO_SYNC|IO_NODELOCKED|IO_UNIT, 
                        vfs_context_ucred(ref-&gt;ctx), (<span class="enscript-type">int</span> *) 0,
			vfs_context_proc(ref-&gt;ctx)));
}


<span class="enscript-type">struct</span> mount *
<span class="enscript-function-name">kern_file_mount</span>(<span class="enscript-type">struct</span> kern_direct_file_io_ref_t * ref)
{
    <span class="enscript-keyword">return</span> (ref-&gt;vp-&gt;v_mount);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">kern_close_file_for_direct_io</span>(<span class="enscript-type">struct</span> kern_direct_file_io_ref_t * ref,
			      off_t write_offset, <span class="enscript-type">void</span> * addr, size_t write_length,
			      off_t discard_offset, off_t discard_end)
{
    <span class="enscript-type">int</span> error;
    kprintf(<span class="enscript-string">&quot;kern_close_file_for_direct_io\n&quot;</span>);

    <span class="enscript-keyword">if</span> (!ref) <span class="enscript-keyword">return</span>;

    <span class="enscript-keyword">if</span> (ref-&gt;vp)
    {
        <span class="enscript-type">int</span> (*do_ioctl)(<span class="enscript-type">void</span> * p1, <span class="enscript-type">void</span> * p2, u_long theIoctl, caddr_t result);
        <span class="enscript-type">void</span> * p1;
        <span class="enscript-type">void</span> * p2;

        <span class="enscript-keyword">if</span> (ref-&gt;vp-&gt;v_type == VREG)
        {
            p1 = &amp;ref-&gt;device;
            p2 = kernproc;
            do_ioctl = &amp;file_ioctl;
        }
        <span class="enscript-keyword">else</span>
        {
            <span class="enscript-comment">/* Partition. */</span>
            p1 = ref-&gt;vp;
            p2 = ref-&gt;ctx;
            do_ioctl = &amp;device_ioctl;
        }
        (<span class="enscript-type">void</span>) do_ioctl(p1, p2, DKIOCUNLOCKPHYSICALEXTENTS, NULL);

		<span class="enscript-comment">//XXX If unmapping extents then don't also need to unpin; except ...
</span>		<span class="enscript-comment">//XXX if file unaligned (HFS 4k / Fusion 128k) then pin is superset and
</span>		<span class="enscript-comment">//XXX unmap is subset, so save extra walk over file extents (and the risk
</span>		<span class="enscript-comment">//XXX that CF drain starts) vs leaving partial units pinned to SSD
</span>		<span class="enscript-comment">//XXX (until whatever was sharing also unmaps).  Err on cleaning up fully.
</span>		boolean_t will_unmap = (!ref-&gt;pinned || ref-&gt;cf) &amp;&amp; (discard_end &gt; discard_offset);
		boolean_t will_unpin = (ref-&gt;pinned &amp;&amp; ref-&gt;cf <span class="enscript-comment">/* &amp;&amp; !will_unmap */</span>);

		(<span class="enscript-type">void</span>) kern_ioctl_file_extents(ref, _DKIOCCSUNPINEXTENT, 0, (will_unpin) ? ref-&gt;filelength : 0);

        <span class="enscript-keyword">if</span> (will_unmap)
        {
            (<span class="enscript-type">void</span>) kern_ioctl_file_extents(ref, DKIOCUNMAP, discard_offset, (ref-&gt;cf) ? ref-&gt;filelength : discard_end);
        }

        <span class="enscript-keyword">if</span> (addr &amp;&amp; write_length)
        {
            (<span class="enscript-type">void</span>) kern_write_file(ref, write_offset, addr, write_length, 0);
        }

        error = vnode_close(ref-&gt;vp, FWRITE, ref-&gt;ctx);

        ref-&gt;vp = NULLVP;
        kprintf(<span class="enscript-string">&quot;vnode_close(%d)\n&quot;</span>, error);
    }
    <span class="enscript-keyword">if</span> (ref-&gt;ctx)
    {
	vfs_context_rele(ref-&gt;ctx);
	ref-&gt;ctx = NULL;
    }
    kfree(ref, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kern_direct_file_io_ref_t));
}
</pre>
<hr />
</body></html>