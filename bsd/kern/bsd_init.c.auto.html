<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>bsd_init.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">bsd_init.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 * 
 *
 * Copyright (c) 1982, 1986, 1989, 1991, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)init_main.c	8.16 (Berkeley) 5/14/95
 */</span>

<span class="enscript-comment">/* 
 *
 * Mach Operating System
 * Copyright (c) 1987 Carnegie-Mellon University
 * All rights reserved.  The CMU software License Agreement specifies
 * the terms and conditions for use and redistribution.
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/clist.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mman.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dkstat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/codesign.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/startup.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ast.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_host.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ux_exception.h&gt;</span>	<span class="enscript-comment">/* for ux_exception_port */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/reboot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/exception_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/busvar.h&gt;</span>			<span class="enscript-comment">/* for pseudo_inits */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/semaphore.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sync_policy.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_act.h&gt;</span>		<span class="enscript-comment">/* for thread_resume() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>			<span class="enscript-comment">/* for task_set_exception_ports() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ux_exception.h&gt;</span>		<span class="enscript-comment">/* for ux_handler() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>		<span class="enscript-comment">/* for ubc_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>			<span class="enscript-comment">/* for mcache_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>			<span class="enscript-comment">/* for mbinit() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/event.h&gt;</span>			<span class="enscript-comment">/* for knote_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_memorystatus.h&gt;</span>	<span class="enscript-comment">/* for memorystatus_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/aio_kern.h&gt;</span>		<span class="enscript-comment">/* for aio_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/semaphore.h&gt;</span>		<span class="enscript-comment">/* for psem_cache_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>			<span class="enscript-comment">/* for dlil_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kpi_protocol.h&gt;</span>		<span class="enscript-comment">/* for proto_kpi_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/iptap.h&gt;</span>			<span class="enscript-comment">/* for iptap_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/pipe.h&gt;</span>			<span class="enscript-comment">/* for pipeinit() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>		<span class="enscript-comment">/* for socketinit() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>		<span class="enscript-comment">/* for domaininit() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>		<span class="enscript-comment">/* for thread_wakeup() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_ether.h&gt;</span>		<span class="enscript-comment">/* for ether_family_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_gif.h&gt;</span>			<span class="enscript-comment">/* for gif_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>		<span class="enscript-comment">/* for vnode_pager_bootstrap() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/devfsdefs.h&gt;</span>	<span class="enscript-comment">/* for devfs_kernel_mount() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv.h&gt;</span>		<span class="enscript-comment">/* for host_set_exception_ports() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>			<span class="enscript-comment">/* for host_priv_self() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>			<span class="enscript-comment">/* for kmem_suballoc() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/semaphore.h&gt;</span>		<span class="enscript-comment">/* for psem_lock_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/msgbuf.h&gt;</span>			<span class="enscript-comment">/* for log_setsize() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/tty.h&gt;</span>			<span class="enscript-comment">/* for tty_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_uuid_policy.h&gt;</span>	<span class="enscript-comment">/* proc_uuid_policy_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/flow_divert.h&gt;</span>	<span class="enscript-comment">/* flow_divert_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/content_filter.h&gt;</span>		<span class="enscript-comment">/* for cfil_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/necp.h&gt;</span>			<span class="enscript-comment">/* for necp_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/network_agent.h&gt;</span>		<span class="enscript-comment">/* for netagent_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/packet_mangler.h&gt;</span>		<span class="enscript-comment">/* for pkt_mnglr_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_utun.h&gt;</span>		<span class="enscript-comment">/* for utun_register_control() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_ipsec.h&gt;</span>		<span class="enscript-comment">/* for ipsec_register_control() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/net_str_id.h&gt;</span>		<span class="enscript-comment">/* for net_str_id_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/netsrc.h&gt;</span>			<span class="enscript-comment">/* for netsrc_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>			<span class="enscript-comment">/* for nstat_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_cc.h&gt;</span>			<span class="enscript-comment">/* for tcp_cc_init() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_var.h&gt;</span>		<span class="enscript-comment">/* for mptcp_control_register() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>		<span class="enscript-comment">/* for assert() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_overrides.h&gt;</span>		<span class="enscript-comment">/* for init_system_override() */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/init.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_internal.h&gt;</span>	<span class="enscript-comment">/* mac_init_bsd() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_mach_internal.h&gt;</span>	<span class="enscript-comment">/* mac_update_task_label() */</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/exec.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/netboot.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IMAGEBOOT</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/imageboot.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PFLOG</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_pflog.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/pal_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;console/video_console.h&gt;</span>


<span class="enscript-type">void</span> * <span class="enscript-function-name">get_user_regs</span>(thread_t);		<span class="enscript-comment">/* XXX kludge for &lt;machine/thread.h&gt; */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOKitInitializeTime</span>(<span class="enscript-type">void</span>);		<span class="enscript-comment">/* XXX */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">IOSleep</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);		<span class="enscript-comment">/* XXX */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">loopattach</span>(<span class="enscript-type">void</span>);			<span class="enscript-comment">/* XXX */</span>

<span class="enscript-type">const</span> <span class="enscript-type">char</span>    copyright[] =
<span class="enscript-string">&quot;Copyright (c) 1982, 1986, 1989, 1991, 1993\n\t&quot;</span>
<span class="enscript-string">&quot;The Regents of the University of California. &quot;</span>
<span class="enscript-string">&quot;All rights reserved.\n\n&quot;</span>;

<span class="enscript-comment">/* Components of the first process -- never freed. */</span>
<span class="enscript-type">struct</span>	proc proc0;
<span class="enscript-type">struct</span>	session session0;
<span class="enscript-type">struct</span>	pgrp pgrp0;
<span class="enscript-type">struct</span>	filedesc filedesc0;
<span class="enscript-type">struct</span>	plimit limit0;
<span class="enscript-type">struct</span>	pstats pstats0;
<span class="enscript-type">struct</span>	sigacts sigacts0;
proc_t kernproc;
proc_t initproc;

<span class="enscript-type">long</span> tk_cancc;
<span class="enscript-type">long</span> tk_nin;
<span class="enscript-type">long</span> tk_nout;
<span class="enscript-type">long</span> tk_rawcc;

<span class="enscript-type">int</span> lock_trace = 0;
<span class="enscript-comment">/* Global variables to make pstat happy. We do swapping differently */</span>
<span class="enscript-type">int</span> nswdev, nswap;
<span class="enscript-type">int</span> nswapmap;
<span class="enscript-type">void</span> *swapmap;
<span class="enscript-type">struct</span> swdevt swdevt[1];

dev_t	rootdev;		<span class="enscript-comment">/* device of the root */</span>
dev_t	dumpdev;		<span class="enscript-comment">/* device to take dumps on */</span>
<span class="enscript-type">long</span>	dumplo;			<span class="enscript-comment">/* offset into dumpdev */</span>
<span class="enscript-type">long</span>	hostid;
<span class="enscript-type">char</span>	hostname[MAXHOSTNAMELEN];
<span class="enscript-type">int</span>		hostnamelen;
<span class="enscript-type">char</span>	domainname[MAXDOMNAMELEN];
<span class="enscript-type">int</span>		domainnamelen;

<span class="enscript-type">char</span> rootdevice[16]; 	<span class="enscript-comment">/* hfs device names have at least 9 chars */</span>

#<span class="enscript-reference">if</span>  <span class="enscript-variable-name">KMEMSTATS</span>
<span class="enscript-type">struct</span>	kmemstats kmemstats[M_LAST];
#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span>	vnode *rootvp;
<span class="enscript-type">int</span> boothowto = RB_DEBUG;
<span class="enscript-type">int</span> minimalboot = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PROC_REF_DEBUG</span>
__private_extern__ <span class="enscript-type">int</span> proc_ref_tracking_disabled = 0; <span class="enscript-comment">/* disable panics on leaked proc refs across syscall boundary */</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">IOFindBSDRoot</span>(<span class="enscript-type">char</span> *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, dev_t *, u_int32_t *);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">IOSecureBSDRoot</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * rootName);
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">IOKitBSDInit</span>(<span class="enscript-type">void</span> );
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kminit</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">file_lock_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kmeminit</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bsd_bufferinit</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">throttle_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">macx_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">acct_init</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> serverperfmode;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> ncl;

vm_map_t	bsd_pageable_map;
vm_map_t	mb_map;

<span class="enscript-type">static</span>  <span class="enscript-type">int</span> bsd_simul_execs;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> bsd_pageable_map_size;
__private_extern__ <span class="enscript-type">int</span> execargs_cache_size = 0;
__private_extern__ <span class="enscript-type">int</span> execargs_free_count = 0;
__private_extern__ vm_offset_t * execargs_cache = NULL;

<span class="enscript-type">void</span> <span class="enscript-function-name">bsd_exec_setup</span>(<span class="enscript-type">int</span>);

__private_extern__ <span class="enscript-type">int</span> bootarg_vnode_cache_defeat = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span> &amp;&amp; (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
__private_extern__ <span class="enscript-type">int</span> bootarg_no_vnode_jetsam = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM &amp;&amp; (DEVELOPMENT || DEBUG) */</span>

<span class="enscript-comment">/*
 * Prevent kernel-based ASLR from being used, for testing.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
__private_extern__ <span class="enscript-type">int</span> bootarg_disable_aslr = 0;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">int</span>	cmask = CMASK;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> customnbuf;

<span class="enscript-type">void</span> <span class="enscript-function-name">bsd_init</span>(<span class="enscript-type">void</span>);
kern_return_t <span class="enscript-function-name">bsd_autoconf</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">bsd_utaskbootstrap</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">parse_bsd_args</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> task_t bsd_init_task;
<span class="enscript-type">extern</span> boolean_t init_task_died;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DEV_KMEM</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dev_kmem_init</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">time_zone_slock_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">select_waitq_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">process_name</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *, proc_t);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">setconf</span>(<span class="enscript-type">void</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SYSV_SHM</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">sysv_shm_lock_init</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SYSV_SEM</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">sysv_sem_lock_init</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SYSV_MSG</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">sysv_msg_lock_init</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__x86_64__</span>)
<span class="enscript-comment">/* MACF policy_check configuration flags; see policy_check.c for details */</span>
<span class="enscript-type">int</span> policy_check_flags = 0;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">check_policy_init</span>(<span class="enscript-type">int</span>);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* CONFIG_MACF */</span>

<span class="enscript-comment">/* If we are using CONFIG_DTRACE */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	<span class="enscript-type">extern</span> <span class="enscript-type">void</span> dtrace_postinit(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Initialization code.
 * Called from cold start routine as
 * soon as a stack and segmentation
 * have been established.
 * Functions:
 *	turn on clock
 *	hand craft 0th process
 *	call all initialization routines
 *  hand craft 1st user process
 */</span>

<span class="enscript-comment">/*
 *	Sets the name for the given task.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">process_name</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *s, proc_t p)
{
       strlcpy(p-&gt;p_comm, s, <span class="enscript-keyword">sizeof</span>(p-&gt;p_comm));
       strlcpy(p-&gt;p_name, s, <span class="enscript-keyword">sizeof</span>(p-&gt;p_name));
}

<span class="enscript-comment">/* To allow these values to be patched, they're globals here */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/vmparam.h&gt;</span>
<span class="enscript-type">struct</span> rlimit vm_initial_limit_stack = { DFLSSIZ, MAXSSIZ - PAGE_MAX_SIZE };
<span class="enscript-type">struct</span> rlimit vm_initial_limit_data = { DFLDSIZ, MAXDSIZ };
<span class="enscript-type">struct</span> rlimit vm_initial_limit_core = { DFLCSIZ, MAXCSIZ };

<span class="enscript-type">extern</span> thread_t	cloneproc(task_t, coalition_t, proc_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> 	(*mountroot)(<span class="enscript-type">void</span>);

lck_grp_t * proc_lck_grp;
lck_grp_t * proc_slock_grp;
lck_grp_t * proc_fdmlock_grp;
lck_grp_t * proc_mlock_grp;
lck_grp_attr_t * proc_lck_grp_attr;
lck_attr_t * proc_lck_attr;
lck_mtx_t * proc_list_mlock;
lck_mtx_t * proc_klist_mlock;

<span class="enscript-type">extern</span> lck_mtx_t * execargs_cache_lock;

<span class="enscript-comment">/* hook called after root is mounted XXX temporary hack */</span>
<span class="enscript-function-name">void</span> (*mountroot_post_hook)(<span class="enscript-type">void</span>);
<span class="enscript-function-name">void</span> (*unmountroot_pre_hook)(<span class="enscript-type">void</span>);

<span class="enscript-comment">/*
 * This function is called very early on in the Mach startup, from the
 * function start_kernel_threads() in osfmk/kern/startup.c.  It's called
 * in the context of the current (startup) task using a call to the
 * function kernel_thread_create() to jump into start_kernel_threads().
 * Internally, kernel_thread_create() calls thread_create_internal(),
 * which calls uthread_alloc().  The function of uthread_alloc() is
 * normally to allocate a uthread structure, and fill out the uu_sigmask,
 * uu_context fields.  It skips filling these out in the case of the &quot;task&quot;
 * being &quot;kernel_task&quot;, because the order of operation is inverted.  To
 * account for that, we need to manually fill in at least the contents
 * of the uu_context.vc_ucred field so that the uthread structure can be
 * used like any other.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">bsd_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> uthread *ut;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;
	<span class="enscript-type">struct</span> vfs_context context;
	kern_return_t	ret;
	<span class="enscript-type">struct</span> ucred temp_cred;
	<span class="enscript-type">struct</span> posix_cred temp_pcred;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span> || <span class="enscript-variable-name">CONFIG_IMAGEBOOT</span>
	boolean_t       netboot = FALSE;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">bsd_init_kprintf</span>(x...) <span class="enscript-comment">/* kprintf(&quot;bsd_init: &quot; x) */</span>

	throttle_init();

	printf(copyright);
	
	bsd_init_kprintf(<span class="enscript-string">&quot;calling kmeminit\n&quot;</span>);
	kmeminit();
	
	bsd_init_kprintf(<span class="enscript-string">&quot;calling parse_bsd_args\n&quot;</span>);
	parse_bsd_args();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DEV_KMEM</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling dev_kmem_init\n&quot;</span>);
	dev_kmem_init();
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Initialize kauth subsystem before instancing the first credential */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling kauth_init\n&quot;</span>);
	kauth_init();

	<span class="enscript-comment">/* Initialize process and pgrp structures. */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling procinit\n&quot;</span>);
	procinit();

	<span class="enscript-comment">/* Initialize the ttys (MUST be before kminit()/bsd_autoconf()!)*/</span>
	tty_init();

	kernproc = &amp;proc0;	<span class="enscript-comment">/* implicitly bzero'ed */</span>

	<span class="enscript-comment">/* kernel_task-&gt;proc = kernproc; */</span>
	set_bsdtask_info(kernel_task,(<span class="enscript-type">void</span> *)kernproc);

	<span class="enscript-comment">/* give kernproc a name */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling process_name\n&quot;</span>);
	process_name(<span class="enscript-string">&quot;kernel_task&quot;</span>, kernproc);

	<span class="enscript-comment">/* allocate proc lock group attribute and group */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling lck_grp_attr_alloc_init\n&quot;</span>);
	proc_lck_grp_attr= lck_grp_attr_alloc_init();

	proc_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;proc&quot;</span>,  proc_lck_grp_attr);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FINE_LOCK_GROUPS</span>
	proc_slock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;proc-slock&quot;</span>,  proc_lck_grp_attr);
	proc_fdmlock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;proc-fdmlock&quot;</span>,  proc_lck_grp_attr);
	proc_mlock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;proc-mlock&quot;</span>,  proc_lck_grp_attr);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* Allocate proc lock attribute */</span>
	proc_lck_attr = lck_attr_alloc_init();
#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__PROC_INTERNAL_DEBUG</span>
	lck_attr_setdebug(proc_lck_attr);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FINE_LOCK_GROUPS</span>
	proc_list_mlock = lck_mtx_alloc_init(proc_mlock_grp, proc_lck_attr);
	proc_klist_mlock = lck_mtx_alloc_init(proc_mlock_grp, proc_lck_attr);
	lck_mtx_init(&amp;kernproc-&gt;p_mlock, proc_mlock_grp, proc_lck_attr);
	lck_mtx_init(&amp;kernproc-&gt;p_fdmlock, proc_fdmlock_grp, proc_lck_attr);
	lck_spin_init(&amp;kernproc-&gt;p_slock, proc_slock_grp, proc_lck_attr);
#<span class="enscript-reference">else</span>
	proc_list_mlock = lck_mtx_alloc_init(proc_lck_grp, proc_lck_attr);
	proc_klist_mlock = lck_mtx_alloc_init(proc_lck_grp, proc_lck_attr);
	lck_mtx_init(&amp;kernproc-&gt;p_mlock, proc_lck_grp, proc_lck_attr);
	lck_mtx_init(&amp;kernproc-&gt;p_fdmlock, proc_lck_grp, proc_lck_attr);
	lck_spin_init(&amp;kernproc-&gt;p_slock, proc_lck_grp, proc_lck_attr);
#<span class="enscript-reference">endif</span>

	assert(bsd_simul_execs != 0);
	execargs_cache_lock = lck_mtx_alloc_init(proc_lck_grp, proc_lck_attr);
	execargs_cache_size = bsd_simul_execs;
	execargs_free_count = bsd_simul_execs;
	execargs_cache = (vm_offset_t *)kalloc(bsd_simul_execs * <span class="enscript-keyword">sizeof</span>(vm_offset_t));
	bzero(execargs_cache, bsd_simul_execs * <span class="enscript-keyword">sizeof</span>(vm_offset_t));
	
	<span class="enscript-keyword">if</span> (current_task() != kernel_task)
		printf(<span class="enscript-string">&quot;bsd_init: We have a problem, &quot;</span>
				<span class="enscript-string">&quot;current task is not kernel task\n&quot;</span>);
	
	bsd_init_kprintf(<span class="enscript-string">&quot;calling get_bsdthread_info\n&quot;</span>);
	ut = (uthread_t)get_bsdthread_info(current_thread());

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/*
	 * Initialize the MAC Framework
	 */</span>
	mac_policy_initbsd();
	kernproc-&gt;p_mac_enforce = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__x86_64__</span>)
	<span class="enscript-comment">/*
	 * We currently only support this on i386/x86_64, as that is the
	 * only lock code we have instrumented so far.
	 */</span>
	check_policy_init(policy_check_flags);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>

	<span class="enscript-comment">/* Initialize System Override call */</span>
	init_system_override();
	
	<span class="enscript-comment">/*
	 * Create process 0.
	 */</span>
	proc_list_lock();
	LIST_INSERT_HEAD(&amp;allproc, kernproc, p_list);
	kernproc-&gt;p_pgrp = &amp;pgrp0;
	LIST_INSERT_HEAD(PGRPHASH(0), &amp;pgrp0, pg_hash);
	LIST_INIT(&amp;pgrp0.pg_members);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_FINE_LOCK_GROUPS</span>
	lck_mtx_init(&amp;pgrp0.pg_mlock, proc_mlock_grp, proc_lck_attr);
#<span class="enscript-reference">else</span>
	lck_mtx_init(&amp;pgrp0.pg_mlock, proc_lck_grp, proc_lck_attr);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* There is no other bsd thread this point and is safe without pgrp lock */</span>
	LIST_INSERT_HEAD(&amp;pgrp0.pg_members, kernproc, p_pglist);
	kernproc-&gt;p_listflag |= P_LIST_INPGRP;
	kernproc-&gt;p_pgrpid = 0;
	kernproc-&gt;p_uniqueid = 0;

	pgrp0.pg_session = &amp;session0;
	pgrp0.pg_membercnt = 1;

	session0.s_count = 1;
	session0.s_leader = kernproc;
	session0.s_listflags = 0;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_FINE_LOCK_GROUPS</span>
	lck_mtx_init(&amp;session0.s_mlock, proc_mlock_grp, proc_lck_attr);
#<span class="enscript-reference">else</span>
	lck_mtx_init(&amp;session0.s_mlock, proc_lck_grp, proc_lck_attr);
#<span class="enscript-reference">endif</span>
	LIST_INSERT_HEAD(SESSHASH(0), &amp;session0, s_hash);
	proc_list_unlock();

	kernproc-&gt;task = kernel_task;
	
	kernproc-&gt;p_stat = SRUN;
	kernproc-&gt;p_flag = P_SYSTEM;
	kernproc-&gt;p_lflag = 0;
	kernproc-&gt;p_ladvflag = 0;
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (bootarg_disable_aslr)
		kernproc-&gt;p_flag |= P_DISABLE_ASLR;
#<span class="enscript-reference">endif</span>

	kernproc-&gt;p_nice = NZERO;
	kernproc-&gt;p_pptr = kernproc;

	TAILQ_INIT(&amp;kernproc-&gt;p_uthlist);
	TAILQ_INSERT_TAIL(&amp;kernproc-&gt;p_uthlist, ut, uu_list);
	
	kernproc-&gt;sigwait = FALSE;
	kernproc-&gt;sigwait_thread = THREAD_NULL;
	kernproc-&gt;exit_thread = THREAD_NULL;
	kernproc-&gt;p_csflags = CS_VALID;

	<span class="enscript-comment">/*
	 * Create credential.  This also Initializes the audit information.
	 */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling bzero\n&quot;</span>);
	bzero(&amp;temp_cred, <span class="enscript-keyword">sizeof</span>(temp_cred));
	bzero(&amp;temp_pcred, <span class="enscript-keyword">sizeof</span>(temp_pcred));
	temp_pcred.cr_ngroups = 1;
	<span class="enscript-comment">/* kern_proc, shouldn't call up to DS for group membership */</span>
	temp_pcred.cr_flags = CRF_NOMEMBERD;
	temp_cred.cr_audit.as_aia_p = audit_default_aia_p;
	
	bsd_init_kprintf(<span class="enscript-string">&quot;calling kauth_cred_create\n&quot;</span>);
	<span class="enscript-comment">/*
	 * We have to label the temp cred before we create from it to
	 * properly set cr_ngroups, or the create will fail.
	 */</span>
	posix_cred_label(&amp;temp_cred, &amp;temp_pcred);
	kernproc-&gt;p_ucred = kauth_cred_create(&amp;temp_cred); 

	<span class="enscript-comment">/* update cred on proc */</span>
	PROC_UPDATE_CREDS_ONPROC(kernproc);

	<span class="enscript-comment">/* give the (already exisiting) initial thread a reference on it */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling kauth_cred_ref\n&quot;</span>);
	kauth_cred_ref(kernproc-&gt;p_ucred);
	ut-&gt;uu_context.vc_ucred = kernproc-&gt;p_ucred;
	ut-&gt;uu_context.vc_thread = current_thread();

	TAILQ_INIT(&amp;kernproc-&gt;p_aio_activeq);
	TAILQ_INIT(&amp;kernproc-&gt;p_aio_doneq);
	kernproc-&gt;p_aio_total_count = 0;
	kernproc-&gt;p_aio_active_count = 0;

	bsd_init_kprintf(<span class="enscript-string">&quot;calling file_lock_init\n&quot;</span>);
	file_lock_init();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_cred_label_associate_kernel(kernproc-&gt;p_ucred);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Create the file descriptor table. */</span>
	kernproc-&gt;p_fd = &amp;filedesc0;
	filedesc0.fd_cmask = cmask;
	filedesc0.fd_knlistsize = -1;
	filedesc0.fd_knlist = NULL;
	filedesc0.fd_knhash = NULL;
	filedesc0.fd_knhashmask = 0;

	<span class="enscript-comment">/* Create the limits structures. */</span>
	kernproc-&gt;p_limit = &amp;limit0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; <span class="enscript-keyword">sizeof</span>(kernproc-&gt;p_rlimit)/<span class="enscript-keyword">sizeof</span>(kernproc-&gt;p_rlimit[0]); i++)
		limit0.pl_rlimit[i].rlim_cur = 
			limit0.pl_rlimit[i].rlim_max = RLIM_INFINITY;
	limit0.pl_rlimit[RLIMIT_NOFILE].rlim_cur = NOFILE;
	limit0.pl_rlimit[RLIMIT_NPROC].rlim_cur = maxprocperuid;
	limit0.pl_rlimit[RLIMIT_NPROC].rlim_max = maxproc;
	limit0.pl_rlimit[RLIMIT_STACK] = vm_initial_limit_stack;
	limit0.pl_rlimit[RLIMIT_DATA] = vm_initial_limit_data;
	limit0.pl_rlimit[RLIMIT_CORE] = vm_initial_limit_core;
	limit0.pl_refcnt = 1;

	kernproc-&gt;p_stats = &amp;pstats0;
	kernproc-&gt;p_sigacts = &amp;sigacts0;

	<span class="enscript-comment">/*
	 * Charge root for one process: launchd.
	 */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling chgproccnt\n&quot;</span>);
	(<span class="enscript-type">void</span>)chgproccnt(0, 1);

	<span class="enscript-comment">/*
	 *	Allocate a kernel submap for pageable memory
	 *	for temporary copying (execve()).
	 */</span>
	{
		vm_offset_t	minimum;

		bsd_init_kprintf(<span class="enscript-string">&quot;calling kmem_suballoc\n&quot;</span>);
		assert(bsd_pageable_map_size != 0);
		ret = kmem_suballoc(kernel_map,
				&amp;minimum,
				(vm_size_t)bsd_pageable_map_size,
				TRUE,
				VM_FLAGS_ANYWHERE | VM_MAKE_TAG(VM_KERN_MEMORY_BSD),
				&amp;bsd_pageable_map);
		<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS) 
			panic(<span class="enscript-string">&quot;bsd_init: Failed to allocate bsd pageable map&quot;</span>);
	}

	<span class="enscript-comment">/*
	 * Initialize buffers and hash links for buffers
	 *
	 * SIDE EFFECT: Starts a thread for bcleanbuf_thread(), so must
	 *		happen after a credential has been associated with
	 *		the kernel task.
	 */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling bsd_bufferinit\n&quot;</span>);
	bsd_bufferinit();

	<span class="enscript-comment">/* Initialize the execve() semaphore */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling semaphore_create\n&quot;</span>);

	<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS)
		panic(<span class="enscript-string">&quot;bsd_init: Failed to create execve semaphore&quot;</span>);

	<span class="enscript-comment">/*
	 * Initialize the calendar.
	 */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling IOKitInitializeTime\n&quot;</span>);
	IOKitInitializeTime();

	bsd_init_kprintf(<span class="enscript-string">&quot;calling ubc_init\n&quot;</span>);
	ubc_init();

	<span class="enscript-comment">/*
	 * Initialize device-switches.
	 */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling devsw_init() \n&quot;</span>);
	devsw_init();

	<span class="enscript-comment">/* Initialize the file systems. */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling vfsinit\n&quot;</span>);
	vfsinit();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROC_UUID_POLICY</span>
	<span class="enscript-comment">/* Initial proc_uuid_policy subsystem */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling proc_uuid_policy_init()\n&quot;</span>);
	proc_uuid_policy_init();
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SOCKETS</span>
	<span class="enscript-comment">/* Initialize per-CPU cache allocator */</span>
	mcache_init();

	<span class="enscript-comment">/* Initialize mbuf's. */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling mbinit\n&quot;</span>);
	mbinit();
	net_str_id_init(); <span class="enscript-comment">/* for mbuf tags */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* SOCKETS */</span>

	<span class="enscript-comment">/*
	 * Initializes security event auditing.
	 * XXX: Should/could this occur later?
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_AUDIT</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling audit_init\n&quot;</span>);
 	audit_init();  
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Initialize kqueues */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling knote_init\n&quot;</span>);
	knote_init();

	<span class="enscript-comment">/* Initialize for async IO */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling aio_init\n&quot;</span>);
	aio_init();

	<span class="enscript-comment">/* Initialize pipes */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling pipeinit\n&quot;</span>);
	pipeinit();

	<span class="enscript-comment">/* Initialize SysV shm subsystem locks; the subsystem proper is
	 * initialized through a sysctl.
	 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SYSV_SHM</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling sysv_shm_lock_init\n&quot;</span>);
	sysv_shm_lock_init();
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SYSV_SEM</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling sysv_sem_lock_init\n&quot;</span>);
	sysv_sem_lock_init();
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SYSV_MSG</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;sysv_msg_lock_init\n&quot;</span>);
	sysv_msg_lock_init();
#<span class="enscript-reference">endif</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling pshm_lock_init\n&quot;</span>);
	pshm_lock_init();
	bsd_init_kprintf(<span class="enscript-string">&quot;calling psem_lock_init\n&quot;</span>);
	psem_lock_init();

	pthread_init();
	<span class="enscript-comment">/* POSIX Shm and Sem */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling pshm_cache_init\n&quot;</span>);
	pshm_cache_init();
	bsd_init_kprintf(<span class="enscript-string">&quot;calling psem_cache_init\n&quot;</span>);
	psem_cache_init();
	bsd_init_kprintf(<span class="enscript-string">&quot;calling time_zone_slock_init\n&quot;</span>);
	time_zone_slock_init();
	bsd_init_kprintf(<span class="enscript-string">&quot;calling select_waitq_init\n&quot;</span>);
	select_waitq_init();

	<span class="enscript-comment">/*
	 * Initialize protocols.  Block reception of incoming packets
	 * until everything is ready.
	 */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling sysctl_register_fixed\n&quot;</span>);
	sysctl_register_fixed(); 
	bsd_init_kprintf(<span class="enscript-string">&quot;calling sysctl_mib_init\n&quot;</span>);
	sysctl_mib_init();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NETWORKING</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling dlil_init\n&quot;</span>);
	dlil_init();
	bsd_init_kprintf(<span class="enscript-string">&quot;calling proto_kpi_init\n&quot;</span>);
	proto_kpi_init();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NETWORKING */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SOCKETS</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling socketinit\n&quot;</span>);
	socketinit();
	bsd_init_kprintf(<span class="enscript-string">&quot;calling domaininit\n&quot;</span>);
	domaininit();
	iptap_init();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FLOW_DIVERT</span>
	flow_divert_init();
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* FLOW_DIVERT */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* SOCKETS */</span>

	kernproc-&gt;p_fd-&gt;fd_cdir = NULL;
	kernproc-&gt;p_fd-&gt;fd_rdir = NULL;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>
    #error <span class="enscript-string">&quot;CONFIG_FREEZE defined without matching CONFIG_MEMORYSTATUS&quot;</span>
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* Initialise background freezing */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling memorystatus_freeze_init\n&quot;</span>);
	memorystatus_freeze_init();
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>
	<span class="enscript-comment">/* Initialize kernel memory status notifications */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling memorystatus_init\n&quot;</span>);
	memorystatus_init();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MEMORYSTATUS */</span>

	bsd_init_kprintf(<span class="enscript-string">&quot;calling macx_init\n&quot;</span>);
	macx_init();

	bsd_init_kprintf(<span class="enscript-string">&quot;calling acct_init\n&quot;</span>);
	acct_init();

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">GPROF</span>
	<span class="enscript-comment">/* Initialize kernel profiling. */</span>
	kmstartup();
#<span class="enscript-reference">endif</span>

	bsd_init_kprintf(<span class="enscript-string">&quot;calling bsd_autoconf\n&quot;</span>);
	bsd_autoconf();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	dtrace_postinit();
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * We attach the loopback interface *way* down here to ensure
	 * it happens after autoconf(), otherwise it becomes the
	 * &quot;primary&quot; interface.
	 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;loop.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NLOOP</span> &gt; 0
	bsd_init_kprintf(<span class="enscript-string">&quot;calling loopattach\n&quot;</span>);
	loopattach();			<span class="enscript-comment">/* XXX */</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NGIF</span>
	<span class="enscript-comment">/* Initialize gif interface (after lo0) */</span>
	gif_init();
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PFLOG</span>
	<span class="enscript-comment">/* Initialize packet filter log interface */</span>
	pfloginit();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PFLOG */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NETHER</span> &gt; 0
	<span class="enscript-comment">/* Register the built-in dlil ethernet interface family */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling ether_family_init\n&quot;</span>);
	ether_family_init();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* ETHER */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NETWORKING</span>
	<span class="enscript-comment">/* Call any kext code that wants to run just after network init */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling net_init_run\n&quot;</span>);
	net_init_run();
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
	cfil_init();
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PACKET_MANGLER</span>
	pkt_mnglr_init();
#<span class="enscript-reference">endif</span>	

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	<span class="enscript-comment">/* Initialize Network Extension Control Policies */</span>
	necp_init();
#<span class="enscript-reference">endif</span>

	netagent_init();

	<span class="enscript-comment">/* register user tunnel kernel control handler */</span>
	utun_register_control();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	ipsec_register_control();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
	netsrc_init();
	nstat_init();
	tcp_cc_init();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
	mptcp_control_register();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NETWORKING */</span>

	bsd_init_kprintf(<span class="enscript-string">&quot;calling vnode_pager_bootstrap\n&quot;</span>);
	vnode_pager_bootstrap();

	bsd_init_kprintf(<span class="enscript-string">&quot;calling inittodr\n&quot;</span>);
	inittodr(0);

	<span class="enscript-comment">/* Mount the root file system. */</span>
	<span class="enscript-keyword">while</span>( TRUE) {
		<span class="enscript-type">int</span> err;

		bsd_init_kprintf(<span class="enscript-string">&quot;calling setconf\n&quot;</span>);
		setconf();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
		netboot = (mountroot == netboot_mountroot);
#<span class="enscript-reference">endif</span>

		bsd_init_kprintf(<span class="enscript-string">&quot;vfs_mountroot\n&quot;</span>);
		<span class="enscript-keyword">if</span> (0 == (err = vfs_mountroot()))
			<span class="enscript-keyword">break</span>;
		rootdevice[0] = <span class="enscript-string">'\0'</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
		<span class="enscript-keyword">if</span> (netboot) {
			PE_display_icon( 0, <span class="enscript-string">&quot;noroot&quot;</span>);  <span class="enscript-comment">/* XXX a netboot-specific icon would be nicer */</span>
			vc_progress_set(FALSE, 0);
			<span class="enscript-keyword">for</span> (i=1; 1; i*=2) {
				printf(<span class="enscript-string">&quot;bsd_init: failed to mount network root, error %d, %s\n&quot;</span>,
					err, PE_boot_args());
				printf(<span class="enscript-string">&quot;We are hanging here...\n&quot;</span>);
				IOSleep(i*60*1000);
			}
			<span class="enscript-comment">/*NOTREACHED*/</span>
		}
#<span class="enscript-reference">endif</span>
		printf(<span class="enscript-string">&quot;cannot mount root, errno = %d\n&quot;</span>, err);
		boothowto |= RB_ASKNAME;
	}

	IOSecureBSDRoot(rootdevice);

	context.vc_thread = current_thread();
	context.vc_ucred = kernproc-&gt;p_ucred;
	mountlist.tqh_first-&gt;mnt_flag |= MNT_ROOTFS;

	bsd_init_kprintf(<span class="enscript-string">&quot;calling VFS_ROOT\n&quot;</span>);
	<span class="enscript-comment">/* Get the vnode for '/'.  Set fdp-&gt;fd_fd.fd_cdir to reference it. */</span>
	<span class="enscript-keyword">if</span> (VFS_ROOT(mountlist.tqh_first, &amp;rootvnode, &amp;context))
		panic(<span class="enscript-string">&quot;bsd_init: cannot find root vnode: %s&quot;</span>, PE_boot_args());
	rootvnode-&gt;v_flag |= VROOT;
	(<span class="enscript-type">void</span>)vnode_ref(rootvnode);
	(<span class="enscript-type">void</span>)vnode_put(rootvnode);
	filedesc0.fd_cdir = rootvnode;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
	<span class="enscript-keyword">if</span> (netboot) {
		<span class="enscript-type">int</span> err;

		netboot = TRUE;
		<span class="enscript-comment">/* post mount setup */</span>
		<span class="enscript-keyword">if</span> ((err = netboot_setup()) != 0) {
			PE_display_icon( 0, <span class="enscript-string">&quot;noroot&quot;</span>);  <span class="enscript-comment">/* XXX a netboot-specific icon would be nicer */</span>
			vc_progress_set(FALSE, 0);
			<span class="enscript-keyword">for</span> (i=1; 1; i*=2) {
				printf(<span class="enscript-string">&quot;bsd_init: NetBoot could not find root, error %d: %s\n&quot;</span>,
					err, PE_boot_args());
				printf(<span class="enscript-string">&quot;We are hanging here...\n&quot;</span>);
				IOSleep(i*60*1000);
			}
			<span class="enscript-comment">/*NOTREACHED*/</span>
		}
	}
#<span class="enscript-reference">endif</span>
	

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IMAGEBOOT</span>
	<span class="enscript-comment">/*
	 * See if a system disk image is present. If so, mount it and
	 * switch the root vnode to point to it
	 */</span> 
	<span class="enscript-keyword">if</span> (netboot == FALSE &amp;&amp; imageboot_needed()) {
		<span class="enscript-comment">/* 
		 * An image was found.  No turning back: we're booted
		 * with a kernel from the disk image.
		 */</span>
		imageboot_setup(); 
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IMAGEBOOT */</span>
  
	<span class="enscript-comment">/* set initial time; all other resource data is  already zero'ed */</span>
	microtime_with_abstime(&amp;kernproc-&gt;p_start, &amp;kernproc-&gt;p_stats-&gt;ps_start);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVFS</span>
	{
	    <span class="enscript-type">char</span> mounthere[] = <span class="enscript-string">&quot;/dev&quot;</span>;	<span class="enscript-comment">/* !const because of internal casting */</span>

	    bsd_init_kprintf(<span class="enscript-string">&quot;calling devfs_kernel_mount\n&quot;</span>);
	    devfs_kernel_mount(mounthere);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVFS */</span>

	<span class="enscript-comment">/* Initialize signal state for process 0. */</span>
	bsd_init_kprintf(<span class="enscript-string">&quot;calling siginit\n&quot;</span>);
	siginit(kernproc);

	bsd_init_kprintf(<span class="enscript-string">&quot;calling bsd_utaskbootstrap\n&quot;</span>);
	bsd_utaskbootstrap();

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
	kernproc-&gt;p_flag |= P_LP64;
#<span class="enscript-reference">endif</span>

	pal_kernel_announce();

	bsd_init_kprintf(<span class="enscript-string">&quot;calling mountroot_post_hook\n&quot;</span>);

	<span class="enscript-comment">/* invoke post-root-mount hook */</span>
	<span class="enscript-keyword">if</span> (mountroot_post_hook != NULL)
		mountroot_post_hook();

#<span class="enscript-reference">if</span> 0 <span class="enscript-comment">/* not yet */</span>
	consider_zone_gc(FALSE);
#<span class="enscript-reference">endif</span>


	bsd_init_kprintf(<span class="enscript-string">&quot;done\n&quot;</span>);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bsdinit_task</span>(<span class="enscript-type">void</span>)
{
	proc_t p = current_proc();
	<span class="enscript-type">struct</span> uthread *ut;
	thread_t thread;

	process_name(<span class="enscript-string">&quot;init&quot;</span>, p);

	ux_handler_init();

	thread = current_thread();
	(<span class="enscript-type">void</span>) host_set_exception_ports(host_priv_self(),
					EXC_MASK_ALL &amp; ~(EXC_MASK_RPC_ALERT),<span class="enscript-comment">//pilotfish (shark) needs this port
</span>					(mach_port_t) ux_exception_port,
					EXCEPTION_DEFAULT| MACH_EXCEPTION_CODES,
					0);

	ut = (uthread_t)get_bsdthread_info(thread);

	bsd_init_task = get_threadtask(thread);
	init_task_died = FALSE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_cred_label_associate_user(p-&gt;p_ucred);
#<span class="enscript-reference">endif</span>
	load_init_program(p);
	lock_trace = 1;
}

kern_return_t
<span class="enscript-function-name">bsd_autoconf</span>(<span class="enscript-type">void</span>)
{
	kprintf(<span class="enscript-string">&quot;bsd_autoconf: calling kminit\n&quot;</span>);
	kminit();

	<span class="enscript-comment">/* 
	 * Early startup for bsd pseudodevices.
	 */</span>
	{
	    <span class="enscript-type">struct</span> pseudo_init *pi;
	
	    <span class="enscript-keyword">for</span> (pi = pseudo_inits; pi-&gt;ps_func; pi++)
		(*pi-&gt;ps_func) (pi-&gt;ps_count);
	}

	<span class="enscript-keyword">return</span>( IOKitBSDInit());
}


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disklabel.h&gt;</span>  <span class="enscript-comment">/* for MAXPARTITIONS */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">setconf</span>(<span class="enscript-type">void</span>)
{	
	u_int32_t	flags;
	kern_return_t	err;

	err = IOFindBSDRoot(rootdevice, <span class="enscript-keyword">sizeof</span>(rootdevice), &amp;rootdev, &amp;flags);
	<span class="enscript-keyword">if</span>( err) {
		printf(<span class="enscript-string">&quot;setconf: IOFindBSDRoot returned an error (%d);&quot;</span>
			<span class="enscript-string">&quot;setting rootdevice to 'sd0a'.\n&quot;</span>, err); <span class="enscript-comment">/* XXX DEBUG TEMP */</span>
		rootdev = makedev( 6, 0 );
		strlcpy(rootdevice, <span class="enscript-string">&quot;sd0a&quot;</span>, <span class="enscript-keyword">sizeof</span>(rootdevice));
		flags = 0;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
	<span class="enscript-keyword">if</span>( flags &amp; 1 ) {
		<span class="enscript-comment">/* network device */</span>
		mountroot = netboot_mountroot;
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/* otherwise have vfs determine root filesystem */</span>
		mountroot = NULL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
	}
#<span class="enscript-reference">endif</span>

}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bsd_utaskbootstrap</span>(<span class="enscript-type">void</span>)
{
	thread_t thread;
	<span class="enscript-type">struct</span> uthread *ut;

	<span class="enscript-comment">/*
	 * Clone the bootstrap process from the kernel process, without
	 * inheriting either task characteristics or memory from the kernel;
	 */</span>
	thread = cloneproc(TASK_NULL, COALITION_NULL, kernproc, FALSE, TRUE);

	<span class="enscript-comment">/* Hold the reference as it will be dropped during shutdown */</span>
	initproc = proc_find(1);				
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__PROC_INTERNAL_DEBUG</span>
	<span class="enscript-keyword">if</span> (initproc == PROC_NULL)
		panic(<span class="enscript-string">&quot;bsd_utaskbootstrap: initproc not set\n&quot;</span>);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Since we aren't going back out the normal way to our parent,
	 * we have to drop the transition locks explicitly.
	 */</span>
	proc_signalend(initproc, 0);
	proc_transend(initproc, 0);

	ut = (<span class="enscript-type">struct</span> uthread *)get_bsdthread_info(thread);
	ut-&gt;uu_sigmask = 0;
	act_set_astbsd(thread);
	proc_clear_return_wait(initproc, thread);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">parse_bsd_args</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">char</span> namep[16];
	<span class="enscript-type">int</span> msgbuf;

	<span class="enscript-keyword">if</span> ( PE_parse_boot_argn(<span class="enscript-string">&quot;-s&quot;</span>, namep, <span class="enscript-keyword">sizeof</span> (namep)))
		boothowto |= RB_SINGLE;

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-b&quot;</span>, namep, <span class="enscript-keyword">sizeof</span> (namep)))
		boothowto |= RB_NOBOOTRC;

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-x&quot;</span>, namep, <span class="enscript-keyword">sizeof</span> (namep))) <span class="enscript-comment">/* safe boot */</span>
		boothowto |= RB_SAFEBOOT;

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-minimalboot&quot;</span>, namep, <span class="enscript-keyword">sizeof</span>(namep))) {
		<span class="enscript-comment">/*
		 * -minimalboot indicates that we want userspace to be bootstrapped to a
		 * minimal environment.  What constitutes minimal is up to the bootstrap
		 * process.
		 */</span>
		minimalboot = 1;
	}


	<span class="enscript-comment">/* disable vnode_cache_is_authorized() by setting vnode_cache_defeat */</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-vnode_cache_defeat&quot;</span>, namep, <span class="enscript-keyword">sizeof</span> (namep)))
		bootarg_vnode_cache_defeat = 1;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-disable_aslr&quot;</span>, namep, <span class="enscript-keyword">sizeof</span> (namep)))
		bootarg_disable_aslr = 1;
#<span class="enscript-reference">endif</span>

	PE_parse_boot_argn(<span class="enscript-string">&quot;ncl&quot;</span>, &amp;ncl, <span class="enscript-keyword">sizeof</span> (ncl));
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;nbuf&quot;</span>, &amp;max_nbuf_headers,
				<span class="enscript-keyword">sizeof</span> (max_nbuf_headers))) {
		customnbuf = 1;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-variable-name">defined</span> (<span class="enscript-variable-name">__x86_64__</span>)
	PE_parse_boot_argn(<span class="enscript-string">&quot;policy_check&quot;</span>, &amp;policy_check_flags, <span class="enscript-keyword">sizeof</span> (policy_check_flags));
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* CONFIG_MACF */</span>

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;msgbuf&quot;</span>, &amp;msgbuf, <span class="enscript-keyword">sizeof</span> (msgbuf))) {
		log_setsize(msgbuf);
	}

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-novfscache&quot;</span>, namep, <span class="enscript-keyword">sizeof</span>(namep))) {
		nc_disabled = 1;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span> &amp;&amp; (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-no_vnode_jetsam&quot;</span>, namep, <span class="enscript-keyword">sizeof</span>(namep)))
		 bootarg_no_vnode_jetsam = 1;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM &amp;&amp; (DEVELOPMENT || DEBUG) */</span>



#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PROC_REF_DEBUG</span>
	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;-disable_procref_tracking&quot;</span>, namep, <span class="enscript-keyword">sizeof</span>(namep))) {
		proc_ref_tracking_disabled = 1;
	}
#<span class="enscript-reference">endif</span>

	PE_parse_boot_argn(<span class="enscript-string">&quot;sigrestrict&quot;</span>, &amp;sigrestrict_arg, <span class="enscript-keyword">sizeof</span>(sigrestrict_arg));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bsd_exec_setup</span>(<span class="enscript-type">int</span> scale)
{

	<span class="enscript-keyword">switch</span> (scale) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
			bsd_simul_execs = BSD_SIMUL_EXECS;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">2</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">3</span>:
			bsd_simul_execs = 65;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">4</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">5</span>:
			bsd_simul_execs = 129;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">6</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">7</span>:
			bsd_simul_execs = 257;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			bsd_simul_execs = 513;
			<span class="enscript-keyword">break</span>;
			
	}
	bsd_pageable_map_size = (bsd_simul_execs * BSD_PAGEABLE_SIZE_PER_EXEC);
}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">NFSCLIENT</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">netboot_root</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">int</span> 
<span class="enscript-function-name">netboot_root</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span>(0);
}
#<span class="enscript-reference">endif</span>
</pre>
<hr />
</body></html>