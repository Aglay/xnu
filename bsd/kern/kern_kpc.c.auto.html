<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_kpc.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_kpc.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mman.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kpc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kperf/kperf.h&gt;</span>

<span class="enscript-comment">/* Various sysctl requests */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REQ_CLASSES</span>              (1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REQ_COUNTING</span>             (2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REQ_THREAD_COUNTING</span>      (3)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REQ_CONFIG_COUNT</span>         (4)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REQ_COUNTER_COUNT</span>        (5)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REQ_THREAD_COUNTERS</span>      (6)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REQ_COUNTERS</span>             (7)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REQ_SHADOW_COUNTERS</span>      (8)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REQ_CONFIG</span>               (9)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REQ_PERIOD</span>              (10)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REQ_ACTIONID</span>            (11)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REQ_SW_INC</span>              (14)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">REQ_PMU_VERSION</span>         (15)

<span class="enscript-comment">/* Type-munging casts */</span>
<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*getint_t)(<span class="enscript-type">void</span>);
<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*setint_t)(<span class="enscript-type">int</span>);

<span class="enscript-comment">/* safety */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> kpc_initted = 0;

<span class="enscript-comment">/* locking and buffer for large data requests */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SYSCTL_BUFFER_SIZE</span> (33 * sizeof(uint64_t))
<span class="enscript-type">static</span> lck_grp_attr_t *sysctl_buffer_lckgrp_attr = NULL;
<span class="enscript-type">static</span> lck_grp_t      *sysctl_buffer_lckgrp = NULL;
<span class="enscript-type">static</span> lck_mtx_t       sysctl_buffer_lock;
<span class="enscript-type">static</span> <span class="enscript-type">void</span>           *sysctl_buffer = NULL;

<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*setget_func_t)(<span class="enscript-type">int</span>);

<span class="enscript-type">void</span>
<span class="enscript-function-name">kpc_init</span>(<span class="enscript-type">void</span>)
{
	sysctl_buffer_lckgrp_attr = lck_grp_attr_alloc_init();
        sysctl_buffer_lckgrp = lck_grp_alloc_init(<span class="enscript-string">&quot;kpc&quot;</span>, 
                                                  sysctl_buffer_lckgrp_attr);
	lck_mtx_init(&amp;sysctl_buffer_lock, sysctl_buffer_lckgrp, LCK_ATTR_NULL);

	kpc_arch_init();
	kpc_common_init();
	kpc_thread_init();

	kpc_initted = 1;
}

<span class="enscript-comment">/* abstract sysctl handlers */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_get_int</span>( <span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">struct</span> sysctl_req *req,
                uint32_t value )
{
	<span class="enscript-type">int</span> error = 0;
    
	<span class="enscript-comment">/* copy out the old value */</span>
	error = sysctl_handle_int(oidp, &amp;value, 0, req);
    
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_set_int</span>( <span class="enscript-type">struct</span> sysctl_req *req, <span class="enscript-type">int</span> (*set_func)(<span class="enscript-type">int</span>))
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> value = 0;
    
	error = SYSCTL_IN( req, &amp;value, <span class="enscript-keyword">sizeof</span>(value) );
	<span class="enscript-keyword">if</span>( error )
		<span class="enscript-keyword">return</span> error;
    
	error = set_func( value );

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_getset_int</span>( <span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">struct</span> sysctl_req *req,
                   <span class="enscript-type">int</span> (*get_func)(<span class="enscript-type">void</span>), <span class="enscript-type">int</span> (*set_func)(<span class="enscript-type">int</span>) )
{
	<span class="enscript-type">int</span> error = 0;
	uint32_t value = 0;
    
	<span class="enscript-comment">/* get the old value and process it */</span>
	value = get_func();

	<span class="enscript-comment">/* copy out the old value, get the new value */</span>
	error = sysctl_handle_int(oidp, &amp;value, 0, req);
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/* if that worked, and we're writing... */</span>
	error = set_func( value );

	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_setget_int</span>( <span class="enscript-type">struct</span> sysctl_req *req,
                   <span class="enscript-type">int</span> (*setget_func)(<span class="enscript-type">int</span>) )
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> value = 0;
    
	error = SYSCTL_IN( req, &amp;value, <span class="enscript-keyword">sizeof</span>(value) );
	<span class="enscript-keyword">if</span>( error )
		<span class="enscript-keyword">return</span> error;
	
	value = setget_func(value);

	error = SYSCTL_OUT( req, &amp;value, <span class="enscript-keyword">sizeof</span>(value) );

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kpc_sysctl_acquire_buffer</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span>( sysctl_buffer == NULL )
	{
		sysctl_buffer = kalloc(SYSCTL_BUFFER_SIZE);
		<span class="enscript-keyword">if</span>( sysctl_buffer )
		{
			bzero( sysctl_buffer, SYSCTL_BUFFER_SIZE );
		}
	}

	<span class="enscript-keyword">if</span>( !sysctl_buffer )
	{
		<span class="enscript-keyword">return</span> ENOMEM;
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">sysctl_kpc_get_counters</span>(uint32_t counters,
                      uint32_t *size, <span class="enscript-type">void</span> *buf)
{
	uint64_t *ctr_buf = (uint64_t*)buf;
	<span class="enscript-type">int</span> curcpu;
	uint32_t count;

	count = kpc_get_cpu_counters(counters &amp; KPC_ALL_CPUS,
	                             counters,
	                             &amp;curcpu, &amp;ctr_buf[1]);
	<span class="enscript-keyword">if</span> (!count)
		<span class="enscript-keyword">return</span> EINVAL;

	ctr_buf[0] = curcpu;

	*size = (count+1) * <span class="enscript-keyword">sizeof</span>(uint64_t);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">sysctl_kpc_get_shadow_counters</span>(uint32_t counters,
                      uint32_t *size, <span class="enscript-type">void</span> *buf)
{
	uint64_t *ctr_buf = (uint64_t*)buf;
	<span class="enscript-type">int</span> curcpu;
	uint32_t count;

	count = kpc_get_shadow_counters(counters &amp; KPC_ALL_CPUS,
	                                counters,
	                                &amp;curcpu, &amp;ctr_buf[1]);

	<span class="enscript-keyword">if</span> (!count)
		<span class="enscript-keyword">return</span> EINVAL;

	ctr_buf[0] = curcpu;

	*size = (count+1) * <span class="enscript-keyword">sizeof</span>(uint64_t);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">sysctl_kpc_get_thread_counters</span>(uint32_t tid,
                             uint32_t *size, <span class="enscript-type">void</span> *buf)
{
	uint32_t count = *size / <span class="enscript-keyword">sizeof</span>(uint64_t);
	<span class="enscript-type">int</span> r;

	<span class="enscript-keyword">if</span>( tid != 0 )
		<span class="enscript-keyword">return</span> EINVAL;

	r = kpc_get_curthread_counters(&amp;count, buf);
	<span class="enscript-keyword">if</span>( !r )
		*size = count * <span class="enscript-keyword">sizeof</span>(uint64_t);

	<span class="enscript-keyword">return</span> r;
}   

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_kpc_get_config</span>(uint32_t classes, <span class="enscript-type">void</span>* buf)
{
	<span class="enscript-keyword">return</span> kpc_get_config( classes, buf );
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_kpc_set_config</span>(uint32_t classes, <span class="enscript-type">void</span>* buf)
{
	<span class="enscript-comment">/* userspace cannot reconfigure the power class */</span>
	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_POWER_MASK)
		<span class="enscript-keyword">return</span> (EPERM);
	<span class="enscript-keyword">return</span> kpc_set_config( classes, buf);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_kpc_get_period</span>(uint32_t classes, <span class="enscript-type">void</span>* buf)
{
	<span class="enscript-keyword">return</span> kpc_get_period( classes, buf );
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_kpc_set_period</span>(uint32_t classes, <span class="enscript-type">void</span>* buf)
{
	<span class="enscript-comment">/* userspace cannot reconfigure the power class */</span>
	<span class="enscript-keyword">if</span> (classes &amp; KPC_CLASS_POWER_MASK)
		<span class="enscript-keyword">return</span> (EPERM);
	<span class="enscript-keyword">return</span> kpc_set_period( classes, buf);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_kpc_get_actionid</span>(uint32_t classes, <span class="enscript-type">void</span>* buf)
{
	<span class="enscript-keyword">return</span> kpc_get_actionid( classes, buf );
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_kpc_set_actionid</span>(uint32_t classes, <span class="enscript-type">void</span>* buf)
{
	<span class="enscript-keyword">return</span> kpc_set_actionid( classes, buf);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_get_bigarray</span>( <span class="enscript-type">struct</span> sysctl_req *req, 
                     <span class="enscript-type">int</span> (*get_fn)(uint32_t, uint32_t*, <span class="enscript-type">void</span>*) )
{
	<span class="enscript-type">int</span> error = 0;
	uint32_t bufsize = SYSCTL_BUFFER_SIZE;
	uint32_t arg = 0;

	<span class="enscript-comment">/* get the argument */</span>
	error = SYSCTL_IN( req, &amp;arg, <span class="enscript-keyword">sizeof</span>(arg) );
	<span class="enscript-keyword">if</span>(error)
	{
		printf( <span class="enscript-string">&quot;kpc: no arg?\n&quot;</span> );
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-comment">/* get the wired buffer */</span>
	error = kpc_sysctl_acquire_buffer();
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-comment">/* atomically get the array into the wired buffer. We have a double
	 * copy, but this is better than page faulting / interrupting during
	 * a copy.
	 */</span>
	error = get_fn( arg, &amp;bufsize, sysctl_buffer );

	<span class="enscript-comment">/* do the copy out */</span>
	<span class="enscript-keyword">if</span>( !error )
		error = SYSCTL_OUT( req, sysctl_buffer, bufsize );

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/* given a config word, how many bytes does it take? */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_config_size</span>( uint32_t config )
{
	<span class="enscript-keyword">return</span> kpc_get_config_count(config) * <span class="enscript-keyword">sizeof</span>(kpc_config_t);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_counter_size</span>( uint32_t classes )
{
	<span class="enscript-keyword">return</span> kpc_get_counter_count(classes) * <span class="enscript-keyword">sizeof</span>(uint64_t);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_actionid_size</span>( uint32_t classes )
{
	<span class="enscript-keyword">return</span> kpc_get_counter_count(classes) * <span class="enscript-keyword">sizeof</span>(int32_t);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_getset_bigarray</span>( <span class="enscript-type">struct</span> sysctl_req *req, 
                        <span class="enscript-type">int</span> (*size_fn)(uint32_t arg),
                        <span class="enscript-type">int</span> (*get_fn)(uint32_t, <span class="enscript-type">void</span>*),
                        <span class="enscript-type">int</span> (*set_fn)(uint32_t, <span class="enscript-type">void</span>*) )
{
	<span class="enscript-type">int</span> error = 0;
	uint32_t bufsize = SYSCTL_BUFFER_SIZE;
	uint32_t regsize = 0;
	uint64_t arg;

	<span class="enscript-comment">/* get the config word */</span>
	error = SYSCTL_IN( req, &amp;arg, <span class="enscript-keyword">sizeof</span>(arg) );
	<span class="enscript-keyword">if</span>(error)
	{
		printf( <span class="enscript-string">&quot;kpc: no arg?\n&quot;</span> );
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-comment">/* Work out size of registers */</span>
	regsize = size_fn((uint32_t)arg);

	<span class="enscript-comment">/* Ignore NULL requests */</span>
	<span class="enscript-keyword">if</span>(regsize == 0)
		<span class="enscript-keyword">return</span> EINVAL;

	<span class="enscript-comment">/* ensure not too big */</span>
	<span class="enscript-keyword">if</span>( regsize &gt; bufsize )
		<span class="enscript-keyword">return</span> EINVAL;

	<span class="enscript-comment">/* get the wired buffer */</span>
	error = kpc_sysctl_acquire_buffer();
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-comment">// if writing...
</span>	<span class="enscript-keyword">if</span>(req-&gt;newptr)
	{
		<span class="enscript-comment">// copy in the rest in -- sysctl remembers we did one already
</span>		error = SYSCTL_IN( req, sysctl_buffer, 
		                   regsize );

		<span class="enscript-comment">// if SYSCTL_IN fails it means we are only doing a read
</span>		<span class="enscript-keyword">if</span>(!error) {
			<span class="enscript-comment">// set it
</span>			error = set_fn( (uint32_t)arg, sysctl_buffer );
			<span class="enscript-keyword">if</span>( error )
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
		}
	}

	<span class="enscript-comment">// if reading
</span>	<span class="enscript-keyword">if</span>(req-&gt;oldptr)
	{
		<span class="enscript-comment">// read it
</span>		error = get_fn( (uint32_t)arg, sysctl_buffer );
		<span class="enscript-keyword">if</span>( error )
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;

		<span class="enscript-comment">// copy out the full set
</span>		error = SYSCTL_OUT( req, sysctl_buffer, regsize );
	}
   
<span class="enscript-reference">fail</span>:
	<span class="enscript-keyword">return</span> error;
}



<span class="enscript-comment">/*
 * #define SYSCTL_HANDLER_ARGS (struct sysctl_oid *oidp,         \
 *                                void *arg1, int arg2,                 \
 *                              struct sysctl_req *req )
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
kpc_sysctl SYSCTL_HANDLER_ARGS
{
	<span class="enscript-type">int</span> ret;

	<span class="enscript-comment">// __unused struct sysctl_oid *unused_oidp = oidp;
</span>	(<span class="enscript-type">void</span>)arg2;
    
	<span class="enscript-keyword">if</span>( !kpc_initted )
		panic(<span class="enscript-string">&quot;kpc_init not called&quot;</span>);

	<span class="enscript-comment">// Most sysctls require an access check, but a few are public.
</span>	<span class="enscript-keyword">switch</span>( (uintptr_t) arg1 ) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_CLASSES</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_CONFIG_COUNT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_COUNTER_COUNT</span>:
		<span class="enscript-comment">// These read-only sysctls are public.
</span>		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-comment">// Require kperf access to read or write anything else.
</span>		<span class="enscript-comment">// This is either root or the blessed pid.
</span>		ret = kperf_access_check();
		<span class="enscript-keyword">if</span> (ret) {
			<span class="enscript-keyword">return</span> ret;
		}
		<span class="enscript-keyword">break</span>;
	}

	lck_mtx_lock(&amp;sysctl_buffer_lock);

	<span class="enscript-comment">/* which request */</span>
	<span class="enscript-keyword">switch</span>( (uintptr_t) arg1 )
	{
	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_CLASSES</span>:
		ret = sysctl_get_int( oidp, req,
		                       kpc_get_classes() );
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_COUNTING</span>:
		ret = sysctl_getset_int( oidp, req,
		                          (getint_t)kpc_get_running,
		                          (setint_t)kpc_set_running );
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_THREAD_COUNTING</span>:
		ret = sysctl_getset_int( oidp, req,
		                          (getint_t)kpc_get_thread_counting,
		                          (setint_t)kpc_set_thread_counting );
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_CONFIG_COUNT</span>:
		ret = sysctl_setget_int( req,
		                          (setget_func_t)kpc_get_config_count );
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_COUNTER_COUNT</span>:
		ret = sysctl_setget_int( req,
		                          (setget_func_t)kpc_get_counter_count );
		<span class="enscript-keyword">break</span>;


	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_THREAD_COUNTERS</span>:
		ret = sysctl_get_bigarray( req, sysctl_kpc_get_thread_counters );
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_COUNTERS</span>:
		ret = sysctl_get_bigarray( req, sysctl_kpc_get_counters );
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_SHADOW_COUNTERS</span>:
		ret = sysctl_get_bigarray( req, sysctl_kpc_get_shadow_counters );
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_CONFIG</span>:
		ret = sysctl_getset_bigarray( req,
		                               sysctl_config_size,
		                               sysctl_kpc_get_config,
		                               sysctl_kpc_set_config );
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_PERIOD</span>:
		ret = sysctl_getset_bigarray( req,
		                               sysctl_counter_size,
		                               sysctl_kpc_get_period,
		                               sysctl_kpc_set_period );
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_ACTIONID</span>:
		ret = sysctl_getset_bigarray( req,
		                               sysctl_actionid_size,
		                               sysctl_kpc_get_actionid,
		                               sysctl_kpc_set_actionid );
		<span class="enscript-keyword">break</span>;


	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_SW_INC</span>:
		ret = sysctl_set_int( req, (setget_func_t)kpc_set_sw_inc );
		<span class="enscript-keyword">break</span>;		

	<span class="enscript-keyword">case</span> <span class="enscript-reference">REQ_PMU_VERSION</span>:
		ret = sysctl_get_int(oidp, req, kpc_get_pmu_version());
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		ret = ENOENT;
		<span class="enscript-keyword">break</span>;
	}

	lck_mtx_unlock(&amp;sysctl_buffer_lock);
 
	<span class="enscript-keyword">return</span> ret;
}


<span class="enscript-comment">/***  sysctl definitions  ***/</span>

<span class="enscript-comment">/* root kperf node */</span>
<span class="enscript-function-name">SYSCTL_NODE</span>(, OID_AUTO, kpc, CTLFLAG_RW|CTLFLAG_LOCKED, 0,
            <span class="enscript-string">&quot;kpc&quot;</span>);

<span class="enscript-comment">/* values */</span>
<span class="enscript-function-name">SYSCTL_PROC</span>(_kpc, OID_AUTO, classes,
            CTLTYPE_INT|CTLFLAG_RD|CTLFLAG_ANYBODY,
            (<span class="enscript-type">void</span>*)REQ_CLASSES, 
            <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), kpc_sysctl, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Available classes&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kpc, OID_AUTO, counting,
            CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
            (<span class="enscript-type">void</span>*)REQ_COUNTING, 
            <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), kpc_sysctl, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;PMCs counting&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kpc, OID_AUTO, thread_counting,
            CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
            (<span class="enscript-type">void</span>*)REQ_THREAD_COUNTING, 
            <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), kpc_sysctl, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Thread accumulation&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kpc, OID_AUTO, pmu_version,
            CTLTYPE_INT | CTLFLAG_RD | CTLFLAG_ANYBODY,
            (<span class="enscript-type">void</span> *)REQ_PMU_VERSION,
            <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), kpc_sysctl, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;PMU version for hardware&quot;</span>);

<span class="enscript-comment">/* faux values */</span>
<span class="enscript-function-name">SYSCTL_PROC</span>(_kpc, OID_AUTO, config_count,
            CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
            (<span class="enscript-type">void</span>*)REQ_CONFIG_COUNT, 
            <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), kpc_sysctl, <span class="enscript-string">&quot;S&quot;</span>, <span class="enscript-string">&quot;Config count&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kpc, OID_AUTO, counter_count,
            CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
            (<span class="enscript-type">void</span>*)REQ_COUNTER_COUNT, 
            <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), kpc_sysctl, <span class="enscript-string">&quot;S&quot;</span>, <span class="enscript-string">&quot;Counter count&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kpc, OID_AUTO, sw_inc,
            CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
            (<span class="enscript-type">void</span>*)REQ_SW_INC, 
            <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), kpc_sysctl, <span class="enscript-string">&quot;S&quot;</span>, <span class="enscript-string">&quot;Software increment&quot;</span>);

<span class="enscript-comment">/* arrays */</span>
<span class="enscript-function-name">SYSCTL_PROC</span>(_kpc, OID_AUTO, thread_counters,
            CTLFLAG_RD|CTLFLAG_WR|CTLFLAG_ANYBODY,
            (<span class="enscript-type">void</span>*)REQ_THREAD_COUNTERS, 
            <span class="enscript-keyword">sizeof</span>(uint64_t), kpc_sysctl, 
            <span class="enscript-string">&quot;QU&quot;</span>, <span class="enscript-string">&quot;Current thread counters&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kpc, OID_AUTO, counters,
            CTLFLAG_RD|CTLFLAG_WR|CTLFLAG_ANYBODY,
            (<span class="enscript-type">void</span>*)REQ_COUNTERS, 
            <span class="enscript-keyword">sizeof</span>(uint64_t), kpc_sysctl, 
            <span class="enscript-string">&quot;QU&quot;</span>, <span class="enscript-string">&quot;Current counters&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kpc, OID_AUTO, shadow_counters,
            CTLFLAG_RD|CTLFLAG_WR|CTLFLAG_ANYBODY,
            (<span class="enscript-type">void</span>*)REQ_SHADOW_COUNTERS, 
            <span class="enscript-keyword">sizeof</span>(uint64_t), kpc_sysctl, 
            <span class="enscript-string">&quot;QU&quot;</span>, <span class="enscript-string">&quot;Current shadow counters&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kpc, OID_AUTO, config,
            CTLFLAG_RD|CTLFLAG_WR|CTLFLAG_ANYBODY,
            (<span class="enscript-type">void</span>*)REQ_CONFIG, 
            <span class="enscript-keyword">sizeof</span>(uint64_t), kpc_sysctl, 
            <span class="enscript-string">&quot;QU&quot;</span>, <span class="enscript-string">&quot;Set counter configs&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kpc, OID_AUTO, period,
            CTLFLAG_RD|CTLFLAG_WR|CTLFLAG_ANYBODY,
            (<span class="enscript-type">void</span>*)REQ_PERIOD, 
            <span class="enscript-keyword">sizeof</span>(uint64_t), kpc_sysctl, 
            <span class="enscript-string">&quot;QU&quot;</span>, <span class="enscript-string">&quot;Set counter periods&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kpc, OID_AUTO, actionid,
            CTLFLAG_RD|CTLFLAG_WR|CTLFLAG_ANYBODY,
            (<span class="enscript-type">void</span>*)REQ_ACTIONID, 
            <span class="enscript-keyword">sizeof</span>(uint32_t), kpc_sysctl, 
            <span class="enscript-string">&quot;QU&quot;</span>, <span class="enscript-string">&quot;Set counter actionids&quot;</span>);


</pre>
<hr />
</body></html>