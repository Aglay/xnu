<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_memorystatus.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_memorystatus.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/coalition.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/coalition.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/wait.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/tree.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_memorystatus.h&gt;</span> 

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
<span class="enscript-comment">/* For logging clarity */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *jetsam_kill_cause_name[] = {
	<span class="enscript-string">&quot;&quot;</span>                      ,
	<span class="enscript-string">&quot;jettisoned&quot;</span>		,       <span class="enscript-comment">/* kMemorystatusKilled			*/</span>
	<span class="enscript-string">&quot;highwater&quot;</span>             ,       <span class="enscript-comment">/* kMemorystatusKilledHiwat		*/</span>
	<span class="enscript-string">&quot;vnode-limit&quot;</span>           ,       <span class="enscript-comment">/* kMemorystatusKilledVnodes		*/</span>
	<span class="enscript-string">&quot;vm-pageshortage&quot;</span>       ,       <span class="enscript-comment">/* kMemorystatusKilledVMPageShortage	*/</span>
	<span class="enscript-string">&quot;vm-thrashing&quot;</span>          ,       <span class="enscript-comment">/* kMemorystatusKilledVMThrashing	*/</span>
	<span class="enscript-string">&quot;fc-thrashing&quot;</span>          ,       <span class="enscript-comment">/* kMemorystatusKilledFCThrashing	*/</span>
	<span class="enscript-string">&quot;per-process-limit&quot;</span>     ,       <span class="enscript-comment">/* kMemorystatusKilledPerProcessLimit	*/</span>
	<span class="enscript-string">&quot;diagnostic&quot;</span>            ,       <span class="enscript-comment">/* kMemorystatusKilledDiagnostic	*/</span>
	<span class="enscript-string">&quot;idle-exit&quot;</span>             ,       <span class="enscript-comment">/* kMemorystatusKilledIdleExit		*/</span>
};

<span class="enscript-comment">/* Does cause indicate vm or fc thrashing? */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">is_thrashing</span>(<span class="enscript-type">unsigned</span> cause)
{
	<span class="enscript-keyword">switch</span> (cause) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kMemorystatusKilledVMThrashing</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kMemorystatusKilledFCThrashing</span>:
		<span class="enscript-keyword">return</span> TRUE;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> FALSE;
	}
}

<span class="enscript-comment">/* Callback into vm_compressor.c to signal that thrashing has been mitigated. */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_thrashing_jetsam_done</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* These are very verbose printfs(), enable with
 * MEMORYSTATUS_DEBUG_LOG
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MEMORYSTATUS_DEBUG_LOG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MEMORYSTATUS_DEBUG</span>(cond, format, ...)      \
<span class="enscript-keyword">do</span> {                                              \
	<span class="enscript-keyword">if</span> (cond) { printf(format, ##__VA_ARGS__); } \
} <span class="enscript-keyword">while</span>(0)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">MEMORYSTATUS_DEBUG</span>(cond, format, ...)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Active / Inactive limit support
 * proc list must be locked
 *
 * The SET_*** macros are used to initialize a limit
 * for the first time.
 *
 * The CACHE_*** macros are use to cache the limit that will
 * soon be in effect down in the ledgers.
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SET_ACTIVE_LIMITS_LOCKED</span>(p, limit, is_fatal)			\
MACRO_BEGIN								\
(p)-&gt;p_memstat_memlimit_active = (limit);				\
   (p)-&gt;p_memstat_state &amp;= ~P_MEMSTAT_MEMLIMIT_ACTIVE_EXC_TRIGGERED;	\
   <span class="enscript-keyword">if</span> (is_fatal) {							\
	   (p)-&gt;p_memstat_state |= P_MEMSTAT_MEMLIMIT_ACTIVE_FATAL;	\
   } <span class="enscript-keyword">else</span> {								\
	   (p)-&gt;p_memstat_state &amp;= ~P_MEMSTAT_MEMLIMIT_ACTIVE_FATAL;	\
   }									\
MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SET_INACTIVE_LIMITS_LOCKED</span>(p, limit, is_fatal)			\
MACRO_BEGIN								\
(p)-&gt;p_memstat_memlimit_inactive = (limit);				\
   (p)-&gt;p_memstat_state &amp;= ~P_MEMSTAT_MEMLIMIT_INACTIVE_EXC_TRIGGERED;	\
   <span class="enscript-keyword">if</span> (is_fatal) {							\
	   (p)-&gt;p_memstat_state |= P_MEMSTAT_MEMLIMIT_INACTIVE_FATAL;	\
   } <span class="enscript-keyword">else</span> {								\
	   (p)-&gt;p_memstat_state &amp;= ~P_MEMSTAT_MEMLIMIT_INACTIVE_FATAL;	\
   }									\
MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CACHE_ACTIVE_LIMITS_LOCKED</span>(p, trigger_exception)		\
MACRO_BEGIN								\
(p)-&gt;p_memstat_memlimit = (p)-&gt;p_memstat_memlimit_active;		\
   <span class="enscript-keyword">if</span> ((p)-&gt;p_memstat_state &amp; P_MEMSTAT_MEMLIMIT_ACTIVE_FATAL) {	\
	   (p)-&gt;p_memstat_state |= P_MEMSTAT_FATAL_MEMLIMIT;		\
   } <span class="enscript-keyword">else</span> {								\
	   (p)-&gt;p_memstat_state &amp;= ~P_MEMSTAT_FATAL_MEMLIMIT;		\
   }									\
   <span class="enscript-keyword">if</span> ((p)-&gt;p_memstat_state &amp; P_MEMSTAT_MEMLIMIT_ACTIVE_EXC_TRIGGERED) { \
	   trigger_exception = FALSE;					\
   } <span class="enscript-keyword">else</span> {								\
	   trigger_exception = TRUE;					\
   }									\
MACRO_END

#<span class="enscript-reference">define</span> <span class="enscript-function-name">CACHE_INACTIVE_LIMITS_LOCKED</span>(p, trigger_exception)		\
MACRO_BEGIN								\
(p)-&gt;p_memstat_memlimit = (p)-&gt;p_memstat_memlimit_inactive;		\
   <span class="enscript-keyword">if</span> ((p)-&gt;p_memstat_state &amp; P_MEMSTAT_MEMLIMIT_INACTIVE_FATAL) {	\
	   (p)-&gt;p_memstat_state |= P_MEMSTAT_FATAL_MEMLIMIT;		\
   } <span class="enscript-keyword">else</span> {								\
	   (p)-&gt;p_memstat_state &amp;= ~P_MEMSTAT_FATAL_MEMLIMIT;		\
   }									\
   <span class="enscript-keyword">if</span> ((p)-&gt;p_memstat_state &amp; P_MEMSTAT_MEMLIMIT_INACTIVE_EXC_TRIGGERED) { \
	   trigger_exception = FALSE;					\
   } <span class="enscript-keyword">else</span> {								\
	   trigger_exception = TRUE;					\
   }									\
MACRO_END


<span class="enscript-comment">/* General tunables */</span>

<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> delta_percentage = 5;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> critical_threshold_percentage = 5;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> idle_offset_percentage = 5;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> pressure_threshold_percentage = 15;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> freeze_threshold_percentage = 50;

<span class="enscript-comment">/* General memorystatus stuff */</span>

<span class="enscript-type">struct</span> klist memorystatus_klist;
<span class="enscript-type">static</span> lck_mtx_t memorystatus_klist_mutex;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_klist_lock</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_klist_unlock</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> uint64_t memorystatus_idle_delay_time = 0;

<span class="enscript-comment">/*
 * Memorystatus kevents
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">filt_memorystatusattach</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">filt_memorystatusdetach</span>(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">filt_memorystatus</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint);

<span class="enscript-type">struct</span> filterops memorystatus_filtops = {
	.f_attach = filt_memorystatusattach,
	.f_detach = filt_memorystatusdetach,
	.f_event = filt_memorystatus,
};

<span class="enscript-type">enum</span> {
	kMemorystatusNoPressure = 0x1,
	kMemorystatusPressure = 0x2,
	kMemorystatusLowSwap = 0x4
};

<span class="enscript-comment">/* Idle guard handling */</span>

<span class="enscript-type">static</span> int32_t memorystatus_scheduled_idle_demotions = 0;

<span class="enscript-type">static</span> thread_call_t memorystatus_idle_demotion_call;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_perform_idle_demotion</span>(__unused <span class="enscript-type">void</span> *spare1, __unused <span class="enscript-type">void</span> *spare2);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_schedule_idle_demotion_locked</span>(proc_t p, boolean_t set_state);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_invalidate_idle_demotion_locked</span>(proc_t p, boolean_t clean_state);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_reschedule_idle_demotion_locked</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_update_priority_locked</span>(proc_t p, <span class="enscript-type">int</span> priority, boolean_t head_insert);

boolean_t <span class="enscript-function-name">is_knote_registered_modify_task_pressure_bits</span>(<span class="enscript-type">struct</span> knote*, <span class="enscript-type">int</span>, task_t, vm_pressure_level_t, vm_pressure_level_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_send_low_swap_note</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">int</span> memorystatus_wakeup = 0;

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_level = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_early_boot_level = 0;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> memorystatus_list_count = 0;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MEMSTAT_BUCKET_COUNT</span> (JETSAM_PRIORITY_MAX + 1)

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> memstat_bucket {
    TAILQ_HEAD(, proc) list;
    <span class="enscript-type">int</span> count;
} memstat_bucket_t;

memstat_bucket_t memstat_bucket[MEMSTAT_BUCKET_COUNT];

uint64_t memstat_idle_demotion_deadline = 0;

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_dirty_count = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, max_task_pmem, CTLFLAG_RD|CTLFLAG_LOCKED|CTLFLAG_MASKED, &amp;max_task_footprint_mb, 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span> // <span class="enscript-variable-name">CONFIG_JETSAM</span>


<span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_get_level</span>(__unused <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> memorystatus_get_level_args *args, __unused <span class="enscript-type">int</span> *ret)
{
	user_addr_t	level = 0;
	
	level = args-&gt;level;
	
	<span class="enscript-keyword">if</span> (copyout(&amp;memorystatus_level, level, <span class="enscript-keyword">sizeof</span>(memorystatus_level)) != 0) {
		<span class="enscript-keyword">return</span> EFAULT;
	}
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> proc_t <span class="enscript-function-name">memorystatus_get_first_proc_locked</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *bucket_index, boolean_t search);
<span class="enscript-type">static</span> proc_t <span class="enscript-function-name">memorystatus_get_next_proc_locked</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *bucket_index, proc_t p, boolean_t search);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_thread</span>(<span class="enscript-type">void</span> *param __unused, wait_result_t wr __unused);

<span class="enscript-comment">/* Jetsam */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">memorystatus_cmd_set_jetsam_memory_limit</span>(pid_t pid, int32_t high_water_mark, __unused int32_t *retval, boolean_t is_fatal_limit);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">memorystatus_cmd_set_memlimit_properties</span>(pid_t pid, user_addr_t buffer, size_t buffer_size, __unused int32_t *retval);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">memorystatus_set_memlimit_properties</span>(pid_t pid, memorystatus_memlimit_properties_t *entry);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">memorystatus_cmd_get_memlimit_properties</span>(pid_t pid, user_addr_t buffer, size_t buffer_size, __unused int32_t *retval);

<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">proc_jetsam_state_is_active_locked</span>(proc_t);

<span class="enscript-type">int</span> <span class="enscript-function-name">proc_get_memstat_priority</span>(proc_t, boolean_t);

<span class="enscript-comment">/* Kill processes exceeding their limit either under memory pressure (1), or as soon as possible (0) */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LEGACY_HIWATER</span> 1

<span class="enscript-type">static</span> boolean_t memorystatus_idle_snapshot = 0;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> memorystatus_highwater_enabled = 1;  <span class="enscript-comment">/* Update the cached memlimit data. This should be removed. */</span>

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_delta = 0;

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_available_pages_critical_base = 0;
<span class="enscript-comment">//static unsigned int memorystatus_last_foreground_pressure_pages = (unsigned int)-1;
</span><span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_available_pages_critical_idle_offset = 0;

<span class="enscript-comment">/* Jetsam Loop Detection */</span>
<span class="enscript-type">static</span> boolean_t memorystatus_jld_enabled = TRUE;		<span class="enscript-comment">/* Enables jetsam loop detection on all devices */</span>
<span class="enscript-type">static</span> uint32_t memorystatus_jld_eval_period_msecs = 0;		<span class="enscript-comment">/* Init pass sets this based on device memory size */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>      memorystatus_jld_eval_aggressive_count = 3;	<span class="enscript-comment">/* Raise the priority max after 'n' aggressive loops */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>      memorystatus_jld_eval_aggressive_priority_band_max = 15;  <span class="enscript-comment">/* Kill aggressively up through this band */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-comment">/* 
 * Jetsam Loop Detection tunables.
 */</span>

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, memorystatus_jld_eval_period_msecs, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_jld_eval_period_msecs, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, memorystatus_jld_eval_aggressive_count, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_jld_eval_aggressive_count, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, memorystatus_jld_eval_aggressive_priority_band_max, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_jld_eval_aggressive_priority_band_max, 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_jetsam_panic_debug = 0;

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_jetsam_policy = kPolicyDefault;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_jetsam_policy_offset_pages_diagnostic = 0;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_debug_dump_this_bucket = 0;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_thread_wasted_wakeup = 0;

<span class="enscript-type">static</span> uint32_t kill_under_pressure_cause = 0;

<span class="enscript-comment">/*
 * default jetsam snapshot support
 */</span>
<span class="enscript-type">static</span> memorystatus_jetsam_snapshot_t *memorystatus_jetsam_snapshot;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">memorystatus_jetsam_snapshot_list</span> memorystatus_jetsam_snapshot-&gt;entries
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_jetsam_snapshot_count = 0;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_jetsam_snapshot_max = 0;
<span class="enscript-type">static</span> uint64_t memorystatus_jetsam_snapshot_last_timestamp = 0;
<span class="enscript-type">static</span> uint64_t memorystatus_jetsam_snapshot_timeout = 0;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">JETSAM_SNAPSHOT_TIMEOUT_SECS</span> 30

<span class="enscript-comment">/*
 * snapshot support for memstats collected at boot.
 */</span>
<span class="enscript-type">static</span> memorystatus_jetsam_snapshot_t memorystatus_at_boot_snapshot;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_clear_errors</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_get_task_page_counts</span>(task_t task, uint32_t *footprint, uint32_t *max_footprint, uint32_t *max_footprint_lifetime, uint32_t *purgeable_pages);
<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">memorystatus_build_state</span>(proc_t p);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_update_levels_locked</span>(boolean_t critical_only);
<span class="enscript-comment">//static boolean_t memorystatus_issue_pressure_kevent(boolean_t pressured);
</span>
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">memorystatus_kill_specific_process</span>(pid_t victim_pid, uint32_t cause);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">memorystatus_kill_top_process</span>(boolean_t any, boolean_t sort_flag, uint32_t cause, int32_t *priority, uint32_t *errors);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">memorystatus_kill_top_process_aggressive</span>(boolean_t any, uint32_t cause, <span class="enscript-type">int</span> aggr_count, int32_t priority_max, uint32_t *errors);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LEGACY_HIWATER</span>
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">memorystatus_kill_hiwat_proc</span>(uint32_t *errors);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">memorystatus_kill_process_async</span>(pid_t victim_pid, uint32_t cause);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">memorystatus_kill_process_sync</span>(pid_t victim_pid, uint32_t cause);

<span class="enscript-comment">/* Priority Band Sorting Routines */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">memorystatus_sort_bucket</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bucket_index, <span class="enscript-type">int</span> sort_order);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">memorystatus_sort_by_largest_coalition_locked</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bucket_index, <span class="enscript-type">int</span> coal_sort_order);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_sort_by_largest_process_locked</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bucket_index);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>  <span class="enscript-function-name">memorystatus_move_list_locked</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bucket_index, pid_t *pid_list, <span class="enscript-type">int</span> list_sz);

<span class="enscript-comment">/* qsort routines */</span>
<span class="enscript-type">typedef</span> <span class="enscript-function-name">int</span> (*cmpfunc_t)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *a, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *b);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">qsort</span>(<span class="enscript-type">void</span> *a, size_t n, size_t es, cmpfunc_t cmp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">memstat_asc_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *a, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *b);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>

<span class="enscript-comment">/* VM pressure */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    vm_page_free_count;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    vm_page_active_count;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    vm_page_inactive_count;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    vm_page_throttled_count;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    vm_page_purgeable_count;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>    vm_page_wire_count;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PRESSURE_EVENTS</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;vm_pressure.h&quot;</span>

<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">memorystatus_warn_process</span>(pid_t pid, boolean_t critical);

vm_pressure_level_t memorystatus_vm_pressure_level = kVMPressureNormal;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_available_pages = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)-1;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_available_pages_pressure = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_available_pages_critical = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_frozen_count = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_suspended_count = 0;

<span class="enscript-comment">/*
 * We use this flag to signal if we have any HWM offenders
 * on the system. This way we can reduce the number of wakeups
 * of the memorystatus_thread when the system is between the
 * &quot;pressure&quot; and &quot;critical&quot; threshold.
 *
 * The (re-)setting of this variable is done without any locks
 * or synchronization simply because it is not possible (currently)
 * to keep track of HWM offenders that drop down below their memory
 * limit and/or exit. So, we choose to burn a couple of wasted wakeups
 * by allowing the unguarded modification of this variable.
 */</span>
boolean_t memorystatus_hwm_candidates = 0;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">memorystatus_send_note</span>(<span class="enscript-type">int</span> event_code, <span class="enscript-type">void</span> *data, size_t data_length);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MEMORYSTATUS */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PRESSURE_EVENTS */</span>

<span class="enscript-comment">/* Freeze */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>

boolean_t memorystatus_freeze_enabled = FALSE;
<span class="enscript-type">int</span> memorystatus_freeze_wakeup = 0;

lck_grp_attr_t *freezer_lck_grp_attr;
lck_grp_t *freezer_lck_grp;
<span class="enscript-type">static</span> lck_mtx_t freezer_mutex;

<span class="enscript-type">static</span> inline boolean_t <span class="enscript-function-name">memorystatus_can_freeze_processes</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">memorystatus_can_freeze</span>(boolean_t *memorystatus_freeze_swap_low);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_freeze_thread</span>(<span class="enscript-type">void</span> *param __unused, wait_result_t wr __unused);

<span class="enscript-comment">/* Thresholds */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_freeze_threshold = 0;

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_freeze_pages_min = 0;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_freeze_pages_max = 0;

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_freeze_suspended_threshold = FREEZE_SUSPENDED_THRESHOLD_DEFAULT;

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_freeze_daily_mb_max = FREEZE_DAILY_MB_MAX_DEFAULT;

<span class="enscript-comment">/* Stats */</span>
<span class="enscript-type">static</span> uint64_t memorystatus_freeze_count = 0;
<span class="enscript-type">static</span> uint64_t memorystatus_freeze_pageouts = 0;

<span class="enscript-comment">/* Throttling */</span>
<span class="enscript-type">static</span> throttle_interval_t throttle_intervals[] = {
	{      60,  8, 0, 0, { 0, 0 }, FALSE }, <span class="enscript-comment">/* 1 hour intermediate interval, 8x burst */</span>
	{ 24 * 60,  1, 0, 0, { 0, 0 }, FALSE }, <span class="enscript-comment">/* 24 hour long interval, no burst */</span>
};

<span class="enscript-type">static</span> uint64_t memorystatus_freeze_throttle_count = 0;

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> memorystatus_suspended_footprint_total = 0;

<span class="enscript-type">extern</span> uint64_t <span class="enscript-function-name">vm_swap_get_free_space</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">memorystatus_freeze_update_throttle</span>();

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>

<span class="enscript-comment">/* Debug */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> knote *<span class="enscript-function-name">vm_find_knote_from_pid</span>(pid_t, <span class="enscript-type">struct</span> klist *);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_debug_dump_bucket_locked</span> (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bucket_index)
{
	proc_t p = NULL;
	uint32_t pages = 0;
	uint32_t pages_in_mb = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> b = bucket_index;
	boolean_t traverse_all_buckets = FALSE;

        <span class="enscript-keyword">if</span> (bucket_index &gt;= MEMSTAT_BUCKET_COUNT) {
		traverse_all_buckets = TRUE;
		b = 0;
        } <span class="enscript-keyword">else</span> {
		traverse_all_buckets = FALSE;
		b = bucket_index;
	}

	<span class="enscript-comment">/*
	 * Missing from this dump is the value actually
	 * stored in the ledger... also, format could be better.
	 */</span>
        printf(<span class="enscript-string">&quot;memorystatus_debug_dump ***START***\n&quot;</span>);
	printf(<span class="enscript-string">&quot;bucket [pid] [pages/pages-mb] state [EP / RP] dirty deadline [C-limit / A-limit / IA-limit] name\n&quot;</span>);
	p = memorystatus_get_first_proc_locked(&amp;b, traverse_all_buckets);
	<span class="enscript-keyword">while</span> (p) {
		memorystatus_get_task_page_counts(p-&gt;task, &amp;pages, NULL, NULL, NULL);
		pages_in_mb = (pages * 4096) /1024 / 1024;
                printf(<span class="enscript-string">&quot;%d     [%d]     [%d/%dMB] 0x%x [%d / %d] 0x%x %lld    [%d%s / %d%s / %d%s] %s\n&quot;</span>, 
		       b, p-&gt;p_pid, pages, pages_in_mb,
		       p-&gt;p_memstat_state, p-&gt;p_memstat_effectivepriority, p-&gt;p_memstat_requestedpriority, p-&gt;p_memstat_dirty, p-&gt;p_memstat_idledeadline,
		       p-&gt;p_memstat_memlimit,
		       (p-&gt;p_memstat_state &amp; P_MEMSTAT_FATAL_MEMLIMIT ? <span class="enscript-string">&quot;F &quot;</span> : <span class="enscript-string">&quot;NF&quot;</span>),
		       p-&gt;p_memstat_memlimit_active, 
		       (p-&gt;p_memstat_state &amp; P_MEMSTAT_MEMLIMIT_ACTIVE_FATAL ? <span class="enscript-string">&quot;F &quot;</span> : <span class="enscript-string">&quot;NF&quot;</span>),
		       p-&gt;p_memstat_memlimit_inactive, 
		       (p-&gt;p_memstat_state &amp; P_MEMSTAT_MEMLIMIT_INACTIVE_FATAL ? <span class="enscript-string">&quot;F &quot;</span> : <span class="enscript-string">&quot;NF&quot;</span>),
		       (p-&gt;p_comm ? p-&gt;p_comm : <span class="enscript-string">&quot;unknown&quot;</span>));
		p = memorystatus_get_next_proc_locked(&amp;b, p, traverse_all_buckets);
        }
        printf(<span class="enscript-string">&quot;memorystatus_debug_dump ***END***\n&quot;</span>);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_memorystatus_debug_dump_bucket SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg2</span>)
        <span class="enscript-type">int</span> bucket_index = 0;
        <span class="enscript-type">int</span> error;
	error = SYSCTL_OUT(req, arg1, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr) {
		<span class="enscript-keyword">return</span> (error);
	}
        error = SYSCTL_IN(req, &amp;bucket_index, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
        <span class="enscript-keyword">if</span> (error || !req-&gt;newptr) {
                <span class="enscript-keyword">return</span> (error);
        }
	<span class="enscript-keyword">if</span> (bucket_index &gt;= MEMSTAT_BUCKET_COUNT) {
		<span class="enscript-comment">/*
		 * All jetsam buckets will be dumped.
		 */</span>
        } <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Only a single bucket will be dumped.
		 */</span>
	}

	proc_list_lock();
	memorystatus_debug_dump_bucket_locked(bucket_index);
	proc_list_unlock();
	memorystatus_debug_dump_this_bucket = bucket_index;
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Debug aid to look at jetsam buckets and proc jetsam fields.
 *	Use this sysctl to act on a particular jetsam bucket.
 *	Writing the sysctl triggers the dump.
 *   	Usage: sysctl kern.memorystatus_debug_dump_this_bucket=&lt;bucket_index&gt;
 */</span>

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, memorystatus_debug_dump_this_bucket, CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_debug_dump_this_bucket, 0, sysctl_memorystatus_debug_dump_bucket, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);


<span class="enscript-comment">/* Debug aid to aid determination of limit */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_memorystatus_highwater_enable SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg2</span>)
	proc_t p;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> b = 0;
	<span class="enscript-type">int</span> error, enable = 0;

	error = SYSCTL_OUT(req, arg1, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr) {
		<span class="enscript-keyword">return</span> (error);
	}

	error = SYSCTL_IN(req, &amp;enable, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr) {
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> (!(enable == 0 || enable == 1)) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	proc_list_lock();

	p = memorystatus_get_first_proc_locked(&amp;b, TRUE);
	<span class="enscript-keyword">while</span> (p) {
		boolean_t trigger_exception;

		<span class="enscript-keyword">if</span> (enable) {
			<span class="enscript-comment">/*
			 * No need to consider P_MEMSTAT_MEMLIMIT_BACKGROUND anymore.
			 * Background limits are described via the inactive limit slots.
			 */</span>

			<span class="enscript-keyword">if</span> (proc_jetsam_state_is_active_locked(p) == TRUE) {
				CACHE_ACTIVE_LIMITS_LOCKED(p, trigger_exception);
			} <span class="enscript-keyword">else</span> {
				CACHE_INACTIVE_LIMITS_LOCKED(p, trigger_exception);
			}

		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Disabling limits does not touch the stored variants.
			 * Set the cached limit fields to system_wide defaults.
			 */</span>
			p-&gt;p_memstat_memlimit = -1;
			p-&gt;p_memstat_state |= P_MEMSTAT_FATAL_MEMLIMIT;
			trigger_exception = TRUE;
		}

		<span class="enscript-comment">/*
		 * Enforce the cached limit by writing to the ledger.
		 */</span>
		task_set_phys_footprint_limit_internal(p-&gt;task, (p-&gt;p_memstat_memlimit &gt; 0) ? p-&gt;p_memstat_memlimit: -1, NULL, trigger_exception);

		p = memorystatus_get_next_proc_locked(&amp;b, p, TRUE);
	}
	
	memorystatus_highwater_enabled = enable;

	proc_list_unlock();

	<span class="enscript-keyword">return</span> 0;

}

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, memorystatus_idle_snapshot, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_idle_snapshot, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, memorystatus_highwater_enabled, CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_highwater_enabled, 0, sysctl_memorystatus_highwater_enable, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, memorystatus_available_pages, CTLFLAG_RD|CTLFLAG_LOCKED, &amp;memorystatus_available_pages, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, memorystatus_available_pages_critical, CTLFLAG_RD|CTLFLAG_LOCKED, &amp;memorystatus_available_pages_critical, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, memorystatus_available_pages_critical_base, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_available_pages_critical_base, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, memorystatus_available_pages_critical_idle_offset, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_available_pages_critical_idle_offset, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* Diagnostic code */</span>

<span class="enscript-type">enum</span> {
	kJetsamDiagnosticModeNone =              0, 
	kJetsamDiagnosticModeAll  =              1,
	kJetsamDiagnosticModeStopAtFirstActive = 2,
	kJetsamDiagnosticModeCount
} jetsam_diagnostic_mode = kJetsamDiagnosticModeNone;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> jetsam_diagnostic_suspended_one_active_proc = 0;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_jetsam_diagnostic_mode SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)

	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *diagnosticStrings[] = {
		<span class="enscript-string">&quot;jetsam: diagnostic mode: resetting critical level.&quot;</span>,
		<span class="enscript-string">&quot;jetsam: diagnostic mode: will examine all processes&quot;</span>,
		<span class="enscript-string">&quot;jetsam: diagnostic mode: will stop at first active process&quot;</span>                
	};
        
	<span class="enscript-type">int</span> error, val = jetsam_diagnostic_mode;
	boolean_t changed = FALSE;

	error = sysctl_handle_int(oidp, &amp;val, 0, req);
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr)
 		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> ((val &lt; 0) || (val &gt;= kJetsamDiagnosticModeCount)) {
		printf(<span class="enscript-string">&quot;jetsam: diagnostic mode: invalid value - %d\n&quot;</span>, val);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	
	proc_list_lock();
	
	<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) val != jetsam_diagnostic_mode) {
		jetsam_diagnostic_mode = val;

		memorystatus_jetsam_policy &amp;= ~kPolicyDiagnoseActive;
                
		<span class="enscript-keyword">switch</span> (jetsam_diagnostic_mode) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kJetsamDiagnosticModeNone</span>:
			<span class="enscript-comment">/* Already cleared */</span>
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kJetsamDiagnosticModeAll</span>:
			memorystatus_jetsam_policy |= kPolicyDiagnoseAll;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kJetsamDiagnosticModeStopAtFirstActive</span>:
			memorystatus_jetsam_policy |= kPolicyDiagnoseFirst;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* Already validated */</span>
			<span class="enscript-keyword">break</span>;
		}
        	
		memorystatus_update_levels_locked(FALSE);
		changed = TRUE;
	}
        
	proc_list_unlock();
	
	<span class="enscript-keyword">if</span> (changed) {
		printf(<span class="enscript-string">&quot;%s\n&quot;</span>, diagnosticStrings[val]);
	}
	
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_debug, OID_AUTO, jetsam_diagnostic_mode, CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_LOCKED|CTLFLAG_ANYBODY,
  		&amp;jetsam_diagnostic_mode, 0, sysctl_jetsam_diagnostic_mode, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;Jetsam Diagnostic Mode&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, memorystatus_jetsam_policy_offset_pages_diagnostic, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_jetsam_policy_offset_pages_diagnostic, 0, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PRESSURE_EVENTS</span>

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, memorystatus_available_pages_pressure, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_available_pages_pressure, 0, <span class="enscript-string">&quot;&quot;</span>);


<span class="enscript-comment">/*
 * This routine is used for targeted notifications
 * regardless of system memory pressure.
 * &quot;memnote&quot; is the current user.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_memorystatus_vm_pressure_send SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)

	<span class="enscript-type">int</span> error = 0, pid = 0;
	<span class="enscript-type">int</span> ret = 0;
	<span class="enscript-type">struct</span> knote *kn = NULL;
	boolean_t found_knote = FALSE;

	error = sysctl_handle_int(oidp, &amp;pid, 0, req);
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * We inspect 3 lists here for targeted notifications:
	 * - memorystatus_klist
	 * - vm_pressure_klist
	 * - vm_pressure_dormant_klist
	 *
	 * The vm_pressure_* lists are tied to the old VM_PRESSURE
	 * notification mechanism. We intend to stop using that
	 * mechanism and, in turn, get rid of the 2 lists and
	 * vm_dispatch_pressure_note_to_pid() too.
	 */</span>

	memorystatus_klist_lock();

	SLIST_FOREACH(kn, &amp;memorystatus_klist, kn_selnext) {
		proc_t knote_proc = kn-&gt;kn_kq-&gt;kq_p;
		pid_t knote_pid = knote_proc-&gt;p_pid;

		<span class="enscript-keyword">if</span> (knote_pid == pid) {
			<span class="enscript-comment">/*
			 * Forcibly send this pid a &quot;warning&quot; memory pressure notification.
			 */</span>
			kn-&gt;kn_fflags = NOTE_MEMORYSTATUS_PRESSURE_WARN;
			found_knote = TRUE;
		}
	}

	<span class="enscript-keyword">if</span> (found_knote) {
		KNOTE(&amp;memorystatus_klist, 0);
		ret = 0;
	} <span class="enscript-keyword">else</span> {
		ret = vm_dispatch_pressure_note_to_pid(pid, FALSE);
	}

	memorystatus_klist_unlock();

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, memorystatus_vm_pressure_send, CTLTYPE_INT|CTLFLAG_WR|CTLFLAG_LOCKED|CTLFLAG_MASKED,
    0, 0, &amp;sysctl_memorystatus_vm_pressure_send, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PRESSURE_EVENTS */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, memorystatus_freeze_daily_mb_max, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_freeze_daily_mb_max, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, memorystatus_freeze_threshold, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_freeze_threshold, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, memorystatus_freeze_pages_min, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_freeze_pages_min, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, memorystatus_freeze_pages_max, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_freeze_pages_max, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_QUAD</span>(_kern, OID_AUTO, memorystatus_freeze_count, CTLFLAG_RD|CTLFLAG_LOCKED, &amp;memorystatus_freeze_count, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_QUAD</span>(_kern, OID_AUTO, memorystatus_freeze_pageouts, CTLFLAG_RD|CTLFLAG_LOCKED, &amp;memorystatus_freeze_pageouts, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_QUAD</span>(_kern, OID_AUTO, memorystatus_freeze_throttle_count, CTLFLAG_RD|CTLFLAG_LOCKED, &amp;memorystatus_freeze_throttle_count, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, memorystatus_freeze_min_processes, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_freeze_suspended_threshold, 0, <span class="enscript-string">&quot;&quot;</span>);

boolean_t memorystatus_freeze_throttle_enabled = TRUE;
<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, memorystatus_freeze_throttle_enabled, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_freeze_throttle_enabled, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* 
 * Manual trigger of freeze and thaw for dev / debug kernels only.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_memorystatus_freeze SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, pid = 0;
	proc_t p;

	<span class="enscript-keyword">if</span> (memorystatus_freeze_enabled == FALSE) {
		<span class="enscript-keyword">return</span> ENOTSUP;
	}

	error = sysctl_handle_int(oidp, &amp;pid, 0, req);
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (pid == 2) {
		vm_pageout_anonymous_pages();

		<span class="enscript-keyword">return</span> 0;
	}

	lck_mtx_lock(&amp;freezer_mutex);

	p = proc_find(pid);
	<span class="enscript-keyword">if</span> (p != NULL) {
		uint32_t purgeable, wired, clean, dirty;
		boolean_t shared;
		uint32_t max_pages = 0;

		<span class="enscript-keyword">if</span> (DEFAULT_FREEZER_IS_ACTIVE || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_SWAPBACKED) {

			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> avail_swap_space = 0; <span class="enscript-comment">/* in pages. */</span>

			<span class="enscript-keyword">if</span> (DEFAULT_FREEZER_IS_ACTIVE) {
				<span class="enscript-comment">/*
				 * Freezer backed by default pager and swap file(s).
				 */</span>
				avail_swap_space = default_pager_swap_pages_free();
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * Freezer backed by the compressor and swap file(s)
				 * while will hold compressed data.
				 */</span>
				avail_swap_space = vm_swap_get_free_space() / PAGE_SIZE_64;
			}

			max_pages = MIN(avail_swap_space, memorystatus_freeze_pages_max);

		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * We only have the compressor without any swap.
			 */</span>
			max_pages = UINT32_MAX - 1;
		}

		error = task_freeze(p-&gt;task, &amp;purgeable, &amp;wired, &amp;clean, &amp;dirty, max_pages, &amp;shared, FALSE);
		proc_rele(p);

		<span class="enscript-keyword">if</span> (error)
			error = EIO;

		lck_mtx_unlock(&amp;freezer_mutex);
		<span class="enscript-keyword">return</span> error;
	}

	lck_mtx_unlock(&amp;freezer_mutex);
	<span class="enscript-keyword">return</span> EINVAL;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, memorystatus_freeze, CTLTYPE_INT|CTLFLAG_WR|CTLFLAG_LOCKED|CTLFLAG_MASKED,
    0, 0, &amp;sysctl_memorystatus_freeze, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_memorystatus_available_pages_thaw SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)

	<span class="enscript-type">int</span> error, pid = 0;
	proc_t p;

	<span class="enscript-keyword">if</span> (memorystatus_freeze_enabled == FALSE) {
		<span class="enscript-keyword">return</span> ENOTSUP;
	}

	error = sysctl_handle_int(oidp, &amp;pid, 0, req);
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr)
		<span class="enscript-keyword">return</span> (error);

	p = proc_find(pid);
	<span class="enscript-keyword">if</span> (p != NULL) {
		error = task_thaw(p-&gt;task);
		proc_rele(p);
		
		<span class="enscript-keyword">if</span> (error)
			error = EIO;
		<span class="enscript-keyword">return</span> error;
	}

	<span class="enscript-keyword">return</span> EINVAL;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, memorystatus_thaw, CTLTYPE_INT|CTLFLAG_WR|CTLFLAG_LOCKED|CTLFLAG_MASKED,
    0, 0, &amp;sysctl_memorystatus_available_pages_thaw, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">kernel_thread_start_priority</span>(thread_continue_t continuation,
                                                  <span class="enscript-type">void</span> *parameter,
                                                  integer_t priority,
                                                  thread_t *new_thread);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
<span class="enscript-comment">/*
 * Picks the sorting routine for a given jetsam priority band.
 *
 * Input:
 *	bucket_index - jetsam priority band to be sorted.
 *	sort_order - JETSAM_SORT_xxx from kern_memorystatus.h
 *		Currently sort_order is only meaningful when handling
 *		coalitions.
 *
 * Return: 
 *	0     on success
 * 	non-0 on failure
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">memorystatus_sort_bucket</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bucket_index, <span class="enscript-type">int</span> sort_order)
{
	<span class="enscript-type">int</span> coal_sort_order;

	<span class="enscript-comment">/*
	 * Verify the jetsam priority
	 */</span>
        <span class="enscript-keyword">if</span> (bucket_index &gt;= MEMSTAT_BUCKET_COUNT) {
		<span class="enscript-keyword">return</span>(EINVAL);
        }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
        <span class="enscript-keyword">if</span> (sort_order == JETSAM_SORT_DEFAULT) {
		coal_sort_order = COALITION_SORT_DEFAULT;
	} <span class="enscript-keyword">else</span> {
		coal_sort_order = sort_order;		<span class="enscript-comment">/* only used for testing scenarios */</span>
	}
#<span class="enscript-reference">else</span>
	<span class="enscript-comment">/* Verify default */</span>
        <span class="enscript-keyword">if</span> (sort_order == JETSAM_SORT_DEFAULT) {
		coal_sort_order = COALITION_SORT_DEFAULT;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span>(EINVAL);
	}
#<span class="enscript-reference">endif</span>

	proc_list_lock();
	<span class="enscript-keyword">switch</span> (bucket_index) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">JETSAM_PRIORITY_FOREGROUND</span>:
		<span class="enscript-keyword">if</span> (memorystatus_sort_by_largest_coalition_locked(bucket_index, coal_sort_order) == 0) {
			<span class="enscript-comment">/*
			 * Fall back to per process sorting when zero coalitions are found.
			 */</span>
			memorystatus_sort_by_largest_process_locked(bucket_index);
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		memorystatus_sort_by_largest_process_locked(bucket_index);
		<span class="enscript-keyword">break</span>;
	}
	proc_list_unlock();
	
        <span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Sort processes by size for a single jetsam bucket.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_sort_by_largest_process_locked</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bucket_index)
{
	proc_t p = NULL, insert_after_proc = NULL, max_proc = NULL;
	proc_t next_p = NULL, prev_max_proc = NULL;
	uint32_t pages = 0, max_pages = 0;
	memstat_bucket_t *current_bucket;
		
	<span class="enscript-keyword">if</span> (bucket_index &gt;= MEMSTAT_BUCKET_COUNT) {
		<span class="enscript-keyword">return</span>;
	}
		
	current_bucket = &amp;memstat_bucket[bucket_index];

	p = TAILQ_FIRST(&amp;current_bucket-&gt;list);

	<span class="enscript-keyword">while</span> (p) {
		memorystatus_get_task_page_counts(p-&gt;task, &amp;pages, NULL, NULL, NULL);
		max_pages = pages;
		max_proc = p;
		prev_max_proc = p;
		
		<span class="enscript-keyword">while</span> ((next_p = TAILQ_NEXT(p, p_memstat_list)) != NULL) {
			<span class="enscript-comment">/* traversing list until we find next largest process */</span>
			p=next_p;
			memorystatus_get_task_page_counts(p-&gt;task, &amp;pages, NULL, NULL, NULL);
			<span class="enscript-keyword">if</span> (pages &gt; max_pages) {
				max_pages = pages;
				max_proc = p;
			}
		}

		<span class="enscript-keyword">if</span> (prev_max_proc != max_proc) {
			<span class="enscript-comment">/* found a larger process, place it in the list */</span>
			TAILQ_REMOVE(&amp;current_bucket-&gt;list, max_proc, p_memstat_list);
			<span class="enscript-keyword">if</span> (insert_after_proc == NULL) {
				TAILQ_INSERT_HEAD(&amp;current_bucket-&gt;list, max_proc, p_memstat_list);
			} <span class="enscript-keyword">else</span> {
				TAILQ_INSERT_AFTER(&amp;current_bucket-&gt;list, insert_after_proc, max_proc, p_memstat_list);
			}
			prev_max_proc = max_proc;
		}

		insert_after_proc = max_proc;

		p = TAILQ_NEXT(max_proc, p_memstat_list);
	}
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>

<span class="enscript-type">static</span> proc_t <span class="enscript-function-name">memorystatus_get_first_proc_locked</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *bucket_index, boolean_t search) {
	memstat_bucket_t *current_bucket;
	proc_t next_p;

	<span class="enscript-keyword">if</span> ((*bucket_index) &gt;= MEMSTAT_BUCKET_COUNT) {
		<span class="enscript-keyword">return</span> NULL;
	}

	current_bucket = &amp;memstat_bucket[*bucket_index];
	next_p = TAILQ_FIRST(&amp;current_bucket-&gt;list);
	<span class="enscript-keyword">if</span> (!next_p &amp;&amp; search) {
		<span class="enscript-keyword">while</span> (!next_p &amp;&amp; (++(*bucket_index) &lt; MEMSTAT_BUCKET_COUNT)) {
			current_bucket = &amp;memstat_bucket[*bucket_index];
			next_p = TAILQ_FIRST(&amp;current_bucket-&gt;list);
		}
	}
	
	<span class="enscript-keyword">return</span> next_p;
}

<span class="enscript-type">static</span> proc_t <span class="enscript-function-name">memorystatus_get_next_proc_locked</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *bucket_index, proc_t p, boolean_t search) {
	memstat_bucket_t *current_bucket;
	proc_t next_p;
        
	<span class="enscript-keyword">if</span> (!p || ((*bucket_index) &gt;= MEMSTAT_BUCKET_COUNT)) {
		<span class="enscript-keyword">return</span> NULL;
	}

	next_p = TAILQ_NEXT(p, p_memstat_list);
	<span class="enscript-keyword">while</span> (!next_p &amp;&amp; search &amp;&amp; (++(*bucket_index) &lt; MEMSTAT_BUCKET_COUNT)) {
		current_bucket = &amp;memstat_bucket[*bucket_index];
		next_p = TAILQ_FIRST(&amp;current_bucket-&gt;list);
	}

	<span class="enscript-keyword">return</span> next_p;
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_init</span>(<span class="enscript-type">void</span>)
{
	thread_t thread = THREAD_NULL;
	kern_return_t result;
	<span class="enscript-type">int</span> i;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	memorystatus_freeze_pages_min = FREEZE_PAGES_MIN;
	memorystatus_freeze_pages_max = FREEZE_PAGES_MAX;
#<span class="enscript-reference">endif</span>

	nanoseconds_to_absolutetime((uint64_t)DEFERRED_IDLE_EXIT_TIME_SECS * NSEC_PER_SEC, &amp;memorystatus_idle_delay_time);
	
	<span class="enscript-comment">/* Init buckets */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; MEMSTAT_BUCKET_COUNT; i++) {
		TAILQ_INIT(&amp;memstat_bucket[i].list);
		memstat_bucket[i].count = 0;
	}
	
	memorystatus_idle_demotion_call = thread_call_allocate((thread_call_func_t)memorystatus_perform_idle_demotion, NULL);

	<span class="enscript-comment">/* Apply overrides */</span>
	PE_get_default(<span class="enscript-string">&quot;kern.jetsam_delta&quot;</span>, &amp;delta_percentage, <span class="enscript-keyword">sizeof</span>(delta_percentage));
	assert(delta_percentage &lt; 100);
	PE_get_default(<span class="enscript-string">&quot;kern.jetsam_critical_threshold&quot;</span>, &amp;critical_threshold_percentage, <span class="enscript-keyword">sizeof</span>(critical_threshold_percentage));
	assert(critical_threshold_percentage &lt; 100);
	PE_get_default(<span class="enscript-string">&quot;kern.jetsam_idle_offset&quot;</span>, &amp;idle_offset_percentage, <span class="enscript-keyword">sizeof</span>(idle_offset_percentage));
	assert(idle_offset_percentage &lt; 100);
	PE_get_default(<span class="enscript-string">&quot;kern.jetsam_pressure_threshold&quot;</span>, &amp;pressure_threshold_percentage, <span class="enscript-keyword">sizeof</span>(pressure_threshold_percentage));
	assert(pressure_threshold_percentage &lt; 100);
	PE_get_default(<span class="enscript-string">&quot;kern.jetsam_freeze_threshold&quot;</span>, &amp;freeze_threshold_percentage, <span class="enscript-keyword">sizeof</span>(freeze_threshold_percentage));
	assert(freeze_threshold_percentage &lt; 100);
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
	<span class="enscript-comment">/* device tree can request to take snapshots for idle-exit kills by default */</span>
	PE_get_default(<span class="enscript-string">&quot;kern.jetsam_idle_snapshot&quot;</span>, &amp;memorystatus_idle_snapshot, <span class="enscript-keyword">sizeof</span>(memorystatus_idle_snapshot));

	memorystatus_delta = delta_percentage * atop_64(max_mem) / 100;
	memorystatus_available_pages_critical_idle_offset = idle_offset_percentage * atop_64(max_mem) / 100;
	memorystatus_available_pages_critical_base = (critical_threshold_percentage / delta_percentage) * memorystatus_delta;
	
	memorystatus_jetsam_snapshot_max = maxproc;
	memorystatus_jetsam_snapshot = 
		(memorystatus_jetsam_snapshot_t*)kalloc(<span class="enscript-keyword">sizeof</span>(memorystatus_jetsam_snapshot_t) +
		<span class="enscript-keyword">sizeof</span>(memorystatus_jetsam_snapshot_entry_t) * memorystatus_jetsam_snapshot_max);
	<span class="enscript-keyword">if</span> (!memorystatus_jetsam_snapshot) {
		panic(<span class="enscript-string">&quot;Could not allocate memorystatus_jetsam_snapshot&quot;</span>);
	}

	nanoseconds_to_absolutetime((uint64_t)JETSAM_SNAPSHOT_TIMEOUT_SECS * NSEC_PER_SEC, &amp;memorystatus_jetsam_snapshot_timeout);

	memset(&amp;memorystatus_at_boot_snapshot, 0, <span class="enscript-keyword">sizeof</span>(memorystatus_jetsam_snapshot_t));

	<span class="enscript-comment">/* No contention at this point */</span>
	memorystatus_update_levels_locked(FALSE);

	<span class="enscript-comment">/* Jetsam Loop Detection */</span>
	<span class="enscript-keyword">if</span> (max_mem &lt;= (512 * 1024 * 1024)) {
		<span class="enscript-comment">/* 512 MB devices */</span>
		memorystatus_jld_eval_period_msecs = 8000;	<span class="enscript-comment">/* 8000 msecs == 8 second window */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* 1GB and larger devices */</span>
		memorystatus_jld_eval_period_msecs = 6000;	<span class="enscript-comment">/* 6000 msecs == 6 second window */</span>
	}
#<span class="enscript-reference">endif</span>
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	memorystatus_freeze_threshold = (freeze_threshold_percentage / delta_percentage) * memorystatus_delta;
#<span class="enscript-reference">endif</span>
	
	result = kernel_thread_start_priority(memorystatus_thread, NULL, 95 <span class="enscript-comment">/* MAXPRI_KERNEL */</span>, &amp;thread);
	<span class="enscript-keyword">if</span> (result == KERN_SUCCESS) {
		thread_deallocate(thread);
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;Could not create memorystatus_thread&quot;</span>);
	}
}

<span class="enscript-comment">/* Centralised for the purposes of allowing panic-on-jetsam */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vm_wake_compactor_swapper</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">/*
 * The jetsam no frills kill call
 * 	Return: 0 on success
 *		error code on failure (EINVAL...)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">jetsam_do_kill</span>(proc_t p, <span class="enscript-type">int</span> jetsam_flags) {
	<span class="enscript-type">int</span> error = 0;
	error = exit1_internal(p, W_EXITCODE(0, SIGKILL), (<span class="enscript-type">int</span> *)NULL, FALSE, FALSE, jetsam_flags);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Wrapper for processes exiting with memorystatus details
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">memorystatus_do_kill</span>(proc_t p, uint32_t cause) {

	<span class="enscript-type">int</span> error = 0;
	__unused pid_t victim_pid = p-&gt;p_pid;

	KERNEL_DEBUG_CONSTANT( (BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_DO_KILL)) | DBG_FUNC_START,
			       victim_pid, cause, vm_page_free_count, 0, 0);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span> &amp;&amp; (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
	<span class="enscript-keyword">if</span> (memorystatus_jetsam_panic_debug &amp; (1 &lt;&lt; cause)) {
		panic(<span class="enscript-string">&quot;memorystatus_do_kill(): jetsam debug panic (cause: %d)&quot;</span>, cause);
	}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cause</span>)
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span> jetsam_flags = P_LTERM_JETSAM;
	<span class="enscript-keyword">switch</span> (cause) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kMemorystatusKilledHiwat</span>:			jetsam_flags |= P_JETSAM_HIWAT; <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kMemorystatusKilledVnodes</span>:			jetsam_flags |= P_JETSAM_VNODE; <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kMemorystatusKilledVMPageShortage</span>:		jetsam_flags |= P_JETSAM_VMPAGESHORTAGE; <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kMemorystatusKilledVMThrashing</span>:		jetsam_flags |= P_JETSAM_VMTHRASHING; <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kMemorystatusKilledFCThrashing</span>:		jetsam_flags |= P_JETSAM_FCTHRASHING; <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kMemorystatusKilledPerProcessLimit</span>:	jetsam_flags |= P_JETSAM_PID; <span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kMemorystatusKilledIdleExit</span>:		jetsam_flags |= P_JETSAM_IDLEEXIT; <span class="enscript-keyword">break</span>;
	}
	error = jetsam_do_kill(p, jetsam_flags);

	KERNEL_DEBUG_CONSTANT( (BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_DO_KILL)) | DBG_FUNC_END, 
			       victim_pid, cause, vm_page_free_count, error, 0);

	vm_wake_compactor_swapper();

	<span class="enscript-keyword">return</span> (error == 0);
}

<span class="enscript-comment">/*
 * Node manipulation
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_check_levels_locked</span>(<span class="enscript-type">void</span>) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
	<span class="enscript-comment">/* Update levels */</span>
	memorystatus_update_levels_locked(TRUE);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_perform_idle_demotion</span>(__unused <span class="enscript-type">void</span> *spare1, __unused <span class="enscript-type">void</span> *spare2) 
{
	proc_t p;
	uint64_t current_time;
	memstat_bucket_t *demotion_bucket;
   
	MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_perform_idle_demotion()\n&quot;</span>);
   
	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_IDLE_DEMOTE) | DBG_FUNC_START, 0, 0, 0, 0, 0);
 
 	current_time = mach_absolute_time();
 
	proc_list_lock();

	demotion_bucket = &amp;memstat_bucket[JETSAM_PRIORITY_IDLE_DEFERRED];
	p = TAILQ_FIRST(&amp;demotion_bucket-&gt;list);
	    
	<span class="enscript-keyword">while</span> (p) {
		MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_perform_idle_demotion() found %d\n&quot;</span>, p-&gt;p_pid);
	        
		assert(p-&gt;p_memstat_idledeadline);
		assert(p-&gt;p_memstat_dirty &amp; P_DIRTY_DEFER_IN_PROGRESS);
		assert((p-&gt;p_memstat_dirty &amp; (P_DIRTY_IDLE_EXIT_ENABLED|P_DIRTY_IS_DIRTY)) == P_DIRTY_IDLE_EXIT_ENABLED);
        
		<span class="enscript-keyword">if</span> (current_time &gt;= p-&gt;p_memstat_idledeadline) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span> || <span class="enscript-variable-name">DEVELOPMENT</span>
			<span class="enscript-keyword">if</span> (!(p-&gt;p_memstat_dirty &amp; P_DIRTY_MARKED)) {
				printf(<span class="enscript-string">&quot;memorystatus_perform_idle_demotion: moving process %d [%s] to idle band, but never dirtied (0x%x)!\n&quot;</span>,
					p-&gt;p_pid, (p-&gt;p_comm ? p-&gt;p_comm : <span class="enscript-string">&quot;(unknown)&quot;</span>), p-&gt;p_memstat_dirty);
			}
#<span class="enscript-reference">endif</span>
			memorystatus_invalidate_idle_demotion_locked(p, TRUE);
			memorystatus_update_priority_locked(p, JETSAM_PRIORITY_IDLE, false);
			
			<span class="enscript-comment">// The prior process has moved out of the demotion bucket, so grab the new head and continue
</span>			p = TAILQ_FIRST(&amp;demotion_bucket-&gt;list);
			<span class="enscript-keyword">continue</span>;
		}
		
		<span class="enscript-comment">// No further candidates
</span>		<span class="enscript-keyword">break</span>;
	}
	
	memorystatus_reschedule_idle_demotion_locked();
	
	proc_list_unlock();

	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_IDLE_DEMOTE) | DBG_FUNC_END, 0, 0, 0, 0, 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_schedule_idle_demotion_locked</span>(proc_t p, boolean_t set_state) 
{	
	boolean_t present_in_deferred_bucket = FALSE;
	
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_effectivepriority == JETSAM_PRIORITY_IDLE_DEFERRED) {
		present_in_deferred_bucket = TRUE;
	}

	MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_schedule_idle_demotion_locked: scheduling demotion to idle band for pid %d (dirty:0x%x, set_state %d, demotions %d).\n&quot;</span>, 
	    p-&gt;p_pid, p-&gt;p_memstat_dirty, set_state, memorystatus_scheduled_idle_demotions);

	assert((p-&gt;p_memstat_dirty &amp; P_DIRTY_IDLE_EXIT_ENABLED) == P_DIRTY_IDLE_EXIT_ENABLED);

	<span class="enscript-keyword">if</span> (set_state) {
		assert(p-&gt;p_memstat_idledeadline == 0);
		p-&gt;p_memstat_dirty |= P_DIRTY_DEFER_IN_PROGRESS;
		p-&gt;p_memstat_idledeadline = mach_absolute_time() + memorystatus_idle_delay_time;
	}
	
	assert(p-&gt;p_memstat_idledeadline);
	
 	<span class="enscript-keyword">if</span> (present_in_deferred_bucket == FALSE) {
		memorystatus_scheduled_idle_demotions++;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_invalidate_idle_demotion_locked</span>(proc_t p, boolean_t clear_state) 
{
	boolean_t present_in_deferred_bucket = FALSE;
	
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_effectivepriority == JETSAM_PRIORITY_IDLE_DEFERRED) {
		present_in_deferred_bucket = TRUE;
		assert(p-&gt;p_memstat_idledeadline);
	}

	MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_invalidate_idle_demotion(): invalidating demotion to idle band for pid %d (clear_state %d, demotions %d).\n&quot;</span>, 
	    p-&gt;p_pid, clear_state, memorystatus_scheduled_idle_demotions);
    
 
	<span class="enscript-keyword">if</span> (clear_state) {
 		p-&gt;p_memstat_idledeadline = 0;
 		p-&gt;p_memstat_dirty &amp;= ~P_DIRTY_DEFER_IN_PROGRESS;
	}
 	
 	<span class="enscript-keyword">if</span> (present_in_deferred_bucket == TRUE) {
		memorystatus_scheduled_idle_demotions--;
	}

 	assert(memorystatus_scheduled_idle_demotions &gt;= 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_reschedule_idle_demotion_locked</span>(<span class="enscript-type">void</span>) {
 	<span class="enscript-keyword">if</span> (0 == memorystatus_scheduled_idle_demotions) {
 	 	<span class="enscript-keyword">if</span> (memstat_idle_demotion_deadline) {
 	 	 	<span class="enscript-comment">/* Transitioned 1-&gt;0, so cancel next call */</span>
 	 	 	thread_call_cancel(memorystatus_idle_demotion_call);
 	 	 	memstat_idle_demotion_deadline = 0;
 		}
 	} <span class="enscript-keyword">else</span> {
 		memstat_bucket_t *demotion_bucket;
 		proc_t p;
 		demotion_bucket = &amp;memstat_bucket[JETSAM_PRIORITY_IDLE_DEFERRED];
 		p = TAILQ_FIRST(&amp;demotion_bucket-&gt;list);
 		
		assert(p &amp;&amp; p-&gt;p_memstat_idledeadline);
 		
		<span class="enscript-keyword">if</span> (memstat_idle_demotion_deadline != p-&gt;p_memstat_idledeadline){
			thread_call_enter_delayed(memorystatus_idle_demotion_call, p-&gt;p_memstat_idledeadline);
			memstat_idle_demotion_deadline = p-&gt;p_memstat_idledeadline;
		}
 	}
}

<span class="enscript-comment">/* 
 * List manipulation
 */</span>
 
<span class="enscript-type">int</span> 
<span class="enscript-function-name">memorystatus_add</span>(proc_t p, boolean_t locked)
{
	memstat_bucket_t *bucket;
	
	MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_list_add(): adding pid %d with priority %d.\n&quot;</span>, p-&gt;p_pid, p-&gt;p_memstat_effectivepriority);
   
	<span class="enscript-keyword">if</span> (!locked) {
   	   	proc_list_lock();
   	}
	
	<span class="enscript-comment">/* Processes marked internal do not have priority tracked */</span>
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; P_MEMSTAT_INTERNAL) {
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	
	bucket = &amp;memstat_bucket[p-&gt;p_memstat_effectivepriority];
	
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_effectivepriority == JETSAM_PRIORITY_IDLE_DEFERRED) {
		assert(bucket-&gt;count == memorystatus_scheduled_idle_demotions);
	}

	TAILQ_INSERT_TAIL(&amp;bucket-&gt;list, p, p_memstat_list);
	bucket-&gt;count++;

	memorystatus_list_count++;

	memorystatus_check_levels_locked();
	
<span class="enscript-reference">exit</span>:
   	<span class="enscript-keyword">if</span> (!locked) {
   	   	proc_list_unlock();
   	}
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Description:
 *	Moves a process from one jetsam bucket to another.
 *	which changes the LRU position of the process.
 *
 *	Monitors transition between buckets and if necessary
 *	will update cached memory limits accordingly.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_update_priority_locked</span>(proc_t p, <span class="enscript-type">int</span> priority, boolean_t head_insert)
{
	memstat_bucket_t *old_bucket, *new_bucket;
	
	assert(priority &lt; MEMSTAT_BUCKET_COUNT);
	
	<span class="enscript-comment">/* Ensure that exit isn't underway, leaving the proc retained but removed from its bucket */</span>
	<span class="enscript-keyword">if</span> ((p-&gt;p_listflag &amp; P_LIST_EXITED) != 0) {
		<span class="enscript-keyword">return</span>;
	}
	
	MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_update_priority_locked(): setting pid %d to priority %d, inserting at %s\n&quot;</span>,
	                   p-&gt;p_pid, priority, head_insert ? <span class="enscript-string">&quot;head&quot;</span> : <span class="enscript-string">&quot;tail&quot;</span>);

	old_bucket = &amp;memstat_bucket[p-&gt;p_memstat_effectivepriority];
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_effectivepriority == JETSAM_PRIORITY_IDLE_DEFERRED) {
		assert(old_bucket-&gt;count == (memorystatus_scheduled_idle_demotions + 1));
	}

	TAILQ_REMOVE(&amp;old_bucket-&gt;list, p, p_memstat_list);
	old_bucket-&gt;count--;
	
	new_bucket = &amp;memstat_bucket[priority];	
	<span class="enscript-keyword">if</span> (head_insert)
		TAILQ_INSERT_HEAD(&amp;new_bucket-&gt;list, p, p_memstat_list);
	<span class="enscript-keyword">else</span>
		TAILQ_INSERT_TAIL(&amp;new_bucket-&gt;list, p, p_memstat_list);
	new_bucket-&gt;count++;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
	<span class="enscript-keyword">if</span> (memorystatus_highwater_enabled) {
		boolean_t trigger_exception;

		<span class="enscript-comment">/* 
		 * If cached limit data is updated, then the limits
		 * will be enforced by writing to the ledgers.
		 */</span>
		boolean_t ledger_update_needed = TRUE;

		<span class="enscript-comment">/*
		 * No need to consider P_MEMSTAT_MEMLIMIT_BACKGROUND anymore.
		 * Background limits are described via the inactive limit slots.
		 *
		 * Here, we must update the cached memory limit if the task 
		 * is transitioning between:
		 * 	active &lt;--&gt; inactive
		 *	FG     &lt;--&gt;       BG
		 * but:
		 *	dirty  &lt;--&gt;    clean   is ignored
		 *
		 * We bypass processes that have opted into dirty tracking because
		 * a move between buckets does not imply a transition between the
		 * dirty &lt;--&gt; clean state.
		 * Setting limits on processes opted into dirty tracking is handled
		 * in memorystatus_dirty_set() where the transition is very clear.
		 */</span>

		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_dirty &amp; P_DIRTY_TRACK) {

			ledger_update_needed = FALSE;

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((priority &gt;= JETSAM_PRIORITY_FOREGROUND) &amp;&amp; (p-&gt;p_memstat_effectivepriority &lt; JETSAM_PRIORITY_FOREGROUND)) {
			<span class="enscript-comment">/*
			 * 	inactive --&gt; active
			 *	BG       --&gt;     FG
			 *      assign active state
			 */</span>
			CACHE_ACTIVE_LIMITS_LOCKED(p, trigger_exception);

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((priority &lt; JETSAM_PRIORITY_FOREGROUND) &amp;&amp; (p-&gt;p_memstat_effectivepriority &gt;= JETSAM_PRIORITY_FOREGROUND)) {
			<span class="enscript-comment">/*
			 * 	active --&gt; inactive
			 *	FG     --&gt;       BG
			 *      assign inactive state
			 */</span>
			CACHE_INACTIVE_LIMITS_LOCKED(p, trigger_exception);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * The transition between jetsam priority buckets apparently did
			 * not affect active/inactive state.
			 * This is not unusual... especially during startup when
			 * processes are getting established in their respective bands.
			 */</span>
			ledger_update_needed = FALSE;
		}

		<span class="enscript-comment">/*
		 * Enforce the new limits by writing to the ledger
		 */</span>
		<span class="enscript-keyword">if</span> (ledger_update_needed) {
			task_set_phys_footprint_limit_internal(p-&gt;task, (p-&gt;p_memstat_memlimit &gt; 0) ? p-&gt;p_memstat_memlimit : -1, NULL, trigger_exception);

			MEMORYSTATUS_DEBUG(3, <span class="enscript-string">&quot;memorystatus_update_priority_locked: new limit on pid %d (%dMB %s) priority old --&gt; new (%d --&gt; %d) dirty?=0x%x %s\n&quot;</span>,
					   p-&gt;p_pid, (p-&gt;p_memstat_memlimit &gt; 0 ? p-&gt;p_memstat_memlimit : -1),
					   (p-&gt;p_memstat_state &amp; P_MEMSTAT_FATAL_MEMLIMIT ? <span class="enscript-string">&quot;F &quot;</span> : <span class="enscript-string">&quot;NF&quot;</span>), p-&gt;p_memstat_effectivepriority, priority, p-&gt;p_memstat_dirty,
					   (p-&gt;p_memstat_dirty ? ((p-&gt;p_memstat_dirty &amp; P_DIRTY) ? <span class="enscript-string">&quot;isdirty&quot;</span> : <span class="enscript-string">&quot;isclean&quot;</span>) : <span class="enscript-string">&quot;&quot;</span>));
		}
	}

#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* CONFIG_JETSAM */</span>
	
	p-&gt;p_memstat_effectivepriority = priority;
	
	memorystatus_check_levels_locked();
}

<span class="enscript-comment">/*
 *
 * Description: Update the jetsam priority and memory limit attributes for a given process.
 *
 * Parameters:
 *	p	init this process's jetsam information.
 *	priority          The jetsam priority band
 *	user_data	  user specific data, unused by the kernel
 *	effective	  guards against race if process's update already occurred
 *	update_memlimit   When true we know this is the init step via the posix_spawn path.
 *
 *	memlimit_active	  Value in megabytes; The monitored footprint level while the
 *			  process is active.  Exceeding it may result in termination
 *			  based on it's associated fatal flag.
 *
 *	memlimit_active_is_fatal  When a process is active and exceeds its memory footprint,
 *				  this describes whether or not it should be immediately fatal.
 *
 *	memlimit_inactive Value in megabytes; The monitored footprint level while the
 *			  process is inactive.  Exceeding it may result in termination
 *			  based on it's associated fatal flag.
 *
 *	memlimit_inactive_is_fatal  When a process is inactive and exceeds its memory footprint,
 *				    this describes whether or not it should be immediatly fatal.
 *
 *	memlimit_background	This process has a high-water-mark while in the background.
 *				No longer meaningful.  Background limits are described via
 *				the inactive slots.  Flag is ignored.
 *
 *
 * Returns:     0	Success
 *		non-0	Failure
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_update</span>(proc_t p, <span class="enscript-type">int</span> priority, uint64_t user_data, boolean_t effective, boolean_t update_memlimit,
		    int32_t memlimit_active,   boolean_t memlimit_active_is_fatal,
                    int32_t memlimit_inactive, boolean_t memlimit_inactive_is_fatal,
                    __unused boolean_t memlimit_background)
{
	<span class="enscript-type">int</span> ret;
	boolean_t head_insert = false;
	
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_JETSAM</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">update_memlimit</span>, <span class="enscript-variable-name">memlimit_active</span>, <span class="enscript-variable-name">memlimit_inactive</span>)
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">memlimit_active_is_fatal</span>, <span class="enscript-variable-name">memlimit_inactive_is_fatal</span>)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !CONFIG_JETSAM */</span>

	MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_update: changing pid %d: priority %d, user_data 0x%llx\n&quot;</span>, p-&gt;p_pid, priority, user_data);

	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_UPDATE) | DBG_FUNC_START, p-&gt;p_pid, priority, user_data, effective, 0);
	
	<span class="enscript-keyword">if</span> (priority == -1) {
		<span class="enscript-comment">/* Use as shorthand for default priority */</span>
		priority = JETSAM_PRIORITY_DEFAULT;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (priority == JETSAM_PRIORITY_IDLE_DEFERRED) {
		<span class="enscript-comment">/* JETSAM_PRIORITY_IDLE_DEFERRED is reserved for internal use; if requested, adjust to JETSAM_PRIORITY_IDLE. */</span>
		priority = JETSAM_PRIORITY_IDLE;	        
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (priority == JETSAM_PRIORITY_IDLE_HEAD) {
		<span class="enscript-comment">/* JETSAM_PRIORITY_IDLE_HEAD inserts at the head of the idle queue */</span>
		priority = JETSAM_PRIORITY_IDLE;
		head_insert = TRUE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((priority &lt; 0) || (priority &gt;= MEMSTAT_BUCKET_COUNT)) {
		<span class="enscript-comment">/* Sanity check */</span>
		ret = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	proc_list_lock();
	
	assert(!(p-&gt;p_memstat_state &amp; P_MEMSTAT_INTERNAL));

	<span class="enscript-keyword">if</span> (effective &amp;&amp; (p-&gt;p_memstat_state &amp; P_MEMSTAT_PRIORITYUPDATED)) {
		ret = EALREADY;
		proc_list_unlock();
		MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_update: effective change specified for pid %d, but change already occurred.\n&quot;</span>, p-&gt;p_pid);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;             
	}

	<span class="enscript-keyword">if</span> ((p-&gt;p_memstat_state &amp; P_MEMSTAT_TERMINATED) || ((p-&gt;p_listflag &amp; P_LIST_EXITED) != 0)) {
		<span class="enscript-comment">/*
		 * This could happen when a process calling posix_spawn() is exiting on the jetsam thread.
		 */</span>
		ret = EBUSY;
		proc_list_unlock();
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;             
	}

	p-&gt;p_memstat_state |= P_MEMSTAT_PRIORITYUPDATED;
	p-&gt;p_memstat_userdata = user_data;
	p-&gt;p_memstat_requestedpriority = priority;
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
	<span class="enscript-keyword">if</span> (update_memlimit) {
		boolean_t trigger_exception;

		<span class="enscript-comment">/*
		 * Posix_spawn'd processes come through this path to instantiate ledger limits.
		 * Forked processes do not come through this path, so no ledger limits exist.
		 * (That's why forked processes can consume unlimited memory.)
		 */</span>

		MEMORYSTATUS_DEBUG(3, <span class="enscript-string">&quot;memorystatus_update(enter): pid %d, priority %d, dirty=0x%x, Active(%dMB %s), Inactive(%dMB, %s)\n&quot;</span>,
				   p-&gt;p_pid, priority, p-&gt;p_memstat_dirty,
				   memlimit_active,   (memlimit_active_is_fatal ? <span class="enscript-string">&quot;F &quot;</span> : <span class="enscript-string">&quot;NF&quot;</span>),
				   memlimit_inactive, (memlimit_inactive_is_fatal ? <span class="enscript-string">&quot;F &quot;</span> : <span class="enscript-string">&quot;NF&quot;</span>));

		<span class="enscript-keyword">if</span> (memlimit_background) {

			<span class="enscript-comment">/*
			 * With 2-level HWM support, we no longer honor P_MEMSTAT_MEMLIMIT_BACKGROUND.
			 * Background limits are described via the inactive limit slots.
			 */</span>

			<span class="enscript-comment">// p-&gt;p_memstat_state |= P_MEMSTAT_MEMLIMIT_BACKGROUND;
</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
			printf(<span class="enscript-string">&quot;memorystatus_update: WARNING %s[%d] set unused flag P_MEMSTAT_MEMLIMIT_BACKGROUND [A==%dMB %s] [IA==%dMB %s]\n&quot;</span>,
			       (p-&gt;p_comm ? p-&gt;p_comm : <span class="enscript-string">&quot;unknown&quot;</span>), p-&gt;p_pid,
			       memlimit_active, (memlimit_active_is_fatal ? <span class="enscript-string">&quot;F &quot;</span> : <span class="enscript-string">&quot;NF&quot;</span>),
			       memlimit_inactive, (memlimit_inactive_is_fatal ? <span class="enscript-string">&quot;F &quot;</span> : <span class="enscript-string">&quot;NF&quot;</span>));
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
		}

		<span class="enscript-keyword">if</span> (memlimit_active &lt;= 0) {
			<span class="enscript-comment">/*
			 * This process will have a system_wide task limit when active.
			 * System_wide task limit is always fatal.
			 * It's quite common to see non-fatal flag passed in here.
			 * It's not an error, we just ignore it.
			 */</span>

			<span class="enscript-comment">/*
			 * For backward compatibility with some unexplained launchd behavior,
			 * we allow a zero sized limit.  But we still enforce system_wide limit
			 * when written to the ledgers.  
			 */</span>

			<span class="enscript-keyword">if</span> (memlimit_active &lt; 0) {
				memlimit_active = -1;  <span class="enscript-comment">/* enforces system_wide task limit */</span>
			}
			memlimit_active_is_fatal = TRUE;
		}

		<span class="enscript-keyword">if</span> (memlimit_inactive &lt;= 0) {
			<span class="enscript-comment">/*
			 * This process will have a system_wide task limit when inactive.
			 * System_wide task limit is always fatal.
			 */</span>

			memlimit_inactive = -1;
			memlimit_inactive_is_fatal = TRUE;
		}

		<span class="enscript-comment">/*
		 * Initialize the active limit variants for this process.
		 */</span>
		SET_ACTIVE_LIMITS_LOCKED(p, memlimit_active, memlimit_active_is_fatal);

		<span class="enscript-comment">/*
		 * Initialize the inactive limit variants for this process.
		 */</span>
		SET_INACTIVE_LIMITS_LOCKED(p, memlimit_inactive, memlimit_inactive_is_fatal);

		<span class="enscript-comment">/*
		 * Initialize the cached limits for target process.
		 * When the target process is dirty tracked, it's typically
		 * in a clean state.  Non dirty tracked processes are
		 * typically active (Foreground or above).
		 * But just in case, we don't make assumptions...
		 */</span>

		<span class="enscript-keyword">if</span> (proc_jetsam_state_is_active_locked(p) == TRUE) {
			CACHE_ACTIVE_LIMITS_LOCKED(p, trigger_exception);
		} <span class="enscript-keyword">else</span> {
			CACHE_INACTIVE_LIMITS_LOCKED(p, trigger_exception);
		}

		<span class="enscript-comment">/*
		 * Enforce the cached limit by writing to the ledger.
		 */</span>
		<span class="enscript-keyword">if</span> (memorystatus_highwater_enabled) {
			<span class="enscript-comment">/* apply now */</span>
			assert(trigger_exception == TRUE);
			task_set_phys_footprint_limit_internal(p-&gt;task, ((p-&gt;p_memstat_memlimit &gt; 0) ? p-&gt;p_memstat_memlimit : -1), NULL, trigger_exception);

			MEMORYSTATUS_DEBUG(3, <span class="enscript-string">&quot;memorystatus_update: init: limit on pid %d (%dMB %s) targeting priority(%d) dirty?=0x%x %s\n&quot;</span>,
					   p-&gt;p_pid, (p-&gt;p_memstat_memlimit &gt; 0 ? p-&gt;p_memstat_memlimit : -1),
					   (p-&gt;p_memstat_state &amp; P_MEMSTAT_FATAL_MEMLIMIT ? <span class="enscript-string">&quot;F &quot;</span> : <span class="enscript-string">&quot;NF&quot;</span>), priority, p-&gt;p_memstat_dirty,
					   (p-&gt;p_memstat_dirty ? ((p-&gt;p_memstat_dirty &amp; P_DIRTY) ? <span class="enscript-string">&quot;isdirty&quot;</span> : <span class="enscript-string">&quot;isclean&quot;</span>) : <span class="enscript-string">&quot;&quot;</span>));
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>

	<span class="enscript-comment">/*
	 * We can't add to the JETSAM_PRIORITY_IDLE_DEFERRED bucket here.
	 * But, we could be removing it from the bucket.
	 * Check and take appropriate steps if so.
	 */</span>
	
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_effectivepriority == JETSAM_PRIORITY_IDLE_DEFERRED) {
		
		memorystatus_invalidate_idle_demotion_locked(p, TRUE);
	}
	
	memorystatus_update_priority_locked(p, priority, head_insert);
	
	proc_list_unlock();
	ret = 0;

<span class="enscript-reference">out</span>:
	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_UPDATE) | DBG_FUNC_END, ret, 0, 0, 0, 0);

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_remove</span>(proc_t p, boolean_t locked)
{
	<span class="enscript-type">int</span> ret;
	memstat_bucket_t *bucket;

	MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_list_remove: removing pid %d\n&quot;</span>, p-&gt;p_pid);

   	<span class="enscript-keyword">if</span> (!locked) {
   	   	proc_list_lock();
   	}

	assert(!(p-&gt;p_memstat_state &amp; P_MEMSTAT_INTERNAL));
	
	bucket = &amp;memstat_bucket[p-&gt;p_memstat_effectivepriority];
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_effectivepriority == JETSAM_PRIORITY_IDLE_DEFERRED) {
		assert(bucket-&gt;count == memorystatus_scheduled_idle_demotions);
	}

	TAILQ_REMOVE(&amp;bucket-&gt;list, p, p_memstat_list);
	bucket-&gt;count--;

	memorystatus_list_count--;

	<span class="enscript-comment">/* If awaiting demotion to the idle band, clean up */</span>
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_effectivepriority == JETSAM_PRIORITY_IDLE_DEFERRED) {
		memorystatus_invalidate_idle_demotion_locked(p, TRUE);
 		memorystatus_reschedule_idle_demotion_locked();
	}

	memorystatus_check_levels_locked();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>    
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; (P_MEMSTAT_FROZEN)) {
		memorystatus_frozen_count--;
	}

	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; P_MEMSTAT_SUSPENDED) {
		memorystatus_suspended_footprint_total -= p-&gt;p_memstat_suspendedfootprint;
		memorystatus_suspended_count--;
	}
#<span class="enscript-reference">endif</span>

   	<span class="enscript-keyword">if</span> (!locked) {
   	   	proc_list_unlock();
   	}

	<span class="enscript-keyword">if</span> (p) {
		ret = 0; 
	} <span class="enscript-keyword">else</span> {
		ret = ESRCH;
	}

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/*
 * Validate dirty tracking flags with process state.
 *
 * Return:
 *	0     on success
 * 	non-0 on failure
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_validate_track_flags</span>(<span class="enscript-type">struct</span> proc *target_p, uint32_t pcontrol) {
	<span class="enscript-comment">/* See that the process isn't marked for termination */</span>
	<span class="enscript-keyword">if</span> (target_p-&gt;p_memstat_dirty &amp; P_DIRTY_TERMINATED) {
		<span class="enscript-keyword">return</span> EBUSY;
	}
	
	<span class="enscript-comment">/* Idle exit requires that process be tracked */</span>
	<span class="enscript-keyword">if</span> ((pcontrol &amp; PROC_DIRTY_ALLOW_IDLE_EXIT) &amp;&amp;
	   !(pcontrol &amp; PROC_DIRTY_TRACK)) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* 'Launch in progress' tracking requires that process have enabled dirty tracking too. */</span>
	<span class="enscript-keyword">if</span> ((pcontrol &amp; PROC_DIRTY_LAUNCH_IN_PROGRESS) &amp;&amp;
	   !(pcontrol &amp; PROC_DIRTY_TRACK)) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* Deferral is only relevant if idle exit is specified */</span>
	<span class="enscript-keyword">if</span> ((pcontrol &amp; PROC_DIRTY_DEFER) &amp;&amp; 
	   !(pcontrol &amp; PROC_DIRTY_ALLOWS_IDLE_EXIT)) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_update_idle_priority_locked</span>(proc_t p) {
	int32_t priority;

	MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_update_idle_priority_locked(): pid %d dirty 0x%X\n&quot;</span>, p-&gt;p_pid, p-&gt;p_memstat_dirty);
	
	<span class="enscript-keyword">if</span> ((p-&gt;p_memstat_dirty &amp; (P_DIRTY_IDLE_EXIT_ENABLED|P_DIRTY_IS_DIRTY)) == P_DIRTY_IDLE_EXIT_ENABLED) {
		priority = (p-&gt;p_memstat_dirty &amp; P_DIRTY_DEFER_IN_PROGRESS) ? JETSAM_PRIORITY_IDLE_DEFERRED : JETSAM_PRIORITY_IDLE;
	} <span class="enscript-keyword">else</span> {
		priority = p-&gt;p_memstat_requestedpriority;
	}
	
	<span class="enscript-keyword">if</span> (priority != p-&gt;p_memstat_effectivepriority) {
		memorystatus_update_priority_locked(p, priority, false);
	}
} 

<span class="enscript-comment">/*
 * Processes can opt to have their state tracked by the kernel, indicating  when they are busy (dirty) or idle
 * (clean). They may also indicate that they support termination when idle, with the result that they are promoted
 * to their desired, higher, jetsam priority when dirty (and are therefore killed later), and demoted to the low
 * priority idle band when clean (and killed earlier, protecting higher priority procesess).
 *
 * If the deferral flag is set, then newly tracked processes will be protected for an initial period (as determined by
 * memorystatus_idle_delay_time); if they go clean during this time, then they will be moved to a deferred-idle band
 * with a slightly higher priority, guarding against immediate termination under memory pressure and being unable to
 * make forward progress. Finally, when the guard expires, they will be moved to the standard, lowest-priority, idle
 * band. The deferral can be cleared early by clearing the appropriate flag.
 *
 * The deferral timer is active only for the duration that the process is marked as guarded and clean; if the process
 * is marked dirty, the timer will be cancelled. Upon being subsequently marked clean, the deferment will either be
 * re-enabled or the guard state cleared, depending on whether the guard deadline has passed.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_dirty_track</span>(proc_t p, uint32_t pcontrol) {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> old_dirty;
	boolean_t reschedule = FALSE;
	boolean_t already_deferred = FALSE;
	boolean_t defer_now = FALSE;
	<span class="enscript-type">int</span> ret = 0;
    
	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_DIRTY_TRACK),
		p-&gt;p_pid, p-&gt;p_memstat_dirty, pcontrol, 0, 0);
	
	proc_list_lock();
	
	<span class="enscript-keyword">if</span> ((p-&gt;p_listflag &amp; P_LIST_EXITED) != 0) {
		<span class="enscript-comment">/*
		 * Process is on its way out.
		 */</span>
		ret = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; P_MEMSTAT_INTERNAL) {
		ret = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	
	<span class="enscript-keyword">if</span> ((ret = memorystatus_validate_track_flags(p, pcontrol)) != 0) {
		<span class="enscript-comment">/* error  */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

        old_dirty = p-&gt;p_memstat_dirty;

	<span class="enscript-comment">/* These bits are cumulative, as per &lt;rdar://problem/11159924&gt; */</span>
	<span class="enscript-keyword">if</span> (pcontrol &amp; PROC_DIRTY_TRACK) {
		p-&gt;p_memstat_dirty |= P_DIRTY_TRACK;
	}

	<span class="enscript-keyword">if</span> (pcontrol &amp; PROC_DIRTY_ALLOW_IDLE_EXIT) {
		p-&gt;p_memstat_dirty |= P_DIRTY_ALLOW_IDLE_EXIT;					
	}

	<span class="enscript-keyword">if</span> (pcontrol &amp; PROC_DIRTY_LAUNCH_IN_PROGRESS) {
		p-&gt;p_memstat_dirty |= P_DIRTY_LAUNCH_IN_PROGRESS;
	}

	<span class="enscript-keyword">if</span> (old_dirty &amp; P_DIRTY_DEFER_IN_PROGRESS) {
		already_deferred = TRUE;
	}

	<span class="enscript-comment">/* This can be set and cleared exactly once. */</span>
	<span class="enscript-keyword">if</span> (pcontrol &amp; PROC_DIRTY_DEFER) {

	       	<span class="enscript-keyword">if</span> ( !(old_dirty &amp; P_DIRTY_DEFER)) {
			p-&gt;p_memstat_dirty |= P_DIRTY_DEFER;
		}

		defer_now = TRUE;
	}

	MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_on_track_dirty(): set idle-exit %s / defer %s / dirty %s for pid %d\n&quot;</span>,
		((p-&gt;p_memstat_dirty &amp; P_DIRTY_IDLE_EXIT_ENABLED) == P_DIRTY_IDLE_EXIT_ENABLED) ? <span class="enscript-string">&quot;Y&quot;</span> : <span class="enscript-string">&quot;N&quot;</span>,
		defer_now ? <span class="enscript-string">&quot;Y&quot;</span> : <span class="enscript-string">&quot;N&quot;</span>,
		p-&gt;p_memstat_dirty &amp; P_DIRTY ? <span class="enscript-string">&quot;Y&quot;</span> : <span class="enscript-string">&quot;N&quot;</span>,
		p-&gt;p_pid);

	<span class="enscript-comment">/* Kick off or invalidate the idle exit deferment if there's a state transition. */</span>
	<span class="enscript-keyword">if</span> (!(p-&gt;p_memstat_dirty &amp; P_DIRTY_IS_DIRTY)) {
		<span class="enscript-keyword">if</span> (((p-&gt;p_memstat_dirty &amp; P_DIRTY_IDLE_EXIT_ENABLED) == P_DIRTY_IDLE_EXIT_ENABLED) &amp;&amp; 
			defer_now &amp;&amp; !already_deferred) {
			
			<span class="enscript-comment">/*
			 * Request to defer a clean process that's idle-exit enabled 
			 * and not already in the jetsam deferred band.
			 */</span>
			memorystatus_schedule_idle_demotion_locked(p, TRUE);
			reschedule = TRUE;

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!defer_now &amp;&amp; already_deferred) {

			<span class="enscript-comment">/*
			 * Either the process is no longer idle-exit enabled OR
			 * there's a request to cancel a currently active deferral.
			 */</span>
			memorystatus_invalidate_idle_demotion_locked(p, TRUE);
			reschedule = TRUE;
		}
	} <span class="enscript-keyword">else</span> {

		<span class="enscript-comment">/*
		 * We are trying to operate on a dirty process. Dirty processes have to
		 * be removed from the deferred band. The question is do we reset the 
		 * deferred state or not?
		 *
		 * This could be a legal request like:
		 * - this process had opted into the JETSAM_DEFERRED band
		 * - but it's now dirty and requests to opt out.
		 * In this case, we remove the process from the band and reset its
		 * state too. It'll opt back in properly when needed.
		 *
		 * OR, this request could be a user-space bug. E.g.:
		 * - this process had opted into the JETSAM_DEFERRED band when clean
		 * - and, then issues another request to again put it into the band except
		 *   this time the process is dirty.
		 * The process going dirty, as a transition in memorystatus_dirty_set(), will pull the process out of
		 * the deferred band with its state intact. So our request below is no-op.
		 * But we do it here anyways for coverage.
		 *
		 * memorystatus_update_idle_priority_locked()
		 * single-mindedly treats a dirty process as &quot;cannot be in the deferred band&quot;.
		 */</span>

		<span class="enscript-keyword">if</span> (!defer_now &amp;&amp; already_deferred) {
			memorystatus_invalidate_idle_demotion_locked(p, TRUE);
			reschedule = TRUE;
		} <span class="enscript-keyword">else</span> {
			memorystatus_invalidate_idle_demotion_locked(p, FALSE);
			reschedule = TRUE;
		}
	}

	memorystatus_update_idle_priority_locked(p);
	
	<span class="enscript-keyword">if</span> (reschedule) {
		memorystatus_reschedule_idle_demotion_locked();
	}
		
	ret = 0;
	
<span class="enscript-reference">exit</span>:		
	proc_list_unlock();
	
	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_dirty_set</span>(proc_t p, boolean_t self, uint32_t pcontrol) {
	<span class="enscript-type">int</span> ret;
	boolean_t kill = false;
	boolean_t reschedule = FALSE;
	boolean_t was_dirty = FALSE;
	boolean_t now_dirty = FALSE;

	MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_dirty_set(): %d %d 0x%x 0x%x\n&quot;</span>, self, p-&gt;p_pid, pcontrol, p-&gt;p_memstat_dirty);
	
	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_DIRTY_SET), p-&gt;p_pid, self, pcontrol, 0, 0);

	proc_list_lock();

	<span class="enscript-keyword">if</span> ((p-&gt;p_listflag &amp; P_LIST_EXITED) != 0) {
		<span class="enscript-comment">/*
		 * Process is on its way out.
		 */</span>
		ret = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; P_MEMSTAT_INTERNAL) {
		ret = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_dirty &amp; P_DIRTY_IS_DIRTY)
		was_dirty = TRUE;

	<span class="enscript-keyword">if</span> (!(p-&gt;p_memstat_dirty &amp; P_DIRTY_TRACK)) {
		<span class="enscript-comment">/* Dirty tracking not enabled */</span>
		ret = EINVAL;			
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pcontrol &amp;&amp; (p-&gt;p_memstat_dirty &amp; P_DIRTY_TERMINATED)) {
		<span class="enscript-comment">/* 
		 * Process is set to be terminated and we're attempting to mark it dirty.
		 * Set for termination and marking as clean is OK - see &lt;rdar://problem/10594349&gt;.
		 */</span>
		ret = EBUSY;		
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span> flag = (self == TRUE) ? P_DIRTY : P_DIRTY_SHUTDOWN;
		<span class="enscript-keyword">if</span> (pcontrol &amp;&amp; !(p-&gt;p_memstat_dirty &amp; flag)) {
			<span class="enscript-comment">/* Mark the process as having been dirtied at some point */</span>
			p-&gt;p_memstat_dirty |= (flag | P_DIRTY_MARKED);
			memorystatus_dirty_count++;
			ret = 0;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((pcontrol == 0) &amp;&amp; (p-&gt;p_memstat_dirty &amp; flag)) {
			<span class="enscript-keyword">if</span> ((flag == P_DIRTY_SHUTDOWN) &amp;&amp; (!(p-&gt;p_memstat_dirty &amp; P_DIRTY))) {
				<span class="enscript-comment">/* Clearing the dirty shutdown flag, and the process is otherwise clean - kill */</span>
				p-&gt;p_memstat_dirty |= P_DIRTY_TERMINATED;
				kill = true;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((flag == P_DIRTY) &amp;&amp; (p-&gt;p_memstat_dirty &amp; P_DIRTY_TERMINATED)) {
				<span class="enscript-comment">/* Kill previously terminated processes if set clean */</span>
				kill = true;						
			}
			p-&gt;p_memstat_dirty &amp;= ~flag;
			memorystatus_dirty_count--;
			ret = 0;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Already set */</span>
			ret = EALREADY;
		}
	}

	<span class="enscript-keyword">if</span> (ret != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_dirty &amp; P_DIRTY_IS_DIRTY)
		now_dirty = TRUE;

	<span class="enscript-keyword">if</span> ((was_dirty == TRUE &amp;&amp; now_dirty == FALSE) ||
	    (was_dirty == FALSE &amp;&amp; now_dirty == TRUE)) {

		<span class="enscript-comment">/* Manage idle exit deferral, if applied */</span>
		<span class="enscript-keyword">if</span> ((p-&gt;p_memstat_dirty &amp; (P_DIRTY_IDLE_EXIT_ENABLED|P_DIRTY_DEFER_IN_PROGRESS)) ==
		    (P_DIRTY_IDLE_EXIT_ENABLED|P_DIRTY_DEFER_IN_PROGRESS)) {

			<span class="enscript-comment">/*
			 * P_DIRTY_DEFER_IN_PROGRESS means the process is in the deferred band OR it might be heading back
			 * there once it's clean again and has some protection window left.
			 */</span>

			<span class="enscript-keyword">if</span> (p-&gt;p_memstat_dirty &amp; P_DIRTY_IS_DIRTY) {
				<span class="enscript-comment">/*
				 * New dirty process i.e. &quot;was_dirty == FALSE &amp;&amp; now_dirty == TRUE&quot;
				 *
				 * The process will move from the deferred band to its higher requested
				 * jetsam band. But we don't clear its state i.e. we want to remember that
				 * this process was part of the &quot;deferred&quot; band and will return to it.
				 *
				 * This way, we don't let it age beyond the protection
				 * window when it returns to &quot;clean&quot;. All the while giving
				 * it a chance to perform its work while &quot;dirty&quot;.
				 *
				 */</span>
				memorystatus_invalidate_idle_demotion_locked(p, FALSE);
				reschedule = TRUE;
			} <span class="enscript-keyword">else</span> {

				<span class="enscript-comment">/*
				 * Process is back from &quot;dirty&quot; to &quot;clean&quot;.
				 * 
				 * Is its timer up OR does it still have some protection
				 * window left?
				 */</span>

				<span class="enscript-keyword">if</span> (mach_absolute_time() &gt;= p-&gt;p_memstat_idledeadline) {
					<span class="enscript-comment">/*
				 	 * The process' deadline has expired. It currently
					 * does not reside in the DEFERRED bucket.
					 * 
					 * It's on its way to the JETSAM_PRIORITY_IDLE 
					 * bucket via memorystatus_update_idle_priority_locked()
					 * below.
					 
					 * So all we need to do is reset all the state on the
					 * process that's related to the DEFERRED bucket i.e.
					 * the DIRTY_DEFER_IN_PROGRESS flag and the timer deadline.
					 *
				 	 */</span>

					memorystatus_invalidate_idle_demotion_locked(p, TRUE);
					reschedule = TRUE;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/*
					 * It still has some protection window left and so
					 * we just re-arm the timer without modifying any
					 * state on the process.
					 */</span>
					memorystatus_schedule_idle_demotion_locked(p, FALSE);
					reschedule = TRUE;
				}
			}
		}

		memorystatus_update_idle_priority_locked(p);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
		<span class="enscript-keyword">if</span> (memorystatus_highwater_enabled) {
			boolean_t trigger_exception;
			<span class="enscript-comment">/* 
			 * We are in this path because this process transitioned between 
			 * dirty &lt;--&gt; clean state.  Update the cached memory limits.
			 */</span>

			<span class="enscript-keyword">if</span> (proc_jetsam_state_is_active_locked(p) == TRUE) {
				<span class="enscript-comment">/*
				 * process is dirty
				 */</span>
				CACHE_ACTIVE_LIMITS_LOCKED(p, trigger_exception);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * process is clean
				 */</span>
				CACHE_INACTIVE_LIMITS_LOCKED(p, trigger_exception);
			}

			<span class="enscript-comment">/*
			 * Enforce the new limits by writing to the ledger.
			 *
			 * This is a hot path and holding the proc_list_lock while writing to the ledgers,
			 * (where the task lock is taken) is bad.  So, we temporarily drop the proc_list_lock.
			 * We aren't traversing the jetsam bucket list here, so we should be safe.
			 * See rdar://21394491.
			 */</span>

			<span class="enscript-keyword">if</span> (proc_ref_locked(p) == p) {
				<span class="enscript-type">int</span> ledger_limit;
				<span class="enscript-keyword">if</span> (p-&gt;p_memstat_memlimit &gt; 0) {
					ledger_limit = p-&gt;p_memstat_memlimit;
				} <span class="enscript-keyword">else</span> {
					ledger_limit = -1;
				}
				proc_list_unlock();
				task_set_phys_footprint_limit_internal(p-&gt;task, ledger_limit, NULL, trigger_exception);
				proc_list_lock();
				proc_rele_locked(p);

				MEMORYSTATUS_DEBUG(3, <span class="enscript-string">&quot;memorystatus_dirty_set: new limit on pid %d (%dMB %s) priority(%d) dirty?=0x%x %s\n&quot;</span>,
					   p-&gt;p_pid, (p-&gt;p_memstat_memlimit &gt; 0 ? p-&gt;p_memstat_memlimit : -1),
					   (p-&gt;p_memstat_state &amp; P_MEMSTAT_FATAL_MEMLIMIT ? <span class="enscript-string">&quot;F &quot;</span> : <span class="enscript-string">&quot;NF&quot;</span>), p-&gt;p_memstat_effectivepriority, p-&gt;p_memstat_dirty,
					   (p-&gt;p_memstat_dirty ? ((p-&gt;p_memstat_dirty &amp; P_DIRTY) ? <span class="enscript-string">&quot;isdirty&quot;</span> : <span class="enscript-string">&quot;isclean&quot;</span>) : <span class="enscript-string">&quot;&quot;</span>));
			}

		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>
	
		<span class="enscript-comment">/* If the deferral state changed, reschedule the demotion timer */</span>
		<span class="enscript-keyword">if</span> (reschedule) {
			memorystatus_reschedule_idle_demotion_locked();
		}
	}

	<span class="enscript-keyword">if</span> (kill) {
		<span class="enscript-keyword">if</span> (proc_ref_locked(p) == p) {
			proc_list_unlock();
			psignal(p, SIGKILL);
			proc_list_lock();
			proc_rele_locked(p);
		}
	}
	
<span class="enscript-reference">exit</span>:
	proc_list_unlock();

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_dirty_clear</span>(proc_t p, uint32_t pcontrol) {

	<span class="enscript-type">int</span> ret = 0;

	MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_dirty_clear(): %d 0x%x 0x%x\n&quot;</span>, p-&gt;p_pid, pcontrol, p-&gt;p_memstat_dirty);
	
	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_DIRTY_CLEAR), p-&gt;p_pid, pcontrol, 0, 0, 0);

	proc_list_lock();

	<span class="enscript-keyword">if</span> ((p-&gt;p_listflag &amp; P_LIST_EXITED) != 0) {
		<span class="enscript-comment">/*
		 * Process is on its way out.
		 */</span>
		ret = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; P_MEMSTAT_INTERNAL) {
		ret = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> (!(p-&gt;p_memstat_dirty &amp; P_DIRTY_TRACK)) {
		<span class="enscript-comment">/* Dirty tracking not enabled */</span>
		ret = EINVAL;			
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	} 

	<span class="enscript-keyword">if</span> (!pcontrol || (pcontrol &amp; (PROC_DIRTY_LAUNCH_IN_PROGRESS | PROC_DIRTY_DEFER)) == 0) {
		ret = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> (pcontrol &amp; PROC_DIRTY_LAUNCH_IN_PROGRESS) {
		p-&gt;p_memstat_dirty &amp;= ~P_DIRTY_LAUNCH_IN_PROGRESS;
	}

	<span class="enscript-comment">/* This can be set and cleared exactly once. */</span>
	<span class="enscript-keyword">if</span> (pcontrol &amp; PROC_DIRTY_DEFER) {

	       	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_dirty &amp; P_DIRTY_DEFER) {

			p-&gt;p_memstat_dirty &amp;= ~P_DIRTY_DEFER;

			memorystatus_invalidate_idle_demotion_locked(p, TRUE);
			memorystatus_update_idle_priority_locked(p);
			memorystatus_reschedule_idle_demotion_locked();
		}
	}

	ret = 0;
<span class="enscript-reference">exit</span>:
	proc_list_unlock();

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_dirty_get</span>(proc_t p) {
	<span class="enscript-type">int</span> ret = 0;
    
	proc_list_lock();
	
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_dirty &amp; P_DIRTY_TRACK) {
		ret |= PROC_DIRTY_TRACKED;
		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_dirty &amp; P_DIRTY_ALLOW_IDLE_EXIT) {
			ret |= PROC_DIRTY_ALLOWS_IDLE_EXIT;
		}
		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_dirty &amp; P_DIRTY) {
			ret |= PROC_DIRTY_IS_DIRTY;
		}
		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_dirty &amp; P_DIRTY_LAUNCH_IN_PROGRESS) {
			ret |= PROC_DIRTY_LAUNCH_IS_IN_PROGRESS;
		}
	}
	
	proc_list_unlock();
    
	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_on_terminate</span>(proc_t p) {
	<span class="enscript-type">int</span> sig;
    
	proc_list_lock();
	
	p-&gt;p_memstat_dirty |= P_DIRTY_TERMINATED;
	
	<span class="enscript-keyword">if</span> ((p-&gt;p_memstat_dirty &amp; (P_DIRTY_TRACK|P_DIRTY_IS_DIRTY)) == P_DIRTY_TRACK) {
		<span class="enscript-comment">/* Clean; mark as terminated and issue SIGKILL */</span>
		sig = SIGKILL;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Dirty, terminated, or state tracking is unsupported; issue SIGTERM to allow cleanup */</span>
		sig = SIGTERM;
	}

	proc_list_unlock();
	
	<span class="enscript-keyword">return</span> sig;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_on_suspend</span>(proc_t p)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	uint32_t pages;
	memorystatus_get_task_page_counts(p-&gt;task, &amp;pages, NULL, NULL, NULL);
#<span class="enscript-reference">endif</span>
	proc_list_lock();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	p-&gt;p_memstat_suspendedfootprint = pages;
	memorystatus_suspended_footprint_total += pages;
	memorystatus_suspended_count++;
#<span class="enscript-reference">endif</span>
	p-&gt;p_memstat_state |= P_MEMSTAT_SUSPENDED;
	proc_list_unlock();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_on_resume</span>(proc_t p)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	boolean_t frozen;
	pid_t pid;
#<span class="enscript-reference">endif</span>

	proc_list_lock();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	frozen = (p-&gt;p_memstat_state &amp; P_MEMSTAT_FROZEN);
	<span class="enscript-keyword">if</span> (frozen) {
		memorystatus_frozen_count--;
		p-&gt;p_memstat_state |= P_MEMSTAT_PRIOR_THAW;
	}

	memorystatus_suspended_footprint_total -= p-&gt;p_memstat_suspendedfootprint;
	memorystatus_suspended_count--;
	
	pid = p-&gt;p_pid;
#<span class="enscript-reference">endif</span>

	p-&gt;p_memstat_state &amp;= ~(P_MEMSTAT_SUSPENDED | P_MEMSTAT_FROZEN);

	proc_list_unlock();
    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	<span class="enscript-keyword">if</span> (frozen) {
		memorystatus_freeze_entry_t data = { pid, FALSE, 0 };
		memorystatus_send_note(kMemorystatusFreezeNote, &amp;data, <span class="enscript-keyword">sizeof</span>(data));
	}
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_on_inactivity</span>(proc_t p)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	<span class="enscript-comment">/* Wake the freeze thread */</span>
	thread_wakeup((event_t)&amp;memorystatus_freeze_wakeup);
#<span class="enscript-reference">endif</span>	
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">memorystatus_build_state</span>(proc_t p) {
	uint32_t snapshot_state = 0;
    
	<span class="enscript-comment">/* General */</span>
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; P_MEMSTAT_SUSPENDED) {
		snapshot_state |= kMemorystatusSuspended;
	}
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; P_MEMSTAT_FROZEN) {
		snapshot_state |= kMemorystatusFrozen;
	}
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; P_MEMSTAT_PRIOR_THAW) {
 		snapshot_state |= kMemorystatusWasThawed;
	}
	
	<span class="enscript-comment">/* Tracking */</span>
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_dirty &amp; P_DIRTY_TRACK) {
		snapshot_state |= kMemorystatusTracked;
	}
	<span class="enscript-keyword">if</span> ((p-&gt;p_memstat_dirty &amp; P_DIRTY_IDLE_EXIT_ENABLED) == P_DIRTY_IDLE_EXIT_ENABLED) {
		snapshot_state |= kMemorystatusSupportsIdleExit;
	}
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_dirty &amp; P_DIRTY_IS_DIRTY) {
		snapshot_state |= kMemorystatusDirty;
	}

	<span class="enscript-keyword">return</span> snapshot_state;
}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_JETSAM</span>

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">kill_idle_exit_proc</span>(<span class="enscript-type">void</span>)
{
	proc_t p, victim_p = PROC_NULL;
	uint64_t current_time;
	boolean_t killed = FALSE;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i = 0;

	<span class="enscript-comment">/* Pick next idle exit victim. */</span>
	current_time = mach_absolute_time();
	
	proc_list_lock();
	
	p = memorystatus_get_first_proc_locked(&amp;i, FALSE);
	<span class="enscript-keyword">while</span> (p) {
		<span class="enscript-comment">/* No need to look beyond the idle band */</span>
		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_effectivepriority != JETSAM_PRIORITY_IDLE) {
			<span class="enscript-keyword">break</span>;
		}
		
		<span class="enscript-keyword">if</span> ((p-&gt;p_memstat_dirty &amp; (P_DIRTY_ALLOW_IDLE_EXIT|P_DIRTY_IS_DIRTY|P_DIRTY_TERMINATED)) == (P_DIRTY_ALLOW_IDLE_EXIT)) {				
			<span class="enscript-keyword">if</span> (current_time &gt;= p-&gt;p_memstat_idledeadline) {
				p-&gt;p_memstat_dirty |= P_DIRTY_TERMINATED;
				victim_p = proc_ref_locked(p);
				<span class="enscript-keyword">break</span>;
			}
		}
		
		p = memorystatus_get_next_proc_locked(&amp;i, p, FALSE);
	}
	
	proc_list_unlock();
	
	<span class="enscript-keyword">if</span> (victim_p) {
		printf(<span class="enscript-string">&quot;memorystatus_thread: idle exiting pid %d [%s]\n&quot;</span>, victim_p-&gt;p_pid, (victim_p-&gt;p_comm ? victim_p-&gt;p_comm : <span class="enscript-string">&quot;(unknown)&quot;</span>));
		killed = memorystatus_do_kill(victim_p, kMemorystatusKilledIdleExit);
		proc_rele(victim_p);
	}

	<span class="enscript-keyword">return</span> killed;
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_thread_wake</span>(<span class="enscript-type">void</span>) {
	thread_wakeup((event_t)&amp;memorystatus_wakeup);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_pressure_response</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_thread_block</span>(uint32_t interval_ms, thread_continue_t continuation)
{
	<span class="enscript-keyword">if</span> (interval_ms) {
		assert_wait_timeout(&amp;memorystatus_wakeup, THREAD_UNINT, interval_ms, 1000 * NSEC_PER_USEC);
	} <span class="enscript-keyword">else</span> {
		assert_wait(&amp;memorystatus_wakeup, THREAD_UNINT);
	}
	
	<span class="enscript-keyword">return</span> thread_block(continuation);   
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_thread</span>(<span class="enscript-type">void</span> *param __unused, wait_result_t wr __unused)
{
	<span class="enscript-type">static</span> boolean_t is_vm_privileged = FALSE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
	boolean_t post_snapshot = FALSE;
	uint32_t errors = 0;
	uint32_t hwm_kill = 0;
	boolean_t sort_flag = TRUE;

        <span class="enscript-comment">/* Jetsam Loop Detection - locals */</span>
	memstat_bucket_t *bucket;
	<span class="enscript-type">int</span>		jld_bucket_count = 0;
	<span class="enscript-type">struct</span> timeval	jld_now_tstamp = {0,0};
	uint64_t 	jld_now_msecs = 0;

	<span class="enscript-comment">/* Jetsam Loop Detection - statics */</span>
	<span class="enscript-type">static</span> uint64_t  jld_timestamp_msecs = 0;
	<span class="enscript-type">static</span> <span class="enscript-type">int</span>	 jld_idle_kill_candidates = 0;	<span class="enscript-comment">/* Number of available processes in band 0,1 at start */</span>
	<span class="enscript-type">static</span> <span class="enscript-type">int</span>	 jld_idle_kills = 0;		<span class="enscript-comment">/* Number of procs killed during eval period  */</span>
	<span class="enscript-type">static</span> <span class="enscript-type">int</span>	 jld_eval_aggressive_count = 0;		<span class="enscript-comment">/* Bumps the max priority in aggressive loop */</span>
	<span class="enscript-type">static</span> int32_t   jld_priority_band_max = JETSAM_PRIORITY_UI_SUPPORT;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (is_vm_privileged == FALSE) {
		<span class="enscript-comment">/* 
		 * It's the first time the thread has run, so just mark the thread as privileged and block.
		 * This avoids a spurious pass with unset variables, as set out in &lt;rdar://problem/9609402&gt;.
		 */</span>
		thread_wire(host_priv_self(), current_thread(), TRUE);
		is_vm_privileged = TRUE;
		
		<span class="enscript-keyword">if</span> (vm_restricted_to_single_processor == TRUE)
			thread_vm_bind_group_add();

		memorystatus_thread_block(0, memorystatus_thread);
	}
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
	
	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_SCAN) | DBG_FUNC_START,
			      memorystatus_available_pages, memorystatus_jld_enabled, memorystatus_jld_eval_period_msecs, memorystatus_jld_eval_aggressive_count,0);

	<span class="enscript-comment">/*
	 * Jetsam aware version.
	 *
	 * The VM pressure notification thread is working it's way through clients in parallel.
	 *
	 * So, while the pressure notification thread is targeting processes in order of 
	 * increasing jetsam priority, we can hopefully reduce / stop it's work by killing 
	 * any processes that have exceeded their highwater mark.
	 *
	 * If we run out of HWM processes and our available pages drops below the critical threshold, then,
	 * we target the least recently used process in order of increasing jetsam priority (exception: the FG band).
	 */</span>
	<span class="enscript-keyword">while</span> (is_thrashing(kill_under_pressure_cause) ||
	       memorystatus_available_pages &lt;= memorystatus_available_pages_pressure) {
		boolean_t killed;
		int32_t priority;
		uint32_t cause;

		<span class="enscript-keyword">if</span> (kill_under_pressure_cause) {
			cause = kill_under_pressure_cause;
		} <span class="enscript-keyword">else</span> {
			cause = kMemorystatusKilledVMPageShortage;
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LEGACY_HIWATER</span>
		<span class="enscript-comment">/* Highwater */</span>
		killed = memorystatus_kill_hiwat_proc(&amp;errors);
		<span class="enscript-keyword">if</span> (killed) {
			hwm_kill++;
			post_snapshot = TRUE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		} <span class="enscript-keyword">else</span> {
			memorystatus_hwm_candidates = FALSE;
		}

		<span class="enscript-comment">/* No highwater processes to kill. Continue or stop for now? */</span>
		<span class="enscript-keyword">if</span> (!is_thrashing(kill_under_pressure_cause) &amp;&amp;
		    (memorystatus_available_pages &gt; memorystatus_available_pages_critical)) {
			<span class="enscript-comment">/*
			 * We are _not_ out of pressure but we are above the critical threshold and there's:
			 * - no compressor thrashing
			 * - no more HWM processes left.
			 * For now, don't kill any other processes.
			 */</span>
		
			<span class="enscript-keyword">if</span> (hwm_kill == 0) {
 				memorystatus_thread_wasted_wakeup++;
			}

			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (memorystatus_jld_enabled == TRUE) {

			<span class="enscript-comment">/*
			 * Jetsam Loop Detection: attempt to detect
			 * rapid daemon relaunches in the lower bands.
			 */</span>
			
			microuptime(&amp;jld_now_tstamp);

			<span class="enscript-comment">/*
			 * Ignore usecs in this calculation.
			 * msecs granularity is close enough.
			 */</span>
			jld_now_msecs = (jld_now_tstamp.tv_sec * 1000);

			proc_list_lock();
			bucket = &amp;memstat_bucket[JETSAM_PRIORITY_IDLE];
			jld_bucket_count = bucket-&gt;count;
			bucket = &amp;memstat_bucket[JETSAM_PRIORITY_IDLE_DEFERRED];
			jld_bucket_count += bucket-&gt;count;
			proc_list_unlock();

			<span class="enscript-comment">/*
			 * memorystatus_jld_eval_period_msecs is a tunable
			 * memorystatus_jld_eval_aggressive_count is a tunable
			 * memorystatus_jld_eval_aggressive_priority_band_max is a tunable
			 */</span>
			<span class="enscript-keyword">if</span> ( (jld_bucket_count == 0) || 
			     (jld_now_msecs &gt; (jld_timestamp_msecs + memorystatus_jld_eval_period_msecs))) {

				<span class="enscript-comment">/* 
				 * Refresh evaluation parameters 
				 */</span>
				jld_timestamp_msecs	 = jld_now_msecs;
				jld_idle_kill_candidates = jld_bucket_count;
				jld_idle_kills		 = 0;
				jld_eval_aggressive_count = 0;
				jld_priority_band_max	= JETSAM_PRIORITY_UI_SUPPORT;
			}

			<span class="enscript-keyword">if</span> (jld_idle_kills &gt; jld_idle_kill_candidates) {
				jld_eval_aggressive_count++;
				<span class="enscript-keyword">if</span> (jld_eval_aggressive_count &gt; memorystatus_jld_eval_aggressive_count) {
					<span class="enscript-comment">/* 
					 * Bump up the jetsam priority limit (eg: the bucket index)
					 * Enforce bucket index sanity.
					 */</span>
					<span class="enscript-keyword">if</span> ((memorystatus_jld_eval_aggressive_priority_band_max &lt; 0) || 
					    (memorystatus_jld_eval_aggressive_priority_band_max &gt;= MEMSTAT_BUCKET_COUNT)) {
						<span class="enscript-comment">/*
						 * Do nothing.  Stick with the default level.
						 */</span>
					} <span class="enscript-keyword">else</span> {
						jld_priority_band_max = memorystatus_jld_eval_aggressive_priority_band_max;
					}
				}

				killed = memorystatus_kill_top_process_aggressive(
					TRUE, 
					kMemorystatusKilledVMThrashing,
					jld_eval_aggressive_count, 
					jld_priority_band_max, 
					&amp;errors);

					
				<span class="enscript-keyword">if</span> (killed) {
					<span class="enscript-comment">/* Always generate logs after aggressive kill */</span>
					post_snapshot = TRUE;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				} 
			} 
		}
		
		<span class="enscript-comment">/* LRU */</span>
		killed = memorystatus_kill_top_process(TRUE, sort_flag, cause, &amp;priority, &amp;errors);
		sort_flag = FALSE;

		<span class="enscript-keyword">if</span> (killed) {
			<span class="enscript-comment">/*
			 * Don't generate logs for steady-state idle-exit kills,
			 * unless it is overridden for debug or by the device
			 * tree.
			 */</span>
			<span class="enscript-keyword">if</span> ((priority != JETSAM_PRIORITY_IDLE) || memorystatus_idle_snapshot) {
        			post_snapshot = TRUE;
			}

			<span class="enscript-comment">/* Jetsam Loop Detection */</span>
			<span class="enscript-keyword">if</span> (memorystatus_jld_enabled == TRUE) {
				<span class="enscript-keyword">if</span> ((priority == JETSAM_PRIORITY_IDLE) || (priority == JETSAM_PRIORITY_IDLE_DEFERRED)) {
					jld_idle_kills++;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/*
					 * We've reached into bands beyond idle deferred.
					 * We make no attempt to monitor them
					 */</span>
				}
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		
		<span class="enscript-keyword">if</span> (memorystatus_available_pages &lt;= memorystatus_available_pages_critical) {
			<span class="enscript-comment">/* Under pressure and unable to kill a process - panic */</span>
			panic(<span class="enscript-string">&quot;memorystatus_jetsam_thread: no victim! available pages:%d\n&quot;</span>, memorystatus_available_pages);
		}
			
<span class="enscript-reference">done</span>:		

		<span class="enscript-comment">/*
		 * We do not want to over-kill when thrashing has been detected.
		 * To avoid that, we reset the flag here and notify the
		 * compressor.
		 */</span>
		<span class="enscript-keyword">if</span> (is_thrashing(kill_under_pressure_cause)) {
			kill_under_pressure_cause = 0;
			vm_thrashing_jetsam_done();
		}
	}

	kill_under_pressure_cause = 0;
	
	<span class="enscript-keyword">if</span> (errors) {
		memorystatus_clear_errors();
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PRESSURE_EVENTS</span>
	<span class="enscript-comment">/*
	 * LD: We used to target the foreground process first and foremost here.
	 * Now, we target all processes, starting from the non-suspended, background
	 * processes first. We will target foreground too.
	 *
	 * memorystatus_update_vm_pressure(TRUE);
	 */</span>
	<span class="enscript-comment">//vm_pressure_response();
</span>#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (post_snapshot) {
		size_t snapshot_size = <span class="enscript-keyword">sizeof</span>(memorystatus_jetsam_snapshot_t) +
			<span class="enscript-keyword">sizeof</span>(memorystatus_jetsam_snapshot_entry_t) * (memorystatus_jetsam_snapshot_count);
		uint64_t timestamp_now = mach_absolute_time();
		memorystatus_jetsam_snapshot-&gt;notification_time = timestamp_now;
		<span class="enscript-keyword">if</span> (memorystatus_jetsam_snapshot_last_timestamp == 0 ||
				timestamp_now &gt; memorystatus_jetsam_snapshot_last_timestamp + memorystatus_jetsam_snapshot_timeout) {
			<span class="enscript-type">int</span> ret = memorystatus_send_note(kMemorystatusSnapshotNote, &amp;snapshot_size, <span class="enscript-keyword">sizeof</span>(snapshot_size));
			<span class="enscript-keyword">if</span> (!ret) {
				proc_list_lock();
				memorystatus_jetsam_snapshot_last_timestamp = timestamp_now;
				proc_list_unlock();
			}
		}
	}

	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_SCAN) | DBG_FUNC_END,
		memorystatus_available_pages, 0, 0, 0, 0);

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>

	<span class="enscript-comment">/*
	 * Jetsam not enabled
	 */</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>

	memorystatus_thread_block(0, memorystatus_thread);
}

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_JETSAM</span>
<span class="enscript-comment">/*
 * Returns TRUE:
 * 	when an idle-exitable proc was killed
 * Returns FALSE:
 *	when there are no more idle-exitable procs found
 * 	when the attempt to kill an idle-exitable proc failed
 */</span>
boolean_t <span class="enscript-function-name">memorystatus_idle_exit_from_VM</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-keyword">return</span>(kill_idle_exit_proc());
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !CONFIG_JETSAM */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>

<span class="enscript-comment">/*
 * Callback invoked when allowable physical memory footprint exceeded
 * (dirty pages + IOKit mappings)
 *
 * This is invoked for both advisory, non-fatal per-task high watermarks,
 * as well as the fatal task memory limits.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_on_ledger_footprint_exceeded</span>(boolean_t warning, <span class="enscript-type">const</span> <span class="enscript-type">int</span> max_footprint_mb)
{
	boolean_t is_active;
	boolean_t is_fatal;

	proc_t p = current_proc();

	proc_list_lock();

	is_active = proc_jetsam_state_is_active_locked(p);
	is_fatal = (p-&gt;p_memstat_state &amp; P_MEMSTAT_FATAL_MEMLIMIT);

	<span class="enscript-keyword">if</span> (warning == FALSE) {
		<span class="enscript-comment">/*
		 * We only want the EXC_RESOURCE to trigger once per lifetime
		 * of the active/inactive limit state. So, here, we detect the
		 * active/inactive state of the process and mark the
		 * state as exception has been triggered.
		 */</span>
		<span class="enscript-keyword">if</span> (is_active == TRUE) {
			<span class="enscript-comment">/*
			 * turn off exceptions for active state
			 */</span>
			p-&gt;p_memstat_state |= P_MEMSTAT_MEMLIMIT_ACTIVE_EXC_TRIGGERED;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * turn off exceptions for inactive state
			 */</span>
			p-&gt;p_memstat_state |= P_MEMSTAT_MEMLIMIT_INACTIVE_EXC_TRIGGERED;
		}

		<span class="enscript-comment">/*
		 * Soft memory limit is a non-fatal high-water-mark
		 * Hard memory limit is a fatal custom-task-limit or system-wide per-task memory limit.
		 */</span>
		printf(<span class="enscript-string">&quot;process %d (%s) exceeded physical memory footprint, the %s%sMemoryLimit of %d MB\n&quot;</span>,
		       p-&gt;p_pid, p-&gt;p_comm, (is_active ? <span class="enscript-string">&quot;Active&quot;</span> : <span class="enscript-string">&quot;Inactive&quot;</span>),
		       (is_fatal  ? <span class="enscript-string">&quot;Hard&quot;</span> : <span class="enscript-string">&quot;Soft&quot;</span>), max_footprint_mb);

	}

	proc_list_unlock();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PRESSURE_EVENTS</span>
	<span class="enscript-keyword">if</span> (warning == TRUE) {
		<span class="enscript-keyword">if</span> (memorystatus_warn_process(p-&gt;p_pid, TRUE <span class="enscript-comment">/* critical? */</span>) != TRUE) {
			<span class="enscript-comment">/* Print warning, since it's possible that task has not registered for pressure notifications */</span>
			printf(<span class="enscript-string">&quot;task_exceeded_footprint: failed to warn the current task (exiting, or no handler registered?).\n&quot;</span>);
		}
		<span class="enscript-keyword">return</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PRESSURE_EVENTS */</span>

	<span class="enscript-keyword">if</span> (is_fatal) {
		<span class="enscript-comment">/*
		 * If this process has no high watermark or has a fatal task limit, then we have been invoked because the task
		 * has violated either the system-wide per-task memory limit OR its own task limit.
		 */</span>
		<span class="enscript-keyword">if</span> (memorystatus_kill_process_sync(p-&gt;p_pid, kMemorystatusKilledPerProcessLimit) != TRUE) {
			printf(<span class="enscript-string">&quot;task_exceeded_footprint: failed to kill the current task (exiting?).\n&quot;</span>);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * HWM offender exists. Done without locks or synchronization.
		 * See comment near its declaration for more details.
		 */</span>
		memorystatus_hwm_candidates = TRUE;
	}
}

<span class="enscript-comment">/*
 * Toggle the P_MEMSTAT_TERMINATED state.
 * Takes the proc_list_lock.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_memstat_terminated</span>(proc_t p, boolean_t set)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (p) {
		proc_list_lock();
		<span class="enscript-keyword">if</span> (set == TRUE) {
			p-&gt;p_memstat_state |= P_MEMSTAT_TERMINATED;
		} <span class="enscript-keyword">else</span> {
			p-&gt;p_memstat_state &amp;= ~P_MEMSTAT_TERMINATED;
		}
		proc_list_unlock();
	}
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">p</span>, <span class="enscript-variable-name">set</span>)
	<span class="enscript-comment">/*
	 * do nothing
	 */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * This is invoked when cpulimits have been exceeded while in fatal mode.
 * The jetsam_flags do not apply as those are for memory related kills.
 * We call this routine so that the offending process is killed with 
 * a non-zero exit status.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">jetsam_on_ledger_cpulimit_exceeded</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> retval = 0;
	<span class="enscript-type">int</span> jetsam_flags = 0;  <span class="enscript-comment">/* make it obvious */</span>
	proc_t p = current_proc();

	printf(<span class="enscript-string">&quot;task_exceeded_cpulimit: killing pid %d [%s]\n&quot;</span>,
	       p-&gt;p_pid, (p-&gt;p_comm ? p-&gt;p_comm : <span class="enscript-string">&quot;(unknown)&quot;</span>));

	retval = jetsam_do_kill(p, jetsam_flags);
	
	<span class="enscript-keyword">if</span> (retval) {
		printf(<span class="enscript-string">&quot;task_exceeded_cpulimit: failed to kill current task (exiting?).\n&quot;</span>);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_get_task_page_counts</span>(task_t task, uint32_t *footprint, uint32_t *max_footprint, uint32_t *max_footprint_lifetime, uint32_t *purgeable_pages)
{
	assert(task);
	assert(footprint);
    
	*footprint = (uint32_t)(get_task_phys_footprint(task) / PAGE_SIZE_64);
	<span class="enscript-keyword">if</span> (max_footprint) {
		*max_footprint = (uint32_t)(get_task_phys_footprint_max(task) / PAGE_SIZE_64);
	}
	<span class="enscript-keyword">if</span> (max_footprint_lifetime) {
		*max_footprint_lifetime = (uint32_t)(get_task_resident_max(task) / PAGE_SIZE_64);
	}
	<span class="enscript-keyword">if</span> (purgeable_pages) {
		*purgeable_pages = (uint32_t)(get_task_purgeable_size(task) / PAGE_SIZE_64);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_update_jetsam_snapshot_entry_locked</span>(proc_t p, uint32_t kill_cause)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; memorystatus_jetsam_snapshot_count; i++) {
		<span class="enscript-keyword">if</span> (memorystatus_jetsam_snapshot_list[i].pid == p-&gt;p_pid) {
			<span class="enscript-comment">/* Update if the priority has changed since the snapshot was taken */</span>
			<span class="enscript-keyword">if</span> (memorystatus_jetsam_snapshot_list[i].priority != p-&gt;p_memstat_effectivepriority) {
				memorystatus_jetsam_snapshot_list[i].priority = p-&gt;p_memstat_effectivepriority;
				strlcpy(memorystatus_jetsam_snapshot_list[i].name, p-&gt;p_comm, MAXCOMLEN+1);
				memorystatus_jetsam_snapshot_list[i].state = memorystatus_build_state(p);
				memorystatus_jetsam_snapshot_list[i].user_data = p-&gt;p_memstat_userdata;
				memorystatus_jetsam_snapshot_list[i].fds = p-&gt;p_fd-&gt;fd_nfiles;
			}
			memorystatus_jetsam_snapshot_list[i].killed = kill_cause;
			<span class="enscript-keyword">return</span>;
		}
	}
}

<span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_pages_update</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pages_avail)
{
	memorystatus_available_pages = pages_avail;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PRESSURE_EVENTS</span>
	<span class="enscript-comment">/*
	 * Since memorystatus_available_pages changes, we should
	 * re-evaluate the pressure levels on the system and 
	 * check if we need to wake the pressure thread.
	 * We also update memorystatus_level in that routine.
	 */</span> 
	vm_pressure_response();

	<span class="enscript-keyword">if</span> (memorystatus_available_pages &lt;= memorystatus_available_pages_pressure) {

		<span class="enscript-keyword">if</span> (memorystatus_hwm_candidates || (memorystatus_available_pages &lt;= memorystatus_available_pages_critical)) {
			memorystatus_thread_wake();
		}
	}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* VM_PRESSURE_EVENTS */</span>

	boolean_t critical, delta;
        
	<span class="enscript-keyword">if</span> (!memorystatus_delta) {
	    <span class="enscript-keyword">return</span>;
	}
	
	critical = (pages_avail &lt; memorystatus_available_pages_critical) ? TRUE : FALSE;
	delta = ((pages_avail &gt;= (memorystatus_available_pages + memorystatus_delta)) 
                || (memorystatus_available_pages &gt;= (pages_avail + memorystatus_delta))) ? TRUE : FALSE;
        
	<span class="enscript-keyword">if</span> (critical || delta) {
  		memorystatus_level = memorystatus_available_pages * 100 / atop_64(max_mem);
		memorystatus_thread_wake();
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PRESSURE_EVENTS */</span>
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">memorystatus_init_jetsam_snapshot_entry_locked</span>(proc_t p, memorystatus_jetsam_snapshot_entry_t *entry)
{	
	clock_sec_t                     tv_sec;
	clock_usec_t                    tv_usec;

	memset(entry, 0, <span class="enscript-keyword">sizeof</span>(memorystatus_jetsam_snapshot_entry_t));
	
	entry-&gt;pid = p-&gt;p_pid;
	strlcpy(&amp;entry-&gt;name[0], p-&gt;p_comm, MAXCOMLEN+1);
	entry-&gt;priority = p-&gt;p_memstat_effectivepriority;
	memorystatus_get_task_page_counts(p-&gt;task, &amp;entry-&gt;pages, &amp;entry-&gt;max_pages, &amp;entry-&gt;max_pages_lifetime, &amp;entry-&gt;purgeable_pages);
	entry-&gt;state = memorystatus_build_state(p);
	entry-&gt;user_data = p-&gt;p_memstat_userdata;
	memcpy(&amp;entry-&gt;uuid[0], &amp;p-&gt;p_uuid[0], <span class="enscript-keyword">sizeof</span>(p-&gt;p_uuid));
	entry-&gt;fds = p-&gt;p_fd-&gt;fd_nfiles;

	absolutetime_to_microtime(get_task_cpu_time(p-&gt;task), &amp;tv_sec, &amp;tv_usec);
	entry-&gt;cpu_time.tv_sec = tv_sec;
	entry-&gt;cpu_time.tv_usec = tv_usec;

	<span class="enscript-keyword">return</span> TRUE;	
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_init_snapshot_vmstats</span>(memorystatus_jetsam_snapshot_t *snapshot)
{
	kern_return_t kr = KERN_SUCCESS;
	mach_msg_type_number_t	count = HOST_VM_INFO64_COUNT;
	vm_statistics64_data_t	vm_stat;

	<span class="enscript-keyword">if</span> ((kr = host_statistics64(host_self(), HOST_VM_INFO64, (host_info64_t)&amp;vm_stat, &amp;count) != KERN_SUCCESS)) {
		printf(<span class="enscript-string">&quot;memorystatus_init_jetsam_snapshot_stats: host_statistics64 failed with %d\n&quot;</span>, kr);
		memset(&amp;snapshot-&gt;stats, 0, <span class="enscript-keyword">sizeof</span>(snapshot-&gt;stats));
	} <span class="enscript-keyword">else</span> {
		snapshot-&gt;stats.free_pages	= vm_stat.free_count;
		snapshot-&gt;stats.active_pages	= vm_stat.active_count;
		snapshot-&gt;stats.inactive_pages	= vm_stat.inactive_count;
		snapshot-&gt;stats.throttled_pages	= vm_stat.throttled_count;
		snapshot-&gt;stats.purgeable_pages	= vm_stat.purgeable_count;
		snapshot-&gt;stats.wired_pages	= vm_stat.wire_count;

		snapshot-&gt;stats.speculative_pages = vm_stat.speculative_count;
		snapshot-&gt;stats.filebacked_pages  = vm_stat.external_page_count;
		snapshot-&gt;stats.anonymous_pages   = vm_stat.internal_page_count;
		snapshot-&gt;stats.compressions      = vm_stat.compressions;
		snapshot-&gt;stats.decompressions    = vm_stat.decompressions;
		snapshot-&gt;stats.compressor_pages  = vm_stat.compressor_page_count;
		snapshot-&gt;stats.total_uncompressed_pages_in_compressor = vm_stat.total_uncompressed_pages_in_compressor;
	}
}

<span class="enscript-comment">/*
 * Collect vm statistics at boot.
 * Called only once (see kern_exec.c)
 * Data can be consumed at any time.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_init_at_boot_snapshot</span>() {
	memorystatus_init_snapshot_vmstats(&amp;memorystatus_at_boot_snapshot);
	memorystatus_at_boot_snapshot.entry_count = 0;
	memorystatus_at_boot_snapshot.notification_time = 0;   <span class="enscript-comment">/* updated when consumed */</span>
	memorystatus_at_boot_snapshot.snapshot_time = mach_absolute_time();
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_init_jetsam_snapshot_locked</span>(memorystatus_jetsam_snapshot_t *od_snapshot, uint32_t ods_list_count )
{
	proc_t p, next_p;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> b = 0, i = 0;

	memorystatus_jetsam_snapshot_t *snapshot = NULL;
	memorystatus_jetsam_snapshot_entry_t *snapshot_list = NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> snapshot_max = 0;

	<span class="enscript-keyword">if</span> (od_snapshot) {
		<span class="enscript-comment">/*
		 * This is an on_demand snapshot
		 */</span>
		snapshot      = od_snapshot;
		snapshot_list = od_snapshot-&gt;entries;
		snapshot_max  = ods_list_count;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * This is a jetsam event snapshot
		 */</span>
		snapshot      = memorystatus_jetsam_snapshot;
		snapshot_list = memorystatus_jetsam_snapshot-&gt;entries;
		snapshot_max  = memorystatus_jetsam_snapshot_max;
	}

	memorystatus_init_snapshot_vmstats(snapshot);

	next_p = memorystatus_get_first_proc_locked(&amp;b, TRUE);
	<span class="enscript-keyword">while</span> (next_p) {
		p = next_p;
		next_p = memorystatus_get_next_proc_locked(&amp;b, p, TRUE);
	        
		<span class="enscript-keyword">if</span> (FALSE == memorystatus_init_jetsam_snapshot_entry_locked(p, &amp;snapshot_list[i])) {
			<span class="enscript-keyword">continue</span>;
		}
		
		MEMORYSTATUS_DEBUG(0, <span class="enscript-string">&quot;jetsam snapshot pid %d, uuid = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n&quot;</span>,
			p-&gt;p_pid, 
			p-&gt;p_uuid[0], p-&gt;p_uuid[1], p-&gt;p_uuid[2], p-&gt;p_uuid[3], p-&gt;p_uuid[4], p-&gt;p_uuid[5], p-&gt;p_uuid[6], p-&gt;p_uuid[7],
			p-&gt;p_uuid[8], p-&gt;p_uuid[9], p-&gt;p_uuid[10], p-&gt;p_uuid[11], p-&gt;p_uuid[12], p-&gt;p_uuid[13], p-&gt;p_uuid[14], p-&gt;p_uuid[15]);

		<span class="enscript-keyword">if</span> (++i == snapshot_max) {
			<span class="enscript-keyword">break</span>;
		} 	
	}

	snapshot-&gt;snapshot_time = mach_absolute_time();
	snapshot-&gt;entry_count = i;

	<span class="enscript-keyword">if</span> (!od_snapshot) {
		<span class="enscript-comment">/* update the system buffer count */</span>
		memorystatus_jetsam_snapshot_count = i;
	}
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_cmd_set_panic_bits</span>(user_addr_t buffer, uint32_t buffer_size) {
	<span class="enscript-type">int</span> ret;
	memorystatus_jetsam_panic_options_t debug;
	
	<span class="enscript-keyword">if</span> (buffer_size != <span class="enscript-keyword">sizeof</span>(memorystatus_jetsam_panic_options_t)) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	ret = copyin(buffer, &amp;debug, buffer_size);
	<span class="enscript-keyword">if</span> (ret) {
		<span class="enscript-keyword">return</span> ret;
	}
	
	<span class="enscript-comment">/* Panic bits match kMemorystatusKilled* enum */</span>
	memorystatus_jetsam_panic_debug = (memorystatus_jetsam_panic_debug &amp; ~debug.mask) | (debug.data &amp; debug.mask);
	
	<span class="enscript-comment">/* Copyout new value */</span>
	debug.data = memorystatus_jetsam_panic_debug;
	ret = copyout(&amp;debug, buffer, <span class="enscript-keyword">sizeof</span>(memorystatus_jetsam_panic_options_t));
	
	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/*
 * Triggers a sort_order on a specified jetsam priority band.
 * This is for testing only, used to force a path through the sort
 * function.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_cmd_test_jetsam_sort</span>(<span class="enscript-type">int</span> priority, <span class="enscript-type">int</span> sort_order) {

	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bucket_index = 0;

	<span class="enscript-keyword">if</span> (priority == -1) {
		<span class="enscript-comment">/* Use as shorthand for default priority */</span>
		bucket_index = JETSAM_PRIORITY_DEFAULT;
	} <span class="enscript-keyword">else</span> {
		bucket_index = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)priority;
	}

	error = memorystatus_sort_bucket(bucket_index, sort_order);

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Jetsam a specific process.
 */</span>
<span class="enscript-type">static</span> boolean_t 
<span class="enscript-function-name">memorystatus_kill_specific_process</span>(pid_t victim_pid, uint32_t cause) {
	boolean_t killed;
	proc_t p;

	<span class="enscript-comment">/* TODO - add a victim queue and push this into the main jetsam thread */</span>

	p = proc_find(victim_pid);
	<span class="enscript-keyword">if</span> (!p) {
		<span class="enscript-keyword">return</span> FALSE;
	}

	printf(<span class="enscript-string">&quot;memorystatus: specifically killing pid %d [%s] (%s %d) - memorystatus_available_pages: %d\n&quot;</span>, 
		victim_pid, (p-&gt;p_comm ? p-&gt;p_comm : <span class="enscript-string">&quot;(unknown)&quot;</span>),
	       jetsam_kill_cause_name[cause], p-&gt;p_memstat_effectivepriority, memorystatus_available_pages);

	proc_list_lock();

	<span class="enscript-keyword">if</span> (memorystatus_jetsam_snapshot_count == 0) {
		memorystatus_init_jetsam_snapshot_locked(NULL,0);
	}

	memorystatus_update_jetsam_snapshot_entry_locked(p, cause);
	proc_list_unlock();
	
	killed = memorystatus_do_kill(p, cause);
	proc_rele(p);
	
	<span class="enscript-keyword">return</span> killed;
}

<span class="enscript-comment">/*
 * Jetsam the first process in the queue.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">memorystatus_kill_top_process</span>(boolean_t any, boolean_t sort_flag, uint32_t cause, int32_t *priority, uint32_t *errors)
{
	pid_t aPid;
	proc_t p = PROC_NULL, next_p = PROC_NULL;
	boolean_t new_snapshot = FALSE, killed = FALSE;
	<span class="enscript-type">int</span> kill_count = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i = 0;
	uint32_t aPid_ep;

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">any</span>)
#<span class="enscript-reference">endif</span>
	
	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_JETSAM) | DBG_FUNC_START,
		memorystatus_available_pages, 0, 0, 0, 0);


	<span class="enscript-keyword">if</span> (sort_flag == TRUE) {
		(<span class="enscript-type">void</span>)memorystatus_sort_bucket(JETSAM_PRIORITY_FOREGROUND, JETSAM_SORT_DEFAULT);
	}

	proc_list_lock();

	next_p = memorystatus_get_first_proc_locked(&amp;i, TRUE);
	<span class="enscript-keyword">while</span> (next_p) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-type">int</span> activeProcess;
		<span class="enscript-type">int</span> procSuspendedForDiagnosis;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
        
		p = next_p;
		next_p = memorystatus_get_next_proc_locked(&amp;i, p, TRUE);
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
		activeProcess = p-&gt;p_memstat_state &amp; P_MEMSTAT_FOREGROUND;
		procSuspendedForDiagnosis = p-&gt;p_memstat_state &amp; P_MEMSTAT_DIAG_SUSPENDED;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
		
		aPid = p-&gt;p_pid;
		aPid_ep = p-&gt;p_memstat_effectivepriority;

		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; (P_MEMSTAT_ERROR | P_MEMSTAT_TERMINATED)) {
			<span class="enscript-keyword">continue</span>;
		}
		    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-keyword">if</span> ((memorystatus_jetsam_policy &amp; kPolicyDiagnoseActive) &amp;&amp; procSuspendedForDiagnosis) {
			printf(<span class="enscript-string">&quot;jetsam: continuing after ignoring proc suspended already for diagnosis - %d\n&quot;</span>, aPid);
			<span class="enscript-keyword">continue</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>

		<span class="enscript-keyword">if</span> (cause == kMemorystatusKilledVnodes)
		{
			<span class="enscript-comment">/*
			 * If the system runs out of vnodes, we systematically jetsam
			 * processes in hopes of stumbling onto a vnode gain that helps
			 * the system recover.  The process that happens to trigger
			 * this path has no known relationship to the vnode consumption.
			 * We attempt to safeguard that process e.g: do not jetsam it.
			 */</span>

			<span class="enscript-keyword">if</span> (p == current_proc()) {
				<span class="enscript-comment">/* do not jetsam the current process */</span>
				<span class="enscript-keyword">continue</span>;
			}
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
		boolean_t skip;
		boolean_t reclaim_proc = !(p-&gt;p_memstat_state &amp; (P_MEMSTAT_LOCKED | P_MEMSTAT_NORECLAIM));
		<span class="enscript-keyword">if</span> (any || reclaim_proc) {
			skip = FALSE;
		} <span class="enscript-keyword">else</span> {
			skip = TRUE;
		}
			
		<span class="enscript-keyword">if</span> (skip) {
			<span class="enscript-keyword">continue</span>;
		} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
		{
		        <span class="enscript-comment">/*
		         * Capture a snapshot if none exists and:
		         * - priority was not requested (this is something other than an ambient kill)
		         * - the priority was requested *and* the targeted process is not at idle priority
		         */</span>
                	<span class="enscript-keyword">if</span> ((memorystatus_jetsam_snapshot_count == 0) &amp;&amp; 
                		(memorystatus_idle_snapshot || ((!priority) || (priority &amp;&amp; (*priority != JETSAM_PRIORITY_IDLE))))) {
				memorystatus_init_jetsam_snapshot_locked(NULL,0);
                		new_snapshot = TRUE;
                	}
		        
			<span class="enscript-comment">/* 
			 * Mark as terminated so that if exit1() indicates success, but the process (for example)
			 * is blocked in task_exception_notify(), it'll be skipped if encountered again - see 
			 * &lt;rdar://problem/13553476&gt;. This is cheaper than examining P_LEXIT, which requires the 
			 * acquisition of the proc lock.
			 */</span>
			p-&gt;p_memstat_state |= P_MEMSTAT_TERMINATED;
		        
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
			<span class="enscript-keyword">if</span> ((memorystatus_jetsam_policy &amp; kPolicyDiagnoseActive) &amp;&amp; activeProcess) {
				MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;jetsam: suspending pid %d [%s] (active) for diagnosis - memory_status_level: %d\n&quot;</span>,
					aPid, (p-&gt;p_comm ? p-&gt;p_comm: <span class="enscript-string">&quot;(unknown)&quot;</span>), memorystatus_level);
				memorystatus_update_jetsam_snapshot_entry_locked(p, kMemorystatusKilledDiagnostic);
				p-&gt;p_memstat_state |= P_MEMSTAT_DIAG_SUSPENDED;
				<span class="enscript-keyword">if</span> (memorystatus_jetsam_policy &amp; kPolicyDiagnoseFirst) {
					jetsam_diagnostic_suspended_one_active_proc = 1;
					printf(<span class="enscript-string">&quot;jetsam: returning after suspending first active proc - %d\n&quot;</span>, aPid);
				}
				
				p = proc_ref_locked(p);
				proc_list_unlock();
				<span class="enscript-keyword">if</span> (p) {
					task_suspend(p-&gt;task);
					<span class="enscript-keyword">if</span> (priority) {
						*priority = aPid_ep;
					}
					proc_rele(p);
					killed = TRUE;
				}
				
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
			{
				<span class="enscript-comment">/* Shift queue, update stats */</span>
				memorystatus_update_jetsam_snapshot_entry_locked(p, cause);

				<span class="enscript-keyword">if</span> (proc_ref_locked(p) == p) {
					proc_list_unlock();
					printf(<span class="enscript-string">&quot;memorystatus: %s %d [%s] (%s %d) - memorystatus_available_pages: %d\n&quot;</span>,
					    ((aPid_ep == JETSAM_PRIORITY_IDLE) ?
					    <span class="enscript-string">&quot;idle exiting pid&quot;</span> : <span class="enscript-string">&quot;jetsam killing pid&quot;</span>),
					    aPid, (p-&gt;p_comm ? p-&gt;p_comm : <span class="enscript-string">&quot;(unknown)&quot;</span>),
					       jetsam_kill_cause_name[cause], aPid_ep, memorystatus_available_pages);

					killed = memorystatus_do_kill(p, cause);

					<span class="enscript-comment">/* Success? */</span>
					<span class="enscript-keyword">if</span> (killed) {
						<span class="enscript-keyword">if</span> (priority) {
							*priority = aPid_ep;
						}
						proc_rele(p);
						kill_count++;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
					}
				
					<span class="enscript-comment">/*
					 * Failure - first unwind the state,
					 * then fall through to restart the search.
					 */</span>
					proc_list_lock();
					proc_rele_locked(p);
					p-&gt;p_memstat_state &amp;= ~P_MEMSTAT_TERMINATED;
					p-&gt;p_memstat_state |= P_MEMSTAT_ERROR;
					*errors += 1;
				}
				
				<span class="enscript-comment">/*
				 * Failure - restart the search.
				 *
				 * We might have raced with &quot;p&quot; exiting on another core, resulting in no
				 * ref on &quot;p&quot;.  Or, we may have failed to kill &quot;p&quot;.
				 *
				 * Either way, we fall thru to here, leaving the proc in the
				 * P_MEMSTAT_TERMINATED state.
				 *
				 * And, we hold the the proc_list_lock at this point.
				 */</span>

				i = 0;
				next_p = memorystatus_get_first_proc_locked(&amp;i, TRUE);
			}
		}
	}
	
	proc_list_unlock();
	
<span class="enscript-reference">exit</span>:
	<span class="enscript-comment">/* Clear snapshot if freshly captured and no target was found */</span>
	<span class="enscript-keyword">if</span> (new_snapshot &amp;&amp; !killed) {
	    memorystatus_jetsam_snapshot-&gt;entry_count = memorystatus_jetsam_snapshot_count = 0;
	}
	
	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_JETSAM) | DBG_FUNC_END,
			      memorystatus_available_pages, killed ? aPid : 0, kill_count, 0, 0);

	<span class="enscript-keyword">return</span> killed;
}

<span class="enscript-comment">/*
 * Jetsam aggressively 
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">memorystatus_kill_top_process_aggressive</span>(boolean_t any, uint32_t cause, <span class="enscript-type">int</span> aggr_count, int32_t priority_max, 
					 uint32_t *errors)
{
	pid_t aPid;
	proc_t p = PROC_NULL, next_p = PROC_NULL;
	boolean_t new_snapshot = FALSE, killed = FALSE;
	<span class="enscript-type">int</span> kill_count = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i = 0;
	int32_t aPid_ep = 0;

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">any</span>)

	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_JETSAM) | DBG_FUNC_START,
		memorystatus_available_pages, priority_max, 0, 0, 0);

	proc_list_lock();

	next_p = memorystatus_get_first_proc_locked(&amp;i, TRUE);
	<span class="enscript-keyword">while</span> (next_p) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-type">int</span> activeProcess;
		<span class="enscript-type">int</span> procSuspendedForDiagnosis;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>

		<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(next_p-&gt;p_memstat_effectivepriority) != i) {

			<span class="enscript-comment">/*
			 * We have raced with next_p running on another core, as it has
			 * moved to a different jetsam priority band.  This means we have
			 * lost our place in line while traversing the jetsam list.  We
			 * attempt to recover by rewinding to the beginning of the band
			 * we were already traversing.  By doing this, we do not guarantee
			 * that no process escapes this aggressive march, but we can make
			 * skipping an entire range of processes less likely. (PR-21069019)
			 */</span>

			MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus: aggressive%d: rewinding %s moved from band %d --&gt; %d\n&quot;</span>,
			       aggr_count, next_p-&gt;p_comm, i, next_p-&gt;p_memstat_effectivepriority);

			next_p = memorystatus_get_first_proc_locked(&amp;i, TRUE);
			<span class="enscript-keyword">continue</span>;
		}

		p = next_p;
		next_p = memorystatus_get_next_proc_locked(&amp;i, p, TRUE);

		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_effectivepriority &gt; priority_max) {
			<span class="enscript-comment">/* 
			 * Bail out of this killing spree if we have
			 * reached beyond the priority_max jetsam band.
 			 * That is, we kill up to and through the 
			 * priority_max jetsam band.
			 */</span>
			proc_list_unlock();
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
		activeProcess = p-&gt;p_memstat_state &amp; P_MEMSTAT_FOREGROUND;
		procSuspendedForDiagnosis = p-&gt;p_memstat_state &amp; P_MEMSTAT_DIAG_SUSPENDED;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
		
		aPid = p-&gt;p_pid;
		aPid_ep = p-&gt;p_memstat_effectivepriority;

		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; (P_MEMSTAT_ERROR | P_MEMSTAT_TERMINATED)) {
			<span class="enscript-keyword">continue</span>;
		}
		    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-keyword">if</span> ((memorystatus_jetsam_policy &amp; kPolicyDiagnoseActive) &amp;&amp; procSuspendedForDiagnosis) {
			printf(<span class="enscript-string">&quot;jetsam: continuing after ignoring proc suspended already for diagnosis - %d\n&quot;</span>, aPid);
			<span class="enscript-keyword">continue</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>

		<span class="enscript-comment">/*
		 * Capture a snapshot if none exists.
		 */</span>
		<span class="enscript-keyword">if</span> (memorystatus_jetsam_snapshot_count == 0) {
			memorystatus_init_jetsam_snapshot_locked(NULL,0);
			new_snapshot = TRUE;
		}
		        
		<span class="enscript-comment">/* 
		 * Mark as terminated so that if exit1() indicates success, but the process (for example)
		 * is blocked in task_exception_notify(), it'll be skipped if encountered again - see 
		 * &lt;rdar://problem/13553476&gt;. This is cheaper than examining P_LEXIT, which requires the 
		 * acquisition of the proc lock.
		 */</span>
		p-&gt;p_memstat_state |= P_MEMSTAT_TERMINATED;
		        
		<span class="enscript-comment">/* Shift queue, update stats */</span>
		memorystatus_update_jetsam_snapshot_entry_locked(p, cause);

		<span class="enscript-comment">/*
		 * In order to kill the target process, we will drop the proc_list_lock.
		 * To guaranteee that p and next_p don't disappear out from under the lock,
		 * we must take a ref on both.
		 * If we cannot get a reference, then it's likely we've raced with
		 * that process exiting on another core.
		 */</span>
		<span class="enscript-keyword">if</span> (proc_ref_locked(p) == p) {
			<span class="enscript-keyword">if</span> (next_p) {
				<span class="enscript-keyword">while</span> (next_p &amp;&amp; (proc_ref_locked(next_p) != next_p)) {
					proc_t temp_p;

					 <span class="enscript-comment">/*
					  * We must have raced with next_p exiting on another core.
					  * Recover by getting the next eligible process in the band.
					  */</span>

					MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus: aggressive%d: skipping %d [%s] (exiting?)\n&quot;</span>,
					       aggr_count, next_p-&gt;p_pid, (next_p-&gt;p_comm ? next_p-&gt;p_comm : <span class="enscript-string">&quot;(unknown)&quot;</span>));

					temp_p = next_p;
					next_p = memorystatus_get_next_proc_locked(&amp;i, temp_p, TRUE);
				 }
			}
			proc_list_unlock();

			printf(<span class="enscript-string">&quot;memorystatus: aggressive%d: %s %d [%s] (%s %d) - memorystatus_available_pages: %d\n&quot;</span>,
			       aggr_count,
			       ((aPid_ep == JETSAM_PRIORITY_IDLE) ? <span class="enscript-string">&quot;idle exiting pid&quot;</span> : <span class="enscript-string">&quot;jetsam killing pid&quot;</span>),
			       aPid, (p-&gt;p_comm ? p-&gt;p_comm : <span class="enscript-string">&quot;(unknown)&quot;</span>),
			       jetsam_kill_cause_name[cause], aPid_ep, memorystatus_available_pages);

			killed = memorystatus_do_kill(p, cause);
				
			<span class="enscript-comment">/* Success? */</span>
			<span class="enscript-keyword">if</span> (killed) {
				proc_rele(p);
				kill_count++;
				p = NULL;
				killed = FALSE;

				<span class="enscript-comment">/* 
				 * Continue the killing spree.
				 */</span>
				proc_list_lock();
				<span class="enscript-keyword">if</span> (next_p) {
					proc_rele_locked(next_p);
				}
				<span class="enscript-keyword">continue</span>;
			}
					
			<span class="enscript-comment">/*
			 * Failure - first unwind the state,
			 * then fall through to restart the search.
			 */</span>
			proc_list_lock();
			proc_rele_locked(p);
			<span class="enscript-keyword">if</span> (next_p) {
				proc_rele_locked(next_p);
			}
			p-&gt;p_memstat_state &amp;= ~P_MEMSTAT_TERMINATED;
			p-&gt;p_memstat_state |= P_MEMSTAT_ERROR;
			*errors += 1;
			p = NULL;
		}

		<span class="enscript-comment">/*
		 * Failure - restart the search at the beginning of
		 * the band we were already traversing.
		 *
		 * We might have raced with &quot;p&quot; exiting on another core, resulting in no
		 * ref on &quot;p&quot;.  Or, we may have failed to kill &quot;p&quot;.
		 *
		 * Either way, we fall thru to here, leaving the proc in the 
		 * P_MEMSTAT_TERMINATED or P_MEMSTAT_ERROR state.
		 *
		 * And, we hold the the proc_list_lock at this point.
		 */</span>

		next_p = memorystatus_get_first_proc_locked(&amp;i, TRUE);
	}
	
	proc_list_unlock();
	
<span class="enscript-reference">exit</span>:
	<span class="enscript-comment">/* Clear snapshot if freshly captured and no target was found */</span>
	<span class="enscript-keyword">if</span> (new_snapshot &amp;&amp; (kill_count == 0)) {
	    memorystatus_jetsam_snapshot-&gt;entry_count = memorystatus_jetsam_snapshot_count = 0;
	}
	
	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_JETSAM) | DBG_FUNC_END,
			      memorystatus_available_pages, killed ? aPid : 0, kill_count, 0, 0);

	<span class="enscript-keyword">if</span> (kill_count &gt; 0) {
		<span class="enscript-keyword">return</span>(TRUE);
	}
	<span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span>(FALSE);
	}
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LEGACY_HIWATER</span>

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">memorystatus_kill_hiwat_proc</span>(uint32_t *errors)
{
	pid_t aPid = 0;
	proc_t p = PROC_NULL, next_p = PROC_NULL;
	boolean_t new_snapshot = FALSE, killed = FALSE;
	<span class="enscript-type">int</span> kill_count = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i = 0;
	uint32_t aPid_ep;
	
	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_JETSAM_HIWAT) | DBG_FUNC_START,
		memorystatus_available_pages, 0, 0, 0, 0);
	
	proc_list_lock();
	
	next_p = memorystatus_get_first_proc_locked(&amp;i, TRUE);
	<span class="enscript-keyword">while</span> (next_p) {
		uint32_t footprint;
		boolean_t skip;

		p = next_p;
		next_p = memorystatus_get_next_proc_locked(&amp;i, p, TRUE);
		
		aPid = p-&gt;p_pid;
		aPid_ep = p-&gt;p_memstat_effectivepriority;
		
		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state  &amp; (P_MEMSTAT_ERROR | P_MEMSTAT_TERMINATED)) {
			<span class="enscript-keyword">continue</span>;
		}
		
		<span class="enscript-comment">/* skip if no limit set */</span>
		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_memlimit &lt;= 0) {
			<span class="enscript-keyword">continue</span>;
		}

#<span class="enscript-reference">if</span> 0
		<span class="enscript-comment">/*
		 * No need to consider P_MEMSTAT_MEMLIMIT_BACKGROUND anymore.
		 * Background limits are described via the inactive limit slots.
		 * Their fatal/non-fatal setting will drive whether or not to be
		 * considered in this kill path.
		 */</span>

		<span class="enscript-comment">/* skip if a currently inapplicable limit is encountered */</span>
		<span class="enscript-keyword">if</span> ((p-&gt;p_memstat_state &amp; P_MEMSTAT_MEMLIMIT_BACKGROUND) &amp;&amp; (p-&gt;p_memstat_effectivepriority &gt;= JETSAM_PRIORITY_FOREGROUND)) {          
			<span class="enscript-keyword">continue</span>;
		}
#<span class="enscript-reference">endif</span>

		footprint = (uint32_t)(get_task_phys_footprint(p-&gt;task) / (1024 * 1024));
		skip = (((int32_t)footprint) &lt;= p-&gt;p_memstat_memlimit);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
		<span class="enscript-keyword">if</span> (!skip &amp;&amp; (memorystatus_jetsam_policy &amp; kPolicyDiagnoseActive)) {
			<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; P_MEMSTAT_DIAG_SUSPENDED) {
				<span class="enscript-keyword">continue</span>;
			}
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
		<span class="enscript-keyword">if</span> (!skip) {
			<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; P_MEMSTAT_LOCKED) {
				skip = TRUE;
			} <span class="enscript-keyword">else</span> {
				skip = FALSE;
			}				
		}
#<span class="enscript-reference">endif</span>

		<span class="enscript-keyword">if</span> (skip) {
			<span class="enscript-keyword">continue</span>;
		} <span class="enscript-keyword">else</span> {
			MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;jetsam: %s pid %d [%s] - %d Mb &gt; 1 (%d Mb)\n&quot;</span>,
				(memorystatus_jetsam_policy &amp; kPolicyDiagnoseActive) ? <span class="enscript-string">&quot;suspending&quot;</span>: <span class="enscript-string">&quot;killing&quot;</span>, aPid, p-&gt;p_comm, footprint, p-&gt;p_memstat_memlimit);
				
			<span class="enscript-keyword">if</span> (memorystatus_jetsam_snapshot_count == 0) {
				memorystatus_init_jetsam_snapshot_locked(NULL,0);
                		new_snapshot = TRUE;
                	}
                	
			p-&gt;p_memstat_state |= P_MEMSTAT_TERMINATED;
				
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
			<span class="enscript-keyword">if</span> (memorystatus_jetsam_policy &amp; kPolicyDiagnoseActive) {
			        MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;jetsam: pid %d suspended for diagnosis - memorystatus_available_pages: %d\n&quot;</span>, aPid, memorystatus_available_pages);
				memorystatus_update_jetsam_snapshot_entry_locked(p, kMemorystatusKilledDiagnostic);
				p-&gt;p_memstat_state |= P_MEMSTAT_DIAG_SUSPENDED;
				
				p = proc_ref_locked(p);
				proc_list_unlock();
				<span class="enscript-keyword">if</span> (p) {
					task_suspend(p-&gt;task);
					proc_rele(p);
					killed = TRUE;
				}
				
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			} <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
			{
				memorystatus_update_jetsam_snapshot_entry_locked(p, kMemorystatusKilledHiwat);
			        
				<span class="enscript-keyword">if</span> (proc_ref_locked(p) == p) {
					proc_list_unlock();

					printf(<span class="enscript-string">&quot;memorystatus: jetsam killing pid %d [%s] (highwater %d) - memorystatus_available_pages: %d\n&quot;</span>, 
					       aPid, (p-&gt;p_comm ? p-&gt;p_comm : <span class="enscript-string">&quot;(unknown)&quot;</span>), aPid_ep, memorystatus_available_pages);

					killed = memorystatus_do_kill(p, kMemorystatusKilledHiwat);
				
					<span class="enscript-comment">/* Success? */</span>
					<span class="enscript-keyword">if</span> (killed) {
						proc_rele(p);
						kill_count++;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
					}

					<span class="enscript-comment">/*
					 * Failure - first unwind the state,
					 * then fall through to restart the search.
					 */</span>
					proc_list_lock();
					proc_rele_locked(p);
					p-&gt;p_memstat_state &amp;= ~P_MEMSTAT_TERMINATED;
					p-&gt;p_memstat_state |= P_MEMSTAT_ERROR;
					*errors += 1;
				}

				<span class="enscript-comment">/*
				 * Failure - restart the search.
				 *
				 * We might have raced with &quot;p&quot; exiting on another core, resulting in no
				 * ref on &quot;p&quot;.  Or, we may have failed to kill &quot;p&quot;.
				 *
				 * Either way, we fall thru to here, leaving the proc in the 
				 * P_MEMSTAT_TERMINATED state.
				 *
				 * And, we hold the the proc_list_lock at this point.
				 */</span>

				i = 0;
				next_p = memorystatus_get_first_proc_locked(&amp;i, TRUE);
			}
		}
	}
	
	proc_list_unlock();
	
<span class="enscript-reference">exit</span>:
	<span class="enscript-comment">/* Clear snapshot if freshly captured and no target was found */</span>
	<span class="enscript-keyword">if</span> (new_snapshot &amp;&amp; !killed) {
		memorystatus_jetsam_snapshot-&gt;entry_count = memorystatus_jetsam_snapshot_count = 0;
	}
	
	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_JETSAM_HIWAT) | DBG_FUNC_END, 
			      memorystatus_available_pages, killed ? aPid : 0, kill_count, 0, 0);

	<span class="enscript-keyword">return</span> killed;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LEGACY_HIWATER */</span>

<span class="enscript-type">static</span> boolean_t 
<span class="enscript-function-name">memorystatus_kill_process_async</span>(pid_t victim_pid, uint32_t cause) {
	<span class="enscript-comment">/* TODO: allow a general async path */</span>
	<span class="enscript-keyword">if</span> ((victim_pid != -1) || (cause != kMemorystatusKilledVMPageShortage &amp;&amp; cause != kMemorystatusKilledVMThrashing &amp;&amp;
				   cause != kMemorystatusKilledFCThrashing)) {
		<span class="enscript-keyword">return</span> FALSE;
	}
    
	kill_under_pressure_cause = cause;
	memorystatus_thread_wake();
	<span class="enscript-keyword">return</span> TRUE;
}

<span class="enscript-type">static</span> boolean_t 
<span class="enscript-function-name">memorystatus_kill_process_sync</span>(pid_t victim_pid, uint32_t cause) {
	boolean_t res;
	uint32_t errors = 0;
    
	<span class="enscript-keyword">if</span> (victim_pid == -1) {
		<span class="enscript-comment">/* No pid, so kill first process */</span>
		res = memorystatus_kill_top_process(TRUE, TRUE, cause, NULL, &amp;errors);
	} <span class="enscript-keyword">else</span> {
		res = memorystatus_kill_specific_process(victim_pid, cause);
	}
	
	<span class="enscript-keyword">if</span> (errors) {
		memorystatus_clear_errors();
	}
    
	<span class="enscript-keyword">if</span> (res == TRUE) {
		<span class="enscript-comment">/* Fire off snapshot notification */</span>
		size_t snapshot_size = <span class="enscript-keyword">sizeof</span>(memorystatus_jetsam_snapshot_t) + 
			<span class="enscript-keyword">sizeof</span>(memorystatus_jetsam_snapshot_entry_t) * memorystatus_jetsam_snapshot_count;
		uint64_t timestamp_now = mach_absolute_time();
		memorystatus_jetsam_snapshot-&gt;notification_time = timestamp_now;
		<span class="enscript-keyword">if</span> (memorystatus_jetsam_snapshot_last_timestamp == 0 ||
				timestamp_now &gt; memorystatus_jetsam_snapshot_last_timestamp + memorystatus_jetsam_snapshot_timeout) {
			<span class="enscript-type">int</span> ret = memorystatus_send_note(kMemorystatusSnapshotNote, &amp;snapshot_size, <span class="enscript-keyword">sizeof</span>(snapshot_size));
			<span class="enscript-keyword">if</span> (!ret) {
				proc_list_lock();
				memorystatus_jetsam_snapshot_last_timestamp = timestamp_now;
				proc_list_unlock();
			}
		}
	}
    
	<span class="enscript-keyword">return</span> res;
}

boolean_t 
<span class="enscript-function-name">memorystatus_kill_on_VM_page_shortage</span>(boolean_t async) {
	<span class="enscript-keyword">if</span> (async) {
		<span class="enscript-keyword">return</span> memorystatus_kill_process_async(-1, kMemorystatusKilledVMPageShortage);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> memorystatus_kill_process_sync(-1, kMemorystatusKilledVMPageShortage);
	}
}

boolean_t
<span class="enscript-function-name">memorystatus_kill_on_VM_thrashing</span>(boolean_t async) {
	<span class="enscript-keyword">if</span> (async) {
		<span class="enscript-keyword">return</span> memorystatus_kill_process_async(-1, kMemorystatusKilledVMThrashing);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> memorystatus_kill_process_sync(-1, kMemorystatusKilledVMThrashing);
	}
}

boolean_t
<span class="enscript-function-name">memorystatus_kill_on_FC_thrashing</span>(boolean_t async) {
	<span class="enscript-keyword">if</span> (async) {
		<span class="enscript-keyword">return</span> memorystatus_kill_process_async(-1, kMemorystatusKilledFCThrashing);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> memorystatus_kill_process_sync(-1, kMemorystatusKilledFCThrashing);
	}
}

boolean_t 
<span class="enscript-function-name">memorystatus_kill_on_vnode_limit</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-keyword">return</span> memorystatus_kill_process_sync(-1, kMemorystatusKilledVnodes);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_freeze_init</span>(<span class="enscript-type">void</span>)
{
	kern_return_t result;
	thread_t thread;

	freezer_lck_grp_attr = lck_grp_attr_alloc_init();
	freezer_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;freezer&quot;</span>, freezer_lck_grp_attr);

	lck_mtx_init(&amp;freezer_mutex, freezer_lck_grp, NULL);
		
	result = kernel_thread_start(memorystatus_freeze_thread, NULL, &amp;thread);
	<span class="enscript-keyword">if</span> (result == KERN_SUCCESS) {
		thread_deallocate(thread);
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;Could not create memorystatus_freeze_thread&quot;</span>);
	}
}

<span class="enscript-comment">/*
 * Synchronously freeze the passed proc. Called with a reference to the proc held.
 *
 * Returns EINVAL or the value returned by task_freeze().
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_freeze_process_sync</span>(proc_t p)
{
	<span class="enscript-type">int</span> ret = EINVAL;
	pid_t aPid = 0;
	boolean_t memorystatus_freeze_swap_low = FALSE;

	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_FREEZE) | DBG_FUNC_START,
		memorystatus_available_pages, 0, 0, 0, 0);

	lck_mtx_lock(&amp;freezer_mutex);

	<span class="enscript-keyword">if</span> (p == NULL) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> (memorystatus_freeze_enabled == FALSE) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> (!memorystatus_can_freeze(&amp;memorystatus_freeze_swap_low)) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	<span class="enscript-keyword">if</span> (memorystatus_freeze_update_throttle()) {
		printf(<span class="enscript-string">&quot;memorystatus_freeze_process_sync: in throttle, ignorning freeze\n&quot;</span>);
		memorystatus_freeze_throttle_count++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}

	proc_list_lock();

	<span class="enscript-keyword">if</span> (p != NULL) {
		uint32_t purgeable, wired, clean, dirty, state;
		uint32_t max_pages, pages, i;
		boolean_t shared;

		aPid = p-&gt;p_pid;
		state = p-&gt;p_memstat_state;

		<span class="enscript-comment">/* Ensure the process is eligible for freezing */</span>
		<span class="enscript-keyword">if</span> ((state &amp; (P_MEMSTAT_TERMINATED | P_MEMSTAT_LOCKED | P_MEMSTAT_FROZEN)) || !(state &amp; P_MEMSTAT_SUSPENDED)) {
			proc_list_unlock();
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}

		<span class="enscript-comment">/* Only freeze processes meeting our minimum resident page criteria */</span>
		memorystatus_get_task_page_counts(p-&gt;task, &amp;pages, NULL, NULL, NULL);
		<span class="enscript-keyword">if</span> (pages &lt; memorystatus_freeze_pages_min) {
			proc_list_unlock();
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}

		<span class="enscript-keyword">if</span> (DEFAULT_FREEZER_IS_ACTIVE || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_SWAPBACKED) {

			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> avail_swap_space = 0; <span class="enscript-comment">/* in pages. */</span>

			<span class="enscript-keyword">if</span> (DEFAULT_FREEZER_IS_ACTIVE) {
				<span class="enscript-comment">/*
				 * Freezer backed by default pager and swap file(s).
				 */</span>
				avail_swap_space = default_pager_swap_pages_free();
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * Freezer backed by the compressor and swap file(s)
				 * while will hold compressed data.
				 */</span>
				avail_swap_space = vm_swap_get_free_space() / PAGE_SIZE_64;
			}

			max_pages = MIN(avail_swap_space, memorystatus_freeze_pages_max);

			<span class="enscript-keyword">if</span> (max_pages &lt; memorystatus_freeze_pages_min) {
				proc_list_unlock();
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * We only have the compressor without any swap.
			 */</span>
			max_pages = UINT32_MAX - 1;
		}

		<span class="enscript-comment">/* Mark as locked temporarily to avoid kill */</span>
		p-&gt;p_memstat_state |= P_MEMSTAT_LOCKED;
		proc_list_unlock();

		ret = task_freeze(p-&gt;task, &amp;purgeable, &amp;wired, &amp;clean, &amp;dirty, max_pages, &amp;shared, FALSE);

		MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_freeze_process_sync: task_freeze %s for pid %d [%s] - &quot;</span>
			<span class="enscript-string">&quot;memorystatus_pages: %d, purgeable: %d, wired: %d, clean: %d, dirty: %d, shared %d, free swap: %d\n&quot;</span>,
			(ret == KERN_SUCCESS) ? <span class="enscript-string">&quot;SUCCEEDED&quot;</span> : <span class="enscript-string">&quot;FAILED&quot;</span>, aPid, (p-&gt;p_comm ? p-&gt;p_comm : <span class="enscript-string">&quot;(unknown)&quot;</span>),
			memorystatus_available_pages, purgeable, wired, clean, dirty, shared, default_pager_swap_pages_free());

		proc_list_lock();
		p-&gt;p_memstat_state &amp;= ~P_MEMSTAT_LOCKED;

		<span class="enscript-keyword">if</span> (ret == KERN_SUCCESS) {
			memorystatus_freeze_entry_t data = { aPid, TRUE, dirty };

			memorystatus_frozen_count++;

			p-&gt;p_memstat_state |= (P_MEMSTAT_FROZEN | (shared ? 0: P_MEMSTAT_NORECLAIM));

			<span class="enscript-keyword">if</span> (DEFAULT_FREEZER_IS_ACTIVE || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_SWAPBACKED) {
				<span class="enscript-comment">/* Update stats */</span>
				<span class="enscript-keyword">for</span> (i = 0; i &lt; <span class="enscript-keyword">sizeof</span>(throttle_intervals) / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> throttle_interval_t); i++) {
					throttle_intervals[i].pageouts += dirty;
				}
			}

			memorystatus_freeze_pageouts += dirty;
			memorystatus_freeze_count++;

			proc_list_unlock();

			memorystatus_send_note(kMemorystatusFreezeNote, &amp;data, <span class="enscript-keyword">sizeof</span>(data));
		} <span class="enscript-keyword">else</span> {
			proc_list_unlock();
		}
	}

<span class="enscript-reference">exit</span>:
	lck_mtx_unlock(&amp;freezer_mutex);
	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_FREEZE) | DBG_FUNC_END,
		memorystatus_available_pages, aPid, 0, 0, 0);

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_freeze_top_process</span>(boolean_t *memorystatus_freeze_swap_low)
{
	pid_t aPid = 0;
	<span class="enscript-type">int</span> ret = -1;
	proc_t p = PROC_NULL, next_p = PROC_NULL;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i = 0;

	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_FREEZE) | DBG_FUNC_START,
		memorystatus_available_pages, 0, 0, 0, 0);

	proc_list_lock();
	
	next_p = memorystatus_get_first_proc_locked(&amp;i, TRUE);
	<span class="enscript-keyword">while</span> (next_p) {
		kern_return_t kr;
		uint32_t purgeable, wired, clean, dirty;
		boolean_t shared;
		uint32_t pages;
		uint32_t max_pages = 0;
		uint32_t state;
		
		p = next_p;
		next_p = memorystatus_get_next_proc_locked(&amp;i, p, TRUE);

		aPid = p-&gt;p_pid;
		state = p-&gt;p_memstat_state;

		<span class="enscript-comment">/* Ensure the process is eligible for freezing */</span>
		<span class="enscript-keyword">if</span> ((state &amp; (P_MEMSTAT_TERMINATED | P_MEMSTAT_LOCKED | P_MEMSTAT_FROZEN)) || !(state &amp; P_MEMSTAT_SUSPENDED)) {
			<span class="enscript-keyword">continue</span>; <span class="enscript-comment">// with lock held
</span>		}
					
		<span class="enscript-comment">/* Only freeze processes meeting our minimum resident page criteria */</span>
		memorystatus_get_task_page_counts(p-&gt;task, &amp;pages, NULL, NULL, NULL);
		<span class="enscript-keyword">if</span> (pages &lt; memorystatus_freeze_pages_min) {
			<span class="enscript-keyword">continue</span>; <span class="enscript-comment">// with lock held
</span>		} 

		<span class="enscript-keyword">if</span> (DEFAULT_FREEZER_IS_ACTIVE || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_SWAPBACKED) {

			<span class="enscript-comment">/* Ensure there's enough free space to freeze this process. */</span>

			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> avail_swap_space = 0; <span class="enscript-comment">/* in pages. */</span>

			<span class="enscript-keyword">if</span> (DEFAULT_FREEZER_IS_ACTIVE) {
				<span class="enscript-comment">/*
				 * Freezer backed by default pager and swap file(s).
				 */</span>
				avail_swap_space = default_pager_swap_pages_free();
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * Freezer backed by the compressor and swap file(s)
				 * while will hold compressed data.
				 */</span>
				avail_swap_space = vm_swap_get_free_space() / PAGE_SIZE_64;
			}

			max_pages = MIN(avail_swap_space, memorystatus_freeze_pages_max);

			<span class="enscript-keyword">if</span> (max_pages &lt; memorystatus_freeze_pages_min) {
				*memorystatus_freeze_swap_low = TRUE;
				proc_list_unlock();
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * We only have the compressor pool.
			 */</span>
			max_pages = UINT32_MAX - 1;
		}
		
		<span class="enscript-comment">/* Mark as locked temporarily to avoid kill */</span>
		p-&gt;p_memstat_state |= P_MEMSTAT_LOCKED;

		p = proc_ref_locked(p);
		proc_list_unlock();        
		<span class="enscript-keyword">if</span> (!p) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
		}
        
		kr = task_freeze(p-&gt;task, &amp;purgeable, &amp;wired, &amp;clean, &amp;dirty, max_pages, &amp;shared, FALSE);
		
		MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_freeze_top_process: task_freeze %s for pid %d [%s] - &quot;</span>
    			<span class="enscript-string">&quot;memorystatus_pages: %d, purgeable: %d, wired: %d, clean: %d, dirty: %d, shared %d, free swap: %d\n&quot;</span>, 
       		(kr == KERN_SUCCESS) ? <span class="enscript-string">&quot;SUCCEEDED&quot;</span> : <span class="enscript-string">&quot;FAILED&quot;</span>, aPid, (p-&gt;p_comm ? p-&gt;p_comm : <span class="enscript-string">&quot;(unknown)&quot;</span>), 
       		memorystatus_available_pages, purgeable, wired, clean, dirty, shared, default_pager_swap_pages_free());
     
		proc_list_lock();
		p-&gt;p_memstat_state &amp;= ~P_MEMSTAT_LOCKED;
		
		<span class="enscript-comment">/* Success? */</span>
		<span class="enscript-keyword">if</span> (KERN_SUCCESS == kr) {
			memorystatus_freeze_entry_t data = { aPid, TRUE, dirty };
			
			memorystatus_frozen_count++;
			
			p-&gt;p_memstat_state |= (P_MEMSTAT_FROZEN | (shared ? 0: P_MEMSTAT_NORECLAIM));
		
			<span class="enscript-keyword">if</span> (DEFAULT_FREEZER_IS_ACTIVE || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_SWAPBACKED) {
				<span class="enscript-comment">/* Update stats */</span>
				<span class="enscript-keyword">for</span> (i = 0; i &lt; <span class="enscript-keyword">sizeof</span>(throttle_intervals) / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> throttle_interval_t); i++) {
					throttle_intervals[i].pageouts += dirty;
				}
			}

			memorystatus_freeze_pageouts += dirty;
			memorystatus_freeze_count++;

			proc_list_unlock();

			memorystatus_send_note(kMemorystatusFreezeNote, &amp;data, <span class="enscript-keyword">sizeof</span>(data));

			<span class="enscript-comment">/* Return KERN_SUCESS */</span>
			ret = kr;

		} <span class="enscript-keyword">else</span> {
			proc_list_unlock();
		}
        
		proc_rele(p);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">exit</span>;
	}
	
	proc_list_unlock();
	
<span class="enscript-reference">exit</span>:
	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_FREEZE) | DBG_FUNC_END,
		memorystatus_available_pages, aPid, 0, 0, 0);
	
	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">static</span> inline boolean_t 
<span class="enscript-function-name">memorystatus_can_freeze_processes</span>(<span class="enscript-type">void</span>) 
{
	boolean_t ret;
	
	proc_list_lock();
	
	<span class="enscript-keyword">if</span> (memorystatus_suspended_count) {
		uint32_t average_resident_pages, estimated_processes;
        
		<span class="enscript-comment">/* Estimate the number of suspended processes we can fit */</span>
		average_resident_pages = memorystatus_suspended_footprint_total / memorystatus_suspended_count;
		estimated_processes = memorystatus_suspended_count +
			((memorystatus_available_pages - memorystatus_available_pages_critical) / average_resident_pages);

		<span class="enscript-comment">/* If it's predicted that no freeze will occur, lower the threshold temporarily */</span>
		<span class="enscript-keyword">if</span> (estimated_processes &lt;= FREEZE_SUSPENDED_THRESHOLD_DEFAULT) {
			memorystatus_freeze_suspended_threshold = FREEZE_SUSPENDED_THRESHOLD_LOW;
		} <span class="enscript-keyword">else</span> {
			memorystatus_freeze_suspended_threshold = FREEZE_SUSPENDED_THRESHOLD_DEFAULT;
		}

		MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_can_freeze_processes: %d suspended processes, %d average resident pages / process, %d suspended processes estimated\n&quot;</span>, 
			memorystatus_suspended_count, average_resident_pages, estimated_processes);
	
		<span class="enscript-keyword">if</span> ((memorystatus_suspended_count - memorystatus_frozen_count) &gt; memorystatus_freeze_suspended_threshold) {
			ret = TRUE;
		} <span class="enscript-keyword">else</span> {
			ret = FALSE;
		}
	} <span class="enscript-keyword">else</span> {
		ret = FALSE;
	}
				
	proc_list_unlock();
	
	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">static</span> boolean_t 
<span class="enscript-function-name">memorystatus_can_freeze</span>(boolean_t *memorystatus_freeze_swap_low)
{
	boolean_t can_freeze = TRUE;

	<span class="enscript-comment">/* Only freeze if we're sufficiently low on memory; this holds off freeze right
	   after boot,  and is generally is a no-op once we've reached steady state. */</span>
	<span class="enscript-keyword">if</span> (memorystatus_available_pages &gt; memorystatus_freeze_threshold) {
		<span class="enscript-keyword">return</span> FALSE;
	}
	
	<span class="enscript-comment">/* Check minimum suspended process threshold. */</span>
	<span class="enscript-keyword">if</span> (!memorystatus_can_freeze_processes()) {
		<span class="enscript-keyword">return</span> FALSE;
	}

	<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_SWAPLESS || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_SWAPLESS) {
		<span class="enscript-comment">/*
		 * In-core compressor used for freezing WITHOUT on-disk swap support.
		 */</span>

		<span class="enscript-keyword">if</span> (vm_compressor_low_on_space()) {
			<span class="enscript-keyword">if</span> (*memorystatus_freeze_swap_low) {
				*memorystatus_freeze_swap_low = TRUE;
			}

			can_freeze = FALSE;

		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (*memorystatus_freeze_swap_low) {
				*memorystatus_freeze_swap_low = FALSE;
			}

			can_freeze = TRUE;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Freezing WITH on-disk swap support.
		 */</span>

		<span class="enscript-keyword">if</span> (DEFAULT_FREEZER_COMPRESSED_PAGER_IS_SWAPBACKED) {
			<span class="enscript-comment">/*
			 * In-core compressor fronts the swap.
			 */</span>
			<span class="enscript-keyword">if</span> (vm_swap_low_on_space()) {
				<span class="enscript-keyword">if</span> (*memorystatus_freeze_swap_low) {
					*memorystatus_freeze_swap_low = TRUE;
				}

				can_freeze = FALSE;
			}

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (DEFAULT_FREEZER_IS_ACTIVE) {
			<span class="enscript-comment">/*
			 * Legacy freeze mode with no compressor support.
			 */</span>
			<span class="enscript-keyword">if</span> (default_pager_swap_pages_free() &lt; memorystatus_freeze_pages_min) {
				<span class="enscript-keyword">if</span> (*memorystatus_freeze_swap_low) {
					*memorystatus_freeze_swap_low = TRUE;
				}

				can_freeze = FALSE;
			}
		} <span class="enscript-keyword">else</span> {
			panic(<span class="enscript-string">&quot;Not a valid freeze configuration.\n&quot;</span>);
		}
	}
	
	<span class="enscript-keyword">return</span> can_freeze;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_freeze_update_throttle_interval</span>(mach_timespec_t *ts, <span class="enscript-type">struct</span> throttle_interval_t *interval)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> freeze_daily_pageouts_max = memorystatus_freeze_daily_mb_max * (1024 * 1024 / PAGE_SIZE);
	<span class="enscript-keyword">if</span> (CMP_MACH_TIMESPEC(ts, &amp;interval-&gt;ts) &gt;= 0) {
		<span class="enscript-keyword">if</span> (!interval-&gt;max_pageouts) {
			interval-&gt;max_pageouts = (interval-&gt;burst_multiple * (((uint64_t)interval-&gt;mins * freeze_daily_pageouts_max) / (24 * 60)));
		} <span class="enscript-keyword">else</span> {
			printf(<span class="enscript-string">&quot;memorystatus_freeze_update_throttle_interval: %d minute throttle timeout, resetting\n&quot;</span>, interval-&gt;mins);
		}
		interval-&gt;ts.tv_sec = interval-&gt;mins * 60;
		interval-&gt;ts.tv_nsec = 0;
		ADD_MACH_TIMESPEC(&amp;interval-&gt;ts, ts);
		<span class="enscript-comment">/* Since we update the throttle stats pre-freeze, adjust for overshoot here */</span>
		<span class="enscript-keyword">if</span> (interval-&gt;pageouts &gt; interval-&gt;max_pageouts) {
			interval-&gt;pageouts -= interval-&gt;max_pageouts;
		} <span class="enscript-keyword">else</span> {
			interval-&gt;pageouts = 0;
		}
		interval-&gt;throttle = FALSE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!interval-&gt;throttle &amp;&amp; interval-&gt;pageouts &gt;= interval-&gt;max_pageouts) {
		printf(<span class="enscript-string">&quot;memorystatus_freeze_update_throttle_interval: %d minute pageout limit exceeded; enabling throttle\n&quot;</span>, interval-&gt;mins);
		interval-&gt;throttle = TRUE;
	}	

	MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_freeze_update_throttle_interval: throttle updated - %d frozen (%d max) within %dm; %dm remaining; throttle %s\n&quot;</span>, 
		interval-&gt;pageouts, interval-&gt;max_pageouts, interval-&gt;mins, (interval-&gt;ts.tv_sec - ts-&gt;tv_sec) / 60, 
		interval-&gt;throttle ? <span class="enscript-string">&quot;on&quot;</span> : <span class="enscript-string">&quot;off&quot;</span>);
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">memorystatus_freeze_update_throttle</span>(<span class="enscript-type">void</span>) 
{
	clock_sec_t sec;
	clock_nsec_t nsec;
	mach_timespec_t ts;
	uint32_t i;
	boolean_t throttled = FALSE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (!memorystatus_freeze_throttle_enabled)
		<span class="enscript-keyword">return</span> FALSE;
#<span class="enscript-reference">endif</span>

	clock_get_system_nanotime(&amp;sec, &amp;nsec);
	ts.tv_sec = sec;
	ts.tv_nsec = nsec;
	
	<span class="enscript-comment">/* Check freeze pageouts over multiple intervals and throttle if we've exceeded our budget.
	 *
	 * This ensures that periods of inactivity can't be used as 'credit' towards freeze if the device has
	 * remained dormant for a long period. We do, however, allow increased thresholds for shorter intervals in
	 * order to allow for bursts of activity.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; <span class="enscript-keyword">sizeof</span>(throttle_intervals) / <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> throttle_interval_t); i++) {
		memorystatus_freeze_update_throttle_interval(&amp;ts, &amp;throttle_intervals[i]);
		<span class="enscript-keyword">if</span> (throttle_intervals[i].throttle == TRUE)
			throttled = TRUE;
	}								

	<span class="enscript-keyword">return</span> throttled;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_freeze_thread</span>(<span class="enscript-type">void</span> *param __unused, wait_result_t wr __unused)
{
	<span class="enscript-type">static</span> boolean_t memorystatus_freeze_swap_low = FALSE;

	lck_mtx_lock(&amp;freezer_mutex);
	<span class="enscript-keyword">if</span> (memorystatus_freeze_enabled) {
		<span class="enscript-keyword">if</span> (memorystatus_can_freeze(&amp;memorystatus_freeze_swap_low)) {
			<span class="enscript-comment">/* Only freeze if we've not exceeded our pageout budgets.*/</span>
			<span class="enscript-keyword">if</span> (!memorystatus_freeze_update_throttle()) {
				memorystatus_freeze_top_process(&amp;memorystatus_freeze_swap_low);
			} <span class="enscript-keyword">else</span> {
				printf(<span class="enscript-string">&quot;memorystatus_freeze_thread: in throttle, ignoring freeze\n&quot;</span>);
				memorystatus_freeze_throttle_count++; <span class="enscript-comment">/* Throttled, update stats */</span>
			}
		}
	}
	lck_mtx_unlock(&amp;freezer_mutex);

	assert_wait((event_t) &amp;memorystatus_freeze_wakeup, THREAD_UNINT);
	thread_block((thread_continue_t) memorystatus_freeze_thread);	
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PRESSURE_EVENTS</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_send_note</span>(<span class="enscript-type">int</span> event_code, <span class="enscript-type">void</span> *data, size_t data_length) {
	<span class="enscript-type">int</span> ret;
	<span class="enscript-type">struct</span> kev_msg ev_msg;
	
	ev_msg.vendor_code    = KEV_VENDOR_APPLE;
	ev_msg.kev_class      = KEV_SYSTEM_CLASS;
	ev_msg.kev_subclass   = KEV_MEMORYSTATUS_SUBCLASS;

	ev_msg.event_code     = event_code;

	ev_msg.dv[0].data_length = data_length;
	ev_msg.dv[0].data_ptr = data;
	ev_msg.dv[1].data_length = 0;

	ret = kev_post_msg(&amp;ev_msg);
	<span class="enscript-keyword">if</span> (ret) {
		printf(<span class="enscript-string">&quot;%s: kev_post_msg() failed, err %d\n&quot;</span>, __func__, ret);
	}
	
	<span class="enscript-keyword">return</span> ret;
}

boolean_t
<span class="enscript-function-name">memorystatus_warn_process</span>(pid_t pid, boolean_t critical) {

	boolean_t ret = FALSE;
	boolean_t found_knote = FALSE;
	<span class="enscript-type">struct</span> knote *kn = NULL;

	<span class="enscript-comment">/*
	 * See comment in sysctl_memorystatus_vm_pressure_send.
	 */</span>

	memorystatus_klist_lock();

	SLIST_FOREACH(kn, &amp;memorystatus_klist, kn_selnext) {
		proc_t knote_proc = kn-&gt;kn_kq-&gt;kq_p;
		pid_t knote_pid = knote_proc-&gt;p_pid;

		<span class="enscript-keyword">if</span> (knote_pid == pid) {
			<span class="enscript-comment">/*
			 * By setting the &quot;fflags&quot; here, we are forcing
			 * a process to deal with the case where it's
			 * bumping up into its memory limits. If we don't
			 * do this here, we will end up depending on the
			 * system pressure snapshot evaluation in
			 * filt_memorystatus().
			 */</span>
	
			<span class="enscript-keyword">if</span> (critical) {
				<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_MEMORYSTATUS_PRESSURE_CRITICAL) {
					kn-&gt;kn_fflags = NOTE_MEMORYSTATUS_PRESSURE_CRITICAL;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_MEMORYSTATUS_PRESSURE_WARN) {
					kn-&gt;kn_fflags = NOTE_MEMORYSTATUS_PRESSURE_WARN;
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_MEMORYSTATUS_PRESSURE_WARN) {
					kn-&gt;kn_fflags = NOTE_MEMORYSTATUS_PRESSURE_WARN;
				}
			}

			found_knote = TRUE;
		}
	}

	<span class="enscript-keyword">if</span> (found_knote) {
		KNOTE(&amp;memorystatus_klist, 0);
		ret = TRUE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (vm_dispatch_pressure_note_to_pid(pid, FALSE) == 0) {
			ret = TRUE;
		}
	}

	memorystatus_klist_unlock();

	<span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">/*
 * Can only be set by the current task on itself.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_low_mem_privileged_listener</span>(uint32_t op_flags)
{
	boolean_t set_privilege = FALSE;
	<span class="enscript-comment">/*
	 * Need an entitlement check here?
	 */</span>
	<span class="enscript-keyword">if</span> (op_flags == MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_ENABLE) {
		set_privilege = TRUE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (op_flags == MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_DISABLE) {
		set_privilege = FALSE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-keyword">return</span> (task_low_mem_privileged_listener(current_task(), set_privilege, NULL));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_send_pressure_note</span>(pid_t pid) {
 	MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_send_pressure_note(): pid %d\n&quot;</span>, pid);      
 	<span class="enscript-keyword">return</span> memorystatus_send_note(kMemorystatusPressureNote, &amp;pid, <span class="enscript-keyword">sizeof</span>(pid));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_send_low_swap_note</span>(<span class="enscript-type">void</span>) {
	
	<span class="enscript-type">struct</span> knote *kn = NULL;

	memorystatus_klist_lock();
	SLIST_FOREACH(kn, &amp;memorystatus_klist, kn_selnext) {
		<span class="enscript-comment">/* We call is_knote_registered_modify_task_pressure_bits to check if the sfflags for the
		 * current note contain NOTE_MEMORYSTATUS_LOW_SWAP. Once we find one note in the memorystatus_klist
		 * that has the NOTE_MEMORYSTATUS_LOW_SWAP flags in its sfflags set, we call KNOTE with
		 * kMemoryStatusLowSwap as the hint to process and update all knotes on the memorystatus_klist accordingly. */</span>
		<span class="enscript-keyword">if</span> (is_knote_registered_modify_task_pressure_bits(kn, NOTE_MEMORYSTATUS_LOW_SWAP, NULL, 0, 0) == TRUE) {
			KNOTE(&amp;memorystatus_klist, kMemorystatusLowSwap);
			<span class="enscript-keyword">break</span>;
		}
	}

	memorystatus_klist_unlock();
}

boolean_t
<span class="enscript-function-name">memorystatus_bg_pressure_eligible</span>(proc_t p) {
 	boolean_t eligible = FALSE;
        
	proc_list_lock();
	
	MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_bg_pressure_eligible: pid %d, state 0x%x\n&quot;</span>, p-&gt;p_pid, p-&gt;p_memstat_state);
        
 	<span class="enscript-comment">/* Foreground processes have already been dealt with at this point, so just test for eligibility */</span>
 	<span class="enscript-keyword">if</span> (!(p-&gt;p_memstat_state &amp; (P_MEMSTAT_TERMINATED | P_MEMSTAT_LOCKED | P_MEMSTAT_SUSPENDED | P_MEMSTAT_FROZEN))) {
                eligible = TRUE;
	}
        
	proc_list_unlock();
	
 	<span class="enscript-keyword">return</span> eligible;
}

boolean_t
<span class="enscript-function-name">memorystatus_is_foreground_locked</span>(proc_t p) {
        <span class="enscript-keyword">return</span> ((p-&gt;p_memstat_effectivepriority == JETSAM_PRIORITY_FOREGROUND) || 
                (p-&gt;p_memstat_effectivepriority == JETSAM_PRIORITY_FOREGROUND_SUPPORT));
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MEMORYSTATUS */</span>

<span class="enscript-comment">/*
 * Trigger levels to test the mechanism.
 * Can be used via a sysctl.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TEST_LOW_MEMORY_TRIGGER_ONE</span>		1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TEST_LOW_MEMORY_TRIGGER_ALL</span>		2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TEST_PURGEABLE_TRIGGER_ONE</span>		3
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TEST_PURGEABLE_TRIGGER_ALL</span>		4
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TEST_LOW_MEMORY_PURGEABLE_TRIGGER_ONE</span>	5
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TEST_LOW_MEMORY_PURGEABLE_TRIGGER_ALL</span>	6

boolean_t		memorystatus_manual_testing_on = FALSE;
vm_pressure_level_t	memorystatus_manual_testing_level = kVMPressureNormal;

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> knote *
<span class="enscript-function-name">vm_pressure_select_optimal_candidate_to_notify</span>(<span class="enscript-type">struct</span> klist *, <span class="enscript-type">int</span>, boolean_t);

<span class="enscript-type">extern</span>
kern_return_t <span class="enscript-function-name">vm_pressure_notification_without_levels</span>(boolean_t);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_pressure_klist_lock</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_pressure_klist_unlock</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_reset_active_list</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">delay</span>(<span class="enscript-type">int</span>);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">INTER_NOTIFICATION_DELAY</span>	(250000)	<span class="enscript-comment">/* .25 second */</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">memorystatus_on_pageout_scan_end</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-comment">/* No-op */</span>
}

<span class="enscript-comment">/*
 * kn_max - knote
 *
 * knote_pressure_level - to check if the knote is registered for this notification level.
 *
 * task	- task whose bits we'll be modifying
 *
 * pressure_level_to_clear - if the task has been notified of this past level, clear that notification bit so that if/when we revert to that level, the task will be notified again.
 *
 * pressure_level_to_set - the task is about to be notified of this new level. Update the task's bit notification information appropriately.
 *
 */</span>

boolean_t
<span class="enscript-function-name">is_knote_registered_modify_task_pressure_bits</span>(<span class="enscript-type">struct</span> knote *kn_max, <span class="enscript-type">int</span> knote_pressure_level, task_t task, vm_pressure_level_t pressure_level_to_clear, vm_pressure_level_t pressure_level_to_set)
{
	<span class="enscript-keyword">if</span> (kn_max-&gt;kn_sfflags &amp; knote_pressure_level) {

		<span class="enscript-keyword">if</span> (task_has_been_notified(task, pressure_level_to_clear) == TRUE) {

			task_clear_has_been_notified(task, pressure_level_to_clear);
		}

		task_mark_has_been_notified(task, pressure_level_to_set);
		<span class="enscript-keyword">return</span> TRUE;
	}

	<span class="enscript-keyword">return</span> FALSE;
}

<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">vm_pressure_notify_dispatch_vm_clients</span>(boolean_t target_foreground_process);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VM_PRESSURE_DECREASED_SMOOTHING_PERIOD</span>		5000	<span class="enscript-comment">/* milliseconds */</span>

kern_return_t
<span class="enscript-function-name">memorystatus_update_vm_pressure</span>(boolean_t target_foreground_process) 
{
	<span class="enscript-type">struct</span> knote			*kn_max = NULL;
	<span class="enscript-type">struct</span> knote			*kn_cur = NULL, *kn_temp = NULL;  <span class="enscript-comment">/* for safe list traversal */</span>
        pid_t				target_pid = -1;
        <span class="enscript-type">struct</span> klist			dispatch_klist = { NULL };
	proc_t				target_proc = PROC_NULL;
	<span class="enscript-type">struct</span> task			*task = NULL;
	boolean_t			found_candidate = FALSE;

	<span class="enscript-type">static</span> vm_pressure_level_t 	level_snapshot = kVMPressureNormal;
	<span class="enscript-type">static</span> vm_pressure_level_t	prev_level_snapshot = kVMPressureNormal;
	boolean_t			smoothing_window_started = FALSE;
	<span class="enscript-type">struct</span> timeval			smoothing_window_start_tstamp = {0, 0};
	<span class="enscript-type">struct</span> timeval			curr_tstamp = {0, 0};
	<span class="enscript-type">int</span>				elapsed_msecs = 0;

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_JETSAM</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_IDLE_KILLS</span> 100	<span class="enscript-comment">/* limit the number of idle kills allowed */</span>

	<span class="enscript-type">int</span>	idle_kill_counter = 0;

	<span class="enscript-comment">/*
	 * On desktop we take this opportunity to free up memory pressure
	 * by immediately killing idle exitable processes. We use a delay
	 * to avoid overkill.  And we impose a max counter as a fail safe
	 * in case daemons re-launch too fast.
	 */</span>
	<span class="enscript-keyword">while</span> ((memorystatus_vm_pressure_level != kVMPressureNormal) &amp;&amp; (idle_kill_counter &lt; MAX_IDLE_KILLS)) {
		<span class="enscript-keyword">if</span> (memorystatus_idle_exit_from_VM() == FALSE) {
			<span class="enscript-comment">/* No idle exitable processes left to kill */</span>
			<span class="enscript-keyword">break</span>;
		}
		idle_kill_counter++;

		<span class="enscript-keyword">if</span> (memorystatus_manual_testing_on == TRUE) {
			<span class="enscript-comment">/*
			 * Skip the delay when testing
			 * the pressure notification scheme.
			 */</span>
		} <span class="enscript-keyword">else</span> {
			delay(1000000);    <span class="enscript-comment">/* 1 second */</span>
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !CONFIG_JETSAM */</span>

	<span class="enscript-keyword">while</span> (1) {
	
		<span class="enscript-comment">/*
		 * There is a race window here. But it's not clear
		 * how much we benefit from having extra synchronization.
		 */</span>
		level_snapshot = memorystatus_vm_pressure_level;

		<span class="enscript-keyword">if</span> (prev_level_snapshot &gt; level_snapshot) {
			<span class="enscript-comment">/*
			 * Pressure decreased? Let's take a little breather
			 * and see if this condition stays.
			 */</span>
			<span class="enscript-keyword">if</span> (smoothing_window_started == FALSE) {

				smoothing_window_started = TRUE;
				microuptime(&amp;smoothing_window_start_tstamp);
			}

			microuptime(&amp;curr_tstamp);
			timevalsub(&amp;curr_tstamp, &amp;smoothing_window_start_tstamp);
			elapsed_msecs = curr_tstamp.tv_sec * 1000 + curr_tstamp.tv_usec / 1000;

			<span class="enscript-keyword">if</span> (elapsed_msecs &lt; VM_PRESSURE_DECREASED_SMOOTHING_PERIOD) {
			
				delay(INTER_NOTIFICATION_DELAY);
				<span class="enscript-keyword">continue</span>;
			}
		}

		prev_level_snapshot = level_snapshot;
		smoothing_window_started = FALSE;

		memorystatus_klist_lock();
		kn_max = vm_pressure_select_optimal_candidate_to_notify(&amp;memorystatus_klist, level_snapshot, target_foreground_process);

        	<span class="enscript-keyword">if</span> (kn_max == NULL) {
			memorystatus_klist_unlock();

			<span class="enscript-comment">/*
			 * No more level-based clients to notify.
			 * Try the non-level based notification clients.
			 *	
			 * However, these non-level clients don't understand
			 * the &quot;return-to-normal&quot; notification.
			 *
			 * So don't consider them for those notifications. Just
			 * return instead.
			 *
			 */</span>

			<span class="enscript-keyword">if</span> (level_snapshot != kVMPressureNormal) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">try_dispatch_vm_clients</span>;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">return</span> KERN_FAILURE;
			}	
		}
		
		target_proc = kn_max-&gt;kn_kq-&gt;kq_p;
		
		proc_list_lock();
		<span class="enscript-keyword">if</span> (target_proc != proc_ref_locked(target_proc)) {
			target_proc = PROC_NULL;
			proc_list_unlock();
			memorystatus_klist_unlock();
			<span class="enscript-keyword">continue</span>;
		}
		proc_list_unlock();
		
		target_pid = target_proc-&gt;p_pid;

		task = (<span class="enscript-type">struct</span> task *)(target_proc-&gt;task);
	
		<span class="enscript-keyword">if</span> (level_snapshot != kVMPressureNormal) {

			<span class="enscript-keyword">if</span> (level_snapshot == kVMPressureWarning || level_snapshot == kVMPressureUrgent) {

				<span class="enscript-keyword">if</span> (is_knote_registered_modify_task_pressure_bits(kn_max, NOTE_MEMORYSTATUS_PRESSURE_WARN, task, kVMPressureCritical, kVMPressureWarning) == TRUE) {
					found_candidate = TRUE;
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (level_snapshot == kVMPressureCritical) {
				
					<span class="enscript-keyword">if</span> (is_knote_registered_modify_task_pressure_bits(kn_max, NOTE_MEMORYSTATUS_PRESSURE_CRITICAL, task, kVMPressureWarning, kVMPressureCritical) == TRUE) {
						found_candidate = TRUE;
					}
				}
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (kn_max-&gt;kn_sfflags &amp; NOTE_MEMORYSTATUS_PRESSURE_NORMAL) {

				task_clear_has_been_notified(task, kVMPressureWarning);
				task_clear_has_been_notified(task, kVMPressureCritical);

				found_candidate = TRUE;
			}
		}

		<span class="enscript-keyword">if</span> (found_candidate == FALSE) {
			proc_rele(target_proc);
			memorystatus_klist_unlock();
			<span class="enscript-keyword">continue</span>;
		}

		SLIST_FOREACH_SAFE(kn_cur, &amp;memorystatus_klist, kn_selnext, kn_temp) {
			proc_t knote_proc = kn_cur-&gt;kn_kq-&gt;kq_p;
			pid_t knote_pid = knote_proc-&gt;p_pid;
			<span class="enscript-keyword">if</span> (knote_pid == target_pid) {
				KNOTE_DETACH(&amp;memorystatus_klist, kn_cur);
				KNOTE_ATTACH(&amp;dispatch_klist, kn_cur);
			}
		}

		KNOTE(&amp;dispatch_klist, (level_snapshot != kVMPressureNormal) ? kMemorystatusPressure : kMemorystatusNoPressure);

		SLIST_FOREACH_SAFE(kn_cur, &amp;dispatch_klist, kn_selnext, kn_temp) {
			KNOTE_DETACH(&amp;dispatch_klist, kn_cur);
			KNOTE_ATTACH(&amp;memorystatus_klist, kn_cur);
		}

		memorystatus_klist_unlock();

		microuptime(&amp;target_proc-&gt;vm_pressure_last_notify_tstamp);
		proc_rele(target_proc);

		<span class="enscript-keyword">if</span> (memorystatus_manual_testing_on == TRUE &amp;&amp; target_foreground_process == TRUE) {
			<span class="enscript-keyword">break</span>;
		}

<span class="enscript-reference">try_dispatch_vm_clients</span>:
		<span class="enscript-keyword">if</span> (kn_max == NULL &amp;&amp; level_snapshot != kVMPressureNormal) {
			<span class="enscript-comment">/*
			 * We will exit this loop when we are done with
			 * notification clients (level and non-level based).
			 */</span>
			<span class="enscript-keyword">if</span> ((vm_pressure_notify_dispatch_vm_clients(target_foreground_process) == KERN_FAILURE) &amp;&amp; (kn_max == NULL)) {
				<span class="enscript-comment">/*
				 * kn_max == NULL i.e. we didn't find any eligible clients for the level-based notifications
				 * AND
				 * we have failed to find any eligible clients for the non-level based notifications too.
				 * So, we are done.
				 */</span>

				<span class="enscript-keyword">return</span> KERN_FAILURE;
			}
		}

		<span class="enscript-comment">/*
		 * LD: This block of code below used to be invoked in the older memory notification scheme on embedded everytime 
		 * a process was sent a memory pressure notification. The &quot;memorystatus_klist&quot; list was used to hold these
		 * privileged listeners. But now we have moved to the newer scheme and are trying to move away from the extra
		 * notifications. So the code is here in case we break compat. and need to send out notifications to the privileged
		 * apps.
		 */</span>
#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0 */</span>

		<span class="enscript-keyword">if</span> (memorystatus_manual_testing_on == TRUE) {
			<span class="enscript-comment">/*
			 * Testing out the pressure notification scheme.
			 * No need for delays etc.
			 */</span>
		} <span class="enscript-keyword">else</span> {

			uint32_t sleep_interval = INTER_NOTIFICATION_DELAY;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> page_delta = 0;
			<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> skip_delay_page_threshold = 0;

			assert(memorystatus_available_pages_pressure &gt;= memorystatus_available_pages_critical_base);
			
			page_delta = (memorystatus_available_pages_pressure - memorystatus_available_pages_critical_base) / 2;
			skip_delay_page_threshold = memorystatus_available_pages_pressure - page_delta;

			<span class="enscript-keyword">if</span> (memorystatus_available_pages &lt;= skip_delay_page_threshold) {
				<span class="enscript-comment">/*
				 * We are nearing the critcal mark fast and can't afford to wait between
				 * notifications.
				 */</span>
				sleep_interval = 0;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>
				
			<span class="enscript-keyword">if</span> (sleep_interval) {
				delay(sleep_interval);
			}
		}
	}

	<span class="enscript-keyword">return</span> KERN_SUCCESS;
}

vm_pressure_level_t
<span class="enscript-function-name">convert_internal_pressure_level_to_dispatch_level</span>(vm_pressure_level_t);

vm_pressure_level_t
<span class="enscript-function-name">convert_internal_pressure_level_to_dispatch_level</span>(vm_pressure_level_t internal_pressure_level)
{
	vm_pressure_level_t	dispatch_level = NOTE_MEMORYSTATUS_PRESSURE_NORMAL;
	
	<span class="enscript-keyword">switch</span> (internal_pressure_level) {

		<span class="enscript-keyword">case</span> <span class="enscript-reference">kVMPressureNormal</span>:
		{
			dispatch_level = NOTE_MEMORYSTATUS_PRESSURE_NORMAL;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">kVMPressureWarning</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kVMPressureUrgent</span>:
		{
			dispatch_level = NOTE_MEMORYSTATUS_PRESSURE_WARN;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">kVMPressureCritical</span>:
		{
			dispatch_level = NOTE_MEMORYSTATUS_PRESSURE_CRITICAL;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> dispatch_level;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_memorystatus_vm_pressure_level SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>, <span class="enscript-variable-name">oidp</span>)
	vm_pressure_level_t dispatch_level = convert_internal_pressure_level_to_dispatch_level(memorystatus_vm_pressure_level);

	<span class="enscript-keyword">return</span> SYSCTL_OUT(req, &amp;dispatch_level, <span class="enscript-keyword">sizeof</span>(dispatch_level));
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span> || <span class="enscript-variable-name">DEVELOPMENT</span>

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, memorystatus_vm_pressure_level, CTLTYPE_INT|CTLFLAG_RD|CTLFLAG_LOCKED,
    0, 0, &amp;sysctl_memorystatus_vm_pressure_level, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">else</span> <span class="enscript-comment">/* DEBUG || DEVELOPMENT */</span>

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, memorystatus_vm_pressure_level, CTLTYPE_INT|CTLFLAG_RD|CTLFLAG_LOCKED|CTLFLAG_MASKED,
    0, 0, &amp;sysctl_memorystatus_vm_pressure_level, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG || DEVELOPMENT */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> memorystatus_purge_on_warning;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> memorystatus_purge_on_critical;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_memorypressure_manual_trigger SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)

	<span class="enscript-type">int</span> level = 0;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> pressure_level = 0;
	<span class="enscript-type">int</span> trigger_request = 0;
	<span class="enscript-type">int</span> force_purge;

	error = sysctl_handle_int(oidp, &amp;level, 0, req);
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr) {
		<span class="enscript-keyword">return</span> (error);
	}

	memorystatus_manual_testing_on = TRUE;

	trigger_request = (level &gt;&gt; 16) &amp; 0xFFFF;
	pressure_level = (level &amp; 0xFFFF); 

	<span class="enscript-keyword">if</span> (trigger_request &lt; TEST_LOW_MEMORY_TRIGGER_ONE ||
	    trigger_request &gt; TEST_LOW_MEMORY_PURGEABLE_TRIGGER_ALL) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">switch</span> (pressure_level) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NOTE_MEMORYSTATUS_PRESSURE_NORMAL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NOTE_MEMORYSTATUS_PRESSURE_WARN</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">NOTE_MEMORYSTATUS_PRESSURE_CRITICAL</span>:
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/*
	 * The pressure level is being set from user-space.
	 * And user-space uses the constants in sys/event.h
	 * So we translate those events to our internal levels here.
	 */</span>
	<span class="enscript-keyword">if</span> (pressure_level == NOTE_MEMORYSTATUS_PRESSURE_NORMAL) {

		memorystatus_manual_testing_level = kVMPressureNormal;
		force_purge = 0;

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pressure_level == NOTE_MEMORYSTATUS_PRESSURE_WARN) {

		memorystatus_manual_testing_level = kVMPressureWarning;
		force_purge = memorystatus_purge_on_warning;

	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pressure_level == NOTE_MEMORYSTATUS_PRESSURE_CRITICAL) {

		memorystatus_manual_testing_level = kVMPressureCritical;
		force_purge = memorystatus_purge_on_critical;
	}

	memorystatus_vm_pressure_level = memorystatus_manual_testing_level;

	<span class="enscript-comment">/* purge according to the new pressure level */</span>
	<span class="enscript-keyword">switch</span> (trigger_request) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TEST_PURGEABLE_TRIGGER_ONE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TEST_LOW_MEMORY_PURGEABLE_TRIGGER_ONE</span>:
		<span class="enscript-keyword">if</span> (force_purge == 0) {
			<span class="enscript-comment">/* no purging requested */</span>
			<span class="enscript-keyword">break</span>;
		}
		vm_purgeable_object_purge_one_unlocked(force_purge);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TEST_PURGEABLE_TRIGGER_ALL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">TEST_LOW_MEMORY_PURGEABLE_TRIGGER_ALL</span>:
		<span class="enscript-keyword">if</span> (force_purge == 0) {
			<span class="enscript-comment">/* no purging requested */</span>
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">while</span> (vm_purgeable_object_purge_one_unlocked(force_purge));
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> ((trigger_request == TEST_LOW_MEMORY_TRIGGER_ONE) ||
	    (trigger_request == TEST_LOW_MEMORY_PURGEABLE_TRIGGER_ONE)) {

		memorystatus_update_vm_pressure(TRUE);
	}

	<span class="enscript-keyword">if</span> ((trigger_request == TEST_LOW_MEMORY_TRIGGER_ALL) ||
	    (trigger_request == TEST_LOW_MEMORY_PURGEABLE_TRIGGER_ALL)) {

		<span class="enscript-keyword">while</span> (memorystatus_update_vm_pressure(FALSE) == KERN_SUCCESS) {
			<span class="enscript-keyword">continue</span>;
		}
	}
		
	<span class="enscript-keyword">if</span> (pressure_level == NOTE_MEMORYSTATUS_PRESSURE_NORMAL) {
		memorystatus_manual_testing_on = FALSE;
				
		vm_pressure_klist_lock();
		vm_reset_active_list();
		vm_pressure_klist_unlock();
	} <span class="enscript-keyword">else</span> {

		vm_pressure_klist_lock();
		vm_pressure_notification_without_levels(FALSE);
		vm_pressure_klist_unlock();
	}

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, memorypressure_manual_trigger, CTLTYPE_INT|CTLFLAG_WR|CTLFLAG_LOCKED|CTLFLAG_MASKED,
    0, 0, &amp;sysctl_memorypressure_manual_trigger, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);


<span class="enscript-type">extern</span> <span class="enscript-type">int</span> memorystatus_purge_on_warning;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> memorystatus_purge_on_urgent;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> memorystatus_purge_on_critical;

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, memorystatus_purge_on_warning, CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_purge_on_warning, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, memorystatus_purge_on_urgent, CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_purge_on_urgent, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, memorystatus_purge_on_critical, CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_LOCKED, &amp;memorystatus_purge_on_critical, 0, <span class="enscript-string">&quot;&quot;</span>);


#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* VM_PRESSURE_EVENTS */</span>

<span class="enscript-comment">/* Return both allocated and actual size, since there's a race between allocation and list compilation */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_get_priority_list</span>(memorystatus_priority_entry_t **list_ptr, size_t *buffer_size, size_t *list_size, boolean_t size_only) 
{
 	uint32_t list_count, i = 0;
	memorystatus_priority_entry_t *list_entry;
	proc_t p;

 	list_count = memorystatus_list_count;
	*list_size = <span class="enscript-keyword">sizeof</span>(memorystatus_priority_entry_t) * list_count;

	<span class="enscript-comment">/* Just a size check? */</span>
	<span class="enscript-keyword">if</span> (size_only) {
		<span class="enscript-keyword">return</span> 0;
	}
	
	<span class="enscript-comment">/* Otherwise, validate the size of the buffer */</span>
	<span class="enscript-keyword">if</span> (*buffer_size &lt; *list_size) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

 	*list_ptr = (memorystatus_priority_entry_t*)kalloc(*list_size);
	<span class="enscript-keyword">if</span> (!list_ptr) {
		<span class="enscript-keyword">return</span> ENOMEM;
	}

	memset(*list_ptr, 0, *list_size);

	*buffer_size = *list_size;
	*list_size = 0;

	list_entry = *list_ptr;

	proc_list_lock();

	p = memorystatus_get_first_proc_locked(&amp;i, TRUE);
	<span class="enscript-keyword">while</span> (p &amp;&amp; (*list_size &lt; *buffer_size)) {
		list_entry-&gt;pid = p-&gt;p_pid;
		list_entry-&gt;priority = p-&gt;p_memstat_effectivepriority;
		list_entry-&gt;user_data = p-&gt;p_memstat_userdata;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">LEGACY_HIWATER</span>

		<span class="enscript-comment">/*
		 * No need to consider P_MEMSTAT_MEMLIMIT_BACKGROUND anymore.
		 * Background limits are described via the inactive limit slots.
		 * So, here, the cached limit should always be valid.
		 */</span>

		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_memlimit &lt;= 0) {
                        task_get_phys_footprint_limit(p-&gt;task, &amp;list_entry-&gt;limit);
                } <span class="enscript-keyword">else</span> {
                        list_entry-&gt;limit = p-&gt;p_memstat_memlimit;
                }
#<span class="enscript-reference">else</span>
		task_get_phys_footprint_limit(p-&gt;task, &amp;list_entry-&gt;limit);
#<span class="enscript-reference">endif</span>
		list_entry-&gt;state = memorystatus_build_state(p);
		list_entry++;

		*list_size += <span class="enscript-keyword">sizeof</span>(memorystatus_priority_entry_t);
		
		p = memorystatus_get_next_proc_locked(&amp;i, p, TRUE);
	}
	
	proc_list_unlock();
	
	MEMORYSTATUS_DEBUG(1, <span class="enscript-string">&quot;memorystatus_get_priority_list: returning %lu for size\n&quot;</span>, (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)*list_size);
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_cmd_get_priority_list</span>(user_addr_t buffer, size_t buffer_size, int32_t *retval) {
	<span class="enscript-type">int</span> error = EINVAL;
	boolean_t size_only;
	memorystatus_priority_entry_t *list = NULL;
	size_t list_size;
	
	size_only = ((buffer == USER_ADDR_NULL) ? TRUE: FALSE);
		
	error = memorystatus_get_priority_list(&amp;list, &amp;buffer_size, &amp;list_size, size_only);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (!size_only) {
		error = copyout(list, buffer, list_size);
	}
	
	<span class="enscript-keyword">if</span> (error == 0) {
		*retval = list_size;
	}
<span class="enscript-reference">out</span>:

	<span class="enscript-keyword">if</span> (list) {
		kfree(list, buffer_size);
	}

	<span class="enscript-keyword">return</span> error;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">memorystatus_clear_errors</span>(<span class="enscript-type">void</span>)
{
	proc_t p;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i = 0;

	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_CLEAR_ERRORS) | DBG_FUNC_START, 0, 0, 0, 0, 0);
    
	proc_list_lock();
    
	p = memorystatus_get_first_proc_locked(&amp;i, TRUE);
	<span class="enscript-keyword">while</span> (p) {
		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; P_MEMSTAT_ERROR) {
			p-&gt;p_memstat_state &amp;= ~P_MEMSTAT_ERROR;
		}
		p = memorystatus_get_next_proc_locked(&amp;i, p, TRUE);
	}
	
	proc_list_unlock();

	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_CLEAR_ERRORS) | DBG_FUNC_END, 0, 0, 0, 0, 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_update_levels_locked</span>(boolean_t critical_only) {

	memorystatus_available_pages_critical = memorystatus_available_pages_critical_base;

	<span class="enscript-comment">/*
	 * If there's an entry in the first bucket, we have idle processes.
	 */</span>
	memstat_bucket_t *first_bucket = &amp;memstat_bucket[JETSAM_PRIORITY_IDLE];
	<span class="enscript-keyword">if</span> (first_bucket-&gt;count) {
		memorystatus_available_pages_critical += memorystatus_available_pages_critical_idle_offset;

		<span class="enscript-keyword">if</span> (memorystatus_available_pages_critical  &gt; memorystatus_available_pages_pressure ) {
			<span class="enscript-comment">/* 
			 * The critical threshold must never exceed the pressure threshold
			 */</span>
			memorystatus_available_pages_critical = memorystatus_available_pages_pressure;
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span> || <span class="enscript-variable-name">DEVELOPMENT</span>
	<span class="enscript-keyword">if</span> (memorystatus_jetsam_policy &amp; kPolicyDiagnoseActive) {
		memorystatus_available_pages_critical += memorystatus_jetsam_policy_offset_pages_diagnostic;

		<span class="enscript-keyword">if</span> (memorystatus_available_pages_critical &gt; memorystatus_available_pages_pressure ) {
			<span class="enscript-comment">/* 
			 * The critical threshold must never exceed the pressure threshold
			 */</span>
			memorystatus_available_pages_critical = memorystatus_available_pages_pressure;
		}
	}
#<span class="enscript-reference">endif</span>
        
	<span class="enscript-keyword">if</span> (critical_only) {
		<span class="enscript-keyword">return</span>;
	}
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">VM_PRESSURE_EVENTS</span>
	memorystatus_available_pages_pressure = (pressure_threshold_percentage / delta_percentage) * memorystatus_delta;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span> || <span class="enscript-variable-name">DEVELOPMENT</span>
	<span class="enscript-keyword">if</span> (memorystatus_jetsam_policy &amp; kPolicyDiagnoseActive) {
		memorystatus_available_pages_pressure += memorystatus_jetsam_policy_offset_pages_diagnostic;
	}
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 * Get the at_boot snapshot
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_get_at_boot_snapshot</span>(memorystatus_jetsam_snapshot_t **snapshot, size_t *snapshot_size, boolean_t size_only) {
	size_t input_size = *snapshot_size;

	<span class="enscript-comment">/*
	 * The at_boot snapshot has no entry list.
	 */</span>
	*snapshot_size = <span class="enscript-keyword">sizeof</span>(memorystatus_jetsam_snapshot_t);

	<span class="enscript-keyword">if</span> (size_only) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/*
	 * Validate the size of the snapshot buffer
	 */</span>
	<span class="enscript-keyword">if</span> (input_size &lt; *snapshot_size) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/*
	 * Update the notification_time only
	 */</span>
	memorystatus_at_boot_snapshot.notification_time = mach_absolute_time();
	*snapshot = &amp;memorystatus_at_boot_snapshot;

	MEMORYSTATUS_DEBUG(7, <span class="enscript-string">&quot;memorystatus_get_at_boot_snapshot: returned inputsize (%ld), snapshot_size(%ld), listcount(%d)\n&quot;</span>,
			   (<span class="enscript-type">long</span>)input_size, (<span class="enscript-type">long</span>)*snapshot_size, 0);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_get_on_demand_snapshot</span>(memorystatus_jetsam_snapshot_t **snapshot, size_t *snapshot_size, boolean_t size_only) {
	size_t input_size = *snapshot_size;
	uint32_t ods_list_count = memorystatus_list_count;
	memorystatus_jetsam_snapshot_t *ods = NULL;	<span class="enscript-comment">/* The on_demand snapshot buffer */</span>

	*snapshot_size = <span class="enscript-keyword">sizeof</span>(memorystatus_jetsam_snapshot_t) + (<span class="enscript-keyword">sizeof</span>(memorystatus_jetsam_snapshot_entry_t) * (ods_list_count));

	<span class="enscript-keyword">if</span> (size_only) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/*
	 * Validate the size of the snapshot buffer.
	 * This is inherently racey. May want to revisit
	 * this error condition and trim the output when
	 * it doesn't fit.
	 */</span>
	<span class="enscript-keyword">if</span> (input_size &lt; *snapshot_size) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/*
	 * Allocate and initialize a snapshot buffer.
	 */</span>
	ods = (memorystatus_jetsam_snapshot_t *)kalloc(*snapshot_size);
	<span class="enscript-keyword">if</span> (!ods) {
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	memset(ods, 0, *snapshot_size);

	proc_list_lock();
	memorystatus_init_jetsam_snapshot_locked(ods, ods_list_count);
	proc_list_unlock();

	<span class="enscript-comment">/*
	 * Return the kernel allocated, on_demand buffer.
	 * The caller of this routine will copy the data out
	 * to user space and then free the kernel allocated
	 * buffer.
	 */</span>
	*snapshot = ods;

	MEMORYSTATUS_DEBUG(7, <span class="enscript-string">&quot;memorystatus_get_on_demand_snapshot: returned inputsize (%ld), snapshot_size(%ld), listcount(%ld)\n&quot;</span>,
				   (<span class="enscript-type">long</span>)input_size, (<span class="enscript-type">long</span>)*snapshot_size, (<span class="enscript-type">long</span>)ods_list_count);
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_get_jetsam_snapshot</span>(memorystatus_jetsam_snapshot_t **snapshot, size_t *snapshot_size, boolean_t size_only) {
	size_t input_size = *snapshot_size;

	<span class="enscript-keyword">if</span> (memorystatus_jetsam_snapshot_count &gt; 0) {
		*snapshot_size = <span class="enscript-keyword">sizeof</span>(memorystatus_jetsam_snapshot_t) + (<span class="enscript-keyword">sizeof</span>(memorystatus_jetsam_snapshot_entry_t) * (memorystatus_jetsam_snapshot_count));
	} <span class="enscript-keyword">else</span> {
		*snapshot_size = 0;
	}

	<span class="enscript-keyword">if</span> (size_only) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (input_size &lt; *snapshot_size) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	*snapshot = memorystatus_jetsam_snapshot;

	MEMORYSTATUS_DEBUG(7, <span class="enscript-string">&quot;memorystatus_get_jetsam_snapshot: returned inputsize (%ld), snapshot_size(%ld), listcount(%ld)\n&quot;</span>,
				   (<span class="enscript-type">long</span>)input_size, (<span class="enscript-type">long</span>)*snapshot_size, (<span class="enscript-type">long</span>)memorystatus_jetsam_snapshot_count);

	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_cmd_get_jetsam_snapshot</span>(int32_t flags, user_addr_t buffer, size_t buffer_size, int32_t *retval) {
	<span class="enscript-type">int</span> error = EINVAL;
	boolean_t size_only;
	boolean_t is_default_snapshot = FALSE;
	boolean_t is_on_demand_snapshot = FALSE;
	boolean_t is_at_boot_snapshot = FALSE;
	memorystatus_jetsam_snapshot_t *snapshot;

	size_only = ((buffer == USER_ADDR_NULL) ? TRUE : FALSE);

	<span class="enscript-keyword">if</span> (flags == 0) {
		<span class="enscript-comment">/* Default */</span>
		is_default_snapshot = TRUE;
		error = memorystatus_get_jetsam_snapshot(&amp;snapshot, &amp;buffer_size, size_only);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (flags &amp; ~(MEMORYSTATUS_SNAPSHOT_ON_DEMAND | MEMORYSTATUS_SNAPSHOT_AT_BOOT)) {
			<span class="enscript-comment">/*
			 * Unsupported bit set in flag.
			 */</span>
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-keyword">if</span> ((flags &amp; (MEMORYSTATUS_SNAPSHOT_ON_DEMAND | MEMORYSTATUS_SNAPSHOT_AT_BOOT)) ==
		    (MEMORYSTATUS_SNAPSHOT_ON_DEMAND |	MEMORYSTATUS_SNAPSHOT_AT_BOOT)) {
			<span class="enscript-comment">/*
			 * Can't have both set at the same time.
			 */</span>
			<span class="enscript-keyword">return</span> EINVAL;
		}

		<span class="enscript-keyword">if</span> (flags &amp; MEMORYSTATUS_SNAPSHOT_ON_DEMAND) {
			is_on_demand_snapshot = TRUE;
			<span class="enscript-comment">/*
			 * When not requesting the size only, the following call will allocate
			 * an on_demand snapshot buffer, which is freed below.
			 */</span>
			error = memorystatus_get_on_demand_snapshot(&amp;snapshot, &amp;buffer_size, size_only);

		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; MEMORYSTATUS_SNAPSHOT_AT_BOOT) {
			is_at_boot_snapshot = TRUE;
			error = memorystatus_get_at_boot_snapshot(&amp;snapshot, &amp;buffer_size, size_only);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Invalid flag setting.
			 */</span>
			<span class="enscript-keyword">return</span> EINVAL;
		}
	}

	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Copy the data out to user space and clear the snapshot buffer.
	 * If working with the jetsam snapshot,
	 *	clearing the buffer means, reset the count.
	 * If working with an on_demand snapshot
	 *	clearing the buffer means, free it.
	 * If working with the at_boot snapshot
	 *	there is nothing to clear or update.
	 */</span>
	<span class="enscript-keyword">if</span> (!size_only) {
		<span class="enscript-keyword">if</span> ((error = copyout(snapshot, buffer, buffer_size)) == 0) {
			<span class="enscript-keyword">if</span> (is_default_snapshot) {
				<span class="enscript-comment">/*
				 * The jetsam snapshot is never freed, its count is simply reset.
				 */</span>
				snapshot-&gt;entry_count = memorystatus_jetsam_snapshot_count = 0;

				proc_list_lock();
				memorystatus_jetsam_snapshot_last_timestamp = 0;
				proc_list_unlock();
			}
		}

		<span class="enscript-keyword">if</span> (is_on_demand_snapshot) {
			<span class="enscript-comment">/*
			 * The on_demand snapshot is always freed,
			 * even if the copyout failed.
			 */</span>
			<span class="enscript-keyword">if</span>(snapshot) {
				kfree(snapshot, buffer_size);
			}
		}
	}

	<span class="enscript-keyword">if</span> (error == 0) {
		*retval = buffer_size;
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * 	Routine:	memorystatus_cmd_grp_set_properties
 *	Purpose:	Update properties for a group of processes.
 *
 *	Supported Properties:
 *	[priority]
 *		Move each process out of its effective priority
 *		band and into a new priority band.
 *		Maintains relative order from lowest to highest priority.
 *		In single band, maintains relative order from head to tail.
 *
 *		eg: before	[effectivepriority | pid]
 *				[18 | p101              ]
 *				[17 | p55, p67, p19     ]
 *				[12 | p103 p10          ]
 *				[ 7 | p25               ]
 *			 	[ 0 | p71, p82,         ]
 *
 *		after	[ new band | pid]
 *			[ xxx | p71, p82, p25, p103, p10, p55, p67, p19, p101]
 *
 *	Returns:  0 on success, else non-zero.
 *
 *	Caveat:   We know there is a race window regarding recycled pids.
 *		  A process could be killed before the kernel can act on it here.
 *		  If a pid cannot be found in any of the jetsam priority bands,
 *		  then we simply ignore it.  No harm.
 *		  But, if the pid has been recycled then it could be an issue.
 *		  In that scenario, we might move an unsuspecting process to the new
 *		  priority band. It's not clear how the kernel can safeguard
 *		  against this, but it would be an extremely rare case anyway.
 *		  The caller of this api might avoid such race conditions by
 *		  ensuring that the processes passed in the pid list are suspended.
 */</span>


<span class="enscript-comment">/* This internal structure can expand when we add support for more properties */</span>
<span class="enscript-type">typedef</span>	<span class="enscript-type">struct</span> memorystatus_internal_properties
{
	proc_t proc;
	int32_t priority;  <span class="enscript-comment">/* see memorytstatus_priority_entry_t : priority */</span>
} memorystatus_internal_properties_t;
	

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_cmd_grp_set_properties</span>(int32_t flags, user_addr_t buffer, size_t buffer_size, __unused int32_t *retval) {

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span> (<span class="enscript-variable-name">flags</span>)

	<span class="enscript-comment">/*
	 * We only handle setting priority
	 * per process
	 */</span>

	<span class="enscript-type">int</span> error = 0;
	memorystatus_priority_entry_t *entries = NULL;
	uint32_t entry_count = 0;

	<span class="enscript-comment">/* This will be the ordered proc list */</span>
	memorystatus_internal_properties_t *table = NULL;
	size_t table_size = 0;
	uint32_t table_count = 0;

	uint32_t i = 0;
	uint32_t bucket_index = 0;
	boolean_t head_insert;
	int32_t new_priority;
	
	proc_t p;

	<span class="enscript-comment">/* Verify inputs */</span>
	<span class="enscript-keyword">if</span> ((buffer == USER_ADDR_NULL) || (buffer_size == 0) || ((buffer_size % <span class="enscript-keyword">sizeof</span>(memorystatus_priority_entry_t)) != 0)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	entry_count = (buffer_size / <span class="enscript-keyword">sizeof</span>(memorystatus_priority_entry_t));
	<span class="enscript-keyword">if</span> ((entries = (memorystatus_priority_entry_t *)kalloc(buffer_size)) == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_GRP_SET_PROP) | DBG_FUNC_START, entry_count, 0, 0, 0, 0);

	<span class="enscript-keyword">if</span> ((error = copyin(buffer, entries, buffer_size)) != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Verify sanity of input priorities */</span>
	<span class="enscript-keyword">for</span> (i=0; i &lt; entry_count; i++) {
		<span class="enscript-keyword">if</span> (entries[i].priority == -1) {
			<span class="enscript-comment">/* Use as shorthand for default priority */</span>
			entries[i].priority = JETSAM_PRIORITY_DEFAULT;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (entries[i].priority == JETSAM_PRIORITY_IDLE_DEFERRED) {
			<span class="enscript-comment">/* JETSAM_PRIORITY_IDLE_DEFERRED is reserved for internal use;
			 * if requested, adjust to JETSAM_PRIORITY_IDLE. */</span>
			entries[i].priority = JETSAM_PRIORITY_IDLE;
	        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (entries[i].priority == JETSAM_PRIORITY_IDLE_HEAD) {
			<span class="enscript-comment">/* JETSAM_PRIORITY_IDLE_HEAD inserts at the head of the idle
			 * queue */</span>
			<span class="enscript-comment">/* Deal with this later */</span>
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((entries[i].priority &lt; 0) || (entries[i].priority &gt;= MEMSTAT_BUCKET_COUNT)) {
			<span class="enscript-comment">/* Sanity check */</span>
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	table_size = <span class="enscript-keyword">sizeof</span>(memorystatus_internal_properties_t) * entry_count;
	<span class="enscript-keyword">if</span> ( (table = (memorystatus_internal_properties_t *)kalloc(table_size)) == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	memset(table, 0, table_size);


	<span class="enscript-comment">/*
	 * For each jetsam bucket entry, spin through the input property list.
	 * When a matching pid is found, populate an adjacent table with the
	 * appropriate proc pointer and new property values.
	 * This traversal automatically preserves order from lowest
	 * to highest priority.
	 */</span>

	bucket_index=0;
	
	proc_list_lock();

	<span class="enscript-comment">/* Create the ordered table */</span>
	p = memorystatus_get_first_proc_locked(&amp;bucket_index, TRUE);	
	<span class="enscript-keyword">while</span> (p &amp;&amp; (table_count &lt; entry_count)) {
		<span class="enscript-keyword">for</span> (i=0; i &lt; entry_count; i++ ) {
			<span class="enscript-keyword">if</span> (p-&gt;p_pid == entries[i].pid) {
				<span class="enscript-comment">/* Build the table data  */</span>
				table[table_count].proc = p;
				table[table_count].priority = entries[i].priority;
				table_count++;
				<span class="enscript-keyword">break</span>;
			}
		}
		p = memorystatus_get_next_proc_locked(&amp;bucket_index, p, TRUE);
	}
	
	<span class="enscript-comment">/* We now have ordered list of procs ready to move */</span>
	<span class="enscript-keyword">for</span> (i=0; i &lt; table_count; i++) {
		p = table[i].proc;
		assert(p != NULL);

		<span class="enscript-comment">/* Allow head inserts -- but relative order is now  */</span>
		<span class="enscript-keyword">if</span> (table[i].priority == JETSAM_PRIORITY_IDLE_HEAD) {
			new_priority = JETSAM_PRIORITY_IDLE;
			head_insert = true;
		} <span class="enscript-keyword">else</span> {
			new_priority = table[i].priority;
			head_insert = false;
		}
		
		<span class="enscript-comment">/* Not allowed */</span>
		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; P_MEMSTAT_INTERNAL) {
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * Take appropriate steps if moving proc out of the
		 * JETSAM_PRIORITY_IDLE_DEFERRED band.
		 */</span>
		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_effectivepriority == JETSAM_PRIORITY_IDLE_DEFERRED) {
			memorystatus_invalidate_idle_demotion_locked(p, TRUE);
		}

		memorystatus_update_priority_locked(p, new_priority, head_insert);
	}

	proc_list_unlock();

	<span class="enscript-comment">/*
	 * if (table_count != entry_count)
	 * then some pids were not found in a jetsam band.
	 * harmless but interesting...
	 */</span>
	KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_MEMSTAT, BSD_MEMSTAT_GRP_SET_PROP) | DBG_FUNC_END, entry_count, table_count, 0, 0, 0);
	
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (entries)
		kfree(entries, buffer_size);
	<span class="enscript-keyword">if</span> (table)
		kfree(table, table_size);

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * This routine is used to update a process's jetsam priority position and stored user_data.
 * It is not used for the setting of memory limits, which is why the last 6 args to the
 * memorystatus_update() call are 0 or FALSE.
 */</span>
	
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_cmd_set_priority_properties</span>(pid_t pid, user_addr_t buffer, size_t buffer_size, __unused int32_t *retval) {
	<span class="enscript-type">int</span> error = 0;
	memorystatus_priority_properties_t mpp_entry;

	<span class="enscript-comment">/* Validate inputs */</span>
	<span class="enscript-keyword">if</span> ((pid == 0) || (buffer == USER_ADDR_NULL) || (buffer_size != <span class="enscript-keyword">sizeof</span>(memorystatus_priority_properties_t))) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	
	error = copyin(buffer, &amp;mpp_entry, buffer_size);

	<span class="enscript-keyword">if</span> (error == 0) {
		proc_t p;
                
		p = proc_find(pid);
		<span class="enscript-keyword">if</span> (!p) {
			<span class="enscript-keyword">return</span> ESRCH;
		}
		
		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; P_MEMSTAT_INTERNAL) {
			proc_rele(p);
			<span class="enscript-keyword">return</span> EPERM;
		}
	
		error = memorystatus_update(p, mpp_entry.priority, mpp_entry.user_data, FALSE, FALSE, 0, 0, FALSE, FALSE, FALSE);
		proc_rele(p);
	}
	
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_cmd_set_memlimit_properties</span>(pid_t pid, user_addr_t buffer, size_t buffer_size, __unused int32_t *retval) {
	<span class="enscript-type">int</span> error = 0;
	memorystatus_memlimit_properties_t mmp_entry;

	<span class="enscript-comment">/* Validate inputs */</span>
	<span class="enscript-keyword">if</span> ((pid == 0) || (buffer == USER_ADDR_NULL) || (buffer_size != <span class="enscript-keyword">sizeof</span>(memorystatus_memlimit_properties_t))) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	error = copyin(buffer, &amp;mmp_entry, buffer_size);

	<span class="enscript-keyword">if</span> (error == 0) {
		error = memorystatus_set_memlimit_properties(pid, &amp;mmp_entry);
	}

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * When getting the memlimit settings, we can't simply call task_get_phys_footprint_limit().
 * That gets the proc's cached memlimit and there is no guarantee that the active/inactive
 * limits will be the same in the no-limit case.  Instead we convert limits &lt;= 0 using
 * task_convert_phys_footprint_limit(). It computes the same limit value that would be written
 * to the task's ledgers via task_set_phys_footprint_limit().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_cmd_get_memlimit_properties</span>(pid_t pid, user_addr_t buffer, size_t buffer_size, __unused int32_t *retval) {
	<span class="enscript-type">int</span> error = 0;
	memorystatus_memlimit_properties_t mmp_entry;

	<span class="enscript-comment">/* Validate inputs */</span>
	<span class="enscript-keyword">if</span> ((pid == 0) || (buffer == USER_ADDR_NULL) || (buffer_size != <span class="enscript-keyword">sizeof</span>(memorystatus_memlimit_properties_t))) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	memset (&amp;mmp_entry, 0, <span class="enscript-keyword">sizeof</span>(memorystatus_memlimit_properties_t));

	proc_t p = proc_find(pid);
	<span class="enscript-keyword">if</span> (!p) {
		<span class="enscript-keyword">return</span> ESRCH;
	}

	<span class="enscript-comment">/*
	 * Get the active limit and attributes.
	 * No locks taken since we hold a reference to the proc.
	 */</span>

	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_memlimit_active &gt; 0 ) {
		mmp_entry.memlimit_active = p-&gt;p_memstat_memlimit_active;
	} <span class="enscript-keyword">else</span> {
		task_convert_phys_footprint_limit(-1, &amp;mmp_entry.memlimit_active);
	}

	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; P_MEMSTAT_MEMLIMIT_ACTIVE_FATAL) {
		mmp_entry.memlimit_active_attr |= MEMORYSTATUS_MEMLIMIT_ATTR_FATAL;
	}

	<span class="enscript-comment">/*
	 * Get the inactive limit and attributes
	 */</span>
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_memlimit_inactive &lt;= 0) {
		task_convert_phys_footprint_limit(-1, &amp;mmp_entry.memlimit_inactive);
	} <span class="enscript-keyword">else</span> {
		mmp_entry.memlimit_inactive = p-&gt;p_memstat_memlimit_inactive;
	}
	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_state &amp; P_MEMSTAT_MEMLIMIT_INACTIVE_FATAL) {
		mmp_entry.memlimit_inactive_attr |= MEMORYSTATUS_MEMLIMIT_ATTR_FATAL;
	}
	proc_rele(p);

	error = copyout(&amp;mmp_entry, buffer, buffer_size);

	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_cmd_get_pressure_status</span>(int32_t *retval) {	
	<span class="enscript-type">int</span> error;
	
	<span class="enscript-comment">/* Need privilege for check */</span>
	error = priv_check_cred(kauth_cred_get(), PRIV_VM_PRESSURE, 0);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span> (error);
	}
	
	<span class="enscript-comment">/* Inherently racy, so it's not worth taking a lock here */</span>
	*retval = (kVMPressureNormal != memorystatus_vm_pressure_level) ? 1 : 0;
	
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_get_pressure_status_kdp</span>() {
	<span class="enscript-keyword">return</span> (kVMPressureNormal != memorystatus_vm_pressure_level) ? 1 : 0;
}

<span class="enscript-comment">/*
 * Every process, including a P_MEMSTAT_INTERNAL process (currently only pid 1), is allowed to set a HWM.
 *
 * This call is inflexible -- it does not distinguish between active/inactive, fatal/non-fatal
 * So, with 2-level HWM preserving previous behavior will map as follows.
 *      - treat the limit passed in as both an active and inactive limit.
 *      - treat the is_fatal_limit flag as though it applies to both active and inactive limits.
 *
 * When invoked via MEMORYSTATUS_CMD_SET_JETSAM_HIGH_WATER_MARK
 *      - the is_fatal_limit is FALSE, meaning the active and inactive limits are non-fatal/soft
 *      - so mapping is (active/non-fatal, inactive/non-fatal)
 *
 * When invoked via MEMORYSTATUS_CMD_SET_JETSAM_TASK_LIMIT
 *      - the is_fatal_limit is TRUE, meaning the process's active and inactive limits are fatal/hard
 *      - so mapping is (active/fatal, inactive/fatal)
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_cmd_set_jetsam_memory_limit</span>(pid_t pid, int32_t high_water_mark, __unused int32_t *retval, boolean_t is_fatal_limit) {
	<span class="enscript-type">int</span> error = 0;
	memorystatus_memlimit_properties_t entry;

	entry.memlimit_active = high_water_mark;
	entry.memlimit_active_attr = 0;
	entry.memlimit_inactive = high_water_mark;
	entry.memlimit_inactive_attr = 0;

	<span class="enscript-keyword">if</span> (is_fatal_limit == TRUE) {
		entry.memlimit_active_attr   |= MEMORYSTATUS_MEMLIMIT_ATTR_FATAL;
		entry.memlimit_inactive_attr |= MEMORYSTATUS_MEMLIMIT_ATTR_FATAL;
	}

	error = memorystatus_set_memlimit_properties(pid, &amp;entry);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_set_memlimit_properties</span>(pid_t pid, memorystatus_memlimit_properties_t *entry) {

	int32_t  memlimit_active;
	boolean_t memlimit_active_is_fatal;
	int32_t  memlimit_inactive;
	boolean_t memlimit_inactive_is_fatal;
	uint32_t valid_attrs = 0;
	<span class="enscript-type">int</span>       error = 0;
        
	proc_t p = proc_find(pid);
	<span class="enscript-keyword">if</span> (!p) {
		<span class="enscript-keyword">return</span> ESRCH;
	}

	<span class="enscript-comment">/*
	 * Check for valid attribute flags.
	 */</span>
	valid_attrs |= (MEMORYSTATUS_MEMLIMIT_ATTR_FATAL);
	<span class="enscript-keyword">if</span> ((entry-&gt;memlimit_active_attr &amp; (~valid_attrs)) != 0) {
		proc_rele(p);
		<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">if</span> ((entry-&gt;memlimit_inactive_attr &amp; (~valid_attrs)) != 0) {
		proc_rele(p);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/*
	 * Setup the active memlimit properties
	 */</span>
	memlimit_active = entry-&gt;memlimit_active;
	<span class="enscript-keyword">if</span> (entry-&gt;memlimit_active_attr &amp; MEMORYSTATUS_MEMLIMIT_ATTR_FATAL) {
		memlimit_active_is_fatal = TRUE;
	} <span class="enscript-keyword">else</span> {
		memlimit_active_is_fatal = FALSE;
	}

	<span class="enscript-comment">/*
	 * Setup the inactive memlimit properties
	 */</span>
	memlimit_inactive = entry-&gt;memlimit_inactive;
	<span class="enscript-keyword">if</span> (entry-&gt;memlimit_inactive_attr &amp; MEMORYSTATUS_MEMLIMIT_ATTR_FATAL) {
		memlimit_inactive_is_fatal = TRUE;
	} <span class="enscript-keyword">else</span> {
		memlimit_inactive_is_fatal = FALSE;
	}

	<span class="enscript-comment">/*
	 * Setting a limit of &lt;= 0 implies that the process has no
	 * high-water-mark and has no per-task-limit.  That means
	 * the system_wide task limit is in place, which by the way,
	 * is always fatal.
	 */</span>

	<span class="enscript-keyword">if</span> (memlimit_active &lt;= 0) {
		<span class="enscript-comment">/*
		 * Enforce the fatal system_wide task limit while process is active.
		 */</span>
		memlimit_active = -1;
		memlimit_active_is_fatal = TRUE;
	}

	<span class="enscript-keyword">if</span> (memlimit_inactive &lt;= 0) {
		<span class="enscript-comment">/*
		 * Enforce the fatal system_wide task limit while process is inactive.
		 */</span>
		memlimit_inactive = -1;
		memlimit_inactive_is_fatal = TRUE;
	}

	proc_list_lock();

	<span class="enscript-comment">/*
	 * Store the active limit variants in the proc.
	 */</span>
	SET_ACTIVE_LIMITS_LOCKED(p, memlimit_active, memlimit_active_is_fatal);

	<span class="enscript-comment">/*
	 * Store the inactive limit variants in the proc.
	 */</span>
	SET_INACTIVE_LIMITS_LOCKED(p, memlimit_inactive, memlimit_inactive_is_fatal);

	<span class="enscript-comment">/*
	 * Enforce appropriate limit variant by updating the cached values
	 * and writing the ledger.
	 * Limit choice is based on process active/inactive state.
	 */</span>

	<span class="enscript-keyword">if</span> (memorystatus_highwater_enabled) {
		boolean_t trigger_exception;
		<span class="enscript-comment">/*
		 * No need to consider P_MEMSTAT_MEMLIMIT_BACKGROUND anymore.
		 * Background limits are described via the inactive limit slots.
		 */</span>

		<span class="enscript-keyword">if</span> (proc_jetsam_state_is_active_locked(p) == TRUE) {
			CACHE_ACTIVE_LIMITS_LOCKED(p, trigger_exception);
		} <span class="enscript-keyword">else</span> {
			CACHE_INACTIVE_LIMITS_LOCKED(p, trigger_exception);
		}

		<span class="enscript-comment">/* Enforce the limit by writing to the ledgers */</span>
		assert(trigger_exception == TRUE);
		error = (task_set_phys_footprint_limit_internal(p-&gt;task, ((p-&gt;p_memstat_memlimit &gt; 0) ? p-&gt;p_memstat_memlimit : -1), NULL, trigger_exception) == 0) ? 0 : EINVAL;

		MEMORYSTATUS_DEBUG(3, <span class="enscript-string">&quot;memorystatus_set_memlimit_properties: new limit on pid %d (%dMB %s) current priority (%d) dirty_state?=0x%x %s\n&quot;</span>,
				   p-&gt;p_pid, (p-&gt;p_memstat_memlimit &gt; 0 ? p-&gt;p_memstat_memlimit : -1),
				   (p-&gt;p_memstat_state &amp; P_MEMSTAT_FATAL_MEMLIMIT ? <span class="enscript-string">&quot;F &quot;</span> : <span class="enscript-string">&quot;NF&quot;</span>), p-&gt;p_memstat_effectivepriority, p-&gt;p_memstat_dirty,
				   (p-&gt;p_memstat_dirty ? ((p-&gt;p_memstat_dirty &amp; P_DIRTY) ? <span class="enscript-string">&quot;isdirty&quot;</span> : <span class="enscript-string">&quot;isclean&quot;</span>) : <span class="enscript-string">&quot;&quot;</span>));
	}

	proc_list_unlock();
	proc_rele(p);
	
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Returns the jetsam priority (effective or requested) of the process
 * associated with this task.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_get_memstat_priority</span>(proc_t p, boolean_t effective_priority)
{
	<span class="enscript-keyword">if</span> (p) {
		<span class="enscript-keyword">if</span> (effective_priority) {
			<span class="enscript-keyword">return</span> p-&gt;p_memstat_effectivepriority;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">return</span> p-&gt;p_memstat_requestedpriority;
		}
	}
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Description:
 *	Evaluates active vs. inactive process state.
 *	Processes that opt into dirty tracking are evaluated
 *	based on clean vs dirty state.
 *	dirty ==&gt; active
 *	clean ==&gt; inactive
 *
 *	Process that do not opt into dirty tracking are
 *	evalulated based on priority level.
 *	Foreground or above ==&gt; active
 *	Below Foreground    ==&gt; inactive
 *
 *	Return: TRUE if active
 *		False if inactive
 */</span>

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">proc_jetsam_state_is_active_locked</span>(proc_t p) {

	<span class="enscript-keyword">if</span> (p-&gt;p_memstat_dirty &amp; P_DIRTY_TRACK) {
		<span class="enscript-comment">/*
		 * process has opted into dirty tracking
		 * active state is based on dirty vs. clean
		 */</span>
		<span class="enscript-keyword">if</span> (p-&gt;p_memstat_dirty &amp; P_DIRTY_IS_DIRTY) {
			<span class="enscript-comment">/*
			 * process is dirty
			 * implies active state
			 */</span>
			<span class="enscript-keyword">return</span> TRUE;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * process is clean
			 * implies inactive state
			 */</span>
			<span class="enscript-keyword">return</span> FALSE;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (p-&gt;p_memstat_effectivepriority &gt;= JETSAM_PRIORITY_FOREGROUND) {
		<span class="enscript-comment">/*
		 * process is Foreground or higher
		 * implies active state
		 */</span>
		<span class="enscript-keyword">return</span> TRUE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * process found below Foreground
		 * implies inactive state
		 */</span>
		<span class="enscript-keyword">return</span> FALSE;
	}
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_control</span>(<span class="enscript-type">struct</span> proc *p __unused, <span class="enscript-type">struct</span> memorystatus_control_args *args, <span class="enscript-type">int</span> *ret) {
	<span class="enscript-type">int</span> error = EINVAL;

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_JETSAM</span>
	#pragma unused(ret)
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Root only for now */</span>
	<span class="enscript-keyword">if</span> (!kauth_cred_issuser(kauth_cred_get())) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
	<span class="enscript-comment">/* Sanity check */</span>
	<span class="enscript-keyword">if</span> (args-&gt;buffersize &gt; MEMORYSTATUS_BUFFERSIZE_MAX) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">switch</span> (args-&gt;command) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORYSTATUS_CMD_GET_PRIORITY_LIST</span>:
		error = memorystatus_cmd_get_priority_list(args-&gt;buffer, args-&gt;buffersize, ret);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORYSTATUS_CMD_SET_PRIORITY_PROPERTIES</span>:
		error = memorystatus_cmd_set_priority_properties(args-&gt;pid, args-&gt;buffer, args-&gt;buffersize, ret);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORYSTATUS_CMD_SET_MEMLIMIT_PROPERTIES</span>:
		error = memorystatus_cmd_set_memlimit_properties(args-&gt;pid, args-&gt;buffer, args-&gt;buffersize, ret);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORYSTATUS_CMD_GET_MEMLIMIT_PROPERTIES</span>:
		error = memorystatus_cmd_get_memlimit_properties(args-&gt;pid, args-&gt;buffer, args-&gt;buffersize, ret);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORYSTATUS_CMD_GRP_SET_PROPERTIES</span>:
		error = memorystatus_cmd_grp_set_properties((int32_t)args-&gt;flags, args-&gt;buffer, args-&gt;buffersize, ret);
		<span class="enscript-keyword">break</span>;		
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORYSTATUS_CMD_GET_JETSAM_SNAPSHOT</span>:
		error = memorystatus_cmd_get_jetsam_snapshot((int32_t)args-&gt;flags, args-&gt;buffer, args-&gt;buffersize, ret);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORYSTATUS_CMD_GET_PRESSURE_STATUS</span>:
		error = memorystatus_cmd_get_pressure_status(ret);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORYSTATUS_CMD_SET_JETSAM_HIGH_WATER_MARK</span>:
		<span class="enscript-comment">/*
		 * This call does not distinguish between active and inactive limits.
		 * Default behavior in 2-level HWM world is to set both.
		 * Non-fatal limit is also assumed for both.
		 */</span>
		error = memorystatus_cmd_set_jetsam_memory_limit(args-&gt;pid, (int32_t)args-&gt;flags, ret, FALSE);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORYSTATUS_CMD_SET_JETSAM_TASK_LIMIT</span>:
		<span class="enscript-comment">/*
		 * This call does not distinguish between active and inactive limits.
		 * Default behavior in 2-level HWM world is to set both.
		 * Fatal limit is also assumed for both.
		 */</span>
		error = memorystatus_cmd_set_jetsam_memory_limit(args-&gt;pid, (int32_t)args-&gt;flags, ret, TRUE);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-comment">/* Test commands */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORYSTATUS_CMD_TEST_JETSAM</span>:
		error = memorystatus_kill_process_sync(args-&gt;pid, kMemorystatusKilled) ? 0 : EINVAL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORYSTATUS_CMD_TEST_JETSAM_SORT</span>:
		error = memorystatus_cmd_test_jetsam_sort(args-&gt;pid, (int32_t)args-&gt;flags);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORYSTATUS_CMD_SET_JETSAM_PANIC_BITS</span>:
		error = memorystatus_cmd_set_panic_bits(args-&gt;buffer, args-&gt;buffersize);
		<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_ENABLE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MEMORYSTATUS_CMD_PRIVILEGED_LISTENER_DISABLE</span>:
		error = memorystatus_low_mem_privileged_listener(args-&gt;command);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_memorystatusattach</span>(<span class="enscript-type">struct</span> knote *kn)
{	
	kn-&gt;kn_flags |= EV_CLEAR;
	<span class="enscript-keyword">return</span> memorystatus_knote_register(kn);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_memorystatusdetach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	memorystatus_knote_unregister(kn);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_memorystatus</span>(<span class="enscript-type">struct</span> knote *kn __unused, <span class="enscript-type">long</span> hint)
{
	<span class="enscript-keyword">if</span> (hint) {
		<span class="enscript-keyword">switch</span> (hint) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kMemorystatusNoPressure</span>:
			<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_MEMORYSTATUS_PRESSURE_NORMAL) {
				kn-&gt;kn_fflags = NOTE_MEMORYSTATUS_PRESSURE_NORMAL;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kMemorystatusPressure</span>:
			<span class="enscript-keyword">if</span> (memorystatus_vm_pressure_level == kVMPressureWarning || memorystatus_vm_pressure_level == kVMPressureUrgent) {
				<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_MEMORYSTATUS_PRESSURE_WARN) {
					kn-&gt;kn_fflags = NOTE_MEMORYSTATUS_PRESSURE_WARN;
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (memorystatus_vm_pressure_level == kVMPressureCritical) {

				<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_MEMORYSTATUS_PRESSURE_CRITICAL) {
					kn-&gt;kn_fflags = NOTE_MEMORYSTATUS_PRESSURE_CRITICAL;
				}
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">kMemorystatusLowSwap</span>:
			<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_MEMORYSTATUS_LOW_SWAP) {
				kn-&gt;kn_fflags = NOTE_MEMORYSTATUS_LOW_SWAP;
			}
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}
	}
	
	<span class="enscript-keyword">return</span> (kn-&gt;kn_fflags != 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_klist_lock</span>(<span class="enscript-type">void</span>) {
	lck_mtx_lock(&amp;memorystatus_klist_mutex);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_klist_unlock</span>(<span class="enscript-type">void</span>) {
	lck_mtx_unlock(&amp;memorystatus_klist_mutex);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">memorystatus_kevent_init</span>(lck_grp_t *grp, lck_attr_t *attr) {
	lck_mtx_init(&amp;memorystatus_klist_mutex, grp, attr);
	klist_init(&amp;memorystatus_klist);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_knote_register</span>(<span class="enscript-type">struct</span> knote *kn) {
	<span class="enscript-type">int</span> error = 0;
	
	memorystatus_klist_lock();
	
	<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; (NOTE_MEMORYSTATUS_PRESSURE_NORMAL | NOTE_MEMORYSTATUS_PRESSURE_WARN | NOTE_MEMORYSTATUS_PRESSURE_CRITICAL | NOTE_MEMORYSTATUS_LOW_SWAP)) {

		KNOTE_ATTACH(&amp;memorystatus_klist, kn);

	} <span class="enscript-keyword">else</span> {	  
		error = ENOTSUP;
	}
	
	memorystatus_klist_unlock();
	
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">memorystatus_knote_unregister</span>(<span class="enscript-type">struct</span> knote *kn __unused) {	
	memorystatus_klist_lock();
	KNOTE_DETACH(&amp;memorystatus_klist, kn);
	memorystatus_klist_unlock();
}


#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span> &amp;&amp; <span class="enscript-variable-name">VM_PRESSURE_EVENTS</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">memorystatus_issue_pressure_kevent</span>(boolean_t pressured) {
	memorystatus_klist_lock();
	KNOTE(&amp;memorystatus_klist, pressured ? kMemorystatusPressure : kMemorystatusNoPressure);
	memorystatus_klist_unlock();
	<span class="enscript-keyword">return</span> TRUE;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_JETSAM &amp;&amp; VM_PRESSURE_EVENTS */</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 0 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_JETSAM</span>
<span class="enscript-comment">/* Coalition support */</span>

<span class="enscript-comment">/* sorting info for a particular priority bucket */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> memstat_sort_info {
	coalition_t	msi_coal;
	uint64_t	msi_page_count;
	pid_t		msi_pid;
	<span class="enscript-type">int</span>		msi_ntasks;
} memstat_sort_info_t;

<span class="enscript-comment">/* 
 * qsort from smallest page count to largest page count
 *
 * return &lt; 0 for a &lt; b
 *          0 for a == b
 *        &gt; 0 for a &gt; b
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">memstat_asc_cmp</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *a, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *b)
{
        <span class="enscript-type">const</span> memstat_sort_info_t *msA = (<span class="enscript-type">const</span> memstat_sort_info_t *)a;
        <span class="enscript-type">const</span> memstat_sort_info_t *msB = (<span class="enscript-type">const</span> memstat_sort_info_t *)b;

        <span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>)((uint64_t)msA-&gt;msi_page_count - (uint64_t)msB-&gt;msi_page_count);
}

<span class="enscript-comment">/*
 * Return the number of pids rearranged during this sort.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_sort_by_largest_coalition_locked</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bucket_index, <span class="enscript-type">int</span> coal_sort_order)
{
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_SORT_PIDS</span>		80
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_COAL_LEADERS</span> 	10

	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> b = bucket_index;
	<span class="enscript-type">int</span> nleaders = 0;
	<span class="enscript-type">int</span> ntasks = 0;
	proc_t p = NULL;
	coalition_t coal = COALITION_NULL;
	<span class="enscript-type">int</span> pids_moved = 0;
	<span class="enscript-type">int</span> total_pids_moved = 0;
	<span class="enscript-type">int</span> i;

	<span class="enscript-comment">/* 
	 * The system is typically under memory pressure when in this
	 * path, hence, we want to avoid dynamic memory allocation.
	 */</span>
	memstat_sort_info_t leaders[MAX_COAL_LEADERS];
	pid_t pid_list[MAX_SORT_PIDS];

	<span class="enscript-keyword">if</span> (bucket_index &gt;= MEMSTAT_BUCKET_COUNT) {
                <span class="enscript-keyword">return</span>(0);
        }

	<span class="enscript-comment">/*
	 * Clear the array that holds coalition leader information
	 */</span>
	<span class="enscript-keyword">for</span> (i=0; i &lt; MAX_COAL_LEADERS; i++) {
		leaders[i].msi_coal = COALITION_NULL;
		leaders[i].msi_page_count = 0;		<span class="enscript-comment">/* will hold total coalition page count */</span>
		leaders[i].msi_pid = 0;			<span class="enscript-comment">/* will hold coalition leader pid */</span>
		leaders[i].msi_ntasks = 0;		<span class="enscript-comment">/* will hold the number of tasks in a coalition */</span>
	}

        p = memorystatus_get_first_proc_locked(&amp;b, FALSE);
        <span class="enscript-keyword">while</span> (p) {
                <span class="enscript-keyword">if</span> (coalition_is_leader(p-&gt;task, COALITION_TYPE_JETSAM, &amp;coal)) {
			<span class="enscript-keyword">if</span> (nleaders &lt; MAX_COAL_LEADERS) {
				<span class="enscript-type">int</span> coal_ntasks = 0;
				uint64_t coal_page_count = coalition_get_page_count(coal, &amp;coal_ntasks);
				leaders[nleaders].msi_coal = coal;
				leaders[nleaders].msi_page_count = coal_page_count;
				leaders[nleaders].msi_pid = p-&gt;p_pid;    	<span class="enscript-comment">/* the coalition leader */</span>
				leaders[nleaders].msi_ntasks = coal_ntasks;
				nleaders++;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* 
				 * We've hit MAX_COAL_LEADERS meaning we can handle no more coalitions.
				 * Abandoned coalitions will linger at the tail of the priority band 
				 * when this sort session ends.
				 * TODO:  should this be an assert?
				 */</span>
				printf(<span class="enscript-string">&quot;%s: WARNING: more than %d leaders in priority band [%d]\n&quot;</span>,
				       __FUNCTION__, MAX_COAL_LEADERS, bucket_index);
				<span class="enscript-keyword">break</span>;
			}
                }
                p=memorystatus_get_next_proc_locked(&amp;b, p, FALSE);
        }

	<span class="enscript-keyword">if</span> (nleaders == 0) {
		<span class="enscript-comment">/* Nothing to sort */</span>
		<span class="enscript-keyword">return</span>(0);
	}

	<span class="enscript-comment">/* 
	 * Sort the coalition leader array, from smallest coalition page count
	 * to largest coalition page count.  When inserted in the priority bucket,
	 * smallest coalition is handled first, resulting in the last to be jetsammed.
	 */</span>
	<span class="enscript-keyword">if</span> (nleaders &gt; 1) {
		qsort(leaders, nleaders, <span class="enscript-keyword">sizeof</span>(memstat_sort_info_t), memstat_asc_cmp);
	}

#<span class="enscript-reference">if</span> 0
	<span class="enscript-keyword">for</span> (i = 0; i &lt; nleaders; i++) {
		printf(<span class="enscript-string">&quot;%s: coal_leader[%d of %d] pid[%d] pages[%llu] ntasks[%d]\n&quot;</span>,
		       __FUNCTION__, i, nleaders, leaders[i].msi_pid, leaders[i].msi_page_count,
			leaders[i].msi_ntasks);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * During coalition sorting, processes in a priority band are rearranged
	 * by being re-inserted at the head of the queue.  So, when handling a
	 * list, the first process that gets moved to the head of the queue,
	 * ultimately gets pushed toward the queue tail, and hence, jetsams last.
	 *
	 * So, for example, the coalition leader is expected to jetsam last,
	 * after its coalition members.  Therefore, the coalition leader is
	 * inserted at the head of the queue first.
	 *
	 * After processing a coalition, the jetsam order is as follows:
	 *   undefs(jetsam first), extensions, xpc services, leader(jetsam last)
	 */</span>

	<span class="enscript-comment">/*
	 * Coalition members are rearranged in the priority bucket here,
	 * based on their coalition role.
	 */</span>
	total_pids_moved = 0;
	<span class="enscript-keyword">for</span> (i=0; i &lt; nleaders; i++) {
		
		<span class="enscript-comment">/* a bit of bookkeeping */</span>
		pids_moved = 0;

		<span class="enscript-comment">/* Coalition leaders are jetsammed last, so move into place first */</span>
		pid_list[0] = leaders[i].msi_pid;
		pids_moved += memorystatus_move_list_locked(bucket_index, pid_list, 1);

		<span class="enscript-comment">/* xpc services should jetsam after extensions */</span>
		ntasks = coalition_get_pid_list (leaders[i].msi_coal, COALITION_ROLEMASK_XPC,
						 coal_sort_order, pid_list, MAX_SORT_PIDS);

		<span class="enscript-keyword">if</span> (ntasks &gt; 0) {
			pids_moved += memorystatus_move_list_locked(bucket_index, pid_list, 
								    (ntasks &lt;= MAX_SORT_PIDS ? ntasks : MAX_SORT_PIDS));
		}

		<span class="enscript-comment">/* extensions should jetsam after unmarked processes */</span>
		ntasks = coalition_get_pid_list (leaders[i].msi_coal, COALITION_ROLEMASK_EXT,
						 coal_sort_order, pid_list, MAX_SORT_PIDS);

		<span class="enscript-keyword">if</span> (ntasks &gt; 0) {
			pids_moved += memorystatus_move_list_locked(bucket_index, pid_list,
								    (ntasks &lt;= MAX_SORT_PIDS ? ntasks : MAX_SORT_PIDS));
		}

		<span class="enscript-comment">/* undefined coalition members should be the first to jetsam */</span>
		ntasks = coalition_get_pid_list (leaders[i].msi_coal, COALITION_ROLEMASK_UNDEF,
						 coal_sort_order, pid_list, MAX_SORT_PIDS);

		<span class="enscript-keyword">if</span> (ntasks &gt; 0) {
			pids_moved += memorystatus_move_list_locked(bucket_index, pid_list, 
								    (ntasks &lt;= MAX_SORT_PIDS ? ntasks : MAX_SORT_PIDS));
		}

#<span class="enscript-reference">if</span> 0
		<span class="enscript-keyword">if</span> (pids_moved == leaders[i].msi_ntasks) {
			<span class="enscript-comment">/*
			 * All the pids in the coalition were found in this band.
			 */</span>
			printf(<span class="enscript-string">&quot;%s: pids_moved[%d]  equal  total coalition ntasks[%d] \n&quot;</span>, __FUNCTION__,
			       pids_moved, leaders[i].msi_ntasks);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pids_moved &gt; leaders[i].msi_ntasks) {
			<span class="enscript-comment">/*
			 * Apparently new coalition members showed up during the sort?
			 */</span>
			printf(<span class="enscript-string">&quot;%s: pids_moved[%d] were greater than expected coalition ntasks[%d] \n&quot;</span>, __FUNCTION__,
			       pids_moved, leaders[i].msi_ntasks);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Apparently not all the pids in the coalition were found in this band?
			 */</span>
			printf(<span class="enscript-string">&quot;%s: pids_moved[%d] were less than  expected coalition ntasks[%d] \n&quot;</span>, __FUNCTION__,
			       pids_moved, leaders[i].msi_ntasks);
		}
#<span class="enscript-reference">endif</span>

		total_pids_moved += pids_moved;

	} <span class="enscript-comment">/* end for */</span>

	<span class="enscript-keyword">return</span>(total_pids_moved);
}


<span class="enscript-comment">/*
 * Traverse a list of pids, searching for each within the priority band provided.
 * If pid is found, move it to the front of the priority band.
 * Never searches outside the priority band provided.
 * 
 * Input:
 *	bucket_index - jetsam priority band.
 *	pid_list - pointer to a list of pids.
 *	list_sz  - number of pids in the list.
 *
 * Pid list ordering is important in that, 
 * pid_list[n] is expected to jetsam ahead of pid_list[n+1].
 * The sort_order is set by the coalition default.
 *
 * Return: 
 *	the number of pids found and hence moved within the priority band.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">memorystatus_move_list_locked</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> bucket_index, pid_t *pid_list, <span class="enscript-type">int</span> list_sz)
{
	memstat_bucket_t *current_bucket;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">int</span> found_pids = 0;

	<span class="enscript-keyword">if</span> ((pid_list == NULL) || (list_sz &lt;= 0)) {
		<span class="enscript-keyword">return</span>(0);
	}

	<span class="enscript-keyword">if</span> (bucket_index &gt;= MEMSTAT_BUCKET_COUNT) {
                <span class="enscript-keyword">return</span>(0);
        }

	current_bucket = &amp;memstat_bucket[bucket_index];
	<span class="enscript-keyword">for</span> (i=0; i &lt; list_sz; i++) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> b = bucket_index;
		proc_t p = NULL;
		proc_t aProc = NULL;
		pid_t  aPid;
		<span class="enscript-type">int</span> list_index;

		list_index = ((list_sz - 1) - i);
                aPid = pid_list[list_index];

                <span class="enscript-comment">/* never search beyond bucket_index provided */</span>
                p = memorystatus_get_first_proc_locked(&amp;b, FALSE);
                <span class="enscript-keyword">while</span> (p) {
                        <span class="enscript-keyword">if</span> (p-&gt;p_pid == aPid) {
                                aProc = p;
                                <span class="enscript-keyword">break</span>;
                        }
                        p = memorystatus_get_next_proc_locked(&amp;b, p, FALSE);
                }

                <span class="enscript-keyword">if</span> (aProc == NULL) {
			<span class="enscript-comment">/* pid not found in this band, just skip it */</span>
                        <span class="enscript-keyword">continue</span>;
                } <span class="enscript-keyword">else</span> {
                        TAILQ_REMOVE(&amp;current_bucket-&gt;list, aProc, p_memstat_list);
                        TAILQ_INSERT_HEAD(&amp;current_bucket-&gt;list, aProc, p_memstat_list);
			found_pids++;
                }
        }
	<span class="enscript-keyword">return</span>(found_pids);
}
#<span class="enscript-reference">endif</span>  <span class="enscript-comment">/* CONFIG_JETSAM */</span>
</pre>
<hr />
</body></html>