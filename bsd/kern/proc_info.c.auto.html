<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>proc_info.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">proc_info.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2005-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * sysctl system call.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/tty.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disklabel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/aio_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_memorystatus.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_region.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/bsdtask_info.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/msgbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/priv.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/guarded.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ipc_misc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>

<span class="enscript-comment">/* Needed by proc_pidnoteexit() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/codesign.h&gt;</span>

<span class="enscript-comment">/* Needed by proc_listcoalitions() */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_COALITIONS</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/coalition.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span> pshmnode;
<span class="enscript-type">struct</span> psemnode;
<span class="enscript-type">struct</span> pipe;
<span class="enscript-type">struct</span> kqueue;
<span class="enscript-type">struct</span> atalk;

uint64_t <span class="enscript-function-name">get_dispatchqueue_offset_from_proc</span>(<span class="enscript-type">void</span> *);
uint64_t <span class="enscript-function-name">get_dispatchqueue_serialno_offset_from_proc</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">int</span> <span class="enscript-function-name">proc_info_internal</span>(<span class="enscript-type">int</span> callnum, <span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor, uint64_t arg, user_addr_t buffer, uint32_t buffersize, int32_t * retval);

<span class="enscript-comment">/*
 * TODO: Replace the noinline attribute below.  Currently, it serves
 * to avoid stack bloat caused by inlining multiple functions that
 * have large stack footprints; when the functions are independent
 * of each other (will not both be called in any given call to the
 * caller), this only serves to bloat the stack, as we allocate
 * space for both functions, despite the fact that we only need a
 * fraction of that space.
 *
 * Long term, these functions should not be allocating everything on
 * the stack, and should move large allocations (the huge structs
 * that proc info deals in) to the heap, or eliminate them if
 * possible.
 *
 * The functions that most desperately need to improve stack usage
 * (starting with the worst offenders):
 *   proc_pidvnodepathinfo
 *   proc_pidinfo
 *   proc_pidregionpathinfo
 *   pid_vnodeinfopath
 *   pid_pshminfo
 *   pid_pseminfo
 *   pid_socketinfo
 *   proc_pid_rusage
 *   proc_pidoriginatorinfo
 */</span>

<span class="enscript-comment">/* protos for proc_info calls */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_listpids(uint32_t type, uint32_t tyoneinfo, user_addr_t buffer, uint32_t buffersize, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidinfo(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor, uint64_t arg, user_addr_t buffer, uint32_t buffersize, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidfdinfo(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor,<span class="enscript-type">int</span> fd, user_addr_t buffer, uint32_t buffersize, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_kernmsgbuf(user_addr_t buffer, uint32_t buffersize, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_setcontrol(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor, uint64_t arg, user_addr_t buffer, uint32_t buffersize, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidfileportinfo(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor, mach_port_name_t name, user_addr_t buffer, uint32_t buffersize, int32_t *retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_dirtycontrol(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor, uint64_t arg, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_terminate(<span class="enscript-type">int</span> pid, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pid_rusage(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor, user_addr_t buffer, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidoriginatorinfo(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor, user_addr_t buffer, uint32_t buffersize, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_listcoalitions(<span class="enscript-type">int</span> flavor, <span class="enscript-type">int</span> coaltype, user_addr_t buffer, uint32_t buffersize, int32_t *retval);

<span class="enscript-comment">/* protos for procpidinfo calls */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidfdlist(proc_t p, user_addr_t buffer, uint32_t buffersize, int32_t *retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidbsdinfo(proc_t p, <span class="enscript-type">struct</span> proc_bsdinfo *pbsd, <span class="enscript-type">int</span> zombie);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidshortbsdinfo(proc_t p, <span class="enscript-type">struct</span> proc_bsdshortinfo *pbsd_shortp, <span class="enscript-type">int</span> zombie);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidtaskinfo(proc_t p, <span class="enscript-type">struct</span> proc_taskinfo *ptinfo);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidthreadinfo(proc_t p, uint64_t arg,  <span class="enscript-type">int</span> thuniqueid, <span class="enscript-type">struct</span> proc_threadinfo *pthinfo);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidthreadpathinfo(proc_t p, uint64_t arg,  <span class="enscript-type">struct</span> proc_threadwithpathinfo *pinfo);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidlistthreads(proc_t p,  user_addr_t buffer, uint32_t buffersize, int32_t *retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidregioninfo(proc_t p, uint64_t arg, user_addr_t buffer, uint32_t buffersize, int32_t *retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidregionpathinfo(proc_t p,  uint64_t arg, user_addr_t buffer, uint32_t buffersize, int32_t *retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidregionpathinfo2(proc_t p,  uint64_t arg, user_addr_t buffer, uint32_t buffersize, int32_t *retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidregionpathinfo3(proc_t p,  uint64_t arg, user_addr_t buffer, uint32_t buffersize, int32_t *retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidvnodepathinfo(proc_t p,  uint64_t arg, user_addr_t buffer, uint32_t buffersize, int32_t *retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidpathinfo(proc_t p, uint64_t arg, user_addr_t buffer, uint32_t buffersize, int32_t *retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidworkqueueinfo(proc_t p, <span class="enscript-type">struct</span> proc_workqueueinfo *pwqinfo);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidfileportlist(proc_t p, user_addr_t buffer, uint32_t buffersize, int32_t *retval);
<span class="enscript-type">void</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_piduniqidentifierinfo(proc_t p, <span class="enscript-type">struct</span> proc_uniqidentifierinfo *p_uniqidinfo);
<span class="enscript-type">void</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_archinfo(proc_t p, <span class="enscript-type">struct</span> proc_archinfo *pai);
<span class="enscript-type">void</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidcoalitioninfo(proc_t p, <span class="enscript-type">struct</span> proc_pidcoalitioninfo *pci);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidnoteexit(proc_t p, uint64_t arg,  uint32_t *data);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) proc_pidoriginatorpid_uuid(uuid_t uuid, uint32_t buffersize, pid_t *pid);


<span class="enscript-comment">/* protos for proc_pidfdinfo calls */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) pid_vnodeinfo(vnode_t vp, uint32_t vid, <span class="enscript-type">struct</span> fileproc * fp,proc_t proc, <span class="enscript-type">int</span> fd, user_addr_t  buffer, uint32_t buffersize, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) pid_vnodeinfopath(vnode_t vp, uint32_t vid, <span class="enscript-type">struct</span> fileproc * fp,proc_t proc, <span class="enscript-type">int</span> fd, user_addr_t  buffer, uint32_t buffersize, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) pid_socketinfo(socket_t  so, <span class="enscript-type">struct</span> fileproc *fp,proc_t proc, <span class="enscript-type">int</span> fd, user_addr_t  buffer, uint32_t buffersize, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) pid_pseminfo(<span class="enscript-type">struct</span> psemnode * psem, <span class="enscript-type">struct</span> fileproc * fp, proc_t proc, <span class="enscript-type">int</span> fd, user_addr_t  buffer, uint32_t buffersize, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) pid_pshminfo(<span class="enscript-type">struct</span> pshmnode * pshm, <span class="enscript-type">struct</span> fileproc * fp, proc_t proc, <span class="enscript-type">int</span> fd, user_addr_t  buffer, uint32_t buffersize, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) pid_pipeinfo(<span class="enscript-type">struct</span> pipe * p, <span class="enscript-type">struct</span> fileproc * fp, proc_t proc, <span class="enscript-type">int</span> fd, user_addr_t  buffer, uint32_t buffersize, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) pid_kqueueinfo(<span class="enscript-type">struct</span> kqueue * kq, <span class="enscript-type">struct</span> fileproc * fp, proc_t proc, <span class="enscript-type">int</span> fd, user_addr_t  buffer, uint32_t buffersize, int32_t * retval);
<span class="enscript-type">int</span> <span class="enscript-function-name">__attribute__</span> ((noinline)) pid_atalkinfo(<span class="enscript-type">struct</span> atalk  * at, <span class="enscript-type">struct</span> fileproc * fp, proc_t proc, <span class="enscript-type">int</span> fd, user_addr_t  buffer, uint32_t buffersize, int32_t * retval);


<span class="enscript-comment">/* protos for misc */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">fill_vnodeinfo</span>(vnode_t vp, <span class="enscript-type">struct</span> vnode_info *vinfo);
<span class="enscript-type">void</span>  <span class="enscript-function-name">fill_fileinfo</span>(<span class="enscript-type">struct</span> fileproc * fp, proc_t proc, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> proc_fileinfo * finfo);
<span class="enscript-type">int</span> <span class="enscript-function-name">proc_security_policy</span>(proc_t targetp, <span class="enscript-type">int</span> callnum, <span class="enscript-type">int</span> flavor, boolean_t check_same_user);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">munge_vinfo_stat</span>(<span class="enscript-type">struct</span> stat64 *sbp, <span class="enscript-type">struct</span> vinfo_stat *vsbp);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_piduuidinfo</span>(pid_t pid, uuid_t uuid_buf, uint32_t buffersize);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cansignal</span>(<span class="enscript-type">struct</span> proc *, kauth_cred_t, <span class="enscript-type">struct</span> proc *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_get_rusage</span>(proc_t proc, <span class="enscript-type">int</span> flavor, user_addr_t buffer, <span class="enscript-type">int</span> is_zombie);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CHECK_SAME_USER</span>         TRUE
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NO_CHECK_SAME_USER</span>      FALSE

uint64_t <span class="enscript-function-name">get_dispatchqueue_offset_from_proc</span>(<span class="enscript-type">void</span> *p)
{
	<span class="enscript-keyword">if</span>(p != NULL) {
		proc_t pself = (proc_t)p;
		<span class="enscript-keyword">return</span> (pself-&gt;p_dispatchqueue_offset);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> (uint64_t)0;
	}
}

uint64_t <span class="enscript-function-name">get_dispatchqueue_serialno_offset_from_proc</span>(<span class="enscript-type">void</span> *p)
{
	<span class="enscript-keyword">if</span>(p != NULL) {
		proc_t pself = (proc_t)p;
		<span class="enscript-keyword">return</span> (pself-&gt;p_dispatchqueue_serialno_offset);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> (uint64_t)0;
	}
}

<span class="enscript-comment">/***************************** proc_info ********************/</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_info</span>(__unused <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> proc_info_args * uap, int32_t *retval)
{
	<span class="enscript-keyword">return</span>(proc_info_internal(uap-&gt;callnum, uap-&gt;pid, uap-&gt;flavor, uap-&gt;arg, uap-&gt;buffer, uap-&gt;buffersize, retval));
}


<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_info_internal</span>(<span class="enscript-type">int</span> callnum, <span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor, uint64_t arg, user_addr_t buffer, uint32_t  buffersize, int32_t * retval)
{

	<span class="enscript-keyword">switch</span>(callnum) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_INFO_CALL_LISTPIDS</span>:
			<span class="enscript-comment">/* pid contains type and flavor contains typeinfo */</span>
			<span class="enscript-keyword">return</span>(proc_listpids(pid, flavor, buffer, buffersize, retval));
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_INFO_CALL_PIDINFO</span>:
			<span class="enscript-keyword">return</span>(proc_pidinfo(pid, flavor, arg, buffer, buffersize, retval));
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_INFO_CALL_PIDFDINFO</span>:
			<span class="enscript-keyword">return</span>(proc_pidfdinfo(pid, flavor, (<span class="enscript-type">int</span>)arg, buffer, buffersize, retval));
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_INFO_CALL_KERNMSGBUF</span>:
			<span class="enscript-keyword">return</span>(proc_kernmsgbuf(buffer, buffersize, retval));
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_INFO_CALL_SETCONTROL</span>:
			<span class="enscript-keyword">return</span>(proc_setcontrol(pid, flavor, arg, buffer, buffersize, retval));
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_INFO_CALL_PIDFILEPORTINFO</span>:
			<span class="enscript-keyword">return</span>(proc_pidfileportinfo(pid, flavor, (mach_port_name_t)arg, buffer, buffersize, retval));
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_INFO_CALL_TERMINATE</span>:
			<span class="enscript-keyword">return</span>(proc_terminate(pid, retval));
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_INFO_CALL_DIRTYCONTROL</span>:
			<span class="enscript-keyword">return</span>(proc_dirtycontrol(pid, flavor, arg, retval));
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_INFO_CALL_PIDRUSAGE</span>:
			<span class="enscript-keyword">return</span> (proc_pid_rusage(pid, flavor, buffer, retval));
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_INFO_CALL_PIDORIGINATORINFO</span>:
			<span class="enscript-keyword">return</span> (proc_pidoriginatorinfo(pid, flavor, buffer, buffersize, retval));
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_INFO_CALL_LISTCOALITIONS</span>:
			<span class="enscript-keyword">return</span> proc_listcoalitions(pid <span class="enscript-comment">/* flavor */</span>, flavor <span class="enscript-comment">/* coaltype */</span>, buffer,
						   buffersize, retval);
		<span class="enscript-reference">default</span>:
				<span class="enscript-keyword">return</span>(EINVAL);
	}

	<span class="enscript-keyword">return</span>(EINVAL);
}

<span class="enscript-comment">/******************* proc_listpids routine ****************/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_listpids</span>(uint32_t type, uint32_t typeinfo, user_addr_t buffer, uint32_t  buffersize, int32_t * retval)
{
	<span class="enscript-type">int</span> numprocs, wantpids;
	<span class="enscript-type">char</span> * kbuf;
	<span class="enscript-type">int</span> * ptr;
	<span class="enscript-type">int</span> n, skip;
	<span class="enscript-type">struct</span> proc * p;
	<span class="enscript-type">struct</span> tty * tp;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> proclist *current_list;

	<span class="enscript-comment">/* Do we have permission to look into this? */</span>
	<span class="enscript-keyword">if</span> ((error = proc_security_policy(PROC_NULL, PROC_INFO_CALL_LISTPIDS, type, NO_CHECK_SAME_USER)))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/* if the buffer is null, return num of procs */</span>
	<span class="enscript-keyword">if</span> (buffer == (user_addr_t)0) {
		*retval = ((nprocs+20) * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
		<span class="enscript-keyword">return</span>(0);
	}

	<span class="enscript-keyword">if</span> (buffersize &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)) {
		<span class="enscript-keyword">return</span>(ENOMEM);
	}
	wantpids = buffersize/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>);
	numprocs = nprocs+20;
	<span class="enscript-keyword">if</span> (numprocs &gt; wantpids)
		numprocs = wantpids;

	kbuf = (<span class="enscript-type">char</span> *)kalloc((vm_size_t)(numprocs * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)));
	<span class="enscript-keyword">if</span> (kbuf == NULL)
		<span class="enscript-keyword">return</span>(ENOMEM);
	bzero(kbuf, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));

	proc_list_lock();

	
	n = 0;
	ptr = (<span class="enscript-type">int</span> *)kbuf;
	current_list = &amp;allproc;
<span class="enscript-reference">proc_loop</span>:
	LIST_FOREACH(p, current_list, p_list) {
		skip = 0;
		<span class="enscript-keyword">switch</span> (type) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PGRP_ONLY</span>:
				<span class="enscript-keyword">if</span> (p-&gt;p_pgrpid != (pid_t)typeinfo)
					skip = 1;
			  	<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PPID_ONLY</span>:
				<span class="enscript-keyword">if</span> ((p-&gt;p_ppid != (pid_t)typeinfo) &amp;&amp; (((p-&gt;p_lflag &amp; P_LTRACED) == 0) || (p-&gt;p_oppid != (pid_t)typeinfo)))
					skip = 1;
			  	<span class="enscript-keyword">break</span>;

			<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_ALL_PIDS</span>:
				skip = 0;
			  	<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_TTY_ONLY</span>:
				<span class="enscript-comment">/* racy but list lock is held */</span>
				<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_CONTROLT) == 0 ||
					(p-&gt;p_pgrp == NULL) || (p-&gt;p_pgrp-&gt;pg_session == NULL) ||
			    	(tp = SESSION_TP(p-&gt;p_pgrp-&gt;pg_session)) == TTY_NULL ||
			    	tp-&gt;t_dev != (dev_t)typeinfo)
					skip = 1;
			  	<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_UID_ONLY</span>:
				<span class="enscript-keyword">if</span> (p-&gt;p_ucred == NULL)
					skip = 1;
				<span class="enscript-keyword">else</span> {
					kauth_cred_t my_cred;
					uid_t uid;
			
					my_cred = kauth_cred_proc_ref(p);
					uid = kauth_cred_getuid(my_cred);
					kauth_cred_unref(&amp;my_cred);
					<span class="enscript-keyword">if</span> (uid != (uid_t)typeinfo)
						skip = 1;
				}
			  	<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_RUID_ONLY</span>:
				<span class="enscript-keyword">if</span> (p-&gt;p_ucred == NULL)
					skip = 1;
				<span class="enscript-keyword">else</span> {
					kauth_cred_t my_cred;
					uid_t uid;
			
					my_cred = kauth_cred_proc_ref(p);
					uid = kauth_cred_getruid(my_cred);
					kauth_cred_unref(&amp;my_cred);
					<span class="enscript-keyword">if</span> (uid != (uid_t)typeinfo)
						skip = 1;
				}
			  	<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
			  skip = 1;
			  <span class="enscript-keyword">break</span>;
		};

		<span class="enscript-keyword">if</span>(skip == 0) {
			*ptr++ = p-&gt;p_pid;
			n++;
		}
		<span class="enscript-keyword">if</span> (n &gt;= numprocs)
			<span class="enscript-keyword">break</span>;
	}
	
	<span class="enscript-keyword">if</span> ((n &lt; numprocs) &amp;&amp; (current_list == &amp;allproc)) {
		current_list = &amp;zombproc;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">proc_loop</span>;
	}

	proc_list_unlock();

	ptr = (<span class="enscript-type">int</span> *)kbuf;
	error = copyout((caddr_t)ptr, buffer, n * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
	<span class="enscript-keyword">if</span> (error == 0)
		*retval = (n * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
	kfree((<span class="enscript-type">void</span> *)kbuf, (vm_size_t)(numprocs * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)));

	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/********************************** proc_pidfdlist routines ********************************/</span>

<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_pidfdlist</span>(proc_t p, user_addr_t buffer, uint32_t  buffersize, int32_t *retval)
{
		<span class="enscript-type">int</span> numfds, needfds;
		<span class="enscript-type">char</span> * kbuf;
		<span class="enscript-type">struct</span> proc_fdinfo * pfd;
		<span class="enscript-type">struct</span> fileproc * fp;
		<span class="enscript-type">int</span> n;
		<span class="enscript-type">int</span> count = 0;
		<span class="enscript-type">int</span> error = 0;
		
	 	numfds = p-&gt;p_fd-&gt;fd_nfiles;	

		<span class="enscript-keyword">if</span> (buffer == (user_addr_t) 0) {
			numfds += 20;
			*retval = (numfds * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_fdinfo));
			<span class="enscript-keyword">return</span>(0);
		}

		<span class="enscript-comment">/* buffersize is big enough atleast for one struct */</span>
		needfds = buffersize/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_fdinfo);

		<span class="enscript-keyword">if</span> (numfds &gt; needfds)
			numfds = needfds;

		kbuf = (<span class="enscript-type">char</span> *)kalloc((vm_size_t)(numfds * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_fdinfo)));
		<span class="enscript-keyword">if</span> (kbuf == NULL)
			<span class="enscript-keyword">return</span>(ENOMEM);
		bzero(kbuf, numfds * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_fdinfo));

		proc_fdlock(p);

		pfd = (<span class="enscript-type">struct</span> proc_fdinfo *)kbuf;

		<span class="enscript-keyword">for</span> (n = 0; ((n &lt; numfds) &amp;&amp; (n &lt; p-&gt;p_fd-&gt;fd_nfiles)); n++) {
			<span class="enscript-keyword">if</span> (((fp = p-&gt;p_fd-&gt;fd_ofiles[n]) != 0) 
			     &amp;&amp; ((p-&gt;p_fd-&gt;fd_ofileflags[n] &amp; UF_RESERVED) == 0)) {
				file_type_t fdtype = FILEGLOB_DTYPE(fp-&gt;f_fglob);
				pfd-&gt;proc_fd = n;
				pfd-&gt;proc_fdtype = (fdtype != DTYPE_ATALK) ?
					fdtype : PROX_FDTYPE_ATALK;
				count++;
				pfd++;
			}
		}
		proc_fdunlock(p);

		error = copyout(kbuf, buffer, count * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_fdinfo));
		kfree((<span class="enscript-type">void</span> *)kbuf, (vm_size_t)(numfds * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_fdinfo)));
		<span class="enscript-keyword">if</span> (error == 0)
			*retval = (count * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_fdinfo));
		<span class="enscript-keyword">return</span>(error);		
}

<span class="enscript-comment">/*
 * Helper functions for proc_pidfileportlist.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">proc_fileport_count</span>(__unused mach_port_name_t name,
    __unused <span class="enscript-type">struct</span> fileglob *fg, <span class="enscript-type">void</span> *arg)
{
	uint32_t *counter = arg;

	*counter += 1;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">struct</span> fileport_fdtype_args {
	<span class="enscript-type">struct</span> proc_fileportinfo *ffa_pfi;
	<span class="enscript-type">struct</span> proc_fileportinfo *ffa_pfi_end;
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">proc_fileport_fdtype</span>(mach_port_name_t name, <span class="enscript-type">struct</span> fileglob *fg, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> fileport_fdtype_args *ffa = arg;

	<span class="enscript-keyword">if</span> (ffa-&gt;ffa_pfi != ffa-&gt;ffa_pfi_end) {
		file_type_t fdtype = FILEGLOB_DTYPE(fg);

		ffa-&gt;ffa_pfi-&gt;proc_fdtype = (fdtype != DTYPE_ATALK) ?
			fdtype : PROX_FDTYPE_ATALK;
		ffa-&gt;ffa_pfi-&gt;proc_fileport = name;
		ffa-&gt;ffa_pfi++;
		<span class="enscript-keyword">return</span> (0);		<span class="enscript-comment">/* keep walking */</span>
	} <span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> (-1);		<span class="enscript-comment">/* stop the walk! */</span>
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_pidfileportlist</span>(proc_t p,
	user_addr_t buffer, uint32_t buffersize, int32_t *retval)
{
	<span class="enscript-type">void</span> *kbuf;
	vm_size_t kbufsize;
	<span class="enscript-type">struct</span> proc_fileportinfo *pfi;
	uint32_t needfileports, numfileports;
	<span class="enscript-type">struct</span> fileport_fdtype_args ffa;
	<span class="enscript-type">int</span> error;

	needfileports = buffersize / <span class="enscript-keyword">sizeof</span> (*pfi);
	<span class="enscript-keyword">if</span> ((user_addr_t)0 == buffer || needfileports &gt; (uint32_t)maxfiles) {
		<span class="enscript-comment">/*
		 * Either (i) the user is asking for a fileport count,
		 * or (ii) the number of fileports they're asking for is
		 * larger than the maximum number of open files (!); count
		 * them to bound subsequent heap allocations.
		 */</span>
		numfileports = 0;
		<span class="enscript-keyword">switch</span> (fileport_walk(p-&gt;task,
		    proc_fileport_count, &amp;numfileports)) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SUCCESS</span>:
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_RESOURCE_SHORTAGE</span>:
			<span class="enscript-keyword">return</span> (ENOMEM);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_INVALID_TASK</span>:
			<span class="enscript-keyword">return</span> (ESRCH);
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span> (EINVAL);
		}

		<span class="enscript-keyword">if</span> (numfileports == 0) {
			*retval = 0;		<span class="enscript-comment">/* none at all, bail */</span>
			<span class="enscript-keyword">return</span> (0);
		}
		<span class="enscript-keyword">if</span> ((user_addr_t)0 == buffer) {
			numfileports += 20;	<span class="enscript-comment">/* accelerate convergence */</span>
			*retval = numfileports * <span class="enscript-keyword">sizeof</span> (*pfi);
			<span class="enscript-keyword">return</span> (0);
		}
		<span class="enscript-keyword">if</span> (needfileports &gt; numfileports)
			needfileports = numfileports;
	}

	assert(buffersize &gt;= PROC_PIDLISTFILEPORTS_SIZE);

	kbufsize = (vm_size_t)needfileports * <span class="enscript-keyword">sizeof</span> (*pfi);
	pfi = kbuf = kalloc(kbufsize);
	<span class="enscript-keyword">if</span> (kbuf == NULL)
	   	<span class="enscript-keyword">return</span> (ENOMEM);
	bzero(kbuf, kbufsize);

	ffa.ffa_pfi = pfi;
	ffa.ffa_pfi_end = pfi + needfileports;

	<span class="enscript-keyword">switch</span> (fileport_walk(p-&gt;task, proc_fileport_fdtype, &amp;ffa)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SUCCESS</span>:
		error = 0;
		pfi = ffa.ffa_pfi;
		<span class="enscript-keyword">if</span> ((numfileports = pfi - (typeof(pfi))kbuf) == 0)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (numfileports &gt; needfileports)
			panic(<span class="enscript-string">&quot;more fileports returned than requested&quot;</span>);
		error = copyout(kbuf, buffer, numfileports * <span class="enscript-keyword">sizeof</span> (*pfi));
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_RESOURCE_SHORTAGE</span>:
		error = ENOMEM;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_INVALID_TASK</span>:
		error = ESRCH;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}
	kfree(kbuf, kbufsize);
	<span class="enscript-keyword">if</span> (error == 0)
		*retval = numfileports * <span class="enscript-keyword">sizeof</span> (*pfi);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_pidbsdinfo</span>(proc_t p, <span class="enscript-type">struct</span> proc_bsdinfo * pbsd, <span class="enscript-type">int</span> zombie)
{
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> tty *tp;
	<span class="enscript-type">struct</span>  session *sessionp = NULL;
	<span class="enscript-type">struct</span> pgrp * pg;
	kauth_cred_t my_cred;

	pg = proc_pgrp(p);
	sessionp = proc_session(p);

	my_cred = kauth_cred_proc_ref(p);
	bzero(pbsd, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_bsdinfo));
	pbsd-&gt;pbi_status = p-&gt;p_stat;
	pbsd-&gt;pbi_xstatus = p-&gt;p_xstat;
	pbsd-&gt;pbi_pid = p-&gt;p_pid;
	pbsd-&gt;pbi_ppid = p-&gt;p_ppid;
	pbsd-&gt;pbi_uid = kauth_cred_getuid(my_cred);
	pbsd-&gt;pbi_gid = kauth_cred_getgid(my_cred); 
	pbsd-&gt;pbi_ruid =  kauth_cred_getruid(my_cred);
	pbsd-&gt;pbi_rgid = kauth_cred_getrgid(my_cred);
	pbsd-&gt;pbi_svuid =  kauth_cred_getsvuid(my_cred);
	pbsd-&gt;pbi_svgid = kauth_cred_getsvgid(my_cred);
	kauth_cred_unref(&amp;my_cred);
	
	pbsd-&gt;pbi_nice = p-&gt;p_nice;
	pbsd-&gt;pbi_start_tvsec = p-&gt;p_start.tv_sec;
	pbsd-&gt;pbi_start_tvusec = p-&gt;p_start.tv_usec;
	bcopy(&amp;p-&gt;p_comm, &amp;pbsd-&gt;pbi_comm[0], MAXCOMLEN);
	pbsd-&gt;pbi_comm[MAXCOMLEN - 1] = <span class="enscript-string">'\0'</span>;
	bcopy(&amp;p-&gt;p_name, &amp;pbsd-&gt;pbi_name[0], 2*MAXCOMLEN);
	pbsd-&gt;pbi_name[(2*MAXCOMLEN) - 1] = <span class="enscript-string">'\0'</span>;

	pbsd-&gt;pbi_flags = 0;	
	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_SYSTEM) == P_SYSTEM) 
		pbsd-&gt;pbi_flags |= PROC_FLAG_SYSTEM;
	<span class="enscript-keyword">if</span> ((p-&gt;p_lflag &amp; P_LTRACED) == P_LTRACED) 
		pbsd-&gt;pbi_flags |= PROC_FLAG_TRACED;
	<span class="enscript-keyword">if</span> ((p-&gt;p_lflag &amp; P_LEXIT) == P_LEXIT) 
		pbsd-&gt;pbi_flags |= PROC_FLAG_INEXIT;
	<span class="enscript-keyword">if</span> ((p-&gt;p_lflag &amp; P_LPPWAIT) == P_LPPWAIT) 
		pbsd-&gt;pbi_flags |= PROC_FLAG_PPWAIT;
	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_LP64) == P_LP64) 
		pbsd-&gt;pbi_flags |= PROC_FLAG_LP64;
	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_CONTROLT) == P_CONTROLT) 
		pbsd-&gt;pbi_flags |= PROC_FLAG_CONTROLT;
	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_THCWD) == P_THCWD) 
		pbsd-&gt;pbi_flags |= PROC_FLAG_THCWD;
	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_SUGID) == P_SUGID) 
		pbsd-&gt;pbi_flags |= PROC_FLAG_PSUGID;
	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_EXEC) == P_EXEC) 
		pbsd-&gt;pbi_flags |= PROC_FLAG_EXEC;

	<span class="enscript-keyword">if</span> (sessionp != SESSION_NULL) {
		<span class="enscript-keyword">if</span> (SESS_LEADER(p, sessionp))
			pbsd-&gt;pbi_flags |= PROC_FLAG_SLEADER;
		<span class="enscript-keyword">if</span> (sessionp-&gt;s_ttyvp)
			pbsd-&gt;pbi_flags |= PROC_FLAG_CTTY;
	}

	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_DELAYIDLESLEEP) == P_DELAYIDLESLEEP) 
		pbsd-&gt;pbi_flags |= PROC_FLAG_DELAYIDLESLEEP;

	<span class="enscript-keyword">switch</span>(PROC_CONTROL_STATE(p)) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">P_PCTHROTTLE</span>:
			pbsd-&gt;pbi_flags |= PROC_FLAG_PC_THROTTLE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">P_PCSUSP</span>:
			pbsd-&gt;pbi_flags |= PROC_FLAG_PC_SUSP;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">P_PCKILL</span>:
			pbsd-&gt;pbi_flags |= PROC_FLAG_PC_KILL;
			<span class="enscript-keyword">break</span>;
	};

	<span class="enscript-keyword">switch</span>(PROC_ACTION_STATE(p)) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">P_PCTHROTTLE</span>:
			pbsd-&gt;pbi_flags |= PROC_FLAG_PA_THROTTLE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">P_PCSUSP</span>:
			pbsd-&gt;pbi_flags |= PROC_FLAG_PA_SUSP;
			<span class="enscript-keyword">break</span>;
	};
		
	<span class="enscript-comment">/* if process is a zombie skip bg state */</span>
	<span class="enscript-keyword">if</span> ((zombie == 0) &amp;&amp; (p-&gt;p_stat != SZOMB) &amp;&amp; (p-&gt;task != TASK_NULL))
		proc_get_darwinbgstate(p-&gt;task, &amp;pbsd-&gt;pbi_flags);

	<span class="enscript-keyword">if</span> (zombie == 0)
		pbsd-&gt;pbi_nfiles = p-&gt;p_fd-&gt;fd_nfiles;
	
	pbsd-&gt;e_tdev = NODEV;
	<span class="enscript-keyword">if</span> (pg != PGRP_NULL) {
		pbsd-&gt;pbi_pgid = p-&gt;p_pgrpid;
		pbsd-&gt;pbi_pjobc = pg-&gt;pg_jobc;
		<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_CONTROLT) &amp;&amp; (sessionp != SESSION_NULL) &amp;&amp; (tp = SESSION_TP(sessionp))) {
			pbsd-&gt;e_tdev = tp-&gt;t_dev;
			pbsd-&gt;e_tpgid = sessionp-&gt;s_ttypgrpid;
		}
	} 
	<span class="enscript-keyword">if</span> (sessionp != SESSION_NULL)
		session_rele(sessionp);
	<span class="enscript-keyword">if</span> (pg != PGRP_NULL)
		pg_rele(pg);

	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_pidshortbsdinfo</span>(proc_t p, <span class="enscript-type">struct</span> proc_bsdshortinfo * pbsd_shortp, <span class="enscript-type">int</span> zombie)
{
	bzero(pbsd_shortp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_bsdshortinfo));
	pbsd_shortp-&gt;pbsi_pid = p-&gt;p_pid;
	pbsd_shortp-&gt;pbsi_ppid = p-&gt;p_ppid;
	pbsd_shortp-&gt;pbsi_pgid = p-&gt;p_pgrpid;
	pbsd_shortp-&gt;pbsi_status = p-&gt;p_stat;
	bcopy(&amp;p-&gt;p_comm, &amp;pbsd_shortp-&gt;pbsi_comm[0], MAXCOMLEN);
	pbsd_shortp-&gt;pbsi_comm[MAXCOMLEN - 1] = <span class="enscript-string">'\0'</span>;

	pbsd_shortp-&gt;pbsi_flags = 0;	
	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_SYSTEM) == P_SYSTEM) 
		pbsd_shortp-&gt;pbsi_flags |= PROC_FLAG_SYSTEM;
	<span class="enscript-keyword">if</span> ((p-&gt;p_lflag &amp; P_LTRACED) == P_LTRACED) 
		pbsd_shortp-&gt;pbsi_flags |= PROC_FLAG_TRACED;
	<span class="enscript-keyword">if</span> ((p-&gt;p_lflag &amp; P_LEXIT) == P_LEXIT) 
		pbsd_shortp-&gt;pbsi_flags |= PROC_FLAG_INEXIT;
	<span class="enscript-keyword">if</span> ((p-&gt;p_lflag &amp; P_LPPWAIT) == P_LPPWAIT) 
		pbsd_shortp-&gt;pbsi_flags |= PROC_FLAG_PPWAIT;
	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_LP64) == P_LP64) 
		pbsd_shortp-&gt;pbsi_flags |= PROC_FLAG_LP64;
	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_CONTROLT) == P_CONTROLT) 
		pbsd_shortp-&gt;pbsi_flags |= PROC_FLAG_CONTROLT;
	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_THCWD) == P_THCWD) 
		pbsd_shortp-&gt;pbsi_flags |= PROC_FLAG_THCWD;
	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_SUGID) == P_SUGID) 
		pbsd_shortp-&gt;pbsi_flags |= PROC_FLAG_PSUGID;
	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_EXEC) == P_EXEC) 
		pbsd_shortp-&gt;pbsi_flags |= PROC_FLAG_EXEC;
	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_DELAYIDLESLEEP) == P_DELAYIDLESLEEP) 
		pbsd_shortp-&gt;pbsi_flags |= PROC_FLAG_DELAYIDLESLEEP;

	<span class="enscript-keyword">switch</span>(PROC_CONTROL_STATE(p)) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">P_PCTHROTTLE</span>:
			pbsd_shortp-&gt;pbsi_flags |= PROC_FLAG_PC_THROTTLE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">P_PCSUSP</span>:
			pbsd_shortp-&gt;pbsi_flags |= PROC_FLAG_PC_SUSP;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">P_PCKILL</span>:
			pbsd_shortp-&gt;pbsi_flags |= PROC_FLAG_PC_KILL;
			<span class="enscript-keyword">break</span>;
	};

	<span class="enscript-keyword">switch</span>(PROC_ACTION_STATE(p)) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">P_PCTHROTTLE</span>:
			pbsd_shortp-&gt;pbsi_flags |= PROC_FLAG_PA_THROTTLE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">P_PCSUSP</span>:
			pbsd_shortp-&gt;pbsi_flags |= PROC_FLAG_PA_SUSP;
			<span class="enscript-keyword">break</span>;
	};
		
	<span class="enscript-comment">/* if process is a zombie skip bg state */</span>
	<span class="enscript-keyword">if</span> ((zombie == 0) &amp;&amp; (p-&gt;p_stat != SZOMB) &amp;&amp; (p-&gt;task != TASK_NULL))
		proc_get_darwinbgstate(p-&gt;task, &amp;pbsd_shortp-&gt;pbsi_flags);

	pbsd_shortp-&gt;pbsi_uid = p-&gt;p_uid;
	pbsd_shortp-&gt;pbsi_gid = p-&gt;p_gid; 
	pbsd_shortp-&gt;pbsi_ruid =  p-&gt;p_ruid;
	pbsd_shortp-&gt;pbsi_rgid = p-&gt;p_rgid;
	pbsd_shortp-&gt;pbsi_svuid =  p-&gt;p_svuid;
	pbsd_shortp-&gt;pbsi_svgid = p-&gt;p_svgid;
	
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_pidtaskinfo</span>(proc_t p, <span class="enscript-type">struct</span> proc_taskinfo * ptinfo)
{
	task_t task;
	
	task = p-&gt;task;

	bzero(ptinfo, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_taskinfo));
	fill_taskprocinfo(task, (<span class="enscript-type">struct</span> proc_taskinfo_internal *)ptinfo);

	<span class="enscript-keyword">return</span>(0);
}



<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_pidthreadinfo</span>(proc_t p, uint64_t arg,  <span class="enscript-type">int</span> thuniqueid, <span class="enscript-type">struct</span> proc_threadinfo *pthinfo)
{
	<span class="enscript-type">int</span> error = 0;
	uint64_t threadaddr = (uint64_t)arg;

	bzero(pthinfo, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_threadinfo));

	error = fill_taskthreadinfo(p-&gt;task, threadaddr, thuniqueid, (<span class="enscript-type">struct</span> proc_threadinfo_internal *)pthinfo, NULL, NULL);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span>(ESRCH);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span>(0);

}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">bsd_getthreadname</span>(<span class="enscript-type">void</span> *uth, <span class="enscript-type">char</span> *buffer)
{
	<span class="enscript-type">struct</span> uthread *ut = (<span class="enscript-type">struct</span> uthread *)uth;
	<span class="enscript-keyword">if</span>(ut-&gt;pth_name)
		bcopy(ut-&gt;pth_name,buffer,MAXTHREADNAMESIZE);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bsd_threadcdir</span>(<span class="enscript-type">void</span> * uth, <span class="enscript-type">void</span> *vptr, <span class="enscript-type">int</span> *vidp)
{
	<span class="enscript-type">struct</span> uthread * ut = (<span class="enscript-type">struct</span> uthread *)uth;
	vnode_t vp;
	vnode_t *vpp = (vnode_t *)vptr;

	vp = ut-&gt;uu_cdir;
	<span class="enscript-keyword">if</span> (vp  != NULLVP) {
		<span class="enscript-keyword">if</span> (vpp != NULL) {
			*vpp = vp;
			<span class="enscript-keyword">if</span> (vidp != NULL)
				*vidp = vp-&gt;v_id;
		}
	}
}


<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_pidthreadpathinfo</span>(proc_t p, uint64_t arg,  <span class="enscript-type">struct</span> proc_threadwithpathinfo *pinfo)
{
	vnode_t vp = NULLVP;
	<span class="enscript-type">int</span> vid;
	<span class="enscript-type">int</span> error = 0;
	uint64_t threadaddr = (uint64_t)arg;
	<span class="enscript-type">int</span> count;

	bzero(pinfo, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_threadwithpathinfo));

	error = fill_taskthreadinfo(p-&gt;task, threadaddr, 0, (<span class="enscript-type">struct</span> proc_threadinfo_internal *)&amp;pinfo-&gt;pt, (<span class="enscript-type">void</span> *)&amp;vp, &amp;vid);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span>(ESRCH);

	<span class="enscript-keyword">if</span> ((vp != NULLVP) &amp;&amp; ((vnode_getwithvid(vp, vid)) == 0)) {
		error = fill_vnodeinfo(vp, &amp;pinfo-&gt;pvip.vip_vi) ;
		<span class="enscript-keyword">if</span> (error == 0) {
			count = MAXPATHLEN;
			vn_getpath(vp, &amp;pinfo-&gt;pvip.vip_path[0], &amp;count);
			pinfo-&gt;pvip.vip_path[MAXPATHLEN-1] = 0;
		}
		vnode_put(vp);
	}	
	<span class="enscript-keyword">return</span>(error);
}



<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_pidlistthreads</span>(proc_t p,  user_addr_t buffer, uint32_t  buffersize, int32_t *retval)
{
	<span class="enscript-type">int</span> count = 0;	
	<span class="enscript-type">int</span> ret = 0;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">void</span> * kbuf;
	<span class="enscript-type">int</span> numthreads;

	
	count = buffersize/(<span class="enscript-keyword">sizeof</span>(uint64_t));
	numthreads = get_numthreads(p-&gt;task);

	numthreads += 10;

	<span class="enscript-keyword">if</span> (numthreads &gt; count)
		numthreads = count;

	kbuf = (<span class="enscript-type">void</span> *)kalloc(numthreads * <span class="enscript-keyword">sizeof</span>(uint64_t));
	<span class="enscript-keyword">if</span> (kbuf == NULL)
		<span class="enscript-keyword">return</span>(ENOMEM);
	bzero(kbuf, numthreads * <span class="enscript-keyword">sizeof</span>(uint64_t));
	
	ret = fill_taskthreadlist(p-&gt;task, kbuf, numthreads);
	
	error = copyout(kbuf, buffer, ret);
	kfree(kbuf, numthreads * <span class="enscript-keyword">sizeof</span>(uint64_t));
	<span class="enscript-keyword">if</span> (error == 0)
		*retval = ret;
	<span class="enscript-keyword">return</span>(error);
	
}


<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_pidregioninfo</span>(proc_t p, uint64_t arg, user_addr_t buffer, __unused uint32_t  buffersize, int32_t *retval)
{
	<span class="enscript-type">struct</span> proc_regioninfo preginfo;
	<span class="enscript-type">int</span> ret, error = 0;

	bzero(&amp;preginfo, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_regioninfo));
	ret = fill_procregioninfo( p-&gt;task, arg, (<span class="enscript-type">struct</span> proc_regioninfo_internal *)&amp;preginfo, (uintptr_t *)0, (uint32_t *)0);
	<span class="enscript-keyword">if</span> (ret == 0)
		<span class="enscript-keyword">return</span>(EINVAL);
	error = copyout(&amp;preginfo, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_regioninfo));
	<span class="enscript-keyword">if</span> (error == 0)
		*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_regioninfo);
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_pidregionpathinfo</span>(proc_t p, uint64_t arg, user_addr_t buffer, __unused uint32_t  buffersize, int32_t *retval)
{
	<span class="enscript-type">struct</span> proc_regionwithpathinfo preginfo;
	<span class="enscript-type">int</span> ret, error = 0;
	uintptr_t vnodeaddr= 0;
	uint32_t vnodeid= 0;
	vnode_t vp;
	<span class="enscript-type">int</span> count;

	bzero(&amp;preginfo, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_regionwithpathinfo));

	ret = fill_procregioninfo( p-&gt;task, arg, (<span class="enscript-type">struct</span> proc_regioninfo_internal *)&amp;preginfo.prp_prinfo, (uintptr_t *)&amp;vnodeaddr, (uint32_t *)&amp;vnodeid);
	<span class="enscript-keyword">if</span> (ret == 0)
		<span class="enscript-keyword">return</span>(EINVAL);
	<span class="enscript-keyword">if</span> (vnodeaddr) {
		vp = (vnode_t)vnodeaddr;
		<span class="enscript-keyword">if</span> ((vnode_getwithvid(vp, vnodeid)) == 0) {
			<span class="enscript-comment">/* FILL THE VNODEINFO */</span>
			error = fill_vnodeinfo(vp, &amp;preginfo.prp_vip.vip_vi);
			count = MAXPATHLEN;
			vn_getpath(vp, &amp;preginfo.prp_vip.vip_path[0], &amp;count);
			<span class="enscript-comment">/* Always make sure it is null terminated */</span>
			preginfo.prp_vip.vip_path[MAXPATHLEN-1] = 0;
			vnode_put(vp);
		}
	}
	error = copyout(&amp;preginfo, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_regionwithpathinfo));
	<span class="enscript-keyword">if</span> (error == 0)
		*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_regionwithpathinfo);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_pidregionpathinfo2</span>(proc_t p,  uint64_t arg, user_addr_t buffer, __unused uint32_t buffersize, int32_t *retval)
{
	<span class="enscript-type">struct</span> proc_regionwithpathinfo preginfo;
	<span class="enscript-type">int</span> ret, error = 0;
	uintptr_t vnodeaddr= 0;
	uint32_t vnodeid= 0;
	vnode_t vp;
	<span class="enscript-type">int</span> count;

	bzero(&amp;preginfo, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_regionwithpathinfo));

	ret = fill_procregioninfo_onlymappedvnodes( p-&gt;task, arg, (<span class="enscript-type">struct</span> proc_regioninfo_internal *)&amp;preginfo.prp_prinfo, (uintptr_t *)&amp;vnodeaddr, (uint32_t *)&amp;vnodeid);
	<span class="enscript-keyword">if</span> (ret == 0)
		<span class="enscript-keyword">return</span>(EINVAL);
	<span class="enscript-keyword">if</span> (!vnodeaddr)
		<span class="enscript-keyword">return</span>(EINVAL);

	vp = (vnode_t)vnodeaddr;
	<span class="enscript-keyword">if</span> ((vnode_getwithvid(vp, vnodeid)) == 0) {
		<span class="enscript-comment">/* FILL THE VNODEINFO */</span>
		error = fill_vnodeinfo(vp, &amp;preginfo.prp_vip.vip_vi);
		count = MAXPATHLEN;
		vn_getpath(vp, &amp;preginfo.prp_vip.vip_path[0], &amp;count);
		<span class="enscript-comment">/* Always make sure it is null terminated */</span>
		preginfo.prp_vip.vip_path[MAXPATHLEN-1] = 0;
		vnode_put(vp);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span>(EINVAL);
	}

	error = copyout(&amp;preginfo, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_regionwithpathinfo));
	<span class="enscript-keyword">if</span> (error == 0)
		*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_regionwithpathinfo);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_pidregionpathinfo3</span>(proc_t p,  uint64_t arg, user_addr_t buffer, __unused uint32_t buffersize, int32_t *retval)
{
	<span class="enscript-type">struct</span> proc_regionwithpathinfo preginfo;
	<span class="enscript-type">int</span> ret, error = 0;
	uintptr_t vnodeaddr;
	uint32_t vnodeid;
	vnode_t vp;
	<span class="enscript-type">int</span> count;
	uint64_t addr = 0;

	<span class="enscript-comment">/* Loop while looking for vnodes that match dev_t filter */</span>
	<span class="enscript-keyword">do</span> {
		bzero(&amp;preginfo, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_regionwithpathinfo));
		vnodeaddr = 0;
		vnodeid = 0;

		ret = fill_procregioninfo_onlymappedvnodes( p-&gt;task, addr, (<span class="enscript-type">struct</span> proc_regioninfo_internal *)&amp;preginfo.prp_prinfo, (uintptr_t *)&amp;vnodeaddr, (uint32_t *)&amp;vnodeid);
		<span class="enscript-keyword">if</span> (ret == 0)
			<span class="enscript-keyword">return</span>(EINVAL);
		<span class="enscript-keyword">if</span> (!vnodeaddr)
			<span class="enscript-keyword">return</span>(EINVAL);

		vp = (vnode_t)vnodeaddr;
		<span class="enscript-keyword">if</span> ((vnode_getwithvid(vp, vnodeid)) == 0) {
			<span class="enscript-comment">/* Check if the vnode matches the filter, otherwise loop looking for the next memory region backed by a vnode */</span>
			<span class="enscript-type">struct</span> vnode_attr va;
			
			memset(&amp;va, 0, <span class="enscript-keyword">sizeof</span>(va));
			VATTR_INIT(&amp;va);
			VATTR_WANTED(&amp;va, va_fsid);

			ret = vnode_getattr(vp, &amp;va, vfs_context_current());
			<span class="enscript-keyword">if</span> (ret) {
				vnode_put(vp);
				<span class="enscript-keyword">return</span>(EINVAL);
			}

			<span class="enscript-keyword">if</span> (va.va_fsid == arg) {
				<span class="enscript-comment">/* FILL THE VNODEINFO */</span>
				error = fill_vnodeinfo(vp, &amp;preginfo.prp_vip.vip_vi);
				count = MAXPATHLEN;
				vn_getpath(vp, &amp;preginfo.prp_vip.vip_path[0], &amp;count);
				<span class="enscript-comment">/* Always make sure it is null terminated */</span>
				preginfo.prp_vip.vip_path[MAXPATHLEN-1] = 0;
				vnode_put(vp);
				<span class="enscript-keyword">break</span>;
			}
			vnode_put(vp);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">return</span>(EINVAL);
		}

		addr = preginfo.prp_prinfo.pri_address + preginfo.prp_prinfo.pri_size;
	} <span class="enscript-keyword">while</span> (1);

	error = copyout(&amp;preginfo, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_regionwithpathinfo));
	<span class="enscript-keyword">if</span> (error == 0)
		*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_regionwithpathinfo);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Path is relative to current process directory; may different from current
 * thread directory.
 */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_pidvnodepathinfo</span>(proc_t p, __unused uint64_t arg, user_addr_t buffer, __unused uint32_t  buffersize, int32_t *retval)
{
	<span class="enscript-type">struct</span> proc_vnodepathinfo pvninfo;
	<span class="enscript-type">int</span> error = 0;
	vnode_t vncdirvp = NULLVP;
	uint32_t vncdirid=0;
	vnode_t vnrdirvp = NULLVP;
	uint32_t vnrdirid=0;
	<span class="enscript-type">int</span> count;

	bzero(&amp;pvninfo, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_vnodepathinfo));

	proc_fdlock(p);
	<span class="enscript-keyword">if</span> (p-&gt;p_fd-&gt;fd_cdir) {
		vncdirvp = p-&gt;p_fd-&gt;fd_cdir;
		vncdirid = p-&gt;p_fd-&gt;fd_cdir-&gt;v_id;
	}
	<span class="enscript-keyword">if</span> (p-&gt;p_fd-&gt;fd_rdir) {
		vnrdirvp = p-&gt;p_fd-&gt;fd_rdir;
		vnrdirid = p-&gt;p_fd-&gt;fd_rdir-&gt;v_id;
	}
	proc_fdunlock(p);

	<span class="enscript-keyword">if</span> (vncdirvp != NULLVP) {
		<span class="enscript-keyword">if</span> ((error = vnode_getwithvid(vncdirvp, vncdirid)) == 0) {
			<span class="enscript-comment">/* FILL THE VNODEINFO */</span>
			error = fill_vnodeinfo(vncdirvp, &amp;pvninfo.pvi_cdir.vip_vi);
			<span class="enscript-keyword">if</span> ( error == 0) {
				count = MAXPATHLEN;
				vn_getpath(vncdirvp, &amp;pvninfo.pvi_cdir.vip_path[0], &amp;count);
				pvninfo.pvi_cdir.vip_path[MAXPATHLEN-1] = 0;
			}	
			vnode_put(vncdirvp);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	<span class="enscript-keyword">if</span> ((error == 0) &amp;&amp; (vnrdirvp != NULLVP)) {
		<span class="enscript-keyword">if</span> ((error = vnode_getwithvid(vnrdirvp, vnrdirid)) == 0) {
			<span class="enscript-comment">/* FILL THE VNODEINFO */</span>
			error = fill_vnodeinfo(vnrdirvp, &amp;pvninfo.pvi_rdir.vip_vi);
			<span class="enscript-keyword">if</span> ( error == 0) {
				count = MAXPATHLEN;
				vn_getpath(vnrdirvp, &amp;pvninfo.pvi_rdir.vip_path[0], &amp;count);
				pvninfo.pvi_rdir.vip_path[MAXPATHLEN-1] = 0;
			}	
			vnode_put(vnrdirvp);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	<span class="enscript-keyword">if</span> (error == 0) {
		error = copyout(&amp;pvninfo, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_vnodepathinfo));
		<span class="enscript-keyword">if</span> (error == 0)
			*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_vnodepathinfo);
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_pidpathinfo</span>(proc_t p, __unused uint64_t arg, user_addr_t buffer, uint32_t buffersize, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> vid, error;
	vnode_t tvp;
	vnode_t nvp = NULLVP;
	<span class="enscript-type">int</span> len = buffersize; 
	<span class="enscript-type">char</span> * buf;

	tvp = p-&gt;p_textvp;

	<span class="enscript-keyword">if</span> (tvp == NULLVP)
		<span class="enscript-keyword">return</span>(ESRCH);

	buf = (<span class="enscript-type">char</span> *)kalloc(buffersize);
	<span class="enscript-keyword">if</span> (buf == NULL) 
		<span class="enscript-keyword">return</span>(ENOMEM);


	vid = vnode_vid(tvp);
	error = vnode_getwithvid(tvp, vid);
	<span class="enscript-keyword">if</span> (error == 0) {
		error = vn_getpath_fsenter(tvp, buf, &amp;len);
		vnode_put(tvp);
		<span class="enscript-keyword">if</span> (error == 0) {
			error = vnode_lookup(buf, 0, &amp;nvp, vfs_context_current()); 
			<span class="enscript-keyword">if</span> ((error == 0) &amp;&amp; ( nvp != NULLVP))
				vnode_put(nvp);
			<span class="enscript-keyword">if</span> (error == 0) {
				error = copyout(buf, buffer, len);
			}
		}
	}
	kfree(buf, buffersize);
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_pidworkqueueinfo</span>(proc_t p, <span class="enscript-type">struct</span> proc_workqueueinfo *pwqinfo)
{
	<span class="enscript-type">int</span> error = 0;

	bzero(pwqinfo, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_workqueueinfo));

	error = fill_procworkqueue(p, pwqinfo);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span>(ESRCH);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span>(0);

}


<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_piduniqidentifierinfo</span>(proc_t p, <span class="enscript-type">struct</span> proc_uniqidentifierinfo *p_uniqidinfo)
{
	p_uniqidinfo-&gt;p_uniqueid = proc_uniqueid(p);
	proc_getexecutableuuid(p, (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)&amp;p_uniqidinfo-&gt;p_uuid, <span class="enscript-keyword">sizeof</span>(p_uniqidinfo-&gt;p_uuid));
	p_uniqidinfo-&gt;p_puniqueid = proc_puniqueid(p);
	p_uniqidinfo-&gt;p_reserve2 = 0;
	p_uniqidinfo-&gt;p_reserve3 = 0;
	p_uniqidinfo-&gt;p_reserve4 = 0;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">proc_piduuidinfo</span>(pid_t pid, uuid_t uuid_buf, uint32_t buffersize)
{
	<span class="enscript-type">struct</span> proc * p = PROC_NULL;
	<span class="enscript-type">int</span> zombref = 0;

	<span class="enscript-keyword">if</span> (buffersize &lt; <span class="enscript-keyword">sizeof</span>(uuid_t))
		<span class="enscript-keyword">return</span> EINVAL;

	<span class="enscript-keyword">if</span> ((p = proc_find(pid)) == PROC_NULL) {
		p = proc_find_zombref(pid);
		zombref = 1;
	}
	<span class="enscript-keyword">if</span> (p == PROC_NULL) {
		<span class="enscript-keyword">return</span> ESRCH;
	}

	proc_getexecutableuuid(p, (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)uuid_buf, buffersize);

	<span class="enscript-keyword">if</span> (zombref)
		proc_drop_zombref(p);
	<span class="enscript-keyword">else</span>
		proc_rele(p);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Function to get the uuid and pid of the originator of the voucher.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_pidoriginatorpid_uuid</span>(uuid_t uuid, uint32_t buffersize, pid_t *pid)
{
	pid_t originator_pid;
	kern_return_t kr;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* 
	 * Get the current voucher origin pid. The pid returned here 
	 * might not be valid or may have been recycled.
	 */</span>
	kr = thread_get_current_voucher_origin_pid(&amp;originator_pid);
	<span class="enscript-comment">/* If errors, convert errors to appropriate format */</span>
	<span class="enscript-keyword">if</span> (kr) {
		<span class="enscript-keyword">if</span> (kr == KERN_INVALID_TASK)
			error = ESRCH;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kr == KERN_INVALID_VALUE)
			error = ENOATTR;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
		<span class="enscript-keyword">return</span> error;
	}

	*pid = originator_pid;
	error = proc_piduuidinfo(originator_pid, uuid, buffersize);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * Function to get the uuid of the originator of the voucher.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_pidoriginatoruuid</span>(uuid_t uuid, uint32_t buffersize)
{
	pid_t originator_pid;
	<span class="enscript-keyword">return</span> (proc_pidoriginatorpid_uuid(uuid, buffersize, &amp;originator_pid));
}

<span class="enscript-comment">/***************************** proc_pidoriginatorinfo ***************************/</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_pidoriginatorinfo</span>(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor, user_addr_t buffer, uint32_t  buffersize, int32_t * retval)
{
	<span class="enscript-type">int</span> error = ENOTSUP;
	uint32_t size;

	<span class="enscript-keyword">switch</span> (flavor) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDORIGINATOR_UUID</span>:
			size = PROC_PIDORIGINATOR_UUID_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDORIGINATOR_BGSTATE</span>:
			size = PROC_PIDORIGINATOR_BGSTATE_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDORIGINATOR_PID_UUID</span>:
			size = PROC_PIDORIGINATOR_PID_UUID_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span>(EINVAL);
	}

	<span class="enscript-keyword">if</span> (buffersize &lt; size) 
		<span class="enscript-keyword">return</span>(ENOMEM);

	<span class="enscript-keyword">if</span> (pid != 0 &amp;&amp; pid != proc_selfpid())
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">switch</span> (flavor) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDORIGINATOR_UUID</span>: {
			uuid_t uuid;

			error = proc_pidoriginatoruuid(uuid, <span class="enscript-keyword">sizeof</span>(uuid));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

			error = copyout(uuid, buffer, size);
			<span class="enscript-keyword">if</span> (error == 0)
				*retval = size;
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDORIGINATOR_PID_UUID</span>: {
			<span class="enscript-type">struct</span> proc_originatorinfo originator_info;

			error = proc_pidoriginatorpid_uuid(originator_info.originator_uuid,
						<span class="enscript-keyword">sizeof</span>(uuid_t), &amp;originator_info.originator_pid);
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

			originator_info.p_reserve2 = 0;
			originator_info.p_reserve3 = 0;
			originator_info.p_reserve4 = 0;

			error = copyout(&amp;originator_info, buffer, size);
			<span class="enscript-keyword">if</span> (error == 0)
				*retval = size;
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDORIGINATOR_BGSTATE</span>: {
			uint32_t is_backgrounded;
			error = proc_get_originatorbgstate(&amp;is_backgrounded);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

			error = copyout(&amp;is_backgrounded, buffer, size);
			<span class="enscript-keyword">if</span> (error == 0)
				*retval = size;
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = ENOTSUP;
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/***************************** proc_listcoalitions ***************************/</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">proc_listcoalitions</span>(<span class="enscript-type">int</span> flavor, <span class="enscript-type">int</span> type, user_addr_t buffer,
			uint32_t buffersize, int32_t *retval)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_COALITIONS</span>
	<span class="enscript-type">int</span> error = ENOTSUP;
	<span class="enscript-type">int</span> coal_type;
	uint32_t elem_size;
	<span class="enscript-type">void</span> *coalinfo = NULL;
	uint32_t k_buffersize = 0, copyout_sz = 0;
	<span class="enscript-type">int</span> ncoals = 0, ncoals_ = 0;

	<span class="enscript-comment">/* struct procinfo_coalinfo; */</span>

	<span class="enscript-keyword">switch</span> (flavor) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LISTCOALITIONS_ALL_COALS</span>:
		elem_size = LISTCOALITIONS_ALL_COALS_SIZE;
		coal_type = -1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LISTCOALITIONS_SINGLE_TYPE</span>:
		elem_size = LISTCOALITIONS_SINGLE_TYPE_SIZE;
		coal_type = type;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* find the total number of coalitions */</span>
	ncoals = coalitions_get_list(coal_type, NULL, 0);

	<span class="enscript-keyword">if</span> (ncoals == 0 || buffer == 0 || buffersize == 0) {
		<span class="enscript-comment">/*
		 * user just wants buffer size
		 * or there are no coalitions
		 */</span>
		error = 0;
		*retval = (<span class="enscript-type">int</span>)(ncoals * elem_size);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	k_buffersize = ncoals * elem_size;
	coalinfo = kalloc((vm_size_t)k_buffersize);
	<span class="enscript-keyword">if</span> (!coalinfo) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	bzero(coalinfo, k_buffersize);

	<span class="enscript-keyword">switch</span> (flavor) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LISTCOALITIONS_ALL_COALS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">LISTCOALITIONS_SINGLE_TYPE</span>:
		ncoals_ = coalitions_get_list(coal_type, coalinfo, ncoals);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;memory corruption?!&quot;</span>);
	}

	<span class="enscript-keyword">if</span> (ncoals_ == 0) {
		<span class="enscript-comment">/* all the coalitions disappeared... weird but valid */</span>
		error = 0;
		*retval = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Some coalitions may have disappeared between our initial check,
	 * and the the actual list acquisition.
	 * Only copy out what we really need.
	 */</span>
	copyout_sz = k_buffersize;
	<span class="enscript-keyword">if</span> (ncoals_ &lt; ncoals)
		copyout_sz = ncoals_ * elem_size;

	<span class="enscript-comment">/*
	 * copy the list up to user space
	 * (we're guaranteed to have a non-null pointer/size here)
	 */</span>
	error = copyout(coalinfo, buffer,
			copyout_sz &lt; buffersize ? copyout_sz : buffersize);

	<span class="enscript-keyword">if</span> (error == 0)
		*retval = (<span class="enscript-type">int</span>)copyout_sz;

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (coalinfo)
		kfree(coalinfo, k_buffersize);

	<span class="enscript-keyword">return</span> error;
#<span class="enscript-reference">else</span>
	<span class="enscript-comment">/* no coalition support */</span>
	(<span class="enscript-type">void</span>)flavor;
	(<span class="enscript-type">void</span>)type;
	(<span class="enscript-type">void</span>)buffer;
	(<span class="enscript-type">void</span>)buffersize;
	(<span class="enscript-type">void</span>)retval;
	<span class="enscript-keyword">return</span> ENOTSUP;
#<span class="enscript-reference">endif</span>
}


<span class="enscript-comment">/********************************** proc_pidinfo ********************************/</span>


<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_pidinfo</span>(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor, uint64_t arg, user_addr_t buffer, uint32_t  buffersize, int32_t * retval)
{
	<span class="enscript-type">struct</span> proc * p = PROC_NULL;
	<span class="enscript-type">int</span> error = ENOTSUP;
	<span class="enscript-type">int</span> gotref = 0;
	<span class="enscript-type">int</span> findzomb = 0;
	<span class="enscript-type">int</span> shortversion = 0;
	uint32_t size;
	<span class="enscript-type">int</span> zombie = 0;
	<span class="enscript-type">int</span> thuniqueid = 0;
	<span class="enscript-type">int</span> uniqidversion = 0;
	boolean_t check_same_user;

	<span class="enscript-keyword">switch</span> (flavor) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDLISTFDS</span>:
			size = PROC_PIDLISTFD_SIZE;
			<span class="enscript-keyword">if</span> (buffer == (user_addr_t)0)
				size = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDTBSDINFO</span>:
			size = PROC_PIDTBSDINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDTASKINFO</span>:
			size = PROC_PIDTASKINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDTASKALLINFO</span>:
			size = PROC_PIDTASKALLINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDTHREADINFO</span>:
			size = PROC_PIDTHREADINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDLISTTHREADS</span>:
			size = PROC_PIDLISTTHREADS_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDREGIONINFO</span>:
			size = PROC_PIDREGIONINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDREGIONPATHINFO</span>:
			size = PROC_PIDREGIONPATHINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDVNODEPATHINFO</span>:
			size = PROC_PIDVNODEPATHINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDTHREADPATHINFO</span>:
			size = PROC_PIDTHREADPATHINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDPATHINFO</span>:
			size = MAXPATHLEN;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDWORKQUEUEINFO</span>:
			<span class="enscript-comment">/* kernel does not have workq info */</span>
			<span class="enscript-keyword">if</span> (pid == 0)
				<span class="enscript-keyword">return</span>(EINVAL);
			<span class="enscript-keyword">else</span>
				size = PROC_PIDWORKQUEUEINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDT_SHORTBSDINFO</span>:
			size = PROC_PIDT_SHORTBSDINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDLISTFILEPORTS</span>:
			size = PROC_PIDLISTFILEPORTS_SIZE;
			<span class="enscript-keyword">if</span> (buffer == (user_addr_t)0)
				size = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDTHREADID64INFO</span>:
			size = PROC_PIDTHREADID64INFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDUNIQIDENTIFIERINFO</span>:
			size = PROC_PIDUNIQIDENTIFIERINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDT_BSDINFOWITHUNIQID</span>:
			size = PROC_PIDT_BSDINFOWITHUNIQID_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDARCHINFO</span>:
			size = PROC_PIDARCHINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDCOALITIONINFO</span>:
			size = PROC_PIDCOALITIONINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDNOTEEXIT</span>:
			<span class="enscript-comment">/* 
			 * Set findzomb explicitly because arg passed
			 * in is used as note exit status bits.
			 */</span>
			size = PROC_PIDNOTEEXIT_SIZE;
			findzomb = 1;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDREGIONPATHINFO2</span>:
			size = PROC_PIDREGIONPATHINFO2_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDREGIONPATHINFO3</span>:
			size = PROC_PIDREGIONPATHINFO3_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span>(EINVAL);
	}

	<span class="enscript-keyword">if</span> (buffersize &lt; size) 
		<span class="enscript-keyword">return</span>(ENOMEM);

	<span class="enscript-keyword">if</span> ((flavor == PROC_PIDPATHINFO) &amp;&amp; (buffersize &gt; PROC_PIDPATHINFO_MAXSIZE)) {
		<span class="enscript-keyword">return</span>(EOVERFLOW);
	}

	<span class="enscript-comment">/* Check if we need to look for zombies */</span>
	<span class="enscript-keyword">if</span> ((flavor == PROC_PIDTBSDINFO) || (flavor == PROC_PIDT_SHORTBSDINFO) || (flavor == PROC_PIDT_BSDINFOWITHUNIQID) 
	    || (flavor == PROC_PIDUNIQIDENTIFIERINFO)) {
		<span class="enscript-keyword">if</span> (arg)
			findzomb = 1;
	}

	<span class="enscript-keyword">if</span> ((p = proc_find(pid)) == PROC_NULL) {
		<span class="enscript-keyword">if</span> (findzomb)
			p = proc_find_zombref(pid);
		<span class="enscript-keyword">if</span> (p == PROC_NULL) {
			error = ESRCH;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		zombie = 1;
	} <span class="enscript-keyword">else</span> {
		gotref = 1;
	}

	<span class="enscript-comment">/* Certain operations don't require privileges */</span>
	<span class="enscript-keyword">switch</span> (flavor) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDT_SHORTBSDINFO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDUNIQIDENTIFIERINFO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDPATHINFO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDCOALITIONINFO</span>:
			check_same_user = NO_CHECK_SAME_USER;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			check_same_user = CHECK_SAME_USER;
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* Do we have permission to look into this? */</span>
	<span class="enscript-keyword">if</span> ((error = proc_security_policy(p, PROC_INFO_CALL_PIDINFO, flavor, check_same_user)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">switch</span> (flavor) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDLISTFDS</span>: {
			error = proc_pidfdlist(p, buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDUNIQIDENTIFIERINFO</span>: {
			<span class="enscript-type">struct</span> proc_uniqidentifierinfo p_uniqidinfo;

			proc_piduniqidentifierinfo(p, &amp;p_uniqidinfo);
			error = copyout(&amp;p_uniqidinfo, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_uniqidentifierinfo));
			<span class="enscript-keyword">if</span> (error == 0)
				*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_uniqidentifierinfo);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDT_SHORTBSDINFO</span>:
			shortversion = 1;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDT_BSDINFOWITHUNIQID</span>: 
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDTBSDINFO</span>: {
			<span class="enscript-type">struct</span> proc_bsdinfo pbsd;
			<span class="enscript-type">struct</span> proc_bsdshortinfo pbsd_short;
			<span class="enscript-type">struct</span> proc_bsdinfowithuniqid pbsd_uniqid;
		
			<span class="enscript-keyword">if</span> (flavor == PROC_PIDT_BSDINFOWITHUNIQID)
				uniqidversion = 1;
			
			<span class="enscript-keyword">if</span> (shortversion != 0) {
				error = proc_pidshortbsdinfo(p, &amp;pbsd_short, zombie);
			} <span class="enscript-keyword">else</span> {
				error = proc_pidbsdinfo(p, &amp;pbsd, zombie);
				<span class="enscript-keyword">if</span> (uniqidversion != 0) { 
					proc_piduniqidentifierinfo(p, &amp;pbsd_uniqid.p_uniqidentifier);
					pbsd_uniqid.pbsd = pbsd;
				}
			}
			
			<span class="enscript-keyword">if</span> (error == 0) {
				<span class="enscript-keyword">if</span> (shortversion != 0) {
					error = copyout(&amp;pbsd_short, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_bsdshortinfo));
					<span class="enscript-keyword">if</span> (error == 0)
						*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_bsdshortinfo);
				 } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uniqidversion != 0) {
					error = copyout(&amp;pbsd_uniqid, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_bsdinfowithuniqid));
					<span class="enscript-keyword">if</span> (error == 0)
						*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_bsdinfowithuniqid);
				} <span class="enscript-keyword">else</span> {
					error = copyout(&amp;pbsd, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_bsdinfo));
					<span class="enscript-keyword">if</span> (error == 0)
						*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_bsdinfo);
				}
			}	
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDTASKINFO</span>: {
			<span class="enscript-type">struct</span> proc_taskinfo ptinfo;

			error =  proc_pidtaskinfo(p, &amp;ptinfo);
			<span class="enscript-keyword">if</span> (error == 0) {
				error = copyout(&amp;ptinfo, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_taskinfo));
				<span class="enscript-keyword">if</span> (error == 0)
					*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_taskinfo);
			}	
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDTASKALLINFO</span>: {
		<span class="enscript-type">struct</span> proc_taskallinfo pall;

			error = proc_pidbsdinfo(p, &amp;pall.pbsd, 0);
			error =  proc_pidtaskinfo(p, &amp;pall.ptinfo);
			<span class="enscript-keyword">if</span> (error == 0) {
				error = copyout(&amp;pall, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_taskallinfo));
				<span class="enscript-keyword">if</span> (error == 0)
					*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_taskallinfo);
			}	
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDTHREADID64INFO</span>:
			thuniqueid = 1;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDTHREADINFO</span>:{
		<span class="enscript-type">struct</span> proc_threadinfo pthinfo;

			error  = proc_pidthreadinfo(p,  arg, thuniqueid, &amp;pthinfo);
			<span class="enscript-keyword">if</span> (error == 0) {
				error = copyout(&amp;pthinfo, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_threadinfo));
				<span class="enscript-keyword">if</span> (error == 0)
					*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_threadinfo);
			}	
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDLISTTHREADS</span>:{
			error =  proc_pidlistthreads(p,  buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDREGIONINFO</span>:{
			error =  proc_pidregioninfo(p,  arg, buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;


		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDREGIONPATHINFO</span>:{
			error =  proc_pidregionpathinfo(p, arg, buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDREGIONPATHINFO2</span>:{
			error =  proc_pidregionpathinfo2(p, arg, buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDREGIONPATHINFO3</span>:{
			error =  proc_pidregionpathinfo3(p, arg, buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDVNODEPATHINFO</span>:{
			error =  proc_pidvnodepathinfo(p, arg, buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;


		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDTHREADPATHINFO</span>:{
		<span class="enscript-type">struct</span> proc_threadwithpathinfo pinfo;

			error  = proc_pidthreadpathinfo(p,  arg, &amp;pinfo);
			<span class="enscript-keyword">if</span> (error == 0) {
				error = copyout((caddr_t)&amp;pinfo, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_threadwithpathinfo));
				<span class="enscript-keyword">if</span> (error == 0)
						*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_threadwithpathinfo);
			}
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDPATHINFO</span>: {
			error =  proc_pidpathinfo(p, arg, buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;


		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDWORKQUEUEINFO</span>:{
		<span class="enscript-type">struct</span> proc_workqueueinfo pwqinfo;

			error  = proc_pidworkqueueinfo(p, &amp;pwqinfo);
			<span class="enscript-keyword">if</span> (error == 0) {
				error = copyout(&amp;pwqinfo, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_workqueueinfo));
				<span class="enscript-keyword">if</span> (error == 0)
					*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_workqueueinfo);
			}	
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDLISTFILEPORTS</span>: {
			error = proc_pidfileportlist(p, buffer, buffersize,
			    retval);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDARCHINFO</span>: {	
			<span class="enscript-type">struct</span> proc_archinfo pai;
			proc_archinfo(p, &amp;pai);
			error = copyout(&amp;pai, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_archinfo));
			<span class="enscript-keyword">if</span> (error == 0) {
				*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_archinfo);
			}
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDCOALITIONINFO</span>: {
			<span class="enscript-type">struct</span> proc_pidcoalitioninfo pci;
			proc_pidcoalitioninfo(p, &amp;pci);
			error = copyout(&amp;pci, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_pidcoalitioninfo));
			<span class="enscript-keyword">if</span> (error == 0) {
				*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> proc_pidcoalitioninfo);
			}
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDNOTEEXIT</span>: {
			uint32_t data;
			error = proc_pidnoteexit(p, arg, &amp;data);
			<span class="enscript-keyword">if</span> (error == 0) {
				error = copyout(&amp;data, buffer, <span class="enscript-keyword">sizeof</span>(data));
				<span class="enscript-keyword">if</span> (error == 0) {
					*retval = <span class="enscript-keyword">sizeof</span>(data);
				}
			}
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = ENOTSUP;
	}
	
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (gotref)
		proc_rele(p);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (zombie)
		proc_drop_zombref(p);
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">pid_vnodeinfo</span>(vnode_t vp, uint32_t vid, <span class="enscript-type">struct</span> fileproc * fp, proc_t proc, <span class="enscript-type">int</span> fd, user_addr_t  buffer, __unused uint32_t buffersize, int32_t * retval)
{
	<span class="enscript-type">struct</span> vnode_fdinfo vfi;
	<span class="enscript-type">int</span> error= 0;

	<span class="enscript-keyword">if</span> ((error = vnode_getwithvid(vp, vid)) != 0) {
		<span class="enscript-keyword">return</span>(error);
	}
	bzero(&amp;vfi, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vnode_fdinfo));
	fill_fileinfo(fp, proc, fd, &amp;vfi.pfi);
	error = fill_vnodeinfo(vp, &amp;vfi.pvi);
	vnode_put(vp);
	<span class="enscript-keyword">if</span> (error == 0) {
		error = copyout((caddr_t)&amp;vfi, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vnode_fdinfo));
		<span class="enscript-keyword">if</span> (error == 0)
			*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vnode_fdinfo);
	}
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pid_vnodeinfopath</span>(vnode_t vp, uint32_t vid, <span class="enscript-type">struct</span> fileproc * fp, proc_t proc, <span class="enscript-type">int</span> fd, user_addr_t  buffer, __unused uint32_t buffersize, int32_t * retval)
{
	<span class="enscript-type">struct</span> vnode_fdinfowithpath vfip;
	<span class="enscript-type">int</span> count, error= 0;

	<span class="enscript-keyword">if</span> ((error = vnode_getwithvid(vp, vid)) != 0) {
		<span class="enscript-keyword">return</span>(error);
	}
	bzero(&amp;vfip, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vnode_fdinfowithpath));
	fill_fileinfo(fp, proc, fd, &amp;vfip.pfi);
	error = fill_vnodeinfo(vp, &amp;vfip.pvip.vip_vi) ;
	<span class="enscript-keyword">if</span> (error == 0) {
		count = MAXPATHLEN;
		vn_getpath(vp, &amp;vfip.pvip.vip_path[0], &amp;count);
		vfip.pvip.vip_path[MAXPATHLEN-1] = 0;
		vnode_put(vp);
		error = copyout((caddr_t)&amp;vfip, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vnode_fdinfowithpath));
		<span class="enscript-keyword">if</span> (error == 0)
			*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vnode_fdinfowithpath);
	} <span class="enscript-keyword">else</span> 
		vnode_put(vp);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">fill_fileinfo</span>(<span class="enscript-type">struct</span> fileproc * fp, proc_t proc, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> proc_fileinfo * fproc)
{
	fproc-&gt;fi_openflags = fp-&gt;f_fglob-&gt;fg_flag;
	fproc-&gt;fi_status = 0;
	fproc-&gt;fi_offset = fp-&gt;f_fglob-&gt;fg_offset;
	fproc-&gt;fi_type = FILEGLOB_DTYPE(fp-&gt;f_fglob);
	<span class="enscript-keyword">if</span> (fp-&gt;f_fglob-&gt;fg_count &gt; 1)
		fproc-&gt;fi_status |= PROC_FP_SHARED;
	<span class="enscript-keyword">if</span> (proc != PROC_NULL) {
		<span class="enscript-keyword">if</span> ((FDFLAGS_GET(proc, fd) &amp; UF_EXCLOSE) != 0)
			fproc-&gt;fi_status |= PROC_FP_CLEXEC;
		<span class="enscript-keyword">if</span> ((FDFLAGS_GET(proc, fd) &amp; UF_FORKCLOSE) != 0)
			fproc-&gt;fi_status |= PROC_FP_CLFORK;
	}
	<span class="enscript-keyword">if</span> (FILEPROC_TYPE(fp) == FTYPE_GUARDED) {
		fproc-&gt;fi_status |= PROC_FP_GUARDED;
		fproc-&gt;fi_guardflags = 0;
		<span class="enscript-keyword">if</span> (fp_isguarded(fp, GUARD_CLOSE))
			fproc-&gt;fi_guardflags |= PROC_FI_GUARD_CLOSE;
		<span class="enscript-keyword">if</span> (fp_isguarded(fp, GUARD_DUP))
			fproc-&gt;fi_guardflags |= PROC_FI_GUARD_DUP;
		<span class="enscript-keyword">if</span> (fp_isguarded(fp, GUARD_SOCKET_IPC))
			fproc-&gt;fi_guardflags |= PROC_FI_GUARD_SOCKET_IPC;
		<span class="enscript-keyword">if</span> (fp_isguarded(fp, GUARD_FILEPORT))
			fproc-&gt;fi_guardflags |= PROC_FI_GUARD_FILEPORT;
	}
}



<span class="enscript-type">int</span>
<span class="enscript-function-name">fill_vnodeinfo</span>(vnode_t vp, <span class="enscript-type">struct</span> vnode_info *vinfo)
{
		vfs_context_t context;
		<span class="enscript-type">struct</span> stat64 sb;
		<span class="enscript-type">int</span> error = 0;

		bzero(&amp;sb, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> stat64));
		context = vfs_context_create((vfs_context_t)0);
		error = vn_stat(vp, &amp;sb, NULL, 1, context);
		(<span class="enscript-type">void</span>)vfs_context_rele(context);

		munge_vinfo_stat(&amp;sb, &amp;vinfo-&gt;vi_stat);

		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		<span class="enscript-keyword">if</span> (vp-&gt;v_mount != dead_mountp) {
			vinfo-&gt;vi_fsid = vp-&gt;v_mount-&gt;mnt_vfsstat.f_fsid;
		} <span class="enscript-keyword">else</span> {
			vinfo-&gt;vi_fsid.val[0] = 0;
			vinfo-&gt;vi_fsid.val[1] = 0;
		}
		vinfo-&gt;vi_type = vp-&gt;v_type;
<span class="enscript-reference">out</span>:
		<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pid_socketinfo</span>(socket_t so, <span class="enscript-type">struct</span> fileproc *fp, proc_t proc, <span class="enscript-type">int</span> fd, user_addr_t  buffer, __unused uint32_t buffersize, int32_t * retval)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SOCKETS</span>
	<span class="enscript-type">struct</span> socket_fdinfo s;
	<span class="enscript-type">int</span> error = 0;

	bzero(&amp;s, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> socket_fdinfo));
	fill_fileinfo(fp, proc, fd, &amp;s.pfi);
	<span class="enscript-keyword">if</span> ((error = fill_socketinfo(so, &amp;s.psi)) == 0) {
		<span class="enscript-keyword">if</span> ((error = copyout(&amp;s, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> socket_fdinfo))) == 0)
				*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> socket_fdinfo);
	}
	<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">so</span>, <span class="enscript-variable-name">fp</span>, <span class="enscript-variable-name">proc</span>, <span class="enscript-variable-name">fd</span>, <span class="enscript-variable-name">buffer</span>)
	*retval = 0;
	<span class="enscript-keyword">return</span> (ENOTSUP);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pid_pseminfo</span>(<span class="enscript-type">struct</span> psemnode *psem, <span class="enscript-type">struct</span> fileproc *fp, proc_t proc, <span class="enscript-type">int</span> fd, user_addr_t  buffer, __unused uint32_t buffersize, int32_t * retval)
{
	<span class="enscript-type">struct</span> psem_fdinfo pseminfo;
	<span class="enscript-type">int</span> error = 0;

	bzero(&amp;pseminfo, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> psem_fdinfo));
	fill_fileinfo(fp, proc, fd, &amp;pseminfo.pfi);

	<span class="enscript-keyword">if</span> ((error = fill_pseminfo(psem, &amp;pseminfo.pseminfo)) == 0) {
		<span class="enscript-keyword">if</span> ((error = copyout(&amp;pseminfo, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> psem_fdinfo))) == 0)
				*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> psem_fdinfo);
	}

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pid_pshminfo</span>(<span class="enscript-type">struct</span> pshmnode *pshm, <span class="enscript-type">struct</span> fileproc *fp, proc_t proc, <span class="enscript-type">int</span> fd, user_addr_t  buffer, __unused uint32_t buffersize, int32_t * retval)
{
	<span class="enscript-type">struct</span> pshm_fdinfo pshminfo;
	<span class="enscript-type">int</span> error = 0;

	bzero(&amp;pshminfo, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pshm_fdinfo));
	fill_fileinfo(fp, proc, fd, &amp;pshminfo.pfi);

	<span class="enscript-keyword">if</span> ((error = fill_pshminfo(pshm, &amp;pshminfo.pshminfo)) == 0) {
		<span class="enscript-keyword">if</span> ((error = copyout(&amp;pshminfo, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pshm_fdinfo))) == 0)
				*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pshm_fdinfo);
	}

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pid_pipeinfo</span>(<span class="enscript-type">struct</span> pipe *  p, <span class="enscript-type">struct</span> fileproc *fp, proc_t proc, <span class="enscript-type">int</span> fd, user_addr_t  buffer, __unused uint32_t buffersize, int32_t * retval)
{
	<span class="enscript-type">struct</span> pipe_fdinfo pipeinfo;
	<span class="enscript-type">int</span> error = 0;

	bzero(&amp;pipeinfo, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pipe_fdinfo));
	fill_fileinfo(fp, proc, fd, &amp;pipeinfo.pfi);
	<span class="enscript-keyword">if</span> ((error = fill_pipeinfo(p, &amp;pipeinfo.pipeinfo)) == 0) {
		<span class="enscript-keyword">if</span> ((error = copyout(&amp;pipeinfo, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pipe_fdinfo))) == 0)
				*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pipe_fdinfo);
	}

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pid_kqueueinfo</span>(<span class="enscript-type">struct</span> kqueue * kq, <span class="enscript-type">struct</span> fileproc *fp, proc_t proc, <span class="enscript-type">int</span> fd, user_addr_t  buffer, __unused uint32_t buffersize, int32_t * retval)
{
	<span class="enscript-type">struct</span> kqueue_fdinfo kqinfo;
	<span class="enscript-type">int</span> error = 0;

	bzero(&amp;kqinfo, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kqueue_fdinfo));

	<span class="enscript-comment">/* not all kq's are associated with a file (e.g. workqkq) */</span>
	<span class="enscript-keyword">if</span> (fp) {
		assert(fd &gt;= 0);
		fill_fileinfo(fp, proc, fd, &amp;kqinfo.pfi);
	}

	<span class="enscript-keyword">if</span> ((error = fill_kqueueinfo(kq, &amp;kqinfo.kqueueinfo)) == 0) {
		<span class="enscript-keyword">if</span> ((error = copyout(&amp;kqinfo, buffer, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kqueue_fdinfo))) == 0)
				*retval = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kqueue_fdinfo);
	}

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pid_atalkinfo</span>(__unused <span class="enscript-type">struct</span> atalk * at, __unused <span class="enscript-type">struct</span> fileproc *fp,  __unused proc_t proc, __unused <span class="enscript-type">int</span> fd, __unused user_addr_t  buffer, __unused uint32_t buffersize, __unused int32_t * retval)
{
	<span class="enscript-keyword">return</span> ENOTSUP;
}



<span class="enscript-comment">/************************** proc_pidfdinfo routine ***************************/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_pidfdinfo</span>(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor,  <span class="enscript-type">int</span> fd, user_addr_t buffer, uint32_t buffersize, int32_t * retval)
{
	proc_t p;
	<span class="enscript-type">int</span> error = ENOTSUP;
	<span class="enscript-type">struct</span> fileproc * fp = NULL;
	uint32_t size;

	<span class="enscript-keyword">switch</span> (flavor) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDVNODEINFO</span>:
			size = PROC_PIDFDVNODEINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDVNODEPATHINFO</span>:
			size = PROC_PIDFDVNODEPATHINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDSOCKETINFO</span>:
			size = PROC_PIDFDSOCKETINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDPSEMINFO</span>:
			size = PROC_PIDFDPSEMINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDPSHMINFO</span>:
			size = PROC_PIDFDPSHMINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDPIPEINFO</span>:
			size = PROC_PIDFDPIPEINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDKQUEUEINFO</span>:
			size = PROC_PIDFDKQUEUEINFO_SIZE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDKQUEUE_EXTINFO</span>:
			size = PROC_PIDFDKQUEUE_EXTINFO_SIZE;
			<span class="enscript-keyword">if</span> (buffer == (user_addr_t)0)
				size = 0;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDATALKINFO</span>:
			size = PROC_PIDFDATALKINFO_SIZE;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">return</span>(EINVAL);

	}

	<span class="enscript-keyword">if</span> (buffersize &lt; size)
		<span class="enscript-keyword">return</span>(ENOMEM);

	<span class="enscript-keyword">if</span> ((p = proc_find(pid)) == PROC_NULL) {
		error = ESRCH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Do we have permission to look into this? */</span>
	<span class="enscript-keyword">if</span> ((error = proc_security_policy(p, PROC_INFO_CALL_PIDFDINFO, flavor, CHECK_SAME_USER)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;

	<span class="enscript-keyword">switch</span> (flavor) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDVNODEINFO</span>: {
			vnode_t vp;
			uint32_t vid=0;

			<span class="enscript-keyword">if</span> ((error = fp_getfvpandvid(p, fd, &amp;fp,  &amp;vp, &amp;vid)) !=0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
			}
			<span class="enscript-comment">/* no need to be under the fdlock */</span>
			error =  pid_vnodeinfo(vp, vid, fp, p, fd, buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDVNODEPATHINFO</span>: {
			vnode_t vp;
			uint32_t vid=0;

			<span class="enscript-keyword">if</span> ((error = fp_getfvpandvid(p, fd, &amp;fp,  &amp;vp, &amp;vid)) !=0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
			}

			<span class="enscript-comment">/* no need to be under the fdlock */</span>
			error =  pid_vnodeinfopath(vp, vid, fp, p, fd, buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDSOCKETINFO</span>: {
			socket_t so; 

			<span class="enscript-keyword">if</span> ((error = fp_getfsock(p, fd, &amp;fp,  &amp;so)) !=0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
			}
			<span class="enscript-comment">/* no need to be under the fdlock */</span>
			error =  pid_socketinfo(so, fp, p, fd, buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDPSEMINFO</span>: {
			<span class="enscript-type">struct</span> psemnode * psem;

			<span class="enscript-keyword">if</span> ((error = fp_getfpsem(p, fd, &amp;fp,  &amp;psem)) !=0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
			}
			<span class="enscript-comment">/* no need to be under the fdlock */</span>
			error =  pid_pseminfo(psem, fp, p, fd, buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDPSHMINFO</span>: {
			<span class="enscript-type">struct</span> pshmnode * pshm;

			<span class="enscript-keyword">if</span> ((error = fp_getfpshm(p, fd, &amp;fp,  &amp;pshm)) !=0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
			}
			<span class="enscript-comment">/* no need to be under the fdlock */</span>
			error =  pid_pshminfo(pshm, fp, p, fd, buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDPIPEINFO</span>: {
			<span class="enscript-type">struct</span> pipe * cpipe;

			<span class="enscript-keyword">if</span> ((error = fp_getfpipe(p, fd, &amp;fp,  &amp;cpipe)) !=0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
			}
			<span class="enscript-comment">/* no need to be under the fdlock */</span>
			error =  pid_pipeinfo(cpipe, fp, p, fd, buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDKQUEUEINFO</span>: {
			<span class="enscript-type">struct</span> kqueue * kq;

			<span class="enscript-keyword">if</span> (fd == -1) {
				<span class="enscript-keyword">if</span> ((kq = p-&gt;p_wqkqueue) == NULL) {
					<span class="enscript-comment">/* wqkqueue is initialized on-demand */</span>
					error = 0;
					<span class="enscript-keyword">break</span>;
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((error = fp_getfkq(p, fd, &amp;fp,  &amp;kq)) != 0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
			}

			<span class="enscript-comment">/* no need to be under the fdlock */</span>
			error = pid_kqueueinfo(kq, fp, p, fd, buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFDKQUEUE_EXTINFO</span>: {
			<span class="enscript-type">struct</span> kqueue * kq;

			<span class="enscript-keyword">if</span> (fd == -1) {
				<span class="enscript-keyword">if</span> ((kq = p-&gt;p_wqkqueue) == NULL) {
					<span class="enscript-comment">/* wqkqueue is initialized on-demand */</span>
					error = 0;
					<span class="enscript-keyword">break</span>;
				}
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((error = fp_getfkq(p, fd, &amp;fp, &amp;kq)) != 0) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
			}
			error = pid_kqueue_extinfo(p, kq, buffer, buffersize, retval);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>: {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;
		}
	}

	<span class="enscript-keyword">if</span> (fp) {
		fp_drop(p, fd, fp , 0);
	}
out1 :
	proc_rele(p);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * Helper function for proc_pidfileportinfo
 */</span>

<span class="enscript-type">struct</span> fileport_info_args {
	<span class="enscript-type">int</span>		fia_flavor;
	user_addr_t	fia_buffer;
	uint32_t	fia_buffersize;
	int32_t		*fia_retval;
};

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">proc_fileport_info</span>(__unused mach_port_name_t name,
	<span class="enscript-type">struct</span> fileglob *fg, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> fileport_info_args *fia = arg;
	<span class="enscript-type">struct</span> fileproc __fileproc, *fp = &amp;__fileproc;
	<span class="enscript-type">int</span> error;

	bzero(fp, <span class="enscript-keyword">sizeof</span> (*fp));
	fp-&gt;f_fglob = fg;

	<span class="enscript-keyword">switch</span> (fia-&gt;fia_flavor) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFILEPORTVNODEPATHINFO</span>: {
		vnode_t vp;

		<span class="enscript-keyword">if</span> (FILEGLOB_DTYPE(fg) != DTYPE_VNODE) {
			error = ENOTSUP;
			<span class="enscript-keyword">break</span>;
		}
		vp = (<span class="enscript-type">struct</span> vnode *)fg-&gt;fg_data;
		error = pid_vnodeinfopath(vp, vnode_vid(vp), fp, PROC_NULL, 0,
		    fia-&gt;fia_buffer, fia-&gt;fia_buffersize, fia-&gt;fia_retval);
	}	<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFILEPORTSOCKETINFO</span>: {
		socket_t so;

		<span class="enscript-keyword">if</span> (FILEGLOB_DTYPE(fg) != DTYPE_SOCKET) {
			error = EOPNOTSUPP;
			<span class="enscript-keyword">break</span>;
		}
		so = (socket_t)fg-&gt;fg_data;
		error = pid_socketinfo(so, fp, PROC_NULL, 0,
		    fia-&gt;fia_buffer, fia-&gt;fia_buffersize, fia-&gt;fia_retval);
	}	<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFILEPORTPSHMINFO</span>: {
		<span class="enscript-type">struct</span> pshmnode *pshm;

		<span class="enscript-keyword">if</span> (FILEGLOB_DTYPE(fg) != DTYPE_PSXSHM) {
			error = EBADF;		<span class="enscript-comment">/* ick - mirror fp_getfpshm */</span>
			<span class="enscript-keyword">break</span>;
		}
		pshm = (<span class="enscript-type">struct</span> pshmnode *)fg-&gt;fg_data;
		error = pid_pshminfo(pshm, fp, PROC_NULL, 0,
		    fia-&gt;fia_buffer, fia-&gt;fia_buffersize, fia-&gt;fia_retval);
	}	<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFILEPORTPIPEINFO</span>: {
		<span class="enscript-type">struct</span> pipe *cpipe;

		<span class="enscript-keyword">if</span> (FILEGLOB_DTYPE(fg) != DTYPE_PIPE) {
			error = EBADF;		<span class="enscript-comment">/* ick - mirror fp_getfpipe */</span>
			<span class="enscript-keyword">break</span>;
		}
		cpipe = (<span class="enscript-type">struct</span> pipe *)fg-&gt;fg_data;
		error = pid_pipeinfo(cpipe, fp, PROC_NULL, 0,
		    fia-&gt;fia_buffer, fia-&gt;fia_buffersize, fia-&gt;fia_retval);
	}	<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/************************* proc_pidfileportinfo routine *********************/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_pidfileportinfo</span>(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor, mach_port_name_t name,
	user_addr_t buffer, uint32_t buffersize, int32_t *retval)
{
	proc_t p;
	<span class="enscript-type">int</span> error = ENOTSUP;
	uint32_t size;
	<span class="enscript-type">struct</span> fileport_info_args fia;

	<span class="enscript-comment">/* fileport types are restricted by file_issendable() */</span>

	<span class="enscript-keyword">switch</span> (flavor) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFILEPORTVNODEPATHINFO</span>:
		size = PROC_PIDFILEPORTVNODEPATHINFO_SIZE;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFILEPORTSOCKETINFO</span>:
		size = PROC_PIDFILEPORTSOCKETINFO_SIZE;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFILEPORTPSHMINFO</span>:
		size = PROC_PIDFILEPORTPSHMINFO_SIZE;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_PIDFILEPORTPIPEINFO</span>:
		size = PROC_PIDFILEPORTPIPEINFO_SIZE;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}
 
	<span class="enscript-keyword">if</span> (buffersize &lt; size)
		<span class="enscript-keyword">return</span> (ENOMEM);
	<span class="enscript-keyword">if</span> ((p = proc_find(pid)) == PROC_NULL) {
		error = ESRCH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Do we have permission to look into this? */</span>
	<span class="enscript-keyword">if</span> ((error = proc_security_policy(p, PROC_INFO_CALL_PIDFILEPORTINFO, flavor, CHECK_SAME_USER)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out1</span>;

	fia.fia_flavor = flavor;
	fia.fia_buffer = buffer;
	fia.fia_buffersize = buffersize;
	fia.fia_retval = retval;

	<span class="enscript-keyword">if</span> (fileport_invoke(p-&gt;task, name,
	    proc_fileport_info, &amp;fia, &amp;error) != KERN_SUCCESS)
		error = EINVAL;
<span class="enscript-reference">out1</span>:
	proc_rele(p);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_security_policy</span>(proc_t targetp, __unused <span class="enscript-type">int</span> callnum, __unused <span class="enscript-type">int</span> flavor, boolean_t check_same_user)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> ((error = mac_proc_check_proc_info(current_proc(), targetp, callnum, flavor)))
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* The 'listpids' call doesn't have a target proc */</span>
	<span class="enscript-keyword">if</span> (targetp == PROC_NULL) {
		assert(callnum == PROC_INFO_CALL_LISTPIDS &amp;&amp; check_same_user == NO_CHECK_SAME_USER);
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/*
	 * Check for 'get information for processes owned by other users' privilege
	 * root has this privilege by default
	 */</span>
	<span class="enscript-keyword">if</span> (priv_check_cred(kauth_cred_get(), PRIV_GLOBAL_PROC_INFO, 0) == 0)
		check_same_user = FALSE;

	<span class="enscript-keyword">if</span> (check_same_user) {
		kauth_cred_t target_cred;
		uid_t        target_uid;

		target_cred = kauth_cred_proc_ref(targetp);
		target_uid  = kauth_cred_getuid(target_cred);
		kauth_cred_unref(&amp;target_cred);

		<span class="enscript-keyword">if</span> (kauth_getuid() != target_uid)
			<span class="enscript-keyword">return</span>(EPERM);
	}

	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_kernmsgbuf</span>(user_addr_t buffer, uint32_t buffersize, int32_t * retval)
{
	<span class="enscript-keyword">if</span> (suser(kauth_cred_get(), (u_short *)0) == 0) {
		<span class="enscript-keyword">return</span>(log_dmesg(buffer, buffersize, retval));
	} <span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span>(EPERM);
}

<span class="enscript-comment">/* ********* process control sets on self only */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">proc_setcontrol</span>(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor, uint64_t arg, user_addr_t buffer, uint32_t buffersize, __unused int32_t * retval)
{
	<span class="enscript-type">struct</span> proc * pself = PROC_NULL;
	<span class="enscript-type">int</span> error = 0;
	uint32_t pcontrol = (uint32_t)arg;
	<span class="enscript-type">struct</span> uthread *ut = NULL;


	pself = current_proc();
	<span class="enscript-keyword">if</span> (pid != pself-&gt;p_pid)
		<span class="enscript-keyword">return</span>(EINVAL);

	<span class="enscript-comment">/* Do we have permission to look into this? */</span>
	<span class="enscript-keyword">if</span> ((error = proc_security_policy(pself, PROC_INFO_CALL_SETCONTROL, flavor, NO_CHECK_SAME_USER)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">switch</span> (flavor) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_SELFSET_PCONTROL</span>: {
			<span class="enscript-keyword">if</span> (pcontrol &gt; P_PCMAX)
				<span class="enscript-keyword">return</span>(EINVAL);
			proc_lock(pself);
			<span class="enscript-comment">/* reset existing control setting while retaining action state */</span>
			pself-&gt;p_pcaction &amp;= PROC_ACTION_MASK;
			<span class="enscript-comment">/* set new control state */</span>
			pself-&gt;p_pcaction |= pcontrol;
			proc_unlock(pself);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_SELFSET_THREADNAME</span>: {
			<span class="enscript-comment">/* PROC_SELFSET_THREADNAME_SIZE = (MAXTHREADNAMESIZE -1) */</span>
			<span class="enscript-keyword">if</span>(buffersize &gt; PROC_SELFSET_THREADNAME_SIZE)
				<span class="enscript-keyword">return</span> ENAMETOOLONG;
			ut = current_uthread();

			<span class="enscript-keyword">if</span>(!ut-&gt;pth_name)
			{
				ut-&gt;pth_name = (<span class="enscript-type">char</span>*)kalloc(MAXTHREADNAMESIZE );
				<span class="enscript-keyword">if</span>(!ut-&gt;pth_name)
					<span class="enscript-keyword">return</span> ENOMEM;
			}
			bzero(ut-&gt;pth_name, MAXTHREADNAMESIZE);
			error = copyin(buffer, ut-&gt;pth_name, buffersize);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_SELFSET_VMRSRCOWNER</span>: {
			<span class="enscript-comment">/* need to to be superuser */</span>
			<span class="enscript-keyword">if</span> (suser(kauth_cred_get(), (u_short *)0) != 0) {
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			proc_lock(pself);
			<span class="enscript-comment">/* reset existing control setting while retaining action state */</span>
			pself-&gt;p_lflag |= P_LVMRSRCOWNER;
			proc_unlock(pself);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_SELFSET_DELAYIDLESLEEP</span>: {
			<span class="enscript-comment">/* mark or clear the process property to delay idle sleep disk IO */</span>
			<span class="enscript-keyword">if</span> (pcontrol != 0)
				OSBitOrAtomic(P_DELAYIDLESLEEP, &amp;pself-&gt;p_flag);
			<span class="enscript-keyword">else</span>
				OSBitAndAtomic(~((uint32_t)P_DELAYIDLESLEEP), &amp;pself-&gt;p_flag);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = ENOTSUP;
	}
	
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span>(error);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_dirtycontrol</span>(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor, uint64_t arg, int32_t *retval) {
	<span class="enscript-type">struct</span> proc *target_p;
	<span class="enscript-type">int</span> error = 0;
	uint32_t pcontrol = (uint32_t)arg;
	kauth_cred_t my_cred, target_cred;
	boolean_t self = FALSE;
	boolean_t child = FALSE;
	boolean_t zombref = FALSE;
	pid_t selfpid;

	target_p = proc_find(pid);

	<span class="enscript-keyword">if</span> (target_p == PROC_NULL) {
		<span class="enscript-keyword">if</span> (flavor == PROC_DIRTYCONTROL_GET) {
			target_p = proc_find_zombref(pid);
			zombref = 1;
		}

		<span class="enscript-keyword">if</span> (target_p == PROC_NULL)
			<span class="enscript-keyword">return</span>(ESRCH);

	}

	my_cred = kauth_cred_get();
	target_cred = kauth_cred_proc_ref(target_p);

	<span class="enscript-comment">/* Do we have permission to look into this? */</span>
	<span class="enscript-keyword">if</span> ((error = proc_security_policy(target_p, PROC_INFO_CALL_DIRTYCONTROL, flavor, NO_CHECK_SAME_USER)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	selfpid = proc_selfpid();
	<span class="enscript-keyword">if</span> (pid == selfpid) {
		self = TRUE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (target_p-&gt;p_ppid == selfpid) {
		child = TRUE;
	}
	
	<span class="enscript-keyword">switch</span> (flavor) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_DIRTYCONTROL_TRACK</span>: {
			<span class="enscript-comment">/* Only allow the process itself, its parent, or root */</span>
			<span class="enscript-keyword">if</span> ((self == FALSE) &amp;&amp; (child == FALSE) &amp;&amp; kauth_cred_issuser(kauth_cred_get()) != TRUE) {
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			error = memorystatus_dirty_track(target_p, pcontrol);
		}
		<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_DIRTYCONTROL_SET</span>: {			
			<span class="enscript-comment">/* Check privileges; use cansignal() here since the process could be terminated */</span>
			<span class="enscript-keyword">if</span> (!cansignal(current_proc(), my_cred, target_p, SIGKILL, 0)) {
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			
			error = memorystatus_dirty_set(target_p, self, pcontrol);	
		}
		<span class="enscript-keyword">break</span>;
		
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_DIRTYCONTROL_GET</span>: {
			<span class="enscript-comment">/* No permissions check - dirty state is freely available */</span>
			<span class="enscript-keyword">if</span> (retval) {
				*retval = memorystatus_dirty_get(target_p);
			} <span class="enscript-keyword">else</span> {
				error = EINVAL;
			}
		}
		<span class="enscript-keyword">break</span>;
		
		<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_DIRTYCONTROL_CLEAR</span>: {			
			<span class="enscript-comment">/* Check privileges; use cansignal() here since the process could be terminated */</span>
			<span class="enscript-keyword">if</span> (!cansignal(current_proc(), my_cred, target_p, SIGKILL, 0)) {
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			
			error = memorystatus_dirty_clear(target_p, pcontrol);	
		}
		<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (zombref)
		proc_drop_zombref(target_p);
	<span class="enscript-keyword">else</span>
		proc_rele(target_p);

	kauth_cred_unref(&amp;target_cred);
	
	<span class="enscript-keyword">return</span>(error);	
}
#<span class="enscript-reference">else</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_dirtycontrol</span>(__unused <span class="enscript-type">int</span> pid, __unused <span class="enscript-type">int</span> flavor, __unused uint64_t arg, __unused int32_t *retval) {
        <span class="enscript-keyword">return</span> ENOTSUP;
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MEMORYSTATUS */</span>

<span class="enscript-comment">/*
 * proc_terminate() provides support for sudden termination.
 * SIGKILL is issued to tracked, clean processes; otherwise,
 * SIGTERM is sent.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_terminate</span>(<span class="enscript-type">int</span> pid, int32_t *retval)
{
	<span class="enscript-type">int</span> error = 0;
	proc_t p;
	kauth_cred_t uc = kauth_cred_get();
	<span class="enscript-type">int</span> sig;

#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/* XXX: Check if these are necessary */</span>
	AUDIT_ARG(pid, pid);
	AUDIT_ARG(signum, sig);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (pid &lt;= 0 || retval == NULL) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> ((p = proc_find(pid)) == NULL) {
		<span class="enscript-keyword">return</span> (ESRCH);
	}

#<span class="enscript-reference">if</span> 0
	<span class="enscript-comment">/* XXX: Check if these are necessary */</span>
	AUDIT_ARG(process, p);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Check privileges; if SIGKILL can be issued, then SIGTERM is also OK */</span>
	<span class="enscript-keyword">if</span> (!cansignal(current_proc(), uc, p, SIGKILL, 0)) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Not allowed to sudden terminate yourself */</span>
	<span class="enscript-keyword">if</span> (p == current_proc()) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>
	<span class="enscript-comment">/* Determine requisite signal to issue */</span>
	sig = memorystatus_on_terminate(p);
#<span class="enscript-reference">else</span>
	sig = SIGTERM;
#<span class="enscript-reference">endif</span>

	proc_set_task_policy(p-&gt;task, THREAD_NULL, TASK_POLICY_ATTRIBUTE,
	                     TASK_POLICY_TERMINATED, TASK_POLICY_ENABLE);

	psignal(p, sig);
	*retval = sig;

<span class="enscript-reference">out</span>:
	proc_rele(p);
	
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/*
 * copy stat64 structure into vinfo_stat structure.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">munge_vinfo_stat</span>(<span class="enscript-type">struct</span> stat64 *sbp, <span class="enscript-type">struct</span> vinfo_stat *vsbp)
{
        bzero(vsbp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vinfo_stat));

	vsbp-&gt;vst_dev = sbp-&gt;st_dev;
	vsbp-&gt;vst_mode = sbp-&gt;st_mode;
	vsbp-&gt;vst_nlink = sbp-&gt;st_nlink;
	vsbp-&gt;vst_ino = sbp-&gt;st_ino;
	vsbp-&gt;vst_uid = sbp-&gt;st_uid;
	vsbp-&gt;vst_gid = sbp-&gt;st_gid;
	vsbp-&gt;vst_atime = sbp-&gt;st_atimespec.tv_sec;
	vsbp-&gt;vst_atimensec = sbp-&gt;st_atimespec.tv_nsec;
	vsbp-&gt;vst_mtime = sbp-&gt;st_mtimespec.tv_sec;
	vsbp-&gt;vst_mtimensec = sbp-&gt;st_mtimespec.tv_nsec;
	vsbp-&gt;vst_ctime = sbp-&gt;st_ctimespec.tv_sec;
	vsbp-&gt;vst_ctimensec = sbp-&gt;st_ctimespec.tv_nsec;
	vsbp-&gt;vst_birthtime = sbp-&gt;st_birthtimespec.tv_sec;
	vsbp-&gt;vst_birthtimensec = sbp-&gt;st_birthtimespec.tv_nsec;
	vsbp-&gt;vst_size = sbp-&gt;st_size;
	vsbp-&gt;vst_blocks = sbp-&gt;st_blocks;
	vsbp-&gt;vst_blksize = sbp-&gt;st_blksize;
	vsbp-&gt;vst_flags = sbp-&gt;st_flags;
	vsbp-&gt;vst_gen = sbp-&gt;st_gen;
	vsbp-&gt;vst_rdev = sbp-&gt;st_rdev;
	vsbp-&gt;vst_qspare[0] = sbp-&gt;st_qspare[0];
	vsbp-&gt;vst_qspare[1] = sbp-&gt;st_qspare[1];
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_pid_rusage</span>(<span class="enscript-type">int</span> pid, <span class="enscript-type">int</span> flavor, user_addr_t buffer, __unused int32_t *retval)
{
	proc_t          p;
	<span class="enscript-type">int</span>             error;
	<span class="enscript-type">int</span>             zombie = 0;

	<span class="enscript-keyword">if</span> ((p = proc_find(pid)) == PROC_NULL) {
		<span class="enscript-keyword">if</span> ((p = proc_find_zombref(pid)) == PROC_NULL) {
			<span class="enscript-keyword">return</span> (ESRCH);
		}
		zombie = 1;
	}

	<span class="enscript-comment">/* Do we have permission to look into this? */</span>
	<span class="enscript-keyword">if</span> ((error = proc_security_policy(p, PROC_INFO_CALL_PIDRUSAGE, flavor, CHECK_SAME_USER)))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	error = proc_get_rusage(p, flavor, buffer, zombie);

<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (zombie)
		proc_drop_zombref(p);
	<span class="enscript-keyword">else</span>
		proc_rele(p);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">proc_archinfo</span>(proc_t p, <span class="enscript-type">struct</span> proc_archinfo *pai)
{
	proc_lock(p);
	pai-&gt;p_cputype = p-&gt;p_cputype;
	pai-&gt;p_cpusubtype = p-&gt;p_cpusubtype;
	proc_unlock(p);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_pidcoalitioninfo</span>(proc_t p, <span class="enscript-type">struct</span> proc_pidcoalitioninfo *ppci)
{
	bzero(ppci, <span class="enscript-keyword">sizeof</span>(*ppci));
	proc_coalitionids(p, ppci-&gt;coalition_id);
}



<span class="enscript-comment">/* 
 * Wrapper to provide NOTE_EXIT_DETAIL and NOTE_EXITSTATUS
 * It mimics the data that is typically captured by the 
 * EVFILT_PROC, NOTE_EXIT event mechanism.
 * See filt_proc() in kern_event.c.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">proc_pidnoteexit</span>(proc_t p, uint64_t flags, uint32_t *data)
{
	uint32_t exit_data = 0;
	uint32_t exit_flags = (uint32_t)flags;

	proc_lock(p);

	<span class="enscript-comment">/*
	 * Allow access to the parent of the exiting
	 * child or the parent debugger only.
	 */</span>
	<span class="enscript-keyword">do</span> {
		pid_t selfpid = proc_selfpid();

		<span class="enscript-keyword">if</span> (p-&gt;p_ppid == selfpid)
			<span class="enscript-keyword">break</span>;  <span class="enscript-comment">/* parent =&gt; ok */</span>
	
		<span class="enscript-keyword">if</span> ((p-&gt;p_lflag &amp; P_LTRACED) != 0 &amp;&amp;
		    (p-&gt;p_oppid == selfpid))
			<span class="enscript-keyword">break</span>;  <span class="enscript-comment">/* parent-in-waiting =&gt; ok */</span>

		proc_unlock(p);
		<span class="enscript-keyword">return</span> (EACCES);
	} <span class="enscript-keyword">while</span> (0);
	
	<span class="enscript-keyword">if</span> ((exit_flags &amp; NOTE_EXITSTATUS) != 0) {
		<span class="enscript-comment">/* The signal and exit status */</span>
		exit_data |= (p-&gt;p_xstat &amp; NOTE_PDATAMASK);
	}

	<span class="enscript-keyword">if</span> ((exit_flags &amp; NOTE_EXIT_DETAIL) != 0) {
		<span class="enscript-comment">/* The exit detail */</span>
		<span class="enscript-keyword">if</span> ((p-&gt;p_lflag &amp; P_LTERM_DECRYPTFAIL) != 0) {
			exit_data |= NOTE_EXIT_DECRYPTFAIL;
		}

		<span class="enscript-keyword">if</span> ((p-&gt;p_lflag &amp; P_LTERM_JETSAM) != 0) {
			exit_data |= NOTE_EXIT_MEMORY;

			<span class="enscript-keyword">switch</span> (p-&gt;p_lflag &amp; P_JETSAM_MASK) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">P_JETSAM_VMPAGESHORTAGE</span>:
				exit_data |= NOTE_EXIT_MEMORY_VMPAGESHORTAGE;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">P_JETSAM_VMTHRASHING</span>:
				exit_data |= NOTE_EXIT_MEMORY_VMTHRASHING;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">P_JETSAM_FCTHRASHING</span>:
				exit_data |= NOTE_EXIT_MEMORY_FCTHRASHING;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">P_JETSAM_VNODE</span>:
				exit_data |= NOTE_EXIT_MEMORY_VNODE;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">P_JETSAM_HIWAT</span>:
				exit_data |= NOTE_EXIT_MEMORY_HIWAT;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">P_JETSAM_PID</span>:
				exit_data |= NOTE_EXIT_MEMORY_PID;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">P_JETSAM_IDLEEXIT</span>:
				exit_data |= NOTE_EXIT_MEMORY_IDLE;
				<span class="enscript-keyword">break</span>;
			}
		}

		<span class="enscript-keyword">if</span> ((p-&gt;p_csflags &amp; CS_KILLED) != 0) {
			exit_data |= NOTE_EXIT_CSERROR;
		}
	}

	proc_unlock(p);

	*data = exit_data;

	<span class="enscript-keyword">return</span> (0);
}

</pre>
<hr />
</body></html>