<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>posix_sem.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">posix_sem.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 *	Copyright (c) 1990, 1996-1998 Apple Computer, Inc.
 *	All Rights Reserved.
 */</span>
<span class="enscript-comment">/*
 * posix_sem.c : Support for POSIX semaphore APIs
 *
 *	File:	posix_sem.c
 *	Author:	Ananthakrishna Ramesh
 *
 * HISTORY
 * 2-Sep-1999	A.Ramesh
 *	Created for MacOSX
 *
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/tty.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/semaphore.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_info.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_prot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/semaphore.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/sync_policy.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/kern_return.h&gt;</span>


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_flag</span> f_fglob-&gt;fg_flag
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_type</span> f_fglob-&gt;fg_ops-&gt;fo_type
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_msgcount</span> f_fglob-&gt;fg_msgcount
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_cred</span> f_fglob-&gt;fg_cred
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_ops</span> f_fglob-&gt;fg_ops
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_offset</span> f_fglob-&gt;fg_offset
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_data</span> f_fglob-&gt;fg_data
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PSEMNAMLEN</span>	31	<span class="enscript-comment">/* maximum name segment length we bother with */</span>

<span class="enscript-type">struct</span> pseminfo {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	psem_flags;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	psem_usecount;
	mode_t		psem_mode;
	uid_t		psem_uid;
	gid_t		psem_gid;
	<span class="enscript-type">char</span>		psem_name[PSEMNAMLEN + 1];	<span class="enscript-comment">/* segment name */</span>
	semaphore_t	psem_semobject;
	<span class="enscript-type">struct</span> label *	psem_label;
	pid_t		psem_creator_pid;
	uint64_t	psem_creator_uniqueid;
};
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PSEMINFO_NULL</span> (struct pseminfo *)0

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PSEM_NONE</span>	1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PSEM_DEFINED</span>	2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PSEM_ALLOCATED</span>	4
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PSEM_MAPPED</span>	8
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PSEM_INUSE</span>	0x10
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PSEM_REMOVED</span>	0x20
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PSEM_INCREATE</span>	0x40
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PSEM_INDELETE</span>	0x80

<span class="enscript-type">struct</span>	psemcache {
	LIST_ENTRY(psemcache) psem_hash;	<span class="enscript-comment">/* hash chain */</span>
	<span class="enscript-type">struct</span>	pseminfo *pseminfo;		<span class="enscript-comment">/* vnode the name refers to */</span>
	<span class="enscript-type">int</span>	psem_nlen;		<span class="enscript-comment">/* length of name */</span>
	<span class="enscript-type">char</span>	psem_name[PSEMNAMLEN + 1];	<span class="enscript-comment">/* segment name */</span>
};
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PSEMCACHE_NULL</span> (struct psemcache *)0

<span class="enscript-type">struct</span>	psemstats {
	<span class="enscript-type">long</span>	goodhits;		<span class="enscript-comment">/* hits that we can really use */</span>
	<span class="enscript-type">long</span>	neghits;		<span class="enscript-comment">/* negative hits that we can use */</span>
	<span class="enscript-type">long</span>	badhits;		<span class="enscript-comment">/* hits we must drop */</span>
	<span class="enscript-type">long</span>	falsehits;		<span class="enscript-comment">/* hits with id mismatch */</span>
	<span class="enscript-type">long</span>	miss;		<span class="enscript-comment">/* misses */</span>
	<span class="enscript-type">long</span>	longnames;		<span class="enscript-comment">/* long names that ignore cache */</span>
};

<span class="enscript-type">struct</span> psemname {
	<span class="enscript-type">char</span>	*psem_nameptr;	<span class="enscript-comment">/* pointer to looked up name */</span>
	<span class="enscript-type">long</span>	psem_namelen;	<span class="enscript-comment">/* length of looked up component */</span>
	u_int32_t	psem_hash;	<span class="enscript-comment">/* hash value of looked up name */</span>
};

<span class="enscript-type">struct</span> psemnode {
	<span class="enscript-type">struct</span> pseminfo *pinfo;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> readcnt;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> writecnt;
#<span class="enscript-reference">endif</span>
};
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PSEMNODE_NULL</span> (struct psemnode *)0


#<span class="enscript-reference">define</span> <span class="enscript-function-name">PSEMHASH</span>(pnp) \
	(&amp;psemhashtbl[(pnp)-&gt;psem_hash &amp; psemhash])
<span class="enscript-function-name">LIST_HEAD</span>(psemhashhead, psemcache) *psemhashtbl;	<span class="enscript-comment">/* Hash Table */</span>
u_long	psemhash;				<span class="enscript-comment">/* size of hash table - 1 */</span>
<span class="enscript-type">long</span>	psemnument;			<span class="enscript-comment">/* number of cache entries allocated */</span>
<span class="enscript-type">long</span>	posix_sem_max = 10000;		<span class="enscript-comment">/* tunable for max POSIX semaphores */</span>
					<span class="enscript-comment">/* 10000 limits to ~1M of memory */</span>
<span class="enscript-function-name">SYSCTL_NODE</span>(_kern, KERN_POSIX, posix, CTLFLAG_RW | CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;Posix&quot;</span>);
<span class="enscript-function-name">SYSCTL_NODE</span>(_kern_posix, OID_AUTO, sem, CTLFLAG_RW | CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;Semaphores&quot;</span>);
<span class="enscript-function-name">SYSCTL_LONG</span> (_kern_posix_sem, OID_AUTO, max, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;posix_sem_max, <span class="enscript-string">&quot;max&quot;</span>);

<span class="enscript-type">struct</span> psemstats psemstats;		<span class="enscript-comment">/* cache effectiveness statistics */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">psem_access</span>(<span class="enscript-type">struct</span> pseminfo *pinfo, <span class="enscript-type">int</span> mode, kauth_cred_t cred);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">psem_cache_search</span>(<span class="enscript-type">struct</span> pseminfo **,
				<span class="enscript-type">struct</span> psemname *, <span class="enscript-type">struct</span> psemcache **);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">psem_delete</span>(<span class="enscript-type">struct</span> pseminfo * pinfo);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">psem_read</span> (<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio,
			    <span class="enscript-type">int</span> flags, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">psem_write</span> (<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio,
			    <span class="enscript-type">int</span> flags, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">psem_ioctl</span> (<span class="enscript-type">struct</span> fileproc *fp, u_long com,
			    caddr_t data, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">psem_select</span> (<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">int</span> which, <span class="enscript-type">void</span> *wql, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">psem_closefile</span> (<span class="enscript-type">struct</span> fileglob *fp, vfs_context_t ctx);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">psem_kqfilter</span> (<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> knote *kn, vfs_context_t ctx);

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> fileops psemops = {
	DTYPE_PSXSEM,
	psem_read,
	psem_write,
	psem_ioctl,
	psem_select,
	psem_closefile,
	psem_kqfilter,
	NULL
};

<span class="enscript-type">static</span> lck_grp_t       *psx_sem_subsys_lck_grp;
<span class="enscript-type">static</span> lck_grp_attr_t  *psx_sem_subsys_lck_grp_attr;
<span class="enscript-type">static</span> lck_attr_t      *psx_sem_subsys_lck_attr;
<span class="enscript-type">static</span> lck_mtx_t        psx_sem_subsys_mutex;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PSEM_SUBSYS_LOCK</span>() lck_mtx_lock(&amp; psx_sem_subsys_mutex)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PSEM_SUBSYS_UNLOCK</span>() lck_mtx_unlock(&amp; psx_sem_subsys_mutex)


<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">psem_cache_add</span>(<span class="enscript-type">struct</span> pseminfo *psemp, <span class="enscript-type">struct</span> psemname *pnp, <span class="enscript-type">struct</span> psemcache *pcp);
<span class="enscript-comment">/* Initialize the mutex governing access to the posix sem subsystem */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">psem_lock_init</span>( <span class="enscript-type">void</span> )
{

    psx_sem_subsys_lck_grp_attr = lck_grp_attr_alloc_init();

    psx_sem_subsys_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;posix shared memory&quot;</span>, psx_sem_subsys_lck_grp_attr);

    psx_sem_subsys_lck_attr = lck_attr_alloc_init();
    lck_mtx_init(&amp; psx_sem_subsys_mutex, psx_sem_subsys_lck_grp, psx_sem_subsys_lck_attr);
}

<span class="enscript-comment">/*
 * Lookup an entry in the cache 
 * 
 * 
 * status of -1 is returned if matches
 * If the lookup determines that the name does not exist
 * (negative cacheing), a status of ENOENT is returned. If the lookup
 * fails, a status of zero is returned.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">psem_cache_search</span>(<span class="enscript-type">struct</span> pseminfo **psemp, <span class="enscript-type">struct</span> psemname *pnp,
		  <span class="enscript-type">struct</span> psemcache **pcache)
{
	<span class="enscript-type">struct</span> psemcache *pcp, *nnp;
	<span class="enscript-type">struct</span> psemhashhead *pcpp;

	<span class="enscript-keyword">if</span> (pnp-&gt;psem_namelen &gt; PSEMNAMLEN) {
		psemstats.longnames++;
		<span class="enscript-keyword">return</span> (0);
	}

	pcpp = PSEMHASH(pnp);
	<span class="enscript-keyword">for</span> (pcp = pcpp-&gt;lh_first; pcp != 0; pcp = nnp) {
		nnp = pcp-&gt;psem_hash.le_next;
		<span class="enscript-keyword">if</span> (pcp-&gt;psem_nlen == pnp-&gt;psem_namelen &amp;&amp;
		    !bcmp(pcp-&gt;psem_name, pnp-&gt;psem_nameptr, 						(u_int)pcp-&gt; psem_nlen))
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (pcp == 0) {
		psemstats.miss++;
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-comment">/* We found a &quot;positive&quot; match, return the vnode */</span>
        <span class="enscript-keyword">if</span> (pcp-&gt;pseminfo) {
		psemstats.goodhits++;
		<span class="enscript-comment">/* TOUCH(ncp); */</span>
		*psemp = pcp-&gt;pseminfo;
		*pcache = pcp;
		<span class="enscript-keyword">return</span> (-1);
	}

	<span class="enscript-comment">/*
	 * We found a &quot;negative&quot; match, ENOENT notifies client of this match.
	 * The nc_vpid field records whether this is a whiteout.
	 */</span>
	psemstats.neghits++;
	<span class="enscript-keyword">return</span> (ENOENT);
}

<span class="enscript-comment">/*
 * Add an entry to the cache.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">psem_cache_add</span>(<span class="enscript-type">struct</span> pseminfo *psemp, <span class="enscript-type">struct</span> psemname *pnp, <span class="enscript-type">struct</span> psemcache *pcp)
{
	<span class="enscript-type">struct</span> psemhashhead *pcpp;
	<span class="enscript-type">struct</span> pseminfo *dpinfo;
	<span class="enscript-type">struct</span> psemcache *dpcp;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (pnp-&gt;psem_namelen &gt; PSEMNAMLEN)
		panic(<span class="enscript-string">&quot;cache_enter: name too long&quot;</span>);
#<span class="enscript-reference">endif</span>


	<span class="enscript-comment">/*  if the entry has already been added by some one else return */</span>
	<span class="enscript-keyword">if</span> (psem_cache_search(&amp;dpinfo, pnp, &amp;dpcp) == -1) {
		<span class="enscript-keyword">return</span>(EEXIST);
	}
	<span class="enscript-keyword">if</span> (psemnument &gt;= posix_sem_max)
		<span class="enscript-keyword">return</span>(ENOSPC);
	psemnument++;
	<span class="enscript-comment">/*
	 * Fill in cache info, if vp is NULL this is a &quot;negative&quot; cache entry.
	 * For negative entries, we have to record whether it is a whiteout.
	 * the whiteout flag is stored in the nc_vpid field which is
	 * otherwise unused.
	 */</span>
	pcp-&gt;pseminfo = psemp;
	pcp-&gt;psem_nlen = pnp-&gt;psem_namelen;
	bcopy(pnp-&gt;psem_nameptr, pcp-&gt;psem_name, (<span class="enscript-type">unsigned</span>)pcp-&gt;psem_nlen);
	pcpp = PSEMHASH(pnp);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	{
		<span class="enscript-type">struct</span> psemcache *p;

		<span class="enscript-keyword">for</span> (p = pcpp-&gt;lh_first; p != 0; p = p-&gt;psem_hash.le_next)
			<span class="enscript-keyword">if</span> (p == pcp)
				panic(<span class="enscript-string">&quot;psem:cache_enter duplicate&quot;</span>);
	}
#<span class="enscript-reference">endif</span>
	LIST_INSERT_HEAD(pcpp, pcp, psem_hash);
	<span class="enscript-keyword">return</span>(0);
}

<span class="enscript-comment">/*
 * Name cache initialization, from vfs_init() when we are booting
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">psem_cache_init</span>(<span class="enscript-type">void</span>)
{
	psemhashtbl = hashinit(posix_sem_max / 2, M_SHM, &amp;psemhash);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">psem_cache_delete</span>(<span class="enscript-type">struct</span> psemcache *pcp)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (pcp-&gt;psem_hash.le_prev == 0)
		panic(<span class="enscript-string">&quot;psem namecache purge le_prev&quot;</span>);
	<span class="enscript-keyword">if</span> (pcp-&gt;psem_hash.le_next == pcp)
		panic(<span class="enscript-string">&quot;namecache purge le_next&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DIAGNOSTIC */</span>
	LIST_REMOVE(pcp, psem_hash);
	pcp-&gt;psem_hash.le_prev = NULL;	
	psemnument--;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NOT_USED</span>
<span class="enscript-comment">/*
 * Invalidate a all entries to particular vnode.
 * 
 * We actually just increment the v_id, that will do it. The entries will
 * be purged by lookup as they get found. If the v_id wraps around, we
 * need to ditch the entire cache, to avoid confusion. No valid vnode will
 * ever have (v_id == 0).
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">psem_cache_purge</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> psemcache *pcp;
	<span class="enscript-type">struct</span> psemhashhead *pcpp;

	<span class="enscript-keyword">for</span> (pcpp = &amp;psemhashtbl[psemhash]; pcpp &gt;= psemhashtbl; pcpp--) {
		<span class="enscript-keyword">while</span> ( (pcp = pcpp-&gt;lh_first) )
			psem_cache_delete(pcp);
	}
}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* NOT_USED */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">sem_open</span>(proc_t p, <span class="enscript-type">struct</span> sem_open_args *uap, user_addr_t *retval)
{
	size_t i;
	<span class="enscript-type">int</span> indx, error;
	<span class="enscript-type">struct</span> psemname nd;
	<span class="enscript-type">struct</span> pseminfo *pinfo;
	<span class="enscript-type">struct</span> fileproc *fp = NULL;
	<span class="enscript-type">char</span> *pnbuf = NULL;
	<span class="enscript-type">struct</span> pseminfo *new_pinfo = PSEMINFO_NULL;
	<span class="enscript-type">struct</span> psemnode *new_pnode = PSEMNODE_NULL;
	<span class="enscript-type">struct</span> psemcache *pcache = PSEMCACHE_NULL;
	<span class="enscript-type">char</span> * nameptr;
	<span class="enscript-type">char</span> * cp;
	size_t pathlen, plen;
	<span class="enscript-type">int</span> fmode ;
	<span class="enscript-type">int</span> cmode = uap-&gt;mode;
	<span class="enscript-type">int</span> value = uap-&gt;value;
	<span class="enscript-type">int</span> incache = 0;
	<span class="enscript-type">struct</span> psemcache *pcp = PSEMCACHE_NULL;
	kern_return_t kret = KERN_INVALID_ADDRESS;	<span class="enscript-comment">/* default fail */</span>
	
	AUDIT_ARG(fflags, uap-&gt;oflag);
	AUDIT_ARG(mode, uap-&gt;mode);
	AUDIT_ARG(value32, uap-&gt;value);

	pinfo = PSEMINFO_NULL;

	<span class="enscript-comment">/*
	 * Preallocate everything we might need up front to avoid taking
	 * and dropping the lock, opening us up to race conditions.
	 */</span>
	MALLOC_ZONE(pnbuf, caddr_t, MAXPATHLEN, M_NAMEI, M_WAITOK);
	<span class="enscript-keyword">if</span> (pnbuf == NULL) {
		error = ENOSPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	pathlen = MAXPATHLEN;
	error = copyinstr(uap-&gt;name, pnbuf, MAXPATHLEN, &amp;pathlen);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	AUDIT_ARG(text, pnbuf);
	<span class="enscript-keyword">if</span> ( (pathlen &gt; PSEMNAMLEN) ) {
		error = ENAMETOOLONG;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PSXSEM_NAME_RESTRICT</span>
	nameptr = pnbuf;
	<span class="enscript-keyword">if</span> (*nameptr == <span class="enscript-string">'/'</span>) {
		<span class="enscript-keyword">while</span> (*(nameptr++) == <span class="enscript-string">'/'</span>) {
			plen--;
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
        } <span class="enscript-keyword">else</span> {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PSXSEM_NAME_RESTRICT */</span>

	plen = pathlen;
	nameptr = pnbuf;
	nd.psem_nameptr = nameptr;
	nd.psem_namelen = plen;
	nd.psem_hash = 0;

        <span class="enscript-keyword">for</span> (cp = nameptr, i=1; *cp != 0 &amp;&amp; i &lt;= plen; i++, cp++) {
               nd.psem_hash += (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>)*cp * i;
	}

	<span class="enscript-comment">/*
	 * attempt to allocate a new fp; if unsuccessful, the fp will be
	 * left unmodified (NULL).
	 */</span>
	error = falloc(p, &amp;fp, &amp;indx, vfs_context_current());
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	<span class="enscript-comment">/*
	 * We allocate a new entry if we are less than the maximum
	 * allowed and the one at the front of the LRU list is in use.
	 * Otherwise we use the one at the front of the LRU list.
	 */</span>
	MALLOC(pcp, <span class="enscript-type">struct</span> psemcache *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> psemcache), M_SHM, M_WAITOK|M_ZERO);
	<span class="enscript-keyword">if</span> (pcp == PSEMCACHE_NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	MALLOC(new_pinfo, <span class="enscript-type">struct</span> pseminfo *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pseminfo), M_SHM, M_WAITOK|M_ZERO);
	<span class="enscript-keyword">if</span> (new_pinfo == NULL) {
		error = ENOSPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_posixsem_label_init(new_pinfo);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Provisionally create the semaphore in the new_pinfo; we have to do
	 * this here to prevent locking later.  We use the value of kret to
	 * signal success or failure, which is why we set its default value
	 * to KERN_INVALID_ADDRESS, above.
	 */</span>
	
	fmode = FFLAGS(uap-&gt;oflag);
	
	<span class="enscript-keyword">if</span>((fmode &amp; O_CREAT)) {
		
		<span class="enscript-keyword">if</span>((value &lt; 0) || (value &gt; SEM_VALUE_MAX)) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
		
		kret = semaphore_create(kernel_task, &amp;new_pinfo-&gt;psem_semobject, SYNC_POLICY_FIFO, value);
	
		<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
			<span class="enscript-keyword">switch</span> (kret) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_RESOURCE_SHORTAGE</span>:
					error = ENOMEM;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_PROTECTION_FAILURE</span>:
					error = EACCES;
					<span class="enscript-keyword">break</span>;
				<span class="enscript-reference">default</span>:
					error = EINVAL;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
	}
	
	MALLOC(new_pnode, <span class="enscript-type">struct</span> psemnode *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> psemnode), M_SHM, M_WAITOK|M_ZERO);
	<span class="enscript-keyword">if</span> (new_pnode == NULL) {
		error = ENOSPC;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	PSEM_SUBSYS_LOCK();
	error = psem_cache_search(&amp;pinfo, &amp;nd, &amp;pcache);

	<span class="enscript-keyword">if</span> (error == ENOENT) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_locked</span>;

	}
	<span class="enscript-keyword">if</span> (!error) {
		incache = 0;
	} <span class="enscript-keyword">else</span>
		incache = 1;

	cmode &amp;=  ALLPERMS;

	<span class="enscript-keyword">if</span> (((fmode &amp; (O_CREAT | O_EXCL))==(O_CREAT | O_EXCL)) &amp;&amp;  incache) {
		<span class="enscript-comment">/* sem exists and opened O_EXCL */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">notyet</span>
		<span class="enscript-keyword">if</span> (pinfo-&gt;psem_flags &amp; PSEM_INDELETE) {
		}
#<span class="enscript-reference">endif</span> 
		AUDIT_ARG(posix_ipc_perm, pinfo-&gt;psem_uid,
			pinfo-&gt;psem_gid, pinfo-&gt;psem_mode);
		error = EEXIST;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_locked</span>;
	}
	<span class="enscript-keyword">if</span> (((fmode &amp; (O_CREAT | O_EXCL))== O_CREAT) &amp;&amp;  incache) {
		<span class="enscript-comment">/* As per POSIX, O_CREAT has no effect */</span>
		fmode &amp;= ~O_CREAT;
	}

	<span class="enscript-keyword">if</span> ( (fmode &amp; O_CREAT) ) {
		<span class="enscript-comment">/* create a new one (commit the allocation) */</span>
		pinfo = new_pinfo;
		pinfo-&gt;psem_flags = PSEM_DEFINED | PSEM_INCREATE;
		pinfo-&gt;psem_usecount = 1;
		pinfo-&gt;psem_mode = cmode;
		pinfo-&gt;psem_uid = kauth_getuid();
		pinfo-&gt;psem_gid = kauth_getgid();
		bcopy(pnbuf, &amp;pinfo-&gt;psem_name[0], PSEMNAMLEN);
		pinfo-&gt;psem_name[PSEMNAMLEN]= 0;
		pinfo-&gt;psem_flags &amp;= ~PSEM_DEFINED;
		pinfo-&gt;psem_flags |= PSEM_ALLOCATED;
		pinfo-&gt;psem_creator_pid = p-&gt;p_pid;
		pinfo-&gt;psem_creator_uniqueid = p-&gt;p_uniqueid;
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		error = mac_posixsem_check_create(kauth_cred_get(), nameptr);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_locked</span>;
		}
		mac_posixsem_label_associate(kauth_cred_get(), pinfo, nameptr);
#<span class="enscript-reference">endif</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* semaphore should exist as it is without  O_CREAT */</span>
		<span class="enscript-keyword">if</span> (!incache) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_locked</span>;
		}
		<span class="enscript-keyword">if</span>( pinfo-&gt;psem_flags &amp; PSEM_INDELETE) {
			error = ENOENT;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_locked</span>;
		}	
		AUDIT_ARG(posix_ipc_perm, pinfo-&gt;psem_uid,
			pinfo-&gt;psem_gid, pinfo-&gt;psem_mode);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		error = mac_posixsem_check_open(kauth_cred_get(), pinfo);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_locked</span>;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> ( (error = psem_access(pinfo, fmode, kauth_cred_get())) ) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_locked</span>;
		}
	}

	<span class="enscript-keyword">if</span> (!incache) {
		<span class="enscript-comment">/* if successful, this will consume the pcp */</span>
		<span class="enscript-keyword">if</span> ( (error = psem_cache_add(pinfo, &amp;nd, pcp)) ) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad_locked</span>;
		}
	}
	pinfo-&gt;psem_flags &amp;= ~PSEM_INCREATE;
	pinfo-&gt;psem_usecount++;
	new_pnode-&gt;pinfo = pinfo;
	PSEM_SUBSYS_UNLOCK();

	<span class="enscript-comment">/*
	 * if incache, we did not use the new pcp or the new pcp or the
	 * new . and we must free them.
	 */</span>
	<span class="enscript-keyword">if</span> (incache) {
		FREE(pcp, M_SHM);
		pcp = PSEMCACHE_NULL;
		<span class="enscript-keyword">if</span> (new_pinfo != PSEMINFO_NULL) {
			<span class="enscript-comment">/* return value ignored - we can't _not_ do this */</span>
			(<span class="enscript-type">void</span>)semaphore_destroy(kernel_task, new_pinfo-&gt;psem_semobject);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
			mac_posixsem_label_destroy(new_pinfo);
#<span class="enscript-reference">endif</span>
			FREE(new_pinfo, M_SHM);
			new_pinfo = PSEMINFO_NULL;
		}
	}

	proc_fdlock(p);
	fp-&gt;f_flag = fmode &amp; FMASK;
	fp-&gt;f_ops = &amp;psemops;
	fp-&gt;f_data = (caddr_t)new_pnode;
	procfdtbl_releasefd(p, indx, NULL);
	fp_drop(p, indx, fp, 1);
	proc_fdunlock(p);

	*retval = CAST_USER_ADDR_T(indx);
	FREE_ZONE(pnbuf, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">bad_locked</span>:
	PSEM_SUBSYS_UNLOCK();
<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">if</span> (pcp != PSEMCACHE_NULL)
		FREE(pcp, M_SHM);

	<span class="enscript-keyword">if</span> (new_pnode != PSEMNODE_NULL)
		FREE(new_pnode, M_SHM);

	<span class="enscript-keyword">if</span> (fp != NULL)
		fp_free(p, indx, fp);

	<span class="enscript-keyword">if</span> (new_pinfo != PSEMINFO_NULL) {
		<span class="enscript-comment">/*
		 * kret signals whether or not we successfully created a
		 * Mach semaphore for this semaphore; if so, we need to
		 * destroy it here.
		 */</span>
		<span class="enscript-keyword">if</span> (kret == KERN_SUCCESS) {
			<span class="enscript-comment">/* return value ignored - we can't _not_ do this */</span>
			(<span class="enscript-type">void</span>)semaphore_destroy(kernel_task, new_pinfo-&gt;psem_semobject);
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_posixsem_label_destroy(new_pinfo);
#<span class="enscript-reference">endif</span>
		FREE(new_pinfo, M_SHM);
	}

	<span class="enscript-keyword">if</span> (pnbuf != NULL)
		FREE_ZONE(pnbuf, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * XXX This code is repeated in several places
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">psem_access</span>(<span class="enscript-type">struct</span> pseminfo *pinfo, <span class="enscript-type">int</span> mode, kauth_cred_t cred)
{
	<span class="enscript-type">int</span> mode_req = ((mode &amp; FREAD) ? S_IRUSR : 0) |
		       ((mode &amp; FWRITE) ? S_IWUSR : 0);

	<span class="enscript-comment">/* Otherwise, user id 0 always gets access. */</span>
	<span class="enscript-keyword">if</span> (!suser(cred, NULL))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">return</span>(posix_cred_access(cred, pinfo-&gt;psem_uid, pinfo-&gt;psem_gid, pinfo-&gt;psem_mode, mode_req));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sem_unlink</span>(__unused proc_t p, <span class="enscript-type">struct</span> sem_unlink_args *uap, __unused int32_t *retval)
{
	size_t i;
	<span class="enscript-type">int</span> error=0;
	<span class="enscript-type">struct</span> psemname nd;
	<span class="enscript-type">struct</span> pseminfo *pinfo;
	<span class="enscript-type">char</span> * pnbuf;
	<span class="enscript-type">char</span> * nameptr;
	<span class="enscript-type">char</span> * cp;
	size_t pathlen, plen;
	<span class="enscript-type">int</span> incache = 0;
	<span class="enscript-type">struct</span> psemcache *pcache = PSEMCACHE_NULL;

	pinfo = PSEMINFO_NULL;

	MALLOC_ZONE(pnbuf, caddr_t, MAXPATHLEN, M_NAMEI, M_WAITOK);
	<span class="enscript-keyword">if</span> (pnbuf == NULL) {
		<span class="enscript-keyword">return</span>(ENOSPC);		<span class="enscript-comment">/* XXX non-standard */</span>
	}
	pathlen = MAXPATHLEN;
	error = copyinstr(uap-&gt;name, pnbuf, MAXPATHLEN, &amp;pathlen);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	AUDIT_ARG(text, pnbuf);
	<span class="enscript-keyword">if</span> (pathlen &gt; PSEMNAMLEN) {
		error = ENAMETOOLONG;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">PSXSEM_NAME_RESTRICT</span>
	nameptr = pnbuf;
	<span class="enscript-keyword">if</span> (*nameptr == <span class="enscript-string">'/'</span>) {
		<span class="enscript-keyword">while</span> (*(nameptr++) == <span class="enscript-string">'/'</span>) {
			plen--;
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}
        } <span class="enscript-keyword">else</span> {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PSXSEM_NAME_RESTRICT */</span>

	plen = pathlen;
	nameptr = pnbuf;
	nd.psem_nameptr = nameptr;
	nd.psem_namelen = plen;
	nd. psem_hash =0;

        <span class="enscript-keyword">for</span> (cp = nameptr, i=1; *cp != 0 &amp;&amp; i &lt;= plen; i++, cp++) {
               nd.psem_hash += (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span>)*cp * i;
	}

	PSEM_SUBSYS_LOCK();
	error = psem_cache_search(&amp;pinfo, &amp;nd, &amp;pcache);

	<span class="enscript-keyword">if</span> (error == ENOENT) {
		PSEM_SUBSYS_UNLOCK();
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;

	}
	<span class="enscript-keyword">if</span> (!error) {
		PSEM_SUBSYS_UNLOCK();
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	} <span class="enscript-keyword">else</span>
		incache = 1;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_posixsem_check_unlink(kauth_cred_get(), pinfo, nameptr);
	<span class="enscript-keyword">if</span> (error) {
		PSEM_SUBSYS_UNLOCK();
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ( (error = psem_access(pinfo, pinfo-&gt;psem_mode, kauth_cred_get())) ) {
		PSEM_SUBSYS_UNLOCK();
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> ((pinfo-&gt;psem_flags &amp; (PSEM_DEFINED | PSEM_ALLOCATED))==0) {
		PSEM_SUBSYS_UNLOCK();
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-keyword">if</span> ( (pinfo-&gt;psem_flags &amp; PSEM_INDELETE) ) {
		PSEM_SUBSYS_UNLOCK();
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	AUDIT_ARG(posix_ipc_perm, pinfo-&gt;psem_uid, pinfo-&gt;psem_gid,
		  pinfo-&gt;psem_mode);

	pinfo-&gt;psem_flags |= PSEM_INDELETE;
	pinfo-&gt;psem_usecount--;

	<span class="enscript-keyword">if</span> (!pinfo-&gt;psem_usecount) {
		psem_delete(pinfo);
		FREE(pinfo,M_SHM);
	} <span class="enscript-keyword">else</span>
		pinfo-&gt;psem_flags |= PSEM_REMOVED;

	psem_cache_delete(pcache);
	PSEM_SUBSYS_UNLOCK();
	FREE(pcache, M_SHM);
	error = 0;
<span class="enscript-reference">bad</span>:
	FREE_ZONE(pnbuf, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sem_close</span>(proc_t p, <span class="enscript-type">struct</span> sem_close_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> fd = CAST_DOWN_EXPLICIT(<span class="enscript-type">int</span>,uap-&gt;sem);
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">int</span> error = 0;

	AUDIT_ARG(fd, fd); <span class="enscript-comment">/* XXX This seems wrong; uap-&gt;sem is a pointer */</span>

	proc_fdlock(p);
	error = fp_lookup(p,fd, &amp;fp, 1);
	<span class="enscript-keyword">if</span> (error) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span>(error);
	}
	procfdtbl_markclosefd(p, fd);
	fileproc_drain(p, fp);
	fdrelse(p, fd);
	error = closef_locked(fp, fp-&gt;f_fglob, p);
	fileproc_free(fp);
	proc_fdunlock(p);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sem_wait</span>(proc_t p, <span class="enscript-type">struct</span> sem_wait_args *uap, int32_t *retval)
{
	__pthread_testcancel(1);
	<span class="enscript-keyword">return</span>(sem_wait_nocancel(p, (<span class="enscript-type">struct</span> sem_wait_nocancel_args *)uap, retval));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sem_wait_nocancel</span>(proc_t p, <span class="enscript-type">struct</span> sem_wait_nocancel_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> fd = CAST_DOWN_EXPLICIT(<span class="enscript-type">int</span>,uap-&gt;sem);
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">struct</span> pseminfo * pinfo;
	<span class="enscript-type">struct</span> psemnode * pnode ;
	kern_return_t kret;
	<span class="enscript-type">int</span> error;

	error = fp_getfpsem(p, fd, &amp;fp, &amp;pnode);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (((pnode = (<span class="enscript-type">struct</span> psemnode *)fp-&gt;f_data)) == PSEMNODE_NULL )  {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	PSEM_SUBSYS_LOCK();
	<span class="enscript-keyword">if</span> ((pinfo = pnode-&gt;pinfo) == PSEMINFO_NULL) {
		PSEM_SUBSYS_UNLOCK();
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> ((pinfo-&gt;psem_flags &amp; (PSEM_DEFINED | PSEM_ALLOCATED)) 
			!= PSEM_ALLOCATED) {
		PSEM_SUBSYS_UNLOCK();
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_posixsem_check_wait(kauth_cred_get(), pinfo);
	<span class="enscript-keyword">if</span> (error) {
		PSEM_SUBSYS_UNLOCK();
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span>
	PSEM_SUBSYS_UNLOCK();
	kret = semaphore_wait(pinfo-&gt;psem_semobject);
	<span class="enscript-keyword">switch</span> (kret) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_INVALID_ADDRESS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_PROTECTION_FAILURE</span>:
		error = EACCES;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_ABORTED</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_OPERATION_TIMED_OUT</span>:
		error = EINTR;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SUCCESS</span>:
		error = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">out</span>:
	fp_drop(p, fd, fp, 0);
	<span class="enscript-keyword">return</span>(error);

}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sem_trywait</span>(proc_t p, <span class="enscript-type">struct</span> sem_trywait_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> fd = CAST_DOWN_EXPLICIT(<span class="enscript-type">int</span>,uap-&gt;sem);
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">struct</span> pseminfo * pinfo;
	<span class="enscript-type">struct</span> psemnode * pnode ;
	kern_return_t kret;
	mach_timespec_t wait_time;
	<span class="enscript-type">int</span> error;
	
	error = fp_getfpsem(p, fd, &amp;fp, &amp;pnode);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (((pnode = (<span class="enscript-type">struct</span> psemnode *)fp-&gt;f_data)) == PSEMNODE_NULL )  {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	PSEM_SUBSYS_LOCK();
	<span class="enscript-keyword">if</span> ((pinfo = pnode-&gt;pinfo) == PSEMINFO_NULL) {
		PSEM_SUBSYS_UNLOCK();
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> ((pinfo-&gt;psem_flags &amp; (PSEM_DEFINED | PSEM_ALLOCATED)) 
			!= PSEM_ALLOCATED) {
		PSEM_SUBSYS_UNLOCK();
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_posixsem_check_wait(kauth_cred_get(), pinfo);
	<span class="enscript-keyword">if</span> (error) {
		PSEM_SUBSYS_UNLOCK();
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span>
	PSEM_SUBSYS_UNLOCK();
	wait_time.tv_sec = 0;
	wait_time.tv_nsec = 0;

	kret = semaphore_timedwait(pinfo-&gt;psem_semobject, MACH_TIMESPEC_ZERO);
	<span class="enscript-keyword">switch</span> (kret) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_INVALID_ADDRESS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_PROTECTION_FAILURE</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_ABORTED</span>:
		error = EINTR;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_OPERATION_TIMED_OUT</span>:
		error = EAGAIN;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SUCCESS</span>:
		error = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">out</span>:
	fp_drop(p, fd, fp, 0);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sem_post</span>(proc_t p, <span class="enscript-type">struct</span> sem_post_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> fd = CAST_DOWN_EXPLICIT(<span class="enscript-type">int</span>,uap-&gt;sem);
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">struct</span> pseminfo * pinfo;
	<span class="enscript-type">struct</span> psemnode * pnode ;
	kern_return_t kret;
	<span class="enscript-type">int</span> error;

	error = fp_getfpsem(p, fd, &amp;fp, &amp;pnode);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (((pnode = (<span class="enscript-type">struct</span> psemnode *)fp-&gt;f_data)) == PSEMNODE_NULL )  {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	PSEM_SUBSYS_LOCK();
	<span class="enscript-keyword">if</span> ((pinfo = pnode-&gt;pinfo) == PSEMINFO_NULL) {
		PSEM_SUBSYS_UNLOCK();
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> ((pinfo-&gt;psem_flags &amp; (PSEM_DEFINED | PSEM_ALLOCATED)) 
			!= PSEM_ALLOCATED) {
		PSEM_SUBSYS_UNLOCK();
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_posixsem_check_post(kauth_cred_get(), pinfo);
	<span class="enscript-keyword">if</span> (error) {
		PSEM_SUBSYS_UNLOCK();
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
#<span class="enscript-reference">endif</span>
	PSEM_SUBSYS_UNLOCK();
	kret = semaphore_signal(pinfo-&gt;psem_semobject);
	<span class="enscript-keyword">switch</span> (kret) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_INVALID_ADDRESS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_PROTECTION_FAILURE</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_ABORTED</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_OPERATION_TIMED_OUT</span>:
		error = EINTR;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SUCCESS</span>:
		error = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}
<span class="enscript-reference">out</span>:
	fp_drop(p, fd, fp, 0);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">psem_close</span>(<span class="enscript-type">struct</span> psemnode *pnode, __unused <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">int</span> error=0;
	<span class="enscript-type">struct</span> pseminfo *pinfo;

	PSEM_SUBSYS_LOCK();
	<span class="enscript-keyword">if</span> ((pinfo = pnode-&gt;pinfo) == PSEMINFO_NULL){
		PSEM_SUBSYS_UNLOCK();
		<span class="enscript-keyword">return</span>(EINVAL);
	}

	<span class="enscript-keyword">if</span> ((pinfo-&gt;psem_flags &amp; PSEM_ALLOCATED) != PSEM_ALLOCATED) {
		PSEM_SUBSYS_UNLOCK();
		<span class="enscript-keyword">return</span>(EINVAL);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span>(!pinfo-&gt;psem_usecount) {
		kprintf(<span class="enscript-string">&quot;negative usecount in psem_close\n&quot;</span>);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DIAGNOSTIC */</span>
	pinfo-&gt;psem_usecount--;

 	<span class="enscript-keyword">if</span> ((pinfo-&gt;psem_flags &amp; PSEM_REMOVED) &amp;&amp; !pinfo-&gt;psem_usecount) {
		PSEM_SUBSYS_UNLOCK();
		<span class="enscript-comment">/* lock dropped as only semaphore is destroyed here */</span>
		error = psem_delete(pinfo);
		FREE(pinfo,M_SHM);
	} <span class="enscript-keyword">else</span> {
		PSEM_SUBSYS_UNLOCK();
	}
	<span class="enscript-comment">/* subsystem lock is dropped when we get here */</span>
	FREE(pnode, M_SHM);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">psem_closefile</span>(<span class="enscript-type">struct</span> fileglob *fg, __unused vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * Not locked as psem_close is called only from here and is locked
	 * properly
	 */</span>
	error =  psem_close(((<span class="enscript-type">struct</span> psemnode *)fg-&gt;fg_data), fg-&gt;fg_flag);

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">psem_delete</span>(<span class="enscript-type">struct</span> pseminfo * pinfo)
{
	kern_return_t kret;

	kret = semaphore_destroy(kernel_task, pinfo-&gt;psem_semobject);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_posixsem_label_destroy(pinfo);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">switch</span> (kret) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_INVALID_ADDRESS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_PROTECTION_FAILURE</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_ABORTED</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_OPERATION_TIMED_OUT</span>:
		<span class="enscript-keyword">return</span> (EINTR);
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_SUCCESS</span>:
		<span class="enscript-keyword">return</span>(0);
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span> (EINVAL);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">psem_read</span>(__unused <span class="enscript-type">struct</span> fileproc *fp, __unused <span class="enscript-type">struct</span> uio *uio, 
		  __unused <span class="enscript-type">int</span> flags, __unused vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span>(ENOTSUP);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">psem_write</span>(__unused <span class="enscript-type">struct</span> fileproc *fp, __unused <span class="enscript-type">struct</span> uio *uio, 
		   __unused <span class="enscript-type">int</span> flags, __unused vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span>(ENOTSUP);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">psem_ioctl</span>(__unused <span class="enscript-type">struct</span> fileproc *fp, __unused u_long com, 
			__unused caddr_t data, __unused vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span>(ENOTSUP);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">psem_select</span>(__unused <span class="enscript-type">struct</span> fileproc *fp, __unused <span class="enscript-type">int</span> which, 
			__unused <span class="enscript-type">void</span> *wql, __unused vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span>(ENOTSUP);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">psem_kqfilter</span>(__unused <span class="enscript-type">struct</span> fileproc *fp, __unused <span class="enscript-type">struct</span> knote *kn, 
				__unused vfs_context_t ctx)
{
	<span class="enscript-keyword">return</span> (ENOTSUP);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fill_pseminfo</span>(<span class="enscript-type">struct</span> psemnode *pnode, <span class="enscript-type">struct</span> psem_info * info)
{
	<span class="enscript-type">struct</span> pseminfo *pinfo;
	<span class="enscript-type">struct</span> vinfo_stat  *sb;

	PSEM_SUBSYS_LOCK();
	<span class="enscript-keyword">if</span> ((pinfo = pnode-&gt;pinfo) == PSEMINFO_NULL){
		PSEM_SUBSYS_UNLOCK();
		<span class="enscript-keyword">return</span>(EINVAL);
	}

#<span class="enscript-reference">if</span> 0
	<span class="enscript-keyword">if</span> ((pinfo-&gt;psem_flags &amp; PSEM_ALLOCATED) != PSEM_ALLOCATED) {
		PSEM_SUBSYS_UNLOCK();
		<span class="enscript-keyword">return</span>(EINVAL);
	}
#<span class="enscript-reference">endif</span>

	sb = &amp;info-&gt;psem_stat;
	bzero(sb, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> vinfo_stat));

    	sb-&gt;vst_mode = pinfo-&gt;psem_mode;
    	sb-&gt;vst_uid = pinfo-&gt;psem_uid;
    	sb-&gt;vst_gid = pinfo-&gt;psem_gid;
    	sb-&gt;vst_size = pinfo-&gt;psem_usecount;
	bcopy(&amp;pinfo-&gt;psem_name[0], &amp;info-&gt;psem_name[0], PSEMNAMLEN+1);

	PSEM_SUBSYS_UNLOCK();
	<span class="enscript-keyword">return</span>(0);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">psem_label_associate</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> vnode *vp, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> psemnode *pnode;
	<span class="enscript-type">struct</span> pseminfo *psem;

	PSEM_SUBSYS_LOCK();
	pnode = (<span class="enscript-type">struct</span> psemnode *)fp-&gt;f_fglob-&gt;fg_data;
	<span class="enscript-keyword">if</span> (pnode != NULL) {
		psem = pnode-&gt;pinfo;
		<span class="enscript-keyword">if</span> (psem != NULL)
			mac_posixsem_vnode_label_associate(
				vfs_context_ucred(ctx), psem, psem-&gt;psem_label,
				vp, vp-&gt;v_label);
	}
	PSEM_SUBSYS_UNLOCK();
}
#<span class="enscript-reference">endif</span>
      
</pre>
<hr />
</body></html>