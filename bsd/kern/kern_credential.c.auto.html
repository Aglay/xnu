<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_credential.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_credential.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2004-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

<span class="enscript-comment">/*
 * Kernel Authorization framework: Management of process/thread credentials
 * and identity information.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>	<span class="enscript-comment">/* XXX trim includes */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/acct.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ucred.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/timeb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/times.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sdt.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>	<span class="enscript-comment">/* For manifest constants in posix_cred_access */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/message.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_security.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MACH_ASSERT</span>
# <span class="enscript-reference">undef</span> <span class="enscript-variable-name">MACH_ASSERT</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MACH_ASSERT</span> 1	<span class="enscript-comment">/* XXX so bogus */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/_label.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">mach_kauth_cred_uthread_update</span>( <span class="enscript-type">void</span> );

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CRED_DIAGNOSTIC</span> 0

# <span class="enscript-reference">define</span> <span class="enscript-function-name">NULLCRED_CHECK</span>(_c)	do {if (!IS_VALID_CRED(_c)) panic(<span class="enscript-string">&quot;%s: bad credential %p&quot;</span>, __FUNCTION__,_c);} while(0)

<span class="enscript-comment">/* Set to 1 to turn on KAUTH_DEBUG for kern_credential.c */</span>
#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">KAUTH_DEBUG</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">KAUTH_DEBUG</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">K_UUID_FMT</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">K_UUID_FMT</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">K_UUID_ARG</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">K_UUID_ARG</span>
#<span class="enscript-reference">endif</span>

# <span class="enscript-reference">define</span> <span class="enscript-variable-name">K_UUID_FMT</span> <span class="enscript-string">&quot;%08x:%08x:%08x:%08x&quot;</span>
# <span class="enscript-reference">define</span> <span class="enscript-function-name">K_UUID_ARG</span>(_u) *(int *)&amp;_u.g_guid[0],*(int *)&amp;_u.g_guid[4],*(int *)&amp;_u.g_guid[8],*(int *)&amp;_u.g_guid[12]
# <span class="enscript-reference">define</span> <span class="enscript-function-name">KAUTH_DEBUG</span>(fmt, args...)      do { printf(<span class="enscript-string">&quot;%s:%d: &quot;</span> fmt <span class="enscript-string">&quot;\n&quot;</span>, __PRETTY_FUNCTION__, __LINE__ , ##args); } while (0)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Credential debugging; we can track entry into a function that might
 * change a credential, and we can track actual credential changes that
 * result.
 *
 * Note:	Does *NOT* currently include per-thread credential changes
 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_CRED</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DEBUG_CRED_ENTER</span>		printf
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DEBUG_CRED_CHANGE</span>		printf
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kauth_cred_print</span>(kauth_cred_t cred);

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>	<span class="enscript-comment">/* needed for get_backtrace( ) */</span>

<span class="enscript-type">int</span> <span class="enscript-function-name">is_target_cred</span>( kauth_cred_t the_cred );
<span class="enscript-type">void</span> <span class="enscript-function-name">get_backtrace</span>( <span class="enscript-type">void</span> );

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_dump_creds</span>( __unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, 
							  __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req );
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_dump_cred_backtraces</span>( __unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, 
							 __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req );

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_STACK_DEPTH</span> 8
<span class="enscript-type">struct</span> cred_backtrace {
	<span class="enscript-type">int</span>				depth;
	<span class="enscript-type">void</span> *			stack[ MAX_STACK_DEPTH ];
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> cred_backtrace cred_backtrace;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_CRED_BUFFER_SLOTS</span> 200
<span class="enscript-type">struct</span> cred_debug_buffer {
	<span class="enscript-type">int</span>				next_slot;
	cred_backtrace	stack_buffer[ MAX_CRED_BUFFER_SLOTS ];	
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> cred_debug_buffer cred_debug_buffer;
cred_debug_buffer * cred_debug_buf_p = NULL;

#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* !DEBUG_CRED */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DEBUG_CRED_ENTER</span>(fmt, ...)	do {} while (0)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DEBUG_CRED_CHANGE</span>(fmt, ...)	do {} while (0)

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !DEBUG_CRED */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_EXT_RESOLVER</span>
<span class="enscript-comment">/*
 * Interface to external identity resolver.
 *
 * The architecture of the interface is simple; the external resolver calls
 * in to get work, then calls back with completed work.  It also calls us
 * to let us know that it's (re)started, so that we can resubmit work if it
 * times out.
 */</span>

<span class="enscript-type">static</span> lck_mtx_t *kauth_resolver_mtx;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KAUTH_RESOLVER_LOCK</span>()	lck_mtx_lock(kauth_resolver_mtx);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KAUTH_RESOLVER_UNLOCK</span>()	lck_mtx_unlock(kauth_resolver_mtx);

<span class="enscript-type">static</span> <span class="enscript-type">volatile</span> pid_t	kauth_resolver_identity;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_identitysvc_has_registered;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_resolver_registered;
<span class="enscript-type">static</span> uint32_t	kauth_resolver_sequence;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_resolver_timeout = 30;	<span class="enscript-comment">/* default: 30 seconds */</span>

<span class="enscript-type">struct</span> kauth_resolver_work {
	TAILQ_ENTRY(kauth_resolver_work) kr_link;
	<span class="enscript-type">struct</span> kauth_identity_extlookup kr_work;
	uint64_t	kr_extend;
	uint32_t	kr_seqno;
	<span class="enscript-type">int</span>		kr_refs;
	<span class="enscript-type">int</span>		kr_flags;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KAUTH_REQUEST_UNSUBMITTED</span>	(1&lt;&lt;0)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KAUTH_REQUEST_SUBMITTED</span>		(1&lt;&lt;1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KAUTH_REQUEST_DONE</span>		(1&lt;&lt;2)
	<span class="enscript-type">int</span>		kr_result;
};

<span class="enscript-function-name">TAILQ_HEAD</span>(kauth_resolver_unsubmitted_head, kauth_resolver_work) kauth_resolver_unsubmitted;
<span class="enscript-function-name">TAILQ_HEAD</span>(kauth_resolver_submitted_head, kauth_resolver_work)	kauth_resolver_submitted;
<span class="enscript-function-name">TAILQ_HEAD</span>(kauth_resolver_done_head, kauth_resolver_work)	kauth_resolver_done;

<span class="enscript-comment">/* Number of resolver timeouts between logged complaints */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KAUTH_COMPLAINT_INTERVAL</span> 1000
<span class="enscript-type">int</span> kauth_resolver_timeout_cnt = 0;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_resolver_submit(<span class="enscript-type">struct</span> kauth_identity_extlookup *lkp, uint64_t extend_data);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_resolver_complete(user_addr_t message);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_resolver_getwork(user_addr_t message);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_resolver_getwork2(user_addr_t message);
<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span> __KERNEL_IS_WAITING_ON_EXTERNAL_CREDENTIAL_RESOLVER__(
	<span class="enscript-type">struct</span> kauth_resolver_work *); 

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KAUTH_CACHES_MAX_SIZE</span> 10000 <span class="enscript-comment">/* Max # entries for both groups and id caches */</span>

<span class="enscript-type">struct</span> kauth_identity {
	TAILQ_ENTRY(kauth_identity) ki_link;
	<span class="enscript-type">int</span>	ki_valid;
	uid_t	ki_uid;
	gid_t	ki_gid;
	<span class="enscript-type">int</span>	ki_supgrpcnt;
	gid_t	ki_supgrps[NGROUPS];
	guid_t	ki_guid;
	ntsid_t ki_ntsid;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*ki_name;	<span class="enscript-comment">/* string name from string cache */</span>
	<span class="enscript-comment">/*
	 * Expiry times are the earliest time at which we will disregard the
	 * cached state and go to userland.  Before then if the valid bit is
	 * set, we will return the cached value.  If it's not set, we will
	 * not go to userland to resolve, just assume that there is no answer
	 * available.
	 */</span>
	time_t	ki_groups_expiry;
	time_t	ki_guid_expiry;
	time_t	ki_ntsid_expiry;
};

<span class="enscript-type">static</span> <span class="enscript-function-name">TAILQ_HEAD</span>(kauth_identity_head, kauth_identity) kauth_identities;
<span class="enscript-type">static</span> lck_mtx_t *kauth_identity_mtx;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KAUTH_IDENTITY_LOCK</span>()	lck_mtx_lock(kauth_identity_mtx);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KAUTH_IDENTITY_UNLOCK</span>()	lck_mtx_unlock(kauth_identity_mtx);
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KAUTH_IDENTITY_CACHEMAX_DEFAULT</span> 100	<span class="enscript-comment">/* XXX default sizing? */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> kauth_identity_cachemax = KAUTH_IDENTITY_CACHEMAX_DEFAULT;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> kauth_identity_count;

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> kauth_identity *<span class="enscript-function-name">kauth_identity_alloc</span>(uid_t uid, gid_t gid, guid_t *guidp, time_t guid_expiry,
	ntsid_t *ntsidp, time_t ntsid_expiry, <span class="enscript-type">int</span> supgrpcnt, gid_t *supgrps, time_t groups_expiry,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> nametype);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	kauth_identity_register_and_free(<span class="enscript-type">struct</span> kauth_identity *kip);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	kauth_identity_updatecache(<span class="enscript-type">struct</span> kauth_identity_extlookup *elp, <span class="enscript-type">struct</span> kauth_identity *kip, uint64_t extend_data);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	kauth_identity_trimcache(<span class="enscript-type">int</span> newsize);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	kauth_identity_lru(<span class="enscript-type">struct</span> kauth_identity *kip);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_identity_guid_expired(<span class="enscript-type">struct</span> kauth_identity *kip);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_identity_ntsid_expired(<span class="enscript-type">struct</span> kauth_identity *kip);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_identity_find_uid(uid_t uid, <span class="enscript-type">struct</span> kauth_identity *kir, <span class="enscript-type">char</span> *getname);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_identity_find_gid(gid_t gid, <span class="enscript-type">struct</span> kauth_identity *kir, <span class="enscript-type">char</span> *getname);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_identity_find_guid(guid_t *guidp, <span class="enscript-type">struct</span> kauth_identity *kir, <span class="enscript-type">char</span> *getname);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_identity_find_ntsid(ntsid_t *ntsid, <span class="enscript-type">struct</span> kauth_identity *kir, <span class="enscript-type">char</span> *getname);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_identity_find_nam(<span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> valid, <span class="enscript-type">struct</span> kauth_identity *kir);

<span class="enscript-type">struct</span> kauth_group_membership {
	TAILQ_ENTRY(kauth_group_membership) gm_link;
	uid_t	gm_uid;		<span class="enscript-comment">/* the identity whose membership we're recording */</span>
	gid_t	gm_gid;		<span class="enscript-comment">/* group of which they are a member */</span>
	time_t	gm_expiry;	<span class="enscript-comment">/* TTL for the membership, or 0 for persistent entries */</span>
	<span class="enscript-type">int</span>	gm_flags;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KAUTH_GROUP_ISMEMBER</span>	(1&lt;&lt;0)
};

<span class="enscript-function-name">TAILQ_HEAD</span>(kauth_groups_head, kauth_group_membership) kauth_groups;
<span class="enscript-type">static</span> lck_mtx_t *kauth_groups_mtx;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KAUTH_GROUPS_LOCK</span>()	lck_mtx_lock(kauth_groups_mtx);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KAUTH_GROUPS_UNLOCK</span>()	lck_mtx_unlock(kauth_groups_mtx);
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KAUTH_GROUPS_CACHEMAX_DEFAULT</span> 100	<span class="enscript-comment">/* XXX default sizing? */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> kauth_groups_cachemax = KAUTH_GROUPS_CACHEMAX_DEFAULT;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> kauth_groups_count;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_groups_expired(<span class="enscript-type">struct</span> kauth_group_membership *gm);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	kauth_groups_lru(<span class="enscript-type">struct</span> kauth_group_membership *gm);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	kauth_groups_updatecache(<span class="enscript-type">struct</span> kauth_identity_extlookup *el);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	kauth_groups_trimcache(<span class="enscript-type">int</span> newsize);

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* CONFIG_EXT_RESOLVER */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KAUTH_CRED_TABLE_SIZE</span> 97

<span class="enscript-function-name">TAILQ_HEAD</span>(kauth_cred_entry_head, ucred);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> kauth_cred_entry_head * kauth_cred_table_anchor = NULL;

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KAUTH_CRED_HASH_DEBUG</span>	0

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">kauth_cred_add</span>(kauth_cred_t new_cred);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">kauth_cred_remove</span>(kauth_cred_t cred);
<span class="enscript-type">static</span> inline u_long <span class="enscript-function-name">kauth_cred_hash</span>(<span class="enscript-type">const</span> uint8_t *datap, <span class="enscript-type">int</span> data_len, u_long start_key);
<span class="enscript-type">static</span> u_long <span class="enscript-function-name">kauth_cred_get_hashkey</span>(kauth_cred_t cred);
<span class="enscript-type">static</span> kauth_cred_t <span class="enscript-function-name">kauth_cred_update</span>(kauth_cred_t old_cred, kauth_cred_t new_cred, boolean_t retain_auditinfo);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">kauth_cred_unref_hashlocked</span>(kauth_cred_t *credp);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KAUTH_CRED_HASH_DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_cred_count = 0;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kauth_cred_hash_print</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kauth_cred_print</span>(kauth_cred_t cred);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_EXT_RESOLVER</span>

<span class="enscript-comment">/*
 *  __KERNEL_IS_WAITING_ON_EXTERNAL_CREDENTIAL_RESOLVER__
 *
 * Description:  Waits for the user space daemon to respond to the request
 *               we made. Function declared non inline to be visible in 
 *               stackshots and spindumps as well as debugging.
 *
 * Parameters:   workp                     Work queue entry.
 *
 * Returns:      0                         on Success.
 *               EIO                       if Resolver is dead.
 *               EINTR                     thread interrupted in msleep
 *               EWOULDBLOCK               thread timed out in msleep
 *               ERESTART                  returned by msleep.
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((noinline)) <span class="enscript-type">int</span> 
<span class="enscript-function-name">__KERNEL_IS_WAITING_ON_EXTERNAL_CREDENTIAL_RESOLVER__</span>(
	<span class="enscript-type">struct</span> kauth_resolver_work  *workp)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> timespec ts;
	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-comment">/* we could compute a better timeout here */</span>
		ts.tv_sec = kauth_resolver_timeout;
		ts.tv_nsec = 0;
		error = msleep(workp, kauth_resolver_mtx, PCATCH, <span class="enscript-string">&quot;kr_submit&quot;</span>, &amp;ts);
		<span class="enscript-comment">/* request has been completed? */</span>
		<span class="enscript-keyword">if</span> ((error == 0) &amp;&amp; (workp-&gt;kr_flags &amp; KAUTH_REQUEST_DONE))
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/* woken because the resolver has died? */</span>
		<span class="enscript-keyword">if</span> (kauth_resolver_identity == 0) {
			error = EIO;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* an error? */</span>
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> error;
}


<span class="enscript-comment">/*
 * kauth_resolver_init
 *
 * Description:	Initialize the daemon side of the credential identity resolver
 *
 * Parameters:	(void)
 *
 * Returns:	(void)
 *
 * Notes:	Initialize the credential identity resolver for use; the
 *		credential identity resolver is the KPI used by the user
 *		space credential identity resolver daemon to communicate
 *		with the kernel via the identitysvc() system call..
 *
 *		This is how membership in more than 16 groups (1 effective
 *		and 15 supplementary) is supported, and also how UID's,
 *		UUID's, and so on, are translated to/from POSIX credential
 *		values.
 *
 *		The credential identity resolver operates by attempting to
 *		determine identity first from the credential, then from
 *		the kernel credential identity cache, and finally by
 *		enqueueing a request to a user space daemon.
 *
 *		This function is called from kauth_init() in the file
 *		kern_authorization.c.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_resolver_init</span>(<span class="enscript-type">void</span>)
{
	TAILQ_INIT(&amp;kauth_resolver_unsubmitted);
	TAILQ_INIT(&amp;kauth_resolver_submitted);
	TAILQ_INIT(&amp;kauth_resolver_done);
	kauth_resolver_sequence = 31337;
	kauth_resolver_mtx = lck_mtx_alloc_init(kauth_lck_grp, 0<span class="enscript-comment">/*LCK_ATTR_NULL*/</span>);
}


<span class="enscript-comment">/*
 * kauth_resolver_submit
 *
 * Description:	Submit an external credential identity resolution request to
 *		the user space daemon.
 *
 * Parameters:	lkp				A pointer to an external
 *						lookup request
 *		extend_data			extended data for kr_extend
 *
 * Returns:	0				Success
 *		EWOULDBLOCK			No resolver registered
 *		EINTR				Operation interrupted (e.g. by
 *						a signal)
 *		ENOMEM				Could not allocate work item
 *	copyinstr:EFAULT			Bad message from user space
 *	workp-&gt;kr_result:???			An error from the user space
 *						daemon (includes ENOENT!)
 *
 * Implicit returns:
 *		*lkp				Modified
 *
 * Notes:	Allocate a work queue entry, submit the work and wait for
 *		the operation to either complete or time out.  Outstanding
 *		operations may also be cancelled.
 *
 *		Submission is by means of placing the item on a work queue
 *		which is serviced by an external resolver thread calling
 *		into the kernel.  The caller then sleeps until timeout,
 *		cancellation, or an external resolver thread calls in with
 *		a result message to kauth_resolver_complete().  All of these
 *		events wake the caller back up.
 *
 *		This code is called from either kauth_cred_ismember_gid()
 *		for a group membership request, or it is called from
 *		kauth_cred_cache_lookup() when we get a cache miss.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_resolver_submit</span>(<span class="enscript-type">struct</span> kauth_identity_extlookup *lkp, uint64_t extend_data)
{
	<span class="enscript-type">struct</span> kauth_resolver_work *workp, *killp;
	<span class="enscript-type">struct</span> timespec ts;
	<span class="enscript-type">int</span>	error, shouldfree;
	
	<span class="enscript-comment">/* no point actually blocking if the resolver isn't up yet */</span>
	<span class="enscript-keyword">if</span> (kauth_resolver_identity == 0) {
		<span class="enscript-comment">/*
		 * We've already waited an initial &lt;kauth_resolver_timeout&gt;
		 * seconds with no result.
		 *
		 * Sleep on a stack address so no one wakes us before timeout;
		 * we sleep a half a second in case we are a high priority
		 * process, so that memberd doesn't starve while we are in a
		 * tight loop between user and kernel, eating all the CPU.
		 */</span>
		error = tsleep(&amp;ts, PZERO | PCATCH, <span class="enscript-string">&quot;kr_submit&quot;</span>, hz/2);
		<span class="enscript-keyword">if</span> (kauth_resolver_identity == 0) {
			<span class="enscript-comment">/*
			 * if things haven't changed while we were asleep,
			 * tell the caller we couldn't get an authoritative
			 * answer.
			 */</span>
			<span class="enscript-keyword">return</span>(EWOULDBLOCK);
		}
	}
		
	MALLOC(workp, <span class="enscript-type">struct</span> kauth_resolver_work *, <span class="enscript-keyword">sizeof</span>(*workp), M_KAUTH, M_WAITOK);
	<span class="enscript-keyword">if</span> (workp == NULL)
		<span class="enscript-keyword">return</span>(ENOMEM);

	workp-&gt;kr_work = *lkp;
	workp-&gt;kr_extend = extend_data;
	workp-&gt;kr_refs = 1;
	workp-&gt;kr_flags = KAUTH_REQUEST_UNSUBMITTED;
	workp-&gt;kr_result = 0;

	<span class="enscript-comment">/*
	 * We insert the request onto the unsubmitted queue, the call in from
	 * the resolver will it to the submitted thread when appropriate.
	 */</span>
	KAUTH_RESOLVER_LOCK();
	workp-&gt;kr_seqno = workp-&gt;kr_work.el_seqno = kauth_resolver_sequence++;
	workp-&gt;kr_work.el_result = KAUTH_EXTLOOKUP_INPROG;

	<span class="enscript-comment">/*
	 * XXX We *MUST NOT* attempt to coalesce identical work items due to
	 * XXX the inability to ensure order of update of the request item
	 * XXX extended data vs. the wakeup; instead, we let whoever is waiting
	 * XXX for each item repeat the update when they wake up.
	 */</span>
	TAILQ_INSERT_TAIL(&amp;kauth_resolver_unsubmitted, workp, kr_link);

	<span class="enscript-comment">/*
	 * Wake up an external resolver thread to deal with the new work; one
	 * may not be available, and if not, then the request will be grabbed
	 * when a resolver thread comes back into the kernel to request new
	 * work.
	 */</span>
	wakeup_one((caddr_t)&amp;kauth_resolver_unsubmitted);
	error = __KERNEL_IS_WAITING_ON_EXTERNAL_CREDENTIAL_RESOLVER__(workp);

	<span class="enscript-comment">/* if the request was processed, copy the result */</span>
	<span class="enscript-keyword">if</span> (error == 0)
		*lkp = workp-&gt;kr_work;
	
	<span class="enscript-keyword">if</span> (error == EWOULDBLOCK) {
	        <span class="enscript-keyword">if</span> ((kauth_resolver_timeout_cnt++ % KAUTH_COMPLAINT_INTERVAL) == 0) {
                        printf(<span class="enscript-string">&quot;kauth external resolver timed out (%d timeout(s) of %d seconds).\n&quot;</span>,
                                kauth_resolver_timeout_cnt, kauth_resolver_timeout);
                }
                
	        <span class="enscript-keyword">if</span> (workp-&gt;kr_flags &amp; KAUTH_REQUEST_UNSUBMITTED) {
	                <span class="enscript-comment">/*
                	 * If the request timed out and was never collected, the resolver
                	 * is dead and probably not coming back anytime soon.  In this
                	 * case we revert to no-resolver behaviour, and punt all the other
                	 * sleeping requests to clear the backlog.
                	 */</span>
                        KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - request timed out without being collected for processing, resolver dead&quot;</span>);

                        <span class="enscript-comment">/*
                        * Make the current resolver non-authoritative, and mark it as
                        * no longer registered to prevent kauth_cred_ismember_gid()
                        * enqueueing more work until a new one is registered.  This
                        * mitigates the damage a crashing resolver may inflict.
                        */</span>
                        kauth_resolver_identity = 0;
                        kauth_resolver_registered = 0;

                        <span class="enscript-comment">/* kill all the other requestes that are waiting as well */</span>
                        TAILQ_FOREACH(killp, &amp;kauth_resolver_submitted, kr_link)
                                wakeup(killp);
                        TAILQ_FOREACH(killp, &amp;kauth_resolver_unsubmitted, kr_link)
                                wakeup(killp);
                        <span class="enscript-comment">/* Cause all waiting-for-work threads to return EIO */</span>
                        wakeup((caddr_t)&amp;kauth_resolver_unsubmitted);
                }
        }

	<span class="enscript-comment">/*
	 * drop our reference on the work item, and note whether we should
	 * free it or not
	 */</span>
	<span class="enscript-keyword">if</span> (--workp-&gt;kr_refs &lt;= 0) {
		<span class="enscript-comment">/* work out which list we have to remove it from */</span>
		<span class="enscript-keyword">if</span> (workp-&gt;kr_flags &amp; KAUTH_REQUEST_DONE) {
			TAILQ_REMOVE(&amp;kauth_resolver_done, workp, kr_link);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (workp-&gt;kr_flags &amp; KAUTH_REQUEST_SUBMITTED) {
			TAILQ_REMOVE(&amp;kauth_resolver_submitted, workp, kr_link);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (workp-&gt;kr_flags &amp; KAUTH_REQUEST_UNSUBMITTED) {
			TAILQ_REMOVE(&amp;kauth_resolver_unsubmitted, workp, kr_link);
		} <span class="enscript-keyword">else</span> {
			KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - completed request has no valid queue&quot;</span>);
		}
		shouldfree = 1;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* someone else still has a reference on this request */</span>
		shouldfree = 0;
	}

	<span class="enscript-comment">/* collect request result */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		error = workp-&gt;kr_result;
	}
	KAUTH_RESOLVER_UNLOCK();

	<span class="enscript-comment">/*
	 * If we dropped the last reference, free the request.
	 */</span>
	<span class="enscript-keyword">if</span> (shouldfree) {
		FREE(workp, M_KAUTH);
	}

	KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - returning %d&quot;</span>, error);
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * identitysvc
 *
 * Description:	System call interface for the external identity resolver.
 *
 * Parameters:	uap-&gt;message			Message from daemon to kernel
 *
 * Returns:	0				Successfully became resolver
 *		EPERM				Not the resolver process
 *	kauth_authorize_generic:EPERM		Not root user
 *	kauth_resolver_complete:EIO
 *	kauth_resolver_complete:EFAULT
 *	kauth_resolver_getwork:EINTR
 *	kauth_resolver_getwork:EFAULT
 *
 * Notes:	This system call blocks until there is work enqueued, at
 *		which time the kernel wakes it up, and a message from the
 *		kernel is copied out to the identity resolution daemon, which
 *		proceed to attempt to resolve it.  When the resolution has
 *		completed (successfully or not), the daemon called back into
 *		this system call to give the result to the kernel, and wait
 *		for the next request.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">identitysvc</span>(__unused <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> identitysvc_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> opcode = uap-&gt;opcode;
	user_addr_t message = uap-&gt;message;
	<span class="enscript-type">struct</span> kauth_resolver_work *workp;
	<span class="enscript-type">struct</span> kauth_cache_sizes sz_arg;
	<span class="enscript-type">int</span> error;
	pid_t new_id;

	<span class="enscript-comment">/*
	 * New server registering itself.
	 */</span>
	<span class="enscript-keyword">if</span> (opcode == KAUTH_EXTLOOKUP_REGISTER) {
		new_id = current_proc()-&gt;p_pid;
		<span class="enscript-keyword">if</span> ((error = kauth_authorize_generic(kauth_cred_get(), KAUTH_GENERIC_ISSUSER)) != 0) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - pid %d refused permission to become identity resolver&quot;</span>, new_id);
			<span class="enscript-keyword">return</span>(error);
		}
		KAUTH_RESOLVER_LOCK();
		<span class="enscript-keyword">if</span> (kauth_resolver_identity != new_id) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - new resolver %d taking over from old %d&quot;</span>, new_id, kauth_resolver_identity);
			<span class="enscript-comment">/*
			 * We have a new server, so assume that all the old requests have been lost.
			 */</span>
			<span class="enscript-keyword">while</span> ((workp = TAILQ_LAST(&amp;kauth_resolver_submitted, kauth_resolver_submitted_head)) != NULL) {
				TAILQ_REMOVE(&amp;kauth_resolver_submitted, workp, kr_link);
				workp-&gt;kr_flags &amp;= ~KAUTH_REQUEST_SUBMITTED;
				workp-&gt;kr_flags |= KAUTH_REQUEST_UNSUBMITTED;
				TAILQ_INSERT_HEAD(&amp;kauth_resolver_unsubmitted, workp, kr_link);
			}
			<span class="enscript-comment">/*
			 * Allow user space resolver to override the
			 * external resolution timeout
			 */</span>
			<span class="enscript-keyword">if</span> (message &gt; 30 &amp;&amp; message &lt; 10000) {
				kauth_resolver_timeout = message;
				KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - new resolver changes timeout to %d seconds\n&quot;</span>, (<span class="enscript-type">int</span>)message);
			}
			kauth_resolver_identity = new_id;
			kauth_resolver_registered = 1;
			kauth_identitysvc_has_registered = 1;
			wakeup(&amp;kauth_resolver_unsubmitted);
		}
		KAUTH_RESOLVER_UNLOCK();
		<span class="enscript-keyword">return</span>(0);
	}

	<span class="enscript-comment">/*
	 * Beyond this point, we must be the resolver process. We verify this
	 * by confirming the resolver credential and pid.
	 */</span>
	<span class="enscript-keyword">if</span> ((kauth_cred_getuid(kauth_cred_get()) != 0) || (current_proc()-&gt;p_pid != kauth_resolver_identity)) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - call from bogus resolver %d\n&quot;</span>, current_proc()-&gt;p_pid);
		<span class="enscript-keyword">return</span>(EPERM);
	}
	
	<span class="enscript-keyword">if</span> (opcode == KAUTH_GET_CACHE_SIZES) {
		KAUTH_IDENTITY_LOCK();
		sz_arg.kcs_id_size = kauth_identity_cachemax;
		KAUTH_IDENTITY_UNLOCK();
		
		KAUTH_GROUPS_LOCK();
		sz_arg.kcs_group_size = kauth_groups_cachemax;
		KAUTH_GROUPS_UNLOCK();

		<span class="enscript-keyword">if</span> ((error = copyout(&amp;sz_arg, uap-&gt;message, <span class="enscript-keyword">sizeof</span> (sz_arg))) != 0) {
			<span class="enscript-keyword">return</span> (error);
		}
		
		<span class="enscript-keyword">return</span> (0);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (opcode == KAUTH_SET_CACHE_SIZES) {
		<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;message, &amp;sz_arg, <span class="enscript-keyword">sizeof</span> (sz_arg))) != 0) {
			<span class="enscript-keyword">return</span> (error);
		}
		
		<span class="enscript-keyword">if</span> ((sz_arg.kcs_group_size &gt; KAUTH_CACHES_MAX_SIZE) ||
		    (sz_arg.kcs_id_size &gt; KAUTH_CACHES_MAX_SIZE)) {
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		
		KAUTH_IDENTITY_LOCK();
		kauth_identity_cachemax = sz_arg.kcs_id_size;
		kauth_identity_trimcache(kauth_identity_cachemax);
		KAUTH_IDENTITY_UNLOCK();
		
		KAUTH_GROUPS_LOCK();
		kauth_groups_cachemax = sz_arg.kcs_group_size;
		kauth_groups_trimcache(kauth_groups_cachemax);
		KAUTH_GROUPS_UNLOCK();
		
		<span class="enscript-keyword">return</span> (0);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (opcode == KAUTH_CLEAR_CACHES) {
		KAUTH_IDENTITY_LOCK();
		kauth_identity_trimcache(0);
		KAUTH_IDENTITY_UNLOCK();
		
		KAUTH_GROUPS_LOCK();
		kauth_groups_trimcache(0);
		KAUTH_GROUPS_UNLOCK();
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (opcode == KAUTH_EXTLOOKUP_DEREGISTER) {
		<span class="enscript-comment">/*
		 * Terminate outstanding requests; without an authoritative
		 * resolver, we are now back on our own authority.
		 */</span>
		<span class="enscript-type">struct</span> kauth_resolver_work *killp;

		KAUTH_RESOLVER_LOCK();

		<span class="enscript-comment">/*
		 * Clear the identity, but also mark it as unregistered so
		 * there is no explicit future expectation of us getting a
		 * new resolver any time soon.
		 */</span>
		kauth_resolver_identity = 0;
		kauth_resolver_registered = 0;

		TAILQ_FOREACH(killp, &amp;kauth_resolver_submitted, kr_link)
		    wakeup(killp);
		TAILQ_FOREACH(killp, &amp;kauth_resolver_unsubmitted, kr_link)
		    wakeup(killp);
		<span class="enscript-comment">/* Cause all waiting-for-work threads to return EIO */</span>
		wakeup((caddr_t)&amp;kauth_resolver_unsubmitted);
		KAUTH_RESOLVER_UNLOCK();
	}
	
	<span class="enscript-comment">/*
	 * Got a result returning?
	 */</span>
	<span class="enscript-keyword">if</span> (opcode &amp; KAUTH_EXTLOOKUP_RESULT) {
		<span class="enscript-keyword">if</span> ((error = kauth_resolver_complete(message)) != 0)
			<span class="enscript-keyword">return</span>(error);
	}

	<span class="enscript-comment">/*
	 * Caller wants to take more work?
	 */</span>
	<span class="enscript-keyword">if</span> (opcode &amp; KAUTH_EXTLOOKUP_WORKER) {
		<span class="enscript-keyword">if</span> ((error = kauth_resolver_getwork(message)) != 0)
			<span class="enscript-keyword">return</span>(error);
	}

	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-comment">/*
 * kauth_resolver_getwork_continue
 *		
 * Description:	Continuation for kauth_resolver_getwork
 *
 * Parameters:	result				Error code or 0 for the sleep
 *						that got us to this function
 *
 * Returns:	0				Success
 *		EINTR				Interrupted (e.g. by signal)
 *	kauth_resolver_getwork2:EFAULT
 *
 * Notes:	See kauth_resolver_getwork(0 and kauth_resolver_getwork2() for
 *		more information.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_resolver_getwork_continue</span>(<span class="enscript-type">int</span> result)
{
	thread_t thread;
	<span class="enscript-type">struct</span> uthread *ut;
	user_addr_t message;

	<span class="enscript-keyword">if</span> (result) {
		KAUTH_RESOLVER_UNLOCK();
		<span class="enscript-keyword">return</span>(result);
	}

	<span class="enscript-comment">/*
	 * If we lost a race with another thread/memberd restarting, then we
	 * need to go back to sleep to look for more work.  If it was memberd
	 * restarting, then the msleep0() will error out here, as our thread
	 * will already be &quot;dead&quot;.
	 */</span>
	<span class="enscript-keyword">if</span> (TAILQ_FIRST(&amp;kauth_resolver_unsubmitted) == NULL) {
		<span class="enscript-type">int</span> error;

		error = msleep0(&amp;kauth_resolver_unsubmitted, kauth_resolver_mtx, PCATCH, <span class="enscript-string">&quot;GRGetWork&quot;</span>, 0, kauth_resolver_getwork_continue);
		<span class="enscript-comment">/*
		 * If this is a wakeup from another thread in the resolver
		 * deregistering it, error out the request-for-work thread
		 */</span>
		<span class="enscript-keyword">if</span> (!kauth_resolver_identity)
			error = EIO;
		KAUTH_RESOLVER_UNLOCK();
		<span class="enscript-keyword">return</span>(error);
	}

	thread = current_thread();
	ut = get_bsdthread_info(thread);
	message = ut-&gt;uu_kevent.uu_kauth.message;
	<span class="enscript-keyword">return</span>(kauth_resolver_getwork2(message));
}


<span class="enscript-comment">/*
 * kauth_resolver_getwork2
 *
 * Decription:	Common utility function to copy out a identity resolver work
 *		item from the kernel to user space as part of the user space
 *		identity resolver requesting work.
 *
 * Parameters:	message				message to user space
 *
 * Returns:	0				Success
 *		EFAULT				Bad user space message address
 *
 * Notes:	This common function exists to permit the use of continuations
 *		in the identity resolution process.  This frees up the stack
 *		while we are waiting for the user space resolver to complete
 *		a request.  This is specifically used so that our per thread
 *		cost can be small, and we will therefore be willing to run a
 *		larger number of threads in the user space identity resolver.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_resolver_getwork2</span>(user_addr_t message)
{
	<span class="enscript-type">struct</span> kauth_resolver_work *workp;
	<span class="enscript-type">int</span>		error;

	<span class="enscript-comment">/*
	 * Note: We depend on the caller protecting us from a NULL work item
	 * queue, since we must have the kauth resolver lock on entry to this
	 * function.
	 */</span>
	workp = TAILQ_FIRST(&amp;kauth_resolver_unsubmitted);

	<span class="enscript-comment">/*
	 * Copy out the external lookup structure for the request, not
	 * including the el_extend field, which contains the address of the
	 * external buffer provided by the external resolver into which we
	 * copy the extension request information.
	 */</span>
	<span class="enscript-comment">/* BEFORE FIELD */</span>
	<span class="enscript-keyword">if</span> ((error = copyout(&amp;workp-&gt;kr_work, message, offsetof(<span class="enscript-type">struct</span> kauth_identity_extlookup, el_extend))) != 0) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - error submitting work to resolve&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/* AFTER FIELD */</span>
	<span class="enscript-keyword">if</span> ((error = copyout(&amp;workp-&gt;kr_work.el_info_reserved_1,
			message + offsetof(<span class="enscript-type">struct</span> kauth_identity_extlookup, el_info_reserved_1),
		<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kauth_identity_extlookup) - offsetof(<span class="enscript-type">struct</span> kauth_identity_extlookup, el_info_reserved_1))) != 0) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - error submitting work to resolve&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Handle extended requests here; if we have a request of a type where
	 * the kernel wants a translation of extended information, then we need
	 * to copy it out into the extended buffer, assuming the buffer is
	 * valid; we only attempt to get the buffer address if we have request
	 * data to copy into it.
	 */</span>

	<span class="enscript-comment">/*
	 * translate a user@domain string into a uid/gid/whatever
	 */</span>
	<span class="enscript-keyword">if</span> (workp-&gt;kr_work.el_flags &amp; (KAUTH_EXTLOOKUP_VALID_PWNAM | KAUTH_EXTLOOKUP_VALID_GRNAM)) {
		uint64_t uaddr;

		error = copyin(message + offsetof(<span class="enscript-type">struct</span> kauth_identity_extlookup, el_extend), &amp;uaddr, <span class="enscript-keyword">sizeof</span>(uaddr));
		<span class="enscript-keyword">if</span> (!error) {
			size_t actual;	<span class="enscript-comment">/* not used */</span>
			<span class="enscript-comment">/*
			 * Use copyoutstr() to reduce the copy size; we let
			 * this catch a NULL uaddr because we shouldn't be
			 * asking in that case anyway.
			 */</span>
			error = copyoutstr(CAST_DOWN(<span class="enscript-type">void</span> *,workp-&gt;kr_extend), uaddr, MAXPATHLEN, &amp;actual);
		}
		<span class="enscript-keyword">if</span> (error) {
			KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - error submitting work to resolve&quot;</span>);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	TAILQ_REMOVE(&amp;kauth_resolver_unsubmitted, workp, kr_link);
	workp-&gt;kr_flags &amp;= ~KAUTH_REQUEST_UNSUBMITTED;
	workp-&gt;kr_flags |= KAUTH_REQUEST_SUBMITTED;
	TAILQ_INSERT_TAIL(&amp;kauth_resolver_submitted, workp, kr_link);

<span class="enscript-reference">out</span>:
	KAUTH_RESOLVER_UNLOCK();
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * kauth_resolver_getwork
 *
 * Description:	Get a work item from the enqueued requests from the kernel and
 *		give it to the user space daemon.
 *
 * Parameters:	message				message to user space
 *
 * Returns:	0				Success
 *		EINTR				Interrupted (e.g. by signal)
 *	kauth_resolver_getwork2:EFAULT
 *
 * Notes:	This function blocks in a continuation if there are no work
 *		items available for processing at the time the user space
 *		identity resolution daemon makes a request for work.  This
 *		permits a large number of threads to be used by the daemon,
 *		without using a lot of wired kernel memory when there are no
 *		actual request outstanding.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_resolver_getwork</span>(user_addr_t message)
{
	<span class="enscript-type">struct</span> kauth_resolver_work *workp;
	<span class="enscript-type">int</span>		error;

	KAUTH_RESOLVER_LOCK();
	error = 0;
	<span class="enscript-keyword">while</span> ((workp = TAILQ_FIRST(&amp;kauth_resolver_unsubmitted)) == NULL) {
		thread_t thread = current_thread();
		<span class="enscript-type">struct</span> uthread *ut = get_bsdthread_info(thread);

		ut-&gt;uu_kevent.uu_kauth.message = message;
		error = msleep0(&amp;kauth_resolver_unsubmitted, kauth_resolver_mtx, PCATCH, <span class="enscript-string">&quot;GRGetWork&quot;</span>, 0, kauth_resolver_getwork_continue);
		KAUTH_RESOLVER_UNLOCK();
		<span class="enscript-comment">/*
		 * If this is a wakeup from another thread in the resolver
		 * deregistering it, error out the request-for-work thread
		 */</span>
		<span class="enscript-keyword">if</span> (!kauth_resolver_identity)
			error = EIO;
		<span class="enscript-keyword">return</span>(error);
	}
	<span class="enscript-keyword">return</span> kauth_resolver_getwork2(message);
}


<span class="enscript-comment">/*
 * kauth_resolver_complete
 *
 * Description:	Return a result from userspace.
 *
 * Parameters:	message				message from user space
 *
 * Returns:	0				Success
 *		EIO				The resolver is dead
 *	copyin:EFAULT				Bad message from user space
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_resolver_complete</span>(user_addr_t message)
{
	<span class="enscript-type">struct</span> kauth_identity_extlookup	extl;
	<span class="enscript-type">struct</span> kauth_resolver_work *workp;
	<span class="enscript-type">struct</span> kauth_resolver_work *killp;
	<span class="enscript-type">int</span> error, result, request_flags;

	<span class="enscript-comment">/*
	 * Copy in the mesage, including the extension field, since we are
	 * copying into a local variable.
	 */</span>
	<span class="enscript-keyword">if</span> ((error = copyin(message, &amp;extl, <span class="enscript-keyword">sizeof</span>(extl))) != 0) {
		KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - error getting completed work\n&quot;</span>);
		<span class="enscript-keyword">return</span>(error);
	}

	KAUTH_RESOLVER_LOCK();

	error = 0;
	result = 0;
	<span class="enscript-keyword">switch</span> (extl.el_result) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_EXTLOOKUP_INPROG</span>:
	{
		<span class="enscript-type">static</span> <span class="enscript-type">int</span> once = 0;

		<span class="enscript-comment">/* XXX this should go away once memberd is updated */</span>
		<span class="enscript-keyword">if</span> (!once) {
			printf(<span class="enscript-string">&quot;kauth_resolver: memberd is not setting valid result codes (assuming always successful)\n&quot;</span>);
			once = 1;
		}
	}
	<span class="enscript-comment">/* FALLTHROUGH */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_EXTLOOKUP_SUCCESS</span>:
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_EXTLOOKUP_FATAL</span>:
		<span class="enscript-comment">/* fatal error means the resolver is dead */</span>
		KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - resolver %d died, waiting for a new one&quot;</span>, kauth_resolver_identity);
		<span class="enscript-comment">/*
		 * Terminate outstanding requests; without an authoritative
		 * resolver, we are now back on our own authority.  Tag the
		 * resolver unregistered to prevent kauth_cred_ismember_gid()
		 * enqueueing more work until a new one is registered.  This
		 * mitigates the damage a crashing resolver may inflict.
		 */</span>
		kauth_resolver_identity = 0;
		kauth_resolver_registered = 0;

		TAILQ_FOREACH(killp, &amp;kauth_resolver_submitted, kr_link)
		    wakeup(killp);
		TAILQ_FOREACH(killp, &amp;kauth_resolver_unsubmitted, kr_link)
		    wakeup(killp);
		<span class="enscript-comment">/* Cause all waiting-for-work threads to return EIO */</span>
		wakeup((caddr_t)&amp;kauth_resolver_unsubmitted);
		<span class="enscript-comment">/* and return EIO to the caller */</span>
		error = EIO;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_EXTLOOKUP_BADRQ</span>:
		KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - resolver reported invalid request %d&quot;</span>, extl.el_seqno);
		result = EINVAL;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_EXTLOOKUP_FAILURE</span>:
		KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - resolver reported transient failure for request %d&quot;</span>, extl.el_seqno);
		result = EIO;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - resolver returned unexpected status %d&quot;</span>, extl.el_result);
		result = EIO;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * In the case of a fatal error, we assume that the resolver will
	 * restart quickly and re-collect all of the outstanding requests.
	 * Thus, we don't complete the request which returned the fatal
	 * error status.
	 */</span>
	<span class="enscript-keyword">if</span> (extl.el_result != KAUTH_EXTLOOKUP_FATAL) {
		<span class="enscript-comment">/* scan our list for this request */</span>
		TAILQ_FOREACH(workp, &amp;kauth_resolver_submitted, kr_link) {
			<span class="enscript-comment">/* found it? */</span>
			<span class="enscript-keyword">if</span> (workp-&gt;kr_seqno == extl.el_seqno) {
				<span class="enscript-comment">/*
				 * Take a snapshot of the original request flags.
				 */</span>
				request_flags = workp-&gt;kr_work.el_flags;

				<span class="enscript-comment">/*
				 * Get the request of the submitted queue so
				 * that it is not cleaned up out from under
				 * us by a timeout.
				 */</span>
				TAILQ_REMOVE(&amp;kauth_resolver_submitted, workp, kr_link);
				workp-&gt;kr_flags &amp;= ~KAUTH_REQUEST_SUBMITTED;
				workp-&gt;kr_flags |= KAUTH_REQUEST_DONE;
				workp-&gt;kr_result = result;

				<span class="enscript-comment">/* Copy the result message to the work item. */</span>
				memcpy(&amp;workp-&gt;kr_work, &amp;extl, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kauth_identity_extlookup));

				<span class="enscript-comment">/*
				 * Check if we have a result in the extension
				 * field; if we do, then we need to separately
				 * copy the data from the message el_extend
				 * into the request buffer that's in the work
				 * item.  We have to do it here because we do
				 * not want to wake up the waiter until the
				 * data is in their buffer, and because the
				 * actual request response may be destroyed
				 * by the time the requester wakes up, and they
				 * do not have access to the user space buffer
				 * address.
				 *
				 * It is safe to drop and reacquire the lock
				 * here because we've already removed the item
				 * from the submission queue, but have not yet
				 * moved it to the completion queue.  Note that
				 * near simultaneous requests may result in
				 * duplication of requests for items in this
				 * window. This should not be a performance
				 * issue and is easily detectable by comparing
				 * time to live on last response vs. time of
				 * next request in the resolver logs.
				 *
				 * A malicious/faulty resolver could overwrite
				 * part of a user's address space if they return
				 * flags that mismatch the original request's flags.
				 */</span>
				<span class="enscript-keyword">if</span> ((extl.el_flags &amp; request_flags) &amp; (KAUTH_EXTLOOKUP_VALID_PWNAM|KAUTH_EXTLOOKUP_VALID_GRNAM)) {
					size_t actual;	<span class="enscript-comment">/* notused */</span>

					KAUTH_RESOLVER_UNLOCK();
					error = copyinstr(extl.el_extend, CAST_DOWN(<span class="enscript-type">void</span> *, workp-&gt;kr_extend), MAXPATHLEN, &amp;actual);
					KAUTH_RESOLVER_LOCK();
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (extl.el_flags &amp;  (KAUTH_EXTLOOKUP_VALID_PWNAM|KAUTH_EXTLOOKUP_VALID_GRNAM)) {
					error = EFAULT;
					KAUTH_DEBUG(<span class="enscript-string">&quot;RESOLVER - resolver returned mismatching extension flags (%d), request contained (%d)&quot;</span>,
							extl.el_flags, request_flags);
				}

				<span class="enscript-comment">/*
				 * Move the completed work item to the
				 * completion queue and wake up requester(s)
				 */</span>
				TAILQ_INSERT_TAIL(&amp;kauth_resolver_done, workp, kr_link);
				wakeup(workp);
				<span class="enscript-keyword">break</span>;
			}
		}
	}
	<span class="enscript-comment">/*
	 * Note that it's OK for us not to find anything; if the request has
	 * timed out the work record will be gone.
	 */</span>
	KAUTH_RESOLVER_UNLOCK();
	
	<span class="enscript-keyword">return</span>(error);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_EXT_RESOLVER */</span>


<span class="enscript-comment">/*
 * Identity cache.
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">KI_VALID_UID</span>	(1&lt;&lt;0)		<span class="enscript-comment">/* UID and GID are mutually exclusive */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KI_VALID_GID</span>	(1&lt;&lt;1)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KI_VALID_GUID</span>	(1&lt;&lt;2)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KI_VALID_NTSID</span>	(1&lt;&lt;3)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KI_VALID_PWNAM</span>	(1&lt;&lt;4)	<span class="enscript-comment">/* Used for translation */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KI_VALID_GRNAM</span>	(1&lt;&lt;5)	<span class="enscript-comment">/* Used for translation */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KI_VALID_GROUPS</span> (1&lt;&lt;6)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_EXT_RESOLVER</span>
<span class="enscript-comment">/*
 * kauth_identity_init
 *
 * Description:	Initialize the kernel side of the credential identity resolver
 *
 * Parameters:	(void)
 *
 * Returns:	(void)
 *
 * Notes:	Initialize the credential identity resolver for use; the
 *		credential identity resolver is the KPI used to communicate
 *		with a user space credential identity resolver daemon.
 *
 *		This function is called from kauth_init() in the file
 *		kern_authorization.c.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_identity_init</span>(<span class="enscript-type">void</span>)
{
	TAILQ_INIT(&amp;kauth_identities);
	kauth_identity_mtx = lck_mtx_alloc_init(kauth_lck_grp, 0<span class="enscript-comment">/*LCK_ATTR_NULL*/</span>);
}


<span class="enscript-comment">/*
 * kauth_identity_alloc
 *
 * Description:	Allocate and fill out a kauth_identity structure for
 *		translation between {UID|GID}/GUID/NTSID
 *
 * Parameters:	uid
 *
 * Returns:	NULL				Insufficient memory to satisfy
 *						the request or bad parameters
 *		!NULL				A pointer to the allocated
 *						structure, filled in
 *
 * Notes:	It is illegal to translate between UID and GID; any given UUID
 *		or NTSID can only refer to an NTSID or UUID (respectively),
 *		and *either* a UID *or* a GID, but not both.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> kauth_identity *
<span class="enscript-function-name">kauth_identity_alloc</span>(uid_t uid, gid_t gid, guid_t *guidp, time_t guid_expiry,
	ntsid_t *ntsidp, time_t ntsid_expiry, <span class="enscript-type">int</span> supgrpcnt, gid_t *supgrps, time_t groups_expiry,
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> nametype)
{
	<span class="enscript-type">struct</span> kauth_identity *kip;
	
	<span class="enscript-comment">/* get and fill in a new identity */</span>
	MALLOC(kip, <span class="enscript-type">struct</span> kauth_identity *, <span class="enscript-keyword">sizeof</span>(*kip), M_KAUTH, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (kip != NULL) {
		<span class="enscript-keyword">if</span> (gid != KAUTH_GID_NONE) {
			kip-&gt;ki_gid = gid;
			kip-&gt;ki_valid = KI_VALID_GID;
		}
		<span class="enscript-keyword">if</span> (uid != KAUTH_UID_NONE) {
			<span class="enscript-keyword">if</span> (kip-&gt;ki_valid &amp; KI_VALID_GID)
				panic(<span class="enscript-string">&quot;can't allocate kauth identity with both uid and gid&quot;</span>);
			kip-&gt;ki_uid = uid;
			kip-&gt;ki_valid = KI_VALID_UID;
		}
		<span class="enscript-keyword">if</span> (supgrpcnt) {
			<span class="enscript-comment">/*
			 * A malicious/faulty resolver could return bad values
			 */</span>
			assert(supgrpcnt &gt;= 0);
			assert(supgrpcnt &lt;= NGROUPS);
			assert(supgrps != NULL);

			<span class="enscript-keyword">if</span> ((supgrpcnt &lt; 0) || (supgrpcnt &gt; NGROUPS) || (supgrps == NULL)) {
				<span class="enscript-keyword">return</span> NULL;
			}
			<span class="enscript-keyword">if</span> (kip-&gt;ki_valid &amp; KI_VALID_GID)
				panic(<span class="enscript-string">&quot;can't allocate kauth identity with both gid and supplementary groups&quot;</span>);
			kip-&gt;ki_supgrpcnt = supgrpcnt;
			memcpy(kip-&gt;ki_supgrps, supgrps, <span class="enscript-keyword">sizeof</span>(supgrps[0]) * supgrpcnt);
			kip-&gt;ki_valid |= KI_VALID_GROUPS;
		}
		kip-&gt;ki_groups_expiry = groups_expiry;
		<span class="enscript-keyword">if</span> (guidp != NULL) {
			kip-&gt;ki_guid = *guidp;
			kip-&gt;ki_valid |= KI_VALID_GUID;
		}
		kip-&gt;ki_guid_expiry = guid_expiry;
		<span class="enscript-keyword">if</span> (ntsidp != NULL) {
			kip-&gt;ki_ntsid = *ntsidp;
			kip-&gt;ki_valid |= KI_VALID_NTSID;
		}
		kip-&gt;ki_ntsid_expiry = ntsid_expiry;
		<span class="enscript-keyword">if</span> (name != NULL) {
			kip-&gt;ki_name = name;
			kip-&gt;ki_valid |= nametype;
		}
	}
	<span class="enscript-keyword">return</span>(kip);
}


<span class="enscript-comment">/*
 * kauth_identity_register_and_free
 *
 * Description:	Register an association between identity tokens.  The passed
 *		'kip' is consumed by this function.
 *
 * Parameters:	kip				Pointer to kauth_identity
 *						structure to register
 *
 * Returns:	(void)
 *
 * Notes:	The memory pointer to by 'kip' is assumed to have been
 *		previously allocated via kauth_identity_alloc().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_identity_register_and_free</span>(<span class="enscript-type">struct</span> kauth_identity *kip)
{
	<span class="enscript-type">struct</span> kauth_identity *ip;

	<span class="enscript-comment">/*
	 * We search the cache for the UID listed in the incoming association.
	 * If we already have an entry, the new information is merged.
	 */</span>
	ip = NULL;
	KAUTH_IDENTITY_LOCK();
	<span class="enscript-keyword">if</span> (kip-&gt;ki_valid &amp; KI_VALID_UID) {
		<span class="enscript-keyword">if</span> (kip-&gt;ki_valid &amp; KI_VALID_GID)
			panic(<span class="enscript-string">&quot;kauth_identity: can't insert record with both UID and GID as key&quot;</span>);
		TAILQ_FOREACH(ip, &amp;kauth_identities, ki_link)
		    <span class="enscript-keyword">if</span> ((ip-&gt;ki_valid &amp; KI_VALID_UID) &amp;&amp; (ip-&gt;ki_uid == kip-&gt;ki_uid))
				<span class="enscript-keyword">break</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kip-&gt;ki_valid &amp; KI_VALID_GID) {
		TAILQ_FOREACH(ip, &amp;kauth_identities, ki_link)
		    <span class="enscript-keyword">if</span> ((ip-&gt;ki_valid &amp; KI_VALID_GID) &amp;&amp; (ip-&gt;ki_gid == kip-&gt;ki_gid))
				<span class="enscript-keyword">break</span>;
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;kauth_identity: can't insert record without UID or GID as key&quot;</span>);
	}
		
	<span class="enscript-keyword">if</span> (ip != NULL) {
		<span class="enscript-comment">/* we already have an entry, merge/overwrite */</span>
		<span class="enscript-keyword">if</span> (kip-&gt;ki_valid &amp; KI_VALID_GUID) {
			ip-&gt;ki_guid = kip-&gt;ki_guid;
			ip-&gt;ki_valid |= KI_VALID_GUID;
		}
		ip-&gt;ki_guid_expiry = kip-&gt;ki_guid_expiry;
		<span class="enscript-keyword">if</span> (kip-&gt;ki_valid &amp; KI_VALID_NTSID) {
			ip-&gt;ki_ntsid = kip-&gt;ki_ntsid;
			ip-&gt;ki_valid |= KI_VALID_NTSID;
		}
		ip-&gt;ki_ntsid_expiry = kip-&gt;ki_ntsid_expiry;
		<span class="enscript-comment">/* a valid ki_name field overwrites the previous name field */</span>
		<span class="enscript-keyword">if</span> (kip-&gt;ki_valid &amp; (KI_VALID_PWNAM | KI_VALID_GRNAM)) {
			<span class="enscript-comment">/* if there's an old one, discard it */</span>
			<span class="enscript-type">const</span> <span class="enscript-type">char</span> *oname = NULL;
			<span class="enscript-keyword">if</span> (ip-&gt;ki_valid &amp; (KI_VALID_PWNAM | KI_VALID_GRNAM))
				oname = ip-&gt;ki_name;
			ip-&gt;ki_name = kip-&gt;ki_name;
			kip-&gt;ki_name = oname;
		}
		<span class="enscript-comment">/* and discard the incoming entry */</span>
		ip = kip;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * if we don't have any information on this identity, add it;
		 * if it pushes us over our limit, discard the oldest one.
		 */</span>
		TAILQ_INSERT_HEAD(&amp;kauth_identities, kip, ki_link);
		<span class="enscript-keyword">if</span> (++kauth_identity_count &gt; kauth_identity_cachemax) {
			ip = TAILQ_LAST(&amp;kauth_identities, kauth_identity_head);
			TAILQ_REMOVE(&amp;kauth_identities, ip, ki_link);
			kauth_identity_count--;
		}
	}
	KAUTH_IDENTITY_UNLOCK();
	<span class="enscript-comment">/* have to drop lock before freeing expired entry (it may be in use) */</span>
	<span class="enscript-keyword">if</span> (ip != NULL) {
		<span class="enscript-comment">/* if the ki_name field is used, clear it first */</span>
		<span class="enscript-keyword">if</span> (ip-&gt;ki_valid &amp; (KI_VALID_PWNAM | KI_VALID_GRNAM))
			vfs_removename(ip-&gt;ki_name);
		<span class="enscript-comment">/* free the expired entry */</span>
		FREE(ip, M_KAUTH);
	}
}


<span class="enscript-comment">/*
 * kauth_identity_updatecache
 *
 * Description:	Given a lookup result, add any associations that we don't
 *		currently have; replace ones which have changed.
 *
 * Parameters:	elp				External lookup result from
 *						user space daemon to kernel
 *		rkip				pointer to returned kauth
 *						identity, or NULL
 *		extend_data			Extended data (can vary)
 *
 * Returns:	(void)
 *
 * Implicit returns:
 *		*rkip				Modified (if non-NULL)
 *
 * Notes:	For extended information requests, this code relies on the fact
 *		that elp-&gt;el_flags is never used as an rvalue, and is only
 *		ever bit-tested for valid lookup information we are willing
 *		to cache.
 *
 * XXX:		We may have to do the same in the case that extended data was
 *		passed out to user space to ensure that the request string
 *		gets cached; we may also be able to use the rkip as an
 *		input to avoid this.  The jury is still out.
 *
 * XXX:		This codes performance could be improved for multiple valid
 *		results by combining the loop iteration in a single loop.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_identity_updatecache</span>(<span class="enscript-type">struct</span> kauth_identity_extlookup *elp, <span class="enscript-type">struct</span> kauth_identity *rkip, uint64_t extend_data)
{
	<span class="enscript-type">struct</span> timeval tv;
	<span class="enscript-type">struct</span> kauth_identity *kip;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *speculative_name = NULL;

	microuptime(&amp;tv);

	<span class="enscript-comment">/*
	 * If there is extended data, and that data represents a name rather
	 * than something else, speculatively create an entry for it in the
	 * string cache.  We do this to avoid holding the KAUTH_IDENTITY_LOCK
	 * over the allocation later.
	 */</span>
	<span class="enscript-keyword">if</span> (elp-&gt;el_flags &amp; (KAUTH_EXTLOOKUP_VALID_PWNAM | KAUTH_EXTLOOKUP_VALID_GRNAM)) {
		<span class="enscript-type">const</span> <span class="enscript-type">char</span> *tmp = CAST_DOWN(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *,extend_data);
		speculative_name = vfs_addname(tmp, strnlen(tmp, MAXPATHLEN - 1), 0, 0);
	}
	
	<span class="enscript-comment">/* user identity? */</span>
	<span class="enscript-keyword">if</span> (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_UID) {
		KAUTH_IDENTITY_LOCK();
		TAILQ_FOREACH(kip, &amp;kauth_identities, ki_link) {
			<span class="enscript-comment">/* matching record */</span>
			<span class="enscript-keyword">if</span> ((kip-&gt;ki_valid &amp; KI_VALID_UID) &amp;&amp; (kip-&gt;ki_uid == elp-&gt;el_uid)) {
				<span class="enscript-keyword">if</span> (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_SUPGRPS) {
					assert(elp-&gt;el_sup_grp_cnt &lt;= NGROUPS);
					kip-&gt;ki_supgrpcnt = elp-&gt;el_sup_grp_cnt;
					memcpy(kip-&gt;ki_supgrps, elp-&gt;el_sup_groups, <span class="enscript-keyword">sizeof</span>(elp-&gt;el_sup_groups[0]) * kip-&gt;ki_supgrpcnt);
					kip-&gt;ki_valid |= KI_VALID_GROUPS;
					kip-&gt;ki_groups_expiry = (elp-&gt;el_member_valid) ? tv.tv_sec + elp-&gt;el_member_valid : 0;
				}
				<span class="enscript-keyword">if</span> (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_UGUID) {
					kip-&gt;ki_guid = elp-&gt;el_uguid;
					kip-&gt;ki_valid |= KI_VALID_GUID;
				}
				kip-&gt;ki_guid_expiry = (elp-&gt;el_uguid_valid) ? tv.tv_sec + elp-&gt;el_uguid_valid : 0;
				<span class="enscript-keyword">if</span> (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_USID) {
					kip-&gt;ki_ntsid = elp-&gt;el_usid;
					kip-&gt;ki_valid |= KI_VALID_NTSID;
				}
				kip-&gt;ki_ntsid_expiry = (elp-&gt;el_usid_valid) ? tv.tv_sec + elp-&gt;el_usid_valid : 0;
				<span class="enscript-keyword">if</span> (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_PWNAM) {
					<span class="enscript-type">const</span> <span class="enscript-type">char</span> *oname = kip-&gt;ki_name;
					kip-&gt;ki_name = speculative_name;
					speculative_name = NULL;
					kip-&gt;ki_valid |= KI_VALID_PWNAM;
					<span class="enscript-keyword">if</span> (oname) {
						<span class="enscript-comment">/*
						 * free oname (if any) outside
						 * the lock
						 */</span>
						speculative_name = oname;
					}
				}
				kauth_identity_lru(kip);
				<span class="enscript-keyword">if</span> (rkip != NULL)
					*rkip = *kip;
				KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - refreshed %d is &quot;</span> K_UUID_FMT, kip-&gt;ki_uid, K_UUID_ARG(kip-&gt;ki_guid));
				<span class="enscript-keyword">break</span>;
			}
		}
		KAUTH_IDENTITY_UNLOCK();
		<span class="enscript-comment">/* not found in cache, add new record */</span>
		<span class="enscript-keyword">if</span> (kip == NULL) {
			kip = kauth_identity_alloc(elp-&gt;el_uid, KAUTH_GID_NONE,
			    (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_UGUID) ? &amp;elp-&gt;el_uguid : NULL,
			    (elp-&gt;el_uguid_valid) ? tv.tv_sec + elp-&gt;el_uguid_valid : 0,
			    (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_USID) ? &amp;elp-&gt;el_usid : NULL,
			    (elp-&gt;el_usid_valid) ? tv.tv_sec + elp-&gt;el_usid_valid : 0,
			    (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_SUPGRPS) ? elp-&gt;el_sup_grp_cnt : 0,
			    (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_SUPGRPS) ? elp-&gt;el_sup_groups : NULL,
			    (elp-&gt;el_member_valid) ? tv.tv_sec + elp-&gt;el_member_valid : 0,
			    (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_PWNAM) ? speculative_name : NULL,
			    KI_VALID_PWNAM);
			<span class="enscript-keyword">if</span> (kip != NULL) {
				<span class="enscript-keyword">if</span> (rkip != NULL)
					*rkip = *kip;
				<span class="enscript-keyword">if</span> (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_PWNAM)
					speculative_name = NULL;
				KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - learned %d is &quot;</span> K_UUID_FMT, kip-&gt;ki_uid, K_UUID_ARG(kip-&gt;ki_guid));
				kauth_identity_register_and_free(kip);
			}
		}
	}

	<span class="enscript-comment">/* group identity? (ignore, if we already processed it as a user) */</span>
	<span class="enscript-keyword">if</span> (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_GID &amp;&amp; !(elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_UID)) {
		KAUTH_IDENTITY_LOCK();
		TAILQ_FOREACH(kip, &amp;kauth_identities, ki_link) {
			<span class="enscript-comment">/* matching record */</span>
			<span class="enscript-keyword">if</span> ((kip-&gt;ki_valid &amp; KI_VALID_GID) &amp;&amp; (kip-&gt;ki_gid == elp-&gt;el_gid)) {
				<span class="enscript-keyword">if</span> (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_GGUID) {
					kip-&gt;ki_guid = elp-&gt;el_gguid;
					kip-&gt;ki_valid |= KI_VALID_GUID;
				}
				kip-&gt;ki_guid_expiry = (elp-&gt;el_gguid_valid) ? tv.tv_sec + elp-&gt;el_gguid_valid : 0;
				<span class="enscript-keyword">if</span> (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_GSID) {
					kip-&gt;ki_ntsid = elp-&gt;el_gsid;
					kip-&gt;ki_valid |= KI_VALID_NTSID;
				}
				kip-&gt;ki_ntsid_expiry = (elp-&gt;el_gsid_valid) ? tv.tv_sec + elp-&gt;el_gsid_valid : 0;
				<span class="enscript-keyword">if</span> (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_GRNAM) {
					<span class="enscript-type">const</span> <span class="enscript-type">char</span> *oname = kip-&gt;ki_name;
					kip-&gt;ki_name = speculative_name;
					speculative_name = NULL;
					kip-&gt;ki_valid |= KI_VALID_GRNAM;
					<span class="enscript-keyword">if</span> (oname) {
						<span class="enscript-comment">/*
						 * free oname (if any) outside
						 * the lock
						 */</span>
						speculative_name = oname;
					}
				}
				kauth_identity_lru(kip);
				<span class="enscript-keyword">if</span> (rkip != NULL)
					*rkip = *kip;
				KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - refreshed %d is &quot;</span> K_UUID_FMT, kip-&gt;ki_uid, K_UUID_ARG(kip-&gt;ki_guid));
				<span class="enscript-keyword">break</span>;
			}
		}
		KAUTH_IDENTITY_UNLOCK();
		<span class="enscript-comment">/* not found in cache, add new record */</span>
		<span class="enscript-keyword">if</span> (kip == NULL) {
			kip = kauth_identity_alloc(KAUTH_UID_NONE, elp-&gt;el_gid,
			    (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_GGUID) ? &amp;elp-&gt;el_gguid : NULL,
			    (elp-&gt;el_gguid_valid) ? tv.tv_sec + elp-&gt;el_gguid_valid : 0,
			    (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_GSID) ? &amp;elp-&gt;el_gsid : NULL,
			    (elp-&gt;el_gsid_valid) ? tv.tv_sec + elp-&gt;el_gsid_valid : 0,
			    (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_SUPGRPS) ? elp-&gt;el_sup_grp_cnt : 0,
			    (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_SUPGRPS) ? elp-&gt;el_sup_groups : NULL,
			    (elp-&gt;el_member_valid) ? tv.tv_sec + elp-&gt;el_member_valid : 0,
			    (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_GRNAM) ? speculative_name : NULL,
			    KI_VALID_GRNAM);
			<span class="enscript-keyword">if</span> (kip != NULL) {
				<span class="enscript-keyword">if</span> (rkip != NULL)
					*rkip = *kip;
				<span class="enscript-keyword">if</span> (elp-&gt;el_flags &amp; KAUTH_EXTLOOKUP_VALID_GRNAM)
					speculative_name = NULL;
				KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - learned %d is &quot;</span> K_UUID_FMT, kip-&gt;ki_uid, K_UUID_ARG(kip-&gt;ki_guid));
				kauth_identity_register_and_free(kip);
			}
		}
	}

	<span class="enscript-comment">/* If we have a name reference to drop, drop it here */</span>
	<span class="enscript-keyword">if</span> (speculative_name != NULL) {
		vfs_removename(speculative_name);
	}
}


<span class="enscript-comment">/*
 * Trim older entries from the identity cache.
 *
 * Must be called with the identity cache lock held.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_identity_trimcache</span>(<span class="enscript-type">int</span> newsize) {
	<span class="enscript-type">struct</span> kauth_identity 		*kip;
	
	lck_mtx_assert(kauth_identity_mtx, LCK_MTX_ASSERT_OWNED);
		
	<span class="enscript-keyword">while</span> (kauth_identity_count &gt; newsize) {
		kip = TAILQ_LAST(&amp;kauth_identities, kauth_identity_head);
		TAILQ_REMOVE(&amp;kauth_identities, kip, ki_link);
		kauth_identity_count--;
		FREE(kip, M_KAUTH);
	}
}

<span class="enscript-comment">/*
 * kauth_identity_lru
 *
 * Description:	Promote the entry to the head of the LRU, assumes the cache
 *		is locked.
 *
 * Parameters:	kip				kauth identity to move to the
 *						head of the LRU list, if it's
 *						not already there
 *
 * Returns:	(void)
 *
 * Notes:	This is called even if the entry has expired; typically an
 *		expired entry that's been looked up is about to be revalidated,
 *		and having it closer to the head of the LRU means finding it
 *		quickly again when the revalidation comes through.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_identity_lru</span>(<span class="enscript-type">struct</span> kauth_identity *kip)
{
	<span class="enscript-keyword">if</span> (kip != TAILQ_FIRST(&amp;kauth_identities)) {
		TAILQ_REMOVE(&amp;kauth_identities, kip, ki_link);
		TAILQ_INSERT_HEAD(&amp;kauth_identities, kip, ki_link);
	}
}


<span class="enscript-comment">/*
 * kauth_identity_guid_expired
 *
 * Description:	Handle lazy expiration of GUID translations.
 *
 * Parameters:	kip				kauth identity to check for
 *						GUID expiration
 *
 * Returns:	1				Expired
 *		0				Not expired
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_identity_guid_expired</span>(<span class="enscript-type">struct</span> kauth_identity *kip)
{
	<span class="enscript-type">struct</span> timeval tv;

	<span class="enscript-comment">/*
	 * Expiration time of 0 means this entry is persistent.
	 */</span>
	<span class="enscript-keyword">if</span> (kip-&gt;ki_guid_expiry == 0)
		<span class="enscript-keyword">return</span> (0);

	microuptime(&amp;tv);
	KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - GUID expires @ %ld now %ld&quot;</span>, kip-&gt;ki_guid_expiry, tv.tv_sec);

	<span class="enscript-keyword">return</span>((kip-&gt;ki_guid_expiry &lt;= tv.tv_sec) ? 1 : 0);
}


<span class="enscript-comment">/*
 * kauth_identity_ntsid_expired
 *
 * Description:	Handle lazy expiration of NTSID translations.
 *
 * Parameters:	kip				kauth identity to check for
 *						NTSID expiration
 *
 * Returns:	1				Expired
 *		0				Not expired
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_identity_ntsid_expired</span>(<span class="enscript-type">struct</span> kauth_identity *kip)
{
	<span class="enscript-type">struct</span> timeval tv;

	<span class="enscript-comment">/*
	 * Expiration time of 0 means this entry is persistent.
	 */</span>
	<span class="enscript-keyword">if</span> (kip-&gt;ki_ntsid_expiry == 0)
		<span class="enscript-keyword">return</span> (0);

	microuptime(&amp;tv);
	KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - NTSID expires @ %ld now %ld&quot;</span>, kip-&gt;ki_ntsid_expiry, tv.tv_sec);

	<span class="enscript-keyword">return</span>((kip-&gt;ki_ntsid_expiry &lt;= tv.tv_sec) ? 1 : 0);
}

<span class="enscript-comment">/*
 * kauth_identity_groups_expired
 *
 * Description:	Handle lazy expiration of supplemental group translations.
 *
 * Parameters:	kip				kauth identity to check for
 *						groups expiration
 *
 * Returns:	1				Expired
 *		0				Not expired
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_identity_groups_expired</span>(<span class="enscript-type">struct</span> kauth_identity *kip)
{
	<span class="enscript-type">struct</span> timeval tv;

	<span class="enscript-comment">/*
	 * Expiration time of 0 means this entry is persistent.
	 */</span>
	<span class="enscript-keyword">if</span> (kip-&gt;ki_groups_expiry == 0)
		<span class="enscript-keyword">return</span> (0);

	microuptime(&amp;tv);
	KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - GROUPS expires @ %ld now %ld\n&quot;</span>, kip-&gt;ki_groups_expiry, tv.tv_sec);

	<span class="enscript-keyword">return</span>((kip-&gt;ki_groups_expiry &lt;= tv.tv_sec) ? 1 : 0);
}

<span class="enscript-comment">/*
 * kauth_identity_find_uid
 *
 * Description: Search for an entry by UID
 *
 * Parameters:	uid				UID to find
 *		kir				Pointer to return area
 *		getname				Name buffer, if ki_name wanted
 *
 * Returns:	0				Found
 *		ENOENT				Not found
 *
 * Implicit returns:
 *		*klr				Modified, if found
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_identity_find_uid</span>(uid_t uid, <span class="enscript-type">struct</span> kauth_identity *kir, <span class="enscript-type">char</span> *getname)
{
	<span class="enscript-type">struct</span> kauth_identity *kip;

	KAUTH_IDENTITY_LOCK();
	TAILQ_FOREACH(kip, &amp;kauth_identities, ki_link) {
		<span class="enscript-keyword">if</span> ((kip-&gt;ki_valid &amp; KI_VALID_UID) &amp;&amp; (uid == kip-&gt;ki_uid)) {
			kauth_identity_lru(kip);
			<span class="enscript-comment">/* Copy via structure assignment */</span>
			*kir = *kip;
			<span class="enscript-comment">/* If a name is wanted and one exists, copy it out */</span>
			<span class="enscript-keyword">if</span> (getname != NULL &amp;&amp; (kip-&gt;ki_valid &amp; (KI_VALID_PWNAM | KI_VALID_GRNAM)))
				strlcpy(getname, kip-&gt;ki_name, MAXPATHLEN);
			<span class="enscript-keyword">break</span>;
		}
	}
	KAUTH_IDENTITY_UNLOCK();
	<span class="enscript-keyword">return</span>((kip == NULL) ? ENOENT : 0);
}


<span class="enscript-comment">/*
 * kauth_identity_find_gid
 *
 * Description: Search for an entry by GID
 *
 * Parameters:	gid				GID to find
 *		kir				Pointer to return area
 *		getname				Name buffer, if ki_name wanted
 *
 * Returns:	0				Found
 *		ENOENT				Not found
 *
 * Implicit returns:
 *		*klr				Modified, if found
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_identity_find_gid</span>(uid_t gid, <span class="enscript-type">struct</span> kauth_identity *kir, <span class="enscript-type">char</span> *getname)
{
	<span class="enscript-type">struct</span> kauth_identity *kip;

	KAUTH_IDENTITY_LOCK();
	TAILQ_FOREACH(kip, &amp;kauth_identities, ki_link) {
		<span class="enscript-keyword">if</span> ((kip-&gt;ki_valid &amp; KI_VALID_GID) &amp;&amp; (gid == kip-&gt;ki_gid)) {
			kauth_identity_lru(kip);
			<span class="enscript-comment">/* Copy via structure assignment */</span>
			*kir = *kip;
			<span class="enscript-comment">/* If a name is wanted and one exists, copy it out */</span>
			<span class="enscript-keyword">if</span> (getname != NULL &amp;&amp; (kip-&gt;ki_valid &amp; (KI_VALID_PWNAM | KI_VALID_GRNAM)))
				strlcpy(getname, kip-&gt;ki_name, MAXPATHLEN);
			<span class="enscript-keyword">break</span>;
		}
	}
	KAUTH_IDENTITY_UNLOCK();
	<span class="enscript-keyword">return</span>((kip == NULL) ? ENOENT : 0);
}


<span class="enscript-comment">/*
 * kauth_identity_find_guid
 *
 * Description: Search for an entry by GUID
 *
 * Parameters:	guidp				Pointer to GUID to find
 *		kir				Pointer to return area
 *		getname				Name buffer, if ki_name wanted
 *
 * Returns:	0				Found
 *		ENOENT				Not found
 *
 * Implicit returns:
 *		*klr				Modified, if found
 *
 * Note:	The association may be expired, in which case the caller
 *		may elect to call out to userland to revalidate.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_identity_find_guid</span>(guid_t *guidp, <span class="enscript-type">struct</span> kauth_identity *kir, <span class="enscript-type">char</span> *getname)
{
	<span class="enscript-type">struct</span> kauth_identity *kip;

	KAUTH_IDENTITY_LOCK();
	TAILQ_FOREACH(kip, &amp;kauth_identities, ki_link) {
		<span class="enscript-keyword">if</span> ((kip-&gt;ki_valid &amp; KI_VALID_GUID) &amp;&amp; (kauth_guid_equal(guidp, &amp;kip-&gt;ki_guid))) {
			kauth_identity_lru(kip);
			<span class="enscript-comment">/* Copy via structure assignment */</span>
			*kir = *kip;
			<span class="enscript-comment">/* If a name is wanted and one exists, copy it out */</span>
			<span class="enscript-keyword">if</span> (getname != NULL &amp;&amp; (kip-&gt;ki_valid &amp; (KI_VALID_PWNAM | KI_VALID_GRNAM)))
				strlcpy(getname, kip-&gt;ki_name, MAXPATHLEN);
			<span class="enscript-keyword">break</span>;
		}
	}
	KAUTH_IDENTITY_UNLOCK();
	<span class="enscript-keyword">return</span>((kip == NULL) ? ENOENT : 0);
}

<span class="enscript-comment">/*
 * kauth_identity_find_nam
 *
 * Description:	Search for an entry by name
 *
 * Parameters:	name				Pointer to name to find
 *		valid				KI_VALID_PWNAM or KI_VALID_GRNAM
 *		kir				Pointer to return area
 *
 * Returns:	0				Found
 *		ENOENT				Not found
 *
 * Implicit returns:
 *		*klr				Modified, if found
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_identity_find_nam</span>(<span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> valid, <span class="enscript-type">struct</span> kauth_identity *kir)
{
	<span class="enscript-type">struct</span> kauth_identity *kip;

	KAUTH_IDENTITY_LOCK();
	TAILQ_FOREACH(kip, &amp;kauth_identities, ki_link) {
		<span class="enscript-keyword">if</span> ((kip-&gt;ki_valid &amp; valid) &amp;&amp; !strcmp(name, kip-&gt;ki_name)) {
			kauth_identity_lru(kip);
			<span class="enscript-comment">/* Copy via structure assignment */</span>
			*kir = *kip;
			<span class="enscript-keyword">break</span>;
		}
	}
	KAUTH_IDENTITY_UNLOCK();
	<span class="enscript-keyword">return</span>((kip == NULL) ? ENOENT : 0);
}


<span class="enscript-comment">/*
 * kauth_identity_find_ntsid
 *
 * Description: Search for an entry by NTSID
 *
 * Parameters:	ntsid				Pointer to NTSID to find
 *		kir				Pointer to return area
 *		getname				Name buffer, if ki_name wanted
 *
 * Returns:	0				Found
 *		ENOENT				Not found
 *
 * Implicit returns:
 *		*klr				Modified, if found
 *
 * Note:	The association may be expired, in which case the caller
 *		may elect to call out to userland to revalidate.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_identity_find_ntsid</span>(ntsid_t *ntsid, <span class="enscript-type">struct</span> kauth_identity *kir, <span class="enscript-type">char</span> *getname)
{
	<span class="enscript-type">struct</span> kauth_identity *kip;

	KAUTH_IDENTITY_LOCK();
	TAILQ_FOREACH(kip, &amp;kauth_identities, ki_link) {
		<span class="enscript-keyword">if</span> ((kip-&gt;ki_valid &amp; KI_VALID_NTSID) &amp;&amp; (kauth_ntsid_equal(ntsid, &amp;kip-&gt;ki_ntsid))) {
			kauth_identity_lru(kip);
			<span class="enscript-comment">/* Copy via structure assignment */</span>
			*kir = *kip;
			<span class="enscript-comment">/* If a name is wanted and one exists, copy it out */</span>
			<span class="enscript-keyword">if</span> (getname != NULL &amp;&amp; (kip-&gt;ki_valid &amp; (KI_VALID_PWNAM | KI_VALID_GRNAM)))
				strlcpy(getname, kip-&gt;ki_name, MAXPATHLEN);
			<span class="enscript-keyword">break</span>;
		}
	}
	KAUTH_IDENTITY_UNLOCK();
	<span class="enscript-keyword">return</span>((kip == NULL) ? ENOENT : 0);
}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* CONFIG_EXT_RESOLVER */</span>


<span class="enscript-comment">/*
 * GUID handling.
 */</span>
guid_t kauth_null_guid;


<span class="enscript-comment">/*
 * kauth_guid_equal
 *
 * Description:	Determine the equality of two GUIDs
 *
 * Parameters:	guid1				Pointer to first GUID
 *		guid2				Pointer to second GUID
 *
 * Returns:	0				If GUIDs are unequal
 *		!0				If GUIDs are equal
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_guid_equal</span>(guid_t *guid1, guid_t *guid2)
{
	<span class="enscript-keyword">return</span>(bcmp(guid1, guid2, <span class="enscript-keyword">sizeof</span>(*guid1)) == 0);
}


<span class="enscript-comment">/*
 * kauth_wellknown_guid
 *
 * Description:	Determine if a GUID is a well-known GUID
 *
 * Parameters:	guid				Pointer to GUID to check
 *
 * Returns:	KAUTH_WKG_NOT			Not a well known GUID
 *		KAUTH_WKG_EVERYBODY		&quot;Everybody&quot;
 *		KAUTH_WKG_NOBODY		&quot;Nobody&quot;
 *		KAUTH_WKG_OWNER			&quot;Other&quot;
 *		KAUTH_WKG_GROUP			&quot;Group&quot;
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_wellknown_guid</span>(guid_t *guid)
{
	<span class="enscript-type">static</span> <span class="enscript-type">char</span>	fingerprint[] = {0xab, 0xcd, 0xef, 0xab, 0xcd, 0xef, 0xab, 0xcd, 0xef, 0xab, 0xcd, 0xef};
	uint32_t		code;
	<span class="enscript-comment">/*
	 * All WKGs begin with the same 12 bytes.
	 */</span>
	<span class="enscript-keyword">if</span> (bcmp((<span class="enscript-type">void</span> *)guid, fingerprint, 12) == 0) {
		<span class="enscript-comment">/*
		 * The final 4 bytes are our code (in network byte order).
		 */</span>
		code = OSSwapHostToBigInt32(*(uint32_t *)&amp;guid-&gt;g_guid[12]);
		<span class="enscript-keyword">switch</span>(code) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">0x0000000c</span>:
			<span class="enscript-keyword">return</span>(KAUTH_WKG_EVERYBODY);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">0xfffffffe</span>:
			<span class="enscript-keyword">return</span>(KAUTH_WKG_NOBODY);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">0x0000000a</span>:
			<span class="enscript-keyword">return</span>(KAUTH_WKG_OWNER);
		<span class="enscript-keyword">case</span> <span class="enscript-reference">0x00000010</span>:
			<span class="enscript-keyword">return</span>(KAUTH_WKG_GROUP);
		}
	}
	<span class="enscript-keyword">return</span>(KAUTH_WKG_NOT);
}


<span class="enscript-comment">/*
 * kauth_ntsid_equal
 *
 * Description:	Determine the equality of two NTSIDs (NT Security Identifiers) 
 *
 * Parameters:	sid1				Pointer to first NTSID
 *		sid2				Pointer to second NTSID
 *
 * Returns:	0				If GUIDs are unequal
 *		!0				If GUIDs are equal
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_ntsid_equal</span>(ntsid_t *sid1, ntsid_t *sid2)
{
	<span class="enscript-comment">/* check sizes for equality, also sanity-check size while we're at it */</span>
	<span class="enscript-keyword">if</span> ((KAUTH_NTSID_SIZE(sid1) == KAUTH_NTSID_SIZE(sid2)) &amp;&amp;
	    (KAUTH_NTSID_SIZE(sid1) &lt;= <span class="enscript-keyword">sizeof</span>(*sid1)) &amp;&amp;
	    bcmp(sid1, sid2, KAUTH_NTSID_SIZE(sid1)) == 0)
		<span class="enscript-keyword">return</span>(1);
	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-comment">/*
 * Identity KPI
 *
 * We support four tokens representing identity:
 *  - Credential reference
 *  - UID
 *  - GUID
 *  - NT security identifier
 *
 * Of these, the UID is the ubiquitous identifier; cross-referencing should
 * be done using it.
 */</span>



<span class="enscript-comment">/*
 * kauth_cred_change_egid
 *
 * Description:	Set EGID by changing the first element of cr_groups for the
 *		passed credential; if the new EGID exists in the list of
 *		groups already, then rotate the old EGID into its position,
 *		otherwise replace it
 *
 * Parameters:	cred			Pointer to the credential to modify
 *		new_egid		The new EGID to set
 *
 * Returns:	0			The egid did not displace a member of
 *					the supplementary group list
 *		1			The egid being set displaced a member
 *					of the supplementary groups list
 *
 * Note:	Utility function; internal use only because of locking.
 *
 *		This function operates on the credential passed; the caller
 *		must operate either on a newly allocated credential (one for
 *		which there is no hash cache reference and no externally
 *		visible pointer reference), or a template credential.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_change_egid</span>(kauth_cred_t cred, gid_t new_egid)
{
	<span class="enscript-type">int</span>	i;
	<span class="enscript-type">int</span>	displaced = 1;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">radar_4600026</span>
	<span class="enscript-type">int</span>	is_member;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* radar_4600026 */</span>
	gid_t	old_egid = kauth_cred_getgid(cred);
	posix_cred_t pcred = posix_cred_get(cred);

	<span class="enscript-comment">/* Ignoring the first entry, scan for a match for the new egid */</span>
	<span class="enscript-keyword">for</span> (i = 1; i &lt; pcred-&gt;cr_ngroups; i++) {
		<span class="enscript-comment">/*
		 * If we find a match, swap them so we don't lose overall
		 * group information
		 */</span>
		<span class="enscript-keyword">if</span> (pcred-&gt;cr_groups[i] == new_egid) {
			pcred-&gt;cr_groups[i] = old_egid;
			DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;kauth_cred_change_egid: unset displaced\n&quot;</span>);
			displaced = 0;
			<span class="enscript-keyword">break</span>;
		}
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">radar_4600026</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Fix</span> <span class="enscript-variable-name">radar</span> 4600026 <span class="enscript-variable-name">first</span>!!!

<span class="enscript-comment">/*
This is correct for memberd behaviour, but incorrect for POSIX; to address
this, we would need to automatically opt-out any SUID/SGID binary, and force
it to use initgroups to opt back in.  We take the approach of considering it
opt'ed out in any group of 16 displacement instead, since it's a much more
conservative approach (i.e. less likely to cause things to break).
*/</span>

	<span class="enscript-comment">/*
	 * If we displaced a member of the supplementary groups list of the
	 * credential, and we have not opted out of memberd, then if memberd
	 * says that the credential is a member of the group, then it has not
	 * actually been displaced.
	 *
	 * NB:	This is typically a cold code path.
	 */</span>
	<span class="enscript-keyword">if</span> (displaced &amp;&amp; !(pcred-&gt;cr_flags &amp; CRF_NOMEMBERD) &amp;&amp;
	    kauth_cred_ismember_gid(cred, new_egid, &amp;is_member) == 0 &amp;&amp;
	    is_member) {
	    	displaced = 0;
		DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;kauth_cred_change_egid: reset displaced\n&quot;</span>);
	}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* radar_4600026 */</span>

	<span class="enscript-comment">/* set the new EGID into the old spot */</span>
	pcred-&gt;cr_groups[0] = new_egid;

	<span class="enscript-keyword">return</span> (displaced);
}


<span class="enscript-comment">/*
 * kauth_cred_getuid
 *
 * Description:	Fetch UID from credential
 *
 * Parameters:	cred				Credential to examine
 *
 * Returns:	(uid_t)				UID associated with credential
 */</span>
uid_t
<span class="enscript-function-name">kauth_cred_getuid</span>(kauth_cred_t cred)
{
	NULLCRED_CHECK(cred);
	<span class="enscript-keyword">return</span>(posix_cred_get(cred)-&gt;cr_uid);
}


<span class="enscript-comment">/*
 * kauth_cred_getruid
 *
 * Description:	Fetch RUID from credential
 *
 * Parameters:	cred				Credential to examine
 *
 * Returns:	(uid_t)				RUID associated with credential
 */</span>
uid_t
<span class="enscript-function-name">kauth_cred_getruid</span>(kauth_cred_t cred)
{
	NULLCRED_CHECK(cred);
	<span class="enscript-keyword">return</span>(posix_cred_get(cred)-&gt;cr_ruid);
}


<span class="enscript-comment">/*
 * kauth_cred_getsvuid
 *
 * Description:	Fetch SVUID from credential
 *
 * Parameters:	cred				Credential to examine
 *
 * Returns:	(uid_t)				SVUID associated with credential
 */</span>
uid_t
<span class="enscript-function-name">kauth_cred_getsvuid</span>(kauth_cred_t cred)
{
	NULLCRED_CHECK(cred);
	<span class="enscript-keyword">return</span>(posix_cred_get(cred)-&gt;cr_svuid);
}


<span class="enscript-comment">/*
 * kauth_cred_getgid
 *
 * Description:	Fetch GID from credential
 *
 * Parameters:	cred				Credential to examine
 *
 * Returns:	(gid_t)				GID associated with credential
 */</span>
gid_t
<span class="enscript-function-name">kauth_cred_getgid</span>(kauth_cred_t cred)
{
	NULLCRED_CHECK(cred);
	<span class="enscript-keyword">return</span>(posix_cred_get(cred)-&gt;cr_gid);
}


<span class="enscript-comment">/*
 * kauth_cred_getrgid
 *
 * Description:	Fetch RGID from credential
 *
 * Parameters:	cred				Credential to examine
 *
 * Returns:	(gid_t)				RGID associated with credential
 */</span>
gid_t
<span class="enscript-function-name">kauth_cred_getrgid</span>(kauth_cred_t cred)
{
	NULLCRED_CHECK(cred);
	<span class="enscript-keyword">return</span>(posix_cred_get(cred)-&gt;cr_rgid);
}


<span class="enscript-comment">/*
 * kauth_cred_getsvgid
 *
 * Description:	Fetch SVGID from credential
 *
 * Parameters:	cred				Credential to examine
 *
 * Returns:	(gid_t)				SVGID associated with credential
 */</span>
gid_t
<span class="enscript-function-name">kauth_cred_getsvgid</span>(kauth_cred_t cred)
{
	NULLCRED_CHECK(cred);
	<span class="enscript-keyword">return</span>(posix_cred_get(cred)-&gt;cr_svgid);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>	kauth_cred_cache_lookup(<span class="enscript-type">int</span> from, <span class="enscript-type">int</span> to, <span class="enscript-type">void</span> *src, <span class="enscript-type">void</span> *dst);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_EXT_RESOLVER</span> == 0
<span class="enscript-comment">/*
 * If there's no resolver, short-circuit the kauth_cred_x2y() lookups.
 */</span>
<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_cache_lookup</span>(__unused <span class="enscript-type">int</span> from, __unused <span class="enscript-type">int</span> to,
	__unused <span class="enscript-type">void</span> *src, __unused <span class="enscript-type">void</span> *dst)
{
	<span class="enscript-keyword">return</span> (EWOULDBLOCK);

}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">CONFIG_EXT_RESOLVER</span>) &amp;&amp; (<span class="enscript-variable-name">CONFIG_EXT_RESOLVER</span>)
<span class="enscript-comment">/*
 * Structure to hold supplemental groups. Used for impedance matching with 
 * kauth_cred_cache_lookup below.
 */</span>
<span class="enscript-type">struct</span> supgroups {
	<span class="enscript-type">int</span> *count;
	gid_t *groups;
};

<span class="enscript-comment">/*
 * kauth_cred_uid2groups
 *
 * Description:	Fetch supplemental GROUPS from UID
 *
 * Parameters:	uid				UID to examine
 *		groups				pointer to an array of gid_ts
 *		gcount				pointer to the number of groups wanted/returned
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*groups				Modified, if successful
 *		*gcount				Modified, if successful
 *
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_uid2groups</span>(uid_t *uid, gid_t *groups, <span class="enscript-type">int</span> *gcount)
{
	<span class="enscript-type">int</span> rv;

	<span class="enscript-type">struct</span> supgroups supgroups;
	supgroups.count = gcount;
	supgroups.groups = groups;

	rv = kauth_cred_cache_lookup(KI_VALID_UID, KI_VALID_GROUPS, uid, &amp;supgroups);

	<span class="enscript-keyword">return</span> (rv);
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * kauth_cred_guid2pwnam
 *
 * Description:	Fetch PWNAM from GUID
 *
 * Parameters:	guidp				Pointer to GUID to examine
 *		pwnam				Pointer to user@domain buffer
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*pwnam				Modified, if successful
 *
 * Notes:	pwnam is assumed to point to a buffer of MAXPATHLEN in size
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_guid2pwnam</span>(guid_t *guidp, <span class="enscript-type">char</span> *pwnam)
{
	<span class="enscript-keyword">return</span>(kauth_cred_cache_lookup(KI_VALID_GUID, KI_VALID_PWNAM, guidp, pwnam));
}


<span class="enscript-comment">/*
 * kauth_cred_guid2grnam
 *
 * Description:	Fetch GRNAM from GUID
 *
 * Parameters:	guidp				Pointer to GUID to examine
 *		grnam				Pointer to group@domain buffer
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*grnam				Modified, if successful
 *
 * Notes:	grnam is assumed to point to a buffer of MAXPATHLEN in size
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_guid2grnam</span>(guid_t *guidp, <span class="enscript-type">char</span> *grnam)
{
	<span class="enscript-keyword">return</span>(kauth_cred_cache_lookup(KI_VALID_GUID, KI_VALID_GRNAM, guidp, grnam));
}


<span class="enscript-comment">/*
 * kauth_cred_pwnam2guid
 *
 * Description:	Fetch PWNAM from GUID
 *
 * Parameters:	pwnam				String containing user@domain
 *		guidp				Pointer to buffer for GUID
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*guidp				Modified, if successful
 *
 * Notes:	pwnam should not point to a request larger than MAXPATHLEN
 *		bytes in size, including the NUL termination of the string.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_pwnam2guid</span>(<span class="enscript-type">char</span> *pwnam, guid_t *guidp)
{
	<span class="enscript-keyword">return</span>(kauth_cred_cache_lookup(KI_VALID_PWNAM, KI_VALID_GUID, pwnam, guidp));
}


<span class="enscript-comment">/*
 * kauth_cred_grnam2guid
 *
 * Description:	Fetch GRNAM from GUID
 *
 * Parameters:	grnam				String containing group@domain
 *		guidp				Pointer to buffer for GUID
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*guidp				Modified, if successful
 *
 * Notes:	grnam should not point to a request larger than MAXPATHLEN
 *		bytes in size, including the NUL termination of the string.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_grnam2guid</span>(<span class="enscript-type">char</span> *grnam, guid_t *guidp)
{
	<span class="enscript-keyword">return</span>(kauth_cred_cache_lookup(KI_VALID_GRNAM, KI_VALID_GUID, grnam, guidp));
}


<span class="enscript-comment">/*
 * kauth_cred_guid2uid
 *
 * Description:	Fetch UID from GUID
 *
 * Parameters:	guidp				Pointer to GUID to examine
 *		uidp				Pointer to buffer for UID
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*uidp				Modified, if successful
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_guid2uid</span>(guid_t *guidp, uid_t *uidp)
{
	<span class="enscript-keyword">return</span>(kauth_cred_cache_lookup(KI_VALID_GUID, KI_VALID_UID, guidp, uidp));
}


<span class="enscript-comment">/*
 * kauth_cred_guid2gid
 *
 * Description:	Fetch GID from GUID
 *
 * Parameters:	guidp				Pointer to GUID to examine
 *		gidp				Pointer to buffer for GID
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*gidp				Modified, if successful
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_guid2gid</span>(guid_t *guidp, gid_t *gidp)
{
	<span class="enscript-keyword">return</span>(kauth_cred_cache_lookup(KI_VALID_GUID, KI_VALID_GID, guidp, gidp));
}


<span class="enscript-comment">/*
 * kauth_cred_ntsid2uid
 *
 * Description:	Fetch UID from NTSID
 *
 * Parameters:	sidp				Pointer to NTSID to examine
 *		uidp				Pointer to buffer for UID
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*uidp				Modified, if successful
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_ntsid2uid</span>(ntsid_t *sidp, uid_t *uidp)
{
	<span class="enscript-keyword">return</span>(kauth_cred_cache_lookup(KI_VALID_NTSID, KI_VALID_UID, sidp, uidp));
}


<span class="enscript-comment">/*
 * kauth_cred_ntsid2gid
 *
 * Description:	Fetch GID from NTSID
 *
 * Parameters:	sidp				Pointer to NTSID to examine
 *		gidp				Pointer to buffer for GID
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*gidp				Modified, if successful
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_ntsid2gid</span>(ntsid_t *sidp, gid_t *gidp)
{
	<span class="enscript-keyword">return</span>(kauth_cred_cache_lookup(KI_VALID_NTSID, KI_VALID_GID, sidp, gidp));
}


<span class="enscript-comment">/*
 * kauth_cred_ntsid2guid
 *
 * Description:	Fetch GUID from NTSID
 *
 * Parameters:	sidp				Pointer to NTSID to examine
 *		guidp				Pointer to buffer for GUID
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*guidp				Modified, if successful
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_ntsid2guid</span>(ntsid_t *sidp, guid_t *guidp)
{
	<span class="enscript-keyword">return</span>(kauth_cred_cache_lookup(KI_VALID_NTSID, KI_VALID_GUID, sidp, guidp));
}


<span class="enscript-comment">/*
 * kauth_cred_uid2guid
 *
 * Description:	Fetch GUID from UID
 *
 * Parameters:	uid				UID to examine
 *		guidp				Pointer to buffer for GUID
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*guidp				Modified, if successful
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_uid2guid</span>(uid_t uid, guid_t *guidp)
{
	<span class="enscript-keyword">return</span>(kauth_cred_cache_lookup(KI_VALID_UID, KI_VALID_GUID, &amp;uid, guidp));
}


<span class="enscript-comment">/*
 * kauth_cred_getguid
 *
 * Description:	Fetch GUID from credential
 *
 * Parameters:	cred				Credential to examine
 *		guidp				Pointer to buffer for GUID
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*guidp				Modified, if successful
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_getguid</span>(kauth_cred_t cred, guid_t *guidp)
{
	NULLCRED_CHECK(cred);
	<span class="enscript-keyword">return</span>(kauth_cred_uid2guid(kauth_cred_getuid(cred), guidp));
}


<span class="enscript-comment">/*
 * kauth_cred_getguid
 *
 * Description:	Fetch GUID from GID
 *
 * Parameters:	gid				GID to examine
 *		guidp				Pointer to buffer for GUID
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*guidp				Modified, if successful
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_gid2guid</span>(gid_t gid, guid_t *guidp)
{
	<span class="enscript-keyword">return</span>(kauth_cred_cache_lookup(KI_VALID_GID, KI_VALID_GUID, &amp;gid, guidp));
}


<span class="enscript-comment">/*
 * kauth_cred_uid2ntsid
 *
 * Description:	Fetch NTSID from UID
 *
 * Parameters:	uid				UID to examine
 *		sidp				Pointer to buffer for NTSID
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*sidp				Modified, if successful
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_uid2ntsid</span>(uid_t uid, ntsid_t *sidp)
{
	<span class="enscript-keyword">return</span>(kauth_cred_cache_lookup(KI_VALID_UID, KI_VALID_NTSID, &amp;uid, sidp));
}


<span class="enscript-comment">/*
 * kauth_cred_getntsid
 *
 * Description:	Fetch NTSID from credential
 *
 * Parameters:	cred				Credential to examine
 *		sidp				Pointer to buffer for NTSID
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*sidp				Modified, if successful
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_getntsid</span>(kauth_cred_t cred, ntsid_t *sidp)
{
	NULLCRED_CHECK(cred);
	<span class="enscript-keyword">return</span>(kauth_cred_uid2ntsid(kauth_cred_getuid(cred), sidp));
}


<span class="enscript-comment">/*
 * kauth_cred_gid2ntsid
 *
 * Description:	Fetch NTSID from GID
 *
 * Parameters:	gid				GID to examine
 *		sidp				Pointer to buffer for NTSID
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*sidp				Modified, if successful
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_gid2ntsid</span>(gid_t gid, ntsid_t *sidp)
{
	<span class="enscript-keyword">return</span>(kauth_cred_cache_lookup(KI_VALID_GID, KI_VALID_NTSID, &amp;gid, sidp));
}


<span class="enscript-comment">/*
 * kauth_cred_guid2ntsid
 *
 * Description:	Fetch NTSID from GUID
 *
 * Parameters:	guidp				Pointer to GUID to examine
 *		sidp				Pointer to buffer for NTSID
 *
 * Returns:	0				Success
 *	kauth_cred_cache_lookup:EINVAL
 *
 * Implicit returns:
 *		*sidp				Modified, if successful
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_guid2ntsid</span>(guid_t *guidp, ntsid_t *sidp)
{
	<span class="enscript-keyword">return</span>(kauth_cred_cache_lookup(KI_VALID_GUID, KI_VALID_NTSID, guidp, sidp));
}


<span class="enscript-comment">/*
 * kauth_cred_cache_lookup
 *
 * Description:	Lookup a translation in the cache; if one is not found, and
 *		the attempt was not fatal, submit the request to the resolver
 *		instead, and wait for it to complete or be aborted.
 *
 * Parameters:	from				Identity information we have
 *		to				Identity information we want
 *		src				Pointer to buffer containing
 *						the source identity
 *		dst				Pointer to buffer to receive
 *						the target identity
 *
 * Returns:	0				Success
 *		EINVAL				Unknown source identity type
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_EXT_RESOLVER</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_cache_lookup</span>(<span class="enscript-type">int</span> from, <span class="enscript-type">int</span> to, <span class="enscript-type">void</span> *src, <span class="enscript-type">void</span> *dst)
{
	<span class="enscript-type">struct</span> kauth_identity ki;
	<span class="enscript-type">struct</span> kauth_identity_extlookup el;
	<span class="enscript-type">int</span> error;
	uint64_t extend_data = 0ULL;
	<span class="enscript-type">int</span> (* expired)(<span class="enscript-type">struct</span> kauth_identity *kip);
	<span class="enscript-type">char</span> *namebuf = NULL;

	KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - translate %d to %d&quot;</span>, from, to);
	
	<span class="enscript-comment">/*
	 * Look for an existing cache entry for this association.
	 * If the entry has not expired, return the cached information.
	 * We do not cache user@domain translations here; they use too
	 * much memory to hold onto forever, and can not be updated
	 * atomically.
	 */</span>
	<span class="enscript-keyword">if</span> (to == KI_VALID_PWNAM || to == KI_VALID_GRNAM) {
		namebuf = dst;
	}
	ki.ki_valid = 0;
	<span class="enscript-keyword">switch</span>(from) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_UID</span>:
		error = kauth_identity_find_uid(*(uid_t *)src, &amp;ki, namebuf);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_GID</span>:
		error = kauth_identity_find_gid(*(gid_t *)src, &amp;ki, namebuf);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_GUID</span>:
		error = kauth_identity_find_guid((guid_t *)src, &amp;ki, namebuf);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_NTSID</span>:
		error = kauth_identity_find_ntsid((ntsid_t *)src, &amp;ki, namebuf);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_PWNAM</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_GRNAM</span>:
		<span class="enscript-comment">/* Names are unique in their 'from' space */</span>
		error = kauth_identity_find_nam((<span class="enscript-type">char</span> *)src, from, &amp;ki);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span>(EINVAL);
	}
	<span class="enscript-comment">/* lookup failure or error */</span>
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-comment">/* any other error is fatal */</span>
		<span class="enscript-keyword">if</span> (error != ENOENT) {
			<span class="enscript-comment">/* XXX bogus check - this is not possible */</span>
			KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - cache search error %d&quot;</span>, error);
			<span class="enscript-keyword">return</span>(error);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* found a valid cached entry, check expiry */</span>
		<span class="enscript-keyword">switch</span>(to) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_GUID</span>:
			expired = kauth_identity_guid_expired;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_NTSID</span>:
			expired = kauth_identity_ntsid_expired;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_GROUPS</span>:
			expired = kauth_identity_groups_expired;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">switch</span>(from) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_GUID</span>:
				expired = kauth_identity_guid_expired;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_NTSID</span>:
				expired = kauth_identity_ntsid_expired;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				expired = NULL;
			}
		}

		<span class="enscript-comment">/*
		 * If no expiry function, or not expired, we have found
		 * a hit.
		 */</span>
		<span class="enscript-keyword">if</span> (expired) {
			<span class="enscript-keyword">if</span> (!expired(&amp;ki)) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - entry valid, unexpired&quot;</span>);
				expired = NULL; <span class="enscript-comment">/* must clear it is used as a flag */</span>
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * We leave ki_valid set here; it contains a
				 * translation but the TTL has expired.  If we can't
				 * get a result from the resolver, we will use it as
				 * a better-than nothing alternative.
				 */</span>
				
				KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - expired entry found&quot;</span>);
			}
		} <span class="enscript-keyword">else</span> {
			KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - no expiry function&quot;</span>);
		}
		
		<span class="enscript-keyword">if</span> (!expired) {
			<span class="enscript-comment">/* do we have a translation? */</span>
			<span class="enscript-keyword">if</span> (ki.ki_valid &amp; to) {
				KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - found matching entry with valid 0x%08x&quot;</span>, ki.ki_valid);
				DTRACE_PROC4(kauth__identity__cache__hit, <span class="enscript-type">int</span>, from, <span class="enscript-type">int</span>, to, <span class="enscript-type">void</span> *, src, <span class="enscript-type">void</span> *, dst);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * GUIDs and NTSIDs map to either a UID or a GID, but not both. 
				 * If we went looking for a translation from GUID or NTSID and 
				 * found a translation that wasn't for our desired type, then 
				 * don't bother calling the resolver. We know that this 
				 * GUID/NTSID can't translate to our desired type.
				 */</span>
				<span class="enscript-keyword">switch</span>(from) {
				<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_GUID</span>:
				<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_NTSID</span>:
					<span class="enscript-keyword">switch</span>(to) {
					<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_GID</span>:
						<span class="enscript-keyword">if</span> ((ki.ki_valid &amp; KI_VALID_UID)) {
							KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - unexpected entry 0x%08x &amp; %x&quot;</span>, ki.ki_valid, KI_VALID_GID);
							<span class="enscript-keyword">return</span> (ENOENT);
						}
						<span class="enscript-keyword">break</span>;
					<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_UID</span>:
						<span class="enscript-keyword">if</span> ((ki.ki_valid &amp; KI_VALID_GID)) {
							KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - unexpected entry 0x%08x &amp; %x&quot;</span>, ki.ki_valid, KI_VALID_UID);
							<span class="enscript-keyword">return</span> (ENOENT);
						}
						<span class="enscript-keyword">break</span>;
					}
					<span class="enscript-keyword">break</span>;
				}
			}
		}
	}

	<span class="enscript-comment">/*
	 * We failed to find a cache entry; call the resolver.
	 *
	 * Note:	We ask for as much non-extended data as we can get,
	 *		and only provide (or ask for) extended information if
	 *		we have a 'from' (or 'to') which requires it.  This
	 *		way we don't pay for the extra transfer overhead for
	 *		data we don't need.
	 */</span>
	bzero(&amp;el, <span class="enscript-keyword">sizeof</span>(el));
	el.el_info_pid = current_proc()-&gt;p_pid;
	<span class="enscript-keyword">switch</span>(from) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_UID</span>:
		el.el_flags = KAUTH_EXTLOOKUP_VALID_UID;
		el.el_uid = *(uid_t *)src;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_GID</span>:
		el.el_flags = KAUTH_EXTLOOKUP_VALID_GID;
		el.el_gid = *(gid_t *)src;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_GUID</span>:
		el.el_flags = KAUTH_EXTLOOKUP_VALID_UGUID | KAUTH_EXTLOOKUP_VALID_GGUID;
		el.el_uguid = *(guid_t *)src;
		el.el_gguid = *(guid_t *)src;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_NTSID</span>:
		el.el_flags = KAUTH_EXTLOOKUP_VALID_USID | KAUTH_EXTLOOKUP_VALID_GSID;
		el.el_usid = *(ntsid_t *)src;
		el.el_gsid = *(ntsid_t *)src;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_PWNAM</span>:
		<span class="enscript-comment">/* extra overhead */</span>
		el.el_flags = KAUTH_EXTLOOKUP_VALID_PWNAM;
		extend_data = CAST_USER_ADDR_T(src);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_GRNAM</span>:
		<span class="enscript-comment">/* extra overhead */</span>
		el.el_flags = KAUTH_EXTLOOKUP_VALID_GRNAM;
		extend_data = CAST_USER_ADDR_T(src);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span>(EINVAL);
	}
	<span class="enscript-comment">/*
	 * Here we ask for everything all at once, to avoid having to work
	 * out what we really want now, or might want soon.
	 *
	 * Asking for SID translations when we don't know we need them right
	 * now is going to cause excess work to be done if we're connected
	 * to a network that thinks it can translate them.  This list needs
	 * to get smaller/smarter.
	 */</span>
	el.el_flags |= KAUTH_EXTLOOKUP_WANT_UID | KAUTH_EXTLOOKUP_WANT_GID |
	    KAUTH_EXTLOOKUP_WANT_UGUID | KAUTH_EXTLOOKUP_WANT_GGUID |
	    KAUTH_EXTLOOKUP_WANT_USID | KAUTH_EXTLOOKUP_WANT_GSID;
	<span class="enscript-keyword">if</span> (to == KI_VALID_PWNAM) {
		<span class="enscript-comment">/* extra overhead */</span>
		el.el_flags |= KAUTH_EXTLOOKUP_WANT_PWNAM;
		extend_data = CAST_USER_ADDR_T(dst);
	}
	<span class="enscript-keyword">if</span> (to == KI_VALID_GRNAM) {
		<span class="enscript-comment">/* extra overhead */</span>
		el.el_flags |= KAUTH_EXTLOOKUP_WANT_GRNAM;
		extend_data = CAST_USER_ADDR_T(dst);
	}
	<span class="enscript-keyword">if</span> (to == KI_VALID_GROUPS) {
		<span class="enscript-comment">/* Expensive and only useful for an NFS client not using kerberos */</span>
		el.el_flags |= KAUTH_EXTLOOKUP_WANT_SUPGRPS;
		<span class="enscript-keyword">if</span> (ki.ki_valid &amp; KI_VALID_GROUPS) {
			<span class="enscript-comment">/*
			 * Copy the current supplemental groups for the resolver. 
			 * The resolver should check these groups first and if
			 * the user (uid) is still a member it should endeavor to 
			 * keep them in the list. Otherwise NFS clients could get
			 * changing access to server file system objects on each
			 * expiration.
			 */</span>
			el.el_sup_grp_cnt = ki.ki_supgrpcnt;

			memcpy(el.el_sup_groups, ki.ki_supgrps, <span class="enscript-keyword">sizeof</span> (el.el_sup_groups[0]) * ki.ki_supgrpcnt);
			<span class="enscript-comment">/* Let the resolver know these were the previous valid groups */</span>
			el.el_flags |= KAUTH_EXTLOOKUP_VALID_SUPGRPS;
			KAUTH_DEBUG(<span class="enscript-string">&quot;GROUPS: Sending previously valid GROUPS&quot;</span>);
		} <span class="enscript-keyword">else</span>
			KAUTH_DEBUG(<span class="enscript-string">&quot;GROUPS: no valid groups to send&quot;</span>);
	}

	<span class="enscript-comment">/* Call resolver */</span>
	KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - calling resolver for %x&quot;</span>, el.el_flags);

	DTRACE_PROC3(kauth__id__resolver__submitted, <span class="enscript-type">int</span>, from, <span class="enscript-type">int</span>, to, uintptr_t, src);
	
	error = kauth_resolver_submit(&amp;el, extend_data);

	DTRACE_PROC2(kauth__id__resolver__returned, <span class="enscript-type">int</span>, error, <span class="enscript-type">struct</span> kauth_identity_extlookup *, &amp;el)
	
	KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - resolver returned %d&quot;</span>, error);

	<span class="enscript-comment">/* was the external lookup successful? */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-comment">/*
		 * Save the results from the lookup - we may have other
		 * information, even if we didn't get a guid or the
		 * extended data.
		 *
		 * If we came from a name, we know the extend_data is valid.
		 */</span>
		<span class="enscript-keyword">if</span> (from == KI_VALID_PWNAM)
			el.el_flags |= KAUTH_EXTLOOKUP_VALID_PWNAM;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (from == KI_VALID_GRNAM)
			el.el_flags |= KAUTH_EXTLOOKUP_VALID_GRNAM;

		kauth_identity_updatecache(&amp;el, &amp;ki, extend_data);

		<span class="enscript-comment">/*
		 * Check to see if we have a valid cache entry
		 * originating from the result.
		 */</span>
		<span class="enscript-keyword">if</span> (!(ki.ki_valid &amp; to)) {
			error = ENOENT;
		}
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span>(error);
<span class="enscript-reference">found</span>:
	<span class="enscript-comment">/*
	 * Copy from the appropriate struct kauth_identity cache entry
	 * structure into the destination buffer area.
	 */</span>
	<span class="enscript-keyword">switch</span>(to) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_UID</span>:
		*(uid_t *)dst = ki.ki_uid;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_GID</span>:
		*(gid_t *)dst = ki.ki_gid;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_GUID</span>:
		*(guid_t *)dst = ki.ki_guid;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_NTSID</span>:
		*(ntsid_t *)dst = ki.ki_ntsid;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_GROUPS</span>: {
			<span class="enscript-type">struct</span> supgroups *gp = (<span class="enscript-type">struct</span> supgroups *)dst;
			u_int32_t limit = ki.ki_supgrpcnt;
			
			<span class="enscript-keyword">if</span> (gp-&gt;count) {
				limit = MIN(ki.ki_supgrpcnt, *gp-&gt;count);
				*gp-&gt;count = limit;
			}
			
			memcpy(gp-&gt;groups, ki.ki_supgrps, <span class="enscript-keyword">sizeof</span>(gid_t) * limit);
		}
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_PWNAM</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KI_VALID_GRNAM</span>:
		<span class="enscript-comment">/* handled in kauth_resolver_complete() */</span>
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">return</span>(EINVAL);
	}
	KAUTH_DEBUG(<span class="enscript-string">&quot;CACHE - returned successfully&quot;</span>);
	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-comment">/*
 * Group membership cache.
 *
 * XXX the linked-list implementation here needs to be optimized.
 */</span>

<span class="enscript-comment">/*
 * kauth_groups_init
 *
 * Description:	Initialize the groups cache
 *
 * Parameters:	(void)
 *
 * Returns:	(void)
 *
 * Notes:	Initialize the groups cache for use; the group cache is used
 *		to avoid unnecessary calls out to user space.
 *
 *		This function is called from kauth_init() in the file
 *		kern_authorization.c.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_groups_init</span>(<span class="enscript-type">void</span>)
{
	TAILQ_INIT(&amp;kauth_groups);
	kauth_groups_mtx = lck_mtx_alloc_init(kauth_lck_grp, 0<span class="enscript-comment">/*LCK_ATTR_NULL*/</span>);
}


<span class="enscript-comment">/*
 * kauth_groups_expired
 *
 * Description:	Handle lazy expiration of group membership cache entries
 *
 * Parameters:	gm				group membership entry to
 *						check for expiration
 *
 * Returns:	1				Expired
 *		0				Not expired
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_groups_expired</span>(<span class="enscript-type">struct</span> kauth_group_membership *gm)
{
	<span class="enscript-type">struct</span> timeval tv;

	<span class="enscript-comment">/*
	 * Expiration time of 0 means this entry is persistent.
	 */</span>
	<span class="enscript-keyword">if</span> (gm-&gt;gm_expiry == 0)
		<span class="enscript-keyword">return</span> (0);
		
	microuptime(&amp;tv);
	
	<span class="enscript-keyword">return</span>((gm-&gt;gm_expiry &lt;= tv.tv_sec) ? 1 : 0);
}


<span class="enscript-comment">/*
 * kauth_groups_lru
 *
 * Description:	Promote the entry to the head of the LRU, assumes the cache
 *		is locked.
 *
 * Parameters:	kip				group membership entry to move
 *						to the head of the LRU list,
 *						if it's not already there
 *
 * Returns:	(void)
 *
 * Notes:	This is called even if the entry has expired; typically an
 *		expired entry that's been looked up is about to be revalidated,
 *		and having it closer to the head of the LRU means finding it
 *		quickly again when the revalidation comes through.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_groups_lru</span>(<span class="enscript-type">struct</span> kauth_group_membership *gm)
{
	<span class="enscript-keyword">if</span> (gm != TAILQ_FIRST(&amp;kauth_groups)) {
		TAILQ_REMOVE(&amp;kauth_groups, gm, gm_link);
		TAILQ_INSERT_HEAD(&amp;kauth_groups, gm, gm_link);
	}
}


<span class="enscript-comment">/*
 * kauth_groups_updatecache
 *
 * Description:	Given a lookup result, add any group cache associations that
 *		we don't currently have.
 *
 * Parameters:	elp				External lookup result from
 *						user space daemon to kernel
 *		rkip				pointer to returned kauth
 *						identity, or NULL
 *
 * Returns:	(void)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_groups_updatecache</span>(<span class="enscript-type">struct</span> kauth_identity_extlookup *el)
{
	<span class="enscript-type">struct</span> kauth_group_membership *gm;
	<span class="enscript-type">struct</span> timeval tv;
	
	<span class="enscript-comment">/* need a valid response if we are to cache anything */</span>
	<span class="enscript-keyword">if</span> ((el-&gt;el_flags &amp;
		(KAUTH_EXTLOOKUP_VALID_UID | KAUTH_EXTLOOKUP_VALID_GID | KAUTH_EXTLOOKUP_VALID_MEMBERSHIP)) !=
	    (KAUTH_EXTLOOKUP_VALID_UID | KAUTH_EXTLOOKUP_VALID_GID | KAUTH_EXTLOOKUP_VALID_MEMBERSHIP))
		<span class="enscript-keyword">return</span>;

	microuptime(&amp;tv);

	<span class="enscript-comment">/*
	 * Search for an existing record for this association before inserting
	 * a new one; if we find one, update it instead of creating a new one
	 */</span>
	KAUTH_GROUPS_LOCK();
	TAILQ_FOREACH(gm, &amp;kauth_groups, gm_link) {
		<span class="enscript-keyword">if</span> ((el-&gt;el_uid == gm-&gt;gm_uid) &amp;&amp;
		    (el-&gt;el_gid == gm-&gt;gm_gid)) {
			<span class="enscript-keyword">if</span> (el-&gt;el_flags &amp; KAUTH_EXTLOOKUP_ISMEMBER) {
				gm-&gt;gm_flags |= KAUTH_GROUP_ISMEMBER;
			} <span class="enscript-keyword">else</span> {
				gm-&gt;gm_flags &amp;= ~KAUTH_GROUP_ISMEMBER;
			}
			gm-&gt;gm_expiry = (el-&gt;el_member_valid) ? el-&gt;el_member_valid + tv.tv_sec : 0;
			kauth_groups_lru(gm);
			<span class="enscript-keyword">break</span>;
		}
	}
	KAUTH_GROUPS_UNLOCK();

	<span class="enscript-comment">/* if we found an entry to update, stop here */</span>
	<span class="enscript-keyword">if</span> (gm != NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-comment">/* allocate a new record */</span>
	MALLOC(gm, <span class="enscript-type">struct</span> kauth_group_membership *, <span class="enscript-keyword">sizeof</span>(*gm), M_KAUTH, M_WAITOK);
	<span class="enscript-keyword">if</span> (gm != NULL) {
		gm-&gt;gm_uid = el-&gt;el_uid;
		gm-&gt;gm_gid = el-&gt;el_gid;
		<span class="enscript-keyword">if</span> (el-&gt;el_flags &amp; KAUTH_EXTLOOKUP_ISMEMBER) {
			gm-&gt;gm_flags |= KAUTH_GROUP_ISMEMBER;
		} <span class="enscript-keyword">else</span> {
			gm-&gt;gm_flags &amp;= ~KAUTH_GROUP_ISMEMBER;
		}
		gm-&gt;gm_expiry = (el-&gt;el_member_valid) ? el-&gt;el_member_valid + tv.tv_sec : 0;
	}		

	<span class="enscript-comment">/*
	 * Insert the new entry.  Note that it's possible to race ourselves
	 * here and end up with duplicate entries in the list.  Wasteful, but
	 * harmless since the first into the list will never be looked up,
	 * and thus will eventually just fall off the end.
	 */</span>
	KAUTH_GROUPS_LOCK();
	TAILQ_INSERT_HEAD(&amp;kauth_groups, gm, gm_link);
	<span class="enscript-keyword">if</span> (++kauth_groups_count &gt; kauth_groups_cachemax) {
		gm = TAILQ_LAST(&amp;kauth_groups, kauth_groups_head);
		TAILQ_REMOVE(&amp;kauth_groups, gm, gm_link);
		kauth_groups_count--;
	} <span class="enscript-keyword">else</span> {
		gm = NULL;
	}
	KAUTH_GROUPS_UNLOCK();

	<span class="enscript-comment">/* free expired cache entry */</span>
	<span class="enscript-keyword">if</span> (gm != NULL)
		FREE(gm, M_KAUTH);
}

<span class="enscript-comment">/*
 * Trim older entries from the group membership cache.
 *
 * Must be called with the group cache lock held.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_groups_trimcache</span>(<span class="enscript-type">int</span> new_size) {
        <span class="enscript-type">struct</span> kauth_group_membership *gm;

	lck_mtx_assert(kauth_groups_mtx, LCK_MTX_ASSERT_OWNED);
        
	<span class="enscript-keyword">while</span> (kauth_groups_count &gt; new_size) {
		gm = TAILQ_LAST(&amp;kauth_groups, kauth_groups_head);
		TAILQ_REMOVE(&amp;kauth_groups, gm, gm_link);
		kauth_groups_count--;
		FREE(gm, M_KAUTH);
	}
}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* CONFIG_EXT_RESOLVER */</span>

<span class="enscript-comment">/*
 * Group membership KPI
 */</span>

<span class="enscript-comment">/*
 * kauth_cred_ismember_gid
 *
 * Description:	Given a credential and a GID, determine if the GID is a member
 *		of one of the supplementary groups associated with the given
 *		credential
 *
 * Parameters:	cred				Credential to check in
 *		gid				GID to check for membership
 *		resultp				Pointer to int to contain the
 *						result of the call
 *
 * Returns:	0				Success
 *		ENOENT				Could not perform lookup
 *	kauth_resolver_submit:EWOULDBLOCK
 *	kauth_resolver_submit:EINTR
 *	kauth_resolver_submit:ENOMEM
 *	kauth_resolver_submit:ENOENT		User space daemon did not vend
 *						this credential.
 *	kauth_resolver_submit:???		Unlikely error from user space
 *
 * Implicit returns:
 *		*resultp (modified)	1	Is member
 *					0	Is not member
 *
 * Notes:	This function guarantees not to modify resultp when returning
 *		an error.
 *
 *		This function effectively checks the EGID as well, since the
 *		EGID is cr_groups[0] as an implementation detail.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_ismember_gid</span>(kauth_cred_t cred, gid_t gid, <span class="enscript-type">int</span> *resultp)
{
	posix_cred_t pcred = posix_cred_get(cred);
	<span class="enscript-type">int</span> i;

	<span class="enscript-comment">/*
	 * Check the per-credential list of override groups.
	 *
	 * We can conditionalise this on cred-&gt;cr_gmuid == KAUTH_UID_NONE since
	 * the cache should be used for that case.
	 */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; pcred-&gt;cr_ngroups; i++) {
		<span class="enscript-keyword">if</span> (gid == pcred-&gt;cr_groups[i]) {
			*resultp = 1;
			<span class="enscript-keyword">return</span>(0);
		}
	}

	<span class="enscript-comment">/*
	 * If we don't have a UID for group membership checks, the in-cred list
	 * was authoritative and we can stop here.
	 */</span>
	<span class="enscript-keyword">if</span> (pcred-&gt;cr_gmuid == KAUTH_UID_NONE) {
		*resultp = 0;
		<span class="enscript-keyword">return</span>(0);
	}
		
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_EXT_RESOLVER</span>
	<span class="enscript-type">struct</span> kauth_group_membership *gm;
	<span class="enscript-type">struct</span> kauth_identity_extlookup el;
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * If the resolver hasn't checked in yet, we are early in the boot
	 * phase and the local group list is complete and authoritative.
	 */</span>
	<span class="enscript-keyword">if</span> (!kauth_resolver_registered) {
		*resultp = 0;
		<span class="enscript-keyword">return</span>(0);
	}

	<span class="enscript-comment">/* TODO: */</span>
	<span class="enscript-comment">/* XXX check supplementary groups */</span>
	<span class="enscript-comment">/* XXX check whiteout groups */</span>
	<span class="enscript-comment">/* XXX nesting of supplementary/whiteout groups? */</span>

	<span class="enscript-comment">/*
	 * Check the group cache.
	 */</span>
	KAUTH_GROUPS_LOCK();
	TAILQ_FOREACH(gm, &amp;kauth_groups, gm_link) {
		<span class="enscript-keyword">if</span> ((gm-&gt;gm_uid == pcred-&gt;cr_gmuid) &amp;&amp; (gm-&gt;gm_gid == gid) &amp;&amp; !kauth_groups_expired(gm)) {
			kauth_groups_lru(gm);
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-comment">/* did we find a membership entry? */</span>
	<span class="enscript-keyword">if</span> (gm != NULL)
		*resultp = (gm-&gt;gm_flags &amp; KAUTH_GROUP_ISMEMBER) ? 1 : 0;
	KAUTH_GROUPS_UNLOCK();

	<span class="enscript-comment">/* if we did, we can return now */</span>
	<span class="enscript-keyword">if</span> (gm != NULL) {
		DTRACE_PROC2(kauth__group__cache__hit, <span class="enscript-type">int</span>, pcred-&gt;cr_gmuid, <span class="enscript-type">int</span>, gid);
		<span class="enscript-keyword">return</span>(0);
	}

	<span class="enscript-comment">/* nothing in the cache, need to go to userland */</span>
	bzero(&amp;el, <span class="enscript-keyword">sizeof</span>(el));
	el.el_info_pid = current_proc()-&gt;p_pid;
	el.el_flags = KAUTH_EXTLOOKUP_VALID_UID | KAUTH_EXTLOOKUP_VALID_GID | KAUTH_EXTLOOKUP_WANT_MEMBERSHIP;
	el.el_uid = pcred-&gt;cr_gmuid;
	el.el_gid = gid;
	el.el_member_valid = 0;		<span class="enscript-comment">/* XXX set by resolver? */</span>

	DTRACE_PROC2(kauth__group__resolver__submitted, <span class="enscript-type">int</span>, el.el_uid, <span class="enscript-type">int</span>, el.el_gid);
	
	error = kauth_resolver_submit(&amp;el, 0ULL);
	
	DTRACE_PROC2(kauth__group__resolver__returned, <span class="enscript-type">int</span>, error, <span class="enscript-type">int</span>, el.el_flags);
	
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span>(error);
	<span class="enscript-comment">/* save the results from the lookup */</span>
	kauth_groups_updatecache(&amp;el);

	<span class="enscript-comment">/* if we successfully ascertained membership, report */</span>
	<span class="enscript-keyword">if</span> (el.el_flags &amp; KAUTH_EXTLOOKUP_VALID_MEMBERSHIP) {
		*resultp = (el.el_flags &amp; KAUTH_EXTLOOKUP_ISMEMBER) ? 1 : 0;
		<span class="enscript-keyword">return</span>(0);
	}

	<span class="enscript-keyword">return</span>(ENOENT);
#<span class="enscript-reference">else</span>
	*resultp = 0;
	<span class="enscript-keyword">return</span>(0);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-comment">/*
 * kauth_cred_ismember_guid
 *
 * Description:	Determine whether the supplied credential is a member of the
 *		group nominated by GUID.
 *
 * Parameters:	cred				Credential to check in
 *		guidp				Pointer to GUID whose group
 *						we are testing for membership
 *		resultp				Pointer to int to contain the
 *						result of the call
 *
 * Returns:	0				Success
 *	kauth_cred_guid2gid:EINVAL
 *	kauth_cred_ismember_gid:ENOENT
 *	kauth_resolver_submit:ENOENT		User space daemon did not vend
 *						this credential.
 *	kauth_cred_ismember_gid:EWOULDBLOCK
 *	kauth_cred_ismember_gid:EINTR
 *	kauth_cred_ismember_gid:ENOMEM
 *	kauth_cred_ismember_gid:???		Unlikely error from user space
 *
 * Implicit returns:
 *		*resultp (modified)	1	Is member
 *					0	Is not member
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_ismember_guid</span>(__unused kauth_cred_t cred, guid_t *guidp, <span class="enscript-type">int</span> *resultp)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">switch</span> (kauth_wellknown_guid(guidp)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_WKG_NOBODY</span>:
		*resultp = 0;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KAUTH_WKG_EVERYBODY</span>:
		*resultp = 1;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_EXT_RESOLVER</span>
	{
		<span class="enscript-type">struct</span> kauth_identity ki;
		gid_t gid;
#<span class="enscript-reference">if</span> 6603280
		<span class="enscript-comment">/*
		 * Grovel the identity cache looking for this GUID.
		 * If we find it, and it is for a user record, return
		 * false because it's not a group.
		 *
		 * This is necessary because we don't have -ve caching
		 * of group memberships, and we really want to avoid
		 * calling out to the resolver if at all possible.
		 *
		 * Because we're called by the ACL evaluator, and the
		 * ACL evaluator is likely to encounter ACEs for users,
		 * this is expected to be a common case.
		 */</span>
		ki.ki_valid = 0;
		<span class="enscript-keyword">if</span> ((error = kauth_identity_find_guid(guidp, &amp;ki, NULL)) == 0 &amp;&amp;
		    !kauth_identity_guid_expired(&amp;ki)) {
			<span class="enscript-keyword">if</span> (ki.ki_valid &amp; KI_VALID_GID) {
				<span class="enscript-comment">/* It's a group after all... */</span>
				gid = ki.ki_gid;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">do_check</span>;
			}
			<span class="enscript-keyword">if</span> (ki.ki_valid &amp; KI_VALID_UID) {
				*resultp = 0;
				<span class="enscript-keyword">return</span> (0);
			}
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* 6603280 */</span>
		<span class="enscript-comment">/*
		 * Attempt to translate the GUID to a GID.  Even if
		 * this fails, we will have primed the cache if it is
		 * a user record and we'll see it above the next time
		 * we're asked.
		 */</span>
		<span class="enscript-keyword">if</span> ((error = kauth_cred_guid2gid(guidp, &amp;gid)) != 0) {
			<span class="enscript-comment">/*
			 * If we have no guid -&gt; gid translation, it's not a group and
			 * thus the cred can't be a member.
			 */</span>
			<span class="enscript-keyword">if</span> (error == ENOENT) {
				*resultp = 0;
				error = 0;
			}
		} <span class="enscript-keyword">else</span> {
 <span class="enscript-reference">do_check</span>:
			error = kauth_cred_ismember_gid(cred, gid, resultp);
		}
	}
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* CONFIG_EXT_RESOLVER */</span>
		error = ENOENT;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* CONFIG_EXT_RESOLVER */</span>
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * kauth_cred_gid_subset
 *
 * Description:	Given two credentials, determine if all GIDs associated with 
 * 		the first are also associated with the second
 *
 * Parameters:	cred1				Credential to check for
 * 		cred2				Credential to check in
 *		resultp				Pointer to int to contain the
 *						result of the call
 *
 * Returns:	0				Success
 *		non-zero			See kauth_cred_ismember_gid for
 *						error codes
 *
 * Implicit returns:
 *		*resultp (modified)	1	Is subset
 *					0	Is not subset
 *
 * Notes:	This function guarantees not to modify resultp when returning
 *		an error.
 */</span>
<span class="enscript-type">int</span>	
<span class="enscript-function-name">kauth_cred_gid_subset</span>(kauth_cred_t cred1, kauth_cred_t cred2, <span class="enscript-type">int</span> *resultp)
{
	<span class="enscript-type">int</span> i, err, res = 1;
	gid_t gid;
	posix_cred_t pcred1 = posix_cred_get(cred1);
	posix_cred_t pcred2 = posix_cred_get(cred2);

	<span class="enscript-comment">/* First, check the local list of groups */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; pcred1-&gt;cr_ngroups; i++) {
		gid = pcred1-&gt;cr_groups[i];
		<span class="enscript-keyword">if</span> ((err = kauth_cred_ismember_gid(cred2, gid, &amp;res)) != 0) {
			<span class="enscript-keyword">return</span> err;
		}

		<span class="enscript-keyword">if</span> (!res &amp;&amp; gid != pcred2-&gt;cr_rgid &amp;&amp; gid != pcred2-&gt;cr_svgid) {
			*resultp = 0;
			<span class="enscript-keyword">return</span> 0;
		}
	}

	<span class="enscript-comment">/* Check real gid */</span>
	<span class="enscript-keyword">if</span> ((err = kauth_cred_ismember_gid(cred2, pcred1-&gt;cr_rgid, &amp;res)) != 0) {
		<span class="enscript-keyword">return</span> err;
	}

	<span class="enscript-keyword">if</span> (!res &amp;&amp; pcred1-&gt;cr_rgid != pcred2-&gt;cr_rgid &amp;&amp;
			pcred1-&gt;cr_rgid != pcred2-&gt;cr_svgid) {
		*resultp = 0;
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/* Finally, check saved gid */</span>
	<span class="enscript-keyword">if</span> ((err = kauth_cred_ismember_gid(cred2, pcred1-&gt;cr_svgid, &amp;res)) != 0){
		<span class="enscript-keyword">return</span> err;
	}

	<span class="enscript-keyword">if</span> (!res &amp;&amp; pcred1-&gt;cr_svgid != pcred2-&gt;cr_rgid &amp;&amp;
			pcred1-&gt;cr_svgid != pcred2-&gt;cr_svgid) {
		*resultp = 0;
		<span class="enscript-keyword">return</span> 0;
	}

	*resultp = 1;
	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/*
 * kauth_cred_issuser
 *
 * Description:	Fast replacement for issuser()
 *
 * Parameters:	cred				Credential to check for super
 *						user privileges
 *
 * Returns:	0				Not super user
 *		!0				Is super user
 *
 * Notes:	This function uses a magic number which is not a manifest
 *		constant; this is bad practice.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_issuser</span>(kauth_cred_t cred)
{
	<span class="enscript-keyword">return</span>(kauth_cred_getuid(cred) == 0);
}


<span class="enscript-comment">/*
 * Credential KPI
 */</span>

<span class="enscript-comment">/* lock protecting credential hash table */</span>
<span class="enscript-type">static</span> lck_mtx_t *kauth_cred_hash_mtx;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KAUTH_CRED_HASH_LOCK</span>()		lck_mtx_lock(kauth_cred_hash_mtx);
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KAUTH_CRED_HASH_UNLOCK</span>()	lck_mtx_unlock(kauth_cred_hash_mtx);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KAUTH_CRED_HASH_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KAUTH_CRED_HASH_LOCK_ASSERT</span>()	lck_mtx_assert(kauth_cred_hash_mtx, LCK_MTX_ASSERT_OWNED)
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* !KAUTH_CRED_HASH_DEBUG */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">KAUTH_CRED_HASH_LOCK_ASSERT</span>()
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !KAUTH_CRED_HASH_DEBUG */</span>


<span class="enscript-comment">/*
 * kauth_cred_init
 *
 * Description:	Initialize the credential hash cache
 *
 * Parameters:	(void)
 *
 * Returns:	(void)
 *
 * Notes:	Intialize the credential hash cache for use; the credential
 *		hash cache is used convert duplicate credentials into a
 *		single reference counted credential in order to save wired
 *		kernel memory.  In practice, this generally means a desktop
 *		system runs with a few tens of credentials, instead of one
 *		per process, one per thread, one per vnode cache entry, and
 *		so on.  This generally results in savings of 200K or more
 *		(potentially much more on server systems).
 *
 *		The hash cache internally has a reference on the credential
 *		for itself as a means of avoiding a reclaim race for a
 *		credential in the process of having it's last non-hash
 *		reference released.  This would otherwise result in the
 *		possibility of a freed credential that was still in uses due
 *		a race.  This use is protected by the KAUTH_CRED_HASH_LOCK.
 *
 *		On final release, the hash reference is droped, and the
 *		credential is freed back to the system.
 *
 *		This function is called from kauth_init() in the file
 *		kern_authorization.c.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_cred_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span>		i;
	
	kauth_cred_hash_mtx = lck_mtx_alloc_init(kauth_lck_grp, 0<span class="enscript-comment">/*LCK_ATTR_NULL*/</span>);

	<span class="enscript-comment">/*allocate credential hash table */</span>
	MALLOC(kauth_cred_table_anchor, <span class="enscript-type">struct</span> kauth_cred_entry_head *, 
			(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> kauth_cred_entry_head) * KAUTH_CRED_TABLE_SIZE),
			M_KAUTH, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (kauth_cred_table_anchor == NULL)
		panic(<span class="enscript-string">&quot;startup: kauth_cred_init&quot;</span>);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; KAUTH_CRED_TABLE_SIZE; i++) {
		TAILQ_INIT(&amp;kauth_cred_table_anchor[i]);
	}
}


<span class="enscript-comment">/*
 * kauth_getuid
 *
 * Description:	Get the current thread's effective UID.
 *
 * Parameters:	(void)
 *
 * Returns:	(uid_t)				The effective UID of the
 *						current thread
 */</span>
uid_t
<span class="enscript-function-name">kauth_getuid</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span>(kauth_cred_getuid(kauth_cred_get()));
}


<span class="enscript-comment">/*
 * kauth_getruid
 *
 * Description:	Get the current thread's real UID.
 *
 * Parameters:	(void)
 *
 * Returns:	(uid_t)				The real UID of the current
 *						thread
 */</span>
uid_t
<span class="enscript-function-name">kauth_getruid</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span>(kauth_cred_getruid(kauth_cred_get()));
}


<span class="enscript-comment">/*
 * kauth_getgid
 *
 * Description:	Get the current thread's effective GID.
 *
 * Parameters:	(void)
 *
 * Returns:	(gid_t)				The effective GID of the
 *						current thread
 */</span>
gid_t
<span class="enscript-function-name">kauth_getgid</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span>(kauth_cred_getgid(kauth_cred_get()));
}


<span class="enscript-comment">/*
 * kauth_getgid
 *
 * Description:	Get the current thread's real GID.
 *
 * Parameters:	(void)
 *
 * Returns:	(gid_t)				The real GID of the current
 *						thread
 */</span>
gid_t
<span class="enscript-function-name">kauth_getrgid</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span>(kauth_cred_getrgid(kauth_cred_get()));
}


<span class="enscript-comment">/*
 * kauth_cred_get
 *
 * Description:	Returns a pointer to the current thread's credential
 *
 * Parameters:	(void)
 *
 * Returns:	(kauth_cred_t)			Pointer to the current thread's
 *						credential
 *
 * Notes:	This function does not take a reference; because of this, the
 *		caller MUST NOT do anything that would let the thread's
 *		credential change while using the returned value, without
 *		first explicitly taking their own reference.
 *
 *		If a caller intends to take a reference on the resulting
 *		credential pointer from calling this function, it is strongly
 *		recommended that the caller use kauth_cred_get_with_ref()
 *		instead, to protect against any future changes to the cred
 *		locking protocols; such changes could otherwise potentially
 *		introduce race windows in the callers code.
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_get</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> proc *p;
	<span class="enscript-type">struct</span> uthread *uthread;

	uthread = get_bsdthread_info(current_thread());
	<span class="enscript-comment">/* sanity */</span>
	<span class="enscript-keyword">if</span> (uthread == NULL)
		panic(<span class="enscript-string">&quot;thread wants credential but has no BSD thread info&quot;</span>);
	<span class="enscript-comment">/*
	 * We can lazy-bind credentials to threads, as long as their processes
	 * have them.
	 *
	 * XXX If we later inline this function, the code in this block
	 * XXX should probably be called out in a function.
	 */</span>
	<span class="enscript-keyword">if</span> (uthread-&gt;uu_ucred == NOCRED) {
		<span class="enscript-keyword">if</span> ((p = (proc_t) get_bsdtask_info(get_threadtask(current_thread()))) == NULL)
			panic(<span class="enscript-string">&quot;thread wants credential but has no BSD process&quot;</span>);
		uthread-&gt;uu_ucred = kauth_cred_proc_ref(p);
	}
	<span class="enscript-keyword">return</span>(uthread-&gt;uu_ucred);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mach_kauth_cred_uthread_update</span>(<span class="enscript-type">void</span>)
{
	uthread_t uthread;
	proc_t proc;

	uthread = get_bsdthread_info(current_thread());
	proc = current_proc();

	kauth_cred_uthread_update(uthread, proc);
}

<span class="enscript-comment">/*
 * kauth_cred_uthread_update
 *
 * Description:	Given a uthread, a proc, and whether or not the proc is locked,
 *		late-bind the uthread cred to the proc cred.
 *
 * Parameters:	uthread_t			The uthread to update
 *		proc_t				The process to update to
 *
 * Returns:	(void)
 *
 * Notes:	This code is common code called from system call or trap entry
 *		in the case that the process thread may have been changed
 *		since the last time the thread entered the kernel.  It is
 *		generally only called with the current uthread and process as
 *		parameters.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_cred_uthread_update</span>(uthread_t uthread, proc_t proc)
{
	<span class="enscript-keyword">if</span> (uthread-&gt;uu_ucred != proc-&gt;p_ucred &amp;&amp;
	    (uthread-&gt;uu_flag &amp; UT_SETUID) == 0) {
		kauth_cred_t old = uthread-&gt;uu_ucred;
		uthread-&gt;uu_ucred = kauth_cred_proc_ref(proc);
		<span class="enscript-keyword">if</span> (IS_VALID_CRED(old))
			kauth_cred_unref(&amp;old);
	}
}


<span class="enscript-comment">/*
 * kauth_cred_get_with_ref
 *
 * Description:	Takes a reference on the current thread's credential, and then
 *		returns a pointer to it to the caller.
 *
 * Parameters:	(void)
 *
 * Returns:	(kauth_cred_t)			Pointer to the current thread's
 *						newly referenced credential
 *
 * Notes:	This function takes a reference on the credential before
 *		returning it to the caller.
 *
 *		It is the responsibility of the calling code to release this
 *		reference when the credential is no longer in use.
 *
 *		Since the returned reference may be a persistent reference
 *		(e.g. one cached in another data structure with a lifetime
 *		longer than the calling function), this release may be delayed
 *		until such time as the persistent reference is to be destroyed.
 *		An example of this would be the per vnode credential cache used
 *		to accelerate lookup operations.
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_get_with_ref</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> proc *procp;
	<span class="enscript-type">struct</span> uthread *uthread;

	uthread = get_bsdthread_info(current_thread());
	<span class="enscript-comment">/* sanity checks */</span>
	<span class="enscript-keyword">if</span> (uthread == NULL)
		panic(<span class="enscript-string">&quot;%s - thread wants credential but has no BSD thread info&quot;</span>, __FUNCTION__);
	<span class="enscript-keyword">if</span> ((procp = (proc_t) get_bsdtask_info(get_threadtask(current_thread()))) == NULL)
		panic(<span class="enscript-string">&quot;%s - thread wants credential but has no BSD process&quot;</span>, __FUNCTION__);

	<span class="enscript-comment">/*
	 * We can lazy-bind credentials to threads, as long as their processes
	 * have them.
	 *
	 * XXX If we later inline this function, the code in this block
	 * XXX should probably be called out in a function.
	 */</span>
	<span class="enscript-keyword">if</span> (uthread-&gt;uu_ucred == NOCRED) {
		<span class="enscript-comment">/* take reference for new cred in thread */</span>
		uthread-&gt;uu_ucred = kauth_cred_proc_ref(procp);
	}
	<span class="enscript-comment">/* take a reference for our caller */</span>
	kauth_cred_ref(uthread-&gt;uu_ucred);
	<span class="enscript-keyword">return</span>(uthread-&gt;uu_ucred);
}


<span class="enscript-comment">/*
 * kauth_cred_proc_ref
 *
 * Description:	Takes a reference on the current process's credential, and
 *		then returns a pointer to it to the caller.
 *
 * Parameters:	procp				Process whose credential we
 *						intend to take a reference on
 *
 * Returns:	(kauth_cred_t)			Pointer to the process's
 *						newly referenced credential
 *
 * Locks:	PROC_LOCK is held before taking the reference and released
 *		after the refeence is taken to protect the p_ucred field of
 *		the process referred to by procp.
 *
 * Notes:	This function takes a reference on the credential before
 *		returning it to the caller.
 *
 *		It is the responsibility of the calling code to release this
 *		reference when the credential is no longer in use.
 *
 *		Since the returned reference may be a persistent reference
 *		(e.g. one cached in another data structure with a lifetime
 *		longer than the calling function), this release may be delayed
 *		until such time as the persistent reference is to be destroyed.
 *		An example of this would be the per vnode credential cache used
 *		to accelerate lookup operations.
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_proc_ref</span>(proc_t procp)
{
	kauth_cred_t 	cred;
	
	proc_lock(procp);
	cred = proc_ucred(procp);
	kauth_cred_ref(cred);
	proc_unlock(procp);
	<span class="enscript-keyword">return</span>(cred);
}


<span class="enscript-comment">/*
 * kauth_cred_alloc
 *
 * Description:	Allocate a new credential
 *
 * Parameters:	(void)
 *
 * Returns:	!NULL				Newly allocated credential
 *		NULL				Insufficient memory
 *
 * Notes:	The newly allocated credential is zero'ed as part of the
 *		allocation process, with the exception of the reference
 *		count, which is set to 1 to indicate a single reference
 *		held by the caller.
 *
 *		Since newly allocated credentials have no external pointers
 *		referencing them, prior to making them visible in an externally
 *		visible pointer (e.g. by adding them to the credential hash
 *		cache) is the only legal time in which an existing credential
 *		can be safely iinitialized or modified directly.
 *
 *		After initialization, the caller is expected to call the
 *		function kauth_cred_add() to add the credential to the hash
 *		cache, after which time it's frozen and becomes publically
 *		visible.
 *
 *		The release protocol depends on kauth_hash_add() being called
 *		before kauth_cred_rele() (there is a diagnostic panic which
 *		will trigger if this protocol is not observed).
 *
 * XXX:		This function really ought to be static, rather than being
 *		exported as KPI, since a failure of kauth_cred_add() can only
 *		be handled by an explicit free of the credential; such frees
 *		depend on knowlegdge of the allocation method used, which is
 *		permitted to change between kernel revisions.
 *
 * XXX:		In the insufficient resource case, this code panic's rather
 *		than returning a NULL pointer; the code that calls this
 *		function needs to be audited before this can be changed.
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_alloc</span>(<span class="enscript-type">void</span>)
{
	kauth_cred_t newcred;
	
	MALLOC_ZONE(newcred, kauth_cred_t, <span class="enscript-keyword">sizeof</span>(*newcred), M_CRED, M_WAITOK);
	<span class="enscript-keyword">if</span> (newcred != 0) {
		posix_cred_t newpcred = posix_cred_get(newcred);
		bzero(newcred, <span class="enscript-keyword">sizeof</span>(*newcred));
		newcred-&gt;cr_ref = 1;
		newcred-&gt;cr_audit.as_aia_p = audit_default_aia_p;
		<span class="enscript-comment">/* must do this, or cred has same group membership as uid 0 */</span>
		newpcred-&gt;cr_gmuid = KAUTH_UID_NONE;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CRED_DIAGNOSTIC</span>
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;kauth_cred_alloc: couldn't allocate credential&quot;</span>);
#<span class="enscript-reference">endif</span>		
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KAUTH_CRED_HASH_DEBUG</span>
	kauth_cred_count++;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_cred_label_init(newcred);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span>(newcred);
}


<span class="enscript-comment">/*
 * kauth_cred_create
 *
 * Description:	Look to see if we already have a known credential in the hash
 *		cache; if one is found, bump the reference count and return
 *		it.  If there are no credentials that match the given
 *		credential, then allocate a new credential.
 *
 * Parameters:	cred				Template for credential to
 *						be created
 *
 * Returns:	(kauth_cred_t)			The credential that was found
 *						in the hash or created
 *		NULL				kauth_cred_add() failed, or
 *						there was not an egid specified
 *
 * Notes:	The gmuid is hard-defaulted to the UID specified.  Since we
 *		maintain this field, we can't expect callers to know how it
 *		needs to be set.  Callers should be prepared for this field
 *		to be overwritten.
 *
 * XXX:		This code will tight-loop if memory for a new credential is
 *		persistently unavailable; this is perhaps not the wisest way
 *		to handle this condition, but current callers do not expect
 *		a failure.
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_create</span>(kauth_cred_t cred)
{
	kauth_cred_t 	found_cred, new_cred = NULL;
	posix_cred_t	pcred = posix_cred_get(cred);
	<span class="enscript-type">int</span> is_member = 0;

	KAUTH_CRED_HASH_LOCK_ASSERT();

	<span class="enscript-keyword">if</span> (pcred-&gt;cr_flags &amp; CRF_NOMEMBERD) {
		pcred-&gt;cr_gmuid = KAUTH_UID_NONE;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * If the template credential is not opting out of external
		 * group membership resolution, then we need to check that
		 * the UID we will be using is resolvable by the external
		 * resolver.  If it's not, then we opt it out anyway, since
		 * all future external resolution requests will be failing
		 * anyway, and potentially taking a long time to do it.  We
		 * use gid 0 because we always know it will exist and not
		 * trigger additional lookups. This is OK, because we end up
		 * precatching the information here as a result.
		 */</span>
		<span class="enscript-keyword">if</span> (!kauth_cred_ismember_gid(cred, 0, &amp;is_member)) {
			<span class="enscript-comment">/*
			 * It's a recognized value; we don't really care about
			 * the answer, so long as it's something the external
			 * resolver could have vended.
			 */</span>
			pcred-&gt;cr_gmuid = pcred-&gt;cr_uid;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * It's not something the external resolver could
			 * have vended, so we don't want to ask it more
			 * questions about the credential in the future. This
			 * speeds up future lookups, as long as the caller
			 * caches results; otherwise, it the same recurring
			 * cost.  Since most credentials are used multiple
			 * times, we still get some performance win from this.
			 */</span>
			pcred-&gt;cr_gmuid = KAUTH_UID_NONE;
			pcred-&gt;cr_flags |= CRF_NOMEMBERD;
		}
	}

	<span class="enscript-comment">/* Caller *must* specify at least the egid in cr_groups[0] */</span>
	<span class="enscript-keyword">if</span> (pcred-&gt;cr_ngroups &lt; 1)
		<span class="enscript-keyword">return</span>(NULL);
	
	<span class="enscript-keyword">for</span> (;;) {
		KAUTH_CRED_HASH_LOCK();
		found_cred = kauth_cred_find(cred);
		<span class="enscript-keyword">if</span> (found_cred != NULL) {
			<span class="enscript-comment">/*
			 * Found an existing credential so we'll bump
			 * reference count and return
			 */</span>
			kauth_cred_ref(found_cred);
			KAUTH_CRED_HASH_UNLOCK();
			<span class="enscript-keyword">return</span>(found_cred);
		}
		KAUTH_CRED_HASH_UNLOCK();
	
		<span class="enscript-comment">/*
		 * No existing credential found.  Create one and add it to
		 * our hash table.
		 */</span>
		new_cred = kauth_cred_alloc();
		<span class="enscript-keyword">if</span> (new_cred != NULL) {
			<span class="enscript-type">int</span>		err;
			posix_cred_t	new_pcred = posix_cred_get(new_cred);
			new_pcred-&gt;cr_uid = pcred-&gt;cr_uid;
			new_pcred-&gt;cr_ruid = pcred-&gt;cr_ruid;
			new_pcred-&gt;cr_svuid = pcred-&gt;cr_svuid;
			new_pcred-&gt;cr_rgid = pcred-&gt;cr_rgid;
			new_pcred-&gt;cr_svgid = pcred-&gt;cr_svgid;
			new_pcred-&gt;cr_gmuid = pcred-&gt;cr_gmuid;
			new_pcred-&gt;cr_ngroups = pcred-&gt;cr_ngroups;	
			bcopy(&amp;pcred-&gt;cr_groups[0], &amp;new_pcred-&gt;cr_groups[0], <span class="enscript-keyword">sizeof</span>(new_pcred-&gt;cr_groups));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_AUDIT</span>
			bcopy(&amp;cred-&gt;cr_audit, &amp;new_cred-&gt;cr_audit, 
			    <span class="enscript-keyword">sizeof</span>(new_cred-&gt;cr_audit));
#<span class="enscript-reference">endif</span>
			new_pcred-&gt;cr_flags = pcred-&gt;cr_flags;
			
			KAUTH_CRED_HASH_LOCK();
			err = kauth_cred_add(new_cred);
			KAUTH_CRED_HASH_UNLOCK();
			
			<span class="enscript-comment">/* Retry if kauth_cred_add returns non zero value */</span>
			<span class="enscript-keyword">if</span> (err == 0)
				<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
			mac_cred_label_destroy(new_cred);
#<span class="enscript-reference">endif</span>
			AUDIT_SESSION_UNREF(new_cred);

			FREE_ZONE(new_cred, <span class="enscript-keyword">sizeof</span>(*new_cred), M_CRED);
			new_cred = NULL;
		}
	}

	<span class="enscript-keyword">return</span>(new_cred);
}


<span class="enscript-comment">/*
 * kauth_cred_setresuid
 *
 * Description:	Update the given credential using the UID arguments.  The given
 *		UIDs are used to set the effective UID, real UID, saved UID,
 *		and GMUID (used for group membership checking).
 *
 * Parameters:	cred				The original credential
 *		ruid				The new real UID
 *		euid				The new effective UID
 *		svuid				The new saved UID
 *		gmuid				KAUTH_UID_NONE -or- the new
 *						group membership UID
 *
 * Returns:	(kauth_cred_t)			The updated credential
 *
 * Note:	gmuid is different in that a KAUTH_UID_NONE is a valid
 *		setting, so if you don't want it to change, pass it the
 *		previous value, explicitly.
 *
 * IMPORTANT:	This function is implemented via kauth_cred_update(), which,
 *		if it returns a credential other than the one it is passed,
 *		will have dropped the reference on the passed credential.  All
 *		callers should be aware of this, and treat this function as an
 *		unref + ref, potentially on different credentials.
 *
 *		Because of this, the caller is expected to take its own
 *		reference on the credential passed as the first parameter,
 *		and be prepared to release the reference on the credential
 *		that is returned to them, if it is not intended to be a
 *		persistent reference.
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_setresuid</span>(kauth_cred_t cred, uid_t ruid, uid_t euid, uid_t svuid, uid_t gmuid)
{
	<span class="enscript-type">struct</span> ucred temp_cred;
	posix_cred_t temp_pcred = posix_cred_get(&amp;temp_cred);
	posix_cred_t pcred = posix_cred_get(cred);

	NULLCRED_CHECK(cred);

	<span class="enscript-comment">/*
	 * We don't need to do anything if the UIDs we are changing are
	 * already the same as the UIDs passed in
	 */</span>
	<span class="enscript-keyword">if</span> ((euid == KAUTH_UID_NONE || pcred-&gt;cr_uid == euid) &amp;&amp;
	    (ruid == KAUTH_UID_NONE || pcred-&gt;cr_ruid == ruid) &amp;&amp;
	    (svuid == KAUTH_UID_NONE || pcred-&gt;cr_svuid == svuid) &amp;&amp;
	    (pcred-&gt;cr_gmuid == gmuid)) {
		<span class="enscript-comment">/* no change needed */</span>
		<span class="enscript-keyword">return</span>(cred);
	}

	<span class="enscript-comment">/*
	 * Look up in cred hash table to see if we have a matching credential
	 * with the new values; this is done by calling kauth_cred_update().
	 */</span>
	bcopy(cred, &amp;temp_cred, <span class="enscript-keyword">sizeof</span>(temp_cred));
	<span class="enscript-keyword">if</span> (euid != KAUTH_UID_NONE) {
		temp_pcred-&gt;cr_uid = euid;
	}
	<span class="enscript-keyword">if</span> (ruid != KAUTH_UID_NONE) {
		temp_pcred-&gt;cr_ruid = ruid;
	}
	<span class="enscript-keyword">if</span> (svuid != KAUTH_UID_NONE) {
		temp_pcred-&gt;cr_svuid = svuid;
	}

	<span class="enscript-comment">/*
	 * If we are setting the gmuid to KAUTH_UID_NONE, then we want to
	 * opt out of participation in external group resolution, unless we
	 * unless we explicitly opt back in later.
	 */</span>
	<span class="enscript-keyword">if</span> ((temp_pcred-&gt;cr_gmuid = gmuid) == KAUTH_UID_NONE) {
		temp_pcred-&gt;cr_flags |= CRF_NOMEMBERD;
	}

	<span class="enscript-keyword">return</span>(kauth_cred_update(cred, &amp;temp_cred, TRUE));
}


<span class="enscript-comment">/*
 * kauth_cred_setresgid
 *
 * Description:	Update the given credential using the GID arguments.  The given
 *		GIDs are used to set the effective GID, real GID, and saved
 *		GID.
 *
 * Parameters:	cred				The original credential
 *		rgid				The new real GID
 *		egid				The new effective GID
 *		svgid				The new saved GID
 *
 * Returns:	(kauth_cred_t)			The updated credential
 *
 * IMPORTANT:	This function is implemented via kauth_cred_update(), which,
 *		if it returns a credential other than the one it is passed,
 *		will have dropped the reference on the passed credential.  All
 *		callers should be aware of this, and treat this function as an
 *		unref + ref, potentially on different credentials.
 *
 *		Because of this, the caller is expected to take its own
 *		reference on the credential passed as the first parameter,
 *		and be prepared to release the reference on the credential
 *		that is returned to them, if it is not intended to be a
 *		persistent reference.
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_setresgid</span>(kauth_cred_t cred, gid_t rgid, gid_t egid, gid_t svgid)
{
	<span class="enscript-type">struct</span> ucred 	temp_cred;
	posix_cred_t temp_pcred = posix_cred_get(&amp;temp_cred);
	posix_cred_t pcred = posix_cred_get(cred);

	NULLCRED_CHECK(cred);
	DEBUG_CRED_ENTER(<span class="enscript-string">&quot;kauth_cred_setresgid %p %d %d %d\n&quot;</span>, cred, rgid, egid, svgid);

	<span class="enscript-comment">/*
	 * We don't need to do anything if the given GID are already the 
	 * same as the GIDs in the credential.
	 */</span>
	<span class="enscript-keyword">if</span> (pcred-&gt;cr_groups[0] == egid &amp;&amp;
	    pcred-&gt;cr_rgid == rgid &amp;&amp;
	    pcred-&gt;cr_svgid == svgid) {
		<span class="enscript-comment">/* no change needed */</span>
		<span class="enscript-keyword">return</span>(cred);
	}

	<span class="enscript-comment">/*
	 * Look up in cred hash table to see if we have a matching credential
	 * with the new values; this is done by calling kauth_cred_update().
	 */</span>
	bcopy(cred, &amp;temp_cred, <span class="enscript-keyword">sizeof</span>(temp_cred));
	<span class="enscript-keyword">if</span> (egid != KAUTH_GID_NONE) {
		<span class="enscript-comment">/* displacing a supplementary group opts us out of memberd */</span>
		<span class="enscript-keyword">if</span> (kauth_cred_change_egid(&amp;temp_cred, egid)) {
			DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;displaced!\n&quot;</span>);
			temp_pcred-&gt;cr_flags |= CRF_NOMEMBERD;
			temp_pcred-&gt;cr_gmuid = KAUTH_UID_NONE;
		} <span class="enscript-keyword">else</span> {
			DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;not displaced\n&quot;</span>);
		}
	}
	<span class="enscript-keyword">if</span> (rgid != KAUTH_GID_NONE) {
		temp_pcred-&gt;cr_rgid = rgid;
	}
	<span class="enscript-keyword">if</span> (svgid != KAUTH_GID_NONE) {
		temp_pcred-&gt;cr_svgid = svgid;
	}

	<span class="enscript-keyword">return</span>(kauth_cred_update(cred, &amp;temp_cred, TRUE));
}


<span class="enscript-comment">/*
 * Update the given credential with the given groups.  We only allocate a new 
 *	credential when the given gid actually results in changes to the existing 
 *	credential.
 *	The gmuid argument supplies a new uid (or KAUTH_UID_NONE to opt out)
 *	which will be used for group membership checking.
 */</span>
<span class="enscript-comment">/*
 * kauth_cred_setgroups
 *
 * Description:	Update the given credential using the provide supplementary
 *		group list and group membership UID
 *
 * Parameters:	cred				The original credential
 *		groups				Pointer to gid_t array which
 *						contains the new group list
 *		groupcount			The count of valid groups which
 *						are contained in 'groups'
 *		gmuid				KAUTH_UID_NONE -or- the new
 *						group membership UID
 *
 * Returns:	(kauth_cred_t)			The updated credential
 *
 * Note:	gmuid is different in that a KAUTH_UID_NONE is a valid
 *		setting, so if you don't want it to change, pass it the
 *		previous value, explicitly.
 *
 * IMPORTANT:	This function is implemented via kauth_cred_update(), which,
 *		if it returns a credential other than the one it is passed,
 *		will have dropped the reference on the passed credential.  All
 *		callers should be aware of this, and treat this function as an
 *		unref + ref, potentially on different credentials.
 *
 *		Because of this, the caller is expected to take its own
 *		reference on the credential passed as the first parameter,
 *		and be prepared to release the reference on the credential
 *		that is returned to them, if it is not intended to be a
 *		persistent reference.
 *
 * XXX:		Changes are determined in ordinal order - if the caller passes
 *		in the same groups list that is already present in the
 *		credential, but the members are in a different order, even if
 *		the EGID is not modified (i.e. cr_groups[0] is the same), it
 *		is considered a modification to the credential, and a new
 *		credential is created.
 *
 *		This should perhaps be better optimized, but it is considered
 *		to be the caller's problem.
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_setgroups</span>(kauth_cred_t cred, gid_t *groups, <span class="enscript-type">int</span> groupcount, uid_t gmuid)
{
	<span class="enscript-type">int</span>		i;
	<span class="enscript-type">struct</span> ucred temp_cred;
	posix_cred_t temp_pcred = posix_cred_get(&amp;temp_cred);
	posix_cred_t pcred;

	NULLCRED_CHECK(cred);

	pcred = posix_cred_get(cred);

	<span class="enscript-comment">/*
	 * We don't need to do anything if the given list of groups does not
	 * change.
	 */</span>
	<span class="enscript-keyword">if</span> ((pcred-&gt;cr_gmuid == gmuid) &amp;&amp; (pcred-&gt;cr_ngroups == groupcount)) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; groupcount; i++) {
			<span class="enscript-keyword">if</span> (pcred-&gt;cr_groups[i] != groups[i])
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (i == groupcount) {
			<span class="enscript-comment">/* no change needed */</span>
			<span class="enscript-keyword">return</span>(cred);
		}
	}

	<span class="enscript-comment">/*
	 * Look up in cred hash table to see if we have a matching credential
	 * with new values.  If we are setting or clearing the gmuid, then
	 * update the cr_flags, since clearing it is sticky.  This permits an
	 * opt-out of memberd processing using setgroups(), and an opt-in
	 * using initgroups().  This is required for POSIX conformance.
	 */</span>
	bcopy(cred, &amp;temp_cred, <span class="enscript-keyword">sizeof</span>(temp_cred));
	temp_pcred-&gt;cr_ngroups = groupcount;
	bcopy(groups, temp_pcred-&gt;cr_groups, <span class="enscript-keyword">sizeof</span>(temp_pcred-&gt;cr_groups));
	temp_pcred-&gt;cr_gmuid = gmuid;
	<span class="enscript-keyword">if</span> (gmuid == KAUTH_UID_NONE)
		temp_pcred-&gt;cr_flags |= CRF_NOMEMBERD;
	<span class="enscript-keyword">else</span>
		temp_pcred-&gt;cr_flags &amp;= ~CRF_NOMEMBERD;

	<span class="enscript-keyword">return</span>(kauth_cred_update(cred, &amp;temp_cred, TRUE));
}

<span class="enscript-comment">/*
 * Notes:	The return value exists to account for the possibility of a
 *		kauth_cred_t without a POSIX label.  This will be the case in
 *		the future (see posix_cred_get() below, for more details).
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_EXT_RESOLVER</span>
<span class="enscript-type">int</span> kauth_external_supplementary_groups_supported = 1;

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, ds_supgroups_supported, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;kauth_external_supplementary_groups_supported, 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_getgroups</span>(kauth_cred_t cred, gid_t *grouplist, <span class="enscript-type">int</span> *countp)
{
	<span class="enscript-type">int</span> limit = NGROUPS;
	posix_cred_t pcred;
	
	pcred = posix_cred_get(cred);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_EXT_RESOLVER</span>  
	<span class="enscript-comment">/*
	 * If we've not opted out of using the resolver, then convert the cred to a list
	 * of supplemental groups. We do this only if there has been a resolver to talk to,
	 * since we may be too early in boot, or in an environment that isn't using DS.
	 */</span>
	<span class="enscript-keyword">if</span> (kauth_identitysvc_has_registered &amp;&amp; kauth_external_supplementary_groups_supported &amp;&amp; (pcred-&gt;cr_flags &amp; CRF_NOMEMBERD) == 0) {		
		uid_t uid = kauth_cred_getuid(cred);
		<span class="enscript-type">int</span> err;
		
		err = kauth_cred_uid2groups(&amp;uid, grouplist, countp);
		<span class="enscript-keyword">if</span> (!err)
			<span class="enscript-keyword">return</span> 0;

		<span class="enscript-comment">/* On error just fall through */</span>
		KAUTH_DEBUG(<span class="enscript-string">&quot;kauth_cred_getgroups failed %d\n&quot;</span>, err);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_EXT_RESOLVER */</span>

	<span class="enscript-comment">/*
	 * If they just want a copy of the groups list, they may not care
	 * about the actual count.  If they specify an input count, however,
	 * treat it as an indicator of the buffer size available in grouplist,
	 * and limit the returned list to that size.
	 */</span>
	<span class="enscript-keyword">if</span> (countp) {
		limit = MIN(*countp, pcred-&gt;cr_ngroups);
		*countp = limit;
	}

	memcpy(grouplist, pcred-&gt;cr_groups, <span class="enscript-keyword">sizeof</span>(gid_t) * limit);

	<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/*
 * kauth_cred_setuidgid
 *
 * Description:	Update the given credential using the UID and GID arguments.
 *		The given UID is used to set the effective UID, real UID, and
 *		saved UID.  The given GID is used to set the effective GID,
 *		real GID, and saved GID.
 *
 * Parameters:	cred				The original credential
 *		uid				The new UID to use
 *		gid				The new GID to use
 *
 * Returns:	(kauth_cred_t)			The updated credential
 *
 * Notes:	We set the gmuid to uid if the credential we are inheriting
 *		from has not opted out of memberd participation; otherwise
 *		we set it to KAUTH_UID_NONE
 *
 *		This code is only ever called from the per-thread credential
 *		code path in the &quot;set per thread credential&quot; case; and in
 *		posix_spawn() in the case that the POSIX_SPAWN_RESETIDS
 *		flag is set.
 *
 * IMPORTANT:	This function is implemented via kauth_cred_update(), which,
 *		if it returns a credential other than the one it is passed,
 *		will have dropped the reference on the passed credential.  All
 *		callers should be aware of this, and treat this function as an
 *		unref + ref, potentially on different credentials.
 *
 *		Because of this, the caller is expected to take its own
 *		reference on the credential passed as the first parameter,
 *		and be prepared to release the reference on the credential
 *		that is returned to them, if it is not intended to be a
 *		persistent reference.
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_setuidgid</span>(kauth_cred_t cred, uid_t uid, gid_t gid)
{
	<span class="enscript-type">struct</span> ucred temp_cred;
	posix_cred_t temp_pcred = posix_cred_get(&amp;temp_cred);
	posix_cred_t pcred;

	NULLCRED_CHECK(cred);

	pcred = posix_cred_get(cred);

	<span class="enscript-comment">/*
	 * We don't need to do anything if the effective, real and saved
	 * user IDs are already the same as the user ID passed into us.
	 */</span>
	<span class="enscript-keyword">if</span> (pcred-&gt;cr_uid == uid &amp;&amp; pcred-&gt;cr_ruid == uid &amp;&amp; pcred-&gt;cr_svuid == uid &amp;&amp;
		pcred-&gt;cr_gid == gid &amp;&amp; pcred-&gt;cr_rgid == gid &amp;&amp; pcred-&gt;cr_svgid == gid) {
		<span class="enscript-comment">/* no change needed */</span>
		<span class="enscript-keyword">return</span>(cred);
	}

	<span class="enscript-comment">/*
	 * Look up in cred hash table to see if we have a matching credential
	 * with the new values.
	 */</span>
	bzero(&amp;temp_cred, <span class="enscript-keyword">sizeof</span>(temp_cred));
	temp_pcred-&gt;cr_uid = uid;
	temp_pcred-&gt;cr_ruid = uid;
	temp_pcred-&gt;cr_svuid = uid;
	temp_pcred-&gt;cr_flags = pcred-&gt;cr_flags;
	<span class="enscript-comment">/* inherit the opt-out of memberd */</span>
	<span class="enscript-keyword">if</span> (pcred-&gt;cr_flags &amp; CRF_NOMEMBERD) {
		temp_pcred-&gt;cr_gmuid = KAUTH_UID_NONE;
		temp_pcred-&gt;cr_flags |= CRF_NOMEMBERD;
	} <span class="enscript-keyword">else</span> {
		temp_pcred-&gt;cr_gmuid = uid;
		temp_pcred-&gt;cr_flags &amp;= ~CRF_NOMEMBERD;
	}
	temp_pcred-&gt;cr_ngroups = 1;
	<span class="enscript-comment">/* displacing a supplementary group opts us out of memberd */</span>
	<span class="enscript-keyword">if</span> (kauth_cred_change_egid(&amp;temp_cred, gid)) {
		temp_pcred-&gt;cr_gmuid = KAUTH_UID_NONE;
		temp_pcred-&gt;cr_flags |= CRF_NOMEMBERD;
	}
	temp_pcred-&gt;cr_rgid = gid;
	temp_pcred-&gt;cr_svgid = gid;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	temp_cred.cr_label = cred-&gt;cr_label;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span>(kauth_cred_update(cred, &amp;temp_cred, TRUE));
}


<span class="enscript-comment">/*
 * kauth_cred_setsvuidgid
 *
 * Description:	Function used by execve to set the saved uid and gid values
 *		for suid/sgid programs
 *
 * Parameters:	cred				The credential to update
 *		uid				The saved uid to set
 *		gid				The saved gid to set
 *
 * Returns:	(kauth_cred_t)			The updated credential
 *
 * IMPORTANT:	This function is implemented via kauth_cred_update(), which,
 *		if it returns a credential other than the one it is passed,
 *		will have dropped the reference on the passed credential.  All
 *		callers should be aware of this, and treat this function as an
 *		unref + ref, potentially on different credentials.
 *
 *		Because of this, the caller is expected to take its own
 *		reference on the credential passed as the first parameter,
 *		and be prepared to release the reference on the credential
 *		that is returned to them, if it is not intended to be a
 *		persistent reference.
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_setsvuidgid</span>(kauth_cred_t cred, uid_t uid, gid_t gid)
{
	<span class="enscript-type">struct</span> ucred temp_cred;
	posix_cred_t temp_pcred = posix_cred_get(&amp;temp_cred);
	posix_cred_t pcred;

	NULLCRED_CHECK(cred);

	pcred = posix_cred_get(cred);

	DEBUG_CRED_ENTER(<span class="enscript-string">&quot;kauth_cred_setsvuidgid: %p u%d-&gt;%d g%d-&gt;%d\n&quot;</span>, cred, cred-&gt;cr_svuid, uid, cred-&gt;cr_svgid, gid);

	<span class="enscript-comment">/*
	 * We don't need to do anything if the effective, real and saved
	 * uids are already the same as the uid provided.  This check is
	 * likely insufficient.
	 */</span>
	<span class="enscript-keyword">if</span> (pcred-&gt;cr_svuid == uid &amp;&amp; pcred-&gt;cr_svgid == gid) {
		<span class="enscript-comment">/* no change needed */</span>
		<span class="enscript-keyword">return</span>(cred);
	}
	DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;kauth_cred_setsvuidgid: cred change\n&quot;</span>);

	<span class="enscript-comment">/* look up in cred hash table to see if we have a matching credential
	 * with new values.
	 */</span>
	bcopy(cred, &amp;temp_cred, <span class="enscript-keyword">sizeof</span>(temp_cred));
	temp_pcred-&gt;cr_svuid = uid;
	temp_pcred-&gt;cr_svgid = gid;

	<span class="enscript-keyword">return</span>(kauth_cred_update(cred, &amp;temp_cred, TRUE));
}


<span class="enscript-comment">/*
 * kauth_cred_setauditinfo
 * 
 * Description:	Update the given credential using the given au_session_t.
 *
 * Parameters:	cred				The original credential
 *		auditinfo_p			Pointer to ne audit information
 *
 * Returns:	(kauth_cred_t)			The updated credential
 *
 * IMPORTANT:	This function is implemented via kauth_cred_update(), which,
 *		if it returns a credential other than the one it is passed,
 *		will have dropped the reference on the passed credential.  All
 *		callers should be aware of this, and treat this function as an
 *		unref + ref, potentially on different credentials.
 *
 *		Because of this, the caller is expected to take its own
 *		reference on the credential passed as the first parameter,
 *		and be prepared to release the reference on the credential
 *		that is returned to them, if it is not intended to be a
 *		persistent reference.
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_setauditinfo</span>(kauth_cred_t cred, au_session_t *auditinfo_p)
{
	<span class="enscript-type">struct</span> ucred temp_cred;

	NULLCRED_CHECK(cred);

	<span class="enscript-comment">/*
	 * We don't need to do anything if the audit info is already the
	 * same as the audit info in the credential provided.
	 */</span>
	<span class="enscript-keyword">if</span> (bcmp(&amp;cred-&gt;cr_audit, auditinfo_p, <span class="enscript-keyword">sizeof</span>(cred-&gt;cr_audit)) == 0) {
		<span class="enscript-comment">/* no change needed */</span>
		<span class="enscript-keyword">return</span>(cred);
	}

	bcopy(cred, &amp;temp_cred, <span class="enscript-keyword">sizeof</span>(temp_cred));
	bcopy(auditinfo_p, &amp;temp_cred.cr_audit, <span class="enscript-keyword">sizeof</span>(temp_cred.cr_audit));

	<span class="enscript-keyword">return</span>(kauth_cred_update(cred, &amp;temp_cred, FALSE));
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
<span class="enscript-comment">/*
 * kauth_cred_label_update
 * 
 * Description:	Update the MAC label associated with a credential
 *
 * Parameters:	cred				The original credential
 *		label				The MAC label to set
 *
 * Returns:	(kauth_cred_t)			The updated credential
 *
 * IMPORTANT:	This function is implemented via kauth_cred_update(), which,
 *		if it returns a credential other than the one it is passed,
 *		will have dropped the reference on the passed credential.  All
 *		callers should be aware of this, and treat this function as an
 *		unref + ref, potentially on different credentials.
 *
 *		Because of this, the caller is expected to take its own
 *		reference on the credential passed as the first parameter,
 *		and be prepared to release the reference on the credential
 *		that is returned to them, if it is not intended to be a
 *		persistent reference.
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_label_update</span>(kauth_cred_t cred, <span class="enscript-type">struct</span> label *label)
{
	kauth_cred_t newcred;
	<span class="enscript-type">struct</span> ucred temp_cred;

	bcopy(cred, &amp;temp_cred, <span class="enscript-keyword">sizeof</span>(temp_cred));

	mac_cred_label_init(&amp;temp_cred);
	mac_cred_label_associate(cred, &amp;temp_cred);
	mac_cred_label_update(&amp;temp_cred, label);

	newcred = kauth_cred_update(cred, &amp;temp_cred, TRUE);
	mac_cred_label_destroy(&amp;temp_cred);
	<span class="enscript-keyword">return</span> (newcred);
}

<span class="enscript-comment">/*
 * kauth_cred_label_update_execve
 * 
 * Description:	Update the MAC label associated with a credential as
 *		part of exec
 *
 * Parameters:	cred				The original credential
 *		vp				The exec vnode
 *		scriptl				The script MAC label
 *		execl				The executable MAC label
 *		disjointp			Pointer to flag to set if old
 *						and returned credentials are
 *						disjoint
 *
 * Returns:	(kauth_cred_t)			The updated credential
 *
 * Implicit returns:
 *		*disjointp			Set to 1 for disjoint creds
 *
 * IMPORTANT:	This function is implemented via kauth_cred_update(), which,
 *		if it returns a credential other than the one it is passed,
 *		will have dropped the reference on the passed credential.  All
 *		callers should be aware of this, and treat this function as an
 *		unref + ref, potentially on different credentials.
 *
 *		Because of this, the caller is expected to take its own
 *		reference on the credential passed as the first parameter,
 *		and be prepared to release the reference on the credential
 *		that is returned to them, if it is not intended to be a
 *		persistent reference.
 */</span>

<span class="enscript-type">static</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_label_update_execve</span>(kauth_cred_t cred, vfs_context_t ctx,
	<span class="enscript-type">struct</span> vnode *vp, off_t offset, <span class="enscript-type">struct</span> vnode *scriptvp, <span class="enscript-type">struct</span> label *scriptl,
	<span class="enscript-type">struct</span> label *execl, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *csflags, <span class="enscript-type">void</span> *macextensions, <span class="enscript-type">int</span> *disjointp, <span class="enscript-type">int</span> *labelupdateerror)
{
	kauth_cred_t newcred;
	<span class="enscript-type">struct</span> ucred temp_cred;

	bcopy(cred, &amp;temp_cred, <span class="enscript-keyword">sizeof</span>(temp_cred));

	mac_cred_label_init(&amp;temp_cred);
	mac_cred_label_associate(cred, &amp;temp_cred);
	mac_cred_label_update_execve(ctx, &amp;temp_cred, 
						  vp, offset, scriptvp, scriptl, execl, csflags,
						  macextensions, disjointp, labelupdateerror);

	newcred = kauth_cred_update(cred, &amp;temp_cred, TRUE);
	mac_cred_label_destroy(&amp;temp_cred);
	<span class="enscript-keyword">return</span> (newcred);
}

<span class="enscript-comment">/*
 *  kauth_proc_label_update
 *
 * Description:  Update the label inside the credential associated with the process.
 *
 * Parameters:	p			The process to modify
 *				label		The label to place in the process credential
 *
 * Notes:		The credential associated with the process may change as a result
 *				of this call.  The caller should not assume the process reference to
 *				the old credential still exists.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">kauth_proc_label_update</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> label *label)
{
	kauth_cred_t my_cred, my_new_cred;

	my_cred = kauth_cred_proc_ref(p);

	DEBUG_CRED_ENTER(<span class="enscript-string">&quot;kauth_proc_label_update: %p\n&quot;</span>, my_cred);

	<span class="enscript-comment">/* get current credential and take a reference while we muck with it */</span>
	<span class="enscript-keyword">for</span> (;;) {

  		<span class="enscript-comment">/* 
		 * Set the credential with new info.  If there is no change,
		 * we get back the same credential we passed in; if there is
		 * a change, we drop the reference on the credential we
		 * passed in.  The subsequent compare is safe, because it is
		 * a pointer compare rather than a contents compare.
  		 */</span>
		my_new_cred = kauth_cred_label_update(my_cred, label);
		<span class="enscript-keyword">if</span> (my_cred != my_new_cred) {

			DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;kauth_proc_setlabel_unlocked CH(%d): %p/0x%08x -&gt; %p/0x%08x\n&quot;</span>, p-&gt;p_pid, my_cred, my_cred-&gt;cr_flags, my_new_cred, my_new_cred-&gt;cr_flags);

			proc_lock(p);
			<span class="enscript-comment">/*
			 * We need to protect for a race where another thread
			 * also changed the credential after we took our
			 * reference.  If p_ucred has changed then we should
			 * restart this again with the new cred.
			 */</span>
			<span class="enscript-keyword">if</span> (p-&gt;p_ucred != my_cred) {
				proc_unlock(p);
				kauth_cred_unref(&amp;my_new_cred);
				my_cred = kauth_cred_proc_ref(p);
				<span class="enscript-comment">/* try again */</span>
				<span class="enscript-keyword">continue</span>;
			}
			p-&gt;p_ucred = my_new_cred;
			<span class="enscript-comment">/* update cred on proc */</span>
			PROC_UPDATE_CREDS_ONPROC(p);

			mac_proc_set_enforce(p, MAC_ALL_ENFORCE);
			proc_unlock(p);
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-comment">/* Drop old proc reference or our extra reference */</span>
	kauth_cred_unref(&amp;my_cred);
	
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 *  kauth_proc_label_update_execve
 *
 * Description: Update the label inside the credential associated with the
 *		process as part of a transitioning execve.  The label will
 *		be updated by the policies as part of this processing, not
 *		provided up front.
 *
 * Parameters:	p			The process to modify
 *		ctx			The context of the exec
 *		vp			The vnode being exec'ed
 *		scriptl			The script MAC label
 *		execl			The executable MAC label
 *		lupdateerror	The error place holder for MAC label authority 
 *						to update about possible termination
 *
 * Returns:	0			Label update did not make credential
 *					disjoint
 *		1			Label update caused credential to be
 *					disjoint
 *
 * Notes:	The credential associated with the process WILL change as a
 *		result of this call.  The caller should not assume the process
 *		reference to the old credential still exists.
 */</span>
 
<span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_proc_label_update_execve</span>(<span class="enscript-type">struct</span> proc *p, vfs_context_t ctx,
	<span class="enscript-type">struct</span> vnode *vp, off_t offset, <span class="enscript-type">struct</span> vnode *scriptvp, <span class="enscript-type">struct</span> label *scriptl,
	<span class="enscript-type">struct</span> label *execl, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *csflags, <span class="enscript-type">void</span> *macextensions, <span class="enscript-type">int</span> *disjoint, <span class="enscript-type">int</span> *update_return)
{
	kauth_cred_t my_cred, my_new_cred;
	my_cred = kauth_cred_proc_ref(p);

	DEBUG_CRED_ENTER(<span class="enscript-string">&quot;kauth_proc_label_update_execve: %p\n&quot;</span>, my_cred);

	<span class="enscript-comment">/* get current credential and take a reference while we muck with it */</span>
	<span class="enscript-keyword">for</span> (;;) {

  		<span class="enscript-comment">/* 
		 * Set the credential with new info.  If there is no change,
		 * we get back the same credential we passed in; if there is
		 * a change, we drop the reference on the credential we
		 * passed in.  The subsequent compare is safe, because it is
		 * a pointer compare rather than a contents compare.
  		 */</span>
		my_new_cred = kauth_cred_label_update_execve(my_cred, ctx, vp, offset, scriptvp, scriptl, execl, csflags, macextensions, disjoint, update_return);
		<span class="enscript-keyword">if</span> (my_cred != my_new_cred) {

			DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;kauth_proc_label_update_execve_unlocked CH(%d): %p/0x%08x -&gt; %p/0x%08x\n&quot;</span>, p-&gt;p_pid, my_cred, my_cred-&gt;cr_flags, my_new_cred, my_new_cred-&gt;cr_flags);

			proc_lock(p);
			<span class="enscript-comment">/*
			 * We need to protect for a race where another thread
			 * also changed the credential after we took our
			 * reference.  If p_ucred has changed then we should
			 * restart this again with the new cred.
			 */</span>
			<span class="enscript-keyword">if</span> (p-&gt;p_ucred != my_cred) {
				proc_unlock(p);
				kauth_cred_unref(&amp;my_new_cred);
				my_cred = kauth_cred_proc_ref(p);
				<span class="enscript-comment">/* try again */</span>
				<span class="enscript-keyword">continue</span>;
			}
			p-&gt;p_ucred = my_new_cred;
			<span class="enscript-comment">/* update cred on proc */</span>
			PROC_UPDATE_CREDS_ONPROC(p);
			mac_proc_set_enforce(p, MAC_ALL_ENFORCE);
			proc_unlock(p);
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-comment">/* Drop old proc reference or our extra reference */</span>
	kauth_cred_unref(&amp;my_cred);
}

#<span class="enscript-reference">if</span> 1
<span class="enscript-comment">/*
 * for temporary binary compatibility
 */</span>
kauth_cred_t	kauth_cred_setlabel(kauth_cred_t cred, <span class="enscript-type">struct</span> label *label);
kauth_cred_t
<span class="enscript-function-name">kauth_cred_setlabel</span>(kauth_cred_t cred, <span class="enscript-type">struct</span> label *label)
{
	<span class="enscript-keyword">return</span> kauth_cred_label_update(cred, label);
}

<span class="enscript-type">int</span> <span class="enscript-function-name">kauth_proc_setlabel</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> label *label);
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_proc_setlabel</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> label *label)
{
	<span class="enscript-keyword">return</span> kauth_proc_label_update(p, label);
}
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">else</span>

<span class="enscript-comment">/* this is a temp hack to cover us when MACF is not built in a kernel configuration. 
 * Since we cannot build our export lists based on the kernel configuration we need
 * to define a stub. 
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_label_update</span>(__unused kauth_cred_t cred, __unused <span class="enscript-type">void</span> *label)
{
	<span class="enscript-keyword">return</span>(NULL);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_proc_label_update</span>(__unused <span class="enscript-type">struct</span> proc *p, __unused <span class="enscript-type">void</span> *label)
{
	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">if</span> 1
<span class="enscript-comment">/*
 * for temporary binary compatibility
 */</span>
kauth_cred_t	kauth_cred_setlabel(kauth_cred_t cred, <span class="enscript-type">void</span> *label);
kauth_cred_t
<span class="enscript-function-name">kauth_cred_setlabel</span>(__unused kauth_cred_t cred, __unused <span class="enscript-type">void</span> *label)
{
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">int</span> <span class="enscript-function-name">kauth_proc_setlabel</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">void</span> *label);
<span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_proc_setlabel</span>(__unused <span class="enscript-type">struct</span> proc *p, __unused <span class="enscript-type">void</span> *label)
{
	<span class="enscript-keyword">return</span> (0);
}
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * kauth_cred_ref
 *
 * Description:	Add a reference to the passed credential
 *
 * Parameters:	cred				The credential to reference
 *
 * Returns:	(void)
 *
 * Notes:	This function adds a reference to the provided credential;
 *		the existing reference on the credential is assumed to be
 *		held stable over this operation by taking the appropriate
 *		lock to protect the pointer from which it is being referenced,
 *		if necessary (e.g. the proc lock is held over the call if the
 *		credential being referenced is from p_ucred, the vnode lock
 *		if from the per vnode name cache cred cache, and so on).
 *
 *		This is safe from the kauth_cred_unref() path, since an atomic
 *		add is used, and the unref path specifically checks to see that
 *		the value has not been changed to add a reference between the
 *		time the credential is unreferenced by another pointer and the
 *		time it is unreferenced from the cred hash cache.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_cred_ref</span>(kauth_cred_t cred)
{
	<span class="enscript-type">int</span>		old_value;
	
	NULLCRED_CHECK(cred);

	old_value = OSAddAtomicLong(1, (<span class="enscript-type">long</span>*)&amp;cred-&gt;cr_ref);

	<span class="enscript-keyword">if</span> (old_value &lt; 1)
		panic(<span class="enscript-string">&quot;kauth_cred_ref: trying to take a reference on a cred with no references&quot;</span>);

#<span class="enscript-reference">if</span> 0 // <span class="enscript-variable-name">use</span> <span class="enscript-variable-name">this</span> <span class="enscript-variable-name">to</span> <span class="enscript-variable-name">watch</span> <span class="enscript-variable-name">a</span> <span class="enscript-variable-name">specific</span> <span class="enscript-variable-name">credential</span>
	<span class="enscript-keyword">if</span> ( is_target_cred( cred ) != 0 ) {
 		get_backtrace( );
	}
#<span class="enscript-reference">endif</span>
		
	<span class="enscript-keyword">return</span>;
}


<span class="enscript-comment">/*
 * kauth_cred_unref_hashlocked
 *
 * Description:	release a credential reference; when the last reference is
 *		released, the credential will be freed.
 *
 * Parameters:	credp				Pointer to address containing
 *						credential to be freed
 *
 * Returns:	TRUE if the credential must be destroyed by the caller.
 *		FALSE otherwise.
 *
 * Implicit returns:
 *		*credp				Set to NOCRED
 *
 * Notes:	This function assumes the credential hash lock is held.
 *
 *		This function is internal use only, since the hash lock is
 *		scoped to this compilation unit.
 *
 *		This function destroys the contents of the pointer passed by
 *		the caller to prevent the caller accidentally attempting to
 *		release a given reference twice in error.
 *
 *		The last reference is considered to be released when a release
 *		of a credential of a reference count of 2 occurs; this is an
 *		intended effect, to take into account the reference held by
 *		the credential hash, which is released at the same time.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">kauth_cred_unref_hashlocked</span>(kauth_cred_t *credp)
{
	<span class="enscript-type">int</span>		old_value;
	boolean_t	destroy_it = FALSE;

	KAUTH_CRED_HASH_LOCK_ASSERT();
	NULLCRED_CHECK(*credp);

	old_value = OSAddAtomicLong(-1, (<span class="enscript-type">long</span>*)&amp;(*credp)-&gt;cr_ref);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (old_value == 0)
		panic(<span class="enscript-string">&quot;%s:0x%08x kauth_cred_unref_hashlocked: dropping a reference on a cred with no references&quot;</span>, current_proc()-&gt;p_comm, *credp);
	<span class="enscript-keyword">if</span> (old_value == 1)
		panic(<span class="enscript-string">&quot;%s:0x%08x kauth_cred_unref_hashlocked: dropping a reference on a cred with no hash entry&quot;</span>, current_proc()-&gt;p_comm, *credp);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> 0 // <span class="enscript-variable-name">use</span> <span class="enscript-variable-name">this</span> <span class="enscript-variable-name">to</span> <span class="enscript-variable-name">watch</span> <span class="enscript-variable-name">a</span> <span class="enscript-variable-name">specific</span> <span class="enscript-variable-name">credential</span>
	<span class="enscript-keyword">if</span> ( is_target_cred( *credp ) != 0 ) {
		get_backtrace( );
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * If the old_value is 2, then we have just released the last external
	 * reference to this credential
	 */</span>
	<span class="enscript-keyword">if</span> (old_value &lt; 3) {
		<span class="enscript-comment">/* The last absolute reference is our credential hash table */</span>
		destroy_it = kauth_cred_remove(*credp);
	}

	<span class="enscript-keyword">if</span> (destroy_it == FALSE) {
		*credp = NOCRED;
	}

	<span class="enscript-keyword">return</span> (destroy_it);
}


<span class="enscript-comment">/*
 * kauth_cred_unref
 *
 * Description:	Release a credential reference while holding the credential
 *		hash lock; when the last reference is released, the credential
 *		will be freed.
 *
 * Parameters:	credp				Pointer to address containing
 *						credential to be freed
 *
 * Returns:	(void)
 *
 * Implicit returns:
 *		*credp				Set to NOCRED
 *
 * Notes:	See kauth_cred_unref_hashlocked() for more information.
 *
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_cred_unref</span>(kauth_cred_t *credp)
{
	boolean_t destroy_it;

	KAUTH_CRED_HASH_LOCK();
	destroy_it = kauth_cred_unref_hashlocked(credp);
	KAUTH_CRED_HASH_UNLOCK();

	<span class="enscript-keyword">if</span> (destroy_it == TRUE) {
		assert(*credp != NOCRED);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_cred_label_destroy(*credp);
#<span class="enscript-reference">endif</span>
		AUDIT_SESSION_UNREF(*credp);

		(*credp)-&gt;cr_ref = 0;
		FREE_ZONE(*credp, <span class="enscript-keyword">sizeof</span>(*(*credp)), M_CRED);
		*credp = NOCRED;
	}
}


#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
<span class="enscript-comment">/*
 * kauth_cred_rele
 *
 * Description:	release a credential reference; when the last reference is
 *		released, the credential will be freed
 *
 * Parameters:	cred				Credential to release
 *
 * Returns:	(void)
 *
 * DEPRECATED:	This interface is obsolete due to a failure to clear out the
 *		clear the pointer in the caller to avoid multiple releases of
 *		the same credential.  The currently recommended interface is
 *		kauth_cred_unref().
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_cred_rele</span>(kauth_cred_t cred)
{
	kauth_cred_unref(&amp;cred);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>


<span class="enscript-comment">/*
 * kauth_cred_dup
 *
 * Description:	Duplicate a credential via alloc and copy; the new credential
 *		has only it's own
 *
 * Parameters:	cred				The credential to duplicate
 *
 * Returns:	(kauth_cred_t)			The duplicate credential
 *
 * Notes:	The typical value to calling this routine is if you are going
 *		to modify an existing credential, and expect to need a new one
 *		from the hash cache.
 *
 *		This should probably not be used in the majority of cases;
 *		if you are using it instead of kauth_cred_create(), you are
 *		likely making a mistake.
 *
 *		The newly allocated credential is copied as part of the
 *		allocation process, with the exception of the reference
 *		count, which is set to 1 to indicate a single reference
 *		held by the caller.
 *
 *		Since newly allocated credentials have no external pointers
 *		referencing them, prior to making them visible in an externally
 *		visible pointer (e.g. by adding them to the credential hash
 *		cache) is the only legal time in which an existing credential
 *		can be safely initialized or modified directly.
 *
 *		After initialization, the caller is expected to call the
 *		function kauth_cred_add() to add the credential to the hash
 *		cache, after which time it's frozen and becomes publicly
 *		visible.
 *
 *		The release protocol depends on kauth_hash_add() being called
 *		before kauth_cred_rele() (there is a diagnostic panic which
 *		will trigger if this protocol is not observed).
 *
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_dup</span>(kauth_cred_t cred)
{
	kauth_cred_t newcred;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-type">struct</span> label *temp_label;
#<span class="enscript-reference">endif</span>
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CRED_DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (cred == NOCRED || cred == FSCRED)
		panic(<span class="enscript-string">&quot;kauth_cred_dup: bad credential&quot;</span>);
#<span class="enscript-reference">endif</span>
	newcred = kauth_cred_alloc();
	<span class="enscript-keyword">if</span> (newcred != NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		temp_label = newcred-&gt;cr_label;
#<span class="enscript-reference">endif</span>
		bcopy(cred, newcred, <span class="enscript-keyword">sizeof</span>(*newcred));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		newcred-&gt;cr_label = temp_label;
		mac_cred_label_associate(cred, newcred);
#<span class="enscript-reference">endif</span>
		AUDIT_SESSION_REF(cred);
		newcred-&gt;cr_ref = 1;
	}
	<span class="enscript-keyword">return</span>(newcred);
}

<span class="enscript-comment">/*
 * kauth_cred_copy_real
 *
 * Description:	Returns a credential based on the passed credential but which
 *		reflects the real rather than effective UID and GID.
 *
 * Parameters:	cred				The credential from which to
 *						derive the new credential
 *
 * Returns:	(kauth_cred_t)			The copied credential
 *
 * IMPORTANT:	This function DOES NOT utilize kauth_cred_update(); as a
 *		result, the caller is responsible for dropping BOTH the
 *		additional reference on the passed cred (if any), and the
 *		credential returned by this function.  The drop should be
 *		via the kauth_cred_unref() KPI.
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_copy_real</span>(kauth_cred_t cred)
{
	kauth_cred_t newcred = NULL, found_cred;
	<span class="enscript-type">struct</span> ucred temp_cred;
	posix_cred_t temp_pcred = posix_cred_get(&amp;temp_cred);
	posix_cred_t pcred = posix_cred_get(cred);

	<span class="enscript-comment">/* if the credential is already 'real', just take a reference */</span>
	<span class="enscript-keyword">if</span> ((pcred-&gt;cr_ruid == pcred-&gt;cr_uid) &amp;&amp;
	    (pcred-&gt;cr_rgid == pcred-&gt;cr_gid)) {
		kauth_cred_ref(cred);
		<span class="enscript-keyword">return</span>(cred);
	}

	<span class="enscript-comment">/*
	 * Look up in cred hash table to see if we have a matching credential
	 * with the new values.
	 */</span>
	bcopy(cred, &amp;temp_cred, <span class="enscript-keyword">sizeof</span>(temp_cred));
	temp_pcred-&gt;cr_uid = pcred-&gt;cr_ruid;
	<span class="enscript-comment">/* displacing a supplementary group opts us out of memberd */</span>
	<span class="enscript-keyword">if</span> (kauth_cred_change_egid(&amp;temp_cred, pcred-&gt;cr_rgid)) {
		temp_pcred-&gt;cr_flags |= CRF_NOMEMBERD;
		temp_pcred-&gt;cr_gmuid = KAUTH_UID_NONE;
	}
	<span class="enscript-comment">/*
	 * If the cred is not opted out, make sure we are using the r/euid
	 * for group checks
	 */</span>
	<span class="enscript-keyword">if</span> (temp_pcred-&gt;cr_gmuid != KAUTH_UID_NONE)
		temp_pcred-&gt;cr_gmuid = pcred-&gt;cr_ruid;

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-type">int</span>		err;
		
		KAUTH_CRED_HASH_LOCK();
		found_cred = kauth_cred_find(&amp;temp_cred);
		<span class="enscript-keyword">if</span> (found_cred == cred) {
			<span class="enscript-comment">/* same cred so just bail */</span>
			KAUTH_CRED_HASH_UNLOCK();
			<span class="enscript-keyword">return</span>(cred); 
		}
		<span class="enscript-keyword">if</span> (found_cred != NULL) {
			<span class="enscript-comment">/*
			 * Found a match so we bump reference count on new
			 * one.  We leave the old one alone.
			 */</span>
			kauth_cred_ref(found_cred);
			KAUTH_CRED_HASH_UNLOCK();
			<span class="enscript-keyword">return</span>(found_cred);
		}
	
		<span class="enscript-comment">/*
		 * Must allocate a new credential, copy in old credential
		 * data and update the real user and group IDs.
		 */</span>
		newcred = kauth_cred_dup(&amp;temp_cred);
		err = kauth_cred_add(newcred);
		KAUTH_CRED_HASH_UNLOCK();

		<span class="enscript-comment">/* Retry if kauth_cred_add() fails */</span>
		<span class="enscript-keyword">if</span> (err == 0)
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_cred_label_destroy(newcred);
#<span class="enscript-reference">endif</span>
		AUDIT_SESSION_UNREF(newcred);

		FREE_ZONE(newcred, <span class="enscript-keyword">sizeof</span>(*newcred), M_CRED);
		newcred = NULL;
	}
	
	<span class="enscript-keyword">return</span>(newcred);
}


<span class="enscript-comment">/*
 * kauth_cred_update
 *
 * Description:	Common code to update a credential
 *
 * Parameters:	old_cred			Reference counted credential
 *						to update
 *		model_cred			Non-reference counted model
 *						credential to apply to the
 *						credential to be updated
 *		retain_auditinfo		Flag as to whether or not the
 *						audit information should be
 *						copied from the old_cred into
 *						the model_cred
 *
 * Returns:	(kauth_cred_t)			The updated credential
 *
 * IMPORTANT:	This function will potentially return a credential other than
 *		the one it is passed, and if so, it will have dropped the
 *		reference on the passed credential.  All callers should be
 *		aware of this, and treat this function as an unref + ref,
 *		potentially on different credentials.
 *
 *		Because of this, the caller is expected to take its own
 *		reference on the credential passed as the first parameter,
 *		and be prepared to release the reference on the credential
 *		that is returned to them, if it is not intended to be a
 *		persistent reference.
 */</span>
<span class="enscript-type">static</span> kauth_cred_t
<span class="enscript-function-name">kauth_cred_update</span>(kauth_cred_t old_cred, kauth_cred_t model_cred,
	boolean_t retain_auditinfo)
{	
	kauth_cred_t found_cred, new_cred = NULL;
	
	<span class="enscript-comment">/*
	 * Make sure we carry the auditinfo forward to the new credential
	 * unless we are actually updating the auditinfo.
	 */</span>
	<span class="enscript-keyword">if</span> (retain_auditinfo) {
		bcopy(&amp;old_cred-&gt;cr_audit, &amp;model_cred-&gt;cr_audit, 
		    <span class="enscript-keyword">sizeof</span>(model_cred-&gt;cr_audit));
	}
	
	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-type">int</span>		err;

		KAUTH_CRED_HASH_LOCK();
		found_cred = kauth_cred_find(model_cred);
		<span class="enscript-keyword">if</span> (found_cred == old_cred) {
			<span class="enscript-comment">/* same cred so just bail */</span>
			KAUTH_CRED_HASH_UNLOCK();
			<span class="enscript-keyword">return</span>(old_cred); 
		}
		<span class="enscript-keyword">if</span> (found_cred != NULL) {
			boolean_t destroy_it;

			DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;kauth_cred_update(cache hit): %p -&gt; %p\n&quot;</span>, old_cred, found_cred);
			<span class="enscript-comment">/*
			 * Found a match so we bump reference count on new
			 * one and decrement reference count on the old one.
			 */</span>
			kauth_cred_ref(found_cred);
			destroy_it = kauth_cred_unref_hashlocked(&amp;old_cred);
			KAUTH_CRED_HASH_UNLOCK();
			<span class="enscript-keyword">if</span> (destroy_it == TRUE) {
				assert(old_cred != NOCRED);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
				mac_cred_label_destroy(old_cred);
#<span class="enscript-reference">endif</span>
				AUDIT_SESSION_UNREF(old_cred);

				old_cred-&gt;cr_ref = 0;
				FREE_ZONE(old_cred, <span class="enscript-keyword">sizeof</span>(*old_cred), M_CRED);
				old_cred = NOCRED;

			}
			<span class="enscript-keyword">return</span>(found_cred);
		}

		<span class="enscript-comment">/*
		 * Must allocate a new credential using the model.  also
		 * adds the new credential to the credential hash table.
		 */</span>
		new_cred = kauth_cred_dup(model_cred);
		err = kauth_cred_add(new_cred);
		KAUTH_CRED_HASH_UNLOCK();

		<span class="enscript-comment">/* retry if kauth_cred_add returns non zero value */</span>
		<span class="enscript-keyword">if</span> (err == 0)
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_cred_label_destroy(new_cred);
#<span class="enscript-reference">endif</span>
		AUDIT_SESSION_UNREF(new_cred);

		FREE_ZONE(new_cred, <span class="enscript-keyword">sizeof</span>(*new_cred), M_CRED);
		new_cred = NULL;
	}

	DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;kauth_cred_update(cache miss): %p -&gt; %p\n&quot;</span>, old_cred, new_cred);
	kauth_cred_unref(&amp;old_cred);
	<span class="enscript-keyword">return</span>(new_cred);
}


<span class="enscript-comment">/*
 * kauth_cred_add
 *
 * Description:	Add the given credential to our credential hash table and
 *		take an additional reference to account for our use of the
 *		credential in the hash table
 *
 * Parameters:	new_cred			Credential to insert into cred
 *						hash cache
 *
 * Returns:	0				Success
 *		-1				Hash insertion failed: caller
 *						should retry
 *
 * Locks:	Caller is expected to hold KAUTH_CRED_HASH_LOCK
 *
 * Notes:	The 'new_cred' MUST NOT already be in the cred hash cache
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">kauth_cred_add</span>(kauth_cred_t new_cred)
{
	u_long			hash_key;

	KAUTH_CRED_HASH_LOCK_ASSERT();

	hash_key = kauth_cred_get_hashkey(new_cred);
	hash_key %= KAUTH_CRED_TABLE_SIZE;

	<span class="enscript-comment">/* race fix - there is a window where another matching credential 
	 * could have been inserted between the time this one was created and we
	 * got the hash lock.  If we find a match return an error and have the 
	 * the caller retry.
	 */</span>
	<span class="enscript-keyword">if</span> (kauth_cred_find(new_cred) != NULL) {
		<span class="enscript-keyword">return</span>(-1);
	}
	
	<span class="enscript-comment">/* take a reference for our use in credential hash table */</span> 
	kauth_cred_ref(new_cred);

	<span class="enscript-comment">/* insert the credential into the hash table */</span>
	TAILQ_INSERT_HEAD(&amp;kauth_cred_table_anchor[hash_key], new_cred, cr_link);
	
	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-comment">/* 
 * kauth_cred_remove
 *
 * Description:	Remove the given credential from our credential hash table
 *
 * Parameters:	cred				Credential to remove from cred
 *						hash cache
 *
 * Returns:	TRUE if the cred was found &amp; removed from the hash; FALSE if not.
 *
 * Locks:	Caller is expected to hold KAUTH_CRED_HASH_LOCK
 *
 * Notes:	The check for the reference increment after entry is generally
 *		agree to be safe, since we use atomic operations, and the
 *		following code occurs with the hash lock held; in theory, this
 *		protects us from the 2-&gt;1 reference that gets us here.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">kauth_cred_remove</span>(kauth_cred_t cred)
{
	u_long			hash_key;
	kauth_cred_t	found_cred;

	hash_key = kauth_cred_get_hashkey(cred);
	hash_key %= KAUTH_CRED_TABLE_SIZE;

	<span class="enscript-comment">/* Avoid race */</span>
	<span class="enscript-keyword">if</span> (cred-&gt;cr_ref &lt; 1)
		panic(<span class="enscript-string">&quot;cred reference underflow&quot;</span>);
	<span class="enscript-keyword">if</span> (cred-&gt;cr_ref &gt; 1)
		<span class="enscript-keyword">return</span> (FALSE);		<span class="enscript-comment">/* someone else got a ref */</span>
		
	<span class="enscript-comment">/* Find cred in the credential hash table */</span>
	TAILQ_FOREACH(found_cred, &amp;kauth_cred_table_anchor[hash_key], cr_link) {
		<span class="enscript-keyword">if</span> (found_cred == cred) {
			<span class="enscript-comment">/* found a match, remove it from the hash table */</span>
			TAILQ_REMOVE(&amp;kauth_cred_table_anchor[hash_key], found_cred, cr_link);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KAUTH_CRED_HASH_DEBUG</span>
			kauth_cred_count--;
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">return</span> (TRUE);
		}
	}

	<span class="enscript-comment">/* Did not find a match... this should not happen! XXX Make panic? */</span>
	printf(<span class="enscript-string">&quot;%s:%d - %s - %s - did not find a match for %p\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, current_proc()-&gt;p_comm, cred);
	<span class="enscript-keyword">return</span> (FALSE);
}


<span class="enscript-comment">/* 
 * kauth_cred_find
 *
 * Description:	Using the given credential data, look for a match in our
 *		credential hash table
 *
 * Parameters:	cred				Credential to lookup in cred
 *						hash cache
 *
 * Returns:	NULL				Not found
 *		!NULL				Matching credential already in
 *						cred hash cache
 *
 * Locks:	Caller is expected to hold KAUTH_CRED_HASH_LOCK
 */</span>
kauth_cred_t
<span class="enscript-function-name">kauth_cred_find</span>(kauth_cred_t cred)
{
	u_long			hash_key;
	kauth_cred_t	found_cred;
	posix_cred_t pcred = posix_cred_get(cred);

	KAUTH_CRED_HASH_LOCK_ASSERT();

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KAUTH_CRED_HASH_DEBUG</span>
	<span class="enscript-type">static</span> <span class="enscript-type">int</span>		test_count = 0; 

	test_count++;
	<span class="enscript-keyword">if</span> ((test_count % 200) == 0) {
		kauth_cred_hash_print();
	}
#<span class="enscript-reference">endif</span>

	hash_key = kauth_cred_get_hashkey(cred);
	hash_key %= KAUTH_CRED_TABLE_SIZE;

	<span class="enscript-comment">/* Find cred in the credential hash table */</span>
	TAILQ_FOREACH(found_cred, &amp;kauth_cred_table_anchor[hash_key], cr_link) {
		boolean_t match;
		posix_cred_t found_pcred = posix_cred_get(found_cred);

		<span class="enscript-comment">/*
		 * don't worry about the label unless the flags in
		 * either credential tell us to.
		 */</span>
		match = (bcmp(found_pcred, pcred, <span class="enscript-keyword">sizeof</span> (*pcred)) == 0) ? TRUE : FALSE;
		match = match &amp;&amp; ((bcmp(&amp;found_cred-&gt;cr_audit, &amp;cred-&gt;cr_audit,
			<span class="enscript-keyword">sizeof</span>(cred-&gt;cr_audit)) == 0) ? TRUE : FALSE);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-keyword">if</span> (((found_pcred-&gt;cr_flags &amp; CRF_MAC_ENFORCE) != 0) ||
		    ((pcred-&gt;cr_flags &amp; CRF_MAC_ENFORCE) != 0)) {
			match = match &amp;&amp; mac_cred_label_compare(found_cred-&gt;cr_label,
				cred-&gt;cr_label);
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (match) {
			<span class="enscript-comment">/* found a match */</span>
			<span class="enscript-keyword">return</span>(found_cred);
		}
	}
	<span class="enscript-comment">/* No match found */</span>

	<span class="enscript-keyword">return</span>(NULL);
}


<span class="enscript-comment">/*
 * kauth_cred_hash
 *
 * Description:	Generates a hash key using data that makes up a credential;
 *		based on ElfHash
 *
 * Parameters:	datap				Pointer to data to hash
 *		data_len			Count of bytes to hash
 *		start_key			Start key value
 *
 * Returns:	(u_long)			Returned hash key
 */</span>
<span class="enscript-type">static</span> inline u_long
<span class="enscript-function-name">kauth_cred_hash</span>(<span class="enscript-type">const</span> uint8_t *datap, <span class="enscript-type">int</span> data_len, u_long start_key)
{
	u_long	hash_key = start_key;
	u_long	temp;

	<span class="enscript-keyword">while</span> (data_len &gt; 0) {
		hash_key = (hash_key &lt;&lt; 4) + *datap++;
		temp = hash_key &amp; 0xF0000000;
		<span class="enscript-keyword">if</span> (temp) {
			hash_key ^= temp &gt;&gt; 24;
		}
		hash_key &amp;= ~temp;
		data_len--;
	}
	<span class="enscript-keyword">return</span>(hash_key);
}


<span class="enscript-comment">/*
 * kauth_cred_get_hashkey
 *
 * Description:	Generate a hash key using data that makes up a credential;
 *		based on ElfHash.  We hash on the entire credential data,
 *		not including the ref count or the TAILQ, which are mutable;
 *		everything else isn't.
 *
 * Parameters:	cred				Credential for which hash is
 *						desired
 *
 * Returns:	(u_long)			Returned hash key
 *
 * Notes:	When actually moving the POSIX credential into a real label,
 *		remember to update this hash computation.
 */</span>
<span class="enscript-type">static</span> u_long
<span class="enscript-function-name">kauth_cred_get_hashkey</span>(kauth_cred_t cred)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	posix_cred_t pcred = posix_cred_get(cred);
#<span class="enscript-reference">endif</span>
	u_long	hash_key = 0;

	hash_key = kauth_cred_hash((uint8_t *)&amp;cred-&gt;cr_posix, 
							   <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> posix_cred),
							   hash_key);
	hash_key = kauth_cred_hash((uint8_t *)&amp;cred-&gt;cr_audit, 
							   <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> au_session),
							   hash_key);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (pcred-&gt;cr_flags &amp; CRF_MAC_ENFORCE) {
		hash_key = kauth_cred_hash((uint8_t *)cred-&gt;cr_label, 
								   <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> label),
								   hash_key);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span>(hash_key);
}


#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KAUTH_CRED_HASH_DEBUG</span>
<span class="enscript-comment">/*
 * kauth_cred_hash_print
 *
 * Description:	Print out cred hash cache table information for debugging
 *		purposes, including the credential contents
 *
 * Parameters:	(void)
 *
 * Returns:	(void)
 *
 * Implicit returns:	Results in console output
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_cred_hash_print</span>(<span class="enscript-type">void</span>) 
{
	<span class="enscript-type">int</span> 			i, j;
	kauth_cred_t	found_cred;
		
	printf(<span class="enscript-string">&quot;\n\t kauth credential hash table statistics - current cred count %d \n&quot;</span>, kauth_cred_count);
	<span class="enscript-comment">/* count slot hits, misses, collisions, and max depth */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; KAUTH_CRED_TABLE_SIZE; i++) {
		printf(<span class="enscript-string">&quot;[%02d] &quot;</span>, i);
		j = 0;
		TAILQ_FOREACH(found_cred, &amp;kauth_cred_table_anchor[i], cr_link) {
			<span class="enscript-keyword">if</span> (j &gt; 0) {
				printf(<span class="enscript-string">&quot;---- &quot;</span>);
			}
			j++;
			kauth_cred_print(found_cred);
			printf(<span class="enscript-string">&quot;\n&quot;</span>);
		}
		<span class="enscript-keyword">if</span> (j == 0) {
			printf(<span class="enscript-string">&quot;NOCRED \n&quot;</span>);
		}
	}
}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* KAUTH_CRED_HASH_DEBUG */</span>


#<span class="enscript-reference">if</span> (<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">KAUTH_CRED_HASH_DEBUG</span>) &amp;&amp; (<span class="enscript-variable-name">KAUTH_CRED_HASH_DEBUG</span> != 0)) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">DEBUG_CRED</span>)
<span class="enscript-comment">/*
 * kauth_cred_print
 *
 * Description:	Print out an individual credential's contents for debugging
 *		purposes
 *
 * Parameters:	cred				The credential to print out
 *
 * Returns:	(void)
 *
 * Implicit returns:	Results in console output
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">kauth_cred_print</span>(kauth_cred_t cred) 
{
	<span class="enscript-type">int</span> 	i;

	printf(<span class="enscript-string">&quot;%p - refs %lu flags 0x%08x uids e%d r%d sv%d gm%d &quot;</span>, cred, cred-&gt;cr_ref, cred-&gt;cr_flags, cred-&gt;cr_uid, cred-&gt;cr_ruid, cred-&gt;cr_svuid, cred-&gt;cr_gmuid);
	printf(<span class="enscript-string">&quot;group count %d gids &quot;</span>, cred-&gt;cr_ngroups);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; NGROUPS; i++) {
		<span class="enscript-keyword">if</span> (i == 0)
			printf(<span class="enscript-string">&quot;e&quot;</span>);
		printf(<span class="enscript-string">&quot;%d &quot;</span>, cred-&gt;cr_groups[i]);
	}
	printf(<span class="enscript-string">&quot;r%d sv%d &quot;</span>, cred-&gt;cr_rgid, cred-&gt;cr_svgid);
	printf(<span class="enscript-string">&quot;auditinfo_addr %d %d %d %d %d %d\n&quot;</span>, 
		cred-&gt;cr_audit.s_aia_p-&gt;ai_auid,
		cred-&gt;cr_audit.as_mask.am_success,
		cred-&gt;cr_audit.as_mask.am_failure,
		cred-&gt;cr_audit.as_aia_p-&gt;ai_termid.at_port,
		cred-&gt;cr_audit.as_aia_p-&gt;ai_termid.at_addr[0],
		cred-&gt;cr_audit.as_aia_p-&gt;ai_asid);
}

<span class="enscript-type">int</span> <span class="enscript-function-name">is_target_cred</span>( kauth_cred_t the_cred )
{
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_uid != 0 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_ruid != 0 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_svuid != 0 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_ngroups != 11 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_groups[0] != 11 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_groups[1] != 81 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_groups[2] != 63947 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_groups[3] != 80288 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_groups[4] != 89006 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_groups[5] != 52173 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_groups[6] != 84524 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_groups[7] != 79 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_groups[8] != 80292 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_groups[9] != 80 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_groups[10] != 90824 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_rgid != 11 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_svgid != 11 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_gmuid != 3475 ) 
		<span class="enscript-keyword">return</span>( 0 );
	<span class="enscript-keyword">if</span> ( the_cred-&gt;cr_audit.as_aia_p-&gt;ai_auid != 3475 ) 
		<span class="enscript-keyword">return</span>( 0 );
<span class="enscript-comment">/*
	if ( the_cred-&gt;cr_audit.as_mask.am_success != 0 ) 
		return( 0 );
	if ( the_cred-&gt;cr_audit.as_mask.am_failure != 0 ) 
		return( 0 );
	if ( the_cred-&gt;cr_audit.as_aia_p-&gt;ai_termid.at_port != 0 ) 
		return( 0 );
	if ( the_cred-&gt;cr_audit.as_aia_p-&gt;ai_termid.at_addr[0] != 0 ) 
		return( 0 );
	if ( the_cred-&gt;cr_audit.as_aia_p-&gt;ai_asid != 0 ) 
		return( 0 );
	if ( the_cred-&gt;cr_flags != 0 ) 
		return( 0 );
*/</span>
	<span class="enscript-keyword">return</span>( -1 ); <span class="enscript-comment">// found target cred
</span>}

<span class="enscript-type">void</span> <span class="enscript-function-name">get_backtrace</span>( <span class="enscript-type">void</span> )
{
	<span class="enscript-type">int</span>				my_slot;
	<span class="enscript-type">void</span> *			my_stack[ MAX_STACK_DEPTH ];
	<span class="enscript-type">int</span>				i, my_depth;
	
	<span class="enscript-keyword">if</span> ( cred_debug_buf_p == NULL ) {
		MALLOC(cred_debug_buf_p, cred_debug_buffer *, <span class="enscript-keyword">sizeof</span>(*cred_debug_buf_p), M_KAUTH, M_WAITOK);
		bzero(cred_debug_buf_p, <span class="enscript-keyword">sizeof</span>(*cred_debug_buf_p));
	}	

	<span class="enscript-keyword">if</span> ( cred_debug_buf_p-&gt;next_slot &gt; (MAX_CRED_BUFFER_SLOTS - 1) ) {
		<span class="enscript-comment">/* buffer is full */</span>
		<span class="enscript-keyword">return</span>;
	}
	
	my_depth = OSBacktrace(&amp;my_stack[0], MAX_STACK_DEPTH);
	<span class="enscript-keyword">if</span> ( my_depth == 0 ) {
		printf(<span class="enscript-string">&quot;%s - OSBacktrace failed \n&quot;</span>, __FUNCTION__);
		<span class="enscript-keyword">return</span>;
	}
	
	<span class="enscript-comment">/* fill new backtrace */</span>
	my_slot = cred_debug_buf_p-&gt;next_slot;
	cred_debug_buf_p-&gt;next_slot++;
	cred_debug_buf_p-&gt;stack_buffer[ my_slot ].depth = my_depth;
	<span class="enscript-keyword">for</span> ( i = 0; i &lt; my_depth; i++ ) {
		cred_debug_buf_p-&gt;stack_buffer[ my_slot ].stack[ i ] = my_stack[ i ];
	}

	<span class="enscript-keyword">return</span>;
}


<span class="enscript-comment">/* subset of struct ucred for use in sysctl_dump_creds */</span>
<span class="enscript-type">struct</span> debug_ucred {
	<span class="enscript-type">void</span>	*credp;
	u_long	cr_ref;				<span class="enscript-comment">/* reference count */</span>
	uid_t	cr_uid;				<span class="enscript-comment">/* effective user id */</span>
	uid_t	cr_ruid;			<span class="enscript-comment">/* real user id */</span>
	uid_t	cr_svuid;			<span class="enscript-comment">/* saved user id */</span>
	<span class="enscript-type">short</span>	cr_ngroups;			<span class="enscript-comment">/* number of groups in advisory list */</span>
	gid_t	cr_groups[NGROUPS];	<span class="enscript-comment">/* advisory group list */</span>
	gid_t	cr_rgid;			<span class="enscript-comment">/* real group id */</span>
	gid_t	cr_svgid;			<span class="enscript-comment">/* saved group id */</span>
	uid_t	cr_gmuid;			<span class="enscript-comment">/* UID for group membership purposes */</span>
	<span class="enscript-type">struct</span> auditinfo_addr cr_audit;	<span class="enscript-comment">/* user auditing data. */</span>
	<span class="enscript-type">void</span>	*cr_label;			<span class="enscript-comment">/* MACF label */</span>
	<span class="enscript-type">int</span>		cr_flags;			<span class="enscript-comment">/* flags on credential */</span>
};
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> debug_ucred debug_ucred;

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, dump_creds, CTLFLAG_RD,
    NULL, 0, sysctl_dump_creds, <span class="enscript-string">&quot;S,debug_ucred&quot;</span>, <span class="enscript-string">&quot;List of credentials in the cred hash&quot;</span>);

<span class="enscript-comment">/*	accessed by:      
 *	err = sysctlbyname( &quot;kern.dump_creds&quot;, bufp, &amp;len, NULL, 0 );
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_dump_creds</span>( __unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req )
{
	<span class="enscript-type">int</span> 			i, j, counter = 0;
	<span class="enscript-type">int</span>				error;
	size_t			space;
	kauth_cred_t	found_cred;
	debug_ucred *	cred_listp;
	debug_ucred *	nextp;

	<span class="enscript-comment">/* This is a readonly node. */</span>
	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-comment">/* calculate space needed */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; KAUTH_CRED_TABLE_SIZE; i++) {
		TAILQ_FOREACH(found_cred, &amp;kauth_cred_table_anchor[i], cr_link) {
			counter++;
		}
	}

	<span class="enscript-comment">/* they are querying us so just return the space required. */</span>
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		counter += 10; <span class="enscript-comment">// add in some padding;
</span>		req-&gt;oldidx = counter * <span class="enscript-keyword">sizeof</span>(debug_ucred);
		<span class="enscript-keyword">return</span> 0;
	}

	MALLOC( cred_listp, debug_ucred *, req-&gt;oldlen, M_TEMP, M_WAITOK );
	<span class="enscript-keyword">if</span> ( cred_listp == NULL ) {
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	
	<span class="enscript-comment">/* fill in creds to send back */</span>
	nextp = cred_listp;
	space = 0;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; KAUTH_CRED_TABLE_SIZE; i++) {
		TAILQ_FOREACH(found_cred, &amp;kauth_cred_table_anchor[i], cr_link) {
			nextp-&gt;credp = found_cred;
			nextp-&gt;cr_ref = found_cred-&gt;cr_ref;
			nextp-&gt;cr_uid = found_cred-&gt;cr_uid;
			nextp-&gt;cr_ruid = found_cred-&gt;cr_ruid;
			nextp-&gt;cr_svuid = found_cred-&gt;cr_svuid;
			nextp-&gt;cr_ngroups = found_cred-&gt;cr_ngroups;
			<span class="enscript-keyword">for</span> ( j = 0; j &lt; nextp-&gt;cr_ngroups; j++ ) {
				nextp-&gt;cr_groups[ j ] = found_cred-&gt;cr_groups[ j ];
			}
			nextp-&gt;cr_rgid = found_cred-&gt;cr_rgid;
			nextp-&gt;cr_svgid = found_cred-&gt;cr_svgid;
			nextp-&gt;cr_gmuid = found_cred-&gt;cr_gmuid;
			nextp-&gt;cr_audit.ai_auid =
			    found_cred-&gt;cr_audit.as_aia_p-&gt;ai_auid;
			nextp-&gt;cr_audit.ai_mask.am_success =
			    found_cred-&gt;cr_audit.as_mask.am_success;
			nextp-&gt;cr_audit.ai_mask.am_failure =
			    found_cred-&gt;cr_audit.as_mask.am_failure;
			nextp-&gt;cr_audit.ai_termid.at_port =
			    found_cred-&gt;cr_audit.as_aia_p-&gt;ai_termid.at_port;
			nextp-&gt;cr_audit.ai_termid.at_type =
			    found_cred-&gt;cr_audit.as_aia_p-&gt;ai_termid.at_type;
			nextp-&gt;cr_audit.ai_termid.at_addr[0] =
			    found_cred-&gt;cr_audit.as_aia_p-&gt;ai_termid.at_addr[0];
			nextp-&gt;cr_audit.ai_termid.at_addr[1] =
			    found_cred-&gt;cr_audit.as_aia_p-&gt;ai_termid.at_addr[1];
			nextp-&gt;cr_audit.ai_termid.at_addr[2] =
			    found_cred-&gt;cr_audit.as_aia_p-&gt;ai_termid.at_addr[2];
			nextp-&gt;cr_audit.ai_termid.at_addr[3] =
			    found_cred-&gt;cr_audit.as_aia_p-&gt;ai_termid.at_addr[3];
			nextp-&gt;cr_audit.ai_asid =
			    found_cred-&gt;cr_audit.as_aia_p-&gt;ai_asid;
			nextp-&gt;cr_audit.ai_flags =
			    found_cred-&gt;cr_audit.as_aia_p-&gt;ai_flags;
			nextp-&gt;cr_label = found_cred-&gt;cr_label;
			nextp-&gt;cr_flags = found_cred-&gt;cr_flags;
			nextp++;
			space += <span class="enscript-keyword">sizeof</span>(debug_ucred);
			<span class="enscript-keyword">if</span> ( space &gt; req-&gt;oldlen ) {
				FREE(cred_listp, M_TEMP);
				<span class="enscript-keyword">return</span> (ENOMEM);
			}
		}
	}
	req-&gt;oldlen = space;
	error = SYSCTL_OUT(req, cred_listp, req-&gt;oldlen);
	FREE(cred_listp, M_TEMP);
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, cred_bt, CTLFLAG_RD,
    NULL, 0, sysctl_dump_cred_backtraces, <span class="enscript-string">&quot;S,cred_debug_buffer&quot;</span>, <span class="enscript-string">&quot;dump credential backtrace&quot;</span>);

<span class="enscript-comment">/*	accessed by:      
 *	err = sysctlbyname( &quot;kern.cred_bt&quot;, bufp, &amp;len, NULL, 0 );
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_dump_cred_backtraces</span>( __unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req )
{
	<span class="enscript-type">int</span> 			i, j;
	<span class="enscript-type">int</span>				error;
	size_t			space;
	cred_debug_buffer *	bt_bufp;
	cred_backtrace *	nextp;

	<span class="enscript-comment">/* This is a readonly node. */</span>
	<span class="enscript-keyword">if</span> (req-&gt;newptr != USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-keyword">if</span> ( cred_debug_buf_p == NULL ) {
		<span class="enscript-keyword">return</span> (EAGAIN);
	}

	<span class="enscript-comment">/* calculate space needed */</span>
	space = <span class="enscript-keyword">sizeof</span>( cred_debug_buf_p-&gt;next_slot );
	space += (<span class="enscript-keyword">sizeof</span>( cred_backtrace ) * cred_debug_buf_p-&gt;next_slot);

	<span class="enscript-comment">/* they are querying us so just return the space required. */</span>
	<span class="enscript-keyword">if</span> (req-&gt;oldptr == USER_ADDR_NULL) {
		req-&gt;oldidx = space;
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> ( space &gt; req-&gt;oldlen ) {
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	MALLOC( bt_bufp, cred_debug_buffer *, req-&gt;oldlen, M_TEMP, M_WAITOK );
	<span class="enscript-keyword">if</span> ( bt_bufp == NULL ) {
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	
	<span class="enscript-comment">/* fill in backtrace info to send back */</span>
	bt_bufp-&gt;next_slot = cred_debug_buf_p-&gt;next_slot;
	space = <span class="enscript-keyword">sizeof</span>(bt_bufp-&gt;next_slot);
	
	nextp = &amp;bt_bufp-&gt;stack_buffer[ 0 ];
	<span class="enscript-keyword">for</span> (i = 0; i &lt; cred_debug_buf_p-&gt;next_slot; i++) {
		nextp-&gt;depth = cred_debug_buf_p-&gt;stack_buffer[ i ].depth;
		<span class="enscript-keyword">for</span> ( j = 0; j &lt; nextp-&gt;depth; j++ ) {
			nextp-&gt;stack[ j ] = cred_debug_buf_p-&gt;stack_buffer[ i ].stack[ j ];
		}
		space += <span class="enscript-keyword">sizeof</span>(*nextp);
		nextp++;
	}
	req-&gt;oldlen = space;
	error = SYSCTL_OUT(req, bt_bufp, req-&gt;oldlen);
	FREE(bt_bufp, M_TEMP);
	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* KAUTH_CRED_HASH_DEBUG || DEBUG_CRED */</span>


<span class="enscript-comment">/*
 **********************************************************************
 * The following routines will be moved to a policy_posix.c module at
 * some future point.
 **********************************************************************
 */</span>

<span class="enscript-comment">/*
 * posix_cred_create
 *
 * Description:	Helper function to create a kauth_cred_t credential that is
 *		initally labelled with a specific POSIX credential label
 *
 * Parameters:	pcred			The posix_cred_t to use as the initial
 *					label value
 *
 * Returns:	(kauth_cred_t)		The credential that was found in the
 *					hash or creates
 *		NULL			kauth_cred_add() failed, or there was
 *					no egid specified, or we failed to
 *					attach a label to the new credential
 *
 * Notes:	This function currently wraps kauth_cred_create(), and is the
 *		only consumer of that ill-fated function, apart from bsd_init().
 *		It exists solely to support the NFS server code creation of
 *		credentials based on the over-the-wire RPC calls containing
 *		traditional POSIX credential information being tunneled to
 *		the server host from the client machine.
 *
 *		In the future, we hope this function goes away.
 *
 *		In the short term, it creates a temporary credential, puts
 *		the POSIX information from NFS into it, and then calls
 *		kauth_cred_create(), as an internal implementation detail.
 *
 *		If we have to keep it around in the medium term, it will
 *		create a new kauth_cred_t, then label it with a POSIX label
 *		corresponding to the contents of the kauth_cred_t.  If the
 *		policy_posix MACF module is not loaded, it will instead
 *		substitute a posix_cred_t which GRANTS all access (effectively
 *		a &quot;root&quot; credential) in order to not prevent NFS from working
 *		in the case that we are not supporting POSIX credentials.
 */</span>
kauth_cred_t
<span class="enscript-function-name">posix_cred_create</span>(posix_cred_t pcred)
{
	<span class="enscript-type">struct</span> ucred temp_cred;

	bzero(&amp;temp_cred, <span class="enscript-keyword">sizeof</span>(temp_cred));
	temp_cred.cr_posix = *pcred;

	<span class="enscript-keyword">return</span> kauth_cred_create(&amp;temp_cred);
}


<span class="enscript-comment">/*
 * posix_cred_get
 *
 * Description:	Given a kauth_cred_t, return the POSIX credential label, if
 *		any, which is associated with it.
 *
 * Parameters:	cred			The credential to obtain the label from
 *
 * Returns:	posix_cred_t		The POSIX credential label
 *
 * Notes:	In the event that the policy_posix MACF module IS NOT loaded,
 *		this function will return a pointer to a posix_cred_t which
 *		GRANTS all access (effectively, a &quot;root&quot; credential).  This is
 *		necessary to support legacy code which insists on tightly
 *		integrating POSIX credentials into its APIs, including, but
 *		not limited to, System V IPC mechanisms, POSIX IPC mechanisms,
 *		NFSv3, signals, dtrace, and a large number of kauth routines
 *		used to implement POSIX permissions related system calls.
 *
 *		In the event that the policy_posix MACF module IS loaded, and
 *		there is no POSIX label on the kauth_cred_t credential, this
 *		function will return a pointer to a posix_cred_t which DENIES
 *		all access (effectively, a &quot;deny rights granted by POSIX&quot;
 *		credential).  This is necessary to support the concept of a
 *		transiently loaded POSIX policy, or kauth_cred_t credentials
 *		which can not be used in conjunctions with POSIX permissions
 *		checks.
 *
 *		This function currently returns the address of the cr_posix
 *		field of the supplied kauth_cred_t credential, and as such
 *		currently can not fail.  In the future, this will not be the
 *		case.
 */</span>
posix_cred_t
<span class="enscript-function-name">posix_cred_get</span>(kauth_cred_t cred)
{
	<span class="enscript-keyword">return</span>(&amp;cred-&gt;cr_posix);
}


<span class="enscript-comment">/*
 * posix_cred_label
 *
 * Description:	Label a kauth_cred_t with a POSIX credential label
 *
 * Parameters:	cred			The credential to label
 *		pcred			The POSIX credential t label it with
 *
 * Returns:	(void)
 *
 * Notes:	This function is currently void in order to permit it to fit
 *		in with the current MACF framework label methods which allow
 *		labeling to fail silently.  This is like acceptable for
 *		mandatory access controls, but not for POSIX, since those
 *		access controls are advisory.  We will need to consider a
 *		return value in a future version of the MACF API.
 *
 *		This operation currently cannot fail, as currently the POSIX
 *		credential is a subfield of the kauth_cred_t (ucred), which
 *		MUST be valid.  In the future, this will not be the case.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">posix_cred_label</span>(kauth_cred_t cred, posix_cred_t pcred)
{
	cred-&gt;cr_posix = *pcred;	<span class="enscript-comment">/* structure assign for now */</span>
}


<span class="enscript-comment">/*
 * posix_cred_access
 *
 * Description:	Perform a POSIX access check for a protected object
 *
 * Parameters:	cred			The credential to check
 *		object_uid		The POSIX UID of the protected object
 *		object_gid		The POSIX GID of the protected object
 *		object_mode		The POSIX mode of the protected object
 *		mode_req		The requested POSIX access rights
 *
 * Returns	0			Access is granted
 *		EACCES			Access is denied
 *
 * Notes:	This code optimizes the case where the world and group rights
 *		would both grant the requested rights to avoid making a group
 *		membership query.  This is a big performance win in the case
 *		where this is true.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">posix_cred_access</span>(kauth_cred_t cred, id_t object_uid, id_t object_gid, mode_t object_mode, mode_t mode_req)
{
	<span class="enscript-type">int</span> is_member;
	mode_t mode_owner = (object_mode &amp; S_IRWXU);
	mode_t mode_group = (object_mode &amp; S_IRWXG) &lt;&lt; 3;
	mode_t mode_world = (object_mode &amp; S_IRWXO) &lt;&lt; 6;

	<span class="enscript-comment">/*
	 * Check first for owner rights
	 */</span>
	<span class="enscript-keyword">if</span> (kauth_cred_getuid(cred) == object_uid &amp;&amp; (mode_req &amp; mode_owner) == mode_req)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/*
	 * Combined group and world rights check, if we don't have owner rights
	 *
	 * OPTIMIZED: If group and world rights would grant the same bits, and
	 * they set of requested bits is in both, then we can simply check the
	 * world rights, avoiding a group membership check, which is expensive.
	 */</span>
	<span class="enscript-keyword">if</span> ((mode_req &amp; mode_group &amp; mode_world) == mode_req) {
		<span class="enscript-keyword">return</span> (0);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * NON-OPTIMIZED: requires group membership check.
		 */</span>
		<span class="enscript-keyword">if</span> ((mode_req &amp; mode_group) != mode_req) {
			<span class="enscript-comment">/*
			 * exclusion group : treat errors as &quot;is a member&quot;
			 *
			 * NON-OPTIMIZED: +group would deny; must check group
			 */</span>
			<span class="enscript-keyword">if</span> (!kauth_cred_ismember_gid(cred, object_gid, &amp;is_member) &amp;&amp; is_member) {
				<span class="enscript-comment">/*
				 * DENY: +group denies
				 */</span>
				<span class="enscript-keyword">return</span> (EACCES);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> ((mode_req &amp; mode_world) != mode_req) {
					<span class="enscript-comment">/*
					 * DENY: both -group &amp; world would deny
					 */</span>
					<span class="enscript-keyword">return</span> (EACCES);
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/*
					 * ALLOW: allowed by -group and +world
					 */</span>
					<span class="enscript-keyword">return</span> (0);
				}
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * inclusion group; treat errors as &quot;not a member&quot;
			 *
			 * NON-OPTIMIZED: +group allows, world denies; must
			 * check group
			 */</span>
			<span class="enscript-keyword">if</span> (!kauth_cred_ismember_gid(cred, object_gid, &amp;is_member) &amp;&amp; is_member) {
				<span class="enscript-comment">/*
				 * ALLOW: allowed by +group
				 */</span>
				<span class="enscript-keyword">return</span> (0);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> ((mode_req &amp; mode_world) != mode_req) {
					<span class="enscript-comment">/*
					 * DENY: both -group &amp; world would deny
					 */</span>
					<span class="enscript-keyword">return</span> (EACCES);
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-comment">/*
					 * ALLOW: allowed by -group and +world
					 */</span>
					<span class="enscript-keyword">return</span> (0);
				}
			}
		}
	}
}
</pre>
<hr />
</body></html>