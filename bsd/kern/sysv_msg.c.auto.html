<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>sysv_msg.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">sysv_msg.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Implementation of SVID messages
 *
 * Author:  Daniel Boulet
 *
 * Copyright 1993 Daniel Boulet and RTMX Inc.
 *
 * This system call was implemented by Daniel Boulet under contract from RTMX.
 *
 * Redistribution and use in source forms, with and without modification,
 * are permitted provided that this entire comment appears intact.
 *
 * Redistribution in binary form may occur without any restrictions.
 * Obviously, it would be nice if you gave credit where credit is due
 * but requiring it would be too onerous.
 *
 * This software is provided ``AS IS'' without any warranties of any kind.
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/msg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ipcs.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SYSV_MSG</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">msginit</span>(<span class="enscript-type">void</span> *);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MSG_DEBUG</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>

<span class="enscript-comment">/* Uncomment this line to see MAC debugging output. */</span>
<span class="enscript-comment">/* #define	MAC_DEBUG */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_DEBUG</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MPRINTF</span>(a)	printf(a)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MPRINTF</span>(a)
#<span class="enscript-reference">endif</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">msg_freehdr</span>(<span class="enscript-type">struct</span> msg *msghdr);

<span class="enscript-type">typedef</span> <span class="enscript-type">int</span>     <span class="enscript-function-name">sy_call_t</span>(<span class="enscript-type">struct</span> proc *, <span class="enscript-type">void</span> *, <span class="enscript-type">int</span> *);

<span class="enscript-comment">/* XXX casting to (sy_call_t *) is bogus, as usual. */</span>
<span class="enscript-type">static</span> sy_call_t *msgcalls[] = {
	(sy_call_t *)msgctl, (sy_call_t *)msgget,
	(sy_call_t *)msgsnd, (sy_call_t *)msgrcv
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>		nfree_msgmaps;	<span class="enscript-comment">/* # of free map entries */</span>
<span class="enscript-type">static</span> <span class="enscript-type">short</span>		free_msgmaps;	<span class="enscript-comment">/* free map entries list head */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> msg	*free_msghdrs;	<span class="enscript-comment">/* list of free msg headers */</span>
<span class="enscript-type">char</span>			*msgpool;	<span class="enscript-comment">/* MSGMAX byte long msg buffer pool */</span>
<span class="enscript-type">struct</span> msgmap		*msgmaps;	<span class="enscript-comment">/* MSGSEG msgmap structures */</span>
<span class="enscript-type">struct</span> msg		*msghdrs;	<span class="enscript-comment">/* MSGTQL msg headers */</span>
<span class="enscript-type">struct</span> msqid_kernel	*msqids;	<span class="enscript-comment">/* MSGMNI msqid_kernel structs (wrapping user_msqid_ds structs) */</span>

<span class="enscript-type">static</span> lck_grp_t       *sysv_msg_subsys_lck_grp;
<span class="enscript-type">static</span> lck_grp_attr_t  *sysv_msg_subsys_lck_grp_attr;
<span class="enscript-type">static</span> lck_attr_t      *sysv_msg_subsys_lck_attr;
<span class="enscript-type">static</span> lck_mtx_t        sysv_msg_subsys_mutex;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SYSV_MSG_SUBSYS_LOCK</span>() lck_mtx_lock(&amp;sysv_msg_subsys_mutex)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SYSV_MSG_SUBSYS_UNLOCK</span>() lck_mtx_unlock(&amp;sysv_msg_subsys_mutex)

<span class="enscript-type">void</span> <span class="enscript-function-name">sysv_msg_lock_init</span>(<span class="enscript-type">void</span>);


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE_API_PRIVATE</span>
	<span class="enscript-type">int</span>	msgmax,		<span class="enscript-comment">/* max chars in a message */</span>
		msgmni,		<span class="enscript-comment">/* max message queue identifiers */</span>
		msgmnb,		<span class="enscript-comment">/* max chars in a queue */</span>
		msgtql,		<span class="enscript-comment">/* max messages in system */</span>
		msgssz,		<span class="enscript-comment">/* size of a message segment (see notes above) */</span>
		msgseg;		<span class="enscript-comment">/* number of message segments */</span>
<span class="enscript-type">struct</span> msginfo msginfo = {
		MSGMAX,		<span class="enscript-comment">/* = (MSGSSZ*MSGSEG) : max chars in a message */</span>
		MSGMNI,		<span class="enscript-comment">/* = 40 : max message queue identifiers */</span>
		MSGMNB,		<span class="enscript-comment">/* = 2048 : max chars in a queue */</span>
		MSGTQL,		<span class="enscript-comment">/* = 40 : max messages in system */</span>
		MSGSSZ,		<span class="enscript-comment">/* = 8 : size of a message segment (2^N long) */</span>
		MSGSEG		<span class="enscript-comment">/* = 2048 : number of message segments */</span>
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __APPLE_API_PRIVATE */</span>

<span class="enscript-comment">/* Initialize the mutex governing access to the SysV msg subsystem */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">sysv_msg_lock_init</span>( <span class="enscript-type">void</span> )
{
	sysv_msg_subsys_lck_grp_attr = lck_grp_attr_alloc_init();

	sysv_msg_subsys_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;sysv_msg_subsys_lock&quot;</span>, sysv_msg_subsys_lck_grp_attr);

	sysv_msg_subsys_lck_attr = lck_attr_alloc_init();
	lck_mtx_init(&amp;sysv_msg_subsys_mutex, sysv_msg_subsys_lck_grp, sysv_msg_subsys_lck_attr);
}

<span class="enscript-type">static</span> __inline__ user_time_t
<span class="enscript-function-name">sysv_msgtime</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> timeval	tv;
	microtime(&amp;tv);
	<span class="enscript-keyword">return</span> (tv.tv_sec);
}

<span class="enscript-comment">/*
 * NOTE: Source and target may *NOT* overlap! (target is smaller)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">msqid_ds_kerneltouser32</span>(<span class="enscript-type">struct</span> user_msqid_ds *in, <span class="enscript-type">struct</span> user32_msqid_ds *out)
{
	out-&gt;msg_perm	= in-&gt;msg_perm;
	out-&gt;msg_qnum	= in-&gt;msg_qnum;
	out-&gt;msg_cbytes	= in-&gt;msg_cbytes;	<span class="enscript-comment">/* for ipcs */</span>
	out-&gt;msg_qbytes	= in-&gt;msg_qbytes;
	out-&gt;msg_lspid	= in-&gt;msg_lspid;
	out-&gt;msg_lrpid	= in-&gt;msg_lrpid;
	out-&gt;msg_stime	= in-&gt;msg_stime;	<span class="enscript-comment">/* XXX loss of range */</span>
	out-&gt;msg_rtime	= in-&gt;msg_rtime;	<span class="enscript-comment">/* XXX loss of range */</span>
	out-&gt;msg_ctime	= in-&gt;msg_ctime;	<span class="enscript-comment">/* XXX loss of range */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">msqid_ds_kerneltouser64</span>(<span class="enscript-type">struct</span> user_msqid_ds *in, <span class="enscript-type">struct</span> user64_msqid_ds *out)
{
	out-&gt;msg_perm	= in-&gt;msg_perm;
	out-&gt;msg_qnum	= in-&gt;msg_qnum;
	out-&gt;msg_cbytes	= in-&gt;msg_cbytes;	<span class="enscript-comment">/* for ipcs */</span>
	out-&gt;msg_qbytes	= in-&gt;msg_qbytes;
	out-&gt;msg_lspid	= in-&gt;msg_lspid;
	out-&gt;msg_lrpid	= in-&gt;msg_lrpid;
	out-&gt;msg_stime	= in-&gt;msg_stime;	<span class="enscript-comment">/* XXX loss of range */</span>
	out-&gt;msg_rtime	= in-&gt;msg_rtime;	<span class="enscript-comment">/* XXX loss of range */</span>
	out-&gt;msg_ctime	= in-&gt;msg_ctime;	<span class="enscript-comment">/* XXX loss of range */</span>
}

<span class="enscript-comment">/*
 * NOTE: Source and target may are permitted to overlap! (source is smaller);
 * this works because we copy fields in order from the end of the struct to
 * the beginning.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">msqid_ds_user32tokernel</span>(<span class="enscript-type">struct</span> user32_msqid_ds *in, <span class="enscript-type">struct</span> user_msqid_ds *out)
{
	out-&gt;msg_ctime	= in-&gt;msg_ctime;
	out-&gt;msg_rtime	= in-&gt;msg_rtime;
	out-&gt;msg_stime	= in-&gt;msg_stime;
	out-&gt;msg_lrpid	= in-&gt;msg_lrpid;
	out-&gt;msg_lspid	= in-&gt;msg_lspid;
	out-&gt;msg_qbytes	= in-&gt;msg_qbytes;
	out-&gt;msg_cbytes	= in-&gt;msg_cbytes;	<span class="enscript-comment">/* for ipcs */</span>
	out-&gt;msg_qnum	= in-&gt;msg_qnum;
	out-&gt;msg_perm	= in-&gt;msg_perm;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">msqid_ds_user64tokernel</span>(<span class="enscript-type">struct</span> user64_msqid_ds *in, <span class="enscript-type">struct</span> user_msqid_ds *out)
{
	out-&gt;msg_ctime	= in-&gt;msg_ctime;
	out-&gt;msg_rtime	= in-&gt;msg_rtime;
	out-&gt;msg_stime	= in-&gt;msg_stime;
	out-&gt;msg_lrpid	= in-&gt;msg_lrpid;
	out-&gt;msg_lspid	= in-&gt;msg_lspid;
	out-&gt;msg_qbytes	= in-&gt;msg_qbytes;
	out-&gt;msg_cbytes	= in-&gt;msg_cbytes;	<span class="enscript-comment">/* for ipcs */</span>
	out-&gt;msg_qnum	= in-&gt;msg_qnum;
	out-&gt;msg_perm	= in-&gt;msg_perm;
}

<span class="enscript-comment">/* This routine assumes the system is locked prior to calling this routine */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">msginit</span>(__unused <span class="enscript-type">void</span> *dummy)
{
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> initted = 0;
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> i;

	<span class="enscript-comment">/* Lazy initialization on first system call; we don't have SYSINIT(). */</span>
	<span class="enscript-keyword">if</span> (initted)
		<span class="enscript-keyword">return</span> (initted);

	<span class="enscript-comment">/*
	 * msginfo.msgssz should be a power of two for efficiency reasons.
	 * It is also pretty silly if msginfo.msgssz is less than 8
	 * or greater than about 256 so ...
	 */</span>
	i = 8;
	<span class="enscript-keyword">while</span> (i &lt; 1024 &amp;&amp; i != msginfo.msgssz)
		i &lt;&lt;= 1;
    	<span class="enscript-keyword">if</span> (i != msginfo.msgssz) {
		printf(<span class="enscript-string">&quot;msginfo.msgssz=%d (0x%x) not a small power of 2; resetting to %d\n&quot;</span>, msginfo.msgssz, msginfo.msgssz, MSGSSZ);
		msginfo.msgssz = MSGSSZ;
	}

	<span class="enscript-keyword">if</span> (msginfo.msgseg &gt; 32767) {
		printf(<span class="enscript-string">&quot;msginfo.msgseg=%d (&gt; 32767); resetting to %d\n&quot;</span>, msginfo.msgseg, MSGSEG);
		msginfo.msgseg = MSGSEG;
	}


	<span class="enscript-comment">/*
	 * Allocate memory for message pool, maps, headers, and queue IDs;
	 * if this fails, fail safely and leave it uninitialized (related
	 * system calls will fail).
	 */</span>
	msgpool = (<span class="enscript-type">char</span> *)_MALLOC(msginfo.msgmax, M_SHM, M_WAITOK);
	<span class="enscript-keyword">if</span> (msgpool == NULL) {
		printf(<span class="enscript-string">&quot;msginit: can't allocate msgpool&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	MALLOC(msgmaps, <span class="enscript-type">struct</span> msgmap *,
			<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> msgmap) * msginfo.msgseg, 
			M_SHM, M_WAITOK);
	<span class="enscript-keyword">if</span> (msgmaps == NULL) {
		printf(<span class="enscript-string">&quot;msginit: can't allocate msgmaps&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	MALLOC(msghdrs, <span class="enscript-type">struct</span> msg *,
			<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> msg) * msginfo.msgtql, 
			M_SHM, M_WAITOK);
	<span class="enscript-keyword">if</span> (msghdrs == NULL) {
		printf(<span class="enscript-string">&quot;msginit: can't allocate msghdrs&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	MALLOC(msqids, <span class="enscript-type">struct</span> msqid_kernel *,
			<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user_msqid_ds) * msginfo.msgmni, 
			M_SHM, M_WAITOK);
	<span class="enscript-keyword">if</span> (msqids == NULL) {
		printf(<span class="enscript-string">&quot;msginit: can't allocate msqids&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}


	<span class="enscript-comment">/* init msgmaps */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; msginfo.msgseg; i++) {
		<span class="enscript-keyword">if</span> (i &gt; 0)
			msgmaps[i-1].next = i;
		msgmaps[i].next = -1;	<span class="enscript-comment">/* implies entry is available */</span>
	}
	free_msgmaps = 0;
	nfree_msgmaps = msginfo.msgseg;


	<span class="enscript-comment">/* init msghdrs */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; msginfo.msgtql; i++) {
		msghdrs[i].msg_type = 0;
		<span class="enscript-keyword">if</span> (i &gt; 0)
			msghdrs[i-1].msg_next = &amp;msghdrs[i];
		msghdrs[i].msg_next = NULL;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_sysvmsg_label_init(&amp;msghdrs[i]);
#<span class="enscript-reference">endif</span>
    	}
	free_msghdrs = &amp;msghdrs[0];

	<span class="enscript-comment">/* init msqids */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; msginfo.msgmni; i++) {
		msqids[i].u.msg_qbytes = 0;	<span class="enscript-comment">/* implies entry is available */</span>
		msqids[i].u.msg_perm._seq = 0;	<span class="enscript-comment">/* reset to a known value */</span>
		msqids[i].u.msg_perm.mode = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_sysvmsq_label_init(&amp;msqids[i]);
#<span class="enscript-reference">endif</span>
	}

	initted = 1;
<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">if</span> (!initted) {
		<span class="enscript-keyword">if</span> (msgpool != NULL)
			_FREE(msgpool, M_SHM);
		<span class="enscript-keyword">if</span> (msgmaps != NULL)
			FREE(msgmaps, M_SHM);
		<span class="enscript-keyword">if</span> (msghdrs != NULL)
			FREE(msghdrs, M_SHM);
		<span class="enscript-keyword">if</span> (msqids != NULL)
			FREE(msqids, M_SHM);
	}
	<span class="enscript-keyword">return</span> (initted);
}

<span class="enscript-comment">/*
 * msgsys
 *
 * Entry point for all MSG calls: msgctl, msgget, msgsnd, msgrcv
 *
 * Parameters:	p	Process requesting the call
 * 		uap	User argument descriptor (see below)
 * 		retval	Return value of the selected msg call
 *
 * Indirect parameters:	uap-&gt;which	msg call to invoke (index in array of msg calls)
 * 			uap-&gt;a2		User argument descriptor
 *                  
 * Returns:	0	Success
 * 		!0	Not success
 *
 * Implicit returns: retval	Return value of the selected msg call
 *
 * DEPRECATED:  This interface should not be used to call the other MSG
 * 		functions (msgctl, msgget, msgsnd, msgrcv). The correct
 * 		usage is to call the other MSG functions directly.
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">msgsys</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> msgsys_args *uap, int32_t *retval)
{
	<span class="enscript-keyword">if</span> (uap-&gt;which &gt;= <span class="enscript-keyword">sizeof</span>(msgcalls)/<span class="enscript-keyword">sizeof</span>(msgcalls[0]))
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">return</span> ((*msgcalls[uap-&gt;which])(p, &amp;uap-&gt;a2, retval));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">msg_freehdr</span>(<span class="enscript-type">struct</span> msg *msghdr)
{
	<span class="enscript-keyword">while</span> (msghdr-&gt;msg_ts &gt; 0) {
		<span class="enscript-type">short</span> next;
		<span class="enscript-keyword">if</span> (msghdr-&gt;msg_spot &lt; 0 || msghdr-&gt;msg_spot &gt;= msginfo.msgseg)
			panic(<span class="enscript-string">&quot;msghdr-&gt;msg_spot out of range&quot;</span>);
		next = msgmaps[msghdr-&gt;msg_spot].next;
		msgmaps[msghdr-&gt;msg_spot].next = free_msgmaps;
		free_msgmaps = msghdr-&gt;msg_spot;
		nfree_msgmaps++;
		msghdr-&gt;msg_spot = next;
		<span class="enscript-keyword">if</span> (msghdr-&gt;msg_ts &gt;= msginfo.msgssz)
			msghdr-&gt;msg_ts -= msginfo.msgssz;
		<span class="enscript-keyword">else</span>
			msghdr-&gt;msg_ts = 0;
	}
	<span class="enscript-keyword">if</span> (msghdr-&gt;msg_spot != -1)
		panic(<span class="enscript-string">&quot;msghdr-&gt;msg_spot != -1&quot;</span>);
	msghdr-&gt;msg_next = free_msghdrs;
	free_msghdrs = msghdr;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_sysvmsg_label_recycle(msghdr);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Notify waiters that there are free message headers and segments
	 * now available.
	 */</span>
	wakeup((caddr_t)&amp;free_msghdrs);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">msgctl</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> msgctl_args *uap, int32_t *retval)
{
	<span class="enscript-type">int</span> msqid = uap-&gt;msqid;
	<span class="enscript-type">int</span> cmd = uap-&gt;cmd;
	kauth_cred_t cred = kauth_cred_get();
	<span class="enscript-type">int</span> rval, eval;
	<span class="enscript-type">struct</span> user_msqid_ds msqbuf;
	<span class="enscript-type">struct</span> msqid_kernel *msqptr;

	SYSV_MSG_SUBSYS_LOCK();

	<span class="enscript-keyword">if</span> (!msginit(0)) {
		eval =  ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgctlout</span>;
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
	printf(<span class="enscript-string">&quot;call to msgctl(%d, %d, 0x%qx)\n&quot;</span>, msqid, cmd, uap-&gt;buf);
#<span class="enscript-reference">endif</span>

	AUDIT_ARG(svipc_cmd, cmd);
	AUDIT_ARG(svipc_id, msqid);
	msqid = IPCID_TO_IX(msqid);

	<span class="enscript-keyword">if</span> (msqid &lt; 0 || msqid &gt;= msginfo.msgmni) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;msqid (%d) out of range (0&lt;=msqid&lt;%d)\n&quot;</span>, msqid,
		    msginfo.msgmni);
#<span class="enscript-reference">endif</span>
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgctlout</span>;
	}

	msqptr = &amp;msqids[msqid];

	<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_qbytes == 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;no such msqid\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgctlout</span>;
	}
	<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_perm._seq != IPCID_TO_SEQ(uap-&gt;msqid)) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;wrong sequence number\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgctlout</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	eval = mac_sysvmsq_check_msqctl(kauth_cred_get(), msqptr, cmd);
	<span class="enscript-keyword">if</span> (eval) 
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgctlout</span>;
#<span class="enscript-reference">endif</span>

	eval = 0;
	rval = 0;

	<span class="enscript-keyword">switch</span> (cmd) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPC_RMID</span>:
	{
		<span class="enscript-type">struct</span> msg *msghdr;
		<span class="enscript-keyword">if</span> ((eval = ipcperm(cred, &amp;msqptr-&gt;u.msg_perm, IPC_M)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgctlout</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-comment">/*
		 * Check that the thread has MAC access permissions to
		 * individual msghdrs.  Note: We need to do this in a
		 * separate loop because the actual loop alters the
		 * msq/msghdr info as it progresses, and there is no going
		 * back if half the way through we discover that the
		 * thread cannot free a certain msghdr.  The msq will get
		 * into an inconsistent state.
		 */</span>
		<span class="enscript-keyword">for</span> (msghdr = msqptr-&gt;u.msg_first; msghdr != NULL;
		    msghdr = msghdr-&gt;msg_next) {
			eval = mac_sysvmsq_check_msgrmid(kauth_cred_get(), msghdr);
			<span class="enscript-keyword">if</span> (eval) 
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgctlout</span>;
		}
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/* Free the message headers */</span>
		msghdr = msqptr-&gt;u.msg_first;
		<span class="enscript-keyword">while</span> (msghdr != NULL) {
			<span class="enscript-type">struct</span> msg *msghdr_tmp;

			<span class="enscript-comment">/* Free the segments of each message */</span>
			msqptr-&gt;u.msg_cbytes -= msghdr-&gt;msg_ts;
			msqptr-&gt;u.msg_qnum--;
			msghdr_tmp = msghdr;
			msghdr = msghdr-&gt;msg_next;
			msg_freehdr(msghdr_tmp);
		}

		<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_cbytes != 0)
			panic(<span class="enscript-string">&quot;msg_cbytes is messed up&quot;</span>);
		<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_qnum != 0)
			panic(<span class="enscript-string">&quot;msg_qnum is messed up&quot;</span>);

		msqptr-&gt;u.msg_qbytes = 0;	<span class="enscript-comment">/* Mark it as free */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_sysvmsq_label_recycle(msqptr);
#<span class="enscript-reference">endif</span>

		wakeup((caddr_t)msqptr);
	}

		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPC_SET</span>:
		<span class="enscript-keyword">if</span> ((eval = ipcperm(cred, &amp;msqptr-&gt;u.msg_perm, IPC_M)))
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgctlout</span>;

		SYSV_MSG_SUBSYS_UNLOCK();

		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			<span class="enscript-type">struct</span> user64_msqid_ds tmpds;
			eval = copyin(uap-&gt;buf, &amp;tmpds, <span class="enscript-keyword">sizeof</span>(tmpds));

			msqid_ds_user64tokernel(&amp;tmpds, &amp;msqbuf);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_msqid_ds tmpds;

			eval = copyin(uap-&gt;buf, &amp;tmpds, <span class="enscript-keyword">sizeof</span>(tmpds));

			msqid_ds_user32tokernel(&amp;tmpds, &amp;msqbuf);
		}
		<span class="enscript-keyword">if</span> (eval)
			<span class="enscript-keyword">return</span>(eval);

		SYSV_MSG_SUBSYS_LOCK();

		<span class="enscript-keyword">if</span> (msqbuf.msg_qbytes &gt; msqptr-&gt;u.msg_qbytes) {
			eval = suser(cred, &amp;p-&gt;p_acflag);
			<span class="enscript-keyword">if</span> (eval)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgctlout</span>;
		}


		<span class="enscript-comment">/* compare (msglen_t) value against restrict (int) value */</span>
		<span class="enscript-keyword">if</span> (msqbuf.msg_qbytes &gt; (user_msglen_t)msginfo.msgmnb) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;can't increase msg_qbytes beyond %d (truncating)\n&quot;</span>,
			    msginfo.msgmnb);
#<span class="enscript-reference">endif</span>
			msqbuf.msg_qbytes = msginfo.msgmnb;	<span class="enscript-comment">/* silently restrict qbytes to system limit */</span>
		}
		<span class="enscript-keyword">if</span> (msqbuf.msg_qbytes == 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;can't reduce msg_qbytes to 0\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			eval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgctlout</span>;
		}
		msqptr-&gt;u.msg_perm.uid = msqbuf.msg_perm.uid;	<span class="enscript-comment">/* change the owner */</span>
		msqptr-&gt;u.msg_perm.gid = msqbuf.msg_perm.gid;	<span class="enscript-comment">/* change the owner */</span>
		msqptr-&gt;u.msg_perm.mode = (msqptr-&gt;u.msg_perm.mode &amp; ~0777) |
		    (msqbuf.msg_perm.mode &amp; 0777);
		msqptr-&gt;u.msg_qbytes = msqbuf.msg_qbytes;
		msqptr-&gt;u.msg_ctime = sysv_msgtime();
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPC_STAT</span>:
		<span class="enscript-keyword">if</span> ((eval = ipcperm(cred, &amp;msqptr-&gt;u.msg_perm, IPC_R))) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;requester doesn't have read access\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgctlout</span>;
		}

		SYSV_MSG_SUBSYS_UNLOCK();
		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			<span class="enscript-type">struct</span> user64_msqid_ds msqid_ds64;
			msqid_ds_kerneltouser64(&amp;msqptr-&gt;u, &amp;msqid_ds64);
			eval = copyout(&amp;msqid_ds64, uap-&gt;buf, <span class="enscript-keyword">sizeof</span>(msqid_ds64));
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_msqid_ds msqid_ds32;
			msqid_ds_kerneltouser32(&amp;msqptr-&gt;u, &amp;msqid_ds32);
			eval = copyout(&amp;msqid_ds32, uap-&gt;buf, <span class="enscript-keyword">sizeof</span>(msqid_ds32));
		}
		SYSV_MSG_SUBSYS_LOCK();
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;invalid command %d\n&quot;</span>, cmd);
#<span class="enscript-reference">endif</span>
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgctlout</span>;
	}

	<span class="enscript-keyword">if</span> (eval == 0)
		*retval = rval;
<span class="enscript-reference">msgctlout</span>:
	SYSV_MSG_SUBSYS_UNLOCK();
	<span class="enscript-keyword">return</span>(eval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">msgget</span>(__unused <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> msgget_args *uap, int32_t *retval)
{
	<span class="enscript-type">int</span> msqid, eval;
	<span class="enscript-type">int</span> key = uap-&gt;key;
	<span class="enscript-type">int</span> msgflg = uap-&gt;msgflg;
	kauth_cred_t cred = kauth_cred_get();
	<span class="enscript-type">struct</span> msqid_kernel *msqptr = NULL;

	SYSV_MSG_SUBSYS_LOCK();

	<span class="enscript-keyword">if</span> (!msginit(0)) {
		eval =  ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msggetout</span>;
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
	printf(<span class="enscript-string">&quot;msgget(0x%x, 0%o)\n&quot;</span>, key, msgflg);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (key != IPC_PRIVATE) {
		<span class="enscript-keyword">for</span> (msqid = 0; msqid &lt; msginfo.msgmni; msqid++) {
			msqptr = &amp;msqids[msqid];
			<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_qbytes != 0 &amp;&amp;
			    msqptr-&gt;u.msg_perm._key == key)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (msqid &lt; msginfo.msgmni) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;found public key\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> ((msgflg &amp; IPC_CREAT) &amp;&amp; (msgflg &amp; IPC_EXCL)) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
				printf(<span class="enscript-string">&quot;not exclusive\n&quot;</span>);
#<span class="enscript-reference">endif</span>
				eval = EEXIST;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">msggetout</span>;
			}
			<span class="enscript-keyword">if</span> ((eval = ipcperm(cred, &amp;msqptr-&gt;u.msg_perm, msgflg &amp; 0700 ))) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
				printf(<span class="enscript-string">&quot;requester doesn't have 0%o access\n&quot;</span>,
				    msgflg &amp; 0700);
#<span class="enscript-reference">endif</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">msggetout</span>;
			}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
			eval = mac_sysvmsq_check_msqget(cred, msqptr);
			<span class="enscript-keyword">if</span> (eval) 
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">msggetout</span>;
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;
		}
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
	printf(<span class="enscript-string">&quot;need to allocate the user_msqid_ds\n&quot;</span>);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (key == IPC_PRIVATE || (msgflg &amp; IPC_CREAT)) {
		<span class="enscript-keyword">for</span> (msqid = 0; msqid &lt; msginfo.msgmni; msqid++) {
			<span class="enscript-comment">/*
			 * Look for an unallocated and unlocked user_msqid_ds.
			 * user_msqid_ds's can be locked by msgsnd or msgrcv
			 * while they are copying the message in/out.  We
			 * can't re-use the entry until they release it.
			 */</span>
			msqptr = &amp;msqids[msqid];
			<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_qbytes == 0 &amp;&amp;
			    (msqptr-&gt;u.msg_perm.mode &amp; MSG_LOCKED) == 0)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (msqid == msginfo.msgmni) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;no more user_msqid_ds's available\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			eval = ENOSPC;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">msggetout</span>;
		}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;msqid %d is available\n&quot;</span>, msqid);
#<span class="enscript-reference">endif</span>
		msqptr-&gt;u.msg_perm._key = key;
		msqptr-&gt;u.msg_perm.cuid = kauth_cred_getuid(cred);
		msqptr-&gt;u.msg_perm.uid = kauth_cred_getuid(cred);
		msqptr-&gt;u.msg_perm.cgid = kauth_cred_getgid(cred);
		msqptr-&gt;u.msg_perm.gid = kauth_cred_getgid(cred);
		msqptr-&gt;u.msg_perm.mode = (msgflg &amp; 0777);
		<span class="enscript-comment">/* Make sure that the returned msqid is unique */</span>
		msqptr-&gt;u.msg_perm._seq++;
		msqptr-&gt;u.msg_first = NULL;
		msqptr-&gt;u.msg_last = NULL;
		msqptr-&gt;u.msg_cbytes = 0;
		msqptr-&gt;u.msg_qnum = 0;
		msqptr-&gt;u.msg_qbytes = msginfo.msgmnb;
		msqptr-&gt;u.msg_lspid = 0;
		msqptr-&gt;u.msg_lrpid = 0;
		msqptr-&gt;u.msg_stime = 0;
		msqptr-&gt;u.msg_rtime = 0;
		msqptr-&gt;u.msg_ctime = sysv_msgtime();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_sysvmsq_label_associate(cred, msqptr);
#<span class="enscript-reference">endif</span>
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;didn't find it and wasn't asked to create it\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		eval = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msggetout</span>;
	}

<span class="enscript-reference">found</span>:
	<span class="enscript-comment">/* Construct the unique msqid */</span>
	*retval = IXSEQ_TO_IPCID(msqid, msqptr-&gt;u.msg_perm);
	AUDIT_ARG(svipc_id, *retval);
	eval = 0;
<span class="enscript-reference">msggetout</span>:
	SYSV_MSG_SUBSYS_UNLOCK();
	<span class="enscript-keyword">return</span>(eval);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">msgsnd</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> msgsnd_args *uap, int32_t *retval)
{
	__pthread_testcancel(1);
	<span class="enscript-keyword">return</span>(msgsnd_nocancel(p, (<span class="enscript-type">struct</span> msgsnd_nocancel_args *)uap, retval));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">msgsnd_nocancel</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> msgsnd_nocancel_args *uap, int32_t *retval)
{
	<span class="enscript-type">int</span> msqid = uap-&gt;msqid;
	user_addr_t user_msgp = uap-&gt;msgp;
	size_t msgsz = (size_t)uap-&gt;msgsz;	<span class="enscript-comment">/* limit to 4G */</span>
	<span class="enscript-type">int</span> msgflg = uap-&gt;msgflg;
	<span class="enscript-type">int</span> segs_needed, eval;
	<span class="enscript-type">struct</span> msqid_kernel *msqptr;
	<span class="enscript-type">struct</span> msg *msghdr;
	<span class="enscript-type">short</span> next;
	user_long_t msgtype;


	SYSV_MSG_SUBSYS_LOCK();

	<span class="enscript-keyword">if</span> (!msginit(0)) {
		eval =  ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgsndout</span>;
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
	printf(<span class="enscript-string">&quot;call to msgsnd(%d, 0x%qx, %ld, %d)\n&quot;</span>, msqid, user_msgp, msgsz,
	    msgflg);
#<span class="enscript-reference">endif</span>

	AUDIT_ARG(svipc_id, msqid);
	msqid = IPCID_TO_IX(msqid);

	<span class="enscript-keyword">if</span> (msqid &lt; 0 || msqid &gt;= msginfo.msgmni) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;msqid (%d) out of range (0&lt;=msqid&lt;%d)\n&quot;</span>, msqid,
		    msginfo.msgmni);
#<span class="enscript-reference">endif</span>
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgsndout</span>;
	}

	msqptr = &amp;msqids[msqid];
	<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_qbytes == 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;no such message queue id\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgsndout</span>;
	}
	<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_perm._seq != IPCID_TO_SEQ(uap-&gt;msqid)) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;wrong sequence number\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgsndout</span>;
	}

	<span class="enscript-keyword">if</span> ((eval = ipcperm(kauth_cred_get(), &amp;msqptr-&gt;u.msg_perm, IPC_W))) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;requester doesn't have write access\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgsndout</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	eval = mac_sysvmsq_check_msqsnd(kauth_cred_get(), msqptr);
	<span class="enscript-keyword">if</span> (eval) 
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgsndout</span>;
#<span class="enscript-reference">endif</span>
	segs_needed = (msgsz + msginfo.msgssz - 1) / msginfo.msgssz;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
	printf(<span class="enscript-string">&quot;msgsz=%ld, msgssz=%d, segs_needed=%d\n&quot;</span>, msgsz, msginfo.msgssz,
	    segs_needed);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * If we suffer resource starvation, we will sleep in this loop and
	 * wait for more resources to become available.  This is a loop to
	 * ensure reacquisition of the mutex following any sleep, since there
	 * are multiple resources under contention.
	 */</span>
	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-type">void</span> *blocking_resource = NULL;

		<span class="enscript-comment">/*
		 * Check that we have not had the maximum message size change
		 * out from under us and render our message invalid while we
		 * slept waiting for some resource.
		 */</span>
		<span class="enscript-keyword">if</span> (msgsz &gt; msqptr-&gt;u.msg_qbytes) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;msgsz &gt; msqptr-&gt;msg_qbytes\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			eval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgsndout</span>;
		}

		<span class="enscript-comment">/*
		 * If the user_msqid_ds is already locked, we need to sleep on
		 * the queue until it's unlocked.
		 */</span>
		<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_perm.mode &amp; MSG_LOCKED) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;msqid is locked\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			blocking_resource = msqptr;
		}

		<span class="enscript-comment">/*
		 * If our message plus the messages already in the queue would
		 * cause us to exceed the maximum number of bytes wer are
		 * permitted to queue, then block on the queue until it drains.
		 */</span>
		<span class="enscript-keyword">if</span> (msgsz + msqptr-&gt;u.msg_cbytes &gt; msqptr-&gt;u.msg_qbytes) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;msgsz + msg_cbytes &gt; msg_qbytes\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			blocking_resource = msqptr;
		}

		<span class="enscript-comment">/*
		 * Both message maps and message headers are protected by
		 * sleeping on the address of the pointer to the list of free
		 * message headers, since they are allocated and freed in
		 * tandem.
		 */</span>
		<span class="enscript-keyword">if</span> (segs_needed &gt; nfree_msgmaps) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;segs_needed &gt; nfree_msgmaps\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			blocking_resource = &amp;free_msghdrs;
		}
		<span class="enscript-keyword">if</span> (free_msghdrs == NULL) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;no more msghdrs\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			blocking_resource = &amp;free_msghdrs;
		}

		<span class="enscript-keyword">if</span> (blocking_resource != NULL) {
			<span class="enscript-type">int</span> we_own_it;

			<span class="enscript-keyword">if</span> ((msgflg &amp; IPC_NOWAIT) != 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
				printf(<span class="enscript-string">&quot;need more resources but caller doesn't want to wait\n&quot;</span>);
#<span class="enscript-reference">endif</span>
				eval = EAGAIN;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgsndout</span>;
			}

			<span class="enscript-keyword">if</span> ((msqptr-&gt;u.msg_perm.mode &amp; MSG_LOCKED) != 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
				printf(<span class="enscript-string">&quot;we don't own the user_msqid_ds\n&quot;</span>);
#<span class="enscript-reference">endif</span>
				we_own_it = 0;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* Force later arrivals to wait for our
				   request */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
				printf(<span class="enscript-string">&quot;we own the user_msqid_ds\n&quot;</span>);
#<span class="enscript-reference">endif</span>
				msqptr-&gt;u.msg_perm.mode |= MSG_LOCKED;
				we_own_it = 1;
			}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;goodnight\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			eval = msleep(blocking_resource, &amp;sysv_msg_subsys_mutex, (PZERO - 4) | PCATCH,
			    <span class="enscript-string">&quot;msgwait&quot;</span>, 0);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;good morning, eval=%d\n&quot;</span>, eval);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> (we_own_it)
				msqptr-&gt;u.msg_perm.mode &amp;= ~MSG_LOCKED;
			<span class="enscript-keyword">if</span> (eval != 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
				printf(<span class="enscript-string">&quot;msgsnd:  interrupted system call\n&quot;</span>);
#<span class="enscript-reference">endif</span>
				eval = EINTR;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgsndout</span>;
			}

			<span class="enscript-comment">/*
			 * Make sure that the msq queue still exists
			 */</span>

			<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_qbytes == 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
				printf(<span class="enscript-string">&quot;msqid deleted\n&quot;</span>);
#<span class="enscript-reference">endif</span>
				eval = EIDRM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgsndout</span>;
			
			}

		} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;got all the resources that we need\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-comment">/*
	 * We have the resources that we need.
	 * Make sure!
	 */</span>

	<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_perm.mode &amp; MSG_LOCKED)
		panic(<span class="enscript-string">&quot;msg_perm.mode &amp; MSG_LOCKED&quot;</span>);
	<span class="enscript-keyword">if</span> (segs_needed &gt; nfree_msgmaps)
		panic(<span class="enscript-string">&quot;segs_needed &gt; nfree_msgmaps&quot;</span>);
	<span class="enscript-keyword">if</span> (msgsz + msqptr-&gt;u.msg_cbytes &gt; msqptr-&gt;u.msg_qbytes)
		panic(<span class="enscript-string">&quot;msgsz + msg_cbytes &gt; msg_qbytes&quot;</span>);
	<span class="enscript-keyword">if</span> (free_msghdrs == NULL)
		panic(<span class="enscript-string">&quot;no more msghdrs&quot;</span>);

	<span class="enscript-comment">/*
	 * Re-lock the user_msqid_ds in case we page-fault when copying in
	 * the message
	 */</span>
	<span class="enscript-keyword">if</span> ((msqptr-&gt;u.msg_perm.mode &amp; MSG_LOCKED) != 0)
		panic(<span class="enscript-string">&quot;user_msqid_ds is already locked&quot;</span>);
	msqptr-&gt;u.msg_perm.mode |= MSG_LOCKED;

	<span class="enscript-comment">/*
	 * Allocate a message header
	 */</span>
	msghdr = free_msghdrs;
	free_msghdrs = msghdr-&gt;msg_next;
	msghdr-&gt;msg_spot = -1;
	msghdr-&gt;msg_ts = msgsz;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	mac_sysvmsg_label_associate(kauth_cred_get(), msqptr, msghdr);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Allocate space for the message
	 */</span>

	<span class="enscript-keyword">while</span> (segs_needed &gt; 0) {
		<span class="enscript-keyword">if</span> (nfree_msgmaps &lt;= 0)
			panic(<span class="enscript-string">&quot;not enough msgmaps&quot;</span>);
		<span class="enscript-keyword">if</span> (free_msgmaps == -1)
			panic(<span class="enscript-string">&quot;nil free_msgmaps&quot;</span>);
		next = free_msgmaps;
		<span class="enscript-keyword">if</span> (next &lt;= -1)
			panic(<span class="enscript-string">&quot;next too low #1&quot;</span>);
		<span class="enscript-keyword">if</span> (next &gt;= msginfo.msgseg)
			panic(<span class="enscript-string">&quot;next out of range #1&quot;</span>);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;allocating segment %d to message\n&quot;</span>, next);
#<span class="enscript-reference">endif</span>
		free_msgmaps = msgmaps[next].next;
		nfree_msgmaps--;
		msgmaps[next].next = msghdr-&gt;msg_spot;
		msghdr-&gt;msg_spot = next;
		segs_needed--;
	}

	<span class="enscript-comment">/*
	 * Copy in the message type.  For a 64 bit process, this is 64 bits,
	 * but we only ever use the low 32 bits, so the cast is OK.
	 */</span>
	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		SYSV_MSG_SUBSYS_UNLOCK();
		eval = copyin(user_msgp, &amp;msgtype, <span class="enscript-keyword">sizeof</span>(msgtype));
		SYSV_MSG_SUBSYS_LOCK();
		msghdr-&gt;msg_type = CAST_DOWN(<span class="enscript-type">long</span>,msgtype);
		user_msgp = user_msgp + <span class="enscript-keyword">sizeof</span>(msgtype);	<span class="enscript-comment">/* ptr math */</span>
	} <span class="enscript-keyword">else</span> {
		SYSV_MSG_SUBSYS_UNLOCK();
		int32_t msg_type32;
		eval = copyin(user_msgp, &amp;msg_type32, <span class="enscript-keyword">sizeof</span>(msg_type32));
		msghdr-&gt;msg_type = msg_type32;
		SYSV_MSG_SUBSYS_LOCK();
		user_msgp = user_msgp + <span class="enscript-keyword">sizeof</span>(msg_type32);		<span class="enscript-comment">/* ptr math */</span>
	}

	<span class="enscript-keyword">if</span> (eval != 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;error %d copying the message type\n&quot;</span>, eval);
#<span class="enscript-reference">endif</span>
		msg_freehdr(msghdr);
		msqptr-&gt;u.msg_perm.mode &amp;= ~MSG_LOCKED;
		wakeup((caddr_t)msqptr);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgsndout</span>;
	}


	<span class="enscript-comment">/*
	 * Validate the message type
	 */</span>
	<span class="enscript-keyword">if</span> (msghdr-&gt;msg_type &lt; 1) {
		msg_freehdr(msghdr);
		msqptr-&gt;u.msg_perm.mode &amp;= ~MSG_LOCKED;
		wakeup((caddr_t)msqptr);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;mtype (%ld) &lt; 1\n&quot;</span>, msghdr-&gt;msg_type);
#<span class="enscript-reference">endif</span>
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgsndout</span>;
	}

	<span class="enscript-comment">/*
	 * Copy in the message body
	 */</span>
	next = msghdr-&gt;msg_spot;
	<span class="enscript-keyword">while</span> (msgsz &gt; 0) {
		size_t tlen;
		<span class="enscript-comment">/* compare input (size_t) value against restrict (int) value */</span>
		<span class="enscript-keyword">if</span> (msgsz &gt; (size_t)msginfo.msgssz)
			tlen = msginfo.msgssz;
		<span class="enscript-keyword">else</span>
			tlen = msgsz;
		<span class="enscript-keyword">if</span> (next &lt;= -1)
			panic(<span class="enscript-string">&quot;next too low #2&quot;</span>);
		<span class="enscript-keyword">if</span> (next &gt;= msginfo.msgseg)
			panic(<span class="enscript-string">&quot;next out of range #2&quot;</span>);

		SYSV_MSG_SUBSYS_UNLOCK();
		eval = copyin(user_msgp, &amp;msgpool[next * msginfo.msgssz], tlen);
		SYSV_MSG_SUBSYS_LOCK();

		<span class="enscript-keyword">if</span> (eval != 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;error %d copying in message segment\n&quot;</span>, eval);
#<span class="enscript-reference">endif</span>
			msg_freehdr(msghdr);
			msqptr-&gt;u.msg_perm.mode &amp;= ~MSG_LOCKED;
			wakeup((caddr_t)msqptr);

			<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgsndout</span>;
		}
		msgsz -= tlen;
		user_msgp = user_msgp + tlen;	<span class="enscript-comment">/* ptr math */</span>
		next = msgmaps[next].next;
	}
	<span class="enscript-keyword">if</span> (next != -1)
		panic(<span class="enscript-string">&quot;didn't use all the msg segments&quot;</span>);

	<span class="enscript-comment">/*
	 * We've got the message.  Unlock the user_msqid_ds.
	 */</span>

	msqptr-&gt;u.msg_perm.mode &amp;= ~MSG_LOCKED;

	<span class="enscript-comment">/*
	 * Make sure that the user_msqid_ds is still allocated.
	 */</span>

	<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_qbytes == 0) {
		msg_freehdr(msghdr);
		wakeup((caddr_t)msqptr);
		<span class="enscript-comment">/* The SVID says to return EIDRM. */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">EIDRM</span>
		eval = EIDRM;
#<span class="enscript-reference">else</span>
		<span class="enscript-comment">/* Unfortunately, BSD doesn't define that code yet! */</span>
		eval = EINVAL;
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgsndout</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/*
	 * Note: Since the task/thread allocates the msghdr and usually
	 * primes it with its own MAC label, for a majority of policies, it
	 * won't be necessary to check whether the msghdr has access
	 * permissions to the msgq.  The mac_sysvmsq_check_msqsnd check would
	 * suffice in that case.  However, this hook may be required where
	 * individual policies derive a non-identical label for the msghdr
	 * from the current thread label and may want to check the msghdr
	 * enqueue permissions, along with read/write permissions to the
	 * msgq.
	 */</span>
	eval = mac_sysvmsq_check_enqueue(kauth_cred_get(), msghdr, msqptr);
	<span class="enscript-keyword">if</span> (eval) {
		msg_freehdr(msghdr);
		wakeup((caddr_t) msqptr);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgsndout</span>;
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Put the message into the queue
	 */</span>

	<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_first == NULL) {
		msqptr-&gt;u.msg_first = msghdr;
		msqptr-&gt;u.msg_last = msghdr;
	} <span class="enscript-keyword">else</span> {
		msqptr-&gt;u.msg_last-&gt;msg_next = msghdr;
		msqptr-&gt;u.msg_last = msghdr;
	}
	msqptr-&gt;u.msg_last-&gt;msg_next = NULL;

	msqptr-&gt;u.msg_cbytes += msghdr-&gt;msg_ts;
	msqptr-&gt;u.msg_qnum++;
	msqptr-&gt;u.msg_lspid = p-&gt;p_pid;
	msqptr-&gt;u.msg_stime = sysv_msgtime();

	wakeup((caddr_t)msqptr);
	*retval = 0;
	eval = 0;

<span class="enscript-reference">msgsndout</span>:
	SYSV_MSG_SUBSYS_UNLOCK();
	<span class="enscript-keyword">return</span>(eval);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">msgrcv</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> msgrcv_args *uap, user_ssize_t *retval)
{
	__pthread_testcancel(1);
	<span class="enscript-keyword">return</span>(msgrcv_nocancel(p, (<span class="enscript-type">struct</span> msgrcv_nocancel_args *)uap, retval));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">msgrcv_nocancel</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> msgrcv_nocancel_args *uap, user_ssize_t *retval)
{
	<span class="enscript-type">int</span> msqid = uap-&gt;msqid;
	user_addr_t user_msgp = uap-&gt;msgp;
	size_t msgsz = (size_t)uap-&gt;msgsz;	<span class="enscript-comment">/* limit to 4G */</span>
	<span class="enscript-type">long</span> msgtyp = (<span class="enscript-type">long</span>)uap-&gt;msgtyp;	<span class="enscript-comment">/* limit to 32 bits */</span>
	<span class="enscript-type">int</span> msgflg = uap-&gt;msgflg;
	size_t len;
	<span class="enscript-type">struct</span> msqid_kernel *msqptr;
	<span class="enscript-type">struct</span> msg *msghdr;
	<span class="enscript-type">int</span> eval;
	<span class="enscript-type">short</span> next;
	user_long_t msgtype;
	int32_t msg_type32;

	SYSV_MSG_SUBSYS_LOCK();

	<span class="enscript-keyword">if</span> (!msginit(0)) {
		eval =  ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgrcvout</span>;
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
	printf(<span class="enscript-string">&quot;call to msgrcv(%d, 0x%qx, %ld, %ld, %d)\n&quot;</span>, msqid, user_msgp,
	    msgsz, msgtyp, msgflg);
#<span class="enscript-reference">endif</span>

	AUDIT_ARG(svipc_id, msqid);
	msqid = IPCID_TO_IX(msqid);

	<span class="enscript-keyword">if</span> (msqid &lt; 0 || msqid &gt;= msginfo.msgmni) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;msqid (%d) out of range (0&lt;=msqid&lt;%d)\n&quot;</span>, msqid,
		    msginfo.msgmni);
#<span class="enscript-reference">endif</span>
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgrcvout</span>;
	}

	msqptr = &amp;msqids[msqid];
	<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_qbytes == 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;no such message queue id\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgrcvout</span>;
	}
	<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_perm._seq != IPCID_TO_SEQ(uap-&gt;msqid)) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;wrong sequence number\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgrcvout</span>;
	}

	<span class="enscript-keyword">if</span> ((eval = ipcperm(kauth_cred_get(), &amp;msqptr-&gt;u.msg_perm, IPC_R))) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;requester doesn't have read access\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgrcvout</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	eval = mac_sysvmsq_check_msqrcv(kauth_cred_get(), msqptr);
	<span class="enscript-keyword">if</span> (eval) 
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgrcvout</span>;
#<span class="enscript-reference">endif</span>
	msghdr = NULL;
	<span class="enscript-keyword">while</span> (msghdr == NULL) {
		<span class="enscript-keyword">if</span> (msgtyp == 0) {
			msghdr = msqptr-&gt;u.msg_first;
			<span class="enscript-keyword">if</span> (msghdr != NULL) {
				<span class="enscript-keyword">if</span> (msgsz &lt; msghdr-&gt;msg_ts &amp;&amp;
				    (msgflg &amp; MSG_NOERROR) == 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
					printf(<span class="enscript-string">&quot;first message on the queue is too big (want %ld, got %d)\n&quot;</span>,
					    msgsz, msghdr-&gt;msg_ts);
#<span class="enscript-reference">endif</span>
					eval = E2BIG;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgrcvout</span>;
				}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
				eval = mac_sysvmsq_check_msgrcv(kauth_cred_get(),
				    msghdr);
				<span class="enscript-keyword">if</span> (eval) 
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgrcvout</span>;
#<span class="enscript-reference">endif</span>
				<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_first == msqptr-&gt;u.msg_last) {
					msqptr-&gt;u.msg_first = NULL;
					msqptr-&gt;u.msg_last = NULL;
				} <span class="enscript-keyword">else</span> {
					msqptr-&gt;u.msg_first = msghdr-&gt;msg_next;
					<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_first == NULL)
						panic(<span class="enscript-string">&quot;msg_first/last messed up #1&quot;</span>);
				}
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> msg *previous;
			<span class="enscript-type">struct</span> msg **prev;

			previous = NULL;
			prev = &amp;(msqptr-&gt;u.msg_first);
			<span class="enscript-keyword">while</span> ((msghdr = *prev) != NULL) {
				<span class="enscript-comment">/*
				 * Is this message's type an exact match or is
				 * this message's type less than or equal to
				 * the absolute value of a negative msgtyp?
				 * Note that the second half of this test can
				 * NEVER be true if msgtyp is positive since
				 * msg_type is always positive!
				 */</span>

				<span class="enscript-keyword">if</span> (msgtyp == msghdr-&gt;msg_type ||
				    msghdr-&gt;msg_type &lt;= -msgtyp) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
					printf(<span class="enscript-string">&quot;found message type %ld, requested %ld\n&quot;</span>,
					    msghdr-&gt;msg_type, msgtyp);
#<span class="enscript-reference">endif</span>
					<span class="enscript-keyword">if</span> (msgsz &lt; msghdr-&gt;msg_ts &amp;&amp;
					    (msgflg &amp; MSG_NOERROR) == 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
						printf(<span class="enscript-string">&quot;requested message on the queue is too big (want %ld, got %d)\n&quot;</span>,
						    msgsz, msghdr-&gt;msg_ts);
#<span class="enscript-reference">endif</span>
						eval = E2BIG;
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgrcvout</span>;
					}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
					eval = mac_sysvmsq_check_msgrcv(
					    kauth_cred_get(), msghdr);
					<span class="enscript-keyword">if</span> (eval) 
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgrcvout</span>;
#<span class="enscript-reference">endif</span>
					*prev = msghdr-&gt;msg_next;
					<span class="enscript-keyword">if</span> (msghdr == msqptr-&gt;u.msg_last) {
						<span class="enscript-keyword">if</span> (previous == NULL) {
							<span class="enscript-keyword">if</span> (prev !=
							    &amp;msqptr-&gt;u.msg_first)
								panic(<span class="enscript-string">&quot;msg_first/last messed up #2&quot;</span>);
							msqptr-&gt;u.msg_first =
							    NULL;
							msqptr-&gt;u.msg_last =
							    NULL;
						} <span class="enscript-keyword">else</span> {
							<span class="enscript-keyword">if</span> (prev ==
							    &amp;msqptr-&gt;u.msg_first)
								panic(<span class="enscript-string">&quot;msg_first/last messed up #3&quot;</span>);
							msqptr-&gt;u.msg_last =
							    previous;
						}
					}
					<span class="enscript-keyword">break</span>;
				}
				previous = msghdr;
				prev = &amp;(msghdr-&gt;msg_next);
			}
		}

		<span class="enscript-comment">/*
		 * We've either extracted the msghdr for the appropriate
		 * message or there isn't one.
		 * If there is one then bail out of this loop.
		 */</span>

		<span class="enscript-keyword">if</span> (msghdr != NULL)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/*
		 * Hmph!  No message found.  Does the user want to wait?
		 */</span>

		<span class="enscript-keyword">if</span> ((msgflg &amp; IPC_NOWAIT) != 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;no appropriate message found (msgtyp=%ld)\n&quot;</span>,
			    msgtyp);
#<span class="enscript-reference">endif</span>
			<span class="enscript-comment">/* The SVID says to return ENOMSG. */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">ENOMSG</span>
			eval = ENOMSG;
#<span class="enscript-reference">else</span>
			<span class="enscript-comment">/* Unfortunately, BSD doesn't define that code yet! */</span>
			eval = EAGAIN;
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgrcvout</span>;
		}

		<span class="enscript-comment">/*
		 * Wait for something to happen
		 */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;msgrcv:  goodnight\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		eval = msleep((caddr_t)msqptr, &amp;sysv_msg_subsys_mutex, (PZERO - 4) | PCATCH, <span class="enscript-string">&quot;msgwait&quot;</span>,
		    0);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;msgrcv:  good morning (eval=%d)\n&quot;</span>, eval);
#<span class="enscript-reference">endif</span>

		<span class="enscript-keyword">if</span> (eval != 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;msgsnd:  interrupted system call\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			eval = EINTR;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgrcvout</span>;
		}

		<span class="enscript-comment">/*
		 * Make sure that the msq queue still exists
		 */</span>

		<span class="enscript-keyword">if</span> (msqptr-&gt;u.msg_qbytes == 0 ||
		    msqptr-&gt;u.msg_perm._seq != IPCID_TO_SEQ(uap-&gt;msqid)) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;msqid deleted\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			<span class="enscript-comment">/* The SVID says to return EIDRM. */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">EIDRM</span>
			eval = EIDRM;
#<span class="enscript-reference">else</span>
			<span class="enscript-comment">/* Unfortunately, BSD doesn't define that code yet! */</span>
			eval = EINVAL;
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgrcvout</span>;
		}
	}

	<span class="enscript-comment">/*
	 * Return the message to the user.
	 *
	 * First, do the bookkeeping (before we risk being interrupted).
	 */</span>

	msqptr-&gt;u.msg_cbytes -= msghdr-&gt;msg_ts;
	msqptr-&gt;u.msg_qnum--;
	msqptr-&gt;u.msg_lrpid = p-&gt;p_pid;
	msqptr-&gt;u.msg_rtime = sysv_msgtime();

	<span class="enscript-comment">/*
	 * Make msgsz the actual amount that we'll be returning.
	 * Note that this effectively truncates the message if it is too long
	 * (since msgsz is never increased).
	 */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
	printf(<span class="enscript-string">&quot;found a message, msgsz=%ld, msg_ts=%d\n&quot;</span>, msgsz,
	    msghdr-&gt;msg_ts);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (msgsz &gt; msghdr-&gt;msg_ts)
		msgsz = msghdr-&gt;msg_ts;

	<span class="enscript-comment">/*
	 * Return the type to the user.
	 */</span>

	<span class="enscript-comment">/*
	 * Copy out the message type.  For a 64 bit process, this is 64 bits,
	 * but we only ever use the low 32 bits, so the cast is OK.
	 */</span>
	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		msgtype = msghdr-&gt;msg_type;
		SYSV_MSG_SUBSYS_UNLOCK();
		eval = copyout(&amp;msgtype, user_msgp, <span class="enscript-keyword">sizeof</span>(msgtype));
		SYSV_MSG_SUBSYS_LOCK();
		user_msgp = user_msgp + <span class="enscript-keyword">sizeof</span>(msgtype);	<span class="enscript-comment">/* ptr math */</span>
	} <span class="enscript-keyword">else</span> {
		msg_type32 = msghdr-&gt;msg_type;
		SYSV_MSG_SUBSYS_UNLOCK();
		eval = copyout(&amp;msg_type32, user_msgp, <span class="enscript-keyword">sizeof</span>(msg_type32));
		SYSV_MSG_SUBSYS_LOCK();
		user_msgp = user_msgp + <span class="enscript-keyword">sizeof</span>(msg_type32);		<span class="enscript-comment">/* ptr math */</span>
	}

	<span class="enscript-keyword">if</span> (eval != 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
		printf(<span class="enscript-string">&quot;error (%d) copying out message type\n&quot;</span>, eval);
#<span class="enscript-reference">endif</span>
		msg_freehdr(msghdr);
		wakeup((caddr_t)msqptr);

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgrcvout</span>;
	}


	<span class="enscript-comment">/*
	 * Return the segments to the user
	 */</span>

	next = msghdr-&gt;msg_spot;
	<span class="enscript-keyword">for</span> (len = 0; len &lt; msgsz; len += msginfo.msgssz) {
		size_t tlen;

		<span class="enscript-comment">/* compare input (size_t) value against restrict (int) value */</span>
		<span class="enscript-keyword">if</span> (msgsz &gt; (size_t)msginfo.msgssz)
			tlen = msginfo.msgssz;
		<span class="enscript-keyword">else</span>
			tlen = msgsz;
		<span class="enscript-keyword">if</span> (next &lt;= -1)
			panic(<span class="enscript-string">&quot;next too low #3&quot;</span>);
		<span class="enscript-keyword">if</span> (next &gt;= msginfo.msgseg)
			panic(<span class="enscript-string">&quot;next out of range #3&quot;</span>);
		SYSV_MSG_SUBSYS_UNLOCK();
		eval = copyout(&amp;msgpool[next * msginfo.msgssz],
		    user_msgp, tlen);
		SYSV_MSG_SUBSYS_LOCK();
		<span class="enscript-keyword">if</span> (eval != 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MSG_DEBUG_OK</span>
			printf(<span class="enscript-string">&quot;error (%d) copying out message segment\n&quot;</span>,
			    eval);
#<span class="enscript-reference">endif</span>
			msg_freehdr(msghdr);
			wakeup((caddr_t)msqptr);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">msgrcvout</span>;
		}
		user_msgp = user_msgp + tlen;	<span class="enscript-comment">/* ptr math */</span>
		next = msgmaps[next].next;
	}

	<span class="enscript-comment">/*
	 * Done, return the actual number of bytes copied out.
	 */</span>

	msg_freehdr(msghdr);
	wakeup((caddr_t)msqptr);
	*retval = msgsz;
	eval = 0;
<span class="enscript-reference">msgrcvout</span>:
	SYSV_MSG_SUBSYS_UNLOCK();
	<span class="enscript-keyword">return</span>(eval);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">IPCS_msg_sysctl</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1,
	__unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> cursor;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> user32_IPCS_command u32;
		<span class="enscript-type">struct</span> user_IPCS_command u64;
	} ipcs;
	<span class="enscript-type">struct</span> user32_msqid_ds msqid_ds32;	<span class="enscript-comment">/* post conversion, 32 bit version */</span>
	<span class="enscript-type">struct</span> user64_msqid_ds msqid_ds64;	<span class="enscript-comment">/* post conversion, 64 bit version */</span>
	<span class="enscript-type">void</span> *msqid_dsp;
	size_t ipcs_sz;
	size_t msqid_ds_sz;
	<span class="enscript-type">struct</span> proc *p = current_proc();

	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		ipcs_sz = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user_IPCS_command);
		msqid_ds_sz = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user64_msqid_ds);
	} <span class="enscript-keyword">else</span> {
		ipcs_sz = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_IPCS_command);
		msqid_ds_sz = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_msqid_ds);
	}

	<span class="enscript-comment">/* Copy in the command structure */</span>
	<span class="enscript-keyword">if</span> ((error = SYSCTL_IN(req, &amp;ipcs, ipcs_sz)) != 0) {
		<span class="enscript-keyword">return</span>(error);
	}

	<span class="enscript-keyword">if</span> (!IS_64BIT_PROCESS(p))	<span class="enscript-comment">/* convert in place */</span>
		ipcs.u64.ipcs_data = CAST_USER_ADDR_T(ipcs.u32.ipcs_data);

	<span class="enscript-comment">/* Let us version this interface... */</span>
	<span class="enscript-keyword">if</span> (ipcs.u64.ipcs_magic != IPCS_MAGIC) {
		<span class="enscript-keyword">return</span>(EINVAL);
	}

	SYSV_MSG_SUBSYS_LOCK();

	<span class="enscript-keyword">switch</span>(ipcs.u64.ipcs_op) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPCS_MSG_CONF</span>:	<span class="enscript-comment">/* Obtain global configuration data */</span>
		<span class="enscript-keyword">if</span> (ipcs.u64.ipcs_datalen != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> msginfo)) {
			error = ERANGE;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (ipcs.u64.ipcs_cursor != 0) {	<span class="enscript-comment">/* fwd. compat. */</span>
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		SYSV_MSG_SUBSYS_UNLOCK();
		error = copyout(&amp;msginfo, ipcs.u64.ipcs_data, ipcs.u64.ipcs_datalen);
		SYSV_MSG_SUBSYS_LOCK();
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPCS_MSG_ITER</span>:	<span class="enscript-comment">/* Iterate over existing segments */</span>
		<span class="enscript-comment">/* Not done up top so we can set limits via sysctl (later) */</span>
		<span class="enscript-keyword">if</span> (!msginit(0)) {
			error =  ENOMEM;
			<span class="enscript-keyword">break</span>;
		}

		cursor = ipcs.u64.ipcs_cursor;
		<span class="enscript-keyword">if</span> (cursor &lt; 0 || cursor &gt;= msginfo.msgmni) {
			error = ERANGE;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (ipcs.u64.ipcs_datalen != (<span class="enscript-type">int</span>)msqid_ds_sz) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">for</span>( ; cursor &lt; msginfo.msgmni; cursor++) {
			<span class="enscript-keyword">if</span> (msqids[cursor].u.msg_qbytes != 0)	<span class="enscript-comment">/* allocated */</span>
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (cursor == msginfo.msgmni) {
			error = ENOENT;
			<span class="enscript-keyword">break</span>;
		}

		msqid_dsp = &amp;msqids[cursor];	<span class="enscript-comment">/* default: 64 bit */</span>

		<span class="enscript-comment">/*
		 * If necessary, convert the 64 bit kernel segment
		 * descriptor to a 32 bit user one.
		 */</span>
		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			msqid_ds_kerneltouser64(msqid_dsp, &amp;msqid_ds64);
			msqid_dsp = &amp;msqid_ds64;
		} <span class="enscript-keyword">else</span> {
			msqid_ds_kerneltouser32(msqid_dsp, &amp;msqid_ds32);
			msqid_dsp = &amp;msqid_ds32;
		}

		SYSV_MSG_SUBSYS_UNLOCK();
		error = copyout(msqid_dsp, ipcs.u64.ipcs_data, ipcs.u64.ipcs_datalen);
		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-comment">/* update cursor */</span>
			ipcs.u64.ipcs_cursor = cursor + 1;

			<span class="enscript-keyword">if</span> (!IS_64BIT_PROCESS(p))	<span class="enscript-comment">/* convert in place */</span>
				ipcs.u32.ipcs_data = CAST_DOWN_EXPLICIT(user32_addr_t,ipcs.u64.ipcs_data);
			error = SYSCTL_OUT(req, &amp;ipcs, ipcs_sz);
		}
		SYSV_MSG_SUBSYS_LOCK();
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}

	SYSV_MSG_SUBSYS_UNLOCK();
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-function-name">SYSCTL_DECL</span>(_kern_sysv_ipcs);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_sysv_ipcs, OID_AUTO, msg, CTLFLAG_RW | CTLFLAG_ANYBODY | CTLFLAG_LOCKED,
	0, 0, IPCS_msg_sysctl,
	<span class="enscript-string">&quot;S,IPCS_msg_command&quot;</span>,
	<span class="enscript-string">&quot;ipcs msg command interface&quot;</span>);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* SYSV_MSG */</span>
</pre>
<hr />
</body></html>