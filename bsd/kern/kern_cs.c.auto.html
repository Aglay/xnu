<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_cs.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_cs.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/codesign.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/msg.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_policy.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_vm.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>


#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/shared_region.h&gt;</span>

<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> cs_procs_killed = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> cs_procs_invalidated = 0;

<span class="enscript-type">int</span> cs_force_kill = 0;
<span class="enscript-type">int</span> cs_force_hard = 0;
<span class="enscript-type">int</span> cs_debug = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SECURE_KERNEL</span>
<span class="enscript-type">const</span> <span class="enscript-type">int</span> cs_enforcement_enable = 1;
<span class="enscript-type">const</span> <span class="enscript-type">int</span> cs_library_val_enable = 1;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !SECURE_KERNEL */</span>
<span class="enscript-type">int</span> cs_enforcement_panic=0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ENFORCE_SIGNED_CODE</span>
<span class="enscript-type">int</span> cs_enforcement_enable = 1;
#<span class="enscript-reference">else</span>
<span class="enscript-type">int</span> cs_enforcement_enable = 0;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_ENFORCE_LIBRARY_VALIDATION</span>
<span class="enscript-type">int</span> cs_library_val_enable = 1;
#<span class="enscript-reference">else</span>
<span class="enscript-type">int</span> cs_library_val_enable = 0;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !SECURE_KERNEL */</span>
<span class="enscript-type">int</span> cs_all_vnodes = 0;

<span class="enscript-type">static</span> lck_grp_t *cs_lockgrp;

<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, cs_force_kill, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;cs_force_kill, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, cs_force_hard, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;cs_force_hard, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, cs_debug, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;cs_debug, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, cs_all_vnodes, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;cs_all_vnodes, 0, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">SECURE_KERNEL</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, cs_enforcement, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;cs_enforcement_enable, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, cs_enforcement_panic, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;cs_enforcement_panic, 0, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_ENFORCE_LIBRARY_VALIDATION</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, cs_library_validation, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;cs_library_val_enable, 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !SECURE_KERNEL */</span>

<span class="enscript-type">int</span> panic_on_cs_killed = 0;
<span class="enscript-type">void</span>
<span class="enscript-function-name">cs_init</span>(<span class="enscript-type">void</span>)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span> &amp;&amp; <span class="enscript-variable-name">__x86_64__</span>
	panic_on_cs_killed = 1;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MACH_ASSERT &amp;&amp; __x86_64__ */</span>
	PE_parse_boot_argn(<span class="enscript-string">&quot;panic_on_cs_killed&quot;</span>, &amp;panic_on_cs_killed,
			   <span class="enscript-keyword">sizeof</span> (panic_on_cs_killed));
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">SECURE_KERNEL</span>
	<span class="enscript-type">int</span> disable_cs_enforcement = 0;
	PE_parse_boot_argn(<span class="enscript-string">&quot;cs_enforcement_disable&quot;</span>, &amp;disable_cs_enforcement, 
			   <span class="enscript-keyword">sizeof</span> (disable_cs_enforcement));
	<span class="enscript-keyword">if</span> (disable_cs_enforcement) {
		cs_enforcement_enable = 0;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">int</span> panic = 0;
		PE_parse_boot_argn(<span class="enscript-string">&quot;cs_enforcement_panic&quot;</span>, &amp;panic, <span class="enscript-keyword">sizeof</span>(panic));
		cs_enforcement_panic = (panic != 0);
	}

	PE_parse_boot_argn(<span class="enscript-string">&quot;cs_debug&quot;</span>, &amp;cs_debug, <span class="enscript-keyword">sizeof</span> (cs_debug));

#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_ENFORCE_LIBRARY_VALIDATION</span>
	PE_parse_boot_argn(<span class="enscript-string">&quot;cs_library_val_enable&quot;</span>, &amp;cs_library_val_enable,
			   <span class="enscript-keyword">sizeof</span> (cs_library_val_enable));
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !SECURE_KERNEL */</span>

	lck_grp_attr_t *attr = lck_grp_attr_alloc_init();
	cs_lockgrp = lck_grp_alloc_init(<span class="enscript-string">&quot;KERNCS&quot;</span>, attr);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">cs_allow_invalid</span>(<span class="enscript-type">struct</span> proc *p)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MACH_ASSERT</span>
	lck_mtx_assert(&amp;p-&gt;p_mlock, LCK_MTX_ASSERT_NOTOWNED);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span> &amp;&amp; <span class="enscript-variable-name">CONFIG_ENFORCE_SIGNED_CODE</span>
	<span class="enscript-comment">/* There needs to be a MAC policy to implement this hook, or else the
	 * kill bits will be cleared here every time. If we have 
	 * CONFIG_ENFORCE_SIGNED_CODE, we can assume there is a policy
	 * implementing the hook. 
	 */</span>
	<span class="enscript-keyword">if</span>( 0 != mac_proc_check_run_cs_invalid(p)) {
		<span class="enscript-keyword">if</span>(cs_debug) printf(<span class="enscript-string">&quot;CODE SIGNING: cs_allow_invalid() &quot;</span>
				    <span class="enscript-string">&quot;not allowed: pid %d\n&quot;</span>, 
				    p-&gt;p_pid);
		<span class="enscript-keyword">return</span> 0;
	}
	<span class="enscript-keyword">if</span>(cs_debug) printf(<span class="enscript-string">&quot;CODE SIGNING: cs_allow_invalid() &quot;</span>
			    <span class="enscript-string">&quot;allowed: pid %d\n&quot;</span>, 
			    p-&gt;p_pid);
	proc_lock(p);
	p-&gt;p_csflags &amp;= ~(CS_KILL | CS_HARD);
	proc_unlock(p);
	vm_map_switch_protect(get_task_map(p-&gt;task), FALSE);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> (p-&gt;p_csflags &amp; (CS_KILL | CS_HARD)) == 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">cs_invalid_page</span>(
	addr64_t vaddr)
{
	<span class="enscript-type">struct</span> proc	*p;
	<span class="enscript-type">int</span>		send_kill = 0, retval = 0, verbose = cs_debug;
	uint32_t	csflags;

	p = current_proc();

	<span class="enscript-keyword">if</span> (verbose)
		printf(<span class="enscript-string">&quot;CODE SIGNING: cs_invalid_page(0x%llx): p=%d[%s]\n&quot;</span>,
		    vaddr, p-&gt;p_pid, p-&gt;p_comm);

	proc_lock(p);

	<span class="enscript-comment">/* XXX for testing */</span>
	<span class="enscript-keyword">if</span> (cs_force_kill)
		p-&gt;p_csflags |= CS_KILL;
	<span class="enscript-keyword">if</span> (cs_force_hard)
		p-&gt;p_csflags |= CS_HARD;

	<span class="enscript-comment">/* CS_KILL triggers a kill signal, and no you can't have the page. Nothing else. */</span>
	<span class="enscript-keyword">if</span> (p-&gt;p_csflags &amp; CS_KILL) {
		<span class="enscript-keyword">if</span> (panic_on_cs_killed &amp;&amp;
		    vaddr &gt;= SHARED_REGION_BASE &amp;&amp;
		    vaddr &lt; SHARED_REGION_BASE + SHARED_REGION_SIZE) {
			panic(<span class="enscript-string">&quot;&lt;rdar://14393620&gt; cs_invalid_page(va=0x%llx): killing p=%p\n&quot;</span>, (uint64_t) vaddr, p);
		}
		p-&gt;p_csflags |= CS_KILLED;
		cs_procs_killed++;
		send_kill = 1;
		retval = 1;
	}
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">__x86_64__</span>
	<span class="enscript-keyword">if</span> (panic_on_cs_killed &amp;&amp;
	    vaddr &gt;= SHARED_REGION_BASE &amp;&amp;
	    vaddr &lt; SHARED_REGION_BASE + SHARED_REGION_SIZE) {
		panic(<span class="enscript-string">&quot;&lt;rdar://14393620&gt; cs_invalid_page(va=0x%llx): cs error p=%p\n&quot;</span>, (uint64_t) vaddr, p);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __x86_64__ */</span>

	<span class="enscript-comment">/* CS_HARD means fail the mapping operation so the process stays valid. */</span>
	<span class="enscript-keyword">if</span> (p-&gt;p_csflags &amp; CS_HARD) {
		retval = 1;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (p-&gt;p_csflags &amp; CS_VALID) {
			p-&gt;p_csflags &amp;= ~CS_VALID;
			cs_procs_invalidated++;
			verbose = 1;
		}
	}
	csflags = p-&gt;p_csflags;
	proc_unlock(p);

	<span class="enscript-keyword">if</span> (verbose)
		printf(<span class="enscript-string">&quot;CODE SIGNING: cs_invalid_page(0x%llx): &quot;</span>
		       <span class="enscript-string">&quot;p=%d[%s] final status 0x%x, %s page%s\n&quot;</span>,
		       vaddr, p-&gt;p_pid, p-&gt;p_comm, p-&gt;p_csflags,
		       retval ? <span class="enscript-string">&quot;denying&quot;</span> : <span class="enscript-string">&quot;allowing (remove VALID)&quot;</span>,
		       send_kill ? <span class="enscript-string">&quot; sending SIGKILL&quot;</span> : <span class="enscript-string">&quot;&quot;</span>);

	<span class="enscript-keyword">if</span> (send_kill)
		threadsignal(current_thread(), SIGKILL, EXC_BAD_ACCESS);


	<span class="enscript-keyword">return</span> retval;
}

<span class="enscript-comment">/*
 * Assumes p (if passed in) is locked with proc_lock().
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">cs_enforcement</span>(<span class="enscript-type">struct</span> proc *p)
{

	<span class="enscript-keyword">if</span> (cs_enforcement_enable)
		<span class="enscript-keyword">return</span> 1;
	
	<span class="enscript-keyword">if</span> (p == NULL)
		p = current_proc();

	<span class="enscript-keyword">if</span> (p != NULL &amp;&amp; (p-&gt;p_csflags &amp; CS_ENFORCEMENT))
		<span class="enscript-keyword">return</span> 1;

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Library validation functions 
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">cs_require_lv</span>(<span class="enscript-type">struct</span> proc *p)
{
	
	<span class="enscript-keyword">if</span> (cs_library_val_enable)
		<span class="enscript-keyword">return</span> 1;

	<span class="enscript-keyword">if</span> (p == NULL)
		p = current_proc();
	
	<span class="enscript-keyword">if</span> (p != NULL &amp;&amp; (p-&gt;p_csflags &amp; CS_REQUIRE_LV))
		<span class="enscript-keyword">return</span> 1;
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Function: csblob_get_platform_binary
 *
 * Description: This function returns true if the binary is
 *		in the trust cache.
*/</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">csblob_get_platform_binary</span>(<span class="enscript-type">struct</span> cs_blob *blob)
{
    <span class="enscript-keyword">if</span> (blob &amp;&amp; blob-&gt;csb_platform_binary)
	<span class="enscript-keyword">return</span> 1;
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Function: csblob_get_flags
 *
 * Description: This function returns the flags for a given blob
*/</span>

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">csblob_get_flags</span>(<span class="enscript-type">struct</span> cs_blob *blob)
{
	<span class="enscript-keyword">if</span> (blob)
		<span class="enscript-keyword">return</span> blob-&gt;csb_flags;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * Function: csproc_get_blob
 *
 * Description: This function returns the cs_blob
 *		for the process p
 */</span>
<span class="enscript-type">struct</span> cs_blob *
<span class="enscript-function-name">csproc_get_blob</span>(<span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-keyword">if</span> (NULL == p)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">if</span> (NULL == p-&gt;p_textvp)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">return</span> ubc_cs_blob_get(p-&gt;p_textvp, -1, p-&gt;p_textoff);
}

<span class="enscript-comment">/*
 * Function: csproc_get_blob
 *
 * Description: This function returns the cs_blob
 *		for the vnode vp
 */</span>
<span class="enscript-type">struct</span> cs_blob *
<span class="enscript-function-name">csvnode_get_blob</span>(<span class="enscript-type">struct</span> vnode *vp, off_t offset)
{
	<span class="enscript-keyword">return</span> ubc_cs_blob_get(vp, -1, offset);
}

<span class="enscript-comment">/*
 * Function: csblob_get_teamid
 *
 * Description: This function returns a pointer to the
 *		team id of csblob
*/</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">csblob_get_teamid</span>(<span class="enscript-type">struct</span> cs_blob *csblob)
{
	<span class="enscript-keyword">return</span> csblob-&gt;csb_teamid;
}

<span class="enscript-comment">/*
 * Function: csblob_get_identity
 *
 * Description: This function returns a pointer to the
 *		identity string
 */</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">csblob_get_identity</span>(<span class="enscript-type">struct</span> cs_blob *csblob)
{
	<span class="enscript-type">const</span> CS_CodeDirectory *cd;

	cd = (<span class="enscript-type">const</span> CS_CodeDirectory *)csblob_find_blob(csblob, CSSLOT_CODEDIRECTORY, CSMAGIC_CODEDIRECTORY);
	<span class="enscript-keyword">if</span> (cd == NULL)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">if</span> (cd-&gt;identOffset == 0)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">return</span> ((<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)cd) + ntohl(cd-&gt;identOffset);
}

<span class="enscript-comment">/*
 * Function: csblob_get_cdhash
 *
 * Description: This function returns a pointer to the
 *		cdhash of csblob (20 byte array)
 */</span>
<span class="enscript-type">const</span> uint8_t *
<span class="enscript-function-name">csblob_get_cdhash</span>(<span class="enscript-type">struct</span> cs_blob *csblob)
{
	<span class="enscript-keyword">return</span> csblob-&gt;csb_cdhash;
}

<span class="enscript-comment">/*
 * Function: csproc_get_teamid 
 *
 * Description: This function returns a pointer to the
 *		team id of the process p
*/</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">csproc_get_teamid</span>(<span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> cs_blob *csblob;

	csblob = csproc_get_blob(p);
	<span class="enscript-keyword">if</span> (csblob == NULL)
	    <span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">return</span> csblob_get_teamid(csblob);
}

<span class="enscript-comment">/*
 * Function: csvnode_get_teamid 
 *
 * Description: This function returns a pointer to the
 *		team id of the binary at the given offset in vnode vp
*/</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">csvnode_get_teamid</span>(<span class="enscript-type">struct</span> vnode *vp, off_t offset)
{
	<span class="enscript-type">struct</span> cs_blob *csblob;

	<span class="enscript-keyword">if</span> (vp == NULL)
		<span class="enscript-keyword">return</span> NULL;

	csblob = ubc_cs_blob_get(vp, -1, offset);
	<span class="enscript-keyword">if</span> (csblob == NULL)
	    <span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">return</span> csblob_get_teamid(csblob);
}

<span class="enscript-comment">/*
 * Function: csproc_get_platform_binary
 *
 * Description: This function returns the value
 *		of the platform_binary field for proc p
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">csproc_get_platform_binary</span>(<span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> cs_blob *csblob;

	csblob = csproc_get_blob(p);

	<span class="enscript-comment">/* If there is no csblob this returns 0 because
	   it is true that it is not a platform binary */</span>
	<span class="enscript-keyword">return</span> (csblob == NULL) ? 0 : csblob-&gt;csb_platform_binary;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">csproc_get_platform_path</span>(<span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> cs_blob *csblob = csproc_get_blob(p);

	<span class="enscript-keyword">return</span> (csblob == NULL) ? 0 : csblob-&gt;csb_platform_path;
}

<span class="enscript-comment">/*
 * Function: csfg_get_platform_binary
 *
 * Description: This function returns the 
 *		platform binary field for the 
 * 		fileglob fg
 */</span>
<span class="enscript-type">int</span> 
<span class="enscript-function-name">csfg_get_platform_binary</span>(<span class="enscript-type">struct</span> fileglob *fg)
{
	<span class="enscript-type">int</span> platform_binary = 0;
	<span class="enscript-type">struct</span> ubc_info *uip;
	vnode_t vp;

	<span class="enscript-keyword">if</span> (FILEGLOB_DTYPE(fg) != DTYPE_VNODE)
		<span class="enscript-keyword">return</span> 0;
	
	vp = (<span class="enscript-type">struct</span> vnode *)fg-&gt;fg_data;
	<span class="enscript-keyword">if</span> (vp == NULL)
		<span class="enscript-keyword">return</span> 0;

	vnode_lock(vp);
	<span class="enscript-keyword">if</span> (!UBCINFOEXISTS(vp))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	
	uip = vp-&gt;v_ubcinfo;
	<span class="enscript-keyword">if</span> (uip == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	
	<span class="enscript-keyword">if</span> (uip-&gt;cs_blobs == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* It is OK to extract the teamid from the first blob
	   because all blobs of a vnode must have the same teamid */</span>	
	platform_binary = uip-&gt;cs_blobs-&gt;csb_platform_binary;
<span class="enscript-reference">out</span>:
	vnode_unlock(vp);

	<span class="enscript-keyword">return</span> platform_binary;
}

uint8_t *
<span class="enscript-function-name">csfg_get_cdhash</span>(<span class="enscript-type">struct</span> fileglob *fg, uint64_t offset, size_t *cdhash_size)
{
	vnode_t vp;

	<span class="enscript-keyword">if</span> (FILEGLOB_DTYPE(fg) != DTYPE_VNODE)
		<span class="enscript-keyword">return</span> NULL;

	vp = (<span class="enscript-type">struct</span> vnode *)fg-&gt;fg_data;
	<span class="enscript-keyword">if</span> (vp == NULL)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-type">struct</span> cs_blob *csblob = NULL;
	<span class="enscript-keyword">if</span> ((csblob = ubc_cs_blob_get(vp, -1, offset)) == NULL) 
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">if</span> (cdhash_size)
		*cdhash_size = CS_CDHASH_LEN;

	<span class="enscript-keyword">return</span> csblob-&gt;csb_cdhash;
}

<span class="enscript-comment">/*
 * Function: csfg_get_teamid
 *
 * Description: This returns a pointer to
 * 		the teamid for the fileglob fg
 */</span>
<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">csfg_get_teamid</span>(<span class="enscript-type">struct</span> fileglob *fg)
{
	<span class="enscript-type">struct</span> ubc_info *uip;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *str = NULL;
	vnode_t vp;

	<span class="enscript-keyword">if</span> (FILEGLOB_DTYPE(fg) != DTYPE_VNODE)
		<span class="enscript-keyword">return</span> NULL;
	
	vp = (<span class="enscript-type">struct</span> vnode *)fg-&gt;fg_data;
	<span class="enscript-keyword">if</span> (vp == NULL)
		<span class="enscript-keyword">return</span> NULL;

	vnode_lock(vp);
	<span class="enscript-keyword">if</span> (!UBCINFOEXISTS(vp))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	
	uip = vp-&gt;v_ubcinfo;
	<span class="enscript-keyword">if</span> (uip == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	
	<span class="enscript-keyword">if</span> (uip-&gt;cs_blobs == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-comment">/* It is OK to extract the teamid from the first blob
	   because all blobs of a vnode must have the same teamid */</span>	
	str = uip-&gt;cs_blobs-&gt;csb_teamid;
<span class="enscript-reference">out</span>:
	vnode_unlock(vp);

	<span class="enscript-keyword">return</span> str;
}

uint32_t
<span class="enscript-function-name">cs_entitlement_flags</span>(<span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-keyword">return</span> (p-&gt;p_csflags &amp; CS_ENTITLEMENT_FLAGS);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">cs_restricted</span>(<span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-keyword">return</span> (p-&gt;p_csflags &amp; CS_RESTRICT) ? 1 : 0;
}

<span class="enscript-comment">/*
 * Function: csfg_get_path
 *
 * Description: This populates the buffer passed in
 *		with the path of the vnode
 *		When calling this, the fileglob
 *		cannot go away. The caller must have a
 *		a reference on the fileglob or fileproc
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">csfg_get_path</span>(<span class="enscript-type">struct</span> fileglob *fg, <span class="enscript-type">char</span> *path, <span class="enscript-type">int</span> *len)
{
	vnode_t vp = NULL;

	<span class="enscript-keyword">if</span> (FILEGLOB_DTYPE(fg) != DTYPE_VNODE)
		<span class="enscript-keyword">return</span> -1;
	
	vp = (<span class="enscript-type">struct</span> vnode *)fg-&gt;fg_data;

	<span class="enscript-comment">/* vn_getpath returns 0 for success,
	   or an error code */</span>
	<span class="enscript-keyword">return</span> vn_getpath(vp, path, len);
}

<span class="enscript-comment">/* Retrieve the entitlements blob for a process.
 * Returns:
 *   EINVAL	no text vnode associated with the process
 *   EBADEXEC   invalid code signing data
 *   0		no error occurred
 *
 * On success, out_start and out_length will point to the
 * entitlements blob if found; or will be set to NULL/zero
 * if there were no entitlements.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">cs_entitlements_blob_get</span>(proc_t p, <span class="enscript-type">void</span> **out_start, size_t *out_length)
{
	<span class="enscript-type">struct</span> cs_blob *csblob;

	*out_start = NULL;
	*out_length = 0;

	<span class="enscript-keyword">if</span> (NULL == p-&gt;p_textvp)
		<span class="enscript-keyword">return</span> EINVAL;

	<span class="enscript-keyword">if</span> ((csblob = ubc_cs_blob_get(p-&gt;p_textvp, -1, p-&gt;p_textoff)) == NULL)
		<span class="enscript-keyword">return</span> 0;

	<span class="enscript-keyword">return</span> csblob_get_entitlements(csblob, out_start, out_length);
}

<span class="enscript-comment">/* Retrieve the codesign identity for a process.
 * Returns:
 *   NULL	an error occured
 *   string	the cs_identity
 */</span>

<span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">cs_identity_get</span>(proc_t p)
{
	<span class="enscript-type">struct</span> cs_blob *csblob;

	<span class="enscript-keyword">if</span> (NULL == p-&gt;p_textvp)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">if</span> ((csblob = ubc_cs_blob_get(p-&gt;p_textvp, -1, p-&gt;p_textoff)) == NULL)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">return</span> csblob_get_identity(csblob);
}


<span class="enscript-comment">/* Retrieve the codesign blob for a process.
 * Returns:
 *   EINVAL	no text vnode associated with the process
 *   0		no error occurred
 *
 * On success, out_start and out_length will point to the
 * cms blob if found; or will be set to NULL/zero
 * if there were no blob.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">cs_blob_get</span>(proc_t p, <span class="enscript-type">void</span> **out_start, size_t *out_length)
{
	<span class="enscript-type">struct</span> cs_blob *csblob;

	*out_start = NULL;
	*out_length = 0;

	<span class="enscript-keyword">if</span> (NULL == p-&gt;p_textvp)
		<span class="enscript-keyword">return</span> EINVAL;

	<span class="enscript-keyword">if</span> ((csblob = ubc_cs_blob_get(p-&gt;p_textvp, -1, p-&gt;p_textoff)) == NULL)
		<span class="enscript-keyword">return</span> 0;

	*out_start = (<span class="enscript-type">void</span> *)csblob-&gt;csb_mem_kaddr;
	*out_length = csblob-&gt;csb_mem_size;

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * return cshash of a process, cdhash is of size CS_CDHASH_LEN
 */</span>

uint8_t *
<span class="enscript-function-name">cs_get_cdhash</span>(<span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> cs_blob *csblob;

	<span class="enscript-keyword">if</span> (NULL == p-&gt;p_textvp)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">if</span> ((csblob = ubc_cs_blob_get(p-&gt;p_textvp, -1, p-&gt;p_textoff)) == NULL)
		<span class="enscript-keyword">return</span> NULL;

	<span class="enscript-keyword">return</span> csblob-&gt;csb_cdhash;
}
</pre>
<hr />
</body></html>