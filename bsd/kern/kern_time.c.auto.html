<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_time.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_time.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)kern_time.c	8.4 (Berkeley) 5/26/95
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/priv.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span> <span class="enscript-comment">/* for net_uptime2timeval() */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HZ</span>	100	<span class="enscript-comment">/* XXX */</span>

<span class="enscript-comment">/* simple lock used to access timezone, tz structure */</span>
lck_spin_t * tz_slock;
lck_grp_t * tz_slock_grp;
lck_attr_t * tz_slock_attr;
lck_grp_attr_t	*tz_slock_grp_attr;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>		setthetime(
					<span class="enscript-type">struct</span> timeval	*tv);

<span class="enscript-type">void</span> <span class="enscript-function-name">time_zone_slock_init</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">/* 
 * Time of day and interval timer support.
 *
 * These routines provide the kernel entry points to get and set
 * the time-of-day and per-process interval timers.  Subroutines
 * here provide support for adding and subtracting timeval structures
 * and decrementing interval timers, optionally reloading the interval
 * timers when they expire.
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">gettimeofday</span>(
__unused	<span class="enscript-type">struct</span> proc	*p,
			<span class="enscript-type">struct</span> gettimeofday_args *uap, 
			int32_t *retval)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> timezone ltz; <span class="enscript-comment">/* local copy */</span>

	<span class="enscript-keyword">if</span> (uap-&gt;tp) {
		clock_sec_t		secs;
		clock_usec_t	usecs;

		clock_gettimeofday(&amp;secs, &amp;usecs);
		retval[0] = secs;
		retval[1] = usecs;
	}
	
	<span class="enscript-keyword">if</span> (uap-&gt;tzp) {
		lck_spin_lock(tz_slock);
		ltz = tz;
		lck_spin_unlock(tz_slock);

		error = copyout((caddr_t)&amp;ltz, CAST_USER_ADDR_T(uap-&gt;tzp), <span class="enscript-keyword">sizeof</span> (tz));
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * XXX Y2038 bug because of setthetime() argument
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">settimeofday</span>(__unused <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> settimeofday_args  *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> timeval atv;
	<span class="enscript-type">struct</span> timezone atz;
	<span class="enscript-type">int</span> error;

	bzero(&amp;atv, <span class="enscript-keyword">sizeof</span>(atv));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_system_check_settime(kauth_cred_get());
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((error = suser(kauth_cred_get(), &amp;p-&gt;p_acflag)))
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-comment">/* Verify all parameters before changing time */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;tv) {
		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			<span class="enscript-type">struct</span> user64_timeval user_atv;
			error = copyin(uap-&gt;tv, &amp;user_atv, <span class="enscript-keyword">sizeof</span>(user_atv));
			atv.tv_sec = user_atv.tv_sec;
			atv.tv_usec = user_atv.tv_usec;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_timeval user_atv;
			error = copyin(uap-&gt;tv, &amp;user_atv, <span class="enscript-keyword">sizeof</span>(user_atv));
			atv.tv_sec = user_atv.tv_sec;
			atv.tv_usec = user_atv.tv_usec;
		}
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> (error);
	}
	<span class="enscript-keyword">if</span> (uap-&gt;tzp &amp;&amp; (error = copyin(uap-&gt;tzp, (caddr_t)&amp;atz, <span class="enscript-keyword">sizeof</span>(atz))))
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (uap-&gt;tv) {
		timevalfix(&amp;atv);
		<span class="enscript-keyword">if</span> (atv.tv_sec &lt; 0 || (atv.tv_sec == 0 &amp;&amp; atv.tv_usec &lt; 0))
			<span class="enscript-keyword">return</span> (EPERM);
		setthetime(&amp;atv);
	}
	<span class="enscript-keyword">if</span> (uap-&gt;tzp) {
		lck_spin_lock(tz_slock);
		tz = atz;
		lck_spin_unlock(tz_slock);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">setthetime</span>(
	<span class="enscript-type">struct</span> timeval	*tv)
{
	clock_set_calendar_microtime(tv-&gt;tv_sec, tv-&gt;tv_usec);
}

<span class="enscript-comment">/*
 * XXX Y2038 bug because of clock_adjtime() first argument
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">adjtime</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> adjtime_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> timeval atv;
	<span class="enscript-type">int</span> error;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_system_check_settime(kauth_cred_get());
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> ((error = priv_check_cred(kauth_cred_get(), PRIV_ADJTIME, 0)))
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		<span class="enscript-type">struct</span> user64_timeval user_atv;
		error = copyin(uap-&gt;delta, &amp;user_atv, <span class="enscript-keyword">sizeof</span>(user_atv));
		atv.tv_sec = user_atv.tv_sec;
		atv.tv_usec = user_atv.tv_usec;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_timeval user_atv;
		error = copyin(uap-&gt;delta, &amp;user_atv, <span class="enscript-keyword">sizeof</span>(user_atv));
		atv.tv_sec = user_atv.tv_sec;
		atv.tv_usec = user_atv.tv_usec;
	}
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
		
	<span class="enscript-comment">/*
	 * Compute the total correction and the rate at which to apply it.
	 */</span>
	clock_adjtime(&amp;atv.tv_sec, &amp;atv.tv_usec);

	<span class="enscript-keyword">if</span> (uap-&gt;olddelta) {
		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			<span class="enscript-type">struct</span> user64_timeval user_atv;
			user_atv.tv_sec = atv.tv_sec;
			user_atv.tv_usec = atv.tv_usec;
			error = copyout(&amp;user_atv, uap-&gt;olddelta, <span class="enscript-keyword">sizeof</span>(user_atv));
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_timeval user_atv;
			user_atv.tv_sec = atv.tv_sec;
			user_atv.tv_usec = atv.tv_usec;
			error = copyout(&amp;user_atv, uap-&gt;olddelta, <span class="enscript-keyword">sizeof</span>(user_atv));
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 *	Verify the calendar value.  If negative,
 *	reset to zero (the epoch).
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">inittodr</span>(
	__unused time_t	base)
{
	<span class="enscript-type">struct</span> timeval	tv;

	<span class="enscript-comment">/*
	 * Assertion:
	 * The calendar has already been
	 * set up from the platform clock.
	 *
	 * The value returned by microtime()
	 * is gotten from the calendar.
	 */</span>
	microtime(&amp;tv);

	<span class="enscript-keyword">if</span> (tv.tv_sec &lt; 0 || tv.tv_usec &lt; 0) {
		printf (<span class="enscript-string">&quot;WARNING: preposterous time in Real Time Clock&quot;</span>);
		tv.tv_sec = 0;		<span class="enscript-comment">/* the UNIX epoch */</span>
		tv.tv_usec = 0;
		setthetime(&amp;tv);
		printf(<span class="enscript-string">&quot; -- CHECK AND RESET THE DATE!\n&quot;</span>);
	}
}

time_t
<span class="enscript-function-name">boottime_sec</span>(<span class="enscript-type">void</span>)
{
	clock_sec_t		secs;
	clock_nsec_t	nanosecs;

	clock_get_boottime_nanotime(&amp;secs, &amp;nanosecs);
	<span class="enscript-keyword">return</span> (secs);
}

<span class="enscript-comment">/*
 * Get value of an interval timer.  The process virtual and
 * profiling virtual time timers are kept internally in the
 * way they are specified externally: in time until they expire.
 *
 * The real time interval timer expiration time (p_rtime)
 * is kept as an absolute time rather than as a delta, so that
 * it is easy to keep periodic real-time signals from drifting.
 *
 * The real time timer is processed by a callout routine.
 * Since a callout may be delayed in real time due to
 * other processing in the system, it is possible for the real
 * time callout routine (realitexpire, given below), to be delayed
 * in real time past when it is supposed to occur.  It does not
 * suffice, therefore, to reload the real time .it_value from the
 * real time .it_interval.  Rather, we compute the next time in
 * absolute time when the timer should go off.
 *
 * Returns:	0			Success
 *		EINVAL			Invalid argument
 *	copyout:EFAULT			Bad address
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getitimer</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> getitimer_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> itimerval aitv;

	<span class="enscript-keyword">if</span> (uap-&gt;which &gt; ITIMER_PROF)
		<span class="enscript-keyword">return</span>(EINVAL);

	bzero(&amp;aitv, <span class="enscript-keyword">sizeof</span>(aitv));

	proc_spinlock(p);
	<span class="enscript-keyword">switch</span> (uap-&gt;which) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ITIMER_REAL</span>:
		<span class="enscript-comment">/*
		 * If time for real time timer has passed return 0,
		 * else return difference between current time and
		 * time for the timer to go off.
		 */</span>
		aitv = p-&gt;p_realtimer;
		<span class="enscript-keyword">if</span> (timerisset(&amp;p-&gt;p_rtime)) {
			<span class="enscript-type">struct</span> timeval		now;

			microuptime(&amp;now);
			<span class="enscript-keyword">if</span> (timercmp(&amp;p-&gt;p_rtime, &amp;now, &lt;))
				timerclear(&amp;aitv.it_value);
			<span class="enscript-keyword">else</span> {
				aitv.it_value = p-&gt;p_rtime;
				timevalsub(&amp;aitv.it_value, &amp;now);
			}
		}
		<span class="enscript-keyword">else</span>
			timerclear(&amp;aitv.it_value);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ITIMER_VIRTUAL</span>:
		aitv = p-&gt;p_vtimer_user;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ITIMER_PROF</span>:
		aitv = p-&gt;p_vtimer_prof;
		<span class="enscript-keyword">break</span>;
	}

	proc_spinunlock(p);

	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		<span class="enscript-type">struct</span> user64_itimerval user_itv;
		user_itv.it_interval.tv_sec = aitv.it_interval.tv_sec;
		user_itv.it_interval.tv_usec = aitv.it_interval.tv_usec;
		user_itv.it_value.tv_sec = aitv.it_value.tv_sec;
		user_itv.it_value.tv_usec = aitv.it_value.tv_usec;
		<span class="enscript-keyword">return</span> (copyout((caddr_t)&amp;user_itv, uap-&gt;itv, <span class="enscript-keyword">sizeof</span> (user_itv)));
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_itimerval user_itv;
		user_itv.it_interval.tv_sec = aitv.it_interval.tv_sec;
		user_itv.it_interval.tv_usec = aitv.it_interval.tv_usec;
		user_itv.it_value.tv_sec = aitv.it_value.tv_sec;
		user_itv.it_value.tv_usec = aitv.it_value.tv_usec;
		<span class="enscript-keyword">return</span> (copyout((caddr_t)&amp;user_itv, uap-&gt;itv, <span class="enscript-keyword">sizeof</span> (user_itv)));
	}
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *		EINVAL			Invalid argument
 *	copyin:EFAULT			Bad address
 *	getitimer:EINVAL		Invalid argument
 *	getitimer:EFAULT		Bad address
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setitimer</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> setitimer_args *uap, int32_t *retval)
{
	<span class="enscript-type">struct</span> itimerval aitv;
	user_addr_t itvp;
	<span class="enscript-type">int</span> error;

	bzero(&amp;aitv, <span class="enscript-keyword">sizeof</span>(aitv));

	<span class="enscript-keyword">if</span> (uap-&gt;which &gt; ITIMER_PROF)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> ((itvp = uap-&gt;itv)) {
		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			<span class="enscript-type">struct</span> user64_itimerval user_itv;
			<span class="enscript-keyword">if</span> ((error = copyin(itvp, (caddr_t)&amp;user_itv, <span class="enscript-keyword">sizeof</span> (user_itv))))
				<span class="enscript-keyword">return</span> (error);
			aitv.it_interval.tv_sec = user_itv.it_interval.tv_sec;
			aitv.it_interval.tv_usec = user_itv.it_interval.tv_usec;
			aitv.it_value.tv_sec = user_itv.it_value.tv_sec;
			aitv.it_value.tv_usec = user_itv.it_value.tv_usec;
		} <span class="enscript-keyword">else</span> { 
			<span class="enscript-type">struct</span> user32_itimerval user_itv;
			<span class="enscript-keyword">if</span> ((error = copyin(itvp, (caddr_t)&amp;user_itv, <span class="enscript-keyword">sizeof</span> (user_itv))))
				<span class="enscript-keyword">return</span> (error);
			aitv.it_interval.tv_sec = user_itv.it_interval.tv_sec;
			aitv.it_interval.tv_usec = user_itv.it_interval.tv_usec;
			aitv.it_value.tv_sec = user_itv.it_value.tv_sec;
			aitv.it_value.tv_usec = user_itv.it_value.tv_usec;
		}
	}
	<span class="enscript-keyword">if</span> ((uap-&gt;itv = uap-&gt;oitv) &amp;&amp; (error = getitimer(p, (<span class="enscript-type">struct</span> getitimer_args *)uap, retval)))
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (itvp == 0)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">if</span> (itimerfix(&amp;aitv.it_value) || itimerfix(&amp;aitv.it_interval))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">switch</span> (uap-&gt;which) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ITIMER_REAL</span>:
		proc_spinlock(p);
		<span class="enscript-keyword">if</span> (timerisset(&amp;aitv.it_value)) {
			microuptime(&amp;p-&gt;p_rtime);
			timevaladd(&amp;p-&gt;p_rtime, &amp;aitv.it_value);
			p-&gt;p_realtimer = aitv;
			<span class="enscript-keyword">if</span> (!thread_call_enter_delayed_with_leeway(p-&gt;p_rcall, NULL,
					         tvtoabstime(&amp;p-&gt;p_rtime), 0, THREAD_CALL_DELAY_USER_NORMAL))
				p-&gt;p_ractive++;
		} <span class="enscript-keyword">else</span>  {
			timerclear(&amp;p-&gt;p_rtime);
			p-&gt;p_realtimer = aitv;
			<span class="enscript-keyword">if</span> (thread_call_cancel(p-&gt;p_rcall))
				p-&gt;p_ractive--;
		}
		proc_spinunlock(p);

		<span class="enscript-keyword">break</span>;


	<span class="enscript-keyword">case</span> <span class="enscript-reference">ITIMER_VIRTUAL</span>:
		<span class="enscript-keyword">if</span> (timerisset(&amp;aitv.it_value))
			task_vtimer_set(p-&gt;task, TASK_VTIMER_USER);
	<span class="enscript-keyword">else</span>
			task_vtimer_clear(p-&gt;task, TASK_VTIMER_USER);

		proc_spinlock(p);
		p-&gt;p_vtimer_user = aitv;
		proc_spinunlock(p);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">ITIMER_PROF</span>:
		<span class="enscript-keyword">if</span> (timerisset(&amp;aitv.it_value))
			task_vtimer_set(p-&gt;task, TASK_VTIMER_PROF);
		<span class="enscript-keyword">else</span>
			task_vtimer_clear(p-&gt;task, TASK_VTIMER_PROF);

		proc_spinlock(p);
		p-&gt;p_vtimer_prof = aitv;
		proc_spinunlock(p);
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Real interval timer expired:
 * send process whose timer expired an alarm signal.
 * If time is not set up to reload, then just return.
 * Else compute next time timer should go off which is &gt; current time.
 * This is where delay in processing this timeout causes multiple
 * SIGALRM calls to be compressed into one.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">realitexpire</span>(
	<span class="enscript-type">struct</span> proc	*p)
{
	<span class="enscript-type">struct</span> proc *r;
	<span class="enscript-type">struct</span> timeval	t;

	r = proc_find(p-&gt;p_pid);

	proc_spinlock(p);

	<span class="enscript-keyword">if</span> (--p-&gt;p_ractive &gt; 0 || r != p) {
		proc_spinunlock(p);

		<span class="enscript-keyword">if</span> (r != NULL)
			proc_rele(r);
		<span class="enscript-keyword">return</span>;
	}
	
	<span class="enscript-keyword">if</span> (!timerisset(&amp;p-&gt;p_realtimer.it_interval)) {
		timerclear(&amp;p-&gt;p_rtime);
		proc_spinunlock(p);

		psignal(p, SIGALRM);
		proc_rele(p);
		<span class="enscript-keyword">return</span>;
	}

	microuptime(&amp;t);
	timevaladd(&amp;p-&gt;p_rtime, &amp;p-&gt;p_realtimer.it_interval);
	<span class="enscript-keyword">if</span> (timercmp(&amp;p-&gt;p_rtime, &amp;t, &lt;=)) {
		<span class="enscript-keyword">if</span> ((p-&gt;p_rtime.tv_sec + 2) &gt;= t.tv_sec) {
			<span class="enscript-keyword">for</span> (;;) {
				timevaladd(&amp;p-&gt;p_rtime, &amp;p-&gt;p_realtimer.it_interval);
				<span class="enscript-keyword">if</span> (timercmp(&amp;p-&gt;p_rtime, &amp;t, &gt;))
					<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">else</span> {
			p-&gt;p_rtime = p-&gt;p_realtimer.it_interval;
			timevaladd(&amp;p-&gt;p_rtime, &amp;t);
		}
	}

	<span class="enscript-keyword">if</span> (!thread_call_enter_delayed(p-&gt;p_rcall, tvtoabstime(&amp;p-&gt;p_rtime)))
		p-&gt;p_ractive++;
	proc_spinunlock(p);

	psignal(p, SIGALRM);
	proc_rele(p);
}

<span class="enscript-comment">/*
 * Check that a proposed value to load into the .it_value or
 * .it_interval part of an interval timer is acceptable.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">itimerfix</span>(
	<span class="enscript-type">struct</span> timeval *tv)
{

	<span class="enscript-keyword">if</span> (tv-&gt;tv_sec &lt; 0 || tv-&gt;tv_sec &gt; 100000000 ||
	    tv-&gt;tv_usec &lt; 0 || tv-&gt;tv_usec &gt;= 1000000)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Decrement an interval timer by a specified number
 * of microseconds, which must be less than a second,
 * i.e. &lt; 1000000.  If the timer expires, then reload
 * it.  In this case, carry over (usec - old value) to
 * reduce the value reloaded into the timer so that
 * the timer does not drift.  This routine assumes
 * that it is called in a context where the timers
 * on which it is operating cannot change in value.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">itimerdecr</span>(proc_t p,
	<span class="enscript-type">struct</span> itimerval *itp, <span class="enscript-type">int</span> usec)
{

	proc_spinlock(p);
	
	<span class="enscript-keyword">if</span> (itp-&gt;it_value.tv_usec &lt; usec) {
		<span class="enscript-keyword">if</span> (itp-&gt;it_value.tv_sec == 0) {
			<span class="enscript-comment">/* expired, and already in next interval */</span>
			usec -= itp-&gt;it_value.tv_usec;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">expire</span>;
		}
		itp-&gt;it_value.tv_usec += 1000000;
		itp-&gt;it_value.tv_sec--;
	}
	itp-&gt;it_value.tv_usec -= usec;
	usec = 0;
	<span class="enscript-keyword">if</span> (timerisset(&amp;itp-&gt;it_value)) {
		proc_spinunlock(p);
		<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-comment">/* expired, exactly at end of interval */</span>
<span class="enscript-reference">expire</span>:
	<span class="enscript-keyword">if</span> (timerisset(&amp;itp-&gt;it_interval)) {
		itp-&gt;it_value = itp-&gt;it_interval;
		<span class="enscript-keyword">if</span> (itp-&gt;it_value.tv_sec &gt; 0) {
		itp-&gt;it_value.tv_usec -= usec;
		<span class="enscript-keyword">if</span> (itp-&gt;it_value.tv_usec &lt; 0) {
			itp-&gt;it_value.tv_usec += 1000000;
			itp-&gt;it_value.tv_sec--;
			}
		}
	} <span class="enscript-keyword">else</span>
		itp-&gt;it_value.tv_usec = 0;		<span class="enscript-comment">/* sec is already 0 */</span>
	proc_spinunlock(p);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Add and subtract routines for timevals.
 * N.B.: subtract routine doesn't deal with
 * results which are before the beginning,
 * it just gets very confused in this case.
 * Caveat emptor.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">timevaladd</span>(
	<span class="enscript-type">struct</span> timeval *t1,
	<span class="enscript-type">struct</span> timeval *t2)
{

	t1-&gt;tv_sec += t2-&gt;tv_sec;
	t1-&gt;tv_usec += t2-&gt;tv_usec;
	timevalfix(t1);
}
<span class="enscript-type">void</span>
<span class="enscript-function-name">timevalsub</span>(
	<span class="enscript-type">struct</span> timeval *t1,
	<span class="enscript-type">struct</span> timeval *t2)
{

	t1-&gt;tv_sec -= t2-&gt;tv_sec;
	t1-&gt;tv_usec -= t2-&gt;tv_usec;
	timevalfix(t1);
}
<span class="enscript-type">void</span>
<span class="enscript-function-name">timevalfix</span>(
	<span class="enscript-type">struct</span> timeval *t1)
{

	<span class="enscript-keyword">if</span> (t1-&gt;tv_usec &lt; 0) {
		t1-&gt;tv_sec--;
		t1-&gt;tv_usec += 1000000;
	}
	<span class="enscript-keyword">if</span> (t1-&gt;tv_usec &gt;= 1000000) {
		t1-&gt;tv_sec++;
		t1-&gt;tv_usec -= 1000000;
	}
}

<span class="enscript-comment">/*
 * Return the best possible estimate of the time in the timeval
 * to which tvp points.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">microtime</span>(
	<span class="enscript-type">struct</span> timeval	*tvp)
{
	clock_sec_t		tv_sec;
	clock_usec_t	tv_usec;

	clock_get_calendar_microtime(&amp;tv_sec, &amp;tv_usec);

	tvp-&gt;tv_sec = tv_sec;
	tvp-&gt;tv_usec = tv_usec;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">microtime_with_abstime</span>(
	<span class="enscript-type">struct</span> timeval	*tvp, uint64_t *abstime)
{
	clock_sec_t		tv_sec;
	clock_usec_t	tv_usec;

	clock_get_calendar_absolute_and_microtime(&amp;tv_sec, &amp;tv_usec, abstime);

	tvp-&gt;tv_sec = tv_sec;
	tvp-&gt;tv_usec = tv_usec;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">microuptime</span>(
	<span class="enscript-type">struct</span> timeval	*tvp)
{
	clock_sec_t		tv_sec;
	clock_usec_t	tv_usec;

	clock_get_system_microtime(&amp;tv_sec, &amp;tv_usec);

	tvp-&gt;tv_sec = tv_sec;
	tvp-&gt;tv_usec = tv_usec;
}

<span class="enscript-comment">/*
 * Ditto for timespec.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">nanotime</span>(
	<span class="enscript-type">struct</span> timespec *tsp)
{
	clock_sec_t		tv_sec;
	clock_nsec_t	tv_nsec;

	clock_get_calendar_nanotime(&amp;tv_sec, &amp;tv_nsec);

	tsp-&gt;tv_sec = tv_sec;
	tsp-&gt;tv_nsec = tv_nsec;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">nanouptime</span>(
	<span class="enscript-type">struct</span> timespec *tsp)
{
	clock_sec_t		tv_sec;
	clock_nsec_t	tv_nsec;

	clock_get_system_nanotime(&amp;tv_sec, &amp;tv_nsec);

	tsp-&gt;tv_sec = tv_sec;
	tsp-&gt;tv_nsec = tv_nsec;
}

uint64_t
<span class="enscript-function-name">tvtoabstime</span>(
	<span class="enscript-type">struct</span> timeval	*tvp)
{
	uint64_t	result, usresult;

	clock_interval_to_absolutetime_interval(
						tvp-&gt;tv_sec, NSEC_PER_SEC, &amp;result);
	clock_interval_to_absolutetime_interval(
						tvp-&gt;tv_usec, NSEC_PER_USEC, &amp;usresult);

	<span class="enscript-keyword">return</span> (result + usresult);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NETWORKING</span>
<span class="enscript-comment">/*
 * ratecheck(): simple time-based rate-limit checking.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ratecheck</span>(<span class="enscript-type">struct</span> timeval *lasttime, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> timeval *mininterval)
{
	<span class="enscript-type">struct</span> timeval tv, delta;
	<span class="enscript-type">int</span> rv = 0;

	net_uptime2timeval(&amp;tv);
	delta = tv;
	timevalsub(&amp;delta, lasttime);

	<span class="enscript-comment">/*
	 * check for 0,0 is so that the message will be seen at least once,
	 * even if interval is huge.
	 */</span>
	<span class="enscript-keyword">if</span> (timevalcmp(&amp;delta, mininterval, &gt;=) ||
	    (lasttime-&gt;tv_sec == 0 &amp;&amp; lasttime-&gt;tv_usec == 0)) {
		*lasttime = tv;
		rv = 1;
	}

	<span class="enscript-keyword">return</span> (rv);
}

<span class="enscript-comment">/*
 * ppsratecheck(): packets (or events) per second limitation.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">ppsratecheck</span>(<span class="enscript-type">struct</span> timeval *lasttime, <span class="enscript-type">int</span> *curpps, <span class="enscript-type">int</span> maxpps)
{
	<span class="enscript-type">struct</span> timeval tv, delta;
	<span class="enscript-type">int</span> rv;

	net_uptime2timeval(&amp;tv);

	timersub(&amp;tv, lasttime, &amp;delta);

	<span class="enscript-comment">/*
	 * Check for 0,0 so that the message will be seen at least once.
	 * If more than one second has passed since the last update of
	 * lasttime, reset the counter.
	 *
	 * we do increment *curpps even in *curpps &lt; maxpps case, as some may
	 * try to use *curpps for stat purposes as well.
	 */</span>
	<span class="enscript-keyword">if</span> ((lasttime-&gt;tv_sec == 0 &amp;&amp; lasttime-&gt;tv_usec == 0) ||
	    delta.tv_sec &gt;= 1) {
		*lasttime = tv;
		*curpps = 0;
		rv = 1;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (maxpps &lt; 0)
		rv = 1;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*curpps &lt; maxpps)
		rv = 1;
	<span class="enscript-keyword">else</span>
		rv = 0;

#<span class="enscript-reference">if</span> 1 <span class="enscript-comment">/* DIAGNOSTIC? */</span>
	<span class="enscript-comment">/* be careful about wrap-around */</span>
	<span class="enscript-keyword">if</span> (*curpps + 1 &gt; 0)
		*curpps = *curpps + 1;
#<span class="enscript-reference">else</span>
	<span class="enscript-comment">/*
	 * assume that there's not too many calls to this function.
	 * not sure if the assumption holds, as it depends on *caller's*
	 * behavior, not the behavior of this function.
	 * IMHO it is wrong to make assumption on the caller's behavior,
	 * so the above #if is #if 1, not #ifdef DIAGNOSTIC.
	 */</span>
	*curpps = *curpps + 1;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> (rv);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NETWORKING */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">time_zone_slock_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* allocate lock group attribute and group */</span>
	tz_slock_grp_attr = lck_grp_attr_alloc_init();

	tz_slock_grp =  lck_grp_alloc_init(<span class="enscript-string">&quot;tzlock&quot;</span>, tz_slock_grp_attr);

	<span class="enscript-comment">/* Allocate lock attribute */</span>
	tz_slock_attr = lck_attr_alloc_init();

	<span class="enscript-comment">/* Allocate the spin lock */</span>
	tz_slock = lck_spin_alloc_init(tz_slock_grp, tz_slock_attr);
}
</pre>
<hr />
</body></html>