<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>decmpfs.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">decmpfs.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2008-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">HFS_COMPRESSION</span>
<span class="enscript-comment">/* we need these symbols even though compression is turned off */</span>
<span class="enscript-type">char</span> register_decmpfs_decompressor;
<span class="enscript-type">char</span> unregister_decmpfs_decompressor;
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* HFS_COMPRESSION */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/xattr.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/decmpfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSByteOrder.h&gt;</span>

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> --- <span class="enscript-variable-name">debugging</span> ---

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COMPRESSION_DEBUG</span> 0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">COMPRESSION_DEBUG_VERBOSE</span> 0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MALLOC_DEBUG</span> 0

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">baseName</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *path)
{
    <span class="enscript-keyword">if</span> (!path)
        <span class="enscript-keyword">return</span> NULL;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *ret = path;
    <span class="enscript-type">int</span> i;
    <span class="enscript-keyword">for</span> (i = 0; path[i] != 0; i++) {
        <span class="enscript-keyword">if</span> (path[i] == <span class="enscript-string">'/'</span>)
            ret = &amp;path[i + 1];
    }
    <span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">static</span> <span class="enscript-type">char</span>*
<span class="enscript-function-name">vnpath</span>(vnode_t vp, <span class="enscript-type">char</span> *path, <span class="enscript-type">int</span> len)
{
    <span class="enscript-type">int</span> origlen = len;
    path[0] = 0;
    vn_getpath(vp, path, &amp;len);
    path[origlen - 1] = 0;
    <span class="enscript-keyword">return</span> path;
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ErrorLog</span>(x, args...) printf(<span class="enscript-string">&quot;%s:%d:%s: &quot;</span> x, baseName(__FILE__), __LINE__, __FUNCTION__, ## args)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">ErrorLogWithPath</span>(x, args...) do { char *path; MALLOC(path, char *, PATH_MAX, M_TEMP, M_WAITOK); printf(<span class="enscript-string">&quot;%s:%d:%s: %s: &quot;</span> x, baseName(__FILE__), __LINE__, __FUNCTION__, vnpath(vp, path, PATH_MAX), ## args); FREE(path, M_TEMP); } while(0)

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPRESSION_DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DebugLog</span> ErrorLog
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DebugLogWithPath</span> ErrorLogWithPath
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DebugLog</span>(x...) do { } while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DebugLogWithPath</span>(x...) do { } while(0)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPRESSION_DEBUG_VERBOSE</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VerboseLog</span> ErrorLog
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">VerboseLogWithPath</span> ErrorLogWithPath
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VerboseLog</span>(x...) do { } while(0)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">VerboseLogWithPath</span>(x...) do { } while(0)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MALLOC_DEBUG</span>

<span class="enscript-type">static</span> SInt32 totalAlloc;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
    uint32_t allocSz;
    uint32_t magic;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *file;
    <span class="enscript-type">int</span> line;
} allocated;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">_malloc</span>(uint32_t sz, __unused <span class="enscript-type">int</span> type, __unused <span class="enscript-type">int</span> flags, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *file, <span class="enscript-type">int</span> line)
{
    uint32_t allocSz = sz + 2 * <span class="enscript-keyword">sizeof</span>(allocated);
    
    allocated *alloc = NULL;
    MALLOC(alloc, allocated *, allocSz, type, flags);
    <span class="enscript-keyword">if</span> (!alloc) {
        ErrorLog(<span class="enscript-string">&quot;malloc failed\n&quot;</span>);
        <span class="enscript-keyword">return</span> NULL;
    }
    
    <span class="enscript-type">char</span> *ret = (<span class="enscript-type">char</span>*)&amp;alloc[1];
    allocated *alloc2 = (allocated*)(ret + sz);
	
    alloc-&gt;allocSz = allocSz;
    alloc-&gt;magic = 0xdadadada;
    alloc-&gt;file = file;
    alloc-&gt;line = line;
    
    *alloc2 = *alloc;
    
    <span class="enscript-type">int</span> s = OSAddAtomic(sz, &amp;totalAlloc);
    ErrorLog(<span class="enscript-string">&quot;malloc(%d) -&gt; %p, total allocations %d\n&quot;</span>, sz, ret, s + sz);
    
    <span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">_free</span>(<span class="enscript-type">char</span> *ret, __unused <span class="enscript-type">int</span> type, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *file, <span class="enscript-type">int</span> line)
{
    <span class="enscript-keyword">if</span> (!ret) {
        ErrorLog(<span class="enscript-string">&quot;freeing null\n&quot;</span>);
        <span class="enscript-keyword">return</span>;
    }
    allocated *alloc = (allocated*)ret;
    alloc--;
    uint32_t sz = alloc-&gt;allocSz - 2 * <span class="enscript-keyword">sizeof</span>(allocated);
    allocated *alloc2 = (allocated*)(ret + sz);
    
    <span class="enscript-keyword">if</span> (alloc-&gt;magic != 0xdadadada) {
        panic(<span class="enscript-string">&quot;freeing bad pointer&quot;</span>);
    }
	
    <span class="enscript-keyword">if</span> (memcmp(alloc, alloc2, <span class="enscript-keyword">sizeof</span>(*alloc)) != 0) {
        panic(<span class="enscript-string">&quot;clobbered data&quot;</span>);
    }
    
    memset(ret, 0xce, sz);
    alloc2-&gt;file = file;
    alloc2-&gt;line = line;
    FREE(alloc, type);
    <span class="enscript-type">int</span> s = OSAddAtomic(-sz, &amp;totalAlloc);
    ErrorLog(<span class="enscript-string">&quot;free(%p,%d) -&gt; total allocations %d\n&quot;</span>, ret, sz, s - sz);
}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">MALLOC</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">FREE</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MALLOC</span>(space, cast, size, type, flags) (space) = (cast)_malloc(size, type, flags, __FILE__, __LINE__)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">FREE</span>(addr, type) _free((void *)addr, type, __FILE__, __LINE__)

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MALLOC_DEBUG */</span>

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> --- <span class="enscript-variable-name">globals</span> ---

<span class="enscript-type">static</span> lck_grp_t *decmpfs_lockgrp;

<span class="enscript-type">static</span> decmpfs_registration * decompressors[CMP_MAX]; <span class="enscript-comment">/* the registered compressors */</span>
<span class="enscript-type">static</span> lck_rw_t * decompressorsLock;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> decompress_channel; <span class="enscript-comment">/* channel used by decompress_file to wake up waiters */</span>
<span class="enscript-type">static</span> lck_mtx_t *decompress_channel_mtx;

vfs_context_t decmpfs_ctx;

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> --- <span class="enscript-variable-name">decmp_get_func</span> ---

#<span class="enscript-reference">define</span> <span class="enscript-function-name">offsetof_func</span>(func) ((uintptr_t)(&amp;(((decmpfs_registration*)NULL)-&gt;func)))

<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">_func_from_offset</span>(uint32_t type, uintptr_t offset)
{
    <span class="enscript-comment">/* get the function at the given offset in the registration for the given type */</span>
    decmpfs_registration *reg = decompressors[type];
    <span class="enscript-type">char</span> *regChar = (<span class="enscript-type">char</span>*)reg;
    <span class="enscript-type">char</span> *func = &amp;regChar[offset];
    <span class="enscript-type">void</span> **funcPtr = (<span class="enscript-type">void</span>**)func;

    <span class="enscript-keyword">switch</span> (reg-&gt;decmpfs_registration) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">DECMPFS_REGISTRATION_VERSION_V1</span>:
            <span class="enscript-keyword">if</span> (offset &gt; offsetof_func(free_data))
                <span class="enscript-keyword">return</span> NULL;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">DECMPFS_REGISTRATION_VERSION_V3</span>:
            <span class="enscript-keyword">if</span> (offset &gt; offsetof_func(get_flags))
                <span class="enscript-keyword">return</span> NULL;
            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            <span class="enscript-keyword">return</span> NULL;
    }

    <span class="enscript-keyword">return</span> funcPtr[0];
}

<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">IOServicePublishResource</span>( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * property, boolean_t value );
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">IOServiceWaitForMatchingResource</span>( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * property, uint64_t timeout );
<span class="enscript-type">extern</span> boolean_t <span class="enscript-function-name">IOCatalogueMatchingDriversPresent</span>( <span class="enscript-type">const</span> <span class="enscript-type">char</span> * property );

<span class="enscript-type">static</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">_decmp_get_func</span>(vnode_t vp, uint32_t type, uintptr_t offset)
{
	<span class="enscript-comment">/*
	 this function should be called while holding a shared lock to decompressorsLock,
	 and will return with the lock held
	 */</span>
	
	<span class="enscript-keyword">if</span> (type &gt;= CMP_MAX)
		<span class="enscript-keyword">return</span> NULL;
	
	<span class="enscript-keyword">if</span> (decompressors[type] != NULL) {
		<span class="enscript-comment">// the compressor has already registered but the function might be null
</span>		<span class="enscript-keyword">return</span> _func_from_offset(type, offset);
	}
	
    <span class="enscript-comment">// does IOKit know about a kext that is supposed to provide this type?
</span>    <span class="enscript-type">char</span> providesName[80];
    snprintf(providesName, <span class="enscript-keyword">sizeof</span>(providesName), <span class="enscript-string">&quot;com.apple.AppleFSCompression.providesType%u&quot;</span>, type);
    <span class="enscript-keyword">if</span> (IOCatalogueMatchingDriversPresent(providesName)) {
        <span class="enscript-comment">// there is a kext that says it will register for this type, so let's wait for it
</span>        <span class="enscript-type">char</span> resourceName[80];
        uint64_t delay = 10000000ULL; <span class="enscript-comment">// 10 milliseconds.
</span>        snprintf(resourceName, <span class="enscript-keyword">sizeof</span>(resourceName), <span class="enscript-string">&quot;com.apple.AppleFSCompression.Type%u&quot;</span>, type);
        ErrorLogWithPath(<span class="enscript-string">&quot;waiting for %s\n&quot;</span>, resourceName);
        <span class="enscript-keyword">while</span>(decompressors[type] == NULL) {
            lck_rw_unlock_shared(decompressorsLock); <span class="enscript-comment">// we have to unlock to allow the kext to register
</span>            <span class="enscript-keyword">if</span> (IOServiceWaitForMatchingResource(resourceName, delay)) {
                lck_rw_lock_shared(decompressorsLock);
                <span class="enscript-keyword">break</span>;
            }
            <span class="enscript-keyword">if</span> (!IOCatalogueMatchingDriversPresent(providesName)) {
                <span class="enscript-comment">// 
</span>                ErrorLogWithPath(<span class="enscript-string">&quot;the kext with %s is no longer present\n&quot;</span>, providesName);
                lck_rw_lock_shared(decompressorsLock);
                <span class="enscript-keyword">break</span>;
            }
            ErrorLogWithPath(<span class="enscript-string">&quot;still waiting for %s\n&quot;</span>, resourceName);
            delay *= 2;
            lck_rw_lock_shared(decompressorsLock);
        }
        <span class="enscript-comment">// IOKit says the kext is loaded, so it should be registered too!
</span>        <span class="enscript-keyword">if</span> (decompressors[type] == NULL) {
            ErrorLogWithPath(<span class="enscript-string">&quot;we found %s, but the type still isn't registered\n&quot;</span>, providesName);
            <span class="enscript-keyword">return</span> NULL;
        }
        <span class="enscript-comment">// it's now registered, so let's return the function
</span>        <span class="enscript-keyword">return</span> _func_from_offset(type, offset);
    }
    
	<span class="enscript-comment">// the compressor hasn't registered, so it never will unless someone manually kextloads it
</span>	ErrorLogWithPath(<span class="enscript-string">&quot;tried to access a compressed file of unregistered type %d\n&quot;</span>, type);
	<span class="enscript-keyword">return</span> NULL;
}

#<span class="enscript-reference">define</span> <span class="enscript-function-name">decmp_get_func</span>(vp, type, func) ((typeof(((decmpfs_registration*)NULL)-&gt;func))_decmp_get_func(vp, type, offsetof_func(func)))

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> --- <span class="enscript-variable-name">utilities</span> ---

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPRESSION_DEBUG</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">vnsize</span>(vnode_t vp, uint64_t *size)
{
    <span class="enscript-type">struct</span> vnode_attr va;
    VATTR_INIT(&amp;va);
    VATTR_WANTED(&amp;va, va_data_size);
	<span class="enscript-type">int</span> error = vnode_getattr(vp, &amp;va, decmpfs_ctx);
    <span class="enscript-keyword">if</span> (error != 0) {
        ErrorLogWithPath(<span class="enscript-string">&quot;vnode_getattr err %d\n&quot;</span>, error);
        <span class="enscript-keyword">return</span> error;
    }
    *size = va.va_data_size;
    <span class="enscript-keyword">return</span> 0;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* COMPRESSION_DEBUG */</span>

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> --- <span class="enscript-variable-name">cnode</span> <span class="enscript-variable-name">routines</span> ---

<span class="enscript-type">void</span>
<span class="enscript-function-name">decmpfs_cnode_init</span>(decmpfs_cnode *cp)
{
    memset(cp, 0, <span class="enscript-keyword">sizeof</span>(*cp));
	lck_rw_init(&amp;cp-&gt;compressed_data_lock, decmpfs_lockgrp, NULL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">decmpfs_cnode_destroy</span>(decmpfs_cnode *cp)
{
	lck_rw_destroy(&amp;cp-&gt;compressed_data_lock, decmpfs_lockgrp);
}

boolean_t
<span class="enscript-function-name">decmpfs_trylock_compressed_data</span>(decmpfs_cnode *cp, <span class="enscript-type">int</span> exclusive)
{
	<span class="enscript-type">void</span> *thread = current_thread();
	boolean_t retval = FALSE;

	<span class="enscript-keyword">if</span> (cp-&gt;lockowner == thread) {
		<span class="enscript-comment">/* this thread is already holding an exclusive lock, so bump the count */</span>
		cp-&gt;lockcount++;
		retval = TRUE;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (exclusive) {
		<span class="enscript-keyword">if</span> ((retval = lck_rw_try_lock_exclusive(&amp;cp-&gt;compressed_data_lock))) {
			cp-&gt;lockowner = thread;
			cp-&gt;lockcount = 1;
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> ((retval = lck_rw_try_lock_shared(&amp;cp-&gt;compressed_data_lock))) {
			cp-&gt;lockowner = (<span class="enscript-type">void</span> *)-1;
		}
	}
	<span class="enscript-keyword">return</span> retval;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">decmpfs_lock_compressed_data</span>(decmpfs_cnode *cp, <span class="enscript-type">int</span> exclusive)
{
	<span class="enscript-type">void</span> *thread = current_thread();
	
	<span class="enscript-keyword">if</span> (cp-&gt;lockowner == thread) {
		<span class="enscript-comment">/* this thread is already holding an exclusive lock, so bump the count */</span>
		cp-&gt;lockcount++;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (exclusive) {
		lck_rw_lock_exclusive(&amp;cp-&gt;compressed_data_lock);
		cp-&gt;lockowner = thread;
		cp-&gt;lockcount = 1;
	} <span class="enscript-keyword">else</span> {
		lck_rw_lock_shared(&amp;cp-&gt;compressed_data_lock);
		cp-&gt;lockowner = (<span class="enscript-type">void</span> *)-1;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">decmpfs_unlock_compressed_data</span>(decmpfs_cnode *cp, __unused <span class="enscript-type">int</span> exclusive)
{
	<span class="enscript-type">void</span> *thread = current_thread();
	
	<span class="enscript-keyword">if</span> (cp-&gt;lockowner == thread) {
		<span class="enscript-comment">/* this thread is holding an exclusive lock, so decrement the count */</span>
		<span class="enscript-keyword">if</span> ((--cp-&gt;lockcount) &gt; 0) {
			<span class="enscript-comment">/* the caller still has outstanding locks, so we're done */</span>
			<span class="enscript-keyword">return</span>;
		}
		cp-&gt;lockowner = NULL;
	}
	
	lck_rw_done(&amp;cp-&gt;compressed_data_lock);
}

uint32_t
<span class="enscript-function-name">decmpfs_cnode_get_vnode_state</span>(decmpfs_cnode *cp)
{
    <span class="enscript-keyword">return</span> cp-&gt;cmp_state;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">decmpfs_cnode_set_vnode_state</span>(decmpfs_cnode *cp, uint32_t state, <span class="enscript-type">int</span> skiplock)
{
	<span class="enscript-keyword">if</span> (!skiplock) decmpfs_lock_compressed_data(cp, 1);
	cp-&gt;cmp_state = state;
    <span class="enscript-keyword">if</span> (state == FILE_TYPE_UNKNOWN) {
        <span class="enscript-comment">/* clear out the compression type too */</span>
        cp-&gt;cmp_type = 0;
    }
	<span class="enscript-keyword">if</span> (!skiplock) decmpfs_unlock_compressed_data(cp, 1);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">decmpfs_cnode_set_vnode_cmp_type</span>(decmpfs_cnode *cp, uint32_t cmp_type, <span class="enscript-type">int</span> skiplock)
{
    <span class="enscript-keyword">if</span> (!skiplock) decmpfs_lock_compressed_data(cp, 1);
    cp-&gt;cmp_type = cmp_type;
    <span class="enscript-keyword">if</span> (!skiplock) decmpfs_unlock_compressed_data(cp, 1);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">decmpfs_cnode_set_vnode_minimal_xattr</span>(decmpfs_cnode *cp, <span class="enscript-type">int</span> minimal_xattr, <span class="enscript-type">int</span> skiplock)
{
    <span class="enscript-keyword">if</span> (!skiplock) decmpfs_lock_compressed_data(cp, 1);
    cp-&gt;cmp_minimal_xattr = minimal_xattr;
    <span class="enscript-keyword">if</span> (!skiplock) decmpfs_unlock_compressed_data(cp, 1);
}

uint64_t
<span class="enscript-function-name">decmpfs_cnode_get_vnode_cached_size</span>(decmpfs_cnode *cp)
{
    <span class="enscript-keyword">return</span> cp-&gt;uncompressed_size;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">decmpfs_cnode_set_vnode_cached_size</span>(decmpfs_cnode *cp, uint64_t size)
{
    <span class="enscript-keyword">while</span>(1) {
        uint64_t old = cp-&gt;uncompressed_size;
        <span class="enscript-keyword">if</span> (OSCompareAndSwap64(old, size, (UInt64*)&amp;cp-&gt;uncompressed_size)) {
            <span class="enscript-keyword">return</span>;
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-comment">/* failed to write our value, so loop */</span>
        }
    }
}

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">decmpfs_cnode_get_decompression_flags</span>(decmpfs_cnode *cp)
{
    <span class="enscript-keyword">return</span> cp-&gt;decompression_flags;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">decmpfs_cnode_set_decompression_flags</span>(decmpfs_cnode *cp, uint64_t flags)
{
    <span class="enscript-keyword">while</span>(1) {
        uint64_t old = cp-&gt;decompression_flags;
        <span class="enscript-keyword">if</span> (OSCompareAndSwap64(old, flags, (UInt64*)&amp;cp-&gt;decompression_flags)) {
            <span class="enscript-keyword">return</span>;
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-comment">/* failed to write our value, so loop */</span>
        }
    }
}

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> --- <span class="enscript-variable-name">decmpfs</span> <span class="enscript-variable-name">state</span> <span class="enscript-variable-name">routines</span> ---

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">decmpfs_fetch_compressed_header</span>(vnode_t vp, decmpfs_cnode *cp, decmpfs_header **hdrOut, <span class="enscript-type">int</span> returnInvalid)
{
    <span class="enscript-comment">/*
     fetches vp's compression xattr, converting it into a decmpfs_header; returns 0 or errno
     if returnInvalid == 1, returns the header even if the type was invalid (out of range),
     and return ERANGE in that case
     */</span>
    
	size_t read_size             = 0;
	size_t attr_size             = 0;
    uio_t attr_uio               = NULL;
    <span class="enscript-type">int</span> err                      = 0;
    <span class="enscript-type">char</span> *data                   = NULL;
    decmpfs_header *hdr = NULL;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF(1) ];
    
    <span class="enscript-keyword">if</span> ((cp != NULL) &amp;&amp;
        (cp-&gt;cmp_type != 0) &amp;&amp;
        (cp-&gt;cmp_minimal_xattr != 0)) {
        <span class="enscript-comment">/* this file's xattr didn't have any extra data when we fetched it, so we can synthesize a header from the data in the cnode */</span>
        
        MALLOC(data, <span class="enscript-type">char</span> *, <span class="enscript-keyword">sizeof</span>(decmpfs_header), M_TEMP, M_WAITOK);
        <span class="enscript-keyword">if</span> (!data) {
            err = ENOMEM;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }
        hdr = (decmpfs_header*)data;
        hdr-&gt;attr_size = <span class="enscript-keyword">sizeof</span>(decmpfs_disk_header);
        hdr-&gt;compression_magic = DECMPFS_MAGIC;
        hdr-&gt;compression_type  = cp-&gt;cmp_type;
        hdr-&gt;uncompressed_size = decmpfs_cnode_get_vnode_cached_size(cp);
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-comment">/* figure out how big the xattr is on disk */</span>
        err = vn_getxattr(vp, DECMPFS_XATTR_NAME, NULL, &amp;attr_size, XATTR_NOSECURITY, decmpfs_ctx);
        <span class="enscript-keyword">if</span> (err != 0)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        
        <span class="enscript-keyword">if</span> (attr_size &lt; <span class="enscript-keyword">sizeof</span>(decmpfs_disk_header) || attr_size &gt; MAX_DECMPFS_XATTR_SIZE) {
            err = EINVAL;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }
        
        <span class="enscript-comment">/* allocation includes space for the extra attr_size field of a compressed_header */</span>
        MALLOC(data, <span class="enscript-type">char</span> *, attr_size + <span class="enscript-keyword">sizeof</span>(hdr-&gt;attr_size), M_TEMP, M_WAITOK);
        <span class="enscript-keyword">if</span> (!data) {
            err = ENOMEM;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }
        
        <span class="enscript-comment">/* read the xattr into our buffer, skipping over the attr_size field at the beginning */</span>
        attr_uio = uio_createwithbuffer(1, 0, UIO_SYSSPACE, UIO_READ, &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span>(uio_buf));
        uio_addiov(attr_uio, CAST_USER_ADDR_T(data + <span class="enscript-keyword">sizeof</span>(hdr-&gt;attr_size)), attr_size);
        
        err = vn_getxattr(vp, DECMPFS_XATTR_NAME, attr_uio, &amp;read_size, XATTR_NOSECURITY, decmpfs_ctx);
        <span class="enscript-keyword">if</span> (err != 0)
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        <span class="enscript-keyword">if</span> (read_size != attr_size) {
            err = EINVAL;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }
        hdr = (decmpfs_header*)data;
        hdr-&gt;attr_size = attr_size;
        <span class="enscript-comment">/* swap the fields to native endian */</span>
        hdr-&gt;compression_magic = OSSwapLittleToHostInt32(hdr-&gt;compression_magic);
        hdr-&gt;compression_type  = OSSwapLittleToHostInt32(hdr-&gt;compression_type);
        hdr-&gt;uncompressed_size = OSSwapLittleToHostInt64(hdr-&gt;uncompressed_size);
    }
    
    <span class="enscript-keyword">if</span> (hdr-&gt;compression_magic != DECMPFS_MAGIC) {
        ErrorLogWithPath(<span class="enscript-string">&quot;invalid compression_magic 0x%08x, should be 0x%08x\n&quot;</span>, hdr-&gt;compression_magic, DECMPFS_MAGIC);
        err = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
	
    <span class="enscript-keyword">if</span> (hdr-&gt;compression_type &gt;= CMP_MAX) {
        <span class="enscript-keyword">if</span> (returnInvalid) {
            <span class="enscript-comment">/* return the header even though the type is out of range */</span>
            err = ERANGE;
        } <span class="enscript-keyword">else</span> {
            ErrorLogWithPath(<span class="enscript-string">&quot;compression_type %d out of range\n&quot;</span>, hdr-&gt;compression_type);
            err = EINVAL;
        }
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
	
<span class="enscript-reference">out</span>:
    <span class="enscript-keyword">if</span> (err &amp;&amp; (err != ERANGE)) {
        DebugLogWithPath(<span class="enscript-string">&quot;err %d\n&quot;</span>, err);
        <span class="enscript-keyword">if</span> (data) FREE(data, M_TEMP);
        *hdrOut = NULL;
    } <span class="enscript-keyword">else</span> {
        *hdrOut = hdr;
    }
    <span class="enscript-keyword">return</span> err;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">decmpfs_fast_get_state</span>(decmpfs_cnode *cp)
{
    <span class="enscript-comment">/*
     return the cached state
     this should *only* be called when we know that decmpfs_file_is_compressed has already been called,
     because this implies that the cached state is valid
     */</span>
    <span class="enscript-type">int</span> cmp_state = decmpfs_cnode_get_vnode_state(cp);
	
    <span class="enscript-keyword">switch</span>(cmp_state) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_NOT_COMPRESSED</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_COMPRESSED</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_CONVERTING</span>:
            <span class="enscript-keyword">return</span> cmp_state;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_TYPE_UNKNOWN</span>:
            <span class="enscript-comment">/*
             we should only get here if decmpfs_file_is_compressed was not called earlier on this vnode,
             which should not be possible
             */</span>
            ErrorLog(<span class="enscript-string">&quot;decmpfs_fast_get_state called on unknown file\n&quot;</span>);
            <span class="enscript-keyword">return</span> FILE_IS_NOT_COMPRESSED;
        <span class="enscript-reference">default</span>:
            <span class="enscript-comment">/* */</span>
            ErrorLog(<span class="enscript-string">&quot;unknown cmp_state %d\n&quot;</span>, cmp_state);
            <span class="enscript-keyword">return</span> FILE_IS_NOT_COMPRESSED;
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">decmpfs_fast_file_is_compressed</span>(decmpfs_cnode *cp)
{
    <span class="enscript-type">int</span> cmp_state = decmpfs_cnode_get_vnode_state(cp);
	
    <span class="enscript-keyword">switch</span>(cmp_state) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_NOT_COMPRESSED</span>:
			<span class="enscript-keyword">return</span> 0;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_COMPRESSED</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_CONVERTING</span>:
            <span class="enscript-keyword">return</span> 1;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_TYPE_UNKNOWN</span>:
            <span class="enscript-comment">/*
             we should only get here if decmpfs_file_is_compressed was not called earlier on this vnode,
             which should not be possible
             */</span>
            ErrorLog(<span class="enscript-string">&quot;decmpfs_fast_get_state called on unknown file\n&quot;</span>);
            <span class="enscript-keyword">return</span> 0;
        <span class="enscript-reference">default</span>:
            <span class="enscript-comment">/* */</span>
            ErrorLog(<span class="enscript-string">&quot;unknown cmp_state %d\n&quot;</span>, cmp_state);
            <span class="enscript-keyword">return</span> 0;
    }
}

errno_t
<span class="enscript-function-name">decmpfs_validate_compressed_file</span>(vnode_t vp, decmpfs_cnode *cp)
{
    <span class="enscript-comment">/* give a compressor a chance to indicate that a compressed file is invalid */</span>
    
    decmpfs_header *hdr = NULL;
    errno_t err = decmpfs_fetch_compressed_header(vp, cp, &amp;hdr, 0);
    <span class="enscript-keyword">if</span> (err) {
        <span class="enscript-comment">/* we couldn't get the header */</span>
        <span class="enscript-keyword">if</span> (decmpfs_fast_get_state(cp) == FILE_IS_NOT_COMPRESSED) {
            <span class="enscript-comment">/* the file is no longer compressed, so return success */</span>
            err = 0;
        }
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    
    lck_rw_lock_shared(decompressorsLock);
    decmpfs_validate_compressed_file_func validate = decmp_get_func(vp, hdr-&gt;compression_type, validate);
    <span class="enscript-keyword">if</span> (validate) {    <span class="enscript-comment">/* make sure this validation function is valid */</span>
        <span class="enscript-comment">/* is the data okay? */</span>
		err = validate(vp, decmpfs_ctx, hdr);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (decmp_get_func(vp, hdr-&gt;compression_type, fetch) == NULL) {
        <span class="enscript-comment">/* the type isn't registered */</span>
        err = EIO;
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-comment">/* no validate registered, so nothing to do */</span>
        err = 0;
    }
    lck_rw_unlock_shared(decompressorsLock);
<span class="enscript-reference">out</span>:
    <span class="enscript-keyword">if</span> (hdr) FREE(hdr, M_TEMP);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPRESSION_DEBUG</span>
    <span class="enscript-keyword">if</span> (err) {
        DebugLogWithPath(<span class="enscript-string">&quot;decmpfs_validate_compressed_file ret %d, vp-&gt;v_flag %d\n&quot;</span>, err, vp-&gt;v_flag);
    }
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span> err;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">decmpfs_file_is_compressed</span>(vnode_t vp, decmpfs_cnode *cp)
{
    <span class="enscript-comment">/*
     determines whether vp points to a compressed file
	 
     to speed up this operation, we cache the result in the cnode, and do as little as possible
     in the case where the cnode already has a valid cached state
     
     */</span>
    
    <span class="enscript-type">int</span> ret = 0;
	<span class="enscript-type">int</span> error = 0;
	uint32_t cmp_state;
	<span class="enscript-type">struct</span> vnode_attr va_fetch;
    decmpfs_header *hdr = NULL;
    mount_t mp = NULL;
	<span class="enscript-type">int</span> cnode_locked = 0;
    <span class="enscript-type">int</span> saveInvalid = 0; <span class="enscript-comment">// save the header data even though the type was out of range
</span>    uint64_t decompression_flags = 0;
	
    <span class="enscript-keyword">if</span> (vnode_isnamedstream(vp)) {
        <span class="enscript-comment">/*
         named streams can't be compressed
         since named streams of the same file share the same cnode,
         we don't want to get/set the state in the cnode, just return 0
         */</span>
        <span class="enscript-keyword">return</span> 0;
    }
    
    <span class="enscript-comment">/* examine the cached a state in this cnode */</span>    
    cmp_state = decmpfs_cnode_get_vnode_state(cp);
    <span class="enscript-keyword">switch</span>(cmp_state) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_NOT_COMPRESSED</span>:
			<span class="enscript-keyword">return</span> 0;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_COMPRESSED</span>:
			<span class="enscript-keyword">return</span> 1;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_CONVERTING</span>:
            <span class="enscript-comment">/* treat the file as compressed, because this gives us a way to block future reads until decompression is done */</span>
            <span class="enscript-keyword">return</span> 1;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_TYPE_UNKNOWN</span>:
            <span class="enscript-comment">/* the first time we encountered this vnode, so we need to check it out */</span>
            <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
            <span class="enscript-comment">/* unknown state, assume file is not compressed */</span>
            ErrorLogWithPath(<span class="enscript-string">&quot;unknown cmp_state %d\n&quot;</span>, cmp_state);
            <span class="enscript-keyword">return</span> 0;
    }
    
    <span class="enscript-keyword">if</span> (!vnode_isreg(vp)) {
        <span class="enscript-comment">/* only regular files can be compressed */</span>
        ret = FILE_IS_NOT_COMPRESSED;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    
    mp = vnode_mount(vp); 
    <span class="enscript-keyword">if</span> (mp == NULL) {
        <span class="enscript-comment">/*
         this should only be true before we mount the root filesystem
         we short-cut this return to avoid the call to getattr below, which
         will fail before root is mounted
         */</span>
        ret = FILE_IS_NOT_COMPRESSED;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    <span class="enscript-keyword">if</span> ((mp-&gt;mnt_flag &amp; MNT_LOCAL) == 0) {
        <span class="enscript-comment">/* compression only supported on local filesystems */</span>
        ret = FILE_IS_NOT_COMPRESSED;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    
	<span class="enscript-comment">/* lock our cnode data so that another caller doesn't change the state under us */</span>
	decmpfs_lock_compressed_data(cp, 1);
	cnode_locked = 1;
	
	VATTR_INIT(&amp;va_fetch);
	VATTR_WANTED(&amp;va_fetch, va_flags);
	error = vnode_getattr(vp, &amp;va_fetch, decmpfs_ctx);
	<span class="enscript-keyword">if</span> (error) {
        <span class="enscript-comment">/* failed to get the bsd flags so the file is not compressed */</span>
        ret = FILE_IS_NOT_COMPRESSED;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
	<span class="enscript-keyword">if</span> (va_fetch.va_flags &amp; UF_COMPRESSED) {
		<span class="enscript-comment">/* UF_COMPRESSED is on, make sure the file has the DECMPFS_XATTR_NAME xattr */</span>
        error = decmpfs_fetch_compressed_header(vp, cp, &amp;hdr, 1);
        <span class="enscript-keyword">if</span> ((hdr != NULL) &amp;&amp; (error == ERANGE)) {
            saveInvalid = 1;
        }
        <span class="enscript-keyword">if</span> (error) {
            <span class="enscript-comment">/* failed to get the xattr so the file is not compressed */</span>
            ret = FILE_IS_NOT_COMPRESSED;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
        }
        <span class="enscript-comment">/* we got the xattr, so the file is compressed */</span>
        ret = FILE_IS_COMPRESSED;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
    <span class="enscript-comment">/* UF_COMPRESSED isn't on, so the file isn't compressed */</span>
    ret = FILE_IS_NOT_COMPRESSED;
    
<span class="enscript-reference">done</span>:
    <span class="enscript-keyword">if</span> (((ret == FILE_IS_COMPRESSED) || saveInvalid) &amp;&amp; hdr) {
		<span class="enscript-comment">/*
		 cache the uncompressed size away in the cnode
		 */</span>
		
		<span class="enscript-keyword">if</span> (!cnode_locked) {
			<span class="enscript-comment">/*
			 we should never get here since the only place ret is set to FILE_IS_COMPRESSED
			 is after the call to decmpfs_lock_compressed_data above
			 */</span>
			decmpfs_lock_compressed_data(cp, 1);
			cnode_locked = 1;
		}
		
        decmpfs_cnode_set_vnode_cached_size(cp, hdr-&gt;uncompressed_size);
		decmpfs_cnode_set_vnode_state(cp, ret, 1);
        decmpfs_cnode_set_vnode_cmp_type(cp, hdr-&gt;compression_type, 1);
        <span class="enscript-comment">/* remember if the xattr's size was equal to the minimal xattr */</span>
        <span class="enscript-keyword">if</span> (hdr-&gt;attr_size == <span class="enscript-keyword">sizeof</span>(decmpfs_disk_header)) {
            decmpfs_cnode_set_vnode_minimal_xattr(cp, 1, 1);
        }
        <span class="enscript-keyword">if</span> (ret == FILE_IS_COMPRESSED) {
            <span class="enscript-comment">/* update the ubc's size for this file */</span>
            ubc_setsize(vp, hdr-&gt;uncompressed_size);
            
            <span class="enscript-comment">/* update the decompression flags in the decmpfs cnode */</span>
            lck_rw_lock_shared(decompressorsLock);
            decmpfs_get_decompression_flags_func get_flags = decmp_get_func(vp, hdr-&gt;compression_type, get_flags);
            <span class="enscript-keyword">if</span> (get_flags) {
                decompression_flags = get_flags(vp, decmpfs_ctx, hdr);
            }
            lck_rw_unlock_shared(decompressorsLock);
            decmpfs_cnode_set_decompression_flags(cp, decompression_flags);
        }
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* we might have already taken the lock above; if so, skip taking it again by passing cnode_locked as the skiplock parameter */</span>
		decmpfs_cnode_set_vnode_state(cp, ret, cnode_locked);
	}
	
	<span class="enscript-keyword">if</span> (cnode_locked) decmpfs_unlock_compressed_data(cp, 1);
    
    <span class="enscript-keyword">if</span> (hdr) FREE(hdr, M_TEMP);
	
	<span class="enscript-keyword">switch</span>(ret) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_NOT_COMPRESSED</span>:
			<span class="enscript-keyword">return</span> 0;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_COMPRESSED</span>:
        <span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_CONVERTING</span>:
			<span class="enscript-keyword">return</span> 1;
        <span class="enscript-reference">default</span>:
            <span class="enscript-comment">/* unknown state, assume file is not compressed */</span>
            ErrorLogWithPath(<span class="enscript-string">&quot;unknown ret %d\n&quot;</span>, ret);
            <span class="enscript-keyword">return</span> 0;
    }
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">decmpfs_update_attributes</span>(vnode_t vp, <span class="enscript-type">struct</span> vnode_attr *vap)
{
    <span class="enscript-type">int</span> error = 0;
    
    <span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_flags)) {
        <span class="enscript-comment">/* the BSD flags are being updated */</span>
        <span class="enscript-keyword">if</span> (vap-&gt;va_flags &amp; UF_COMPRESSED) {
            <span class="enscript-comment">/* the compressed bit is being set, did it change? */</span>
            <span class="enscript-type">struct</span> vnode_attr va_fetch;
            <span class="enscript-type">int</span> old_flags = 0;
            VATTR_INIT(&amp;va_fetch);
            VATTR_WANTED(&amp;va_fetch, va_flags);
			error = vnode_getattr(vp, &amp;va_fetch, decmpfs_ctx);
            <span class="enscript-keyword">if</span> (error)
                <span class="enscript-keyword">return</span> error;
            
            old_flags = va_fetch.va_flags;
            
            <span class="enscript-keyword">if</span> (!(old_flags &amp; UF_COMPRESSED)) {
                <span class="enscript-comment">/*
                 * Compression bit was turned on, make sure the file has the DECMPFS_XATTR_NAME attribute.
                 * This precludes anyone from using the UF_COMPRESSED bit for anything else, and it enforces
                 * an order of operation -- you must first do the setxattr and then the chflags.
                 */</span>
				
				<span class="enscript-keyword">if</span> (VATTR_IS_ACTIVE(vap, va_data_size)) {
					<span class="enscript-comment">/*
					 * don't allow the caller to set the BSD flag and the size in the same call
					 * since this doesn't really make sense
					 */</span>
					vap-&gt;va_flags &amp;= ~UF_COMPRESSED;
					<span class="enscript-keyword">return</span> 0;
				}
				
                decmpfs_header *hdr = NULL;
                error = decmpfs_fetch_compressed_header(vp, NULL, &amp;hdr, 1);
                <span class="enscript-keyword">if</span> (error == 0) {
                    <span class="enscript-comment">/*
                     allow the flag to be set since the decmpfs attribute is present
                     in that case, we also want to truncate the data fork of the file
                     */</span>
                    VATTR_SET_ACTIVE(vap, va_data_size);
                    vap-&gt;va_data_size = 0;
                } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == ERANGE) {
                    <span class="enscript-comment">/* the file had a decmpfs attribute but the type was out of range, so don't muck with the file's data size */</span>
                } <span class="enscript-keyword">else</span> {
                    <span class="enscript-comment">/* no DECMPFS_XATTR_NAME attribute, so deny the update */</span>
					vap-&gt;va_flags &amp;= ~UF_COMPRESSED;
                }
                <span class="enscript-keyword">if</span> (hdr) FREE(hdr, M_TEMP);
            }
        }
    }
    
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">wait_for_decompress</span>(decmpfs_cnode *cp)
{
    <span class="enscript-type">int</span> state;
    lck_mtx_lock(decompress_channel_mtx);
    <span class="enscript-keyword">do</span> {
        state = decmpfs_fast_get_state(cp);
        <span class="enscript-keyword">if</span> (state != FILE_IS_CONVERTING) {
            <span class="enscript-comment">/* file is not decompressing */</span>
            lck_mtx_unlock(decompress_channel_mtx);
            <span class="enscript-keyword">return</span> state;
        }
        msleep((caddr_t)&amp;decompress_channel, decompress_channel_mtx, PINOD, <span class="enscript-string">&quot;wait_for_decompress&quot;</span>, NULL);
    } <span class="enscript-keyword">while</span>(1);
}

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> --- <span class="enscript-variable-name">decmpfs</span> <span class="enscript-variable-name">hide</span> <span class="enscript-variable-name">query</span> <span class="enscript-variable-name">routines</span> ---

<span class="enscript-type">int</span>
<span class="enscript-function-name">decmpfs_hides_rsrc</span>(vfs_context_t ctx, decmpfs_cnode *cp)
{
	<span class="enscript-comment">/*
	 WARNING!!!
	 callers may (and do) pass NULL for ctx, so we should only use it
	 for this equality comparison
	 
	 This routine should only be called after a file has already been through decmpfs_file_is_compressed
	 */</span>
	
	<span class="enscript-keyword">if</span> (ctx == decmpfs_ctx)
		<span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-keyword">if</span> (!decmpfs_fast_file_is_compressed(cp))
		<span class="enscript-keyword">return</span> 0;
	
	<span class="enscript-comment">/* all compressed files hide their resource fork */</span>
	<span class="enscript-keyword">return</span> 1;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">decmpfs_hides_xattr</span>(vfs_context_t ctx, decmpfs_cnode *cp, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *xattr)
{
	<span class="enscript-comment">/*
	 WARNING!!!
	 callers may (and do) pass NULL for ctx, so we should only use it
	 for this equality comparison
     
	 This routine should only be called after a file has already been through decmpfs_file_is_compressed
	 */</span>
	
	<span class="enscript-keyword">if</span> (ctx == decmpfs_ctx)
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">if</span> (strncmp(xattr, XATTR_RESOURCEFORK_NAME, <span class="enscript-keyword">sizeof</span>(XATTR_RESOURCEFORK_NAME) - 1) == 0)
		<span class="enscript-keyword">return</span> decmpfs_hides_rsrc(ctx, cp);
	<span class="enscript-keyword">if</span> (!decmpfs_fast_file_is_compressed(cp))
    <span class="enscript-comment">/* file is not compressed, so don't hide this xattr */</span>
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">if</span> (strncmp(xattr, DECMPFS_XATTR_NAME, <span class="enscript-keyword">sizeof</span>(DECMPFS_XATTR_NAME) - 1) == 0)
    <span class="enscript-comment">/* it's our xattr, so hide it */</span>
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-comment">/* don't hide this xattr */</span>
	<span class="enscript-keyword">return</span> 0;
}

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> --- <span class="enscript-variable-name">registration</span>/<span class="enscript-variable-name">validation</span> <span class="enscript-variable-name">routines</span> ---

<span class="enscript-type">static</span> inline <span class="enscript-type">int</span> <span class="enscript-function-name">registration_valid</span>(decmpfs_registration *registration)
{
    <span class="enscript-keyword">return</span> registration &amp;&amp; ((registration-&gt;decmpfs_registration == DECMPFS_REGISTRATION_VERSION_V1) || (registration-&gt;decmpfs_registration == DECMPFS_REGISTRATION_VERSION_V3));
}

errno_t
<span class="enscript-function-name">register_decmpfs_decompressor</span>(uint32_t compression_type, decmpfs_registration *registration)
{
    <span class="enscript-comment">/* called by kexts to register decompressors */</span>
    
    errno_t ret = 0;
    <span class="enscript-type">int</span> locked = 0;
    <span class="enscript-type">char</span> resourceName[80];
    
    <span class="enscript-keyword">if</span> ((compression_type &gt;= CMP_MAX) || !registration_valid(registration)) {
        ret = EINVAL;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    
    lck_rw_lock_exclusive(decompressorsLock); locked = 1;
	
    <span class="enscript-comment">/* make sure the registration for this type is zero */</span>
	<span class="enscript-keyword">if</span> (decompressors[compression_type] != NULL) {
		ret = EEXIST;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
    decompressors[compression_type] = registration;
    snprintf(resourceName, <span class="enscript-keyword">sizeof</span>(resourceName), <span class="enscript-string">&quot;com.apple.AppleFSCompression.Type%u&quot;</span>, compression_type);
    IOServicePublishResource(resourceName, TRUE);
    
<span class="enscript-reference">out</span>:
    <span class="enscript-keyword">if</span> (locked) lck_rw_unlock_exclusive(decompressorsLock);
    <span class="enscript-keyword">return</span> ret;
}

errno_t
<span class="enscript-function-name">unregister_decmpfs_decompressor</span>(uint32_t compression_type, decmpfs_registration *registration)
{
    <span class="enscript-comment">/* called by kexts to unregister decompressors */</span>
    
    errno_t ret = 0;
    <span class="enscript-type">int</span> locked = 0;
    <span class="enscript-type">char</span> resourceName[80];

    <span class="enscript-keyword">if</span> ((compression_type &gt;= CMP_MAX) || !registration_valid(registration)) {
        ret = EINVAL;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    
    lck_rw_lock_exclusive(decompressorsLock); locked = 1;
    <span class="enscript-keyword">if</span> (decompressors[compression_type] != registration) {
        ret = EEXIST;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    decompressors[compression_type] = NULL;
    snprintf(resourceName, <span class="enscript-keyword">sizeof</span>(resourceName), <span class="enscript-string">&quot;com.apple.AppleFSCompression.Type%u&quot;</span>, compression_type);
    IOServicePublishResource(resourceName, FALSE);
    
<span class="enscript-reference">out</span>:
    <span class="enscript-keyword">if</span> (locked) lck_rw_unlock_exclusive(decompressorsLock);
    <span class="enscript-keyword">return</span> ret;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">compression_type_valid</span>(vnode_t vp, decmpfs_header *hdr)
{
    <span class="enscript-comment">/* fast pre-check to determine if the given compressor has checked in */</span>
    <span class="enscript-type">int</span> ret = 0;
    
    <span class="enscript-comment">/* every compressor must have at least a fetch function */</span>
    lck_rw_lock_shared(decompressorsLock);
    <span class="enscript-keyword">if</span> (decmp_get_func(vp, hdr-&gt;compression_type, fetch) != NULL) {
        ret = 1;
    }
    lck_rw_unlock_shared(decompressorsLock);
	
    <span class="enscript-keyword">return</span> ret;
}

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> --- <span class="enscript-variable-name">compression</span>/<span class="enscript-variable-name">decompression</span> <span class="enscript-variable-name">routines</span> ---

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">decmpfs_fetch_uncompressed_data</span>(vnode_t vp, decmpfs_cnode *cp, decmpfs_header *hdr, off_t offset, user_ssize_t size, <span class="enscript-type">int</span> nvec, decmpfs_vector *vec, uint64_t *bytes_read)
{
    <span class="enscript-comment">/* get the uncompressed bytes for the specified region of vp by calling out to the registered compressor */</span>
    
    <span class="enscript-type">int</span> err          = 0;
	
    *bytes_read = 0;
    
    <span class="enscript-keyword">if</span> ((uint64_t)offset &gt;= hdr-&gt;uncompressed_size) {
        <span class="enscript-comment">/* reading past end of file; nothing to do */</span>
        err = 0;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    <span class="enscript-keyword">if</span> (offset &lt; 0) {
        <span class="enscript-comment">/* tried to read from before start of file */</span>
        err = EINVAL;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    <span class="enscript-keyword">if</span> ((uint64_t)(offset + size) &gt; hdr-&gt;uncompressed_size) {
        <span class="enscript-comment">/* adjust size so we don't read past the end of the file */</span>
		size = hdr-&gt;uncompressed_size - offset;
	}
    <span class="enscript-keyword">if</span> (size == 0) {
        <span class="enscript-comment">/* nothing to read */</span>
        err = 0;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    
    lck_rw_lock_shared(decompressorsLock);
    decmpfs_fetch_uncompressed_data_func fetch = decmp_get_func(vp, hdr-&gt;compression_type, fetch);
    <span class="enscript-keyword">if</span> (fetch) {
		err = fetch(vp, decmpfs_ctx, hdr, offset, size, nvec, vec, bytes_read);
		lck_rw_unlock_shared(decompressorsLock);
        <span class="enscript-keyword">if</span> (err == 0) {
            uint64_t decompression_flags = decmpfs_cnode_get_decompression_flags(cp);
            <span class="enscript-keyword">if</span> (decompression_flags &amp; DECMPFS_FLAGS_FORCE_FLUSH_ON_DECOMPRESS) {
#<span class="enscript-reference">if</span>	!<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
                <span class="enscript-type">int</span> i;
                <span class="enscript-keyword">for</span> (i = 0; i &lt; nvec; i++) {
                    flush_dcache64((addr64_t)(uintptr_t)vec[i].buf, vec[i].size, FALSE);
                }
#<span class="enscript-reference">endif</span>
            }
        }
    } <span class="enscript-keyword">else</span> {
        err = ENOTSUP;
        lck_rw_unlock_shared(decompressorsLock);
    }
    
<span class="enscript-reference">out</span>:
    <span class="enscript-keyword">return</span> err;
}

<span class="enscript-type">static</span> kern_return_t
<span class="enscript-function-name">commit_upl</span>(upl_t upl, upl_offset_t pl_offset, size_t uplSize, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> abort)
{
    kern_return_t kr = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
    upl_unmark_decmp(upl);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IOSCHED */</span>
    
    <span class="enscript-comment">/* commit the upl pages */</span>
    <span class="enscript-keyword">if</span> (abort) {
        VerboseLog(<span class="enscript-string">&quot;aborting upl, flags 0x%08x\n&quot;</span>, flags);
		kr = ubc_upl_abort_range(upl, pl_offset, uplSize, flags);
        <span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
            ErrorLog(<span class="enscript-string">&quot;ubc_upl_abort_range error %d\n&quot;</span>, (<span class="enscript-type">int</span>)kr);
    } <span class="enscript-keyword">else</span> {
        VerboseLog(<span class="enscript-string">&quot;committing upl, flags 0x%08x\n&quot;</span>, flags | UPL_COMMIT_CLEAR_DIRTY);
		kr = ubc_upl_commit_range(upl, pl_offset, uplSize, flags | UPL_COMMIT_CLEAR_DIRTY | UPL_COMMIT_WRITTEN_BY_KERNEL);
        <span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
            ErrorLog(<span class="enscript-string">&quot;ubc_upl_commit_range error %d\n&quot;</span>, (<span class="enscript-type">int</span>)kr);
    }
    <span class="enscript-keyword">return</span> kr;
}


errno_t
<span class="enscript-function-name">decmpfs_pagein_compressed</span>(<span class="enscript-type">struct</span> vnop_pagein_args *ap, <span class="enscript-type">int</span> *is_compressed, decmpfs_cnode *cp)
{
    <span class="enscript-comment">/* handles a page-in request from vfs for a compressed file */</span>
    
    <span class="enscript-type">int</span> err                      = 0;
    vnode_t vp                   = ap-&gt;a_vp;
    upl_t pl                     = ap-&gt;a_pl;
	upl_offset_t pl_offset       = ap-&gt;a_pl_offset;
    off_t f_offset               = ap-&gt;a_f_offset;
    size_t size                  = ap-&gt;a_size;
	<span class="enscript-type">int</span> flags                    = ap-&gt;a_flags;
    off_t uplPos                 = 0;
    user_ssize_t uplSize         = 0;
	<span class="enscript-type">void</span> *data                   = NULL;
    decmpfs_header *hdr = NULL;
    <span class="enscript-type">int</span> abort_pagein             = 0;
    uint64_t cachedSize          = 0;
	<span class="enscript-type">int</span> cmpdata_locked           = 0;
	
    <span class="enscript-keyword">if</span>(!decmpfs_trylock_compressed_data(cp, 0)) {
	    <span class="enscript-keyword">return</span> EAGAIN;
    }
    cmpdata_locked = 1;
    
	
	<span class="enscript-keyword">if</span> (flags &amp; ~(UPL_IOSYNC | UPL_NOCOMMIT | UPL_NORDAHEAD)) {
		DebugLogWithPath(<span class="enscript-string">&quot;pagein: unknown flags 0x%08x\n&quot;</span>, (flags &amp; ~(UPL_IOSYNC | UPL_NOCOMMIT | UPL_NORDAHEAD)));
	}
    
    err = decmpfs_fetch_compressed_header(vp, cp, &amp;hdr, 0);
    <span class="enscript-keyword">if</span> (err != 0) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
	
    cachedSize = hdr-&gt;uncompressed_size;
    
    <span class="enscript-keyword">if</span> (!compression_type_valid(vp, hdr)) {
        <span class="enscript-comment">/* compressor not registered */</span>
        err = ENOTSUP;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
	<span class="enscript-comment">/* Mark the UPL as the requesting UPL for decompression */</span>
	upl_mark_decmp(pl);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IOSCHED */</span>

    <span class="enscript-comment">/* map the upl so we can fetch into it */</span>
	kern_return_t kr = ubc_upl_map(pl, (vm_offset_t*)&amp;data);
	<span class="enscript-keyword">if</span> ((kr != KERN_SUCCESS) || (data == NULL)) {
		err = ENOSPC;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
		upl_unmark_decmp(pl);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IOSCHED */</span>		
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
    
    uplPos = f_offset;
    uplSize = size;

    <span class="enscript-comment">/* clip the size to the size of the file */</span>
    <span class="enscript-keyword">if</span> ((uint64_t)uplPos + uplSize &gt; cachedSize) {
        <span class="enscript-comment">/* truncate the read to the size of the file */</span>
        uplSize = cachedSize - uplPos;
    }
	
    <span class="enscript-comment">/* do the fetch */</span>
    decmpfs_vector vec;
    
<span class="enscript-reference">decompress</span>:
    <span class="enscript-comment">/* the mapped data pointer points to the first page of the page list, so we want to start filling in at an offset of pl_offset */</span>
    vec.buf = (<span class="enscript-type">char</span>*)data + pl_offset;
    vec.size = size;
    
    uint64_t did_read = 0;
	<span class="enscript-keyword">if</span> (decmpfs_fast_get_state(cp) == FILE_IS_CONVERTING) {
		ErrorLogWithPath(<span class="enscript-string">&quot;unexpected pagein during decompress\n&quot;</span>);
		<span class="enscript-comment">/*
		 if the file is converting, this must be a recursive call to pagein from underneath a call to decmpfs_decompress_file;
		 pretend that it succeeded but don't do anything since we're just going to write over the pages anyway
		 */</span>
		err = 0;
		did_read = 0;
	} <span class="enscript-keyword">else</span> {
        err = decmpfs_fetch_uncompressed_data(vp, cp, hdr, uplPos, uplSize, 1, &amp;vec, &amp;did_read);
	}
    <span class="enscript-keyword">if</span> (err) {
        DebugLogWithPath(<span class="enscript-string">&quot;decmpfs_fetch_uncompressed_data err %d\n&quot;</span>, err);
        <span class="enscript-type">int</span> cmp_state = decmpfs_fast_get_state(cp);
        <span class="enscript-keyword">if</span> (cmp_state == FILE_IS_CONVERTING) {
            DebugLogWithPath(<span class="enscript-string">&quot;cmp_state == FILE_IS_CONVERTING\n&quot;</span>);
            cmp_state = wait_for_decompress(cp);
            <span class="enscript-keyword">if</span> (cmp_state == FILE_IS_COMPRESSED) {
                DebugLogWithPath(<span class="enscript-string">&quot;cmp_state == FILE_IS_COMPRESSED\n&quot;</span>);
                <span class="enscript-comment">/* a decompress was attempted but it failed, let's try calling fetch again */</span>
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">decompress</span>;
            }
        }
        <span class="enscript-keyword">if</span> (cmp_state == FILE_IS_NOT_COMPRESSED) {
            DebugLogWithPath(<span class="enscript-string">&quot;cmp_state == FILE_IS_NOT_COMPRESSED\n&quot;</span>);
            <span class="enscript-comment">/* the file was decompressed after we started reading it */</span>
            abort_pagein = 1;   <span class="enscript-comment">/* we're not going to commit our data */</span>
            *is_compressed = 0; <span class="enscript-comment">/* instruct caller to fall back to its normal path */</span>
        }
    }
    
    <span class="enscript-comment">/* zero out whatever we didn't read, and zero out the end of the last page(s) */</span>
    uint64_t total_size = (size + (PAGE_SIZE - 1)) &amp; ~(PAGE_SIZE - 1);
    <span class="enscript-keyword">if</span> (did_read &lt; total_size) {
        memset((<span class="enscript-type">char</span>*)vec.buf + did_read, 0, total_size - did_read);
    }
   
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
	upl_unmark_decmp(pl);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IOSCHED */</span>	
 
	kr = ubc_upl_unmap(pl); data = NULL; <span class="enscript-comment">/* make sure to set data to NULL so we don't try to unmap again below */</span>
    <span class="enscript-keyword">if</span> (kr != KERN_SUCCESS)
        ErrorLogWithPath(<span class="enscript-string">&quot;ubc_upl_unmap error %d\n&quot;</span>, (<span class="enscript-type">int</span>)kr);
    <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">if</span> (!abort_pagein) {
            <span class="enscript-comment">/* commit our pages */</span>
			kr = commit_upl(pl, pl_offset, total_size, UPL_COMMIT_FREE_ON_EMPTY, 0);
        }
    }
    
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (data) ubc_upl_unmap(pl);
    <span class="enscript-keyword">if</span> (hdr) FREE(hdr, M_TEMP);
	<span class="enscript-keyword">if</span> (cmpdata_locked) decmpfs_unlock_compressed_data(cp, 0);
    <span class="enscript-keyword">if</span> (err) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
        <span class="enscript-type">char</span> *path;
        MALLOC(path, <span class="enscript-type">char</span> *, PATH_MAX, M_TEMP, M_WAITOK);
        panic(<span class="enscript-string">&quot;%s: decmpfs_pagein_compressed: err %d&quot;</span>, vnpath(vp, path, PATH_MAX), err);
        FREE(path, M_TEMP);
#<span class="enscript-reference">else</span>
        ErrorLogWithPath(<span class="enscript-string">&quot;err %d\n&quot;</span>, err);
#<span class="enscript-reference">endif</span>
    }
	<span class="enscript-keyword">return</span> err;
}

errno_t 
<span class="enscript-function-name">decmpfs_read_compressed</span>(<span class="enscript-type">struct</span> vnop_read_args *ap, <span class="enscript-type">int</span> *is_compressed, decmpfs_cnode *cp)
{
    <span class="enscript-comment">/* handles a read request from vfs for a compressed file */</span>
	
    uio_t uio                    = ap-&gt;a_uio;
    vnode_t vp                   = ap-&gt;a_vp;
    <span class="enscript-type">int</span> err                      = 0;
    <span class="enscript-type">int</span> countInt                 = 0;
    off_t uplPos                 = 0;
    user_ssize_t uplSize         = 0;
    user_ssize_t uplRemaining    = 0;
    off_t curUplPos              = 0;
    user_ssize_t curUplSize      = 0;
    kern_return_t kr             = KERN_SUCCESS;
    <span class="enscript-type">int</span> abort_read               = 0;
    <span class="enscript-type">void</span> *data                   = NULL;
    uint64_t did_read            = 0;
    upl_t upl                    = NULL;
    upl_page_info_t *pli         = NULL;
    decmpfs_header *hdr          = NULL;
    uint64_t cachedSize          = 0;
    off_t uioPos                 = 0;
    user_ssize_t uioRemaining    = 0;
	<span class="enscript-type">int</span> cmpdata_locked           = 0;
	
	decmpfs_lock_compressed_data(cp, 0); cmpdata_locked = 1;
	
    uplPos = uio_offset(uio);
    uplSize = uio_resid(uio);
    VerboseLogWithPath(<span class="enscript-string">&quot;uplPos %lld uplSize %lld\n&quot;</span>, uplPos, uplSize);
	
    cachedSize = decmpfs_cnode_get_vnode_cached_size(cp);
    
    <span class="enscript-keyword">if</span> ((uint64_t)uplPos + uplSize &gt; cachedSize) {
        <span class="enscript-comment">/* truncate the read to the size of the file */</span>
        uplSize = cachedSize - uplPos;
    }
    
    <span class="enscript-comment">/* give the cluster layer a chance to fill in whatever it already has */</span>
    countInt = (uplSize &gt; INT_MAX) ? INT_MAX : uplSize;
    err = cluster_copy_ubc_data(vp, uio, &amp;countInt, 0);
    <span class="enscript-keyword">if</span> (err != 0)
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	
    <span class="enscript-comment">/* figure out what's left */</span>
    uioPos = uio_offset(uio);
    uioRemaining = uio_resid(uio);
    <span class="enscript-keyword">if</span> ((uint64_t)uioPos + uioRemaining &gt; cachedSize) {
        <span class="enscript-comment">/* truncate the read to the size of the file */</span>
        uioRemaining = cachedSize - uioPos;
    }
    
    <span class="enscript-keyword">if</span> (uioRemaining &lt;= 0) {
        <span class="enscript-comment">/* nothing left */</span>
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    
    err = decmpfs_fetch_compressed_header(vp, cp, &amp;hdr, 0);
    <span class="enscript-keyword">if</span> (err != 0) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    <span class="enscript-keyword">if</span> (!compression_type_valid(vp, hdr)) {
        err = ENOTSUP;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    
    uplPos = uioPos;
    uplSize = uioRemaining;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPRESSION_DEBUG</span>
    DebugLogWithPath(<span class="enscript-string">&quot;uplPos %lld uplSize %lld\n&quot;</span>, (uint64_t)uplPos, (uint64_t)uplSize);
#<span class="enscript-reference">endif</span>
	
    lck_rw_lock_shared(decompressorsLock);
    decmpfs_adjust_fetch_region_func adjust_fetch = decmp_get_func(vp, hdr-&gt;compression_type, adjust_fetch);
    <span class="enscript-keyword">if</span> (adjust_fetch) {
        <span class="enscript-comment">/* give the compressor a chance to adjust the portion of the file that we read */</span>
		adjust_fetch(vp, decmpfs_ctx, hdr, &amp;uplPos, &amp;uplSize);
        VerboseLogWithPath(<span class="enscript-string">&quot;adjusted uplPos %lld uplSize %lld\n&quot;</span>, (uint64_t)uplPos, (uint64_t)uplSize);
    }
    lck_rw_unlock_shared(decompressorsLock);
    
    <span class="enscript-comment">/* clip the adjusted size to the size of the file */</span>
    <span class="enscript-keyword">if</span> ((uint64_t)uplPos + uplSize &gt; cachedSize) {
        <span class="enscript-comment">/* truncate the read to the size of the file */</span>
        uplSize = cachedSize - uplPos;
    }
    
    <span class="enscript-keyword">if</span> (uplSize &lt;= 0) {
        <span class="enscript-comment">/* nothing left */</span>
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    
    <span class="enscript-comment">/*
     since we're going to create a upl for the given region of the file,
     make sure we're on page boundaries
     */</span>
    
    <span class="enscript-keyword">if</span> (uplPos &amp; (PAGE_SIZE - 1)) {
        <span class="enscript-comment">/* round position down to page boundary */</span>
        uplSize += (uplPos &amp; (PAGE_SIZE - 1));
        uplPos &amp;= ~(PAGE_SIZE - 1);
    }
    <span class="enscript-comment">/* round size up to page multiple */</span>
    uplSize = (uplSize + (PAGE_SIZE - 1)) &amp; ~(PAGE_SIZE - 1);
    
    VerboseLogWithPath(<span class="enscript-string">&quot;new uplPos %lld uplSize %lld\n&quot;</span>, (uint64_t)uplPos, (uint64_t)uplSize);
    
    uplRemaining = uplSize;
    curUplPos = uplPos;
    curUplSize = 0;
    
    <span class="enscript-keyword">while</span>(uplRemaining &gt; 0) {
        <span class="enscript-comment">/* start after the last upl */</span>
        curUplPos += curUplSize;
        
        <span class="enscript-comment">/* clip to max upl size */</span>
        curUplSize = uplRemaining;
        <span class="enscript-keyword">if</span> (curUplSize &gt; MAX_UPL_SIZE_BYTES) {
            curUplSize = MAX_UPL_SIZE_BYTES;
        }
        
        <span class="enscript-comment">/* create the upl */</span>
        kr = ubc_create_upl(vp, curUplPos, curUplSize, &amp;upl, &amp;pli, UPL_SET_LITE);
        <span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {
            ErrorLogWithPath(<span class="enscript-string">&quot;ubc_create_upl error %d\n&quot;</span>, (<span class="enscript-type">int</span>)kr);
            err = EINVAL;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }
        VerboseLogWithPath(<span class="enscript-string">&quot;curUplPos %lld curUplSize %lld\n&quot;</span>, (uint64_t)curUplPos, (uint64_t)curUplSize);
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_IOSCHED</span>
	<span class="enscript-comment">/* Mark the UPL as the requesting UPL for decompression */</span>
	upl_mark_decmp(upl);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IOSCHED */</span>	

        <span class="enscript-comment">/* map the upl */</span>
        kr = ubc_upl_map(upl, (vm_offset_t*)&amp;data);
        <span class="enscript-keyword">if</span> (kr != KERN_SUCCESS) {

	    commit_upl(upl, 0, curUplSize, UPL_ABORT_FREE_ON_EMPTY, 1);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
            <span class="enscript-type">char</span> *path;
            MALLOC(path, <span class="enscript-type">char</span> *, PATH_MAX, M_TEMP, M_WAITOK);
            panic(<span class="enscript-string">&quot;%s: decmpfs_read_compressed: ubc_upl_map error %d&quot;</span>, vnpath(vp, path, PATH_MAX), (<span class="enscript-type">int</span>)kr);
            FREE(path, M_TEMP);
#<span class="enscript-reference">else</span>
            ErrorLogWithPath(<span class="enscript-string">&quot;ubc_upl_map error %d\n&quot;</span>, (<span class="enscript-type">int</span>)kr);
#<span class="enscript-reference">endif</span>
            err = EINVAL;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }
        
        <span class="enscript-comment">/* make sure the map succeeded */</span>
        <span class="enscript-keyword">if</span> (!data) {

	    commit_upl(upl, 0, curUplSize, UPL_ABORT_FREE_ON_EMPTY, 1);

            ErrorLogWithPath(<span class="enscript-string">&quot;ubc_upl_map mapped null\n&quot;</span>);
            err = EINVAL;
            <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
        }
        
        <span class="enscript-comment">/* fetch uncompressed data into the mapped upl */</span>
        decmpfs_vector vec;
    <span class="enscript-reference">decompress</span>:
        vec = (decmpfs_vector){ .buf = data, .size = curUplSize };
        err = decmpfs_fetch_uncompressed_data(vp, cp, hdr, curUplPos, curUplSize, 1, &amp;vec, &amp;did_read);
        <span class="enscript-keyword">if</span> (err) {
            ErrorLogWithPath(<span class="enscript-string">&quot;decmpfs_fetch_uncompressed_data err %d\n&quot;</span>, err);
            
            <span class="enscript-comment">/* maybe the file is converting to decompressed */</span>
            <span class="enscript-type">int</span> cmp_state = decmpfs_fast_get_state(cp);
            <span class="enscript-keyword">if</span> (cmp_state == FILE_IS_CONVERTING) {
                ErrorLogWithPath(<span class="enscript-string">&quot;cmp_state == FILE_IS_CONVERTING\n&quot;</span>);
                cmp_state = wait_for_decompress(cp);
                <span class="enscript-keyword">if</span> (cmp_state == FILE_IS_COMPRESSED) {
                    ErrorLogWithPath(<span class="enscript-string">&quot;cmp_state == FILE_IS_COMPRESSED\n&quot;</span>);
                    <span class="enscript-comment">/* a decompress was attempted but it failed, let's try fetching again */</span>
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">decompress</span>;
                }
            }
            <span class="enscript-keyword">if</span> (cmp_state == FILE_IS_NOT_COMPRESSED) {
                ErrorLogWithPath(<span class="enscript-string">&quot;cmp_state == FILE_IS_NOT_COMPRESSED\n&quot;</span>);
                <span class="enscript-comment">/* the file was decompressed after we started reading it */</span>
                abort_read = 1;     <span class="enscript-comment">/* we're not going to commit our data */</span>
                *is_compressed = 0; <span class="enscript-comment">/* instruct caller to fall back to its normal path */</span>
            }
            kr = KERN_FAILURE;
            did_read = 0;
        }
        <span class="enscript-comment">/* zero out the remainder of the last page */</span>
        memset((<span class="enscript-type">char</span>*)data + did_read, 0, curUplSize - did_read);
        kr = ubc_upl_unmap(upl);
        <span class="enscript-keyword">if</span> (kr == KERN_SUCCESS) {
            <span class="enscript-keyword">if</span> (abort_read) {
				kr = commit_upl(upl, 0, curUplSize, UPL_ABORT_FREE_ON_EMPTY, 1);
            } <span class="enscript-keyword">else</span> {
                VerboseLogWithPath(<span class="enscript-string">&quot;uioPos %lld uioRemaining %lld\n&quot;</span>, (uint64_t)uioPos, (uint64_t)uioRemaining);
                <span class="enscript-keyword">if</span> (uioRemaining) {
                    off_t uplOff = uioPos - curUplPos;
                    <span class="enscript-keyword">if</span> (uplOff &lt; 0) {
                        ErrorLogWithPath(<span class="enscript-string">&quot;uplOff %lld should never be negative\n&quot;</span>, (int64_t)uplOff);
                        err = EINVAL;
                    } <span class="enscript-keyword">else</span> {
                        off_t count = curUplPos + curUplSize - uioPos;
                        <span class="enscript-keyword">if</span> (count &lt; 0) {
                            <span class="enscript-comment">/* this upl is entirely before the uio */</span>
                        } <span class="enscript-keyword">else</span> {
                            <span class="enscript-keyword">if</span> (count &gt; uioRemaining)
                                count = uioRemaining;
                            <span class="enscript-type">int</span> io_resid = count;
                            err = cluster_copy_upl_data(uio, upl, uplOff, &amp;io_resid);
                            <span class="enscript-type">int</span> copied = count - io_resid;
                            VerboseLogWithPath(<span class="enscript-string">&quot;uplOff %lld count %lld copied %lld\n&quot;</span>, (uint64_t)uplOff, (uint64_t)count, (uint64_t)copied);
                            <span class="enscript-keyword">if</span> (err) {
                                ErrorLogWithPath(<span class="enscript-string">&quot;cluster_copy_upl_data err %d\n&quot;</span>, err);
                            }
                            uioPos += copied;
                            uioRemaining -= copied;
                        }
                    }
                }
				kr = commit_upl(upl, 0, curUplSize, UPL_COMMIT_FREE_ON_EMPTY | UPL_COMMIT_INACTIVATE, 0);
                <span class="enscript-keyword">if</span> (err) {
                    <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
                }
            }
        } <span class="enscript-keyword">else</span> {
            ErrorLogWithPath(<span class="enscript-string">&quot;ubc_upl_unmap error %d\n&quot;</span>, (<span class="enscript-type">int</span>)kr);
        }
    
        uplRemaining -= curUplSize;
    }
    
<span class="enscript-reference">out</span>:

    <span class="enscript-keyword">if</span> (hdr) FREE(hdr, M_TEMP);
	<span class="enscript-keyword">if</span> (cmpdata_locked) decmpfs_unlock_compressed_data(cp, 0);
    <span class="enscript-keyword">if</span> (err) {<span class="enscript-comment">/* something went wrong */</span>
        ErrorLogWithPath(<span class="enscript-string">&quot;err %d\n&quot;</span>, err);
        <span class="enscript-keyword">return</span> err;
    }
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPRESSION_DEBUG</span>
    uplSize = uio_resid(uio);
    <span class="enscript-keyword">if</span> (uplSize)
        VerboseLogWithPath(<span class="enscript-string">&quot;still %lld bytes to copy\n&quot;</span>, uplSize);
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">decmpfs_free_compressed_data</span>(vnode_t vp, decmpfs_cnode *cp)
{
    <span class="enscript-comment">/*
     call out to the decompressor to free remove any data associated with this compressed file
     then delete the file's compression xattr
     */</span>
    
    decmpfs_header *hdr = NULL;
    <span class="enscript-type">int</span> err = decmpfs_fetch_compressed_header(vp, cp, &amp;hdr, 0);
    <span class="enscript-keyword">if</span> (err) {
        ErrorLogWithPath(<span class="enscript-string">&quot;decmpfs_fetch_compressed_header err %d\n&quot;</span>, err);
    } <span class="enscript-keyword">else</span> {
        lck_rw_lock_shared(decompressorsLock);
        decmpfs_free_compressed_data_func free_data = decmp_get_func(vp, hdr-&gt;compression_type, free_data);
        <span class="enscript-keyword">if</span> (free_data) {
			err = free_data(vp, decmpfs_ctx, hdr);
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-comment">/* nothing to do, so no error */</span>
            err = 0;
        }
        lck_rw_unlock_shared(decompressorsLock);
        
        <span class="enscript-keyword">if</span> (err != 0) {
            ErrorLogWithPath(<span class="enscript-string">&quot;decompressor err %d\n&quot;</span>, err);
        }
    }
    
    <span class="enscript-comment">/* delete the xattr */</span>
	err = vn_removexattr(vp, DECMPFS_XATTR_NAME, 0, decmpfs_ctx);
    <span class="enscript-keyword">if</span> (err != 0) {
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    
<span class="enscript-reference">out</span>:
    <span class="enscript-keyword">if</span> (hdr) FREE(hdr, M_TEMP);
    <span class="enscript-keyword">return</span> err;
}

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> --- <span class="enscript-variable-name">file</span> <span class="enscript-variable-name">conversion</span> <span class="enscript-variable-name">routines</span> ---

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">unset_compressed_flag</span>(vnode_t vp)
{
    <span class="enscript-type">int</span> err = 0;
    <span class="enscript-type">struct</span> vnode_attr va;
    <span class="enscript-type">int</span> new_bsdflags = 0;
    
    VATTR_INIT(&amp;va);
    VATTR_WANTED(&amp;va, va_flags);
	err = vnode_getattr(vp, &amp;va, decmpfs_ctx);
    
    <span class="enscript-keyword">if</span> (err != 0) {
        ErrorLogWithPath(<span class="enscript-string">&quot;vnode_getattr err %d\n&quot;</span>, err);
    } <span class="enscript-keyword">else</span> {
        new_bsdflags = va.va_flags &amp; ~UF_COMPRESSED;
        
        VATTR_INIT(&amp;va);
        VATTR_SET(&amp;va, va_flags, new_bsdflags);
		err = vnode_setattr(vp, &amp;va, decmpfs_ctx);
        <span class="enscript-keyword">if</span> (err != 0) {
            ErrorLogWithPath(<span class="enscript-string">&quot;vnode_setattr err %d\n&quot;</span>, err);
        }
    }
    <span class="enscript-keyword">return</span> err;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">decmpfs_decompress_file</span>(vnode_t vp, decmpfs_cnode *cp, off_t toSize, <span class="enscript-type">int</span> truncate_okay, <span class="enscript-type">int</span> skiplock)
{
	<span class="enscript-comment">/* convert a compressed file to an uncompressed file */</span>
	
	<span class="enscript-type">int</span> err                      = 0;
	<span class="enscript-type">char</span> *data                   = NULL;
	uio_t uio_w                  = 0;
	off_t offset                 = 0;
	uint32_t old_state           = 0;
	uint32_t new_state           = 0;
	<span class="enscript-type">int</span> update_file_state        = 0;
	<span class="enscript-type">int</span> allocSize                = 0;
	decmpfs_header *hdr = NULL;
	<span class="enscript-type">int</span> cmpdata_locked           = 0;
	off_t remaining              = 0;
	uint64_t uncompressed_size   = 0;
	
	<span class="enscript-keyword">if</span> (!skiplock) {
		decmpfs_lock_compressed_data(cp, 1); cmpdata_locked = 1;
	}
	
<span class="enscript-reference">decompress</span>:
	old_state = decmpfs_fast_get_state(cp);
	
	<span class="enscript-keyword">switch</span>(old_state) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_NOT_COMPRESSED</span>:
		{
			<span class="enscript-comment">/* someone else decompressed the file */</span>
			err = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
			
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_TYPE_UNKNOWN</span>:
		{
			<span class="enscript-comment">/* the file is in an unknown state, so update the state and retry */</span>
			(<span class="enscript-type">void</span>)decmpfs_file_is_compressed(vp, cp);
			
			<span class="enscript-comment">/* try again */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">decompress</span>;
		}
			
		<span class="enscript-keyword">case</span> <span class="enscript-reference">FILE_IS_COMPRESSED</span>:
		{
			<span class="enscript-comment">/* the file is compressed, so decompress it */</span>
			<span class="enscript-keyword">break</span>;
		}
			
		<span class="enscript-reference">default</span>:
		{
			<span class="enscript-comment">/*
			 this shouldn't happen since multiple calls to decmpfs_decompress_file lock each other out,
			 and when decmpfs_decompress_file returns, the state should be always be set back to
			 FILE_IS_NOT_COMPRESSED or FILE_IS_UNKNOWN
			 */</span>
			err = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	
    err = decmpfs_fetch_compressed_header(vp, cp, &amp;hdr, 0);
	<span class="enscript-keyword">if</span> (err != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
	uncompressed_size = hdr-&gt;uncompressed_size;
	<span class="enscript-keyword">if</span> (toSize == -1)
		toSize = hdr-&gt;uncompressed_size;
	
	<span class="enscript-keyword">if</span> (toSize == 0) {
		<span class="enscript-comment">/* special case truncating the file to zero bytes */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nodecmp</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((uint64_t)toSize &gt; hdr-&gt;uncompressed_size) {
		<span class="enscript-comment">/* the caller is trying to grow the file, so we should decompress all the data */</span>
		toSize = hdr-&gt;uncompressed_size;
	}
	
	allocSize = MIN(64*1024, toSize);
	MALLOC(data, <span class="enscript-type">char</span> *, allocSize, M_TEMP, M_WAITOK);
	<span class="enscript-keyword">if</span> (!data) {
		err = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
	uio_w = uio_create(1, 0LL, UIO_SYSSPACE, UIO_WRITE);
	<span class="enscript-keyword">if</span> (!uio_w) {
		err = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	uio_w-&gt;uio_flags |= UIO_FLAGS_IS_COMPRESSED_FILE;
	
	remaining = toSize;
	
	<span class="enscript-comment">/* tell the buffer cache that this is an empty file */</span>
	ubc_setsize(vp, 0);
	
	<span class="enscript-comment">/* if we got here, we need to decompress the file */</span>
	decmpfs_cnode_set_vnode_state(cp, FILE_IS_CONVERTING, 1);
	
	<span class="enscript-keyword">while</span>(remaining &gt; 0) {
		<span class="enscript-comment">/* loop decompressing data from the file and writing it into the data fork */</span>
		
		uint64_t bytes_read = 0;
		decmpfs_vector vec = { .buf = data, .size = MIN(allocSize, remaining) };
		err = decmpfs_fetch_uncompressed_data(vp, cp, hdr, offset, vec.size, 1, &amp;vec, &amp;bytes_read);
		<span class="enscript-keyword">if</span> (err != 0) {
			ErrorLogWithPath(<span class="enscript-string">&quot;decmpfs_fetch_uncompressed_data err %d\n&quot;</span>, err);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		
		<span class="enscript-keyword">if</span> (bytes_read == 0) {
			<span class="enscript-comment">/* we're done reading data */</span>
			<span class="enscript-keyword">break</span>;
		}
		
		uio_reset(uio_w, offset, UIO_SYSSPACE, UIO_WRITE);
		err = uio_addiov(uio_w, CAST_USER_ADDR_T(data), bytes_read);
		<span class="enscript-keyword">if</span> (err != 0) {
			ErrorLogWithPath(<span class="enscript-string">&quot;uio_addiov err %d\n&quot;</span>, err);
			err = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		
		err = VNOP_WRITE(vp, uio_w, 0, decmpfs_ctx);
		<span class="enscript-keyword">if</span> (err != 0) {
			<span class="enscript-comment">/* if the write failed, truncate the file to zero bytes */</span>
			ErrorLogWithPath(<span class="enscript-string">&quot;VNOP_WRITE err %d\n&quot;</span>, err);
			<span class="enscript-keyword">break</span>;
		}
		offset += bytes_read;
		remaining -= bytes_read;
	}
	
	<span class="enscript-keyword">if</span> (err == 0) {
		<span class="enscript-keyword">if</span> (offset != toSize) {
			ErrorLogWithPath(<span class="enscript-string">&quot;file decompressed to %lld instead of %lld\n&quot;</span>, offset, toSize);
			err = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	
	<span class="enscript-keyword">if</span> (err == 0) {
		<span class="enscript-comment">/* sync the data and metadata */</span>
		err = VNOP_FSYNC(vp, MNT_WAIT, decmpfs_ctx);
		<span class="enscript-keyword">if</span> (err != 0) {
			ErrorLogWithPath(<span class="enscript-string">&quot;VNOP_FSYNC err %d\n&quot;</span>, err);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	
	<span class="enscript-keyword">if</span> (err != 0) {
		<span class="enscript-comment">/* write, setattr, or fsync failed */</span>
		ErrorLogWithPath(<span class="enscript-string">&quot;aborting decompress, err %d\n&quot;</span>, err);
		<span class="enscript-keyword">if</span> (truncate_okay) {
			<span class="enscript-comment">/* truncate anything we might have written */</span>
			<span class="enscript-type">int</span> error = vnode_setsize(vp, 0, 0, decmpfs_ctx);
			ErrorLogWithPath(<span class="enscript-string">&quot;vnode_setsize err %d\n&quot;</span>, error);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
<span class="enscript-reference">nodecmp</span>:
	<span class="enscript-comment">/* if we're truncating the file to zero bytes, we'll skip ahead to here */</span>
	
	<span class="enscript-comment">/* unset the compressed flag */</span>
	unset_compressed_flag(vp);
	
	<span class="enscript-comment">/* free the compressed data associated with this file */</span>
	err = decmpfs_free_compressed_data(vp, cp);
	<span class="enscript-keyword">if</span> (err != 0) {
		ErrorLogWithPath(<span class="enscript-string">&quot;decmpfs_free_compressed_data err %d\n&quot;</span>, err);
	}
	
	<span class="enscript-comment">/*
	 even if free_compressed_data or vnode_getattr/vnode_setattr failed, return success
	 since we succeeded in writing all of the file data to the data fork
	 */</span>
	err = 0;
	
	<span class="enscript-comment">/* if we got this far, the file was successfully decompressed */</span>
	update_file_state = 1;
	new_state = FILE_IS_NOT_COMPRESSED;
	
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPRESSION_DEBUG</span>
	{
		uint64_t filesize = 0;
		vnsize(vp, &amp;filesize);
		DebugLogWithPath(<span class="enscript-string">&quot;new file size %lld\n&quot;</span>, filesize);
	}
#<span class="enscript-reference">endif</span>
	
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (hdr) FREE(hdr, M_TEMP);
	<span class="enscript-keyword">if</span> (data) FREE(data, M_TEMP);
	<span class="enscript-keyword">if</span> (uio_w) uio_free(uio_w);
	
	<span class="enscript-keyword">if</span> (err != 0) {
		<span class="enscript-comment">/* if there was a failure, reset compression flags to unknown and clear the buffer cache data */</span>
		update_file_state = 1;
		new_state = FILE_TYPE_UNKNOWN;
		<span class="enscript-keyword">if</span> (uncompressed_size) {
			ubc_setsize(vp, 0);
			ubc_setsize(vp, uncompressed_size);
        }
	}
	
	<span class="enscript-keyword">if</span> (update_file_state) {
		lck_mtx_lock(decompress_channel_mtx);
		decmpfs_cnode_set_vnode_state(cp, new_state, 1);
		wakeup((caddr_t)&amp;decompress_channel); <span class="enscript-comment">/* wake up anyone who might have been waiting for decompression */</span>
		lck_mtx_unlock(decompress_channel_mtx);
	}
	
	<span class="enscript-keyword">if</span> (cmpdata_locked) decmpfs_unlock_compressed_data(cp, 1);
	
	<span class="enscript-keyword">return</span> err;
}

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> --- <span class="enscript-variable-name">Type1</span> <span class="enscript-variable-name">compressor</span> ---

<span class="enscript-comment">/*
 The &quot;Type1&quot; compressor stores the data fork directly in the compression xattr
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">decmpfs_validate_compressed_file_Type1</span>(__unused vnode_t vp, __unused vfs_context_t ctx, decmpfs_header *hdr)
{
    <span class="enscript-type">int</span> err          = 0;
    
    <span class="enscript-keyword">if</span> (hdr-&gt;uncompressed_size + <span class="enscript-keyword">sizeof</span>(decmpfs_disk_header) != (uint64_t)hdr-&gt;attr_size) {
        err = EINVAL;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
<span class="enscript-reference">out</span>:
    <span class="enscript-keyword">return</span> err;    
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">decmpfs_fetch_uncompressed_data_Type1</span>(__unused vnode_t vp, __unused vfs_context_t ctx, decmpfs_header *hdr, off_t offset, user_ssize_t size, <span class="enscript-type">int</span> nvec, decmpfs_vector *vec, uint64_t *bytes_read)
{
    <span class="enscript-type">int</span> err          = 0;
    <span class="enscript-type">int</span> i;
    user_ssize_t remaining;
    
    <span class="enscript-keyword">if</span> (hdr-&gt;uncompressed_size + <span class="enscript-keyword">sizeof</span>(decmpfs_disk_header) != (uint64_t)hdr-&gt;attr_size) {
        err = EINVAL;
        <span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
    }
    
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COMPRESSION_DEBUG</span>
    <span class="enscript-type">static</span> <span class="enscript-type">int</span> dummy = 0; <span class="enscript-comment">// prevent syslog from coalescing printfs
</span>    DebugLogWithPath(<span class="enscript-string">&quot;%d memcpy %lld at %lld\n&quot;</span>, dummy++, size, (uint64_t)offset);
#<span class="enscript-reference">endif</span>
    
    remaining = size;
    <span class="enscript-keyword">for</span> (i = 0; (i &lt; nvec) &amp;&amp; (remaining &gt; 0); i++) {
        user_ssize_t curCopy = vec[i].size;
        <span class="enscript-keyword">if</span> (curCopy &gt; remaining)
            curCopy = remaining;
        memcpy(vec[i].buf, hdr-&gt;attr_bytes + offset, curCopy);
        offset += curCopy;
        remaining -= curCopy;
    }
    
    <span class="enscript-keyword">if</span> ((bytes_read) &amp;&amp; (err == 0))
        *bytes_read = (size - remaining);
    
<span class="enscript-reference">out</span>:
    <span class="enscript-keyword">return</span> err;
}

<span class="enscript-type">static</span> decmpfs_registration Type1Reg =
{
    .decmpfs_registration = DECMPFS_REGISTRATION_VERSION,
    .validate          = decmpfs_validate_compressed_file_Type1,
    .adjust_fetch      = NULL, <span class="enscript-comment">/* no adjust necessary */</span>
    .fetch             = decmpfs_fetch_uncompressed_data_Type1,
    .free_data         = NULL, <span class="enscript-comment">/* no free necessary */</span>
    .get_flags         = NULL  <span class="enscript-comment">/* no flags */</span>
};

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> --- <span class="enscript-variable-name">decmpfs</span> <span class="enscript-variable-name">initialization</span> ---

<span class="enscript-type">void</span> <span class="enscript-function-name">decmpfs_init</span>()
{
    <span class="enscript-type">static</span> <span class="enscript-type">int</span> done = 0;
    <span class="enscript-keyword">if</span> (done) <span class="enscript-keyword">return</span>;
    
	decmpfs_ctx = vfs_context_create(vfs_context_kernel());
	
    lck_grp_attr_t *attr = lck_grp_attr_alloc_init();
    decmpfs_lockgrp = lck_grp_alloc_init(<span class="enscript-string">&quot;VFSCOMP&quot;</span>,  attr);
    decompressorsLock = lck_rw_alloc_init(decmpfs_lockgrp, NULL);
    decompress_channel_mtx = lck_mtx_alloc_init(decmpfs_lockgrp, NULL);
    
    register_decmpfs_decompressor(CMP_Type1, &amp;Type1Reg);
    
    done = 1;
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* HFS_COMPRESSION */</span>
</pre>
<hr />
</body></html>