<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kpi_socketfilter.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kpi_socketfilter.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_socketfilter.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/kext_net.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/tcp_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/udp_var.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SFEF_ATTACHED</span>		0x1	<span class="enscript-comment">/* SFE is on socket list */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SFEF_NODETACH</span>		0x2	<span class="enscript-comment">/* Detach should not be called */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SFEF_NOSOCKET</span>		0x4	<span class="enscript-comment">/* Socket is gone */</span>

<span class="enscript-type">struct</span> socket_filter_entry {
	<span class="enscript-type">struct</span> socket_filter_entry	*sfe_next_onsocket;
	<span class="enscript-type">struct</span> socket_filter_entry	*sfe_next_onfilter;
	<span class="enscript-type">struct</span> socket_filter_entry	*sfe_next_oncleanup;

	<span class="enscript-type">struct</span> socket_filter		*sfe_filter;
	<span class="enscript-type">struct</span> socket			*sfe_socket;
	<span class="enscript-type">void</span>				*sfe_cookie;

	uint32_t			sfe_flags;
	int32_t				sfe_refcount;
};

<span class="enscript-type">struct</span> socket_filter {
	TAILQ_ENTRY(socket_filter)	sf_protosw_next;
	TAILQ_ENTRY(socket_filter)	sf_global_next;
	<span class="enscript-type">struct</span> socket_filter_entry	*sf_entry_head;

	<span class="enscript-type">struct</span> protosw			*sf_proto;
	<span class="enscript-type">struct</span> sflt_filter		sf_filter;
	u_int32_t			sf_refcount;
};

<span class="enscript-function-name">TAILQ_HEAD</span>(socket_filter_list, socket_filter);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> socket_filter_list	sock_filter_head;
<span class="enscript-type">static</span> lck_rw_t				*sock_filter_lock = NULL;
<span class="enscript-type">static</span> lck_mtx_t			*sock_filter_cleanup_lock = NULL;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> socket_filter_entry	*sock_filter_cleanup_entries = NULL;
<span class="enscript-type">static</span> thread_t				sock_filter_cleanup_thread = NULL;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">sflt_cleanup_thread</span>(<span class="enscript-type">void</span> *, wait_result_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">sflt_detach_locked</span>(<span class="enscript-type">struct</span> socket_filter_entry *entry);

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -- <span class="enscript-variable-name">Internal</span> <span class="enscript-variable-name">State</span> <span class="enscript-variable-name">Management</span> --

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">sflt_init</span>(<span class="enscript-type">void</span>)
{
	lck_grp_attr_t	*grp_attrib = NULL;
	lck_attr_t	*lck_attrib = NULL;
	lck_grp_t	*lck_group = NULL;

	TAILQ_INIT(&amp;sock_filter_head);

	<span class="enscript-comment">/* Allocate a rw lock */</span>
	grp_attrib = lck_grp_attr_alloc_init();
	lck_group = lck_grp_alloc_init(<span class="enscript-string">&quot;socket filter lock&quot;</span>, grp_attrib);
	lck_grp_attr_free(grp_attrib);
	lck_attrib = lck_attr_alloc_init();
	sock_filter_lock = lck_rw_alloc_init(lck_group, lck_attrib);
	sock_filter_cleanup_lock = lck_mtx_alloc_init(lck_group, lck_attrib);
	lck_grp_free(lck_group);
	lck_attr_free(lck_attrib);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sflt_retain_locked</span>(<span class="enscript-type">struct</span> socket_filter	*filter)
{
	filter-&gt;sf_refcount++;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sflt_release_locked</span>(<span class="enscript-type">struct</span> socket_filter *filter)
{
	filter-&gt;sf_refcount--;
	<span class="enscript-keyword">if</span> (filter-&gt;sf_refcount == 0) {
		<span class="enscript-comment">/* Call the unregistered function */</span>
		<span class="enscript-keyword">if</span> (filter-&gt;sf_filter.sf_unregistered) {
			lck_rw_unlock_exclusive(sock_filter_lock);
			filter-&gt;sf_filter.sf_unregistered(
			    filter-&gt;sf_filter.sf_handle);
			lck_rw_lock_exclusive(sock_filter_lock);
		}

		<span class="enscript-comment">/* Free the entry */</span>
		FREE(filter, M_IFADDR);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sflt_entry_retain</span>(<span class="enscript-type">struct</span> socket_filter_entry *entry)
{
	<span class="enscript-keyword">if</span> (OSIncrementAtomic(&amp;entry-&gt;sfe_refcount) &lt;= 0) {
		panic(<span class="enscript-string">&quot;sflt_entry_retain - sfe_refcount &lt;= 0\n&quot;</span>);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sflt_entry_release</span>(<span class="enscript-type">struct</span> socket_filter_entry *entry)
{
	SInt32 old = OSDecrementAtomic(&amp;entry-&gt;sfe_refcount);
	<span class="enscript-keyword">if</span> (old == 1) {
		<span class="enscript-comment">/* That was the last reference */</span>

		<span class="enscript-comment">/* Take the cleanup lock */</span>
		lck_mtx_lock(sock_filter_cleanup_lock);

		<span class="enscript-comment">/* Put this item on the cleanup list */</span>
		entry-&gt;sfe_next_oncleanup = sock_filter_cleanup_entries;
		sock_filter_cleanup_entries = entry;

		<span class="enscript-comment">/* If the item is the first item in the list */</span>
		<span class="enscript-keyword">if</span> (entry-&gt;sfe_next_oncleanup == NULL) {
			<span class="enscript-keyword">if</span> (sock_filter_cleanup_thread == NULL) {
				<span class="enscript-comment">/* Create a thread */</span>
				kernel_thread_start(sflt_cleanup_thread,
				    NULL, &amp;sock_filter_cleanup_thread);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* Wakeup the thread */</span>
				wakeup(&amp;sock_filter_cleanup_entries);
			}
		}

		<span class="enscript-comment">/* Drop the cleanup lock */</span>
		lck_mtx_unlock(sock_filter_cleanup_lock);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (old &lt;= 0) {
		panic(<span class="enscript-string">&quot;sflt_entry_release - sfe_refcount (%d) &lt;= 0\n&quot;</span>,
		    (<span class="enscript-type">int</span>)old);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sflt_cleanup_thread</span>(<span class="enscript-type">void</span> *blah, wait_result_t blah2)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">blah</span>, <span class="enscript-variable-name">blah2</span>)
	<span class="enscript-keyword">while</span> (1) {
		lck_mtx_lock(sock_filter_cleanup_lock);
		<span class="enscript-keyword">while</span> (sock_filter_cleanup_entries == NULL) {
			<span class="enscript-comment">/* Sleep until we've got something better to do */</span>
			msleep(&amp;sock_filter_cleanup_entries,
			    sock_filter_cleanup_lock, PWAIT,
			    <span class="enscript-string">&quot;sflt_cleanup&quot;</span>, NULL);
		}

		<span class="enscript-comment">/* Pull the current list of dead items */</span>
		<span class="enscript-type">struct</span> socket_filter_entry *dead = sock_filter_cleanup_entries;
		sock_filter_cleanup_entries = NULL;

		<span class="enscript-comment">/* Drop the lock */</span>
		lck_mtx_unlock(sock_filter_cleanup_lock);

		<span class="enscript-comment">/* Take the socket filter lock */</span>
		lck_rw_lock_exclusive(sock_filter_lock);

		<span class="enscript-comment">/* Cleanup every dead item */</span>
		<span class="enscript-type">struct</span> socket_filter_entry	*entry;
		<span class="enscript-keyword">for</span> (entry = dead; entry; entry = dead) {
			<span class="enscript-type">struct</span> socket_filter_entry	**nextpp;

			dead = entry-&gt;sfe_next_oncleanup;

			<span class="enscript-comment">/* Call detach function if necessary - drop the lock */</span>
			<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_NODETACH) == 0 &amp;&amp;
			    entry-&gt;sfe_filter-&gt;sf_filter.sf_detach) {
				entry-&gt;sfe_flags |= SFEF_NODETACH;
				lck_rw_unlock_exclusive(sock_filter_lock);

				<span class="enscript-comment">/*
				 * Warning - passing a potentially
				 * dead socket may be bad
				 */</span>
				entry-&gt;sfe_filter-&gt;sf_filter. sf_detach(
				    entry-&gt;sfe_cookie, entry-&gt;sfe_socket);

				lck_rw_lock_exclusive(sock_filter_lock);
			}

			<span class="enscript-comment">/*
			 * Pull entry off the socket list --
			 * if the socket still exists
			 */</span>
			<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_NOSOCKET) == 0) {
				<span class="enscript-keyword">for</span> (nextpp = &amp;entry-&gt;sfe_socket-&gt;so_filt;
				    *nextpp;
				    nextpp = &amp;(*nextpp)-&gt;sfe_next_onsocket) {
					<span class="enscript-keyword">if</span> (*nextpp == entry) {
						*nextpp =
						    entry-&gt;sfe_next_onsocket;
						<span class="enscript-keyword">break</span>;
					}
				}
			}

			<span class="enscript-comment">/* Pull entry off the filter list */</span>
			<span class="enscript-keyword">for</span> (nextpp = &amp;entry-&gt;sfe_filter-&gt;sf_entry_head;
			    *nextpp; nextpp = &amp;(*nextpp)-&gt;sfe_next_onfilter) {
				<span class="enscript-keyword">if</span> (*nextpp == entry) {
					*nextpp = entry-&gt;sfe_next_onfilter;
					<span class="enscript-keyword">break</span>;
				}
			}

			<span class="enscript-comment">/*
			 * Release the filter -- may drop lock, but that's okay
			 */</span>
			sflt_release_locked(entry-&gt;sfe_filter);
			entry-&gt;sfe_socket = NULL;
			entry-&gt;sfe_filter = NULL;
			FREE(entry, M_IFADDR);
		}

		<span class="enscript-comment">/* Drop the socket filter lock */</span>
		lck_rw_unlock_exclusive(sock_filter_lock);
	}
	<span class="enscript-comment">/* NOTREACHED */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sflt_attach_locked</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> socket_filter *filter,
    <span class="enscript-type">int</span> socklocked)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> socket_filter_entry *entry = NULL;

	<span class="enscript-keyword">if</span> (filter == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	<span class="enscript-keyword">for</span> (entry = so-&gt;so_filt; entry; entry = entry-&gt;sfe_next_onfilter) {
		<span class="enscript-keyword">if</span> (entry-&gt;sfe_filter-&gt;sf_filter.sf_handle ==
		    filter-&gt;sf_filter.sf_handle)
			<span class="enscript-keyword">return</span> (EEXIST);
	}
	<span class="enscript-comment">/* allocate the socket filter entry */</span>
	MALLOC(entry, <span class="enscript-type">struct</span> socket_filter_entry *, <span class="enscript-keyword">sizeof</span> (*entry), M_IFADDR,
	    M_WAITOK);
	<span class="enscript-keyword">if</span> (entry == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	<span class="enscript-comment">/* Initialize the socket filter entry */</span>
	entry-&gt;sfe_cookie = NULL;
	entry-&gt;sfe_flags = SFEF_ATTACHED;
	entry-&gt;sfe_refcount = 1; <span class="enscript-comment">/* corresponds to SFEF_ATTACHED flag set */</span>

	<span class="enscript-comment">/* Put the entry in the filter list */</span>
	sflt_retain_locked(filter);
	entry-&gt;sfe_filter = filter;
	entry-&gt;sfe_next_onfilter = filter-&gt;sf_entry_head;
	filter-&gt;sf_entry_head = entry;

	<span class="enscript-comment">/* Put the entry on the socket filter list */</span>
	entry-&gt;sfe_socket = so;
	entry-&gt;sfe_next_onsocket = so-&gt;so_filt;
	so-&gt;so_filt = entry;

	<span class="enscript-keyword">if</span> (entry-&gt;sfe_filter-&gt;sf_filter.sf_attach) {
		<span class="enscript-comment">/* Retain the entry while we call attach */</span>
		sflt_entry_retain(entry);

		<span class="enscript-comment">/*
		 * Release the filter lock --
		 * callers must be aware we will do this
		 */</span>
		lck_rw_unlock_exclusive(sock_filter_lock);

		<span class="enscript-comment">/* Unlock the socket */</span>
		<span class="enscript-keyword">if</span> (socklocked)
			socket_unlock(so, 0);

		<span class="enscript-comment">/* It's finally safe to call the filter function */</span>
		error = entry-&gt;sfe_filter-&gt;sf_filter.sf_attach(
		    &amp;entry-&gt;sfe_cookie, so);

		<span class="enscript-comment">/* Lock the socket again */</span>
		<span class="enscript-keyword">if</span> (socklocked)
			socket_lock(so, 0);

		<span class="enscript-comment">/* Lock the filters again */</span>
		lck_rw_lock_exclusive(sock_filter_lock);

		<span class="enscript-comment">/*
		 * If the attach function returns an error,
		 * this filter must be detached
		 */</span>
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-comment">/* don't call sf_detach */</span>
			entry-&gt;sfe_flags |= SFEF_NODETACH;
			sflt_detach_locked(entry);
		}

		<span class="enscript-comment">/* Release the retain we held through the attach call */</span>
		sflt_entry_release(entry);
	}

	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">sflt_attach_internal</span>(socket_t socket, sflt_handle handle)
{
	<span class="enscript-keyword">if</span> (socket == NULL || handle == 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-type">int</span> result = EINVAL;

	lck_rw_lock_exclusive(sock_filter_lock);

	<span class="enscript-type">struct</span> socket_filter *filter = NULL;
	TAILQ_FOREACH(filter, &amp;sock_filter_head, sf_global_next) {
		<span class="enscript-keyword">if</span> (filter-&gt;sf_filter.sf_handle == handle) <span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (filter) {
		result = sflt_attach_locked(socket, filter, 1);
	}

	lck_rw_unlock_exclusive(sock_filter_lock);

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sflt_detach_locked</span>(<span class="enscript-type">struct</span> socket_filter_entry *entry)
{
	<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_ATTACHED) != 0) {
		entry-&gt;sfe_flags &amp;= ~SFEF_ATTACHED;
		sflt_entry_release(entry);
	}
}

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -- <span class="enscript-variable-name">Socket</span> <span class="enscript-variable-name">Layer</span> <span class="enscript-variable-name">Hooks</span> --

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">sflt_initsock</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-comment">/*
	 * Point to the real protosw, as so_proto might have been
	 * pointed to a modified version.
	 */</span>
	<span class="enscript-type">struct</span> protosw *proto = so-&gt;so_proto-&gt;pr_protosw;

	lck_rw_lock_shared(sock_filter_lock);
	<span class="enscript-keyword">if</span> (TAILQ_FIRST(&amp;proto-&gt;pr_filter_head) != NULL) {
		<span class="enscript-comment">/* Promote lock to exclusive */</span>
		<span class="enscript-keyword">if</span> (!lck_rw_lock_shared_to_exclusive(sock_filter_lock))
			lck_rw_lock_exclusive(sock_filter_lock);

		<span class="enscript-comment">/*
		 * Warning: A filter unregistering will be pulled out of
		 * the list.  This could happen while we drop the lock in
		 * sftl_attach_locked or sflt_release_locked.  For this
		 * reason we retain a reference on the filter (or next_filter)
		 * while calling this function.  This protects us from a panic,
		 * but it could result in a socket being created without all
		 * of the global filters if we're attaching a filter as it
		 * is removed, if that's possible.
		 */</span>
		<span class="enscript-type">struct</span> socket_filter *filter =
		    TAILQ_FIRST(&amp;proto-&gt;pr_filter_head);

		sflt_retain_locked(filter);

		<span class="enscript-keyword">while</span> (filter) {
			<span class="enscript-type">struct</span> socket_filter *filter_next;
			<span class="enscript-comment">/*
			 * Warning: sflt_attach_private_locked
			 * will drop the lock
			 */</span>
			sflt_attach_locked(so, filter, 0);

			filter_next = TAILQ_NEXT(filter, sf_protosw_next);
			<span class="enscript-keyword">if</span> (filter_next)
				sflt_retain_locked(filter_next);

			<span class="enscript-comment">/*
			 * Warning: filt_release_locked may remove
			 * the filter from the queue
			 */</span>
			sflt_release_locked(filter);
			filter = filter_next;
		}
	}
	lck_rw_done(sock_filter_lock);
}

<span class="enscript-comment">/*
 * sflt_termsock
 *
 * Detaches all filters from the socket.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">sflt_termsock</span>(<span class="enscript-type">struct</span> socket *so)
{
	lck_rw_lock_exclusive(sock_filter_lock);

	<span class="enscript-type">struct</span> socket_filter_entry *entry;

	<span class="enscript-keyword">while</span> ((entry = so-&gt;so_filt) != NULL) {
		<span class="enscript-comment">/* Pull filter off the socket */</span>
		so-&gt;so_filt = entry-&gt;sfe_next_onsocket;
		entry-&gt;sfe_flags |= SFEF_NOSOCKET;

		<span class="enscript-comment">/* Call detach */</span>
		sflt_detach_locked(entry);

		<span class="enscript-comment">/*
		 * On sflt_termsock, we can't return until the detach function
		 * has been called.  Call the detach function - this is gross
		 * because the socket filter entry could be freed when we drop
		 * the lock, so we make copies on  the stack and retain
		 * everything we need before dropping the lock.
		 */</span>
		<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_NODETACH) == 0 &amp;&amp;
		    entry-&gt;sfe_filter-&gt;sf_filter.sf_detach) {
			<span class="enscript-type">void</span> *sfe_cookie = entry-&gt;sfe_cookie;
			<span class="enscript-type">struct</span> socket_filter *sfe_filter = entry-&gt;sfe_filter;

			<span class="enscript-comment">/* Retain the socket filter */</span>
			sflt_retain_locked(sfe_filter);

			<span class="enscript-comment">/* Mark that we've called the detach function */</span>
			entry-&gt;sfe_flags |= SFEF_NODETACH;

			<span class="enscript-comment">/* Drop the lock before calling the detach function */</span>
			lck_rw_unlock_exclusive(sock_filter_lock);
			sfe_filter-&gt;sf_filter.sf_detach(sfe_cookie, so);
			lck_rw_lock_exclusive(sock_filter_lock);

			<span class="enscript-comment">/* Release the filter */</span>
			sflt_release_locked(sfe_filter);
		}
	}

	lck_rw_unlock_exclusive(sock_filter_lock);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sflt_notify_internal</span>(<span class="enscript-type">struct</span> socket *so, sflt_event_t event, <span class="enscript-type">void</span> *param,
    sflt_handle handle)
{
	<span class="enscript-keyword">if</span> (so-&gt;so_filt == NULL)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-type">struct</span> socket_filter_entry *entry;
	<span class="enscript-type">int</span> unlocked = 0;

	lck_rw_lock_shared(sock_filter_lock);
	<span class="enscript-keyword">for</span> (entry = so-&gt;so_filt; entry; entry = entry-&gt;sfe_next_onsocket) {
		<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_ATTACHED) &amp;&amp;
		    entry-&gt;sfe_filter-&gt;sf_filter.sf_notify &amp;&amp;
		    ((handle &amp;&amp; entry-&gt;sfe_filter-&gt;sf_filter.sf_handle !=
		    handle) || !handle)) {
			<span class="enscript-comment">/*
			 * Retain the filter entry and release
			 * the socket filter lock
			 */</span>
			sflt_entry_retain(entry);
			lck_rw_unlock_shared(sock_filter_lock);

			<span class="enscript-comment">/* If the socket isn't already unlocked, unlock it */</span>
			<span class="enscript-keyword">if</span> (unlocked == 0) {
				unlocked = 1;
				socket_unlock(so, 0);
			}

			<span class="enscript-comment">/* Finally call the filter */</span>
			entry-&gt;sfe_filter-&gt;sf_filter.sf_notify(
			    entry-&gt;sfe_cookie, so, event, param);

			<span class="enscript-comment">/*
			 * Take the socket filter lock again
			 * and release the entry
			 */</span>
			lck_rw_lock_shared(sock_filter_lock);
			sflt_entry_release(entry);
		}
	}
	lck_rw_unlock_shared(sock_filter_lock);

	<span class="enscript-keyword">if</span> (unlocked != 0) {
		socket_lock(so, 0);
	}
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">sflt_notify</span>(<span class="enscript-type">struct</span> socket *so, sflt_event_t event, <span class="enscript-type">void</span>	 *param)
{
	sflt_notify_internal(so, event, param, 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sflt_notify_after_register</span>(<span class="enscript-type">struct</span> socket *so, sflt_event_t event,
    sflt_handle handle)
{
	sflt_notify_internal(so, event, NULL, handle);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sflt_ioctl</span>(<span class="enscript-type">struct</span> socket *so, u_long cmd, caddr_t data)
{
	<span class="enscript-keyword">if</span> (so-&gt;so_filt == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-type">struct</span> socket_filter_entry *entry;
	<span class="enscript-type">int</span> unlocked = 0;
	<span class="enscript-type">int</span> error = 0;

	lck_rw_lock_shared(sock_filter_lock);
	<span class="enscript-keyword">for</span> (entry = so-&gt;so_filt; entry &amp;&amp; error == 0;
	    entry = entry-&gt;sfe_next_onsocket) {
		<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_ATTACHED) &amp;&amp;
		    entry-&gt;sfe_filter-&gt;sf_filter.sf_ioctl) {
			<span class="enscript-comment">/*
			 * Retain the filter entry and release
			 * the socket filter lock
			 */</span>
			sflt_entry_retain(entry);
			lck_rw_unlock_shared(sock_filter_lock);

			<span class="enscript-comment">/* If the socket isn't already unlocked, unlock it */</span>
			<span class="enscript-keyword">if</span> (unlocked == 0) {
				socket_unlock(so, 0);
				unlocked = 1;
			}

			<span class="enscript-comment">/* Call the filter */</span>
			error = entry-&gt;sfe_filter-&gt;sf_filter.sf_ioctl(
			    entry-&gt;sfe_cookie, so, cmd, data);

			<span class="enscript-comment">/*
			 * Take the socket filter lock again
			 * and release the entry
			 */</span>
			lck_rw_lock_shared(sock_filter_lock);
			sflt_entry_release(entry);
		}
	}
	lck_rw_unlock_shared(sock_filter_lock);

	<span class="enscript-keyword">if</span> (unlocked) {
		socket_lock(so, 0);
	}

	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sflt_bind</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *nam)
{
	<span class="enscript-keyword">if</span> (so-&gt;so_filt == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-type">struct</span> socket_filter_entry *entry;
	<span class="enscript-type">int</span> unlocked = 0;
	<span class="enscript-type">int</span> error = 0;

	lck_rw_lock_shared(sock_filter_lock);
	<span class="enscript-keyword">for</span> (entry = so-&gt;so_filt; entry &amp;&amp; error == 0;
	    entry = entry-&gt;sfe_next_onsocket) {
		<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_ATTACHED) &amp;&amp;
		    entry-&gt;sfe_filter-&gt;sf_filter.sf_bind) {
			<span class="enscript-comment">/*
			 * Retain the filter entry and
			 * release the socket filter lock
			 */</span>
			sflt_entry_retain(entry);
			lck_rw_unlock_shared(sock_filter_lock);

			<span class="enscript-comment">/* If the socket isn't already unlocked, unlock it */</span>
			<span class="enscript-keyword">if</span> (unlocked == 0) {
				socket_unlock(so, 0);
				unlocked = 1;
			}

			<span class="enscript-comment">/* Call the filter */</span>
			error = entry-&gt;sfe_filter-&gt;sf_filter.sf_bind(
			    entry-&gt;sfe_cookie, so, nam);

			<span class="enscript-comment">/*
			 * Take the socket filter lock again and
			 * release the entry
			 */</span>
			lck_rw_lock_shared(sock_filter_lock);
			sflt_entry_release(entry);
		}
	}
	lck_rw_unlock_shared(sock_filter_lock);

	<span class="enscript-keyword">if</span> (unlocked) {
		socket_lock(so, 0);
	}

	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sflt_listen</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-keyword">if</span> (so-&gt;so_filt == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-type">struct</span> socket_filter_entry *entry;
	<span class="enscript-type">int</span> unlocked = 0;
	<span class="enscript-type">int</span> error = 0;

	lck_rw_lock_shared(sock_filter_lock);
	<span class="enscript-keyword">for</span> (entry = so-&gt;so_filt; entry &amp;&amp; error == 0;
	    entry = entry-&gt;sfe_next_onsocket) {
		<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_ATTACHED) &amp;&amp;
		    entry-&gt;sfe_filter-&gt;sf_filter.sf_listen) {
			<span class="enscript-comment">/*
			 * Retain the filter entry and release
			 * the socket filter lock
			 */</span>
			sflt_entry_retain(entry);
			lck_rw_unlock_shared(sock_filter_lock);

			<span class="enscript-comment">/* If the socket isn't already unlocked, unlock it */</span>
			<span class="enscript-keyword">if</span> (unlocked == 0) {
				socket_unlock(so, 0);
				unlocked = 1;
			}

			<span class="enscript-comment">/* Call the filter */</span>
			error = entry-&gt;sfe_filter-&gt;sf_filter.sf_listen(
			    entry-&gt;sfe_cookie, so);

			<span class="enscript-comment">/*
			 * Take the socket filter lock again
			 * and release the entry
			 */</span>
			lck_rw_lock_shared(sock_filter_lock);
			sflt_entry_release(entry);
		}
	}
	lck_rw_unlock_shared(sock_filter_lock);

	<span class="enscript-keyword">if</span> (unlocked) {
		socket_lock(so, 0);
	}

	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sflt_accept</span>(<span class="enscript-type">struct</span> socket *head, <span class="enscript-type">struct</span> socket *so,
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *local, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *remote)
{
	<span class="enscript-keyword">if</span> (so-&gt;so_filt == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-type">struct</span> socket_filter_entry *entry;
	<span class="enscript-type">int</span> unlocked = 0;
	<span class="enscript-type">int</span> error = 0;

	lck_rw_lock_shared(sock_filter_lock);
	<span class="enscript-keyword">for</span> (entry = so-&gt;so_filt; entry &amp;&amp; error == 0;
	    entry = entry-&gt;sfe_next_onsocket) {
		<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_ATTACHED) &amp;&amp;
		    entry-&gt;sfe_filter-&gt;sf_filter.sf_accept) {
			<span class="enscript-comment">/*
			 * Retain the filter entry and
			 * release the socket filter lock
			 */</span>
			sflt_entry_retain(entry);
			lck_rw_unlock_shared(sock_filter_lock);

			<span class="enscript-comment">/* If the socket isn't already unlocked, unlock it */</span>
			<span class="enscript-keyword">if</span> (unlocked == 0) {
				socket_unlock(so, 0);
				unlocked = 1;
			}

			<span class="enscript-comment">/* Call the filter */</span>
			error = entry-&gt;sfe_filter-&gt;sf_filter.sf_accept(
			    entry-&gt;sfe_cookie, head, so, local, remote);

			<span class="enscript-comment">/*
			 * Take the socket filter lock again
			 * and release the entry
			 */</span>
			lck_rw_lock_shared(sock_filter_lock);
			sflt_entry_release(entry);
		}
	}
	lck_rw_unlock_shared(sock_filter_lock);

	<span class="enscript-keyword">if</span> (unlocked) {
		socket_lock(so, 0);
	}

	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sflt_getsockname</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **local)
{
	<span class="enscript-keyword">if</span> (so-&gt;so_filt == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-type">struct</span> socket_filter_entry *entry;
	<span class="enscript-type">int</span> unlocked = 0;
	<span class="enscript-type">int</span> error = 0;

	lck_rw_lock_shared(sock_filter_lock);
	<span class="enscript-keyword">for</span> (entry = so-&gt;so_filt; entry &amp;&amp; error == 0;
	    entry = entry-&gt;sfe_next_onsocket) {
		<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_ATTACHED) &amp;&amp;
		    entry-&gt;sfe_filter-&gt;sf_filter.sf_getsockname) {
			<span class="enscript-comment">/*
			 * Retain the filter entry and
			 * release the socket filter lock
			 */</span>
			sflt_entry_retain(entry);
			lck_rw_unlock_shared(sock_filter_lock);

			<span class="enscript-comment">/* If the socket isn't already unlocked, unlock it */</span>
			<span class="enscript-keyword">if</span> (unlocked == 0) {
				socket_unlock(so, 0);
				unlocked = 1;
			}

			<span class="enscript-comment">/* Call the filter */</span>
			error = entry-&gt;sfe_filter-&gt;sf_filter.sf_getsockname(
			    entry-&gt;sfe_cookie, so, local);

			<span class="enscript-comment">/*
			 * Take the socket filter lock again
			 * and release the entry
			 */</span>
			lck_rw_lock_shared(sock_filter_lock);
			sflt_entry_release(entry);
		}
	}
	lck_rw_unlock_shared(sock_filter_lock);

	<span class="enscript-keyword">if</span> (unlocked) {
		socket_lock(so, 0);
	}

	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sflt_getpeername</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **remote)
{
	<span class="enscript-keyword">if</span> (so-&gt;so_filt == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-type">struct</span> socket_filter_entry *entry;
	<span class="enscript-type">int</span> unlocked = 0;
	<span class="enscript-type">int</span> error = 0;

	lck_rw_lock_shared(sock_filter_lock);
	<span class="enscript-keyword">for</span> (entry = so-&gt;so_filt; entry &amp;&amp; error == 0;
	    entry = entry-&gt;sfe_next_onsocket) {
		<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_ATTACHED) &amp;&amp;
		    entry-&gt;sfe_filter-&gt;sf_filter.sf_getpeername) {
			<span class="enscript-comment">/*
			 * Retain the filter entry and release
			 * the socket filter lock
			 */</span>
			sflt_entry_retain(entry);
			lck_rw_unlock_shared(sock_filter_lock);

			<span class="enscript-comment">/* If the socket isn't already unlocked, unlock it */</span>
			<span class="enscript-keyword">if</span> (unlocked == 0) {
				socket_unlock(so, 0);
				unlocked = 1;
			}

			<span class="enscript-comment">/* Call the filter */</span>
			error = entry-&gt;sfe_filter-&gt;sf_filter.sf_getpeername(
			    entry-&gt;sfe_cookie, so, remote);

			<span class="enscript-comment">/*
			 * Take the socket filter lock again
			 * and release the entry
			 */</span>
			lck_rw_lock_shared(sock_filter_lock);
			sflt_entry_release(entry);
		}
	}
	lck_rw_unlock_shared(sock_filter_lock);

	<span class="enscript-keyword">if</span> (unlocked) {
		socket_lock(so, 0);
	}

	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sflt_connectin</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr	*remote)
{
	<span class="enscript-keyword">if</span> (so-&gt;so_filt == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-type">struct</span> socket_filter_entry *entry;
	<span class="enscript-type">int</span> unlocked = 0;
	<span class="enscript-type">int</span> error = 0;

	lck_rw_lock_shared(sock_filter_lock);
	<span class="enscript-keyword">for</span> (entry = so-&gt;so_filt; entry &amp;&amp; error == 0;
	    entry = entry-&gt;sfe_next_onsocket) {
		<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_ATTACHED) &amp;&amp;
		    entry-&gt;sfe_filter-&gt;sf_filter.sf_connect_in) {
			<span class="enscript-comment">/*
			 * Retain the filter entry and release
			 * the socket filter lock
			 */</span>
			sflt_entry_retain(entry);
			lck_rw_unlock_shared(sock_filter_lock);

			<span class="enscript-comment">/* If the socket isn't already unlocked, unlock it */</span>
			<span class="enscript-keyword">if</span> (unlocked == 0) {
				socket_unlock(so, 0);
				unlocked = 1;
			}

			<span class="enscript-comment">/* Call the filter */</span>
			error = entry-&gt;sfe_filter-&gt;sf_filter.sf_connect_in(
			    entry-&gt;sfe_cookie, so, remote);

			<span class="enscript-comment">/*
			 * Take the socket filter lock again
			 * and release the entry
			 */</span>
			lck_rw_lock_shared(sock_filter_lock);
			sflt_entry_release(entry);
		}
	}
	lck_rw_unlock_shared(sock_filter_lock);

	<span class="enscript-keyword">if</span> (unlocked) {
		socket_lock(so, 0);
	}

	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sflt_connectout</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *nam)
{
	<span class="enscript-keyword">if</span> (so-&gt;so_filt == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-type">struct</span> socket_filter_entry *entry;
	<span class="enscript-type">int</span> unlocked = 0;
	<span class="enscript-type">int</span> error = 0;

	lck_rw_lock_shared(sock_filter_lock);
	<span class="enscript-keyword">for</span> (entry = so-&gt;so_filt; entry &amp;&amp; error == 0;
	    entry = entry-&gt;sfe_next_onsocket) {
		<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_ATTACHED) &amp;&amp;
		    entry-&gt;sfe_filter-&gt;sf_filter.sf_connect_out) {
			<span class="enscript-comment">/*
			 * Retain the filter entry and release
			 * the socket filter lock
			 */</span>
			sflt_entry_retain(entry);
			lck_rw_unlock_shared(sock_filter_lock);

			<span class="enscript-comment">/* If the socket isn't already unlocked, unlock it */</span>
			<span class="enscript-keyword">if</span> (unlocked == 0) {
				socket_unlock(so, 0);
				unlocked = 1;
			}

			<span class="enscript-comment">/* Call the filter */</span>
			error = entry-&gt;sfe_filter-&gt;sf_filter.sf_connect_out(
			    entry-&gt;sfe_cookie, so, nam);

			<span class="enscript-comment">/*
			 * Take the socket filter lock again
			 * and release the entry
			 */</span>
			lck_rw_lock_shared(sock_filter_lock);
			sflt_entry_release(entry);
		}
	}
	lck_rw_unlock_shared(sock_filter_lock);

	<span class="enscript-keyword">if</span> (unlocked) {
		socket_lock(so, 0);
	}

	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sflt_connectxout</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr_list **dst_sl0)
{
	<span class="enscript-type">char</span> buf[SOCK_MAXADDRLEN];
	<span class="enscript-type">struct</span> sockaddr_list *dst_sl;
	<span class="enscript-type">struct</span> sockaddr_entry *se, *tse;
	<span class="enscript-type">int</span> modified = 0;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (so-&gt;so_filt == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/* make a copy as sflt_connectout() releases socket lock */</span>
	dst_sl = sockaddrlist_dup(*dst_sl0, M_WAITOK);
	<span class="enscript-keyword">if</span> (dst_sl == NULL)
		<span class="enscript-keyword">return</span> (ENOBUFS);

	<span class="enscript-comment">/*
	 * Hmm; we don't yet have a connectx socket filter callback,
	 * so the closest thing to do is to probably call sflt_connectout()
	 * as many times as there are addresses in the list, and bail
	 * as soon as we get an error.
	 */</span>
	TAILQ_FOREACH_SAFE(se, &amp;dst_sl-&gt;sl_head, se_link, tse) {
		<span class="enscript-type">int</span> sa_len = se-&gt;se_addr-&gt;sa_len;

		<span class="enscript-comment">/* remember the original address */</span>
		bzero(buf, <span class="enscript-keyword">sizeof</span> (buf));
		bcopy(se-&gt;se_addr, buf, sa_len);

		VERIFY(se-&gt;se_addr != NULL);
		error = sflt_connectout(so, se-&gt;se_addr);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-comment">/* see if the address was modified */</span>
		<span class="enscript-keyword">if</span> (bcmp(se-&gt;se_addr, buf, sa_len) != 0)
			modified = 1;
	}

	<span class="enscript-keyword">if</span> (error != 0 || !modified) {
		<span class="enscript-comment">/* leave the original as is */</span>
		sockaddrlist_free(dst_sl);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * At least one address was modified and there were no errors;
		 * ditch the original and return the modified list.
		 */</span>
		sockaddrlist_free(*dst_sl0);
		*dst_sl0 = dst_sl;
	}

	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sflt_setsockopt</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-keyword">if</span> (so-&gt;so_filt == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-type">struct</span> socket_filter_entry *entry;
	<span class="enscript-type">int</span> unlocked = 0;
	<span class="enscript-type">int</span> error = 0;

	lck_rw_lock_shared(sock_filter_lock);
	<span class="enscript-keyword">for</span> (entry = so-&gt;so_filt; entry &amp;&amp; error == 0;
	    entry = entry-&gt;sfe_next_onsocket) {
		<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_ATTACHED) &amp;&amp;
		    entry-&gt;sfe_filter-&gt;sf_filter.sf_setoption) {
			<span class="enscript-comment">/*
			 * Retain the filter entry and release
			 * the socket filter lock
			 */</span>
			sflt_entry_retain(entry);
			lck_rw_unlock_shared(sock_filter_lock);

			<span class="enscript-comment">/* If the socket isn't already unlocked, unlock it */</span>
			<span class="enscript-keyword">if</span> (unlocked == 0) {
				socket_unlock(so, 0);
				unlocked = 1;
			}

			<span class="enscript-comment">/* Call the filter */</span>
			error = entry-&gt;sfe_filter-&gt;sf_filter.sf_setoption(
			    entry-&gt;sfe_cookie, so, sopt);

			<span class="enscript-comment">/*
			 * Take the socket filter lock again
			 * and release the entry
			 */</span>
			lck_rw_lock_shared(sock_filter_lock);
			sflt_entry_release(entry);
		}
	}
	lck_rw_unlock_shared(sock_filter_lock);

	<span class="enscript-keyword">if</span> (unlocked) {
		socket_lock(so, 0);
	}

	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sflt_getsockopt</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt)
{
	<span class="enscript-keyword">if</span> (so-&gt;so_filt == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-type">struct</span> socket_filter_entry *entry;
	<span class="enscript-type">int</span> unlocked = 0;
	<span class="enscript-type">int</span> error = 0;

	lck_rw_lock_shared(sock_filter_lock);
	<span class="enscript-keyword">for</span> (entry = so-&gt;so_filt; entry &amp;&amp; error == 0;
	    entry = entry-&gt;sfe_next_onsocket) {
		<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_ATTACHED) &amp;&amp;
		    entry-&gt;sfe_filter-&gt;sf_filter.sf_getoption) {
			<span class="enscript-comment">/*
			 * Retain the filter entry and release
			 * the socket filter lock
			 */</span>
			sflt_entry_retain(entry);
			lck_rw_unlock_shared(sock_filter_lock);

			<span class="enscript-comment">/* If the socket isn't already unlocked, unlock it */</span>
			<span class="enscript-keyword">if</span> (unlocked == 0) {
				socket_unlock(so, 0);
				unlocked = 1;
			}

			<span class="enscript-comment">/* Call the filter */</span>
			error = entry-&gt;sfe_filter-&gt;sf_filter.sf_getoption(
			    entry-&gt;sfe_cookie, so, sopt);

			<span class="enscript-comment">/*
			 * Take the socket filter lock again
			 * and release the entry
			 */</span>
			lck_rw_lock_shared(sock_filter_lock);
			sflt_entry_release(entry);
		}
	}
	lck_rw_unlock_shared(sock_filter_lock);

	<span class="enscript-keyword">if</span> (unlocked) {
		socket_lock(so, 0);
	}

	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sflt_data_out</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *to, mbuf_t *data,
    mbuf_t *control, sflt_data_flag_t flags)
{
	<span class="enscript-keyword">if</span> (so-&gt;so_filt == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-type">struct</span> socket_filter_entry *entry;
	<span class="enscript-type">int</span> unlocked = 0;
	<span class="enscript-type">int</span> setsendthread = 0;
	<span class="enscript-type">int</span> error = 0;

	lck_rw_lock_shared(sock_filter_lock);
	<span class="enscript-keyword">for</span> (entry = so-&gt;so_filt; entry &amp;&amp; error == 0;
	    entry = entry-&gt;sfe_next_onsocket) {
		<span class="enscript-comment">/* skip if this is a subflow socket */</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_MP_SUBFLOW)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_ATTACHED) &amp;&amp;
		    entry-&gt;sfe_filter-&gt;sf_filter.sf_data_out) {
			<span class="enscript-comment">/*
			 * Retain the filter entry and
			 * release the socket filter lock
			 */</span>
			sflt_entry_retain(entry);
			lck_rw_unlock_shared(sock_filter_lock);

			<span class="enscript-comment">/* If the socket isn't already unlocked, unlock it */</span>
			<span class="enscript-keyword">if</span> (unlocked == 0) {
				<span class="enscript-keyword">if</span> (so-&gt;so_send_filt_thread == NULL) {
					setsendthread = 1;
					so-&gt;so_send_filt_thread =
					    current_thread();
				}
				socket_unlock(so, 0);
				unlocked = 1;
			}

			<span class="enscript-comment">/* Call the filter */</span>
			error = entry-&gt;sfe_filter-&gt;sf_filter.sf_data_out(
			    entry-&gt;sfe_cookie, so, to, data, control, flags);

			<span class="enscript-comment">/*
			 * Take the socket filter lock again
			 * and release the entry
			 */</span>
			lck_rw_lock_shared(sock_filter_lock);
			sflt_entry_release(entry);
		}
	}
	lck_rw_unlock_shared(sock_filter_lock);

	<span class="enscript-keyword">if</span> (unlocked) {
		socket_lock(so, 0);
		<span class="enscript-keyword">if</span> (setsendthread)
			so-&gt;so_send_filt_thread = NULL;
	}

	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sflt_data_in</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *from, mbuf_t *data,
    mbuf_t *control, sflt_data_flag_t flags)
{
	<span class="enscript-keyword">if</span> (so-&gt;so_filt == NULL)
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-type">struct</span> socket_filter_entry *entry;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> unlocked = 0;

	lck_rw_lock_shared(sock_filter_lock);

	<span class="enscript-keyword">for</span> (entry = so-&gt;so_filt; entry &amp;&amp; (error == 0);
	    entry = entry-&gt;sfe_next_onsocket) {
		<span class="enscript-comment">/* skip if this is a subflow socket */</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_MP_SUBFLOW)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> ((entry-&gt;sfe_flags &amp; SFEF_ATTACHED) &amp;&amp;
		    entry-&gt;sfe_filter-&gt;sf_filter.sf_data_in) {
			<span class="enscript-comment">/*
			 * Retain the filter entry and
			 * release the socket filter lock
			 */</span>
			sflt_entry_retain(entry);
			lck_rw_unlock_shared(sock_filter_lock);

			<span class="enscript-comment">/* If the socket isn't already unlocked, unlock it */</span>
			<span class="enscript-keyword">if</span> (unlocked == 0) {
				unlocked = 1;
				socket_unlock(so, 0);
			}

			<span class="enscript-comment">/* Call the filter */</span>
			error = entry-&gt;sfe_filter-&gt;sf_filter.sf_data_in(
			    entry-&gt;sfe_cookie, so, from, data, control, flags);

			<span class="enscript-comment">/*
			 * Take the socket filter lock again
			 * and release the entry
			 */</span>
			lck_rw_lock_shared(sock_filter_lock);
			sflt_entry_release(entry);
		}
	}
	lck_rw_unlock_shared(sock_filter_lock);

	<span class="enscript-keyword">if</span> (unlocked) {
		socket_lock(so, 0);
	}

	<span class="enscript-keyword">return</span> (error);
}

#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -- <span class="enscript-variable-name">KPI</span> --

errno_t
<span class="enscript-function-name">sflt_attach</span>(socket_t socket, sflt_handle handle)
{
	socket_lock(socket, 1);
	errno_t result = sflt_attach_internal(socket, handle);
	socket_unlock(socket, 1);
	<span class="enscript-keyword">return</span> (result);
}

errno_t
<span class="enscript-function-name">sflt_detach</span>(socket_t socket, sflt_handle handle)
{
	<span class="enscript-type">struct</span> socket_filter_entry *entry;
	errno_t	result = 0;

	<span class="enscript-keyword">if</span> (socket == NULL || handle == 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	lck_rw_lock_exclusive(sock_filter_lock);
	<span class="enscript-keyword">for</span> (entry = socket-&gt;so_filt; entry; entry = entry-&gt;sfe_next_onsocket) {
		<span class="enscript-keyword">if</span> (entry-&gt;sfe_filter-&gt;sf_filter.sf_handle == handle &amp;&amp;
		    (entry-&gt;sfe_flags &amp; SFEF_ATTACHED) != 0) {
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">if</span> (entry != NULL) {
		sflt_detach_locked(entry);
	}
	lck_rw_unlock_exclusive(sock_filter_lock);

	<span class="enscript-keyword">return</span> (result);
}

<span class="enscript-type">struct</span> solist {
	<span class="enscript-type">struct</span> solist *next;
	<span class="enscript-type">struct</span> socket *so;
};

errno_t
<span class="enscript-function-name">sflt_register</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sflt_filter *filter, <span class="enscript-type">int</span> domain, <span class="enscript-type">int</span> type,
    <span class="enscript-type">int</span>	 protocol)
{
	<span class="enscript-type">struct</span> socket_filter *sock_filt = NULL;
	<span class="enscript-type">struct</span> socket_filter *match = NULL;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> protosw *pr;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len;
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">struct</span> inpcb *inp;
	<span class="enscript-type">struct</span> solist *solisthead = NULL, *solist = NULL;

	<span class="enscript-keyword">if</span> ((domain != PF_INET) &amp;&amp; (domain != PF_INET6))
		<span class="enscript-keyword">return</span> (ENOTSUP);

	pr = pffindproto(domain, protocol, type);
	<span class="enscript-keyword">if</span> (pr == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	<span class="enscript-keyword">if</span> (filter-&gt;sf_attach == NULL || filter-&gt;sf_detach == NULL ||
	    filter-&gt;sf_handle == 0 || filter-&gt;sf_name == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* Allocate the socket filter */</span>
	MALLOC(sock_filt, <span class="enscript-type">struct</span> socket_filter *, <span class="enscript-keyword">sizeof</span> (*sock_filt),
	    M_IFADDR, M_WAITOK);
	<span class="enscript-keyword">if</span> (sock_filt == NULL) {
		<span class="enscript-keyword">return</span> (ENOBUFS);
	}

	bzero(sock_filt, <span class="enscript-keyword">sizeof</span> (*sock_filt));

	<span class="enscript-comment">/* Legacy sflt_filter length; current structure minus extended */</span>
	len = <span class="enscript-keyword">sizeof</span> (*filter) - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sflt_filter_ext);
	<span class="enscript-comment">/*
	 * Include extended fields if filter defines SFLT_EXTENDED.
	 * We've zeroed out our internal sflt_filter placeholder,
	 * so any unused portion would have been taken care of.
	 */</span>
	<span class="enscript-keyword">if</span> (filter-&gt;sf_flags &amp; SFLT_EXTENDED) {
		<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ext_len = filter-&gt;sf_len;

		<span class="enscript-keyword">if</span> (ext_len &gt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sflt_filter_ext))
			ext_len = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sflt_filter_ext);

		len += ext_len;
	}
	bcopy(filter, &amp;sock_filt-&gt;sf_filter, len);

	lck_rw_lock_exclusive(sock_filter_lock);
	<span class="enscript-comment">/* Look for an existing entry */</span>
	TAILQ_FOREACH(match, &amp;sock_filter_head, sf_global_next) {
		<span class="enscript-keyword">if</span> (match-&gt;sf_filter.sf_handle ==
		    sock_filt-&gt;sf_filter.sf_handle) {
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-comment">/* Add the entry only if there was no existing entry */</span>
	<span class="enscript-keyword">if</span> (match == NULL) {
		TAILQ_INSERT_TAIL(&amp;sock_filter_head, sock_filt, sf_global_next);
		<span class="enscript-keyword">if</span> ((sock_filt-&gt;sf_filter.sf_flags &amp; SFLT_GLOBAL) != 0) {
			TAILQ_INSERT_TAIL(&amp;pr-&gt;pr_filter_head, sock_filt,
			    sf_protosw_next);
			sock_filt-&gt;sf_proto = pr;
		}
		sflt_retain_locked(sock_filt);
	}
	lck_rw_unlock_exclusive(sock_filter_lock);

	<span class="enscript-keyword">if</span> (match != NULL) {
		FREE(sock_filt, M_IFADDR);
		<span class="enscript-keyword">return</span> (EEXIST);
	}

	<span class="enscript-keyword">if</span> (!(filter-&gt;sf_flags &amp; SFLT_EXTENDED_REGISTRY))
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * Setup the filter on the TCP and UDP sockets already created.
	 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SOLIST_ADD</span>(_so) do {						\
	solist-&gt;next = solisthead;					\
	sock_retain((_so));						\
	solist-&gt;so = (_so);						\
	solisthead = solist;						\
} <span class="enscript-keyword">while</span> (0)
	<span class="enscript-keyword">if</span> (protocol == IPPROTO_TCP) {
		lck_rw_lock_shared(tcbinfo.ipi_lock);
		LIST_FOREACH(inp, tcbinfo.ipi_listhead, inp_list) {
			so = inp-&gt;inp_socket;
			<span class="enscript-keyword">if</span> (so == NULL || (so-&gt;so_state &amp; SS_DEFUNCT) ||
			    (!(so-&gt;so_flags &amp; SOF_MP_SUBFLOW) &amp;&amp;
			    (so-&gt;so_state &amp; SS_NOFDREF)) ||
			    !SOCK_CHECK_DOM(so, domain) ||
			    !SOCK_CHECK_TYPE(so, type))
				<span class="enscript-keyword">continue</span>;
			MALLOC(solist, <span class="enscript-type">struct</span> solist *, <span class="enscript-keyword">sizeof</span> (*solist),
			    M_IFADDR, M_NOWAIT);
			<span class="enscript-keyword">if</span> (!solist)
				<span class="enscript-keyword">continue</span>;
			SOLIST_ADD(so);
		}
		lck_rw_done(tcbinfo.ipi_lock);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (protocol == IPPROTO_UDP) {
		lck_rw_lock_shared(udbinfo.ipi_lock);
		LIST_FOREACH(inp, udbinfo.ipi_listhead, inp_list) {
			so = inp-&gt;inp_socket;
			<span class="enscript-keyword">if</span> (so == NULL || (so-&gt;so_state &amp; SS_DEFUNCT) ||
			    (!(so-&gt;so_flags &amp; SOF_MP_SUBFLOW) &amp;&amp;
			    (so-&gt;so_state &amp; SS_NOFDREF)) ||
			    !SOCK_CHECK_DOM(so, domain) ||
			    !SOCK_CHECK_TYPE(so, type))
				<span class="enscript-keyword">continue</span>;
			MALLOC(solist, <span class="enscript-type">struct</span> solist *, <span class="enscript-keyword">sizeof</span> (*solist),
			    M_IFADDR, M_NOWAIT);
			<span class="enscript-keyword">if</span> (!solist)
				<span class="enscript-keyword">continue</span>;
			SOLIST_ADD(so);
		}
		lck_rw_done(udbinfo.ipi_lock);
	}
	<span class="enscript-comment">/* XXX it's possible to walk the raw socket list as well */</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">SOLIST_ADD</span>

	<span class="enscript-keyword">while</span> (solisthead) {
		sflt_handle handle = filter-&gt;sf_handle;

		so = solisthead-&gt;so;
		socket_lock(so, 0);
		sflt_initsock(so);
		<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_ISCONNECTING)
			sflt_notify_after_register(so, sock_evt_connecting,
			    handle);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_ISCONNECTED)
			sflt_notify_after_register(so, sock_evt_connected,
			    handle);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((so-&gt;so_state &amp;
		    (SS_ISDISCONNECTING|SS_CANTRCVMORE|SS_CANTSENDMORE)) ==
		    (SS_ISDISCONNECTING|SS_CANTRCVMORE|SS_CANTSENDMORE))
			sflt_notify_after_register(so, sock_evt_disconnecting,
			    handle);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((so-&gt;so_state &amp;
		    (SS_CANTRCVMORE|SS_CANTSENDMORE|SS_ISDISCONNECTED)) ==
		    (SS_CANTRCVMORE|SS_CANTSENDMORE|SS_ISDISCONNECTED))
			sflt_notify_after_register(so, sock_evt_disconnected,
			    handle);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_CANTSENDMORE)
			sflt_notify_after_register(so, sock_evt_cantsendmore,
			    handle);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_CANTRCVMORE)
			sflt_notify_after_register(so, sock_evt_cantrecvmore,
			    handle);
		socket_unlock(so, 0);
		<span class="enscript-comment">/* XXX no easy way to post the sock_evt_closing event */</span>
		sock_release(so);
		solist = solisthead;
		solisthead = solisthead-&gt;next;
		FREE(solist, M_IFADDR);
	}

	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">sflt_unregister</span>(sflt_handle handle)
{
	<span class="enscript-type">struct</span> socket_filter *filter;
	lck_rw_lock_exclusive(sock_filter_lock);

	<span class="enscript-comment">/* Find the entry by the handle */</span>
	TAILQ_FOREACH(filter, &amp;sock_filter_head, sf_global_next) {
		<span class="enscript-keyword">if</span> (filter-&gt;sf_filter.sf_handle == handle)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (filter) {
		<span class="enscript-comment">/* Remove it from the global list */</span>
		TAILQ_REMOVE(&amp;sock_filter_head, filter, sf_global_next);

		<span class="enscript-comment">/* Remove it from the protosw list */</span>
		<span class="enscript-keyword">if</span> ((filter-&gt;sf_filter.sf_flags &amp; SFLT_GLOBAL) != 0) {
			TAILQ_REMOVE(&amp;filter-&gt;sf_proto-&gt;pr_filter_head,
			    filter, sf_protosw_next);
		}

		<span class="enscript-comment">/* Detach from any sockets */</span>
		<span class="enscript-type">struct</span> socket_filter_entry *entry = NULL;

		<span class="enscript-keyword">for</span> (entry = filter-&gt;sf_entry_head; entry;
		    entry = entry-&gt;sfe_next_onfilter) {
			sflt_detach_locked(entry);
		}

		<span class="enscript-comment">/* Release the filter */</span>
		sflt_release_locked(filter);
	}

	lck_rw_unlock_exclusive(sock_filter_lock);

	<span class="enscript-keyword">if</span> (filter == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">sock_inject_data_in</span>(socket_t so, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *from, mbuf_t data,
    mbuf_t control, sflt_data_flag_t flags)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (so == NULL || data == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (flags &amp; sock_data_filt_flag_oob) {
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}

	socket_lock(so, 1);

	<span class="enscript-comment">/* reject if this is a subflow socket */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_MP_SUBFLOW) {
		error = ENOTSUP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (from) {
		<span class="enscript-keyword">if</span> (sbappendaddr(&amp;so-&gt;so_rcv,
		    (<span class="enscript-type">struct</span> sockaddr *)(uintptr_t)from, data, control, NULL))
			sorwakeup(so);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (control) {
		<span class="enscript-keyword">if</span> (sbappendcontrol(&amp;so-&gt;so_rcv, data, control, NULL))
			sorwakeup(so);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (flags &amp; sock_data_filt_flag_record) {
		<span class="enscript-keyword">if</span> (control || from) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-keyword">if</span> (sbappendrecord(&amp;so-&gt;so_rcv, (<span class="enscript-type">struct</span> mbuf *)data))
			sorwakeup(so);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (sbappend(&amp;so-&gt;so_rcv, data))
		sorwakeup(so);
<span class="enscript-reference">done</span>:
	socket_unlock(so, 1);
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">sock_inject_data_out</span>(socket_t so, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *to, mbuf_t data,
    mbuf_t control, sflt_data_flag_t flags)
{
	<span class="enscript-type">int</span> sosendflags = 0;

	<span class="enscript-comment">/* reject if this is a subflow socket */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_MP_SUBFLOW)
		<span class="enscript-keyword">return</span> (ENOTSUP);

	<span class="enscript-keyword">if</span> (flags &amp; sock_data_filt_flag_oob)
		sosendflags = MSG_OOB;
	<span class="enscript-keyword">return</span> (sosend(so, (<span class="enscript-type">struct</span> sockaddr *)(uintptr_t)to, NULL,
	    data, control, sosendflags));
}

sockopt_dir
<span class="enscript-function-name">sockopt_direction</span>(sockopt_t sopt)
{
	<span class="enscript-keyword">return</span> ((sopt-&gt;sopt_dir == SOPT_GET) ? sockopt_get : sockopt_set);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sockopt_level</span>(sockopt_t sopt)
{
	<span class="enscript-keyword">return</span> (sopt-&gt;sopt_level);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sockopt_name</span>(sockopt_t sopt)
{
	<span class="enscript-keyword">return</span> (sopt-&gt;sopt_name);
}

size_t
<span class="enscript-function-name">sockopt_valsize</span>(sockopt_t sopt)
{
	<span class="enscript-keyword">return</span> (sopt-&gt;sopt_valsize);
}

errno_t
<span class="enscript-function-name">sockopt_copyin</span>(sockopt_t sopt, <span class="enscript-type">void</span> *data, size_t len)
{
	<span class="enscript-keyword">return</span> (sooptcopyin(sopt, data, len, len));
}

errno_t
<span class="enscript-function-name">sockopt_copyout</span>(sockopt_t sopt, <span class="enscript-type">void</span> *data, size_t len)
{
	<span class="enscript-keyword">return</span> (sooptcopyout(sopt, data, len));
}
</pre>
<hr />
</body></html>