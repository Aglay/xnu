<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_prot.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_prot.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2008 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 *
 *
 * Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
 * 
 *
 * Copyright (c) 1982, 1986, 1989, 1990, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)kern_prot.c	8.9 (Berkeley) 2/14/95
 * 
 *
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 *
 *
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 *
 */</span>

<span class="enscript-comment">/*
 * System calls related to processes and protection
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/acct.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ucred.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/timeb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/times.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">chgproccnt_ok</span>(p) 1

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/message.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_security.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>		<span class="enscript-comment">/* for current_task() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>


<span class="enscript-comment">/*
 * Credential debugging; we can track entry into a function that might
 * change a credential, and we can track actual credential changes that
 * result.
 *
 * Note:	Does *NOT* currently include per-thread credential changes
 *
 *		We don't use kauth_cred_print() in current debugging, but it
 *		can be used if needed when debugging is active.
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_CRED</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DEBUG_CRED_ENTER</span>		printf
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DEBUG_CRED_CHANGE</span>		printf
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">kauth_cred_print</span>(kauth_cred_t cred);
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* !DEBUG_CRED */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DEBUG_CRED_ENTER</span>(fmt, ...)	do {} while (0)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DEBUG_CRED_CHANGE</span>(fmt, ...)	do {} while (0)
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !DEBUG_CRED */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">task_importance_update_owner_info</span>(task_t);
#<span class="enscript-reference">endif</span>


<span class="enscript-comment">/*
 * setprivexec
 *
 * Description:	(dis)allow this process to hold task, thread, or execption
 *		ports of processes about to exec.
 *
 * Parameters:	uap-&gt;flag			New value for flag
 *
 * Returns:	int				Previous value of flag
 *
 * XXX:		Belongs in kern_proc.c
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setprivexec</span>(proc_t p, <span class="enscript-type">struct</span> setprivexec_args *uap, int32_t *retval)
{
	AUDIT_ARG(value32, uap-&gt;flag);
	*retval = p-&gt;p_debugger;
	p-&gt;p_debugger = (uap-&gt;flag != 0);
	<span class="enscript-keyword">return</span>(0);
}


<span class="enscript-comment">/*
 * getpid
 *
 * Description:	get the process ID
 *
 * Parameters:	(void)
 *
 * Returns:	pid_t				Current process ID
 *
 * XXX:		Belongs in kern_proc.c
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getpid</span>(proc_t p, __unused <span class="enscript-type">struct</span> getpid_args *uap, int32_t *retval)
{

	*retval = p-&gt;p_pid;
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * getppid
 *
 * Description: get the parent process ID
 *
 * Parameters:	(void)
 *
 * Returns:	pid_t				Parent process ID
 *
 * XXX:		Belongs in kern_proc.c
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getppid</span>(proc_t p, __unused <span class="enscript-type">struct</span> getppid_args *uap, int32_t *retval)
{

	*retval = p-&gt;p_ppid;
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * getpgrp
 *
 * Description:	get the process group ID of the calling process
 *
 * Parameters:	(void)
 *
 * Returns:	pid_t				Process group ID
 *
 * XXX:		Belongs in kern_proc.c
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getpgrp</span>(proc_t p, __unused <span class="enscript-type">struct</span> getpgrp_args *uap, int32_t *retval)
{

	*retval = p-&gt;p_pgrpid;
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * getpgid
 *
 * Description: Get an arbitary pid's process group id
 *
 * Parameters:	uap-&gt;pid			The target pid
 *
 * Returns:	0				Success
 *		ESRCH				No such process
 *
 * Notes:	We are permitted to return EPERM in the case that the target
 *		process is not in the same session as the calling process,
 *		which could be a security consideration
 *
 * XXX:		Belongs in kern_proc.c
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getpgid</span>(proc_t p, <span class="enscript-type">struct</span> getpgid_args *uap, int32_t *retval)
{
	proc_t pt;
	<span class="enscript-type">int</span> refheld = 0;

	pt = p;
	<span class="enscript-keyword">if</span> (uap-&gt;pid == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;

	<span class="enscript-keyword">if</span> ((pt = proc_find(uap-&gt;pid)) == 0)
		<span class="enscript-keyword">return</span> (ESRCH);
	refheld = 1;
<span class="enscript-reference">found</span>:
	*retval = pt-&gt;p_pgrpid;
	<span class="enscript-keyword">if</span> (refheld != 0)
		proc_rele(pt);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * getsid
 *
 * Description:	Get an arbitary pid's session leaders process group ID
 *
 * Parameters:	uap-&gt;pid			The target pid
 *
 * Returns:	0				Success
 *		ESRCH				No such process
 *
 * Notes:	We are permitted to return EPERM in the case that the target
 *		process is not in the same session as the calling process,
 *		which could be a security consideration
 *
 * XXX:		Belongs in kern_proc.c
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getsid</span>(proc_t p, <span class="enscript-type">struct</span> getsid_args *uap, int32_t *retval)
{
	proc_t pt;
	<span class="enscript-type">int</span> refheld = 0;
	<span class="enscript-type">struct</span> session * sessp;

	pt = p;
	<span class="enscript-keyword">if</span> (uap-&gt;pid == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;

	<span class="enscript-keyword">if</span> ((pt = proc_find(uap-&gt;pid)) == 0)
		<span class="enscript-keyword">return</span> (ESRCH);
	refheld = 1;
<span class="enscript-reference">found</span>:
	sessp = proc_session(pt);
	*retval = sessp-&gt;s_sid;
	session_rele(sessp);

	<span class="enscript-keyword">if</span> (refheld != 0)
		proc_rele(pt);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * getuid
 *
 * Description:	get real user ID for caller
 *
 * Parameters:	(void)
 *
 * Returns:	uid_t				The real uid of the caller
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getuid</span>(__unused proc_t p, __unused <span class="enscript-type">struct</span> getuid_args *uap, int32_t *retval)
{

 	*retval = kauth_getruid();
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * geteuid
 *
 * Description:	get effective user ID for caller
 *
 * Parameters:	(void)
 *
 * Returns:	uid_t				The effective uid of the caller
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">geteuid</span>(__unused proc_t p, __unused <span class="enscript-type">struct</span> geteuid_args *uap, int32_t *retval)
{

 	*retval = kauth_getuid();
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * gettid
 *
 * Description:	Return the per-thread override identity.
 *
 * Parameters:	uap-&gt;uidp			Address of uid_t to get uid
 *		uap-&gt;gidp			Address of gid_t to get gid
 *
 * Returns:	0				Success
 *		ESRCH				No per thread identity active
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">gettid</span>(__unused proc_t p, <span class="enscript-type">struct</span> gettid_args *uap, int32_t *retval)
{
	<span class="enscript-type">struct</span> uthread *uthread = get_bsdthread_info(current_thread());
	<span class="enscript-type">int</span>	error;

	<span class="enscript-comment">/*
	 * If this thread is not running with an override identity, we can't
	 * return one to the caller, so return an error instead.
	 */</span>
	<span class="enscript-keyword">if</span> (!(uthread-&gt;uu_flag &amp; UT_SETUID))
		<span class="enscript-keyword">return</span> (ESRCH);

	<span class="enscript-keyword">if</span> ((error = suword(uap-&gt;uidp, kauth_cred_getruid(uthread-&gt;uu_ucred))))
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> ((error = suword(uap-&gt;gidp, kauth_cred_getrgid(uthread-&gt;uu_ucred))))
		<span class="enscript-keyword">return</span> (error);

	*retval = 0;
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * getgid
 *
 * Description:	get the real group ID for the calling process
 *
 * Parameters:	(void)
 *
 * Returns:	gid_t				The real gid of the caller
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getgid</span>(__unused proc_t p, __unused <span class="enscript-type">struct</span> getgid_args *uap, int32_t *retval)
{

	*retval = kauth_getrgid();
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * getegid
 *
 * Description:	get the effective group ID for the calling process
 *
 * Parameters:	(void)
 *
 * Returns:	gid_t				The effective gid of the caller
 *
 * Notes:	As an implementation detail, the effective gid is stored as
 *		the first element of the supplementary group list.
 *
 *		This could be implemented in Libc instead because of the above
 *		detail.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getegid</span>(__unused proc_t p, __unused <span class="enscript-type">struct</span> getegid_args *uap, int32_t *retval)
{

	*retval = kauth_getgid();
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * getgroups
 *
 * Description:	get the list of supplementary groups for the calling process
 *
 * Parameters:	uap-&gt;gidsetsize			# of gid_t's in user buffer
 *		uap-&gt;gidset			Pointer to user buffer
 *
 * Returns:	0				Success
 *		EINVAL				User buffer too small
 *	copyout:EFAULT				User buffer invalid
 *
 * Retval:	-1				Error
 *		!0				# of groups
 *
 * Notes:	The caller may specify a 0 value for gidsetsize, and we will
 *		then return how large a buffer is required (in gid_t's) to
 *		contain the answer at the time of the call.  Otherwise, we
 *		return the number of gid_t's catually copied to user space.
 *
 *		When called with a 0 gidsetsize from a multithreaded program,
 *		there is no guarantee that another thread may not change the
 *		number of supplementary groups, and therefore a subsequent
 *		call could still fail, unless the maximum possible buffer
 *		size is supplied by the user.
 *
 *		As an implementation detail, the effective gid is stored as
 *		the first element of the supplementary group list, and will
 *		be returned by this call.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getgroups</span>(__unused proc_t p, <span class="enscript-type">struct</span> getgroups_args *uap, int32_t *retval)
{
	<span class="enscript-type">int</span> ngrp;
	<span class="enscript-type">int</span> error;
	kauth_cred_t cred;
	posix_cred_t pcred;

	<span class="enscript-comment">/* grab reference while we muck around with the credential */</span>
	cred = kauth_cred_get_with_ref();
	pcred = posix_cred_get(cred);

	<span class="enscript-keyword">if</span> ((ngrp = uap-&gt;gidsetsize) == 0) {
		*retval = pcred-&gt;cr_ngroups;
		kauth_cred_unref(&amp;cred);
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">if</span> (ngrp &lt; pcred-&gt;cr_ngroups) {
		kauth_cred_unref(&amp;cred);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	ngrp = pcred-&gt;cr_ngroups;
	<span class="enscript-keyword">if</span> ((error = copyout((caddr_t)pcred-&gt;cr_groups,
	    				uap-&gt;gidset, 
	    				ngrp * <span class="enscript-keyword">sizeof</span>(gid_t)))) {
		kauth_cred_unref(&amp;cred);
		<span class="enscript-keyword">return</span> (error);
	}
	kauth_cred_unref(&amp;cred);
	*retval = ngrp;
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Return the per-thread/per-process supplementary groups list.
 *
 * XXX implement getsgroups
 *
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">getsgroups</span>(__unused proc_t p, __unused <span class="enscript-type">struct</span> getsgroups_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span>(ENOTSUP);
}

<span class="enscript-comment">/*
 * Return the per-thread/per-process whiteout groups list.
 * 
 * XXX implement getwgroups
 *
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">getwgroups</span>(__unused proc_t p, __unused <span class="enscript-type">struct</span> getwgroups_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span>(ENOTSUP);
}


<span class="enscript-comment">/*
 * setsid
 *
 * Description:	Create a new session and set the process group ID to the
 *		session ID
 *
 * Parameters:	(void)
 *
 * Returns:	0				Success
 *		EPERM				Permission denied
 *
 * Notes:	If the calling process is not the process group leader; there
 *		is no existing process group with its ID, and we are not
 *		currently in vfork, then this function will create a new
 *		session, a new process group, and put the caller in the
 *		process group (as the sole member) and make it the session
 *		leader (as the sole process in the session).
 *
 *		The existing controlling tty (if any) will be dissociated
 *		from the process, and the next non-O_NOCTTY open of a tty
 *		will establish a new controlling tty.
 *
 * XXX:		Belongs in kern_proc.c
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setsid</span>(proc_t p, __unused <span class="enscript-type">struct</span> setsid_args *uap, int32_t *retval)
{
	<span class="enscript-type">struct</span> pgrp * pg = PGRP_NULL;

	<span class="enscript-keyword">if</span> (p-&gt;p_pgrpid == p-&gt;p_pid || (pg = pgfind(p-&gt;p_pid)) || p-&gt;p_lflag &amp; P_LINVFORK) {
		<span class="enscript-keyword">if</span> (pg != PGRP_NULL)
			pg_rele(pg);
		<span class="enscript-keyword">return</span> (EPERM);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* enter pgrp works with its own pgrp refcount */</span>
		(<span class="enscript-type">void</span>)enterpgrp(p, p-&gt;p_pid, 1);
		*retval = p-&gt;p_pid;
		<span class="enscript-keyword">return</span> (0);
	}
}


<span class="enscript-comment">/*
 * setpgid
 *
 * Description: set process group ID for job control
 *
 * Parameters:	uap-&gt;pid			Process to change
 *		uap-&gt;pgid			Process group to join or create
 *
 * Returns:	0			Success
 *		ESRCH			pid is not the caller or a child of
 *					the caller
 *	enterpgrp:ESRCH			No such process
 *		EACCES			Permission denied due to exec
 *		EINVAL			Invalid argument
 *		EPERM			The target process is not in the same
 *					session as the calling process
 *		EPERM			The target process is a session leader
 *		EPERM			pid and pgid are not the same, and
 *					there is no process in the calling
 *					process whose process group ID matches
 *					pgid
 *
 * Notes:	This function will cause the target process to either join
 *		an existing process process group, or create a new process
 *		group in the session of the calling process.  It cannot be
 *		used to change the process group ID of a process which is
 *		already a session leader.
 *
 *		If the target pid is 0, the pid of the calling process is
 *		substituted as the new target; if pgid is 0, the target pid
 *		is used as the target process group ID.
 *
 * Legacy:	This system call entry point is also used to implement the
 *		legacy library routine setpgrp(), which under POSIX 
 *
 * XXX:		Belongs in kern_proc.c
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setpgid</span>(proc_t curp, <span class="enscript-type">register</span> <span class="enscript-type">struct</span> setpgid_args *uap, __unused int32_t *retval)
{
	proc_t targp = PROC_NULL;	<span class="enscript-comment">/* target process */</span>
	<span class="enscript-type">struct</span> pgrp *pg = PGRP_NULL;	<span class="enscript-comment">/* target pgrp */</span>
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> refheld = 0;
	<span class="enscript-type">int</span> samesess = 0;
	<span class="enscript-type">struct</span> session * curp_sessp = SESSION_NULL;
	<span class="enscript-type">struct</span> session * targp_sessp = SESSION_NULL;

	curp_sessp = proc_session(curp);

	<span class="enscript-keyword">if</span> (uap-&gt;pid != 0 &amp;&amp; uap-&gt;pid != curp-&gt;p_pid) {
		<span class="enscript-keyword">if</span> ((targp = proc_find(uap-&gt;pid)) == 0 || !inferior(targp)) {
			<span class="enscript-keyword">if</span> (targp != PROC_NULL)
				refheld = 1;
			error = ESRCH;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		refheld = 1;
		targp_sessp = proc_session(targp);
		<span class="enscript-keyword">if</span> (targp_sessp != curp_sessp) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (targp-&gt;p_flag &amp; P_EXEC) {
			error = EACCES;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	} <span class="enscript-keyword">else</span> {
		targp = curp;
		targp_sessp = proc_session(targp);
	}

	<span class="enscript-keyword">if</span> (SESS_LEADER(targp, targp_sessp)) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (targp_sessp != SESSION_NULL) {
		session_rele(targp_sessp);
		targp_sessp = SESSION_NULL;
	}

	<span class="enscript-keyword">if</span> (uap-&gt;pgid &lt; 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (uap-&gt;pgid == 0)
		uap-&gt;pgid = targp-&gt;p_pid;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uap-&gt;pgid != targp-&gt;p_pid) {
		<span class="enscript-keyword">if</span> ((pg = pgfind(uap-&gt;pgid)) == 0){
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		samesess = (pg-&gt;pg_session != curp_sessp); 
		pg_rele(pg);
		<span class="enscript-keyword">if</span> (samesess != 0) {
			error = EPERM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
	error = enterpgrp(targp, uap-&gt;pgid, 0);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (targp_sessp != SESSION_NULL)
		session_rele(targp_sessp);
	<span class="enscript-keyword">if</span> (curp_sessp != SESSION_NULL)
		session_rele(curp_sessp);
	<span class="enscript-keyword">if</span> (refheld != 0)
		proc_rele(targp);
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * issetugid
 *
 * Description:	Is current process tainted by uid or gid changes system call
 *
 * Parameters:	(void)
 *
 * Returns:	0				Not tainted
 *		1				Tainted
 *
 * Notes:	A process is considered tainted if it was created as a retult
 *		of an execve call from an imnage that had either the SUID or
 *		SGID bit set on the executable, or if it has changed any of its
 *		real, effective, or saved user or group IDs since beginning
 *		execution.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">issetugid</span>(proc_t p, __unused <span class="enscript-type">struct</span> issetugid_args *uap, int32_t *retval)
{
	<span class="enscript-comment">/*
	 * Note: OpenBSD sets a P_SUGIDEXEC flag set at execve() time,
	 * we use P_SUGID because we consider changing the owners as
	 * &quot;tainting&quot; as well.
	 * This is significant for procs that start as root and &quot;become&quot;
	 * a user without an exec - programs cannot know *everything*
	 * that libc *might* have put in their data segment.
	 */</span>

	*retval = (p-&gt;p_flag &amp; P_SUGID) ? 1 : 0;
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * setuid
 *
 * Description:	Set user ID system call
 *
 * Parameters:	uap-&gt;uid			uid to set
 *
 * Returns:	0				Success
 *	suser:EPERM				Permission denied
 *
 * Notes:	If called by a privileged process, this function will set the
 *		real, effective, and saved uid to the requested value.
 *
 *		If called from an unprivileged process, but uid is equal to the
 *		real or saved uid, then the effective uid will be set to the
 *		requested value, but the real and saved uid will not change.
 *
 *		If the credential is changed as a result of this call, then we
 *		flag the process as having set privilege since the last exec.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setuid</span>(proc_t p, <span class="enscript-type">struct</span> setuid_args *uap, __unused int32_t *retval)
{
	uid_t uid;
	uid_t svuid = KAUTH_UID_NONE;
	uid_t ruid = KAUTH_UID_NONE;
	uid_t gmuid = KAUTH_UID_NONE;
	<span class="enscript-type">int</span> error;
	kauth_cred_t my_cred, my_new_cred;
	posix_cred_t my_pcred;

	uid = uap-&gt;uid;

	<span class="enscript-comment">/* get current credential and take a reference while we muck with it */</span>
	my_cred = kauth_cred_proc_ref(p);
	my_pcred = posix_cred_get(my_cred);

	DEBUG_CRED_ENTER(<span class="enscript-string">&quot;setuid (%d/%d): %p %d\n&quot;</span>, p-&gt;p_pid, (p-&gt;p_pptr ? p-&gt;p_pptr-&gt;p_pid : 0), my_cred, uap-&gt;uid);
	AUDIT_ARG(uid, uid);

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> (uid != my_pcred-&gt;cr_ruid &amp;&amp;		<span class="enscript-comment">/* allow setuid(getuid()) */</span>
		    uid != my_pcred-&gt;cr_svuid &amp;&amp;	<span class="enscript-comment">/* allow setuid(saved uid) */</span>
		    (error = suser(my_cred, &amp;p-&gt;p_acflag))) {
			kauth_cred_unref(&amp;my_cred);
			<span class="enscript-keyword">return</span> (error);
		}

		<span class="enscript-comment">/*
		 * If we are privileged, then set the saved and real UID too;
		 * otherwise, just set the effective UID
		 */</span>
		<span class="enscript-keyword">if</span> (suser(my_cred, &amp;p-&gt;p_acflag) == 0) {
			svuid = uid;
			ruid = uid;
		} <span class="enscript-keyword">else</span> {
			svuid = KAUTH_UID_NONE;
			ruid = KAUTH_UID_NONE;
		}
		<span class="enscript-comment">/*
		 * Only set the gmuid if the current cred has not opt'ed out;
		 * this normally only happens when calling setgroups() instead
		 * of initgroups() to set an explicit group list, or one of the
		 * other group manipulation functions is invoked and results in
		 * a dislocation (i.e. the credential group membership changes
		 * to something other than the default list for the user, as
		 * in entering a group or leaving an exclusion group).
		 */</span>
		<span class="enscript-keyword">if</span> (!(my_pcred-&gt;cr_flags &amp; CRF_NOMEMBERD))
			gmuid = uid;

  		<span class="enscript-comment">/* 
		 * Set the credential with new info.  If there is no change,
		 * we get back the same credential we passed in; if there is
		 * a change, we drop the reference on the credential we
		 * passed in.  The subsequent compare is safe, because it is
		 * a pointer compare rather than a contents compare.
  		 */</span>
		my_new_cred = kauth_cred_setresuid(my_cred, ruid, uid, svuid, gmuid);
		<span class="enscript-keyword">if</span> (my_cred != my_new_cred) {

			DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;setuid CH(%d): %p/0x%08x -&gt; %p/0x%08x\n&quot;</span>, p-&gt;p_pid, my_cred, my_pcred-&gt;cr_flags, my_new_cred, posix_cred_get(my_new_cred)-&gt;cr_flags);

			<span class="enscript-comment">/*
			 * If we're changing the ruid from A to B, we might race with another thread that's setting ruid from B to A.
			 * The current locking mechanisms don't allow us to make the entire credential switch operation atomic,
			 * thus we may be able to change the process credentials from ruid A to B, but get preempted before incrementing the proc
			 * count of B. If a second thread sees the new process credentials and switches back to ruid A, that other thread
			 * may be able to decrement the proc count of B before we can increment it. This results in a panic.
			 * Incrementing the proc count of the target ruid, B, before setting the process credentials prevents this race.
			 */</span>
			<span class="enscript-keyword">if</span> (ruid != KAUTH_UID_NONE &amp;&amp; chgproccnt_ok(p)) {
				(<span class="enscript-type">void</span>)chgproccnt(ruid, 1);
			}

			proc_lock(p);
			<span class="enscript-comment">/*
			 * We need to protect for a race where another thread
			 * also changed the credential after we took our
			 * reference.  If p_ucred has changed then we should
			 * restart this again with the new cred.
			 *
			 * Note: the kauth_cred_setresuid has consumed a reference to my_cred, it p_ucred != my_cred, then my_cred must not be dereferenced!
			 */</span>
			<span class="enscript-keyword">if</span> (p-&gt;p_ucred != my_cred) {
				proc_unlock(p);
				<span class="enscript-comment">/*
				 * We didn't successfully switch to the new ruid, so decrement
				 * the procs/uid count that we incremented above.
				 */</span>
				<span class="enscript-keyword">if</span> (ruid != KAUTH_UID_NONE &amp;&amp; chgproccnt_ok(p)) {
					(<span class="enscript-type">void</span>)chgproccnt(ruid, -1);
				}
				kauth_cred_unref(&amp;my_new_cred);
				my_cred = kauth_cred_proc_ref(p);
				my_pcred = posix_cred_get(my_cred);
				<span class="enscript-comment">/* try again */</span>
				<span class="enscript-keyword">continue</span>;
			}
			p-&gt;p_ucred = my_new_cred;
			<span class="enscript-comment">/* update cred on proc */</span>
			PROC_UPDATE_CREDS_ONPROC(p);

			OSBitOrAtomic(P_SUGID, &amp;p-&gt;p_flag);
			proc_unlock(p);
			<span class="enscript-comment">/*
			 * If we've updated the ruid, decrement the count of procs running
			 * under the previous ruid
			 */</span>
			<span class="enscript-keyword">if</span> (ruid != KAUTH_UID_NONE &amp;&amp; chgproccnt_ok(p)) {
				(<span class="enscript-type">void</span>)chgproccnt(my_pcred-&gt;cr_ruid, -1);
			}
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-comment">/* Drop old proc reference or our extra reference */</span>
	kauth_cred_unref(&amp;my_cred);
	
	set_security_token(p);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * seteuid
 *
 * Description:	Set effective user ID system call
 *
 * Parameters:	uap-&gt;euid			effective uid to set
 *
 * Returns:	0				Success
 *	suser:EPERM				Permission denied
 *
 * Notes:	If called by a privileged process, or called from an
 *		unprivileged process but euid is equal to the real or saved
 *		uid, then the effective uid will be set to the requested
 *		value, but the real and saved uid will not change.
 *
 *		If the credential is changed as a result of this call, then we
 *		flag the process as having set privilege since the last exec.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">seteuid</span>(proc_t p, <span class="enscript-type">struct</span> seteuid_args *uap, __unused int32_t *retval)
{
	uid_t euid;
	<span class="enscript-type">int</span> error;
	kauth_cred_t my_cred, my_new_cred;
	posix_cred_t my_pcred;

	DEBUG_CRED_ENTER(<span class="enscript-string">&quot;seteuid: %d\n&quot;</span>, uap-&gt;euid);

	euid = uap-&gt;euid;
	AUDIT_ARG(euid, euid);

	my_cred = kauth_cred_proc_ref(p);
	my_pcred = posix_cred_get(my_cred);

	<span class="enscript-keyword">for</span> (;;) {

		<span class="enscript-keyword">if</span> (euid != my_pcred-&gt;cr_ruid &amp;&amp; euid != my_pcred-&gt;cr_svuid &amp;&amp;
			(error = suser(my_cred, &amp;p-&gt;p_acflag))) {
			kauth_cred_unref(&amp;my_cred);
			<span class="enscript-keyword">return</span> (error);
		}

  		<span class="enscript-comment">/* 
		 * Set the credential with new info.  If there is no change,
		 * we get back the same credential we passed in; if there is
		 * a change, we drop the reference on the credential we
		 * passed in.  The subsequent compare is safe, because it is
		 * a pointer compare rather than a contents compare.
  		 */</span>
		my_new_cred = kauth_cred_setresuid(my_cred, KAUTH_UID_NONE, euid, KAUTH_UID_NONE, my_pcred-&gt;cr_gmuid);
	
		<span class="enscript-keyword">if</span> (my_cred != my_new_cred) {

			DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;seteuid CH(%d): %p/0x%08x -&gt; %p/0x%08x\n&quot;</span>, p-&gt;p_pid, my_cred, my_pcred-&gt;cr_flags, my_new_cred, posix_cred_get(my_new_cred)-&gt;cr_flags);

			proc_lock(p);
			<span class="enscript-comment">/*
			 * We need to protect for a race where another thread
			 * also changed the credential after we took our
			 * reference.  If p_ucred has changed then we
			 * should restart this again with the new cred.
			 */</span>
			<span class="enscript-keyword">if</span> (p-&gt;p_ucred != my_cred) {
				proc_unlock(p);
				kauth_cred_unref(&amp;my_new_cred);
				my_cred = kauth_cred_proc_ref(p);
				my_pcred = posix_cred_get(my_cred);
				<span class="enscript-comment">/* try again */</span>
				<span class="enscript-keyword">continue</span>;
			}
			p-&gt;p_ucred = my_new_cred;
			<span class="enscript-comment">/* update cred on proc */</span>
			PROC_UPDATE_CREDS_ONPROC(p);
			OSBitOrAtomic(P_SUGID, &amp;p-&gt;p_flag);
			proc_unlock(p);
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-comment">/* drop old proc reference or our extra reference */</span>
	kauth_cred_unref(&amp;my_cred);

	set_security_token(p);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * setreuid
 *
 * Description:	Set real and effective user ID system call
 *
 * Parameters:	uap-&gt;ruid			real uid to set
 *		uap-&gt;euid			effective uid to set
 *
 * Returns:	0				Success
 *	suser:EPERM				Permission denied
 *
 * Notes:	A value of -1 is a special case indicating that the uid for
 *		which that value is specified not be changed.  If both values
 *		are specified as -1, no action is taken.
 *
 *		If called by a privileged process, the real and effective uid
 *		will be set to the new value(s) specified.
 *
 *		If called from an unprivileged process, the real uid may be
 *		set to the current value of the real uid, or to the current
 *		value of the saved uid.  The effective uid may be set to the
 *		current value of any of the effective, real, or saved uid.
 *
 *		If the newly requested real uid or effective uid does not
 *		match the saved uid, then set the saved uid to the new
 *		effective uid (potentially unrecoverably dropping saved
 *		privilege).
 *
 *		If the credential is changed as a result of this call, then we
 *		flag the process as having set privilege since the last exec.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setreuid</span>(proc_t p, <span class="enscript-type">struct</span> setreuid_args *uap, __unused int32_t *retval)
{
	uid_t ruid, euid;
	<span class="enscript-type">int</span> error;
	kauth_cred_t my_cred, my_new_cred;
	posix_cred_t my_pcred;

	DEBUG_CRED_ENTER(<span class="enscript-string">&quot;setreuid %d %d\n&quot;</span>, uap-&gt;ruid, uap-&gt;euid);

	ruid = uap-&gt;ruid;
	euid = uap-&gt;euid;
	<span class="enscript-keyword">if</span> (ruid == (uid_t)-1)
		ruid = KAUTH_UID_NONE;
	<span class="enscript-keyword">if</span> (euid == (uid_t)-1)
		euid = KAUTH_UID_NONE;
	AUDIT_ARG(euid, euid);
	AUDIT_ARG(ruid, ruid);

	my_cred = kauth_cred_proc_ref(p);
	my_pcred = posix_cred_get(my_cred);

	<span class="enscript-keyword">for</span> (;;) {

		<span class="enscript-keyword">if</span> (((ruid != KAUTH_UID_NONE &amp;&amp;		<span class="enscript-comment">/* allow no change of ruid */</span>
		      ruid != my_pcred-&gt;cr_ruid &amp;&amp;	<span class="enscript-comment">/* allow ruid = ruid */</span>
		      ruid != my_pcred-&gt;cr_uid &amp;&amp;	<span class="enscript-comment">/* allow ruid = euid */</span>
		      ruid != my_pcred-&gt;cr_svuid) ||	<span class="enscript-comment">/* allow ruid = svuid */</span>
		     (euid != KAUTH_UID_NONE &amp;&amp;		<span class="enscript-comment">/* allow no change of euid */</span>
		      euid != my_pcred-&gt;cr_uid &amp;&amp;	<span class="enscript-comment">/* allow euid = euid */</span>
		      euid != my_pcred-&gt;cr_ruid &amp;&amp;	<span class="enscript-comment">/* allow euid = ruid */</span>
		      euid != my_pcred-&gt;cr_svuid)) &amp;&amp;	<span class="enscript-comment">/* allow euid = svuid */</span>
		    (error = suser(my_cred, &amp;p-&gt;p_acflag))) { <span class="enscript-comment">/* allow root user any */</span>
			kauth_cred_unref(&amp;my_cred);
			<span class="enscript-keyword">return</span> (error);
		}

		uid_t new_euid;
		uid_t svuid = KAUTH_UID_NONE;

		new_euid = my_pcred-&gt;cr_uid;
  		<span class="enscript-comment">/* 
		 * Set the credential with new info.  If there is no change,
		 * we get back the same credential we passed in; if there is
		 * a change, we drop the reference on the credential we
		 * passed in.  The subsequent compare is safe, because it is
		 * a pointer compare rather than a contents compare.
  		 */</span>
		<span class="enscript-keyword">if</span> (euid != KAUTH_UID_NONE &amp;&amp; my_pcred-&gt;cr_uid != euid) {
			<span class="enscript-comment">/* changing the effective UID */</span>
			new_euid = euid;
			OSBitOrAtomic(P_SUGID, &amp;p-&gt;p_flag);
		}
		<span class="enscript-comment">/*
		 * If the newly requested real uid or effective uid does
		 * not match the saved uid, then set the saved uid to the
		 * new effective uid.  We are protected from escalation
		 * by the prechecking.
		 */</span>
		<span class="enscript-keyword">if</span> (my_pcred-&gt;cr_svuid != uap-&gt;ruid &amp;&amp;
		    my_pcred-&gt;cr_svuid != uap-&gt;euid) {
		    	svuid = new_euid;
			OSBitOrAtomic(P_SUGID, &amp;p-&gt;p_flag);
		}

		my_new_cred = kauth_cred_setresuid(my_cred, ruid, euid, svuid, my_pcred-&gt;cr_gmuid);
	
		<span class="enscript-keyword">if</span> (my_cred != my_new_cred) {

			DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;setreuid CH(%d): %p/0x%08x -&gt; %p/0x%08x\n&quot;</span>, p-&gt;p_pid, my_cred, my_pcred-&gt;cr_flags, my_new_cred, posix_cred_get(my_new_cred)-&gt;cr_flags);

			<span class="enscript-comment">/*
			 * If we're changing the ruid from A to B, we might race with another thread that's setting ruid from B to A.
			 * The current locking mechanisms don't allow us to make the entire credential switch operation atomic,
			 * thus we may be able to change the process credentials from ruid A to B, but get preempted before incrementing the proc
			 * count of B. If a second thread sees the new process credentials and switches back to ruid A, that other thread
			 * may be able to decrement the proc count of B before we can increment it. This results in a panic.
			 * Incrementing the proc count of the target ruid, B, before setting the process credentials prevents this race.
			 */</span>
			<span class="enscript-keyword">if</span> (ruid != KAUTH_UID_NONE &amp;&amp; chgproccnt_ok(p)) {
				(<span class="enscript-type">void</span>)chgproccnt(ruid, 1);
			}

			proc_lock(p);
			<span class="enscript-comment">/*
			 * We need to protect for a race where another thread
			 * also changed the credential after we took our
			 * reference.  If p_ucred has changed then we should
			 * restart this again with the new cred.
			 *
			 * Note: the kauth_cred_setresuid has consumed a reference to my_cred, it p_ucred != my_cred, then my_cred must not be dereferenced!
			 */</span>
			<span class="enscript-keyword">if</span> (p-&gt;p_ucred != my_cred) {
				proc_unlock(p);
				<span class="enscript-keyword">if</span> (ruid != KAUTH_UID_NONE &amp;&amp; chgproccnt_ok(p)) {
					<span class="enscript-comment">/*
					 * We didn't successfully switch to the new ruid, so decrement
					 * the procs/uid count that we incremented above.
					 */</span>
					(<span class="enscript-type">void</span>)chgproccnt(ruid, -1);
				}
				kauth_cred_unref(&amp;my_new_cred);
				my_cred = kauth_cred_proc_ref(p);
				my_pcred = posix_cred_get(my_cred);
				<span class="enscript-comment">/* try again */</span>
				<span class="enscript-keyword">continue</span>;
			}

			p-&gt;p_ucred = my_new_cred;
			<span class="enscript-comment">/* update cred on proc */</span>
			PROC_UPDATE_CREDS_ONPROC(p);
			OSBitOrAtomic(P_SUGID, &amp;p-&gt;p_flag);
			proc_unlock(p);

			<span class="enscript-keyword">if</span> (ruid != KAUTH_UID_NONE &amp;&amp; chgproccnt_ok(p)) {
				<span class="enscript-comment">/*
				 * We switched to a new ruid, so decrement the count of procs running
				 * under the previous ruid
				 */</span>
				(<span class="enscript-type">void</span>)chgproccnt(my_pcred-&gt;cr_ruid, -1);
			}
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-comment">/* drop old proc reference or our extra reference */</span>
	kauth_cred_unref(&amp;my_cred);

	set_security_token(p);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * setgid
 *
 * Description:	Set group ID system call
 *
 * Parameters:	uap-&gt;gid			gid to set
 *
 * Returns:	0				Success
 *	suser:EPERM				Permission denied
 *
 * Notes:	If called by a privileged process, this function will set the
 *		real, effective, and saved gid to the requested value.
 *
 *		If called from an unprivileged process, but gid is equal to the
 *		real or saved gid, then the effective gid will be set to the
 *		requested value, but the real and saved gid will not change.
 *
 *		If the credential is changed as a result of this call, then we
 *		flag the process as having set privilege since the last exec.
 *
 *		As an implementation detail, the effective gid is stored as
 *		the first element of the supplementary group list, and
 *		therefore the effective group list may be reordered to keep
 *		the supplementary group list unchanged.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setgid</span>(proc_t p, <span class="enscript-type">struct</span> setgid_args *uap, __unused int32_t *retval)
{
	gid_t gid;
	gid_t rgid = KAUTH_GID_NONE;
	gid_t svgid = KAUTH_GID_NONE;
	<span class="enscript-type">int</span> error;
	kauth_cred_t my_cred, my_new_cred;
	posix_cred_t my_pcred;

	DEBUG_CRED_ENTER(<span class="enscript-string">&quot;setgid(%d/%d): %d\n&quot;</span>, p-&gt;p_pid, (p-&gt;p_pptr ? p-&gt;p_pptr-&gt;p_pid : 0), uap-&gt;gid);

	gid = uap-&gt;gid;
	AUDIT_ARG(gid, gid);

	<span class="enscript-comment">/* get current credential and take a reference while we muck with it */</span>
	my_cred = kauth_cred_proc_ref(p);
	my_pcred = posix_cred_get(my_cred);

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> (gid != my_pcred-&gt;cr_rgid &amp;&amp;		<span class="enscript-comment">/* allow setgid(getgid()) */</span>
		    gid != my_pcred-&gt;cr_svgid &amp;&amp;	<span class="enscript-comment">/* allow setgid(saved gid) */</span>
		    (error = suser(my_cred, &amp;p-&gt;p_acflag))) {
			kauth_cred_unref(&amp;my_cred);
			<span class="enscript-keyword">return</span> (error);
		}

		<span class="enscript-comment">/*
		 * If we are privileged, then set the saved and real GID too;
		 * otherwise, just set the effective GID
		 */</span>
		<span class="enscript-keyword">if</span> (suser(my_cred,  &amp;p-&gt;p_acflag) == 0) {
			svgid = gid;
			rgid = gid;
		} <span class="enscript-keyword">else</span> {
			svgid = KAUTH_GID_NONE;
			rgid = KAUTH_GID_NONE;
		}

  		<span class="enscript-comment">/* 
		 * Set the credential with new info.  If there is no change,
		 * we get back the same credential we passed in; if there is
		 * a change, we drop the reference on the credential we
		 * passed in.  The subsequent compare is safe, because it is
		 * a pointer compare rather than a contents compare.
  		 */</span>
		my_new_cred = kauth_cred_setresgid(my_cred, rgid, gid, svgid);
		<span class="enscript-keyword">if</span> (my_cred != my_new_cred) {

			DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;setgid(CH)%d: %p/0x%08x-&gt;%p/0x%08x\n&quot;</span>, p-&gt;p_pid, my_cred, my_cred-&gt;cr_flags, my_new_cred, my_new_cred-&gt;cr_flags);

			proc_lock(p);
			<span class="enscript-comment">/*
			 * We need to protect for a race where another thread
			 * also changed the credential after we took our
			 * reference.  If p_ucred has changed then we
			 * should restart this again with the new cred.
			 */</span>
			<span class="enscript-keyword">if</span> (p-&gt;p_ucred != my_cred) {
				proc_unlock(p);
				kauth_cred_unref(&amp;my_new_cred);
				<span class="enscript-comment">/* try again */</span>
				my_cred = kauth_cred_proc_ref(p);
				my_pcred = posix_cred_get(my_cred);
				<span class="enscript-keyword">continue</span>;
			}
			p-&gt;p_ucred = my_new_cred;
			<span class="enscript-comment">/* update cred on proc */</span>
			PROC_UPDATE_CREDS_ONPROC(p);
			OSBitOrAtomic(P_SUGID, &amp;p-&gt;p_flag);
			proc_unlock(p);
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-comment">/* Drop old proc reference or our extra reference */</span>
	kauth_cred_unref(&amp;my_cred);
	
	set_security_token(p);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * setegid
 *
 * Description:	Set effective group ID system call
 *
 * Parameters:	uap-&gt;egid			effective gid to set
 *
 * Returns:	0				Success
 *	suser:EPERM
 *
 * Notes:	If called by a privileged process, or called from an
 *		unprivileged process but egid is equal to the real or saved
 *		gid, then the effective gid will be set to the requested
 *		value, but the real and saved gid will not change.
 *
 *		If the credential is changed as a result of this call, then we
 *		flag the process as having set privilege since the last exec.
 *
 *		As an implementation detail, the effective gid is stored as
 *		the first element of the supplementary group list, and
 *		therefore the effective group list may be reordered to keep
 *		the supplementary group list unchanged.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setegid</span>(proc_t p, <span class="enscript-type">struct</span> setegid_args *uap, __unused int32_t *retval)
{
	gid_t egid;
	<span class="enscript-type">int</span> error;
	kauth_cred_t my_cred, my_new_cred;
	posix_cred_t my_pcred;

	DEBUG_CRED_ENTER(<span class="enscript-string">&quot;setegid %d\n&quot;</span>, uap-&gt;egid);

	egid = uap-&gt;egid;
	AUDIT_ARG(egid, egid);

	<span class="enscript-comment">/* get current credential and take a reference while we muck with it */</span>
	my_cred = kauth_cred_proc_ref(p);
	my_pcred = posix_cred_get(my_cred);


	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> (egid != my_pcred-&gt;cr_rgid &amp;&amp;
		    egid != my_pcred-&gt;cr_svgid &amp;&amp;
		    (error = suser(my_cred, &amp;p-&gt;p_acflag))) {
			kauth_cred_unref(&amp;my_cred);
			<span class="enscript-keyword">return</span> (error);
		}
  		<span class="enscript-comment">/* 
		 * Set the credential with new info.  If there is no change,
		 * we get back the same credential we passed in; if there is
		 * a change, we drop the reference on the credential we
		 * passed in.  The subsequent compare is safe, because it is
		 * a pointer compare rather than a contents compare.
  		 */</span>
		my_new_cred = kauth_cred_setresgid(my_cred, KAUTH_GID_NONE, egid, KAUTH_GID_NONE);
		<span class="enscript-keyword">if</span> (my_cred != my_new_cred) {

			DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;setegid(CH)%d: %p/0x%08x-&gt;%p/0x%08x\n&quot;</span>, p-&gt;p_pid, my_cred, my_pcred-&gt;cr_flags, my_new_cred, posix_cred_get(my_new_cred)-&gt;cr_flags);

			proc_lock(p);
			<span class="enscript-comment">/*
			 * We need to protect for a race where another thread
			 * also changed the credential after we took our
			 * reference.  If p_ucred has changed then we
			 * should restart this again with the new cred.
			 */</span>
			<span class="enscript-keyword">if</span> (p-&gt;p_ucred != my_cred) {
				proc_unlock(p);
				kauth_cred_unref(&amp;my_new_cred);
				<span class="enscript-comment">/* try again */</span>
				my_cred = kauth_cred_proc_ref(p);
				my_pcred = posix_cred_get(my_cred);
				<span class="enscript-keyword">continue</span>;
			}
			p-&gt;p_ucred = my_new_cred;
			<span class="enscript-comment">/* update cred on proc */</span>
			PROC_UPDATE_CREDS_ONPROC(p);
			OSBitOrAtomic(P_SUGID, &amp;p-&gt;p_flag);
			proc_unlock(p);
		}
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* Drop old proc reference or our extra reference */</span>
	kauth_cred_unref(&amp;my_cred);

	set_security_token(p);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * setregid
 *
 * Description:	Set real and effective group ID system call
 *
 * Parameters:	uap-&gt;rgid			real gid to set
 *		uap-&gt;egid			effective gid to set
 *
 * Returns:	0				Success
 *	suser:EPERM				Permission denied
 *
 * Notes:	A value of -1 is a special case indicating that the gid for
 *		which that value is specified not be changed.  If both values
 *		are specified as -1, no action is taken.
 *
 *		If called by a privileged process, the real and effective gid
 *		will be set to the new value(s) specified.
 *
 *		If called from an unprivileged process, the real gid may be
 *		set to the current value of the real gid, or to the current
 *		value of the saved gid.  The effective gid may be set to the
 *		current value of any of the effective, real, or saved gid.
 *
 *		If the new real and effective gid will not be equal, or the
 *		new real or effective gid is not the same as the saved gid,
 *		then the saved gid will be updated to reflect the new
 *		effective gid (potentially unrecoverably dropping saved
 *		privilege).
 *
 *		If the credential is changed as a result of this call, then we
 *		flag the process as having set privilege since the last exec.
 *
 *		As an implementation detail, the effective gid is stored as
 *		the first element of the supplementary group list, and
 *		therefore the effective group list may be reordered to keep
 *		the supplementary group list unchanged.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setregid</span>(proc_t p, <span class="enscript-type">struct</span> setregid_args *uap, __unused int32_t *retval)
{
	gid_t rgid, egid;
	<span class="enscript-type">int</span> error;
	kauth_cred_t my_cred, my_new_cred;
	posix_cred_t my_pcred;

	DEBUG_CRED_ENTER(<span class="enscript-string">&quot;setregid %d %d\n&quot;</span>, uap-&gt;rgid, uap-&gt;egid);

	rgid = uap-&gt;rgid;
	egid = uap-&gt;egid;

	<span class="enscript-keyword">if</span> (rgid == (uid_t)-1)
		rgid = KAUTH_GID_NONE;
	<span class="enscript-keyword">if</span> (egid == (uid_t)-1)
		egid = KAUTH_GID_NONE;
	AUDIT_ARG(egid, egid);
	AUDIT_ARG(rgid, rgid);

	<span class="enscript-comment">/* get current credential and take a reference while we muck with it */</span>
	my_cred = kauth_cred_proc_ref(p);
	my_pcred = posix_cred_get(my_cred);

	<span class="enscript-keyword">for</span> (;;) {

		<span class="enscript-keyword">if</span> (((rgid != KAUTH_UID_NONE &amp;&amp;		<span class="enscript-comment">/* allow no change of rgid */</span>
		      rgid != my_pcred-&gt;cr_rgid &amp;&amp;	<span class="enscript-comment">/* allow rgid = rgid */</span>
		      rgid != my_pcred-&gt;cr_gid &amp;&amp;	<span class="enscript-comment">/* allow rgid = egid */</span>
		      rgid != my_pcred-&gt;cr_svgid) ||	<span class="enscript-comment">/* allow rgid = svgid */</span>
		     (egid != KAUTH_UID_NONE &amp;&amp;		<span class="enscript-comment">/* allow no change of egid */</span>
		      egid != my_pcred-&gt;cr_groups[0] &amp;&amp;	<span class="enscript-comment">/* allow no change of egid */</span>
		      egid != my_pcred-&gt;cr_gid &amp;&amp;	<span class="enscript-comment">/* allow egid = egid */</span>
		      egid != my_pcred-&gt;cr_rgid &amp;&amp;	<span class="enscript-comment">/* allow egid = rgid */</span>
		      egid != my_pcred-&gt;cr_svgid)) &amp;&amp;	<span class="enscript-comment">/* allow egid = svgid */</span>
		    (error = suser(my_cred, &amp;p-&gt;p_acflag))) { <span class="enscript-comment">/* allow root user any */</span>
			kauth_cred_unref(&amp;my_cred);
			<span class="enscript-keyword">return</span> (error);
		}

		uid_t new_egid = my_pcred-&gt;cr_gid;
		uid_t new_rgid = my_pcred-&gt;cr_rgid;
		uid_t svgid = KAUTH_UID_NONE;

		
  		<span class="enscript-comment">/* 
		 * Set the credential with new info.  If there is no change,
		 * we get back the same credential we passed in; if there is
		 * a change, we drop the reference on the credential we
		 * passed in.  The subsequent compare is safe, because it is
		 * a pointer compare rather than a contents compare.
  		 */</span>
		<span class="enscript-keyword">if</span> (egid != KAUTH_UID_NONE &amp;&amp; my_pcred-&gt;cr_gid != egid) {
			<span class="enscript-comment">/* changing the effective GID */</span>
			new_egid = egid;
			OSBitOrAtomic(P_SUGID, &amp;p-&gt;p_flag);
		}
		<span class="enscript-keyword">if</span> (rgid != KAUTH_UID_NONE &amp;&amp; my_pcred-&gt;cr_rgid != rgid) {
			<span class="enscript-comment">/* changing the real GID */</span>
			new_rgid = rgid;
			OSBitOrAtomic(P_SUGID, &amp;p-&gt;p_flag);
		}
		<span class="enscript-comment">/*
		 * If the newly requested real gid or effective gid does
		 * not match the saved gid, then set the saved gid to the
		 * new effective gid.  We are protected from escalation
		 * by the prechecking.
		 */</span>
		<span class="enscript-keyword">if</span> (my_pcred-&gt;cr_svgid != uap-&gt;rgid &amp;&amp;
		    my_pcred-&gt;cr_svgid != uap-&gt;egid) {
		    	svgid = new_egid;
			OSBitOrAtomic(P_SUGID, &amp;p-&gt;p_flag);
		}

		my_new_cred = kauth_cred_setresgid(my_cred, rgid, egid, svgid);
		<span class="enscript-keyword">if</span> (my_cred != my_new_cred) {

			DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;setregid(CH)%d: %p/0x%08x-&gt;%p/0x%08x\n&quot;</span>, p-&gt;p_pid, my_cred, my_pcred-&gt;cr_flags, my_new_cred, posix_cred_get(my_new_cred)-&gt;cr_flags);

			proc_lock(p);
			<span class="enscript-comment">/* need to protect for a race where another thread
			 * also changed the credential after we took our
			 * reference.  If p_ucred has changed then we
			 * should restart this again with the new cred.
			 */</span>
			<span class="enscript-keyword">if</span> (p-&gt;p_ucred != my_cred) {
				proc_unlock(p);
				kauth_cred_unref(&amp;my_new_cred);
				<span class="enscript-comment">/* try again */</span>
				my_cred = kauth_cred_proc_ref(p);
				my_pcred = posix_cred_get(my_cred);
				<span class="enscript-keyword">continue</span>;
			}
			p-&gt;p_ucred = my_new_cred;
			<span class="enscript-comment">/* update cred on proc */</span>
			PROC_UPDATE_CREDS_ONPROC(p);
			OSBitOrAtomic(P_SUGID, &amp;p-&gt;p_flag); <span class="enscript-comment">/* XXX redundant? */</span>
			proc_unlock(p);
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-comment">/* Drop old proc reference or our extra reference */</span>
	kauth_cred_unref(&amp;my_cred);

	set_security_token(p);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Set the per-thread override identity.  The first parameter can be the
 * current real UID, KAUTH_UID_NONE, or, if the caller is privileged, it
 * can be any UID.  If it is KAUTH_UID_NONE, then as a special case, this
 * means &quot;revert to the per process credential&quot;; otherwise, if permitted,
 * it changes the effective, real, and saved UIDs and GIDs for the current
 * thread to the requested UID and single GID, and clears all other GIDs.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">settid</span>(proc_t p, <span class="enscript-type">struct</span> settid_args *uap, __unused int32_t *retval)
{
	kauth_cred_t uc;
	<span class="enscript-type">struct</span> uthread *uthread = get_bsdthread_info(current_thread());
	uid_t uid;
	gid_t gid;

	uid = uap-&gt;uid;
	gid = uap-&gt;gid;
	AUDIT_ARG(uid, uid);
	AUDIT_ARG(gid, gid);

	<span class="enscript-keyword">if</span> (proc_suser(p) != 0) 
		<span class="enscript-keyword">return</span> (EPERM);
	
	<span class="enscript-keyword">if</span> (uid == KAUTH_UID_NONE) {

		<span class="enscript-comment">/* must already be assuming another identity in order to revert back */</span>
		<span class="enscript-keyword">if</span> ((uthread-&gt;uu_flag &amp; UT_SETUID) == 0)
			<span class="enscript-keyword">return</span> (EPERM);

		<span class="enscript-comment">/* revert to delayed binding of process credential */</span>
		uc = kauth_cred_proc_ref(p);
		kauth_cred_unref(&amp;uthread-&gt;uu_ucred);
		uthread-&gt;uu_ucred = uc;
		uthread-&gt;uu_flag &amp;= ~UT_SETUID;
	} <span class="enscript-keyword">else</span> {
		kauth_cred_t my_cred, my_new_cred;

		<span class="enscript-comment">/* cannot already be assuming another identity */</span>
		<span class="enscript-keyword">if</span> ((uthread-&gt;uu_flag &amp; UT_SETUID) != 0) {
			<span class="enscript-keyword">return</span> (EPERM);
		}

		<span class="enscript-comment">/*
		 * Get a new credential instance from the old if this one
		 * changes; otherwise kauth_cred_setuidgid() returns the
		 * same credential.  We take an extra reference on the
		 * current credential while we muck with it, so we can do
		 * the post-compare for changes by pointer.
		 */</span>
		kauth_cred_ref(uthread-&gt;uu_ucred); 
		my_cred = uthread-&gt;uu_ucred;
		my_new_cred = kauth_cred_setuidgid(my_cred, uid, gid);
		<span class="enscript-keyword">if</span> (my_cred != my_new_cred)
			uthread-&gt;uu_ucred = my_new_cred;
		uthread-&gt;uu_flag |= UT_SETUID;

		<span class="enscript-comment">/* Drop old uthread reference or our extra reference */</span>
		kauth_cred_unref(&amp;my_cred);
	}
	<span class="enscript-comment">/*
	 * XXX should potentially set per thread security token (there is
	 * XXX none).
	 * XXX it is unclear whether P_SUGID should be st at this point;
	 * XXX in theory, it is being deprecated.
	 */</span>
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Set the per-thread override identity.  Use this system call for a thread to
 * assume the identity of another process or to revert back to normal identity
 * of the current process.
 *
 * When the &quot;assume&quot; argument is non zero the current thread will assume the
 * identity of the process represented by the pid argument.
 *
 * When the assume argument is zero we revert back to our normal identity.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">settid_with_pid</span>(proc_t p, <span class="enscript-type">struct</span> settid_with_pid_args *uap, __unused int32_t *retval)
{
	proc_t target_proc;
	<span class="enscript-type">struct</span> uthread *uthread = get_bsdthread_info(current_thread());
	kauth_cred_t my_cred, my_target_cred, my_new_cred;
	posix_cred_t my_target_pcred;

	AUDIT_ARG(pid, uap-&gt;pid);
	AUDIT_ARG(value32, uap-&gt;assume);

	<span class="enscript-keyword">if</span> (proc_suser(p) != 0) {
		<span class="enscript-keyword">return</span> (EPERM);
	}

	<span class="enscript-comment">/*
	 * XXX should potentially set per thread security token (there is
	 * XXX none).
	 * XXX it is unclear whether P_SUGID should be st at this point;
	 * XXX in theory, it is being deprecated.
	 */</span>

	<span class="enscript-comment">/*
	 * assume argument tells us to assume the identity of the process with the
	 * id passed in the pid argument.
	 */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;assume != 0) {
		<span class="enscript-comment">/* can't do this if we have already assumed an identity */</span>
		<span class="enscript-keyword">if</span> ((uthread-&gt;uu_flag &amp; UT_SETUID) != 0)
			<span class="enscript-keyword">return</span> (EPERM);
	
		target_proc = proc_find(uap-&gt;pid);
		<span class="enscript-comment">/* can't assume the identity of the kernel process */</span>
		<span class="enscript-keyword">if</span> (target_proc == NULL || target_proc == kernproc) {
			<span class="enscript-keyword">if</span> (target_proc!= NULL)
				proc_rele(target_proc);
			<span class="enscript-keyword">return</span> (ESRCH);
		}
	
		<span class="enscript-comment">/*
		 * Take a reference on the credential used in our target
		 * process then use it as the identity for our current
		 * thread.  We take an extra reference on the current
		 * credential while we muck with it, so we can do the
		 * post-compare for changes by pointer.
		 *
		 * The post-compare is needed for the case that our process
		 * credential has been changed to be identical to our thread
		 * credential following our assumption of a per-thread one,
		 * since the credential cache will maintain a unique instance.
		 */</span>
		kauth_cred_ref(uthread-&gt;uu_ucred); 
		my_cred = uthread-&gt;uu_ucred;
		my_target_cred = kauth_cred_proc_ref(target_proc);
		my_target_pcred = posix_cred_get(my_target_cred);
		my_new_cred = kauth_cred_setuidgid(my_cred, my_target_pcred-&gt;cr_uid, my_target_pcred-&gt;cr_gid);
		<span class="enscript-keyword">if</span> (my_cred != my_new_cred)
			uthread-&gt;uu_ucred = my_new_cred;
	
		uthread-&gt;uu_flag |= UT_SETUID;
		
		<span class="enscript-comment">/* Drop old uthread reference or our extra reference */</span>
		proc_rele(target_proc);
		kauth_cred_unref(&amp;my_cred);
		kauth_cred_unref(&amp;my_target_cred);

		<span class="enscript-keyword">return</span> (0);
	}
	
	<span class="enscript-comment">/*
	 * Otherwise, we are reverting back to normal mode of operation where
	 * delayed binding of the process credential sets the credential in
	 * the thread (uu_ucred)
	 */</span>
	<span class="enscript-keyword">if</span> ((uthread-&gt;uu_flag &amp; UT_SETUID) == 0)
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-comment">/* revert to delayed binding of process credential */</span>
	my_new_cred = kauth_cred_proc_ref(p);
	kauth_cred_unref(&amp;uthread-&gt;uu_ucred);
	uthread-&gt;uu_ucred = my_new_cred;
	uthread-&gt;uu_flag &amp;= ~UT_SETUID;
	
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * setgroups1
 *
 * Description: Internal implementation for both the setgroups and initgroups
 *		system calls
 *
 * Parameters:	gidsetsize			Number of groups in set
 *		gidset				Pointer to group list
 *		gmuid				Base gid (initgroups only!)
 *
 * Returns:	0				Success
 *	suser:EPERM				Permision denied
 *		EINVAL				Invalid gidsetsize value
 *	copyin:EFAULT				Bad gidset or gidsetsize is
 *						too large
 *
 * Notes:	When called from a thread running under an assumed per-thread
 *		identity, this function will operate against the per-thread
 *		credential, rather than against the process credential.  In
 *		this specific case, the process credential is verified to
 *		still be privileged at the time of the call, rather than the
 *		per-thread credential for this operation to be permitted.
 *
 *		This effectively means that setgroups/initigroups calls in
 *		a thread running a per-thread credential should occur *after*
 *		the settid call that created it, not before (unlike setuid,
 *		which must be called after, since it will result in privilege
 *		being dropped).
 *
 *		When called normally (i.e. no per-thread assumed identity),
 *		the per process credential is updated per POSIX.
 *
 *		If the credential is changed as a result of this call, then we
 *		flag the process as having set privilege since the last exec.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">setgroups1</span>(proc_t p, u_int gidsetsize, user_addr_t gidset, uid_t gmuid, __unused int32_t *retval)
{
	u_int ngrp;
	gid_t	newgroups[NGROUPS] = { 0 };
	<span class="enscript-type">int</span> 	error;
	kauth_cred_t my_cred, my_new_cred;
	<span class="enscript-type">struct</span> uthread *uthread = get_bsdthread_info(current_thread());

	DEBUG_CRED_ENTER(<span class="enscript-string">&quot;setgroups1 (%d/%d): %d 0x%016x %d\n&quot;</span>, p-&gt;p_pid, (p-&gt;p_pptr ? p-&gt;p_pptr-&gt;p_pid : 0), gidsetsize, gidset, gmuid);

	ngrp = gidsetsize;
	<span class="enscript-keyword">if</span> (ngrp &gt; NGROUPS)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> ( ngrp &lt; 1 ) {
		ngrp = 1;
	} <span class="enscript-keyword">else</span> {
		error = copyin(gidset,
			(caddr_t)newgroups, ngrp * <span class="enscript-keyword">sizeof</span>(gid_t));
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">return</span> (error);
		}
	}

	my_cred = kauth_cred_proc_ref(p);
	<span class="enscript-keyword">if</span> ((error = suser(my_cred, &amp;p-&gt;p_acflag))) {
		kauth_cred_unref(&amp;my_cred);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> ((uthread-&gt;uu_flag &amp; UT_SETUID) != 0) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_CRED</span>
		<span class="enscript-type">int</span> my_cred_flags = uthread-&gt;uu_ucred-&gt;cr_flags;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* DEBUG_CRED */</span>
		kauth_cred_unref(&amp;my_cred);

		<span class="enscript-comment">/*
		 * If this thread is under an assumed identity, set the
		 * supplementary grouplist on the thread credential instead
		 * of the process one.  If we were the only reference holder,
		 * the credential is updated in place, otherwise, our reference
		 * is dropped and we get back a different cred with a reference
		 * already held on it.  Because this is per-thread, we don't
		 * need the referencing/locking/retry required for per-process.
		 */</span>
		my_cred = uthread-&gt;uu_ucred;
		uthread-&gt;uu_ucred = kauth_cred_setgroups(my_cred, &amp;newgroups[0], ngrp, gmuid);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_CRED</span>
		<span class="enscript-keyword">if</span> (my_cred != uthread-&gt;uu_ucred) {
			DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;setgroups1(CH)%d: %p/0x%08x-&gt;%p/0x%08x\n&quot;</span>, p-&gt;p_pid, my_cred, my_cred_flags, uthread-&gt;uu_ucred , uthread-&gt;uu_ucred -&gt;cr_flags);
		}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* DEBUG_CRED */</span>
	} <span class="enscript-keyword">else</span> {

		<span class="enscript-comment">/*
		 * get current credential and take a reference while we muck
		 * with it
		 */</span>
		<span class="enscript-keyword">for</span> (;;) {
			<span class="enscript-comment">/* 
			 * Set the credential with new info.  If there is no
			 * change, we get back the same credential we passed
			 * in; if there is a change, we drop the reference on
			 * the credential we passed in.  The subsequent
			 * compare is safe, because it is a pointer compare
			 * rather than a contents compare.
			 */</span>
			my_new_cred = kauth_cred_setgroups(my_cred, &amp;newgroups[0], ngrp, gmuid);
			<span class="enscript-keyword">if</span> (my_cred != my_new_cred) {

				DEBUG_CRED_CHANGE(<span class="enscript-string">&quot;setgroups1(CH)%d: %p/0x%08x-&gt;%p/0x%08x\n&quot;</span>, p-&gt;p_pid, my_cred, my_cred-&gt;cr_flags, my_new_cred, my_new_cred-&gt;cr_flags);

				proc_lock(p);
				<span class="enscript-comment">/*
				 * We need to protect for a race where another
				 * thread also changed the credential after we
				 * took our reference.  If p_ucred has 
				 * changed then we should restart this again
				 * with the new cred.
				 */</span>
				<span class="enscript-keyword">if</span> (p-&gt;p_ucred != my_cred) {
					proc_unlock(p);
					kauth_cred_unref(&amp;my_new_cred);
					my_cred = kauth_cred_proc_ref(p);
					<span class="enscript-comment">/* try again */</span>
					<span class="enscript-keyword">continue</span>;
				}
				p-&gt;p_ucred = my_new_cred;
				<span class="enscript-comment">/* update cred on proc */</span>
				PROC_UPDATE_CREDS_ONPROC(p);
				OSBitOrAtomic(P_SUGID, &amp;p-&gt;p_flag);
				proc_unlock(p);
			}
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* Drop old proc reference or our extra reference */</span>
		AUDIT_ARG(groupset, posix_cred_get(my_cred)-&gt;cr_groups, ngrp);
		kauth_cred_unref(&amp;my_cred);


		set_security_token(p);
	}

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * initgroups
 *
 * Description: Initialize the default supplementary groups list and set the
 *		gmuid for use by the external group resolver (if any)
 *
 * Parameters:	uap-&gt;gidsetsize			Number of groups in set
 *		uap-&gt;gidset			Pointer to group list
 *		uap-&gt;gmuid			Base gid
 *
 * Returns:	0				Success
 *	setgroups1:EPERM			Permision denied
 *	setgroups1:EINVAL			Invalid gidsetsize value
 *	setgroups1:EFAULT			Bad gidset or gidsetsize is
 *
 * Notes:	This function opts *IN* to memberd participation
 *
 *		The normal purpose of this function is for a privileged
 *		process to indicate supplementary groups and identity for
 *		participation in extended group membership resolution prior
 *		to dropping privilege by assuming a specific user identity.
 *
 *		It is the first half of the primary mechanism whereby user
 *		identity is established to the system by programs such as
 *		/usr/bin/login.  The second half is the drop of uid privilege
 *		for a specific uid corresponding to the user.
 *
 * See also:	setgroups1()
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">initgroups</span>(proc_t p, <span class="enscript-type">struct</span> initgroups_args *uap, __unused int32_t *retval)
{
	DEBUG_CRED_ENTER(<span class="enscript-string">&quot;initgroups\n&quot;</span>);

	<span class="enscript-keyword">return</span>(setgroups1(p, uap-&gt;gidsetsize, uap-&gt;gidset, uap-&gt;gmuid, retval));
}


<span class="enscript-comment">/*
 * setgroups
 *
 * Description: Initialize the default supplementary groups list
 *
 * Parameters:	gidsetsize			Number of groups in set
 *		gidset				Pointer to group list
 *
 * Returns:	0				Success
 *	setgroups1:EPERM			Permision denied
 *	setgroups1:EINVAL			Invalid gidsetsize value
 *	setgroups1:EFAULT			Bad gidset or gidsetsize is
 *
 * Notes:	This functions opts *OUT* of memberd participation.
 *
 *		This function exists for compatibility with POSIX.  Most user
 *		programs should use initgroups() instead to ensure correct
 *		participation in group membership resolution when utilizing
 *		a directory service for authentication.
 *
 *		It is identical to an initgroups() call with a gmuid argument
 *		of KAUTH_UID_NONE.
 *
 * See also:	setgroups1()
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setgroups</span>(proc_t p, <span class="enscript-type">struct</span> setgroups_args *uap, __unused int32_t *retval)
{
	DEBUG_CRED_ENTER(<span class="enscript-string">&quot;setgroups\n&quot;</span>);

	<span class="enscript-keyword">return</span>(setgroups1(p, uap-&gt;gidsetsize, uap-&gt;gidset, KAUTH_UID_NONE, retval));
}


<span class="enscript-comment">/*
 * Set the per-thread/per-process supplementary groups list.
 * 
 * XXX implement setsgroups
 *
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">setsgroups</span>(__unused proc_t p, __unused <span class="enscript-type">struct</span> setsgroups_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span>(ENOTSUP);
}

<span class="enscript-comment">/*
 * Set the per-thread/per-process whiteout groups list.
 * 
 * XXX implement setwgroups
 *
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">setwgroups</span>(__unused proc_t p, __unused <span class="enscript-type">struct</span> setwgroups_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">return</span>(ENOTSUP);
}


<span class="enscript-comment">/*
 * Check if gid is a member of the group set.
 *
 * XXX This interface is going away; use kauth_cred_ismember_gid() directly
 * XXX instead.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">groupmember</span>(gid_t gid, kauth_cred_t cred)
{
	<span class="enscript-type">int</span> is_member;

	<span class="enscript-keyword">if</span> (kauth_cred_ismember_gid(cred, gid, &amp;is_member) == 0 &amp;&amp; is_member)
		<span class="enscript-keyword">return</span> (1);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Test whether the specified credentials imply &quot;super-user&quot;
 * privilege; if so, and we have accounting info, set the flag
 * indicating use of super-powers.
 * Returns 0 or error.
 *
 * XXX This interface is going away; use kauth_cred_issuser() directly
 * XXX instead.
 *
 * Note:	This interface exists to implement the &quot;has used privilege&quot;
 *		bit (ASU) in the p_acflags field of the process, which is
 *		only externalized via private sysctl and in process accounting
 *		records.  The flag is technically not required in either case.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">suser</span>(kauth_cred_t cred, u_short *acflag)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
	<span class="enscript-keyword">if</span> (!IS_VALID_CRED(cred))
		panic(<span class="enscript-string">&quot;suser&quot;</span>);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (kauth_cred_getuid(cred) == 0) {
		<span class="enscript-keyword">if</span> (acflag)
			*acflag |= ASU;
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">return</span> (EPERM);
}


<span class="enscript-comment">/*
 * getlogin
 *
 * Description:	Get login name, if available.
 *
 * Parameters:	uap-&gt;namebuf			User buffer for return
 *		uap-&gt;namelen			User buffer length
 *
 * Returns:	0				Success
 *	copyout:EFAULT
 *
 * Notes:	Intended to obtain a string containing the user name of the
 *		user associated with the controlling terminal for the calling
 *		process.
 *
 *		Not very useful on modern systems, due to inherent length
 *		limitations for the static array in the session structure
 *		which is used to store the login name.
 *
 *		Permitted to return NULL
 *
 * XXX:		Belongs in kern_proc.c
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">getlogin</span>(proc_t p, <span class="enscript-type">struct</span> getlogin_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">char</span> buffer[MAXLOGNAME+1];
	<span class="enscript-type">struct</span> session * sessp;

	bzero(buffer, MAXLOGNAME+1);

	sessp = proc_session(p);

	<span class="enscript-keyword">if</span> (uap-&gt;namelen &gt; MAXLOGNAME)
		uap-&gt;namelen = MAXLOGNAME;

	<span class="enscript-keyword">if</span>(sessp != SESSION_NULL) {
		session_lock(sessp);
		bcopy( sessp-&gt;s_login, buffer, uap-&gt;namelen);
		session_unlock(sessp);
	}
	session_rele(sessp);

	<span class="enscript-keyword">return</span> (copyout((caddr_t)buffer, uap-&gt;namebuf, uap-&gt;namelen));
}


<span class="enscript-comment">/*
 * setlogin
 *
 * Description:	Set login name.
 *
 * Parameters:	uap-&gt;namebuf			User buffer containing name
 *
 * Returns:	0				Success
 *	suser:EPERM				Permission denied
 *	copyinstr:EFAULT			User buffer invalid
 *	copyinstr:EINVAL			Supplied name was too long
 *
 * Notes:	This is a utility system call to support getlogin().
 *
 * XXX:		Belongs in kern_proc.c
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">setlogin</span>(proc_t p, <span class="enscript-type">struct</span> setlogin_args *uap, __unused int32_t *retval)
{
	<span class="enscript-type">int</span> error;
	size_t dummy=0;
	<span class="enscript-type">char</span> buffer[MAXLOGNAME+1];
	<span class="enscript-type">struct</span> session * sessp;

	<span class="enscript-keyword">if</span> ((error = proc_suser(p)))
		<span class="enscript-keyword">return</span> (error);

	bzero(&amp;buffer[0], MAXLOGNAME+1);


	error = copyinstr(uap-&gt;namebuf,
	    (caddr_t) &amp;buffer[0],
	    MAXLOGNAME - 1, (size_t *)&amp;dummy);

	sessp = proc_session(p);

	<span class="enscript-keyword">if</span> (sessp != SESSION_NULL) {
		session_lock(sessp);
		bcopy(buffer, sessp-&gt;s_login, MAXLOGNAME);
		session_unlock(sessp);
		session_rele(sessp);
	}


	<span class="enscript-keyword">if</span> (!error) {
		AUDIT_ARG(text, buffer);
	 } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == ENAMETOOLONG)
		error = EINVAL;
	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/* Set the secrity token of the task with current euid and eguid */</span>
<span class="enscript-comment">/*
 * XXX This needs to change to give the task a reference and/or an opaque
 * XXX identifier.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">set_security_token</span>(proc_t p)
{
	security_token_t sec_token;
	audit_token_t    audit_token;
	kauth_cred_t my_cred;
	posix_cred_t my_pcred;
	host_priv_t host_priv;

	<span class="enscript-comment">/*
	 * Don't allow a vfork child to override the parent's token settings
	 * (since they share a task).  Instead, the child will just have to
	 * suffer along using the parent's token until the exec().  It's all
	 * undefined behavior anyway, right?
	 */</span>
	<span class="enscript-keyword">if</span> (p-&gt;task == current_task()) {
		uthread_t	 uthread;
		uthread = (uthread_t)get_bsdthread_info(current_thread());
		<span class="enscript-keyword">if</span> (uthread-&gt;uu_flag &amp; UT_VFORK)
			<span class="enscript-keyword">return</span> (1);
	}
		
	my_cred = kauth_cred_proc_ref(p);
	my_pcred = posix_cred_get(my_cred);

	<span class="enscript-comment">/* XXX mach_init doesn't have a p_ucred when it calls this function */</span>
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(my_cred)) {
		sec_token.val[0] = kauth_cred_getuid(my_cred);
		sec_token.val[1] = kauth_cred_getgid(my_cred);
	} <span class="enscript-keyword">else</span> {
		sec_token.val[0] = 0;
		sec_token.val[1] = 0;
	}

	<span class="enscript-comment">/*
	 * The current layout of the Mach audit token explicitly
	 * adds these fields.  But nobody should rely on such
	 * a literal representation.  Instead, the BSM library
	 * provides a function to convert an audit token into
	 * a BSM subject.  Use of that mechanism will isolate
	 * the user of the trailer from future representation
	 * changes.
	 */</span>
	audit_token.val[0] = my_cred-&gt;cr_audit.as_aia_p-&gt;ai_auid;
	audit_token.val[1] = my_pcred-&gt;cr_uid;
	audit_token.val[2] = my_pcred-&gt;cr_gid;
	audit_token.val[3] = my_pcred-&gt;cr_ruid;
	audit_token.val[4] = my_pcred-&gt;cr_rgid;
	audit_token.val[5] = p-&gt;p_pid;
	audit_token.val[6] = my_cred-&gt;cr_audit.as_aia_p-&gt;ai_asid;
	audit_token.val[7] = p-&gt;p_idversion;

	host_priv = (sec_token.val[0]) ? HOST_PRIV_NULL : host_priv_self();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">if</span> (host_priv != HOST_PRIV_NULL &amp;&amp; mac_system_check_host_priv(my_cred))
		host_priv = HOST_PRIV_NULL;
#<span class="enscript-reference">endif</span>
	kauth_cred_unref(&amp;my_cred);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-comment">/* 
	 * Update the pid an proc name for importance base if any
	 */</span>
	task_importance_update_owner_info(p-&gt;task);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">return</span> (host_security_set_task_token(host_security_self(),
					   p-&gt;task,
					   sec_token,
					   audit_token,
					   host_priv) != KERN_SUCCESS);
}


<span class="enscript-type">int</span> <span class="enscript-function-name">get_audit_token_pid</span>(audit_token_t *audit_token);

<span class="enscript-type">int</span>
<span class="enscript-function-name">get_audit_token_pid</span>(audit_token_t *audit_token)
{
	<span class="enscript-comment">/* keep in-sync with set_security_token (above) */</span>
	<span class="enscript-keyword">if</span> (audit_token)
		<span class="enscript-keyword">return</span> (<span class="enscript-type">int</span>)audit_token-&gt;val[5];
	<span class="enscript-keyword">return</span> -1;
}


<span class="enscript-comment">/*
 * Fill in a struct xucred based on a kauth_cred_t.
 */</span>
__private_extern__
<span class="enscript-type">void</span>
<span class="enscript-function-name">cru2x</span>(kauth_cred_t cr, <span class="enscript-type">struct</span> xucred *xcr)
{
	posix_cred_t pcr = posix_cred_get(cr);

	bzero(xcr, <span class="enscript-keyword">sizeof</span>(*xcr));
	xcr-&gt;cr_version = XUCRED_VERSION;
	xcr-&gt;cr_uid = kauth_cred_getuid(cr);
	xcr-&gt;cr_ngroups = pcr-&gt;cr_ngroups;
	bcopy(pcr-&gt;cr_groups, xcr-&gt;cr_groups, <span class="enscript-keyword">sizeof</span>(xcr-&gt;cr_groups));
}
</pre>
<hr />
</body></html>