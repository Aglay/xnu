<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_clock.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_clock.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*-
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)kern_clock.c	8.5 (Berkeley) 1/21/94
 */</span>
<span class="enscript-comment">/*
 * HISTORY
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/spl.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resource.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">GPROF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/gmon.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/ast.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>

<span class="enscript-type">void</span> <span class="enscript-function-name">bsd_uprofil</span>(<span class="enscript-type">struct</span> time_value *syst, user_addr_t pc);
<span class="enscript-type">int</span> <span class="enscript-function-name">tvtohz</span>(<span class="enscript-type">struct</span> timeval *tv);

<span class="enscript-comment">/*
 * Clock handling routines.
 *
 * This code is written to operate with two timers which run
 * independently of each other. The main clock, running at hz
 * times per second, is used to do scheduling and timeout calculations.
 * The second timer does resource utilization estimation statistically
 * based on the state of the machine phz times a second. Both functions
 * can be performed by a single clock (ie hz == phz), however the 
 * statistics will be much more prone to errors. Ideally a machine
 * would have separate clocks measuring time spent in user state, system
 * state, interrupt state, and idle state. These clocks would allow a non-
 * approximate measure of resource utilization.
 */</span>

<span class="enscript-comment">/*
 * The hz hardware interval timer.
 */</span>

<span class="enscript-type">int</span>             hz = 100;                <span class="enscript-comment">/* GET RID OF THIS !!! */</span>
<span class="enscript-type">int</span>             tick = (1000000 / 100);  <span class="enscript-comment">/* GET RID OF THIS !!! */</span>

<span class="enscript-comment">/*
 * Kernel timeout services.
 */</span>

<span class="enscript-comment">/*
 *	Set a timeout.
 *
 *	fcn:		function to call
 *	param:		parameter to pass to function
 *	interval:	timeout interval, in hz.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">timeout</span>(
	timeout_fcn_t			fcn,
	<span class="enscript-type">void</span>					*param,
	<span class="enscript-type">int</span>						interval)
{
	uint64_t		deadline;

	clock_interval_to_deadline(interval, NSEC_PER_SEC / hz, &amp;deadline);
	thread_call_func_delayed((thread_call_func_t)fcn, param, deadline);
}

<span class="enscript-comment">/*
 *	Set a timeout with leeway.
 *
 *	fcn:		function to call
 *	param:		parameter to pass to function
 *	interval:	timeout interval, in hz.
 *	leeway_interval:	leeway interval, in hz.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">timeout_with_leeway</span>(
	timeout_fcn_t			fcn,
	<span class="enscript-type">void</span>					*param,
	<span class="enscript-type">int</span>						interval,
	<span class="enscript-type">int</span>						leeway_interval)
{
	uint64_t		deadline;
	uint64_t		leeway;

	clock_interval_to_deadline(interval, NSEC_PER_SEC / hz, &amp;deadline);

	clock_interval_to_absolutetime_interval(leeway_interval, NSEC_PER_SEC / hz, &amp;leeway);

	thread_call_func_delayed_with_leeway((thread_call_func_t)fcn, param, deadline, leeway, THREAD_CALL_DELAY_LEEWAY);
}

<span class="enscript-comment">/*
 * Cancel a timeout.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">untimeout</span>(
	timeout_fcn_t		fcn,
	<span class="enscript-type">void</span>			*param)
{
	thread_call_func_cancel((thread_call_func_t)fcn, param, FALSE);
}


<span class="enscript-comment">/*
 *	Set a timeout.
 *
 *	fcn:		function to call
 *	param:		parameter to pass to function
 *	ts:		timeout interval, in timespec
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">bsd_timeout</span>(
	timeout_fcn_t			fcn,
	<span class="enscript-type">void</span>					*param,
	<span class="enscript-type">struct</span> timespec         *ts)
{
	uint64_t		deadline = 0;

	<span class="enscript-keyword">if</span> (ts &amp;&amp; (ts-&gt;tv_sec || ts-&gt;tv_nsec)) {
		nanoseconds_to_absolutetime((uint64_t)ts-&gt;tv_sec * NSEC_PER_SEC + ts-&gt;tv_nsec,  &amp;deadline );
		clock_absolutetime_interval_to_deadline( deadline, &amp;deadline );
	}
	thread_call_func_delayed((thread_call_func_t)fcn, param, deadline);
}

<span class="enscript-comment">/*
 * Cancel a timeout.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">bsd_untimeout</span>(
	timeout_fcn_t		fcn,
	<span class="enscript-type">void</span>			*param)
{
	thread_call_func_cancel((thread_call_func_t)fcn, param, FALSE);
}


<span class="enscript-comment">/*
 * Compute number of hz until specified time.
 * Used to compute third argument to timeout() from an
 * absolute time.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">hzto</span>(<span class="enscript-type">struct</span> timeval *tv)
{
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">long</span> ticks;
	<span class="enscript-type">long</span> sec;

	microtime(&amp;now);
	<span class="enscript-comment">/*
	 * If number of milliseconds will fit in 32 bit arithmetic,
	 * then compute number of milliseconds to time and scale to
	 * ticks.  Otherwise just compute number of hz in time, rounding
	 * times greater than representible to maximum value.
	 *
	 * Delta times less than 25 days can be computed ``exactly''.
	 * Maximum value for any timeout in 10ms ticks is 250 days.
	 */</span>
	sec = tv-&gt;tv_sec - now.tv_sec;
	<span class="enscript-keyword">if</span> (sec &lt;= 0x7fffffff / 1000 - 1000)
		ticks = ((tv-&gt;tv_sec - now.tv_sec) * 1000 +
			(tv-&gt;tv_usec - now.tv_usec) / 1000)
				/ (tick / 1000);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sec &lt;= 0x7fffffff / hz)
		ticks = sec * hz;
	<span class="enscript-keyword">else</span>
		ticks = 0x7fffffff;

	<span class="enscript-keyword">return</span> (ticks);
}

<span class="enscript-comment">/*
 * Return information about system clocks.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_clockrate
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, __unused <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">struct</span> clockinfo clkinfo;

	<span class="enscript-comment">/*
	 * Construct clockinfo structure.
	 */</span>
	clkinfo.hz = hz;
	clkinfo.tick = tick;
	clkinfo.profhz = hz;
	clkinfo.stathz = hz;
	<span class="enscript-keyword">return</span> sysctl_io_opaque(req, &amp;clkinfo, <span class="enscript-keyword">sizeof</span>(clkinfo), NULL);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_CLOCKRATE, clockrate,
		CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED,
		0, 0, sysctl_clockrate, <span class="enscript-string">&quot;S,clockinfo&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);


<span class="enscript-comment">/*
 * Compute number of ticks in the specified amount of time.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">tvtohz</span>(<span class="enscript-type">struct</span> timeval *tv)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> ticks;
	<span class="enscript-type">long</span> sec, usec;

	<span class="enscript-comment">/*
	 * If the number of usecs in the whole seconds part of the time
	 * difference fits in a long, then the total number of usecs will
	 * fit in an unsigned long.  Compute the total and convert it to
	 * ticks, rounding up and adding 1 to allow for the current tick
	 * to expire.  Rounding also depends on unsigned long arithmetic
	 * to avoid overflow.
	 *
	 * Otherwise, if the number of ticks in the whole seconds part of
	 * the time difference fits in a long, then convert the parts to
	 * ticks separately and add, using similar rounding methods and
	 * overflow avoidance.  This method would work in the previous
	 * case but it is slightly slower and assumes that hz is integral.
	 *
	 * Otherwise, round the time difference down to the maximum
	 * representable value.
	 *
	 * If ints have 32 bits, then the maximum value for any timeout in
	 * 10ms ticks is 248 days.
	 */</span>
	sec = tv-&gt;tv_sec;
	usec = tv-&gt;tv_usec;
	<span class="enscript-keyword">if</span> (usec &lt; 0) {
		sec--;
		usec += 1000000;
	}
	<span class="enscript-keyword">if</span> (sec &lt; 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
		<span class="enscript-keyword">if</span> (usec &gt; 0) {
			sec++;
			usec -= 1000000;
		}
		printf(<span class="enscript-string">&quot;tvotohz: negative time difference %ld sec %ld usec\n&quot;</span>,
		       sec, usec);
#<span class="enscript-reference">endif</span>
		ticks = 1;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sec &lt;= LONG_MAX / 1000000)
		ticks = (sec * 1000000 + (<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)usec + (tick - 1))
			/ tick + 1;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sec &lt;= LONG_MAX / hz)
		ticks = sec * hz
			+ ((<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>)usec + (tick - 1)) / tick + 1;
	<span class="enscript-keyword">else</span>
		ticks = LONG_MAX;
	<span class="enscript-keyword">if</span> (ticks &gt; INT_MAX)
		ticks = INT_MAX;
	<span class="enscript-keyword">return</span> ((<span class="enscript-type">int</span>)ticks);
}


<span class="enscript-comment">/*
 * Start profiling on a process.
 *
 * Kernel profiling passes kernel_proc which never exits and hence
 * keeps the profile clock running constantly.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">startprofclock</span>(<span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_PROFIL) == 0)
		OSBitOrAtomic(P_PROFIL, &amp;p-&gt;p_flag);
}

<span class="enscript-comment">/*
 * Stop profiling on a process.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">stopprofclock</span>(<span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-keyword">if</span> (p-&gt;p_flag &amp; P_PROFIL)
		OSBitAndAtomic(~((uint32_t)P_PROFIL), &amp;p-&gt;p_flag);
}

<span class="enscript-comment">/* TBD locking user profiling is not resolved yet */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">bsd_uprofil</span>(<span class="enscript-type">struct</span> time_value *syst, user_addr_t pc)
{
	<span class="enscript-type">struct</span> proc *p = current_proc();
	<span class="enscript-type">int</span>		ticks;
	<span class="enscript-type">struct</span> timeval	*tv;
	<span class="enscript-type">struct</span> timeval st;

	<span class="enscript-keyword">if</span> (p == NULL)
	        <span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> ( !(p-&gt;p_flag &amp; P_PROFIL))
	        <span class="enscript-keyword">return</span>;

	st.tv_sec = syst-&gt;seconds;
	st.tv_usec = syst-&gt;microseconds;

	tv = &amp;(p-&gt;p_stats-&gt;p_ru.ru_stime);

	ticks = ((tv-&gt;tv_sec - st.tv_sec) * 1000 +
		(tv-&gt;tv_usec - st.tv_usec) / 1000) /
		(tick / 1000);
	<span class="enscript-keyword">if</span> (ticks)
		addupc_task(p, pc, ticks);
}

<span class="enscript-comment">/* TBD locking user profiling is not resolved yet */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">get_procrustime</span>(time_value_t *tv)
{
	<span class="enscript-type">struct</span> proc *p = current_proc();
	<span class="enscript-type">struct</span> timeval st;

	<span class="enscript-keyword">if</span> (p == NULL) 
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> ( !(p-&gt;p_flag &amp; P_PROFIL))
	        <span class="enscript-keyword">return</span>;

	<span class="enscript-comment">//proc_lock(p);
</span>	st = p-&gt;p_stats-&gt;p_ru.ru_stime;
	<span class="enscript-comment">//proc_unlock(p);
</span>	
	tv-&gt;seconds = st.tv_sec;
	tv-&gt;microseconds = st.tv_usec;
}
</pre>
<hr />
</body></html>