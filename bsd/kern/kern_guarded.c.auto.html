<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_guarded.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_guarded.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/guarded.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ubc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vfs/vfs_support.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syscall.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdbool.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PROTECT</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cprotect.h&gt;</span>
#<span class="enscript-reference">endif</span>


#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_flag</span> f_fglob-&gt;fg_flag
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_type</span> f_fglob-&gt;fg_ops-&gt;fo_type
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">dofilewrite</span>(vfs_context_t ctx, <span class="enscript-type">struct</span> fileproc *fp,
			 user_addr_t bufp, user_size_t nbyte, off_t offset, 
			 <span class="enscript-type">int</span> flags, user_ssize_t *retval );
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">wr_uio</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> fileproc *fp, uio_t uio, user_ssize_t *retval);

<span class="enscript-comment">/*
 * Experimental guarded file descriptor support.
 */</span>

kern_return_t <span class="enscript-function-name">task_exception_notify</span>(exception_type_t exception,
        mach_exception_data_type_t code, mach_exception_data_type_t subcode);

<span class="enscript-comment">/*
 * Most fd's have an underlying fileproc struct; but some may be
 * guarded_fileproc structs which implement guarded fds.  The latter
 * struct (below) embeds the former.
 *
 * The two types should be distinguished by the &quot;type&quot; portion of f_flags.
 * There's also a magic number to help catch misuse and bugs.
 *
 * This is a bit unpleasant, but results from the desire to allow
 * alternate file behaviours for a few file descriptors without
 * growing the fileproc data structure.
 */</span>

<span class="enscript-type">struct</span> guarded_fileproc {
	<span class="enscript-type">struct</span> fileproc gf_fileproc;
	u_int		gf_magic;
	u_int		gf_attrs;
	thread_t	gf_thread;
	guardid_t	gf_guard;
	<span class="enscript-type">int</span>		gf_exc_fd;
	u_int		gf_exc_code;
};

<span class="enscript-type">const</span> size_t sizeof_guarded_fileproc = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> guarded_fileproc);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">FP_TO_GFP</span>(fp)	((struct guarded_fileproc *)(fp))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">GFP_TO_FP</span>(gfp)	(&amp;(gfp)-&gt;gf_fileproc)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GUARDED_FILEPROC_MAGIC</span>	0x29083

<span class="enscript-type">struct</span> gfp_crarg {
	guardid_t gca_guard;
	u_int gca_attrs;
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> fileproc *
<span class="enscript-function-name">guarded_fileproc_alloc_init</span>(<span class="enscript-type">void</span> *crarg)
{
	<span class="enscript-type">struct</span> gfp_crarg *aarg = crarg;
	<span class="enscript-type">struct</span> guarded_fileproc *gfp;

	<span class="enscript-keyword">if</span> ((gfp = kalloc(<span class="enscript-keyword">sizeof</span> (*gfp))) == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	bzero(gfp, <span class="enscript-keyword">sizeof</span> (*gfp));
	gfp-&gt;gf_fileproc.f_flags = FTYPE_GUARDED;
	gfp-&gt;gf_magic = GUARDED_FILEPROC_MAGIC;
	gfp-&gt;gf_guard = aarg-&gt;gca_guard;
	gfp-&gt;gf_attrs = aarg-&gt;gca_attrs;

	<span class="enscript-keyword">return</span> (GFP_TO_FP(gfp));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">guarded_fileproc_free</span>(<span class="enscript-type">struct</span> fileproc *fp)
{
	<span class="enscript-type">struct</span> guarded_fileproc *gfp = FP_TO_GFP(fp);

	<span class="enscript-keyword">if</span> (FILEPROC_TYPE(fp) != FTYPE_GUARDED ||
	    GUARDED_FILEPROC_MAGIC != gfp-&gt;gf_magic)
		panic(<span class="enscript-string">&quot;%s: corrupt fp %p flags %x&quot;</span>, __func__, fp, fp-&gt;f_flags);

	kfree(gfp, <span class="enscript-keyword">sizeof</span> (*gfp));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">fp_lookup_guarded</span>(proc_t p, <span class="enscript-type">int</span> fd, guardid_t guard,
    <span class="enscript-type">struct</span> guarded_fileproc **gfpp, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((error = fp_lookup(p, fd, &amp;fp, locked)) != 0)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">if</span> (FILEPROC_TYPE(fp) != FTYPE_GUARDED) {
		(<span class="enscript-type">void</span>) fp_drop(p, fd, fp, locked);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-type">struct</span> guarded_fileproc *gfp = FP_TO_GFP(fp);

	<span class="enscript-keyword">if</span> (GUARDED_FILEPROC_MAGIC != gfp-&gt;gf_magic)
		panic(<span class="enscript-string">&quot;%s: corrupt fp %p&quot;</span>, __func__, fp);

	<span class="enscript-keyword">if</span> (guard != gfp-&gt;gf_guard) {
		(<span class="enscript-type">void</span>) fp_drop(p, fd, fp, locked);
		<span class="enscript-keyword">return</span> (EPERM);	<span class="enscript-comment">/* *not* a mismatch exception */</span>
	}
	<span class="enscript-keyword">if</span> (gfpp)
		*gfpp = gfp;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Expected use pattern:
 *
 * if (FP_ISGUARDED(fp, GUARD_CLOSE)) {
 * 	error = fp_guard_exception(p, fd, fp, kGUARD_EXC_CLOSE);
 *      proc_fdunlock(p);
 *      return (error);
 * }
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">fp_isguarded</span>(<span class="enscript-type">struct</span> fileproc *fp, u_int attrs)
{
	<span class="enscript-keyword">if</span> (FILEPROC_TYPE(fp) == FTYPE_GUARDED) {
		<span class="enscript-type">struct</span> guarded_fileproc *gfp = FP_TO_GFP(fp);

		<span class="enscript-keyword">if</span> (GUARDED_FILEPROC_MAGIC != gfp-&gt;gf_magic)
			panic(<span class="enscript-string">&quot;%s: corrupt gfp %p flags %x&quot;</span>,
			    __func__, gfp, fp-&gt;f_flags);
		<span class="enscript-keyword">return</span> ((attrs &amp; gfp-&gt;gf_attrs) == attrs);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">extern</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">proc_name_address</span>(<span class="enscript-type">void</span> *p);

<span class="enscript-type">int</span>
<span class="enscript-function-name">fp_guard_exception</span>(proc_t p, <span class="enscript-type">int</span> fd, <span class="enscript-type">struct</span> fileproc *fp, u_int code)
{
	<span class="enscript-keyword">if</span> (FILEPROC_TYPE(fp) != FTYPE_GUARDED)
		panic(<span class="enscript-string">&quot;%s corrupt fp %p flags %x&quot;</span>, __func__, fp, fp-&gt;f_flags);

	<span class="enscript-type">struct</span> guarded_fileproc *gfp = FP_TO_GFP(fp);

	<span class="enscript-comment">/* all gfd fields protected via proc_fdlock() */</span>
	proc_fdlock_assert(p, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (NULL == gfp-&gt;gf_thread) {
		thread_t t = current_thread();
		gfp-&gt;gf_thread = t;
		gfp-&gt;gf_exc_fd = fd;
		gfp-&gt;gf_exc_code = code;

		<span class="enscript-comment">/*
		 * This thread was the first to attempt the
		 * operation that violated the guard on this fd;
		 * generate an exception.
		 */</span>
		printf(<span class="enscript-string">&quot;%s: guarded fd exception: &quot;</span>
		    <span class="enscript-string">&quot;fd %d code 0x%x guard 0x%llx\n&quot;</span>,
		    proc_name_address(p), gfp-&gt;gf_exc_fd,
		    gfp-&gt;gf_exc_code, gfp-&gt;gf_guard);

		thread_guard_violation(t, GUARD_TYPE_FD);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * We already recorded a violation on this fd for a
		 * different thread, so posting an exception is
		 * already in progress.  We could pause for a bit
		 * and check again, or we could panic (though that seems
		 * heavy handed), or we could just press on with the
		 * error return alone.  For now, resort to printf.
		 */</span>
		printf(<span class="enscript-string">&quot;%s: guarded fd exception+: &quot;</span>
		    <span class="enscript-string">&quot;fd %d code 0x%x guard 0x%llx\n&quot;</span>,
		    proc_name_address(p), gfp-&gt;gf_exc_fd,
		    gfp-&gt;gf_exc_code, gfp-&gt;gf_guard);
	}

	<span class="enscript-keyword">return</span> (EPERM);
}

<span class="enscript-comment">/*
 * (Invoked before returning to userland from the syscall handler.)
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">fd_guard_ast</span>(thread_t t)
{
	proc_t p = current_proc();
	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">int</span> i;

	proc_fdlock(p);
	<span class="enscript-keyword">for</span> (i = fdp-&gt;fd_lastfile; i &gt;= 0; i--) {
		<span class="enscript-type">struct</span> fileproc *fp = fdp-&gt;fd_ofiles[i];

		<span class="enscript-keyword">if</span> (fp == NULL ||
		    FILEPROC_TYPE(fp) != FTYPE_GUARDED)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-type">struct</span> guarded_fileproc *gfp = FP_TO_GFP(fp);

		<span class="enscript-keyword">if</span> (GUARDED_FILEPROC_MAGIC != gfp-&gt;gf_magic)
			panic(<span class="enscript-string">&quot;%s: corrupt gfp %p flags %x&quot;</span>,
			    __func__, gfp, fp-&gt;f_flags);

		<span class="enscript-keyword">if</span> (gfp-&gt;gf_thread == t) {
			mach_exception_data_type_t code, subcode;

			gfp-&gt;gf_thread = NULL;

			<span class="enscript-comment">/*
			 * EXC_GUARD exception code namespace.
			 *
			 * code:
			 * +-------------------------------------------------+
			 * | [63:61] guard type | [60:0] guard-specific data |
			 * +-------------------------------------------------+
			 *
			 * subcode:
			 * +-------------------------------------------------+
			 * |       [63:0] guard-specific data                |
			 * +-------------------------------------------------+
			 *
			 * At the moment, we have just one guard type: file
			 * descriptor guards.
			 *
			 * File descriptor guards use the exception codes like
			 * so:
			 *
			 * code:			 
			 * +--------------------------------------------------+
			 * |[63:61] GUARD_TYPE_FD | [60:32] flavor | [31:0] fd|
			 * +--------------------------------------------------+
			 *
			 * subcode:
			 * +--------------------------------------------------+
			 * |       [63:0] guard value                         |
			 * +--------------------------------------------------+
			 */</span>
			code = (((uint64_t)GUARD_TYPE_FD) &lt;&lt; 61) |
			       (((uint64_t)gfp-&gt;gf_exc_code) &lt;&lt; 32) |
			       ((uint64_t)gfp-&gt;gf_exc_fd);
			subcode = gfp-&gt;gf_guard;
			proc_fdunlock(p);

			(<span class="enscript-type">void</span>) task_exception_notify(EXC_GUARD, code, subcode);
			psignal(p, SIGKILL);

			<span class="enscript-keyword">return</span>;
		}
	}
	proc_fdunlock(p);
}

<span class="enscript-comment">/*
 * Experimental guarded file descriptor SPIs
 */</span>

<span class="enscript-comment">/*
 * int guarded_open_np(const char *pathname, int flags,
 *     const guardid_t *guard, u_int guardflags, ...);
 *
 * In this initial implementation, GUARD_DUP must be specified.
 * GUARD_CLOSE, GUARD_SOCKET_IPC and GUARD_FILEPORT are optional.
 *
 * If GUARD_DUP wasn't specified, then we'd have to do the (extra) work
 * to allow dup-ing a descriptor to inherit the guard onto the new
 * descriptor.  (Perhaps GUARD_DUP behaviours should just always be true
 * for a guarded fd?  Or, more sanely, all the dup operations should
 * just always propagate the guard?)
 *
 * Guarded descriptors are always close-on-exec, and GUARD_CLOSE
 * requires close-on-fork; O_CLOEXEC must be set in flags.
 * This setting is immutable; attempts to clear the flag will
 * cause a guard exception.
 *
 * XXX	It's somewhat broken that change_fdguard_np() can completely
 *	remove the guard and thus revoke down the immutability
 *	promises above.  Ick.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">guarded_open_np</span>(proc_t p, <span class="enscript-type">struct</span> guarded_open_np_args *uap, int32_t *retval)
{
	<span class="enscript-keyword">if</span> ((uap-&gt;flags &amp; O_CLOEXEC) == 0)
		<span class="enscript-keyword">return</span> (EINVAL);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GUARD_REQUIRED</span> (GUARD_DUP)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">GUARD_ALL</span>      (GUARD_REQUIRED |	\
			(GUARD_CLOSE | GUARD_SOCKET_IPC | GUARD_FILEPORT | GUARD_WRITE))

	<span class="enscript-keyword">if</span> (((uap-&gt;guardflags &amp; GUARD_REQUIRED) != GUARD_REQUIRED) ||
	    ((uap-&gt;guardflags &amp; ~GUARD_ALL) != 0))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> gfp_crarg crarg = {
		.gca_attrs = uap-&gt;guardflags
	};

	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;guard,
	    &amp;(crarg.gca_guard), <span class="enscript-keyword">sizeof</span> (crarg.gca_guard))) != 0)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * Disallow certain guard values -- is zero enough?
	 */</span>
	<span class="enscript-keyword">if</span> (crarg.gca_guard == 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">struct</span> nameidata nd;
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">int</span> cmode;

	VATTR_INIT(&amp;va);
	cmode = ((uap-&gt;mode &amp; ~fdp-&gt;fd_cmask) &amp; ALLPERMS) &amp; ~S_ISTXT;
	VATTR_SET(&amp;va, va_mode, cmode &amp; ACCESSPERMS);

	NDINIT(&amp;nd, LOOKUP, OP_OPEN, FOLLOW | AUDITVNPATH1, UIO_USERSPACE,
	       uap-&gt;path, ctx);

	<span class="enscript-keyword">return</span> (open1(ctx, &amp;nd, uap-&gt;flags | O_CLOFORK, &amp;va,
	    guarded_fileproc_alloc_init, &amp;crarg, retval));
}

<span class="enscript-comment">/*
 * int guarded_open_dprotected_np(const char *pathname, int flags,
 *     const guardid_t *guard, u_int guardflags, int dpclass, int dpflags, ...);
 *
 * This SPI is extension of guarded_open_np() to include dataprotection class on creation
 * in &quot;dpclass&quot; and dataprotection flags 'dpflags'. Otherwise behaviors are same as in
 * guarded_open_np()
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">guarded_open_dprotected_np</span>(proc_t p, <span class="enscript-type">struct</span> guarded_open_dprotected_np_args *uap, int32_t *retval)
{
	<span class="enscript-keyword">if</span> ((uap-&gt;flags &amp; O_CLOEXEC) == 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (((uap-&gt;guardflags &amp; GUARD_REQUIRED) != GUARD_REQUIRED) ||
	    ((uap-&gt;guardflags &amp; ~GUARD_ALL) != 0))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> gfp_crarg crarg = {
		.gca_attrs = uap-&gt;guardflags
	};

	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;guard,
	    &amp;(crarg.gca_guard), <span class="enscript-keyword">sizeof</span> (crarg.gca_guard))) != 0)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-comment">/*
	 * Disallow certain guard values -- is zero enough?
	 */</span>
	<span class="enscript-keyword">if</span> (crarg.gca_guard == 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-type">struct</span> filedesc *fdp = p-&gt;p_fd;
	<span class="enscript-type">struct</span> vnode_attr va;
	<span class="enscript-type">struct</span> nameidata nd;
	vfs_context_t ctx = vfs_context_current();
	<span class="enscript-type">int</span> cmode;

	VATTR_INIT(&amp;va);
	cmode = ((uap-&gt;mode &amp; ~fdp-&gt;fd_cmask) &amp; ALLPERMS) &amp; ~S_ISTXT;
	VATTR_SET(&amp;va, va_mode, cmode &amp; ACCESSPERMS);

	NDINIT(&amp;nd, LOOKUP, OP_OPEN, FOLLOW | AUDITVNPATH1, UIO_USERSPACE,
	       uap-&gt;path, ctx);

	<span class="enscript-comment">/* 
	 * Initialize the extra fields in vnode_attr to pass down dataprotection 
	 * extra fields.
	 * 1. target cprotect class.
	 * 2. set a flag to mark it as requiring open-raw-encrypted semantics. 
	 */</span> 
	<span class="enscript-keyword">if</span> (uap-&gt;flags &amp; O_CREAT) {	
		VATTR_SET(&amp;va, va_dataprotect_class, uap-&gt;dpclass);
	}
	
	<span class="enscript-keyword">if</span> (uap-&gt;dpflags &amp; (O_DP_GETRAWENCRYPTED|O_DP_GETRAWUNENCRYPTED)) {
		<span class="enscript-keyword">if</span> ( uap-&gt;flags &amp; (O_RDWR | O_WRONLY)) {
			<span class="enscript-comment">/* Not allowed to write raw encrypted bytes */</span>
			<span class="enscript-keyword">return</span> EINVAL;		
		}			
		<span class="enscript-keyword">if</span> (uap-&gt;dpflags &amp; O_DP_GETRAWENCRYPTED) {
		    VATTR_SET(&amp;va, va_dataprotect_flags, VA_DP_RAWENCRYPTED);
		}
		<span class="enscript-keyword">if</span> (uap-&gt;dpflags &amp; O_DP_GETRAWUNENCRYPTED) {
		    VATTR_SET(&amp;va, va_dataprotect_flags, VA_DP_RAWUNENCRYPTED);
		}
	}

	<span class="enscript-keyword">return</span> (open1(ctx, &amp;nd, uap-&gt;flags | O_CLOFORK, &amp;va,
	    guarded_fileproc_alloc_init, &amp;crarg, retval));
}

<span class="enscript-comment">/*
 * int guarded_kqueue_np(const guardid_t *guard, u_int guardflags);
 *
 * Create a guarded kqueue descriptor with guardid and guardflags.
 *
 * Same restrictions on guardflags as for guarded_open_np().
 * All kqueues are -always- close-on-exec and close-on-fork by themselves
 * and are not sendable.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">guarded_kqueue_np</span>(proc_t p, <span class="enscript-type">struct</span> guarded_kqueue_np_args *uap, int32_t *retval)
{
	<span class="enscript-keyword">if</span> (((uap-&gt;guardflags &amp; GUARD_REQUIRED) != GUARD_REQUIRED) ||
	    ((uap-&gt;guardflags &amp; ~GUARD_ALL) != 0))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> gfp_crarg crarg = {
		.gca_attrs = uap-&gt;guardflags
	};

	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;guard,
	    &amp;(crarg.gca_guard), <span class="enscript-keyword">sizeof</span> (crarg.gca_guard))) != 0)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (crarg.gca_guard == 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (kqueue_body(p, guarded_fileproc_alloc_init, &amp;crarg, retval));
}

<span class="enscript-comment">/*
 * int guarded_close_np(int fd, const guardid_t *guard);
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">guarded_close_np</span>(proc_t p, <span class="enscript-type">struct</span> guarded_close_np_args *uap,
    __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> guarded_fileproc *gfp;
	<span class="enscript-type">int</span> fd = uap-&gt;fd;
	<span class="enscript-type">int</span> error;
	guardid_t uguard;

	AUDIT_SYSCLOSE(p, fd);

	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;guard, &amp;uguard, <span class="enscript-keyword">sizeof</span> (uguard))) != 0)
		<span class="enscript-keyword">return</span> (error);

	proc_fdlock(p);
	<span class="enscript-keyword">if</span> ((error = fp_lookup_guarded(p, fd, uguard, &amp;gfp, 1)) != 0) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (error);
	}
	error = close_internal_locked(p, fd, GFP_TO_FP(gfp), 0);
	proc_fdunlock(p);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * int
 * change_fdguard_np(int fd, const guardid_t *guard, u_int guardflags,
 *    const guardid_t *nguard, u_int nguardflags, int *fdflagsp);
 *
 * Given a file descriptor, atomically exchange &lt;guard, guardflags&gt; for
 * a new guard &lt;nguard, nguardflags&gt;, returning the previous fd
 * flags (see fcntl:F_SETFD) in *fdflagsp.
 *
 * This syscall can be used to either (a) add a new guard to an existing
 * unguarded file descriptor (b) remove the old guard from an existing
 * guarded file descriptor or (c) change the guard (guardid and/or
 * guardflags) on a guarded file descriptor.
 *
 * If 'guard' is NULL, fd must be unguarded at entry. If the call completes
 * successfully the fd will be guarded with &lt;nguard, nguardflags&gt;.
 *
 * Guarding a file descriptor has some side-effects on the &quot;fdflags&quot;
 * associated with the descriptor - in particular FD_CLOEXEC is
 * forced ON unconditionally, and FD_CLOFORK is forced ON by GUARD_CLOSE.
 * Callers who wish to subsequently restore the state of the fd should save
 * the value of *fdflagsp after a successful invocation.
 *
 * If 'nguard' is NULL, fd must be guarded at entry, &lt;guard, guardflags&gt;
 * must match with what's already guarding the descriptor, and the
 * result will be to completely remove the guard.  Note also that the
 * fdflags are copied to the descriptor from the incoming *fdflagsp argument. 
 *
 * If the descriptor is guarded, and neither 'guard' nor 'nguard' is NULL
 * and &lt;guard, guardflags&gt; matches what's already guarding the descriptor,
 * then &lt;nguard, nguardflags&gt; becomes the new guard.  In this case, even if
 * the GUARD_CLOSE flag is being cleared, it is still possible to continue
 * to keep FD_CLOFORK on the descriptor by passing FD_CLOFORK via fdflagsp.
 *
 * (File descriptors whose underlying fileglobs are marked FG_CONFINED are
 * still close-on-fork, regardless of the setting of FD_CLOFORK.)
 *
 * Example 1: Guard an unguarded descriptor during a set of operations,
 * then restore the original state of the descriptor.
 *
 * int sav_flags = 0;
 * change_fdguard_np(fd, NULL, 0, &amp;myguard, GUARD_CLOSE, &amp;sav_flags);
 * // do things with now guarded 'fd'
 * change_fdguard_np(fd, &amp;myguard, GUARD_CLOSE, NULL, 0, &amp;sav_flags);
 * // fd now unguarded.
 *
 * Example 2: Change the guard of a guarded descriptor during a set of
 * operations, then restore the original state of the descriptor.
 *
 * int sav_flags = (gdflags &amp; GUARD_CLOSE) ? FD_CLOFORK : 0;
 * change_fdguard_np(fd, &amp;gd, gdflags, &amp;myguard, GUARD_CLOSE, &amp;sav_flags);
 * // do things with 'fd' with a different guard
 * change_fdguard_np(fd, &amp;myg, GUARD_CLOSE, &amp;gd, gdflags, &amp;sav_flags);
 * // back to original guarded state
 *
 * XXX	This SPI is too much of a chainsaw and should be revised.
 */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">change_fdguard_np</span>(proc_t p, <span class="enscript-type">struct</span> change_fdguard_np_args *uap,
    __unused int32_t *retval)
{
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">int</span> fd = uap-&gt;fd;
	<span class="enscript-type">int</span> error;
	guardid_t oldg = 0, newg = 0;
	<span class="enscript-type">int</span> nfdflags = 0;

	<span class="enscript-keyword">if</span> (0 != uap-&gt;guard &amp;&amp;
	    0 != (error = copyin(uap-&gt;guard, &amp;oldg, <span class="enscript-keyword">sizeof</span> (oldg))))
		<span class="enscript-keyword">return</span> (error); <span class="enscript-comment">/* can't copyin current guard */</span>

	<span class="enscript-keyword">if</span> (0 != uap-&gt;nguard &amp;&amp;
	    0 != (error = copyin(uap-&gt;nguard, &amp;newg, <span class="enscript-keyword">sizeof</span> (newg))))
		<span class="enscript-keyword">return</span> (error); <span class="enscript-comment">/* can't copyin new guard */</span>

	<span class="enscript-keyword">if</span> (0 != uap-&gt;fdflagsp &amp;&amp;
	    0 != (error = copyin(uap-&gt;fdflagsp, &amp;nfdflags, <span class="enscript-keyword">sizeof</span> (nfdflags))))
		<span class="enscript-keyword">return</span> (error); <span class="enscript-comment">/* can't copyin new fdflags */</span>
	    
	proc_fdlock(p);
<span class="enscript-reference">restart</span>:
	<span class="enscript-keyword">if</span> ((error = fp_lookup(p, fd, &amp;fp, 1)) != 0) {
		proc_fdunlock(p);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> (0 != uap-&gt;fdflagsp) {
		<span class="enscript-type">int</span> ofdflags = FDFLAGS_GET(p, fd);
		<span class="enscript-type">int</span> ofl = ((ofdflags &amp; UF_EXCLOSE) ? FD_CLOEXEC : 0) |
			((ofdflags &amp; UF_FORKCLOSE) ? FD_CLOFORK : 0);
		proc_fdunlock(p);
		<span class="enscript-keyword">if</span> (0 != (error = copyout(&amp;ofl, uap-&gt;fdflagsp, <span class="enscript-keyword">sizeof</span> (ofl)))) {
			proc_fdlock(p);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropout</span>; <span class="enscript-comment">/* can't copyout old fdflags */</span>
		}
		proc_fdlock(p);
	}

	<span class="enscript-keyword">if</span> (FILEPROC_TYPE(fp) == FTYPE_GUARDED) {
		<span class="enscript-keyword">if</span> (0 == uap-&gt;guard || 0 == uap-&gt;guardflags)
			error = EINVAL; <span class="enscript-comment">/* missing guard! */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (0 == oldg)
			error = EPERM; <span class="enscript-comment">/* guardids cannot be zero */</span>
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (0 != uap-&gt;guard || 0 != uap-&gt;guardflags)
			error = EINVAL; <span class="enscript-comment">/* guard provided, but none needed! */</span>
	}

	<span class="enscript-keyword">if</span> (0 != error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropout</span>;

	<span class="enscript-keyword">if</span> (0 != uap-&gt;nguard) {
		<span class="enscript-comment">/*
		 * There's a new guard in town.
		 */</span>
		<span class="enscript-keyword">if</span> (0 == newg)
			error = EINVAL; <span class="enscript-comment">/* guards cannot contain zero */</span>
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (((uap-&gt;nguardflags &amp; GUARD_REQUIRED) != GUARD_REQUIRED) ||
		    ((uap-&gt;nguardflags &amp; ~GUARD_ALL) != 0))
			error = EINVAL; <span class="enscript-comment">/* must have valid attributes too */</span>
		<span class="enscript-keyword">if</span> (0 != error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropout</span>;

		<span class="enscript-keyword">if</span> (FILEPROC_TYPE(fp) == FTYPE_GUARDED) {
			<span class="enscript-comment">/*
			 * Replace old guard with new guard
			 */</span>
			<span class="enscript-type">struct</span> guarded_fileproc *gfp = FP_TO_GFP(fp);

			<span class="enscript-keyword">if</span> (GUARDED_FILEPROC_MAGIC != gfp-&gt;gf_magic)
				panic(<span class="enscript-string">&quot;%s: corrupt gfp %p flags %x&quot;</span>,
				      __func__, gfp, fp-&gt;f_flags);

			<span class="enscript-keyword">if</span> (oldg == gfp-&gt;gf_guard &amp;&amp;
			    uap-&gt;guardflags == gfp-&gt;gf_attrs) {
				<span class="enscript-comment">/*
				 * Must match existing guard + attributes
				 * before we'll swap them to new ones, managing
				 * fdflags &quot;side-effects&quot; as we go.   Note that
				 * userland can request FD_CLOFORK semantics.
				 */</span>
				<span class="enscript-keyword">if</span> (gfp-&gt;gf_attrs &amp; GUARD_CLOSE)
					FDFLAGS_CLR(p, fd, UF_FORKCLOSE);
				gfp-&gt;gf_guard = newg;
				gfp-&gt;gf_attrs = uap-&gt;nguardflags;
				<span class="enscript-keyword">if</span> (gfp-&gt;gf_attrs &amp; GUARD_CLOSE)
					FDFLAGS_SET(p, fd, UF_FORKCLOSE);
				FDFLAGS_SET(p, fd,
				    (nfdflags &amp; FD_CLOFORK) ? UF_FORKCLOSE : 0);
				<span class="enscript-comment">/* FG_CONFINED enforced regardless */</span>
			} <span class="enscript-keyword">else</span> {
				error = EPERM;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropout</span>;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Add a guard to a previously unguarded descriptor
			 */</span>
			<span class="enscript-keyword">switch</span> (FILEGLOB_DTYPE(fp-&gt;f_fglob)) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_VNODE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_PIPE</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_SOCKET</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">DTYPE_KQUEUE</span>:
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				error = ENOTSUP;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropout</span>;
			}

			proc_fdunlock(p);

			<span class="enscript-type">struct</span> gfp_crarg crarg = {
				.gca_guard = newg,
				.gca_attrs = uap-&gt;nguardflags
			};
			<span class="enscript-type">struct</span> fileproc *nfp =
				guarded_fileproc_alloc_init(&amp;crarg);
			<span class="enscript-type">struct</span> guarded_fileproc *gfp;

			proc_fdlock(p);

			<span class="enscript-keyword">switch</span> (error = fp_tryswap(p, fd, nfp)) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>: <span class="enscript-comment">/* guarded-ness comes with side-effects */</span>
				gfp = FP_TO_GFP(nfp);
				<span class="enscript-keyword">if</span> (gfp-&gt;gf_attrs &amp; GUARD_CLOSE)
					FDFLAGS_SET(p, fd, UF_FORKCLOSE);
				FDFLAGS_SET(p, fd, UF_EXCLOSE);
				(<span class="enscript-type">void</span>) fp_drop(p, fd, nfp, 1);
				fileproc_free(fp);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">EKEEPLOOKING</span>: <span class="enscript-comment">/* f_iocount indicates a collision */</span>
				(<span class="enscript-type">void</span>) fp_drop(p, fd, fp, 1);
				fileproc_free(nfp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
			<span class="enscript-reference">default</span>:
				(<span class="enscript-type">void</span>) fp_drop(p, fd, fp, 1);
				fileproc_free(nfp);
				<span class="enscript-keyword">break</span>;
			}
			proc_fdunlock(p);
			<span class="enscript-keyword">return</span> (error);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * No new guard.
		 */</span>
		<span class="enscript-keyword">if</span> (FILEPROC_TYPE(fp) == FTYPE_GUARDED) {
			<span class="enscript-comment">/*
			 * Remove the guard altogether.
			 */</span>
			<span class="enscript-type">struct</span> guarded_fileproc *gfp = FP_TO_GFP(fp);

			<span class="enscript-keyword">if</span> (0 != uap-&gt;nguardflags) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropout</span>;
			}

			<span class="enscript-keyword">if</span> (GUARDED_FILEPROC_MAGIC != gfp-&gt;gf_magic)
				panic(<span class="enscript-string">&quot;%s: corrupt gfp %p flags %x&quot;</span>,
				      __func__, gfp, fp-&gt;f_flags);

			<span class="enscript-keyword">if</span> (oldg != gfp-&gt;gf_guard ||
			    uap-&gt;guardflags != gfp-&gt;gf_attrs) {
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">dropout</span>;
			}

			proc_fdunlock(p);
			<span class="enscript-type">struct</span> fileproc *nfp = fileproc_alloc_init(NULL);
			proc_fdlock(p);

			<span class="enscript-keyword">switch</span> (error = fp_tryswap(p, fd, nfp)) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>: <span class="enscript-comment">/* undo side-effects of guarded-ness */</span>
				FDFLAGS_CLR(p, fd, UF_FORKCLOSE | UF_EXCLOSE);
				FDFLAGS_SET(p, fd,
				    (nfdflags &amp; FD_CLOFORK) ? UF_FORKCLOSE : 0);
				<span class="enscript-comment">/* FG_CONFINED enforced regardless */</span>
				FDFLAGS_SET(p, fd,
				    (nfdflags &amp; FD_CLOEXEC) ? UF_EXCLOSE : 0);
				(<span class="enscript-type">void</span>) fp_drop(p, fd, nfp, 1);
				fileproc_free(fp);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">EKEEPLOOKING</span>: <span class="enscript-comment">/* f_iocount indicates collision */</span>
				(<span class="enscript-type">void</span>) fp_drop(p, fd, fp, 1);
				fileproc_free(nfp);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
			<span class="enscript-reference">default</span>:
				(<span class="enscript-type">void</span>) fp_drop(p, fd, fp, 1);
				fileproc_free(nfp);
				<span class="enscript-keyword">break</span>;
			}
			proc_fdunlock(p);
			<span class="enscript-keyword">return</span> (error);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Not already guarded, and no new guard?
			 */</span>
			error = EINVAL;
		}
	}

<span class="enscript-reference">dropout</span>:
	(<span class="enscript-type">void</span>) fp_drop(p, fd, fp, 1);
	proc_fdunlock(p);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * user_ssize_t guarded_write_np(int fd, const guardid_t *guard,
 *                          user_addr_t cbuf, user_ssize_t nbyte);
 *
 * Initial implementation of guarded writes.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">guarded_write_np</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> guarded_write_np_args *uap, user_ssize_t *retval)
{
	<span class="enscript-type">int</span> error;      
	<span class="enscript-type">int</span> fd = uap-&gt;fd;
	guardid_t uguard;
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">struct</span> guarded_fileproc *gfp;
	bool wrote_some = false;

	AUDIT_ARG(fd, fd);

	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;guard, &amp;uguard, <span class="enscript-keyword">sizeof</span> (uguard))) != 0)
		<span class="enscript-keyword">return</span> (error);

	error = fp_lookup_guarded(p, fd, uguard, &amp;gfp, 0);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span>(error);

	fp = GFP_TO_FP(gfp);
	<span class="enscript-keyword">if</span> ((fp-&gt;f_flag &amp; FWRITE) == 0) {
		error = EBADF;
	} <span class="enscript-keyword">else</span> {

		<span class="enscript-type">struct</span> vfs_context context = *(vfs_context_current());
		context.vc_ucred = fp-&gt;f_fglob-&gt;fg_cred;

		error = dofilewrite(&amp;context, fp, uap-&gt;cbuf, uap-&gt;nbyte,
			(off_t)-1, 0, retval);
		wrote_some = *retval &gt; 0;
	}
	<span class="enscript-keyword">if</span> (wrote_some)
	        fp_drop_written(p, fd, fp);
	<span class="enscript-keyword">else</span>
	        fp_drop(p, fd, fp, 0);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * user_ssize_t guarded_pwrite_np(int fd, const guardid_t *guard,
 *                        user_addr_t buf, user_size_t nbyte, off_t offset);
 *
 * Initial implementation of guarded pwrites.
 */</span>
 <span class="enscript-type">int</span>
 guarded_pwrite_np(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> guarded_pwrite_np_args *uap, user_ssize_t *retval)
 {
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">int</span> error; 
	<span class="enscript-type">int</span> fd = uap-&gt;fd;
	vnode_t vp  = (vnode_t)0;
	guardid_t uguard;
	<span class="enscript-type">struct</span> guarded_fileproc *gfp;
	bool wrote_some = false;

	AUDIT_ARG(fd, fd);

	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;guard, &amp;uguard, <span class="enscript-keyword">sizeof</span> (uguard))) != 0)
		<span class="enscript-keyword">return</span> (error);

	error = fp_lookup_guarded(p, fd, uguard, &amp;gfp, 0);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span>(error);

	fp = GFP_TO_FP(gfp);
	<span class="enscript-keyword">if</span> ((fp-&gt;f_flag &amp; FWRITE) == 0) {
		error = EBADF;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> vfs_context context = *vfs_context_current();
		context.vc_ucred = fp-&gt;f_fglob-&gt;fg_cred;

		<span class="enscript-keyword">if</span> (fp-&gt;f_type != DTYPE_VNODE) {
			error = ESPIPE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">errout</span>;
		}
		vp = (vnode_t)fp-&gt;f_fglob-&gt;fg_data;
		<span class="enscript-keyword">if</span> (vnode_isfifo(vp)) {
			error = ESPIPE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">errout</span>;
		} 
		<span class="enscript-keyword">if</span> ((vp-&gt;v_flag &amp; VISTTY)) {
			error = ENXIO;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">errout</span>;
		}
		<span class="enscript-keyword">if</span> (uap-&gt;offset == (off_t)-1) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">errout</span>;
		}

		error = dofilewrite(&amp;context, fp, uap-&gt;buf, uap-&gt;nbyte,
			uap-&gt;offset, FOF_OFFSET, retval);
		wrote_some = *retval &gt; 0;
	}
<span class="enscript-reference">errout</span>:
	<span class="enscript-keyword">if</span> (wrote_some)
	        fp_drop_written(p, fd, fp);
	<span class="enscript-keyword">else</span>
	        fp_drop(p, fd, fp, 0);

	KERNEL_DEBUG_CONSTANT((BSDDBG_CODE(DBG_BSD_SC_EXTENDED_INFO, SYS_guarded_pwrite_np) | DBG_FUNC_NONE),
	      uap-&gt;fd, uap-&gt;nbyte, (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)((uap-&gt;offset &gt;&gt; 32)), (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(uap-&gt;offset), 0);
	
        <span class="enscript-keyword">return</span>(error);
}

<span class="enscript-comment">/*
 * user_ssize_t guarded_writev_np(int fd, const guardid_t *guard,
 *                                   struct iovec *iovp, u_int iovcnt);
 *
 * Initial implementation of guarded writev.
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">guarded_writev_np</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> guarded_writev_np_args *uap, user_ssize_t *retval)
{
	uio_t auio = NULL;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> fileproc *fp;
	<span class="enscript-type">struct</span> user_iovec *iovp;
	guardid_t uguard;
	<span class="enscript-type">struct</span> guarded_fileproc *gfp;
	bool wrote_some = false;

	AUDIT_ARG(fd, uap-&gt;fd);

	<span class="enscript-comment">/* Verify range bedfore calling uio_create() */</span>
	<span class="enscript-keyword">if</span> (uap-&gt;iovcnt &lt;= 0 || uap-&gt;iovcnt &gt; UIO_MAXIOV)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* allocate a uio large enough to hold the number of iovecs passed */</span>
	auio = uio_create(uap-&gt;iovcnt, 0,
				  (IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32),
				  UIO_WRITE);
				  
	<span class="enscript-comment">/* get location of iovecs within the uio.  then copyin the iovecs from
	 * user space.
	 */</span>
	iovp = uio_iovsaddr(auio);
	<span class="enscript-keyword">if</span> (iovp == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;
	}
	error = copyin_user_iovec_array(uap-&gt;iovp,
		IS_64BIT_PROCESS(p) ? UIO_USERSPACE64 : UIO_USERSPACE32,
		uap-&gt;iovcnt, iovp);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;
	}
	
	<span class="enscript-comment">/* finalize uio_t for use and do the IO 
	 */</span>
	error = uio_calculateresid(auio);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;
	}

	<span class="enscript-keyword">if</span> ((error = copyin(uap-&gt;guard, &amp;uguard, <span class="enscript-keyword">sizeof</span> (uguard))) != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;

	error = fp_lookup_guarded(p, uap-&gt;fd, uguard, &amp;gfp, 0);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">ExitThisRoutine</span>;

	fp = GFP_TO_FP(gfp);
	<span class="enscript-keyword">if</span> ((fp-&gt;f_flag &amp; FWRITE) == 0) {
		error = EBADF;
	} <span class="enscript-keyword">else</span> {
		error = wr_uio(p, fp, auio, retval);
		wrote_some = *retval &gt; 0;
	}
	
	<span class="enscript-keyword">if</span> (wrote_some)
	        fp_drop_written(p, uap-&gt;fd, fp);
	<span class="enscript-keyword">else</span>
	        fp_drop(p, uap-&gt;fd, fp, 0);
<span class="enscript-reference">ExitThisRoutine</span>:
	<span class="enscript-keyword">if</span> (auio != NULL) {
		uio_free(auio);
	}
	<span class="enscript-keyword">return</span> (error);
}
</pre>
<hr />
</body></html>