<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_fork.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_fork.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2007, 2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995, 1997 Apple Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)kern_fork.c	8.8 (Berkeley) 2/14/95
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/acct.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/codesign.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
<span class="enscript-comment">/* Do not include dtrace.h, it redefines kmem_[alloc/free] */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_fasttrap_fork</span>(proc_t, proc_t);
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_helpers_fork)(proc_t, proc_t);
<span class="enscript-type">extern</span> <span class="enscript-function-name">void</span> (*dtrace_proc_waitfor_exec_ptr)(proc_t);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dtrace_lazy_dofs_duplicate</span>(proc_t, proc_t);

<span class="enscript-comment">/*
 * Since dtrace_proc_waitfor_exec_ptr can be added/removed in dtrace_subr.c,
 * we will store its value before actually calling it.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">void</span> (*dtrace_proc_waitfor_hook)(proc_t) = NULL;

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/dtrace_ptss.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/coalition.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread_call.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/spl.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_mach_internal.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_shared_region.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/shm_internal.h&gt;</span>	<span class="enscript-comment">/* for shmfork() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>		<span class="enscript-comment">/* for thread_create() */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_act.h&gt;</span>	<span class="enscript-comment">/* for thread_resume() */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sdt.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_memorystatus.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* XXX routines which should have Mach prototypes, but don't */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">thread_set_parent</span>(thread_t parent, <span class="enscript-type">int</span> pid);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">act_thread_catt</span>(<span class="enscript-type">void</span> *ctx);
<span class="enscript-type">void</span> <span class="enscript-function-name">thread_set_child</span>(thread_t child, <span class="enscript-type">int</span> pid);
<span class="enscript-type">void</span> *<span class="enscript-function-name">act_thread_csave</span>(<span class="enscript-type">void</span>);


thread_t <span class="enscript-function-name">cloneproc</span>(task_t, coalition_t *, proc_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
proc_t <span class="enscript-function-name">forkproc</span>(proc_t);
<span class="enscript-type">void</span> <span class="enscript-function-name">forkproc_free</span>(proc_t);
thread_t <span class="enscript-function-name">fork_create_child</span>(task_t parent_task, coalition_t *parent_coalitions, proc_t child, <span class="enscript-type">int</span> inherit_memory, <span class="enscript-type">int</span> is64bit);
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_vfork_begin</span>(proc_t parent_proc);
<span class="enscript-type">void</span> <span class="enscript-function-name">proc_vfork_end</span>(proc_t parent_proc);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOFORK</span>	0x1	<span class="enscript-comment">/* fork() system call */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DOVFORK</span>	0x2	<span class="enscript-comment">/* vfork() system call */</span>

<span class="enscript-comment">/*
 * proc_vfork_begin
 *
 * Description:	start a vfork on a process
 *
 * Parameters:	parent_proc		process (re)entering vfork state
 *
 * Returns:	(void)
 *
 * Notes:	Although this function increments a count, a count in
 *		excess of 1 is not currently supported.  According to the
 *		POSIX standard, calling anything other than execve() or
 *		_exit() following a vfork(), including calling vfork()
 *		itself again, will result in undefined behaviour
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_vfork_begin</span>(proc_t parent_proc)
{
	proc_lock(parent_proc);
	parent_proc-&gt;p_lflag  |= P_LVFORK;
	parent_proc-&gt;p_vforkcnt++;
	proc_unlock(parent_proc);
}

<span class="enscript-comment">/*
 * proc_vfork_end
 *
 * Description:	stop a vfork on a process
 *
 * Parameters:	parent_proc		process leaving vfork state
 *
 * Returns:	(void)
 *
 * Notes:	Decrements the count; currently, reentrancy of vfork()
 *		is unsupported on the current process
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_vfork_end</span>(proc_t parent_proc)
{
	proc_lock(parent_proc);
	parent_proc-&gt;p_vforkcnt--;
	<span class="enscript-keyword">if</span> (parent_proc-&gt;p_vforkcnt &lt; 0)
		panic(<span class="enscript-string">&quot;vfork cnt is -ve&quot;</span>);
	<span class="enscript-keyword">if</span> (parent_proc-&gt;p_vforkcnt == 0)
		parent_proc-&gt;p_lflag  &amp;= ~P_LVFORK;
	proc_unlock(parent_proc);
}


<span class="enscript-comment">/*
 * vfork
 *
 * Description:	vfork system call
 *
 * Parameters:	void			[no arguments]
 *
 * Retval:	0			(to child process)
 *		!0			pid of child (to parent process)
 *		-1			error (see &quot;Returns:&quot;)
 *
 * Returns:	EAGAIN			Administrative limit reached
 *		EINVAL			vfork() called during vfork()
 *		ENOMEM			Failed to allocate new process
 *
 * Note:	After a successful call to this function, the parent process
 *		has its task, thread, and uthread lent to the child process,
 *		and control is returned to the caller; if this function is
 *		invoked as a system call, the return is to user space, and
 *		is effectively running on the child process.
 *
 *		Subsequent calls that operate on process state are permitted,
 *		though discouraged, and will operate on the child process; any
 *		operations on the task, thread, or uthread will result in
 *		changes in the parent state, and, if inheritable, the child
 *		state, when a task, thread, and uthread are realized for the
 *		child process at execve() time, will also be effected.  Given
 *		this, it's recemmended that people use the posix_spawn() call
 *		instead.
 *
 * BLOCK DIAGRAM OF VFORK
 *
 * Before:
 *
 *     ,----------------.         ,-------------.
 *     |                |   task  |             |
 *     | parent_thread  | ------&gt; | parent_task |
 *     |                | &lt;.list. |             |
 *     `----------------'         `-------------'
 *    uthread |  ^             bsd_info |  ^
 *            v  | vc_thread            v  | task
 *     ,----------------.         ,-------------.
 *     |                |         |             |
 *     | parent_uthread | &lt;.list. | parent_proc | &lt;-- current_proc()
 *     |                |         |             |
 *     `----------------'         `-------------'
 *    uu_proc |
 *            v
 *           NULL
 *
 * After:
 *
 *                 ,----------------.         ,-------------.
 *                 |                |   task  |             |
 *          ,----&gt; | parent_thread  | ------&gt; | parent_task |
 *          |      |                | &lt;.list. |             |
 *          |      `----------------'         `-------------'
 *          |     uthread |  ^             bsd_info |  ^
 *          |             v  | vc_thread            v  | task
 *          |      ,----------------.         ,-------------.
 *          |      |                |         |             |
 *          |      | parent_uthread | &lt;.list. | parent_proc |
 *          |      |                |         |             |
 *          |      `----------------'         `-------------'
 *          |     uu_proc |  . list
 *          |             v  v
 *          |      ,----------------.
 *          `----- |                |
 *      p_vforkact | child_proc     | &lt;-- current_proc()
 *                 |                |
 *                 `----------------'
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">vfork</span>(proc_t parent_proc, __unused <span class="enscript-type">struct</span> vfork_args *uap, int32_t *retval)
{
	thread_t child_thread;
	<span class="enscript-type">int</span> err;

	<span class="enscript-keyword">if</span> ((err = fork1(parent_proc, &amp;child_thread, PROC_CREATE_VFORK, NULL)) != 0) {
		retval[1] = 0;
	} <span class="enscript-keyword">else</span> {
		uthread_t ut = get_bsdthread_info(current_thread());
		proc_t child_proc = ut-&gt;uu_proc;

		retval[0] = child_proc-&gt;p_pid;
		retval[1] = 1;		<span class="enscript-comment">/* flag child return for user space */</span>

		<span class="enscript-comment">/*
		 * Drop the signal lock on the child which was taken on our
		 * behalf by forkproc()/cloneproc() to prevent signals being
		 * received by the child in a partially constructed state.
		 */</span>
		proc_signalend(child_proc, 0);
		proc_transend(child_proc, 0);

		proc_knote(parent_proc, NOTE_FORK | child_proc-&gt;p_pid);
		DTRACE_PROC1(create, proc_t, child_proc);
		ut-&gt;uu_flag &amp;= ~UT_VFORKING;
	}

	<span class="enscript-keyword">return</span> (err);
}


<span class="enscript-comment">/*
 * fork1
 *
 * Description:	common code used by all new process creation other than the
 *		bootstrap of the initial process on the system
 *
 * Parameters: parent_proc		parent process of the process being
 *		child_threadp		pointer to location to receive the
 *					Mach thread_t of the child process
 *					breated
 *		kind			kind of creation being requested
 *		coalitions		if spawn, the set of coalitions the
 *					child process should join, or NULL to
 *					inherit the parent's. On non-spawns,
 *					this param is ignored and the child
 *					always inherits the parent's
 *					coalitions.
 *
 * Notes:	Permissable values for 'kind':
 *
 *		PROC_CREATE_FORK	Create a complete process which will
 *					return actively running in both the
 *					parent and the child; the child copies
 *					the parent address space.
 *		PROC_CREATE_SPAWN	Create a complete process which will
 *					return actively running in the parent
 *					only after returning actively running
 *					in the child; the child address space
 *					is newly created by an image activator,
 *					after which the child is run.
 *		PROC_CREATE_VFORK	Creates a partial process which will
 *					borrow the parent task, thread, and
 *					uthread to return running in the child;
 *					the child address space and other parts
 *					are lazily created at execve() time, or
 *					the child is terminated, and the parent
 *					does not actively run until that
 *					happens.
 *
 *		At first it may seem strange that we return the child thread
 *		address rather than process structure, since the process is
 *		the only part guaranteed to be &quot;new&quot;; however, since we do
 *		not actualy adjust other references between Mach and BSD (see
 *		the block diagram above the implementation of vfork()), this
 *		is the only method which guarantees us the ability to get
 *		back to the other information.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fork1</span>(proc_t parent_proc, thread_t *child_threadp, <span class="enscript-type">int</span> kind, coalition_t *coalitions)
{
	thread_t parent_thread = (thread_t)current_thread();
	uthread_t parent_uthread = (uthread_t)get_bsdthread_info(parent_thread);
	proc_t child_proc = NULL;	<span class="enscript-comment">/* set in switch, but compiler... */</span>
	thread_t child_thread = NULL;
	uid_t uid;
	<span class="enscript-type">int</span> count;
	<span class="enscript-type">int</span> err = 0;
	<span class="enscript-type">int</span> spawn = 0;

	<span class="enscript-comment">/*
	 * Although process entries are dynamically created, we still keep
	 * a global limit on the maximum number we will create.  Don't allow
	 * a nonprivileged user to use the last process; don't let root
	 * exceed the limit. The variable nprocs is the current number of
	 * processes, maxproc is the limit.
	 */</span>
	uid = kauth_getruid();
	proc_list_lock();
	<span class="enscript-keyword">if</span> ((nprocs &gt;= maxproc - 1 &amp;&amp; uid != 0) || nprocs &gt;= maxproc) {
		proc_list_unlock();
		tablefull(<span class="enscript-string">&quot;proc&quot;</span>);
		<span class="enscript-keyword">return</span> (EAGAIN);
	}
	proc_list_unlock();

	<span class="enscript-comment">/*
	 * Increment the count of procs running with this uid. Don't allow
	 * a nonprivileged user to exceed their current limit, which is
	 * always less than what an rlim_t can hold.
	 * (locking protection is provided by list lock held in chgproccnt)
	 */</span>

	count = chgproccnt(uid, 1);
	<span class="enscript-keyword">if</span> (uid != 0 &amp;&amp;
	    (rlim_t)count &gt; parent_proc-&gt;p_rlimit[RLIMIT_NPROC].rlim_cur) {
	    	err = EAGAIN;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/*
	 * Determine if MAC policies applied to the process will allow
	 * it to fork.  This is an advisory-only check.
	 */</span>
	err = mac_proc_check_fork(parent_proc);
	<span class="enscript-keyword">if</span> (err  != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">switch</span>(kind) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_CREATE_VFORK</span>:
		<span class="enscript-comment">/*
		 * Prevent a vfork while we are in vfork(); we should
		 * also likely preventing a fork here as well, and this
		 * check should then be outside the switch statement,
		 * since the proc struct contents will copy from the
		 * child and the tash/thread/uthread from the parent in
		 * that case.  We do not support vfork() in vfork()
		 * because we don't have to; the same non-requirement
		 * is true of both fork() and posix_spawn() and any
		 * call  other than execve() amd _exit(), but we've
		 * been historically lenient, so we continue to be so
		 * (for now).
		 *
		 * &lt;rdar://6640521&gt; Probably a source of random panics
		 */</span>
		<span class="enscript-keyword">if</span> (parent_uthread-&gt;uu_flag &amp; UT_VFORK) {
			printf(<span class="enscript-string">&quot;fork1 called within vfork by %s\n&quot;</span>, parent_proc-&gt;p_comm);
			err = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

		<span class="enscript-comment">/*
		 * Flag us in progress; if we chose to support vfork() in
		 * vfork(), we would chain our parent at this point (in
		 * effect, a stack push).  We don't, since we actually want
		 * to disallow everything not specified in the standard
		 */</span>
		proc_vfork_begin(parent_proc);

		<span class="enscript-comment">/* The newly created process comes with signal lock held */</span>
		<span class="enscript-keyword">if</span> ((child_proc = forkproc(parent_proc)) == NULL) {
			<span class="enscript-comment">/* Failed to allocate new process */</span>
			proc_vfork_end(parent_proc);
			err = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

<span class="enscript-comment">// XXX BEGIN: wants to move to be common code (and safe)
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-comment">/*
		 * allow policies to associate the credential/label that
		 * we referenced from the parent ... with the child
		 * JMM - this really isn't safe, as we can drop that
		 *       association without informing the policy in other
		 *       situations (keep long enough to get policies changed)
		 */</span>
		mac_cred_label_associate_fork(child_proc-&gt;p_ucred, child_proc);
#<span class="enscript-reference">endif</span>

		<span class="enscript-comment">/*
		 * Propogate change of PID - may get new cred if auditing.
		 *
		 * NOTE: This has no effect in the vfork case, since
		 *	child_proc-&gt;task != current_task(), but we duplicate it
		 *	because this is probably, ultimately, wrong, since we
		 *	will be running in the &quot;child&quot; which is the parent task
		 *	with the wrong token until we get to the execve() or
		 *	_exit() call; a lot of &quot;undefined&quot; can happen before
		 *	that.
		 *
		 * &lt;rdar://6640530&gt; disallow everything but exeve()/_exit()?
		 */</span>
		set_security_token(child_proc);

		AUDIT_ARG(pid, child_proc-&gt;p_pid);

<span class="enscript-comment">// XXX END: wants to move to be common code (and safe)
</span>
		<span class="enscript-comment">/*
		 * BORROW PARENT TASK, THREAD, UTHREAD FOR CHILD
		 *
		 * Note: this is where we would &quot;push&quot; state instead of setting
		 * it for nested vfork() support (see proc_vfork_end() for
		 * description if issues here).
		 */</span>
		child_proc-&gt;task = parent_proc-&gt;task;

		child_proc-&gt;p_lflag  |= P_LINVFORK;
		child_proc-&gt;p_vforkact = parent_thread;
		child_proc-&gt;p_stat = SRUN;

		<span class="enscript-comment">/*
		 * Until UT_VFORKING is cleared at the end of the vfork
		 * syscall, the process identity of this thread is slightly
		 * murky.
		 *
		 * As long as UT_VFORK and it's associated field (uu_proc)
		 * is set, current_proc() will always return the child process.
		 *
		 * However dtrace_proc_selfpid() returns the parent pid to
		 * ensure that e.g. the proc:::create probe actions accrue
		 * to the parent.  (Otherwise the child magically seems to
		 * have created itself!)
		 */</span>
		parent_uthread-&gt;uu_flag |= UT_VFORK | UT_VFORKING;
		parent_uthread-&gt;uu_proc = child_proc;
		parent_uthread-&gt;uu_userstate = (<span class="enscript-type">void</span> *)act_thread_csave();
		parent_uthread-&gt;uu_vforkmask = parent_uthread-&gt;uu_sigmask;

		<span class="enscript-comment">/* temporarily drop thread-set-id state */</span>
		<span class="enscript-keyword">if</span> (parent_uthread-&gt;uu_flag &amp; UT_SETUID) {
			parent_uthread-&gt;uu_flag |= UT_WASSETUID;
			parent_uthread-&gt;uu_flag &amp;= ~UT_SETUID;
		}

		<span class="enscript-comment">/* blow thread state information */</span>
		<span class="enscript-comment">/* XXX is this actually necessary, given syscall return? */</span>
		thread_set_child(parent_thread, child_proc-&gt;p_pid);

		child_proc-&gt;p_acflag = AFORK;	<span class="enscript-comment">/* forked but not exec'ed */</span>

		<span class="enscript-comment">/*
		 * Preserve synchronization semantics of vfork.  If
		 * waiting for child to exec or exit, set P_PPWAIT
		 * on child, and sleep on our proc (in case of exit).
		 */</span>
		child_proc-&gt;p_lflag |= P_LPPWAIT;
		pinsertchild(parent_proc, child_proc);	<span class="enscript-comment">/* set visible */</span>

		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_CREATE_SPAWN</span>:
		<span class="enscript-comment">/*
		 * A spawned process differs from a forked process in that
		 * the spawned process does not carry around the parents
		 * baggage with regard to address space copying, dtrace,
		 * and so on.
		 */</span>
		spawn = 1;

		<span class="enscript-comment">/* FALLSTHROUGH */</span>

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PROC_CREATE_FORK</span>:
		<span class="enscript-comment">/*
		 * When we clone the parent process, we are going to inherit
		 * its task attributes and memory, since when we fork, we
		 * will, in effect, create a duplicate of it, with only minor
		 * differences.  Contrarily, spawned processes do not inherit.
		 */</span>
		<span class="enscript-keyword">if</span> ((child_thread = cloneproc(parent_proc-&gt;task,
						spawn ? coalitions : NULL,
						parent_proc,
						spawn ? FALSE : TRUE,
						FALSE)) == NULL) {
			<span class="enscript-comment">/* Failed to create thread */</span>
			err = EAGAIN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		}

		<span class="enscript-comment">/* copy current thread state into the child thread (only for fork) */</span>
		<span class="enscript-keyword">if</span> (!spawn) {
			thread_dup(child_thread);
		}

		<span class="enscript-comment">/* child_proc = child_thread-&gt;task-&gt;proc; */</span>
		child_proc = (proc_t)(get_bsdtask_info(get_threadtask(child_thread)));

<span class="enscript-comment">// XXX BEGIN: wants to move to be common code (and safe)
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		<span class="enscript-comment">/*
		 * allow policies to associate the credential/label that
		 * we referenced from the parent ... with the child
		 * JMM - this really isn't safe, as we can drop that
		 *       association without informing the policy in other
		 *       situations (keep long enough to get policies changed)
		 */</span>
		mac_cred_label_associate_fork(child_proc-&gt;p_ucred, child_proc);
#<span class="enscript-reference">endif</span>

		<span class="enscript-comment">/*
		 * Propogate change of PID - may get new cred if auditing.
		 *
		 * NOTE: This has no effect in the vfork case, since
		 *	child_proc-&gt;task != current_task(), but we duplicate it
		 *	because this is probably, ultimately, wrong, since we
		 *	will be running in the &quot;child&quot; which is the parent task
		 *	with the wrong token until we get to the execve() or
		 *	_exit() call; a lot of &quot;undefined&quot; can happen before
		 *	that.
		 *
		 * &lt;rdar://6640530&gt; disallow everything but exeve()/_exit()?
		 */</span>
		set_security_token(child_proc);

		AUDIT_ARG(pid, child_proc-&gt;p_pid);

<span class="enscript-comment">// XXX END: wants to move to be common code (and safe)
</span>
		<span class="enscript-comment">/*
		 * Blow thread state information; this is what gives the child
		 * process its &quot;return&quot; value from a fork() call.
		 *
		 * Note: this should probably move to fork() proper, since it
		 * is not relevent to spawn, and the value won't matter
		 * until we resume the child there.  If you are in here
		 * refactoring code, consider doing this at the same time.
		 */</span>
		thread_set_child(child_thread, child_proc-&gt;p_pid);

		child_proc-&gt;p_acflag = AFORK;	<span class="enscript-comment">/* forked but not exec'ed */</span>

<span class="enscript-comment">// &lt;rdar://6598155&gt; dtrace code cleanup needed
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-comment">/*
		 * This code applies to new processes who are copying the task
		 * and thread state and address spaces of their parent process.
		 */</span>
		<span class="enscript-keyword">if</span> (!spawn) {
<span class="enscript-comment">// &lt;rdar://6598155&gt; call dtrace specific function here instead of all this...
</span>		<span class="enscript-comment">/*
		 * APPLE NOTE: Solaris does a sprlock() and drops the
		 * proc_lock here. We're cheating a bit and only taking
		 * the p_dtrace_sprlock lock. A full sprlock would
		 * task_suspend the parent.
		 */</span>
		lck_mtx_lock(&amp;parent_proc-&gt;p_dtrace_sprlock);

		<span class="enscript-comment">/*
		 * Remove all DTrace tracepoints from the child process. We
		 * need to do this _before_ duplicating USDT providers since
		 * any associated probes may be immediately enabled.
		 */</span>
		<span class="enscript-keyword">if</span> (parent_proc-&gt;p_dtrace_count &gt; 0) {
			dtrace_fasttrap_fork(parent_proc, child_proc);
		}

		lck_mtx_unlock(&amp;parent_proc-&gt;p_dtrace_sprlock);

		<span class="enscript-comment">/*
		 * Duplicate any lazy dof(s). This must be done while NOT
		 * holding the parent sprlock! Lock ordering is
		 * dtrace_dof_mode_lock, then sprlock.  It is imperative we
		 * always call dtrace_lazy_dofs_duplicate, rather than null
		 * check and call if !NULL. If we NULL test, during lazy dof
		 * faulting we can race with the faulting code and proceed
		 * from here to beyond the helpers copy. The lazy dof
		 * faulting will then fail to copy the helpers to the child
		 * process.
		 */</span>
		dtrace_lazy_dofs_duplicate(parent_proc, child_proc);
		
		<span class="enscript-comment">/*
		 * Duplicate any helper actions and providers. The SFORKING
		 * we set above informs the code to enable USDT probes that
		 * sprlock() may fail because the child is being forked.
		 */</span>
		<span class="enscript-comment">/*
		 * APPLE NOTE: As best I can tell, Apple's sprlock() equivalent
		 * never fails to find the child. We do not set SFORKING.
		 */</span>
		<span class="enscript-keyword">if</span> (parent_proc-&gt;p_dtrace_helpers != NULL &amp;&amp; dtrace_helpers_fork) {
			(*dtrace_helpers_fork)(parent_proc, child_proc);
		}

		}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* CONFIG_DTRACE */</span>

		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		panic(<span class="enscript-string">&quot;fork1 called with unknown kind %d&quot;</span>, kind);
		<span class="enscript-keyword">break</span>;
	}


	<span class="enscript-comment">/* return the thread pointer to the caller */</span>
	*child_threadp = child_thread;

<span class="enscript-reference">bad</span>:
	<span class="enscript-comment">/*
	 * In the error case, we return a 0 value for the returned pid (but
	 * it is ignored in the trampoline due to the error return); this
	 * is probably not necessary.
	 */</span>
	<span class="enscript-keyword">if</span> (err) {
		(<span class="enscript-type">void</span>)chgproccnt(uid, -1);
	}

	<span class="enscript-keyword">return</span> (err);
}


<span class="enscript-comment">/*
 * vfork_return
 *
 * Description:	&quot;Return&quot; to parent vfork thread() following execve/_exit;
 *		this is done by reassociating the parent process structure
 *		with the task, thread, and uthread.
 *
 *		Refer to the ASCII art above vfork() to figure out the
 *		state we're undoing.
 *
 * Parameters:	child_proc		Child process
 *		retval			System call return value array
 *		rval			Return value to present to parent
 *
 * Returns:	void
 *
 * Notes:	The caller resumes or exits the parent, as appropriate, after
 *		calling this function.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">vfork_return</span>(proc_t child_proc, int32_t *retval, <span class="enscript-type">int</span> rval)
{
	task_t parent_task = get_threadtask(child_proc-&gt;p_vforkact);
	proc_t parent_proc = get_bsdtask_info(parent_task);
	thread_t th = current_thread();
	uthread_t uth = get_bsdthread_info(th);
	
	act_thread_catt(uth-&gt;uu_userstate);

	<span class="enscript-comment">/* clear vfork state in parent proc structure */</span>
	proc_vfork_end(parent_proc);

	<span class="enscript-comment">/* REPATRIATE PARENT TASK, THREAD, UTHREAD */</span>
	uth-&gt;uu_userstate = 0;
	uth-&gt;uu_flag &amp;= ~UT_VFORK;
	<span class="enscript-comment">/* restore thread-set-id state */</span>
	<span class="enscript-keyword">if</span> (uth-&gt;uu_flag &amp; UT_WASSETUID) {
		uth-&gt;uu_flag |= UT_SETUID;
		uth-&gt;uu_flag &amp;= UT_WASSETUID;
	}
	uth-&gt;uu_proc = 0;
	uth-&gt;uu_sigmask = uth-&gt;uu_vforkmask;

	proc_lock(child_proc);
	child_proc-&gt;p_lflag &amp;= ~P_LINVFORK;
	child_proc-&gt;p_vforkact = 0;
	proc_unlock(child_proc);

	thread_set_parent(th, rval);

	<span class="enscript-keyword">if</span> (retval) {
		retval[0] = rval;
		retval[1] = 0;			<span class="enscript-comment">/* mark parent */</span>
	}
}


<span class="enscript-comment">/*
 * fork_create_child
 *
 * Description:	Common operations associated with the creation of a child
 *		process
 *
 * Parameters:	parent_task		parent task
 *		parent_coalitions	parent's set of coalitions
 *		child_proc		child process
 *		inherit_memory		TRUE, if the parents address space is
 *					to be inherited by the child
 *		is64bit			TRUE, if the child being created will
 *					be associated with a 64 bit process
 *					rather than a 32 bit process
 *
 * Note:	This code is called in the fork() case, from the execve() call
 *		graph, if implementing an execve() following a vfork(), from
 *		the posix_spawn() call graph (which implicitly includes a
 *		vfork() equivalent call, and in the system bootstrap case.
 *
 *		It creates a new task and thread (and as a side effect of the
 *		thread creation, a uthread) in the parent coalition set, which is
 *		then associated with the process 'child'.  If the parent
 *		process address space is to be inherited, then a flag
 *		indicates that the newly created task should inherit this from
 *		the child task.
 *
 *		As a special concession to bootstrapping the initial process
 *		in the system, it's possible for 'parent_task' to be TASK_NULL;
 *		in this case, 'inherit_memory' MUST be FALSE.
 */</span>
thread_t
<span class="enscript-function-name">fork_create_child</span>(task_t parent_task, coalition_t *parent_coalitions, proc_t child_proc, <span class="enscript-type">int</span> inherit_memory, <span class="enscript-type">int</span> is64bit)
{
	thread_t	child_thread = NULL;
	task_t		child_task;
	kern_return_t	result;

	<span class="enscript-comment">/* Create a new task for the child process */</span>
	result = task_create_internal(parent_task,
					parent_coalitions,
					inherit_memory,
					is64bit,
					&amp;child_task);
	<span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
		printf(<span class="enscript-string">&quot;%s: task_create_internal failed.  Code: %d\n&quot;</span>,
		    __func__, result);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* Set the child process task to the new task */</span>
	child_proc-&gt;task = child_task;

	<span class="enscript-comment">/* Set child task process to child proc */</span>
	set_bsdtask_info(child_task, child_proc);

	<span class="enscript-comment">/* Propagate CPU limit timer from parent */</span>
	<span class="enscript-keyword">if</span> (timerisset(&amp;child_proc-&gt;p_rlim_cpu))
		task_vtimer_set(child_task, TASK_VTIMER_RLIM);

	<span class="enscript-comment">/* Set/clear 64 bit vm_map flag */</span>
	<span class="enscript-keyword">if</span> (is64bit)
		vm_map_set_64bit(get_task_map(child_task));
	<span class="enscript-keyword">else</span>
		vm_map_set_32bit(get_task_map(child_task));

	<span class="enscript-comment">/*
	 * Set child process BSD visible scheduler priority if nice value
	 * inherited from parent
	 */</span>
	<span class="enscript-keyword">if</span> (child_proc-&gt;p_nice != 0)
		resetpriority(child_proc);

	<span class="enscript-comment">/* Create a new thread for the child process */</span>
	result = thread_create_with_continuation(child_task, &amp;child_thread, (thread_continue_t)proc_wait_to_return);
	<span class="enscript-keyword">if</span> (result != KERN_SUCCESS) {
		printf(<span class="enscript-string">&quot;%s: thread_create failed. Code: %d\n&quot;</span>,
		    __func__, result);
		task_deallocate(child_task);
		child_task = NULL;
	}

	<span class="enscript-comment">/*
         * Tag thread as being the first thread in its task.
         */</span>
	thread_set_tag(child_thread, THREAD_TAG_MAINTHREAD);

<span class="enscript-reference">bad</span>:
	thread_yield_internal(1);

	<span class="enscript-keyword">return</span>(child_thread);
}


<span class="enscript-comment">/*
 * fork
 *
 * Description:	fork system call.
 *
 * Parameters:	parent			Parent process to fork
 *		uap (void)		[unused]
 *		retval			Return value
 *
 * Returns:	0			Success
 *		EAGAIN			Resource unavailable, try again
 *
 * Notes:	Attempts to create a new child process which inherits state
 *		from the parent process.  If successful, the call returns
 *		having created an initially suspended child process with an
 *		extra Mach task and thread reference, for which the thread
 *		is initially suspended.  Until we resume the child process,
 *		it is not yet running.
 *
 *		The return information to the child is contained in the
 *		thread state structure of the new child, and does not
 *		become visible to the child through a normal return process,
 *		since it never made the call into the kernel itself in the
 *		first place.
 *
 *		After resuming the thread, this function returns directly to
 *		the parent process which invoked the fork() system call.
 *
 * Important:	The child thread_resume occurs before the parent returns;
 *		depending on scheduling latency, this means that it is not
 *		deterministic as to whether the parent or child is scheduled
 *		to run first.  It is entirely possible that the child could
 *		run to completion prior to the parent running.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">fork</span>(proc_t parent_proc, __unused <span class="enscript-type">struct</span> fork_args *uap, int32_t *retval)
{
	thread_t child_thread;
	<span class="enscript-type">int</span> err;

	retval[1] = 0;		<span class="enscript-comment">/* flag parent return for user space */</span>

	<span class="enscript-keyword">if</span> ((err = fork1(parent_proc, &amp;child_thread, PROC_CREATE_FORK, NULL)) == 0) {
		task_t child_task;
		proc_t child_proc;

		<span class="enscript-comment">/* Return to the parent */</span>
		child_proc = (proc_t)get_bsdthreadtask_info(child_thread);
		retval[0] = child_proc-&gt;p_pid;

		<span class="enscript-comment">/*
		 * Drop the signal lock on the child which was taken on our
		 * behalf by forkproc()/cloneproc() to prevent signals being
		 * received by the child in a partially constructed state.
		 */</span>
		proc_signalend(child_proc, 0);
		proc_transend(child_proc, 0);

		<span class="enscript-comment">/* flag the fork has occurred */</span>
		proc_knote(parent_proc, NOTE_FORK | child_proc-&gt;p_pid);
		DTRACE_PROC1(create, proc_t, child_proc);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-keyword">if</span> ((dtrace_proc_waitfor_hook = dtrace_proc_waitfor_exec_ptr) != NULL)
			(*dtrace_proc_waitfor_hook)(child_proc);
#<span class="enscript-reference">endif</span>

		<span class="enscript-comment">/* &quot;Return&quot; to the child */</span>
		proc_clear_return_wait(child_proc, child_thread);

		<span class="enscript-comment">/* drop the extra references we got during the creation */</span>
		<span class="enscript-keyword">if</span> ((child_task = (task_t)get_threadtask(child_thread)) != NULL) {
			task_deallocate(child_task);
		}
		thread_deallocate(child_thread);
	}

	<span class="enscript-keyword">return</span>(err);
}


<span class="enscript-comment">/*
 * cloneproc
 *
 * Description: Create a new process from a specified process.
 *
 * Parameters:	parent_task		The parent task to be cloned, or
 *					TASK_NULL is task characteristics
 *					are not to be inherited
 *					be cloned, or TASK_NULL if the new
 *					task is not to inherit the VM
 *					characteristics of the parent
 *		parent_proc		The parent process to be cloned
 *		inherit_memory		True if the child is to inherit
 *					memory from the parent; if this is
 *					non-NULL, then the parent_task must
 *					also be non-NULL
 *		memstat_internal	Whether to track the process in the
 *					jetsam priority list (if configured)
 *
 * Returns:	!NULL			pointer to new child thread
 *		NULL			Failure (unspecified)
 *
 * Note:	On return newly created child process has signal lock held
 *		to block delivery of signal to it if called with lock set.
 *		fork() code needs to explicity remove this lock before
 *		signals can be delivered
 *
 *		In the case of bootstrap, this function can be called from
 *		bsd_utaskbootstrap() in order to bootstrap the first process;
 *		the net effect is to provide a uthread structure for the
 *		kernel process associated with the kernel task.
 *
 * XXX:		Tristating using the value parent_task as the major key
 *		and inherit_memory as the minor key is something we should
 *		refactor later; we owe the current semantics, ultimately,
 *		to the semantics of task_create_internal.  For now, we will
 *		live with this being somewhat awkward.
 */</span>
thread_t
<span class="enscript-function-name">cloneproc</span>(task_t parent_task, coalition_t *parent_coalitions, proc_t parent_proc, <span class="enscript-type">int</span> inherit_memory, <span class="enscript-type">int</span> memstat_internal)
{
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">memstat_internal</span>)
#<span class="enscript-reference">endif</span>
	task_t child_task;
	proc_t child_proc;
	thread_t child_thread = NULL;

	<span class="enscript-keyword">if</span> ((child_proc = forkproc(parent_proc)) == NULL) {
		<span class="enscript-comment">/* Failed to allocate new process */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	child_thread = fork_create_child(parent_task, parent_coalitions, child_proc, inherit_memory, (parent_task == TASK_NULL) ? FALSE : (parent_proc-&gt;p_flag &amp; P_LP64));

	<span class="enscript-keyword">if</span> (child_thread == NULL) {
		<span class="enscript-comment">/*
		 * Failed to create thread; now we must deconstruct the new
		 * process previously obtained from forkproc().
		 */</span>
		forkproc_free(child_proc);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	child_task = get_threadtask(child_thread);
	<span class="enscript-keyword">if</span> (parent_proc-&gt;p_flag &amp; P_LP64) {
		task_set_64bit(child_task, TRUE);
		OSBitOrAtomic(P_LP64, (UInt32 *)&amp;child_proc-&gt;p_flag);
	} <span class="enscript-keyword">else</span> {
		task_set_64bit(child_task, FALSE);
		OSBitAndAtomic(~((uint32_t)P_LP64), (UInt32 *)&amp;child_proc-&gt;p_flag);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>
	<span class="enscript-keyword">if</span> (memstat_internal) {
		proc_list_lock();
		child_proc-&gt;p_memstat_state |= P_MEMSTAT_INTERNAL;
		proc_list_unlock();
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* make child visible */</span>
	pinsertchild(parent_proc, child_proc);

	<span class="enscript-comment">/*
	 * Make child runnable, set start time.
	 */</span>
	child_proc-&gt;p_stat = SRUN;
<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">return</span>(child_thread);
}


<span class="enscript-comment">/*
 * Destroy a process structure that resulted from a call to forkproc(), but
 * which must be returned to the system because of a subsequent failure
 * preventing it from becoming active.
 *
 * Parameters:	p			The incomplete process from forkproc()
 *
 * Returns:	(void)
 *
 * Note:	This function should only be used in an error handler following
 *		a call to forkproc().
 *
 *		Operations occur in reverse order of those in forkproc().
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">forkproc_free</span>(proc_t p)
{

	<span class="enscript-comment">/* We held signal and a transition locks; drop them */</span>
	proc_signalend(p, 0);
	proc_transend(p, 0);

	<span class="enscript-comment">/*
	 * If we have our own copy of the resource limits structure, we
	 * need to free it.  If it's a shared copy, we need to drop our
	 * reference on it.
	 */</span>
	proc_limitdrop(p, 0);
	p-&gt;p_limit = NULL;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SYSV_SHM</span>
	<span class="enscript-comment">/* Need to drop references to the shared memory segment(s), if any */</span>
	<span class="enscript-keyword">if</span> (p-&gt;vm_shm) {
		<span class="enscript-comment">/*
		 * Use shmexec(): we have no address space, so no mappings
		 *
		 * XXX Yes, the routine is badly named.
		 */</span>
		shmexec(p);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/* Need to undo the effects of the fdcopy(), if any */</span>
	fdfree(p);

	<span class="enscript-comment">/*
	 * Drop the reference on a text vnode pointer, if any
	 * XXX This code is broken in forkproc(); see &lt;rdar://4256419&gt;;
	 * XXX if anyone ever uses this field, we will be extremely unhappy.
	 */</span>
	<span class="enscript-keyword">if</span> (p-&gt;p_textvp) {
		vnode_rele(p-&gt;p_textvp);
		p-&gt;p_textvp = NULL;
	}

	<span class="enscript-comment">/* Stop the profiling clock */</span>
	stopprofclock(p);

	<span class="enscript-comment">/* Update the audit session proc count */</span>
	AUDIT_SESSION_PROCEXIT(p);

	<span class="enscript-comment">/* Release the credential reference */</span>
	kauth_cred_unref(&amp;p-&gt;p_ucred);

	proc_list_lock();
	<span class="enscript-comment">/* Decrement the count of processes in the system */</span>
	nprocs--;
	proc_list_unlock();

	thread_call_free(p-&gt;p_rcall);

	<span class="enscript-comment">/* Free allocated memory */</span>
	FREE_ZONE(p-&gt;p_sigacts, <span class="enscript-keyword">sizeof</span> *p-&gt;p_sigacts, M_SIGACTS);
	FREE_ZONE(p-&gt;p_stats, <span class="enscript-keyword">sizeof</span> *p-&gt;p_stats, M_PSTATS);
	proc_checkdeadrefs(p);
	FREE_ZONE(p, <span class="enscript-keyword">sizeof</span> *p, M_PROC);
}


<span class="enscript-comment">/*
 * forkproc
 *
 * Description:	Create a new process structure, given a parent process
 *		structure.
 *
 * Parameters:	parent_proc		The parent process
 *
 * Returns:	!NULL			The new process structure
 *		NULL			Error (insufficient free memory)
 *
 * Note:	When successful, the newly created process structure is
 *		partially initialized; if a caller needs to deconstruct the
 *		returned structure, they must call forkproc_free() to do so.
 */</span>
proc_t
<span class="enscript-function-name">forkproc</span>(proc_t parent_proc)
{
	proc_t child_proc;	<span class="enscript-comment">/* Our new process */</span>
	<span class="enscript-type">static</span> <span class="enscript-type">int</span> nextpid = 0, pidwrap = 0, nextpidversion = 0;
	<span class="enscript-type">static</span> uint64_t nextuniqueid = 0;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> session *sessp;
	uthread_t parent_uthread = (uthread_t)get_bsdthread_info(current_thread());

	MALLOC_ZONE(child_proc, proc_t , <span class="enscript-keyword">sizeof</span> *child_proc, M_PROC, M_WAITOK);
	<span class="enscript-keyword">if</span> (child_proc == NULL) {
		printf(<span class="enscript-string">&quot;forkproc: M_PROC zone exhausted\n&quot;</span>);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	<span class="enscript-comment">/* zero it out as we need to insert in hash */</span>
	bzero(child_proc, <span class="enscript-keyword">sizeof</span> *child_proc);

	MALLOC_ZONE(child_proc-&gt;p_stats, <span class="enscript-type">struct</span> pstats *,
			<span class="enscript-keyword">sizeof</span> *child_proc-&gt;p_stats, M_PSTATS, M_WAITOK);
	<span class="enscript-keyword">if</span> (child_proc-&gt;p_stats == NULL) {
		printf(<span class="enscript-string">&quot;forkproc: M_SUBPROC zone exhausted (p_stats)\n&quot;</span>);
		FREE_ZONE(child_proc, <span class="enscript-keyword">sizeof</span> *child_proc, M_PROC);
		child_proc = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	MALLOC_ZONE(child_proc-&gt;p_sigacts, <span class="enscript-type">struct</span> sigacts *,
			<span class="enscript-keyword">sizeof</span> *child_proc-&gt;p_sigacts, M_SIGACTS, M_WAITOK);
	<span class="enscript-keyword">if</span> (child_proc-&gt;p_sigacts == NULL) {
		printf(<span class="enscript-string">&quot;forkproc: M_SUBPROC zone exhausted (p_sigacts)\n&quot;</span>);
		FREE_ZONE(child_proc-&gt;p_stats, <span class="enscript-keyword">sizeof</span> *child_proc-&gt;p_stats, M_PSTATS);
		FREE_ZONE(child_proc, <span class="enscript-keyword">sizeof</span> *child_proc, M_PROC);
		child_proc = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	<span class="enscript-comment">/* allocate a callout for use by interval timers */</span>
	child_proc-&gt;p_rcall = thread_call_allocate((thread_call_func_t)realitexpire, child_proc);
	<span class="enscript-keyword">if</span> (child_proc-&gt;p_rcall == NULL) {
		FREE_ZONE(child_proc-&gt;p_sigacts, <span class="enscript-keyword">sizeof</span> *child_proc-&gt;p_sigacts, M_SIGACTS);
		FREE_ZONE(child_proc-&gt;p_stats, <span class="enscript-keyword">sizeof</span> *child_proc-&gt;p_stats, M_PSTATS);
		FREE_ZONE(child_proc, <span class="enscript-keyword">sizeof</span> *child_proc, M_PROC);
		child_proc = NULL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}


	<span class="enscript-comment">/*
	 * Find an unused PID.  
	 */</span>

	proc_list_lock();

	nextpid++;
<span class="enscript-reference">retry</span>:
	<span class="enscript-comment">/*
	 * If the process ID prototype has wrapped around,
	 * restart somewhat above 0, as the low-numbered procs
	 * tend to include daemons that don't exit.
	 */</span>
	<span class="enscript-keyword">if</span> (nextpid &gt;= PID_MAX) {
		nextpid = 100;
		pidwrap = 1;
	}
	<span class="enscript-keyword">if</span> (pidwrap != 0) {

		<span class="enscript-comment">/* if the pid stays in hash both for zombie and runniing state */</span>
		<span class="enscript-keyword">if</span>  (pfind_locked(nextpid) != PROC_NULL) {
			nextpid++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}

		<span class="enscript-keyword">if</span> (pgfind_internal(nextpid) != PGRP_NULL) {
			nextpid++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}	
		<span class="enscript-keyword">if</span> (session_find_internal(nextpid) != SESSION_NULL) {
			nextpid++;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">retry</span>;
		}	
	}
	nprocs++;
	child_proc-&gt;p_pid = nextpid;
	child_proc-&gt;p_responsible_pid = nextpid;	<span class="enscript-comment">/* initially responsible for self */</span>
	child_proc-&gt;p_idversion = nextpidversion++;
	<span class="enscript-comment">/* kernel process is handcrafted and not from fork, so start from 1 */</span>
	child_proc-&gt;p_uniqueid = ++nextuniqueid;
#<span class="enscript-reference">if</span> 1
	<span class="enscript-keyword">if</span> (child_proc-&gt;p_pid != 0) {
		<span class="enscript-keyword">if</span> (pfind_locked(child_proc-&gt;p_pid) != PROC_NULL)
			panic(<span class="enscript-string">&quot;proc in the list already\n&quot;</span>);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/* Insert in the hash */</span>
	child_proc-&gt;p_listflag |= (P_LIST_INHASH | P_LIST_INCREATE);
	LIST_INSERT_HEAD(PIDHASH(child_proc-&gt;p_pid), child_proc, p_hash);
	proc_list_unlock();


	<span class="enscript-comment">/*
	 * We've identified the PID we are going to use; initialize the new
	 * process structure.
	 */</span>
	child_proc-&gt;p_stat = SIDL;
	child_proc-&gt;p_pgrpid = PGRPID_DEAD;

	<span class="enscript-comment">/*
	 * The zero'ing of the proc was at the allocation time due to need
	 * for insertion to hash.  Copy the section that is to be copied
	 * directly from the parent.
	 */</span>
	bcopy(&amp;parent_proc-&gt;p_startcopy, &amp;child_proc-&gt;p_startcopy,
	    (<span class="enscript-type">unsigned</span>) ((caddr_t)&amp;child_proc-&gt;p_endcopy - (caddr_t)&amp;child_proc-&gt;p_startcopy));

	<span class="enscript-comment">/*
	 * Some flags are inherited from the parent.
	 * Duplicate sub-structures as needed.
	 * Increase reference counts on shared objects.
	 * The p_stats and p_sigacts substructs are set in vm_fork.
	 */</span>
	child_proc-&gt;p_flag = (parent_proc-&gt;p_flag &amp; (P_LP64 | P_DISABLE_ASLR | P_DELAYIDLESLEEP | P_SUGID));
	<span class="enscript-keyword">if</span> (parent_proc-&gt;p_flag &amp; P_PROFIL)
		startprofclock(child_proc);

	child_proc-&gt;p_vfs_iopolicy = (parent_proc-&gt;p_vfs_iopolicy &amp; (P_VFS_IOPOLICY_FORCE_HFS_CASE_SENSITIVITY));

	<span class="enscript-comment">/*
	 * Note that if the current thread has an assumed identity, this
	 * credential will be granted to the new process.
	 */</span>
	child_proc-&gt;p_ucred = kauth_cred_get_with_ref();
	<span class="enscript-comment">/* update cred on proc */</span>
	PROC_UPDATE_CREDS_ONPROC(child_proc);
	<span class="enscript-comment">/* update audit session proc count */</span>
	AUDIT_SESSION_PROCNEW(child_proc);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FINE_LOCK_GROUPS</span>
	lck_mtx_init(&amp;child_proc-&gt;p_mlock, proc_mlock_grp, proc_lck_attr);
	lck_mtx_init(&amp;child_proc-&gt;p_fdmlock, proc_fdmlock_grp, proc_lck_attr);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	lck_mtx_init(&amp;child_proc-&gt;p_dtrace_sprlock, proc_lck_grp, proc_lck_attr);
#<span class="enscript-reference">endif</span>
	lck_spin_init(&amp;child_proc-&gt;p_slock, proc_slock_grp, proc_lck_attr);
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* !CONFIG_FINE_LOCK_GROUPS */</span>
	lck_mtx_init(&amp;child_proc-&gt;p_mlock, proc_lck_grp, proc_lck_attr);
	lck_mtx_init(&amp;child_proc-&gt;p_fdmlock, proc_lck_grp, proc_lck_attr);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
	lck_mtx_init(&amp;child_proc-&gt;p_dtrace_sprlock, proc_lck_grp, proc_lck_attr);
#<span class="enscript-reference">endif</span>
	lck_spin_init(&amp;child_proc-&gt;p_slock, proc_lck_grp, proc_lck_attr);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !CONFIG_FINE_LOCK_GROUPS */</span>
	klist_init(&amp;child_proc-&gt;p_klist);

	<span class="enscript-keyword">if</span> (child_proc-&gt;p_textvp != NULLVP) {
		<span class="enscript-comment">/* bump references to the text vnode */</span>
		<span class="enscript-comment">/* Need to hold iocount across the ref call */</span>
		<span class="enscript-keyword">if</span> (vnode_getwithref(child_proc-&gt;p_textvp) == 0) {
			error = vnode_ref(child_proc-&gt;p_textvp);
			vnode_put(child_proc-&gt;p_textvp);
			<span class="enscript-keyword">if</span> (error != 0)
				child_proc-&gt;p_textvp = NULLVP;
		}
	}

	<span class="enscript-comment">/*
	 * Copy the parents per process open file table to the child; if
	 * there is a per-thread current working directory, set the childs
	 * per-process current working directory to that instead of the
	 * parents.
	 *
	 * XXX may fail to copy descriptors to child
	 */</span>
	child_proc-&gt;p_fd = fdcopy(parent_proc, parent_uthread-&gt;uu_cdir);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SYSV_SHM</span>
	<span class="enscript-keyword">if</span> (parent_proc-&gt;vm_shm) {
		<span class="enscript-comment">/* XXX may fail to attach shm to child */</span>
		(<span class="enscript-type">void</span>)shmfork(parent_proc, child_proc);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * inherit the limit structure to child
	 */</span>
	proc_limitfork(parent_proc, child_proc);

	<span class="enscript-keyword">if</span> (child_proc-&gt;p_limit-&gt;pl_rlimit[RLIMIT_CPU].rlim_cur != RLIM_INFINITY) {
		uint64_t rlim_cur = child_proc-&gt;p_limit-&gt;pl_rlimit[RLIMIT_CPU].rlim_cur;
		child_proc-&gt;p_rlim_cpu.tv_sec = (rlim_cur &gt; __INT_MAX__) ? __INT_MAX__ : rlim_cur;
	}

	<span class="enscript-comment">/* Intialize new process stats, including start time */</span>
	<span class="enscript-comment">/* &lt;rdar://6640543&gt; non-zeroed portion contains garbage AFAICT */</span>
	bzero(child_proc-&gt;p_stats, <span class="enscript-keyword">sizeof</span>(*child_proc-&gt;p_stats));
	microtime_with_abstime(&amp;child_proc-&gt;p_start, &amp;child_proc-&gt;p_stats-&gt;ps_start);

	<span class="enscript-keyword">if</span> (parent_proc-&gt;p_sigacts != NULL)
		(<span class="enscript-type">void</span>)memcpy(child_proc-&gt;p_sigacts,
				parent_proc-&gt;p_sigacts, <span class="enscript-keyword">sizeof</span> *child_proc-&gt;p_sigacts);
	<span class="enscript-keyword">else</span>
		(<span class="enscript-type">void</span>)memset(child_proc-&gt;p_sigacts, 0, <span class="enscript-keyword">sizeof</span> *child_proc-&gt;p_sigacts);

	sessp = proc_session(parent_proc);
	<span class="enscript-keyword">if</span> (sessp-&gt;s_ttyvp != NULL &amp;&amp; parent_proc-&gt;p_flag &amp; P_CONTROLT)
		OSBitOrAtomic(P_CONTROLT, &amp;child_proc-&gt;p_flag);
	session_rele(sessp);

	<span class="enscript-comment">/*
	 * block all signals to reach the process.
	 * no transition race should be occuring with the child yet,
	 * but indicate that the process is in (the creation) transition.
	 */</span>
	proc_signalstart(child_proc, 0);
	proc_transstart(child_proc, 0, 0);
	proc_set_return_wait(child_proc);

	child_proc-&gt;p_pcaction = 0;

	TAILQ_INIT(&amp;child_proc-&gt;p_uthlist);
	TAILQ_INIT(&amp;child_proc-&gt;p_aio_activeq);
	TAILQ_INIT(&amp;child_proc-&gt;p_aio_doneq);

	<span class="enscript-comment">/* Inherit the parent flags for code sign */</span>
	child_proc-&gt;p_csflags = (parent_proc-&gt;p_csflags &amp; ~CS_KILLED);

	<span class="enscript-comment">/*
	 * All processes have work queue locks; cleaned up by
	 * reap_child_locked()
	 */</span>
	workqueue_init_lock(child_proc);

	<span class="enscript-comment">/*
	 * Copy work queue information
	 *
	 * Note: This should probably only happen in the case where we are
	 *	creating a child that is a copy of the parent; since this
	 *	routine is called in the non-duplication case of vfork()
	 *	or posix_spawn(), then this information should likely not
	 *	be duplicated.
	 *
	 * &lt;rdar://6640553&gt; Work queue pointers that no longer point to code
	 */</span>
	child_proc-&gt;p_wqthread = parent_proc-&gt;p_wqthread;
	child_proc-&gt;p_threadstart = parent_proc-&gt;p_threadstart;
	child_proc-&gt;p_pthsize = parent_proc-&gt;p_pthsize;
	child_proc-&gt;p_targconc = parent_proc-&gt;p_targconc;
	<span class="enscript-keyword">if</span> ((parent_proc-&gt;p_lflag &amp; P_LREGISTER) != 0) {
		child_proc-&gt;p_lflag |= P_LREGISTER;
	}
	child_proc-&gt;p_wqkqueue = NULL;
	child_proc-&gt;p_dispatchqueue_offset = parent_proc-&gt;p_dispatchqueue_offset;
	child_proc-&gt;p_dispatchqueue_serialno_offset = parent_proc-&gt;p_dispatchqueue_serialno_offset;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PSYNCH</span>
	pth_proc_hashinit(child_proc);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PSYNCH */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MEMORYSTATUS</span>
	<span class="enscript-comment">/* Memorystatus + jetsam init */</span>
	child_proc-&gt;p_memstat_state = 0;
	child_proc-&gt;p_memstat_effectivepriority = JETSAM_PRIORITY_DEFAULT;
	child_proc-&gt;p_memstat_requestedpriority = JETSAM_PRIORITY_DEFAULT;
	child_proc-&gt;p_memstat_userdata = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
	child_proc-&gt;p_memstat_suspendedfootprint = 0;
#<span class="enscript-reference">endif</span>
	child_proc-&gt;p_memstat_dirty = 0;
	child_proc-&gt;p_memstat_idledeadline = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MEMORYSTATUS */</span>

<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">return</span>(child_proc);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_lock</span>(proc_t p)
{
	lck_mtx_lock(&amp;p-&gt;p_mlock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_unlock</span>(proc_t p)
{
	lck_mtx_unlock(&amp;p-&gt;p_mlock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_spinlock</span>(proc_t p)
{
	lck_spin_lock(&amp;p-&gt;p_slock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">proc_spinunlock</span>(proc_t p)
{
	lck_spin_unlock(&amp;p-&gt;p_slock);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">proc_list_lock</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_lock(proc_list_mlock);
}

<span class="enscript-type">void</span> 
<span class="enscript-function-name">proc_list_unlock</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_unlock(proc_list_mlock);
}

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

<span class="enscript-type">struct</span> zone	*uthread_zone;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> uthread_zone_inited = 0;

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">uthread_zone_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (!uthread_zone_inited) {
		uthread_zone = zinit(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> uthread),
					thread_max * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> uthread),
					THREAD_CHUNK * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> uthread),
					<span class="enscript-string">&quot;uthreads&quot;</span>);
		uthread_zone_inited = 1;
	}
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">uthread_alloc</span>(task_t task, thread_t thread, <span class="enscript-type">int</span> noinherit)
{
	proc_t p;
	uthread_t uth;
	uthread_t uth_parent;
	<span class="enscript-type">void</span> *ut;

	<span class="enscript-keyword">if</span> (!uthread_zone_inited)
		uthread_zone_init();

	ut = (<span class="enscript-type">void</span> *)zalloc(uthread_zone);
	bzero(ut, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> uthread));

	p = (proc_t) get_bsdtask_info(task);
	uth = (uthread_t)ut;
	uth-&gt;uu_thread = thread;

	<span class="enscript-comment">/*
	 * Thread inherits credential from the creating thread, if both
	 * are in the same task.
	 *
	 * If the creating thread has no credential or is from another
	 * task we can leave the new thread credential NULL.  If it needs
	 * one later, it will be lazily assigned from the task's process.
	 */</span>
	uth_parent = (uthread_t)get_bsdthread_info(current_thread());
	<span class="enscript-keyword">if</span> ((noinherit == 0) &amp;&amp; task == current_task() &amp;&amp; 
	    uth_parent != NULL &amp;&amp;
	    IS_VALID_CRED(uth_parent-&gt;uu_ucred)) {
		<span class="enscript-comment">/*
		 * XXX The new thread is, in theory, being created in context
		 * XXX of parent thread, so a direct reference to the parent
		 * XXX is OK.
		 */</span>
		kauth_cred_ref(uth_parent-&gt;uu_ucred);
		uth-&gt;uu_ucred = uth_parent-&gt;uu_ucred;
		<span class="enscript-comment">/* the credential we just inherited is an assumed credential */</span>
		<span class="enscript-keyword">if</span> (uth_parent-&gt;uu_flag &amp; UT_SETUID)
			uth-&gt;uu_flag |= UT_SETUID;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* sometimes workqueue threads are created out task context */</span>
		<span class="enscript-keyword">if</span> ((task != kernel_task) &amp;&amp; (p != PROC_NULL))
			uth-&gt;uu_ucred = kauth_cred_proc_ref(p);
		<span class="enscript-keyword">else</span>
			uth-&gt;uu_ucred = NOCRED;
	}

	
	<span class="enscript-keyword">if</span> ((task != kernel_task) &amp;&amp; p) {
		
		proc_lock(p);
		<span class="enscript-keyword">if</span> (noinherit != 0) {
			<span class="enscript-comment">/* workq threads will not inherit masks */</span>
			uth-&gt;uu_sigmask = ~workq_threadmask;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (uth_parent) {
			<span class="enscript-keyword">if</span> (uth_parent-&gt;uu_flag &amp; UT_SAS_OLDMASK)
				uth-&gt;uu_sigmask = uth_parent-&gt;uu_oldmask;
			<span class="enscript-keyword">else</span>
				uth-&gt;uu_sigmask = uth_parent-&gt;uu_sigmask;
		}
		uth-&gt;uu_context.vc_thread = thread;
		TAILQ_INSERT_TAIL(&amp;p-&gt;p_uthlist, uth, uu_list);
		proc_unlock(p);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-keyword">if</span> (p-&gt;p_dtrace_ptss_pages != NULL) {
			uth-&gt;t_dtrace_scratch = dtrace_ptss_claim_entry(p);
		}
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-keyword">return</span> (ut);
}

<span class="enscript-comment">/*
 * This routine frees the thread name field of the uthread_t structure. Split out of
 * uthread_cleanup() so it can be called separately on the threads of a corpse after
 * the corpse notification has been sent, and the handler has had a chance to extract
 * the thread names.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">uthread_cleanup_name</span>(<span class="enscript-type">void</span> *uthread)
{
	uthread_t uth = (uthread_t)uthread;

	<span class="enscript-comment">/*
	 * &lt;rdar://17834538&gt;
	 * Set pth_name to NULL before calling free().
	 * Previously there was a race condition in the
	 * case this code was executing during a stackshot
	 * where the stackshot could try and copy pth_name
	 * after it had been freed and before if was marked
	 * as null.
	 */</span>
	<span class="enscript-keyword">if</span> (uth-&gt;pth_name != NULL) {
		<span class="enscript-type">void</span> *pth_name = uth-&gt;pth_name;
		uth-&gt;pth_name = NULL;
		kfree(pth_name, MAXTHREADNAMESIZE);
	}
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/* 
 * This routine frees all the BSD context in uthread except the credential.
 * It does not free the uthread structure as well
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">uthread_cleanup</span>(task_t task, <span class="enscript-type">void</span> *uthread, <span class="enscript-type">void</span> * bsd_info, boolean_t is_corpse)
{
	<span class="enscript-type">struct</span> _select *sel;
	uthread_t uth = (uthread_t)uthread;
	proc_t p = (proc_t)bsd_info;

	<span class="enscript-keyword">if</span> (uth-&gt;uu_lowpri_window || uth-&gt;uu_throttle_info) {
		<span class="enscript-comment">/*
		 * task is marked as a low priority I/O type
		 * and we've somehow managed to not dismiss the throttle
		 * through the normal exit paths back to user space...
		 * no need to throttle this thread since its going away
		 * but we do need to update our bookeeping w/r to throttled threads
		 *
		 * Calling this routine will clean up any throttle info reference
		 * still inuse by the thread.
		 */</span>
		throttle_lowpri_io(0);
	}
	<span class="enscript-comment">/*
	 * Per-thread audit state should never last beyond system
	 * call return.  Since we don't audit the thread creation/
	 * removal, the thread state pointer should never be
	 * non-NULL when we get here.
	 */</span>
	assert(uth-&gt;uu_ar == NULL);

	sel = &amp;uth-&gt;uu_select;
	<span class="enscript-comment">/* cleanup the select bit space */</span>
	<span class="enscript-keyword">if</span> (sel-&gt;nbytes) {
		FREE(sel-&gt;ibits, M_TEMP);
		FREE(sel-&gt;obits, M_TEMP);
		sel-&gt;nbytes = 0;
	}

	<span class="enscript-keyword">if</span> (uth-&gt;uu_cdir) {
		vnode_rele(uth-&gt;uu_cdir);
		uth-&gt;uu_cdir = NULLVP;
	}

	<span class="enscript-keyword">if</span> (uth-&gt;uu_wqset) {
		<span class="enscript-keyword">if</span> (waitq_set_is_valid(uth-&gt;uu_wqset))
			waitq_set_deinit(uth-&gt;uu_wqset);
		FREE(uth-&gt;uu_wqset, M_SELECT);
		uth-&gt;uu_wqset = NULL;
		uth-&gt;uu_wqstate_sz = 0;
	}

	<span class="enscript-comment">/*
	 * defer the removal of the thread name on process corpses until the corpse has
	 * been autopsied.
	 */</span>
	<span class="enscript-keyword">if</span> (!is_corpse) {
		uthread_cleanup_name(uth);
	}

	<span class="enscript-keyword">if</span> ((task != kernel_task) &amp;&amp; p) {

		<span class="enscript-keyword">if</span> (((uth-&gt;uu_flag &amp; UT_VFORK) == UT_VFORK) &amp;&amp; (uth-&gt;uu_proc != PROC_NULL))  {
			vfork_exit_internal(uth-&gt;uu_proc, 0, 1);
		}
		<span class="enscript-comment">/*
		 * Remove the thread from the process list and
		 * transfer [appropriate] pending signals to the process.
		 */</span>
		<span class="enscript-keyword">if</span> (get_bsdtask_info(task) == p) { 
			proc_lock(p);
			TAILQ_REMOVE(&amp;p-&gt;p_uthlist, uth, uu_list);
			p-&gt;p_siglist |= (uth-&gt;uu_siglist &amp; execmask &amp; (~p-&gt;p_sigignore | sigcantmask));
			proc_unlock(p);
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_DTRACE</span>
		<span class="enscript-type">struct</span> dtrace_ptss_page_entry *tmpptr = uth-&gt;t_dtrace_scratch;
		uth-&gt;t_dtrace_scratch = NULL;
		<span class="enscript-keyword">if</span> (tmpptr != NULL) {
			dtrace_ptss_release_entry(p, tmpptr);
		}
#<span class="enscript-reference">endif</span>
	}
}

<span class="enscript-comment">/* This routine releases the credential stored in uthread */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">uthread_cred_free</span>(<span class="enscript-type">void</span> *uthread)
{
	uthread_t uth = (uthread_t)uthread;

	<span class="enscript-comment">/* and free the uthread itself */</span>
	<span class="enscript-keyword">if</span> (IS_VALID_CRED(uth-&gt;uu_ucred)) {
		kauth_cred_t oldcred = uth-&gt;uu_ucred;
		uth-&gt;uu_ucred = NOCRED;
		kauth_cred_unref(&amp;oldcred);
	}
}

<span class="enscript-comment">/* This routine frees the uthread structure held in thread structure */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">uthread_zone_free</span>(<span class="enscript-type">void</span> *uthread)
{
	uthread_t uth = (uthread_t)uthread;

	<span class="enscript-keyword">if</span> (uth-&gt;t_tombstone) {
		kfree(uth-&gt;t_tombstone, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> doc_tombstone));
		uth-&gt;t_tombstone = NULL;
	}

	<span class="enscript-comment">/* and free the uthread itself */</span>
	zfree(uthread_zone, uthread);
}
</pre>
<hr />
</body></html>