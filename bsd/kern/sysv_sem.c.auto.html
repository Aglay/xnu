<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>sysv_sem.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">sysv_sem.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2007 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Implementation of SVID semaphores
 *
 * Author:  Daniel Boulet
 *
 * This software is provided ``AS IS'' without any warranties of any kind.
 */</span>
<span class="enscript-comment">/*
 * John Bellardo modified the implementation for Darwin. 12/2000
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by McAfee Research in 2004 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 * Copyright (c) 2005-2006 SPARTA, Inc.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sem_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ipcs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysent.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">SYSV_SEM</span>


<span class="enscript-comment">/* Uncomment this line to see the debugging output */</span>
<span class="enscript-comment">/* #define SEM_DEBUG */</span>

<span class="enscript-comment">/* Uncomment this line to see MAC debugging output. */</span>
<span class="enscript-comment">/* #define	MAC_DEBUG */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_DEBUG</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MPRINTF</span>(a)	printf(a)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MPRINTF</span>(a)
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">M_SYSVSEM</span>	M_TEMP


<span class="enscript-comment">/* Hard system limits to avoid resource starvation / DOS attacks.
 * These are not needed if we can make the semaphore pages swappable.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> seminfo limitseminfo = {
	SEMMAP,        <span class="enscript-comment">/* # of entries in semaphore map */</span>
	SEMMNI,        <span class="enscript-comment">/* # of semaphore identifiers */</span>
	SEMMNS,        <span class="enscript-comment">/* # of semaphores in system */</span>
	SEMMNU,        <span class="enscript-comment">/* # of undo structures in system */</span>
	SEMMSL,        <span class="enscript-comment">/* max # of semaphores per id */</span>
	SEMOPM,        <span class="enscript-comment">/* max # of operations per semop call */</span>
	SEMUME,        <span class="enscript-comment">/* max # of undo entries per process */</span>
	SEMUSZ,        <span class="enscript-comment">/* size in bytes of undo structure */</span>
	SEMVMX,        <span class="enscript-comment">/* semaphore maximum value */</span>
	SEMAEM         <span class="enscript-comment">/* adjust on exit max value */</span>
};

<span class="enscript-comment">/* Current system allocations.  We use this structure to track how many
 * resources we have allocated so far.  This way we can set large hard limits
 * and not allocate the memory for them up front.
 */</span>
<span class="enscript-type">struct</span> seminfo seminfo = {
	SEMMAP,	<span class="enscript-comment">/* Unused, # of entries in semaphore map */</span>
	0,	<span class="enscript-comment">/* # of semaphore identifiers */</span>
	0,	<span class="enscript-comment">/* # of semaphores in system */</span>
	0,	<span class="enscript-comment">/* # of undo entries in system */</span>
	SEMMSL,	<span class="enscript-comment">/* max # of semaphores per id */</span>
	SEMOPM,	<span class="enscript-comment">/* max # of operations per semop call */</span>
	SEMUME,	<span class="enscript-comment">/* max # of undo entries per process */</span>
	SEMUSZ,	<span class="enscript-comment">/* size in bytes of undo structure */</span>
	SEMVMX,	<span class="enscript-comment">/* semaphore maximum value */</span>
	SEMAEM	<span class="enscript-comment">/* adjust on exit max value */</span>
};


<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">semu_alloc</span>(<span class="enscript-type">struct</span> proc *p);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">semundo_adjust</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">int</span> *supidx, 
		<span class="enscript-type">int</span> semid, <span class="enscript-type">int</span> semnum, <span class="enscript-type">int</span> adjval);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">semundo_clear</span>(<span class="enscript-type">int</span> semid, <span class="enscript-type">int</span> semnum);

<span class="enscript-comment">/* XXX casting to (sy_call_t *) is bogus, as usual. */</span>
<span class="enscript-type">static</span> sy_call_t *semcalls[] = {
	(sy_call_t *)semctl, (sy_call_t *)semget,
	(sy_call_t *)semop
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>		semtot = 0;		<span class="enscript-comment">/* # of used semaphores */</span>
<span class="enscript-type">struct</span> semid_kernel	*sema = NULL;		<span class="enscript-comment">/* semaphore id pool */</span>
<span class="enscript-type">struct</span> sem		*sem_pool =  NULL;	<span class="enscript-comment">/* semaphore pool */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	 	semu_list_idx = -1;	<span class="enscript-comment">/* active undo structures */</span>
<span class="enscript-type">struct</span> sem_undo		*semu = NULL;		<span class="enscript-comment">/* semaphore undo pool */</span>


<span class="enscript-type">void</span> <span class="enscript-function-name">sysv_sem_lock_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> lck_grp_t       *sysv_sem_subsys_lck_grp;
<span class="enscript-type">static</span> lck_grp_attr_t  *sysv_sem_subsys_lck_grp_attr;
<span class="enscript-type">static</span> lck_attr_t      *sysv_sem_subsys_lck_attr;
<span class="enscript-type">static</span> lck_mtx_t        sysv_sem_subsys_mutex;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">SYSV_SEM_SUBSYS_LOCK</span>() lck_mtx_lock(&amp;sysv_sem_subsys_mutex)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SYSV_SEM_SUBSYS_UNLOCK</span>() lck_mtx_unlock(&amp;sysv_sem_subsys_mutex)


__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">sysv_sem_lock_init</span>( <span class="enscript-type">void</span> )
{

    sysv_sem_subsys_lck_grp_attr = lck_grp_attr_alloc_init();

    sysv_sem_subsys_lck_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;sysv_sem_subsys_lock&quot;</span>, sysv_sem_subsys_lck_grp_attr);

    sysv_sem_subsys_lck_attr = lck_attr_alloc_init();
    lck_mtx_init(&amp;sysv_sem_subsys_mutex, sysv_sem_subsys_lck_grp, sysv_sem_subsys_lck_attr);
}

<span class="enscript-type">static</span> __inline__ user_time_t
<span class="enscript-function-name">sysv_semtime</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> timeval	tv;
	microtime(&amp;tv);
	<span class="enscript-keyword">return</span> (tv.tv_sec);
}

<span class="enscript-comment">/*
 * XXX conversion of internal user_time_t to external tume_t loses
 * XXX precision; not an issue for us now, since we are only ever
 * XXX setting 32 bits worth of time into it.
 *
 * pad field contents are not moved correspondingly; contents will be lost
 *
 * NOTE: Source and target may *NOT* overlap! (target is smaller)
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">semid_ds_kernelto32</span>(<span class="enscript-type">struct</span> user_semid_ds *in, <span class="enscript-type">struct</span> user32_semid_ds *out)
{
	out-&gt;sem_perm = in-&gt;sem_perm;
	out-&gt;sem_base = CAST_DOWN_EXPLICIT(__int32_t,in-&gt;sem_base);
	out-&gt;sem_nsems = in-&gt;sem_nsems;
	out-&gt;sem_otime = in-&gt;sem_otime;		<span class="enscript-comment">/* XXX loses precision */</span>
	out-&gt;sem_ctime = in-&gt;sem_ctime;		<span class="enscript-comment">/* XXX loses precision */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">semid_ds_kernelto64</span>(<span class="enscript-type">struct</span> user_semid_ds *in, <span class="enscript-type">struct</span> user64_semid_ds *out)
{
	out-&gt;sem_perm = in-&gt;sem_perm;
	out-&gt;sem_base = CAST_DOWN_EXPLICIT(__int32_t,in-&gt;sem_base);
	out-&gt;sem_nsems = in-&gt;sem_nsems;
	out-&gt;sem_otime = in-&gt;sem_otime;		<span class="enscript-comment">/* XXX loses precision */</span>
	out-&gt;sem_ctime = in-&gt;sem_ctime;		<span class="enscript-comment">/* XXX loses precision */</span>
}

<span class="enscript-comment">/*
 * pad field contents are not moved correspondingly; contents will be lost
 *
 * NOTE: Source and target may are permitted to overlap! (source is smaller);
 * this works because we copy fields in order from the end of the struct to
 * the beginning.
 *
 * XXX use CAST_USER_ADDR_T() for lack of a CAST_USER_TIME_T(); net effect
 * XXX is the same.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">semid_ds_32tokernel</span>(<span class="enscript-type">struct</span> user32_semid_ds *in, <span class="enscript-type">struct</span> user_semid_ds *out)
{
	out-&gt;sem_ctime = in-&gt;sem_ctime;
	out-&gt;sem_otime = in-&gt;sem_otime;
	out-&gt;sem_nsems = in-&gt;sem_nsems;
	out-&gt;sem_base = (<span class="enscript-type">void</span> *)(uintptr_t)in-&gt;sem_base;
	out-&gt;sem_perm = in-&gt;sem_perm;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">semid_ds_64tokernel</span>(<span class="enscript-type">struct</span> user64_semid_ds *in, <span class="enscript-type">struct</span> user_semid_ds *out)
{
	out-&gt;sem_ctime = in-&gt;sem_ctime;
	out-&gt;sem_otime = in-&gt;sem_otime;
	out-&gt;sem_nsems = in-&gt;sem_nsems;
	out-&gt;sem_base = (<span class="enscript-type">void</span> *)(uintptr_t)in-&gt;sem_base;
	out-&gt;sem_perm = in-&gt;sem_perm;
}


<span class="enscript-comment">/*
 * semsys
 *
 * Entry point for all SEM calls: semctl, semget, semop
 *
 * Parameters:	p	Process requesting the call
 * 		uap	User argument descriptor (see below)
 * 		retval	Return value of the selected sem call
 *
 * Indirect parameters:	uap-&gt;which	sem call to invoke (index in array of sem calls)
 * 			uap-&gt;a2		User argument descriptor
 *                 
 * Returns:	0	Success
 *		!0	Not success
 *
 * Implicit returns: retval	Return value of the selected sem call
 *
 * DEPRECATED:  This interface should not be used to call the other SEM
 * 		functions (semctl, semget, semop). The correct usage is
 * 		to call the other SEM functions directly.
 *
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">semsys</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> semsys_args *uap, int32_t *retval)
{

	<span class="enscript-comment">/* The individual calls handling the locking now */</span>

	<span class="enscript-keyword">if</span> (uap-&gt;which &gt;= <span class="enscript-keyword">sizeof</span>(semcalls)/<span class="enscript-keyword">sizeof</span>(semcalls[0]))
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">return</span> ((*semcalls[uap-&gt;which])(p, &amp;uap-&gt;a2, retval));
}

<span class="enscript-comment">/*
 * Expand the semu array to the given capacity.  If the expansion fails
 * return 0, otherwise return 1.
 *
 * Assumes we already have the subsystem lock.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">grow_semu_array</span>(<span class="enscript-type">int</span> newSize)
{
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> i;
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> sem_undo *newSemu;

	<span class="enscript-keyword">if</span> (newSize &lt;= seminfo.semmnu)
		<span class="enscript-keyword">return</span> 1;
	<span class="enscript-keyword">if</span> (newSize &gt; limitseminfo.semmnu) <span class="enscript-comment">/* enforce hard limit */</span>
	{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;undo structure hard limit of %d reached, requested %d\n&quot;</span>,
			limitseminfo.semmnu, newSize);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span> 0;
	}
	newSize = (newSize/SEMMNU_INC + 1) * SEMMNU_INC;
	newSize = newSize &gt; limitseminfo.semmnu ? limitseminfo.semmnu : newSize;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
	printf(<span class="enscript-string">&quot;growing semu[] from %d to %d\n&quot;</span>, seminfo.semmnu, newSize);
#<span class="enscript-reference">endif</span>
	MALLOC(newSemu, <span class="enscript-type">struct</span> sem_undo *, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sem_undo) * newSize,
	       M_SYSVSEM, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (NULL == newSemu)
	{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;allocation failed.  no changes made.\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span> 0;
	}

       	<span class="enscript-comment">/* copy the old data to the new array */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; seminfo.semmnu; i++)
	{
		newSemu[i] = semu[i];
	}
	<span class="enscript-comment">/*
	 * The new elements (from newSemu[i] to newSemu[newSize-1]) have their
	 * &quot;un_proc&quot; set to 0 (i.e. NULL) by the M_ZERO flag to MALLOC() above,
	 * so they're already marked as &quot;not in use&quot;.
	 */</span>

	<span class="enscript-comment">/* Clean up the old array */</span>
	<span class="enscript-keyword">if</span> (semu)
		FREE(semu, M_SYSVSEM);

	semu = newSemu;
	seminfo.semmnu = newSize;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
	printf(<span class="enscript-string">&quot;expansion successful\n&quot;</span>);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> 1;
}

<span class="enscript-comment">/*
 * Expand the sema array to the given capacity.  If the expansion fails
 * we return 0, otherwise we return 1.
 *
 * Assumes we already have the subsystem lock.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">grow_sema_array</span>(<span class="enscript-type">int</span> newSize)
{
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> semid_kernel *newSema;
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (newSize &lt;= seminfo.semmni)
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-keyword">if</span> (newSize &gt; limitseminfo.semmni) <span class="enscript-comment">/* enforce hard limit */</span>
	{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;identifier hard limit of %d reached, requested %d\n&quot;</span>,
			limitseminfo.semmni, newSize);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span> 0;
	}
	newSize = (newSize/SEMMNI_INC + 1) * SEMMNI_INC;
	newSize = newSize &gt; limitseminfo.semmni ? limitseminfo.semmni : newSize;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
	printf(<span class="enscript-string">&quot;growing sema[] from %d to %d\n&quot;</span>, seminfo.semmni, newSize);
#<span class="enscript-reference">endif</span>
	MALLOC(newSema, <span class="enscript-type">struct</span> semid_kernel *,
	       <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> semid_kernel) * newSize,
	       M_SYSVSEM, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (NULL == newSema)
	{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;allocation failed.  no changes made.\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/* copy over the old ids */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; seminfo.semmni; i++)
	{
		newSema[i] = sema[i];
		<span class="enscript-comment">/* This is a hack.  What we really want to be able to
		 * do is change the value a process is waiting on
		 * without waking it up, but I don't know how to do
		 * this with the existing code, so we wake up the
		 * process and let it do a lot of work to determine the
		 * semaphore set is really not available yet, and then
		 * sleep on the correct, reallocated semid_kernel pointer.
		 */</span>
		<span class="enscript-keyword">if</span> (sema[i].u.sem_perm.mode &amp; SEM_ALLOC)
			wakeup((caddr_t)&amp;sema[i]);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-keyword">for</span> (i = seminfo.semmni; i &lt; newSize; i++)
	{
		mac_sysvsem_label_init(&amp;newSema[i]);
	}
#<span class="enscript-reference">endif</span>
	
	<span class="enscript-comment">/*
	 * The new elements (from newSema[i] to newSema[newSize-1]) have their
	 * &quot;sem_base&quot; and &quot;sem_perm.mode&quot; set to 0 (i.e. NULL) by the M_ZERO
	 * flag to MALLOC() above, so they're already marked as &quot;not in use&quot;.
	 */</span>

	<span class="enscript-comment">/* Clean up the old array */</span>
	<span class="enscript-keyword">if</span> (sema)
		FREE(sema, M_SYSVSEM);

	sema = newSema;
	seminfo.semmni = newSize;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
	printf(<span class="enscript-string">&quot;expansion successful\n&quot;</span>);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> 1;
}

<span class="enscript-comment">/*
 * Expand the sem_pool array to the given capacity.  If the expansion fails
 * we return 0 (fail), otherwise we return 1 (success).
 *
 * Assumes we already hold the subsystem lock.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">grow_sem_pool</span>(<span class="enscript-type">int</span> new_pool_size)
{
	<span class="enscript-type">struct</span> sem *new_sem_pool = NULL;
	<span class="enscript-type">struct</span> sem *sem_free;
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (new_pool_size &lt; semtot)
		<span class="enscript-keyword">return</span> 0;
	<span class="enscript-comment">/* enforce hard limit */</span>
	<span class="enscript-keyword">if</span> (new_pool_size &gt; limitseminfo.semmns) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;semaphore hard limit of %d reached, requested %d\n&quot;</span>,
			limitseminfo.semmns, new_pool_size);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span> 0;
	}

	new_pool_size = (new_pool_size/SEMMNS_INC + 1) * SEMMNS_INC;
	new_pool_size = new_pool_size &gt; limitseminfo.semmns ? limitseminfo.semmns : new_pool_size;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
	printf(<span class="enscript-string">&quot;growing sem_pool array from %d to %d\n&quot;</span>, seminfo.semmns, new_pool_size);
#<span class="enscript-reference">endif</span>
	MALLOC(new_sem_pool, <span class="enscript-type">struct</span> sem *, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sem) * new_pool_size,
	       M_SYSVSEM, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (NULL == new_sem_pool) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;allocation failed.  no changes made.\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/* We have our new memory, now copy the old contents over */</span>
	<span class="enscript-keyword">if</span> (sem_pool)
		<span class="enscript-keyword">for</span>(i = 0; i &lt; seminfo.semmns; i++)
			new_sem_pool[i] = sem_pool[i];

	<span class="enscript-comment">/* Update our id structures to point to the new semaphores */</span>
	<span class="enscript-keyword">for</span>(i = 0; i &lt; seminfo.semmni; i++) {
		<span class="enscript-keyword">if</span> (sema[i].u.sem_perm.mode &amp; SEM_ALLOC)  <span class="enscript-comment">/* ID in use */</span>
			sema[i].u.sem_base = new_sem_pool + 
				(sema[i].u.sem_base - sem_pool);
	}

	sem_free = sem_pool;
	sem_pool = new_sem_pool;

	<span class="enscript-comment">/* clean up the old array */</span>
	<span class="enscript-keyword">if</span> (sem_free != NULL)
		FREE(sem_free, M_SYSVSEM);

	seminfo.semmns = new_pool_size;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
	printf(<span class="enscript-string">&quot;expansion complete\n&quot;</span>);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">return</span> 1;
}

<span class="enscript-comment">/*
 * Allocate a new sem_undo structure for a process
 * (returns ptr to structure or NULL if no more room)
 *
 * Assumes we already hold the subsystem lock.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">semu_alloc</span>(<span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">register</span> <span class="enscript-type">int</span> i;
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> sem_undo *suptr;
	<span class="enscript-type">int</span> *supidx;
	<span class="enscript-type">int</span> attempt;

	<span class="enscript-comment">/*
	 * Try twice to allocate something.
	 * (we'll purge any empty structures after the first pass so
	 * two passes are always enough)
	 */</span>

	<span class="enscript-keyword">for</span> (attempt = 0; attempt &lt; 2; attempt++) {
		<span class="enscript-comment">/*
		 * Look for a free structure.
		 * Fill it in and return it if we find one.
		 */</span>

		<span class="enscript-keyword">for</span> (i = 0; i &lt; seminfo.semmnu; i++) {
			suptr = SEMU(i);
			<span class="enscript-keyword">if</span> (suptr-&gt;un_proc == NULL) {
				suptr-&gt;un_next_idx = semu_list_idx;
				semu_list_idx = i;
				suptr-&gt;un_cnt = 0;
				suptr-&gt;un_ent = NULL;
				suptr-&gt;un_proc = p;
				<span class="enscript-keyword">return</span> i;
			}
		}

		<span class="enscript-comment">/*
		 * We didn't find a free one, if this is the first attempt
		 * then try to free some structures.
		 */</span>

		<span class="enscript-keyword">if</span> (attempt == 0) {
			<span class="enscript-comment">/* All the structures are in use - try to free some */</span>
			<span class="enscript-type">int</span> did_something = 0;

			supidx = &amp;semu_list_idx;
			<span class="enscript-keyword">while</span> (*supidx != -1) {
				suptr = SEMU(*supidx);
				<span class="enscript-keyword">if</span> (suptr-&gt;un_cnt == 0)  {
					suptr-&gt;un_proc = NULL;
					*supidx = suptr-&gt;un_next_idx;
					did_something = 1;
				} <span class="enscript-keyword">else</span>
					supidx = &amp;(suptr-&gt;un_next_idx);
			}

			<span class="enscript-comment">/* If we didn't free anything. Try expanding
			 * the semu[] array.  If that doesn't work
			 * then fail.  We expand last to get the
			 * most reuse out of existing resources.
			 */</span>
			<span class="enscript-keyword">if</span> (!did_something)
				<span class="enscript-keyword">if</span> (!grow_semu_array(seminfo.semmnu + 1))
					<span class="enscript-keyword">return</span> -1;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * The second pass failed even though we freed
			 * something after the first pass!
			 * This is IMPOSSIBLE!
			 */</span>
			panic(<span class="enscript-string">&quot;semu_alloc - second attempt failed&quot;</span>);
		}
	}
	<span class="enscript-keyword">return</span> -1;
}

<span class="enscript-comment">/*
 * Adjust a particular entry for a particular proc
 *
 * Assumes we already hold the subsystem lock.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">semundo_adjust</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">int</span> *supidx, <span class="enscript-type">int</span> semid,
	<span class="enscript-type">int</span> semnum, <span class="enscript-type">int</span> adjval)
{
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> sem_undo *suptr;
	<span class="enscript-type">int</span> suidx;
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> undo *sueptr, **suepptr, *new_sueptr;
	<span class="enscript-type">int</span> i;

	<span class="enscript-comment">/*
	 * Look for and remember the sem_undo if the caller doesn't provide it
	 */</span>

	suidx = *supidx;
	<span class="enscript-keyword">if</span> (suidx == -1) {
		<span class="enscript-keyword">for</span> (suidx = semu_list_idx; suidx != -1;
		    suidx = suptr-&gt;un_next_idx) {
			suptr = SEMU(suidx);
			<span class="enscript-keyword">if</span> (suptr-&gt;un_proc == p) {
				*supidx = suidx;
				<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (suidx == -1) {
			<span class="enscript-keyword">if</span> (adjval == 0)
				<span class="enscript-keyword">return</span>(0);
			suidx = semu_alloc(p);
			<span class="enscript-keyword">if</span> (suidx == -1)
				<span class="enscript-keyword">return</span>(ENOSPC);
			*supidx = suidx;
		}
	}

	<span class="enscript-comment">/*
	 * Look for the requested entry and adjust it (delete if adjval becomes
	 * 0).
	 */</span>
	suptr = SEMU(suidx);
	new_sueptr = NULL;
	<span class="enscript-keyword">for</span> (i = 0, suepptr = &amp;suptr-&gt;un_ent, sueptr = suptr-&gt;un_ent;
	     i &lt; suptr-&gt;un_cnt;
	     i++, suepptr = &amp;sueptr-&gt;une_next, sueptr = sueptr-&gt;une_next) {
		<span class="enscript-keyword">if</span> (sueptr-&gt;une_id != semid || sueptr-&gt;une_num != semnum)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (adjval == 0)
			sueptr-&gt;une_adjval = 0;
		<span class="enscript-keyword">else</span>
			sueptr-&gt;une_adjval += adjval;
		<span class="enscript-keyword">if</span> (sueptr-&gt;une_adjval == 0) {
			suptr-&gt;un_cnt--;
			*suepptr = sueptr-&gt;une_next;
			FREE(sueptr, M_SYSVSEM);
			sueptr = NULL;
		}
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-comment">/* Didn't find the right entry - create it */</span>
	<span class="enscript-keyword">if</span> (adjval == 0) {
		<span class="enscript-comment">/* no adjustment: no need for a new entry */</span>
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (suptr-&gt;un_cnt == limitseminfo.semume) {
		<span class="enscript-comment">/* reached the limit number of semaphore undo entries */</span>
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* allocate a new semaphore undo entry */</span>
	MALLOC(new_sueptr, <span class="enscript-type">struct</span> undo *, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> undo),
	       M_SYSVSEM, M_WAITOK);
	<span class="enscript-keyword">if</span> (new_sueptr == NULL) {
		<span class="enscript-keyword">return</span> ENOMEM;
	}

	<span class="enscript-comment">/* fill in the new semaphore undo entry */</span>
	new_sueptr-&gt;une_next = suptr-&gt;un_ent;
	suptr-&gt;un_ent = new_sueptr;
	suptr-&gt;un_cnt++;
	new_sueptr-&gt;une_adjval = adjval;
	new_sueptr-&gt;une_id = semid;
	new_sueptr-&gt;une_num = semnum;

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/* Assumes we already hold the subsystem lock.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">semundo_clear</span>(<span class="enscript-type">int</span> semid, <span class="enscript-type">int</span> semnum)
{
	<span class="enscript-type">struct</span> sem_undo *suptr;
	<span class="enscript-type">int</span> suidx;

	<span class="enscript-keyword">for</span> (suidx = semu_list_idx; suidx != -1; suidx = suptr-&gt;un_next_idx) {
		<span class="enscript-type">struct</span> undo *sueptr;
		<span class="enscript-type">struct</span> undo **suepptr;
		<span class="enscript-type">int</span> i = 0;

		suptr = SEMU(suidx);
		sueptr = suptr-&gt;un_ent;
		suepptr = &amp;suptr-&gt;un_ent;
		<span class="enscript-keyword">while</span> (i &lt; suptr-&gt;un_cnt) {
			<span class="enscript-keyword">if</span> (sueptr-&gt;une_id == semid) {
				<span class="enscript-keyword">if</span> (semnum == -1 || sueptr-&gt;une_num == semnum) {
					suptr-&gt;un_cnt--;
					*suepptr = sueptr-&gt;une_next;
					FREE(sueptr, M_SYSVSEM);
					sueptr = *suepptr;
					<span class="enscript-keyword">continue</span>;
				}
				<span class="enscript-keyword">if</span> (semnum != -1)
					<span class="enscript-keyword">break</span>;
			}
			i++;
			suepptr = &amp;sueptr-&gt;une_next;
			sueptr = sueptr-&gt;une_next;
		}
	}
}

<span class="enscript-comment">/*
 * Note that the user-mode half of this passes a union coerced to a
 * user_addr_t.  The union contains either an int or a pointer, and
 * so we have to coerce it back, variant on whether the calling
 * process is 64 bit or not.  The coercion works for the 'val' element
 * because the alignment is the same in user and kernel space.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">semctl</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> semctl_args *uap, int32_t *retval)
{
	<span class="enscript-type">int</span> semid = uap-&gt;semid;
	<span class="enscript-type">int</span> semnum = uap-&gt;semnum;
	<span class="enscript-type">int</span> cmd = uap-&gt;cmd;
	user_semun_t user_arg = (user_semun_t)uap-&gt;arg;
	kauth_cred_t cred = kauth_cred_get();
	<span class="enscript-type">int</span> i, rval, eval;
	<span class="enscript-type">struct</span> user_semid_ds sbuf;
	<span class="enscript-type">struct</span> semid_kernel *semakptr;
	

	AUDIT_ARG(svipc_cmd, cmd);
	AUDIT_ARG(svipc_id, semid);

	SYSV_SEM_SUBSYS_LOCK();

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
	printf(<span class="enscript-string">&quot;call to semctl(%d, %d, %d, 0x%qx)\n&quot;</span>, semid, semnum, cmd, user_arg);
#<span class="enscript-reference">endif</span>

	semid = IPCID_TO_IX(semid);

	<span class="enscript-keyword">if</span> (semid &lt; 0 || semid &gt;= seminfo.semmni) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;Invalid semid\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
	}

	semakptr = &amp;sema[semid];
	<span class="enscript-keyword">if</span> ((semakptr-&gt;u.sem_perm.mode &amp; SEM_ALLOC) == 0 ||
	    semakptr-&gt;u.sem_perm._seq != IPCID_TO_SEQ(uap-&gt;semid)) {
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	eval = mac_sysvsem_check_semctl(cred, semakptr, cmd);
	<span class="enscript-keyword">if</span> (eval)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
#<span class="enscript-reference">endif</span>

	eval = 0;
	rval = 0;

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPC_RMID</span>:
		<span class="enscript-keyword">if</span> ((eval = ipcperm(cred, &amp;semakptr-&gt;u.sem_perm, IPC_M))) 
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;

		semakptr-&gt;u.sem_perm.cuid = kauth_cred_getuid(cred);
		semakptr-&gt;u.sem_perm.uid = kauth_cred_getuid(cred);
		semtot -= semakptr-&gt;u.sem_nsems;
		<span class="enscript-keyword">for</span> (i = semakptr-&gt;u.sem_base - sem_pool; i &lt; semtot; i++)
			sem_pool[i] = sem_pool[i + semakptr-&gt;u.sem_nsems];
		<span class="enscript-keyword">for</span> (i = 0; i &lt; seminfo.semmni; i++) {
			<span class="enscript-keyword">if</span> ((sema[i].u.sem_perm.mode &amp; SEM_ALLOC) &amp;&amp;
			    sema[i].u.sem_base &gt; semakptr-&gt;u.sem_base)
				sema[i].u.sem_base -= semakptr-&gt;u.sem_nsems;
		}
		semakptr-&gt;u.sem_perm.mode = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_sysvsem_label_recycle(semakptr);
#<span class="enscript-reference">endif</span>
		semundo_clear(semid, -1);
		wakeup((caddr_t)semakptr);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPC_SET</span>:
		<span class="enscript-keyword">if</span> ((eval = ipcperm(cred, &amp;semakptr-&gt;u.sem_perm, IPC_M)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;

		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			<span class="enscript-type">struct</span> user64_semid_ds ds64;
			eval = copyin(user_arg.buf, &amp;ds64, <span class="enscript-keyword">sizeof</span>(ds64));
			semid_ds_64tokernel(&amp;ds64, &amp;sbuf);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_semid_ds ds32;
			eval = copyin(user_arg.buf, &amp;ds32, <span class="enscript-keyword">sizeof</span>(ds32));
			semid_ds_32tokernel(&amp;ds32, &amp;sbuf);
		}
		
		<span class="enscript-keyword">if</span> (eval != 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
		}

		semakptr-&gt;u.sem_perm.uid = sbuf.sem_perm.uid;
		semakptr-&gt;u.sem_perm.gid = sbuf.sem_perm.gid;
		semakptr-&gt;u.sem_perm.mode = (semakptr-&gt;u.sem_perm.mode &amp;
		    ~0777) | (sbuf.sem_perm.mode &amp; 0777);
		semakptr-&gt;u.sem_ctime = sysv_semtime();
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPC_STAT</span>:
		<span class="enscript-keyword">if</span> ((eval = ipcperm(cred, &amp;semakptr-&gt;u.sem_perm, IPC_R)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;

		<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
			<span class="enscript-type">struct</span> user64_semid_ds semid_ds64;
			bzero(&amp;semid_ds64, <span class="enscript-keyword">sizeof</span>(semid_ds64));
			semid_ds_kernelto64(&amp;semakptr-&gt;u, &amp;semid_ds64);
			eval = copyout(&amp;semid_ds64, user_arg.buf, <span class="enscript-keyword">sizeof</span>(semid_ds64));
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_semid_ds semid_ds32;
			bzero(&amp;semid_ds32, <span class="enscript-keyword">sizeof</span>(semid_ds32));
			semid_ds_kernelto32(&amp;semakptr-&gt;u, &amp;semid_ds32);
			eval = copyout(&amp;semid_ds32, user_arg.buf, <span class="enscript-keyword">sizeof</span>(semid_ds32));
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">GETNCNT</span>:
		<span class="enscript-keyword">if</span> ((eval = ipcperm(cred, &amp;semakptr-&gt;u.sem_perm, IPC_R)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
		<span class="enscript-keyword">if</span> (semnum &lt; 0 || semnum &gt;= semakptr-&gt;u.sem_nsems) {
			eval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
		}
		rval = semakptr-&gt;u.sem_base[semnum].semncnt;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">GETPID</span>:
		<span class="enscript-keyword">if</span> ((eval = ipcperm(cred, &amp;semakptr-&gt;u.sem_perm, IPC_R)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
		<span class="enscript-keyword">if</span> (semnum &lt; 0 || semnum &gt;= semakptr-&gt;u.sem_nsems) {
			eval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
		}
		rval = semakptr-&gt;u.sem_base[semnum].sempid;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">GETVAL</span>:
		<span class="enscript-keyword">if</span> ((eval = ipcperm(cred, &amp;semakptr-&gt;u.sem_perm, IPC_R)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
		<span class="enscript-keyword">if</span> (semnum &lt; 0 || semnum &gt;= semakptr-&gt;u.sem_nsems) {
			eval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
		}
		rval = semakptr-&gt;u.sem_base[semnum].semval;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">GETALL</span>:
		<span class="enscript-keyword">if</span> ((eval = ipcperm(cred, &amp;semakptr-&gt;u.sem_perm, IPC_R)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
<span class="enscript-comment">/* XXXXXXXXXXXXXXXX TBD XXXXXXXXXXXXXXXX */</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; semakptr-&gt;u.sem_nsems; i++) {
			<span class="enscript-comment">/* XXX could be done in one go... */</span>
			eval = copyout((caddr_t)&amp;semakptr-&gt;u.sem_base[i].semval,
			    user_arg.array + (i * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>)),
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>));
			<span class="enscript-keyword">if</span> (eval != 0)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">GETZCNT</span>:
		<span class="enscript-keyword">if</span> ((eval = ipcperm(cred, &amp;semakptr-&gt;u.sem_perm, IPC_R)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
		<span class="enscript-keyword">if</span> (semnum &lt; 0 || semnum &gt;= semakptr-&gt;u.sem_nsems) {
			eval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
		}
		rval = semakptr-&gt;u.sem_base[semnum].semzcnt;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SETVAL</span>:
		<span class="enscript-keyword">if</span> ((eval = ipcperm(cred, &amp;semakptr-&gt;u.sem_perm, IPC_W)))
                {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
			printf(<span class="enscript-string">&quot;Invalid credentials for write\n&quot;</span>);
#<span class="enscript-reference">endif</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
		}
		<span class="enscript-keyword">if</span> (semnum &lt; 0 || semnum &gt;= semakptr-&gt;u.sem_nsems)
		{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
			printf(<span class="enscript-string">&quot;Invalid number out of range for set\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			eval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
		}
		
		<span class="enscript-comment">/*
		 * Cast down a pointer instead of using 'val' member directly
		 * to avoid introducing endieness and a pad field into the
		 * header file.  Ugly, but it works.
		 */</span>
		u_int newsemval = CAST_DOWN_EXPLICIT(u_int, user_arg.buf);
		
		<span class="enscript-comment">/*
		 * The check is being performed as unsigned values to match 
		 * eventual destination
		 */</span> 
		<span class="enscript-keyword">if</span> (newsemval &gt; (u_int)seminfo.semvmx)
		{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
			printf(<span class="enscript-string">&quot;Out of range sem value for set\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			eval = ERANGE;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
		}
		semakptr-&gt;u.sem_base[semnum].semval = newsemval;
		semakptr-&gt;u.sem_base[semnum].sempid = p-&gt;p_pid;
		<span class="enscript-comment">/* XXX scottl Should there be a MAC call here? */</span>
		semundo_clear(semid, semnum);
		wakeup((caddr_t)semakptr);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SETALL</span>:
		<span class="enscript-keyword">if</span> ((eval = ipcperm(cred, &amp;semakptr-&gt;u.sem_perm, IPC_W)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
<span class="enscript-comment">/*** XXXXXXXXXXXX TBD ********/</span>
		<span class="enscript-keyword">for</span> (i = 0; i &lt; semakptr-&gt;u.sem_nsems; i++) {
			<span class="enscript-comment">/* XXX could be done in one go... */</span>
			eval = copyin(user_arg.array + (i * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>)),
			    (caddr_t)&amp;semakptr-&gt;u.sem_base[i].semval,
			    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>));
			<span class="enscript-keyword">if</span> (eval != 0)
				<span class="enscript-keyword">break</span>;
			semakptr-&gt;u.sem_base[i].sempid = p-&gt;p_pid;
		}
		<span class="enscript-comment">/* XXX scottl Should there be a MAC call here? */</span>
		semundo_clear(semid, -1);
		wakeup((caddr_t)semakptr);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
			eval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">semctlout</span>;
	}

	<span class="enscript-keyword">if</span> (eval == 0)
		*retval = rval;
<span class="enscript-reference">semctlout</span>:
	SYSV_SEM_SUBSYS_UNLOCK();
	<span class="enscript-keyword">return</span>(eval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">semget</span>(__unused <span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> semget_args *uap, int32_t *retval)
{
	<span class="enscript-type">int</span> semid, eval;
	<span class="enscript-type">int</span> key = uap-&gt;key;
	<span class="enscript-type">int</span> nsems = uap-&gt;nsems;
	<span class="enscript-type">int</span> semflg = uap-&gt;semflg;
	kauth_cred_t cred = kauth_cred_get();

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
	<span class="enscript-keyword">if</span> (key != IPC_PRIVATE)
		printf(<span class="enscript-string">&quot;semget(0x%x, %d, 0%o)\n&quot;</span>, key, nsems, semflg);
	<span class="enscript-keyword">else</span>
		printf(<span class="enscript-string">&quot;semget(IPC_PRIVATE, %d, 0%o)\n&quot;</span>, nsems, semflg);
#<span class="enscript-reference">endif</span>


	SYSV_SEM_SUBSYS_LOCK();

    
	<span class="enscript-keyword">if</span> (key != IPC_PRIVATE) {
		<span class="enscript-keyword">for</span> (semid = 0; semid &lt; seminfo.semmni; semid++) {
			<span class="enscript-keyword">if</span> ((sema[semid].u.sem_perm.mode &amp; SEM_ALLOC) &amp;&amp;
			    sema[semid].u.sem_perm._key == key)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (semid &lt; seminfo.semmni) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
			printf(<span class="enscript-string">&quot;found public key\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> ((eval = ipcperm(cred, &amp;sema[semid].u.sem_perm,
			    semflg &amp; 0700)))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semgetout</span>;
			<span class="enscript-keyword">if</span> (nsems &lt; 0 || sema[semid].u.sem_nsems &lt; nsems) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
				printf(<span class="enscript-string">&quot;too small\n&quot;</span>);
#<span class="enscript-reference">endif</span>
				eval = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semgetout</span>;
			}
			<span class="enscript-keyword">if</span> ((semflg &amp; IPC_CREAT) &amp;&amp; (semflg &amp; IPC_EXCL)) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
				printf(<span class="enscript-string">&quot;not exclusive\n&quot;</span>);
#<span class="enscript-reference">endif</span>
				eval = EEXIST;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semgetout</span>;
			}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
			eval = mac_sysvsem_check_semget(cred, &amp;sema[semid]);
			<span class="enscript-keyword">if</span> (eval) 
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semgetout</span>;
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">found</span>;
		}
	}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
	printf(<span class="enscript-string">&quot;need to allocate an id for the request\n&quot;</span>);
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (key == IPC_PRIVATE || (semflg &amp; IPC_CREAT)) {
		<span class="enscript-keyword">if</span> (nsems &lt;= 0 || nsems &gt; limitseminfo.semmsl) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
			printf(<span class="enscript-string">&quot;nsems out of range (0&lt;%d&lt;=%d)\n&quot;</span>, nsems,
			    seminfo.semmsl);
#<span class="enscript-reference">endif</span>
			eval = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">semgetout</span>;
		}
		<span class="enscript-keyword">if</span> (nsems &gt; seminfo.semmns - semtot) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
			printf(<span class="enscript-string">&quot;not enough semaphores left (need %d, got %d)\n&quot;</span>,
			    nsems, seminfo.semmns - semtot);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> (!grow_sem_pool(semtot + nsems)) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
				printf(<span class="enscript-string">&quot;failed to grow the sem array\n&quot;</span>);
#<span class="enscript-reference">endif</span>
				eval = ENOSPC;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semgetout</span>;
			}
		}
		<span class="enscript-keyword">for</span> (semid = 0; semid &lt; seminfo.semmni; semid++) {
			<span class="enscript-keyword">if</span> ((sema[semid].u.sem_perm.mode &amp; SEM_ALLOC) == 0)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (semid == seminfo.semmni) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
			printf(<span class="enscript-string">&quot;no more id's available\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">if</span> (!grow_sema_array(seminfo.semmni + 1))
			{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
				printf(<span class="enscript-string">&quot;failed to grow sema array\n&quot;</span>);
#<span class="enscript-reference">endif</span>
				eval = ENOSPC;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semgetout</span>;
			}
		}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;semid %d is available\n&quot;</span>, semid);
#<span class="enscript-reference">endif</span>
		sema[semid].u.sem_perm._key = key;
		sema[semid].u.sem_perm.cuid = kauth_cred_getuid(cred);
		sema[semid].u.sem_perm.uid = kauth_cred_getuid(cred);
		sema[semid].u.sem_perm.cgid = kauth_cred_getgid(cred);
		sema[semid].u.sem_perm.gid = kauth_cred_getgid(cred);
		sema[semid].u.sem_perm.mode = (semflg &amp; 0777) | SEM_ALLOC;
		sema[semid].u.sem_perm._seq =
		    (sema[semid].u.sem_perm._seq + 1) &amp; 0x7fff;
		sema[semid].u.sem_nsems = nsems;
		sema[semid].u.sem_otime = 0;
		sema[semid].u.sem_ctime = sysv_semtime();
		sema[semid].u.sem_base = &amp;sem_pool[semtot];
		semtot += nsems;
		bzero(sema[semid].u.sem_base,
		    <span class="enscript-keyword">sizeof</span>(sema[semid].u.sem_base[0])*nsems);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
		mac_sysvsem_label_associate(cred, &amp;sema[semid]);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;sembase = 0x%x, next = 0x%x\n&quot;</span>, sema[semid].u.sem_base,
		    &amp;sem_pool[semtot]);
#<span class="enscript-reference">endif</span>
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;didn't find it and wasn't asked to create it\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		eval = ENOENT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">semgetout</span>;
	}

<span class="enscript-reference">found</span>:
	*retval = IXSEQ_TO_IPCID(semid, sema[semid].u.sem_perm);
	AUDIT_ARG(svipc_id, *retval);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
	printf(<span class="enscript-string">&quot;semget is done, returning %d\n&quot;</span>, *retval);
#<span class="enscript-reference">endif</span>
	eval = 0;

<span class="enscript-reference">semgetout</span>:
	SYSV_SEM_SUBSYS_UNLOCK();
	<span class="enscript-keyword">return</span>(eval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">semop</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> semop_args *uap, int32_t *retval)
{
	<span class="enscript-type">int</span> semid = uap-&gt;semid;
	<span class="enscript-type">int</span> nsops = uap-&gt;nsops;
	<span class="enscript-type">struct</span> sembuf sops[seminfo.semopm];
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> semid_kernel *semakptr;
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> sembuf *sopptr = NULL;	<span class="enscript-comment">/* protected by 'semptr' */</span>
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> sem *semptr = NULL;	<span class="enscript-comment">/* protected by 'if' */</span>
	<span class="enscript-type">int</span> supidx = -1;
	<span class="enscript-type">int</span> i, j, eval;
	<span class="enscript-type">int</span> do_wakeup, do_undos;

	AUDIT_ARG(svipc_id, uap-&gt;semid);

	SYSV_SEM_SUBSYS_LOCK();

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
	printf(<span class="enscript-string">&quot;call to semop(%d, 0x%x, %d)\n&quot;</span>, semid, sops, nsops);
#<span class="enscript-reference">endif</span>

	semid = IPCID_TO_IX(semid);	<span class="enscript-comment">/* Convert back to zero origin */</span>

	<span class="enscript-keyword">if</span> (semid &lt; 0 || semid &gt;= seminfo.semmni) {
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">semopout</span>;
	}

	semakptr = &amp;sema[semid];
	<span class="enscript-keyword">if</span> ((semakptr-&gt;u.sem_perm.mode &amp; SEM_ALLOC) == 0) {
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">semopout</span>;
	}
	<span class="enscript-keyword">if</span> (semakptr-&gt;u.sem_perm._seq != IPCID_TO_SEQ(uap-&gt;semid)) {
		eval = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">semopout</span>;
	}

	<span class="enscript-keyword">if</span> ((eval = ipcperm(kauth_cred_get(), &amp;semakptr-&gt;u.sem_perm, IPC_W))) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;eval = %d from ipaccess\n&quot;</span>, eval);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">semopout</span>;
	}

	<span class="enscript-keyword">if</span> (nsops &lt; 0 || nsops &gt; seminfo.semopm) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;too many sops (max=%d, nsops=%d)\n&quot;</span>,
		    seminfo.semopm, nsops);
#<span class="enscript-reference">endif</span>
		eval = E2BIG;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">semopout</span>;
	}
	
	<span class="enscript-comment">/*  OK for LP64, since sizeof(struct sembuf) is currently invariant */</span>
	<span class="enscript-keyword">if</span> ((eval = copyin(uap-&gt;sops, &amp;sops, nsops * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sembuf))) != 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;eval = %d from copyin(%08x, %08x, %ld)\n&quot;</span>, eval,
		    uap-&gt;sops, &amp;sops, nsops * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sembuf));
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">semopout</span>;
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/*
	 * Initial pass thru sops to see what permissions are needed.
	 */</span>
	j = 0;		<span class="enscript-comment">/* permission needed */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; nsops; i++)
		j |= (sops[i].sem_op == 0) ? SEM_R : SEM_A;

	<span class="enscript-comment">/*
	 * The MAC hook checks whether the thread has read (and possibly
	 * write) permissions to the semaphore array based on the
	 * sopptr-&gt;sem_op value.
	 */</span>
	eval = mac_sysvsem_check_semop(kauth_cred_get(), semakptr, j);
	<span class="enscript-keyword">if</span> (eval)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">semopout</span>;
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Loop trying to satisfy the vector of requests.
	 * If we reach a point where we must wait, any requests already
	 * performed are rolled back and we go to sleep until some other
	 * process wakes us up.  At this point, we start all over again.
	 *
	 * This ensures that from the perspective of other tasks, a set
	 * of requests is atomic (never partially satisfied).
	 */</span>
	do_undos = 0;

	<span class="enscript-keyword">for</span> (;;) {
		do_wakeup = 0;

		<span class="enscript-keyword">for</span> (i = 0; i &lt; nsops; i++) {
			sopptr = &amp;sops[i];

			<span class="enscript-keyword">if</span> (sopptr-&gt;sem_num &gt;= semakptr-&gt;u.sem_nsems) {
				eval = EFBIG;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">semopout</span>;
			}

			semptr = &amp;semakptr-&gt;u.sem_base[sopptr-&gt;sem_num];

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
			printf(<span class="enscript-string">&quot;semop:  semakptr=%x, sem_base=%x, semptr=%x, sem[%d]=%d : op=%d, flag=%s\n&quot;</span>,
			    semakptr, semakptr-&gt;u.sem_base, semptr,
			    sopptr-&gt;sem_num, semptr-&gt;semval, sopptr-&gt;sem_op,
			    (sopptr-&gt;sem_flg &amp; IPC_NOWAIT) ? <span class="enscript-string">&quot;nowait&quot;</span> : <span class="enscript-string">&quot;wait&quot;</span>);
#<span class="enscript-reference">endif</span>

			<span class="enscript-keyword">if</span> (sopptr-&gt;sem_op &lt; 0) {
				<span class="enscript-keyword">if</span> (semptr-&gt;semval + sopptr-&gt;sem_op &lt; 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
					printf(<span class="enscript-string">&quot;semop:  can't do it now\n&quot;</span>);
#<span class="enscript-reference">endif</span>
					<span class="enscript-keyword">break</span>;
				} <span class="enscript-keyword">else</span> {
					semptr-&gt;semval += sopptr-&gt;sem_op;
					<span class="enscript-keyword">if</span> (semptr-&gt;semval == 0 &amp;&amp;
					    semptr-&gt;semzcnt &gt; 0)
						do_wakeup = 1;
				}
				<span class="enscript-keyword">if</span> (sopptr-&gt;sem_flg &amp; SEM_UNDO)
					do_undos = 1;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (sopptr-&gt;sem_op == 0) {
				<span class="enscript-keyword">if</span> (semptr-&gt;semval &gt; 0) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
					printf(<span class="enscript-string">&quot;semop:  not zero now\n&quot;</span>);
#<span class="enscript-reference">endif</span>
					<span class="enscript-keyword">break</span>;
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (semptr-&gt;semncnt &gt; 0)
					do_wakeup = 1;
				semptr-&gt;semval += sopptr-&gt;sem_op;
				<span class="enscript-keyword">if</span> (sopptr-&gt;sem_flg &amp; SEM_UNDO)
					do_undos = 1;
			}
		}

		<span class="enscript-comment">/*
		 * Did we get through the entire vector?
		 */</span>
		<span class="enscript-keyword">if</span> (i &gt;= nsops)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

		<span class="enscript-comment">/*
		 * No ... rollback anything that we've already done
		 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;semop:  rollback 0 through %d\n&quot;</span>, i-1);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">for</span> (j = 0; j &lt; i; j++)
			semakptr-&gt;u.sem_base[sops[j].sem_num].semval -=
			    sops[j].sem_op;

		<span class="enscript-comment">/*
		 * If the request that we couldn't satisfy has the
		 * NOWAIT flag set then return with EAGAIN.
		 */</span>
		<span class="enscript-keyword">if</span> (sopptr-&gt;sem_flg &amp; IPC_NOWAIT) {
			eval = EAGAIN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">semopout</span>;
		}

		<span class="enscript-keyword">if</span> (sopptr-&gt;sem_op == 0)
			semptr-&gt;semzcnt++;
		<span class="enscript-keyword">else</span>
			semptr-&gt;semncnt++;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;semop:  good night!\n&quot;</span>);
#<span class="enscript-reference">endif</span>
		<span class="enscript-comment">/* Release our lock on the semaphore subsystem so
		 * another thread can get at the semaphore we are
		 * waiting for. We will get the lock back after we
		 * wake up.
		 */</span>
		eval = msleep((caddr_t)semakptr, &amp;sysv_sem_subsys_mutex , (PZERO - 4) | PCATCH,
		    <span class="enscript-string">&quot;semwait&quot;</span>, 0);
                
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;semop:  good morning (eval=%d)!\n&quot;</span>, eval);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (eval != 0) {
			eval = EINTR;
		}

		<span class="enscript-comment">/*
		 * IMPORTANT: while we were asleep, the semaphore array might
		 * have been reallocated somewhere else (see grow_sema_array()).
		 * When we wake up, we have to re-lookup the semaphore 
		 * structures and re-validate them.
		 */</span>

		semptr = NULL;

		<span class="enscript-comment">/*
		 * Make sure that the semaphore still exists
		 *
		 * XXX POSIX: Third test this 'if' and 'EINTR' precedence may
		 * fail testing; if so, we will need to revert this code.
		 */</span>
	 	semakptr = &amp;sema[semid];   <span class="enscript-comment">/* sema may have been reallocated */</span>
		<span class="enscript-keyword">if</span> ((semakptr-&gt;u.sem_perm.mode &amp; SEM_ALLOC) == 0 ||
		    semakptr-&gt;u.sem_perm._seq != IPCID_TO_SEQ(uap-&gt;semid) ||
		    sopptr-&gt;sem_num &gt;= semakptr-&gt;u.sem_nsems) {
			<span class="enscript-comment">/* The man page says to return EIDRM. */</span>
			<span class="enscript-comment">/* Unfortunately, BSD doesn't define that code! */</span>
			<span class="enscript-keyword">if</span> (eval == EINTR) {
				<span class="enscript-comment">/*
				 * EINTR takes precedence over the fact that
				 * the semaphore disappeared while we were
				 * sleeping...
				 */</span>
			} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">EIDRM</span>
				eval = EIDRM;
#<span class="enscript-reference">else</span>
				eval = EINVAL;		<span class="enscript-comment">/* Ancient past */</span>
#<span class="enscript-reference">endif</span>
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">semopout</span>;
		}

		<span class="enscript-comment">/*
		 * The semaphore is still alive.  Readjust the count of
		 * waiting processes. semptr needs to be recomputed
		 * because the sem[] may have been reallocated while
		 * we were sleeping, updating our sem_base pointer.
		 */</span>
		semptr = &amp;semakptr-&gt;u.sem_base[sopptr-&gt;sem_num];
		<span class="enscript-keyword">if</span> (sopptr-&gt;sem_op == 0)
			semptr-&gt;semzcnt--;
		<span class="enscript-keyword">else</span>
			semptr-&gt;semncnt--;

		<span class="enscript-keyword">if</span> (eval != 0) { <span class="enscript-comment">/* EINTR */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">semopout</span>;
		}
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-comment">/*
	 * Process any SEM_UNDO requests.
	 */</span>
	<span class="enscript-keyword">if</span> (do_undos) {
		<span class="enscript-keyword">for</span> (i = 0; i &lt; nsops; i++) {
			<span class="enscript-comment">/*
			 * We only need to deal with SEM_UNDO's for non-zero
			 * op's.
			 */</span>
			<span class="enscript-type">int</span> adjval;

			<span class="enscript-keyword">if</span> ((sops[i].sem_flg &amp; SEM_UNDO) == 0)
				<span class="enscript-keyword">continue</span>;
			adjval = sops[i].sem_op;
			<span class="enscript-keyword">if</span> (adjval == 0)
				<span class="enscript-keyword">continue</span>;
			eval = semundo_adjust(p, &amp;supidx, semid,
			    sops[i].sem_num, -adjval);
			<span class="enscript-keyword">if</span> (eval == 0)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-comment">/*
			 * Oh-Oh!  We ran out of either sem_undo's or undo's.
			 * Rollback the adjustments to this point and then
			 * rollback the semaphore ups and down so we can return
			 * with an error with all structures restored.  We
			 * rollback the undo's in the exact reverse order that
			 * we applied them.  This guarantees that we won't run
			 * out of space as we roll things back out.
			 */</span>
			<span class="enscript-keyword">for</span> (j = i - 1; j &gt;= 0; j--) {
				<span class="enscript-keyword">if</span> ((sops[j].sem_flg &amp; SEM_UNDO) == 0)
					<span class="enscript-keyword">continue</span>;
				adjval = sops[j].sem_op;
				<span class="enscript-keyword">if</span> (adjval == 0)
					<span class="enscript-keyword">continue</span>;
				<span class="enscript-keyword">if</span> (semundo_adjust(p, &amp;supidx, semid,
				    sops[j].sem_num, adjval) != 0)
					panic(<span class="enscript-string">&quot;semop - can't undo undos&quot;</span>);
			}

			<span class="enscript-keyword">for</span> (j = 0; j &lt; nsops; j++)
				semakptr-&gt;u.sem_base[sops[j].sem_num].semval -=
				    sops[j].sem_op;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
			printf(<span class="enscript-string">&quot;eval = %d from semundo_adjust\n&quot;</span>, eval);
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">semopout</span>;
		} <span class="enscript-comment">/* loop through the sops */</span>
	} <span class="enscript-comment">/* if (do_undos) */</span>

	<span class="enscript-comment">/* We're definitely done - set the sempid's */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; nsops; i++) {
		sopptr = &amp;sops[i];
		semptr = &amp;semakptr-&gt;u.sem_base[sopptr-&gt;sem_num];
		semptr-&gt;sempid = p-&gt;p_pid;
	}
	semakptr-&gt;u.sem_otime = sysv_semtime();

	<span class="enscript-keyword">if</span> (do_wakeup) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
		printf(<span class="enscript-string">&quot;semop:  doing wakeup\n&quot;</span>);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_WAKEUP</span>
		sem_wakeup((caddr_t)semakptr);
#<span class="enscript-reference">else</span>
		wakeup((caddr_t)semakptr);
#<span class="enscript-reference">endif</span>
		printf(<span class="enscript-string">&quot;semop:  back from wakeup\n&quot;</span>);
#<span class="enscript-reference">else</span>
		wakeup((caddr_t)semakptr);
#<span class="enscript-reference">endif</span>
	}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
	printf(<span class="enscript-string">&quot;semop:  done\n&quot;</span>);
#<span class="enscript-reference">endif</span>
	*retval = 0;
	eval = 0;
<span class="enscript-reference">semopout</span>:
	SYSV_SEM_SUBSYS_UNLOCK();
	<span class="enscript-keyword">return</span>(eval);
}

<span class="enscript-comment">/*
 * Go through the undo structures for this process and apply the adjustments to
 * semaphores.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">semexit</span>(<span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">register</span> <span class="enscript-type">struct</span> sem_undo *suptr = NULL;
	<span class="enscript-type">int</span> suidx;
	<span class="enscript-type">int</span> *supidx;
	<span class="enscript-type">int</span> did_something;

	<span class="enscript-comment">/* If we have not allocated our semaphores yet there can't be
	 * anything to undo, but we need the lock to prevent
	 * dynamic memory race conditions.
	 */</span>
	SYSV_SEM_SUBSYS_LOCK();

	<span class="enscript-keyword">if</span> (!sem_pool)
	{
		SYSV_SEM_SUBSYS_UNLOCK();
		<span class="enscript-keyword">return</span>;
	}
	did_something = 0;

	<span class="enscript-comment">/*
	 * Go through the chain of undo vectors looking for one
	 * associated with this process.
	 */</span>

	<span class="enscript-keyword">for</span> (supidx = &amp;semu_list_idx; (suidx = *supidx) != -1;
	    supidx = &amp;suptr-&gt;un_next_idx) {
		suptr = SEMU(suidx);
		<span class="enscript-keyword">if</span> (suptr-&gt;un_proc == p)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (suidx == -1)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">unlock</span>;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
	printf(<span class="enscript-string">&quot;proc @%08x has undo structure with %d entries\n&quot;</span>, p,
	    suptr-&gt;un_cnt);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * If there are any active undo elements then process them.
	 */</span>
	<span class="enscript-keyword">if</span> (suptr-&gt;un_cnt &gt; 0) {
		<span class="enscript-keyword">while</span> (suptr-&gt;un_ent != NULL) {
			<span class="enscript-type">struct</span> undo *sueptr;
			<span class="enscript-type">int</span> semid;
			<span class="enscript-type">int</span> semnum;
			<span class="enscript-type">int</span> adjval;
			<span class="enscript-type">struct</span> semid_kernel *semakptr;

			sueptr = suptr-&gt;un_ent;
			semid = sueptr-&gt;une_id;
			semnum = sueptr-&gt;une_num;
			adjval = sueptr-&gt;une_adjval;

			semakptr = &amp;sema[semid];
			<span class="enscript-keyword">if</span> ((semakptr-&gt;u.sem_perm.mode &amp; SEM_ALLOC) == 0)
				panic(<span class="enscript-string">&quot;semexit - semid not allocated&quot;</span>);
			<span class="enscript-keyword">if</span> (semnum &gt;= semakptr-&gt;u.sem_nsems)
				panic(<span class="enscript-string">&quot;semexit - semnum out of range&quot;</span>);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
			printf(<span class="enscript-string">&quot;semexit:  %08x id=%d num=%d(adj=%d) ; sem=%d\n&quot;</span>,
			       suptr-&gt;un_proc,
			       semid,
			       semnum,
			       adjval,
			       semakptr-&gt;u.sem_base[semnum].semval);
#<span class="enscript-reference">endif</span>

			<span class="enscript-keyword">if</span> (adjval &lt; 0) {
				<span class="enscript-keyword">if</span> (semakptr-&gt;u.sem_base[semnum].semval &lt; -adjval)
					semakptr-&gt;u.sem_base[semnum].semval = 0;
				<span class="enscript-keyword">else</span>
					semakptr-&gt;u.sem_base[semnum].semval +=
					    adjval;
			} <span class="enscript-keyword">else</span>
				semakptr-&gt;u.sem_base[semnum].semval += adjval;

		<span class="enscript-comment">/* Maybe we should build a list of semakptr's to wake
		 * up, finish all access to data structures, release the
		 * subsystem lock, and wake all the processes.  Something
		 * to think about.
		 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_WAKEUP</span>
			sem_wakeup((caddr_t)semakptr);
#<span class="enscript-reference">else</span>
			wakeup((caddr_t)semakptr);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
			printf(<span class="enscript-string">&quot;semexit:  back from wakeup\n&quot;</span>);
#<span class="enscript-reference">endif</span>
			suptr-&gt;un_cnt--;
			suptr-&gt;un_ent = sueptr-&gt;une_next;
			FREE(sueptr, M_SYSVSEM);
			sueptr = NULL;
		}
	}

	<span class="enscript-comment">/*
	 * Deallocate the undo vector.
	 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SEM_DEBUG</span>
	printf(<span class="enscript-string">&quot;removing vector\n&quot;</span>);
#<span class="enscript-reference">endif</span>
	suptr-&gt;un_proc = NULL;
	*supidx = suptr-&gt;un_next_idx;

<span class="enscript-reference">unlock</span>:
	<span class="enscript-comment">/*
         * There is a semaphore leak (i.e. memory leak) in this code.
         * We should be deleting the IPC_PRIVATE semaphores when they are
         * no longer needed, and we dont. We would have to track which processes
         * know about which IPC_PRIVATE semaphores, updating the list after
         * every fork.  We can't just delete them semaphore when the process
         * that created it dies, because that process may well have forked
         * some children.  So we need to wait until all of it's children have
         * died, and so on.  Maybe we should tag each IPC_PRIVATE sempahore
         * with the creating group ID, count the number of processes left in
         * that group, and delete the semaphore when the group is gone.
         * Until that code gets implemented we will leak IPC_PRIVATE semaphores.
         * There is an upper bound on the size of our semaphore array, so   
         * leaking the semaphores should not work as a DOS attack.
         *
         * Please note that the original BSD code this file is based on had the
         * same leaky semaphore problem.
         */</span>

	SYSV_SEM_SUBSYS_UNLOCK();
}


<span class="enscript-comment">/* (struct sysctl_oid *oidp, void *arg1, int arg2, \
        struct sysctl_req *req) */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_seminfo</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1,
	__unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> error = 0;

	error = SYSCTL_OUT(req, arg1, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
	<span class="enscript-keyword">if</span> (error || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span>(error);

	SYSV_SEM_SUBSYS_LOCK();

	<span class="enscript-comment">/* Set the values only if shared memory is not initialised */</span>
	<span class="enscript-keyword">if</span> ((sem_pool == NULL) &amp;&amp; 
		(sema == NULL) &amp;&amp; 
		(semu == NULL) &amp;&amp; 
		(semu_list_idx == -1)) {
			<span class="enscript-keyword">if</span> ((error = SYSCTL_IN(req, arg1, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)))) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
	} <span class="enscript-keyword">else</span> 
		error = EINVAL;
<span class="enscript-reference">out</span>:
	SYSV_SEM_SUBSYS_UNLOCK();
	<span class="enscript-keyword">return</span>(error);
	
}

<span class="enscript-comment">/* SYSCTL_NODE(_kern, KERN_SYSV, sysv, CTLFLAG_RW, 0, &quot;SYSV&quot;); */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> sysctl_oid_list sysctl__kern_sysv_children;
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_sysv, OID_AUTO, semmni, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;limitseminfo.semmni, 0, &amp;sysctl_seminfo ,<span class="enscript-string">&quot;I&quot;</span>,<span class="enscript-string">&quot;semmni&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_sysv, OID_AUTO, semmns, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;limitseminfo.semmns, 0, &amp;sysctl_seminfo ,<span class="enscript-string">&quot;I&quot;</span>,<span class="enscript-string">&quot;semmns&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_sysv, OID_AUTO, semmnu, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;limitseminfo.semmnu, 0, &amp;sysctl_seminfo ,<span class="enscript-string">&quot;I&quot;</span>,<span class="enscript-string">&quot;semmnu&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_sysv, OID_AUTO, semmsl, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;limitseminfo.semmsl, 0, &amp;sysctl_seminfo ,<span class="enscript-string">&quot;I&quot;</span>,<span class="enscript-string">&quot;semmsl&quot;</span>);
    
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_sysv, OID_AUTO, semume, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;limitseminfo.semume, 0, &amp;sysctl_seminfo ,<span class="enscript-string">&quot;I&quot;</span>,<span class="enscript-string">&quot;semume&quot;</span>);


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">IPCS_sem_sysctl</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1,
	__unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> cursor;
	<span class="enscript-type">union</span> {
		<span class="enscript-type">struct</span> user32_IPCS_command u32;
		<span class="enscript-type">struct</span> user_IPCS_command u64;
	} ipcs;
	<span class="enscript-type">struct</span> user32_semid_ds semid_ds32;	<span class="enscript-comment">/* post conversion, 32 bit version */</span>
	<span class="enscript-type">struct</span> user64_semid_ds semid_ds64;	<span class="enscript-comment">/* post conversion, 64 bit version */</span>
	<span class="enscript-type">void</span> *semid_dsp;
	size_t ipcs_sz;
	size_t semid_ds_sz;
	<span class="enscript-type">struct</span> proc *p = current_proc();

	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p)) {
		ipcs_sz = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user_IPCS_command);
		semid_ds_sz = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user64_semid_ds);
	} <span class="enscript-keyword">else</span> {
		ipcs_sz = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_IPCS_command);
		semid_ds_sz = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_semid_ds);
	}

	<span class="enscript-comment">/* Copy in the command structure */</span>
	<span class="enscript-keyword">if</span> ((error = SYSCTL_IN(req, &amp;ipcs, ipcs_sz)) != 0) {
		<span class="enscript-keyword">return</span>(error);
	}

	<span class="enscript-keyword">if</span> (!IS_64BIT_PROCESS(p)) <span class="enscript-comment">/* convert in place */</span>
		ipcs.u64.ipcs_data = CAST_USER_ADDR_T(ipcs.u32.ipcs_data);

	<span class="enscript-comment">/* Let us version this interface... */</span>
	<span class="enscript-keyword">if</span> (ipcs.u64.ipcs_magic != IPCS_MAGIC) {
		<span class="enscript-keyword">return</span>(EINVAL);
	}

	SYSV_SEM_SUBSYS_LOCK();
	<span class="enscript-keyword">switch</span>(ipcs.u64.ipcs_op) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPCS_SEM_CONF</span>:	<span class="enscript-comment">/* Obtain global configuration data */</span>
		<span class="enscript-keyword">if</span> (ipcs.u64.ipcs_datalen != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> seminfo)) {
			error = ERANGE;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (ipcs.u64.ipcs_cursor != 0) {	<span class="enscript-comment">/* fwd. compat. */</span>
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		error = copyout(&amp;seminfo, ipcs.u64.ipcs_data, ipcs.u64.ipcs_datalen);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">IPCS_SEM_ITER</span>:	<span class="enscript-comment">/* Iterate over existing segments */</span>
		cursor = ipcs.u64.ipcs_cursor;
		<span class="enscript-keyword">if</span> (cursor &lt; 0 || cursor &gt;= seminfo.semmni) {
			error = ERANGE;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (ipcs.u64.ipcs_datalen != (<span class="enscript-type">int</span>)semid_ds_sz ) {
			error = EINVAL;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">for</span>( ; cursor &lt; seminfo.semmni; cursor++) {
			<span class="enscript-keyword">if</span> (sema[cursor].u.sem_perm.mode &amp; SEM_ALLOC)
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (cursor == seminfo.semmni) {
			error = ENOENT;
			<span class="enscript-keyword">break</span>;
		}

		semid_dsp = &amp;sema[cursor].u;	<span class="enscript-comment">/* default: 64 bit */</span>

		<span class="enscript-comment">/*
		 * If necessary, convert the 64 bit kernel segment
		 * descriptor to a 32 bit user one.
		 */</span>
		<span class="enscript-keyword">if</span> (!IS_64BIT_PROCESS(p)) {
			bzero(&amp;semid_ds32, <span class="enscript-keyword">sizeof</span>(semid_ds32));
			semid_ds_kernelto32(semid_dsp, &amp;semid_ds32);
			semid_dsp = &amp;semid_ds32;
		} <span class="enscript-keyword">else</span> {
			bzero(&amp;semid_ds64, <span class="enscript-keyword">sizeof</span>(semid_ds64));
			semid_ds_kernelto64(semid_dsp, &amp;semid_ds64);
			semid_dsp = &amp;semid_ds64;
		}

		error = copyout(semid_dsp, ipcs.u64.ipcs_data, ipcs.u64.ipcs_datalen);
		<span class="enscript-keyword">if</span> (!error) {
			<span class="enscript-comment">/* update cursor */</span>
			ipcs.u64.ipcs_cursor = cursor + 1;

			<span class="enscript-keyword">if</span> (!IS_64BIT_PROCESS(p))       <span class="enscript-comment">/* convert in place */</span>
				ipcs.u32.ipcs_data = CAST_DOWN_EXPLICIT(user32_addr_t,ipcs.u64.ipcs_data);

			error = SYSCTL_OUT(req, &amp;ipcs, ipcs_sz);
		}
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}
	SYSV_SEM_SUBSYS_UNLOCK();
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-function-name">SYSCTL_DECL</span>(_kern_sysv_ipcs);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_sysv_ipcs, OID_AUTO, sem, CTLFLAG_RW | CTLFLAG_ANYBODY | CTLFLAG_LOCKED,
	0, 0, IPCS_sem_sysctl,
	<span class="enscript-string">&quot;S,IPCS_sem_command&quot;</span>,
	<span class="enscript-string">&quot;ipcs sem command interface&quot;</span>);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* SYSV_SEM */</span>
</pre>
<hr />
</body></html>