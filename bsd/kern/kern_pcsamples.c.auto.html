<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_pcsamples.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_pcsamples.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>

vm_offset_t pc_buftomem = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> * 	pc_buffer   = 0;   <span class="enscript-comment">/* buffer that holds each pc */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> * 	pc_bufptr   = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> * 	pc_buflast  = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> npcbufs         = 8192;      <span class="enscript-comment">/* number of pc entries in buffer */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pc_bufsize      = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pcsample_flags  = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pcsample_enable = 0;

pid_t pc_sample_pid = 0;
boolean_t pc_trace_frameworks = FALSE;

<span class="enscript-type">char</span> pcsample_comm[MAXCOMLEN + 1];

<span class="enscript-comment">/* Set the default framework boundaries */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pcsample_beg    = 0;
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pcsample_end    = 0;

<span class="enscript-type">static</span> pid_t global_state_pid = -1;       <span class="enscript-comment">/* Used to control exclusive use of pc_buffer */</span>

<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pc_trace_buf[];
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> pc_trace_cnt;

<span class="enscript-type">void</span> <span class="enscript-function-name">add_pcbuffer</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">branch_tracing_enabled</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">disable_branch_tracing</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">enable_branch_tracing</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">pcsamples_bootstrap</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">pcsamples_clear</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">pcsamples_control</span>(<span class="enscript-type">int</span> *name, u_int namelen, user_addr_t where, size_t *sizep);
<span class="enscript-type">int</span> <span class="enscript-function-name">pcsamples_read</span>(user_addr_t buffer, size_t *number);
<span class="enscript-type">int</span> <span class="enscript-function-name">pcsamples_reinit</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">int</span>
<span class="enscript-function-name">enable_branch_tracing</span>(<span class="enscript-type">void</span>)
{
  <span class="enscript-type">struct</span> proc *p;
  <span class="enscript-keyword">if</span> (-1 != pc_sample_pid) {
    p = proc_find(pc_sample_pid);
    <span class="enscript-keyword">if</span> (p) {
      p-&gt;p_btrace = 1;
	 proc_rele(p);
    } 
  }
  <span class="enscript-keyword">else</span> {
    pc_trace_frameworks = TRUE;
  }

  <span class="enscript-keyword">return</span> 1;

}

<span class="enscript-type">int</span>
<span class="enscript-function-name">disable_branch_tracing</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">struct</span> proc *p;
    <span class="enscript-keyword">switch</span> (pc_sample_pid) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">-1</span>:
        pc_trace_frameworks = FALSE;
        <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
        p = proc_find(pc_sample_pid);
        <span class="enscript-keyword">if</span> (p) {
            p-&gt;p_btrace = 0;
			proc_rele(p);
        }
        <span class="enscript-keyword">break</span>;
    }
    clr_be_bit();
    <span class="enscript-keyword">return</span> 1;
}

<span class="enscript-comment">/*
 * this only works for the current proc as it
 * is called from context_switch in the scheduler
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">branch_tracing_enabled</span>(<span class="enscript-type">void</span>)
{
  <span class="enscript-type">struct</span> proc *p = current_proc();
  <span class="enscript-keyword">if</span> (TRUE == pc_trace_frameworks) <span class="enscript-keyword">return</span> TRUE;
  <span class="enscript-keyword">if</span> (p) {
    <span class="enscript-keyword">return</span> (p-&gt;p_btrace);
  }
  <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">add_pcbuffer</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span>      i;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>  pc; 

	<span class="enscript-keyword">if</span> (!pcsample_enable)
	  <span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">for</span> (i=0; i &lt; pc_trace_cnt; i++)
	  {
	    pc = pc_trace_buf[i];
	    
	    <span class="enscript-keyword">if</span> ((pcsample_beg &lt;= pc) &amp;&amp; (pc &lt; pcsample_end))
	      {
		<span class="enscript-keyword">if</span> (pc_bufptr &gt; pc_buffer)
		  {
		    <span class="enscript-keyword">if</span> ( (*(pc_bufptr-1)) == pc )
		      <span class="enscript-keyword">continue</span>;   <span class="enscript-comment">/* Ignore, probably spinning */</span>
		  }

		<span class="enscript-comment">/* Then the sample is in our range */</span>
		*pc_bufptr = pc;
		pc_bufptr++;
	      }
	  }

	<span class="enscript-comment">/* We never wrap the buffer */</span>
	<span class="enscript-keyword">if</span> ((pc_bufptr + pc_trace_cnt) &gt;= pc_buflast)
	  {
	    pcsample_enable = 0;
	    (<span class="enscript-type">void</span>)disable_branch_tracing();
	    wakeup(&amp;pcsample_enable);
	  }
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pcsamples_bootstrap</span>(<span class="enscript-type">void</span>)
{
        <span class="enscript-keyword">if</span> (!disable_branch_tracing())
            <span class="enscript-keyword">return</span>(ENOTSUP);

	pc_bufsize = npcbufs * <span class="enscript-keyword">sizeof</span>(* pc_buffer);
	<span class="enscript-keyword">if</span> (kmem_alloc(kernel_map, &amp;pc_buftomem,
		       (vm_size_t)pc_bufsize) == KERN_SUCCESS) 
	  pc_buffer = (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *) pc_buftomem;
	<span class="enscript-keyword">else</span> 
	  pc_buffer = NULL;

	<span class="enscript-keyword">if</span> (pc_buffer) {
		pc_bufptr = pc_buffer;
		pc_buflast = &amp;pc_bufptr[npcbufs];
		pcsample_enable = 0;
		<span class="enscript-keyword">return</span>(0);
	} <span class="enscript-keyword">else</span> {
		pc_bufsize=0;
		<span class="enscript-keyword">return</span>(EINVAL);
	}
	
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pcsamples_reinit</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span> ret=0;

    pcsample_enable = 0;

	<span class="enscript-keyword">if</span> (pc_bufsize &amp;&amp; pc_buffer)
		kmem_free(kernel_map, (vm_offset_t)pc_buffer, pc_bufsize);

	ret= pcsamples_bootstrap();
	<span class="enscript-keyword">return</span>(ret);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pcsamples_clear</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-comment">/* Clean up the sample buffer, set defaults */</span> 
    global_state_pid = -1;
	pcsample_enable = 0;
	<span class="enscript-keyword">if</span>(pc_bufsize &amp;&amp; pc_buffer)
	  kmem_free(kernel_map, (vm_offset_t)pc_buffer, pc_bufsize);
	pc_buffer   = NULL;
	pc_bufptr   = NULL;
	pc_buflast  = NULL;
	pc_bufsize  = 0;
	pcsample_beg= 0;
	pcsample_end= 0;
	bzero((<span class="enscript-type">void</span> *)pcsample_comm, <span class="enscript-keyword">sizeof</span>(pcsample_comm));
	(<span class="enscript-type">void</span>)disable_branch_tracing();
	pc_sample_pid = 0;
	pc_trace_frameworks = FALSE;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pcsamples_control</span>(<span class="enscript-type">int</span> *name, __unused u_int namelen, user_addr_t where, size_t *sizep)
{
    <span class="enscript-type">int</span> ret=0;
    size_t size=*sizep;
    <span class="enscript-type">int</span> value = name[1];
    pcinfo_t pc_bufinfo;
    pid_t *pidcheck;

    pid_t curpid;
    <span class="enscript-type">struct</span> proc *p, *curproc;

    <span class="enscript-keyword">if</span> (name[0] != PCSAMPLE_GETNUMBUF)
    { 
        curproc = current_proc();
	    <span class="enscript-keyword">if</span> (curproc)
	      curpid = curproc-&gt;p_pid;
	    <span class="enscript-keyword">else</span>
	      <span class="enscript-keyword">return</span> (ESRCH);

	    <span class="enscript-keyword">if</span> (global_state_pid == -1)
	      global_state_pid = curpid;
	    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (global_state_pid != curpid)
	      {
		<span class="enscript-keyword">if</span>((p = proc_find(global_state_pid)) == NULL)
		  {
		    <span class="enscript-comment">/* The global pid no longer exists */</span>
		    global_state_pid = curpid;
		  }
		<span class="enscript-keyword">else</span>
		  {
			proc_rele(p);
		    <span class="enscript-comment">/* The global pid exists, deny this request */</span>
		    <span class="enscript-keyword">return</span>(EBUSY);
		  }
        }
    }


	<span class="enscript-keyword">switch</span>(name[0]) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">PCSAMPLE_DISABLE</span>:    <span class="enscript-comment">/* used to disable */</span>
		  pcsample_enable=0;
		  <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">PCSAMPLE_SETNUMBUF</span>:
            <span class="enscript-comment">/* The buffer size is bounded by a min and max number of samples */</span>
            <span class="enscript-keyword">if</span> (value &lt; pc_trace_cnt) {
                ret=EINVAL;
			     <span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (value &lt;= MAX_PCSAMPLES)
                <span class="enscript-comment">/*	npcbufs = value &amp; ~(PC_TRACE_CNT-1); */</span>
                npcbufs = value;
			<span class="enscript-keyword">else</span>
                npcbufs = MAX_PCSAMPLES;
			<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">PCSAMPLE_GETNUMBUF</span>:
            <span class="enscript-keyword">if</span> (size &lt; <span class="enscript-keyword">sizeof</span>(pc_bufinfo)) {
                ret=EINVAL;
			    <span class="enscript-keyword">break</span>;
			}
			pc_bufinfo.npcbufs = npcbufs;
			pc_bufinfo.bufsize = pc_bufsize;
			pc_bufinfo.enable = pcsample_enable;
			pc_bufinfo.pcsample_beg = pcsample_beg;
			pc_bufinfo.pcsample_end = pcsample_end;
			<span class="enscript-keyword">if</span>(copyout (&amp;pc_bufinfo, where, <span class="enscript-keyword">sizeof</span>(pc_bufinfo)))
			  {
			    ret=EINVAL;
			  }
			<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">PCSAMPLE_SETUP</span>:
			ret=pcsamples_reinit();
			<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">PCSAMPLE_REMOVE</span>:
			pcsamples_clear();
			<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">PCSAMPLE_READBUF</span>:
		        <span class="enscript-comment">/* A nonzero value says enable and wait on the buffer */</span>
		        <span class="enscript-comment">/* A zero value says read up the buffer immediately */</span>
		        <span class="enscript-keyword">if</span> (value == 0)
			  {
			    <span class="enscript-comment">/* Do not wait on the buffer */</span>
			    pcsample_enable = 0;
			    (<span class="enscript-type">void</span>)disable_branch_tracing();
			    ret = pcsamples_read(where, sizep);
			    <span class="enscript-keyword">break</span>;
			  }
		        <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((pc_bufsize &lt;= 0) || (!pc_buffer))
			{
			  <span class="enscript-comment">/* enable only if buffer is initialized */</span>
			  ret=EINVAL;
			  <span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/* Turn on branch tracing */</span>
			<span class="enscript-keyword">if</span> (!enable_branch_tracing())
			  {
			    ret = ENOTSUP;
			    <span class="enscript-keyword">break</span>;
			  }

			<span class="enscript-comment">/* Enable sampling */</span>
		        pcsample_enable = 1;

			ret = tsleep(&amp;pcsample_enable, PRIBIO | PCATCH, <span class="enscript-string">&quot;pcsample&quot;</span>, 0);
			pcsample_enable = 0;
			(<span class="enscript-type">void</span>)disable_branch_tracing();

			<span class="enscript-keyword">if</span> (ret)
			  {
			    <span class="enscript-comment">/*	Eventually fix this...  if (ret != EINTR) */</span>
			    <span class="enscript-keyword">if</span> (ret)
			      {
				<span class="enscript-comment">/* On errors, except EINTR, we want to cleanup buffer ptrs */</span>
				<span class="enscript-comment">/* pc_bufptr = pc_buffer; */</span>
				*sizep = 0;
			      }
			  }
			<span class="enscript-keyword">else</span>
			  {
			    <span class="enscript-comment">/* The only way to get here is if the buffer is full */</span>
			    ret = pcsamples_read(where, sizep);
			  }

			<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">PCSAMPLE_SETREG</span>:
		        <span class="enscript-keyword">if</span> (size &lt; <span class="enscript-keyword">sizeof</span>(pc_bufinfo))
			  {
			    ret = EINVAL;
			    <span class="enscript-keyword">break</span>;
			  }
			<span class="enscript-keyword">if</span> (copyin(where, &amp;pc_bufinfo, <span class="enscript-keyword">sizeof</span>(pc_bufinfo)))
			  {
			    ret = EINVAL;
			    <span class="enscript-keyword">break</span>;
			  }

			pcsample_beg = pc_bufinfo.pcsample_beg;
			pcsample_end = pc_bufinfo.pcsample_end;
			<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">PCSAMPLE_COMM</span>:
            <span class="enscript-keyword">if</span> (!(<span class="enscript-keyword">sizeof</span>(pcsample_comm) &gt; size)) 
            {
                ret = EINVAL;
                <span class="enscript-keyword">break</span>;
            }
            bzero((<span class="enscript-type">void</span> *)pcsample_comm, <span class="enscript-keyword">sizeof</span>(pcsample_comm));
			<span class="enscript-keyword">if</span> (copyin(where, pcsample_comm, size)) 
			{
                ret = EINVAL;
			    <span class="enscript-keyword">break</span>;
            }

			<span class="enscript-comment">/* Check for command name or pid */</span>
			<span class="enscript-keyword">if</span> (pcsample_comm[0] != <span class="enscript-string">'\0'</span>) 
			{
			    ret= ENOTSUP;
			    <span class="enscript-keyword">break</span>;
            }
			<span class="enscript-keyword">else</span>
			  {
			    <span class="enscript-keyword">if</span> (size != (2 * <span class="enscript-keyword">sizeof</span>(pid_t)))
			    {
			      ret = EINVAL;
			      <span class="enscript-keyword">break</span>;
			    }
			    <span class="enscript-keyword">else</span>
			      {
				pidcheck = (pid_t *)pcsample_comm;
				pc_sample_pid = pidcheck[1];
			      }
			  }
		        <span class="enscript-keyword">break</span>;
    <span class="enscript-reference">default</span>:
		        ret= ENOTSUP;
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span>(ret);
}


<span class="enscript-comment">/* 
   This buffer must be read up in one call.
   If the buffer isn't big enough to hold
   all the samples, it will copy up enough
   to fill the buffer and throw the rest away.
   This buffer never wraps.
*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">pcsamples_read</span>(user_addr_t buffer, size_t *number)
{
    size_t count=0;
    size_t copycount;

	count = (*number)/<span class="enscript-keyword">sizeof</span>(* pc_buffer);

	<span class="enscript-keyword">if</span> (count &amp;&amp; pc_bufsize &amp;&amp; pc_buffer)
	  {
	      copycount = pc_bufptr - pc_buffer;
	      
	      <span class="enscript-keyword">if</span> (copycount &lt;= 0)
		{
		  *number = 0;
		  <span class="enscript-keyword">return</span>(0);
		}

	      <span class="enscript-keyword">if</span> (copycount &gt; count)
		copycount = count;

	      <span class="enscript-comment">/* We actually have data to send up */</span>
	      <span class="enscript-keyword">if</span>(copyout(pc_buffer, buffer, copycount * <span class="enscript-keyword">sizeof</span>(* pc_buffer)))
		{
		  *number = 0;
		  <span class="enscript-keyword">return</span>(EINVAL);
		}
	      *number = copycount;
	      pc_bufptr = pc_buffer;
	      <span class="enscript-keyword">return</span>(0);
	  }
	<span class="enscript-keyword">else</span>
	  {
	    *number = 0;
	    <span class="enscript-keyword">return</span>(0);
	  }
}

</pre>
<hr />
</body></html>