<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>subr_log.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">subr_log.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2010 Apple, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)subr_log.c	8.3 (Berkeley) 2/14/95
 */</span>

<span class="enscript-comment">/*
 * Error log buffer for kernel printf's.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/msgbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/select.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

<span class="enscript-comment">/* XXX should be in a common header somewhere */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">logwakeup</span>(<span class="enscript-type">void</span>);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOG_RDPRI</span>	(PZERO + 1)

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOG_NBIO</span>	0x02
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOG_ASYNC</span>	0x04
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOG_RDWAIT</span>	0x08

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MAX_UNREAD_CHARS</span> (CONFIG_MSG_BSIZE/2)
<span class="enscript-comment">/* All globals should be accessed under LOG_LOCK() */</span>

<span class="enscript-comment">/* logsoftc only valid while log_open=1 */</span>
<span class="enscript-type">struct</span> logsoftc {
	<span class="enscript-type">int</span>	sc_state;		<span class="enscript-comment">/* see above for possibilities */</span>
	<span class="enscript-type">struct</span>	selinfo sc_selp;	<span class="enscript-comment">/* thread waiting for select */</span>
	<span class="enscript-type">int</span>	sc_pgid;		<span class="enscript-comment">/* process/group for async I/O */</span>
} logsoftc;

<span class="enscript-type">int</span>	log_open;			<span class="enscript-comment">/* also used in log() */</span>
<span class="enscript-type">char</span> smsg_bufc[CONFIG_MSG_BSIZE]; <span class="enscript-comment">/* static buffer */</span>
<span class="enscript-type">struct</span> msgbuf msgbuf = {MSG_MAGIC,<span class="enscript-keyword">sizeof</span>(smsg_bufc),0,0,smsg_bufc};
<span class="enscript-type">struct</span> msgbuf *msgbufp <span class="enscript-function-name">__attribute__</span>((used)) = &amp;msgbuf;

<span class="enscript-comment">/* the following are implemented in osfmk/kern/printf.c  */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bsd_log_lock</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bsd_log_unlock</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">bsd_log_init</span>(<span class="enscript-type">void</span>);

<span class="enscript-comment">/* XXX wants a linker set so these can be static */</span>
<span class="enscript-type">extern</span> d_open_t         logopen;
<span class="enscript-type">extern</span> d_close_t        logclose;
<span class="enscript-type">extern</span> d_read_t         logread;
<span class="enscript-type">extern</span> d_ioctl_t        logioctl;
<span class="enscript-type">extern</span> d_select_t       logselect;

<span class="enscript-comment">/*
 * Serialize log access.  Note that the log can be written at interrupt level,
 * so any log manipulations that can be done from, or affect, another processor
 * at interrupt level must be guarded with a spin lock.
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LOG_LOCK</span>() bsd_log_lock()
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">LOG_UNLOCK</span>() bsd_log_unlock()

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">LOG_SETSIZE_DEBUG</span>(x...) kprintf(x)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">LOG_SETSIZE_DEBUG</span>(x...) do { } while(0)
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_kern_msgbuf</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp,
				<span class="enscript-type">void</span> *arg1,
				<span class="enscript-type">int</span> arg2,
				<span class="enscript-type">struct</span> sysctl_req *req);

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">logopen</span>(__unused dev_t dev, __unused <span class="enscript-type">int</span> flags, __unused <span class="enscript-type">int</span> mode, <span class="enscript-type">struct</span> proc *p)
{
	LOG_LOCK();
	<span class="enscript-keyword">if</span> (log_open) {
		LOG_UNLOCK();
		<span class="enscript-keyword">return</span> (EBUSY);
	}
	logsoftc.sc_pgid = p-&gt;p_pid;		<span class="enscript-comment">/* signal process only */</span>
	log_open = 1;

	LOG_UNLOCK();

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">logclose</span>(__unused dev_t dev, __unused <span class="enscript-type">int</span> flag, __unused <span class="enscript-type">int</span> devtype, __unused <span class="enscript-type">struct</span> proc *p)
{
	LOG_LOCK();
	selwakeup(&amp;logsoftc.sc_selp);
	selthreadclear(&amp;logsoftc.sc_selp);
	log_open = 0;
	LOG_UNLOCK();
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">logread</span>(__unused dev_t dev, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">int</span> flag)
{
	<span class="enscript-type">int</span> l;
	<span class="enscript-type">int</span> error = 0;

	LOG_LOCK();
	<span class="enscript-keyword">while</span> (msgbufp-&gt;msg_bufr == msgbufp-&gt;msg_bufx) {
		<span class="enscript-keyword">if</span> (flag &amp; IO_NDELAY) {
			error = EWOULDBLOCK;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		<span class="enscript-keyword">if</span> (logsoftc.sc_state &amp; LOG_NBIO) {
			error = EWOULDBLOCK;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		logsoftc.sc_state |= LOG_RDWAIT;
		LOG_UNLOCK();
		<span class="enscript-comment">/*
		 * If the wakeup is missed 
		 * then wait for 5 sec and reevaluate 
		 */</span>
		<span class="enscript-keyword">if</span> ((error = tsleep((caddr_t)msgbufp, LOG_RDPRI | PCATCH,
				<span class="enscript-string">&quot;klog&quot;</span>, 5 * hz)) != 0) {
			<span class="enscript-comment">/* if it times out; ignore */</span>
			<span class="enscript-keyword">if</span> (error != EWOULDBLOCK)
				<span class="enscript-keyword">return</span> (error);
		}
		LOG_LOCK();
	}
	logsoftc.sc_state &amp;= ~LOG_RDWAIT;

	<span class="enscript-keyword">while</span> (uio_resid(uio) &gt; 0) {
		<span class="enscript-type">int</span> readpos;

		l = msgbufp-&gt;msg_bufx - msgbufp-&gt;msg_bufr;
		<span class="enscript-keyword">if</span> (l &lt; 0)
			l = msgbufp-&gt;msg_size - msgbufp-&gt;msg_bufr;
		l = min(l, uio_resid(uio));
		<span class="enscript-keyword">if</span> (l == 0)
			<span class="enscript-keyword">break</span>;

		readpos = msgbufp-&gt;msg_bufr;
		LOG_UNLOCK();
		error = uiomove((caddr_t)&amp;msgbufp-&gt;msg_bufc[readpos],
			l, uio);
		LOG_LOCK();
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">break</span>;
		msgbufp-&gt;msg_bufr = readpos + l;
		<span class="enscript-keyword">if</span> (msgbufp-&gt;msg_bufr &gt;= msgbufp-&gt;msg_size)
			msgbufp-&gt;msg_bufr = 0;
	}
<span class="enscript-reference">out</span>:
	LOG_UNLOCK();
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">logselect</span>(__unused dev_t dev, <span class="enscript-type">int</span> rw, <span class="enscript-type">void</span> * wql, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-keyword">switch</span> (rw) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FREAD</span>:
		LOG_LOCK();	
		<span class="enscript-keyword">if</span> (msgbufp-&gt;msg_bufr != msgbufp-&gt;msg_bufx) {
			LOG_UNLOCK();
			<span class="enscript-keyword">return</span> (1);
		}
		selrecord(p, &amp;logsoftc.sc_selp, wql);
		LOG_UNLOCK();
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">logwakeup</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> pgid;

	LOG_LOCK();	
	<span class="enscript-keyword">if</span> (!log_open) {
		LOG_UNLOCK();
		<span class="enscript-keyword">return</span>;
	}
	selwakeup(&amp;logsoftc.sc_selp);
	<span class="enscript-keyword">if</span> (logsoftc.sc_state &amp; LOG_ASYNC) {
		pgid = logsoftc.sc_pgid;
		LOG_UNLOCK();
		<span class="enscript-keyword">if</span> (pgid &lt; 0)
			gsignal(-pgid, SIGIO); 
		<span class="enscript-keyword">else</span> 
			proc_signal(pgid, SIGIO);
		LOG_LOCK();
	}
	<span class="enscript-keyword">if</span> (logsoftc.sc_state &amp; LOG_RDWAIT) {
		wakeup((caddr_t)msgbufp);
		logsoftc.sc_state &amp;= ~LOG_RDWAIT;
	}
	LOG_UNLOCK();
}


<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">logioctl</span>(__unused dev_t dev, u_long com, caddr_t data, __unused <span class="enscript-type">int</span> flag, __unused <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> l;

	LOG_LOCK();
	<span class="enscript-keyword">switch</span> (com) {

	<span class="enscript-comment">/* return number of characters immediately available */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIONREAD</span>:
		l = msgbufp-&gt;msg_bufx - msgbufp-&gt;msg_bufr;
		<span class="enscript-keyword">if</span> (l &lt; 0)
			l += msgbufp-&gt;msg_size;
		*(off_t *)data = l;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIONBIO</span>:
		<span class="enscript-keyword">if</span> (*(<span class="enscript-type">int</span> *)data)
			logsoftc.sc_state |= LOG_NBIO;
		<span class="enscript-keyword">else</span>
			logsoftc.sc_state &amp;= ~LOG_NBIO;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIOASYNC</span>:
		<span class="enscript-keyword">if</span> (*(<span class="enscript-type">int</span> *)data)
			logsoftc.sc_state |= LOG_ASYNC;
		<span class="enscript-keyword">else</span>
			logsoftc.sc_state &amp;= ~LOG_ASYNC;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TIOCSPGRP</span>:
		logsoftc.sc_pgid = *(<span class="enscript-type">int</span> *)data;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TIOCGPGRP</span>:
		*(<span class="enscript-type">int</span> *)data = logsoftc.sc_pgid;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		LOG_UNLOCK();
		<span class="enscript-keyword">return</span> (-1);
	}
	LOG_UNLOCK();
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">bsd_log_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/* After this point, we must be ready to accept characters */</span>
}


<span class="enscript-comment">/*
 * log_putc_locked
 *
 * Decription:	Output a character to the log; assumes the LOG_LOCK() is held
 *		by the caller.
 *
 * Parameters:	c				Character to output
 *
 * Returns:	(void)
 *
 * Notes:	This functions is used for multibyte output to the log; it
 *		should be used preferrentially where possible to ensure that
 *		log entries do not end up interspersed due to preemption or
 *		SMP reentrancy.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">log_putc_locked</span>(<span class="enscript-type">char</span> c)
{
	<span class="enscript-type">struct</span> msgbuf *mbp;

	mbp = msgbufp; 
	mbp-&gt;msg_bufc[mbp-&gt;msg_bufx++] = c;
	<span class="enscript-keyword">if</span> (mbp-&gt;msg_bufx &gt;= msgbufp-&gt;msg_size)
		mbp-&gt;msg_bufx = 0;
}


<span class="enscript-comment">/*
 * log_putc
 *
 * Decription:	Output a character to the log; assumes the LOG_LOCK() is NOT
 *		held by the caller.
 *
 * Parameters:	c				Character to output
 *
 * Returns:	(void)
 *
 * Notes:	This function is used for syingle byte output to the log.  It
 *		primarily exists to maintain binary backward compatibility.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">log_putc</span>(<span class="enscript-type">char</span> c)
{
	<span class="enscript-type">int</span> unread_count = 0;
	LOG_LOCK();
	log_putc_locked(c);
	unread_count = msgbufp-&gt;msg_bufx - msgbufp-&gt;msg_bufr;
	LOG_UNLOCK();

	<span class="enscript-keyword">if</span> (unread_count &lt; 0)
		unread_count = 0 - unread_count;
	<span class="enscript-keyword">if</span> (c == <span class="enscript-string">'\n'</span> || unread_count &gt;= MAX_UNREAD_CHARS)
		logwakeup();
}


<span class="enscript-comment">/*
 * it is possible to increase the kernel log buffer size by adding
 *   msgbuf=n
 * to the kernel command line, and to read the current size using
 *   sysctl kern.msgbuf
 * If there is no parameter on the kernel command line, the buffer is
 * allocated statically and is CONFIG_MSG_BSIZE characters in size, otherwise
 * memory is dynamically allocated. Memory management must already be up.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">log_setsize</span>(<span class="enscript-type">int</span> size) {
	<span class="enscript-type">char</span> *new_logdata;
	<span class="enscript-type">int</span> new_logsize, new_bufr, new_bufx;
	<span class="enscript-type">char</span> *old_logdata;
	<span class="enscript-type">int</span> old_logsize, old_bufr, old_bufx;
	<span class="enscript-type">int</span> i, count;
	<span class="enscript-type">char</span> *p, ch;

	<span class="enscript-keyword">if</span> (size &gt; MAX_MSG_BSIZE)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (size &lt;= 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	new_logsize = size;
	<span class="enscript-keyword">if</span> (!(new_logdata = (<span class="enscript-type">char</span>*)kalloc(size))) {
		printf(<span class="enscript-string">&quot;log_setsize: unable to allocate memory\n&quot;</span>);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}
	bzero(new_logdata, new_logsize);

	LOG_LOCK();

	old_logsize = msgbufp-&gt;msg_size;
	old_logdata = msgbufp-&gt;msg_bufc;
	old_bufr = msgbufp-&gt;msg_bufr;
	old_bufx = msgbufp-&gt;msg_bufx;

	LOG_SETSIZE_DEBUG(<span class="enscript-string">&quot;log_setsize(%d): old_logdata %p old_logsize %d old_bufr %d old_bufx %d\n&quot;</span>,
					  size, old_logdata, old_logsize, old_bufr, old_bufx);

	<span class="enscript-comment">/* start &quot;new_logsize&quot; bytes before the write pointer */</span>
	<span class="enscript-keyword">if</span> (new_logsize &lt;= old_bufx) {
		count = new_logsize;
		p = old_logdata + old_bufx - count;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * if new buffer is bigger, copy what we have and let the
		 * bzero above handle the difference
		 */</span>
		count = MIN(new_logsize, old_logsize);
		p = old_logdata + old_logsize - (count - old_bufx);
	}
	<span class="enscript-keyword">for</span> (i = 0; i &lt; count; i++) {
		<span class="enscript-keyword">if</span> (p &gt;= old_logdata + old_logsize)
			p = old_logdata;

		ch = *p++;
		new_logdata[i] = ch;
	}

	new_bufx = i;
	<span class="enscript-keyword">if</span> (new_bufx &gt;= new_logsize)
		new_bufx = 0;
	msgbufp-&gt;msg_bufx = new_bufx;

	new_bufr = old_bufx - old_bufr; <span class="enscript-comment">/* how much were we trailing bufx by? */</span>
	<span class="enscript-keyword">if</span> (new_bufr &lt; 0)
		new_bufr += old_logsize;
	new_bufr = new_bufx - new_bufr; <span class="enscript-comment">/* now relative to oldest data in new buffer */</span>
	<span class="enscript-keyword">if</span> (new_bufr &lt; 0)
		new_bufr += new_logsize;
	msgbufp-&gt;msg_bufr = new_bufr;

	msgbufp-&gt;msg_size = new_logsize;
	msgbufp-&gt;msg_bufc = new_logdata;

	LOG_SETSIZE_DEBUG(<span class="enscript-string">&quot;log_setsize(%d): new_logdata %p new_logsize %d new_bufr %d new_bufx %d\n&quot;</span>,
					  size, new_logdata, new_logsize, new_bufr, new_bufx);

	LOG_UNLOCK();

	<span class="enscript-comment">/* this memory is now dead - clear it so that it compresses better
	   in case of suspend to disk etc. */</span>
	bzero(old_logdata, old_logsize);
	<span class="enscript-keyword">if</span> (old_logdata != smsg_bufc) {
		<span class="enscript-comment">/* dynamic memory that must be freed */</span>
		kfree(old_logdata, old_logsize);
	}

	printf(<span class="enscript-string">&quot;set system log size to %d bytes\n&quot;</span>, new_logsize);

	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, msgbuf, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, 0, 0, sysctl_kern_msgbuf, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_kern_msgbuf</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp __unused,
							  <span class="enscript-type">void</span> *arg1 __unused,
							  <span class="enscript-type">int</span> arg2 __unused,
							  <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> old_bufsize, bufsize;
	<span class="enscript-type">int</span> error;

	LOG_LOCK();
	old_bufsize = bufsize = msgbufp-&gt;msg_size;
	LOG_UNLOCK();

	error = sysctl_io_number(req, bufsize, <span class="enscript-keyword">sizeof</span>(bufsize), &amp;bufsize, NULL);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	<span class="enscript-keyword">if</span> (bufsize != old_bufsize) {
		error = log_setsize(bufsize);
	}

	<span class="enscript-keyword">return</span> (error);
}


<span class="enscript-comment">/*
 * This should be called by /sbin/dmesg only via libproc.
 * It returns as much data still in the buffer as possible.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">log_dmesg</span>(user_addr_t buffer, uint32_t buffersize, int32_t * retval) {
	uint32_t i;
	uint32_t localbuff_size;
	<span class="enscript-type">int</span> error = 0, newl, skip;
	<span class="enscript-type">char</span> *localbuff, *p, *copystart, ch;
	size_t copysize;

	LOG_LOCK();
	localbuff_size = (msgbufp-&gt;msg_size + 2); <span class="enscript-comment">/* + '\n' + '\0' */</span>
	LOG_UNLOCK();

	<span class="enscript-comment">/* Allocate a temporary non-circular buffer for copyout */</span>
	<span class="enscript-keyword">if</span> (!(localbuff = (<span class="enscript-type">char</span> *)kalloc(localbuff_size))) {
		printf(<span class="enscript-string">&quot;log_dmesg: unable to allocate memory\n&quot;</span>);
		<span class="enscript-keyword">return</span> (ENOMEM);
	}

	<span class="enscript-comment">/* in between here, the log could become bigger, but that's fine */</span>
	LOG_LOCK();

	<span class="enscript-comment">/*
	 * The message buffer is circular; start at the write pointer, and
	 * make one loop up to write pointer - 1.
	 */</span>
	p = msgbufp-&gt;msg_bufc + msgbufp-&gt;msg_bufx;
	<span class="enscript-keyword">for</span> (i = newl = skip = 0; p != msgbufp-&gt;msg_bufc + msgbufp-&gt;msg_bufx - 1; ++p) {
		<span class="enscript-keyword">if</span> (p &gt;= msgbufp-&gt;msg_bufc + msgbufp-&gt;msg_size)
			p = msgbufp-&gt;msg_bufc;
		ch = *p;
		<span class="enscript-comment">/* Skip &quot;\n&lt;.*&gt;&quot; syslog sequences. */</span>
		<span class="enscript-keyword">if</span> (skip) {
			<span class="enscript-keyword">if</span> (ch == <span class="enscript-string">'&gt;'</span>)
				newl = skip = 0;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (newl &amp;&amp; ch == <span class="enscript-string">'&lt;'</span>) {
			skip = 1;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> (ch == <span class="enscript-string">'\0'</span>)
			<span class="enscript-keyword">continue</span>;
		newl = (ch == <span class="enscript-string">'\n'</span>);
		localbuff[i++] = ch;
		<span class="enscript-comment">/* The original version of this routine contained a buffer
		 * overflow. At the time, a &quot;small&quot; targeted fix was desired
		 * so the change below to check the buffer bounds was made.
		 * TODO: rewrite this needlessly convoluted routine.
		 */</span>
		<span class="enscript-keyword">if</span> (i == (localbuff_size - 2))
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (!newl)
		localbuff[i++] = <span class="enscript-string">'\n'</span>;
	localbuff[i++] = 0;

	<span class="enscript-keyword">if</span> (buffersize &gt;= i) {
		copystart = localbuff;
		copysize = i;
	} <span class="enscript-keyword">else</span> {
		copystart = localbuff + i - buffersize;
		copysize = buffersize;
	}

	LOG_UNLOCK();

	error = copyout(copystart, buffer, copysize);
	<span class="enscript-keyword">if</span> (!error)
		*retval = copysize;

	kfree(localbuff, localbuff_size);
	<span class="enscript-keyword">return</span> (error);
}
</pre>
<hr />
</body></html>