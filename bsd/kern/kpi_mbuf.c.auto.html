<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kpi_mbuf.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kpi_mbuf.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2004-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">__KPI__</span>
<span class="enscript-comment">//#include &lt;sys/kpi_interface.h&gt;
</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip_var.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;net/net_str_id.h&quot;</span>

<span class="enscript-comment">/* mbuf flags visible to KPI clients; do not add private flags here */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> mbuf_flags_t mbuf_flags_mask = (MBUF_EXT | MBUF_PKTHDR | MBUF_EOR |
    MBUF_LOOP | MBUF_BCAST | MBUF_MCAST | MBUF_FRAG | MBUF_FIRSTFRAG |
    MBUF_LASTFRAG | MBUF_PROMISC | MBUF_HASFCS);

<span class="enscript-comment">/* Unalterable mbuf flags */</span>
<span class="enscript-type">static</span> <span class="enscript-type">const</span> mbuf_flags_t mbuf_cflags_mask = (MBUF_EXT);

<span class="enscript-type">void</span>* <span class="enscript-function-name">mbuf_data</span>(mbuf_t mbuf)
{
	<span class="enscript-keyword">return</span> mbuf-&gt;m_data;
}

<span class="enscript-type">void</span>* <span class="enscript-function-name">mbuf_datastart</span>(mbuf_t mbuf)
{
	<span class="enscript-keyword">if</span> (mbuf-&gt;m_flags &amp; M_EXT)
		<span class="enscript-keyword">return</span> mbuf-&gt;m_ext.ext_buf;
	<span class="enscript-keyword">if</span> (mbuf-&gt;m_flags &amp; M_PKTHDR)
		<span class="enscript-keyword">return</span> mbuf-&gt;m_pktdat;
	<span class="enscript-keyword">return</span> mbuf-&gt;m_dat;
}

errno_t <span class="enscript-function-name">mbuf_setdata</span>(mbuf_t mbuf, <span class="enscript-type">void</span>* data, size_t len)
{
	size_t	start = (size_t)((<span class="enscript-type">char</span>*)mbuf_datastart(mbuf));
	size_t	maxlen = mbuf_maxlen(mbuf);
	
	<span class="enscript-keyword">if</span> ((size_t)data &lt; start || ((size_t)data) + len &gt; start + maxlen)
		<span class="enscript-keyword">return</span> EINVAL;
	mbuf-&gt;m_data = data;
	mbuf-&gt;m_len = len;
	
	<span class="enscript-keyword">return</span> 0;
}

errno_t <span class="enscript-function-name">mbuf_align_32</span>(mbuf_t mbuf, size_t len)
{
	<span class="enscript-keyword">if</span> ((mbuf-&gt;m_flags &amp; M_EXT) != 0 &amp;&amp; m_mclhasreference(mbuf))
		<span class="enscript-keyword">return</span> ENOTSUP;
	mbuf-&gt;m_data = mbuf_datastart(mbuf);
	mbuf-&gt;m_data += ((mbuf_trailingspace(mbuf) - len) &amp;~ (<span class="enscript-keyword">sizeof</span>(u_int32_t) - 1));
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/* This function is used to provide mcl_to_paddr via symbol indirection,
 * please avoid any change in behavior or remove the indirection in 
 * config/Unsupported*
 */</span>
addr64_t <span class="enscript-function-name">mbuf_data_to_physical</span>(<span class="enscript-type">void</span>* ptr)
{
	<span class="enscript-keyword">return</span> ((addr64_t)mcl_to_paddr(ptr));
}

errno_t <span class="enscript-function-name">mbuf_get</span>(mbuf_how_t how, mbuf_type_t type, mbuf_t *mbuf)
{
	<span class="enscript-comment">/* Must set *mbuf to NULL in failure case */</span>
	*mbuf = m_get(how, type);
	
	<span class="enscript-keyword">return</span> (*mbuf == NULL) ? ENOMEM : 0;
}

errno_t <span class="enscript-function-name">mbuf_gethdr</span>(mbuf_how_t how, mbuf_type_t type, mbuf_t *mbuf)
{
	<span class="enscript-comment">/* Must set *mbuf to NULL in failure case */</span>
	*mbuf = m_gethdr(how, type);
	
	<span class="enscript-keyword">return</span> (*mbuf == NULL) ? ENOMEM : 0;
}

errno_t
<span class="enscript-function-name">mbuf_attachcluster</span>(mbuf_how_t how, mbuf_type_t type, mbuf_t *mbuf,
    caddr_t extbuf, <span class="enscript-type">void</span> (*extfree)(caddr_t , u_int, caddr_t),
    size_t extsize, caddr_t extarg)
{
	<span class="enscript-keyword">if</span> (mbuf == NULL || extbuf == NULL || extfree == NULL || extsize == 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> ((*mbuf = m_clattach(*mbuf, type, extbuf,
	    extfree, extsize, extarg, how)) == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">mbuf_alloccluster</span>(mbuf_how_t how, size_t *size, caddr_t *addr)
{
	<span class="enscript-keyword">if</span> (size == NULL || *size == 0 || addr == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	*addr = NULL;

	<span class="enscript-comment">/* Jumbo cluster pool not available? */</span>
	<span class="enscript-keyword">if</span> (*size &gt; MBIGCLBYTES &amp;&amp; njcl == 0)
		<span class="enscript-keyword">return</span> (ENOTSUP);

	<span class="enscript-keyword">if</span> (*size &lt;= MCLBYTES &amp;&amp; (*addr = m_mclalloc(how)) != NULL)
		*size = MCLBYTES;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*size &gt; MCLBYTES &amp;&amp; *size &lt;= MBIGCLBYTES &amp;&amp;
	    (*addr = m_bigalloc(how)) != NULL)
		*size = MBIGCLBYTES;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (*size &gt; MBIGCLBYTES &amp;&amp; *size &lt;= M16KCLBYTES &amp;&amp;
	    (*addr = m_16kalloc(how)) != NULL)
		*size = M16KCLBYTES;
	<span class="enscript-keyword">else</span>
		*size = 0;

	<span class="enscript-keyword">if</span> (*addr == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_freecluster</span>(caddr_t addr, size_t size)
{
	<span class="enscript-keyword">if</span> (size != MCLBYTES &amp;&amp; size != MBIGCLBYTES &amp;&amp; size != M16KCLBYTES)
		panic(<span class="enscript-string">&quot;%s: invalid size (%ld) for cluster %p&quot;</span>, __func__,
		    size, (<span class="enscript-type">void</span> *)addr);

	<span class="enscript-keyword">if</span> (size == MCLBYTES)
		m_mclfree(addr);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (size == MBIGCLBYTES)
		m_bigfree(addr, MBIGCLBYTES, NULL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (njcl &gt; 0)
		m_16kfree(addr, M16KCLBYTES, NULL);
	<span class="enscript-keyword">else</span>
		panic(<span class="enscript-string">&quot;%s: freeing jumbo cluster to an empty pool&quot;</span>, __func__);
}

errno_t
<span class="enscript-function-name">mbuf_getcluster</span>(mbuf_how_t how, mbuf_type_t type, size_t size, mbuf_t* mbuf)
{
	<span class="enscript-comment">/* Must set *mbuf to NULL in failure case */</span>
	errno_t	error = 0;
	<span class="enscript-type">int</span>	created = 0;

	<span class="enscript-keyword">if</span> (mbuf == NULL)
		<span class="enscript-keyword">return</span> EINVAL;
	<span class="enscript-keyword">if</span> (*mbuf == NULL) {
		*mbuf = m_get(how, type);
		<span class="enscript-keyword">if</span> (*mbuf == NULL)
			<span class="enscript-keyword">return</span> ENOMEM;
		created = 1;
	}
	<span class="enscript-comment">/*
	 * At the time this code was written, m_{mclget,mbigget,m16kget}
	 * would always return the same value that was passed in to it.
	 */</span>
	<span class="enscript-keyword">if</span> (size == MCLBYTES) {
		*mbuf = m_mclget(*mbuf, how);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (size == MBIGCLBYTES) {
		*mbuf = m_mbigget(*mbuf, how);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (size == M16KCLBYTES) {
		<span class="enscript-keyword">if</span> (njcl &gt; 0) {
			*mbuf = m_m16kget(*mbuf, how);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Jumbo cluster pool not available? */</span>
			error = ENOTSUP;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	} <span class="enscript-keyword">else</span> {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (*mbuf == NULL || ((*mbuf)-&gt;m_flags &amp; M_EXT) == 0)
		error = ENOMEM;
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (created &amp;&amp; error != 0) {
		mbuf_free(*mbuf);
		*mbuf = NULL;
	}
	<span class="enscript-keyword">return</span> error;	
}

errno_t <span class="enscript-function-name">mbuf_mclget</span>(mbuf_how_t how, mbuf_type_t type, mbuf_t *mbuf)
{
	<span class="enscript-comment">/* Must set *mbuf to NULL in failure case */</span>
	errno_t	error = 0;
	<span class="enscript-type">int</span>		created = 0;
	<span class="enscript-keyword">if</span> (mbuf == NULL) <span class="enscript-keyword">return</span> EINVAL;
	<span class="enscript-keyword">if</span> (*mbuf == NULL) {
		error = mbuf_get(how, type, mbuf);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> error;
		created = 1;
	}
	
	<span class="enscript-comment">/*
	 * At the time this code was written, m_mclget would always
	 * return the same value that was passed in to it.
	 */</span>
	*mbuf = m_mclget(*mbuf, how);
	
	<span class="enscript-keyword">if</span> (created &amp;&amp; ((*mbuf)-&gt;m_flags &amp; M_EXT) == 0) {
		mbuf_free(*mbuf);
		*mbuf = NULL;
	}
	<span class="enscript-keyword">if</span> (*mbuf == NULL || ((*mbuf)-&gt;m_flags &amp; M_EXT) == 0)
		error = ENOMEM;
	<span class="enscript-keyword">return</span> error;	
}


errno_t <span class="enscript-function-name">mbuf_getpacket</span>(mbuf_how_t how, mbuf_t *mbuf)
{
	<span class="enscript-comment">/* Must set *mbuf to NULL in failure case */</span>
	errno_t	error = 0;
	
	*mbuf = m_getpacket_how(how);
	
	<span class="enscript-keyword">if</span> (*mbuf == NULL) {
		<span class="enscript-keyword">if</span> (how == MBUF_WAITOK)
			error = ENOMEM;
		<span class="enscript-keyword">else</span>
			error = EWOULDBLOCK;
	}
	
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-comment">/* This function is used to provide m_free via symbol indirection, please avoid
 * any change in behavior or remove the indirection in config/Unsupported*
 */</span>
mbuf_t <span class="enscript-function-name">mbuf_free</span>(mbuf_t mbuf)
{
	<span class="enscript-keyword">return</span> m_free(mbuf);
}

<span class="enscript-comment">/* This function is used to provide m_freem via symbol indirection, please avoid
 * any change in behavior or remove the indirection in config/Unsupported*
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_freem</span>(mbuf_t mbuf)
{
	m_freem(mbuf);
}

<span class="enscript-type">int</span>	mbuf_freem_list(mbuf_t mbuf)
{
	<span class="enscript-keyword">return</span> m_freem_list(mbuf);
}

size_t <span class="enscript-function-name">mbuf_leadingspace</span>(<span class="enscript-type">const</span> mbuf_t mbuf)
{
	<span class="enscript-keyword">return</span> m_leadingspace(mbuf);
}

<span class="enscript-comment">/* This function is used to provide m_trailingspace via symbol indirection,
 * please avoid any change in behavior or remove the indirection in 
 * config/Unsupported*
 */</span>
size_t <span class="enscript-function-name">mbuf_trailingspace</span>(<span class="enscript-type">const</span> mbuf_t mbuf)
{
	<span class="enscript-keyword">return</span> m_trailingspace(mbuf);
}

<span class="enscript-comment">/* Manipulation */</span>
errno_t <span class="enscript-function-name">mbuf_copym</span>(<span class="enscript-type">const</span> mbuf_t src, size_t offset, size_t len,
				   mbuf_how_t how, mbuf_t *new_mbuf)
{
	<span class="enscript-comment">/* Must set *mbuf to NULL in failure case */</span>
	*new_mbuf = m_copym(src, offset, len, how);
	
	<span class="enscript-keyword">return</span> (*new_mbuf == NULL) ? ENOMEM : 0;
}

errno_t	mbuf_dup(<span class="enscript-type">const</span> mbuf_t src, mbuf_how_t how, mbuf_t *new_mbuf)
{
	<span class="enscript-comment">/* Must set *new_mbuf to NULL in failure case */</span>
	*new_mbuf = m_dup(src, how);
	
	<span class="enscript-keyword">return</span> (*new_mbuf == NULL) ? ENOMEM : 0;
}

errno_t <span class="enscript-function-name">mbuf_prepend</span>(mbuf_t *orig, size_t len, mbuf_how_t how)
{
	<span class="enscript-comment">/* Must set *orig to NULL in failure case */</span>
	*orig = m_prepend_2(*orig, len, how, 0);
	
	<span class="enscript-keyword">return</span> (*orig == NULL) ? ENOMEM : 0;
}

errno_t <span class="enscript-function-name">mbuf_split</span>(mbuf_t src, size_t offset,
					mbuf_how_t how, mbuf_t *new_mbuf)
{
	<span class="enscript-comment">/* Must set *new_mbuf to NULL in failure case */</span>
	*new_mbuf = m_split(src, offset, how);
	
	<span class="enscript-keyword">return</span> (*new_mbuf == NULL) ? ENOMEM : 0;
}

errno_t <span class="enscript-function-name">mbuf_pullup</span>(mbuf_t *mbuf, size_t len)
{
	<span class="enscript-comment">/* Must set *mbuf to NULL in failure case */</span>
	*mbuf = m_pullup(*mbuf, len);
	
	<span class="enscript-keyword">return</span> (*mbuf == NULL) ? ENOMEM : 0;
}

errno_t <span class="enscript-function-name">mbuf_pulldown</span>(mbuf_t src, size_t *offset, size_t len, mbuf_t *location)
{
	<span class="enscript-comment">/* Must set *location to NULL in failure case */</span>
	<span class="enscript-type">int</span> new_offset;
	*location = m_pulldown(src, *offset, len, &amp;new_offset);
	*offset = new_offset;
	
	<span class="enscript-keyword">return</span> (*location == NULL) ? ENOMEM : 0;
}

<span class="enscript-comment">/* This function is used to provide m_adj via symbol indirection, please avoid
 * any change in behavior or remove the indirection in config/Unsupported*
 */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_adj</span>(mbuf_t mbuf, <span class="enscript-type">int</span> len)
{
	m_adj(mbuf, len);
}

errno_t <span class="enscript-function-name">mbuf_adjustlen</span>(mbuf_t m, <span class="enscript-type">int</span> amount)
{
	<span class="enscript-comment">/* Verify m_len will be valid after adding amount */</span>
	<span class="enscript-keyword">if</span> (amount &gt; 0) {
		<span class="enscript-type">int</span>		used = (size_t)mbuf_data(m) - (size_t)mbuf_datastart(m) +
					   m-&gt;m_len;
		
		<span class="enscript-keyword">if</span> ((size_t)(amount + used) &gt; mbuf_maxlen(m))
			<span class="enscript-keyword">return</span> EINVAL;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (-amount &gt; m-&gt;m_len) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	
	m-&gt;m_len += amount;
	<span class="enscript-keyword">return</span> 0;
}

mbuf_t
<span class="enscript-function-name">mbuf_concatenate</span>(mbuf_t dst, mbuf_t src)
{
	<span class="enscript-keyword">if</span> (dst == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	m_cat(dst, src);

	<span class="enscript-comment">/* return dst as is in the current implementation */</span>
	<span class="enscript-keyword">return</span> (dst);
}
errno_t <span class="enscript-function-name">mbuf_copydata</span>(<span class="enscript-type">const</span> mbuf_t m0, size_t off, size_t len, <span class="enscript-type">void</span>* out_data)
{
	<span class="enscript-comment">/* Copied m_copydata, added error handling (don't just panic) */</span>
	<span class="enscript-type">int</span> count;
	mbuf_t	m = m0;

	<span class="enscript-keyword">while</span> (off &gt; 0) {
		<span class="enscript-keyword">if</span> (m == 0)
			<span class="enscript-keyword">return</span> EINVAL;
		<span class="enscript-keyword">if</span> (off &lt; (size_t)m-&gt;m_len)
			<span class="enscript-keyword">break</span>;
		off -= m-&gt;m_len;
		m = m-&gt;m_next;
	}
	<span class="enscript-keyword">while</span> (len &gt; 0) {
		<span class="enscript-keyword">if</span> (m == 0)
			<span class="enscript-keyword">return</span> EINVAL;
		count = m-&gt;m_len - off &gt; len ? len : m-&gt;m_len - off;
		bcopy(mtod(m, caddr_t) + off, out_data, count);
		len -= count;
		out_data = ((<span class="enscript-type">char</span>*)out_data) + count;
		off = 0;
		m = m-&gt;m_next;
	}
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span> <span class="enscript-function-name">mbuf_mclhasreference</span>(mbuf_t mbuf)
{
	<span class="enscript-keyword">if</span> ((mbuf-&gt;m_flags &amp; M_EXT))
		<span class="enscript-keyword">return</span> m_mclhasreference(mbuf);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span> 0;
}


<span class="enscript-comment">/* mbuf header */</span>
mbuf_t <span class="enscript-function-name">mbuf_next</span>(<span class="enscript-type">const</span> mbuf_t mbuf)
{
	<span class="enscript-keyword">return</span> mbuf-&gt;m_next;
}

errno_t <span class="enscript-function-name">mbuf_setnext</span>(mbuf_t mbuf, mbuf_t next)
{
	<span class="enscript-keyword">if</span> (next &amp;&amp; ((next)-&gt;m_nextpkt != NULL ||
		(next)-&gt;m_type == MT_FREE)) <span class="enscript-keyword">return</span> EINVAL;
	mbuf-&gt;m_next = next;
	
	<span class="enscript-keyword">return</span> 0;
}

mbuf_t <span class="enscript-function-name">mbuf_nextpkt</span>(<span class="enscript-type">const</span> mbuf_t mbuf)
{
	<span class="enscript-keyword">return</span> mbuf-&gt;m_nextpkt;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_setnextpkt</span>(mbuf_t mbuf, mbuf_t nextpkt)
{
	mbuf-&gt;m_nextpkt = nextpkt;
}

size_t <span class="enscript-function-name">mbuf_len</span>(<span class="enscript-type">const</span> mbuf_t mbuf)
{
	<span class="enscript-keyword">return</span> mbuf-&gt;m_len;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_setlen</span>(mbuf_t mbuf, size_t len)
{
	mbuf-&gt;m_len = len;
}

size_t <span class="enscript-function-name">mbuf_maxlen</span>(<span class="enscript-type">const</span> mbuf_t mbuf)
{
	<span class="enscript-keyword">if</span> (mbuf-&gt;m_flags &amp; M_EXT)
		<span class="enscript-keyword">return</span> mbuf-&gt;m_ext.ext_size;
	<span class="enscript-keyword">return</span> &amp;mbuf-&gt;m_dat[MLEN] - ((<span class="enscript-type">char</span>*)mbuf_datastart(mbuf));
}

mbuf_type_t <span class="enscript-function-name">mbuf_type</span>(<span class="enscript-type">const</span> mbuf_t mbuf)
{
	<span class="enscript-keyword">return</span> mbuf-&gt;m_type;
}

errno_t <span class="enscript-function-name">mbuf_settype</span>(mbuf_t mbuf, mbuf_type_t new_type)
{
	<span class="enscript-keyword">if</span> (new_type == MBUF_TYPE_FREE) <span class="enscript-keyword">return</span> EINVAL;
	
	m_mchtype(mbuf, new_type);
	
	<span class="enscript-keyword">return</span> 0;
}

mbuf_flags_t
<span class="enscript-function-name">mbuf_flags</span>(<span class="enscript-type">const</span> mbuf_t mbuf)
{
	<span class="enscript-keyword">return</span> (mbuf-&gt;m_flags &amp; mbuf_flags_mask);
}

errno_t
<span class="enscript-function-name">mbuf_setflags</span>(mbuf_t mbuf, mbuf_flags_t flags)
{
	errno_t ret = 0;
	mbuf_flags_t oflags = mbuf-&gt;m_flags;

	<span class="enscript-comment">/*
	 * 1. Return error if public but un-alterable flags are changed
	 *    in flags argument.
	 * 2. Return error if bits other than public flags are set in passed
	 *    flags argument.
	 *    Please note that private flag bits must be passed as reset by kexts,
	 *    as they must use mbuf_flags KPI to get current set of mbuf flags
	 *    and mbuf_flags KPI does not expose private flags.
	 */</span>
	<span class="enscript-keyword">if</span> ((flags ^ oflags) &amp; mbuf_cflags_mask) {
		ret = EINVAL;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (flags &amp; ~mbuf_flags_mask) {
		ret = EINVAL;
	} <span class="enscript-keyword">else</span> {
		mbuf-&gt;m_flags = flags | (mbuf-&gt;m_flags &amp; ~mbuf_flags_mask);
		<span class="enscript-comment">/*
		 * If M_PKTHDR bit has changed, we have work to do;
		 * m_reinit() will take care of setting/clearing the
		 * bit, as well as the rest of bookkeeping.
		 */</span>
		<span class="enscript-keyword">if</span> ((oflags ^ mbuf-&gt;m_flags) &amp; M_PKTHDR) {
			mbuf-&gt;m_flags ^= M_PKTHDR;	<span class="enscript-comment">/* restore */</span>
			ret = m_reinit(mbuf,
			    (mbuf-&gt;m_flags &amp; M_PKTHDR) ? 0 : 1);
		}
	}

	<span class="enscript-keyword">return</span> (ret);
}

errno_t
<span class="enscript-function-name">mbuf_setflags_mask</span>(mbuf_t mbuf, mbuf_flags_t flags, mbuf_flags_t mask)
{
	errno_t ret = 0;

	<span class="enscript-keyword">if</span> (mask &amp; (~mbuf_flags_mask | mbuf_cflags_mask)) {
                ret = EINVAL;
	} <span class="enscript-keyword">else</span> {
		mbuf_flags_t oflags = mbuf-&gt;m_flags;
		mbuf-&gt;m_flags = (flags &amp; mask) | (mbuf-&gt;m_flags &amp; ~mask);
		<span class="enscript-comment">/*
		 * If M_PKTHDR bit has changed, we have work to do;
		 * m_reinit() will take care of setting/clearing the
		 * bit, as well as the rest of bookkeeping.
		 */</span>
		<span class="enscript-keyword">if</span> ((oflags ^ mbuf-&gt;m_flags) &amp; M_PKTHDR) {
			mbuf-&gt;m_flags ^= M_PKTHDR;	<span class="enscript-comment">/* restore */</span>
			ret = m_reinit(mbuf,
			    (mbuf-&gt;m_flags &amp; M_PKTHDR) ? 0 : 1);
		}
	}

	<span class="enscript-keyword">return</span> (ret);
}

errno_t <span class="enscript-function-name">mbuf_copy_pkthdr</span>(mbuf_t dest, <span class="enscript-type">const</span> mbuf_t src)
{
	<span class="enscript-keyword">if</span> (((src)-&gt;m_flags &amp; M_PKTHDR) == 0)
		<span class="enscript-keyword">return</span> EINVAL;
	
	m_copy_pkthdr(dest, src);
	
	<span class="enscript-keyword">return</span> 0;
}

size_t <span class="enscript-function-name">mbuf_pkthdr_len</span>(<span class="enscript-type">const</span> mbuf_t mbuf)
{
	<span class="enscript-keyword">return</span> mbuf-&gt;m_pkthdr.len;
}

__private_extern__ size_t mbuf_pkthdr_maxlen(mbuf_t m)
{
	size_t maxlen = 0;
	mbuf_t n = m;

	<span class="enscript-keyword">while</span> (n) {
		maxlen += mbuf_maxlen(n);
		n = mbuf_next(n);
	}
	<span class="enscript-keyword">return</span> (maxlen);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_pkthdr_setlen</span>(mbuf_t mbuf, size_t len)
{
	mbuf-&gt;m_pkthdr.len = len;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_pkthdr_adjustlen</span>(mbuf_t mbuf, <span class="enscript-type">int</span> amount)
{
	mbuf-&gt;m_pkthdr.len += amount;
}

ifnet_t <span class="enscript-function-name">mbuf_pkthdr_rcvif</span>(<span class="enscript-type">const</span> mbuf_t mbuf)
{
	<span class="enscript-comment">// If we reference count ifnets, we should take a reference here before returning
</span>	<span class="enscript-keyword">return</span> mbuf-&gt;m_pkthdr.rcvif;
}

errno_t <span class="enscript-function-name">mbuf_pkthdr_setrcvif</span>(mbuf_t mbuf, ifnet_t ifnet)
{
	<span class="enscript-comment">/* May want to walk ifnet list to determine if interface is valid */</span>
	mbuf-&gt;m_pkthdr.rcvif = (<span class="enscript-type">struct</span> ifnet*)ifnet;
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span>* <span class="enscript-function-name">mbuf_pkthdr_header</span>(<span class="enscript-type">const</span> mbuf_t mbuf)
{
	<span class="enscript-keyword">return</span> mbuf-&gt;m_pkthdr.pkt_hdr;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_pkthdr_setheader</span>(mbuf_t mbuf, <span class="enscript-type">void</span> *header)
{
	mbuf-&gt;m_pkthdr.pkt_hdr = (<span class="enscript-type">void</span>*)header;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_inbound_modified</span>(mbuf_t mbuf)
{
	<span class="enscript-comment">/* Invalidate hardware generated checksum flags */</span>
	mbuf-&gt;m_pkthdr.csum_flags = 0;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_outbound_finalize</span>(<span class="enscript-type">struct</span> mbuf *m, u_int32_t pf, size_t o)
{
	<span class="enscript-comment">/* Generate the packet in software, client needs it */</span>
	<span class="enscript-keyword">switch</span> (pf) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET</span>:
		(<span class="enscript-type">void</span>) in_finalize_cksum(m, o, m-&gt;m_pkthdr.csum_flags);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET6</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
		<span class="enscript-comment">/*
		 * Checksum offload should not have been enabled when
		 * extension headers exist; indicate that the callee
		 * should skip such case by setting optlen to -1.
		 */</span>
		(<span class="enscript-type">void</span>) in6_finalize_cksum(m, o, -1, -1, m-&gt;m_pkthdr.csum_flags);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}
}

errno_t
<span class="enscript-function-name">mbuf_set_vlan_tag</span>(
	mbuf_t mbuf,
	u_int16_t vlan)
{
	mbuf-&gt;m_pkthdr.csum_flags |= CSUM_VLAN_TAG_VALID;
	mbuf-&gt;m_pkthdr.vlan_tag = vlan;
	
	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">mbuf_get_vlan_tag</span>(
	mbuf_t mbuf,
	u_int16_t *vlan)
{
	<span class="enscript-keyword">if</span> ((mbuf-&gt;m_pkthdr.csum_flags &amp; CSUM_VLAN_TAG_VALID) == 0)
		<span class="enscript-keyword">return</span> ENXIO; <span class="enscript-comment">// No vlan tag set
</span>	
	*vlan = mbuf-&gt;m_pkthdr.vlan_tag;
	
	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">mbuf_clear_vlan_tag</span>(
	mbuf_t mbuf)
{
	mbuf-&gt;m_pkthdr.csum_flags &amp;= ~CSUM_VLAN_TAG_VALID;
	mbuf-&gt;m_pkthdr.vlan_tag = 0;
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> mbuf_csum_request_flags_t mbuf_valid_csum_request_flags = 
	MBUF_CSUM_REQ_IP | MBUF_CSUM_REQ_TCP | MBUF_CSUM_REQ_UDP |
       	MBUF_CSUM_PARTIAL | MBUF_CSUM_REQ_TCPIPV6 | MBUF_CSUM_REQ_UDPIPV6;

errno_t
<span class="enscript-function-name">mbuf_set_csum_requested</span>(
	mbuf_t mbuf,
	mbuf_csum_request_flags_t request,
	u_int32_t value)
{
	request &amp;= mbuf_valid_csum_request_flags;
	mbuf-&gt;m_pkthdr.csum_flags = (mbuf-&gt;m_pkthdr.csum_flags &amp; 0xffff0000) | request;
	mbuf-&gt;m_pkthdr.csum_data = value;
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> mbuf_tso_request_flags_t mbuf_valid_tso_request_flags = 
	MBUF_TSO_IPV4 | MBUF_TSO_IPV6;

errno_t
<span class="enscript-function-name">mbuf_get_tso_requested</span>(
	mbuf_t mbuf,
	mbuf_tso_request_flags_t *request,
	u_int32_t *value)
{
	<span class="enscript-keyword">if</span> (mbuf == NULL || (mbuf-&gt;m_flags &amp; M_PKTHDR) == 0 ||
			request == NULL || value == NULL)
		<span class="enscript-keyword">return</span> EINVAL;

	*request = mbuf-&gt;m_pkthdr.csum_flags;
	*request &amp;= mbuf_valid_tso_request_flags;
	<span class="enscript-keyword">if</span> (*request &amp;&amp; value != NULL) 
		*value = mbuf-&gt;m_pkthdr.tso_segsz;
	
	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">mbuf_get_csum_requested</span>(
	mbuf_t mbuf,
	mbuf_csum_request_flags_t *request,
	u_int32_t *value)
{
	*request = mbuf-&gt;m_pkthdr.csum_flags;
	*request &amp;= mbuf_valid_csum_request_flags;
	<span class="enscript-keyword">if</span> (value != NULL) {
		*value = mbuf-&gt;m_pkthdr.csum_data;
	}
	
	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">mbuf_clear_csum_requested</span>(
	mbuf_t mbuf)
{
	mbuf-&gt;m_pkthdr.csum_flags &amp;= 0xffff0000;
	mbuf-&gt;m_pkthdr.csum_data = 0;
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> mbuf_csum_performed_flags_t mbuf_valid_csum_performed_flags = 
	MBUF_CSUM_DID_IP | MBUF_CSUM_IP_GOOD | MBUF_CSUM_DID_DATA |
	MBUF_CSUM_PSEUDO_HDR | MBUF_CSUM_PARTIAL;

errno_t
<span class="enscript-function-name">mbuf_set_csum_performed</span>(
	mbuf_t mbuf,
	mbuf_csum_performed_flags_t performed,
	u_int32_t value)
{
	performed &amp;= mbuf_valid_csum_performed_flags;
	mbuf-&gt;m_pkthdr.csum_flags = (mbuf-&gt;m_pkthdr.csum_flags &amp; 0xffff0000) | performed;
	mbuf-&gt;m_pkthdr.csum_data = value;
	
	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">mbuf_get_csum_performed</span>(
	mbuf_t mbuf,
	mbuf_csum_performed_flags_t *performed,
	u_int32_t *value)
{
	*performed = mbuf-&gt;m_pkthdr.csum_flags &amp; mbuf_valid_csum_performed_flags;
	*value = mbuf-&gt;m_pkthdr.csum_data;
	
	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">mbuf_clear_csum_performed</span>(
	mbuf_t mbuf)
{
	mbuf-&gt;m_pkthdr.csum_flags &amp;= 0xffff0000;
	mbuf-&gt;m_pkthdr.csum_data = 0;
	
	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">mbuf_inet_cksum</span>(mbuf_t mbuf, <span class="enscript-type">int</span> protocol, u_int32_t offset, u_int32_t length,
    u_int16_t *csum)
{
	<span class="enscript-keyword">if</span> (mbuf == NULL || length == 0 || csum == NULL ||
	   (u_int32_t)mbuf-&gt;m_pkthdr.len &lt; (offset + length))
		<span class="enscript-keyword">return</span> (EINVAL);

	*csum = inet_cksum(mbuf, protocol, offset, length);
	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
errno_t
<span class="enscript-function-name">mbuf_inet6_cksum</span>(mbuf_t mbuf, <span class="enscript-type">int</span> protocol, u_int32_t offset, u_int32_t length,
    u_int16_t *csum)
{
	<span class="enscript-keyword">if</span> (mbuf == NULL || length == 0 || csum == NULL ||
	   (u_int32_t)mbuf-&gt;m_pkthdr.len &lt; (offset + length))
		<span class="enscript-keyword">return</span> (EINVAL);

	*csum = inet6_cksum(mbuf, protocol, offset, length);
	<span class="enscript-keyword">return</span> (0);
}
#<span class="enscript-reference">else</span> <span class="enscript-comment">/* INET6 */</span>
errno_t
<span class="enscript-function-name">mbuf_inet6_cksum</span>(__unused mbuf_t mbuf, __unused <span class="enscript-type">int</span> protocol,
		__unused u_int32_t offset, __unused u_int32_t length,
		__unused u_int16_t *csum)
{
	panic(<span class="enscript-string">&quot;mbuf_inet6_cksum() doesn't exist on this platform\n&quot;</span>);
	<span class="enscript-keyword">return</span> (0);
}

u_int16_t
<span class="enscript-function-name">inet6_cksum</span>(__unused <span class="enscript-type">struct</span> mbuf *m, __unused <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> nxt,
		__unused <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> off, __unused <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len)
{
	panic(<span class="enscript-string">&quot;inet6_cksum() doesn't exist on this platform\n&quot;</span>);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">nd6_lookup_ipv6</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_lookup_ipv6</span>(<span class="enscript-type">void</span>)
{
	panic(<span class="enscript-string">&quot;nd6_lookup_ipv6() doesn't exist on this platform\n&quot;</span>);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">in6addr_local</span>(__unused <span class="enscript-type">struct</span> in6_addr *a)
{
	panic(<span class="enscript-string">&quot;in6addr_local() doesn't exist on this platform\n&quot;</span>);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">nd6_storelladdr</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span>
<span class="enscript-function-name">nd6_storelladdr</span>(<span class="enscript-type">void</span>)
{
	panic(<span class="enscript-string">&quot;nd6_storelladdr() doesn't exist on this platform\n&quot;</span>);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>

<span class="enscript-comment">/*
 * Mbuf tag KPIs
 */</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MTAG_FIRST_ID</span> FIRST_KPI_STR_ID

errno_t
<span class="enscript-function-name">mbuf_tag_id_find</span>(
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>		*string,
	mbuf_tag_id_t	*out_id)
{
	<span class="enscript-keyword">return</span> net_str_id_find_internal(string, out_id, NSI_MBUF_TAG, 1);
}

errno_t
<span class="enscript-function-name">mbuf_tag_allocate</span>(
	mbuf_t			mbuf,
	mbuf_tag_id_t	id,
	mbuf_tag_type_t	type,
	size_t			length,
	mbuf_how_t		how,
	<span class="enscript-type">void</span>**			data_p)
{
	<span class="enscript-type">struct</span> m_tag *tag;
	u_int32_t mtag_id_first, mtag_id_last;
	
	<span class="enscript-keyword">if</span> (data_p != NULL)
		*data_p = NULL;
	
	<span class="enscript-comment">/* Sanity check parameters */</span>
	(<span class="enscript-type">void</span>) net_str_id_first_last(&amp;mtag_id_first, &amp;mtag_id_last, NSI_MBUF_TAG);
	<span class="enscript-keyword">if</span> (mbuf == NULL || (mbuf-&gt;m_flags &amp; M_PKTHDR) == 0 || id &lt; mtag_id_first ||
		id &gt; mtag_id_last || length &lt; 1 || (length &amp; 0xffff0000) != 0 ||
		data_p == NULL) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	
	<span class="enscript-comment">/* Make sure this mtag hasn't already been allocated */</span>
	tag = m_tag_locate(mbuf, id, type, NULL);
	<span class="enscript-keyword">if</span> (tag != NULL) {
		<span class="enscript-keyword">return</span> EEXIST;
	}
	
	<span class="enscript-comment">/* Allocate an mtag */</span>
	tag = m_tag_create(id, type, length, how, mbuf);
	<span class="enscript-keyword">if</span> (tag == NULL) {
		<span class="enscript-keyword">return</span> how == M_WAITOK ? ENOMEM : EWOULDBLOCK;
	}
	
	<span class="enscript-comment">/* Attach the mtag and set *data_p */</span>
	m_tag_prepend(mbuf, tag);
	*data_p = tag + 1;
	
	<span class="enscript-keyword">return</span> 0;
}

errno_t
<span class="enscript-function-name">mbuf_tag_find</span>(
	mbuf_t			mbuf,
	mbuf_tag_id_t	id,
	mbuf_tag_type_t	type,
	size_t*			length,
	<span class="enscript-type">void</span>**			data_p)
{
	<span class="enscript-type">struct</span> m_tag *tag;
	u_int32_t mtag_id_first, mtag_id_last;
	
	<span class="enscript-keyword">if</span> (length != NULL)
		*length = 0;
	<span class="enscript-keyword">if</span> (data_p != NULL)
		*data_p = NULL;
	
	<span class="enscript-comment">/* Sanity check parameters */</span>
	(<span class="enscript-type">void</span>) net_str_id_first_last(&amp;mtag_id_first, &amp;mtag_id_last, NSI_MBUF_TAG);
	<span class="enscript-keyword">if</span> (mbuf == NULL || (mbuf-&gt;m_flags &amp; M_PKTHDR) == 0 || id &lt; mtag_id_first ||
		id &gt; mtag_id_last || length == NULL || data_p == NULL) {
		<span class="enscript-keyword">return</span> EINVAL;
	}
	
	<span class="enscript-comment">/* Locate an mtag */</span>
	tag = m_tag_locate(mbuf, id, type, NULL);
	<span class="enscript-keyword">if</span> (tag == NULL) {
		<span class="enscript-keyword">return</span> ENOENT;
	}
	
	<span class="enscript-comment">/* Copy out the pointer to the data and the lenght value */</span>
	*length = tag-&gt;m_tag_len;
	*data_p = tag + 1;
	
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_tag_free</span>(
	mbuf_t			mbuf,
	mbuf_tag_id_t	id,
	mbuf_tag_type_t	type)
{
	<span class="enscript-type">struct</span> m_tag *tag;
	u_int32_t mtag_id_first, mtag_id_last;
	
	<span class="enscript-comment">/* Sanity check parameters */</span>
	(<span class="enscript-type">void</span>) net_str_id_first_last(&amp;mtag_id_first, &amp;mtag_id_last, NSI_MBUF_TAG);
	<span class="enscript-keyword">if</span> (mbuf == NULL || (mbuf-&gt;m_flags &amp; M_PKTHDR) == 0 || id &lt; mtag_id_first ||
		id &gt; mtag_id_last)
		<span class="enscript-keyword">return</span>;
	
	tag = m_tag_locate(mbuf, id, type, NULL);
	<span class="enscript-keyword">if</span> (tag == NULL) {
		<span class="enscript-keyword">return</span>;
	}
	
	m_tag_delete(mbuf, tag);
	<span class="enscript-keyword">return</span>;
}

<span class="enscript-comment">/*
 * Maximum length of driver auxiliary data; keep this small to
 * fit in a single mbuf to avoid wasting memory, rounded down to
 * the nearest 64-bit boundary.  This takes into account mbuf
 * tag-related (m_taghdr + m_tag) as well m_drvaux_tag structs.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MBUF_DRVAUX_MAXLEN</span>						\
	P2ROUNDDOWN(MLEN - <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> m_taghdr) -			\
	M_TAG_ALIGN(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> m_drvaux_tag)), <span class="enscript-keyword">sizeof</span> (uint64_t))

errno_t
<span class="enscript-function-name">mbuf_add_drvaux</span>(mbuf_t mbuf, mbuf_how_t how, u_int32_t family,
    u_int32_t subfamily, size_t length, <span class="enscript-type">void</span> **data_p)
{
	<span class="enscript-type">struct</span> m_drvaux_tag *p;
	<span class="enscript-type">struct</span> m_tag *tag;

	<span class="enscript-keyword">if</span> (mbuf == NULL || !(mbuf-&gt;m_flags &amp; M_PKTHDR) ||
	    length == 0 || length &gt; MBUF_DRVAUX_MAXLEN)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (data_p != NULL)
		*data_p = NULL;

	<span class="enscript-comment">/* Check if one is already associated */</span>
	<span class="enscript-keyword">if</span> ((tag = m_tag_locate(mbuf, KERNEL_MODULE_TAG_ID,
	    KERNEL_TAG_TYPE_DRVAUX, NULL)) != NULL)
		<span class="enscript-keyword">return</span> (EEXIST);

	<span class="enscript-comment">/* Tag is (m_drvaux_tag + module specific data) */</span>
	<span class="enscript-keyword">if</span> ((tag = m_tag_create(KERNEL_MODULE_TAG_ID, KERNEL_TAG_TYPE_DRVAUX,
	    <span class="enscript-keyword">sizeof</span> (*p) + length, how, mbuf)) == NULL)
		<span class="enscript-keyword">return</span> ((how == MBUF_WAITOK) ? ENOMEM : EWOULDBLOCK);

	p = (<span class="enscript-type">struct</span> m_drvaux_tag *)(tag + 1);
	p-&gt;da_family = family;
	p-&gt;da_subfamily = subfamily;
	p-&gt;da_length = length;

	<span class="enscript-comment">/* Associate the tag */</span>
	m_tag_prepend(mbuf, tag);

	<span class="enscript-keyword">if</span> (data_p != NULL)
		*data_p = (p + 1);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">mbuf_find_drvaux</span>(mbuf_t mbuf, u_int32_t *family_p, u_int32_t *subfamily_p,
    u_int32_t *length_p, <span class="enscript-type">void</span> **data_p)
{
	<span class="enscript-type">struct</span> m_drvaux_tag *p;
	<span class="enscript-type">struct</span> m_tag *tag;

	<span class="enscript-keyword">if</span> (mbuf == NULL || !(mbuf-&gt;m_flags &amp; M_PKTHDR) || data_p == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	*data_p = NULL;

	<span class="enscript-keyword">if</span> ((tag = m_tag_locate(mbuf, KERNEL_MODULE_TAG_ID,
	    KERNEL_TAG_TYPE_DRVAUX, NULL)) == NULL)
		<span class="enscript-keyword">return</span> (ENOENT);

	<span class="enscript-comment">/* Must be at least size of m_drvaux_tag */</span>
	VERIFY(tag-&gt;m_tag_len &gt;= <span class="enscript-keyword">sizeof</span> (*p));

	p = (<span class="enscript-type">struct</span> m_drvaux_tag *)(tag + 1);
	VERIFY(p-&gt;da_length &gt; 0 &amp;&amp; p-&gt;da_length &lt;= MBUF_DRVAUX_MAXLEN);

	<span class="enscript-keyword">if</span> (family_p != NULL)
		*family_p = p-&gt;da_family;
	<span class="enscript-keyword">if</span> (subfamily_p != NULL)
		*subfamily_p = p-&gt;da_subfamily;
	<span class="enscript-keyword">if</span> (length_p != NULL)
		*length_p = p-&gt;da_length;

	*data_p = (p + 1);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_del_drvaux</span>(mbuf_t mbuf)
{
	<span class="enscript-type">struct</span> m_tag *tag;

	<span class="enscript-keyword">if</span> (mbuf == NULL || !(mbuf-&gt;m_flags &amp; M_PKTHDR))
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> ((tag = m_tag_locate(mbuf, KERNEL_MODULE_TAG_ID,
	    KERNEL_TAG_TYPE_DRVAUX, NULL)) != NULL)
		m_tag_delete(mbuf, tag);
}

<span class="enscript-comment">/* mbuf stats */</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_stats</span>(<span class="enscript-type">struct</span> mbuf_stat *stats)
{
	stats-&gt;mbufs = mbstat.m_mbufs;
	stats-&gt;clusters = mbstat.m_clusters;
	stats-&gt;clfree = mbstat.m_clfree;
	stats-&gt;drops = mbstat.m_drops;
	stats-&gt;wait = mbstat.m_wait;
	stats-&gt;drain = mbstat.m_drain;
	__builtin_memcpy(stats-&gt;mtypes, mbstat.m_mtypes, <span class="enscript-keyword">sizeof</span>(stats-&gt;mtypes));
	stats-&gt;mcfail = mbstat.m_mcfail;
	stats-&gt;mpfail = mbstat.m_mpfail;
	stats-&gt;msize = mbstat.m_msize;
	stats-&gt;mclbytes = mbstat.m_mclbytes;
	stats-&gt;minclsize = mbstat.m_minclsize;
	stats-&gt;mlen = mbstat.m_mlen;
	stats-&gt;mhlen = mbstat.m_mhlen;
	stats-&gt;bigclusters = mbstat.m_bigclusters;
	stats-&gt;bigclfree = mbstat.m_bigclfree;
	stats-&gt;bigmclbytes = mbstat.m_bigmclbytes;
}

errno_t
<span class="enscript-function-name">mbuf_allocpacket</span>(mbuf_how_t how, size_t packetlen, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *maxchunks, mbuf_t *mbuf)
{
	errno_t error;
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> numpkts = 1;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> numchunks = maxchunks ? *maxchunks : 0;

	<span class="enscript-keyword">if</span> (packetlen == 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	m = m_allocpacket_internal(&amp;numpkts, packetlen, maxchunks ? &amp;numchunks : NULL, how, 1, 0);
	<span class="enscript-keyword">if</span> (m == 0) {
		<span class="enscript-keyword">if</span> (maxchunks &amp;&amp; *maxchunks &amp;&amp; numchunks &gt; *maxchunks)
			error = ENOBUFS;
		<span class="enscript-keyword">else</span>
			error = ENOMEM;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (maxchunks)
			*maxchunks = numchunks;
		error = 0;
		*mbuf = m;
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;
}

errno_t
<span class="enscript-function-name">mbuf_allocpacket_list</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> numpkts, mbuf_how_t how, size_t packetlen, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *maxchunks, mbuf_t *mbuf)
{
	errno_t error;
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> numchunks = maxchunks ? *maxchunks : 0;

	<span class="enscript-keyword">if</span> (numpkts == 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (packetlen == 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	m = m_allocpacket_internal(&amp;numpkts, packetlen, maxchunks ? &amp;numchunks : NULL, how, 1, 0);
	<span class="enscript-keyword">if</span> (m == 0) {
		<span class="enscript-keyword">if</span> (maxchunks &amp;&amp; *maxchunks &amp;&amp; numchunks &gt; *maxchunks)
			error = ENOBUFS;
		<span class="enscript-keyword">else</span>
			error = ENOMEM;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (maxchunks)
			*maxchunks = numchunks;
		error = 0;
		*mbuf = m;
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> error;
}

__private_extern__ size_t
<span class="enscript-function-name">mbuf_pkt_list_len</span>(mbuf_t m)
{
	size_t len = 0;
	mbuf_t n = m;

	<span class="enscript-keyword">while</span> (n) {
		len += mbuf_pkthdr_len(n);
		n = mbuf_nextpkt(n);
	}
	<span class="enscript-keyword">return</span> (len);
}

__private_extern__ size_t
<span class="enscript-function-name">mbuf_pkt_list_maxlen</span>(mbuf_t m)
{
	size_t maxlen = 0;
	mbuf_t n = m;

	<span class="enscript-keyword">while</span> (n) {
		maxlen += mbuf_pkthdr_maxlen(n);
		n = mbuf_nextpkt(n);
	}
	<span class="enscript-keyword">return</span> (maxlen);
}

<span class="enscript-comment">/*
 * mbuf_copyback differs from m_copyback in a few ways:
 * 1) mbuf_copyback will allocate clusters for new mbufs we append
 * 2) mbuf_copyback will grow the last mbuf in the chain if possible
 * 3) mbuf_copyback reports whether or not the operation succeeded
 * 4) mbuf_copyback allows the caller to specify M_WAITOK or M_NOWAIT
 */</span>
errno_t
<span class="enscript-function-name">mbuf_copyback</span>(
	mbuf_t		m,
	size_t		off,
	size_t		len,
	<span class="enscript-type">const</span> <span class="enscript-type">void</span>	*data,
	mbuf_how_t	how)
{
	size_t	mlen;
	mbuf_t	m_start = m;
	mbuf_t	n;
	<span class="enscript-type">int</span>		totlen = 0;
	errno_t		result = 0;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*cp = data;

	<span class="enscript-keyword">if</span> (m == NULL || len == 0 || data == NULL)
		<span class="enscript-keyword">return</span> EINVAL;
	
	<span class="enscript-keyword">while</span> (off &gt; (mlen = m-&gt;m_len)) {
		off -= mlen;
		totlen += mlen;
		<span class="enscript-keyword">if</span> (m-&gt;m_next == 0) {
			n = m_getclr(how, m-&gt;m_type);
			<span class="enscript-keyword">if</span> (n == 0) {
				result = ENOBUFS;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			n-&gt;m_len = MIN(MLEN, len + off);
			m-&gt;m_next = n;
		}
		m = m-&gt;m_next;
	}
	
	<span class="enscript-keyword">while</span> (len &gt; 0) {
		mlen = MIN(m-&gt;m_len - off, len);
		<span class="enscript-keyword">if</span> (mlen &lt; len &amp;&amp; m-&gt;m_next == NULL &amp;&amp; mbuf_trailingspace(m) &gt; 0) {
			size_t	grow = MIN(mbuf_trailingspace(m), len - mlen);
			mlen += grow;
			m-&gt;m_len += grow;
		}
		bcopy(cp, off + (<span class="enscript-type">char</span>*)mbuf_data(m), (<span class="enscript-type">unsigned</span>)mlen);
		cp += mlen;
		len -= mlen;
		mlen += off;
		off = 0;
		totlen += mlen;
		<span class="enscript-keyword">if</span> (len == 0)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (m-&gt;m_next == 0) {
			n = m_get(how, m-&gt;m_type);
			<span class="enscript-keyword">if</span> (n == NULL) {
				result = ENOBUFS;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">if</span> (len &gt; MINCLSIZE) {
				<span class="enscript-comment">/* cluter allocation failure is okay, we can grow chain */</span>
				mbuf_mclget(how, m-&gt;m_type, &amp;n);
			}
			n-&gt;m_len = MIN(mbuf_maxlen(n), len);
			m-&gt;m_next = n;
		}
		m = m-&gt;m_next;
	}
	
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> ((m_start-&gt;m_flags &amp; M_PKTHDR) &amp;&amp; (m_start-&gt;m_pkthdr.len &lt; totlen))
		m_start-&gt;m_pkthdr.len = totlen;
	
	<span class="enscript-keyword">return</span> result;
}

u_int32_t
<span class="enscript-function-name">mbuf_get_mlen</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (_MLEN);
}

u_int32_t
<span class="enscript-function-name">mbuf_get_mhlen</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (_MHLEN);
}

u_int32_t
<span class="enscript-function-name">mbuf_get_minclsize</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (MHLEN + MLEN);
}

u_int32_t
<span class="enscript-function-name">mbuf_get_traffic_class_max_count</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (MBUF_TC_MAX);
}

errno_t
<span class="enscript-function-name">mbuf_get_traffic_class_index</span>(mbuf_traffic_class_t tc, u_int32_t *index)
{
	<span class="enscript-keyword">if</span> (index == NULL || (u_int32_t)tc &gt;= MBUF_TC_MAX)
		<span class="enscript-keyword">return</span> (EINVAL);

	*index = MBUF_SCIDX(m_service_class_from_val(MBUF_TC2SCVAL(tc)));
	<span class="enscript-keyword">return</span> (0);
}

mbuf_traffic_class_t
<span class="enscript-function-name">mbuf_get_traffic_class</span>(mbuf_t m)
{
	<span class="enscript-keyword">if</span> (m == NULL || !(m-&gt;m_flags &amp; M_PKTHDR))
		<span class="enscript-keyword">return</span> (MBUF_TC_BE);

	<span class="enscript-keyword">return</span> (m_get_traffic_class(m));
}

errno_t
<span class="enscript-function-name">mbuf_set_traffic_class</span>(mbuf_t m, mbuf_traffic_class_t tc)
{
	<span class="enscript-keyword">if</span> (m == NULL || !(m-&gt;m_flags &amp; M_PKTHDR) ||
	    ((u_int32_t)tc &gt;= MBUF_TC_MAX))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (m_set_traffic_class(m, tc));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">mbuf_is_traffic_class_privileged</span>(mbuf_t m)
{
	<span class="enscript-keyword">if</span> (m == NULL || !(m-&gt;m_flags &amp; M_PKTHDR) ||
	    !MBUF_VALID_SC(m-&gt;m_pkthdr.pkt_svc))
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">return</span> ((m-&gt;m_pkthdr.pkt_flags &amp; PKTF_PRIO_PRIVILEGED) ? 1 : 0);
}

u_int32_t
<span class="enscript-function-name">mbuf_get_service_class_max_count</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> (MBUF_SC_MAX_CLASSES);
}

errno_t
<span class="enscript-function-name">mbuf_get_service_class_index</span>(mbuf_svc_class_t sc, u_int32_t *index)
{
	<span class="enscript-keyword">if</span> (index == NULL || !MBUF_VALID_SC(sc))
		<span class="enscript-keyword">return</span> (EINVAL);

	*index = MBUF_SCIDX(sc);
	<span class="enscript-keyword">return</span> (0);
}

mbuf_svc_class_t
<span class="enscript-function-name">mbuf_get_service_class</span>(mbuf_t m)
{
	<span class="enscript-keyword">if</span> (m == NULL || !(m-&gt;m_flags &amp; M_PKTHDR))
		<span class="enscript-keyword">return</span> (MBUF_SC_BE);

	<span class="enscript-keyword">return</span> (m_get_service_class(m));
}

errno_t
<span class="enscript-function-name">mbuf_set_service_class</span>(mbuf_t m, mbuf_svc_class_t sc)
{
	<span class="enscript-keyword">if</span> (m == NULL || !(m-&gt;m_flags &amp; M_PKTHDR))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (m_set_service_class(m, sc));
}

errno_t
<span class="enscript-function-name">mbuf_pkthdr_aux_flags</span>(mbuf_t m, mbuf_pkthdr_aux_flags_t *flagsp)
{
	u_int32_t flags;

	<span class="enscript-keyword">if</span> (m == NULL || !(m-&gt;m_flags &amp; M_PKTHDR) || flagsp == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	*flagsp = 0;
	flags = m-&gt;m_pkthdr.pkt_flags;
	<span class="enscript-keyword">if</span> ((flags &amp; (PKTF_INET_RESOLVE|PKTF_RESOLVE_RTR)) ==
	    (PKTF_INET_RESOLVE|PKTF_RESOLVE_RTR))
		*flagsp |= MBUF_PKTAUXF_INET_RESOLVE_RTR;
	<span class="enscript-keyword">if</span> ((flags &amp; (PKTF_INET6_RESOLVE|PKTF_RESOLVE_RTR)) ==
	    (PKTF_INET6_RESOLVE|PKTF_RESOLVE_RTR))
		*flagsp |= MBUF_PKTAUXF_INET6_RESOLVE_RTR;

	<span class="enscript-comment">/* These 2 flags are mutually exclusive */</span>
	VERIFY((*flagsp &amp;
	    (MBUF_PKTAUXF_INET_RESOLVE_RTR | MBUF_PKTAUXF_INET6_RESOLVE_RTR)) !=
	    (MBUF_PKTAUXF_INET_RESOLVE_RTR | MBUF_PKTAUXF_INET6_RESOLVE_RTR));

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">mbuf_get_driver_scratch</span>(mbuf_t m, u_int8_t **area, size_t *area_len)
{
	<span class="enscript-keyword">if</span> (m == NULL || area == NULL || area_len == NULL ||
	    !(m-&gt;m_flags &amp; M_PKTHDR))
		<span class="enscript-keyword">return</span> (EINVAL);

	*area_len = m_scratch_get(m, area);
	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">mbuf_get_unsent_data_bytes</span>(<span class="enscript-type">const</span> mbuf_t m, u_int32_t *unsent_data)
{
	<span class="enscript-keyword">if</span> (m == NULL || unsent_data == NULL || !(m-&gt;m_flags &amp; M_PKTHDR))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (!(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_VALID_UNSENT_DATA))
		<span class="enscript-keyword">return</span> (EINVAL);

	*unsent_data = m-&gt;m_pkthdr.pkt_unsent_databytes;
	<span class="enscript-keyword">return</span> (0);
}
</pre>
<hr />
</body></html>