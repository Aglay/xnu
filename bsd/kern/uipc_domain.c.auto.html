<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>uipc_domain.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">uipc_domain.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)uipc_domain.c	8.3 (Berkeley) 2/14/95
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/time.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/dlil.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/boolean.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pr_init_old</span>(<span class="enscript-type">struct</span> protosw *, <span class="enscript-type">struct</span> domain *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">init_proto</span>(<span class="enscript-type">struct</span> protosw *, <span class="enscript-type">struct</span> domain *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">attach_proto</span>(<span class="enscript-type">struct</span> protosw *, <span class="enscript-type">struct</span> domain *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">detach_proto</span>(<span class="enscript-type">struct</span> protosw *, <span class="enscript-type">struct</span> domain *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">dom_init_old</span>(<span class="enscript-type">struct</span> domain *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">init_domain</span>(<span class="enscript-type">struct</span> domain *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">attach_domain</span>(<span class="enscript-type">struct</span> domain *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">detach_domain</span>(<span class="enscript-type">struct</span> domain *);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> protosw *<span class="enscript-function-name">pffindprotonotype_locked</span>(<span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> domain *<span class="enscript-function-name">pffinddomain_locked</span>(<span class="enscript-type">int</span>);

<span class="enscript-type">static</span> boolean_t domain_timeout_run;	<span class="enscript-comment">/* domain timer is scheduled to run */</span>
<span class="enscript-type">static</span> boolean_t domain_draining;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">domain_sched_timeout</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">domain_timeout</span>(<span class="enscript-type">void</span> *);

lck_grp_t	*domain_proto_mtx_grp;
lck_attr_t	*domain_proto_mtx_attr;
<span class="enscript-type">static</span> lck_grp_attr_t	*domain_proto_mtx_grp_attr;
<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, domain_proto_mtx);
<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, domain_timeout_mtx);

<span class="enscript-type">static</span> u_int64_t _net_uptime;

#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)

<span class="enscript-function-name">SYSCTL_DECL</span>(_kern_ipc);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> sysctl_do_drain_domains SYSCTL_HANDLER_ARGS;

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_ipc, OID_AUTO, do_drain_domains,
	CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_LOCKED,
	0, 0,
	sysctl_do_drain_domains, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;force manual drain domains&quot;</span>);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pr_init_old</span>(<span class="enscript-type">struct</span> protosw *pp, <span class="enscript-type">struct</span> domain *dp)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">dp</span>)
	VERIFY(pp-&gt;pr_flags &amp; PR_OLD);
	VERIFY(pp-&gt;pr_old != NULL);

	<span class="enscript-keyword">if</span> (pp-&gt;pr_old-&gt;pr_init != NULL)
		pp-&gt;pr_old-&gt;pr_init();
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">init_proto</span>(<span class="enscript-type">struct</span> protosw *pp, <span class="enscript-type">struct</span> domain *dp)
{
	VERIFY(pp-&gt;pr_flags &amp; PR_ATTACHED);

	<span class="enscript-keyword">if</span> (!(pp-&gt;pr_flags &amp; PR_INITIALIZED)) {
		TAILQ_INIT(&amp;pp-&gt;pr_filter_head);
		<span class="enscript-keyword">if</span> (pp-&gt;pr_init != NULL)
			pp-&gt;pr_init(pp, dp);
		pp-&gt;pr_flags |= PR_INITIALIZED;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">attach_proto</span>(<span class="enscript-type">struct</span> protosw *pp, <span class="enscript-type">struct</span> domain *dp)
{
	domain_proto_mtx_lock_assert_held();
	VERIFY(!(pp-&gt;pr_flags &amp; PR_ATTACHED));
	VERIFY(pp-&gt;pr_domain == NULL);
	VERIFY(pp-&gt;pr_protosw == NULL);

	TAILQ_INSERT_TAIL(&amp;dp-&gt;dom_protosw, pp, pr_entry);
	pp-&gt;pr_flags |= PR_ATTACHED;
	pp-&gt;pr_domain = dp;
	pp-&gt;pr_protosw = pp;

	<span class="enscript-comment">/* do some cleaning up on user request callbacks */</span>
	pru_sanitize(pp-&gt;pr_usrreqs);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">detach_proto</span>(<span class="enscript-type">struct</span> protosw *pp, <span class="enscript-type">struct</span> domain *dp)
{
	domain_proto_mtx_lock_assert_held();
	VERIFY(pp-&gt;pr_flags &amp; PR_ATTACHED);
	VERIFY(pp-&gt;pr_domain == dp);
	VERIFY(pp-&gt;pr_protosw == pp);

	TAILQ_REMOVE(&amp;dp-&gt;dom_protosw, pp, pr_entry);
	pp-&gt;pr_flags &amp;= ~PR_ATTACHED;
	pp-&gt;pr_domain = NULL;
	pp-&gt;pr_protosw = NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">dom_init_old</span>(<span class="enscript-type">struct</span> domain *dp)
{
	VERIFY(dp-&gt;dom_flags &amp; DOM_OLD);
	VERIFY(dp-&gt;dom_old != NULL);

	<span class="enscript-keyword">if</span> (dp-&gt;dom_old-&gt;dom_init != NULL)
		dp-&gt;dom_old-&gt;dom_init();
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">init_domain</span>(<span class="enscript-type">struct</span> domain *dp)
{
	VERIFY(dp-&gt;dom_flags &amp; DOM_ATTACHED);

	<span class="enscript-keyword">if</span> (!(dp-&gt;dom_flags &amp; DOM_INITIALIZED)) {
		lck_mtx_init(&amp;dp-&gt;dom_mtx_s, domain_proto_mtx_grp,
		    domain_proto_mtx_attr);
		dp-&gt;dom_mtx = &amp;dp-&gt;dom_mtx_s;
		TAILQ_INIT(&amp;dp-&gt;dom_protosw);
		<span class="enscript-keyword">if</span> (dp-&gt;dom_init != NULL)
			dp-&gt;dom_init(dp);
		dp-&gt;dom_flags |= DOM_INITIALIZED;
	}

	<span class="enscript-comment">/* Recompute for new protocol */</span>
	<span class="enscript-keyword">if</span> (_max_linkhdr &lt; 16)		<span class="enscript-comment">/* XXX - Sheesh; everything's ether? */</span>
		_max_linkhdr = 16;
	_max_linkhdr = max_linkhdr;	<span class="enscript-comment">/* round it up */</span>

	<span class="enscript-keyword">if</span> (dp-&gt;dom_protohdrlen &gt; _max_protohdr)
		_max_protohdr = dp-&gt;dom_protohdrlen;
	_max_protohdr = max_protohdr;	<span class="enscript-comment">/* round it up */</span>

	max_hdr = max_linkhdr + max_protohdr;
	max_datalen = MHLEN - max_hdr;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">attach_domain</span>(<span class="enscript-type">struct</span> domain *dp)
{
	domain_proto_mtx_lock_assert_held();
	VERIFY(!(dp-&gt;dom_flags &amp; DOM_ATTACHED));

	TAILQ_INSERT_TAIL(&amp;domains, dp, dom_entry);
	dp-&gt;dom_flags |= DOM_ATTACHED;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">detach_domain</span>(<span class="enscript-type">struct</span> domain *dp)
{
	domain_proto_mtx_lock_assert_held();
	VERIFY(dp-&gt;dom_flags &amp; DOM_ATTACHED);

	TAILQ_REMOVE(&amp;domains, dp, dom_entry);
	dp-&gt;dom_flags &amp;= ~DOM_ATTACHED;

	<span class="enscript-keyword">if</span> (dp-&gt;dom_flags &amp; DOM_OLD) {
		<span class="enscript-type">struct</span> domain_old *odp = dp-&gt;dom_old;

		VERIFY(odp != NULL);
		odp-&gt;dom_next = NULL;
		odp-&gt;dom_mtx = NULL;
	}
}

<span class="enscript-comment">/*
 * Exported (private) routine, indirection of net_add_domain.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">net_add_domain_old</span>(<span class="enscript-type">struct</span> domain_old *odp)
{
	<span class="enscript-type">struct</span> domain *dp;
	domain_guard_t guard;

	VERIFY(odp != NULL);

	guard = domain_guard_deploy();
	<span class="enscript-keyword">if</span> ((dp = pffinddomain_locked(odp-&gt;dom_family)) != NULL) {
		<span class="enscript-comment">/*
		 * There is really nothing better than to panic here,
		 * as the caller would not have been able to handle
		 * any failures otherwise.
		 */</span>
		panic(<span class="enscript-string">&quot;%s: domain (%d,%s) already exists for %s\n&quot;</span>, __func__,
		    dp-&gt;dom_family, dp-&gt;dom_name, odp-&gt;dom_name);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/* Make sure nothing is currently pointing to the odp. */</span>
	TAILQ_FOREACH(dp, &amp;domains, dom_entry) {
		<span class="enscript-keyword">if</span> (dp-&gt;dom_old == odp) {
			panic(<span class="enscript-string">&quot;%s: domain %p (%d,%s) is already &quot;</span>
			    <span class="enscript-string">&quot;associated with %p (%d,%s)\n&quot;</span>, __func__,
			    odp, odp-&gt;dom_family, odp-&gt;dom_name, dp,
			    dp-&gt;dom_family, dp-&gt;dom_name);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
	}

	<span class="enscript-keyword">if</span> (odp-&gt;dom_protosw != NULL) {
		panic(<span class="enscript-string">&quot;%s: domain (%d,%s) protocols need to added &quot;</span>
		    <span class="enscript-string">&quot;via net_add_proto\n&quot;</span>, __func__, odp-&gt;dom_family,
		    odp-&gt;dom_name);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	dp = _MALLOC(<span class="enscript-keyword">sizeof</span> (*dp), M_TEMP, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (dp == NULL) {
		<span class="enscript-comment">/*
		 * There is really nothing better than to panic here,
		 * as the caller would not have been able to handle
		 * any failures otherwise.
		 */</span>
		panic(<span class="enscript-string">&quot;%s: unable to allocate memory for domain family &quot;</span>
		    <span class="enscript-string">&quot;%d (%s)\n&quot;</span>, __func__, odp-&gt;dom_family, odp-&gt;dom_name);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/* Copy everything but dom_init, dom_mtx, dom_next and dom_refs */</span>
	dp-&gt;dom_family		= odp-&gt;dom_family;
	dp-&gt;dom_flags		= (odp-&gt;dom_flags &amp; DOMF_USERFLAGS) | DOM_OLD;
	dp-&gt;dom_name		= odp-&gt;dom_name;
	dp-&gt;dom_init		= dom_init_old;
	dp-&gt;dom_externalize	= odp-&gt;dom_externalize;
	dp-&gt;dom_dispose		= odp-&gt;dom_dispose;
	dp-&gt;dom_rtattach	= odp-&gt;dom_rtattach;
	dp-&gt;dom_rtoffset	= odp-&gt;dom_rtoffset;
	dp-&gt;dom_maxrtkey	= odp-&gt;dom_maxrtkey;
	dp-&gt;dom_protohdrlen	= odp-&gt;dom_protohdrlen;
	dp-&gt;dom_old		= odp;

	attach_domain(dp);
	init_domain(dp);

	<span class="enscript-comment">/* Point the mutex back to the internal structure's */</span>
	odp-&gt;dom_mtx		= dp-&gt;dom_mtx;
	domain_guard_release(guard);
}

<span class="enscript-comment">/*
 * Exported (private) routine, indirection of net_del_domain.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">net_del_domain_old</span>(<span class="enscript-type">struct</span> domain_old *odp)
{
	<span class="enscript-type">struct</span> domain *dp1, *dp2;
	<span class="enscript-type">int</span> error = 0;
	domain_guard_t guard;

	VERIFY(odp != NULL);

	guard = domain_guard_deploy();
	<span class="enscript-keyword">if</span> (odp-&gt;dom_refs != 0) {
		error = EBUSY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	TAILQ_FOREACH_SAFE(dp1, &amp;domains, dom_entry, dp2) {
		<span class="enscript-keyword">if</span> (!(dp1-&gt;dom_flags &amp; DOM_OLD))
			<span class="enscript-keyword">continue</span>;
		VERIFY(dp1-&gt;dom_old != NULL);
		<span class="enscript-keyword">if</span> (odp == dp1-&gt;dom_old)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (dp1 != NULL) {
		<span class="enscript-type">struct</span> protosw *pp1, *pp2;

		VERIFY(dp1-&gt;dom_flags &amp; DOM_OLD);
		VERIFY(dp1-&gt;dom_old == odp);

		<span class="enscript-comment">/* Remove all protocols attached to this domain */</span>
		TAILQ_FOREACH_SAFE(pp1, &amp;dp1-&gt;dom_protosw, pr_entry, pp2) {
			detach_proto(pp1, dp1);
			<span class="enscript-keyword">if</span> (pp1-&gt;pr_usrreqs-&gt;pru_flags &amp; PRUF_OLD)
				FREE(pp1-&gt;pr_usrreqs, M_TEMP);
			<span class="enscript-keyword">if</span> (pp1-&gt;pr_flags &amp; PR_OLD)
				FREE(pp1, M_TEMP);
		}

		detach_domain(dp1);
		FREE(dp1, M_TEMP);
	} <span class="enscript-keyword">else</span> {
		error = EPFNOSUPPORT;
	}
<span class="enscript-reference">done</span>:
	domain_guard_release(guard);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Internal routine, not exported.
 *
 * net_add_proto - link a protosw into a domain's protosw chain
 *
 * NOTE: Caller must have acquired domain_proto_mtx
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">net_add_proto</span>(<span class="enscript-type">struct</span> protosw *pp, <span class="enscript-type">struct</span> domain *dp, <span class="enscript-type">int</span> doinit)
{
	<span class="enscript-type">struct</span> protosw *pp1;

	<span class="enscript-comment">/*
	 * This could be called as part of initializing the domain,
	 * and thus DOM_INITIALIZED may not be set (yet).
	 */</span>
	domain_proto_mtx_lock_assert_held();
	VERIFY(!(pp-&gt;pr_flags &amp; PR_ATTACHED));

	<span class="enscript-comment">/* pr_domain is set only after the protocol is attached */</span>
	<span class="enscript-keyword">if</span> (pp-&gt;pr_domain != NULL) {
		panic(<span class="enscript-string">&quot;%s: domain (%d,%s), proto %d has non-NULL pr_domain!\n&quot;</span>,
		    __func__, dp-&gt;dom_family, dp-&gt;dom_name, pp-&gt;pr_protocol);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (pp-&gt;pr_usrreqs == NULL) {
		panic(<span class="enscript-string">&quot;%s: domain (%d,%s), proto %d has no usrreqs!\n&quot;</span>,
		    __func__, dp-&gt;dom_family, dp-&gt;dom_name, pp-&gt;pr_protocol);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	TAILQ_FOREACH(pp1, &amp;dp-&gt;dom_protosw, pr_entry) {
		<span class="enscript-keyword">if</span> (pp1-&gt;pr_type == pp-&gt;pr_type &amp;&amp;
		    pp1-&gt;pr_protocol == pp-&gt;pr_protocol)
			<span class="enscript-keyword">return</span> (EEXIST);
	}

	attach_proto(pp, dp);
	<span class="enscript-keyword">if</span> (doinit)
		net_init_proto(pp, dp);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">net_init_proto</span>(<span class="enscript-type">struct</span> protosw *pp, <span class="enscript-type">struct</span> domain *dp)
{
	<span class="enscript-comment">/*
	 * This could be called as part of initializing the domain,
	 * and thus DOM_INITIALIZED may not be set (yet).  The protocol
	 * must have been attached via net_addr_protosw() by now.
	 */</span>
	domain_proto_mtx_lock_assert_held();
	VERIFY(pp-&gt;pr_flags &amp; PR_ATTACHED);

	init_proto(pp, dp);
}

<span class="enscript-comment">/*
 * Exported (private) routine, indirection of net_add_proto.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">net_add_proto_old</span>(<span class="enscript-type">struct</span> protosw_old *opp, <span class="enscript-type">struct</span> domain_old *odp)
{
	<span class="enscript-type">struct</span> pr_usrreqs_old *opru;
	<span class="enscript-type">struct</span> pr_usrreqs *pru = NULL;
	<span class="enscript-type">struct</span> protosw *pp = NULL, *pp1;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> domain *dp;
	domain_guard_t guard;

	<span class="enscript-comment">/*
	 * This could be called as part of initializing the domain,
	 * and thus DOM_INITIALIZED may not be set (yet).
	 */</span>
	guard = domain_guard_deploy();

	<span class="enscript-comment">/* Make sure the domain has been added via net_add_domain */</span>
	TAILQ_FOREACH(dp, &amp;domains, dom_entry) {
		<span class="enscript-keyword">if</span> (!(dp-&gt;dom_flags &amp; DOM_OLD))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (dp-&gt;dom_old == odp)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (dp == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	TAILQ_FOREACH(pp1, &amp;dp-&gt;dom_protosw, pr_entry) {
		<span class="enscript-keyword">if</span> (pp1-&gt;pr_type == opp-&gt;pr_type &amp;&amp;
		    pp1-&gt;pr_protocol == opp-&gt;pr_protocol) {
			error = EEXIST;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	<span class="enscript-keyword">if</span> ((opru = opp-&gt;pr_usrreqs) == NULL) {
		panic(<span class="enscript-string">&quot;%s: domain (%d,%s), proto %d has no usrreqs!\n&quot;</span>,
		    __func__, odp-&gt;dom_family, odp-&gt;dom_name, opp-&gt;pr_protocol);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	pru = _MALLOC(<span class="enscript-keyword">sizeof</span> (*pru), M_TEMP, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (pru == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	pru-&gt;pru_flags		= PRUF_OLD;
	pru-&gt;pru_abort		= opru-&gt;pru_abort;
	pru-&gt;pru_accept		= opru-&gt;pru_accept;
	pru-&gt;pru_attach		= opru-&gt;pru_attach;
	pru-&gt;pru_bind		= opru-&gt;pru_bind;
	pru-&gt;pru_connect	= opru-&gt;pru_connect;
	pru-&gt;pru_connect2	= opru-&gt;pru_connect2;
	pru-&gt;pru_control	= opru-&gt;pru_control;
	pru-&gt;pru_detach		= opru-&gt;pru_detach;
	pru-&gt;pru_disconnect	= opru-&gt;pru_disconnect;
	pru-&gt;pru_listen		= opru-&gt;pru_listen;
	pru-&gt;pru_peeraddr	= opru-&gt;pru_peeraddr;
	pru-&gt;pru_rcvd		= opru-&gt;pru_rcvd;
	pru-&gt;pru_rcvoob		= opru-&gt;pru_rcvoob;
	pru-&gt;pru_send		= opru-&gt;pru_send;
	pru-&gt;pru_sense		= opru-&gt;pru_sense;
	pru-&gt;pru_shutdown	= opru-&gt;pru_shutdown;
	pru-&gt;pru_sockaddr	= opru-&gt;pru_sockaddr;
	pru-&gt;pru_sosend		= opru-&gt;pru_sosend;
	pru-&gt;pru_soreceive	= opru-&gt;pru_soreceive;
	pru-&gt;pru_sopoll		= opru-&gt;pru_sopoll;

	pp = _MALLOC(<span class="enscript-keyword">sizeof</span> (*pp), M_TEMP, M_WAITOK | M_ZERO);
	<span class="enscript-keyword">if</span> (pp == NULL) {
		error = ENOMEM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * Protocol fast and slow timers are now deprecated.
	 */</span>
	<span class="enscript-keyword">if</span> (opp-&gt;pr_unused != NULL) {
		printf(<span class="enscript-string">&quot;%s: domain (%d,%s), proto %d: pr_fasttimo is &quot;</span>
		    <span class="enscript-string">&quot;deprecated and won't be called\n&quot;</span>, __func__,
		    odp-&gt;dom_family, odp-&gt;dom_name, opp-&gt;pr_protocol);
	}
	<span class="enscript-keyword">if</span> (opp-&gt;pr_unused2 != NULL) {
		printf(<span class="enscript-string">&quot;%s: domain (%d,%s), proto %d: pr_slowtimo is &quot;</span>
		    <span class="enscript-string">&quot;deprecated and won't be called\n&quot;</span>, __func__,
		    odp-&gt;dom_family, odp-&gt;dom_name, opp-&gt;pr_protocol);
	}

	<span class="enscript-comment">/* Copy everything but pr_init, pr_next, pr_domain, pr_protosw */</span>
	pp-&gt;pr_type		= opp-&gt;pr_type;
	pp-&gt;pr_protocol		= opp-&gt;pr_protocol;
	pp-&gt;pr_flags		= (opp-&gt;pr_flags &amp; PRF_USERFLAGS) | PR_OLD;
	pp-&gt;pr_input		= opp-&gt;pr_input;
	pp-&gt;pr_output		= opp-&gt;pr_output;
	pp-&gt;pr_ctlinput		= opp-&gt;pr_ctlinput;
	pp-&gt;pr_ctloutput	= opp-&gt;pr_ctloutput;
	pp-&gt;pr_usrreqs		= pru;
	pp-&gt;pr_init		= pr_init_old;
	pp-&gt;pr_drain		= opp-&gt;pr_drain;
	pp-&gt;pr_sysctl		= opp-&gt;pr_sysctl;
	pp-&gt;pr_lock		= opp-&gt;pr_lock;
	pp-&gt;pr_unlock		= opp-&gt;pr_unlock;
	pp-&gt;pr_getlock		= opp-&gt;pr_getlock;
	pp-&gt;pr_old		= opp;

	<span class="enscript-comment">/* attach as well as initialize */</span>
	attach_proto(pp, dp);
	net_init_proto(pp, dp);
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: domain (%d,%s), proto %d: failed to attach, &quot;</span>
		    <span class="enscript-string">&quot;error %d\n&quot;</span>, __func__, odp-&gt;dom_family,
		    odp-&gt;dom_name, opp-&gt;pr_protocol, error);

		<span class="enscript-keyword">if</span> (pru != NULL)
			FREE(pru, M_TEMP);
		<span class="enscript-keyword">if</span> (pp != NULL)
			FREE(pp, M_TEMP);
	}

	domain_guard_release(guard);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Internal routine, not exported.
 *
 * net_del_proto - remove a protosw from a domain's protosw chain.
 * Search the protosw chain for the element with matching data.
 * Then unlink and return.
 *
 * NOTE: Caller must have acquired domain_proto_mtx
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">net_del_proto</span>(<span class="enscript-type">int</span> type, <span class="enscript-type">int</span> protocol, <span class="enscript-type">struct</span> domain *dp)
{
	<span class="enscript-type">struct</span> protosw *pp;

	<span class="enscript-comment">/*
	 * This could be called as part of initializing the domain,
	 * and thus DOM_INITIALIZED may not be set (yet).
	 */</span>
	domain_proto_mtx_lock_assert_held();

	TAILQ_FOREACH(pp, &amp;dp-&gt;dom_protosw, pr_entry) {
		<span class="enscript-keyword">if</span> (pp-&gt;pr_type == type &amp;&amp; pp-&gt;pr_protocol == protocol)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (pp == NULL)
		<span class="enscript-keyword">return</span> (ENXIO);

	detach_proto(pp, dp);
	<span class="enscript-keyword">if</span> (pp-&gt;pr_usrreqs-&gt;pru_flags &amp; PRUF_OLD)
		FREE(pp-&gt;pr_usrreqs, M_TEMP);
	<span class="enscript-keyword">if</span> (pp-&gt;pr_flags &amp; PR_OLD)
		FREE(pp, M_TEMP);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Exported (private) routine, indirection of net_del_proto.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">net_del_proto_old</span>(<span class="enscript-type">int</span> type, <span class="enscript-type">int</span> protocol, <span class="enscript-type">struct</span> domain_old *odp)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> protosw *pp;
	<span class="enscript-type">struct</span> domain *dp;
	domain_guard_t guard;

	<span class="enscript-comment">/*
	 * This could be called as part of initializing the domain,
	 * and thus DOM_INITIALIZED may not be set (yet).
	 */</span>
	guard = domain_guard_deploy();

	<span class="enscript-comment">/* Make sure the domain has been added via net_add_domain */</span>
	TAILQ_FOREACH(dp, &amp;domains, dom_entry) {
		<span class="enscript-keyword">if</span> (!(dp-&gt;dom_flags &amp; DOM_OLD))
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (dp-&gt;dom_old == odp)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (dp == NULL) {
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	TAILQ_FOREACH(pp, &amp;dp-&gt;dom_protosw, pr_entry) {
		<span class="enscript-keyword">if</span> (pp-&gt;pr_type == type &amp;&amp; pp-&gt;pr_protocol == protocol)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (pp == NULL) {
		error = ENXIO;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	detach_proto(pp, dp);
	<span class="enscript-keyword">if</span> (pp-&gt;pr_usrreqs-&gt;pru_flags &amp; PRUF_OLD)
		FREE(pp-&gt;pr_usrreqs, M_TEMP);
	<span class="enscript-keyword">if</span> (pp-&gt;pr_flags &amp; PR_OLD)
		FREE(pp, M_TEMP);

<span class="enscript-reference">done</span>:
	domain_guard_release(guard);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">domain_sched_timeout</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_assert(&amp;domain_timeout_mtx, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (!domain_timeout_run &amp;&amp; domain_draining) {
		domain_timeout_run = TRUE;
		timeout(domain_timeout, NULL, hz);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">net_drain_domains</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_lock(&amp;domain_timeout_mtx);
	domain_draining = TRUE;
	domain_sched_timeout();
	lck_mtx_unlock(&amp;domain_timeout_mtx);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> domain inet6domain_s;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> domain keydomain_s;
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> domain routedomain_s, ndrvdomain_s, inetdomain_s;
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> domain systemdomain_s, localdomain_s;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MULTIPATH</span>
<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> domain mpdomain_s;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MULTIPATH */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">domain_timeout</span>(<span class="enscript-type">void</span> *arg)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg</span>)
	<span class="enscript-type">struct</span> protosw *pp;
	<span class="enscript-type">struct</span> domain *dp;
	domain_guard_t guard;

	lck_mtx_lock(&amp;domain_timeout_mtx);
	<span class="enscript-keyword">if</span> (domain_draining) {
		domain_draining = FALSE;
		lck_mtx_unlock(&amp;domain_timeout_mtx);

		guard = domain_guard_deploy();
		TAILQ_FOREACH(dp, &amp;domains, dom_entry) {
			TAILQ_FOREACH(pp, &amp;dp-&gt;dom_protosw, pr_entry) {
				<span class="enscript-keyword">if</span> (pp-&gt;pr_drain != NULL)
					(*pp-&gt;pr_drain)();
			}
		}
		domain_guard_release(guard);

		lck_mtx_lock(&amp;domain_timeout_mtx);
	}

	<span class="enscript-comment">/* re-arm the timer if there's work to do */</span>
	domain_timeout_run = FALSE;
	domain_sched_timeout();
	lck_mtx_unlock(&amp;domain_timeout_mtx);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">domaininit</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> domain *dp;
	domain_guard_t guard;

	<span class="enscript-comment">/*
	 * allocate lock group attribute and group for domain mutexes
	 */</span>
	domain_proto_mtx_grp_attr = lck_grp_attr_alloc_init();

	domain_proto_mtx_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;domain&quot;</span>,
	    domain_proto_mtx_grp_attr);

	<span class="enscript-comment">/*
	 * allocate the lock attribute for per domain mutexes
	 */</span>
	domain_proto_mtx_attr = lck_attr_alloc_init();

	lck_mtx_init(&amp;domain_proto_mtx, domain_proto_mtx_grp,
	    domain_proto_mtx_attr);
	lck_mtx_init(&amp;domain_timeout_mtx, domain_proto_mtx_grp,
	    domain_proto_mtx_attr);

	guard = domain_guard_deploy();
	<span class="enscript-comment">/*
	 * Add all the static domains to the domains list.  route domain
	 * gets added and initialized last, since we need it to attach
	 * rt_tables[] to everything that's already there.  This also
	 * means that domains added after this point won't get their
	 * dom_rtattach() called on rt_tables[].
	 */</span>
	attach_domain(&amp;inetdomain_s);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	attach_domain(&amp;inet6domain_s);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* INET6 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MULTIPATH</span>
	attach_domain(&amp;mpdomain_s);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MULTIPATH */</span>
	attach_domain(&amp;systemdomain_s);
	attach_domain(&amp;localdomain_s);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IPSEC</span>
	attach_domain(&amp;keydomain_s);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IPSEC */</span>
	attach_domain(&amp;ndrvdomain_s);
	attach_domain(&amp;routedomain_s);	<span class="enscript-comment">/* must be last domain */</span>

	<span class="enscript-comment">/*
	 * Now ask them all to init (XXX including the routing domain,
	 * see above)
	 */</span>
	TAILQ_FOREACH(dp, &amp;domains, dom_entry)
		init_domain(dp);

	domain_guard_release(guard);
}

<span class="enscript-type">static</span> __inline__ <span class="enscript-type">struct</span> domain *
<span class="enscript-function-name">pffinddomain_locked</span>(<span class="enscript-type">int</span> pf)
{
	<span class="enscript-type">struct</span> domain *dp;

	domain_proto_mtx_lock_assert_held();

	TAILQ_FOREACH(dp, &amp;domains, dom_entry) {
		<span class="enscript-keyword">if</span> (dp-&gt;dom_family == pf)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">return</span> (dp);
}

<span class="enscript-type">struct</span> protosw *
<span class="enscript-function-name">pffindtype</span>(<span class="enscript-type">int</span> family, <span class="enscript-type">int</span> type)
{
	<span class="enscript-type">struct</span> protosw *pp = NULL;
	<span class="enscript-type">struct</span> domain *dp;
	domain_guard_t guard;

	guard = domain_guard_deploy();
	<span class="enscript-keyword">if</span> ((dp = pffinddomain_locked(family)) == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	TAILQ_FOREACH(pp, &amp;dp-&gt;dom_protosw, pr_entry) {
		<span class="enscript-keyword">if</span> (pp-&gt;pr_type != 0 &amp;&amp; pp-&gt;pr_type == type)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
<span class="enscript-reference">done</span>:
	domain_guard_release(guard);
	<span class="enscript-keyword">return</span> (pp);
}

<span class="enscript-comment">/*
 * Internal routine, not exported.
 */</span>
<span class="enscript-type">struct</span> domain *
<span class="enscript-function-name">pffinddomain</span>(<span class="enscript-type">int</span> pf)
{
	<span class="enscript-type">struct</span> domain *dp;
	domain_guard_t guard;

	guard = domain_guard_deploy();
	dp = pffinddomain_locked(pf);
	domain_guard_release(guard);
	<span class="enscript-keyword">return</span> (dp);
}

<span class="enscript-comment">/*
 * Exported (private) routine, indirection of pffinddomain.
 */</span>
<span class="enscript-type">struct</span> domain_old *
<span class="enscript-function-name">pffinddomain_old</span>(<span class="enscript-type">int</span> pf)
{
	<span class="enscript-type">struct</span> domain_old *odp = NULL;
	<span class="enscript-type">struct</span> domain *dp;
	domain_guard_t guard;

	guard = domain_guard_deploy();
	<span class="enscript-keyword">if</span> ((dp = pffinddomain_locked(pf)) != NULL &amp;&amp; (dp-&gt;dom_flags &amp; DOM_OLD))
		odp = dp-&gt;dom_old;
	domain_guard_release(guard);
	<span class="enscript-keyword">return</span> (odp);
}

<span class="enscript-comment">/*
 * Internal routine, not exported.
 */</span>
<span class="enscript-type">struct</span> protosw *
<span class="enscript-function-name">pffindproto</span>(<span class="enscript-type">int</span> family, <span class="enscript-type">int</span> protocol, <span class="enscript-type">int</span> type)
{
	<span class="enscript-type">struct</span> protosw *pp;
	domain_guard_t guard;

	guard = domain_guard_deploy();
	pp = pffindproto_locked(family, protocol, type);
	domain_guard_release(guard);
	<span class="enscript-keyword">return</span> (pp);
}

<span class="enscript-type">struct</span> protosw *
<span class="enscript-function-name">pffindproto_locked</span>(<span class="enscript-type">int</span> family, <span class="enscript-type">int</span> protocol, <span class="enscript-type">int</span> type)
{
	<span class="enscript-type">struct</span> protosw *maybe = NULL;
	<span class="enscript-type">struct</span> protosw *pp;
	<span class="enscript-type">struct</span> domain *dp;

	domain_proto_mtx_lock_assert_held();

	<span class="enscript-keyword">if</span> (family == 0)
		<span class="enscript-keyword">return</span> (0);

	dp = pffinddomain_locked(family);
	<span class="enscript-keyword">if</span> (dp == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	TAILQ_FOREACH(pp, &amp;dp-&gt;dom_protosw, pr_entry) {
		<span class="enscript-keyword">if</span> ((pp-&gt;pr_protocol == protocol) &amp;&amp; (pp-&gt;pr_type == type))
			<span class="enscript-keyword">return</span> (pp);

		<span class="enscript-keyword">if</span> (type == SOCK_RAW &amp;&amp; pp-&gt;pr_type == SOCK_RAW &amp;&amp;
		    pp-&gt;pr_protocol == 0 &amp;&amp; maybe == NULL)
			maybe = pp;
	}
	<span class="enscript-keyword">return</span> (maybe);
}

<span class="enscript-comment">/*
 * Exported (private) routine, indirection of pffindproto.
 */</span>
<span class="enscript-type">struct</span> protosw_old *
<span class="enscript-function-name">pffindproto_old</span>(<span class="enscript-type">int</span> family, <span class="enscript-type">int</span> protocol, <span class="enscript-type">int</span> type)
{
	<span class="enscript-type">struct</span> protosw_old *opr = NULL;
	<span class="enscript-type">struct</span> protosw *pp;
	domain_guard_t guard;

	guard = domain_guard_deploy();
	<span class="enscript-keyword">if</span> ((pp = pffindproto_locked(family, protocol, type)) != NULL &amp;&amp;
	    (pp-&gt;pr_flags &amp; PR_OLD))
		opr = pp-&gt;pr_old;
	domain_guard_release(guard);
	<span class="enscript-keyword">return</span> (opr);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> protosw *
<span class="enscript-function-name">pffindprotonotype_locked</span>(<span class="enscript-type">int</span> family, <span class="enscript-type">int</span> protocol, <span class="enscript-type">int</span> type)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">type</span>)
	<span class="enscript-type">struct</span> domain *dp;
	<span class="enscript-type">struct</span> protosw *pp;

	domain_proto_mtx_lock_assert_held();

	<span class="enscript-keyword">if</span> (family == 0)
		<span class="enscript-keyword">return</span> (0);

	dp = pffinddomain_locked(family);
	<span class="enscript-keyword">if</span> (dp == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	TAILQ_FOREACH(pp, &amp;dp-&gt;dom_protosw, pr_entry) {
		<span class="enscript-keyword">if</span> (pp-&gt;pr_protocol == protocol)
			<span class="enscript-keyword">return</span> (pp);
	}
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">struct</span> protosw *
<span class="enscript-function-name">pffindprotonotype</span>(<span class="enscript-type">int</span> family, <span class="enscript-type">int</span> protocol)
{
	<span class="enscript-type">struct</span> protosw *pp;
	domain_guard_t guard;

	<span class="enscript-keyword">if</span> (protocol == 0)
		<span class="enscript-keyword">return</span> (NULL);

	guard = domain_guard_deploy();
	pp = pffindprotonotype_locked(family, protocol, 0);
	domain_guard_release(guard);
	<span class="enscript-keyword">return</span> (pp);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pfctlinput</span>(<span class="enscript-type">int</span> cmd, <span class="enscript-type">struct</span> sockaddr *sa)
{
	pfctlinput2(cmd, sa, NULL);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pfctlinput2</span>(<span class="enscript-type">int</span> cmd, <span class="enscript-type">struct</span> sockaddr *sa, <span class="enscript-type">void</span> *ctlparam)
{
	<span class="enscript-type">struct</span> domain *dp;
	<span class="enscript-type">struct</span> protosw *pp;
	domain_guard_t guard;

	<span class="enscript-keyword">if</span> (sa == NULL)
		<span class="enscript-keyword">return</span>;

	guard = domain_guard_deploy();
	TAILQ_FOREACH(dp, &amp;domains, dom_entry) {
		TAILQ_FOREACH(pp, &amp;dp-&gt;dom_protosw, pr_entry) {
			<span class="enscript-keyword">if</span> (pp-&gt;pr_ctlinput != NULL)
				(*pp-&gt;pr_ctlinput)(cmd, sa, ctlparam);
		}
	}
	domain_guard_release(guard);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">net_update_uptime</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> timeval tv;

	microuptime(&amp;tv);
	_net_uptime = tv.tv_sec;
	<span class="enscript-comment">/*
	 * Round up the timer to the nearest integer value because otherwise
	 * we might setup networking timers that are off by almost 1 second.
	 */</span>
	<span class="enscript-keyword">if</span> (tv.tv_usec &gt; 500000)
		_net_uptime++;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">net_update_uptime_secs</span>(uint64_t secs)
{
	_net_uptime = secs;
}

<span class="enscript-comment">/*
 * Convert our uin64_t net_uptime to a struct timeval.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">net_uptime2timeval</span>(<span class="enscript-type">struct</span> timeval *tv)
{
	<span class="enscript-keyword">if</span> (tv == NULL)
		<span class="enscript-keyword">return</span>;

	tv-&gt;tv_usec = 0;
	tv-&gt;tv_sec = net_uptime();
}

<span class="enscript-comment">/*
 * An alternative way to obtain the coarse-grained uptime (in seconds)
 * for networking code which do not require high-precision timestamp,
 * as this is significantly cheaper than microuptime().
 */</span>
u_int64_t
<span class="enscript-function-name">net_uptime</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (_net_uptime == 0)
		net_update_uptime();

	<span class="enscript-keyword">return</span> (_net_uptime);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">domain_proto_mtx_lock_assert_held</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_assert(&amp;domain_proto_mtx, LCK_MTX_ASSERT_OWNED);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">domain_proto_mtx_lock_assert_notheld</span>(<span class="enscript-type">void</span>)
{
	lck_mtx_assert(&amp;domain_proto_mtx, LCK_MTX_ASSERT_NOTOWNED);
}

domain_guard_t
<span class="enscript-function-name">domain_guard_deploy</span>(<span class="enscript-type">void</span>)
{
	net_thread_marks_t marks;

	marks = net_thread_marks_push(NET_THREAD_HELD_DOMAIN);
	<span class="enscript-keyword">if</span> (marks != net_thread_marks_none) {
		lck_mtx_assert(&amp;domain_proto_mtx, LCK_MTX_ASSERT_NOTOWNED);
		lck_mtx_lock(&amp;domain_proto_mtx);
	}
	<span class="enscript-keyword">else</span>
		lck_mtx_assert(&amp;domain_proto_mtx, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">return</span> ((domain_guard_t)(<span class="enscript-type">const</span> <span class="enscript-type">void</span>*)marks);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">domain_guard_release</span>(domain_guard_t guard)
{
	net_thread_marks_t marks = (net_thread_marks_t)(<span class="enscript-type">const</span> <span class="enscript-type">void</span>*)guard;

	<span class="enscript-keyword">if</span> (marks != net_thread_marks_none) {
		lck_mtx_assert(&amp;domain_proto_mtx, LCK_MTX_ASSERT_OWNED);
		lck_mtx_unlock(&amp;domain_proto_mtx);
		net_thread_marks_pop(marks);
	}
	<span class="enscript-keyword">else</span>
		lck_mtx_assert(&amp;domain_proto_mtx, LCK_MTX_ASSERT_NOTOWNED);
}

domain_unguard_t
<span class="enscript-function-name">domain_unguard_deploy</span>(<span class="enscript-type">void</span>)
{
	net_thread_marks_t marks;

	marks = net_thread_unmarks_push(NET_THREAD_HELD_DOMAIN);
	<span class="enscript-keyword">if</span> (marks != net_thread_marks_none) {
		lck_mtx_assert(&amp;domain_proto_mtx, LCK_MTX_ASSERT_OWNED);
		lck_mtx_unlock(&amp;domain_proto_mtx);
	}
	<span class="enscript-keyword">else</span>
		lck_mtx_assert(&amp;domain_proto_mtx, LCK_MTX_ASSERT_NOTOWNED);

	<span class="enscript-keyword">return</span> ((domain_unguard_t)(<span class="enscript-type">const</span> <span class="enscript-type">void</span>*)marks);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">domain_unguard_release</span>(domain_unguard_t unguard)
{
	net_thread_marks_t marks = (net_thread_marks_t)(<span class="enscript-type">const</span> <span class="enscript-type">void</span>*)unguard;

	<span class="enscript-keyword">if</span> (marks != net_thread_marks_none) {
		lck_mtx_assert(&amp;domain_proto_mtx, LCK_MTX_ASSERT_NOTOWNED);
		lck_mtx_lock(&amp;domain_proto_mtx);
		net_thread_unmarks_pop(marks);
	}
	<span class="enscript-keyword">else</span>
		lck_mtx_assert(&amp;domain_proto_mtx, LCK_MTX_ASSERT_OWNED);
}

#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
 
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_do_drain_domains SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> dummy = 0;

	error = sysctl_handle_int(oidp, &amp;dummy, 0, req);	
	<span class="enscript-keyword">if</span> (error || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (error);

	net_drain_domains();

	<span class="enscript-keyword">return</span> (0);
}

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>
 </pre>
<hr />
</body></html>