<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_lockf.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_lockf.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2015 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Scooter Morris at Genentech Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)ufs_lockf.c	8.3 (Berkeley) 1/6/94
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/cdefs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/lockf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sdt.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>

<span class="enscript-comment">/*
 * This variable controls the maximum number of processes that will
 * be checked in doing deadlock detection.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> maxlockdepth = MAXDEPTH;

#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LOCKF_DEBUGGING</span>	1
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCKF_DEBUGGING</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">lf_print</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *tag, <span class="enscript-type">struct</span> lockf *lock);
<span class="enscript-type">void</span> <span class="enscript-function-name">lf_printlist</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *tag, <span class="enscript-type">struct</span> lockf *lock);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LF_DBG_LOCKOP</span>	(1 &lt;&lt; 0)	<span class="enscript-comment">/* setlk, getlk, clearlk */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LF_DBG_LIST</span>	(1 &lt;&lt; 1)	<span class="enscript-comment">/* split, coalesce */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LF_DBG_IMPINH</span>	(1 &lt;&lt; 2)	<span class="enscript-comment">/* importance inheritance */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LF_DBG_TRACE</span>	(1 &lt;&lt; 3)	<span class="enscript-comment">/* errors, exit */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	lockf_debug = 0;	<span class="enscript-comment">/* was 2, could be 3 ;-) */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_debug, OID_AUTO, lockf_debug, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;lockf_debug, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/*
 * If there is no mask bit selector, or there is one, and the selector is
 * set, then output the debugging diagnostic.
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">LOCKF_DEBUG</span>(mask, ...)					\
	<span class="enscript-keyword">do</span> {							\
		<span class="enscript-keyword">if</span>( !(mask) || ((mask) &amp; lockf_debug)) {	\
			printf(__VA_ARGS__);			\
		}						\
	} <span class="enscript-keyword">while</span>(0)
#<span class="enscript-reference">else</span>	<span class="enscript-comment">/* !LOCKF_DEBUGGING */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">LOCKF_DEBUG</span>(mask, ...)		<span class="enscript-comment">/* mask */</span>
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* !LOCKF_DEBUGGING */</span>

<span class="enscript-function-name">MALLOC_DEFINE</span>(M_LOCKF, <span class="enscript-string">&quot;lockf&quot;</span>, <span class="enscript-string">&quot;Byte-range locking structures&quot;</span>);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">NOLOCKF</span> (struct lockf *)0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">SELF</span>	0x1
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">OTHERS</span>	0x2
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">OFF_MAX</span>	0x7fffffffffffffffULL	<span class="enscript-comment">/* max off_t */</span>

<span class="enscript-comment">/*
 * Overlapping lock states
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	OVERLAP_NONE = 0,
	OVERLAP_EQUALS_LOCK,
	OVERLAP_CONTAINS_LOCK,
	OVERLAP_CONTAINED_BY_LOCK,
	OVERLAP_STARTS_BEFORE_LOCK,
	OVERLAP_ENDS_AFTER_LOCK
} overlap_t;

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	 lf_clearlock(<span class="enscript-type">struct</span> lockf *);
<span class="enscript-type">static</span> overlap_t <span class="enscript-function-name">lf_findoverlap</span>(<span class="enscript-type">struct</span> lockf *,
	    <span class="enscript-type">struct</span> lockf *, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> lockf ***, <span class="enscript-type">struct</span> lockf **);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> lockf *<span class="enscript-function-name">lf_getblock</span>(<span class="enscript-type">struct</span> lockf *, pid_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	 lf_getlock(<span class="enscript-type">struct</span> lockf *, <span class="enscript-type">struct</span> flock *, pid_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	 lf_setlock(<span class="enscript-type">struct</span> lockf *, <span class="enscript-type">struct</span> timespec *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	 lf_split(<span class="enscript-type">struct</span> lockf *, <span class="enscript-type">struct</span> lockf *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	 lf_wakelock(<span class="enscript-type">struct</span> lockf *, boolean_t);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	 lf_hold_assertion(task_t, <span class="enscript-type">struct</span> lockf *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	 lf_jump_to_queue_head(<span class="enscript-type">struct</span> lockf *, <span class="enscript-type">struct</span> lockf *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	 lf_drop_assertion(<span class="enscript-type">struct</span> lockf *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	 lf_boost_blocking_proc(<span class="enscript-type">struct</span> lockf *, <span class="enscript-type">struct</span> lockf *);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

<span class="enscript-comment">/*
 * lf_advlock
 *
 * Description:	Advisory record locking support
 *
 * Parameters:	ap			Argument pointer to a vnop_advlock_args
 *					argument descriptor structure for the
 *					lock operation to be attempted.
 *
 * Returns:	0			Success
 *		EOVERFLOW
 *		EINVAL
 *		ENOLCK			Number of locked regions exceeds limit
 *	lf_setlock:EAGAIN
 *	lf_setlock:EDEADLK
 *	lf_setlock:EINTR
 *	lf_setlock:ENOLCK
 *	lf_setlock:ETIMEDOUT
 *	lf_clearlock:ENOLCK
 *	vnode_size:???
 *
 * Notes:	We return ENOLCK when we run out of memory to support locks; as
 *		such, there is no specific expectation limit other than the
 *		amount of available resources.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">lf_advlock</span>(<span class="enscript-type">struct</span> vnop_advlock_args *ap)
{
	<span class="enscript-type">struct</span> vnode *vp = ap-&gt;a_vp;
	<span class="enscript-type">struct</span> flock *fl = ap-&gt;a_fl;
	vfs_context_t context = ap-&gt;a_context;
	<span class="enscript-type">struct</span> lockf *lock;
	off_t start, end, oadd;
	u_quad_t size;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> lockf **head = &amp;vp-&gt;v_lockf;

	<span class="enscript-comment">/* XXX HFS may need a !vnode_isreg(vp) EISDIR error here */</span>

	<span class="enscript-comment">/*
	 * Avoid the common case of unlocking when inode has no locks.
	 */</span>
	<span class="enscript-keyword">if</span> (*head == (<span class="enscript-type">struct</span> lockf *)0) {
		<span class="enscript-keyword">if</span> (ap-&gt;a_op != F_SETLK) {
			fl-&gt;l_type = F_UNLCK;
			LOCKF_DEBUG(LF_DBG_TRACE,
			    <span class="enscript-string">&quot;lf_advlock: '%s' unlock without lock\n&quot;</span>,
			    vfs_context_proc(context)-&gt;p_comm);
			<span class="enscript-keyword">return</span> (0);
		}
	}

	<span class="enscript-comment">/*
	 * Convert the flock structure into a start and end.
	 */</span>
	<span class="enscript-keyword">switch</span> (fl-&gt;l_whence) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SEEK_SET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SEEK_CUR</span>:
		<span class="enscript-comment">/*
		 * Caller is responsible for adding any necessary offset
		 * when SEEK_CUR is used.
		 */</span>
		start = fl-&gt;l_start;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SEEK_END</span>:

		<span class="enscript-comment">/*
		 * It's OK to cast the u_quad_t to and off_t here, since they
		 * are the same storage size, and the value of the returned
		 * contents will never overflow into the sign bit.  We need to
		 * do this because we will use size to force range checks.
		 */</span>
		<span class="enscript-keyword">if</span> ((error = vnode_size(vp, (off_t *)&amp;size, context))) {
			LOCKF_DEBUG(LF_DBG_TRACE,
			    <span class="enscript-string">&quot;lf_advlock: vnode_getattr failed: %d\n&quot;</span>, error);
			<span class="enscript-keyword">return</span> (error);
		}

		<span class="enscript-keyword">if</span> (size &gt; OFF_MAX ||
		    (fl-&gt;l_start &gt; 0 &amp;&amp;
		     size &gt; (u_quad_t)(OFF_MAX - fl-&gt;l_start)))
			<span class="enscript-keyword">return</span> (EOVERFLOW);
		start = size + fl-&gt;l_start;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		LOCKF_DEBUG(LF_DBG_TRACE, <span class="enscript-string">&quot;lf_advlock: unknown whence %d\n&quot;</span>,
		    fl-&gt;l_whence);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> (start &lt; 0) {
		LOCKF_DEBUG(LF_DBG_TRACE, <span class="enscript-string">&quot;lf_advlock: start &lt; 0 (%qd)\n&quot;</span>,
		    start);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> (fl-&gt;l_len &lt; 0) {
		<span class="enscript-keyword">if</span> (start == 0) {
			LOCKF_DEBUG(LF_DBG_TRACE,
			    <span class="enscript-string">&quot;lf_advlock: len &lt; 0 &amp; start == 0\n&quot;</span>);
			<span class="enscript-keyword">return</span> (EINVAL);
		}
		end = start - 1;
		start += fl-&gt;l_len;
		<span class="enscript-keyword">if</span> (start &lt; 0) {
			LOCKF_DEBUG(LF_DBG_TRACE,
			    <span class="enscript-string">&quot;lf_advlock: start &lt; 0 (%qd)\n&quot;</span>, start);
			<span class="enscript-keyword">return</span> (EINVAL);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (fl-&gt;l_len == 0)
		end = -1;
	<span class="enscript-keyword">else</span> {
		oadd = fl-&gt;l_len - 1;
		<span class="enscript-keyword">if</span> (oadd &gt; (off_t)(OFF_MAX - start)) {
		        LOCKF_DEBUG(LF_DBG_TRACE, <span class="enscript-string">&quot;lf_advlock: overflow\n&quot;</span>);
			<span class="enscript-keyword">return</span> (EOVERFLOW);
		}
		end = start + oadd;
	}
	<span class="enscript-comment">/*
	 * Create the lockf structure
	 */</span>
	MALLOC(lock, <span class="enscript-type">struct</span> lockf *, <span class="enscript-keyword">sizeof</span> *lock, M_LOCKF, M_WAITOK);
	<span class="enscript-keyword">if</span> (lock == NULL)
		<span class="enscript-keyword">return</span> (ENOLCK);
	lock-&gt;lf_start = start;
	lock-&gt;lf_end = end;
	lock-&gt;lf_id = ap-&gt;a_id;
	lock-&gt;lf_vnode = vp;
	lock-&gt;lf_type = fl-&gt;l_type;
	lock-&gt;lf_head = head;
	lock-&gt;lf_next = (<span class="enscript-type">struct</span> lockf *)0;
	TAILQ_INIT(&amp;lock-&gt;lf_blkhd);
	lock-&gt;lf_flags = ap-&gt;a_flags;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
	lock-&gt;lf_boosted = LF_NOT_BOOSTED;
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (ap-&gt;a_flags &amp; F_POSIX)
		lock-&gt;lf_owner = (<span class="enscript-type">struct</span> proc *)lock-&gt;lf_id;
	<span class="enscript-keyword">else</span>
		lock-&gt;lf_owner = NULL;

	<span class="enscript-keyword">if</span> (ap-&gt;a_flags &amp; F_FLOCK)
	        lock-&gt;lf_flags |= F_WAKE1_SAFE;

	lck_mtx_lock(&amp;vp-&gt;v_lock);	<span class="enscript-comment">/* protect the lockf list */</span>
	<span class="enscript-comment">/*
	 * Do the requested operation.
	 */</span>
	<span class="enscript-keyword">switch</span>(ap-&gt;a_op) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_SETLK</span>:
		<span class="enscript-comment">/*
		 * For F_OFD_* locks, lf_id is the fileglob.
		 * Record an &quot;lf_owner&quot; iff this is a confined fd
		 * i.e. it cannot escape this process and will be
		 * F_UNLCKed before the owner exits.  (This is
		 * the implicit guarantee needed to ensure lf_owner
		 * remains a valid reference here.)
		 */</span>
		<span class="enscript-keyword">if</span> (ap-&gt;a_flags &amp; F_OFD_LOCK) {
			<span class="enscript-type">struct</span> fileglob *fg = (<span class="enscript-type">void</span> *)lock-&gt;lf_id;
			<span class="enscript-keyword">if</span> (fg-&gt;fg_lflags &amp; FG_CONFINED)
				lock-&gt;lf_owner = current_proc();
		}
		error = lf_setlock(lock, ap-&gt;a_timeout);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_UNLCK</span>:
		error = lf_clearlock(lock);
		FREE(lock, M_LOCKF);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">F_GETLK</span>:
		error = lf_getlock(lock, fl, -1);
		FREE(lock, M_LOCKF);
		<span class="enscript-keyword">break</span>;


	<span class="enscript-reference">default</span>:
		FREE(lock, M_LOCKF);
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}
	lck_mtx_unlock(&amp;vp-&gt;v_lock);	<span class="enscript-comment">/* done manipulating the list */</span>

	LOCKF_DEBUG(LF_DBG_TRACE, <span class="enscript-string">&quot;lf_advlock: normal exit: %d\n&quot;</span>, error);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Empty the queue of msleeping requests for a lock on the given vnode.
 * Called with the vnode already locked.  Used for forced unmount, where
 * a flock(2) invoker sleeping on a blocked lock holds an iocount reference
 * that prevents the vnode from ever being drained.  Force unmounting wins.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lf_abort_advlocks</span>(vnode_t vp)
{
	<span class="enscript-type">struct</span> lockf *lock;

	<span class="enscript-keyword">if</span> ((lock = vp-&gt;v_lockf) == NULL)
		<span class="enscript-keyword">return</span>;	

	lck_mtx_assert(&amp;vp-&gt;v_lock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;lock-&gt;lf_blkhd)) {
		<span class="enscript-type">struct</span> lockf *tlock;

		TAILQ_FOREACH(tlock, &amp;lock-&gt;lf_blkhd, lf_block) {
			<span class="enscript-comment">/*
			 * Setting this flag should cause all
			 * currently blocked F_SETLK request to
			 * return to userland with an errno.
			 */</span>
			tlock-&gt;lf_flags |= F_ABORT;
		}
		lf_wakelock(lock, TRUE);
	}
}

<span class="enscript-comment">/*
 * Take any lock attempts which are currently blocked by a given lock (&quot;from&quot;)
 * and mark them as blocked by a different lock (&quot;to&quot;).  Used in the case
 * where a byte range currently occupied by &quot;from&quot; is to be occupied by &quot;to.&quot;
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">lf_move_blocked</span>(<span class="enscript-type">struct</span> lockf *to, <span class="enscript-type">struct</span> lockf *from)
{
	<span class="enscript-type">struct</span> lockf *tlock;

	TAILQ_FOREACH(tlock, &amp;from-&gt;lf_blkhd, lf_block) {
		tlock-&gt;lf_next = to;
	}

	TAILQ_CONCAT(&amp;to-&gt;lf_blkhd, &amp;from-&gt;lf_blkhd, lf_block);
}

<span class="enscript-comment">/*
 * lf_coalesce_adjacent
 *
 * Description:	Helper function: when setting a lock, coalesce adjacent
 *		locks.  Needed because adjacent locks are not overlapping,
 *		but POSIX requires that they be coalesced.
 *
 * Parameters:	lock			The new lock which may be adjacent
 *					to already locked regions, and which
 *					should therefore be coalesced with them
 *
 * Returns:	&lt;void&gt;
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">lf_coalesce_adjacent</span>(<span class="enscript-type">struct</span> lockf *lock)
{
	<span class="enscript-type">struct</span> lockf **lf = lock-&gt;lf_head;

	<span class="enscript-keyword">while</span> (*lf != NOLOCKF) {
		<span class="enscript-comment">/* reject locks that obviously could not be coalesced */</span>
		<span class="enscript-keyword">if</span> ((*lf == lock) ||
		    ((*lf)-&gt;lf_id != lock-&gt;lf_id) ||
		    ((*lf)-&gt;lf_type != lock-&gt;lf_type)) {
			lf = &amp;(*lf)-&gt;lf_next;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/*
		 * NOTE: Assumes that if two locks are adjacent on the number line 
		 * and belong to the same owner, then they are adjacent on the list.
		 */</span>
		<span class="enscript-keyword">if</span> ((*lf)-&gt;lf_end != -1 &amp;&amp;
		    ((*lf)-&gt;lf_end + 1) == lock-&gt;lf_start) {
			<span class="enscript-type">struct</span> lockf *adjacent = *lf;

			LOCKF_DEBUG(LF_DBG_LIST, <span class="enscript-string">&quot;lf_coalesce_adjacent: coalesce adjacent previous\n&quot;</span>);
			lock-&gt;lf_start = (*lf)-&gt;lf_start;
			*lf = lock;
			lf = &amp;(*lf)-&gt;lf_next;

			lf_move_blocked(lock, adjacent);

			FREE(adjacent, M_LOCKF);
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-comment">/* If the lock starts adjacent to us, we can coalesce it */</span>
		<span class="enscript-keyword">if</span> (lock-&gt;lf_end != -1 &amp;&amp;
		    (lock-&gt;lf_end + 1) == (*lf)-&gt;lf_start) {
			<span class="enscript-type">struct</span> lockf *adjacent = *lf;

			LOCKF_DEBUG(LF_DBG_LIST, <span class="enscript-string">&quot;lf_coalesce_adjacent: coalesce adjacent following\n&quot;</span>);
			lock-&gt;lf_end = (*lf)-&gt;lf_end;
			lock-&gt;lf_next = (*lf)-&gt;lf_next;
			lf = &amp;lock-&gt;lf_next;

			lf_move_blocked(lock, adjacent);

			FREE(adjacent, M_LOCKF);
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-comment">/* no matching conditions; go on to next lock */</span>
		lf = &amp;(*lf)-&gt;lf_next;
	}
}

<span class="enscript-comment">/*
 * lf_setlock
 *
 * Description:	Set a byte-range lock.
 *
 * Parameters:	lock			The lock structure describing the lock
 *					to be set; allocated by the caller, it
 *					will be linked into the lock list if
 *					the set is successful, and freed if the
 *					set is unsuccessful.
 *
 *		timeout			Timeout specified in the case of
 * 					SETLKWTIMEOUT.
 *
 * Returns:	0			Success
 *		EAGAIN
 *		EDEADLK
 *	lf_split:ENOLCK
 *	lf_clearlock:ENOLCK
 *	msleep:EINTR
 *	msleep:ETIMEDOUT
 *
 * Notes:	We add the lock to the provisional lock list.  We do not
 *		coalesce at this time; this has implications for other lock
 *		requestors in the blocker search mechanism.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">lf_setlock</span>(<span class="enscript-type">struct</span> lockf *lock, <span class="enscript-type">struct</span> timespec *timeout)
{
	<span class="enscript-type">struct</span> lockf *block;
	<span class="enscript-type">struct</span> lockf **head = lock-&gt;lf_head;
	<span class="enscript-type">struct</span> lockf **prev, *overlap, *ltmp;
	<span class="enscript-type">static</span> <span class="enscript-type">char</span> lockstr[] = <span class="enscript-string">&quot;lockf&quot;</span>;
	<span class="enscript-type">int</span> priority, needtolink, error;
	<span class="enscript-type">struct</span> vnode *vp = lock-&gt;lf_vnode;
	overlap_t ovcase;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCKF_DEBUGGING</span>
	<span class="enscript-keyword">if</span> (lockf_debug &amp; LF_DBG_LOCKOP) {
		lf_print(<span class="enscript-string">&quot;lf_setlock&quot;</span>, lock);
		lf_printlist(<span class="enscript-string">&quot;lf_setlock(in)&quot;</span>, lock);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LOCKF_DEBUGGING */</span>

	<span class="enscript-comment">/*
	 * Set the priority
	 */</span>
	priority = PLOCK;
	<span class="enscript-keyword">if</span> (lock-&gt;lf_type == F_WRLCK)
		priority += 4;
	priority |= PCATCH;
	<span class="enscript-comment">/*
	 * Scan lock list for this file looking for locks that would block us.
	 */</span>
	<span class="enscript-keyword">while</span> ((block = lf_getblock(lock, -1))) {
		<span class="enscript-comment">/*
		 * Free the structure and return if nonblocking.
		 */</span>
		<span class="enscript-keyword">if</span> ((lock-&gt;lf_flags &amp; F_WAIT) == 0) {
			DTRACE_FSINFO(advlock__nowait, vnode_t, vp);
			FREE(lock, M_LOCKF);
			<span class="enscript-keyword">return</span> (EAGAIN);
		}

		<span class="enscript-comment">/*
		 * We are blocked. Since flock style locks cover
		 * the whole file, there is no chance for deadlock.
		 *
		 * OFD byte-range locks currently do NOT support
		 * deadlock detection.
		 *
		 * For POSIX byte-range locks we must check for deadlock.
		 *
		 * Deadlock detection is done by looking through the
		 * wait channels to see if there are any cycles that
		 * involve us. MAXDEPTH is set just to make sure we
		 * do not go off into neverland.
		 */</span>
		<span class="enscript-keyword">if</span> ((lock-&gt;lf_flags &amp; F_POSIX) &amp;&amp;
		    (block-&gt;lf_flags &amp; F_POSIX)) {
			<span class="enscript-type">struct</span> proc *wproc, *bproc;
			<span class="enscript-type">struct</span> uthread *ut;
			<span class="enscript-type">struct</span> lockf *waitblock;
			<span class="enscript-type">int</span> i = 0;

			<span class="enscript-comment">/* The block is waiting on something */</span>
			wproc = block-&gt;lf_owner;
			proc_lock(wproc);
			TAILQ_FOREACH(ut, &amp;wproc-&gt;p_uthlist, uu_list) {
				<span class="enscript-comment">/*
				 * While the thread is asleep (uu_wchan != 0)
				 * in this code (uu_wmesg == lockstr)
				 * and we have not exceeded the maximum cycle
				 * depth (i &lt; maxlockdepth), then check for a
				 * cycle to see if the lock is blocked behind
				 * someone blocked behind us.
				 */</span>
				<span class="enscript-keyword">while</span> (((waitblock = (<span class="enscript-type">struct</span> lockf *)ut-&gt;uu_wchan) != NULL) &amp;&amp;
				    ut-&gt;uu_wmesg == lockstr &amp;&amp;
				    (i++ &lt; maxlockdepth)) {
					waitblock = (<span class="enscript-type">struct</span> lockf *)ut-&gt;uu_wchan;
					<span class="enscript-comment">/*
					 * Get the lock blocking the lock
					 * which would block us, and make
					 * certain it hasn't come unblocked
					 * (been granted, e.g. between the time
					 * we called lf_getblock, and the time
					 * we successfully acquired the
					 * proc_lock).
					 */</span>
					waitblock = waitblock-&gt;lf_next;
					<span class="enscript-keyword">if</span> (waitblock == NULL)
						<span class="enscript-keyword">break</span>;

					<span class="enscript-comment">/*
					 * Make sure it's an advisory range
					 * lock and not any other kind of lock;
					 * if we mix lock types, it's our own
					 * fault.
					 */</span>
					<span class="enscript-keyword">if</span> ((waitblock-&gt;lf_flags &amp; F_POSIX) == 0)
						<span class="enscript-keyword">break</span>;

					<span class="enscript-comment">/*
					 * If the owner of the lock that's
					 * blocking a lock that's blocking us
					 * getting the requested lock, then we
					 * would deadlock, so error out.
					 */</span>
					bproc = waitblock-&gt;lf_owner;
					<span class="enscript-keyword">if</span> (bproc == lock-&gt;lf_owner) {
						proc_unlock(wproc);
						FREE(lock, M_LOCKF);
						<span class="enscript-keyword">return</span> (EDEADLK);
					}
				}
			}
			proc_unlock(wproc);
		}

		<span class="enscript-comment">/*
		 * For flock type locks, we must first remove
		 * any shared locks that we hold before we sleep
		 * waiting for an exclusive lock.
		 */</span>
		<span class="enscript-keyword">if</span> ((lock-&gt;lf_flags &amp; F_FLOCK) &amp;&amp;
		    lock-&gt;lf_type == F_WRLCK) {
			lock-&gt;lf_type = F_UNLCK;
			<span class="enscript-keyword">if</span> ((error = lf_clearlock(lock)) != 0) {
				FREE(lock, M_LOCKF);
				<span class="enscript-keyword">return</span> (error);
			}
			lock-&gt;lf_type = F_WRLCK;
		}
		<span class="enscript-comment">/*
		 * Add our lock to the blocked list and sleep until we're free.
		 * Remember who blocked us (for deadlock detection).
		 */</span>
		lock-&gt;lf_next = block;
		TAILQ_INSERT_TAIL(&amp;block-&gt;lf_blkhd, lock, lf_block);

		<span class="enscript-keyword">if</span> ( !(lock-&gt;lf_flags &amp; F_FLOCK))
		        block-&gt;lf_flags &amp;= ~F_WAKE1_SAFE;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
		<span class="enscript-comment">/*
		 * Importance donation is done only for cases where the
		 * owning task can be unambiguously determined.
		 *
		 * POSIX type locks are not inherited by child processes;
		 * we maintain a 1:1 mapping between a lock and its owning
		 * process.
		 *
		 * Flock type locks are inherited across fork() and there is
		 * no 1:1 mapping in the general case.  However, the fileglobs
		 * used by OFD locks *may* be confined to the process that
		 * created them, and thus have an &quot;owner&quot;, in which case
		 * we also attempt importance donation.
		 */</span>
		<span class="enscript-keyword">if</span> ((lock-&gt;lf_flags &amp; block-&gt;lf_flags &amp; F_POSIX) != 0)
			lf_boost_blocking_proc(lock, block);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((lock-&gt;lf_flags &amp; block-&gt;lf_flags &amp; F_OFD_LOCK) &amp;&amp;
		    lock-&gt;lf_owner != block-&gt;lf_owner &amp;&amp;
		    NULL != lock-&gt;lf_owner &amp;&amp; NULL != block-&gt;lf_owner)
			lf_boost_blocking_proc(lock, block);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCKF_DEBUGGING</span>
		<span class="enscript-keyword">if</span> (lockf_debug &amp; LF_DBG_LOCKOP) {
			lf_print(<span class="enscript-string">&quot;lf_setlock: blocking on&quot;</span>, block);
			lf_printlist(<span class="enscript-string">&quot;lf_setlock(block)&quot;</span>, block);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LOCKF_DEBUGGING */</span>
		DTRACE_FSINFO(advlock__wait, vnode_t, vp);

		error = msleep(lock, &amp;vp-&gt;v_lock, priority, lockstr, timeout);

		<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; (lock-&gt;lf_flags &amp; F_ABORT) != 0)
			error = EBADF;

		<span class="enscript-keyword">if</span> (lock-&gt;lf_next) {
			<span class="enscript-comment">/*
			 * lf_wakelock() always sets wakelock-&gt;lf_next to
			 * NULL before a wakeup; so we've been woken early
			 * - perhaps by a debugger, signal or other event.
			 *
			 * Remove 'lock' from the block list (avoids double-add
			 * in the spurious case, which would create a cycle)
			 */</span>
			TAILQ_REMOVE(&amp;lock-&gt;lf_next-&gt;lf_blkhd, lock, lf_block);
			lock-&gt;lf_next = NULL;

			<span class="enscript-keyword">if</span> (error == 0) {
				<span class="enscript-comment">/*
				 * If this was a spurious wakeup, retry
				 */</span>
				printf(<span class="enscript-string">&quot;%s: spurious wakeup, retrying lock\n&quot;</span>,
				    __func__);
				<span class="enscript-keyword">continue</span>;
			}
		}

		<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;lock-&gt;lf_blkhd)) {
		        <span class="enscript-keyword">if</span> ((block = lf_getblock(lock, -1)) != NULL)
				lf_move_blocked(block, lock);
		}

		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;lock-&gt;lf_blkhd))
			        lf_wakelock(lock, TRUE);
			FREE(lock, M_LOCKF);
			<span class="enscript-comment">/* Return ETIMEDOUT if timeout occoured. */</span>
			<span class="enscript-keyword">if</span> (error == EWOULDBLOCK) {
				error = ETIMEDOUT;
			}
			<span class="enscript-keyword">return</span> (error);
		}
	}

	<span class="enscript-comment">/*
	 * No blocks!!  Add the lock.  Note that we will
	 * downgrade or upgrade any overlapping locks this
	 * process already owns.
	 *
	 * Skip over locks owned by other processes.
	 * Handle any locks that overlap and are owned by ourselves.
	 */</span>
	prev = head;
	block = *head;
	needtolink = 1;
	<span class="enscript-keyword">for</span> (;;) {
		ovcase = lf_findoverlap(block, lock, SELF, &amp;prev, &amp;overlap);
		<span class="enscript-keyword">if</span> (ovcase)
			block = overlap-&gt;lf_next;
		<span class="enscript-comment">/*
		 * Six cases:
		 *	0) no overlap
		 *	1) overlap == lock
		 *	2) overlap contains lock
		 *	3) lock contains overlap
		 *	4) overlap starts before lock
		 *	5) overlap ends after lock
		 */</span>
		<span class="enscript-keyword">switch</span> (ovcase) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OVERLAP_NONE</span>:
			<span class="enscript-keyword">if</span> (needtolink) {
				*prev = lock;
				lock-&gt;lf_next = overlap;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">OVERLAP_EQUALS_LOCK</span>:
			<span class="enscript-comment">/*
			 * If downgrading lock, others may be
			 * able to acquire it.
			 */</span>
			<span class="enscript-keyword">if</span> (lock-&gt;lf_type == F_RDLCK &amp;&amp;
			    overlap-&gt;lf_type == F_WRLCK)
			        lf_wakelock(overlap, TRUE);
			overlap-&gt;lf_type = lock-&gt;lf_type;
			FREE(lock, M_LOCKF);
			lock = overlap; <span class="enscript-comment">/* for lf_coalesce_adjacent() */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">OVERLAP_CONTAINS_LOCK</span>:
			<span class="enscript-comment">/*
			 * Check for common starting point and different types.
			 */</span>
			<span class="enscript-keyword">if</span> (overlap-&gt;lf_type == lock-&gt;lf_type) {
				FREE(lock, M_LOCKF);
				lock = overlap; <span class="enscript-comment">/* for lf_coalesce_adjacent() */</span>
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">if</span> (overlap-&gt;lf_start == lock-&gt;lf_start) {
				*prev = lock;
				lock-&gt;lf_next = overlap;
				overlap-&gt;lf_start = lock-&gt;lf_end + 1;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/*
				 * If we can't split the lock, we can't
				 * grant it.  Claim a system limit for the
				 * resource shortage.
				 */</span>
				<span class="enscript-keyword">if</span> (lf_split(overlap, lock)) {
					FREE(lock, M_LOCKF);
					<span class="enscript-keyword">return</span> (ENOLCK);
				}
			}
			lf_wakelock(overlap, TRUE);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">OVERLAP_CONTAINED_BY_LOCK</span>:
			<span class="enscript-comment">/*
			 * If downgrading lock, others may be able to
			 * acquire it, otherwise take the list.
			 */</span>
			<span class="enscript-keyword">if</span> (lock-&gt;lf_type == F_RDLCK &amp;&amp;
			    overlap-&gt;lf_type == F_WRLCK) {
			        lf_wakelock(overlap, TRUE);
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">while</span> (!TAILQ_EMPTY(&amp;overlap-&gt;lf_blkhd)) {
					ltmp = TAILQ_FIRST(&amp;overlap-&gt;lf_blkhd);
					TAILQ_REMOVE(&amp;overlap-&gt;lf_blkhd, ltmp,
					    lf_block);
					TAILQ_INSERT_TAIL(&amp;lock-&gt;lf_blkhd,
					    ltmp, lf_block);
					ltmp-&gt;lf_next = lock;
				}
			}
			<span class="enscript-comment">/*
			 * Add the new lock if necessary and delete the overlap.
			 */</span>
			<span class="enscript-keyword">if</span> (needtolink) {
				*prev = lock;
				lock-&gt;lf_next = overlap-&gt;lf_next;
				prev = &amp;lock-&gt;lf_next;
				needtolink = 0;
			} <span class="enscript-keyword">else</span>
				*prev = overlap-&gt;lf_next;
			FREE(overlap, M_LOCKF);
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">OVERLAP_STARTS_BEFORE_LOCK</span>:
			<span class="enscript-comment">/*
			 * Add lock after overlap on the list.
			 */</span>
			lock-&gt;lf_next = overlap-&gt;lf_next;
			overlap-&gt;lf_next = lock;
			overlap-&gt;lf_end = lock-&gt;lf_start - 1;
			prev = &amp;lock-&gt;lf_next;
			lf_wakelock(overlap, TRUE);
			needtolink = 0;
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">OVERLAP_ENDS_AFTER_LOCK</span>:
			<span class="enscript-comment">/*
			 * Add the new lock before overlap.
			 */</span>
			<span class="enscript-keyword">if</span> (needtolink) {
				*prev = lock;
				lock-&gt;lf_next = overlap;
			}
			overlap-&gt;lf_start = lock-&gt;lf_end + 1;
			lf_wakelock(overlap, TRUE);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-comment">/* Coalesce adjacent locks with identical attributes */</span>
	lf_coalesce_adjacent(lock);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCKF_DEBUGGING</span>
	<span class="enscript-keyword">if</span> (lockf_debug &amp; LF_DBG_LOCKOP) {
		lf_print(<span class="enscript-string">&quot;lf_setlock: got the lock&quot;</span>, lock);
		lf_printlist(<span class="enscript-string">&quot;lf_setlock(out)&quot;</span>, lock);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LOCKF_DEBUGGING */</span>
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * lf_clearlock
 *
 * Description:	Remove a byte-range lock on an vnode.  Generally, find the
 *		lock (or an overlap to that lock) and remove it (or shrink
 *		it), then wakeup anyone we can.
 *
 * Parameters:	unlock			The lock to clear
 *
 * Returns:	0			Success
 *	lf_split:ENOLCK
 *
 * Notes:	A caller may unlock all the locks owned by the caller by
 *		specifying the entire file range; locks owned by other
 *		callers are not effected by this operation.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">lf_clearlock</span>(<span class="enscript-type">struct</span> lockf *unlock)
{
	<span class="enscript-type">struct</span> lockf **head = unlock-&gt;lf_head;
	<span class="enscript-type">struct</span> lockf *lf = *head;
	<span class="enscript-type">struct</span> lockf *overlap, **prev;
	overlap_t ovcase;

	<span class="enscript-keyword">if</span> (lf == NOLOCKF)
		<span class="enscript-keyword">return</span> (0);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCKF_DEBUGGING</span>
	<span class="enscript-keyword">if</span> (unlock-&gt;lf_type != F_UNLCK)
		panic(<span class="enscript-string">&quot;lf_clearlock: bad type&quot;</span>);
	<span class="enscript-keyword">if</span> (lockf_debug &amp; LF_DBG_LOCKOP)
		lf_print(<span class="enscript-string">&quot;lf_clearlock&quot;</span>, unlock);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LOCKF_DEBUGGING */</span>
	prev = head;
	<span class="enscript-keyword">while</span> ((ovcase = lf_findoverlap(lf, unlock, SELF, &amp;prev, &amp;overlap)) != OVERLAP_NONE) {
		<span class="enscript-comment">/*
		 * Wakeup the list of locks to be retried.
		 */</span>
	        lf_wakelock(overlap, FALSE);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>
		<span class="enscript-keyword">if</span> (overlap-&gt;lf_boosted == LF_BOOSTED) {
			lf_drop_assertion(overlap);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>

		<span class="enscript-keyword">switch</span> (ovcase) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">OVERLAP_NONE</span>:	<span class="enscript-comment">/* satisfy compiler enum/switch */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">OVERLAP_EQUALS_LOCK</span>:
			*prev = overlap-&gt;lf_next;
			FREE(overlap, M_LOCKF);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">OVERLAP_CONTAINS_LOCK</span>: <span class="enscript-comment">/* split it */</span>
			<span class="enscript-keyword">if</span> (overlap-&gt;lf_start == unlock-&gt;lf_start) {
				overlap-&gt;lf_start = unlock-&gt;lf_end + 1;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/*
			 * If we can't split the lock, we can't grant it.
			 * Claim a system limit for the resource shortage.
			 */</span>
			<span class="enscript-keyword">if</span> (lf_split(overlap, unlock))
				<span class="enscript-keyword">return</span> (ENOLCK);
			overlap-&gt;lf_next = unlock-&gt;lf_next;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">OVERLAP_CONTAINED_BY_LOCK</span>:
			*prev = overlap-&gt;lf_next;
			lf = overlap-&gt;lf_next;
			FREE(overlap, M_LOCKF);
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">OVERLAP_STARTS_BEFORE_LOCK</span>:
			overlap-&gt;lf_end = unlock-&gt;lf_start - 1;
			prev = &amp;overlap-&gt;lf_next;
			lf = overlap-&gt;lf_next;
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">OVERLAP_ENDS_AFTER_LOCK</span>:
			overlap-&gt;lf_start = unlock-&gt;lf_end + 1;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">break</span>;
	}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCKF_DEBUGGING</span>
	<span class="enscript-keyword">if</span> (lockf_debug &amp; LF_DBG_LOCKOP)
		lf_printlist(<span class="enscript-string">&quot;lf_clearlock&quot;</span>, unlock);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LOCKF_DEBUGGING */</span>
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * lf_getlock
 *
 * Description:	Check whether there is a blocking lock, and if so return
 *		its process identifier into the lock being requested.
 *
 * Parameters:	lock			Pointer to lock to test for blocks
 *		fl			Pointer to flock structure to receive
 *					the blocking lock information, if a
 *					blocking lock is found.
 *		matchpid		-1, or pid value to match in lookup.
 *
 * Returns:	0			Success
 *
 * Implicit Returns:
 *		*fl			Contents modified to reflect the
 *					blocking lock, if one is found; not
 *					modified otherwise
 *
 * Notes:	fl-&gt;l_pid will be (-1) for file locks and will only be set to
 *		the blocking process ID for advisory record locks.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">lf_getlock</span>(<span class="enscript-type">struct</span> lockf *lock, <span class="enscript-type">struct</span> flock *fl, pid_t matchpid)
{
	<span class="enscript-type">struct</span> lockf *block;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCKF_DEBUGGING</span>
	<span class="enscript-keyword">if</span> (lockf_debug &amp; LF_DBG_LOCKOP)
		lf_print(<span class="enscript-string">&quot;lf_getlock&quot;</span>, lock);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LOCKF_DEBUGGING */</span>

	<span class="enscript-keyword">if</span> ((block = lf_getblock(lock, matchpid))) {
		fl-&gt;l_type = block-&gt;lf_type;
		fl-&gt;l_whence = SEEK_SET;
		fl-&gt;l_start = block-&gt;lf_start;
		<span class="enscript-keyword">if</span> (block-&gt;lf_end == -1)
			fl-&gt;l_len = 0;
		<span class="enscript-keyword">else</span>
			fl-&gt;l_len = block-&gt;lf_end - block-&gt;lf_start + 1;
		<span class="enscript-keyword">if</span> (NULL != block-&gt;lf_owner) {
			<span class="enscript-comment">/*
			 * lf_owner is only non-NULL when the lock
			 * &quot;owner&quot; can be unambiguously determined
			 */</span>
			fl-&gt;l_pid = proc_pid(block-&gt;lf_owner);
		} <span class="enscript-keyword">else</span>
			fl-&gt;l_pid = -1;
	} <span class="enscript-keyword">else</span> {
		fl-&gt;l_type = F_UNLCK;
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * lf_getblock
 *
 * Description:	Walk the list of locks for an inode and return the first
 *		blocking lock.  A lock is considered blocking if we are not
 *		the lock owner; otherwise, we are permitted to upgrade or
 *		downgrade it, and it's not considered blocking.
 *
 * Parameters:	lock			The lock for which we are interested
 *					in obtaining the blocking lock, if any
 *		matchpid		-1, or pid value to match in lookup.
 *
 * Returns:	NOLOCKF			No blocking lock exists
 *		!NOLOCKF		The address of the blocking lock's
 *					struct lockf.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> lockf *
<span class="enscript-function-name">lf_getblock</span>(<span class="enscript-type">struct</span> lockf *lock, pid_t matchpid)
{
	<span class="enscript-type">struct</span> lockf **prev, *overlap, *lf = *(lock-&gt;lf_head);

	<span class="enscript-keyword">for</span> (prev = lock-&gt;lf_head;
	    lf_findoverlap(lf, lock, OTHERS, &amp;prev, &amp;overlap) != OVERLAP_NONE;
	    lf = overlap-&gt;lf_next) {
		<span class="enscript-comment">/*
		 * Found an overlap.
		 *
		 * If we're matching pids, and it's a record lock,
		 * or it's an OFD lock on a process-confined fd,
		 * but the pid doesn't match, then keep on looking ..
		 */</span>
		<span class="enscript-keyword">if</span> (matchpid != -1 &amp;&amp;
		    (overlap-&gt;lf_flags &amp; (F_POSIX|F_OFD_LOCK)) != 0 &amp;&amp;
		    proc_pid(overlap-&gt;lf_owner) != matchpid)
			<span class="enscript-keyword">continue</span>;

		<span class="enscript-comment">/*
		 * does it block us?
		 */</span>
		<span class="enscript-keyword">if</span> ((lock-&gt;lf_type == F_WRLCK || overlap-&gt;lf_type == F_WRLCK))
			<span class="enscript-keyword">return</span> (overlap);
	}
	<span class="enscript-keyword">return</span> (NOLOCKF);
}


<span class="enscript-comment">/*
 * lf_findoverlap
 *
 * Description:	Walk the list of locks to find an overlapping lock (if any).
 *
 * Parameters:	lf			First lock on lock list
 *		lock			The lock we are checking for an overlap
 *		check			Check type
 *		prev			pointer to pointer pointer to contain
 *					address of pointer to previous lock
 *					pointer to overlapping lock, if overlap
 *		overlap			pointer to pointer to contain address
 *					of overlapping lock
 *
 * Returns:	OVERLAP_NONE
 *		OVERLAP_EQUALS_LOCK
 *		OVERLAP_CONTAINS_LOCK
 *		OVERLAP_CONTAINED_BY_LOCK
 *		OVERLAP_STARTS_BEFORE_LOCK
 *		OVERLAP_ENDS_AFTER_LOCK
 *
 * Implicit Returns:
 *		*prev			The address of the next pointer in the
 *					lock previous to the overlapping lock;
 *					this is generally used to relink the
 *					lock list, avoiding a second iteration.
 *		*overlap		The pointer to the overlapping lock
 *					itself; this is used to return data in
 *					the check == OTHERS case, and for the
 *					caller to modify the overlapping lock,
 *					in the check == SELF case
 *
 * Note:	This returns only the FIRST overlapping lock.  There may be
 *		more than one.  lf_getlock will return the first blocking lock,
 *		while lf_setlock will iterate over all overlapping locks to
 *
 *		The check parameter can be SELF, meaning we are looking for
 *		overlapping locks owned by us, or it can be OTHERS, meaning
 *		we are looking for overlapping locks owned by someone else so
 *		we can report a blocking lock on an F_GETLK request.
 *
 *		The value of *overlap and *prev are modified, even if there is
 *		no overlapping lock found; always check the return code.
 */</span>
<span class="enscript-type">static</span> overlap_t
<span class="enscript-function-name">lf_findoverlap</span>(<span class="enscript-type">struct</span> lockf *lf, <span class="enscript-type">struct</span> lockf *lock, <span class="enscript-type">int</span> type,
	       <span class="enscript-type">struct</span> lockf ***prev, <span class="enscript-type">struct</span> lockf **overlap)
{
	off_t start, end;
	<span class="enscript-type">int</span> found_self = 0;

	*overlap = lf;
	<span class="enscript-keyword">if</span> (lf == NOLOCKF)
		<span class="enscript-keyword">return</span> (0);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCKF_DEBUGGING</span>
	<span class="enscript-keyword">if</span> (lockf_debug &amp; LF_DBG_LIST)
		lf_print(<span class="enscript-string">&quot;lf_findoverlap: looking for overlap in&quot;</span>, lock);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LOCKF_DEBUGGING */</span>
	start = lock-&gt;lf_start;
	end = lock-&gt;lf_end;
	<span class="enscript-keyword">while</span> (lf != NOLOCKF) {
		<span class="enscript-keyword">if</span> (((type &amp; SELF) &amp;&amp; lf-&gt;lf_id != lock-&gt;lf_id) ||
		    ((type &amp; OTHERS) &amp;&amp; lf-&gt;lf_id == lock-&gt;lf_id)) {
			<span class="enscript-comment">/* 
			 * Locks belonging to one process are adjacent on the
			 * list, so if we've found any locks belonging to us,
			 * and we're now seeing something else, then we've
			 * examined all &quot;self&quot; locks.  Note that bailing out
			 * here is quite important; for coalescing, we assume 
			 * numerically adjacent locks from the same owner to 
			 * be adjacent on the list.
			 */</span>
			<span class="enscript-keyword">if</span> ((type &amp; SELF) &amp;&amp; found_self) {
				<span class="enscript-keyword">return</span> OVERLAP_NONE;
			}

			*prev = &amp;lf-&gt;lf_next;
			*overlap = lf = lf-&gt;lf_next;
			<span class="enscript-keyword">continue</span>;
		}

		<span class="enscript-keyword">if</span> ((type &amp; SELF)) {
			found_self = 1;
		}

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCKF_DEBUGGING</span>
		<span class="enscript-keyword">if</span> (lockf_debug &amp; LF_DBG_LIST)
			lf_print(<span class="enscript-string">&quot;\tchecking&quot;</span>, lf);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LOCKF_DEBUGGING */</span>
		<span class="enscript-comment">/*
		 * OK, check for overlap
		 */</span>
		<span class="enscript-keyword">if</span> ((lf-&gt;lf_end != -1 &amp;&amp; start &gt; lf-&gt;lf_end) ||
		    (end != -1 &amp;&amp; lf-&gt;lf_start &gt; end)) {
			<span class="enscript-comment">/* Case 0 */</span>
			LOCKF_DEBUG(LF_DBG_LIST, <span class="enscript-string">&quot;no overlap\n&quot;</span>);

			<span class="enscript-comment">/*
			 * NOTE: assumes that locks for the same process are 
			 * nonintersecting and ordered.
			 */</span>
			<span class="enscript-keyword">if</span> ((type &amp; SELF) &amp;&amp; end != -1 &amp;&amp; lf-&gt;lf_start &gt; end)
				<span class="enscript-keyword">return</span> (OVERLAP_NONE);
			*prev = &amp;lf-&gt;lf_next;
			*overlap = lf = lf-&gt;lf_next;
			<span class="enscript-keyword">continue</span>;
		}
		<span class="enscript-keyword">if</span> ((lf-&gt;lf_start == start) &amp;&amp; (lf-&gt;lf_end == end)) {
			LOCKF_DEBUG(LF_DBG_LIST, <span class="enscript-string">&quot;overlap == lock\n&quot;</span>);
			<span class="enscript-keyword">return</span> (OVERLAP_EQUALS_LOCK);
		}
		<span class="enscript-keyword">if</span> ((lf-&gt;lf_start &lt;= start) &amp;&amp;
		    (end != -1) &amp;&amp;
		    ((lf-&gt;lf_end &gt;= end) || (lf-&gt;lf_end == -1))) {
			LOCKF_DEBUG(LF_DBG_LIST, <span class="enscript-string">&quot;overlap contains lock\n&quot;</span>);
			<span class="enscript-keyword">return</span> (OVERLAP_CONTAINS_LOCK);
		}
		<span class="enscript-keyword">if</span> (start &lt;= lf-&gt;lf_start &amp;&amp;
		           (end == -1 ||
			   (lf-&gt;lf_end != -1 &amp;&amp; end &gt;= lf-&gt;lf_end))) {
			LOCKF_DEBUG(LF_DBG_LIST, <span class="enscript-string">&quot;lock contains overlap\n&quot;</span>);
			<span class="enscript-keyword">return</span> (OVERLAP_CONTAINED_BY_LOCK);
		}
		<span class="enscript-keyword">if</span> ((lf-&gt;lf_start &lt; start) &amp;&amp;
			((lf-&gt;lf_end &gt;= start) || (lf-&gt;lf_end == -1))) {
			LOCKF_DEBUG(LF_DBG_LIST, <span class="enscript-string">&quot;overlap starts before lock\n&quot;</span>);
			<span class="enscript-keyword">return</span> (OVERLAP_STARTS_BEFORE_LOCK);
		}
		<span class="enscript-keyword">if</span> ((lf-&gt;lf_start &gt; start) &amp;&amp;
			(end != -1) &amp;&amp;
			((lf-&gt;lf_end &gt; end) || (lf-&gt;lf_end == -1))) {
			LOCKF_DEBUG(LF_DBG_LIST, <span class="enscript-string">&quot;overlap ends after lock\n&quot;</span>);
			<span class="enscript-keyword">return</span> (OVERLAP_ENDS_AFTER_LOCK);
		}
		panic(<span class="enscript-string">&quot;lf_findoverlap: default&quot;</span>);
	}
	<span class="enscript-keyword">return</span> (OVERLAP_NONE);
}


<span class="enscript-comment">/*
 * lf_split
 *
 * Description:	Split a lock and a contained region into two or three locks
 *		as necessary.
 *
 * Parameters:	lock1			Lock to split
 *		lock2			Overlapping lock region requiring the
 *					split (upgrade/downgrade/unlock)
 *
 * Returns:	0			Success
 *		ENOLCK			No memory for new lock
 *
 * Implicit Returns:
 *		*lock1			Modified original lock
 *		*lock2			Overlapping lock (inserted into list)
 *		(new lock)		Potential new lock inserted into list
 *					if split results in 3 locks
 *
 * Notes:	This operation can only fail if the split would result in three
 *		locks, and there is insufficient memory to allocate the third
 *		lock; in that case, neither of the locks will be modified.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">lf_split</span>(<span class="enscript-type">struct</span> lockf *lock1, <span class="enscript-type">struct</span> lockf *lock2)
{
	<span class="enscript-type">struct</span> lockf *splitlock;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCKF_DEBUGGING</span>
	<span class="enscript-keyword">if</span> (lockf_debug &amp; LF_DBG_LIST) {
		lf_print(<span class="enscript-string">&quot;lf_split&quot;</span>, lock1);
		lf_print(<span class="enscript-string">&quot;splitting from&quot;</span>, lock2);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LOCKF_DEBUGGING */</span>
	<span class="enscript-comment">/*
	 * Check to see if splitting into only two pieces.
	 */</span>
	<span class="enscript-keyword">if</span> (lock1-&gt;lf_start == lock2-&gt;lf_start) {
		lock1-&gt;lf_start = lock2-&gt;lf_end + 1;
		lock2-&gt;lf_next = lock1;
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-keyword">if</span> (lock1-&gt;lf_end == lock2-&gt;lf_end) {
		lock1-&gt;lf_end = lock2-&gt;lf_start - 1;
		lock2-&gt;lf_next = lock1-&gt;lf_next;
		lock1-&gt;lf_next = lock2;
		<span class="enscript-keyword">return</span> (0);
	}
	<span class="enscript-comment">/*
	 * Make a new lock consisting of the last part of
	 * the encompassing lock
	 */</span>
	MALLOC(splitlock, <span class="enscript-type">struct</span> lockf *, <span class="enscript-keyword">sizeof</span> *splitlock, M_LOCKF, M_WAITOK);
	<span class="enscript-keyword">if</span> (splitlock == NULL)
		<span class="enscript-keyword">return</span> (ENOLCK);
	bcopy(lock1, splitlock, <span class="enscript-keyword">sizeof</span> *splitlock);
	splitlock-&gt;lf_start = lock2-&gt;lf_end + 1;
	TAILQ_INIT(&amp;splitlock-&gt;lf_blkhd);
	lock1-&gt;lf_end = lock2-&gt;lf_start - 1;
	<span class="enscript-comment">/*
	 * OK, now link it in
	 */</span>
	splitlock-&gt;lf_next = lock1-&gt;lf_next;
	lock2-&gt;lf_next = splitlock;
	lock1-&gt;lf_next = lock2;

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * lf_wakelock
 *
 * Wakeup a blocklist in the case of a downgrade or unlock, since others
 * waiting on the lock may now be able to acquire it.
 *
 * Parameters:	listhead		Lock list head on which waiters may
 *					have pending locks
 *
 * Returns:	&lt;void&gt;
 *
 * Notes:	This function iterates a list of locks and wakes all waiters,
 *		rather than only waiters for the contended regions.  Because
 *		of this, for heavily contended files, this can result in a
 *		&quot;thundering herd&quot; situation.  Refactoring the code could make
 *		this operation more efficient, if heavy contention ever results
 *		in a real-world performance problem.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">lf_wakelock</span>(<span class="enscript-type">struct</span> lockf *listhead, boolean_t force_all)
{
	<span class="enscript-type">struct</span> lockf *wakelock;
	boolean_t wake_all = TRUE;

	<span class="enscript-keyword">if</span> (force_all == FALSE &amp;&amp; (listhead-&gt;lf_flags &amp; F_WAKE1_SAFE))
	        wake_all = FALSE;

	<span class="enscript-keyword">while</span> (!TAILQ_EMPTY(&amp;listhead-&gt;lf_blkhd)) {
		wakelock = TAILQ_FIRST(&amp;listhead-&gt;lf_blkhd);
		TAILQ_REMOVE(&amp;listhead-&gt;lf_blkhd, wakelock, lf_block);

		wakelock-&gt;lf_next = NOLOCKF;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCKF_DEBUGGING</span>
		<span class="enscript-keyword">if</span> (lockf_debug &amp; LF_DBG_LOCKOP)
			lf_print(<span class="enscript-string">&quot;lf_wakelock: awakening&quot;</span>, wakelock);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LOCKF_DEBUGGING */</span>
		<span class="enscript-keyword">if</span> (wake_all == FALSE) {
			<span class="enscript-comment">/*
			 * If there are items on the list head block list,
			 * move them to the wakelock list instead, and then
			 * correct their lf_next pointers.
			 */</span>
			<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;listhead-&gt;lf_blkhd)) {
				TAILQ_CONCAT(&amp;wakelock-&gt;lf_blkhd, &amp;listhead-&gt;lf_blkhd, lf_block);

			        <span class="enscript-type">struct</span> lockf *tlock;

			        TAILQ_FOREACH(tlock, &amp;wakelock-&gt;lf_blkhd, lf_block) {
					<span class="enscript-keyword">if</span> (TAILQ_NEXT(tlock, lf_block) == tlock) {
						<span class="enscript-comment">/* See rdar://10887303 */</span>
						panic(<span class="enscript-string">&quot;cycle in wakelock list&quot;</span>);
					}
				        tlock-&gt;lf_next = wakelock;
				}
			}
		}
		wakeup(wakelock);

		<span class="enscript-keyword">if</span> (wake_all == FALSE)
		        <span class="enscript-keyword">break</span>;
	}
}


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">LOCKF_DEBUGGING</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">GET_LF_OWNER_PID</span>(lf)	(proc_pid((lf)-&gt;lf_owner))

<span class="enscript-comment">/*
 * lf_print DEBUG
 *
 * Print out a lock; lock information is prefixed by the string in 'tag'
 *
 * Parameters:	tag			A string tag for debugging
 *		lock			The lock whose information should be
 *					displayed
 *
 * Returns:	&lt;void&gt;
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lf_print</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *tag, <span class="enscript-type">struct</span> lockf *lock)
{
	printf(<span class="enscript-string">&quot;%s: lock %p for &quot;</span>, tag, (<span class="enscript-type">void</span> *)lock);
	<span class="enscript-keyword">if</span> (lock-&gt;lf_flags &amp; F_POSIX)
		printf(<span class="enscript-string">&quot;proc %p (owner %d)&quot;</span>,
		    lock-&gt;lf_id, GET_LF_OWNER_PID(lock));
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lock-&gt;lf_flags &amp; F_OFD_LOCK)
		printf(<span class="enscript-string">&quot;fg %p (owner %d)&quot;</span>,
		    lock-&gt;lf_id, GET_LF_OWNER_PID(lock));
	<span class="enscript-keyword">else</span>
		printf(<span class="enscript-string">&quot;id %p&quot;</span>, (<span class="enscript-type">void</span> *)lock-&gt;lf_id);
	<span class="enscript-keyword">if</span> (lock-&gt;lf_vnode != 0)
		printf(<span class="enscript-string">&quot; in vno %p, %s, start 0x%016llx, end 0x%016llx&quot;</span>,
		    lock-&gt;lf_vnode,
		    lock-&gt;lf_type == F_RDLCK ? <span class="enscript-string">&quot;shared&quot;</span> :
		    lock-&gt;lf_type == F_WRLCK ? <span class="enscript-string">&quot;exclusive&quot;</span> :
		    lock-&gt;lf_type == F_UNLCK ? <span class="enscript-string">&quot;unlock&quot;</span> : <span class="enscript-string">&quot;unknown&quot;</span>,
		    (intmax_t)lock-&gt;lf_start, (intmax_t)lock-&gt;lf_end);
	<span class="enscript-keyword">else</span>
		printf(<span class="enscript-string">&quot; %s, start 0x%016llx, end 0x%016llx&quot;</span>,
		    lock-&gt;lf_type == F_RDLCK ? <span class="enscript-string">&quot;shared&quot;</span> :
		    lock-&gt;lf_type == F_WRLCK ? <span class="enscript-string">&quot;exclusive&quot;</span> :
		    lock-&gt;lf_type == F_UNLCK ? <span class="enscript-string">&quot;unlock&quot;</span> : <span class="enscript-string">&quot;unknown&quot;</span>,
		    (intmax_t)lock-&gt;lf_start, (intmax_t)lock-&gt;lf_end);
	<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;lock-&gt;lf_blkhd))
		printf(<span class="enscript-string">&quot; block %p\n&quot;</span>, (<span class="enscript-type">void</span> *)TAILQ_FIRST(&amp;lock-&gt;lf_blkhd));
	<span class="enscript-keyword">else</span>
		printf(<span class="enscript-string">&quot;\n&quot;</span>);
}


<span class="enscript-comment">/*
 * lf_printlist DEBUG
 *
 * Print out a lock list for the vnode associated with 'lock'; lock information
 * is prefixed by the string in 'tag'
 *
 * Parameters:	tag			A string tag for debugging
 *		lock			The lock whose vnode's lock list should
 *					be displayed
 *
 * Returns:	&lt;void&gt;
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">lf_printlist</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *tag, <span class="enscript-type">struct</span> lockf *lock)
{
	<span class="enscript-type">struct</span> lockf *lf, *blk;

	<span class="enscript-keyword">if</span> (lock-&gt;lf_vnode == 0)
		<span class="enscript-keyword">return</span>;

	printf(<span class="enscript-string">&quot;%s: Lock list for vno %p:\n&quot;</span>,
	    tag, lock-&gt;lf_vnode);
	<span class="enscript-keyword">for</span> (lf = lock-&gt;lf_vnode-&gt;v_lockf; lf; lf = lf-&gt;lf_next) {
		printf(<span class="enscript-string">&quot;\tlock %p for &quot;</span>,(<span class="enscript-type">void</span> *)lf);
		<span class="enscript-keyword">if</span> (lf-&gt;lf_flags &amp; F_POSIX)
			printf(<span class="enscript-string">&quot;proc %p (owner %d)&quot;</span>,
			    lf-&gt;lf_id, GET_LF_OWNER_PID(lf));
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (lf-&gt;lf_flags &amp; F_OFD_LOCK)
			printf(<span class="enscript-string">&quot;fg %p (owner %d)&quot;</span>,
			    lf-&gt;lf_id, GET_LF_OWNER_PID(lf));
		<span class="enscript-keyword">else</span>
			printf(<span class="enscript-string">&quot;id %p&quot;</span>, (<span class="enscript-type">void</span> *)lf-&gt;lf_id);
		printf(<span class="enscript-string">&quot;, %s, start 0x%016llx, end 0x%016llx&quot;</span>,
		    lf-&gt;lf_type == F_RDLCK ? <span class="enscript-string">&quot;shared&quot;</span> :
		    lf-&gt;lf_type == F_WRLCK ? <span class="enscript-string">&quot;exclusive&quot;</span> :
		    lf-&gt;lf_type == F_UNLCK ? <span class="enscript-string">&quot;unlock&quot;</span> :
		    <span class="enscript-string">&quot;unknown&quot;</span>, (intmax_t)lf-&gt;lf_start, (intmax_t)lf-&gt;lf_end);
		TAILQ_FOREACH(blk, &amp;lf-&gt;lf_blkhd, lf_block) {
			printf(<span class="enscript-string">&quot;\n\t\tlock request %p for &quot;</span>, (<span class="enscript-type">void</span> *)blk);
			<span class="enscript-keyword">if</span> (blk-&gt;lf_flags &amp; F_POSIX)
				printf(<span class="enscript-string">&quot;proc %p (owner %d)&quot;</span>,
				    blk-&gt;lf_id, GET_LF_OWNER_PID(blk));
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (blk-&gt;lf_flags &amp; F_OFD_LOCK)
				printf(<span class="enscript-string">&quot;fg %p (owner %d)&quot;</span>,
				    blk-&gt;lf_id, GET_LF_OWNER_PID(blk));
			<span class="enscript-keyword">else</span>
				printf(<span class="enscript-string">&quot;id %p&quot;</span>, (<span class="enscript-type">void</span> *)blk-&gt;lf_id);
			printf(<span class="enscript-string">&quot;, %s, start 0x%016llx, end 0x%016llx&quot;</span>,
			    blk-&gt;lf_type == F_RDLCK ? <span class="enscript-string">&quot;shared&quot;</span> :
			    blk-&gt;lf_type == F_WRLCK ? <span class="enscript-string">&quot;exclusive&quot;</span> :
			    blk-&gt;lf_type == F_UNLCK ? <span class="enscript-string">&quot;unlock&quot;</span> :
			    <span class="enscript-string">&quot;unknown&quot;</span>, (intmax_t)blk-&gt;lf_start,
			    (intmax_t)blk-&gt;lf_end);
			<span class="enscript-keyword">if</span> (!TAILQ_EMPTY(&amp;blk-&gt;lf_blkhd))
				panic(<span class="enscript-string">&quot;lf_printlist: bad list&quot;</span>);
		}
		printf(<span class="enscript-string">&quot;\n&quot;</span>);
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* LOCKF_DEBUGGING */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">IMPORTANCE_INHERITANCE</span>

<span class="enscript-comment">/*
 * lf_hold_assertion
 *
 * Call task importance hold assertion on the owner of the lock.
 *
 * Parameters: block_task               Owner of the lock blocking 
 *                                      current thread.
 *
 *             block                    lock on which the current thread 
 *                                      is blocking on.
 *
 * Returns:    &lt;void&gt;
 *
 * Notes: The task reference on block_task is not needed to be hold since 
 *        the current thread has vnode lock and block_task has a file 
 *        lock, thus removing file lock in exit requires block_task to 
 *        grab the vnode lock.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">lf_hold_assertion</span>(task_t block_task, <span class="enscript-type">struct</span> lockf *block)
{
	<span class="enscript-keyword">if</span> (task_importance_hold_file_lock_assertion(block_task, 1)) {
		block-&gt;lf_boosted = LF_BOOSTED;
		LOCKF_DEBUG(LF_DBG_IMPINH,
		    <span class="enscript-string">&quot;lf: importance hold file lock assert on pid %d lock %p\n&quot;</span>,
		    proc_pid(block-&gt;lf_owner), block);
	}
}


<span class="enscript-comment">/*
 * lf_jump_to_queue_head
 *
 * Jump the lock from the tail of the block queue to the head of
 * the queue.
 *
 * Parameters: block                    lockf struct containing the 
 *                                      block queue.
 *             lock                     lockf struct to be jumped to the
 *                                      front.
 *
 * Returns:    &lt;void&gt;
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">lf_jump_to_queue_head</span>(<span class="enscript-type">struct</span> lockf *block, <span class="enscript-type">struct</span> lockf *lock) 
{
	<span class="enscript-comment">/* Move the lock to the head of the block queue. */</span>
	TAILQ_REMOVE(&amp;block-&gt;lf_blkhd, lock, lf_block);
	TAILQ_INSERT_HEAD(&amp;block-&gt;lf_blkhd, lock, lf_block);
}


<span class="enscript-comment">/*
 * lf_drop_assertion
 *
 * Drops the task hold assertion.
 *
 * Parameters: block                    lockf struct holding the assertion.
 *
 * Returns:    &lt;void&gt;
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">lf_drop_assertion</span>(<span class="enscript-type">struct</span> lockf *block)
{
	LOCKF_DEBUG(LF_DBG_IMPINH, <span class="enscript-string">&quot;lf: %d: dropping assertion for lock %p\n&quot;</span>,
	    proc_pid(block-&gt;lf_owner), block);

	task_t current_task = proc_task(block-&gt;lf_owner);
	task_importance_drop_file_lock_assertion(current_task, 1);
	block-&gt;lf_boosted = LF_NOT_BOOSTED;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">lf_boost_blocking_proc</span>(<span class="enscript-type">struct</span> lockf *lock, <span class="enscript-type">struct</span> lockf *block)
{
	task_t ltask = proc_task(lock-&gt;lf_owner);
	task_t btask = proc_task(block-&gt;lf_owner);

	<span class="enscript-comment">/*
	 * Check if ltask can donate importance. The
	 * check of imp_donor bit is done without holding
	 * any lock. The value may change after you read it,
	 * but it is ok to boost a task while someone else is
	 * unboosting you.
	 *
	 * TODO: Support live inheritance on file locks.
	 */</span>
	<span class="enscript-keyword">if</span> (task_is_importance_donor(ltask)) {
		LOCKF_DEBUG(LF_DBG_IMPINH,
		    <span class="enscript-string">&quot;lf: %d: attempt to boost pid %d that holds lock %p\n&quot;</span>,
		    proc_pid(lock-&gt;lf_owner), proc_pid(block-&gt;lf_owner), block);

		<span class="enscript-keyword">if</span> (block-&gt;lf_boosted != LF_BOOSTED &amp;&amp;
		    task_is_importance_receiver_type(btask)) {
			lf_hold_assertion(btask, block);
		}
		lf_jump_to_queue_head(block, lock);
	}
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* IMPORTANCE_INHERITANCE */</span>
</pre>
<hr />
</body></html>