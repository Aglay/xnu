<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>sys_socket.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">sys_socket.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)sys_socket.c	8.1 (Berkeley) 6/10/93
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filio.h&gt;</span>			<span class="enscript-comment">/* XXX */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sockio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * File operations on sockets.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">soo_read</span>(<span class="enscript-type">struct</span> fileproc *, <span class="enscript-type">struct</span> uio *, <span class="enscript-type">int</span>, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">soo_write</span>(<span class="enscript-type">struct</span> fileproc *, <span class="enscript-type">struct</span> uio *, <span class="enscript-type">int</span>, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">soo_close</span>(<span class="enscript-type">struct</span> fileglob *, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">soo_drain</span>(<span class="enscript-type">struct</span> fileproc *, vfs_context_t ctx);

<span class="enscript-type">const</span> <span class="enscript-type">struct</span> fileops socketops = {
	DTYPE_SOCKET,
	soo_read,
	soo_write,
	soo_ioctl,
	soo_select,
	soo_close,
	soo_kqfilter,
	soo_drain
};

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">soo_read</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio, __unused <span class="enscript-type">int</span> flags,
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
	__unused
#<span class="enscript-reference">endif</span>
	vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">int</span> stat;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
	<span class="enscript-type">int</span> error;
#<span class="enscript-reference">endif</span>

	<span class="enscript-type">int</span> (*fsoreceive)(<span class="enscript-type">struct</span> socket *so2, <span class="enscript-type">struct</span> sockaddr **paddr,
	    <span class="enscript-type">struct</span> uio *uio2, <span class="enscript-type">struct</span> mbuf **mp0, <span class="enscript-type">struct</span> mbuf **controlp,
	    <span class="enscript-type">int</span> *flagsp);

	<span class="enscript-keyword">if</span> ((so = (<span class="enscript-type">struct</span> socket *)fp-&gt;f_fglob-&gt;fg_data) == NULL) {
		<span class="enscript-comment">/* This is not a valid open file descriptor */</span>
		<span class="enscript-keyword">return</span> (EBADF);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
	error = mac_socket_check_receive(vfs_context_ucred(ctx), so);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_SOCKET */</span>

	fsoreceive = so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_soreceive;

	stat = (*fsoreceive)(so, 0, uio, 0, 0, 0);
	<span class="enscript-keyword">return</span> (stat);
}

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">soo_write</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio, __unused <span class="enscript-type">int</span> flags,
	vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">int</span> stat;
	<span class="enscript-type">int</span> (*fsosend)(<span class="enscript-type">struct</span> socket *so2, <span class="enscript-type">struct</span> sockaddr *addr,
	    <span class="enscript-type">struct</span> uio *uio2, <span class="enscript-type">struct</span> mbuf *top, <span class="enscript-type">struct</span> mbuf *control,
	    <span class="enscript-type">int</span> flags2);
	proc_t procp;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
	<span class="enscript-type">int</span> error;
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> ((so = (<span class="enscript-type">struct</span> socket *)fp-&gt;f_fglob-&gt;fg_data) == NULL) {
		<span class="enscript-comment">/* This is not a valid open file descriptor */</span>
		<span class="enscript-keyword">return</span> (EBADF);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
	<span class="enscript-comment">/* JMM - have to fetch the socket's remote addr */</span>
	error = mac_socket_check_send(vfs_context_ucred(ctx), so, NULL);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_SOCKET */</span>

	fsosend = so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_sosend;

	stat = (*fsosend)(so, 0, uio, 0, 0, 0);

	<span class="enscript-comment">/* Generation of SIGPIPE can be controlled per socket */</span>
	procp = vfs_context_proc(ctx);
	<span class="enscript-keyword">if</span> (stat == EPIPE &amp;&amp; !(so-&gt;so_flags &amp; SOF_NOSIGPIPE))
		psignal(procp, SIGPIPE);

	<span class="enscript-keyword">return</span> (stat);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">soioctl</span>(<span class="enscript-type">struct</span> socket *so, u_long cmd, caddr_t data, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> int_arg;

	socket_lock(so, 1);

	<span class="enscript-comment">/* call the socket filter's ioctl handler anything but ours */</span>
	<span class="enscript-keyword">if</span> (IOCGROUP(cmd) != <span class="enscript-string">'i'</span> &amp;&amp; IOCGROUP(cmd) != <span class="enscript-string">'r'</span>) {
		<span class="enscript-keyword">switch</span> (cmd) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGASSOCIDS32</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGASSOCIDS64</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNIDS32</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNIDS64</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNINFO32</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNINFO64</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSCONNORDER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNORDER</span>:
			<span class="enscript-comment">/* don't pass to filter */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = sflt_ioctl(so, cmd, data);
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-keyword">switch</span> (cmd) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIONBIO</span>:			<span class="enscript-comment">/* int */</span>
		bcopy(data, &amp;int_arg, <span class="enscript-keyword">sizeof</span> (int_arg));
		<span class="enscript-keyword">if</span> (int_arg)
			so-&gt;so_state |= SS_NBIO;
		<span class="enscript-keyword">else</span>
			so-&gt;so_state &amp;= ~SS_NBIO;

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIOASYNC</span>:			<span class="enscript-comment">/* int */</span>
		bcopy(data, &amp;int_arg, <span class="enscript-keyword">sizeof</span> (int_arg));
		<span class="enscript-keyword">if</span> (int_arg) {
			so-&gt;so_state |= SS_ASYNC;
			so-&gt;so_rcv.sb_flags |= SB_ASYNC;
			so-&gt;so_snd.sb_flags |= SB_ASYNC;
		} <span class="enscript-keyword">else</span> {
			so-&gt;so_state &amp;= ~SS_ASYNC;
			so-&gt;so_rcv.sb_flags &amp;= ~SB_ASYNC;
			so-&gt;so_snd.sb_flags &amp;= ~SB_ASYNC;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIONREAD</span>:			<span class="enscript-comment">/* int */</span>
		bcopy(&amp;so-&gt;so_rcv.sb_cc, data, <span class="enscript-keyword">sizeof</span> (u_int32_t));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSPGRP</span>:			<span class="enscript-comment">/* int */</span>
		bcopy(data, &amp;so-&gt;so_pgid, <span class="enscript-keyword">sizeof</span> (pid_t));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGPGRP</span>:			<span class="enscript-comment">/* int */</span>
		bcopy(&amp;so-&gt;so_pgid, data, <span class="enscript-keyword">sizeof</span> (pid_t));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCATMARK</span>:		<span class="enscript-comment">/* int */</span>
		int_arg = (so-&gt;so_state &amp; SS_RCVATMARK) != 0;
		bcopy(&amp;int_arg, data, <span class="enscript-keyword">sizeof</span> (int_arg));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSETOT</span>:			<span class="enscript-comment">/* int; deprecated */</span>
		error = EOPNOTSUPP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGASSOCIDS32</span>:		<span class="enscript-comment">/* so_aidreq32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGASSOCIDS64</span>:		<span class="enscript-comment">/* so_aidreq64 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNIDS32</span>:		<span class="enscript-comment">/* so_cidreq32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNIDS64</span>:		<span class="enscript-comment">/* so_cidreq64 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNINFO32</span>:		<span class="enscript-comment">/* so_cinforeq32 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNINFO64</span>:		<span class="enscript-comment">/* so_cinforeq64 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSCONNORDER</span>:		<span class="enscript-comment">/* so_cordreq */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNORDER</span>:		<span class="enscript-comment">/* so_cordreq */</span>
		error = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_control)(so,
		    cmd, data, NULL, p);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Interface/routing/protocol specific ioctls:
	 * interface and routing ioctls should have a
	 * different entry since a socket's unnecessary
	 */</span>
	<span class="enscript-keyword">if</span> (IOCGROUP(cmd) == <span class="enscript-string">'i'</span>) {
		error = ifioctllocked(so, cmd, data, p);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (IOCGROUP(cmd) == <span class="enscript-string">'r'</span>)
			error = rtioctl(cmd, data, p);
		<span class="enscript-keyword">else</span>
			error = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_control)(so,
			    cmd, data, NULL, p);
	}

<span class="enscript-reference">out</span>:
	socket_unlock(so, 1);

	<span class="enscript-keyword">if</span> (error == EJUSTRETURN)
		error = 0;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">soo_ioctl</span>(<span class="enscript-type">struct</span> fileproc *fp, u_long cmd, caddr_t data, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> socket *so;
	proc_t procp = vfs_context_proc(ctx);

	<span class="enscript-keyword">if</span> ((so = (<span class="enscript-type">struct</span> socket *)fp-&gt;f_fglob-&gt;fg_data) == NULL) {
		<span class="enscript-comment">/* This is not a valid open file descriptor */</span>
		<span class="enscript-keyword">return</span> (EBADF);
	}

	<span class="enscript-keyword">return</span> (soioctl(so, cmd, data, procp));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">soo_select</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">int</span> which, <span class="enscript-type">void</span> *wql, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> socket *so = (<span class="enscript-type">struct</span> socket *)fp-&gt;f_fglob-&gt;fg_data;
	<span class="enscript-type">int</span> retnum = 0;
	proc_t procp;

	<span class="enscript-keyword">if</span> (so == NULL || so == (<span class="enscript-type">struct</span> socket *)-1)
		<span class="enscript-keyword">return</span> (0);

	procp = vfs_context_proc(ctx);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
	<span class="enscript-keyword">if</span> (mac_socket_check_select(vfs_context_ucred(ctx), so, which) != 0)
		<span class="enscript-keyword">return</span> (0);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_SOCKET */</span>


	socket_lock(so, 1);
	<span class="enscript-keyword">switch</span> (which) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FREAD</span>:
		so-&gt;so_rcv.sb_flags |= SB_SEL;
		<span class="enscript-keyword">if</span> (soreadable(so)) {
			retnum = 1;
			so-&gt;so_rcv.sb_flags &amp;= ~SB_SEL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		selrecord(procp, &amp;so-&gt;so_rcv.sb_sel, wql);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FWRITE</span>:
		so-&gt;so_snd.sb_flags |= SB_SEL;
		<span class="enscript-keyword">if</span> (sowriteable(so)) {
			retnum = 1;
			so-&gt;so_snd.sb_flags &amp;= ~SB_SEL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		selrecord(procp, &amp;so-&gt;so_snd.sb_sel, wql);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
		so-&gt;so_rcv.sb_flags |= SB_SEL;
		<span class="enscript-keyword">if</span> (so-&gt;so_oobmark || (so-&gt;so_state &amp; SS_RCVATMARK)) {
			retnum = 1;
			so-&gt;so_rcv.sb_flags &amp;= ~SB_SEL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		selrecord(procp, &amp;so-&gt;so_rcv.sb_sel, wql);
		<span class="enscript-keyword">break</span>;
	}

<span class="enscript-reference">done</span>:
	socket_unlock(so, 1);
	<span class="enscript-keyword">return</span> (retnum);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">soo_stat</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">void</span> *ub, <span class="enscript-type">int</span> isstat64)
{
	<span class="enscript-type">int</span> ret;
	<span class="enscript-comment">/* warning avoidance ; protected by isstat64 */</span>
	<span class="enscript-type">struct</span> stat *sb = (<span class="enscript-type">struct</span> stat *)0;
	<span class="enscript-comment">/* warning avoidance ; protected by isstat64 */</span>
	<span class="enscript-type">struct</span> stat64 *sb64 = (<span class="enscript-type">struct</span> stat64 *)0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
	ret = mac_socket_check_stat(kauth_cred_get(), so);
	<span class="enscript-keyword">if</span> (ret)
		<span class="enscript-keyword">return</span> (ret);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (isstat64 != 0) {
		sb64 = (<span class="enscript-type">struct</span> stat64 *)ub;
		bzero((caddr_t)sb64, <span class="enscript-keyword">sizeof</span> (*sb64));
	} <span class="enscript-keyword">else</span> {
		sb = (<span class="enscript-type">struct</span> stat *)ub;
		bzero((caddr_t)sb, <span class="enscript-keyword">sizeof</span> (*sb));
	}

	socket_lock(so, 1);
	<span class="enscript-keyword">if</span> (isstat64 != 0) {
		sb64-&gt;st_mode = S_IFSOCK;
		<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_CANTRCVMORE) == 0 ||
		    so-&gt;so_rcv.sb_cc != 0)
			sb64-&gt;st_mode |= S_IRUSR | S_IRGRP | S_IROTH;
		<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_CANTSENDMORE) == 0)
			sb64-&gt;st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;
		sb64-&gt;st_size = so-&gt;so_rcv.sb_cc - so-&gt;so_rcv.sb_ctl;
		sb64-&gt;st_uid = kauth_cred_getuid(so-&gt;so_cred);
		sb64-&gt;st_gid = kauth_cred_getgid(so-&gt;so_cred);
	} <span class="enscript-keyword">else</span> {
		sb-&gt;st_mode = S_IFSOCK;
		<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_CANTRCVMORE) == 0 ||
		    so-&gt;so_rcv.sb_cc != 0)
			sb-&gt;st_mode |= S_IRUSR | S_IRGRP | S_IROTH;
		<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_CANTSENDMORE) == 0)
			sb-&gt;st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;
		sb-&gt;st_size = so-&gt;so_rcv.sb_cc - so-&gt;so_rcv.sb_ctl;
		sb-&gt;st_uid = kauth_cred_getuid(so-&gt;so_cred);
		sb-&gt;st_gid = kauth_cred_getgid(so-&gt;so_cred);
	}

	ret = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_sense)(so, ub, isstat64);
	socket_unlock(so, 1);
	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">soo_close</span>(<span class="enscript-type">struct</span> fileglob *fg, __unused vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> socket *sp;

	sp = (<span class="enscript-type">struct</span> socket *)fg-&gt;fg_data;
	fg-&gt;fg_data = NULL;

	<span class="enscript-keyword">if</span> (sp)
		error = soclose(sp);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">soo_drain</span>(<span class="enscript-type">struct</span> fileproc *fp, __unused vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> socket *so = (<span class="enscript-type">struct</span> socket *)fp-&gt;f_fglob-&gt;fg_data;

	<span class="enscript-keyword">if</span> (so) {
		socket_lock(so, 1);
		so-&gt;so_state |= SS_DRAINING;

		wakeup((caddr_t)&amp;so-&gt;so_timeo);
		sorwakeup(so);
		sowwakeup(so);
		soevent(so, SO_FILT_HINT_LOCKED);

		socket_unlock(so, 1);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * 's' group ioctls.
 *
 * The switch statement below does nothing at runtime, as it serves as a
 * compile time check to ensure that all of the socket 's' ioctls (those
 * in the 's' group going thru soo_ioctl) that are made available by the
 * networking stack is unique.  This works as long as this routine gets
 * updated each time a new interface ioctl gets added.
 *
 * Any failures at compile time indicates duplicated ioctl values.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-function-name">__attribute__</span>((unused)) <span class="enscript-type">void</span>
<span class="enscript-function-name">soioctl_cassert</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-comment">/*
	 * This is equivalent to _CASSERT() and the compiler wouldn't
	 * generate any instructions, thus for compile time only.
	 */</span>
	<span class="enscript-keyword">switch</span> ((u_long)0) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:

	<span class="enscript-comment">/* bsd/sys/sockio.h */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSHIWAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGHIWAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSLOWAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGLOWAT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCATMARK</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSPGRP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGPGRP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSETOT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGASSOCIDS32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGASSOCIDS64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNIDS32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNIDS64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNINFO32</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNINFO64</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCSCONNORDER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SIOCGCONNORDER</span>:
		;
	}
}
</pre>
<hr />
</body></html>