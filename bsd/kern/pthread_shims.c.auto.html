<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>pthread_shims.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">pthread_shims.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
 
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PTHREAD_INTERNAL</span> 1

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/affinity.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/thread_act.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/pthread_shims.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>

<span class="enscript-comment">/* version number of the in-kernel shims given to pthread.kext */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PTHREAD_SHIMS_VERSION</span> 1

<span class="enscript-comment">/* on arm, the callbacks function has two #ifdef arm ponters */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PTHREAD_CALLBACK_MEMBER</span> ml_get_max_cpus

<span class="enscript-comment">/* compile time asserts to check the length of structures in pthread_shims.h */</span>
<span class="enscript-type">char</span> pthread_functions_size_compile_assert[(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pthread_functions_s) - offsetof(<span class="enscript-type">struct</span> pthread_functions_s, psynch_rw_yieldwrlock) - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span>*)) == (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span>*) * 100) ? 1 : -1];
<span class="enscript-type">char</span> pthread_callbacks_size_compile_assert[(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pthread_callbacks_s) - offsetof(<span class="enscript-type">struct</span> pthread_callbacks_s, PTHREAD_CALLBACK_MEMBER) - <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span>*)) == (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span>*) * 100) ? 1 : -1];

<span class="enscript-comment">/* old pthread code had definitions for these as they don't exist in headers */</span>
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">mach_port_deallocate</span>(ipc_space_t, mach_port_name_t);
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">semaphore_signal_internal_trap</span>(mach_port_name_t);

#<span class="enscript-reference">define</span> <span class="enscript-function-name">PTHREAD_STRUCT_ACCESSOR</span>(get, set, rettype, structtype, member) \
	<span class="enscript-type">static</span> rettype \
	get(structtype x) { \
		<span class="enscript-keyword">return</span> (x)-&gt;member; \
	} \
	<span class="enscript-type">static</span> <span class="enscript-type">void</span> \
	set(structtype x, rettype y) { \
		(x)-&gt;member = y; \
	}
	
<span class="enscript-function-name">PTHREAD_STRUCT_ACCESSOR</span>(proc_get_threadstart, proc_set_threadstart, user_addr_t, <span class="enscript-type">struct</span> proc*, p_threadstart);
<span class="enscript-function-name">PTHREAD_STRUCT_ACCESSOR</span>(proc_get_pthsize, proc_set_pthsize, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> proc*, p_pthsize);
<span class="enscript-function-name">PTHREAD_STRUCT_ACCESSOR</span>(proc_get_wqthread, proc_set_wqthread, user_addr_t, <span class="enscript-type">struct</span> proc*, p_wqthread);
<span class="enscript-function-name">PTHREAD_STRUCT_ACCESSOR</span>(proc_get_targconc, proc_set_targconc, user_addr_t, <span class="enscript-type">struct</span> proc*, p_targconc);
<span class="enscript-function-name">PTHREAD_STRUCT_ACCESSOR</span>(proc_get_stack_addr_hint, proc_set_stack_addr_hint, user_addr_t, <span class="enscript-type">struct</span> proc *, p_stack_addr_hint);
<span class="enscript-function-name">PTHREAD_STRUCT_ACCESSOR</span>(proc_get_dispatchqueue_offset, proc_set_dispatchqueue_offset, uint64_t, <span class="enscript-type">struct</span> proc*, p_dispatchqueue_offset);
<span class="enscript-function-name">PTHREAD_STRUCT_ACCESSOR</span>(proc_get_dispatchqueue_serialno_offset, proc_set_dispatchqueue_serialno_offset, uint64_t, <span class="enscript-type">struct</span> proc*, p_dispatchqueue_serialno_offset);
<span class="enscript-function-name">PTHREAD_STRUCT_ACCESSOR</span>(proc_get_pthread_tsd_offset, proc_set_pthread_tsd_offset, uint32_t, <span class="enscript-type">struct</span> proc *, p_pth_tsd_offset);
<span class="enscript-function-name">PTHREAD_STRUCT_ACCESSOR</span>(proc_get_wqptr, proc_set_wqptr, <span class="enscript-type">void</span>*, <span class="enscript-type">struct</span> proc*, p_wqptr);
<span class="enscript-function-name">PTHREAD_STRUCT_ACCESSOR</span>(proc_get_wqsize, proc_set_wqsize, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> proc*, p_wqsize);
<span class="enscript-function-name">PTHREAD_STRUCT_ACCESSOR</span>(proc_get_pthhash, proc_set_pthhash, <span class="enscript-type">void</span>*, <span class="enscript-type">struct</span> proc*, p_pthhash);

<span class="enscript-function-name">PTHREAD_STRUCT_ACCESSOR</span>(uthread_get_threadlist, uthread_set_threadlist, <span class="enscript-type">void</span>*, <span class="enscript-type">struct</span> uthread*, uu_threadlist);
<span class="enscript-function-name">PTHREAD_STRUCT_ACCESSOR</span>(uthread_get_sigmask, uthread_set_sigmask, sigset_t, <span class="enscript-type">struct</span> uthread*, uu_sigmask);
<span class="enscript-function-name">PTHREAD_STRUCT_ACCESSOR</span>(uthread_get_returnval, uthread_set_returnval, <span class="enscript-type">int</span>, <span class="enscript-type">struct</span> uthread*, uu_rval[0]);

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pthread_returning_to_userspace</span>(<span class="enscript-type">void</span>)
{
	thread_exception_return();
}

<span class="enscript-type">static</span> uint32_t
<span class="enscript-function-name">get_task_threadmax</span>(<span class="enscript-type">void</span>) {
	<span class="enscript-keyword">return</span> task_threadmax;
}

<span class="enscript-type">static</span> task_t
<span class="enscript-function-name">proc_get_task</span>(<span class="enscript-type">struct</span> proc *p) {
	<span class="enscript-keyword">return</span> p-&gt;task;
}

<span class="enscript-type">static</span> lck_spin_t*
<span class="enscript-function-name">proc_get_wqlockptr</span>(<span class="enscript-type">struct</span> proc *p) {
	<span class="enscript-keyword">return</span> &amp;(p-&gt;p_wqlock);
}

<span class="enscript-type">static</span> boolean_t*
<span class="enscript-function-name">proc_get_wqinitingptr</span>(<span class="enscript-type">struct</span> proc *p) {
	<span class="enscript-keyword">return</span> &amp;(p-&gt;p_wqiniting);
}

<span class="enscript-type">static</span> uint64_t
<span class="enscript-function-name">proc_get_register</span>(<span class="enscript-type">struct</span> proc *p) {
	<span class="enscript-keyword">return</span> (p-&gt;p_lflag &amp; P_LREGISTER);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">proc_set_register</span>(<span class="enscript-type">struct</span> proc *p) {
	proc_setregister(p);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>*
<span class="enscript-function-name">uthread_get_uukwe</span>(<span class="enscript-type">struct</span> uthread *t)
{
	<span class="enscript-keyword">return</span> &amp;t-&gt;uu_kevent.uu_kwe;
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">uthread_is_cancelled</span>(<span class="enscript-type">struct</span> uthread *t)
{
	<span class="enscript-keyword">return</span> (t-&gt;uu_flag &amp; (UT_CANCELDISABLE | UT_CANCEL | UT_CANCELED)) == UT_CANCEL;
}

<span class="enscript-type">static</span> vm_map_t
<span class="enscript-function-name">_current_map</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> current_map();
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">qos_main_thread_active</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">return</span> TRUE;
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">proc_usynch_get_requested_thread_qos</span>(<span class="enscript-type">struct</span> uthread *uth)
{
	task_t		task = current_task();
	thread_t	thread = uth ? uth-&gt;uu_thread : current_thread();
	<span class="enscript-type">int</span>			requested_qos;

	requested_qos = proc_get_task_policy(task, thread, TASK_POLICY_ATTRIBUTE, TASK_POLICY_QOS);

	<span class="enscript-comment">/*
	 * For the purposes of userspace synchronization, it doesn't make sense to place an override of UNSPECIFIED
	 * on another thread, if the current thread doesn't have any QoS set. In these cases, upgrade to
	 * THREAD_QOS_USER_INTERACTIVE.
	 */</span>
	<span class="enscript-keyword">if</span> (requested_qos == THREAD_QOS_UNSPECIFIED) {
		requested_qos = THREAD_QOS_USER_INTERACTIVE;
	}

	<span class="enscript-keyword">return</span> requested_qos;
}

<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">proc_usynch_thread_qos_add_override</span>(<span class="enscript-type">struct</span> uthread *uth, uint64_t tid, <span class="enscript-type">int</span> override_qos, boolean_t first_override_for_resource)
{
	task_t task = current_task();
	thread_t thread = uth ? uth-&gt;uu_thread : THREAD_NULL;
	
	<span class="enscript-keyword">return</span> proc_thread_qos_add_override(task, thread, tid, override_qos, first_override_for_resource, USER_ADDR_NULL, THREAD_QOS_OVERRIDE_TYPE_UNKNOWN);
}

<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">proc_usynch_thread_qos_remove_override</span>(<span class="enscript-type">struct</span> uthread *uth, uint64_t tid)
{
	task_t task = current_task();
	thread_t thread = uth ? uth-&gt;uu_thread : THREAD_NULL;

	<span class="enscript-keyword">return</span> proc_thread_qos_remove_override(task, thread, tid, USER_ADDR_NULL, THREAD_QOS_OVERRIDE_TYPE_UNKNOWN);
}

<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">proc_usynch_thread_qos_add_override_for_resource</span>(task_t task, <span class="enscript-type">struct</span> uthread *uth, uint64_t tid, <span class="enscript-type">int</span> override_qos, boolean_t first_override_for_resource, user_addr_t resource, <span class="enscript-type">int</span> resource_type)
{
	thread_t thread = uth ? uth-&gt;uu_thread : THREAD_NULL;
	
	<span class="enscript-keyword">return</span> proc_thread_qos_add_override(task, thread, tid, override_qos, first_override_for_resource, resource, resource_type);
}

<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">proc_usynch_thread_qos_remove_override_for_resource</span>(task_t task, <span class="enscript-type">struct</span> uthread *uth, uint64_t tid, user_addr_t resource, <span class="enscript-type">int</span> resource_type)
{
	thread_t thread = uth ? uth-&gt;uu_thread : THREAD_NULL;

	<span class="enscript-keyword">return</span> proc_thread_qos_remove_override(task, thread, tid, resource, resource_type);
}

<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">proc_usynch_thread_qos_reset_override_for_resource</span>(task_t task, <span class="enscript-type">struct</span> uthread *uth, uint64_t tid, user_addr_t resource, <span class="enscript-type">int</span> resource_type)
{
	thread_t thread = uth ? uth-&gt;uu_thread : THREAD_NULL;

	<span class="enscript-keyword">return</span> proc_thread_qos_reset_override(task, thread, tid, resource, resource_type);
}

<span class="enscript-comment">/* kernel (core) to kext shims */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">pthread_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (!pthread_functions) {
		panic(<span class="enscript-string">&quot;pthread kernel extension not loaded (function table is NULL).&quot;</span>);
	}
	pthread_functions-&gt;pthread_init();
}

<span class="enscript-type">int</span> 
<span class="enscript-function-name">fill_procworkqueue</span>(proc_t p, <span class="enscript-type">struct</span> proc_workqueueinfo * pwqinfo)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;fill_procworkqueue(p, pwqinfo);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">workqueue_init_lock</span>(proc_t p)
{
	pthread_functions-&gt;workqueue_init_lock(p);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">workqueue_destroy_lock</span>(proc_t p)
{
	pthread_functions-&gt;workqueue_destroy_lock(p);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">workqueue_exit</span>(<span class="enscript-type">struct</span> proc *p)
{
	pthread_functions-&gt;workqueue_exit(p);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">workqueue_mark_exiting</span>(<span class="enscript-type">struct</span> proc *p)
{
	pthread_functions-&gt;workqueue_mark_exiting(p);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">workqueue_thread_yielded</span>(<span class="enscript-type">void</span>)
{
	pthread_functions-&gt;workqueue_thread_yielded();
}

sched_call_t
<span class="enscript-function-name">workqueue_get_sched_callback</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-keyword">if</span> (pthread_functions-&gt;workqueue_get_sched_callback) {
		<span class="enscript-keyword">return</span> pthread_functions-&gt;workqueue_get_sched_callback();
	}
	<span class="enscript-keyword">return</span> NULL;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pth_proc_hashinit</span>(proc_t p)
{
	pthread_functions-&gt;pth_proc_hashinit(p);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">pth_proc_hashdelete</span>(proc_t p)
{
	pthread_functions-&gt;pth_proc_hashdelete(p);
}

<span class="enscript-comment">/* syscall shims */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">bsdthread_create</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> bsdthread_create_args *uap, user_addr_t *retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;bsdthread_create(p, uap-&gt;func, uap-&gt;func_arg, uap-&gt;stack, uap-&gt;pthread, uap-&gt;flags, retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bsdthread_register</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> bsdthread_register_args *uap, __unused int32_t *retval)
{
	<span class="enscript-keyword">if</span> (pthread_functions-&gt;version &gt;= 1) {
		<span class="enscript-keyword">return</span> pthread_functions-&gt;bsdthread_register2(p, uap-&gt;threadstart, uap-&gt;wqthread,
													  uap-&gt;flags, uap-&gt;stack_addr_hint, 
													  uap-&gt;targetconc_ptr, uap-&gt;dispatchqueue_offset,
													  uap-&gt;tsd_offset, retval);		
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> pthread_functions-&gt;bsdthread_register(p, uap-&gt;threadstart, uap-&gt;wqthread,
													 uap-&gt;flags, uap-&gt;stack_addr_hint,
													 uap-&gt;targetconc_ptr, uap-&gt;dispatchqueue_offset,
													 retval);
	}
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bsdthread_terminate</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> bsdthread_terminate_args *uap, int32_t *retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;bsdthread_terminate(p, uap-&gt;stackaddr, uap-&gt;freesize, uap-&gt;port, uap-&gt;sem, retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">bsdthread_ctl</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> bsdthread_ctl_args *uap, <span class="enscript-type">int</span> *retval)
{
    <span class="enscript-keyword">return</span> pthread_functions-&gt;bsdthread_ctl(p, uap-&gt;cmd, uap-&gt;arg1, uap-&gt;arg2, uap-&gt;arg3, retval);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">thread_selfid</span>(<span class="enscript-type">struct</span> proc *p, __unused <span class="enscript-type">struct</span> thread_selfid_args *uap, uint64_t *retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;thread_selfid(p, retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">workq_kernreturn</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> workq_kernreturn_args *uap, int32_t *retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;workq_kernreturn(p, uap-&gt;options, uap-&gt;item, uap-&gt;affinity, uap-&gt;prio, retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">workq_open</span>(<span class="enscript-type">struct</span> proc *p, __unused <span class="enscript-type">struct</span> workq_open_args  *uap, int32_t *retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;workq_open(p, retval);
}

<span class="enscript-comment">/* pthread synchroniser syscalls */</span>

<span class="enscript-type">int</span>
<span class="enscript-function-name">psynch_mutexwait</span>(proc_t p, <span class="enscript-type">struct</span> psynch_mutexwait_args *uap, uint32_t *retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;psynch_mutexwait(p, uap-&gt;mutex, uap-&gt;mgen, uap-&gt;ugen, uap-&gt;tid, uap-&gt;flags, retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">psynch_mutexdrop</span>(proc_t p, <span class="enscript-type">struct</span> psynch_mutexdrop_args *uap, uint32_t *retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;psynch_mutexdrop(p, uap-&gt;mutex, uap-&gt;mgen, uap-&gt;ugen, uap-&gt;tid, uap-&gt;flags, retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">psynch_cvbroad</span>(proc_t p, <span class="enscript-type">struct</span> psynch_cvbroad_args *uap, uint32_t *retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;psynch_cvbroad(p, uap-&gt;cv, uap-&gt;cvlsgen, uap-&gt;cvudgen, uap-&gt;flags, uap-&gt;mutex, uap-&gt;mugen, uap-&gt;tid, retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">psynch_cvsignal</span>(proc_t p, <span class="enscript-type">struct</span> psynch_cvsignal_args *uap, uint32_t *retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;psynch_cvsignal(p, uap-&gt;cv, uap-&gt;cvlsgen, uap-&gt;cvugen, uap-&gt;thread_port, uap-&gt;mutex, uap-&gt;mugen, uap-&gt;tid, uap-&gt;flags, retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">psynch_cvwait</span>(proc_t p, <span class="enscript-type">struct</span> psynch_cvwait_args * uap, uint32_t * retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;psynch_cvwait(p, uap-&gt;cv, uap-&gt;cvlsgen, uap-&gt;cvugen, uap-&gt;mutex, uap-&gt;mugen, uap-&gt;flags, uap-&gt;sec, uap-&gt;nsec, retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">psynch_cvclrprepost</span>(proc_t p, <span class="enscript-type">struct</span> psynch_cvclrprepost_args * uap, <span class="enscript-type">int</span> *retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;psynch_cvclrprepost(p, uap-&gt;cv, uap-&gt;cvgen, uap-&gt;cvugen, uap-&gt;cvsgen, uap-&gt;prepocnt, uap-&gt;preposeq, uap-&gt;flags, retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">psynch_rw_longrdlock</span>(proc_t p, <span class="enscript-type">struct</span> psynch_rw_longrdlock_args * uap,  uint32_t *retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;psynch_rw_longrdlock(p, uap-&gt;rwlock, uap-&gt;lgenval, uap-&gt;ugenval, uap-&gt;rw_wc, uap-&gt;flags, retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">psynch_rw_rdlock</span>(proc_t p, <span class="enscript-type">struct</span> psynch_rw_rdlock_args * uap, uint32_t * retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;psynch_rw_rdlock(p, uap-&gt;rwlock, uap-&gt;lgenval, uap-&gt;ugenval, uap-&gt;rw_wc, uap-&gt;flags, retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">psynch_rw_unlock</span>(proc_t p, <span class="enscript-type">struct</span> psynch_rw_unlock_args *uap, uint32_t *retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;psynch_rw_unlock(p, uap-&gt;rwlock, uap-&gt;lgenval, uap-&gt;ugenval, uap-&gt;rw_wc, uap-&gt;flags, retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">psynch_rw_unlock2</span>(__unused proc_t p, __unused <span class="enscript-type">struct</span> psynch_rw_unlock2_args *uap, __unused uint32_t *retval)
{
	<span class="enscript-keyword">return</span> ENOTSUP;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">psynch_rw_wrlock</span>(proc_t p, <span class="enscript-type">struct</span> psynch_rw_wrlock_args *uap, uint32_t *retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;psynch_rw_wrlock(p, uap-&gt;rwlock, uap-&gt;lgenval, uap-&gt;ugenval, uap-&gt;rw_wc, uap-&gt;flags, retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">psynch_rw_yieldwrlock</span>(proc_t p, <span class="enscript-type">struct</span> psynch_rw_yieldwrlock_args *uap, uint32_t *retval)
{
	<span class="enscript-keyword">return</span> pthread_functions-&gt;psynch_rw_yieldwrlock(p, uap-&gt;rwlock, uap-&gt;lgenval, uap-&gt;ugenval, uap-&gt;rw_wc, uap-&gt;flags, retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">psynch_rw_upgrade</span>(__unused proc_t p, __unused <span class="enscript-type">struct</span> psynch_rw_upgrade_args * uap, __unused uint32_t *retval)
{
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">psynch_rw_downgrade</span>(__unused proc_t p, __unused <span class="enscript-type">struct</span> psynch_rw_downgrade_args * uap, __unused <span class="enscript-type">int</span> *retval)
{
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * The callbacks structure (defined in pthread_shims.h) contains a collection
 * of kernel functions that were not deemed sensible to expose as a KPI to all
 * kernel extensions. So the kext is given them in the form of a structure of
 * function pointers.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pthread_callbacks_s pthread_callbacks = {
	.version = PTHREAD_SHIMS_VERSION,
	.config_thread_max = CONFIG_THREAD_MAX,
	.get_task_threadmax = get_task_threadmax,

	.proc_get_threadstart = proc_get_threadstart,
	.proc_set_threadstart = proc_set_threadstart,
	.proc_get_pthsize = proc_get_pthsize,
	.proc_set_pthsize = proc_set_pthsize,
	.proc_get_wqthread = proc_get_wqthread,
	.proc_set_wqthread = proc_set_wqthread,
	.proc_get_targconc = proc_get_targconc,
	.proc_set_targconc = proc_set_targconc,
	.proc_get_dispatchqueue_offset = proc_get_dispatchqueue_offset,
	.proc_set_dispatchqueue_offset = proc_set_dispatchqueue_offset,
	.proc_get_wqptr = proc_get_wqptr,
	.proc_set_wqptr = proc_set_wqptr,
	.proc_get_wqsize = proc_get_wqsize,
	.proc_set_wqsize = proc_set_wqsize,
	.proc_get_wqlockptr = proc_get_wqlockptr,
	.proc_get_wqinitingptr = proc_get_wqinitingptr,
	.proc_get_pthhash = proc_get_pthhash, 
	.proc_set_pthhash = proc_set_pthhash,
	.proc_get_task = proc_get_task,
	.proc_lock = proc_lock,
	.proc_unlock = proc_unlock,		
	.proc_get_register = proc_get_register,
	.proc_set_register = proc_set_register,

	<span class="enscript-comment">/* kernel IPI interfaces */</span>
	.ipc_port_copyout_send = ipc_port_copyout_send,
	.task_get_ipcspace = get_task_ipcspace,
	.vm_map_page_info = vm_map_page_info,
	.vm_map_switch = vm_map_switch,
	.thread_set_wq_state32 = thread_set_wq_state32,
	.thread_set_wq_state64 = thread_set_wq_state64,

	.uthread_get_threadlist = uthread_get_threadlist,
	.uthread_set_threadlist = uthread_set_threadlist,
	.uthread_get_sigmask = uthread_get_sigmask,
	.uthread_set_sigmask = uthread_set_sigmask,
	.uthread_get_uukwe = uthread_get_uukwe,
	.uthread_get_returnval = uthread_get_returnval,
	.uthread_set_returnval = uthread_set_returnval,
	.uthread_is_cancelled = uthread_is_cancelled,
	
	.thread_exception_return = pthread_returning_to_userspace,
	.thread_bootstrap_return = thread_bootstrap_return,
	.unix_syscall_return = unix_syscall_return,

	.absolutetime_to_microtime = absolutetime_to_microtime,

	.proc_restore_workq_bgthreadpolicy = proc_restore_workq_bgthreadpolicy,
	.proc_apply_workq_bgthreadpolicy = proc_apply_workq_bgthreadpolicy,

	.get_bsdthread_info = (<span class="enscript-type">void</span>*)get_bsdthread_info,
	.thread_sched_call = thread_sched_call,
	.thread_static_param = thread_static_param,
	.thread_create_workq = thread_create_workq,
	.thread_policy_set_internal = thread_policy_set_internal,
	.thread_policy_get = thread_policy_get,
	.thread_set_voucher_name = thread_set_voucher_name,

	.thread_affinity_set = thread_affinity_set,

	.zalloc = zalloc,
	.zfree = zfree,
	.zinit = zinit,

	.__pthread_testcancel = __pthread_testcancel,

	.mach_port_deallocate = mach_port_deallocate,
	.semaphore_signal_internal_trap = semaphore_signal_internal_trap,
	.current_map = _current_map,
	.thread_create = thread_create,
	.thread_resume = thread_resume,
	
	.convert_thread_to_port = convert_thread_to_port,
	.ml_get_max_cpus = (<span class="enscript-type">void</span>*)ml_get_max_cpus,


	.proc_get_dispatchqueue_serialno_offset = proc_get_dispatchqueue_serialno_offset,
	.proc_set_dispatchqueue_serialno_offset = proc_set_dispatchqueue_serialno_offset,

	.proc_get_stack_addr_hint = proc_get_stack_addr_hint,
	.proc_set_stack_addr_hint = proc_set_stack_addr_hint,
	.proc_get_pthread_tsd_offset = proc_get_pthread_tsd_offset,
	.proc_set_pthread_tsd_offset = proc_set_pthread_tsd_offset,

	.thread_set_tsd_base = thread_set_tsd_base,

	.proc_usynch_get_requested_thread_qos = proc_usynch_get_requested_thread_qos,
	.proc_usynch_thread_qos_add_override = proc_usynch_thread_qos_add_override,
	.proc_usynch_thread_qos_remove_override = proc_usynch_thread_qos_remove_override,

	.qos_main_thread_active = qos_main_thread_active,

	.proc_usynch_thread_qos_add_override_for_resource = proc_usynch_thread_qos_add_override_for_resource,
	.proc_usynch_thread_qos_remove_override_for_resource = proc_usynch_thread_qos_remove_override_for_resource,
	.proc_usynch_thread_qos_reset_override_for_resource = proc_usynch_thread_qos_reset_override_for_resource,
};

pthread_callbacks_t pthread_kern = &amp;pthread_callbacks;
pthread_functions_t pthread_functions = NULL;

<span class="enscript-comment">/*
 * pthread_kext_register is called by pthread.kext upon load, it has to provide
 * us with a function pointer table of pthread internal calls. In return, this
 * file provides it with a table of function pointers it needs.
 */</span>

<span class="enscript-type">void</span>
<span class="enscript-function-name">pthread_kext_register</span>(pthread_functions_t fns, pthread_callbacks_t *callbacks)
{
	<span class="enscript-keyword">if</span> (pthread_functions != NULL) {
		panic(<span class="enscript-string">&quot;Re-initialisation of pthread kext callbacks.&quot;</span>);
	}
	
	<span class="enscript-keyword">if</span> (callbacks != NULL) {
		*callbacks = &amp;pthread_callbacks;
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;pthread_kext_register called without callbacks pointer.&quot;</span>);
	}
	
	<span class="enscript-keyword">if</span> (fns) {
		pthread_functions = fns;
	}
}
</pre>
<hr />
</body></html>