<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>sys_pipe.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">sys_pipe.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1996 John S. Dyson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Absolutely no warranty of function or purpose is made by the author
 *    John S. Dyson.
 * 4. Modifications may be freely made to this file if the above conditions
 *    are met.
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

<span class="enscript-comment">/*
 * This file contains a high-performance replacement for the socket-based
 * pipes scheme originally used in FreeBSD/4.4Lite.  It does not support
 * all features of sockets, but does do everything that pipes normally
 * do.
 *
 * Pipes are implemented as circular buffers. Following are the valid states in pipes operations
 *  
 *      _________________________________
 * 1.  |_________________________________| r=w, c=0
 * 
 *      _________________________________
 * 2.  |__r:::::wc_______________________| r &lt;= w , c &gt; 0
 *
 *      _________________________________
 * 3.  |::::wc_____r:::::::::::::::::::::| r&gt;w , c &gt; 0
 *
 *      _________________________________
 * 4.  |:::::::wrc:::::::::::::::::::::::| w=r, c = Max size
 *
 *
 *  Nomenclature:-
 *  a-z define the steps in a program flow
 *  1-4 are the states as defined aboe
 *  Action: is what file operation is done on the pipe
 *  
 *  Current:None  Action: initialize with size M=200
 *  a. State 1 ( r=0, w=0, c=0)
 *  
 *  Current: a    Action: write(100) (w &lt; M)
 *  b. State 2 (r=0, w=100, c=100)
 *  
 *  Current: b    Action: write(100) (w = M-w)
 *  c. State 4 (r=0,w=0,c=200)
 *  
 *  Current: b    Action: read(70)  ( r &lt; c )
 *  d. State 2(r=70,w=100,c=30)
 *  
 *  Current: d	  Action: write(75) ( w &lt; (m-w))
 *  e. State 2 (r=70,w=175,c=105)
 *  
 *  Current: d    Action: write(110) ( w &gt; (m-w))
 *  f. State 3 (r=70,w=10,c=140)
 *  
 *  Current: d	  Action: read(30) (r &gt;= c )
 *  g. State 1 (r=100,w=100,c=0)
 *  
 */</span>

<span class="enscript-comment">/*
 * This code create half duplex pipe buffers for facilitating file like
 * operations on pipes. The initial buffer is very small, but this can
 * dynamically change to larger sizes based on usage. The buffer size is never
 * reduced. The total amount of kernel memory used is governed by maxpipekva.
 * In case of dynamic expansion limit is reached, the output thread is blocked
 * until the pipe buffer empties enough to continue. 
 *
 * In order to limit the resource use of pipes, two sysctls exist:
 *
 * kern.ipc.maxpipekva - This is a hard limit on the amount of pageable
 * address space available to us in pipe_map. 
 *
 * Memory usage may be monitored through the sysctls
 * kern.ipc.pipes, kern.ipc.pipekva.
 *
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/stat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/aio_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/pipe.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysproto.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_info.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_flag</span> f_fglob-&gt;fg_flag
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_msgcount</span> f_fglob-&gt;fg_msgcount
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_cred</span> f_fglob-&gt;fg_cred
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_ops</span> f_fglob-&gt;fg_ops
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_offset</span> f_fglob-&gt;fg_offset
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">f_data</span> f_fglob-&gt;fg_data

<span class="enscript-comment">/*
 * interfaces to the outside world exported through file operations 
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pipe_read</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio,
                <span class="enscript-type">int</span> flags, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pipe_write</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio,
                <span class="enscript-type">int</span> flags, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pipe_close</span>(<span class="enscript-type">struct</span> fileglob *fg, vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pipe_select</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">int</span> which, <span class="enscript-type">void</span> * wql,
		vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pipe_kqfilter</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> knote *kn,
		vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pipe_ioctl</span>(<span class="enscript-type">struct</span> fileproc *fp, u_long cmd, caddr_t data,
		vfs_context_t ctx);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pipe_drain</span>(<span class="enscript-type">struct</span> fileproc *fp,vfs_context_t ctx);

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> fileops pipeops = {
	DTYPE_PIPE,
	pipe_read,
	pipe_write,
	pipe_ioctl,
	pipe_select,
	pipe_close,
	pipe_kqfilter,
	pipe_drain
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	filt_pipedetach(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	filt_piperead(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	filt_pipewrite(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> filterops pipe_rfiltops = {
        .f_isfd = 1,
        .f_detach = filt_pipedetach,
        .f_event = filt_piperead,
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> filterops pipe_wfiltops = {
        .f_isfd = 1,
        .f_detach = filt_pipedetach,
        .f_event = filt_pipewrite,
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> nbigpipe;      <span class="enscript-comment">/* for compatibility sake. no longer used */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> amountpipes;   <span class="enscript-comment">/* total number of pipes in system */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> amountpipekva; <span class="enscript-comment">/* total memory used by pipes */</span>

<span class="enscript-type">int</span> maxpipekva <span class="enscript-function-name">__attribute__</span>((used)) = PIPE_KVAMAX;  <span class="enscript-comment">/* allowing 16MB max. */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PIPE_SYSCTLS</span>
<span class="enscript-function-name">SYSCTL_DECL</span>(_kern_ipc);

<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, maxpipekva, CTLFLAG_RD|CTLFLAG_LOCKED,
	   &amp;maxpipekva, 0, <span class="enscript-string">&quot;Pipe KVA limit&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, maxpipekvawired, CTLFLAG_RW|CTLFLAG_LOCKED,
	   &amp;maxpipekvawired, 0, <span class="enscript-string">&quot;Pipe KVA wired limit&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, pipes, CTLFLAG_RD|CTLFLAG_LOCKED,
	   &amp;amountpipes, 0, <span class="enscript-string">&quot;Current # of pipes&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, bigpipes, CTLFLAG_RD|CTLFLAG_LOCKED,
	   &amp;nbigpipe, 0, <span class="enscript-string">&quot;Current # of big pipes&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, pipekva, CTLFLAG_RD|CTLFLAG_LOCKED,
	   &amp;amountpipekva, 0, <span class="enscript-string">&quot;Pipe KVA usage&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, pipekvawired, CTLFLAG_RD|CTLFLAG_LOCKED,
	   &amp;amountpipekvawired, 0, <span class="enscript-string">&quot;Pipe wired KVA usage&quot;</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pipeclose</span>(<span class="enscript-type">struct</span> pipe *cpipe);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pipe_free_kmem</span>(<span class="enscript-type">struct</span> pipe *cpipe);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pipe_create</span>(<span class="enscript-type">struct</span> pipe **cpipep);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">pipespace</span>(<span class="enscript-type">struct</span> pipe *cpipe, <span class="enscript-type">int</span> size);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">choose_pipespace</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> current, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> expected);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">expand_pipespace</span>(<span class="enscript-type">struct</span> pipe *p, <span class="enscript-type">int</span> target_size);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pipeselwakeup</span>(<span class="enscript-type">struct</span> pipe *cpipe, <span class="enscript-type">struct</span> pipe *spipe);
<span class="enscript-type">static</span> __inline <span class="enscript-type">int</span> <span class="enscript-function-name">pipeio_lock</span>(<span class="enscript-type">struct</span> pipe *cpipe, <span class="enscript-type">int</span> catch);
<span class="enscript-type">static</span> __inline <span class="enscript-type">void</span> <span class="enscript-function-name">pipeio_unlock</span>(<span class="enscript-type">struct</span> pipe *cpipe);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">postpipeevent</span>(<span class="enscript-type">struct</span> pipe *, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">evpipefree</span>(<span class="enscript-type">struct</span> pipe *cpipe);

<span class="enscript-type">static</span> lck_grp_t	*pipe_mtx_grp;
<span class="enscript-type">static</span> lck_attr_t	*pipe_mtx_attr;
<span class="enscript-type">static</span> lck_grp_attr_t	*pipe_mtx_grp_attr;

<span class="enscript-type">static</span> zone_t pipe_zone;

#<span class="enscript-reference">define</span> <span class="enscript-function-name">MAX_PIPESIZE</span>(pipe)  		( MAX(PIPE_SIZE, (pipe)-&gt;pipe_buffer.size) )

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PIPE_GARBAGE_AGE_LIMIT</span>		5000	<span class="enscript-comment">/* In milliseconds */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PIPE_GARBAGE_QUEUE_LIMIT</span>	32000

<span class="enscript-type">struct</span> pipe_garbage {
	<span class="enscript-type">struct</span> pipe		*pg_pipe;
	<span class="enscript-type">struct</span> pipe_garbage	*pg_next;
	uint64_t		pg_timestamp;
};

<span class="enscript-type">static</span> zone_t pipe_garbage_zone;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pipe_garbage *pipe_garbage_head = NULL;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> pipe_garbage *pipe_garbage_tail = NULL;
<span class="enscript-type">static</span> uint64_t pipe_garbage_age_limit = PIPE_GARBAGE_AGE_LIMIT;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> pipe_garbage_count = 0;
<span class="enscript-type">static</span> lck_mtx_t *pipe_garbage_lock;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">pipe_garbage_collect</span>(<span class="enscript-type">struct</span> pipe *cpipe);

<span class="enscript-function-name">SYSINIT</span>(vfs, SI_SUB_VFS, SI_ORDER_ANY, pipeinit, NULL);

<span class="enscript-comment">/* initial setup done at time of sysinit */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">pipeinit</span>(<span class="enscript-type">void</span>)
{
	nbigpipe=0;
	vm_size_t zone_size;
 
	zone_size = 8192 * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pipe);
        pipe_zone = zinit(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pipe), zone_size, 4096, <span class="enscript-string">&quot;pipe zone&quot;</span>);


	<span class="enscript-comment">/* allocate lock group attribute and group for pipe mutexes */</span>
	pipe_mtx_grp_attr = lck_grp_attr_alloc_init();
	pipe_mtx_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;pipe&quot;</span>, pipe_mtx_grp_attr);

	<span class="enscript-comment">/* allocate the lock attribute for pipe mutexes */</span>
	pipe_mtx_attr = lck_attr_alloc_init();

	<span class="enscript-comment">/*
	 * Set up garbage collection for dead pipes
	 */</span>
	zone_size = (PIPE_GARBAGE_QUEUE_LIMIT + 20) *
	    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pipe_garbage);
        pipe_garbage_zone = (zone_t)zinit(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> pipe_garbage),
	    zone_size, 4096, <span class="enscript-string">&quot;pipe garbage zone&quot;</span>);
	pipe_garbage_lock = lck_mtx_alloc_init(pipe_mtx_grp, pipe_mtx_attr);
	
}

<span class="enscript-comment">/* Bitmap for things to touch in pipe_touch() */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PIPE_ATIME</span>	0x00000001	<span class="enscript-comment">/* time of last access */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PIPE_MTIME</span>	0x00000002	<span class="enscript-comment">/* time of last modification */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PIPE_CTIME</span>	0x00000004	<span class="enscript-comment">/* time of last status change */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pipe_touch</span>(<span class="enscript-type">struct</span> pipe *tpipe, <span class="enscript-type">int</span> touch)
{
	<span class="enscript-type">struct</span> timeval now;

	microtime(&amp;now);

	<span class="enscript-keyword">if</span> (touch &amp; PIPE_ATIME) {
		tpipe-&gt;st_atimespec.tv_sec  = now.tv_sec;
		tpipe-&gt;st_atimespec.tv_nsec = now.tv_usec * 1000;
	}

	<span class="enscript-keyword">if</span> (touch &amp; PIPE_MTIME) {
		tpipe-&gt;st_mtimespec.tv_sec  = now.tv_sec;
		tpipe-&gt;st_mtimespec.tv_nsec = now.tv_usec * 1000;
	}

	<span class="enscript-keyword">if</span> (touch &amp; PIPE_CTIME) {
		tpipe-&gt;st_ctimespec.tv_sec  = now.tv_sec;
		tpipe-&gt;st_ctimespec.tv_nsec = now.tv_usec * 1000;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pipesize_blocks[] = {512,1024,2048,4096, 4096 * 2, PIPE_SIZE , PIPE_SIZE * 4 };

<span class="enscript-comment">/* 
 * finds the right size from possible sizes in pipesize_blocks 
 * returns the size which matches max(current,expected) 
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">choose_pipespace</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> current, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> expected)
{
	<span class="enscript-type">int</span> i = <span class="enscript-keyword">sizeof</span>(pipesize_blocks)/<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>) -1;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> target;

	<span class="enscript-comment">/*
	 * assert that we always get an atomic transaction sized pipe buffer,
	 * even if the system pipe buffer high-water mark has been crossed.
	 */</span>
	assert(PIPE_BUF == pipesize_blocks[0]);

	<span class="enscript-keyword">if</span> (expected &gt; current) 
		target = expected;
	<span class="enscript-keyword">else</span>
		target = current;

	<span class="enscript-keyword">while</span> ( i &gt;0 &amp;&amp; pipesize_blocks[i-1] &gt; target) {
		i=i-1;

	}
	
	<span class="enscript-keyword">return</span> pipesize_blocks[i];
}


<span class="enscript-comment">/*
 * expand the size of pipe while there is data to be read,
 * and then free the old buffer once the current buffered
 * data has been transferred to new storage.
 * Required: PIPE_LOCK and io lock to be held by caller.
 * returns 0 on success or no expansion possible
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">expand_pipespace</span>(<span class="enscript-type">struct</span> pipe *p, <span class="enscript-type">int</span> target_size)
{
	<span class="enscript-type">struct</span> pipe tmp, oldpipe;
	<span class="enscript-type">int</span> error;
	tmp.pipe_buffer.buffer = 0;
	
	<span class="enscript-keyword">if</span> (p-&gt;pipe_buffer.size &gt;= (<span class="enscript-type">unsigned</span>) target_size) {
		<span class="enscript-keyword">return</span> 0; <span class="enscript-comment">/* the existing buffer is max size possible */</span>
	}
	
	<span class="enscript-comment">/* create enough space in the target */</span>
	error = pipespace(&amp;tmp, target_size);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">return</span> (error);

	oldpipe.pipe_buffer.buffer = p-&gt;pipe_buffer.buffer;
	oldpipe.pipe_buffer.size = p-&gt;pipe_buffer.size;
	
	memcpy(tmp.pipe_buffer.buffer, p-&gt;pipe_buffer.buffer, p-&gt;pipe_buffer.size);
	<span class="enscript-keyword">if</span> (p-&gt;pipe_buffer.cnt &gt; 0 &amp;&amp; p-&gt;pipe_buffer.in &lt;= p-&gt;pipe_buffer.out ){
		<span class="enscript-comment">/* we are in State 3 and need extra copying for read to be consistent */</span>
		memcpy(&amp;tmp.pipe_buffer.buffer[p-&gt;pipe_buffer.size], p-&gt;pipe_buffer.buffer, p-&gt;pipe_buffer.size);
		p-&gt;pipe_buffer.in += p-&gt;pipe_buffer.size;
	}

	p-&gt;pipe_buffer.buffer = tmp.pipe_buffer.buffer;
	p-&gt;pipe_buffer.size = tmp.pipe_buffer.size;


	pipe_free_kmem(&amp;oldpipe);
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-comment">/*
 * The pipe system call for the DTYPE_PIPE type of pipes
 * 
 * returns:
 *  FREAD  | fd0 | --&gt;[struct rpipe] --&gt; |~~buffer~~| \  
 *                                                    (pipe_mutex)
 *  FWRITE | fd1 | --&gt;[struct wpipe] --X              / 
 */</span>

<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">pipe</span>(proc_t p, __unused <span class="enscript-type">struct</span> pipe_args *uap, int32_t *retval)
{
	<span class="enscript-type">struct</span> fileproc *rf, *wf;
	<span class="enscript-type">struct</span> pipe *rpipe, *wpipe;
	lck_mtx_t   *pmtx;
	<span class="enscript-type">int</span> fd, error;

	<span class="enscript-keyword">if</span> ((pmtx = lck_mtx_alloc_init(pipe_mtx_grp, pipe_mtx_attr)) == NULL)
	        <span class="enscript-keyword">return</span> (ENOMEM);
	
	rpipe = wpipe = NULL;
	<span class="enscript-keyword">if</span> (pipe_create(&amp;rpipe) || pipe_create(&amp;wpipe)) {
	        error = ENFILE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">freepipes</span>;
	}
        <span class="enscript-comment">/*
	 * allocate the space for the normal I/O direction up
	 * front... we'll delay the allocation for the other
	 * direction until a write actually occurs (most likely it won't)...
         */</span>
	error = pipespace(rpipe, choose_pipespace(rpipe-&gt;pipe_buffer.size, 0));
        <span class="enscript-keyword">if</span> (error)
	        <span class="enscript-keyword">goto</span> <span class="enscript-reference">freepipes</span>;

	TAILQ_INIT(&amp;rpipe-&gt;pipe_evlist);
	TAILQ_INIT(&amp;wpipe-&gt;pipe_evlist);

	error = falloc(p, &amp;rf, &amp;fd, vfs_context_current());
	<span class="enscript-keyword">if</span> (error) {
	        <span class="enscript-keyword">goto</span> <span class="enscript-reference">freepipes</span>;
	}
	retval[0] = fd;

	<span class="enscript-comment">/*
	 * for now we'll create half-duplex pipes(refer returns section above). 
	 * this is what we've always supported..
	 */</span>
	rf-&gt;f_flag = FREAD;
	rf-&gt;f_data = (caddr_t)rpipe;
	rf-&gt;f_ops = &amp;pipeops;

	error = falloc(p, &amp;wf, &amp;fd, vfs_context_current());
	<span class="enscript-keyword">if</span> (error) {
		fp_free(p, retval[0], rf);
	        <span class="enscript-keyword">goto</span> <span class="enscript-reference">freepipes</span>;
	}
	wf-&gt;f_flag = FWRITE;
	wf-&gt;f_data = (caddr_t)wpipe;
	wf-&gt;f_ops = &amp;pipeops;

	rpipe-&gt;pipe_peer = wpipe;
	wpipe-&gt;pipe_peer = rpipe;
	<span class="enscript-comment">/* both structures share the same mutex */</span>
	rpipe-&gt;pipe_mtxp = wpipe-&gt;pipe_mtxp = pmtx; 

	retval[1] = fd;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/*
	 * XXXXXXXX SHOULD NOT HOLD FILE_LOCK() XXXXXXXXXXXX
	 *
	 * struct pipe represents a pipe endpoint.  The MAC label is shared
	 * between the connected endpoints.  As a result mac_pipe_label_init() and
	 * mac_pipe_label_associate() should only be called on one of the endpoints
	 * after they have been connected.
	 */</span>
	mac_pipe_label_init(rpipe);
	mac_pipe_label_associate(kauth_cred_get(), rpipe);
	wpipe-&gt;pipe_label = rpipe-&gt;pipe_label;
#<span class="enscript-reference">endif</span>
	proc_fdlock_spin(p);
	procfdtbl_releasefd(p, retval[0], NULL);
	procfdtbl_releasefd(p, retval[1], NULL);
	fp_drop(p, retval[0], rf, 1);
	fp_drop(p, retval[1], wf, 1);
	proc_fdunlock(p);


	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">freepipes</span>:
	pipeclose(rpipe); 
	pipeclose(wpipe); 
	lck_mtx_free(pmtx, pipe_mtx_grp);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">pipe_stat</span>(<span class="enscript-type">struct</span> pipe *cpipe, <span class="enscript-type">void</span> *ub, <span class="enscript-type">int</span> isstat64)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
        <span class="enscript-type">int</span> error;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">int</span>	pipe_size = 0;
	<span class="enscript-type">int</span>	pipe_count;
	<span class="enscript-type">struct</span> stat *sb = (<span class="enscript-type">struct</span> stat *)0;	<span class="enscript-comment">/* warning avoidance ; protected by isstat64 */</span>
	<span class="enscript-type">struct</span> stat64 * sb64 = (<span class="enscript-type">struct</span> stat64 *)0;  <span class="enscript-comment">/* warning avoidance ; protected by isstat64 */</span>

	<span class="enscript-keyword">if</span> (cpipe == NULL)
	        <span class="enscript-keyword">return</span> (EBADF);
	PIPE_LOCK(cpipe);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_pipe_check_stat(kauth_cred_get(), cpipe);
	<span class="enscript-keyword">if</span> (error) {
		PIPE_UNLOCK(cpipe);
	        <span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (cpipe-&gt;pipe_buffer.buffer == 0) {
	        <span class="enscript-comment">/* must be stat'ing the write fd */</span>
	        <span class="enscript-keyword">if</span> (cpipe-&gt;pipe_peer) {
		        <span class="enscript-comment">/* the peer still exists, use it's info */</span>
		        pipe_size  = MAX_PIPESIZE(cpipe-&gt;pipe_peer);
			pipe_count = cpipe-&gt;pipe_peer-&gt;pipe_buffer.cnt;
		} <span class="enscript-keyword">else</span> {
			pipe_count = 0;
		}
	} <span class="enscript-keyword">else</span> {
	        pipe_size  = MAX_PIPESIZE(cpipe);
		pipe_count = cpipe-&gt;pipe_buffer.cnt;
	}
	<span class="enscript-comment">/*
	 * since peer's buffer is setup ouside of lock
	 * we might catch it in transient state
	 */</span>
	<span class="enscript-keyword">if</span> (pipe_size == 0)
		pipe_size  = MAX(PIPE_SIZE, pipesize_blocks[0]);

	<span class="enscript-keyword">if</span> (isstat64 != 0) {
		sb64 = (<span class="enscript-type">struct</span> stat64 *)ub;	

		bzero(sb64, <span class="enscript-keyword">sizeof</span>(*sb64));
		sb64-&gt;st_mode = S_IFIFO | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP;
		sb64-&gt;st_blksize = pipe_size;
		sb64-&gt;st_size = pipe_count;
		sb64-&gt;st_blocks = (sb64-&gt;st_size + sb64-&gt;st_blksize - 1) / sb64-&gt;st_blksize;
	
		sb64-&gt;st_uid = kauth_getuid();
		sb64-&gt;st_gid = kauth_getgid();
	
		sb64-&gt;st_atimespec.tv_sec  = cpipe-&gt;st_atimespec.tv_sec;
		sb64-&gt;st_atimespec.tv_nsec = cpipe-&gt;st_atimespec.tv_nsec;
	
		sb64-&gt;st_mtimespec.tv_sec  = cpipe-&gt;st_mtimespec.tv_sec;
		sb64-&gt;st_mtimespec.tv_nsec = cpipe-&gt;st_mtimespec.tv_nsec;

		sb64-&gt;st_ctimespec.tv_sec  = cpipe-&gt;st_ctimespec.tv_sec;
		sb64-&gt;st_ctimespec.tv_nsec = cpipe-&gt;st_ctimespec.tv_nsec;

		<span class="enscript-comment">/*
	 	* Return a relatively unique inode number based on the current
	 	* address of this pipe's struct pipe.  This number may be recycled
	 	* relatively quickly.
	 	*/</span>
		sb64-&gt;st_ino = (ino64_t)VM_KERNEL_ADDRPERM((uintptr_t)cpipe);
	} <span class="enscript-keyword">else</span> {
		sb = (<span class="enscript-type">struct</span> stat *)ub;	

		bzero(sb, <span class="enscript-keyword">sizeof</span>(*sb));
		sb-&gt;st_mode = S_IFIFO | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP;
		sb-&gt;st_blksize = pipe_size;
		sb-&gt;st_size = pipe_count;
		sb-&gt;st_blocks = (sb-&gt;st_size + sb-&gt;st_blksize - 1) / sb-&gt;st_blksize;
	
		sb-&gt;st_uid = kauth_getuid();
		sb-&gt;st_gid = kauth_getgid();
	
		sb-&gt;st_atimespec.tv_sec  = cpipe-&gt;st_atimespec.tv_sec;
		sb-&gt;st_atimespec.tv_nsec = cpipe-&gt;st_atimespec.tv_nsec;
	
		sb-&gt;st_mtimespec.tv_sec  = cpipe-&gt;st_mtimespec.tv_sec;
		sb-&gt;st_mtimespec.tv_nsec = cpipe-&gt;st_mtimespec.tv_nsec;

		sb-&gt;st_ctimespec.tv_sec  = cpipe-&gt;st_ctimespec.tv_sec;
		sb-&gt;st_ctimespec.tv_nsec = cpipe-&gt;st_ctimespec.tv_nsec;

		<span class="enscript-comment">/*
	 	* Return a relatively unique inode number based on the current
	 	* address of this pipe's struct pipe.  This number may be recycled
	 	* relatively quickly.
	 	*/</span>
		sb-&gt;st_ino = (ino_t)VM_KERNEL_ADDRPERM((uintptr_t)cpipe);
	}
	PIPE_UNLOCK(cpipe);

	<span class="enscript-comment">/*
	 * POSIX: Left as 0: st_dev, st_nlink, st_rdev, st_flags, st_gen,
	 * st_uid, st_gid.
	 *
	 * XXX (st_dev) should be unique, but there is no device driver that
	 * XXX is associated with pipes, since they are implemented via a
	 * XXX struct fileops indirection rather than as FS objects.
	 */</span>
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Allocate kva for pipe circular buffer, the space is pageable
 * This routine will 'realloc' the size of a pipe safely, if it fails
 * it will retain the old buffer.
 * If it fails it will return ENOMEM.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pipespace</span>(<span class="enscript-type">struct</span> pipe *cpipe, <span class="enscript-type">int</span> size)
{
	vm_offset_t buffer;

	<span class="enscript-keyword">if</span> (size &lt;= 0)
		<span class="enscript-keyword">return</span>(EINVAL);

	<span class="enscript-keyword">if</span> ((buffer = (vm_offset_t)kalloc(size)) == 0 )
		<span class="enscript-keyword">return</span>(ENOMEM);

	<span class="enscript-comment">/* free old resources if we're resizing */</span>
	pipe_free_kmem(cpipe);
	cpipe-&gt;pipe_buffer.buffer = (caddr_t)buffer;
	cpipe-&gt;pipe_buffer.size = size;
	cpipe-&gt;pipe_buffer.in = 0;
	cpipe-&gt;pipe_buffer.out = 0;
	cpipe-&gt;pipe_buffer.cnt = 0;

	OSAddAtomic(1, &amp;amountpipes);
	OSAddAtomic(cpipe-&gt;pipe_buffer.size, &amp;amountpipekva);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * initialize and allocate VM and memory for pipe
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pipe_create</span>(<span class="enscript-type">struct</span> pipe **cpipep)
{
	<span class="enscript-type">struct</span> pipe *cpipe;
	cpipe = (<span class="enscript-type">struct</span> pipe *)zalloc(pipe_zone);

	<span class="enscript-keyword">if</span> ((*cpipep = cpipe) == NULL)
		<span class="enscript-keyword">return</span> (ENOMEM);

	<span class="enscript-comment">/*
	 * protect so pipespace or pipeclose don't follow a junk pointer
	 * if pipespace() fails.
	 */</span>
	bzero(cpipe, <span class="enscript-keyword">sizeof</span> *cpipe);

	<span class="enscript-comment">/* Initial times are all the time of creation of the pipe */</span>
	pipe_touch(cpipe, PIPE_ATIME | PIPE_MTIME | PIPE_CTIME);
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * lock a pipe for I/O, blocking other access
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">int</span>
<span class="enscript-function-name">pipeio_lock</span>(<span class="enscript-type">struct</span> pipe *cpipe, <span class="enscript-type">int</span> catch)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-keyword">while</span> (cpipe-&gt;pipe_state &amp; PIPE_LOCKFL) {
		cpipe-&gt;pipe_state |= PIPE_LWANT;
		error = msleep(cpipe, PIPE_MTX(cpipe), catch ? (PRIBIO | PCATCH) : PRIBIO,
			       <span class="enscript-string">&quot;pipelk&quot;</span>, 0);
		<span class="enscript-keyword">if</span> (error != 0) 
			<span class="enscript-keyword">return</span> (error);
	}
	cpipe-&gt;pipe_state |= PIPE_LOCKFL;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * unlock a pipe I/O lock
 */</span>
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">pipeio_unlock</span>(<span class="enscript-type">struct</span> pipe *cpipe)
{
	cpipe-&gt;pipe_state &amp;= ~PIPE_LOCKFL;
	<span class="enscript-keyword">if</span> (cpipe-&gt;pipe_state &amp; PIPE_LWANT) {
		cpipe-&gt;pipe_state &amp;= ~PIPE_LWANT;
		wakeup(cpipe);
	}
}

<span class="enscript-comment">/*
 * wakeup anyone whos blocked in select
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pipeselwakeup</span>(<span class="enscript-type">struct</span> pipe *cpipe, <span class="enscript-type">struct</span> pipe *spipe)
{
	<span class="enscript-keyword">if</span> (cpipe-&gt;pipe_state &amp; PIPE_SEL) {
		cpipe-&gt;pipe_state &amp;= ~PIPE_SEL;
		selwakeup(&amp;cpipe-&gt;pipe_sel);
	}
        <span class="enscript-keyword">if</span> (cpipe-&gt;pipe_state &amp; PIPE_KNOTE) 
	       KNOTE(&amp;cpipe-&gt;pipe_sel.si_note, 1);

	postpipeevent(cpipe, EV_RWBYTES);

	<span class="enscript-keyword">if</span> (spipe &amp;&amp; (spipe-&gt;pipe_state &amp; PIPE_ASYNC) &amp;&amp; spipe-&gt;pipe_pgid) {
	        <span class="enscript-keyword">if</span> (spipe-&gt;pipe_pgid &lt; 0)
		        gsignal(-spipe-&gt;pipe_pgid, SIGIO);
		<span class="enscript-keyword">else</span> 
		        proc_signal(spipe-&gt;pipe_pgid, SIGIO);
        }
}

<span class="enscript-comment">/*
 * Read n bytes from the buffer. Semantics are similar to file read.
 * returns: number of bytes read from the buffer
 */</span>
<span class="enscript-comment">/* ARGSUSED */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pipe_read</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio, __unused <span class="enscript-type">int</span> flags,
	__unused vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> pipe *rpipe = (<span class="enscript-type">struct</span> pipe *)fp-&gt;f_data;
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> nread = 0;
	u_int size;

	PIPE_LOCK(rpipe);
	++rpipe-&gt;pipe_busy;

	error = pipeio_lock(rpipe, 1);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">unlocked_error</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_pipe_check_read(kauth_cred_get(), rpipe);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">locked_error</span>;
#<span class="enscript-reference">endif</span>


	<span class="enscript-keyword">while</span> (uio_resid(uio)) {
		<span class="enscript-comment">/*
		 * normal pipe buffer receive
		 */</span>
		<span class="enscript-keyword">if</span> (rpipe-&gt;pipe_buffer.cnt &gt; 0) {
			<span class="enscript-comment">/*
			 * # bytes to read is min( bytes from read pointer until end of buffer,
			 *                         total unread bytes, 
			 *                         user requested byte count)
			 */</span>
			size = rpipe-&gt;pipe_buffer.size - rpipe-&gt;pipe_buffer.out;
			<span class="enscript-keyword">if</span> (size &gt; rpipe-&gt;pipe_buffer.cnt)
				size = rpipe-&gt;pipe_buffer.cnt;
			<span class="enscript-comment">// LP64todo - fix this!
</span>			<span class="enscript-keyword">if</span> (size &gt; (u_int) uio_resid(uio))
				size = (u_int) uio_resid(uio);

			PIPE_UNLOCK(rpipe); <span class="enscript-comment">/* we still hold io lock.*/</span>
			error = uiomove(
			    &amp;rpipe-&gt;pipe_buffer.buffer[rpipe-&gt;pipe_buffer.out],
			    size, uio);
			PIPE_LOCK(rpipe);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;

			rpipe-&gt;pipe_buffer.out += size;
			<span class="enscript-keyword">if</span> (rpipe-&gt;pipe_buffer.out &gt;= rpipe-&gt;pipe_buffer.size)
				rpipe-&gt;pipe_buffer.out = 0;

			rpipe-&gt;pipe_buffer.cnt -= size;
			
			<span class="enscript-comment">/*
			 * If there is no more to read in the pipe, reset
			 * its pointers to the beginning.  This improves
			 * cache hit stats.
			 */</span>
			<span class="enscript-keyword">if</span> (rpipe-&gt;pipe_buffer.cnt == 0) {
				rpipe-&gt;pipe_buffer.in = 0;
				rpipe-&gt;pipe_buffer.out = 0;
			}
			nread += size;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * detect EOF condition
			 * read returns 0 on EOF, no need to set error
			 */</span>
			<span class="enscript-keyword">if</span> (rpipe-&gt;pipe_state &amp; (PIPE_DRAIN | PIPE_EOF)) {
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/*
			 * If the &quot;write-side&quot; has been blocked, wake it up now.
			 */</span>
			<span class="enscript-keyword">if</span> (rpipe-&gt;pipe_state &amp; PIPE_WANTW) {
				rpipe-&gt;pipe_state &amp;= ~PIPE_WANTW;
				wakeup(rpipe);
			}

			<span class="enscript-comment">/*
			 * Break if some data was read in previous iteration.
			 */</span>
			<span class="enscript-keyword">if</span> (nread &gt; 0)
				<span class="enscript-keyword">break</span>;

			<span class="enscript-comment">/*
			 * Unlock the pipe buffer for our remaining processing. 
			 * We will either break out with an error or we will
			 * sleep and relock to loop.
			 */</span>
			pipeio_unlock(rpipe);

			<span class="enscript-comment">/*
			 * Handle non-blocking mode operation or
			 * wait for more data.
			 */</span>
			<span class="enscript-keyword">if</span> (fp-&gt;f_flag &amp; FNONBLOCK) {
				error = EAGAIN;
			} <span class="enscript-keyword">else</span> {
				rpipe-&gt;pipe_state |= PIPE_WANTR;
				error = msleep(rpipe, PIPE_MTX(rpipe), PRIBIO | PCATCH, <span class="enscript-string">&quot;piperd&quot;</span>, 0);
				<span class="enscript-keyword">if</span> (error == 0)
				        error = pipeio_lock(rpipe, 1);
			}
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">unlocked_error</span>;
		}
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
<span class="enscript-reference">locked_error</span>:
#<span class="enscript-reference">endif</span>
	pipeio_unlock(rpipe);

<span class="enscript-reference">unlocked_error</span>:
	--rpipe-&gt;pipe_busy;

	<span class="enscript-comment">/*
	 * PIPE_WANT processing only makes sense if pipe_busy is 0.
	 */</span>
	<span class="enscript-keyword">if</span> ((rpipe-&gt;pipe_busy == 0) &amp;&amp; (rpipe-&gt;pipe_state &amp; PIPE_WANT)) {
		rpipe-&gt;pipe_state &amp;= ~(PIPE_WANT|PIPE_WANTW);
		wakeup(rpipe);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rpipe-&gt;pipe_buffer.cnt &lt; rpipe-&gt;pipe_buffer.size) {
		<span class="enscript-comment">/*
		 * Handle write blocking hysteresis.
		 */</span>
		<span class="enscript-keyword">if</span> (rpipe-&gt;pipe_state &amp; PIPE_WANTW) {
			rpipe-&gt;pipe_state &amp;= ~PIPE_WANTW;
			wakeup(rpipe);
		}
	}

	<span class="enscript-keyword">if</span> ((rpipe-&gt;pipe_buffer.size - rpipe-&gt;pipe_buffer.cnt) &gt; 0)
		pipeselwakeup(rpipe, rpipe-&gt;pipe_peer);

	<span class="enscript-comment">/* update last read time */</span>
	pipe_touch(rpipe, PIPE_ATIME);

	PIPE_UNLOCK(rpipe);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * perform a write of n bytes into the read side of buffer. Since 
 * pipes are unidirectional a write is meant to be read by the otherside only.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pipe_write</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> uio *uio, __unused <span class="enscript-type">int</span> flags,
	__unused vfs_context_t ctx)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> orig_resid;
	<span class="enscript-type">int</span> pipe_size;
	<span class="enscript-type">struct</span> pipe *wpipe, *rpipe;
	<span class="enscript-comment">// LP64todo - fix this!
</span>	orig_resid = uio_resid(uio);
	<span class="enscript-type">int</span> space;

	rpipe = (<span class="enscript-type">struct</span> pipe *)fp-&gt;f_data;

	PIPE_LOCK(rpipe);
	wpipe = rpipe-&gt;pipe_peer;

	<span class="enscript-comment">/*
	 * detect loss of pipe read side, issue SIGPIPE if lost.
	 */</span>
	<span class="enscript-keyword">if</span> (wpipe == NULL || (wpipe-&gt;pipe_state &amp; (PIPE_DRAIN | PIPE_EOF))) {
		PIPE_UNLOCK(rpipe);
		<span class="enscript-keyword">return</span> (EPIPE);
	}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_pipe_check_write(kauth_cred_get(), wpipe);
	<span class="enscript-keyword">if</span> (error) {
		PIPE_UNLOCK(rpipe);
		<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span>
	++wpipe-&gt;pipe_busy;

	pipe_size = 0;

	<span class="enscript-comment">/*
	 * need to allocate some storage... we delay the allocation
	 * until the first write on fd[0] to avoid allocating storage for both
	 * 'pipe ends'... most pipes are half-duplex with the writes targeting
	 * fd[1], so allocating space for both ends is a waste...
	 */</span>

	<span class="enscript-keyword">if</span> ( wpipe-&gt;pipe_buffer.buffer == 0 || ( 
		(<span class="enscript-type">unsigned</span>)orig_resid &gt; wpipe-&gt;pipe_buffer.size - wpipe-&gt;pipe_buffer.cnt &amp;&amp;
		amountpipekva &lt; maxpipekva ) ) {

	        pipe_size = choose_pipespace(wpipe-&gt;pipe_buffer.size, wpipe-&gt;pipe_buffer.cnt + orig_resid);
	}
	<span class="enscript-keyword">if</span> (pipe_size) {
	        <span class="enscript-comment">/*
		 * need to do initial allocation or resizing of pipe
		 * holding both structure and io locks. 
		 */</span>
		<span class="enscript-keyword">if</span> ((error = pipeio_lock(wpipe, 1)) == 0) {
			<span class="enscript-keyword">if</span> (wpipe-&gt;pipe_buffer.cnt == 0) 			
				error = pipespace(wpipe, pipe_size);
			<span class="enscript-keyword">else</span> 
				error = expand_pipespace(wpipe, pipe_size);
		
			pipeio_unlock(wpipe);
			
			<span class="enscript-comment">/* allocation failed */</span>
			<span class="enscript-keyword">if</span> (wpipe-&gt;pipe_buffer.buffer == 0)
			        error = ENOMEM;
		}
		<span class="enscript-keyword">if</span> (error) {
		        <span class="enscript-comment">/*
			 * If an error occurred unbusy and return, waking up any pending
			 * readers.
			 */</span>
		        --wpipe-&gt;pipe_busy;
			<span class="enscript-keyword">if</span> ((wpipe-&gt;pipe_busy == 0) &amp;&amp; 
			    (wpipe-&gt;pipe_state &amp; PIPE_WANT)) {
			        wpipe-&gt;pipe_state &amp;= ~(PIPE_WANT | PIPE_WANTR);
				wakeup(wpipe);
			}
			PIPE_UNLOCK(rpipe);
			<span class="enscript-keyword">return</span>(error);
		}
	}

	<span class="enscript-keyword">while</span> (uio_resid(uio)) {

	<span class="enscript-reference">retrywrite</span>:
		space = wpipe-&gt;pipe_buffer.size - wpipe-&gt;pipe_buffer.cnt;

		<span class="enscript-comment">/* Writes of size &lt;= PIPE_BUF must be atomic. */</span>
		<span class="enscript-keyword">if</span> ((space &lt; uio_resid(uio)) &amp;&amp; (orig_resid &lt;= PIPE_BUF))
			space = 0;

		<span class="enscript-keyword">if</span> (space &gt; 0) {

			<span class="enscript-keyword">if</span> ((error = pipeio_lock(wpipe,1)) == 0) {
				<span class="enscript-type">int</span> size;	<span class="enscript-comment">/* Transfer size */</span>
				<span class="enscript-type">int</span> segsize;	<span class="enscript-comment">/* first segment to transfer */</span>

				<span class="enscript-keyword">if</span> (wpipe-&gt;pipe_state &amp; (PIPE_DRAIN | PIPE_EOF)) {
					pipeio_unlock(wpipe);
				        error = EPIPE;
					<span class="enscript-keyword">break</span>;
				}
				<span class="enscript-comment">/* 
				 * If a process blocked in pipeio_lock, our
				 * value for space might be bad... the mutex
				 * is dropped while we're blocked
				 */</span>
				<span class="enscript-keyword">if</span> (space &gt; (<span class="enscript-type">int</span>)(wpipe-&gt;pipe_buffer.size - 
				    wpipe-&gt;pipe_buffer.cnt)) {
					pipeio_unlock(wpipe);
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">retrywrite</span>;
				}

				<span class="enscript-comment">/*
				 * Transfer size is minimum of uio transfer
				 * and free space in pipe buffer.
				 */</span>
				<span class="enscript-comment">// LP64todo - fix this!
</span>				<span class="enscript-keyword">if</span> (space &gt; uio_resid(uio))
					size = uio_resid(uio);
				<span class="enscript-keyword">else</span>
					size = space;
				<span class="enscript-comment">/*
				 * First segment to transfer is minimum of 
				 * transfer size and contiguous space in
				 * pipe buffer.  If first segment to transfer
				 * is less than the transfer size, we've got
				 * a wraparound in the buffer.
				 */</span>
				segsize = wpipe-&gt;pipe_buffer.size - 
					wpipe-&gt;pipe_buffer.in;
				<span class="enscript-keyword">if</span> (segsize &gt; size)
					segsize = size;
				
				<span class="enscript-comment">/* Transfer first segment */</span>

				PIPE_UNLOCK(rpipe);
				error = uiomove(&amp;wpipe-&gt;pipe_buffer.buffer[wpipe-&gt;pipe_buffer.in], 
						segsize, uio);
				PIPE_LOCK(rpipe);
				
				<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; segsize &lt; size) {
					<span class="enscript-comment">/* 
					 * Transfer remaining part now, to
					 * support atomic writes.  Wraparound
					 * happened. (State 3)
					 */</span>
					<span class="enscript-keyword">if</span> (wpipe-&gt;pipe_buffer.in + segsize != 
					    wpipe-&gt;pipe_buffer.size)
						panic(<span class="enscript-string">&quot;Expected pipe buffer &quot;</span>
						    <span class="enscript-string">&quot;wraparound disappeared&quot;</span>);
						
					PIPE_UNLOCK(rpipe);
					error = uiomove(
					    &amp;wpipe-&gt;pipe_buffer.buffer[0],
				    	    size - segsize, uio);
					PIPE_LOCK(rpipe);
				}
				<span class="enscript-comment">/* 
				 * readers never know to read until count is updated.
				 */</span>
				<span class="enscript-keyword">if</span> (error == 0) {
					wpipe-&gt;pipe_buffer.in += size;
					<span class="enscript-keyword">if</span> (wpipe-&gt;pipe_buffer.in &gt;
					    wpipe-&gt;pipe_buffer.size) {
						<span class="enscript-keyword">if</span> (wpipe-&gt;pipe_buffer.in !=
						    size - segsize +
						    wpipe-&gt;pipe_buffer.size)
							panic(<span class="enscript-string">&quot;Expected &quot;</span>
							    <span class="enscript-string">&quot;wraparound bad&quot;</span>);
						wpipe-&gt;pipe_buffer.in = size -
						    segsize;
					}
				
					wpipe-&gt;pipe_buffer.cnt += size;
					<span class="enscript-keyword">if</span> (wpipe-&gt;pipe_buffer.cnt &gt;
					    wpipe-&gt;pipe_buffer.size)
						panic(<span class="enscript-string">&quot;Pipe buffer overflow&quot;</span>);
				
				}
				pipeio_unlock(wpipe);
			}
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">break</span>;

		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * If the &quot;read-side&quot; has been blocked, wake it up now.
			 */</span>
			<span class="enscript-keyword">if</span> (wpipe-&gt;pipe_state &amp; PIPE_WANTR) {
				wpipe-&gt;pipe_state &amp;= ~PIPE_WANTR;
				wakeup(wpipe);
			}
			<span class="enscript-comment">/*
			 * don't block on non-blocking I/O
			 * we'll do the pipeselwakeup on the way out
			 */</span>
			<span class="enscript-keyword">if</span> (fp-&gt;f_flag &amp; FNONBLOCK) {
				error = EAGAIN;
				<span class="enscript-keyword">break</span>;
			}

			<span class="enscript-comment">/*
			 * If read side wants to go away, we just issue a signal
			 * to ourselves.
			 */</span>
			<span class="enscript-keyword">if</span> (wpipe-&gt;pipe_state &amp; (PIPE_DRAIN | PIPE_EOF)) {
				error = EPIPE;
				<span class="enscript-keyword">break</span>;
			}	

			<span class="enscript-comment">/*
			 * We have no more space and have something to offer,
			 * wake up select/poll.
			 */</span>
			pipeselwakeup(wpipe, wpipe);

			wpipe-&gt;pipe_state |= PIPE_WANTW;

			error = msleep(wpipe, PIPE_MTX(wpipe), PRIBIO | PCATCH, <span class="enscript-string">&quot;pipewr&quot;</span>, 0);

			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">break</span>;
		}
	}
	--wpipe-&gt;pipe_busy;

	<span class="enscript-keyword">if</span> ((wpipe-&gt;pipe_busy == 0) &amp;&amp; (wpipe-&gt;pipe_state &amp; PIPE_WANT)) {
		wpipe-&gt;pipe_state &amp;= ~(PIPE_WANT | PIPE_WANTR);
		wakeup(wpipe);
	}
	<span class="enscript-keyword">if</span> (wpipe-&gt;pipe_buffer.cnt &gt; 0) {
		<span class="enscript-comment">/*
		 * If there are any characters in the buffer, we wake up
		 * the reader if it was blocked waiting for data.
		 */</span>
		<span class="enscript-keyword">if</span> (wpipe-&gt;pipe_state &amp; PIPE_WANTR) {
			wpipe-&gt;pipe_state &amp;= ~PIPE_WANTR;
			wakeup(wpipe);
		}
		<span class="enscript-comment">/*
		 * wake up thread blocked in select/poll or post the notification
		 */</span>
		pipeselwakeup(wpipe, wpipe);
	}

	<span class="enscript-comment">/* Update modification, status change (# of bytes in pipe) times */</span>
	pipe_touch(rpipe, PIPE_MTIME | PIPE_CTIME);
	pipe_touch(wpipe, PIPE_MTIME | PIPE_CTIME);
	PIPE_UNLOCK(rpipe);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * we implement a very minimal set of ioctls for compatibility with sockets.
 */</span>
<span class="enscript-comment">/* ARGSUSED 3 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pipe_ioctl</span>(<span class="enscript-type">struct</span> fileproc *fp, u_long cmd, caddr_t data,
	__unused vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> pipe *mpipe = (<span class="enscript-type">struct</span> pipe *)fp-&gt;f_data;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-type">int</span> error;
#<span class="enscript-reference">endif</span>

	PIPE_LOCK(mpipe);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_pipe_check_ioctl(kauth_cred_get(), mpipe, cmd);
	<span class="enscript-keyword">if</span> (error) {
		PIPE_UNLOCK(mpipe);

		<span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">switch</span> (cmd) {

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIONBIO</span>:
		PIPE_UNLOCK(mpipe);
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIOASYNC</span>:
		<span class="enscript-keyword">if</span> (*(<span class="enscript-type">int</span> *)data) {
			mpipe-&gt;pipe_state |= PIPE_ASYNC;
		} <span class="enscript-keyword">else</span> {
			mpipe-&gt;pipe_state &amp;= ~PIPE_ASYNC;
		}
		PIPE_UNLOCK(mpipe);
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">FIONREAD</span>:
		*(<span class="enscript-type">int</span> *)data = mpipe-&gt;pipe_buffer.cnt;
		PIPE_UNLOCK(mpipe);
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TIOCSPGRP</span>:
		mpipe-&gt;pipe_pgid = *(<span class="enscript-type">int</span> *)data;

		PIPE_UNLOCK(mpipe);
		<span class="enscript-keyword">return</span> (0);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">TIOCGPGRP</span>:
		*(<span class="enscript-type">int</span> *)data = mpipe-&gt;pipe_pgid;

		PIPE_UNLOCK(mpipe);
		<span class="enscript-keyword">return</span> (0);

	}
	PIPE_UNLOCK(mpipe);
	<span class="enscript-keyword">return</span> (ENOTTY);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pipe_select</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">int</span> which, <span class="enscript-type">void</span> *wql, vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> pipe *rpipe = (<span class="enscript-type">struct</span> pipe *)fp-&gt;f_data;
	<span class="enscript-type">struct</span> pipe *wpipe;
	<span class="enscript-type">int</span>    retnum = 0;

	<span class="enscript-keyword">if</span> (rpipe == NULL || rpipe == (<span class="enscript-type">struct</span> pipe *)-1)
	        <span class="enscript-keyword">return</span> (retnum);

	PIPE_LOCK(rpipe);

	wpipe = rpipe-&gt;pipe_peer;
	

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/*
	 * XXX We should use a per thread credential here; minimally, the
	 * XXX process credential should have a persistent reference on it
	 * XXX before being passed in here.
	 */</span>
	<span class="enscript-keyword">if</span> (mac_pipe_check_select(vfs_context_ucred(ctx), rpipe, which)) {
		PIPE_UNLOCK(rpipe);
		<span class="enscript-keyword">return</span> (0);
	}
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">switch</span> (which) {

        <span class="enscript-keyword">case</span> <span class="enscript-reference">FREAD</span>:
		<span class="enscript-keyword">if</span> ((rpipe-&gt;pipe_state &amp; PIPE_DIRECTW) ||
		    (rpipe-&gt;pipe_buffer.cnt &gt; 0) ||
		    (rpipe-&gt;pipe_state &amp; (PIPE_DRAIN | PIPE_EOF))) {

		        retnum = 1;
		} <span class="enscript-keyword">else</span> {
		        rpipe-&gt;pipe_state |= PIPE_SEL;
		        selrecord(vfs_context_proc(ctx), &amp;rpipe-&gt;pipe_sel, wql);
		}
		<span class="enscript-keyword">break</span>;

        <span class="enscript-keyword">case</span> <span class="enscript-reference">FWRITE</span>:
		<span class="enscript-keyword">if</span> (wpipe)
			wpipe-&gt;pipe_state |= PIPE_WSELECT;
		<span class="enscript-keyword">if</span> (wpipe == NULL || (wpipe-&gt;pipe_state &amp; (PIPE_DRAIN | PIPE_EOF)) ||
		    (((wpipe-&gt;pipe_state &amp; PIPE_DIRECTW) == 0) &amp;&amp;
		     (MAX_PIPESIZE(wpipe) - wpipe-&gt;pipe_buffer.cnt) &gt;= PIPE_BUF)) {

		        retnum = 1;
		} <span class="enscript-keyword">else</span> {
		        wpipe-&gt;pipe_state |= PIPE_SEL;
			selrecord(vfs_context_proc(ctx), &amp;wpipe-&gt;pipe_sel, wql);
		}
		<span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
	        rpipe-&gt;pipe_state |= PIPE_SEL;
		selrecord(vfs_context_proc(ctx), &amp;rpipe-&gt;pipe_sel, wql);
		<span class="enscript-keyword">break</span>;
        }
	PIPE_UNLOCK(rpipe);

        <span class="enscript-keyword">return</span> (retnum);
}


<span class="enscript-comment">/* ARGSUSED 1 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pipe_close</span>(<span class="enscript-type">struct</span> fileglob *fg, __unused vfs_context_t ctx)
{
        <span class="enscript-type">struct</span> pipe *cpipe;

	proc_fdlock_spin(vfs_context_proc(ctx));
	cpipe = (<span class="enscript-type">struct</span> pipe *)fg-&gt;fg_data;
	fg-&gt;fg_data = NULL;
	proc_fdunlock(vfs_context_proc(ctx));
	<span class="enscript-keyword">if</span> (cpipe)
	        pipeclose(cpipe);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pipe_free_kmem</span>(<span class="enscript-type">struct</span> pipe *cpipe)
{
	<span class="enscript-keyword">if</span> (cpipe-&gt;pipe_buffer.buffer != NULL) {
		OSAddAtomic(-(cpipe-&gt;pipe_buffer.size), &amp;amountpipekva);
		OSAddAtomic(-1, &amp;amountpipes);
		kfree((<span class="enscript-type">void</span> *)cpipe-&gt;pipe_buffer.buffer,
			  cpipe-&gt;pipe_buffer.size);
		cpipe-&gt;pipe_buffer.buffer = NULL;
		cpipe-&gt;pipe_buffer.size = 0;
	}
}

<span class="enscript-comment">/*
 * shutdown the pipe
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pipeclose</span>(<span class="enscript-type">struct</span> pipe *cpipe)
{
	<span class="enscript-type">struct</span> pipe *ppipe;

	<span class="enscript-keyword">if</span> (cpipe == NULL)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-comment">/* partially created pipes won't have a valid mutex. */</span>
	<span class="enscript-keyword">if</span> (PIPE_MTX(cpipe) != NULL)
		PIPE_LOCK(cpipe);
		

	<span class="enscript-comment">/*
	 * If the other side is blocked, wake it up saying that
	 * we want to close it down.
	 */</span>
	cpipe-&gt;pipe_state &amp;= ~PIPE_DRAIN;
	cpipe-&gt;pipe_state |= PIPE_EOF;
	pipeselwakeup(cpipe, cpipe);
	
	<span class="enscript-keyword">while</span> (cpipe-&gt;pipe_busy) {
		cpipe-&gt;pipe_state |= PIPE_WANT;

		wakeup(cpipe);
 		msleep(cpipe, PIPE_MTX(cpipe), PRIBIO, <span class="enscript-string">&quot;pipecl&quot;</span>, 0);
	}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/*
	 * Free the shared pipe label only after the two ends are disconnected.
	 */</span>
	<span class="enscript-keyword">if</span> (cpipe-&gt;pipe_label != NULL &amp;&amp; cpipe-&gt;pipe_peer == NULL)
		mac_pipe_label_destroy(cpipe);
#<span class="enscript-reference">endif</span>

	<span class="enscript-comment">/*
	 * Disconnect from peer
	 */</span>
	<span class="enscript-keyword">if</span> ((ppipe = cpipe-&gt;pipe_peer) != NULL) {

		ppipe-&gt;pipe_state &amp;= ~(PIPE_DRAIN);
		ppipe-&gt;pipe_state |= PIPE_EOF;

		pipeselwakeup(ppipe, ppipe);
		wakeup(ppipe);

		<span class="enscript-keyword">if</span> (cpipe-&gt;pipe_state &amp; PIPE_KNOTE)
		        KNOTE(&amp;ppipe-&gt;pipe_sel.si_note, 1);

		postpipeevent(ppipe, EV_RCLOSED);

		ppipe-&gt;pipe_peer = NULL;
	}
	evpipefree(cpipe);

	<span class="enscript-comment">/*
	 * free resources
	 */</span>
	<span class="enscript-keyword">if</span> (PIPE_MTX(cpipe) != NULL) {
		<span class="enscript-keyword">if</span> (ppipe != NULL) {
			<span class="enscript-comment">/*
			 * since the mutex is shared and the peer is still
			 * alive, we need to release the mutex, not free it
			 */</span>
			PIPE_UNLOCK(cpipe);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * peer is gone, so we're the sole party left with
			 * interest in this mutex... unlock and free it
			 */</span>
			PIPE_UNLOCK(cpipe);
			lck_mtx_free(PIPE_MTX(cpipe), pipe_mtx_grp);
		}
	}
	pipe_free_kmem(cpipe);
	<span class="enscript-keyword">if</span> (cpipe-&gt;pipe_state &amp; PIPE_WSELECT) {
		pipe_garbage_collect(cpipe);
	} <span class="enscript-keyword">else</span> {
		zfree(pipe_zone, cpipe);
		pipe_garbage_collect(NULL);
	}

}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">pipe_kqfilter</span>(__unused <span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> knote *kn, __unused vfs_context_t ctx)
{
	<span class="enscript-type">struct</span> pipe *cpipe;

	cpipe = (<span class="enscript-type">struct</span> pipe *)kn-&gt;kn_fp-&gt;f_data;

	PIPE_LOCK(cpipe);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	<span class="enscript-comment">/*
	 * XXX We should use a per thread credential here; minimally, the
	 * XXX process credential should have a persistent reference on it
	 * XXX before being passed in here.
	 */</span>
	<span class="enscript-keyword">if</span> (mac_pipe_check_kqfilter(vfs_context_ucred(ctx), kn, cpipe) != 0) {
		PIPE_UNLOCK(cpipe);
		<span class="enscript-keyword">return</span> (1);
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">switch</span> (kn-&gt;kn_filter) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_READ</span>:
		kn-&gt;kn_fop = &amp;pipe_rfiltops;

		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_WRITE</span>:
		kn-&gt;kn_fop = &amp;pipe_wfiltops;

		<span class="enscript-keyword">if</span> (cpipe-&gt;pipe_peer == NULL) {
			<span class="enscript-comment">/*
			 * other end of pipe has been closed
			 */</span>
		        PIPE_UNLOCK(cpipe);
			<span class="enscript-keyword">return</span> (EPIPE);
		}
		<span class="enscript-keyword">if</span> (cpipe-&gt;pipe_peer)
		cpipe = cpipe-&gt;pipe_peer;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
	        PIPE_UNLOCK(cpipe);
		<span class="enscript-keyword">return</span> (1);
	}

	<span class="enscript-keyword">if</span> (KNOTE_ATTACH(&amp;cpipe-&gt;pipe_sel.si_note, kn))
	        cpipe-&gt;pipe_state |= PIPE_KNOTE;

	PIPE_UNLOCK(cpipe);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_pipedetach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-type">struct</span> pipe *cpipe = (<span class="enscript-type">struct</span> pipe *)kn-&gt;kn_fp-&gt;f_data;

	PIPE_LOCK(cpipe);

	<span class="enscript-keyword">if</span> (kn-&gt;kn_filter == EVFILT_WRITE) {
	        <span class="enscript-keyword">if</span> (cpipe-&gt;pipe_peer == NULL) {
		        PIPE_UNLOCK(cpipe);
			<span class="enscript-keyword">return</span>;
		}
		cpipe = cpipe-&gt;pipe_peer;
	}
	<span class="enscript-keyword">if</span> (cpipe-&gt;pipe_state &amp; PIPE_KNOTE) {
	        <span class="enscript-keyword">if</span> (KNOTE_DETACH(&amp;cpipe-&gt;pipe_sel.si_note, kn))
		        cpipe-&gt;pipe_state &amp;= ~PIPE_KNOTE;
	}
	PIPE_UNLOCK(cpipe);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_piperead</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint)
{
	<span class="enscript-type">struct</span> pipe *rpipe = (<span class="enscript-type">struct</span> pipe *)kn-&gt;kn_fp-&gt;f_data;
	<span class="enscript-type">struct</span> pipe *wpipe;
	<span class="enscript-type">int</span>    retval;

	<span class="enscript-comment">/*
	 * if hint == 0, then we've been called from the kevent
	 * world directly and do not currently hold the pipe mutex...
	 * if hint == 1, we're being called back via the KNOTE post
	 * we made in pipeselwakeup, and we already hold the mutex...
	 */</span>
	<span class="enscript-keyword">if</span> (hint == 0)
	        PIPE_LOCK(rpipe);

	wpipe = rpipe-&gt;pipe_peer;
	kn-&gt;kn_data = rpipe-&gt;pipe_buffer.cnt;
	<span class="enscript-keyword">if</span> ((rpipe-&gt;pipe_state &amp; (PIPE_DRAIN | PIPE_EOF)) ||
	    (wpipe == NULL) || (wpipe-&gt;pipe_state &amp; (PIPE_DRAIN | PIPE_EOF))) {
		kn-&gt;kn_flags |= EV_EOF;
		retval = 1;
	} <span class="enscript-keyword">else</span> {
		int64_t lowwat = 1;
		<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_LOWAT) {
			<span class="enscript-keyword">if</span> (rpipe-&gt;pipe_buffer.size &amp;&amp; kn-&gt;kn_sdata &gt; MAX_PIPESIZE(rpipe))
				lowwat = MAX_PIPESIZE(rpipe);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kn-&gt;kn_sdata &gt; lowwat)
				lowwat = kn-&gt;kn_sdata;
		}
		retval = kn-&gt;kn_data &gt;= lowwat;
	}

	<span class="enscript-keyword">if</span> (hint == 0)
	        PIPE_UNLOCK(rpipe);

	<span class="enscript-keyword">return</span> (retval);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_pipewrite</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint)
{
	<span class="enscript-type">struct</span> pipe *rpipe = (<span class="enscript-type">struct</span> pipe *)kn-&gt;kn_fp-&gt;f_data;
	<span class="enscript-type">struct</span> pipe *wpipe;

	<span class="enscript-comment">/*
	 * if hint == 0, then we've been called from the kevent
	 * world directly and do not currently hold the pipe mutex...
	 * if hint == 1, we're being called back via the KNOTE post
	 * we made in pipeselwakeup, and we already hold the mutex...
	 */</span>
	<span class="enscript-keyword">if</span> (hint == 0)
	        PIPE_LOCK(rpipe);

	wpipe = rpipe-&gt;pipe_peer;

	<span class="enscript-keyword">if</span> ((wpipe == NULL) || (wpipe-&gt;pipe_state &amp; (PIPE_DRAIN | PIPE_EOF))) {
		kn-&gt;kn_data = 0;
		kn-&gt;kn_flags |= EV_EOF; 

		<span class="enscript-keyword">if</span> (hint == 0)
		        PIPE_UNLOCK(rpipe);
		<span class="enscript-keyword">return</span> (1);
	}
	kn-&gt;kn_data = MAX_PIPESIZE(wpipe) - wpipe-&gt;pipe_buffer.cnt;

	int64_t lowwat = PIPE_BUF;
	<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_LOWAT) {
		<span class="enscript-keyword">if</span> (wpipe-&gt;pipe_buffer.size &amp;&amp; kn-&gt;kn_sdata &gt; MAX_PIPESIZE(wpipe))
			lowwat = MAX_PIPESIZE(wpipe);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kn-&gt;kn_sdata &gt; lowwat)
			lowwat = kn-&gt;kn_sdata;
	}
	
	<span class="enscript-keyword">if</span> (hint == 0)
	        PIPE_UNLOCK(rpipe);

	<span class="enscript-keyword">return</span> (kn-&gt;kn_data &gt;= lowwat);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">fill_pipeinfo</span>(<span class="enscript-type">struct</span> pipe * cpipe, <span class="enscript-type">struct</span> pipe_info * pinfo)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
        <span class="enscript-type">int</span> error;
#<span class="enscript-reference">endif</span>
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">struct</span> vinfo_stat * ub;
	<span class="enscript-type">int</span> pipe_size = 0;
	<span class="enscript-type">int</span> pipe_count;

	<span class="enscript-keyword">if</span> (cpipe == NULL)
	        <span class="enscript-keyword">return</span> (EBADF);
	PIPE_LOCK(cpipe);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	error = mac_pipe_check_stat(kauth_cred_get(), cpipe);
	<span class="enscript-keyword">if</span> (error) {
		PIPE_UNLOCK(cpipe);
	        <span class="enscript-keyword">return</span> (error);
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (cpipe-&gt;pipe_buffer.buffer == 0) {
	        <span class="enscript-comment">/*
		 * must be stat'ing the write fd
		 */</span>
	        <span class="enscript-keyword">if</span> (cpipe-&gt;pipe_peer) {
		        <span class="enscript-comment">/*
			 * the peer still exists, use it's info
			 */</span>
		        pipe_size  = MAX_PIPESIZE(cpipe-&gt;pipe_peer);
			pipe_count = cpipe-&gt;pipe_peer-&gt;pipe_buffer.cnt;
		} <span class="enscript-keyword">else</span> {
			pipe_count = 0;
		}
	} <span class="enscript-keyword">else</span> {
	        pipe_size  = MAX_PIPESIZE(cpipe);
		pipe_count = cpipe-&gt;pipe_buffer.cnt;
	}
	<span class="enscript-comment">/*
	 * since peer's buffer is setup ouside of lock
	 * we might catch it in transient state
	 */</span>
	<span class="enscript-keyword">if</span> (pipe_size == 0)
		pipe_size  = PIPE_SIZE;

	ub = &amp;pinfo-&gt;pipe_stat;

	bzero(ub, <span class="enscript-keyword">sizeof</span>(*ub));
	ub-&gt;vst_mode = S_IFIFO | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP;
	ub-&gt;vst_blksize = pipe_size;
	ub-&gt;vst_size = pipe_count;
	<span class="enscript-keyword">if</span> (ub-&gt;vst_blksize != 0)
		ub-&gt;vst_blocks = (ub-&gt;vst_size + ub-&gt;vst_blksize - 1) / ub-&gt;vst_blksize;
	ub-&gt;vst_nlink = 1;

	ub-&gt;vst_uid = kauth_getuid();
	ub-&gt;vst_gid = kauth_getgid();

	microtime(&amp;now);
	ub-&gt;vst_atime  = now.tv_sec;
	ub-&gt;vst_atimensec = now.tv_usec * 1000;

	ub-&gt;vst_mtime  = now.tv_sec;
	ub-&gt;vst_mtimensec = now.tv_usec * 1000;

	ub-&gt;vst_ctime  = now.tv_sec;
	ub-&gt;vst_ctimensec = now.tv_usec * 1000;

	<span class="enscript-comment">/*
	 * Left as 0: st_dev, st_ino, st_nlink, st_rdev, st_flags, st_gen, st_uid, st_gid.
	 * XXX (st_dev, st_ino) should be unique.
	 */</span>

	pinfo-&gt;pipe_handle = (uint64_t)VM_KERNEL_ADDRPERM((uintptr_t)cpipe);
	pinfo-&gt;pipe_peerhandle = (uint64_t)VM_KERNEL_ADDRPERM((uintptr_t)(cpipe-&gt;pipe_peer));
	pinfo-&gt;pipe_status = cpipe-&gt;pipe_state;

	PIPE_UNLOCK(cpipe);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">static</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">pipe_drain</span>(<span class="enscript-type">struct</span> fileproc *fp, __unused vfs_context_t ctx)
{

	<span class="enscript-comment">/* Note: fdlock already held */</span>
	<span class="enscript-type">struct</span> pipe *ppipe, *cpipe = (<span class="enscript-type">struct</span> pipe *)(fp-&gt;f_fglob-&gt;fg_data);

	<span class="enscript-keyword">if</span> (cpipe) {
		PIPE_LOCK(cpipe);
		cpipe-&gt;pipe_state |= PIPE_DRAIN; 
		cpipe-&gt;pipe_state &amp;= ~(PIPE_WANTR | PIPE_WANTW);
		wakeup(cpipe);
		
		<span class="enscript-comment">/* Must wake up peer: a writer sleeps on the read side */</span>
		<span class="enscript-keyword">if</span> ((ppipe = cpipe-&gt;pipe_peer)) {
			ppipe-&gt;pipe_state |= PIPE_DRAIN;
			ppipe-&gt;pipe_state &amp;= ~(PIPE_WANTR | PIPE_WANTW);
			wakeup(ppipe);
		}
		
		PIPE_UNLOCK(cpipe);
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">return</span> 1;
}


 <span class="enscript-comment">/*
 * When a thread sets a write-select on a pipe, it creates an implicit,
 * untracked dependency between that thread and the peer of the pipe
 * on which the select is set.  If the peer pipe is closed and freed
 * before the select()ing thread wakes up, the system will panic as
 * it attempts to unwind the dangling select().  To avoid that panic,
 * we notice whenever a dangerous select() is set on a pipe, and
 * defer the final deletion of the pipe until that select()s are all
 * resolved.  Since we can't currently detect exactly when that
 * resolution happens, we use a simple garbage collection queue to 
 * reap the at-risk pipes 'later'.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">pipe_garbage_collect</span>(<span class="enscript-type">struct</span> pipe *cpipe)
{
	uint64_t old, now;
	<span class="enscript-type">struct</span> pipe_garbage *pgp;

	<span class="enscript-comment">/* Convert msecs to nsecs and then to abstime */</span>
	old = pipe_garbage_age_limit * 1000000;
	nanoseconds_to_absolutetime(old, &amp;old);

	lck_mtx_lock(pipe_garbage_lock);

	<span class="enscript-comment">/* Free anything that's been on the queue for &lt;mumble&gt; seconds */</span>
	now = mach_absolute_time();
	old = now - old;
	<span class="enscript-keyword">while</span> ((pgp = pipe_garbage_head) &amp;&amp; pgp-&gt;pg_timestamp &lt; old) {
		pipe_garbage_head = pgp-&gt;pg_next;
		<span class="enscript-keyword">if</span> (pipe_garbage_head == NULL)
			pipe_garbage_tail = NULL;
		pipe_garbage_count--;
		zfree(pipe_zone, pgp-&gt;pg_pipe);
		zfree(pipe_garbage_zone, pgp);
	}

	<span class="enscript-comment">/* Add the new pipe (if any) to the tail of the garbage queue */</span>
	<span class="enscript-keyword">if</span> (cpipe) {
		cpipe-&gt;pipe_state = PIPE_DEAD;
		pgp = (<span class="enscript-type">struct</span> pipe_garbage *)zalloc(pipe_garbage_zone);
		<span class="enscript-keyword">if</span> (pgp == NULL) {
			<span class="enscript-comment">/*
			 * We're too low on memory to garbage collect the
			 * pipe.  Freeing it runs the risk of panicing the
			 * system.  All we can do is leak it and leave
			 * a breadcrumb behind.  The good news, such as it
			 * is, is that this will probably never happen.
			 * We will probably hit the panic below first.
			 */</span>
			printf(<span class="enscript-string">&quot;Leaking pipe %p - no room left in the queue&quot;</span>,
			    cpipe);
			lck_mtx_unlock(pipe_garbage_lock);
			<span class="enscript-keyword">return</span>;
		}

		pgp-&gt;pg_pipe = cpipe;
		pgp-&gt;pg_timestamp = now;
		pgp-&gt;pg_next = NULL;

		<span class="enscript-keyword">if</span> (pipe_garbage_tail)
			pipe_garbage_tail-&gt;pg_next = pgp;
		pipe_garbage_tail = pgp;
		<span class="enscript-keyword">if</span> (pipe_garbage_head == NULL)
			pipe_garbage_head = pipe_garbage_tail;

		<span class="enscript-keyword">if</span> (pipe_garbage_count++ &gt;= PIPE_GARBAGE_QUEUE_LIMIT)
			panic(<span class="enscript-string">&quot;Length of pipe garbage queue exceeded %d&quot;</span>,
			    PIPE_GARBAGE_QUEUE_LIMIT);
	}
	lck_mtx_unlock(pipe_garbage_lock);
}

</pre>
<hr />
</body></html>