<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kern_sysctl.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kern_sysctl.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2000-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*-
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Mike Karels at Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)kern_sysctl.c	8.4 (Berkeley) 4/14/94
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

<span class="enscript-comment">/*
* DEPRECATED sysctl system call code
 *
 * Everything in this file is deprecated. Sysctls should be handled
 * by the code in kern_newsysctl.c.
 * The remaining &quot;case&quot; sections are supposed to be converted into
 * SYSCTL_*-style definitions, and as soon as all of them are gone,
 * this source file is supposed to die.
 *
 * DO NOT ADD ANY MORE &quot;case&quot; SECTIONS TO THIS FILE, instead define
 * your sysctl with SYSCTL_INT, SYSCTL_PROC etc. in your source file.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/buf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/namei.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/tty.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/disklabel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/aio_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/reboot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/memory_maintenance.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/priv.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/audit/audit.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/machine.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_host.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/vm_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/mach_param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/thread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/processor.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/debug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_kern.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_map.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/host_info.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOPlatformExpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/exec.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_protos.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;vm/vm_pageout.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/imgsrc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/timer_call.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;i386/cpuid.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_memorystatus.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KPERF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kperf/kperf.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HYPERVISOR</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/hv_support.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * deliberately setting max requests to really high number
 * so that runaway settings do not cause MALLOC overflows
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">AIO_MAX_REQUESTS</span> (128 * CONFIG_AIO_MAX)

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> aio_max_requests;  				
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> aio_max_requests_per_process;	
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> aio_worker_threads;				
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> lowpri_IO_window_msecs;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> lowpri_IO_delay_msecs;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> nx_enabled;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> speculative_reads_disabled;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> ignore_is_ssd;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> speculative_prefetch_max;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> speculative_prefetch_max_iosize;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> preheat_max_bytes;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> preheat_min_bytes;
<span class="enscript-type">extern</span> <span class="enscript-type">long</span> numvnodes;

<span class="enscript-type">extern</span> uuid_string_t bootsessionuuid_string;

<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_max_delayed_work_limit;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_max_batch;

<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_page_free_min;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_page_free_target;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_page_free_reserved;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_page_speculative_percentage;
<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> vm_page_speculative_q_age_ms;

#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
<span class="enscript-type">extern</span> uint32_t	vm_page_creation_throttled_hard;
<span class="enscript-type">extern</span> uint32_t	vm_page_creation_throttled_soft;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>

<span class="enscript-comment">/*
 * Conditionally allow dtrace to see these functions for debugging purposes.
 */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">STATIC</span>
#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">STATIC</span>
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> 0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">STATIC</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">STATIC</span> static
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> boolean_t    mach_timer_coalescing_enabled;

<span class="enscript-type">extern</span> uint64_t timer_deadline_tracking_bin_1, timer_deadline_tracking_bin_2;

STATIC <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_user32_eproc</span>(proc_t, <span class="enscript-type">struct</span> user32_eproc *__restrict);
STATIC <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_user32_externproc</span>(proc_t, <span class="enscript-type">struct</span> user32_extern_proc *__restrict);
STATIC <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_user64_eproc</span>(proc_t, <span class="enscript-type">struct</span> user64_eproc *__restrict);
STATIC <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_user64_proc</span>(proc_t, <span class="enscript-type">struct</span> user64_kinfo_proc *__restrict);
STATIC <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_user64_externproc</span>(proc_t, <span class="enscript-type">struct</span> user64_extern_proc *__restrict);
STATIC <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_user32_proc</span>(proc_t, <span class="enscript-type">struct</span> user32_kinfo_proc *__restrict);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">kdbg_control</span>(<span class="enscript-type">int</span> *name, u_int namelen, user_addr_t where, size_t * sizep);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> 
<span class="enscript-function-name">netboot_root</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">pcsamples_ops</span>(<span class="enscript-type">int</span> *name, u_int namelen, user_addr_t where, size_t *sizep, 
              proc_t p);
__private_extern__ kern_return_t
<span class="enscript-function-name">reset_vmobjectcache</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> val1, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> val2);
<span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_procargs</span>(<span class="enscript-type">int</span> *name, u_int namelen, user_addr_t where, 
				size_t *sizep, proc_t cur_proc);
STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_procargsx</span>(<span class="enscript-type">int</span> *name, u_int namelen, user_addr_t where, size_t *sizep, 
                 proc_t cur_proc, <span class="enscript-type">int</span> argc_yes);
<span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_struct</span>(user_addr_t oldp, size_t *oldlenp, user_addr_t newp, 
              size_t newlen, <span class="enscript-type">void</span> *sp, <span class="enscript-type">int</span> len);

STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysdoproc_filt_KERN_PROC_PID</span>(proc_t p, <span class="enscript-type">void</span> * arg);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysdoproc_filt_KERN_PROC_PGRP</span>(proc_t p, <span class="enscript-type">void</span> * arg);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysdoproc_filt_KERN_PROC_TTY</span>(proc_t p, <span class="enscript-type">void</span> * arg);
STATIC <span class="enscript-type">int</span>  <span class="enscript-function-name">sysdoproc_filt_KERN_PROC_UID</span>(proc_t p, <span class="enscript-type">void</span> * arg);
STATIC <span class="enscript-type">int</span>  <span class="enscript-function-name">sysdoproc_filt_KERN_PROC_RUID</span>(proc_t p, <span class="enscript-type">void</span> * arg);
<span class="enscript-type">int</span> <span class="enscript-function-name">sysdoproc_callback</span>(proc_t p, <span class="enscript-type">void</span> *arg);


<span class="enscript-comment">/* forward declarations for non-static STATIC */</span>
STATIC <span class="enscript-type">void</span> <span class="enscript-function-name">fill_loadavg64</span>(<span class="enscript-type">struct</span> loadavg *la, <span class="enscript-type">struct</span> user64_loadavg *la64);
STATIC <span class="enscript-type">void</span> <span class="enscript-function-name">fill_loadavg32</span>(<span class="enscript-type">struct</span> loadavg *la, <span class="enscript-type">struct</span> user32_loadavg *la32);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_handle_kern_threadname</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_sched_stats</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_sched_stats_enable</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> sysctl_kdebug_ops SYSCTL_HANDLER_ARGS;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COUNT_SYSCALLS</span>
STATIC <span class="enscript-type">int</span> sysctl_docountsyscalls SYSCTL_HANDLER_ARGS;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* COUNT_SYSCALLS */</span>
STATIC <span class="enscript-type">int</span> sysctl_doprocargs SYSCTL_HANDLER_ARGS;
STATIC <span class="enscript-type">int</span> sysctl_doprocargs2 SYSCTL_HANDLER_ARGS;
STATIC <span class="enscript-type">int</span> sysctl_prochandle SYSCTL_HANDLER_ARGS;
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_aiomax</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_aioprocmax</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_aiothreads</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_maxproc</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_osversion</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_sysctl_bootargs</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_maxvnodes</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_securelvl</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_domainname</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_hostname</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_procname</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_boottime</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_symfile</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_netboot</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_IMGSRC_ACCESS</span>
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_imgsrcdev</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
#<span class="enscript-reference">endif</span>
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_usrstack</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_usrstack64</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_coredump</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_suid_coredump</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_delayterm</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_rage_vnode</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_kern_check_openevt</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_nx</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_loadavg</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_vm_toggle_address_reuse</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_swapusage</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">fetch_process_cputype</span>( proc_t cur_proc, <span class="enscript-type">int</span> *name, u_int namelen, cpu_type_t *cputype);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_sysctl_native</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_sysctl_cputype</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_safeboot</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_singleuser</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_minimalboot</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);
STATIC <span class="enscript-type">int</span> <span class="enscript-function-name">sysctl_slide</span>(<span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req);


<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">IORegistrySetOSBuildVersion</span>(<span class="enscript-type">char</span> * build_version); 

STATIC <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_loadavg64</span>(<span class="enscript-type">struct</span> loadavg *la, <span class="enscript-type">struct</span> user64_loadavg *la64)
{
	la64-&gt;ldavg[0]	= la-&gt;ldavg[0];
	la64-&gt;ldavg[1]	= la-&gt;ldavg[1];
	la64-&gt;ldavg[2]	= la-&gt;ldavg[2];
	la64-&gt;fscale	= (user64_long_t)la-&gt;fscale;
}

STATIC <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_loadavg32</span>(<span class="enscript-type">struct</span> loadavg *la, <span class="enscript-type">struct</span> user32_loadavg *la32)
{
	la32-&gt;ldavg[0]	= la-&gt;ldavg[0];
	la32-&gt;ldavg[1]	= la-&gt;ldavg[1];
	la32-&gt;ldavg[2]	= la-&gt;ldavg[2];
	la32-&gt;fscale	= (user32_long_t)la-&gt;fscale;
}

<span class="enscript-comment">/*
 * Attributes stored in the kernel.
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">char</span> corefilename[MAXPATHLEN+1];
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> do_coredump;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> sugid_coredump;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COUNT_SYSCALLS</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> do_count_syscalls;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">INSECURE</span>
<span class="enscript-type">int</span> securelevel = -1;
#<span class="enscript-reference">else</span>
<span class="enscript-type">int</span> securelevel;
#<span class="enscript-reference">endif</span>

STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_handle_kern_threadname</span>(	__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1,
	      __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> uthread *ut = get_bsdthread_info(current_thread());
	user_addr_t oldp=0, newp=0;
	size_t *oldlenp=NULL;
	size_t newlen=0;

	oldp = req-&gt;oldptr;
	oldlenp = &amp;(req-&gt;oldlen);
	newp = req-&gt;newptr;
	newlen = req-&gt;newlen;

	<span class="enscript-comment">/* We want the current length, and maybe the string itself */</span>
	<span class="enscript-keyword">if</span>(oldlenp) {
		<span class="enscript-comment">/* if we have no thread name yet tell'em we want MAXTHREADNAMESIZE - 1 */</span>
		size_t currlen = MAXTHREADNAMESIZE - 1;
		
		<span class="enscript-keyword">if</span>(ut-&gt;pth_name)
			<span class="enscript-comment">/* use length of current thread name */</span>
			currlen = strlen(ut-&gt;pth_name);
		<span class="enscript-keyword">if</span>(oldp) {
			<span class="enscript-keyword">if</span>(*oldlenp &lt; currlen)
				<span class="enscript-keyword">return</span> ENOMEM;
			<span class="enscript-comment">/* NOTE - we do not copy the NULL terminator */</span>
			<span class="enscript-keyword">if</span>(ut-&gt;pth_name) {
				error = copyout(ut-&gt;pth_name,oldp,currlen);
				<span class="enscript-keyword">if</span>(error)
					<span class="enscript-keyword">return</span> error;
			}
		}	
		<span class="enscript-comment">/* return length of thread name minus NULL terminator (just like strlen)  */</span>
		req-&gt;oldidx = currlen;
	}

	<span class="enscript-comment">/* We want to set the name to something */</span>
	<span class="enscript-keyword">if</span>(newp) 
	{
		<span class="enscript-keyword">if</span>(newlen &gt; (MAXTHREADNAMESIZE - 1))
			<span class="enscript-keyword">return</span> ENAMETOOLONG;
		<span class="enscript-keyword">if</span>(!ut-&gt;pth_name)
		{
			ut-&gt;pth_name = (<span class="enscript-type">char</span>*)kalloc( MAXTHREADNAMESIZE );
			<span class="enscript-keyword">if</span>(!ut-&gt;pth_name)
				<span class="enscript-keyword">return</span> ENOMEM;
		}
		bzero(ut-&gt;pth_name, MAXTHREADNAMESIZE);
		error = copyin(newp, ut-&gt;pth_name, newlen);
		<span class="enscript-keyword">if</span>(error)
			<span class="enscript-keyword">return</span> error;
	}
		
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_THREADNAME, threadname, CTLFLAG_ANYBODY | CTLTYPE_STRING | CTLFLAG_RW | CTLFLAG_LOCKED, 0, 0, sysctl_handle_kern_threadname,<span class="enscript-string">&quot;A&quot;</span>,<span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BSD_HOST</span> 1
STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_sched_stats</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	host_basic_info_data_t hinfo;
	kern_return_t kret;
	uint32_t size;
	<span class="enscript-type">int</span> changed;
	mach_msg_type_number_t count = HOST_BASIC_INFO_COUNT;
	<span class="enscript-type">struct</span> _processor_statistics_np *buf;
	<span class="enscript-type">int</span> error;

	kret = host_info((host_t)BSD_HOST, HOST_BASIC_INFO, (host_info_t)&amp;hinfo, &amp;count);
	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> _processor_statistics_np) * (hinfo.logical_cpu_max + 2); <span class="enscript-comment">/* One for RT Queue, One for Fair Share Queue */</span>
	
	<span class="enscript-keyword">if</span> (req-&gt;oldlen &lt; size) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	MALLOC(buf, <span class="enscript-type">struct</span> _processor_statistics_np*, size, M_TEMP, M_ZERO | M_WAITOK);
	
	kret = get_sched_statistics(buf, &amp;size);
	<span class="enscript-keyword">if</span> (kret != KERN_SUCCESS) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = sysctl_io_opaque(req, buf, size, &amp;changed);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (changed) {
		panic(<span class="enscript-string">&quot;Sched info changed?!&quot;</span>);
	}
<span class="enscript-reference">out</span>:
	FREE(buf, M_TEMP);
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, sched_stats, CTLFLAG_LOCKED, 0, 0, sysctl_sched_stats, <span class="enscript-string">&quot;-&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_sched_stats_enable</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, __unused <span class="enscript-type">struct</span> sysctl_req *req)
{
	boolean_t active;
	<span class="enscript-type">int</span> res;

	<span class="enscript-keyword">if</span> (req-&gt;newlen != <span class="enscript-keyword">sizeof</span>(active)) {
		<span class="enscript-keyword">return</span> EINVAL;
	}

	res = copyin(req-&gt;newptr, &amp;active, <span class="enscript-keyword">sizeof</span>(active));
	<span class="enscript-keyword">if</span> (res != 0) {
		<span class="enscript-keyword">return</span> res;
	}

	<span class="enscript-keyword">return</span> set_sched_stats_active(active);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, sched_stats_enable, CTLFLAG_LOCKED | CTLFLAG_WR, 0, 0, sysctl_sched_stats_enable, <span class="enscript-string">&quot;-&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">extern</span> uint32_t sched_debug_flags;
<span class="enscript-function-name">SYSCTL_INT</span>(_debug, OID_AUTO, sched, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;sched_debug_flags, 0, <span class="enscript-string">&quot;scheduler debug&quot;</span>);

#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEBUG</span> || <span class="enscript-variable-name">DEVELOPMENT</span>)
<span class="enscript-type">extern</span> boolean_t doprnt_hide_pointers;
<span class="enscript-function-name">SYSCTL_INT</span>(_debug, OID_AUTO, hide_kernel_pointers, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;doprnt_hide_pointers, 0, <span class="enscript-string">&quot;hide kernel pointers from log&quot;</span>);
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">get_kernel_symfile</span>(proc_t, <span class="enscript-type">char</span> **);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">COUNT_SYSCALLS</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERN_COUNT_SYSCALLS</span> (KERN_OSTYPE + 1000)

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> 	nsysent;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> syscalls_log[];
<span class="enscript-type">extern</span> <span class="enscript-type">const</span> <span class="enscript-type">char</span> *syscallnames[];

STATIC <span class="enscript-type">int</span>
sysctl_docountsyscalls SYSCTL_HANDLER_ARGS
{
	__unused <span class="enscript-type">int</span> cmd = oidp-&gt;oid_arg2;	<span class="enscript-comment">/* subcommand*/</span>
	__unused <span class="enscript-type">int</span> *name = arg1;	<span class="enscript-comment">/* oid element argument vector */</span>
	__unused <span class="enscript-type">int</span> namelen = arg2;	<span class="enscript-comment">/* number of oid element arguments */</span>
	user_addr_t oldp = req-&gt;oldptr;	<span class="enscript-comment">/* user buffer copy out address */</span>
	size_t *oldlenp = &amp;req-&gt;oldlen;	<span class="enscript-comment">/* user buffer copy out size */</span>
	user_addr_t newp = req-&gt;newptr;	<span class="enscript-comment">/* user buffer copy in address */</span>
	size_t newlen = req-&gt;newlen;	<span class="enscript-comment">/* user buffer copy in size */</span>
	<span class="enscript-type">int</span> error;

	<span class="enscript-type">int</span> tmp;

	<span class="enscript-comment">/* valid values passed in:
	 * = 0 means don't keep called counts for each bsd syscall
	 * &gt; 0 means keep called counts for each bsd syscall
	 * = 2 means dump current counts to the system log
	 * = 3 means reset all counts
	 * for example, to dump current counts:  
	 *		sysctl -w kern.count_calls=2
	 */</span>
	error = sysctl_int(oldp, oldlenp, newp, newlen, &amp;tmp);
	<span class="enscript-keyword">if</span> ( error != 0 ) {
		<span class="enscript-keyword">return</span> (error);
	}
		
	<span class="enscript-keyword">if</span> ( tmp == 1 ) {
		do_count_syscalls = 1;
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ( tmp == 0 || tmp == 2 || tmp == 3 ) {
		<span class="enscript-type">int</span>			i;
		<span class="enscript-keyword">for</span> ( i = 0; i &lt; nsysent; i++ ) {
			<span class="enscript-keyword">if</span> ( syscalls_log[i] != 0 ) {
				<span class="enscript-keyword">if</span> ( tmp == 2 ) {
					printf(<span class="enscript-string">&quot;%d calls - name %s \n&quot;</span>, syscalls_log[i], syscallnames[i]);
				}
				<span class="enscript-keyword">else</span> {
					syscalls_log[i] = 0;
				}
			}
		}
		<span class="enscript-keyword">if</span> ( tmp != 0 ) {
			do_count_syscalls = 1;
		}
	}

	<span class="enscript-comment">/* adjust index so we return the right required/consumed amount */</span>
	<span class="enscript-keyword">if</span> (!error)
		req-&gt;oldidx += req-&gt;oldlen;

	<span class="enscript-keyword">return</span> (error);
}
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_COUNT_SYSCALLS, count_syscalls, CTLTYPE_NODE|CTLFLAG_RD | CTLFLAG_LOCKED,
	0,			<span class="enscript-comment">/* Pointer argument (arg1) */</span>
	0,			<span class="enscript-comment">/* Integer argument (arg2) */</span>
	sysctl_docountsyscalls,	<span class="enscript-comment">/* Handler function */</span>
	NULL,			<span class="enscript-comment">/* Data pointer */</span>
	<span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* COUNT_SYSCALLS */</span>

<span class="enscript-comment">/*
 * The following sysctl_* functions should not be used
 * any more, as they can only cope with callers in
 * user mode: Use new-style
 *  sysctl_io_number()
 *  sysctl_io_string()
 *  sysctl_io_opaque()
 * instead.
 */</span>

<span class="enscript-comment">/*
 * Validate parameters and get old / set new parameters
 * for an integer-valued sysctl function.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_int</span>(user_addr_t oldp, size_t *oldlenp, 
           user_addr_t newp, size_t newlen, <span class="enscript-type">int</span> *valp)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (oldp != USER_ADDR_NULL &amp;&amp; oldlenp == NULL)
		<span class="enscript-keyword">return</span> (EFAULT);
	<span class="enscript-keyword">if</span> (oldp &amp;&amp; *oldlenp &lt; <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>))
		<span class="enscript-keyword">return</span> (ENOMEM);
	<span class="enscript-keyword">if</span> (newp &amp;&amp; newlen != <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>))
		<span class="enscript-keyword">return</span> (EINVAL);
	*oldlenp = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>);
	<span class="enscript-keyword">if</span> (oldp)
		error = copyout(valp, oldp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; newp) {
		error = copyin(newp, valp, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
		AUDIT_ARG(value32, *valp);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Validate parameters and get old / set new parameters
 * for an quad(64bit)-valued sysctl function.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_quad</span>(user_addr_t oldp, size_t *oldlenp, 
            user_addr_t newp, size_t newlen, quad_t *valp)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (oldp != USER_ADDR_NULL &amp;&amp; oldlenp == NULL)
		<span class="enscript-keyword">return</span> (EFAULT);
	<span class="enscript-keyword">if</span> (oldp &amp;&amp; *oldlenp &lt; <span class="enscript-keyword">sizeof</span>(quad_t))
		<span class="enscript-keyword">return</span> (ENOMEM);
	<span class="enscript-keyword">if</span> (newp &amp;&amp; newlen != <span class="enscript-keyword">sizeof</span>(quad_t))
		<span class="enscript-keyword">return</span> (EINVAL);
	*oldlenp = <span class="enscript-keyword">sizeof</span>(quad_t);
	<span class="enscript-keyword">if</span> (oldp)
		error = copyout(valp, oldp, <span class="enscript-keyword">sizeof</span>(quad_t));
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; newp)
		error = copyin(newp, valp, <span class="enscript-keyword">sizeof</span>(quad_t));
	<span class="enscript-keyword">return</span> (error);
}

STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">sysdoproc_filt_KERN_PROC_PID</span>(proc_t p, <span class="enscript-type">void</span> * arg)
{
	<span class="enscript-keyword">if</span> (p-&gt;p_pid != (pid_t)*(<span class="enscript-type">int</span>*)arg)
		<span class="enscript-keyword">return</span>(0);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span>(1);
}

STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">sysdoproc_filt_KERN_PROC_PGRP</span>(proc_t p, <span class="enscript-type">void</span> * arg)
{
	<span class="enscript-keyword">if</span> (p-&gt;p_pgrpid != (pid_t)*(<span class="enscript-type">int</span>*)arg)
		<span class="enscript-keyword">return</span>(0);
	<span class="enscript-keyword">else</span>
	  <span class="enscript-keyword">return</span>(1);
}

STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">sysdoproc_filt_KERN_PROC_TTY</span>(proc_t p, <span class="enscript-type">void</span> * arg)
{
	<span class="enscript-type">int</span> retval;
	<span class="enscript-type">struct</span> tty *tp;

	<span class="enscript-comment">/* This is very racy but list lock is held.. Hmmm. */</span>
	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_CONTROLT) == 0 ||
		(p-&gt;p_pgrp == NULL) || (p-&gt;p_pgrp-&gt;pg_session == NULL) ||
			(tp = SESSION_TP(p-&gt;p_pgrp-&gt;pg_session)) == TTY_NULL ||
			tp-&gt;t_dev != (dev_t)*(<span class="enscript-type">int</span>*)arg)
				retval = 0;
	<span class="enscript-keyword">else</span>
		retval = 1;

	<span class="enscript-keyword">return</span>(retval);
}

STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">sysdoproc_filt_KERN_PROC_UID</span>(proc_t p, <span class="enscript-type">void</span> * arg)
{
	kauth_cred_t my_cred;
	uid_t uid;

	<span class="enscript-keyword">if</span> (p-&gt;p_ucred == NULL)
		<span class="enscript-keyword">return</span>(0);
	my_cred = kauth_cred_proc_ref(p);
	uid = kauth_cred_getuid(my_cred);
	kauth_cred_unref(&amp;my_cred);

	<span class="enscript-keyword">if</span> (uid != (uid_t)*(<span class="enscript-type">int</span>*)arg)
		<span class="enscript-keyword">return</span>(0);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span>(1);
}


STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">sysdoproc_filt_KERN_PROC_RUID</span>(proc_t p, <span class="enscript-type">void</span> * arg)
{
	kauth_cred_t my_cred;
	uid_t ruid;

	<span class="enscript-keyword">if</span> (p-&gt;p_ucred == NULL)
		<span class="enscript-keyword">return</span>(0);
	my_cred = kauth_cred_proc_ref(p);
	ruid = kauth_cred_getruid(my_cred);
	kauth_cred_unref(&amp;my_cred);

	<span class="enscript-keyword">if</span> (ruid != (uid_t)*(<span class="enscript-type">int</span>*)arg)
		<span class="enscript-keyword">return</span>(0);
	<span class="enscript-keyword">else</span>
		<span class="enscript-keyword">return</span>(1);
}

<span class="enscript-comment">/*
 * try over estimating by 5 procs
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">KERN_PROCSLOP</span>	(5 * sizeof (struct kinfo_proc))
<span class="enscript-type">struct</span> sysdoproc_args {
	<span class="enscript-type">int</span>	buflen;
	<span class="enscript-type">void</span>	*kprocp;
	boolean_t is_64_bit;
	user_addr_t	dp;
	size_t needed;
	<span class="enscript-type">int</span> sizeof_kproc;
	<span class="enscript-type">int</span> *errorp;
	<span class="enscript-type">int</span> uidcheck;
	<span class="enscript-type">int</span> ruidcheck;
	<span class="enscript-type">int</span> ttycheck;
	<span class="enscript-type">int</span> uidval;
};

<span class="enscript-type">int</span>
<span class="enscript-function-name">sysdoproc_callback</span>(proc_t p, <span class="enscript-type">void</span> *arg)
{
	<span class="enscript-type">struct</span> sysdoproc_args *args = arg;

	<span class="enscript-keyword">if</span> (args-&gt;buflen &gt;= args-&gt;sizeof_kproc) {
		<span class="enscript-keyword">if</span> ((args-&gt;ruidcheck != 0) &amp;&amp; (sysdoproc_filt_KERN_PROC_RUID(p, &amp;args-&gt;uidval) == 0))
			<span class="enscript-keyword">return</span> (PROC_RETURNED);
		<span class="enscript-keyword">if</span> ((args-&gt;uidcheck != 0) &amp;&amp; (sysdoproc_filt_KERN_PROC_UID(p, &amp;args-&gt;uidval) == 0))
			<span class="enscript-keyword">return</span> (PROC_RETURNED);
		<span class="enscript-keyword">if</span> ((args-&gt;ttycheck != 0) &amp;&amp; (sysdoproc_filt_KERN_PROC_TTY(p, &amp;args-&gt;uidval) == 0))
			<span class="enscript-keyword">return</span> (PROC_RETURNED);

		bzero(args-&gt;kprocp, args-&gt;sizeof_kproc);
		<span class="enscript-keyword">if</span> (args-&gt;is_64_bit)
			fill_user64_proc(p, args-&gt;kprocp);
		<span class="enscript-keyword">else</span>
			fill_user32_proc(p, args-&gt;kprocp);
		<span class="enscript-type">int</span> error = copyout(args-&gt;kprocp, args-&gt;dp, args-&gt;sizeof_kproc);
		<span class="enscript-keyword">if</span> (error) {
			*args-&gt;errorp = error;
			<span class="enscript-keyword">return</span> (PROC_RETURNED_DONE);
		}
		args-&gt;dp += args-&gt;sizeof_kproc;
		args-&gt;buflen -= args-&gt;sizeof_kproc;
	}
	args-&gt;needed += args-&gt;sizeof_kproc;
	<span class="enscript-keyword">return</span> (PROC_RETURNED);
}

<span class="enscript-function-name">SYSCTL_NODE</span>(_kern, KERN_PROC, proc, CTLFLAG_RD | CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;&quot;</span>);
STATIC <span class="enscript-type">int</span>
sysctl_prochandle SYSCTL_HANDLER_ARGS
{
	<span class="enscript-type">int</span> cmd = oidp-&gt;oid_arg2;	<span class="enscript-comment">/* subcommand for multiple nodes */</span>
	<span class="enscript-type">int</span> *name = arg1;		<span class="enscript-comment">/* oid element argument vector */</span>
	<span class="enscript-type">int</span> namelen = arg2;		<span class="enscript-comment">/* number of oid element arguments */</span>
	user_addr_t where = req-&gt;oldptr;<span class="enscript-comment">/* user buffer copy out address */</span>

	user_addr_t dp = where;
	size_t needed = 0;
	<span class="enscript-type">int</span> buflen = where != USER_ADDR_NULL ? req-&gt;oldlen : 0;
	<span class="enscript-type">int</span> error = 0;
	boolean_t is_64_bit = proc_is64bit(current_proc());
	<span class="enscript-type">struct</span> user32_kinfo_proc  user32_kproc;
	<span class="enscript-type">struct</span> user64_kinfo_proc  user_kproc;
	<span class="enscript-type">int</span> sizeof_kproc;
	<span class="enscript-type">void</span> *kprocp;
	<span class="enscript-type">int</span> (*filterfn)(proc_t, <span class="enscript-type">void</span> *) = 0;
	<span class="enscript-type">struct</span> sysdoproc_args args;
	<span class="enscript-type">int</span> uidcheck = 0;
	<span class="enscript-type">int</span> ruidcheck = 0;
	<span class="enscript-type">int</span> ttycheck = 0;

	<span class="enscript-keyword">if</span> (namelen != 1 &amp;&amp; !(namelen == 0 &amp;&amp; cmd == KERN_PROC_ALL))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (is_64_bit) {
		sizeof_kproc = <span class="enscript-keyword">sizeof</span>(user_kproc);
		kprocp = &amp;user_kproc;
	} <span class="enscript-keyword">else</span> {
		sizeof_kproc = <span class="enscript-keyword">sizeof</span>(user32_kproc);
		kprocp = &amp;user32_kproc;
	}

	<span class="enscript-keyword">switch</span> (cmd) {

		<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_PROC_PID</span>:
			filterfn = sysdoproc_filt_KERN_PROC_PID;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_PROC_PGRP</span>:
			filterfn = sysdoproc_filt_KERN_PROC_PGRP;
			<span class="enscript-keyword">break</span>;
	
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_PROC_TTY</span>:
			ttycheck = 1;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_PROC_UID</span>:
			uidcheck = 1;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_PROC_RUID</span>:
			ruidcheck = 1;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_PROC_ALL</span>:
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-comment">/* must be kern.proc.&lt;unknown&gt; */</span>
			<span class="enscript-keyword">return</span> (ENOTSUP);
	}

	error = 0;
	args.buflen = buflen;
	args.kprocp = kprocp;
	args.is_64_bit = is_64_bit;
	args.dp = dp;
	args.needed = needed;
	args.errorp = &amp;error;
	args.uidcheck = uidcheck;
	args.ruidcheck = ruidcheck;
	args.ttycheck = ttycheck;
	args.sizeof_kproc = sizeof_kproc;
	<span class="enscript-keyword">if</span> (namelen)
		args.uidval = name[0];

	proc_iterate((PROC_ALLPROCLIST | PROC_ZOMBPROCLIST),
	    sysdoproc_callback, &amp;args, filterfn, name);

	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);

	dp = args.dp;
	needed = args.needed;
	
	<span class="enscript-keyword">if</span> (where != USER_ADDR_NULL) {
		req-&gt;oldlen = dp - where;
		<span class="enscript-keyword">if</span> (needed &gt; req-&gt;oldlen)
			<span class="enscript-keyword">return</span> (ENOMEM);
	} <span class="enscript-keyword">else</span> {
		needed += KERN_PROCSLOP;
		req-&gt;oldlen = needed;
	}
	<span class="enscript-comment">/* adjust index so we return the right required/consumed amount */</span>
	req-&gt;oldidx += req-&gt;oldlen;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * We specify the subcommand code for multiple nodes as the 'req-&gt;arg2' value
 * in the sysctl declaration itself, which comes into the handler function
 * as 'oidp-&gt;oid_arg2'.
 *
 * For these particular sysctls, since they have well known OIDs, we could
 * have just obtained it from the '((int *)arg1)[0]' parameter, but that would
 * not demonstrate how to handle multiple sysctls that used OID_AUTO instead
 * of a well known value with a common handler function.  This is desirable,
 * because we want well known values to &quot;go away&quot; at some future date.
 *
 * It should be noted that the value of '((int *)arg1)[1]' is used for many
 * an integer parameter to the subcommand for many of these sysctls; we'd
 * rather have used '((int *)arg1)[0]' for that, or even better, an element
 * in a structure passed in as the the 'newp' argument to sysctlbyname(3),
 * and then use leaf-node permissions enforcement, but that would have
 * necessitated modifying user space code to correspond to the interface
 * change, and we are striving for binary backward compatibility here; even
 * though these are SPI, and not intended for use by user space applications
 * which are not themselves system tools or libraries, some applications
 * have erroneously used them.
 */</span>
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_proc, KERN_PROC_ALL, all, CTLTYPE_NODE|CTLFLAG_RD | CTLFLAG_LOCKED,
	0,			<span class="enscript-comment">/* Pointer argument (arg1) */</span>
	KERN_PROC_ALL,		<span class="enscript-comment">/* Integer argument (arg2) */</span>
	sysctl_prochandle,	<span class="enscript-comment">/* Handler function */</span>
	NULL,			<span class="enscript-comment">/* Data is size variant on ILP32/LP64 */</span>
	<span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_proc, KERN_PROC_PID, pid, CTLTYPE_NODE|CTLFLAG_RD | CTLFLAG_LOCKED,
	0,			<span class="enscript-comment">/* Pointer argument (arg1) */</span>
	KERN_PROC_PID,		<span class="enscript-comment">/* Integer argument (arg2) */</span>
	sysctl_prochandle,	<span class="enscript-comment">/* Handler function */</span>
	NULL,			<span class="enscript-comment">/* Data is size variant on ILP32/LP64 */</span>
	<span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_proc, KERN_PROC_TTY, tty, CTLTYPE_NODE|CTLFLAG_RD | CTLFLAG_LOCKED,
	0,			<span class="enscript-comment">/* Pointer argument (arg1) */</span>
	KERN_PROC_TTY,		<span class="enscript-comment">/* Integer argument (arg2) */</span>
	sysctl_prochandle,	<span class="enscript-comment">/* Handler function */</span>
	NULL,			<span class="enscript-comment">/* Data is size variant on ILP32/LP64 */</span>
	<span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_proc, KERN_PROC_PGRP, pgrp, CTLTYPE_NODE|CTLFLAG_RD | CTLFLAG_LOCKED,
	0,			<span class="enscript-comment">/* Pointer argument (arg1) */</span>
	KERN_PROC_PGRP,		<span class="enscript-comment">/* Integer argument (arg2) */</span>
	sysctl_prochandle,	<span class="enscript-comment">/* Handler function */</span>
	NULL,			<span class="enscript-comment">/* Data is size variant on ILP32/LP64 */</span>
	<span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_proc, KERN_PROC_UID, uid, CTLTYPE_NODE|CTLFLAG_RD | CTLFLAG_LOCKED,
	0,			<span class="enscript-comment">/* Pointer argument (arg1) */</span>
	KERN_PROC_UID,		<span class="enscript-comment">/* Integer argument (arg2) */</span>
	sysctl_prochandle,	<span class="enscript-comment">/* Handler function */</span>
	NULL,			<span class="enscript-comment">/* Data is size variant on ILP32/LP64 */</span>
	<span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_proc, KERN_PROC_RUID, ruid, CTLTYPE_NODE|CTLFLAG_RD | CTLFLAG_LOCKED,
	0,			<span class="enscript-comment">/* Pointer argument (arg1) */</span>
	KERN_PROC_RUID,		<span class="enscript-comment">/* Integer argument (arg2) */</span>
	sysctl_prochandle,	<span class="enscript-comment">/* Handler function */</span>
	NULL,			<span class="enscript-comment">/* Data is size variant on ILP32/LP64 */</span>
	<span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_proc, KERN_PROC_LCID, lcid, CTLTYPE_NODE|CTLFLAG_RD | CTLFLAG_LOCKED,
	0,			<span class="enscript-comment">/* Pointer argument (arg1) */</span>
	KERN_PROC_LCID,		<span class="enscript-comment">/* Integer argument (arg2) */</span>
	sysctl_prochandle,	<span class="enscript-comment">/* Handler function */</span>
	NULL,			<span class="enscript-comment">/* Data is size variant on ILP32/LP64 */</span>
	<span class="enscript-string">&quot;&quot;</span>);


<span class="enscript-comment">/*
 * Fill in non-zero fields of an eproc structure for the specified process.
 */</span>
STATIC <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_user32_eproc</span>(proc_t p, <span class="enscript-type">struct</span> user32_eproc *__restrict ep)
{
	<span class="enscript-type">struct</span> tty *tp;
	<span class="enscript-type">struct</span> pgrp *pg;
	<span class="enscript-type">struct</span> session *sessp;
	kauth_cred_t my_cred;

	pg = proc_pgrp(p);
	sessp = proc_session(p);

	<span class="enscript-keyword">if</span> (pg != PGRP_NULL) {
		ep-&gt;e_pgid = p-&gt;p_pgrpid;
		ep-&gt;e_jobc = pg-&gt;pg_jobc;
		<span class="enscript-keyword">if</span> (sessp != SESSION_NULL &amp;&amp; sessp-&gt;s_ttyvp)
			ep-&gt;e_flag = EPROC_CTTY;
	}
	ep-&gt;e_ppid = p-&gt;p_ppid;
	<span class="enscript-keyword">if</span> (p-&gt;p_ucred) {
		my_cred = kauth_cred_proc_ref(p);

		<span class="enscript-comment">/* A fake historical pcred */</span>
		ep-&gt;e_pcred.p_ruid = kauth_cred_getruid(my_cred);
		ep-&gt;e_pcred.p_svuid = kauth_cred_getsvuid(my_cred);
		ep-&gt;e_pcred.p_rgid = kauth_cred_getrgid(my_cred);
		ep-&gt;e_pcred.p_svgid = kauth_cred_getsvgid(my_cred);

		<span class="enscript-comment">/* A fake historical *kauth_cred_t */</span>
		ep-&gt;e_ucred.cr_ref = my_cred-&gt;cr_ref;
		ep-&gt;e_ucred.cr_uid = kauth_cred_getuid(my_cred);
		ep-&gt;e_ucred.cr_ngroups = posix_cred_get(my_cred)-&gt;cr_ngroups;
		bcopy(posix_cred_get(my_cred)-&gt;cr_groups,
			ep-&gt;e_ucred.cr_groups, NGROUPS * <span class="enscript-keyword">sizeof</span> (gid_t));

		kauth_cred_unref(&amp;my_cred);
	}

	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_CONTROLT) &amp;&amp; (sessp != SESSION_NULL) &amp;&amp;
	     (tp = SESSION_TP(sessp))) {
		ep-&gt;e_tdev = tp-&gt;t_dev;
		ep-&gt;e_tpgid = sessp-&gt;s_ttypgrpid;
	} <span class="enscript-keyword">else</span>
		ep-&gt;e_tdev = NODEV;

	<span class="enscript-keyword">if</span> (sessp != SESSION_NULL) {
		<span class="enscript-keyword">if</span> (SESS_LEADER(p, sessp))
			ep-&gt;e_flag |= EPROC_SLEADER;
		session_rele(sessp);
	}
	<span class="enscript-keyword">if</span> (pg != PGRP_NULL)
		pg_rele(pg);
}

<span class="enscript-comment">/*
 * Fill in non-zero fields of an LP64 eproc structure for the specified process.
 */</span>
STATIC <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_user64_eproc</span>(proc_t p, <span class="enscript-type">struct</span> user64_eproc *__restrict ep)
{
	<span class="enscript-type">struct</span> tty *tp;
	<span class="enscript-type">struct</span> pgrp *pg;
	<span class="enscript-type">struct</span> session *sessp;
	kauth_cred_t my_cred;
	
	pg = proc_pgrp(p);
	sessp = proc_session(p);

	<span class="enscript-keyword">if</span> (pg != PGRP_NULL) {
		ep-&gt;e_pgid = p-&gt;p_pgrpid;
		ep-&gt;e_jobc = pg-&gt;pg_jobc;
		<span class="enscript-keyword">if</span> (sessp != SESSION_NULL &amp;&amp; sessp-&gt;s_ttyvp)
			ep-&gt;e_flag = EPROC_CTTY;
	}
	ep-&gt;e_ppid = p-&gt;p_ppid;
	<span class="enscript-keyword">if</span> (p-&gt;p_ucred) {
		my_cred = kauth_cred_proc_ref(p);

		<span class="enscript-comment">/* A fake historical pcred */</span>
		ep-&gt;e_pcred.p_ruid = kauth_cred_getruid(my_cred);
		ep-&gt;e_pcred.p_svuid = kauth_cred_getsvuid(my_cred);
		ep-&gt;e_pcred.p_rgid = kauth_cred_getrgid(my_cred);
		ep-&gt;e_pcred.p_svgid = kauth_cred_getsvgid(my_cred);

		<span class="enscript-comment">/* A fake historical *kauth_cred_t */</span>
		ep-&gt;e_ucred.cr_ref = my_cred-&gt;cr_ref;
		ep-&gt;e_ucred.cr_uid = kauth_cred_getuid(my_cred);
		ep-&gt;e_ucred.cr_ngroups = posix_cred_get(my_cred)-&gt;cr_ngroups;
		bcopy(posix_cred_get(my_cred)-&gt;cr_groups,
			ep-&gt;e_ucred.cr_groups, NGROUPS * <span class="enscript-keyword">sizeof</span> (gid_t));

		kauth_cred_unref(&amp;my_cred);
	}

	<span class="enscript-keyword">if</span> ((p-&gt;p_flag &amp; P_CONTROLT) &amp;&amp; (sessp != SESSION_NULL) &amp;&amp;
	     (tp = SESSION_TP(sessp))) {
		ep-&gt;e_tdev = tp-&gt;t_dev;
		ep-&gt;e_tpgid = sessp-&gt;s_ttypgrpid;
	} <span class="enscript-keyword">else</span>
		ep-&gt;e_tdev = NODEV;

	<span class="enscript-keyword">if</span> (sessp != SESSION_NULL) {
		<span class="enscript-keyword">if</span> (SESS_LEADER(p, sessp))
			ep-&gt;e_flag |= EPROC_SLEADER;
		session_rele(sessp);
	}
	<span class="enscript-keyword">if</span> (pg != PGRP_NULL)
		pg_rele(pg);
}

<span class="enscript-comment">/*
 * Fill in an eproc structure for the specified process.
 * bzeroed by our caller, so only set non-zero fields.
 */</span>
STATIC <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_user32_externproc</span>(proc_t p, <span class="enscript-type">struct</span> user32_extern_proc *__restrict exp)
{
	exp-&gt;p_starttime.tv_sec = p-&gt;p_start.tv_sec;
	exp-&gt;p_starttime.tv_usec = p-&gt;p_start.tv_usec;
	exp-&gt;p_flag = p-&gt;p_flag;
	<span class="enscript-keyword">if</span> (p-&gt;p_lflag &amp; P_LTRACED)
		exp-&gt;p_flag |= P_TRACED;
	<span class="enscript-keyword">if</span> (p-&gt;p_lflag &amp; P_LPPWAIT)
		exp-&gt;p_flag |= P_PPWAIT;
	<span class="enscript-keyword">if</span> (p-&gt;p_lflag &amp; P_LEXIT)
		exp-&gt;p_flag |= P_WEXIT;
	exp-&gt;p_stat = p-&gt;p_stat;
	exp-&gt;p_pid = p-&gt;p_pid;
	exp-&gt;p_oppid = p-&gt;p_oppid;
	<span class="enscript-comment">/* Mach related  */</span>
	exp-&gt;user_stack = p-&gt;user_stack;
	exp-&gt;p_debugger = p-&gt;p_debugger;
	exp-&gt;sigwait = p-&gt;sigwait;
	<span class="enscript-comment">/* scheduling */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_PROC_HAS_SCHEDINFO_</span>
	exp-&gt;p_estcpu = p-&gt;p_estcpu;
	exp-&gt;p_pctcpu = p-&gt;p_pctcpu;
	exp-&gt;p_slptime = p-&gt;p_slptime;
#<span class="enscript-reference">endif</span>
	exp-&gt;p_realtimer.it_interval.tv_sec =
		(user32_time_t)p-&gt;p_realtimer.it_interval.tv_sec;
	exp-&gt;p_realtimer.it_interval.tv_usec =
		(__int32_t)p-&gt;p_realtimer.it_interval.tv_usec;

	exp-&gt;p_realtimer.it_value.tv_sec =
		(user32_time_t)p-&gt;p_realtimer.it_value.tv_sec;
	exp-&gt;p_realtimer.it_value.tv_usec =
		(__int32_t)p-&gt;p_realtimer.it_value.tv_usec;

	exp-&gt;p_rtime.tv_sec = (user32_time_t)p-&gt;p_rtime.tv_sec;
	exp-&gt;p_rtime.tv_usec = (__int32_t)p-&gt;p_rtime.tv_usec;

	exp-&gt;p_sigignore = p-&gt;p_sigignore;
	exp-&gt;p_sigcatch = p-&gt;p_sigcatch;
	exp-&gt;p_priority = p-&gt;p_priority;
	exp-&gt;p_nice = p-&gt;p_nice;
	bcopy(&amp;p-&gt;p_comm, &amp;exp-&gt;p_comm, MAXCOMLEN);
	exp-&gt;p_xstat = p-&gt;p_xstat;
	exp-&gt;p_acflag = p-&gt;p_acflag;
}

<span class="enscript-comment">/*
 * Fill in an LP64 version of extern_proc structure for the specified process.
 */</span>
STATIC <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_user64_externproc</span>(proc_t p, <span class="enscript-type">struct</span> user64_extern_proc *__restrict exp)
{
	exp-&gt;p_starttime.tv_sec = p-&gt;p_start.tv_sec;
	exp-&gt;p_starttime.tv_usec = p-&gt;p_start.tv_usec;
	exp-&gt;p_flag = p-&gt;p_flag;
	<span class="enscript-keyword">if</span> (p-&gt;p_lflag &amp; P_LTRACED)
		exp-&gt;p_flag |= P_TRACED;
	<span class="enscript-keyword">if</span> (p-&gt;p_lflag &amp; P_LPPWAIT)
		exp-&gt;p_flag |= P_PPWAIT;
	<span class="enscript-keyword">if</span> (p-&gt;p_lflag &amp; P_LEXIT)
		exp-&gt;p_flag |= P_WEXIT;
	exp-&gt;p_stat = p-&gt;p_stat;
	exp-&gt;p_pid = p-&gt;p_pid;
	exp-&gt;p_oppid = p-&gt;p_oppid;
	<span class="enscript-comment">/* Mach related  */</span>
	exp-&gt;user_stack = p-&gt;user_stack;
	exp-&gt;p_debugger = p-&gt;p_debugger;
	exp-&gt;sigwait = p-&gt;sigwait;
	<span class="enscript-comment">/* scheduling */</span>
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">_PROC_HAS_SCHEDINFO_</span>
	exp-&gt;p_estcpu = p-&gt;p_estcpu;
	exp-&gt;p_pctcpu = p-&gt;p_pctcpu;
	exp-&gt;p_slptime = p-&gt;p_slptime;
#<span class="enscript-reference">endif</span>
	exp-&gt;p_realtimer.it_interval.tv_sec = p-&gt;p_realtimer.it_interval.tv_sec;
	exp-&gt;p_realtimer.it_interval.tv_usec = p-&gt;p_realtimer.it_interval.tv_usec;

	exp-&gt;p_realtimer.it_value.tv_sec = p-&gt;p_realtimer.it_value.tv_sec;
	exp-&gt;p_realtimer.it_value.tv_usec = p-&gt;p_realtimer.it_value.tv_usec;

	exp-&gt;p_rtime.tv_sec = p-&gt;p_rtime.tv_sec;
	exp-&gt;p_rtime.tv_usec = p-&gt;p_rtime.tv_usec;

	exp-&gt;p_sigignore = p-&gt;p_sigignore;
	exp-&gt;p_sigcatch = p-&gt;p_sigcatch;
	exp-&gt;p_priority = p-&gt;p_priority;
	exp-&gt;p_nice = p-&gt;p_nice;
	bcopy(&amp;p-&gt;p_comm, &amp;exp-&gt;p_comm, MAXCOMLEN);
	exp-&gt;p_xstat = p-&gt;p_xstat;
	exp-&gt;p_acflag = p-&gt;p_acflag;
}

STATIC <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_user32_proc</span>(proc_t p, <span class="enscript-type">struct</span> user32_kinfo_proc *__restrict kp)
{
	<span class="enscript-comment">/* on a 64 bit kernel, 32 bit users get some truncated information */</span>
	fill_user32_externproc(p, &amp;kp-&gt;kp_proc);
	fill_user32_eproc(p, &amp;kp-&gt;kp_eproc);
}

STATIC <span class="enscript-type">void</span>
<span class="enscript-function-name">fill_user64_proc</span>(proc_t p, <span class="enscript-type">struct</span> user64_kinfo_proc *__restrict kp)
{
	fill_user64_externproc(p, &amp;kp-&gt;kp_proc);
	fill_user64_eproc(p, &amp;kp-&gt;kp_eproc);
}

STATIC <span class="enscript-type">int</span>
sysctl_kdebug_ops SYSCTL_HANDLER_ARGS
{
	__unused <span class="enscript-type">int</span> cmd = oidp-&gt;oid_arg2;	<span class="enscript-comment">/* subcommand*/</span>
	<span class="enscript-type">int</span> *name = arg1;		<span class="enscript-comment">/* oid element argument vector */</span>
	<span class="enscript-type">int</span> namelen = arg2;		<span class="enscript-comment">/* number of oid element arguments */</span>
	user_addr_t oldp = req-&gt;oldptr;	<span class="enscript-comment">/* user buffer copy out address */</span>
	size_t *oldlenp = &amp;req-&gt;oldlen;	<span class="enscript-comment">/* user buffer copy out size */</span>
<span class="enscript-comment">//	user_addr_t newp = req-&gt;newptr;	/* user buffer copy in address */
</span><span class="enscript-comment">//	size_t newlen = req-&gt;newlen;	/* user buffer copy in size */
</span>
	proc_t p = current_proc();
	<span class="enscript-type">int</span> ret=0;

	<span class="enscript-keyword">if</span> (namelen == 0)
		<span class="enscript-keyword">return</span>(ENOTSUP);
	
	ret = suser(kauth_cred_get(), &amp;p-&gt;p_acflag);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">KPERF</span>
	<span class="enscript-comment">/* Non-root processes may be blessed by kperf to access data
	 * logged into trace.
	 */</span>
	<span class="enscript-keyword">if</span> (ret)
		ret = kperf_access_check();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* KPERF */</span>
	<span class="enscript-keyword">if</span> (ret)
		<span class="enscript-keyword">return</span>(ret);
	
	<span class="enscript-keyword">switch</span>(name[0]) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDEFLAGS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDDFLAGS</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDENABLE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDGETBUF</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDSETUP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDREMOVE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDSETREG</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDGETREG</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDREADTR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDWRITETR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDWRITEMAP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDPIDTR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDTHRMAP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDPIDEX</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDSETRTCDEC</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDSETBUF</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDGETENTROPY</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDENABLE_BG_TRACE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDDISABLE_BG_TRACE</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDREADCURTHRMAP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDSET_TYPEFILTER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDBUFWAIT</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDCPUMAP</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDWAIT_BG_TRACE_RESET</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDSET_BG_TYPEFILTER</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDWRITEMAP_V3</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_KDWRITETR_V3</span>:
	        ret = kdbg_control(name, namelen, oldp, oldlenp);
	        <span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		ret= ENOTSUP;
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/* adjust index so we return the right required/consumed amount */</span>
	<span class="enscript-keyword">if</span> (!ret)
		req-&gt;oldidx += req-&gt;oldlen;

	<span class="enscript-keyword">return</span> (ret);
}
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_KDEBUG, kdebug, CTLTYPE_NODE|CTLFLAG_RD | CTLFLAG_LOCKED,
	0,			<span class="enscript-comment">/* Pointer argument (arg1) */</span>
	0,			<span class="enscript-comment">/* Integer argument (arg2) */</span>
	sysctl_kdebug_ops,	<span class="enscript-comment">/* Handler function */</span>
	NULL,			<span class="enscript-comment">/* Data pointer */</span>
	<span class="enscript-string">&quot;&quot;</span>);


<span class="enscript-comment">/*
 * Return the top *sizep bytes of the user stack, or the entire area of the
 * user stack down through the saved exec_path, whichever is smaller.
 */</span>
STATIC <span class="enscript-type">int</span>
sysctl_doprocargs SYSCTL_HANDLER_ARGS
{
	__unused <span class="enscript-type">int</span> cmd = oidp-&gt;oid_arg2;	<span class="enscript-comment">/* subcommand*/</span>
	<span class="enscript-type">int</span> *name = arg1;		<span class="enscript-comment">/* oid element argument vector */</span>
	<span class="enscript-type">int</span> namelen = arg2;		<span class="enscript-comment">/* number of oid element arguments */</span>
	user_addr_t oldp = req-&gt;oldptr;	<span class="enscript-comment">/* user buffer copy out address */</span>
	size_t *oldlenp = &amp;req-&gt;oldlen;	<span class="enscript-comment">/* user buffer copy out size */</span>
<span class="enscript-comment">//	user_addr_t newp = req-&gt;newptr;	/* user buffer copy in address */
</span><span class="enscript-comment">//	size_t newlen = req-&gt;newlen;	/* user buffer copy in size */
</span>	<span class="enscript-type">int</span> error;

	error =  sysctl_procargsx( name, namelen, oldp, oldlenp, current_proc(), 0);

	<span class="enscript-comment">/* adjust index so we return the right required/consumed amount */</span>
	<span class="enscript-keyword">if</span> (!error)
		req-&gt;oldidx += req-&gt;oldlen;

	<span class="enscript-keyword">return</span> (error);
}
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_PROCARGS, procargs, CTLTYPE_NODE|CTLFLAG_RD | CTLFLAG_LOCKED,
	0,			<span class="enscript-comment">/* Pointer argument (arg1) */</span>
	0,			<span class="enscript-comment">/* Integer argument (arg2) */</span>
	sysctl_doprocargs,	<span class="enscript-comment">/* Handler function */</span>
	NULL,			<span class="enscript-comment">/* Data pointer */</span>
	<span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
sysctl_doprocargs2 SYSCTL_HANDLER_ARGS
{
	__unused <span class="enscript-type">int</span> cmd = oidp-&gt;oid_arg2;	<span class="enscript-comment">/* subcommand*/</span>
	<span class="enscript-type">int</span> *name = arg1;		<span class="enscript-comment">/* oid element argument vector */</span>
	<span class="enscript-type">int</span> namelen = arg2;		<span class="enscript-comment">/* number of oid element arguments */</span>
	user_addr_t oldp = req-&gt;oldptr;	<span class="enscript-comment">/* user buffer copy out address */</span>
	size_t *oldlenp = &amp;req-&gt;oldlen;	<span class="enscript-comment">/* user buffer copy out size */</span>
<span class="enscript-comment">//	user_addr_t newp = req-&gt;newptr;	/* user buffer copy in address */
</span><span class="enscript-comment">//	size_t newlen = req-&gt;newlen;	/* user buffer copy in size */
</span>	<span class="enscript-type">int</span> error;

	error = sysctl_procargsx( name, namelen, oldp, oldlenp, current_proc(), 1);

	<span class="enscript-comment">/* adjust index so we return the right required/consumed amount */</span>
	<span class="enscript-keyword">if</span> (!error)
		req-&gt;oldidx += req-&gt;oldlen;

	<span class="enscript-keyword">return</span> (error);
}
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_PROCARGS2, procargs2, CTLTYPE_NODE|CTLFLAG_RD | CTLFLAG_LOCKED,
	0,			<span class="enscript-comment">/* Pointer argument (arg1) */</span>
	0,			<span class="enscript-comment">/* Integer argument (arg2) */</span>
	sysctl_doprocargs2,	<span class="enscript-comment">/* Handler function */</span>
	NULL,			<span class="enscript-comment">/* Data pointer */</span>
	<span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_procargsx</span>(<span class="enscript-type">int</span> *name, u_int namelen, user_addr_t where, 
                 size_t *sizep, proc_t cur_proc, <span class="enscript-type">int</span> argc_yes)
{
	proc_t p;
	<span class="enscript-type">int</span> buflen = where != USER_ADDR_NULL ? *sizep : 0;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> _vm_map *proc_map;
	<span class="enscript-type">struct</span> task * task;
	vm_map_copy_t	tmp;
	user_addr_t	arg_addr;
	size_t		arg_size;
	caddr_t data;
	size_t argslen=0;
	<span class="enscript-type">int</span> size;
	vm_offset_t	copy_start, copy_end;
	kern_return_t ret;
	<span class="enscript-type">int</span> pid;
	kauth_cred_t my_cred;
	uid_t uid;

	<span class="enscript-keyword">if</span> ( namelen &lt; 1 )
		<span class="enscript-keyword">return</span>(EINVAL);
	
	<span class="enscript-keyword">if</span> (argc_yes)
		buflen -= <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>);		<span class="enscript-comment">/* reserve first word to return argc */</span>

	<span class="enscript-comment">/* we only care about buflen when where (oldp from sysctl) is not NULL. */</span>
	<span class="enscript-comment">/* when where (oldp from sysctl) is NULL and sizep (oldlenp from sysctl */</span>
	<span class="enscript-comment">/* is not NULL then the caller wants us to return the length needed to */</span>
	<span class="enscript-comment">/* hold the data we would return */</span> 
	<span class="enscript-keyword">if</span> (where != USER_ADDR_NULL &amp;&amp; (buflen &lt;= 0 || buflen &gt; ARG_MAX)) {
		<span class="enscript-keyword">return</span>(EINVAL);
	}
	arg_size = buflen;

	<span class="enscript-comment">/*
	 *	Lookup process by pid
	 */</span>
	pid = name[0];
	p = proc_find(pid);
	<span class="enscript-keyword">if</span> (p == NULL) {
		<span class="enscript-keyword">return</span>(EINVAL);
	}

	<span class="enscript-comment">/*
	 *	Copy the top N bytes of the stack.
	 *	On all machines we have so far, the stack grows
	 *	downwards.
	 *
	 *	If the user expects no more than N bytes of
	 *	argument list, use that as a guess for the
	 *	size.
	 */</span>

	<span class="enscript-keyword">if</span> (!p-&gt;user_stack) {
		proc_rele(p);
		<span class="enscript-keyword">return</span>(EINVAL);
	}

	<span class="enscript-keyword">if</span> (where == USER_ADDR_NULL) {
		<span class="enscript-comment">/* caller only wants to know length of proc args data */</span>
		<span class="enscript-keyword">if</span> (sizep == NULL) {
			proc_rele(p);
			<span class="enscript-keyword">return</span>(EFAULT);
		}
			
		 size = p-&gt;p_argslen;
		proc_rele(p);
		 <span class="enscript-keyword">if</span> (argc_yes) {
		 	size += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>);
		 }
		 <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * old PROCARGS will return the executable's path and plus some
			 * extra space for work alignment and data tags
			 */</span>
		 	size += PATH_MAX + (6 * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));
		 }
		size += (size &amp; (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>) - 1)) ? (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>) - (size &amp; (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>) - 1))) : 0;
		*sizep = size;
		<span class="enscript-keyword">return</span> (0);
	}
	
	my_cred = kauth_cred_proc_ref(p);
	uid = kauth_cred_getuid(my_cred);
	kauth_cred_unref(&amp;my_cred);

	<span class="enscript-keyword">if</span> ((uid != kauth_cred_getuid(kauth_cred_get())) 
		&amp;&amp; suser(kauth_cred_get(), &amp;cur_proc-&gt;p_acflag)) {
		proc_rele(p);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> ((u_int)arg_size &gt; p-&gt;p_argslen)
	        arg_size = round_page(p-&gt;p_argslen);

	arg_addr = p-&gt;user_stack - arg_size;


	<span class="enscript-comment">/*
	 *	Before we can block (any VM code), make another
	 *	reference to the map to keep it alive.  We do
	 *	that by getting a reference on the task itself.
	 */</span>
	task = p-&gt;task;
	<span class="enscript-keyword">if</span> (task == NULL) {
		proc_rele(p);
		<span class="enscript-keyword">return</span>(EINVAL);
	}
	
	argslen = p-&gt;p_argslen;
	<span class="enscript-comment">/*
	 * Once we have a task reference we can convert that into a
	 * map reference, which we will use in the calls below.  The
	 * task/process may change its map after we take this reference
	 * (see execve), but the worst that will happen then is a return
	 * of stale info (which is always a possibility).
	 */</span>
	task_reference(task);
	proc_rele(p);
	proc_map = get_task_map_reference(task);
	task_deallocate(task);
	
	<span class="enscript-keyword">if</span> (proc_map == NULL)
		<span class="enscript-keyword">return</span>(EINVAL);


	ret = kmem_alloc(kernel_map, &amp;copy_start, round_page(arg_size), VM_KERN_MEMORY_BSD);
	<span class="enscript-keyword">if</span> (ret != KERN_SUCCESS) {
		vm_map_deallocate(proc_map);
		<span class="enscript-keyword">return</span>(ENOMEM);
	}

	copy_end = round_page(copy_start + arg_size);

	<span class="enscript-keyword">if</span>( vm_map_copyin(proc_map, (vm_map_address_t)arg_addr, 
			  (vm_map_size_t)arg_size, FALSE, &amp;tmp) != KERN_SUCCESS) {
			vm_map_deallocate(proc_map);
			kmem_free(kernel_map, copy_start,
					round_page(arg_size));
			<span class="enscript-keyword">return</span> (EIO);
	}

	<span class="enscript-comment">/*
	 *	Now that we've done the copyin from the process'
	 *	map, we can release the reference to it.
	 */</span>
	vm_map_deallocate(proc_map);

	<span class="enscript-keyword">if</span>( vm_map_copy_overwrite(kernel_map, 
				  (vm_map_address_t)copy_start, 
				  tmp, FALSE) != KERN_SUCCESS) {
			kmem_free(kernel_map, copy_start,
					round_page(arg_size));
			<span class="enscript-keyword">return</span> (EIO);
	}

	<span class="enscript-keyword">if</span> (arg_size &gt; argslen) {
		data = (caddr_t) (copy_end - argslen);
		size = argslen;
	} <span class="enscript-keyword">else</span> {
		data = (caddr_t) (copy_end - arg_size);
		size = arg_size;
	}

	<span class="enscript-comment">/*
	 * When these sysctls were introduced, the first string in the strings
	 * section was just the bare path of the executable.  However, for security
	 * reasons we now prefix this string with executable_path= so it can be
	 * parsed getenv style.  To avoid binary compatability issues with exising
	 * callers of this sysctl, we strip it off here if present.
	 * (rdar://problem/13746466)
	 */</span>
#<span class="enscript-reference">define</span>        <span class="enscript-variable-name">EXECUTABLE_KEY</span> <span class="enscript-string">&quot;executable_path=&quot;</span>
	<span class="enscript-keyword">if</span> (strncmp(EXECUTABLE_KEY, data, strlen(EXECUTABLE_KEY)) == 0){
		data += strlen(EXECUTABLE_KEY);
		size -= strlen(EXECUTABLE_KEY);
	}

	<span class="enscript-keyword">if</span> (argc_yes) {
		<span class="enscript-comment">/* Put processes argc as the first word in the copyout buffer */</span>
		suword(where, p-&gt;p_argc);
		error = copyout(data, (where + <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)), size);
		size += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>);
	} <span class="enscript-keyword">else</span> {
		error = copyout(data, where, size);

		<span class="enscript-comment">/*
		 * Make the old PROCARGS work to return the executable's path
		 * But, only if there is enough space in the provided buffer
		 *
		 * on entry: data [possibily] points to the beginning of the path 
		 * 
		 * Note: we keep all pointers&amp;sizes aligned to word boundries
		 */</span>
		<span class="enscript-keyword">if</span> ( (! error) &amp;&amp; (buflen &gt; 0 &amp;&amp; (u_int)buflen &gt; argslen) )
		{
			<span class="enscript-type">int</span> binPath_sz, alignedBinPath_sz = 0;
			<span class="enscript-type">int</span> extraSpaceNeeded, addThis;
			user_addr_t placeHere;
			<span class="enscript-type">char</span> * str = (<span class="enscript-type">char</span> *) data;
			<span class="enscript-type">int</span> max_len = size;

			<span class="enscript-comment">/* Some apps are really bad about messing up their stacks
			   So, we have to be extra careful about getting the length
			   of the executing binary.  If we encounter an error, we bail.
			*/</span>

			<span class="enscript-comment">/* Limit ourselves to PATH_MAX paths */</span>
			<span class="enscript-keyword">if</span> ( max_len &gt; PATH_MAX ) max_len = PATH_MAX;

			binPath_sz = 0;

			<span class="enscript-keyword">while</span> ( (binPath_sz &lt; max_len-1) &amp;&amp; (*str++ != 0) )
				binPath_sz++;

			<span class="enscript-comment">/* If we have a NUL terminator, copy it, too */</span>
			<span class="enscript-keyword">if</span> (binPath_sz &lt; max_len-1) binPath_sz += 1;

			<span class="enscript-comment">/* Pre-Flight the space requiremnts */</span>

			<span class="enscript-comment">/* Account for the padding that fills out binPath to the next word */</span>
			alignedBinPath_sz += (binPath_sz &amp; (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)-1)) ? (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)-(binPath_sz &amp; (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)-1))) : 0;

			placeHere = where + size;

			<span class="enscript-comment">/* Account for the bytes needed to keep placeHere word aligned */</span> 
			addThis = (placeHere &amp; (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)-1)) ? (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)-(placeHere &amp; (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)-1))) : 0;

			<span class="enscript-comment">/* Add up all the space that is needed */</span>
			extraSpaceNeeded = alignedBinPath_sz + addThis + binPath_sz + (4 * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>));

			<span class="enscript-comment">/* is there is room to tack on argv[0]? */</span>
			<span class="enscript-keyword">if</span> ( (buflen &amp; ~(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>)-1)) &gt;= ( argslen + extraSpaceNeeded ))
			{
				placeHere += addThis;
				suword(placeHere, 0);
				placeHere += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>);
				suword(placeHere, 0xBFFF0000);
				placeHere += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>);
				suword(placeHere, 0);
				placeHere += <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>);
				error = copyout(data, placeHere, binPath_sz);
				<span class="enscript-keyword">if</span> ( ! error )
				{
					placeHere += binPath_sz;
					suword(placeHere, 0);
					size += extraSpaceNeeded;
				}
			}
		}
	}

	<span class="enscript-keyword">if</span> (copy_start != (vm_offset_t) 0) {
		kmem_free(kernel_map, copy_start, copy_end - copy_start);
	}
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">return</span>(error);
	}

	<span class="enscript-keyword">if</span> (where != USER_ADDR_NULL)
		*sizep = size;
	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-comment">/*
 * Max number of concurrent aio requests
 */</span>
STATIC <span class="enscript-type">int</span>
sysctl_aiomax
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> new_value, changed;
	<span class="enscript-type">int</span> error = sysctl_io_number(req, aio_max_requests, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);
	<span class="enscript-keyword">if</span> (changed) {
		 <span class="enscript-comment">/* make sure the system-wide limit is greater than the per process limit */</span>
		<span class="enscript-keyword">if</span> (new_value &gt;= aio_max_requests_per_process &amp;&amp; new_value &lt;= AIO_MAX_REQUESTS)
			aio_max_requests = new_value;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
	}
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * Max number of concurrent aio requests per process
 */</span>
STATIC <span class="enscript-type">int</span>
sysctl_aioprocmax
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> new_value, changed;
	<span class="enscript-type">int</span> error = sysctl_io_number(req, aio_max_requests_per_process, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);
	<span class="enscript-keyword">if</span> (changed) {
		<span class="enscript-comment">/* make sure per process limit is less than the system-wide limit */</span>
		<span class="enscript-keyword">if</span> (new_value &lt;= aio_max_requests &amp;&amp; new_value &gt;= AIO_LISTIO_MAX)
			aio_max_requests_per_process = new_value;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
	}
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * Max number of async IO worker threads
 */</span>
STATIC <span class="enscript-type">int</span>
sysctl_aiothreads
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> new_value, changed;
	<span class="enscript-type">int</span> error = sysctl_io_number(req, aio_worker_threads, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);
	<span class="enscript-keyword">if</span> (changed) {
		<span class="enscript-comment">/* we only allow an increase in the number of worker threads */</span>
	        <span class="enscript-keyword">if</span> (new_value &gt; aio_worker_threads ) {
		        _aio_create_worker_threads((new_value - aio_worker_threads));
			aio_worker_threads = new_value;
		}
		<span class="enscript-keyword">else</span>
		        error = EINVAL;
	}
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-comment">/*
 * System-wide limit on the max number of processes
 */</span>
STATIC <span class="enscript-type">int</span>
sysctl_maxproc
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> new_value, changed;
	<span class="enscript-type">int</span> error = sysctl_io_number(req, maxproc, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);
	<span class="enscript-keyword">if</span> (changed) {
		AUDIT_ARG(value32, new_value);
		<span class="enscript-comment">/* make sure the system-wide limit is less than the configured hard
		   limit set at kernel compilation */</span>
		<span class="enscript-keyword">if</span> (new_value &lt;= hard_maxproc &amp;&amp; new_value &gt; 0)
			maxproc = new_value;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
	}
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-function-name">SYSCTL_STRING</span>(_kern, KERN_OSTYPE, ostype, 
		CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED, 
		ostype, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_STRING</span>(_kern, KERN_OSRELEASE, osrelease, 
		CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED, 
		osrelease, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, KERN_OSREV, osrevision, 
		CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED, 
		(<span class="enscript-type">int</span> *)NULL, BSD, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_STRING</span>(_kern, KERN_VERSION, version, 
		CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED, 
		version, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_STRING</span>(_kern, OID_AUTO, uuid, 
		CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED, 
		&amp;kernel_uuid_string[0], 0, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-type">int</span> debug_kprint_syscall = 0;
<span class="enscript-type">char</span> debug_kprint_syscall_process[MAXCOMLEN+1];

<span class="enscript-comment">/* Thread safe: bits and string value are not used to reclaim state */</span>
<span class="enscript-function-name">SYSCTL_INT</span> (_debug, OID_AUTO, kprint_syscall,
	    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;debug_kprint_syscall, 0, <span class="enscript-string">&quot;kprintf syscall tracing&quot;</span>);
<span class="enscript-function-name">SYSCTL_STRING</span>(_debug, OID_AUTO, kprint_syscall_process, 
			  CTLFLAG_RW | CTLFLAG_LOCKED, debug_kprint_syscall_process, <span class="enscript-keyword">sizeof</span>(debug_kprint_syscall_process),
			  <span class="enscript-string">&quot;name of process for kprintf syscall tracing&quot;</span>);

<span class="enscript-type">int</span> <span class="enscript-function-name">debug_kprint_current_process</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> **namep)
{
	<span class="enscript-type">struct</span> proc *p = current_proc();

	<span class="enscript-keyword">if</span> (p == NULL) {
		<span class="enscript-keyword">return</span> 0;
	}

	<span class="enscript-keyword">if</span> (debug_kprint_syscall_process[0]) {
		<span class="enscript-comment">/* user asked to scope tracing to a particular process name */</span>
		<span class="enscript-keyword">if</span>(0 == strncmp(debug_kprint_syscall_process,
						p-&gt;p_comm, <span class="enscript-keyword">sizeof</span>(debug_kprint_syscall_process))) {
			<span class="enscript-comment">/* no value in telling the user that we traced what they asked */</span>
			<span class="enscript-keyword">if</span>(namep) *namep = NULL;

			<span class="enscript-keyword">return</span> 1;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">return</span> 0;
		}
	}

	<span class="enscript-comment">/* trace all processes. Tell user what we traced */</span>
	<span class="enscript-keyword">if</span> (namep) {
		*namep = p-&gt;p_comm;
	}

	<span class="enscript-keyword">return</span> 1;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* PR-5293665: need to use a callback function for kern.osversion to set
 * osversion in IORegistry */</span>

STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_osversion</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
    <span class="enscript-type">int</span> rval = 0;

    rval = sysctl_handle_string(oidp, arg1, arg2, req);

    <span class="enscript-keyword">if</span> (req-&gt;newptr) {
        IORegistrySetOSBuildVersion((<span class="enscript-type">char</span> *)arg1); 
    }

    <span class="enscript-keyword">return</span> rval;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_OSVERSION, osversion,
        CTLFLAG_RW | CTLFLAG_KERN | CTLTYPE_STRING | CTLFLAG_LOCKED,
        osversion, 256 <span class="enscript-comment">/* OSVERSIZE*/</span>, 
        sysctl_osversion, <span class="enscript-string">&quot;A&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
sysctl_sysctl_bootargs
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">char</span> buf[256];

	strlcpy(buf, PE_boot_args(), 256);
	error = sysctl_io_string(req, buf, 256, 0, NULL);
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, bootargs,
	CTLFLAG_LOCKED | CTLFLAG_RD | CTLFLAG_KERN | CTLTYPE_STRING,
	NULL, 0,
	sysctl_sysctl_bootargs, <span class="enscript-string">&quot;A&quot;</span>, <span class="enscript-string">&quot;bootargs&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, KERN_MAXFILES, maxfiles, 
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;maxfiles, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, KERN_ARGMAX, argmax, 
		CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED, 
		(<span class="enscript-type">int</span> *)NULL, ARG_MAX, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, KERN_POSIX1, posix1version, 
		CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED, 
		(<span class="enscript-type">int</span> *)NULL, _POSIX_VERSION, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, KERN_NGROUPS, ngroups, 
		CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED, 
		(<span class="enscript-type">int</span> *)NULL, NGROUPS_MAX, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, KERN_JOB_CONTROL, job_control, 
		CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED, 
		(<span class="enscript-type">int</span> *)NULL, 1, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">if</span> 1	<span class="enscript-comment">/* _POSIX_SAVED_IDS from &lt;unistd.h&gt; */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, KERN_SAVED_IDS, saved_ids, 
		CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED, 
		(<span class="enscript-type">int</span> *)NULL, 1, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">else</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, KERN_SAVED_IDS, saved_ids, 
		CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED, 
		NULL, 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, num_files, 
		CTLFLAG_RD | CTLFLAG_LOCKED, 
		&amp;nfiles, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_COMPAT_INT</span>(_kern, OID_AUTO, num_vnodes, 
		CTLFLAG_RD | CTLFLAG_LOCKED, 
		&amp;numvnodes, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, num_tasks, 
		CTLFLAG_RD | CTLFLAG_LOCKED, 
		&amp;task_max, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, num_threads, 
		CTLFLAG_RD | CTLFLAG_LOCKED, 
		&amp;thread_max, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, num_taskthreads, 
		CTLFLAG_RD | CTLFLAG_LOCKED, 
		&amp;task_threadmax, 0, <span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_maxvnodes</span> (__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> oldval = desiredvnodes;
	<span class="enscript-type">int</span> error = sysctl_io_number(req, desiredvnodes, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;desiredvnodes, NULL);

	<span class="enscript-keyword">if</span> (oldval != desiredvnodes) {
		reset_vmobjectcache(oldval, desiredvnodes);
		resize_namecache(desiredvnodes);
	}

	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, namecache_disabled, 
		CTLFLAG_RW | CTLFLAG_LOCKED, 
		&amp;nc_disabled, 0, <span class="enscript-string">&quot;&quot;</span>); 

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_MAXVNODES, maxvnodes,
		CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
		0, 0, sysctl_maxvnodes, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_MAXPROC, maxproc,
		CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
		0, 0, sysctl_maxproc, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_AIOMAX, aiomax,
		CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
		0, 0, sysctl_aiomax, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_AIOPROCMAX, aioprocmax,
		CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
		0, 0, sysctl_aioprocmax, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_AIOTHREADS, aiothreads,
		CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
		0, 0, sysctl_aiothreads, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> sched_smt_balance;
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, sched_smt_balance, 
               CTLFLAG_KERN| CTLFLAG_RW| CTLFLAG_LOCKED, 
               &amp;sched_smt_balance, 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span>

STATIC <span class="enscript-type">int</span>
sysctl_securelvl
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> new_value, changed;
	<span class="enscript-type">int</span> error = sysctl_io_number(req, securelevel, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);
	<span class="enscript-keyword">if</span> (changed) {
		<span class="enscript-keyword">if</span> (!(new_value &lt; securelevel &amp;&amp; req-&gt;p-&gt;p_pid != 1)) {
			proc_list_lock();
			securelevel = new_value;
			proc_list_unlock();
		} <span class="enscript-keyword">else</span> {
			error = EPERM;
		}
	}
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_SECURELVL, securelevel,
		CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
		0, 0, sysctl_securelvl, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);


STATIC <span class="enscript-type">int</span>
sysctl_domainname
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> error, changed;
	error = sysctl_io_string(req, domainname, <span class="enscript-keyword">sizeof</span>(domainname), 0, &amp;changed);
	<span class="enscript-keyword">if</span> (changed) {
		domainnamelen = strlen(domainname);
	}
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_DOMAINNAME, nisdomainname,
		CTLTYPE_STRING | CTLFLAG_RW | CTLFLAG_LOCKED,
		0, 0, sysctl_domainname, <span class="enscript-string">&quot;A&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_COMPAT_INT</span>(_kern, KERN_HOSTID, hostid, 
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;hostid, 0, <span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
sysctl_hostname
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> error, changed;
	error = sysctl_io_string(req, hostname, <span class="enscript-keyword">sizeof</span>(hostname), 1, &amp;changed);
	<span class="enscript-keyword">if</span> (changed) {
		hostnamelen = req-&gt;newlen;
	}
	<span class="enscript-keyword">return</span>(error);
}


<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_HOSTNAME, hostname,
		CTLTYPE_STRING | CTLFLAG_RW | CTLFLAG_LOCKED,
		0, 0, sysctl_hostname, <span class="enscript-string">&quot;A&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
sysctl_procname
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-comment">/* Original code allowed writing, I'm copying this, although this all makes
	   no sense to me. Besides, this sysctl is never used. */</span>
	<span class="enscript-keyword">return</span> sysctl_io_string(req, &amp;req-&gt;p-&gt;p_name[0], (2*MAXCOMLEN+1), 1, NULL);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_PROCNAME, procname,
		CTLTYPE_STRING | CTLFLAG_RW | CTLFLAG_ANYBODY | CTLFLAG_LOCKED,
		0, 0, sysctl_procname, <span class="enscript-string">&quot;A&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, KERN_SPECULATIVE_READS, speculative_reads_disabled, 
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;speculative_reads_disabled, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, ignore_is_ssd, 
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;ignore_is_ssd, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, root_is_CF_drive,
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;root_is_CF_drive, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, preheat_max_bytes, 
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;preheat_max_bytes, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, preheat_min_bytes, 
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;preheat_min_bytes, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, speculative_prefetch_max, 
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;speculative_prefetch_max, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, speculative_prefetch_max_iosize, 
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;speculative_prefetch_max_iosize, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, vm_page_free_target,
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;vm_page_free_target, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, vm_page_free_min,
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;vm_page_free_min, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, vm_page_free_reserved,
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;vm_page_free_reserved, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, vm_page_speculative_percentage,
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;vm_page_speculative_percentage, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, vm_page_speculative_q_age_ms,
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;vm_page_speculative_q_age_ms, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, vm_max_delayed_work_limit,
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;vm_max_delayed_work_limit, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern, OID_AUTO, vm_max_batch,
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;vm_max_batch, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_STRING</span>(_kern, OID_AUTO, bootsessionuuid,
		CTLFLAG_RD | CTLFLAG_LOCKED,
		&amp;bootsessionuuid_string, <span class="enscript-keyword">sizeof</span>(bootsessionuuid_string) , <span class="enscript-string">&quot;&quot;</span>); 

STATIC <span class="enscript-type">int</span>
sysctl_boottime
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	time_t tv_sec = boottime_sec();
	<span class="enscript-type">struct</span> proc *p = req-&gt;p;

	<span class="enscript-keyword">if</span> (proc_is64bit(p)) {
		<span class="enscript-type">struct</span> user64_timeval t;
		t.tv_sec = tv_sec;
		t.tv_usec = 0;
		<span class="enscript-keyword">return</span> sysctl_io_opaque(req, &amp;t, <span class="enscript-keyword">sizeof</span>(t), NULL);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_timeval t;
		t.tv_sec = tv_sec;
		t.tv_usec = 0;
		<span class="enscript-keyword">return</span> sysctl_io_opaque(req, &amp;t, <span class="enscript-keyword">sizeof</span>(t), NULL);
	}
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_BOOTTIME, boottime,
		CTLTYPE_STRUCT | CTLFLAG_KERN | CTLFLAG_RD | CTLFLAG_LOCKED,
		0, 0, sysctl_boottime, <span class="enscript-string">&quot;S,timeval&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
sysctl_symfile
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">char</span> *str;
	<span class="enscript-type">int</span> error = get_kernel_symfile(req-&gt;p, &amp;str);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> (error);
	<span class="enscript-keyword">return</span> sysctl_io_string(req, str, 0, 0, NULL);
}


<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_SYMFILE, symfile,
		CTLTYPE_STRING | CTLFLAG_RD | CTLFLAG_LOCKED,
		0, 0, sysctl_symfile, <span class="enscript-string">&quot;A&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NFSCLIENT</span>
STATIC <span class="enscript-type">int</span>
sysctl_netboot
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-keyword">return</span> sysctl_io_number(req, netboot_root(), <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), NULL, NULL);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_NETBOOT, netboot,
		CTLTYPE_INT | CTLFLAG_RD | CTLFLAG_LOCKED,
		0, 0, sysctl_netboot, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_IMGSRC_ACCESS</span>
<span class="enscript-comment">/*
 * Legacy--act as if only one layer of nesting is possible.
 */</span>
STATIC <span class="enscript-type">int</span>
sysctl_imgsrcdev 
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	vfs_context_t ctx = vfs_context_current();
	vnode_t devvp;
	<span class="enscript-type">int</span> result;

	<span class="enscript-keyword">if</span> (!vfs_context_issuser(ctx)) {
		<span class="enscript-keyword">return</span> EPERM;
	}    

	<span class="enscript-keyword">if</span> (imgsrc_rootvnodes[0] == NULL) {
		<span class="enscript-keyword">return</span> ENOENT;
	}    

	result = vnode_getwithref(imgsrc_rootvnodes[0]);
	<span class="enscript-keyword">if</span> (result != 0) {
		<span class="enscript-keyword">return</span> result;
	}
	
	devvp = vnode_mount(imgsrc_rootvnodes[0])-&gt;mnt_devvp;
	result = vnode_getwithref(devvp);
	<span class="enscript-keyword">if</span> (result != 0) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	result = sysctl_io_number(req, vnode_specrdev(devvp), <span class="enscript-keyword">sizeof</span>(dev_t), NULL, NULL);

	vnode_put(devvp);
<span class="enscript-reference">out</span>:
	vnode_put(imgsrc_rootvnodes[0]);
	<span class="enscript-keyword">return</span> result;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, imgsrcdev,
		CTLTYPE_INT | CTLFLAG_RD | CTLFLAG_LOCKED,
		0, 0, sysctl_imgsrcdev, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>); 

STATIC <span class="enscript-type">int</span>
sysctl_imgsrcinfo
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> imgsrc_info info[MAX_IMAGEBOOT_NESTING];	<span class="enscript-comment">/* 2 for now, no problem */</span>
	uint32_t i;
	vnode_t rvp, devvp;

	<span class="enscript-keyword">if</span> (imgsrc_rootvnodes[0] == NULLVP) {
		<span class="enscript-keyword">return</span> ENXIO;
	}

	<span class="enscript-keyword">for</span> (i = 0; i &lt; MAX_IMAGEBOOT_NESTING; i++) {
		<span class="enscript-comment">/*
		 * Go get the root vnode.
		 */</span>
		rvp = imgsrc_rootvnodes[i];
		<span class="enscript-keyword">if</span> (rvp == NULLVP) {
			<span class="enscript-keyword">break</span>;
		}

		error = vnode_get(rvp);
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-keyword">return</span> error;
		}

		<span class="enscript-comment">/* 
		 * For now, no getting at a non-local volume.
		 */</span>
		devvp = vnode_mount(rvp)-&gt;mnt_devvp;
		<span class="enscript-keyword">if</span> (devvp == NULL) {
			vnode_put(rvp);
			<span class="enscript-keyword">return</span> EINVAL;	
		}

		error = vnode_getwithref(devvp);
		<span class="enscript-keyword">if</span> (error != 0) {
			vnode_put(rvp);
			<span class="enscript-keyword">return</span> error;
		}

		<span class="enscript-comment">/*
		 * Fill in info.
		 */</span>
		info[i].ii_dev = vnode_specrdev(devvp);
		info[i].ii_flags = 0;
		info[i].ii_height = i;
		bzero(info[i].ii_reserved, <span class="enscript-keyword">sizeof</span>(info[i].ii_reserved));

		vnode_put(devvp);
		vnode_put(rvp);
	}

	<span class="enscript-keyword">return</span> sysctl_io_opaque(req, info, i * <span class="enscript-keyword">sizeof</span>(info[0]), NULL);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, imgsrcinfo,
		CTLTYPE_OPAQUE | CTLFLAG_RD | CTLFLAG_LOCKED,
		0, 0, sysctl_imgsrcinfo, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>); 

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IMGSRC_ACCESS */</span>


<span class="enscript-function-name">SYSCTL_DECL</span>(_kern_timer);
<span class="enscript-function-name">SYSCTL_NODE</span>(_kern, OID_AUTO, timer, CTLFLAG_RW | CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;timer&quot;</span>);


<span class="enscript-function-name">SYSCTL_INT</span>(_kern_timer, OID_AUTO, coalescing_enabled, 
		CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
		&amp;mach_timer_coalescing_enabled, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_QUAD</span>(_kern_timer, OID_AUTO, deadline_tracking_bin_1,
		CTLFLAG_RW | CTLFLAG_LOCKED,
		&amp;timer_deadline_tracking_bin_1, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_QUAD</span>(_kern_timer, OID_AUTO, deadline_tracking_bin_2,
		CTLFLAG_RW | CTLFLAG_LOCKED,
		&amp;timer_deadline_tracking_bin_2, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_DECL</span>(_kern_timer_longterm);
<span class="enscript-function-name">SYSCTL_NODE</span>(_kern_timer, OID_AUTO, longterm, CTLFLAG_RW | CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;longterm&quot;</span>);


<span class="enscript-comment">/* Must match definition in osfmk/kern/timer_call.c */</span>
<span class="enscript-type">enum</span> {
	THRESHOLD, QCOUNT,
	ENQUEUES, DEQUEUES, ESCALATES, SCANS, PREEMPTS,
	LATENCY, LATENCY_MIN, LATENCY_MAX
};
<span class="enscript-type">extern</span> uint64_t	timer_sysctl_get(<span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>      <span class="enscript-function-name">timer_sysctl_set</span>(<span class="enscript-type">int</span>, uint64_t);

STATIC <span class="enscript-type">int</span>
sysctl_timer
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span>		oid = (<span class="enscript-type">int</span>)arg1;
	uint64_t	value = timer_sysctl_get(oid);
	uint64_t	new_value;
	<span class="enscript-type">int</span>		error;
	<span class="enscript-type">int</span>		changed;

	error = sysctl_io_number(req, value, <span class="enscript-keyword">sizeof</span>(value), &amp;new_value, &amp;changed);
	<span class="enscript-keyword">if</span> (changed)
		error = timer_sysctl_set(oid, new_value);

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_timer_longterm, OID_AUTO, threshold,
		CTLTYPE_QUAD | CTLFLAG_RW | CTLFLAG_LOCKED,
		(<span class="enscript-type">void</span> *) THRESHOLD, 0, sysctl_timer, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_timer_longterm, OID_AUTO, qlen,
		CTLTYPE_QUAD | CTLFLAG_RD | CTLFLAG_LOCKED,
		(<span class="enscript-type">void</span> *) QCOUNT, 0, sysctl_timer, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_timer_longterm, OID_AUTO, enqueues,
		CTLTYPE_QUAD | CTLFLAG_RD | CTLFLAG_LOCKED,
		(<span class="enscript-type">void</span> *) ENQUEUES, 0, sysctl_timer, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_timer_longterm, OID_AUTO, dequeues,
		CTLTYPE_QUAD | CTLFLAG_RD | CTLFLAG_LOCKED,
		(<span class="enscript-type">void</span> *) DEQUEUES, 0, sysctl_timer, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_timer_longterm, OID_AUTO, escalates,
		CTLTYPE_QUAD | CTLFLAG_RD | CTLFLAG_LOCKED,
		(<span class="enscript-type">void</span> *) ESCALATES, 0, sysctl_timer, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_timer_longterm, OID_AUTO, scans,
		CTLTYPE_QUAD | CTLFLAG_RD | CTLFLAG_LOCKED,
		(<span class="enscript-type">void</span> *) SCANS, 0, sysctl_timer, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_timer_longterm, OID_AUTO, preempts,
		CTLTYPE_QUAD | CTLFLAG_RD | CTLFLAG_LOCKED,
		(<span class="enscript-type">void</span> *) PREEMPTS, 0, sysctl_timer, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_timer_longterm, OID_AUTO, latency,
		CTLTYPE_QUAD | CTLFLAG_RD | CTLFLAG_LOCKED,
		(<span class="enscript-type">void</span> *) LATENCY, 0, sysctl_timer, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_timer_longterm, OID_AUTO, latency_min,
		CTLTYPE_QUAD | CTLFLAG_RD | CTLFLAG_LOCKED,
		(<span class="enscript-type">void</span> *) LATENCY_MIN, 0, sysctl_timer, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_timer_longterm, OID_AUTO, latency_max,
		CTLTYPE_QUAD | CTLFLAG_RD | CTLFLAG_LOCKED,
		(<span class="enscript-type">void</span> *) LATENCY_MAX, 0, sysctl_timer, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

STATIC <span class="enscript-type">int</span>
sysctl_usrstack
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-keyword">return</span> sysctl_io_number(req, (<span class="enscript-type">int</span>)req-&gt;p-&gt;user_stack, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), NULL, NULL);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_USRSTACK32, usrstack,
		CTLTYPE_INT | CTLFLAG_RD | CTLFLAG_LOCKED,
		0, 0, sysctl_usrstack, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
sysctl_usrstack64
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-keyword">return</span> sysctl_io_number(req, req-&gt;p-&gt;user_stack, <span class="enscript-keyword">sizeof</span>(req-&gt;p-&gt;user_stack), NULL, NULL);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_USRSTACK64, usrstack64,
		CTLTYPE_QUAD | CTLFLAG_RD | CTLFLAG_LOCKED,
		0, 0, sysctl_usrstack64, <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_STRING</span>(_kern, KERN_COREFILE, corefile, 
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		corefilename, <span class="enscript-keyword">sizeof</span>(corefilename), <span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
sysctl_coredump
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SECURE_KERNEL</span>
	(<span class="enscript-type">void</span>)req;
	<span class="enscript-keyword">return</span> (ENOTSUP);
#<span class="enscript-reference">else</span>
	<span class="enscript-type">int</span> new_value, changed;
	<span class="enscript-type">int</span> error = sysctl_io_number(req, do_coredump, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);
	<span class="enscript-keyword">if</span> (changed) {
		<span class="enscript-keyword">if</span> ((new_value == 0) || (new_value == 1))
			do_coredump = new_value;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
	}
	<span class="enscript-keyword">return</span>(error);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_COREDUMP, coredump,
		CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
		0, 0, sysctl_coredump, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
sysctl_suid_coredump
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SECURE_KERNEL</span>
	(<span class="enscript-type">void</span>)req;
	<span class="enscript-keyword">return</span> (ENOTSUP);
#<span class="enscript-reference">else</span>
	<span class="enscript-type">int</span> new_value, changed;
	<span class="enscript-type">int</span> error = sysctl_io_number(req, sugid_coredump, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);
	<span class="enscript-keyword">if</span> (changed) {
		<span class="enscript-keyword">if</span> ((new_value == 0) || (new_value == 1))
			sugid_coredump = new_value;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
	}
	<span class="enscript-keyword">return</span>(error);
#<span class="enscript-reference">endif</span>
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_SUGID_COREDUMP, sugid_coredump,
		CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
		0, 0, sysctl_suid_coredump, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
sysctl_delayterm
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">struct</span> proc *p = req-&gt;p;
	<span class="enscript-type">int</span> new_value, changed;
	<span class="enscript-type">int</span> error = sysctl_io_number(req, (req-&gt;p-&gt;p_lflag &amp; P_LDELAYTERM)? 1: 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);
	<span class="enscript-keyword">if</span> (changed) {
		proc_lock(p);
		<span class="enscript-keyword">if</span> (new_value)
			req-&gt;p-&gt;p_lflag |=  P_LDELAYTERM;
		<span class="enscript-keyword">else</span>
			req-&gt;p-&gt;p_lflag &amp;=  ~P_LDELAYTERM;
		proc_unlock(p);
	}
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_PROCDELAYTERM, delayterm,
		CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
		0, 0, sysctl_delayterm, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);


STATIC <span class="enscript-type">int</span>
sysctl_rage_vnode
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">struct</span> proc *p = req-&gt;p;
        <span class="enscript-type">struct</span>  uthread *ut;
	<span class="enscript-type">int</span> new_value, old_value, changed;
	<span class="enscript-type">int</span> error;

	ut = get_bsdthread_info(current_thread());

	<span class="enscript-keyword">if</span> (ut-&gt;uu_flag &amp; UT_RAGE_VNODES)
	        old_value = KERN_RAGE_THREAD;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (p-&gt;p_lflag &amp; P_LRAGE_VNODES)
	        old_value = KERN_RAGE_PROC;
	<span class="enscript-keyword">else</span>
	        old_value = 0;

	error = sysctl_io_number(req, old_value, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);

	<span class="enscript-keyword">if</span> (error == 0) {
	        <span class="enscript-keyword">switch</span> (new_value) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_RAGE_PROC</span>:
		        proc_lock(p);
			p-&gt;p_lflag |= P_LRAGE_VNODES;
			proc_unlock(p);
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_UNRAGE_PROC</span>:
		        proc_lock(p);
			p-&gt;p_lflag &amp;= ~P_LRAGE_VNODES;
			proc_unlock(p);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_RAGE_THREAD</span>:
			ut-&gt;uu_flag |= UT_RAGE_VNODES;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_UNRAGE_THREAD</span>:
		        ut = get_bsdthread_info(current_thread());
			ut-&gt;uu_flag &amp;= ~UT_RAGE_VNODES;
			<span class="enscript-keyword">break</span>;
		}
	}
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_RAGEVNODE, rage_vnode,
		CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_ANYBODY | CTLFLAG_LOCKED,
		0, 0, sysctl_rage_vnode, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* XXX move this interface into libproc and remove this sysctl */</span>
STATIC <span class="enscript-type">int</span>
sysctl_setthread_cpupercent
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> new_value, old_value;
	<span class="enscript-type">int</span> error = 0;
	kern_return_t kret = KERN_SUCCESS;
	uint8_t percent = 0;
	<span class="enscript-type">int</span> ms_refill = 0;

	<span class="enscript-keyword">if</span> (!req-&gt;newptr)
		<span class="enscript-keyword">return</span> (0);

	old_value = 0;

	<span class="enscript-keyword">if</span> ((error = sysctl_io_number(req, old_value, <span class="enscript-keyword">sizeof</span>(old_value), &amp;new_value, NULL)) != 0)
		<span class="enscript-keyword">return</span> (error);

	percent = new_value &amp; 0xff;			<span class="enscript-comment">/* low 8 bytes for perent */</span>
	ms_refill = (new_value &gt;&gt; 8) &amp; 0xffffff;	<span class="enscript-comment">/* upper 24bytes represent ms refill value */</span>
	<span class="enscript-keyword">if</span> (percent &gt; 100)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/*
	 * If the caller is specifying a percentage of 0, this will unset the CPU limit, if present.
	 */</span>
	<span class="enscript-keyword">if</span> ((kret = thread_set_cpulimit(THREAD_CPULIMIT_BLOCK, percent, ms_refill * (<span class="enscript-type">int</span>)NSEC_PER_MSEC)) != 0)
		<span class="enscript-keyword">return</span> (EIO);
	
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, setthread_cpupercent,
		CTLTYPE_INT | CTLFLAG_WR | CTLFLAG_ANYBODY,
		0, 0, sysctl_setthread_cpupercent, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;set thread cpu percentage limit&quot;</span>);


STATIC <span class="enscript-type">int</span>
sysctl_kern_check_openevt
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">struct</span> proc *p = req-&gt;p;
	<span class="enscript-type">int</span> new_value, old_value, changed;
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (p-&gt;p_flag &amp; P_CHECKOPENEVT) {
		old_value = KERN_OPENEVT_PROC;
	} <span class="enscript-keyword">else</span> {
	        old_value = 0;
	}

	error = sysctl_io_number(req, old_value, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);

	<span class="enscript-keyword">if</span> (error == 0) {
	        <span class="enscript-keyword">switch</span> (new_value) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_OPENEVT_PROC</span>:
			OSBitOrAtomic(P_CHECKOPENEVT, &amp;p-&gt;p_flag);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">KERN_UNOPENEVT_PROC</span>:
			OSBitAndAtomic(~((uint32_t)P_CHECKOPENEVT), &amp;p-&gt;p_flag);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = EINVAL;
		}
	}
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_CHECKOPENEVT, check_openevt, CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_ANYBODY | CTLFLAG_LOCKED,
            0, 0, sysctl_kern_check_openevt, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;set the per-process check-open-evt flag&quot;</span>);



STATIC <span class="enscript-type">int</span>
sysctl_nx
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">SECURE_KERNEL</span>
	(<span class="enscript-type">void</span>)req;
	<span class="enscript-keyword">return</span> ENOTSUP;
#<span class="enscript-reference">else</span>
	<span class="enscript-type">int</span> new_value, changed;
	<span class="enscript-type">int</span> error;

	error = sysctl_io_number(req, nx_enabled, <span class="enscript-keyword">sizeof</span>(nx_enabled), &amp;new_value, &amp;changed);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">return</span> error;

	<span class="enscript-keyword">if</span> (changed) {
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__i386__</span>) || <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__x86_64__</span>)
		<span class="enscript-comment">/*
		 * Only allow setting if NX is supported on the chip
		 */</span>
		<span class="enscript-keyword">if</span> (!(cpuid_extfeatures() &amp; CPUID_EXTFEATURE_XD))
			<span class="enscript-keyword">return</span> ENOTSUP;
#<span class="enscript-reference">endif</span>
		nx_enabled = new_value;
	}
	<span class="enscript-keyword">return</span>(error);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* SECURE_KERNEL */</span>
}



<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_NX_PROTECTION, nx, 
		CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		0, 0, sysctl_nx, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
sysctl_loadavg
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
		<span class="enscript-keyword">if</span> (proc_is64bit(req-&gt;p)) {
			<span class="enscript-type">struct</span> user64_loadavg loadinfo64;
			fill_loadavg64(&amp;averunnable, &amp;loadinfo64);
			<span class="enscript-keyword">return</span> sysctl_io_opaque(req, &amp;loadinfo64, <span class="enscript-keyword">sizeof</span>(loadinfo64), NULL);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> user32_loadavg loadinfo32;
			fill_loadavg32(&amp;averunnable, &amp;loadinfo32);
			<span class="enscript-keyword">return</span> sysctl_io_opaque(req, &amp;loadinfo32, <span class="enscript-keyword">sizeof</span>(loadinfo32), NULL);
		}
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_vm, VM_LOADAVG, loadavg,
		CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED,
		0, 0, sysctl_loadavg, <span class="enscript-string">&quot;S,loadavg&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/*
 * Note:	Thread safe; vm_map_lock protects in  vm_toggle_entry_reuse()
 */</span>
STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_vm_toggle_address_reuse</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1,
	      __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> old_value=0, new_value=0, error=0;
	
	<span class="enscript-keyword">if</span>(vm_toggle_entry_reuse( VM_TOGGLE_GETVALUE, &amp;old_value ))
		<span class="enscript-keyword">return</span>(error);
	error = sysctl_io_number(req, old_value, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, NULL);
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-keyword">return</span> (vm_toggle_entry_reuse(new_value, NULL));
	}
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_debug, OID_AUTO, toggle_address_reuse, CTLFLAG_ANYBODY | CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, 0, 0, sysctl_vm_toggle_address_reuse,<span class="enscript-string">&quot;I&quot;</span>,<span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
sysctl_swapusage
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
		<span class="enscript-type">int</span>			error;
		uint64_t		swap_total;
		uint64_t		swap_avail;
		vm_size_t		swap_pagesize;
		boolean_t		swap_encrypted;
		<span class="enscript-type">struct</span> xsw_usage	xsu;

		error = macx_swapinfo(&amp;swap_total,
				      &amp;swap_avail,
				      &amp;swap_pagesize,
				      &amp;swap_encrypted);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">return</span> error;

		xsu.xsu_total = swap_total;
		xsu.xsu_avail = swap_avail;
		xsu.xsu_used = swap_total - swap_avail;
		xsu.xsu_pagesize = swap_pagesize;
		xsu.xsu_encrypted = swap_encrypted;
		<span class="enscript-keyword">return</span> sysctl_io_opaque(req, &amp;xsu, <span class="enscript-keyword">sizeof</span>(xsu), NULL);
}



<span class="enscript-function-name">SYSCTL_PROC</span>(_vm, VM_SWAPUSAGE, swapusage,
		CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED,
		0, 0, sysctl_swapusage, <span class="enscript-string">&quot;S,xsw_usage&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_FREEZE</span>
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">vm_page_reactivate_all_throttled</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
sysctl_freeze_enabled SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> error, val = memorystatus_freeze_enabled ? 1 : 0;
	boolean_t disabled;

	error = sysctl_handle_int(oidp, &amp;val, 0, req);
	<span class="enscript-keyword">if</span> (error || !req-&gt;newptr)
 		<span class="enscript-keyword">return</span> (error);
	
	<span class="enscript-keyword">if</span> (COMPRESSED_PAGER_IS_ACTIVE || DEFAULT_FREEZER_COMPRESSED_PAGER_IS_ACTIVE) {
		<span class="enscript-comment">//assert(req-&gt;newptr);
</span>		printf(<span class="enscript-string">&quot;Failed attempt to set vm.freeze_enabled sysctl\n&quot;</span>);
		<span class="enscript-keyword">return</span> EINVAL;
	}

	<span class="enscript-comment">/* 
	 * If freeze is being disabled, we need to move dirty pages out from the throttle to the active queue. 
	 */</span>
	disabled = (!val &amp;&amp; memorystatus_freeze_enabled);
	
	memorystatus_freeze_enabled = val ? TRUE : FALSE;
	
	<span class="enscript-keyword">if</span> (disabled) {
		vm_page_reactivate_all_throttled();
	}
	
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_vm, OID_AUTO, freeze_enabled, CTLTYPE_INT|CTLFLAG_RW, &amp;memorystatus_freeze_enabled, 0, sysctl_freeze_enabled, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_FREEZE */</span>

<span class="enscript-comment">/* this kernel does NOT implement shared_region_make_private_np() */</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, KERN_SHREG_PRIVATIZABLE, shreg_private, 
		CTLFLAG_RD | CTLFLAG_LOCKED, 
		(<span class="enscript-type">int</span> *)NULL, 0, <span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">fetch_process_cputype</span>(
	proc_t cur_proc,
	<span class="enscript-type">int</span> *name,
	u_int namelen,
	cpu_type_t *cputype)
{
	proc_t p = PROC_NULL;
	<span class="enscript-type">int</span> refheld = 0;
	cpu_type_t ret = 0;
	<span class="enscript-type">int</span> error = 0;
	
	<span class="enscript-keyword">if</span> (namelen == 0)
		p = cur_proc;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (namelen == 1) {
		p = proc_find(name[0]);
		<span class="enscript-keyword">if</span> (p == NULL)
			<span class="enscript-keyword">return</span> (EINVAL);
		refheld = 1;
	} <span class="enscript-keyword">else</span> {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	ret = cpu_type() &amp; ~CPU_ARCH_MASK;
	<span class="enscript-keyword">if</span> (IS_64BIT_PROCESS(p))
		ret |= CPU_ARCH_ABI64;

	*cputype = ret;
	
	<span class="enscript-keyword">if</span> (refheld != 0)
		proc_rele(p);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">return</span> (error);
}

STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_sysctl_native</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2,
		    <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> error;
	cpu_type_t proc_cputype = 0;
	<span class="enscript-keyword">if</span> ((error = fetch_process_cputype(req-&gt;p, (<span class="enscript-type">int</span> *)arg1, arg2, &amp;proc_cputype)) != 0)
		<span class="enscript-keyword">return</span> error;
	<span class="enscript-type">int</span> res = 1;
	<span class="enscript-keyword">if</span> ((proc_cputype &amp; ~CPU_ARCH_MASK) != (cpu_type() &amp; ~CPU_ARCH_MASK))
		res = 0;
	<span class="enscript-keyword">return</span> SYSCTL_OUT(req, &amp;res, <span class="enscript-keyword">sizeof</span>(res));
}	
<span class="enscript-function-name">SYSCTL_PROC</span>(_sysctl, OID_AUTO, proc_native, CTLTYPE_NODE|CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0, sysctl_sysctl_native ,<span class="enscript-string">&quot;I&quot;</span>,<span class="enscript-string">&quot;proc_native&quot;</span>);

STATIC <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_sysctl_cputype</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, <span class="enscript-type">void</span> *arg1, <span class="enscript-type">int</span> arg2,
		     <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> error;
	cpu_type_t proc_cputype = 0;
	<span class="enscript-keyword">if</span> ((error = fetch_process_cputype(req-&gt;p, (<span class="enscript-type">int</span> *)arg1, arg2, &amp;proc_cputype)) != 0)
		<span class="enscript-keyword">return</span> error;
	<span class="enscript-keyword">return</span> SYSCTL_OUT(req, &amp;proc_cputype, <span class="enscript-keyword">sizeof</span>(proc_cputype));
}
<span class="enscript-function-name">SYSCTL_PROC</span>(_sysctl, OID_AUTO, proc_cputype, CTLTYPE_NODE|CTLFLAG_RD | CTLFLAG_LOCKED, 0, 0, sysctl_sysctl_cputype ,<span class="enscript-string">&quot;I&quot;</span>,<span class="enscript-string">&quot;proc_cputype&quot;</span>);

STATIC <span class="enscript-type">int</span>
sysctl_safeboot
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-keyword">return</span> sysctl_io_number(req, boothowto &amp; RB_SAFEBOOT ? 1 : 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), NULL, NULL);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, KERN_SAFEBOOT, safeboot,
		CTLTYPE_INT | CTLFLAG_RD | CTLFLAG_LOCKED,
		0, 0, sysctl_safeboot, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span>
sysctl_singleuser
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-keyword">return</span> sysctl_io_number(req, boothowto &amp; RB_SINGLE ? 1 : 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), NULL, NULL);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, singleuser,
		CTLTYPE_INT | CTLFLAG_RD | CTLFLAG_LOCKED,
		0, 0, sysctl_singleuser, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

STATIC <span class="enscript-type">int</span> sysctl_minimalboot
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-keyword">return</span> sysctl_io_number(req, minimalboot, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), NULL, NULL);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, minimalboot,
		CTLTYPE_INT | CTLFLAG_RD | CTLFLAG_LOCKED,
		0, 0, sysctl_minimalboot, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/*
 * Controls for debugging affinity sets - see osfmk/kern/affinity.c
 */</span>
<span class="enscript-type">extern</span> boolean_t	affinity_sets_enabled;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>		affinity_sets_mapping;

<span class="enscript-function-name">SYSCTL_INT</span> (_kern, OID_AUTO, affinity_sets_enabled,
	    CTLFLAG_RW | CTLFLAG_LOCKED, (<span class="enscript-type">int</span> *) &amp;affinity_sets_enabled, 0, <span class="enscript-string">&quot;hinting enabled&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span> (_kern, OID_AUTO, affinity_sets_mapping,
	    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;affinity_sets_mapping, 0, <span class="enscript-string">&quot;mapping policy&quot;</span>);

<span class="enscript-comment">/*
 * Boolean indicating if KASLR is active.
 */</span>
STATIC <span class="enscript-type">int</span>
sysctl_slide
(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	uint32_t	slide;

	slide = vm_kernel_slide ? 1 : 0;

	<span class="enscript-keyword">return</span> sysctl_io_number( req, slide, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), NULL, NULL);
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, slide,
		CTLTYPE_INT | CTLFLAG_RD | CTLFLAG_LOCKED,
		0, 0, sysctl_slide, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/*
 * Limit on total memory users can wire.
 *
 * vm_global_user_wire_limit - system wide limit on wired memory from all processes combined. 
 *
 * vm_user_wire_limit - per address space limit on wired memory.  This puts a cap on the process's rlimit value.
 *
 * These values are initialized to reasonable defaults at boot time based on the available physical memory in
 * kmem_init().
 *
 * All values are in bytes.
 */</span>

vm_map_size_t	vm_global_no_user_wire_amount;
vm_map_size_t	vm_global_user_wire_limit;
vm_map_size_t	vm_user_wire_limit;

<span class="enscript-comment">/*
 * There needs to be a more automatic/elegant way to do this
 */</span>
<span class="enscript-function-name">SYSCTL_QUAD</span>(_vm, OID_AUTO, global_no_user_wire_amount, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;vm_global_no_user_wire_amount, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_QUAD</span>(_vm, OID_AUTO, global_user_wire_limit, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;vm_global_user_wire_limit, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_QUAD</span>(_vm, OID_AUTO, user_wire_limit, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;vm_user_wire_limit, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> vm_map_copy_overwrite_aligned_src_not_internal;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> vm_map_copy_overwrite_aligned_src_not_symmetric;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> vm_map_copy_overwrite_aligned_src_large;
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, vm_copy_src_not_internal, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;vm_map_copy_overwrite_aligned_src_not_internal, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, vm_copy_src_not_symmetric, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;vm_map_copy_overwrite_aligned_src_not_symmetric, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, vm_copy_src_large, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;vm_map_copy_overwrite_aligned_src_large, 0, <span class="enscript-string">&quot;&quot;</span>);


<span class="enscript-type">extern</span> uint32_t	vm_page_external_count;
<span class="enscript-type">extern</span> uint32_t	vm_page_filecache_min;

<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, vm_page_external_count, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;vm_page_external_count, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, vm_page_filecache_min, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;vm_page_filecache_min, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	vm_compressor_mode;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	vm_compressor_is_active;
<span class="enscript-type">extern</span> <span class="enscript-type">int</span>	vm_compressor_available;
<span class="enscript-type">extern</span> uint32_t	vm_ripe_target_age;
<span class="enscript-type">extern</span> uint32_t	swapout_target_age;
<span class="enscript-type">extern</span> int64_t  compressor_bytes_used;
<span class="enscript-type">extern</span> int64_t  c_segment_input_bytes;
<span class="enscript-type">extern</span> int64_t  c_segment_compressed_bytes;
<span class="enscript-type">extern</span> uint32_t	compressor_eval_period_in_msecs;
<span class="enscript-type">extern</span> uint32_t	compressor_sample_min_in_msecs;
<span class="enscript-type">extern</span> uint32_t	compressor_sample_max_in_msecs;
<span class="enscript-type">extern</span> uint32_t	compressor_thrashing_threshold_per_10msecs;
<span class="enscript-type">extern</span> uint32_t	compressor_thrashing_min_per_10msecs;
<span class="enscript-type">extern</span> uint32_t	vm_compressor_minorcompact_threshold_divisor;
<span class="enscript-type">extern</span> uint32_t	vm_compressor_majorcompact_threshold_divisor;
<span class="enscript-type">extern</span> uint32_t	vm_compressor_unthrottle_threshold_divisor;
<span class="enscript-type">extern</span> uint32_t	vm_compressor_catchup_threshold_divisor;

<span class="enscript-function-name">SYSCTL_QUAD</span>(_vm, OID_AUTO, compressor_input_bytes, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;c_segment_input_bytes, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_QUAD</span>(_vm, OID_AUTO, compressor_compressed_bytes, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;c_segment_compressed_bytes, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_QUAD</span>(_vm, OID_AUTO, compressor_bytes_used, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;compressor_bytes_used, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, compressor_mode, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;vm_compressor_mode, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, compressor_is_active, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;vm_compressor_is_active, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, compressor_swapout_target_age, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;swapout_target_age, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, compressor_available, CTLFLAG_RD | CTLFLAG_LOCKED, &amp;vm_compressor_available, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, vm_ripe_target_age_in_secs, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;vm_ripe_target_age, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, compressor_eval_period_in_msecs, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;compressor_eval_period_in_msecs, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, compressor_sample_min_in_msecs, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;compressor_sample_min_in_msecs, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, compressor_sample_max_in_msecs, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;compressor_sample_max_in_msecs, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, compressor_thrashing_threshold_per_10msecs, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;compressor_thrashing_threshold_per_10msecs, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, compressor_thrashing_min_per_10msecs, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;compressor_thrashing_min_per_10msecs, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, compressor_minorcompact_threshold_divisor, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;vm_compressor_minorcompact_threshold_divisor, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, compressor_majorcompact_threshold_divisor, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;vm_compressor_majorcompact_threshold_divisor, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, compressor_unthrottle_threshold_divisor, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;vm_compressor_unthrottle_threshold_divisor, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, compressor_catchup_threshold_divisor, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;vm_compressor_catchup_threshold_divisor, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_STRING</span>(_vm, OID_AUTO, swapfileprefix, CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED, swapfilename, <span class="enscript-keyword">sizeof</span>(swapfilename) - SWAPFILENAME_INDEX_LEN, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_PHANTOM_CACHE</span>
<span class="enscript-type">extern</span> uint32_t phantom_cache_thrashing_threshold;
<span class="enscript-type">extern</span> uint32_t phantom_cache_eval_period_in_msecs;
<span class="enscript-type">extern</span> uint32_t phantom_cache_thrashing_threshold_ssd;


<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, phantom_cache_eval_period_in_msecs, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;phantom_cache_eval_period_in_msecs, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, phantom_cache_thrashing_threshold, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;phantom_cache_thrashing_threshold, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_vm, OID_AUTO, phantom_cache_thrashing_threshold_ssd, CTLFLAG_RW | CTLFLAG_LOCKED, &amp;phantom_cache_thrashing_threshold_ssd, 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> (<span class="enscript-variable-name">DEVELOPMENT</span> || <span class="enscript-variable-name">DEBUG</span>)

<span class="enscript-function-name">SYSCTL_UINT</span>(_vm, OID_AUTO, vm_page_creation_throttled_hard,
		CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;vm_page_creation_throttled_hard, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_vm, OID_AUTO, vm_page_creation_throttled_soft,
		CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;vm_page_creation_throttled_soft, 0, <span class="enscript-string">&quot;&quot;</span>);

#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEVELOPMENT || DEBUG */</span>

<span class="enscript-comment">/*
 * Enable tracing of voucher contents
 */</span>
<span class="enscript-type">extern</span> uint32_t ipc_voucher_trace_contents;

<span class="enscript-function-name">SYSCTL_INT</span> (_kern, OID_AUTO, ipc_voucher_trace_contents,
	    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;ipc_voucher_trace_contents, 0, <span class="enscript-string">&quot;Enable tracing voucher contents&quot;</span>);

<span class="enscript-comment">/*
 * Kernel stack size and depth
 */</span>
<span class="enscript-function-name">SYSCTL_INT</span> (_kern, OID_AUTO, stack_size,
	    CTLFLAG_RD | CTLFLAG_LOCKED, (<span class="enscript-type">int</span> *) &amp;kernel_stack_size, 0, <span class="enscript-string">&quot;Kernel stack size&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span> (_kern, OID_AUTO, stack_depth_max,
	    CTLFLAG_RD | CTLFLAG_LOCKED, (<span class="enscript-type">int</span> *) &amp;kernel_stack_depth_max, 0, <span class="enscript-string">&quot;Max kernel stack depth at interrupt or context switch&quot;</span>);

<span class="enscript-comment">/*
 * enable back trace for port allocations
 */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> ipc_portbt;

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, ipc_portbt, 
		CTLFLAG_RW | CTLFLAG_KERN | CTLFLAG_LOCKED,
		&amp;ipc_portbt, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/*
 * Scheduler sysctls
 */</span>

<span class="enscript-function-name">SYSCTL_STRING</span>(_kern, OID_AUTO, sched,
			  CTLFLAG_RD | CTLFLAG_KERN | CTLFLAG_LOCKED,
			  sched_string, <span class="enscript-keyword">sizeof</span>(sched_string),
			  <span class="enscript-string">&quot;Timeshare scheduler implementation&quot;</span>);

<span class="enscript-comment">/*
 * Only support runtime modification on embedded platforms
 * with development config enabled
 */</span>


<span class="enscript-comment">/* Parameters related to timer coalescing tuning, to be replaced
 * with a dedicated systemcall in the future.
 */</span>
<span class="enscript-comment">/* Enable processing pending timers in the context of any other interrupt
 * Coalescing tuning parameters for various thread/task attributes */</span>
STATIC <span class="enscript-type">int</span>
sysctl_timer_user_us_kernel_abstime SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>)
	<span class="enscript-type">int</span> size = arg2;	<span class="enscript-comment">/* subcommand*/</span>
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">int</span> changed = 0;
	uint64_t old_value_ns;
	uint64_t new_value_ns;
	uint64_t value_abstime;
	<span class="enscript-keyword">if</span> (size == <span class="enscript-keyword">sizeof</span>(uint32_t))
		value_abstime = *((uint32_t *)arg1);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (size == <span class="enscript-keyword">sizeof</span>(uint64_t))
		value_abstime = *((uint64_t *)arg1);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">return</span> ENOTSUP;

	absolutetime_to_nanoseconds(value_abstime, &amp;old_value_ns);
	error = sysctl_io_number(req, old_value_ns, <span class="enscript-keyword">sizeof</span>(old_value_ns), &amp;new_value_ns, &amp;changed);
	<span class="enscript-keyword">if</span> ((error) || (!changed))
		<span class="enscript-keyword">return</span> error;

	nanoseconds_to_absolutetime(new_value_ns, &amp;value_abstime);
	<span class="enscript-keyword">if</span> (size == <span class="enscript-keyword">sizeof</span>(uint32_t))
		*((uint32_t *)arg1) = (uint32_t)value_abstime;
	<span class="enscript-keyword">else</span>
		*((uint64_t *)arg1) = value_abstime;
	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, timer_coalesce_bg_scale,
    CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.timer_coalesce_bg_shift, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, timer_resort_threshold_ns,
    CTLTYPE_QUAD | CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.timer_resort_threshold_abstime,
    <span class="enscript-keyword">sizeof</span>(tcoal_prio_params.timer_resort_threshold_abstime),
    sysctl_timer_user_us_kernel_abstime,
    <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, timer_coalesce_bg_ns_max,
    CTLTYPE_QUAD | CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.timer_coalesce_bg_abstime_max,
    <span class="enscript-keyword">sizeof</span>(tcoal_prio_params.timer_coalesce_bg_abstime_max),
    sysctl_timer_user_us_kernel_abstime,
    <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, timer_coalesce_kt_scale,
    CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.timer_coalesce_kt_shift, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, timer_coalesce_kt_ns_max,
    CTLTYPE_QUAD | CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.timer_coalesce_kt_abstime_max,
    <span class="enscript-keyword">sizeof</span>(tcoal_prio_params.timer_coalesce_kt_abstime_max),
    sysctl_timer_user_us_kernel_abstime,
    <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, timer_coalesce_fp_scale,
    CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.timer_coalesce_fp_shift, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, timer_coalesce_fp_ns_max,
    CTLTYPE_QUAD | CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.timer_coalesce_fp_abstime_max,
    <span class="enscript-keyword">sizeof</span>(tcoal_prio_params.timer_coalesce_fp_abstime_max), 
   sysctl_timer_user_us_kernel_abstime,
    <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, timer_coalesce_ts_scale,
    CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.timer_coalesce_ts_shift, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, timer_coalesce_ts_ns_max,
    CTLTYPE_QUAD | CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.timer_coalesce_ts_abstime_max,
    <span class="enscript-keyword">sizeof</span>(tcoal_prio_params.timer_coalesce_ts_abstime_max),
    sysctl_timer_user_us_kernel_abstime,
    <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, timer_coalesce_tier0_scale,
    CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.latency_qos_scale[0], 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, timer_coalesce_tier0_ns_max,
    CTLTYPE_QUAD | CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.latency_qos_abstime_max[0],
    <span class="enscript-keyword">sizeof</span>(tcoal_prio_params.latency_qos_abstime_max[0]),
    sysctl_timer_user_us_kernel_abstime,
    <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, timer_coalesce_tier1_scale,
    CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.latency_qos_scale[1], 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, timer_coalesce_tier1_ns_max,
    CTLTYPE_QUAD | CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.latency_qos_abstime_max[1],
    <span class="enscript-keyword">sizeof</span>(tcoal_prio_params.latency_qos_abstime_max[1]),
    sysctl_timer_user_us_kernel_abstime,
    <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, timer_coalesce_tier2_scale,
    CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.latency_qos_scale[2], 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, timer_coalesce_tier2_ns_max,
    CTLTYPE_QUAD | CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.latency_qos_abstime_max[2],
    <span class="enscript-keyword">sizeof</span>(tcoal_prio_params.latency_qos_abstime_max[2]),
    sysctl_timer_user_us_kernel_abstime,
    <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, timer_coalesce_tier3_scale,
    CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.latency_qos_scale[3], 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, timer_coalesce_tier3_ns_max,
    CTLTYPE_QUAD | CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.latency_qos_abstime_max[3],
    <span class="enscript-keyword">sizeof</span>(tcoal_prio_params.latency_qos_abstime_max[3]),
    sysctl_timer_user_us_kernel_abstime,
    <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, timer_coalesce_tier4_scale,
    CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.latency_qos_scale[4], 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, timer_coalesce_tier4_ns_max,
    CTLTYPE_QUAD | CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.latency_qos_abstime_max[4],
    <span class="enscript-keyword">sizeof</span>(tcoal_prio_params.latency_qos_abstime_max[4]),
    sysctl_timer_user_us_kernel_abstime,
    <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, timer_coalesce_tier5_scale,
    CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.latency_qos_scale[5], 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-function-name">SYSCTL_PROC</span>(_kern, OID_AUTO, timer_coalesce_tier5_ns_max,
    CTLTYPE_QUAD | CTLFLAG_KERN | CTLFLAG_RW | CTLFLAG_LOCKED,
    &amp;tcoal_prio_params.latency_qos_abstime_max[5],
    <span class="enscript-keyword">sizeof</span>(tcoal_prio_params.latency_qos_abstime_max[5]),
    sysctl_timer_user_us_kernel_abstime,
    <span class="enscript-string">&quot;Q&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* Communicate the &quot;user idle level&quot; heuristic to the timer layer, and
 * potentially other layers in the future.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">timer_user_idle_level</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1, __unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req) {
	<span class="enscript-type">int</span> new_value = 0, old_value = 0, changed = 0, error;

	old_value = timer_get_user_idle_level();

	error = sysctl_io_number(req, old_value, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; changed) {
		<span class="enscript-keyword">if</span> (timer_set_user_idle_level(new_value) != KERN_SUCCESS)
			error = ERANGE;
	}

	<span class="enscript-keyword">return</span> error;
}

<span class="enscript-function-name">SYSCTL_PROC</span>(_machdep, OID_AUTO, user_idle_level,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
    0, 0,
    timer_user_idle_level, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;User idle level heuristic, 0-128&quot;</span>);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">HYPERVISOR</span>
<span class="enscript-function-name">SYSCTL_INT</span>(_kern, OID_AUTO, hv_support, 
		CTLFLAG_KERN | CTLFLAG_RD | CTLFLAG_LOCKED, 
		&amp;hv_support_available, 0, <span class="enscript-string">&quot;&quot;</span>);
#<span class="enscript-reference">endif</span>


</pre>
<hr />
</body></html>