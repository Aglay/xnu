<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>kpi_socket.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">kpi_socket.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2003-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">__KPI__</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/errno.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>

<span class="enscript-type">static</span> errno_t <span class="enscript-function-name">sock_send_internal</span>(socket_t, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> msghdr	*,
    mbuf_t, <span class="enscript-type">int</span>, size_t	*);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">sock_setupcalls_common</span>(socket_t, sock_upcall, <span class="enscript-type">void</span> *,
    sock_upcall, <span class="enscript-type">void</span> *);

errno_t
<span class="enscript-function-name">sock_accept</span>(socket_t sock, <span class="enscript-type">struct</span> sockaddr *from, <span class="enscript-type">int</span> fromlen, <span class="enscript-type">int</span> flags,
    sock_upcall callback, <span class="enscript-type">void</span> *cookie, socket_t *new_sock)
{
	<span class="enscript-type">struct</span> sockaddr *sa;
	<span class="enscript-type">struct</span> socket *new_so;
	lck_mtx_t *mutex_held;
	<span class="enscript-type">int</span> dosocklock;
	errno_t	error = 0;

	<span class="enscript-keyword">if</span> (sock == NULL || new_sock == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	socket_lock(sock, 1);
	<span class="enscript-keyword">if</span> ((sock-&gt;so_options &amp; SO_ACCEPTCONN) == 0) {
		socket_unlock(sock, 1);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">if</span> ((flags &amp; ~(MSG_DONTWAIT)) != 0) {
		socket_unlock(sock, 1);
		<span class="enscript-keyword">return</span> (ENOTSUP);
	}
	<span class="enscript-keyword">if</span> (((flags &amp; MSG_DONTWAIT) != 0 || (sock-&gt;so_state &amp; SS_NBIO) != 0) &amp;&amp;
	    sock-&gt;so_comp.tqh_first == NULL) {
		socket_unlock(sock, 1);
		<span class="enscript-keyword">return</span> (EWOULDBLOCK);
	}

	<span class="enscript-keyword">if</span> (sock-&gt;so_proto-&gt;pr_getlock != NULL)  {
		mutex_held = (*sock-&gt;so_proto-&gt;pr_getlock)(sock, 0);
		dosocklock = 1;
	} <span class="enscript-keyword">else</span> {
		mutex_held = sock-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx;
		dosocklock = 0;
	}

	<span class="enscript-keyword">while</span> (TAILQ_EMPTY(&amp;sock-&gt;so_comp) &amp;&amp; sock-&gt;so_error == 0) {
		<span class="enscript-keyword">if</span> (sock-&gt;so_state &amp; SS_CANTRCVMORE) {
			sock-&gt;so_error = ECONNABORTED;
			<span class="enscript-keyword">break</span>;
		}
		error = msleep((caddr_t)&amp;sock-&gt;so_timeo, mutex_held,
		    PSOCK | PCATCH, <span class="enscript-string">&quot;sock_accept&quot;</span>, NULL);
		<span class="enscript-keyword">if</span> (error != 0) {
			socket_unlock(sock, 1);
			<span class="enscript-keyword">return</span> (error);
		}
	}
	<span class="enscript-keyword">if</span> (sock-&gt;so_error != 0) {
		error = sock-&gt;so_error;
		sock-&gt;so_error = 0;
		socket_unlock(sock, 1);
		<span class="enscript-keyword">return</span> (error);
	}

	new_so = TAILQ_FIRST(&amp;sock-&gt;so_comp);
	TAILQ_REMOVE(&amp;sock-&gt;so_comp, new_so, so_list);
	sock-&gt;so_qlen--;

	<span class="enscript-comment">/*
	 * Pass the pre-accepted socket to any interested socket filter(s).
	 * Upon failure, the socket would have been closed by the callee.
	 */</span>
	<span class="enscript-keyword">if</span> (new_so-&gt;so_filt != NULL) {
		<span class="enscript-comment">/*
		 * Temporarily drop the listening socket's lock before we
		 * hand off control over to the socket filter(s), but keep
		 * a reference so that it won't go away.  We'll grab it
		 * again once we're done with the filter(s).
		 */</span>
		socket_unlock(sock, 0);
		<span class="enscript-keyword">if</span> ((error = soacceptfilter(new_so)) != 0) {
			<span class="enscript-comment">/* Drop reference on listening socket */</span>
			sodereference(sock);
			<span class="enscript-keyword">return</span> (error);
		}
		socket_lock(sock, 0);
	}

	<span class="enscript-keyword">if</span> (dosocklock)	{
		lck_mtx_assert(new_so-&gt;so_proto-&gt;pr_getlock(new_so, 0),
		    LCK_MTX_ASSERT_NOTOWNED);
		socket_lock(new_so, 1);
	}

	new_so-&gt;so_state &amp;= ~SS_COMP;
	new_so-&gt;so_head = NULL;
	(<span class="enscript-type">void</span>) soacceptlock(new_so, &amp;sa, 0);

	socket_unlock(sock, 1);	<span class="enscript-comment">/* release the head */</span>

	<span class="enscript-comment">/* see comments in sock_setupcall() */</span>
	<span class="enscript-keyword">if</span> (callback != NULL) {
		sock_setupcalls_common(new_so, callback, cookie, NULL, NULL);
	}

	<span class="enscript-keyword">if</span> (sa != NULL &amp;&amp; from != NULL) {
		<span class="enscript-keyword">if</span> (fromlen &gt; sa-&gt;sa_len)
			fromlen = sa-&gt;sa_len;
		memcpy(from, sa, fromlen);
	}
	<span class="enscript-keyword">if</span> (sa != NULL)
		FREE(sa, M_SONAME);

	<span class="enscript-comment">/*
	 * If the socket has been marked as inactive by sosetdefunct(),
	 * disallow further operations on it.
	 */</span>
	<span class="enscript-keyword">if</span> (new_so-&gt;so_flags &amp; SOF_DEFUNCT) {
		(<span class="enscript-type">void</span>) sodefunct(current_proc(), new_so,
		    SHUTDOWN_SOCKET_LEVEL_DISCONNECT_INTERNAL);
	}
	*new_sock = new_so;
	<span class="enscript-keyword">if</span> (dosocklock)
		socket_unlock(new_so, 1);
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">sock_bind</span>(socket_t sock, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *to)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> sockaddr *sa = NULL;
	<span class="enscript-type">struct</span> sockaddr_storage ss;
	boolean_t want_free = TRUE;

	<span class="enscript-keyword">if</span> (sock == NULL || to == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (to-&gt;sa_len &gt; <span class="enscript-keyword">sizeof</span> (ss)) {
		MALLOC(sa, <span class="enscript-type">struct</span> sockaddr *, to-&gt;sa_len, M_SONAME, M_WAITOK);
		<span class="enscript-keyword">if</span> (sa == NULL)
			<span class="enscript-keyword">return</span> (ENOBUFS);
	} <span class="enscript-keyword">else</span> {
		sa = (<span class="enscript-type">struct</span> sockaddr *)&amp;ss;
		want_free = FALSE;
	}
	memcpy(sa, to, to-&gt;sa_len);

	error = sobindlock(sock, sa, 1);	<span class="enscript-comment">/* will lock socket */</span>

	<span class="enscript-keyword">if</span> (sa != NULL &amp;&amp; want_free == TRUE)
		FREE(sa, M_SONAME);

	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">sock_connect</span>(socket_t sock, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr *to, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">int</span> error = 0;
	lck_mtx_t *mutex_held;
	<span class="enscript-type">struct</span> sockaddr *sa = NULL;
	<span class="enscript-type">struct</span> sockaddr_storage ss;
	boolean_t want_free = TRUE;

	<span class="enscript-keyword">if</span> (sock == NULL || to == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">if</span> (to-&gt;sa_len &gt; <span class="enscript-keyword">sizeof</span> (ss)) {
		MALLOC(sa, <span class="enscript-type">struct</span> sockaddr *, to-&gt;sa_len, M_SONAME,
		    (flags &amp; MSG_DONTWAIT) ? M_NOWAIT : M_WAITOK);
		<span class="enscript-keyword">if</span> (sa == NULL)
			<span class="enscript-keyword">return</span> (ENOBUFS);
	} <span class="enscript-keyword">else</span> {
		sa = (<span class="enscript-type">struct</span> sockaddr *)&amp;ss;
		want_free = FALSE;
	}
	memcpy(sa, to, to-&gt;sa_len);

	socket_lock(sock, 1);

	<span class="enscript-keyword">if</span> ((sock-&gt;so_state &amp; SS_ISCONNECTING) &amp;&amp;
	    ((sock-&gt;so_state &amp; SS_NBIO) != 0 || (flags &amp; MSG_DONTWAIT) != 0)) {
		error = EALREADY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	error = soconnectlock(sock, sa, 0);
	<span class="enscript-keyword">if</span> (!error) {
		<span class="enscript-keyword">if</span> ((sock-&gt;so_state &amp; SS_ISCONNECTING) &amp;&amp;
		    ((sock-&gt;so_state &amp; SS_NBIO) != 0 ||
		    (flags &amp; MSG_DONTWAIT) != 0)) {
			error = EINPROGRESS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}

		<span class="enscript-keyword">if</span> (sock-&gt;so_proto-&gt;pr_getlock != NULL)
			mutex_held = (*sock-&gt;so_proto-&gt;pr_getlock)(sock, 0);
		<span class="enscript-keyword">else</span>
			mutex_held = sock-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx;

		<span class="enscript-keyword">while</span> ((sock-&gt;so_state &amp; SS_ISCONNECTING) &amp;&amp;
		    sock-&gt;so_error == 0) {
			error = msleep((caddr_t)&amp;sock-&gt;so_timeo,
			    mutex_held, PSOCK | PCATCH, <span class="enscript-string">&quot;sock_connect&quot;</span>, NULL);
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (error == 0) {
			error = sock-&gt;so_error;
			sock-&gt;so_error = 0;
		}
	} <span class="enscript-keyword">else</span> {
		sock-&gt;so_state &amp;= ~SS_ISCONNECTING;
	}
<span class="enscript-reference">out</span>:
	socket_unlock(sock, 1);

	<span class="enscript-keyword">if</span> (sa != NULL &amp;&amp; want_free == TRUE)
		FREE(sa, M_SONAME);

	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">sock_connectwait</span>(socket_t sock, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> timeval *tv)
{
	lck_mtx_t *mutex_held;
	errno_t	retval = 0;
	<span class="enscript-type">struct</span> timespec ts;

	socket_lock(sock, 1);

	<span class="enscript-comment">/* Check if we're already connected or if we've already errored out */</span>
	<span class="enscript-keyword">if</span> ((sock-&gt;so_state &amp; SS_ISCONNECTING) == 0 || sock-&gt;so_error != 0) {
		<span class="enscript-keyword">if</span> (sock-&gt;so_error != 0) {
			retval = sock-&gt;so_error;
			sock-&gt;so_error = 0;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> ((sock-&gt;so_state &amp; SS_ISCONNECTED) != 0)
				retval = 0;
			<span class="enscript-keyword">else</span>
				retval = EINVAL;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* copied translation from timeval to hertz from SO_RCVTIMEO handling */</span>
	<span class="enscript-keyword">if</span> (tv-&gt;tv_sec &lt; 0 || tv-&gt;tv_sec &gt; SHRT_MAX / hz ||
	    tv-&gt;tv_usec &lt; 0 || tv-&gt;tv_usec &gt;= 1000000) {
		retval = EDOM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	ts.tv_sec = tv-&gt;tv_sec;
	ts.tv_nsec = (tv-&gt;tv_usec * (integer_t)NSEC_PER_USEC);
	<span class="enscript-keyword">if</span> ((ts.tv_sec + (ts.tv_nsec/(<span class="enscript-type">long</span>)NSEC_PER_SEC))/100  &gt;  SHRT_MAX)  {
		retval = EDOM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (sock-&gt;so_proto-&gt;pr_getlock != NULL)
		mutex_held = (*sock-&gt;so_proto-&gt;pr_getlock)(sock, 0);
	<span class="enscript-keyword">else</span>
		mutex_held = sock-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx;

	msleep((caddr_t)&amp;sock-&gt;so_timeo, mutex_held,
	    PSOCK, <span class="enscript-string">&quot;sock_connectwait&quot;</span>, &amp;ts);

	<span class="enscript-comment">/* Check if we're still waiting to connect */</span>
	<span class="enscript-keyword">if</span> ((sock-&gt;so_state &amp; SS_ISCONNECTING) &amp;&amp; sock-&gt;so_error == 0) {
		retval = EINPROGRESS;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (sock-&gt;so_error != 0) {
		retval = sock-&gt;so_error;
		sock-&gt;so_error = 0;
	}

<span class="enscript-reference">done</span>:
	socket_unlock(sock, 1);
	<span class="enscript-keyword">return</span> (retval);
}

errno_t
<span class="enscript-function-name">sock_nointerrupt</span>(socket_t sock, <span class="enscript-type">int</span> on)
{
	socket_lock(sock, 1);

	<span class="enscript-keyword">if</span> (on) {
		sock-&gt;so_rcv.sb_flags |= SB_NOINTR;	<span class="enscript-comment">/* This isn't safe */</span>
		sock-&gt;so_snd.sb_flags |= SB_NOINTR;	<span class="enscript-comment">/* This isn't safe */</span>
	} <span class="enscript-keyword">else</span> {
		sock-&gt;so_rcv.sb_flags &amp;= ~SB_NOINTR;	<span class="enscript-comment">/* This isn't safe */</span>
		sock-&gt;so_snd.sb_flags &amp;= ~SB_NOINTR;	<span class="enscript-comment">/* This isn't safe */</span>
	}

	socket_unlock(sock, 1);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">sock_getpeername</span>(socket_t sock, <span class="enscript-type">struct</span> sockaddr	*peername, <span class="enscript-type">int</span> peernamelen)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> sockaddr	*sa = NULL;

	<span class="enscript-keyword">if</span> (sock == NULL || peername == NULL || peernamelen &lt; 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	socket_lock(sock, 1);
	<span class="enscript-keyword">if</span> (!(sock-&gt;so_state &amp; (SS_ISCONNECTED|SS_ISCONFIRMING))) {
		socket_unlock(sock, 1);
		<span class="enscript-keyword">return</span> (ENOTCONN);
	}
	error = sogetaddr_locked(sock, &amp;sa, 1);
	socket_unlock(sock, 1);
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-keyword">if</span> (peernamelen &gt; sa-&gt;sa_len)
			peernamelen = sa-&gt;sa_len;
		memcpy(peername, sa, peernamelen);
		FREE(sa, M_SONAME);
	}
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">sock_getsockname</span>(socket_t sock, <span class="enscript-type">struct</span> sockaddr	*sockname, <span class="enscript-type">int</span> socknamelen)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> sockaddr	*sa = NULL;

	<span class="enscript-keyword">if</span> (sock == NULL || sockname == NULL || socknamelen &lt; 0)
		<span class="enscript-keyword">return</span> (EINVAL);

	socket_lock(sock, 1);
	error = sogetaddr_locked(sock, &amp;sa, 0);
	socket_unlock(sock, 1);
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-keyword">if</span> (socknamelen &gt; sa-&gt;sa_len)
			socknamelen = sa-&gt;sa_len;
		memcpy(sockname, sa, socknamelen);
		FREE(sa, M_SONAME);
	}
	<span class="enscript-keyword">return</span> (error);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">sogetaddr_locked</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **psa, <span class="enscript-type">int</span> peer)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (so == NULL || psa == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	*psa = NULL;
	error = peer ? so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_peeraddr(so, psa) :
	    so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_sockaddr(so, psa);

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; *psa == NULL) {
		error = ENOMEM;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error != 0 &amp;&amp; *psa != NULL) {
		FREE(*psa, M_SONAME);
		*psa = NULL;
	}
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">sock_getaddr</span>(socket_t sock, <span class="enscript-type">struct</span> sockaddr **psa, <span class="enscript-type">int</span> peer)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (sock == NULL || psa == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	socket_lock(sock, 1);
	error = sogetaddr_locked(sock, psa, peer);
	socket_unlock(sock, 1);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">sock_freeaddr</span>(<span class="enscript-type">struct</span> sockaddr *sa)
{
	<span class="enscript-keyword">if</span> (sa != NULL)
		FREE(sa, M_SONAME);
}

errno_t
<span class="enscript-function-name">sock_getsockopt</span>(socket_t sock, <span class="enscript-type">int</span> level, <span class="enscript-type">int</span> optname, <span class="enscript-type">void</span> *optval,
    <span class="enscript-type">int</span>	*optlen)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> sockopt	sopt;

	<span class="enscript-keyword">if</span> (sock == NULL || optval == NULL || optlen == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	sopt.sopt_dir = SOPT_GET;
	sopt.sopt_level = level;
	sopt.sopt_name = optname;
	sopt.sopt_val = CAST_USER_ADDR_T(optval);
	sopt.sopt_valsize = *optlen;
	sopt.sopt_p = kernproc;
	error = sogetoptlock(sock, &amp;sopt, 1);	<span class="enscript-comment">/* will lock socket */</span>
	<span class="enscript-keyword">if</span> (error == 0)
		*optlen = sopt.sopt_valsize;
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">sock_ioctl</span>(socket_t sock, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> request, <span class="enscript-type">void</span> *argp)
{
	<span class="enscript-keyword">return</span> (soioctl(sock, request, argp, kernproc)); <span class="enscript-comment">/* will lock socket */</span>
}

errno_t
<span class="enscript-function-name">sock_setsockopt</span>(socket_t sock, <span class="enscript-type">int</span> level, <span class="enscript-type">int</span> optname, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *optval,
    <span class="enscript-type">int</span>	optlen)
{
	<span class="enscript-type">struct</span> sockopt	sopt;

	<span class="enscript-keyword">if</span> (sock == NULL || optval == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	sopt.sopt_dir = SOPT_SET;
	sopt.sopt_level = level;
	sopt.sopt_name = optname;
	sopt.sopt_val = CAST_USER_ADDR_T(optval);
	sopt.sopt_valsize = optlen;
	sopt.sopt_p = kernproc;
	<span class="enscript-keyword">return</span> (sosetoptlock(sock, &amp;sopt, 1)); <span class="enscript-comment">/* will lock socket */</span>
}

<span class="enscript-comment">/*
 * This follows the recommended mappings between DSCP code points
 * and WMM access classes.
 */</span>
<span class="enscript-type">static</span> u_int32_t <span class="enscript-function-name">so_tc_from_dscp</span>(u_int8_t dscp);
<span class="enscript-type">static</span> u_int32_t
<span class="enscript-function-name">so_tc_from_dscp</span>(u_int8_t dscp)
{
	u_int32_t tc;

	<span class="enscript-keyword">if</span> (dscp &gt;= 0x30 &amp;&amp; dscp &lt;= 0x3f)
		tc = SO_TC_VO;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dscp &gt;= 0x20 &amp;&amp; dscp &lt;= 0x2f)
		tc = SO_TC_VI;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (dscp &gt;= 0x08 &amp;&amp; dscp &lt;= 0x17)
		tc = SO_TC_BK;
	<span class="enscript-keyword">else</span>
		tc = SO_TC_BE;

	<span class="enscript-keyword">return</span> (tc);
}

errno_t
<span class="enscript-function-name">sock_settclassopt</span>(socket_t sock, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *optval, size_t optlen)
{
	errno_t error = 0;
	<span class="enscript-type">struct</span> sockopt sopt;
	<span class="enscript-type">int</span> sotc;

	<span class="enscript-keyword">if</span> (sock == NULL || optval == NULL || optlen != <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">int</span>))
		<span class="enscript-keyword">return</span> (EINVAL);

	socket_lock(sock, 1);
	<span class="enscript-keyword">if</span> (!(sock-&gt;so_state &amp; SS_ISCONNECTED)) {
		<span class="enscript-comment">/*
		 * If the socket is not connected then we don't know
		 * if the destination is on LAN  or not. Skip
		 * setting traffic class in this case
		 */</span>
		error = ENOTCONN;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (sock-&gt;so_proto == NULL || sock-&gt;so_proto-&gt;pr_domain == NULL ||
	    sock-&gt;so_pcb == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Set the socket traffic class based on the passed DSCP code point
	 * regardless of the scope of the destination
	 */</span>
	sotc = so_tc_from_dscp((*(<span class="enscript-type">const</span> <span class="enscript-type">int</span> *)optval) &gt;&gt; 2);

	sopt.sopt_dir = SOPT_SET;
	sopt.sopt_val = CAST_USER_ADDR_T(&amp;sotc);
	sopt.sopt_valsize = <span class="enscript-keyword">sizeof</span> (sotc);
	sopt.sopt_p = kernproc;
	sopt.sopt_level = SOL_SOCKET;
	sopt.sopt_name = SO_TRAFFIC_CLASS;

	error = sosetoptlock(sock, &amp;sopt, 0);	<span class="enscript-comment">/* already locked */</span>

	<span class="enscript-keyword">if</span> (error != 0) {
		printf(<span class="enscript-string">&quot;%s: sosetopt SO_TRAFFIC_CLASS failed %d\n&quot;</span>,
		    __func__, error);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * Check if the destination address is LAN or link local address.
	 * We do not want to set traffic class bits if the destination
	 * is not local.
	 */</span>
	<span class="enscript-keyword">if</span> (!so_isdstlocal(sock))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	sopt.sopt_dir = SOPT_SET;
	sopt.sopt_val = CAST_USER_ADDR_T(optval);
	sopt.sopt_valsize = optlen;
	sopt.sopt_p = kernproc;

	<span class="enscript-keyword">switch</span> (SOCK_DOM(sock)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET</span>:
		sopt.sopt_level = IPPROTO_IP;
		sopt.sopt_name = IP_TOS;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET6</span>:
		sopt.sopt_level = IPPROTO_IPV6;
		sopt.sopt_name = IPV6_TCLASS;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = sosetoptlock(sock, &amp;sopt, 0);	<span class="enscript-comment">/* already locked */</span>
	socket_unlock(sock, 1);
	<span class="enscript-keyword">return</span> (error);
<span class="enscript-reference">out</span>:
	socket_unlock(sock, 1);
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">sock_gettclassopt</span>(socket_t sock, <span class="enscript-type">void</span> *optval, size_t *optlen)
{
	errno_t error = 0;
	<span class="enscript-type">struct</span> sockopt sopt;

	<span class="enscript-keyword">if</span> (sock == NULL || optval == NULL || optlen == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	sopt.sopt_dir = SOPT_GET;
	sopt.sopt_val = CAST_USER_ADDR_T(optval);
	sopt.sopt_valsize = *optlen;
	sopt.sopt_p = kernproc;

	socket_lock(sock, 1);
	<span class="enscript-keyword">if</span> (sock-&gt;so_proto == NULL || sock-&gt;so_proto-&gt;pr_domain == NULL) {
		socket_unlock(sock, 1);
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">switch</span> (SOCK_DOM(sock)) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET</span>:
		sopt.sopt_level = IPPROTO_IP;
		sopt.sopt_name = IP_TOS;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_INET6</span>:
		sopt.sopt_level = IPPROTO_IPV6;
		sopt.sopt_name = IPV6_TCLASS;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		socket_unlock(sock, 1);
		<span class="enscript-keyword">return</span> (EINVAL);

	}
	error = sogetoptlock(sock, &amp;sopt, 0);	<span class="enscript-comment">/* already locked */</span>
	socket_unlock(sock, 1);
	<span class="enscript-keyword">if</span> (error == 0)
		*optlen = sopt.sopt_valsize;
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">sock_listen</span>(socket_t sock, <span class="enscript-type">int</span> backlog)
{
	<span class="enscript-keyword">if</span> (sock == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (solisten(sock, backlog)); <span class="enscript-comment">/* will lock socket */</span>
}

errno_t
<span class="enscript-function-name">sock_receive_internal</span>(socket_t sock, <span class="enscript-type">struct</span> msghdr *msg, mbuf_t *data,
    <span class="enscript-type">int</span> flags, size_t *recvdlen)
{
	uio_t auio;
	<span class="enscript-type">struct</span> mbuf *control = NULL;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> length = 0;
	<span class="enscript-type">struct</span> sockaddr	*fromsa = NULL;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF((msg != NULL) ? msg-&gt;msg_iovlen : 0) ];

	<span class="enscript-keyword">if</span> (sock == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	auio = uio_createwithbuffer(((msg != NULL) ? msg-&gt;msg_iovlen : 0),
	    0, UIO_SYSSPACE, UIO_READ, &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span> (uio_buf));
	<span class="enscript-keyword">if</span> (msg != NULL &amp;&amp; data == NULL) {
		<span class="enscript-type">int</span> i;
		<span class="enscript-type">struct</span> iovec *tempp = msg-&gt;msg_iov;

		<span class="enscript-keyword">for</span> (i = 0; i &lt; msg-&gt;msg_iovlen; i++) {
			uio_addiov(auio,
			    CAST_USER_ADDR_T((tempp + i)-&gt;iov_base),
			    (tempp + i)-&gt;iov_len);
		}
		<span class="enscript-keyword">if</span> (uio_resid(auio) &lt; 0)
			<span class="enscript-keyword">return</span> (EINVAL);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (recvdlen != NULL) {
		uio_setresid(auio, (uio_resid(auio) + *recvdlen));
	}
	length = uio_resid(auio);

	<span class="enscript-keyword">if</span> (recvdlen != NULL)
		*recvdlen = 0;

	<span class="enscript-comment">/* let pru_soreceive handle the socket locking */</span>
	error = sock-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_soreceive(sock, &amp;fromsa, auio,
	    data, (msg &amp;&amp; msg-&gt;msg_control) ? &amp;control : NULL, &amp;flags);
	<span class="enscript-keyword">if</span> (error != 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">cleanup</span>;

	<span class="enscript-keyword">if</span> (recvdlen != NULL)
		*recvdlen = length - uio_resid(auio);
	<span class="enscript-keyword">if</span> (msg != NULL) {
		msg-&gt;msg_flags = flags;

		<span class="enscript-keyword">if</span> (msg-&gt;msg_name != NULL) {
			<span class="enscript-type">int</span> salen;
			salen = msg-&gt;msg_namelen;
			<span class="enscript-keyword">if</span> (msg-&gt;msg_namelen &gt; 0 &amp;&amp; fromsa != NULL) {
				salen = MIN(salen, fromsa-&gt;sa_len);
				memcpy(msg-&gt;msg_name, fromsa,
				    msg-&gt;msg_namelen &gt; fromsa-&gt;sa_len ?
				    fromsa-&gt;sa_len : msg-&gt;msg_namelen);
			}
		}

		<span class="enscript-keyword">if</span> (msg-&gt;msg_control != NULL) {
			<span class="enscript-type">struct</span> mbuf *m = control;
			u_char *ctlbuf = msg-&gt;msg_control;
			<span class="enscript-type">int</span> clen = msg-&gt;msg_controllen;

			msg-&gt;msg_controllen = 0;

			<span class="enscript-keyword">while</span> (m != NULL &amp;&amp; clen &gt; 0) {
				<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> tocopy;

				<span class="enscript-keyword">if</span> (clen &gt;= m-&gt;m_len) {
					tocopy = m-&gt;m_len;
				} <span class="enscript-keyword">else</span> {
					msg-&gt;msg_flags |= MSG_CTRUNC;
					tocopy = clen;
				}
				memcpy(ctlbuf, mtod(m, caddr_t), tocopy);
				ctlbuf += tocopy;
				clen -= tocopy;
				m = m-&gt;m_next;
			}
			msg-&gt;msg_controllen =
			    (uintptr_t)ctlbuf - (uintptr_t)msg-&gt;msg_control;
		}
	}

<span class="enscript-reference">cleanup</span>:
	<span class="enscript-keyword">if</span> (control != NULL)
		m_freem(control);
	<span class="enscript-keyword">if</span> (fromsa != NULL)
		FREE(fromsa, M_SONAME);
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">sock_receive</span>(socket_t sock, <span class="enscript-type">struct</span> msghdr *msg, <span class="enscript-type">int</span> flags, size_t *recvdlen)
{
	<span class="enscript-keyword">if</span> ((msg == NULL) || (msg-&gt;msg_iovlen &lt; 1) ||
	    (msg-&gt;msg_iov[0].iov_len == 0) ||
	    (msg-&gt;msg_iov[0].iov_base == NULL))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (sock_receive_internal(sock, msg, NULL, flags, recvdlen));
}

errno_t
<span class="enscript-function-name">sock_receivembuf</span>(socket_t sock, <span class="enscript-type">struct</span> msghdr *msg, mbuf_t *data, <span class="enscript-type">int</span> flags,
    size_t *recvlen)
{
	<span class="enscript-keyword">if</span> (data == NULL || recvlen == 0 || *recvlen &lt;= 0 || (msg != NULL &amp;&amp;
	    (msg-&gt;msg_iov != NULL || msg-&gt;msg_iovlen != 0)))
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (sock_receive_internal(sock, msg, data, flags, recvlen));
}

errno_t
<span class="enscript-function-name">sock_send_internal</span>(socket_t sock, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> msghdr *msg, mbuf_t data,
    <span class="enscript-type">int</span> flags, size_t *sentlen)
{
	uio_t auio = NULL;
	<span class="enscript-type">struct</span> mbuf *control = NULL;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">int</span> datalen = 0;
	<span class="enscript-type">char</span> uio_buf[ UIO_SIZEOF((msg != NULL ? msg-&gt;msg_iovlen : 1)) ];

	<span class="enscript-keyword">if</span> (sock == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">errorout</span>;
	}

	<span class="enscript-keyword">if</span> (data == NULL &amp;&amp; msg != NULL) {
		<span class="enscript-type">struct</span> iovec *tempp = msg-&gt;msg_iov;

		auio = uio_createwithbuffer(msg-&gt;msg_iovlen, 0,
		    UIO_SYSSPACE, UIO_WRITE, &amp;uio_buf[0], <span class="enscript-keyword">sizeof</span> (uio_buf));
		<span class="enscript-keyword">if</span> (tempp != NULL) {
			<span class="enscript-type">int</span> i;

			<span class="enscript-keyword">for</span> (i = 0; i &lt; msg-&gt;msg_iovlen; i++) {
				uio_addiov(auio,
				    CAST_USER_ADDR_T((tempp + i)-&gt;iov_base),
				    (tempp + i)-&gt;iov_len);
			}

			<span class="enscript-keyword">if</span> (uio_resid(auio) &lt; 0) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">errorout</span>;
			}
		}
	}

	<span class="enscript-keyword">if</span> (sentlen != NULL)
		*sentlen = 0;

	<span class="enscript-keyword">if</span> (auio != NULL)
		datalen = uio_resid(auio);
	<span class="enscript-keyword">else</span>
		datalen = data-&gt;m_pkthdr.len;

	<span class="enscript-keyword">if</span> (msg != NULL &amp;&amp; msg-&gt;msg_control) {
		<span class="enscript-keyword">if</span> ((size_t)msg-&gt;msg_controllen &lt; <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> cmsghdr)) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">errorout</span>;
		}

		<span class="enscript-keyword">if</span> ((size_t)msg-&gt;msg_controllen &gt; MLEN) {
			error = EINVAL;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">errorout</span>;
		}

		control = m_get(M_NOWAIT, MT_CONTROL);
		<span class="enscript-keyword">if</span> (control == NULL) {
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">errorout</span>;
		}
		memcpy(mtod(control, caddr_t), msg-&gt;msg_control,
		    msg-&gt;msg_controllen);
		control-&gt;m_len = msg-&gt;msg_controllen;
	}

	error = sock-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_sosend(sock, msg != NULL ?
	    (<span class="enscript-type">struct</span> sockaddr *)msg-&gt;msg_name : NULL, auio, data,
	    control, flags);

	<span class="enscript-comment">/*
	 * Residual data is possible in the case of IO vectors but not
	 * in the mbuf case since the latter is treated as atomic send.
	 * If pru_sosend() consumed a portion of the iovecs data and
	 * the error returned is transient, treat it as success; this
	 * is consistent with sendit() behavior.
	 */</span>
	<span class="enscript-keyword">if</span> (auio != NULL &amp;&amp; uio_resid(auio) != datalen &amp;&amp;
	    (error == ERESTART || error == EINTR || error == EWOULDBLOCK))
		error = 0;

	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; sentlen != NULL) {
		<span class="enscript-keyword">if</span> (auio != NULL)
			*sentlen = datalen - uio_resid(auio);
		<span class="enscript-keyword">else</span>
			*sentlen = datalen;
	}

	<span class="enscript-keyword">return</span> (error);

<span class="enscript-comment">/*
 * In cases where we detect an error before returning, we need to
 * free the mbuf chain if there is one. sosend (and pru_sosend) will
 * free the mbuf chain if they encounter an error.
 */</span>
<span class="enscript-reference">errorout</span>:
	<span class="enscript-keyword">if</span> (control)
		m_freem(control);
	<span class="enscript-keyword">if</span> (data)
		m_freem(data);
	<span class="enscript-keyword">if</span> (sentlen)
		*sentlen = 0;
	<span class="enscript-keyword">return</span> (error);
}

errno_t
<span class="enscript-function-name">sock_send</span>(socket_t sock, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> msghdr *msg, <span class="enscript-type">int</span> flags, size_t *sentlen)
{
	<span class="enscript-keyword">if</span> (msg == NULL || msg-&gt;msg_iov == NULL || msg-&gt;msg_iovlen &lt; 1)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (sock_send_internal(sock, msg, NULL, flags, sentlen));
}

errno_t
<span class="enscript-function-name">sock_sendmbuf</span>(socket_t sock, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> msghdr *msg, mbuf_t data,
    <span class="enscript-type">int</span>	flags, size_t *sentlen)
{
	<span class="enscript-keyword">if</span> (data == NULL || (msg != NULL &amp;&amp; (msg-&gt;msg_iov != NULL ||
	    msg-&gt;msg_iovlen != 0))) {
		<span class="enscript-keyword">if</span> (data != NULL)
			m_freem(data);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	<span class="enscript-keyword">return</span> (sock_send_internal(sock, msg, data, flags, sentlen));
}

errno_t
<span class="enscript-function-name">sock_shutdown</span>(socket_t sock, <span class="enscript-type">int</span> how)
{
	<span class="enscript-keyword">if</span> (sock == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-keyword">return</span> (soshutdown(sock, how));
}


errno_t
<span class="enscript-function-name">sock_socket</span>(<span class="enscript-type">int</span>	domain, <span class="enscript-type">int</span> type, <span class="enscript-type">int</span> protocol, sock_upcall callback,
    <span class="enscript-type">void</span> *context, socket_t *new_so)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (new_so == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/* socreate will create an initial so_count */</span>
	error = socreate(domain, new_so, type, protocol);
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-comment">/* see comments in sock_setupcall() */</span>
		<span class="enscript-keyword">if</span> (callback != NULL) {
			sock_setupcalls_common(*new_so, callback, context,
			    NULL, NULL);
		}
		<span class="enscript-comment">/* 
		 * last_pid and last_upid should be zero for sockets
		 * created using sock_socket
		 */</span>
		(*new_so)-&gt;last_pid = 0;
		(*new_so)-&gt;last_upid = 0;
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">sock_close</span>(socket_t sock)
{
	<span class="enscript-keyword">if</span> (sock == NULL)
		<span class="enscript-keyword">return</span>;

	soclose(sock);
}

<span class="enscript-comment">/* Do we want this to be APPLE_PRIVATE API?: YES (LD 12/23/04) */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">sock_retain</span>(socket_t sock)
{
	<span class="enscript-keyword">if</span> (sock == NULL)
		<span class="enscript-keyword">return</span>;

	socket_lock(sock, 1);
	sock-&gt;so_retaincnt++;
	sock-&gt;so_usecount++;	<span class="enscript-comment">/* add extra reference for holding the socket */</span>
	socket_unlock(sock, 1);
}

<span class="enscript-comment">/* Do we want this to be APPLE_PRIVATE API? */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">sock_release</span>(socket_t sock)
{
	<span class="enscript-keyword">if</span> (sock == NULL)
		<span class="enscript-keyword">return</span>;

	socket_lock(sock, 1);
	<span class="enscript-keyword">if</span> (sock-&gt;so_upcallusecount &gt; 0)
		soclose_wait_locked(sock);

	sock-&gt;so_retaincnt--;
	<span class="enscript-keyword">if</span> (sock-&gt;so_retaincnt &lt; 0) {
		panic(<span class="enscript-string">&quot;%s: negative retain count (%d) for sock=%p\n&quot;</span>,
		    __func__, sock-&gt;so_retaincnt, sock);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> ((sock-&gt;so_retaincnt == 0) &amp;&amp; (sock-&gt;so_usecount == 2)) {
		<span class="enscript-comment">/* close socket only if the FD is not holding it */</span>
		soclose_locked(sock);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* remove extra reference holding the socket */</span>
		sock-&gt;so_usecount--;
	}
	socket_unlock(sock, 1);
}

errno_t
<span class="enscript-function-name">sock_setpriv</span>(socket_t sock, <span class="enscript-type">int</span> on)
{
	<span class="enscript-keyword">if</span> (sock == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	socket_lock(sock, 1);
	<span class="enscript-keyword">if</span> (on)
		sock-&gt;so_state |= SS_PRIV;
	<span class="enscript-keyword">else</span>
		sock-&gt;so_state &amp;= ~SS_PRIV;
	socket_unlock(sock, 1);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sock_isconnected</span>(socket_t sock)
{
	<span class="enscript-type">int</span> retval;

	socket_lock(sock, 1);
	retval = ((sock-&gt;so_state &amp; SS_ISCONNECTED) ? 1 : 0);
	socket_unlock(sock, 1);
	<span class="enscript-keyword">return</span> (retval);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sock_isnonblocking</span>(socket_t sock)
{
	<span class="enscript-type">int</span> retval;

	socket_lock(sock, 1);
	retval = ((sock-&gt;so_state &amp; SS_NBIO) ? 1 : 0);
	socket_unlock(sock, 1);
	<span class="enscript-keyword">return</span> (retval);
}

errno_t
<span class="enscript-function-name">sock_gettype</span>(socket_t sock, <span class="enscript-type">int</span> *outDomain, <span class="enscript-type">int</span> *outType, <span class="enscript-type">int</span> *outProtocol)
{
	socket_lock(sock, 1);
	<span class="enscript-keyword">if</span> (outDomain != NULL)
		*outDomain = SOCK_DOM(sock);
	<span class="enscript-keyword">if</span> (outType != NULL)
		*outType = sock-&gt;so_type;
	<span class="enscript-keyword">if</span> (outProtocol != NULL)
		*outProtocol = SOCK_PROTO(sock);
	socket_unlock(sock, 1);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Return the listening socket of a pre-accepted socket.  It returns the
 * listener (so_head) value of a given socket.  This is intended to be
 * called by a socket filter during a filter attach (sf_attach) callback.
 * The value returned by this routine is safe to be used only in the
 * context of that callback, because we hold the listener's lock across
 * the sflt_initsock() call.
 */</span>
socket_t
<span class="enscript-function-name">sock_getlistener</span>(socket_t sock)
{
	<span class="enscript-keyword">return</span> (sock-&gt;so_head);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">sock_set_tcp_stream_priority</span>(socket_t sock)
{
	<span class="enscript-keyword">if</span> ((SOCK_DOM(sock) == PF_INET || SOCK_DOM(sock) == PF_INET6) &amp;&amp;
	    SOCK_TYPE(sock) == SOCK_STREAM) {
		set_tcp_stream_priority(sock);
	}
}

<span class="enscript-comment">/*
 * Caller must have ensured socket is valid and won't be going away.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">socket_set_traffic_mgt_flags_locked</span>(socket_t sock, u_int8_t flags)
{
	(<span class="enscript-type">void</span>) OSBitOrAtomic8(flags, &amp;sock-&gt;so_traffic_mgt_flags);
	sock_set_tcp_stream_priority(sock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">socket_set_traffic_mgt_flags</span>(socket_t sock, u_int8_t flags)
{
	socket_lock(sock, 1);
	socket_set_traffic_mgt_flags_locked(sock, flags);
	socket_unlock(sock, 1);
}

<span class="enscript-comment">/*
 * Caller must have ensured socket is valid and won't be going away.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">socket_clear_traffic_mgt_flags_locked</span>(socket_t sock, u_int8_t flags)
{
	(<span class="enscript-type">void</span>) OSBitAndAtomic8(~flags, &amp;sock-&gt;so_traffic_mgt_flags);
	sock_set_tcp_stream_priority(sock);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">socket_clear_traffic_mgt_flags</span>(socket_t sock, u_int8_t flags)
{
	socket_lock(sock, 1);
	socket_clear_traffic_mgt_flags_locked(sock, flags);
	socket_unlock(sock, 1);
}


<span class="enscript-comment">/*
 * Caller must have ensured socket is valid and won't be going away.
 */</span>
errno_t
<span class="enscript-function-name">socket_defunct</span>(<span class="enscript-type">struct</span> proc *p, socket_t so, <span class="enscript-type">int</span> level)
{
	errno_t retval;

	<span class="enscript-keyword">if</span> (level != SHUTDOWN_SOCKET_LEVEL_DISCONNECT_SVC &amp;&amp;
	    level != SHUTDOWN_SOCKET_LEVEL_DISCONNECT_ALL)
		<span class="enscript-keyword">return</span> (EINVAL);

	socket_lock(so, 1);
	<span class="enscript-comment">/*
	 * SHUTDOWN_SOCKET_LEVEL_DISCONNECT_SVC level is meant to tear down
	 * all of mDNSResponder IPC sockets, currently those of AF_UNIX; note
	 * that this is an implementation artifact of mDNSResponder.  We do
	 * a quick test against the socket buffers for SB_UNIX, since that
	 * would have been set by unp_attach() at socket creation time.
	 */</span>
	<span class="enscript-keyword">if</span> (level == SHUTDOWN_SOCKET_LEVEL_DISCONNECT_SVC &amp;&amp;
	    (so-&gt;so_rcv.sb_flags &amp; so-&gt;so_snd.sb_flags &amp; SB_UNIX) != SB_UNIX) {
		socket_unlock(so, 1);
		<span class="enscript-keyword">return</span> (EOPNOTSUPP);
	}
	retval = sosetdefunct(p, so, level, TRUE);
	<span class="enscript-keyword">if</span> (retval == 0)
		retval = sodefunct(p, so, level);
	socket_unlock(so, 1);
	<span class="enscript-keyword">return</span> (retval);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">sock_setupcalls_common</span>(socket_t sock, sock_upcall rcallback, <span class="enscript-type">void</span> *rcontext,
    sock_upcall wcallback, <span class="enscript-type">void</span> *wcontext)
{
	<span class="enscript-keyword">if</span> (rcallback != NULL) {
		sock-&gt;so_rcv.sb_flags |= SB_UPCALL;
		sock-&gt;so_rcv.sb_upcall = rcallback;
		sock-&gt;so_rcv.sb_upcallarg = rcontext;
	} <span class="enscript-keyword">else</span> {
		sock-&gt;so_rcv.sb_flags &amp;= ~SB_UPCALL;
		sock-&gt;so_rcv.sb_upcall = NULL;
		sock-&gt;so_rcv.sb_upcallarg = NULL;
	}

	<span class="enscript-keyword">if</span> (wcallback != NULL) {
		sock-&gt;so_snd.sb_flags |= SB_UPCALL;
		sock-&gt;so_snd.sb_upcall = wcallback;
		sock-&gt;so_snd.sb_upcallarg = wcontext;
	} <span class="enscript-keyword">else</span> {
		sock-&gt;so_snd.sb_flags &amp;= ~SB_UPCALL;
		sock-&gt;so_snd.sb_upcall = NULL;
		sock-&gt;so_snd.sb_upcallarg = NULL;
	}
}

errno_t
<span class="enscript-function-name">sock_setupcall</span>(socket_t sock, sock_upcall callback, <span class="enscript-type">void</span> *context)
{
	<span class="enscript-keyword">if</span> (sock == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/*
	 * Note that we don't wait for any in progress upcall to complete.
	 * On embedded, sock_setupcall() causes both read and write
	 * callbacks to be set; on desktop, only read callback is set
	 * to maintain legacy KPI behavior.
	 *
	 * The newer sock_setupcalls() KPI should be used instead to set
	 * the read and write callbacks and their respective parameters.
	 */</span>
	socket_lock(sock, 1);
	sock_setupcalls_common(sock, callback, context, NULL, NULL);
	socket_unlock(sock, 1);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">sock_setupcalls</span>(socket_t sock, sock_upcall rcallback, <span class="enscript-type">void</span> *rcontext,
    sock_upcall wcallback, <span class="enscript-type">void</span> *wcontext)
{
	<span class="enscript-keyword">if</span> (sock == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/*
	 * Note that we don't wait for any in progress upcall to complete.
	 */</span>
	socket_lock(sock, 1);
	sock_setupcalls_common(sock, rcallback, rcontext, wcallback, wcontext);
	socket_unlock(sock, 1);

	<span class="enscript-keyword">return</span> (0);
}

errno_t
<span class="enscript-function-name">sock_catchevents</span>(socket_t sock, sock_evupcall ecallback, <span class="enscript-type">void</span> *econtext,
    u_int32_t emask)
{
	<span class="enscript-keyword">if</span> (sock == NULL)
		<span class="enscript-keyword">return</span> (EINVAL);

	<span class="enscript-comment">/*
	 * Note that we don't wait for any in progress upcall to complete.
	 */</span>
	socket_lock(sock, 1);
	<span class="enscript-keyword">if</span> (ecallback != NULL) {
		sock-&gt;so_event = ecallback;
		sock-&gt;so_eventarg = econtext;
		sock-&gt;so_eventmask = emask;
	} <span class="enscript-keyword">else</span> {
		sock-&gt;so_event = sonullevent;
		sock-&gt;so_eventarg = NULL;
		sock-&gt;so_eventmask = 0;
	}
	socket_unlock(sock, 1);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Returns true whether or not a socket belongs to the kernel.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">sock_iskernel</span>(socket_t so)
{
	<span class="enscript-keyword">return</span> (so &amp;&amp; so-&gt;last_pid == 0);
}
</pre>
<hr />
</body></html>