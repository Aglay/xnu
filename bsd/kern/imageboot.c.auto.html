<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>imageboot.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">imageboot.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2006 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/imageboot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> filedesc filedesc0;

<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (*mountroot)(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">char</span> rootdevice[];

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DEBUG_IMAGEBOOT</span> 0

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG_IMAGEBOOT</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DBG_TRACE</span>(...) printf(__VA_ARGS__)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DBG_TRACE</span>(...) do {} while(0)
#<span class="enscript-reference">endif</span>

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">di_root_image</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *path, <span class="enscript-type">char</span> devname[], dev_t *dev_p);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">imageboot_setup_new</span>(<span class="enscript-type">void</span>);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kIBFilePrefix</span> <span class="enscript-string">&quot;file://&quot;</span>

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">imageboot_format_is_valid</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *root_path)
{
	<span class="enscript-keyword">return</span> (strncmp(root_path, kIBFilePrefix,
				strlen(kIBFilePrefix)) == 0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">vnode_get_and_drop_always</span>(vnode_t vp) 
{
	vnode_getalways(vp);
	vnode_rele(vp);
	vnode_put(vp);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">imageboot_needed</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> result = 0;
	<span class="enscript-type">char</span> *root_path = NULL;
	
	DBG_TRACE(<span class="enscript-string">&quot;%s: checking for presence of root path\n&quot;</span>, __FUNCTION__);

	MALLOC_ZONE(root_path, caddr_t, MAXPATHLEN, M_NAMEI, M_WAITOK);
	<span class="enscript-keyword">if</span> (root_path == NULL)
		panic(<span class="enscript-string">&quot;%s: M_NAMEI zone exhausted&quot;</span>, __FUNCTION__);

	<span class="enscript-comment">/* Check for first layer */</span>
	<span class="enscript-keyword">if</span> (!(PE_parse_boot_argn(<span class="enscript-string">&quot;rp0&quot;</span>, root_path, MAXPATHLEN) || 
			PE_parse_boot_argn(<span class="enscript-string">&quot;rp&quot;</span>, root_path, MAXPATHLEN) ||
			PE_parse_boot_argn(IMAGEBOOT_ROOT_ARG, root_path, MAXPATHLEN))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	
	<span class="enscript-comment">/* Sanity-check first layer */</span>
	<span class="enscript-keyword">if</span> (imageboot_format_is_valid(root_path)) {
		DBG_TRACE(<span class="enscript-string">&quot;%s: Found %s\n&quot;</span>, __FUNCTION__, root_path);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	result = 1;

	<span class="enscript-comment">/* Check for second layer */</span>
	<span class="enscript-keyword">if</span> (!(PE_parse_boot_argn(<span class="enscript-string">&quot;rp1&quot;</span>, root_path, MAXPATHLEN) ||
			PE_parse_boot_argn(IMAGEBOOT_CONTAINER_ARG, root_path, MAXPATHLEN))) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Sanity-check second layer */</span>
	<span class="enscript-keyword">if</span> (imageboot_format_is_valid(root_path)) {
		DBG_TRACE(<span class="enscript-string">&quot;%s: Found %s\n&quot;</span>, __FUNCTION__, root_path);
	} <span class="enscript-keyword">else</span> {
		panic(<span class="enscript-string">&quot;%s: Invalid URL scheme for %s\n&quot;</span>,
				__FUNCTION__, root_path);
	}

<span class="enscript-reference">out</span>:
	FREE_ZONE(root_path, MAXPATHLEN, M_NAMEI);

	<span class="enscript-keyword">return</span> (result);
}


<span class="enscript-comment">/*
 * Swaps in new root filesystem based on image path.
 * Current root filesystem is removed from mount list and
 * tagged MNTK_BACKS_ROOT, MNT_ROOTFS is cleared on it, and 
 * &quot;rootvnode&quot; is reset.  Root vnode of currentroot filesystem 
 * is returned with usecount (no iocount).
 */</span>
__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">imageboot_mount_image</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *root_path, <span class="enscript-type">int</span> height)
{
	dev_t       	dev;
	<span class="enscript-type">int</span> 		error;
	vnode_t 	old_rootvnode = NULL;
	vnode_t 	newdp;
	mount_t 	new_rootfs;

	error = di_root_image(root_path, rootdevice, &amp;dev);
	<span class="enscript-keyword">if</span> (error) {
		panic(<span class="enscript-string">&quot;%s: di_root_image failed: %d\n&quot;</span>, __FUNCTION__, error);
	}

	rootdev = dev;
	mountroot = NULL;
	printf(<span class="enscript-string">&quot;%s: root device 0x%x\n&quot;</span>, __FUNCTION__, rootdev);
	error = vfs_mountroot();
	<span class="enscript-keyword">if</span> (error != 0) {
		panic(<span class="enscript-string">&quot;vfs_mountroot() failed.\n&quot;</span>);
	}

	<span class="enscript-comment">/*
	 * Get the vnode for '/'.
	 * Set fdp-&gt;fd_fd.fd_cdir to reference it.
	 */</span>
	<span class="enscript-keyword">if</span> (VFS_ROOT(TAILQ_LAST(&amp;mountlist,mntlist), &amp;newdp, vfs_context_kernel()))
		panic(<span class="enscript-string">&quot;%s: cannot find root vnode&quot;</span>, __FUNCTION__);

	<span class="enscript-keyword">if</span> (rootvnode != NULL) {
		<span class="enscript-comment">/* remember the old rootvnode, but remove it from mountlist */</span>
		mount_t 	old_rootfs;

		old_rootvnode = rootvnode;
		old_rootfs = rootvnode-&gt;v_mount;
	
		mount_list_remove(old_rootfs);
	
		mount_lock(old_rootfs);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_IMGSRC_ACCESS</span>
		old_rootfs-&gt;mnt_kern_flag |= MNTK_BACKS_ROOT;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IMGSRC_ACCESS */</span>
		old_rootfs-&gt;mnt_flag &amp;= ~MNT_ROOTFS;
		mount_unlock(old_rootfs);
	}

	<span class="enscript-comment">/* switch to the new rootvnode */</span>
	rootvnode = newdp;

	new_rootfs = rootvnode-&gt;v_mount;
	mount_lock(new_rootfs);
	new_rootfs-&gt;mnt_flag |= MNT_ROOTFS;
	mount_unlock(new_rootfs);

	vnode_ref(newdp);
	vnode_put(newdp);
	filedesc0.fd_cdir = newdp;
	DBG_TRACE(<span class="enscript-string">&quot;%s: root switched\n&quot;</span>, __FUNCTION__);

	<span class="enscript-keyword">if</span> (old_rootvnode != NULL) {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">CONFIG_IMGSRC_ACCESS</span>
	    <span class="enscript-keyword">if</span> (height &gt;= 0 &amp;&amp; PE_imgsrc_mount_supported()) {
		imgsrc_rootvnodes[height] = old_rootvnode;
	    } <span class="enscript-keyword">else</span> {
		vnode_get_and_drop_always(old_rootvnode);
	    }
#<span class="enscript-reference">else</span> 
	    height = 0; <span class="enscript-comment">/* keep the compiler from complaining */</span>
	    vnode_get_and_drop_always(old_rootvnode);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_IMGSRC_ACCESS */</span>
	}
	<span class="enscript-keyword">return</span> 0;
}

<span class="enscript-type">static</span> boolean_t 
<span class="enscript-function-name">imageboot_setup_new</span>()
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">char</span> *root_path = NULL;
	<span class="enscript-type">int</span> height = 0;
	boolean_t done = FALSE;

	MALLOC_ZONE(root_path, caddr_t, MAXPATHLEN, M_NAMEI, M_WAITOK);
	assert(root_path != NULL);

	<span class="enscript-keyword">if</span>(PE_parse_boot_argn(IMAGEBOOT_CONTAINER_ARG, root_path, MAXPATHLEN) == TRUE) {
		printf(<span class="enscript-string">&quot;%s: container image url is %s\n&quot;</span>, __FUNCTION__, root_path);
		error = imageboot_mount_image(root_path, height);
		<span class="enscript-keyword">if</span> (error != 0) {
			panic(<span class="enscript-string">&quot;Failed to mount container image.&quot;</span>);
		}

		height++;
	}

	<span class="enscript-keyword">if</span> (PE_parse_boot_argn(IMAGEBOOT_ROOT_ARG, root_path, MAXPATHLEN) == FALSE) {
		<span class="enscript-keyword">if</span> (height &gt; 0) {
			panic(<span class="enscript-string">&quot;%s specified without %s?\n&quot;</span>, IMAGEBOOT_CONTAINER_ARG, IMAGEBOOT_ROOT_ARG);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	}

	printf(<span class="enscript-string">&quot;%s: root image url is %s\n&quot;</span>, __FUNCTION__, root_path);

	error = imageboot_mount_image(root_path, height);
	<span class="enscript-keyword">if</span> (error != 0) {
		panic(<span class="enscript-string">&quot;Failed to mount root image.&quot;</span>);
	}

	done = TRUE;

<span class="enscript-reference">out</span>:
	FREE_ZONE(root_path, MAXPATHLEN, M_NAMEI);
	<span class="enscript-keyword">return</span> done;
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">imageboot_setup</span>()
{
	<span class="enscript-type">int</span>         error = 0;
	<span class="enscript-type">char</span> *root_path = NULL;

	DBG_TRACE(<span class="enscript-string">&quot;%s: entry\n&quot;</span>, __FUNCTION__);

	<span class="enscript-keyword">if</span> (rootvnode == NULL) {	
		panic(<span class="enscript-string">&quot;imageboot_setup: rootvnode is NULL.&quot;</span>);
	}

	<span class="enscript-comment">/*
	 * New boot-arg scheme:
	 * 	root-dmg : the dmg that will be the root filesystem.
	 * 	container-dmg : an optional dmg that contains the root-dmg.
	 */</span>
	<span class="enscript-keyword">if</span> (imageboot_setup_new()) {
		<span class="enscript-keyword">return</span>;
	}
	
	MALLOC_ZONE(root_path, caddr_t, MAXPATHLEN, M_NAMEI, M_WAITOK);
	assert(root_path != NULL);

	<span class="enscript-comment">/*
	 * Look for outermost disk image to root from.  If we're doing a nested boot,
	 * there's some sense in which the outer image never needs to be the root filesystem,
	 * but it does need very similar treatment: it must not be unmounted, needs a fake
	 * device vnode created for it, and should not show up in getfsstat() until exposed 
	 * with MNT_IMGSRC. We just make it the temporary root.
	 */</span>
	<span class="enscript-keyword">if</span>((PE_parse_boot_argn(<span class="enscript-string">&quot;rp&quot;</span>, root_path, MAXPATHLEN) == FALSE) &amp;&amp;
		(PE_parse_boot_argn(<span class="enscript-string">&quot;rp0&quot;</span>, root_path, MAXPATHLEN) == FALSE)) {
		panic(<span class="enscript-string">&quot;%s: no valid path to image.\n&quot;</span>, __FUNCTION__);
	}

	printf(<span class="enscript-string">&quot;%s: root image url is %s\n&quot;</span>, __FUNCTION__, root_path);
	
	error = imageboot_mount_image(root_path, 0);
	<span class="enscript-keyword">if</span> (error) {
		panic(<span class="enscript-string">&quot;Failed on first stage of imageboot.&quot;</span>);
	}

	<span class="enscript-comment">/*
	 * See if we are rooting from a nested image
	 */</span>
	<span class="enscript-keyword">if</span>(PE_parse_boot_argn(<span class="enscript-string">&quot;rp1&quot;</span>, root_path, MAXPATHLEN) == FALSE) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}
	
	printf(<span class="enscript-string">&quot;%s: second level root image url is %s\n&quot;</span>, __FUNCTION__, root_path);

	<span class="enscript-comment">/*
	 * If we fail to set up second image, it's not a given that we
	 * can safely root off the first.  
	 */</span>
	error = imageboot_mount_image(root_path, 1);
	<span class="enscript-keyword">if</span> (error) {
		panic(<span class="enscript-string">&quot;Failed on second stage of imageboot.&quot;</span>);	
	}

<span class="enscript-reference">done</span>:
	FREE_ZONE(root_path, MAXPATHLEN, M_NAMEI);

	DBG_TRACE(<span class="enscript-string">&quot;%s: exit\n&quot;</span>, __FUNCTION__);

	<span class="enscript-keyword">return</span>;
}
</pre>
<hr />
</body></html>