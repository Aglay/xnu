<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>uipc_socket.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">uipc_socket.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2015 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)uipc_socket.c	8.3 (Berkeley) 4/15/94
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/fcntl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/poll.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/resourcevar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ev.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kdebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/un.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/priv.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kern_event.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/init.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/content_filter.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/ip6.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet6/ip6_var.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/flow_divert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/locks.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/limits.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/assert.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/task.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kpi_mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/unpcb.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MULTIPATH</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mp_pcb.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/mptcp_var.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MULTIPATH */</span>

#<span class="enscript-reference">define</span> <span class="enscript-function-name">ROUNDUP</span>(a, b) (((a) + ((b) - 1)) &amp; (~((b) - 1)))

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span> || <span class="enscript-variable-name">DEVELOPMENT</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DEBUG_KERNEL_ADDRPERM</span>(_v) (_v)
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">DEBUG_KERNEL_ADDRPERM</span>(_v) VM_KERNEL_ADDRPERM(_v)
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* TODO: this should be in a header file somewhere */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">proc_name_address</span>(<span class="enscript-type">void</span> *p);

<span class="enscript-type">static</span> u_int32_t	so_cache_hw;	<span class="enscript-comment">/* High water mark for socache */</span>
<span class="enscript-type">static</span> u_int32_t	so_cache_timeouts;	<span class="enscript-comment">/* number of timeouts */</span>
<span class="enscript-type">static</span> u_int32_t	so_cache_max_freed;	<span class="enscript-comment">/* max freed per timeout */</span>
<span class="enscript-type">static</span> u_int32_t	cached_sock_count = 0;
<span class="enscript-function-name">STAILQ_HEAD</span>(, socket)	so_cache_head;
<span class="enscript-type">int</span>	max_cached_sock_count = MAX_CACHED_SOCKETS;
<span class="enscript-type">static</span> u_int32_t	so_cache_time;
<span class="enscript-type">static</span> <span class="enscript-type">int</span>		socketinit_done;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone	*so_cache_zone;

<span class="enscript-type">static</span> lck_grp_t	*so_cache_mtx_grp;
<span class="enscript-type">static</span> lck_attr_t	*so_cache_mtx_attr;
<span class="enscript-type">static</span> lck_grp_attr_t	*so_cache_mtx_grp_attr;
<span class="enscript-type">static</span> lck_mtx_t	*so_cache_mtx;

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/limits.h&gt;</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>	filt_sordetach(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	filt_soread(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	filt_sowdetach(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	filt_sowrite(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	filt_sockdetach(<span class="enscript-type">struct</span> knote *kn);
<span class="enscript-type">static</span> <span class="enscript-type">int</span>	filt_sockev(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint);
<span class="enscript-type">static</span> <span class="enscript-type">void</span>	filt_socktouch(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">struct</span> kevent_internal_s *kev,
    <span class="enscript-type">long</span> type);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">sooptcopyin_timeval</span>(<span class="enscript-type">struct</span> sockopt *, <span class="enscript-type">struct</span> timeval *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">sooptcopyout_timeval</span>(<span class="enscript-type">struct</span> sockopt *, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> timeval *);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> filterops soread_filtops = {
	.f_isfd = 1,
	.f_detach = filt_sordetach,
	.f_event = filt_soread,
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> filterops sowrite_filtops = {
	.f_isfd = 1,
	.f_detach = filt_sowdetach,
	.f_event = filt_sowrite,
};

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> filterops sock_filtops = {
	.f_isfd = 1,
	.f_detach = filt_sockdetach,
	.f_event = filt_sockev,
	.f_touch = filt_socktouch,
};

<span class="enscript-function-name">SYSCTL_DECL</span>(_kern_ipc);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">EVEN_MORE_LOCKING_DEBUG</span> 0

<span class="enscript-type">int</span> socket_debug = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, socket_debug,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;socket_debug, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> socket_zone = M_SOCKET;
so_gen_t	so_gencnt;	<span class="enscript-comment">/* generation count for sockets */</span>

<span class="enscript-function-name">MALLOC_DEFINE</span>(M_SONAME, <span class="enscript-string">&quot;soname&quot;</span>, <span class="enscript-string">&quot;socket name&quot;</span>);
<span class="enscript-function-name">MALLOC_DEFINE</span>(M_PCB, <span class="enscript-string">&quot;pcb&quot;</span>, <span class="enscript-string">&quot;protocol control block&quot;</span>);

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_LAYER_IN_BEG</span>	NETDBG_CODE(DBG_NETSOCK, 0)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_LAYER_IN_END</span>	NETDBG_CODE(DBG_NETSOCK, 2)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_LAYER_OUT_BEG</span>	NETDBG_CODE(DBG_NETSOCK, 1)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_LAYER_OUT_END</span>	NETDBG_CODE(DBG_NETSOCK, 3)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_FNC_SOSEND</span>		NETDBG_CODE(DBG_NETSOCK, (4 &lt;&lt; 8) | 1)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_FNC_SOSEND_LIST</span>	NETDBG_CODE(DBG_NETSOCK, (4 &lt;&lt; 8) | 3)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_FNC_SORECEIVE</span>	NETDBG_CODE(DBG_NETSOCK, (8 &lt;&lt; 8))
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_FNC_SORECEIVE_LIST</span>	NETDBG_CODE(DBG_NETSOCK, (8 &lt;&lt; 8) | 3)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">DBG_FNC_SOSHUTDOWN</span>	NETDBG_CODE(DBG_NETSOCK, (9 &lt;&lt; 8))

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MAX_SOOPTGETM_SIZE</span>	(128 * MCLBYTES)

<span class="enscript-type">int</span> somaxconn = SOMAXCONN;
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, KIPC_SOMAXCONN, somaxconn,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;somaxconn, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/* Should we get a maximum also ??? */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sosendmaxchain = 65536;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sosendminchain = 16384;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> sorecvmincopy  = 16384;
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, sosendminchain,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;sosendminchain, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, sorecvmincopy,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;sorecvmincopy, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/*
 * Set to enable jumbo clusters (if available) for large writes when
 * the socket is marked with SOF_MULTIPAGES; see below.
 */</span>
<span class="enscript-type">int</span> sosendjcl = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, sosendjcl,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;sosendjcl, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/*
 * Set this to ignore SOF_MULTIPAGES and use jumbo clusters for large
 * writes on the socket for all protocols on any network interfaces,
 * depending upon sosendjcl above.  Be extra careful when setting this
 * to 1, because sending down packets that cross physical pages down to
 * broken drivers (those that falsely assume that the physical pages
 * are contiguous) might lead to system panics or silent data corruption.
 * When set to 0, the system will respect SOF_MULTIPAGES, which is set
 * only for TCP sockets whose outgoing interface is IFNET_MULTIPAGES
 * capable.  Set this to 1 only for testing/debugging purposes.
 */</span>
<span class="enscript-type">int</span> sosendjcl_ignore_capab = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, sosendjcl_ignore_capab,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;sosendjcl_ignore_capab, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-comment">/*
 * Set this to ignore SOF1_IF_2KCL and use big clusters for large
 * writes on the socket for all protocols on any network interfaces.
 * Be extra careful when setting this to 1, because sending down packets with
 * clusters larger that 2 KB might lead to system panics or data corruption.
 * When set to 0, the system will respect SOF1_IF_2KCL, which is set
 * on the outgoing interface
 * Set this to 1  for testing/debugging purposes only.
 */</span>
<span class="enscript-type">int</span> sosendbigcl_ignore_capab = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, sosendbigcl_ignore_capab,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;sosendbigcl_ignore_capab, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">int</span> sodefunctlog = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, sodefunctlog, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;sodefunctlog, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">int</span> sothrottlelog = 0;
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, sothrottlelog, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;sothrottlelog, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">int</span> sorestrictrecv = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, sorestrictrecv, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;sorestrictrecv, 0, <span class="enscript-string">&quot;Enable inbound interface restrictions&quot;</span>);

<span class="enscript-type">int</span> sorestrictsend = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, sorestrictsend, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;sorestrictsend, 0, <span class="enscript-string">&quot;Enable outbound interface restrictions&quot;</span>);

<span class="enscript-type">int</span> soreserveheadroom = 1;
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, soreserveheadroom, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;soreserveheadroom, 0, <span class="enscript-string">&quot;To allocate contiguous datagram buffers&quot;</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">struct</span> inpcbinfo tcbinfo;

<span class="enscript-comment">/* TODO: these should be in header file */</span>
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">get_inpcb_str_size</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">int</span> <span class="enscript-function-name">get_tcp_str_size</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> sl_zone_size;		<span class="enscript-comment">/* size of sockaddr_list */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *sl_zone;			<span class="enscript-comment">/* zone for sockaddr_list */</span>

<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> se_zone_size;		<span class="enscript-comment">/* size of sockaddr_entry */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> zone *se_zone;			<span class="enscript-comment">/* zone for sockaddr_entry */</span>

vm_size_t	so_cache_zone_element_size;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">sodelayed_copy</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">struct</span> uio *, <span class="enscript-type">struct</span> mbuf **,
    user_ssize_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cached_sock_alloc</span>(<span class="enscript-type">struct</span> socket **, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">cached_sock_free</span>(<span class="enscript-type">struct</span> socket *);

<span class="enscript-comment">/*
 * Maximum of extended background idle sockets per process
 * Set to zero to disable further setting of the option
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SO_IDLE_BK_IDLE_MAX_PER_PROC</span>	1
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SO_IDLE_BK_IDLE_TIME</span>		600
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SO_IDLE_BK_IDLE_RCV_HIWAT</span>	131072

<span class="enscript-type">struct</span> soextbkidlestat soextbkidlestat;

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern_ipc, OID_AUTO, maxextbkidleperproc,
	CTLFLAG_RW | CTLFLAG_LOCKED, &amp;soextbkidlestat.so_xbkidle_maxperproc, 0,
	<span class="enscript-string">&quot;Maximum of extended background idle sockets per process&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern_ipc, OID_AUTO, extbkidletime, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;soextbkidlestat.so_xbkidle_time, 0,
	<span class="enscript-string">&quot;Time in seconds to keep extended background idle sockets&quot;</span>);

<span class="enscript-function-name">SYSCTL_UINT</span>(_kern_ipc, OID_AUTO, extbkidlercvhiwat, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;soextbkidlestat.so_xbkidle_rcvhiwat, 0,
	<span class="enscript-string">&quot;High water mark for extended background idle sockets&quot;</span>);

<span class="enscript-function-name">SYSCTL_STRUCT</span>(_kern_ipc, OID_AUTO, extbkidlestat, CTLFLAG_RD | CTLFLAG_LOCKED,
	&amp;soextbkidlestat, soextbkidlestat, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">int</span> <span class="enscript-function-name">so_set_extended_bk_idle</span>(<span class="enscript-type">struct</span> socket *, <span class="enscript-type">int</span>);

<span class="enscript-comment">/*
 * SOTCDB_NO_DSCP is set by default, to prevent the networking stack from
 * setting the DSCP code on the packet based on the service class; see
 * &lt;rdar://problem/11277343&gt; for details.
 */</span>
__private_extern__ u_int32_t sotcdb = SOTCDB_NO_DSCP;
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, sotcdb, CTLFLAG_RW | CTLFLAG_LOCKED,
	&amp;sotcdb, 0, <span class="enscript-string">&quot;&quot;</span>);

<span class="enscript-type">void</span>
<span class="enscript-function-name">socketinit</span>(<span class="enscript-type">void</span>)
{
	_CASSERT(<span class="enscript-keyword">sizeof</span>(so_gencnt) == <span class="enscript-keyword">sizeof</span>(uint64_t));
	VERIFY(IS_P2ALIGNED(&amp;so_gencnt, <span class="enscript-keyword">sizeof</span>(uint32_t)));

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
	_CASSERT(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sa_endpoints) == <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user64_sa_endpoints));
	_CASSERT(offsetof(<span class="enscript-type">struct</span> sa_endpoints, sae_srcif) == offsetof(<span class="enscript-type">struct</span> user64_sa_endpoints, sae_srcif));
	_CASSERT(offsetof(<span class="enscript-type">struct</span> sa_endpoints, sae_srcaddr) == offsetof(<span class="enscript-type">struct</span> user64_sa_endpoints, sae_srcaddr));
	_CASSERT(offsetof(<span class="enscript-type">struct</span> sa_endpoints, sae_srcaddrlen) == offsetof(<span class="enscript-type">struct</span> user64_sa_endpoints, sae_srcaddrlen));
	_CASSERT(offsetof(<span class="enscript-type">struct</span> sa_endpoints, sae_dstaddr) == offsetof(<span class="enscript-type">struct</span> user64_sa_endpoints, sae_dstaddr));
	_CASSERT(offsetof(<span class="enscript-type">struct</span> sa_endpoints, sae_dstaddrlen) == offsetof(<span class="enscript-type">struct</span> user64_sa_endpoints, sae_dstaddrlen));
#<span class="enscript-reference">else</span>
	_CASSERT(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sa_endpoints) == <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> user32_sa_endpoints));
	_CASSERT(offsetof(<span class="enscript-type">struct</span> sa_endpoints, sae_srcif) == offsetof(<span class="enscript-type">struct</span> user32_sa_endpoints, sae_srcif));
	_CASSERT(offsetof(<span class="enscript-type">struct</span> sa_endpoints, sae_srcaddr) == offsetof(<span class="enscript-type">struct</span> user32_sa_endpoints, sae_srcaddr));
	_CASSERT(offsetof(<span class="enscript-type">struct</span> sa_endpoints, sae_srcaddrlen) == offsetof(<span class="enscript-type">struct</span> user32_sa_endpoints, sae_srcaddrlen));
	_CASSERT(offsetof(<span class="enscript-type">struct</span> sa_endpoints, sae_dstaddr) == offsetof(<span class="enscript-type">struct</span> user32_sa_endpoints, sae_dstaddr));
	_CASSERT(offsetof(<span class="enscript-type">struct</span> sa_endpoints, sae_dstaddrlen) == offsetof(<span class="enscript-type">struct</span> user32_sa_endpoints, sae_dstaddrlen));
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (socketinit_done) {
		printf(<span class="enscript-string">&quot;socketinit: already called...\n&quot;</span>);
		<span class="enscript-keyword">return</span>;
	}
	socketinit_done = 1;

	PE_parse_boot_argn(<span class="enscript-string">&quot;socket_debug&quot;</span>, &amp;socket_debug,
	    <span class="enscript-keyword">sizeof</span> (socket_debug));

	<span class="enscript-comment">/*
	 * allocate lock group attribute and group for socket cache mutex
	 */</span>
	so_cache_mtx_grp_attr = lck_grp_attr_alloc_init();
	so_cache_mtx_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;so_cache&quot;</span>,
	    so_cache_mtx_grp_attr);

	<span class="enscript-comment">/*
	 * allocate the lock attribute for socket cache mutex
	 */</span>
	so_cache_mtx_attr = lck_attr_alloc_init();

	<span class="enscript-comment">/* cached sockets mutex */</span>
	so_cache_mtx = lck_mtx_alloc_init(so_cache_mtx_grp, so_cache_mtx_attr);
	<span class="enscript-keyword">if</span> (so_cache_mtx == NULL) {
		panic(<span class="enscript-string">&quot;%s: unable to allocate so_cache_mtx\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	STAILQ_INIT(&amp;so_cache_head);

	so_cache_zone_element_size = (vm_size_t)(<span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> socket) + 4
	    + get_inpcb_str_size() + 4 + get_tcp_str_size());

	so_cache_zone = zinit(so_cache_zone_element_size,
	    (120000 * so_cache_zone_element_size), 8192, <span class="enscript-string">&quot;socache zone&quot;</span>);
	zone_change(so_cache_zone, Z_CALLERACCT, FALSE);
	zone_change(so_cache_zone, Z_NOENCRYPT, TRUE);

	sl_zone_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_list);
	<span class="enscript-keyword">if</span> ((sl_zone = zinit(sl_zone_size, 1024 * sl_zone_size, 1024,
	    <span class="enscript-string">&quot;sockaddr_list&quot;</span>)) == NULL) {
		panic(<span class="enscript-string">&quot;%s: unable to allocate sockaddr_list zone\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(sl_zone, Z_CALLERACCT, FALSE);
	zone_change(sl_zone, Z_EXPAND, TRUE);

	se_zone_size = <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> sockaddr_entry);
	<span class="enscript-keyword">if</span> ((se_zone = zinit(se_zone_size, 1024 * se_zone_size, 1024,
	    <span class="enscript-string">&quot;sockaddr_entry&quot;</span>)) == NULL) {
		panic(<span class="enscript-string">&quot;%s: unable to allocate sockaddr_entry zone\n&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	zone_change(se_zone, Z_CALLERACCT, FALSE);
	zone_change(se_zone, Z_EXPAND, TRUE);

	bzero(&amp;soextbkidlestat, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> soextbkidlestat));
	soextbkidlestat.so_xbkidle_maxperproc = SO_IDLE_BK_IDLE_MAX_PER_PROC;
	soextbkidlestat.so_xbkidle_time = SO_IDLE_BK_IDLE_TIME;
	soextbkidlestat.so_xbkidle_rcvhiwat = SO_IDLE_BK_IDLE_RCV_HIWAT;

	in_pcbinit();
	sflt_init();
	socket_tclass_init();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MULTIPATH</span>
	mp_pcbinit();
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MULTIPATH */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cached_sock_alloc</span>(<span class="enscript-type">struct</span> socket **so, <span class="enscript-type">int</span> waitok)
{
	caddr_t	temp;
	uintptr_t offset;

	lck_mtx_lock(so_cache_mtx);

	<span class="enscript-keyword">if</span> (!STAILQ_EMPTY(&amp;so_cache_head)) {
		VERIFY(cached_sock_count &gt; 0);

		*so = STAILQ_FIRST(&amp;so_cache_head);
		STAILQ_REMOVE_HEAD(&amp;so_cache_head, so_cache_ent);
		STAILQ_NEXT((*so), so_cache_ent) = NULL;

		cached_sock_count--;
		lck_mtx_unlock(so_cache_mtx);

		temp = (*so)-&gt;so_saved_pcb;
		bzero((caddr_t)*so, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> socket));

		(*so)-&gt;so_saved_pcb = temp;
	} <span class="enscript-keyword">else</span> {

		lck_mtx_unlock(so_cache_mtx);

		<span class="enscript-keyword">if</span> (waitok)
			*so = (<span class="enscript-type">struct</span> socket *)zalloc(so_cache_zone);
		<span class="enscript-keyword">else</span>
			*so = (<span class="enscript-type">struct</span> socket *)zalloc_noblock(so_cache_zone);

		<span class="enscript-keyword">if</span> (*so == NULL)
			<span class="enscript-keyword">return</span>;

		bzero((caddr_t)*so, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> socket));

		<span class="enscript-comment">/*
		 * Define offsets for extra structures into our
		 * single block of memory. Align extra structures
		 * on longword boundaries.
		 */</span>

		offset = (uintptr_t)*so;
		offset += <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> socket);

		offset = ALIGN(offset);

		(*so)-&gt;so_saved_pcb = (caddr_t)offset;
		offset += get_inpcb_str_size();

		offset = ALIGN(offset);

		((<span class="enscript-type">struct</span> inpcb *)(<span class="enscript-type">void</span> *)(*so)-&gt;so_saved_pcb)-&gt;inp_saved_ppcb =
		    (caddr_t)offset;
	}

	OSBitOrAtomic(SOF1_CACHED_IN_SOCK_LAYER, &amp;(*so)-&gt;so_flags1);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">cached_sock_free</span>(<span class="enscript-type">struct</span> socket *so)
{

	lck_mtx_lock(so_cache_mtx);

	so_cache_time = net_uptime();
	<span class="enscript-keyword">if</span> (++cached_sock_count &gt; max_cached_sock_count) {
		--cached_sock_count;
		lck_mtx_unlock(so_cache_mtx);
		zfree(so_cache_zone, so);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (so_cache_hw &lt; cached_sock_count)
			so_cache_hw = cached_sock_count;

		STAILQ_INSERT_TAIL(&amp;so_cache_head, so, so_cache_ent);

		so-&gt;cache_timestamp = so_cache_time;
		lck_mtx_unlock(so_cache_mtx);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">so_update_last_owner_locked</span>(<span class="enscript-type">struct</span> socket *so, proc_t self)
{
	<span class="enscript-keyword">if</span> (so-&gt;last_pid != 0) {
		<span class="enscript-comment">/*
		 * last_pid and last_upid should remain zero for sockets
		 * created using sock_socket. The check above achieves that
		 */</span>
		<span class="enscript-keyword">if</span> (self == PROC_NULL)
			self = current_proc();

		<span class="enscript-keyword">if</span> (so-&gt;last_upid != proc_uniqueid(self) ||
		    so-&gt;last_pid != proc_pid(self)) {
			so-&gt;last_upid = proc_uniqueid(self);
			so-&gt;last_pid = proc_pid(self);
			proc_getexecutableuuid(self, so-&gt;last_uuid,
			    <span class="enscript-keyword">sizeof</span> (so-&gt;last_uuid));
		}
		proc_pidoriginatoruuid(so-&gt;so_vuuid, <span class="enscript-keyword">sizeof</span>(so-&gt;so_vuuid));
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">so_update_policy</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET || SOCK_DOM(so) == PF_INET6)
		(<span class="enscript-type">void</span>) inp_update_policy(sotoinpcb(so));
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">so_update_necp_policy</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *override_local_addr,
    <span class="enscript-type">struct</span> sockaddr *override_remote_addr)
{
	<span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET || SOCK_DOM(so) == PF_INET6)
		inp_update_necp_policy(sotoinpcb(so), override_local_addr,
		    override_remote_addr, 0);
}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

boolean_t
<span class="enscript-function-name">so_cache_timer</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> socket	*p;
	<span class="enscript-type">int</span>		n_freed = 0;
	boolean_t rc = FALSE;

	lck_mtx_lock(so_cache_mtx);
	so_cache_timeouts++;
	so_cache_time = net_uptime();

	<span class="enscript-keyword">while</span> (!STAILQ_EMPTY(&amp;so_cache_head)) {
		VERIFY(cached_sock_count &gt; 0);
		p = STAILQ_FIRST(&amp;so_cache_head);
		<span class="enscript-keyword">if</span> ((so_cache_time - p-&gt;cache_timestamp) &lt;
			SO_CACHE_TIME_LIMIT)
			<span class="enscript-keyword">break</span>;

		STAILQ_REMOVE_HEAD(&amp;so_cache_head, so_cache_ent);
		--cached_sock_count;

		zfree(so_cache_zone, p);

		<span class="enscript-keyword">if</span> (++n_freed &gt;= SO_CACHE_MAX_FREE_BATCH) {
			so_cache_max_freed++;
			<span class="enscript-keyword">break</span>;
		}
	}

	<span class="enscript-comment">/* Schedule again if there is more to cleanup */</span>
	<span class="enscript-keyword">if</span> (!STAILQ_EMPTY(&amp;so_cache_head))
		rc = TRUE;

	lck_mtx_unlock(so_cache_mtx);
	<span class="enscript-keyword">return</span> (rc);
}

<span class="enscript-comment">/*
 * Get a socket structure from our zone, and initialize it.
 * We don't implement `waitok' yet (see comments in uipc_domain.c).
 * Note that it would probably be better to allocate socket
 * and PCB at the same time, but I'm not convinced that all
 * the protocols can be easily modified to do this.
 */</span>
<span class="enscript-type">struct</span> socket *
<span class="enscript-function-name">soalloc</span>(<span class="enscript-type">int</span> waitok, <span class="enscript-type">int</span> dom, <span class="enscript-type">int</span> type)
{
	<span class="enscript-type">struct</span> socket *so;

	<span class="enscript-keyword">if</span> ((dom == PF_INET) &amp;&amp; (type == SOCK_STREAM)) {
		cached_sock_alloc(&amp;so, waitok);
	} <span class="enscript-keyword">else</span> {
		MALLOC_ZONE(so, <span class="enscript-type">struct</span> socket *, <span class="enscript-keyword">sizeof</span> (*so), socket_zone,
		    M_WAITOK);
		<span class="enscript-keyword">if</span> (so != NULL)
			bzero(so, <span class="enscript-keyword">sizeof</span> (*so));
	}
	<span class="enscript-keyword">if</span> (so != NULL) {
		so-&gt;so_gencnt = OSIncrementAtomic64((SInt64 *)&amp;so_gencnt);
		so-&gt;so_zone = socket_zone;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
		<span class="enscript-comment">/* Convert waitok to  M_WAITOK/M_NOWAIT for MAC Framework. */</span>
		<span class="enscript-keyword">if</span> (mac_socket_label_init(so, !waitok) != 0) {
			sodealloc(so);
			<span class="enscript-keyword">return</span> (NULL);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_SOCKET */</span>
	}

	<span class="enscript-keyword">return</span> (so);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">socreate_internal</span>(<span class="enscript-type">int</span> dom, <span class="enscript-type">struct</span> socket **aso, <span class="enscript-type">int</span> type, <span class="enscript-type">int</span> proto,
    <span class="enscript-type">struct</span> proc *p, uint32_t flags, <span class="enscript-type">struct</span> proc *ep)
{
	<span class="enscript-type">struct</span> protosw *prp;
	<span class="enscript-type">struct</span> socket *so;
	<span class="enscript-type">int</span> error = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
	<span class="enscript-type">extern</span> <span class="enscript-type">int</span> tcpconsdebug;
#<span class="enscript-reference">endif</span>

	VERIFY(aso != NULL);
	*aso = NULL;

	<span class="enscript-keyword">if</span> (proto != 0)
		prp = pffindproto(dom, proto, type);
	<span class="enscript-keyword">else</span>
		prp = pffindtype(dom, type);

	<span class="enscript-keyword">if</span> (prp == NULL || prp-&gt;pr_usrreqs-&gt;pru_attach == NULL) {
		<span class="enscript-keyword">if</span> (pffinddomain(dom) == NULL)
			<span class="enscript-keyword">return</span> (EAFNOSUPPORT);
		<span class="enscript-keyword">if</span> (proto != 0) {
			<span class="enscript-keyword">if</span> (pffindprotonotype(dom, proto) != NULL)
				<span class="enscript-keyword">return</span> (EPROTOTYPE);
		}
		<span class="enscript-keyword">return</span> (EPROTONOSUPPORT);
	}
	<span class="enscript-keyword">if</span> (prp-&gt;pr_type != type)
		<span class="enscript-keyword">return</span> (EPROTOTYPE);
	so = soalloc(1, dom, type);
	<span class="enscript-keyword">if</span> (so == NULL)
		<span class="enscript-keyword">return</span> (ENOBUFS);

	<span class="enscript-keyword">if</span> (flags &amp; SOCF_ASYNC)
		so-&gt;so_state |= SS_NBIO;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MULTIPATH</span>
	<span class="enscript-keyword">if</span> (flags &amp; SOCF_MP_SUBFLOW) {
		<span class="enscript-comment">/*
		 * A multipath subflow socket is used internally in the kernel,
		 * therefore it does not have a file desciptor associated by
		 * default.
		 */</span>
		so-&gt;so_state |= SS_NOFDREF;
		so-&gt;so_flags |= SOF_MP_SUBFLOW;
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MULTIPATH */</span>

	TAILQ_INIT(&amp;so-&gt;so_incomp);
	TAILQ_INIT(&amp;so-&gt;so_comp);
	so-&gt;so_type = type;
	so-&gt;last_upid = proc_uniqueid(p);
	so-&gt;last_pid = proc_pid(p);
	proc_getexecutableuuid(p, so-&gt;last_uuid, <span class="enscript-keyword">sizeof</span> (so-&gt;last_uuid));
	proc_pidoriginatoruuid(so-&gt;so_vuuid, <span class="enscript-keyword">sizeof</span>(so-&gt;so_vuuid));

	<span class="enscript-keyword">if</span> (ep != PROC_NULL &amp;&amp; ep != p) {
		so-&gt;e_upid = proc_uniqueid(ep);
		so-&gt;e_pid = proc_pid(ep);
		proc_getexecutableuuid(ep, so-&gt;e_uuid, <span class="enscript-keyword">sizeof</span> (so-&gt;e_uuid));
		so-&gt;so_flags |= SOF_DELEGATED;
	}

	so-&gt;so_cred = kauth_cred_proc_ref(p);
	<span class="enscript-keyword">if</span> (!suser(kauth_cred_get(), NULL))
		so-&gt;so_state |= SS_PRIV;

	so-&gt;so_proto = prp;
	so-&gt;so_rcv.sb_flags |= SB_RECV;
	so-&gt;so_rcv.sb_so = so-&gt;so_snd.sb_so = so;
	so-&gt;next_lock_lr = 0;
	so-&gt;next_unlock_lr = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
	mac_socket_label_associate(kauth_cred_get(), so);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_SOCKET */</span>

	<span class="enscript-comment">/*
	 * Attachment will create the per pcb lock if necessary and
	 * increase refcount for creation, make sure it's done before
	 * socket is inserted in lists.
	 */</span>
	so-&gt;so_usecount++;

	error = (*prp-&gt;pr_usrreqs-&gt;pru_attach)(so, proto, p);
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-comment">/*
		 * Warning:
		 * If so_pcb is not zero, the socket will be leaked,
		 * so protocol attachment handler must be coded carefuly
		 */</span>
		so-&gt;so_state |= SS_NOFDREF;
		so-&gt;so_usecount--;
		sofreelastref(so, 1);	<span class="enscript-comment">/* will deallocate the socket */</span>
		<span class="enscript-keyword">return</span> (error);
	}

	atomic_add_32(&amp;prp-&gt;pr_domain-&gt;dom_refs, 1);
	TAILQ_INIT(&amp;so-&gt;so_evlist);

	<span class="enscript-comment">/* Attach socket filters for this protocol */</span>
	sflt_initsock(so);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">TCPDEBUG</span>
	<span class="enscript-keyword">if</span> (tcpconsdebug == 2)
		so-&gt;so_options |= SO_DEBUG;
#<span class="enscript-reference">endif</span>
	so_set_default_traffic_class(so);

	<span class="enscript-comment">/*
	 * If this thread or task is marked to create backgrounded sockets,
	 * mark the socket as background.
	 */</span>
	<span class="enscript-keyword">if</span> (proc_get_effective_thread_policy(current_thread(),
	    TASK_POLICY_NEW_SOCKETS_BG)) {
		socket_set_traffic_mgt_flags(so, TRAFFIC_MGT_SO_BACKGROUND);
		so-&gt;so_background_thread = current_thread();
	}

	<span class="enscript-keyword">switch</span> (dom) {
	<span class="enscript-comment">/*
	 * Don't mark Unix domain, system or multipath sockets as
	 * eligible for defunct by default.
	 */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_LOCAL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_SYSTEM</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">PF_MULTIPATH</span>:
		so-&gt;so_flags |= SOF_NODEFUNCT;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-comment">/*
	 * Entitlements can't be checked at socket creation time except if the
	 * application requested a feature guarded by a privilege (c.f., socket
	 * delegation).
	 * The priv(9) and the Sandboxing APIs are designed with the idea that
	 * a privilege check should only be triggered by a userland request.
	 * A privilege check at socket creation time is time consuming and
	 * could trigger many authorisation error messages from the security
	 * APIs.
	 */</span>

	*aso = so;

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *		EAFNOSUPPORT
 *		EPROTOTYPE
 *		EPROTONOSUPPORT
 *		ENOBUFS
 *	&lt;pru_attach&gt;:ENOBUFS[AF_UNIX]
 *	&lt;pru_attach&gt;:ENOBUFS[TCP]
 *	&lt;pru_attach&gt;:ENOMEM[TCP]
 *	&lt;pru_attach&gt;:???		[other protocol families, IPSEC]
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">socreate</span>(<span class="enscript-type">int</span> dom, <span class="enscript-type">struct</span> socket **aso, <span class="enscript-type">int</span> type, <span class="enscript-type">int</span> proto)
{
	<span class="enscript-keyword">return</span> (socreate_internal(dom, aso, type, proto, current_proc(), 0,
	    PROC_NULL));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">socreate_delegate</span>(<span class="enscript-type">int</span> dom, <span class="enscript-type">struct</span> socket **aso, <span class="enscript-type">int</span> type, <span class="enscript-type">int</span> proto, pid_t epid)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> proc *ep = PROC_NULL;

	<span class="enscript-keyword">if</span> ((proc_selfpid() != epid) &amp;&amp; ((ep = proc_find(epid)) == PROC_NULL)) {
		error = ESRCH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = socreate_internal(dom, aso, type, proto, current_proc(), 0, ep);

	<span class="enscript-comment">/*
	 * It might not be wise to hold the proc reference when calling
	 * socreate_internal since it calls soalloc with M_WAITOK
	 */</span>
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (ep != PROC_NULL)
		proc_rele(ep);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *	&lt;pru_bind&gt;:EINVAL		Invalid argument [COMMON_START]
 *	&lt;pru_bind&gt;:EAFNOSUPPORT		Address family not supported
 *	&lt;pru_bind&gt;:EADDRNOTAVAIL	Address not available.
 *	&lt;pru_bind&gt;:EINVAL		Invalid argument
 *	&lt;pru_bind&gt;:EAFNOSUPPORT		Address family not supported [notdef]
 *	&lt;pru_bind&gt;:EACCES		Permission denied
 *	&lt;pru_bind&gt;:EADDRINUSE		Address in use
 *	&lt;pru_bind&gt;:EAGAIN		Resource unavailable, try again
 *	&lt;pru_bind&gt;:EPERM		Operation not permitted
 *	&lt;pru_bind&gt;:???
 *	&lt;sf_bind&gt;:???
 *
 * Notes:	It's not possible to fully enumerate the return codes above,
 *		since socket filter authors and protocol family authors may
 *		not choose to limit their error returns to those listed, even
 *		though this may result in some software operating incorrectly.
 *
 *		The error codes which are enumerated above are those known to
 *		be returned by the tcp_usr_bind function supplied.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">sobindlock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">int</span> dolock)
{
	<span class="enscript-type">struct</span> proc *p = current_proc();
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> (dolock)
		socket_lock(so, 1);
	VERIFY(so-&gt;so_usecount &gt; 1);

	so_update_last_owner_locked(so, p);
	so_update_policy(so);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	so_update_necp_policy(so, nam, NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	<span class="enscript-comment">/*
	 * If this is a bind request on a socket that has been marked
	 * as inactive, reject it now before we go any further.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DEFUNCT) {
		error = EINVAL;
		SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: defunct so 0x%llx [%d,%d] (%d)\n&quot;</span>,
		    __func__, proc_pid(p), (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
		    SOCK_DOM(so), SOCK_TYPE(so), error));
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/* Socket filter */</span>
	error = sflt_bind(so, nam);

	<span class="enscript-keyword">if</span> (error == 0)
		error = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_bind)(so, nam, p);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (dolock)
		socket_unlock(so, 1);

	<span class="enscript-keyword">if</span> (error == EJUSTRETURN)
		error = 0;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">sodealloc</span>(<span class="enscript-type">struct</span> socket *so)
{
	kauth_cred_unref(&amp;so-&gt;so_cred);

	<span class="enscript-comment">/* Remove any filters */</span>
	sflt_termsock(so);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
	cfil_sock_detach(so);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>

	<span class="enscript-comment">/* Delete the state allocated for msg queues on a socket */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS) {
		FREE(so-&gt;so_msg_state, M_TEMP);
		so-&gt;so_msg_state = NULL;
	}
	VERIFY(so-&gt;so_msg_state == NULL);

	so-&gt;so_gencnt = OSIncrementAtomic64((SInt64 *)&amp;so_gencnt);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
	mac_socket_label_destroy(so);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_SOCKET */</span>

	<span class="enscript-keyword">if</span> (so-&gt;so_flags1 &amp; SOF1_CACHED_IN_SOCK_LAYER) {
		cached_sock_free(so);
	} <span class="enscript-keyword">else</span> {
		FREE_ZONE(so, <span class="enscript-keyword">sizeof</span> (*so), so-&gt;so_zone);
	}
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *		EINVAL
 *		EOPNOTSUPP
 *	&lt;pru_listen&gt;:EINVAL[AF_UNIX]
 *	&lt;pru_listen&gt;:EINVAL[TCP]
 *	&lt;pru_listen&gt;:EADDRNOTAVAIL[TCP]	Address not available.
 *	&lt;pru_listen&gt;:EINVAL[TCP]	Invalid argument
 *	&lt;pru_listen&gt;:EAFNOSUPPORT[TCP]	Address family not supported [notdef]
 *	&lt;pru_listen&gt;:EACCES[TCP]	Permission denied
 *	&lt;pru_listen&gt;:EADDRINUSE[TCP]	Address in use
 *	&lt;pru_listen&gt;:EAGAIN[TCP]	Resource unavailable, try again
 *	&lt;pru_listen&gt;:EPERM[TCP]		Operation not permitted
 *	&lt;sf_listen&gt;:???
 *
 * Notes:	Other &lt;pru_listen&gt; returns depend on the protocol family; all
 *		&lt;sf_listen&gt; returns depend on what the filter author causes
 *		their filter to return.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">solisten</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> backlog)
{
	<span class="enscript-type">struct</span> proc *p = current_proc();
	<span class="enscript-type">int</span> error = 0;

	socket_lock(so, 1);

	so_update_last_owner_locked(so, p);
	so_update_policy(so);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	so_update_necp_policy(so, NULL, NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	<span class="enscript-keyword">if</span> (so-&gt;so_proto == NULL) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> ((so-&gt;so_proto-&gt;pr_flags &amp; PR_CONNREQUIRED) == 0) {
		error = EOPNOTSUPP;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * If the listen request is made on a socket that is not fully
	 * disconnected, or on a socket that has been marked as inactive,
	 * reject the request now.
	 */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp;
	    (SS_ISCONNECTED|SS_ISCONNECTING|SS_ISDISCONNECTING)) ||
	    (so-&gt;so_flags &amp; SOF_DEFUNCT)) {
		error = EINVAL;
		<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DEFUNCT) {
			SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: defunct so 0x%llx [%d,%d] &quot;</span>
			    <span class="enscript-string">&quot;(%d)\n&quot;</span>, __func__, proc_pid(p),
			    (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
			    SOCK_DOM(so), SOCK_TYPE(so), error));
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> ((so-&gt;so_restrictions &amp; SO_RESTRICT_DENY_IN) != 0) {
		error = EPERM;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = sflt_listen(so);
	<span class="enscript-keyword">if</span> (error == 0)
		error = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_listen)(so, p);

	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">if</span> (error == EJUSTRETURN)
			error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (TAILQ_EMPTY(&amp;so-&gt;so_comp))
		so-&gt;so_options |= SO_ACCEPTCONN;
	<span class="enscript-comment">/*
	 * POSIX: The implementation may have an upper limit on the length of
	 * the listen queue-either global or per accepting socket. If backlog
	 * exceeds this limit, the length of the listen queue is set to the
	 * limit.
	 *
	 * If listen() is called with a backlog argument value that is less
	 * than 0, the function behaves as if it had been called with a backlog
	 * argument value of 0.
	 *
	 * A backlog argument of 0 may allow the socket to accept connections,
	 * in which case the length of the listen queue may be set to an
	 * implementation-defined minimum value.
	 */</span>
	<span class="enscript-keyword">if</span> (backlog &lt;= 0 || backlog &gt; somaxconn)
		backlog = somaxconn;

	so-&gt;so_qlimit = backlog;
<span class="enscript-reference">out</span>:
	socket_unlock(so, 1);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">sofreelastref</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> dealloc)
{
	<span class="enscript-type">struct</span> socket *head = so-&gt;so_head;

	<span class="enscript-comment">/* Assume socket is locked */</span>

	<span class="enscript-keyword">if</span> (!(so-&gt;so_flags &amp; SOF_PCBCLEARING) || !(so-&gt;so_state &amp; SS_NOFDREF)) {
		selthreadclear(&amp;so-&gt;so_snd.sb_sel);
		selthreadclear(&amp;so-&gt;so_rcv.sb_sel);
		so-&gt;so_rcv.sb_flags &amp;= ~(SB_SEL|SB_UPCALL);
		so-&gt;so_snd.sb_flags &amp;= ~(SB_SEL|SB_UPCALL);
		so-&gt;so_event = sonullevent;
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">if</span> (head != NULL) {
		socket_lock(head, 1);
		<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_INCOMP) {
			TAILQ_REMOVE(&amp;head-&gt;so_incomp, so, so_list);
			head-&gt;so_incqlen--;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_COMP) {
			<span class="enscript-comment">/*
			 * We must not decommission a socket that's
			 * on the accept(2) queue.  If we do, then
			 * accept(2) may hang after select(2) indicated
			 * that the listening socket was ready.
			 */</span>
			selthreadclear(&amp;so-&gt;so_snd.sb_sel);
			selthreadclear(&amp;so-&gt;so_rcv.sb_sel);
			so-&gt;so_rcv.sb_flags &amp;= ~(SB_SEL|SB_UPCALL);
			so-&gt;so_snd.sb_flags &amp;= ~(SB_SEL|SB_UPCALL);
			so-&gt;so_event = sonullevent;
			socket_unlock(head, 1);
			<span class="enscript-keyword">return</span>;
		} <span class="enscript-keyword">else</span> {
			panic(<span class="enscript-string">&quot;sofree: not queued&quot;</span>);
		}
		head-&gt;so_qlen--;
		so-&gt;so_state &amp;= ~SS_INCOMP;
		so-&gt;so_head = NULL;
		socket_unlock(head, 1);
	}
	sowflush(so);
	sorflush(so);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FLOW_DIVERT</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_FLOW_DIVERT) {
		flow_divert_detach(so);
	}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* FLOW_DIVERT */</span>

	<span class="enscript-comment">/* 3932268: disable upcall */</span>
	so-&gt;so_rcv.sb_flags &amp;= ~SB_UPCALL;
	so-&gt;so_snd.sb_flags &amp;= ~SB_UPCALL;
	so-&gt;so_event = sonullevent;

	<span class="enscript-keyword">if</span> (dealloc)
		sodealloc(so);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">soclose_wait_locked</span>(<span class="enscript-type">struct</span> socket *so)
{
	lck_mtx_t *mutex_held;

	<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_getlock != NULL)
		mutex_held = (*so-&gt;so_proto-&gt;pr_getlock)(so, 0);
	<span class="enscript-keyword">else</span>
		mutex_held = so-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx;
	lck_mtx_assert(mutex_held, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/*
	 * Double check here and return if there's no outstanding upcall;
	 * otherwise proceed further only if SOF_UPCALLCLOSEWAIT is set.
	 */</span>
	<span class="enscript-keyword">if</span> (!so-&gt;so_upcallusecount || !(so-&gt;so_flags &amp; SOF_UPCALLCLOSEWAIT))
		<span class="enscript-keyword">return</span>;
	so-&gt;so_rcv.sb_flags &amp;= ~SB_UPCALL;
	so-&gt;so_snd.sb_flags &amp;= ~SB_UPCALL;
	so-&gt;so_flags |= SOF_CLOSEWAIT;
	(<span class="enscript-type">void</span>) msleep((caddr_t)&amp;so-&gt;so_upcallusecount, mutex_held, (PZERO - 1),
	    <span class="enscript-string">&quot;soclose_wait_locked&quot;</span>, NULL);
	lck_mtx_assert(mutex_held, LCK_MTX_ASSERT_OWNED);
	so-&gt;so_flags &amp;= ~SOF_CLOSEWAIT;
}

<span class="enscript-comment">/*
 * Close a socket on last file table reference removal.
 * Initiate disconnect if connected.
 * Free socket when disconnect complete.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">soclose_locked</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">int</span> error = 0;
	lck_mtx_t *mutex_held;
	<span class="enscript-type">struct</span> timespec ts;

	<span class="enscript-keyword">if</span> (so-&gt;so_usecount == 0) {
		panic(<span class="enscript-string">&quot;soclose: so=%p refcount=0\n&quot;</span>, so);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	sflt_notify(so, sock_evt_closing, NULL);

	<span class="enscript-keyword">if</span> (so-&gt;so_upcallusecount)
		soclose_wait_locked(so);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
	<span class="enscript-comment">/*
	 * We have to wait until the content filters are done
	 */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; SOF_CONTENT_FILTER) != 0) {
		cfil_sock_close_wait(so);
		cfil_sock_is_closed(so);
		cfil_sock_detach(so);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>

	<span class="enscript-keyword">if</span> (so-&gt;so_flags1 &amp; SOF1_EXTEND_BK_IDLE_INPROG) {
		soresume(current_proc(), so, 1);
		so-&gt;so_flags1 &amp;= ~SOF1_EXTEND_BK_IDLE_WANTED;
	}

	<span class="enscript-keyword">if</span> ((so-&gt;so_options &amp; SO_ACCEPTCONN)) {
		<span class="enscript-type">struct</span> socket *sp, *sonext;
		<span class="enscript-type">int</span> socklock = 0;

		<span class="enscript-comment">/*
		 * We do not want new connection to be added
		 * to the connection queues
		 */</span>
		so-&gt;so_options &amp;= ~SO_ACCEPTCONN;

		<span class="enscript-keyword">for</span> (sp = TAILQ_FIRST(&amp;so-&gt;so_incomp);
		    sp != NULL; sp = sonext) {
			sonext = TAILQ_NEXT(sp, so_list);

			<span class="enscript-comment">/*
			 * Radar 5350314
			 * skip sockets thrown away by tcpdropdropblreq
			 * they will get cleanup by the garbage collection.
			 * otherwise, remove the incomp socket from the queue
			 * and let soabort trigger the appropriate cleanup.
			 */</span>
			<span class="enscript-keyword">if</span> (sp-&gt;so_flags &amp; SOF_OVERFLOW)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_getlock != NULL) {
				<span class="enscript-comment">/*
				 * Lock ordering for consistency with the
				 * rest of the stack, we lock the socket
				 * first and then grabb the head.
				 */</span>
				socket_unlock(so, 0);
				socket_lock(sp, 1);
				socket_lock(so, 0);
				socklock = 1;
			}

			TAILQ_REMOVE(&amp;so-&gt;so_incomp, sp, so_list);
			so-&gt;so_incqlen--;

			<span class="enscript-keyword">if</span> (sp-&gt;so_state &amp; SS_INCOMP) {
				sp-&gt;so_state &amp;= ~SS_INCOMP;
				sp-&gt;so_head = NULL;

				(<span class="enscript-type">void</span>) soabort(sp);
			}

			<span class="enscript-keyword">if</span> (socklock)
				socket_unlock(sp, 1);
		}

		<span class="enscript-keyword">while</span> ((sp = TAILQ_FIRST(&amp;so-&gt;so_comp)) != NULL) {
			<span class="enscript-comment">/* Dequeue from so_comp since sofree() won't do it */</span>
			TAILQ_REMOVE(&amp;so-&gt;so_comp, sp, so_list);
			so-&gt;so_qlen--;

			<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_getlock != NULL) {
				socket_unlock(so, 0);
				socket_lock(sp, 1);
			}

			<span class="enscript-keyword">if</span> (sp-&gt;so_state &amp; SS_COMP) {
				sp-&gt;so_state &amp;= ~SS_COMP;
				sp-&gt;so_head = NULL;

				(<span class="enscript-type">void</span>) soabort(sp);
			}

			<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_getlock != NULL) {
				socket_unlock(sp, 1);
				socket_lock(so, 0);
			}
		}
	}
	<span class="enscript-keyword">if</span> (so-&gt;so_pcb == NULL) {
		<span class="enscript-comment">/* 3915887: mark the socket as ready for dealloc */</span>
		so-&gt;so_flags |= SOF_PCBCLEARING;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">discard</span>;
	}
	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_ISCONNECTED) {
		<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_ISDISCONNECTING) == 0) {
			error = sodisconnectlocked(so);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
		}
		<span class="enscript-keyword">if</span> (so-&gt;so_options &amp; SO_LINGER) {
			<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_ISDISCONNECTING) &amp;&amp;
			    (so-&gt;so_state &amp; SS_NBIO))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">drop</span>;
			<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_getlock != NULL)
				mutex_held = (*so-&gt;so_proto-&gt;pr_getlock)(so, 0);
			<span class="enscript-keyword">else</span>
				mutex_held = so-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx;
			<span class="enscript-keyword">while</span> (so-&gt;so_state &amp; SS_ISCONNECTED) {
				ts.tv_sec = (so-&gt;so_linger/100);
				ts.tv_nsec = (so-&gt;so_linger % 100) *
				    NSEC_PER_USEC * 1000 * 10;
				error = msleep((caddr_t)&amp;so-&gt;so_timeo,
				    mutex_held, PSOCK | PCATCH, <span class="enscript-string">&quot;soclose&quot;</span>, &amp;ts);
				<span class="enscript-keyword">if</span> (error) {
					<span class="enscript-comment">/*
					 * It's OK when the time fires,
					 * don't report an error
					 */</span>
					<span class="enscript-keyword">if</span> (error == EWOULDBLOCK)
						error = 0;
					<span class="enscript-keyword">break</span>;
				}
			}
		}
	}
<span class="enscript-reference">drop</span>:
	<span class="enscript-keyword">if</span> (so-&gt;so_usecount == 0) {
		panic(<span class="enscript-string">&quot;soclose: usecount is zero so=%p\n&quot;</span>, so);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (so-&gt;so_pcb != NULL &amp;&amp; !(so-&gt;so_flags &amp; SOF_PCBCLEARING)) {
		<span class="enscript-type">int</span> error2 = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_detach)(so);
		<span class="enscript-keyword">if</span> (error == 0)
			error = error2;
	}
	<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt;= 0) {
		panic(<span class="enscript-string">&quot;soclose: usecount is zero so=%p\n&quot;</span>, so);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
<span class="enscript-reference">discard</span>:
	<span class="enscript-keyword">if</span> (so-&gt;so_pcb != NULL &amp;&amp; !(so-&gt;so_flags &amp; SOF_MP_SUBFLOW) &amp;&amp;
	    (so-&gt;so_state &amp; SS_NOFDREF)) {
		panic(<span class="enscript-string">&quot;soclose: NOFDREF&quot;</span>);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	so-&gt;so_state |= SS_NOFDREF;

	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_MP_SUBFLOW)
		so-&gt;so_flags &amp;= ~SOF_MP_SUBFLOW;

	<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; SOF_KNOTE) != 0)
		KNOTE(&amp;so-&gt;so_klist, SO_FILT_HINT_LOCKED);

	atomic_add_32(&amp;so-&gt;so_proto-&gt;pr_domain-&gt;dom_refs, -1);
	evsofree(so);

	so-&gt;so_usecount--;
	sofree(so);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">soclose</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">int</span> error = 0;
	socket_lock(so, 1);

	<span class="enscript-keyword">if</span> (so-&gt;so_retaincnt == 0) {
		error = soclose_locked(so);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * if the FD is going away, but socket is
		 * retained in kernel remove its reference
		 */</span>
		so-&gt;so_usecount--;
		<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt; 2)
			panic(<span class="enscript-string">&quot;soclose: retaincnt non null and so=%p &quot;</span>
			    <span class="enscript-string">&quot;usecount=%d\n&quot;</span>, so, so-&gt;so_usecount);
	}
	socket_unlock(so, 1);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Must be called at splnet...
 */</span>
<span class="enscript-comment">/* Should already be locked */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">soabort</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">int</span> error;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MORE_LOCKING_DEBUG</span>
	lck_mtx_t *mutex_held;

	<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_getlock != NULL)
		mutex_held = (*so-&gt;so_proto-&gt;pr_getlock)(so, 0);
	<span class="enscript-keyword">else</span>
		mutex_held = so-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx;
	lck_mtx_assert(mutex_held, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; SOF_ABORTED) == 0) {
		so-&gt;so_flags |= SOF_ABORTED;
		error = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_abort)(so);
		<span class="enscript-keyword">if</span> (error) {
			sofree(so);
			<span class="enscript-keyword">return</span> (error);
		}
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">soacceptlock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **nam, <span class="enscript-type">int</span> dolock)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> (dolock)
		socket_lock(so, 1);

	so_update_last_owner_locked(so, PROC_NULL);
	so_update_policy(so);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	so_update_necp_policy(so, NULL, NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_NOFDREF) == 0)
		panic(<span class="enscript-string">&quot;soaccept: !NOFDREF&quot;</span>);
	so-&gt;so_state &amp;= ~SS_NOFDREF;
	error = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_accept)(so, nam);

	<span class="enscript-keyword">if</span> (dolock)
		socket_unlock(so, 1);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">soaccept</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **nam)
{
	<span class="enscript-keyword">return</span> (soacceptlock(so, nam, 1));
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">soacceptfilter</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> sockaddr *local = NULL, *remote = NULL;
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> socket *head = so-&gt;so_head;

	<span class="enscript-comment">/*
	 * Hold the lock even if this socket has not been made visible
	 * to the filter(s).  For sockets with global locks, this protects
	 * against the head or peer going away
	 */</span>
	socket_lock(so, 1);
	<span class="enscript-keyword">if</span> (sogetaddr_locked(so, &amp;remote, 1) != 0 ||
	    sogetaddr_locked(so, &amp;local, 0) != 0) {
		so-&gt;so_state &amp;= ~(SS_NOFDREF | SS_COMP);
		so-&gt;so_head = NULL;
		socket_unlock(so, 1);
		soclose(so);
		<span class="enscript-comment">/* Out of resources; try it again next time */</span>
		error = ECONNABORTED;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	error = sflt_accept(head, so, local, remote);

	<span class="enscript-comment">/*
	 * If we get EJUSTRETURN from one of the filters, mark this socket
	 * as inactive and return it anyway.  This newly accepted socket
	 * will be disconnected later before we hand it off to the caller.
	 */</span>
	<span class="enscript-keyword">if</span> (error == EJUSTRETURN) {
		error = 0;
		(<span class="enscript-type">void</span>) sosetdefunct(current_proc(), so,
		    SHUTDOWN_SOCKET_LEVEL_DISCONNECT_INTERNAL, FALSE);
	}

	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-comment">/*
		 * This may seem like a duplication to the above error
		 * handling part when we return ECONNABORTED, except
		 * the following is done while holding the lock since
		 * the socket has been exposed to the filter(s) earlier.
		 */</span>
		so-&gt;so_state &amp;= ~(SS_NOFDREF | SS_COMP);
		so-&gt;so_head = NULL;
		socket_unlock(so, 1);
		soclose(so);
		<span class="enscript-comment">/* Propagate socket filter's error code to the caller */</span>
	} <span class="enscript-keyword">else</span> {
		socket_unlock(so, 1);
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-comment">/* Callee checks for NULL pointer */</span>
	sock_freeaddr(remote);
	sock_freeaddr(local);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *		EOPNOTSUPP		Operation not supported on socket
 *		EISCONN			Socket is connected
 *	&lt;pru_connect&gt;:EADDRNOTAVAIL	Address not available.
 *	&lt;pru_connect&gt;:EINVAL		Invalid argument
 *	&lt;pru_connect&gt;:EAFNOSUPPORT	Address family not supported [notdef]
 *	&lt;pru_connect&gt;:EACCES		Permission denied
 *	&lt;pru_connect&gt;:EADDRINUSE	Address in use
 *	&lt;pru_connect&gt;:EAGAIN		Resource unavailable, try again
 *	&lt;pru_connect&gt;:EPERM		Operation not permitted
 *	&lt;sf_connect_out&gt;:???		[anything a filter writer might set]
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">soconnectlock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam, <span class="enscript-type">int</span> dolock)
{
	<span class="enscript-type">int</span> error;
	<span class="enscript-type">struct</span> proc *p = current_proc();

	<span class="enscript-keyword">if</span> (dolock)
		socket_lock(so, 1);

	so_update_last_owner_locked(so, p);
	so_update_policy(so);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	so_update_necp_policy(so, NULL, nam);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	<span class="enscript-comment">/*
	 * If this is a listening socket or if this is a previously-accepted
	 * socket that has been marked as inactive, reject the connect request.
	 */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_options &amp; SO_ACCEPTCONN) || (so-&gt;so_flags &amp; SOF_DEFUNCT)) {
		error = EOPNOTSUPP;
		<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DEFUNCT) {
			SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: defunct so 0x%llx [%d,%d] &quot;</span>
			    <span class="enscript-string">&quot;(%d)\n&quot;</span>, __func__, proc_pid(p),
			    (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
			    SOCK_DOM(so), SOCK_TYPE(so), error));
		}
		<span class="enscript-keyword">if</span> (dolock)
			socket_unlock(so, 1);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> ((so-&gt;so_restrictions &amp; SO_RESTRICT_DENY_OUT) != 0) {
		<span class="enscript-keyword">if</span> (dolock)
			socket_unlock(so, 1);
		<span class="enscript-keyword">return</span> (EPERM);
	}

	<span class="enscript-comment">/*
	 * If protocol is connection-based, can only connect once.
	 * Otherwise, if connected, try to disconnect first.
	 * This allows user to disconnect by connecting to, e.g.,
	 * a null address.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; (SS_ISCONNECTED|SS_ISCONNECTING) &amp;&amp;
	    ((so-&gt;so_proto-&gt;pr_flags &amp; PR_CONNREQUIRED) ||
	    (error = sodisconnectlocked(so)))) {
		error = EISCONN;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Run connect filter before calling protocol:
		 *  - non-blocking connect returns before completion;
		 */</span>
		error = sflt_connectout(so, nam);
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-keyword">if</span> (error == EJUSTRETURN)
				error = 0;
		} <span class="enscript-keyword">else</span> {
			error = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_connect)
			    (so, nam, p);
		}
	}
	<span class="enscript-keyword">if</span> (dolock)
		socket_unlock(so, 1);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">soconnect</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *nam)
{
	<span class="enscript-keyword">return</span> (soconnectlock(so, nam, 1));
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *	&lt;pru_connect2&gt;:EINVAL[AF_UNIX]
 *	&lt;pru_connect2&gt;:EPROTOTYPE[AF_UNIX]
 *	&lt;pru_connect2&gt;:???		[other protocol families]
 *
 * Notes:	&lt;pru_connect2&gt; is not supported by [TCP].
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">soconnect2</span>(<span class="enscript-type">struct</span> socket *so1, <span class="enscript-type">struct</span> socket *so2)
{
	<span class="enscript-type">int</span> error;

	socket_lock(so1, 1);
	<span class="enscript-keyword">if</span> (so2-&gt;so_proto-&gt;pr_lock)
		socket_lock(so2, 1);

	error = (*so1-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_connect2)(so1, so2);

	socket_unlock(so1, 1);
	<span class="enscript-keyword">if</span> (so2-&gt;so_proto-&gt;pr_lock)
		socket_unlock(so2, 1);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">soconnectxlocked</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr_list **src_sl,
    <span class="enscript-type">struct</span> sockaddr_list **dst_sl, <span class="enscript-type">struct</span> proc *p, uint32_t ifscope,
    sae_associd_t aid, sae_connid_t *pcid, uint32_t flags, <span class="enscript-type">void</span> *arg,
    uint32_t arglen, uio_t auio, user_ssize_t *bytes_written)
{
	<span class="enscript-type">int</span> error;

	so_update_last_owner_locked(so, p);
	so_update_policy(so);

	<span class="enscript-comment">/*
	 * If this is a listening socket or if this is a previously-accepted
	 * socket that has been marked as inactive, reject the connect request.
	 */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_options &amp; SO_ACCEPTCONN) || (so-&gt;so_flags &amp; SOF_DEFUNCT)) {
		error = EOPNOTSUPP;
		<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DEFUNCT) {
			SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: defunct so 0x%llx [%d,%d] &quot;</span>
			    <span class="enscript-string">&quot;(%d)\n&quot;</span>, __func__, proc_pid(p),
			    (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
			    SOCK_DOM(so), SOCK_TYPE(so), error));
		}
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> ((so-&gt;so_restrictions &amp; SO_RESTRICT_DENY_OUT) != 0)
		<span class="enscript-keyword">return</span> (EPERM);

	<span class="enscript-comment">/*
	 * If protocol is connection-based, can only connect once
	 * unless PR_MULTICONN is set.  Otherwise, if connected,
	 * try to disconnect first.  This allows user to disconnect
	 * by connecting to, e.g., a null address.
	 */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; (SS_ISCONNECTED|SS_ISCONNECTING)) &amp;&amp;
	    !(so-&gt;so_proto-&gt;pr_flags &amp; PR_MULTICONN) &amp;&amp;
	    ((so-&gt;so_proto-&gt;pr_flags &amp; PR_CONNREQUIRED) ||
	    (error = sodisconnectlocked(so)) != 0)) {
		error = EISCONN;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Run connect filter before calling protocol:
		 *  - non-blocking connect returns before completion;
		 */</span>
		error = sflt_connectxout(so, dst_sl);
		<span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-keyword">if</span> (error == EJUSTRETURN)
				error = 0;
		} <span class="enscript-keyword">else</span> {
			error = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_connectx)
			    (so, src_sl, dst_sl, p, ifscope, aid, pcid,
			    flags, arg, arglen, auio, bytes_written);
		}
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sodisconnectlocked</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_ISCONNECTED) == 0) {
		error = ENOTCONN;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_ISDISCONNECTING) {
		error = EALREADY;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}

	error = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_disconnect)(so);
	<span class="enscript-keyword">if</span> (error == 0)
		sflt_notify(so, sock_evt_disconnected, NULL);

<span class="enscript-reference">bad</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* Locking version */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">sodisconnect</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">int</span> error;

	socket_lock(so, 1);
	error = sodisconnectlocked(so);
	socket_unlock(so, 1);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sodisconnectxlocked</span>(<span class="enscript-type">struct</span> socket *so, sae_associd_t aid, sae_connid_t cid)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/*
	 * Call the protocol disconnectx handler; let it handle all
	 * matters related to the connection state of this session.
	 */</span>
	error = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_disconnectx)(so, aid, cid);
	<span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-comment">/*
		 * The event applies only for the session, not for
		 * the disconnection of individual subflows.
		 */</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; (SS_ISDISCONNECTING|SS_ISDISCONNECTED))
			sflt_notify(so, sock_evt_disconnected, NULL);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sodisconnectx</span>(<span class="enscript-type">struct</span> socket *so, sae_associd_t aid, sae_connid_t cid)
{
	<span class="enscript-type">int</span> error;

	socket_lock(so, 1);
	error = sodisconnectxlocked(so, aid, cid);
	socket_unlock(so, 1);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sopeelofflocked</span>(<span class="enscript-type">struct</span> socket *so, sae_associd_t aid, <span class="enscript-type">struct</span> socket **psop)
{
	<span class="enscript-keyword">return</span> ((*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_peeloff)(so, aid, psop));
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">SBLOCKWAIT</span>(f)	(((f) &amp; MSG_DONTWAIT) ? 0 : SBL_WAIT)

<span class="enscript-comment">/*
 * sosendcheck will lock the socket buffer if it isn't locked and
 * verify that there is space for the data being inserted.
 *
 * Returns:	0			Success
 *		EPIPE
 *	sblock:EWOULDBLOCK
 *	sblock:EINTR
 *	sbwait:EBADF
 *	sbwait:EINTR
 *	[so_error]:???
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">sosendcheck</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *addr, user_ssize_t resid,
    int32_t clen, int32_t atomic, <span class="enscript-type">int</span> flags, <span class="enscript-type">int</span> *sblocked,
    <span class="enscript-type">struct</span> mbuf *control)
{
	<span class="enscript-type">int</span>	error = 0;
	int32_t space;
	<span class="enscript-type">int</span>	assumelock = 0;

<span class="enscript-reference">restart</span>:
	<span class="enscript-keyword">if</span> (*sblocked == 0) {
		<span class="enscript-keyword">if</span> ((so-&gt;so_snd.sb_flags &amp; SB_LOCK) != 0 &amp;&amp;
		    so-&gt;so_send_filt_thread != 0 &amp;&amp;
		    so-&gt;so_send_filt_thread == current_thread()) {
			<span class="enscript-comment">/*
			 * We're being called recursively from a filter,
			 * allow this to continue. Radar 4150520.
			 * Don't set sblocked because we don't want
			 * to perform an unlock later.
			 */</span>
			assumelock = 1;
		} <span class="enscript-keyword">else</span> {
			error = sblock(&amp;so-&gt;so_snd, SBLOCKWAIT(flags));
			<span class="enscript-keyword">if</span> (error) {
				<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DEFUNCT)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">defunct</span>;
				<span class="enscript-keyword">return</span> (error);
			}
			*sblocked = 1;
		}
	}

	<span class="enscript-comment">/*
	 * If a send attempt is made on a socket that has been marked
	 * as inactive (disconnected), reject the request.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DEFUNCT) {
<span class="enscript-reference">defunct</span>:
		error = EPIPE;
		SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: defunct so 0x%llx [%d,%d] (%d)\n&quot;</span>,
		    __func__, proc_selfpid(),
		    (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
		    SOCK_DOM(so), SOCK_TYPE(so), error));
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_CANTSENDMORE) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
		<span class="enscript-comment">/*
		 * Can re-inject data of half closed connections
		 */</span>
		<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_ISDISCONNECTED) == 0 &amp;&amp;
			so-&gt;so_snd.sb_cfil_thread == current_thread() &amp;&amp;
			cfil_sock_data_pending(&amp;so-&gt;so_snd) != 0)
			CFIL_LOG(LOG_INFO,
				<span class="enscript-string">&quot;so %llx ignore SS_CANTSENDMORE&quot;</span>,
				(uint64_t)DEBUG_KERNEL_ADDRPERM(so));
		<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>
			<span class="enscript-keyword">return</span> (EPIPE);
	}
	<span class="enscript-keyword">if</span> (so-&gt;so_error) {
		error = so-&gt;so_error;
		so-&gt;so_error = 0;
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_ISCONNECTED) == 0) {
		<span class="enscript-keyword">if</span> ((so-&gt;so_proto-&gt;pr_flags &amp; PR_CONNREQUIRED) != 0) {
			<span class="enscript-keyword">if</span> (((so-&gt;so_state &amp; SS_ISCONFIRMING) == 0) &amp;&amp;
			    (resid != 0 || clen == 0) &amp;&amp;
			    !(so-&gt;so_flags1 &amp; SOF1_PRECONNECT_DATA)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
				<span class="enscript-comment">/*
				 * MPTCP Fast Join sends data before the
				 * socket is truly connected.
				 */</span>
				<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; (SOF_MP_SUBFLOW |
					SOF_MPTCP_FASTJOIN)) !=
				    (SOF_MP_SUBFLOW | SOF_MPTCP_FASTJOIN))
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>
				<span class="enscript-keyword">return</span> (ENOTCONN);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (addr == 0 &amp;&amp; !(flags&amp;MSG_HOLD)) {
			<span class="enscript-keyword">return</span> ((so-&gt;so_proto-&gt;pr_flags &amp; PR_CONNREQUIRED) ?
			    ENOTCONN : EDESTADDRREQ);
		}
	}

	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS)
		space = msgq_sbspace(so, control);
	<span class="enscript-keyword">else</span>
		space = sbspace(&amp;so-&gt;so_snd);

	<span class="enscript-keyword">if</span> (flags &amp; MSG_OOB)
		space += 1024;
	<span class="enscript-keyword">if</span> ((atomic &amp;&amp; resid &gt; so-&gt;so_snd.sb_hiwat) ||
	    clen &gt; so-&gt;so_snd.sb_hiwat)
		<span class="enscript-keyword">return</span> (EMSGSIZE);

	<span class="enscript-keyword">if</span> ((space &lt; resid + clen &amp;&amp;
	    (atomic || (space &lt; (int32_t)so-&gt;so_snd.sb_lowat) ||
	    space &lt; clen)) ||
	    (so-&gt;so_type == SOCK_STREAM &amp;&amp; so_wait_for_if_feedback(so))) {
		<span class="enscript-comment">/*
		 * don't block the connectx call when there's more data
		 * than can be copied.
		 */</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_flags1 &amp; SOF1_PRECONNECT_DATA) {
			<span class="enscript-keyword">if</span> (space == 0) {
				<span class="enscript-keyword">return</span> (EWOULDBLOCK);
			}
			<span class="enscript-keyword">if</span> (space &lt; (int32_t)so-&gt;so_snd.sb_lowat) {
				<span class="enscript-keyword">return</span> (0);
			}
		}
		<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_NBIO) || (flags &amp; MSG_NBIO) ||
		    assumelock) {
			<span class="enscript-keyword">return</span> (EWOULDBLOCK);
		}
		sbunlock(&amp;so-&gt;so_snd, TRUE);	<span class="enscript-comment">/* keep socket locked */</span>
		*sblocked = 0;
		error = sbwait(&amp;so-&gt;so_snd);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DEFUNCT)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">defunct</span>;
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Send on a socket.
 * If send must go all at once and message is larger than
 * send buffering, then hard error.
 * Lock against other senders.
 * If must go all at once and not enough room now, then
 * inform user that this would block and do nothing.
 * Otherwise, if nonblocking, send as much as possible.
 * The data to be sent is described by &quot;uio&quot; if nonzero,
 * otherwise by the mbuf chain &quot;top&quot; (which must be null
 * if uio is not).  Data provided in mbuf chain must be small
 * enough to send all at once.
 *
 * Returns nonzero on error, timeout or signal; callers
 * must check for short counts if EINTR/ERESTART are returned.
 * Data and control buffers are freed on return.
 * Experiment:
 * MSG_HOLD: go thru most of sosend(), but just enqueue the mbuf
 * MSG_SEND: go thru as for MSG_HOLD on current fragment, then
 *  point at the mbuf chain being constructed and go from there.
 *
 * Returns:	0			Success
 *		EOPNOTSUPP
 *		EINVAL
 *		ENOBUFS
 *	uiomove:EFAULT
 *	sosendcheck:EPIPE
 *	sosendcheck:EWOULDBLOCK
 *	sosendcheck:EINTR
 *	sosendcheck:EBADF
 *	sosendcheck:EINTR
 *	sosendcheck:???			[value from so_error]
 *	&lt;pru_send&gt;:ECONNRESET[TCP]
 *	&lt;pru_send&gt;:EINVAL[TCP]
 *	&lt;pru_send&gt;:ENOBUFS[TCP]
 *	&lt;pru_send&gt;:EADDRINUSE[TCP]
 *	&lt;pru_send&gt;:EADDRNOTAVAIL[TCP]
 *	&lt;pru_send&gt;:EAFNOSUPPORT[TCP]
 *	&lt;pru_send&gt;:EACCES[TCP]
 *	&lt;pru_send&gt;:EAGAIN[TCP]
 *	&lt;pru_send&gt;:EPERM[TCP]
 *	&lt;pru_send&gt;:EMSGSIZE[TCP]
 *	&lt;pru_send&gt;:EHOSTUNREACH[TCP]
 *	&lt;pru_send&gt;:ENETUNREACH[TCP]
 *	&lt;pru_send&gt;:ENETDOWN[TCP]
 *	&lt;pru_send&gt;:ENOMEM[TCP]
 *	&lt;pru_send&gt;:ENOBUFS[TCP]
 *	&lt;pru_send&gt;:???[TCP]		[ignorable: mostly IPSEC/firewall/DLIL]
 *	&lt;pru_send&gt;:EINVAL[AF_UNIX]
 *	&lt;pru_send&gt;:EOPNOTSUPP[AF_UNIX]
 *	&lt;pru_send&gt;:EPIPE[AF_UNIX]
 *	&lt;pru_send&gt;:ENOTCONN[AF_UNIX]
 *	&lt;pru_send&gt;:EISCONN[AF_UNIX]
 *	&lt;pru_send&gt;:???[AF_UNIX]		[whatever a filter author chooses]
 *	&lt;sf_data_out&gt;:???		[whatever a filter author chooses]
 *
 * Notes:	Other &lt;pru_send&gt; returns depend on the protocol family; all
 *		&lt;sf_data_out&gt; returns depend on what the filter author causes
 *		their filter to return.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">sosend</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr *addr, <span class="enscript-type">struct</span> uio *uio,
    <span class="enscript-type">struct</span> mbuf *top, <span class="enscript-type">struct</span> mbuf *control, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> mbuf **mp;
	<span class="enscript-type">struct</span> mbuf *m, *freelist = NULL;
	user_ssize_t space, len, resid, orig_resid;
	<span class="enscript-type">int</span> clen = 0, error, dontroute, mlen, sendflags;
	<span class="enscript-type">int</span> atomic = sosendallatonce(so) || top;
	<span class="enscript-type">int</span> sblocked = 0;
	<span class="enscript-type">struct</span> proc *p = current_proc();
	<span class="enscript-type">struct</span> mbuf *control_copy = NULL;
	uint16_t headroom = 0;
	boolean_t en_tracing = FALSE;

	<span class="enscript-keyword">if</span> (uio != NULL)
		resid = uio_resid(uio);
	<span class="enscript-keyword">else</span>
		resid = top-&gt;m_pkthdr.len;

	KERNEL_DEBUG((DBG_FNC_SOSEND | DBG_FUNC_START), so, resid,
	    so-&gt;so_snd.sb_cc, so-&gt;so_snd.sb_lowat, so-&gt;so_snd.sb_hiwat);

	socket_lock(so, 1);

	<span class="enscript-comment">/*
	 * trace if tracing &amp; network (vs. unix) sockets &amp; and
	 * non-loopback
	 */</span>
	<span class="enscript-keyword">if</span> (ENTR_SHOULDTRACE &amp;&amp;
	    (SOCK_CHECK_DOM(so, AF_INET) || SOCK_CHECK_DOM(so, AF_INET6))) {
		<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
		<span class="enscript-keyword">if</span> (inp-&gt;inp_last_outifp != NULL &amp;&amp;
		    !(inp-&gt;inp_last_outifp-&gt;if_flags &amp; IFF_LOOPBACK)) {
			en_tracing = TRUE;
			KERNEL_ENERGYTRACE(kEnTrActKernSockWrite, DBG_FUNC_START,
			    VM_KERNEL_ADDRPERM(so),
			    ((so-&gt;so_state &amp; SS_NBIO) ? kEnTrFlagNonBlocking : 0),
			    (int64_t)resid);
			orig_resid = resid;
		}
	}

	<span class="enscript-comment">/*
	 * Re-injection should not affect process accounting
	 */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; MSG_SKIPCFIL) == 0) {
		so_update_last_owner_locked(so, p);
		so_update_policy(so);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		so_update_necp_policy(so, NULL, addr);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
	}

	<span class="enscript-keyword">if</span> (so-&gt;so_type != SOCK_STREAM &amp;&amp; (flags &amp; MSG_OOB) != 0) {
		error = EOPNOTSUPP;
		socket_unlock(so, 1);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-comment">/*
	 * In theory resid should be unsigned.
	 * However, space must be signed, as it might be less than 0
	 * if we over-committed, and we must use a signed comparison
	 * of space and resid.  On the other hand, a negative resid
	 * causes us to loop sending 0-length segments to the protocol.
	 *
	 * Usually, MSG_EOR isn't used on SOCK_STREAM type sockets.
	 * But it will be used by sockets doing message delivery.
	 *
	 * Note: We limit resid to be a positive int value as we use
	 * imin() to set bytes_to_copy -- radr://14558484
	 */</span>
	<span class="enscript-keyword">if</span> (resid &lt; 0 || resid &gt; INT_MAX || (so-&gt;so_type == SOCK_STREAM &amp;&amp;
	    !(so-&gt;so_flags &amp; SOF_ENABLE_MSGS) &amp;&amp; (flags &amp; MSG_EOR))) {
		error = EINVAL;
		socket_unlock(so, 1);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	dontroute = (flags &amp; MSG_DONTROUTE) &amp;&amp;
	    (so-&gt;so_options &amp; SO_DONTROUTE) == 0 &amp;&amp;
	    (so-&gt;so_proto-&gt;pr_flags &amp; PR_ATOMIC);
	OSIncrementAtomicLong(&amp;p-&gt;p_stats-&gt;p_ru.ru_msgsnd);

	<span class="enscript-keyword">if</span> (control != NULL)
		clen = control-&gt;m_len;

	<span class="enscript-keyword">if</span> (soreserveheadroom != 0)
		headroom = so-&gt;so_pktheadroom;

	<span class="enscript-keyword">do</span> {
		error = sosendcheck(so, addr, resid, clen, atomic, flags,
		    &amp;sblocked, control);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;

		mp = &amp;top;
		<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS)
			space = msgq_sbspace(so, control);
		<span class="enscript-keyword">else</span>
			space = sbspace(&amp;so-&gt;so_snd) - clen;
		space += ((flags &amp; MSG_OOB) ? 1024 : 0);

		<span class="enscript-keyword">do</span> {
			<span class="enscript-keyword">if</span> (uio == NULL) {
				<span class="enscript-comment">/*
				 * Data is prepackaged in &quot;top&quot;.
				 */</span>
				resid = 0;
				<span class="enscript-keyword">if</span> (flags &amp; MSG_EOR)
					top-&gt;m_flags |= M_EOR;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-type">int</span> chainlength;
				<span class="enscript-type">int</span> bytes_to_copy;
				boolean_t jumbocl;
				boolean_t bigcl;
				<span class="enscript-type">int</span> bytes_to_alloc;

				bytes_to_copy = imin(resid, space);

				bytes_to_alloc = bytes_to_copy;
				<span class="enscript-keyword">if</span> (top == NULL)
					bytes_to_alloc += headroom;

				<span class="enscript-keyword">if</span> (sosendminchain &gt; 0)
					chainlength = 0;
				<span class="enscript-keyword">else</span>
					chainlength = sosendmaxchain;

				<span class="enscript-comment">/*
				 * Use big 4 KB cluster when the outgoing interface
				 * does not prefer 2 KB clusters
				 */</span>
				bigcl = !(so-&gt;so_flags1 &amp; SOF1_IF_2KCL) ||
				    sosendbigcl_ignore_capab;

				<span class="enscript-comment">/*
				 * Attempt to use larger than system page-size
				 * clusters for large writes only if there is
				 * a jumbo cluster pool and if the socket is
				 * marked accordingly.
				 */</span>
				jumbocl = sosendjcl &amp;&amp; njcl &gt; 0 &amp;&amp;
				    ((so-&gt;so_flags &amp; SOF_MULTIPAGES) ||
				    sosendjcl_ignore_capab) &amp;&amp;
				    bigcl;

				socket_unlock(so, 0);

				<span class="enscript-keyword">do</span> {
					<span class="enscript-type">int</span> num_needed;
					<span class="enscript-type">int</span> hdrs_needed = (top == NULL) ? 1 : 0;

					<span class="enscript-comment">/*
					 * try to maintain a local cache of mbuf
					 * clusters needed to complete this
					 * write the list is further limited to
					 * the number that are currently needed
					 * to fill the socket this mechanism
					 * allows a large number of mbufs/
					 * clusters to be grabbed under a single
					 * mbuf lock... if we can't get any
					 * clusters, than fall back to trying
					 * for mbufs if we fail early (or
					 * miscalcluate the number needed) make
					 * sure to release any clusters we
					 * haven't yet consumed.
					 */</span>
					<span class="enscript-keyword">if</span> (freelist == NULL &amp;&amp;
					    bytes_to_alloc &gt; MBIGCLBYTES &amp;&amp;
					    jumbocl) {
						num_needed =
						    bytes_to_alloc / M16KCLBYTES;

						<span class="enscript-keyword">if</span> ((bytes_to_alloc -
						    (num_needed * M16KCLBYTES))
						    &gt;= MINCLSIZE)
							num_needed++;

						freelist =
						    m_getpackets_internal(
						    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)&amp;num_needed,
						    hdrs_needed, M_WAIT, 0,
						    M16KCLBYTES);
						<span class="enscript-comment">/*
						 * Fall back to 4K cluster size
						 * if allocation failed
						 */</span>
					}

					<span class="enscript-keyword">if</span> (freelist == NULL &amp;&amp;
					    bytes_to_alloc &gt; MCLBYTES &amp;&amp;
					    bigcl) {
						num_needed =
						    bytes_to_alloc / MBIGCLBYTES;

						<span class="enscript-keyword">if</span> ((bytes_to_alloc -
						    (num_needed * MBIGCLBYTES)) &gt;=
						    MINCLSIZE)
							num_needed++;

						freelist =
						    m_getpackets_internal(
						    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)&amp;num_needed,
						    hdrs_needed, M_WAIT, 0,
						    MBIGCLBYTES);
						<span class="enscript-comment">/*
						 * Fall back to cluster size
						 * if allocation failed
						 */</span>
					}

					<span class="enscript-comment">/*
					 * Allocate a cluster as we want to
					 * avoid to split the data in more
					 * that one segment and using MINCLSIZE
					 * would lead us to allocate two mbufs
					 */</span>
					<span class="enscript-keyword">if</span> (soreserveheadroom != 0 &amp;&amp;
					    freelist == NULL &amp;&amp;
					    ((top == NULL &amp;&amp;
					    bytes_to_alloc &gt; _MHLEN) ||
					    bytes_to_alloc &gt; _MLEN)) {
						num_needed = ROUNDUP(bytes_to_alloc, MCLBYTES) /
						    MCLBYTES;
						freelist =
						    m_getpackets_internal(
						    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)&amp;num_needed,
						    hdrs_needed, M_WAIT, 0,
						    MCLBYTES);
						<span class="enscript-comment">/*
						 * Fall back to a single mbuf
						 * if allocation failed
						 */</span>
					} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (freelist == NULL &amp;&amp;
					    bytes_to_alloc &gt; MINCLSIZE) {
						num_needed =
						    bytes_to_alloc / MCLBYTES;

						<span class="enscript-keyword">if</span> ((bytes_to_alloc -
						    (num_needed * MCLBYTES)) &gt;=
						    MINCLSIZE)
							num_needed++;

						freelist =
						    m_getpackets_internal(
						    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)&amp;num_needed,
						    hdrs_needed, M_WAIT, 0,
						    MCLBYTES);
						<span class="enscript-comment">/*
						 * Fall back to a single mbuf
						 * if allocation failed
						 */</span>
					}
					<span class="enscript-comment">/*
					 * For datagram protocols, leave
					 * headroom for protocol headers
					 * in the first cluster of the chain
					 */</span>
					<span class="enscript-keyword">if</span> (freelist != NULL &amp;&amp; atomic &amp;&amp;
					    top == NULL &amp;&amp; headroom &gt; 0) {
						freelist-&gt;m_data += headroom;
					}
					
					<span class="enscript-comment">/*
					 * Fall back to regular mbufs without
					 * reserving the socket headroom
					 */</span>
					<span class="enscript-keyword">if</span> (freelist == NULL) {
						<span class="enscript-keyword">if</span> (top == NULL)
							MGETHDR(freelist,
							    M_WAIT, MT_DATA);
						<span class="enscript-keyword">else</span>
							MGET(freelist,
							    M_WAIT, MT_DATA);

						<span class="enscript-keyword">if</span> (freelist == NULL) {
							error = ENOBUFS;
							socket_lock(so, 0);
							<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
						}
						<span class="enscript-comment">/*
						 * For datagram protocols,
						 * leave room for protocol
						 * headers in first mbuf.
						 */</span>
						<span class="enscript-keyword">if</span> (atomic &amp;&amp; top == NULL &amp;&amp;
						    bytes_to_copy &lt; MHLEN) {
							MH_ALIGN(freelist,
							    bytes_to_copy);
						}
					}
					m = freelist;
					freelist = m-&gt;m_next;
					m-&gt;m_next = NULL;

					<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_EXT))
						mlen = m-&gt;m_ext.ext_size -
						    m_leadingspace(m);
					<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_PKTHDR))
						mlen =
						    MHLEN - m_leadingspace(m);
					<span class="enscript-keyword">else</span>
						mlen = MLEN - m_leadingspace(m);
					len = imin(mlen, bytes_to_copy);

					chainlength += len;

					space -= len;

					error = uiomove(mtod(m, caddr_t),
					    len, uio);

					resid = uio_resid(uio);

					m-&gt;m_len = len;
					*mp = m;
					top-&gt;m_pkthdr.len += len;
					<span class="enscript-keyword">if</span> (error)
						<span class="enscript-keyword">break</span>;
					mp = &amp;m-&gt;m_next;
					<span class="enscript-keyword">if</span> (resid &lt;= 0) {
						<span class="enscript-keyword">if</span> (flags &amp; MSG_EOR)
							top-&gt;m_flags |= M_EOR;
						<span class="enscript-keyword">break</span>;
					}
					bytes_to_copy = min(resid, space);

				} <span class="enscript-keyword">while</span> (space &gt; 0 &amp;&amp;
				    (chainlength &lt; sosendmaxchain || atomic ||
				    resid &lt; MINCLSIZE));

				socket_lock(so, 0);

				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
			}

			<span class="enscript-keyword">if</span> (flags &amp; (MSG_HOLD|MSG_SEND)) {
				<span class="enscript-comment">/* Enqueue for later, go away if HOLD */</span>
				<span class="enscript-type">struct</span> mbuf *mb1;
				<span class="enscript-keyword">if</span> (so-&gt;so_temp &amp;&amp; (flags &amp; MSG_FLUSH)) {
					m_freem(so-&gt;so_temp);
					so-&gt;so_temp = NULL;
				}
				<span class="enscript-keyword">if</span> (so-&gt;so_temp)
					so-&gt;so_tail-&gt;m_next = top;
				<span class="enscript-keyword">else</span>
					so-&gt;so_temp = top;
				mb1 = top;
				<span class="enscript-keyword">while</span> (mb1-&gt;m_next)
					mb1 = mb1-&gt;m_next;
				so-&gt;so_tail = mb1;
				<span class="enscript-keyword">if</span> (flags &amp; MSG_HOLD) {
					top = NULL;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
				}
				top = so-&gt;so_temp;
			}
			<span class="enscript-keyword">if</span> (dontroute)
				so-&gt;so_options |= SO_DONTROUTE;

			<span class="enscript-comment">/*
			 * Compute flags here, for pru_send and NKEs
			 *
			 * If the user set MSG_EOF, the protocol
			 * understands this flag and nothing left to
			 * send then use PRU_SEND_EOF instead of PRU_SEND.
			 */</span>
			sendflags = (flags &amp; MSG_OOB) ? PRUS_OOB :
			    ((flags &amp; MSG_EOF) &amp;&amp;
			    (so-&gt;so_proto-&gt;pr_flags &amp; PR_IMPLOPCL) &amp;&amp;
			    (resid &lt;= 0)) ? PRUS_EOF :
			    <span class="enscript-comment">/* If there is more to send set PRUS_MORETOCOME */</span>
			    (resid &gt; 0 &amp;&amp; space &gt; 0) ? PRUS_MORETOCOME : 0;

			<span class="enscript-keyword">if</span> ((flags &amp; MSG_SKIPCFIL) == 0) {
				<span class="enscript-comment">/*
				 * Socket filter processing
				 */</span>
				error = sflt_data_out(so, addr, &amp;top,
				    &amp;control, (sendflags &amp; MSG_OOB) ?
				    sock_data_filt_flag_oob : 0);
				<span class="enscript-keyword">if</span> (error) {
					<span class="enscript-keyword">if</span> (error == EJUSTRETURN) {
						error = 0;
						clen = 0;
						control = NULL;
						top = NULL;
					}
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
				}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
				<span class="enscript-comment">/*
				 * Content filter processing
				 */</span>
				error = cfil_sock_data_out(so, addr, top,
				    control, (sendflags &amp; MSG_OOB) ?
				    sock_data_filt_flag_oob : 0);
				<span class="enscript-keyword">if</span> (error) {
					<span class="enscript-keyword">if</span> (error == EJUSTRETURN) {
						error = 0;
						clen = 0;
						control = NULL;
						top = NULL;
						}
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
				}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>
			}
			<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_ENABLE_MSGS) {
				<span class="enscript-comment">/*
				 * Make a copy of control mbuf,
				 * so that msg priority can be
				 * passed to subsequent mbufs.
				 */</span>
				control_copy = m_dup(control, M_NOWAIT);
			}
			error = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_send)
			    (so, sendflags, top, addr, control, p);

			<span class="enscript-keyword">if</span> (flags &amp; MSG_SEND)
				so-&gt;so_temp = NULL;

			<span class="enscript-keyword">if</span> (dontroute)
				so-&gt;so_options &amp;= ~SO_DONTROUTE;

			clen = 0;
			control = control_copy;
			control_copy = NULL;
			top = NULL;
			mp = &amp;top;
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		} <span class="enscript-keyword">while</span> (resid &amp;&amp; space &gt; 0);
	} <span class="enscript-keyword">while</span> (resid);

<span class="enscript-reference">release</span>:
	<span class="enscript-keyword">if</span> (sblocked)
		sbunlock(&amp;so-&gt;so_snd, FALSE);	<span class="enscript-comment">/* will unlock socket */</span>
	<span class="enscript-keyword">else</span>
		socket_unlock(so, 1);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (top != NULL)
		m_freem(top);
	<span class="enscript-keyword">if</span> (control != NULL)
		m_freem(control);
	<span class="enscript-keyword">if</span> (freelist != NULL)
		m_freem_list(freelist);
	<span class="enscript-keyword">if</span> (control_copy != NULL)
		m_freem(control_copy);

	<span class="enscript-comment">/*
	 * One write has been done. This was enough. Get back to &quot;normal&quot;
	 * behavior.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags1 &amp; SOF1_PRECONNECT_DATA)
		so-&gt;so_flags1 &amp;= ~SOF1_PRECONNECT_DATA;

	<span class="enscript-keyword">if</span> (en_tracing) {
		<span class="enscript-comment">/* resid passed here is the bytes left in uio */</span>
		KERNEL_ENERGYTRACE(kEnTrActKernSockWrite, DBG_FUNC_END,
		    VM_KERNEL_ADDRPERM(so),
		    ((error == EWOULDBLOCK) ? kEnTrFlagNoWork : 0),
		    (int64_t)(orig_resid - resid));
	}
	KERNEL_DEBUG(DBG_FNC_SOSEND | DBG_FUNC_END, so, resid,
	    so-&gt;so_snd.sb_cc, space, error);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Supported only connected sockets (no address) without ancillary data
 * (control mbuf) for atomic protocols
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">sosend_list</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> uio **uioarray, u_int uiocnt, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> mbuf *m, *freelist = NULL;
	user_ssize_t len, resid;
	<span class="enscript-type">int</span> error, dontroute, mlen;
	<span class="enscript-type">int</span> atomic = sosendallatonce(so);
	<span class="enscript-type">int</span> sblocked = 0;
	<span class="enscript-type">struct</span> proc *p = current_proc();
	u_int uiofirst = 0;
	u_int uiolast = 0;
	<span class="enscript-type">struct</span> mbuf *top = NULL;
	uint16_t headroom = 0;
	boolean_t bigcl;

	KERNEL_DEBUG((DBG_FNC_SOSEND_LIST | DBG_FUNC_START), so, uiocnt,
	    so-&gt;so_snd.sb_cc, so-&gt;so_snd.sb_lowat, so-&gt;so_snd.sb_hiwat);

	<span class="enscript-keyword">if</span> (so-&gt;so_type != SOCK_DGRAM) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (atomic == 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_send_list == NULL) {
		error = EPROTONOSUPPORT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (flags &amp; ~(MSG_DONTWAIT | MSG_NBIO)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	resid = uio_array_resid(uioarray, uiocnt);

	<span class="enscript-comment">/*
	 * In theory resid should be unsigned.
	 * However, space must be signed, as it might be less than 0
	 * if we over-committed, and we must use a signed comparison
	 * of space and resid.  On the other hand, a negative resid
	 * causes us to loop sending 0-length segments to the protocol.
	 *
	 * Note: We limit resid to be a positive int value as we use
	 * imin() to set bytes_to_copy -- radr://14558484
	 */</span>
	<span class="enscript-keyword">if</span> (resid &lt; 0 || resid &gt; INT_MAX) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	socket_lock(so, 1);
	so_update_last_owner_locked(so, p);
	so_update_policy(so);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	so_update_necp_policy(so, NULL, NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	dontroute = (flags &amp; MSG_DONTROUTE) &amp;&amp;
	    (so-&gt;so_options &amp; SO_DONTROUTE) == 0 &amp;&amp;
	    (so-&gt;so_proto-&gt;pr_flags &amp; PR_ATOMIC);
	OSIncrementAtomicLong(&amp;p-&gt;p_stats-&gt;p_ru.ru_msgsnd);

	error = sosendcheck(so, NULL, resid, 0, atomic, flags,
	    &amp;sblocked, NULL);
	<span class="enscript-keyword">if</span> (error)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;

	<span class="enscript-comment">/*
	 * Use big 4 KB clusters when the outgoing interface does not prefer
	 * 2 KB clusters
	 */</span>
	bigcl = !(so-&gt;so_flags1 &amp; SOF1_IF_2KCL) || sosendbigcl_ignore_capab;

	<span class="enscript-keyword">if</span> (soreserveheadroom != 0)
		headroom = so-&gt;so_pktheadroom;

	<span class="enscript-keyword">do</span> {
		<span class="enscript-type">int</span> i;
		<span class="enscript-type">int</span> num_needed = 0;
		<span class="enscript-type">int</span> chainlength;
		size_t maxpktlen = 0;
		<span class="enscript-type">int</span> bytes_to_alloc;

		<span class="enscript-keyword">if</span> (sosendminchain &gt; 0)
			chainlength = 0;
		<span class="enscript-keyword">else</span>
			chainlength = sosendmaxchain;

		socket_unlock(so, 0);

		<span class="enscript-comment">/*
		 * Find a set of uio that fit in a reasonable number
		 * of mbuf packets
		 */</span>
		<span class="enscript-keyword">for</span> (i = uiofirst; i &lt; uiocnt; i++) {
			<span class="enscript-type">struct</span> uio *auio = uioarray[i];

			len = uio_resid(auio);

			<span class="enscript-comment">/* Do nothing for empty messages */</span>
			<span class="enscript-keyword">if</span> (len == 0)
				<span class="enscript-keyword">continue</span>;

			num_needed += 1;
			uiolast += 1;

			<span class="enscript-keyword">if</span> (len &gt; maxpktlen)
				maxpktlen = len;

			chainlength += len;
			<span class="enscript-keyword">if</span> (chainlength &gt; sosendmaxchain)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		 * Nothing left to send
		 */</span>
		<span class="enscript-keyword">if</span> (num_needed == 0) {
			socket_lock(so, 0);
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		 * Allocate buffer large enough to include headroom space for
		 * network and link header
		 * 
		 */</span>
		bytes_to_alloc = maxpktlen + headroom;

		<span class="enscript-comment">/*
		 * Allocate a single contiguous buffer of the smallest available
		 * size when possible
		 */</span>
		<span class="enscript-keyword">if</span> (bytes_to_alloc &gt; MCLBYTES &amp;&amp;
		    bytes_to_alloc &lt;= MBIGCLBYTES &amp;&amp; bigcl) {
			freelist = m_getpackets_internal(
			    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)&amp;num_needed,
			    num_needed, M_WAIT, 1,
			    MBIGCLBYTES);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bytes_to_alloc &gt; _MHLEN &amp;&amp;
		    bytes_to_alloc &lt;= MCLBYTES) {
			freelist = m_getpackets_internal(
			    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)&amp;num_needed,
			    num_needed, M_WAIT, 1,
			    MCLBYTES);
		} <span class="enscript-keyword">else</span> {
			freelist = m_allocpacket_internal(
			    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *)&amp;num_needed,
			    bytes_to_alloc, NULL, M_WAIT, 1, 0);
		}
		
		<span class="enscript-keyword">if</span> (freelist == NULL) {
			socket_lock(so, 0);
			error = ENOMEM;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}
		<span class="enscript-comment">/*
		 * Copy each uio of the set into its own mbuf packet
		 */</span>
		<span class="enscript-keyword">for</span> (i = uiofirst, m = freelist;
		    i &lt; uiolast &amp;&amp; m != NULL;
		    i++) {
			<span class="enscript-type">int</span> bytes_to_copy;
			<span class="enscript-type">struct</span> mbuf *n;
			<span class="enscript-type">struct</span> uio *auio = uioarray[i];

			bytes_to_copy = uio_resid(auio);

			<span class="enscript-comment">/* Do nothing for empty messages */</span>
			<span class="enscript-keyword">if</span> (bytes_to_copy == 0)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-comment">/*
			 * Leave headroom for protocol headers
			 * in the first mbuf of the chain
			 */</span>
			m-&gt;m_data += headroom;

			<span class="enscript-keyword">for</span> (n = m; n != NULL; n = n-&gt;m_next) {
				<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_EXT))
					mlen = m-&gt;m_ext.ext_size -
					    m_leadingspace(m);
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_PKTHDR))
					mlen =
					    MHLEN - m_leadingspace(m);
				<span class="enscript-keyword">else</span>
					mlen = MLEN - m_leadingspace(m);
				len = imin(mlen, bytes_to_copy);

				<span class="enscript-comment">/*
				 * Note: uiomove() decrements the iovec
				 * length
				 */</span>
				error = uiomove(mtod(n, caddr_t),
				    len, auio);
				<span class="enscript-keyword">if</span> (error != 0)
					<span class="enscript-keyword">break</span>;
				n-&gt;m_len = len;
				m-&gt;m_pkthdr.len += len;

				VERIFY(m-&gt;m_pkthdr.len &lt;= maxpktlen);

				bytes_to_copy -= len;
				resid -= len;
			}
			<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len == 0) {
				printf(
				    <span class="enscript-string">&quot;%s:%d so %llx pkt %llx type %u len null\n&quot;</span>,
				    __func__, __LINE__,
				    (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
				    (uint64_t)DEBUG_KERNEL_ADDRPERM(m),
				    m-&gt;m_type);
			}
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">break</span>;
			m = m-&gt;m_nextpkt;
		}

		socket_lock(so, 0);

		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		top = freelist;
		freelist = NULL;

		<span class="enscript-keyword">if</span> (dontroute)
			so-&gt;so_options |= SO_DONTROUTE;

		<span class="enscript-keyword">if</span> ((flags &amp; MSG_SKIPCFIL) == 0) {
			<span class="enscript-type">struct</span> mbuf **prevnextp = NULL;

			<span class="enscript-keyword">for</span> (i = uiofirst, m = top;
			    i &lt; uiolast &amp;&amp; m != NULL;
			    i++) {
				<span class="enscript-type">struct</span> mbuf *nextpkt = m-&gt;m_nextpkt;

				<span class="enscript-comment">/*
				 * Socket filter processing
				 */</span>
				error = sflt_data_out(so, NULL, &amp;m,
				    NULL, 0);
				<span class="enscript-keyword">if</span> (error != 0 &amp;&amp; error != EJUSTRETURN)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
				<span class="enscript-keyword">if</span> (error == 0) {
					<span class="enscript-comment">/*
					 * Content filter processing
					 */</span>
					error = cfil_sock_data_out(so, NULL, m,
					    NULL, 0);
					<span class="enscript-keyword">if</span> (error != 0 &amp;&amp; error != EJUSTRETURN)
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
				}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>
				<span class="enscript-comment">/*
				 * Remove packet from the list when
				 * swallowed by a filter
				 */</span>
				<span class="enscript-keyword">if</span> (error == EJUSTRETURN) {
					error = 0;
					<span class="enscript-keyword">if</span> (prevnextp != NULL)
						*prevnextp = nextpkt;
					<span class="enscript-keyword">else</span>
						top = nextpkt;
				}

				m = nextpkt;
				<span class="enscript-keyword">if</span> (m != NULL)
					prevnextp = &amp;m-&gt;m_nextpkt;
			}
		}
		<span class="enscript-keyword">if</span> (top != NULL)
			error = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_send_list)
			    (so, 0, top, NULL, NULL, p);

		<span class="enscript-keyword">if</span> (dontroute)
			so-&gt;so_options &amp;= ~SO_DONTROUTE;

		top = NULL;
		uiofirst = uiolast;
	} <span class="enscript-keyword">while</span> (resid &gt; 0 &amp;&amp; error == 0);
<span class="enscript-reference">release</span>:
	<span class="enscript-keyword">if</span> (sblocked)
		sbunlock(&amp;so-&gt;so_snd, FALSE);	<span class="enscript-comment">/* will unlock socket */</span>
	<span class="enscript-keyword">else</span>
		socket_unlock(so, 1);
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (top != NULL)
		m_freem(top);
	<span class="enscript-keyword">if</span> (freelist != NULL)
		m_freem_list(freelist);

	KERNEL_DEBUG(DBG_FNC_SOSEND_LIST | DBG_FUNC_END, so, resid,
	    so-&gt;so_snd.sb_cc, 0, error);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * May return ERESTART when packet is dropped by MAC policy check
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">soreceive_addr</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **psa,
    <span class="enscript-type">int</span> flags, <span class="enscript-type">struct</span> mbuf **mp, <span class="enscript-type">struct</span> mbuf **nextrecordp, <span class="enscript-type">int</span> canwait)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> mbuf *m = *mp;
	<span class="enscript-type">struct</span> mbuf *nextrecord = *nextrecordp;

	KASSERT(m-&gt;m_type == MT_SONAME, (<span class="enscript-string">&quot;receive 1a&quot;</span>));
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET_SUBSET</span>
	<span class="enscript-comment">/*
	 * Call the MAC framework for policy checking if we're in
	 * the user process context and the socket isn't connected.
	 */</span>
	<span class="enscript-keyword">if</span> (p != kernproc &amp;&amp; !(so-&gt;so_state &amp; SS_ISCONNECTED)) {
		<span class="enscript-type">struct</span> mbuf *m0 = m;
		<span class="enscript-comment">/*
		 * Dequeue this record (temporarily) from the receive
		 * list since we're about to drop the socket's lock
		 * where a new record may arrive and be appended to
		 * the list.  Upon MAC policy failure, the record
		 * will be freed.  Otherwise, we'll add it back to
		 * the head of the list.  We cannot rely on SB_LOCK
		 * because append operation uses the socket's lock.
		 */</span>
		<span class="enscript-keyword">do</span> {
			m-&gt;m_nextpkt = NULL;
			sbfree(&amp;so-&gt;so_rcv, m);
			m = m-&gt;m_next;
		} <span class="enscript-keyword">while</span> (m != NULL);
		m = m0;
		so-&gt;so_rcv.sb_mb = nextrecord;
		SB_EMPTY_FIXUP(&amp;so-&gt;so_rcv);
		SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 1a&quot;</span>);
		SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 1a&quot;</span>);
		socket_unlock(so, 0);

		<span class="enscript-keyword">if</span> (mac_socket_check_received(proc_ucred(p), so,
		    mtod(m, <span class="enscript-type">struct</span> sockaddr *)) != 0) {
			<span class="enscript-comment">/*
			 * MAC policy failure; free this record and
			 * process the next record (or block until
			 * one is available).  We have adjusted sb_cc
			 * and sb_mbcnt above so there is no need to
			 * call sbfree() again.
			 */</span>
			m_freem(m);
			<span class="enscript-comment">/*
			 * Clear SB_LOCK but don't unlock the socket.
			 * Process the next record or wait for one.
			 */</span>
			socket_lock(so, 0);
			sbunlock(&amp;so-&gt;so_rcv, TRUE); <span class="enscript-comment">/* stay locked */</span>
			error = ERESTART;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		socket_lock(so, 0);
		<span class="enscript-comment">/*
		 * If the socket has been defunct'd, drop it.
		 */</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DEFUNCT) {
			m_freem(m);
			error = ENOTCONN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		<span class="enscript-comment">/*
		 * Re-adjust the socket receive list and re-enqueue
		 * the record in front of any packets which may have
		 * been appended while we dropped the lock.
		 */</span>
		<span class="enscript-keyword">for</span> (m = m0; m-&gt;m_next != NULL; m = m-&gt;m_next)
			sballoc(&amp;so-&gt;so_rcv, m);
		sballoc(&amp;so-&gt;so_rcv, m);
		<span class="enscript-keyword">if</span> (so-&gt;so_rcv.sb_mb == NULL) {
			so-&gt;so_rcv.sb_lastrecord = m0;
			so-&gt;so_rcv.sb_mbtail = m;
		}
		m = m0;
		nextrecord = m-&gt;m_nextpkt = so-&gt;so_rcv.sb_mb;
		so-&gt;so_rcv.sb_mb = m;
		SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 1b&quot;</span>);
		SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 1b&quot;</span>);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MACF_SOCKET_SUBSET */</span>
	<span class="enscript-keyword">if</span> (psa != NULL) {
		*psa = dup_sockaddr(mtod(m, <span class="enscript-type">struct</span> sockaddr *), canwait);
		<span class="enscript-keyword">if</span> ((*psa == NULL) &amp;&amp; (flags &amp; MSG_NEEDSA)) {
			error = EWOULDBLOCK;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}
	<span class="enscript-keyword">if</span> (flags &amp; MSG_PEEK) {
		m = m-&gt;m_next;
	} <span class="enscript-keyword">else</span> {
		sbfree(&amp;so-&gt;so_rcv, m);
		<span class="enscript-keyword">if</span> (m-&gt;m_next == NULL &amp;&amp; so-&gt;so_rcv.sb_cc != 0) {
			panic(<span class="enscript-string">&quot;%s: about to create invalid socketbuf&quot;</span>,
			    __func__);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		MFREE(m, so-&gt;so_rcv.sb_mb);
		m = so-&gt;so_rcv.sb_mb;
		<span class="enscript-keyword">if</span> (m != NULL) {
			m-&gt;m_nextpkt = nextrecord;
		} <span class="enscript-keyword">else</span> {
			so-&gt;so_rcv.sb_mb = nextrecord;
			SB_EMPTY_FIXUP(&amp;so-&gt;so_rcv);
		}
	}
<span class="enscript-reference">done</span>:
	*mp = m;
	*nextrecordp = nextrecord;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Process one or more MT_CONTROL mbufs present before any data mbufs
 * in the first mbuf chain on the socket buffer.  If MSG_PEEK, we
 * just copy the data; if !MSG_PEEK, we call into the protocol to
 * perform externalization.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">soreceive_ctl</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> mbuf **controlp, <span class="enscript-type">int</span> flags,
    <span class="enscript-type">struct</span> mbuf **mp, <span class="enscript-type">struct</span> mbuf **nextrecordp)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> mbuf *cm = NULL, *cmn;
	<span class="enscript-type">struct</span> mbuf **cme = &amp;cm;
	<span class="enscript-type">struct</span> sockbuf *sb_rcv = &amp;so-&gt;so_rcv;
	<span class="enscript-type">struct</span> mbuf **msgpcm = NULL;
	<span class="enscript-type">struct</span> mbuf *m = *mp;
	<span class="enscript-type">struct</span> mbuf *nextrecord = *nextrecordp;
	<span class="enscript-type">struct</span> protosw *pr = so-&gt;so_proto;

	<span class="enscript-comment">/*
	 * Externalizing the control messages would require us to
	 * drop the socket's lock below.  Once we re-acquire the
	 * lock, the mbuf chain might change.  In order to preserve
	 * consistency, we unlink all control messages from the
	 * first mbuf chain in one shot and link them separately
	 * onto a different chain.
	 */</span>
	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> (flags &amp; MSG_PEEK) {
			<span class="enscript-keyword">if</span> (controlp != NULL) {
				<span class="enscript-keyword">if</span> (*controlp == NULL) {
					msgpcm = controlp;
				}
				*controlp = m_copy(m, 0, m-&gt;m_len);

				<span class="enscript-comment">/*
				 * If we failed to allocate an mbuf,
				 * release any previously allocated
				 * mbufs for control data. Return
				 * an error. Keep the mbufs in the
				 * socket as this is using
				 * MSG_PEEK flag.
				 */</span>
				<span class="enscript-keyword">if</span> (*controlp == NULL) {
					m_freem(*msgpcm);
					error = ENOBUFS;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
				}
				controlp = &amp;(*controlp)-&gt;m_next;
			}
			m = m-&gt;m_next;
		} <span class="enscript-keyword">else</span> {
			m-&gt;m_nextpkt = NULL;
			sbfree(sb_rcv, m);
			sb_rcv-&gt;sb_mb = m-&gt;m_next;
			m-&gt;m_next = NULL;
			*cme = m;
			cme = &amp;(*cme)-&gt;m_next;
			m = sb_rcv-&gt;sb_mb;
		}
	} <span class="enscript-keyword">while</span> (m != NULL &amp;&amp; m-&gt;m_type == MT_CONTROL);

	<span class="enscript-keyword">if</span> (!(flags &amp; MSG_PEEK)) {
		<span class="enscript-keyword">if</span> (sb_rcv-&gt;sb_mb != NULL) {
			sb_rcv-&gt;sb_mb-&gt;m_nextpkt = nextrecord;
		} <span class="enscript-keyword">else</span> {
			sb_rcv-&gt;sb_mb = nextrecord;
			SB_EMPTY_FIXUP(sb_rcv);
		}
		<span class="enscript-keyword">if</span> (nextrecord == NULL)
			sb_rcv-&gt;sb_lastrecord = m;
	}

	SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive ctl&quot;</span>);
	SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive ctl&quot;</span>);

	<span class="enscript-keyword">while</span> (cm != NULL) {
		<span class="enscript-type">int</span> cmsg_type;

		cmn = cm-&gt;m_next;
		cm-&gt;m_next = NULL;
		cmsg_type = mtod(cm, <span class="enscript-type">struct</span> cmsghdr *)-&gt;cmsg_type;

		<span class="enscript-comment">/*
		 * Call the protocol to externalize SCM_RIGHTS message
		 * and return the modified message to the caller upon
		 * success.  Otherwise, all other control messages are
		 * returned unmodified to the caller.  Note that we
		 * only get into this loop if MSG_PEEK is not set.
		 */</span>
		<span class="enscript-keyword">if</span> (pr-&gt;pr_domain-&gt;dom_externalize != NULL &amp;&amp;
		    cmsg_type == SCM_RIGHTS) {
			<span class="enscript-comment">/*
			 * Release socket lock: see 3903171.  This
			 * would also allow more records to be appended
			 * to the socket buffer.  We still have SB_LOCK
			 * set on it, so we can be sure that the head
			 * of the mbuf chain won't change.
			 */</span>
			socket_unlock(so, 0);
			error = (*pr-&gt;pr_domain-&gt;dom_externalize)(cm);
			socket_lock(so, 0);
		} <span class="enscript-keyword">else</span> {
			error = 0;
		}

		<span class="enscript-keyword">if</span> (controlp != NULL &amp;&amp; error == 0) {
			*controlp = cm;
			controlp = &amp;(*controlp)-&gt;m_next;
		} <span class="enscript-keyword">else</span> {
			(<span class="enscript-type">void</span>) m_free(cm);
		}
		cm = cmn;
	}
	<span class="enscript-comment">/*
	 * Update the value of nextrecord in case we received new
	 * records when the socket was unlocked above for
	 * externalizing SCM_RIGHTS.
	 */</span>
	<span class="enscript-keyword">if</span> (m != NULL)
		nextrecord = sb_rcv-&gt;sb_mb-&gt;m_nextpkt;
	<span class="enscript-keyword">else</span>
		nextrecord = sb_rcv-&gt;sb_mb;

<span class="enscript-reference">done</span>:
	*mp = m;
	*nextrecordp = nextrecord;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Implement receive operations on a socket.
 * We depend on the way that records are added to the sockbuf
 * by sbappend*.  In particular, each record (mbufs linked through m_next)
 * must begin with an address if the protocol so specifies,
 * followed by an optional mbuf or mbufs containing ancillary data,
 * and then zero or more mbufs of data.
 * In order to avoid blocking network interrupts for the entire time here,
 * we splx() while doing the actual copy to user space.
 * Although the sockbuf is locked, new data may still be appended,
 * and thus we must maintain consistency of the sockbuf during that time.
 *
 * The caller may receive the data as a single mbuf chain by supplying
 * an mbuf **mp0 for use in returning the chain.  The uio is then used
 * only for the count in uio_resid.
 *
 * Returns:	0			Success
 *		ENOBUFS
 *		ENOTCONN
 *		EWOULDBLOCK
 *	uiomove:EFAULT
 *	sblock:EWOULDBLOCK
 *	sblock:EINTR
 *	sbwait:EBADF
 *	sbwait:EINTR
 *	sodelayed_copy:EFAULT
 *	&lt;pru_rcvoob&gt;:EINVAL[TCP]
 *	&lt;pru_rcvoob&gt;:EWOULDBLOCK[TCP]
 *	&lt;pru_rcvoob&gt;:???
 *	&lt;pr_domain-&gt;dom_externalize&gt;:EMSGSIZE[AF_UNIX]
 *	&lt;pr_domain-&gt;dom_externalize&gt;:ENOBUFS[AF_UNIX]
 *	&lt;pr_domain-&gt;dom_externalize&gt;:???
 *
 * Notes:	Additional return values from calls through &lt;pru_rcvoob&gt; and
 *		&lt;pr_domain-&gt;dom_externalize&gt; depend on protocols other than
 *		TCP or AF_UNIX, which are documented above.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">soreceive</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockaddr **psa, <span class="enscript-type">struct</span> uio *uio,
    <span class="enscript-type">struct</span> mbuf **mp0, <span class="enscript-type">struct</span> mbuf **controlp, <span class="enscript-type">int</span> *flagsp)
{
	<span class="enscript-type">struct</span> mbuf *m, **mp, *ml = NULL;
	<span class="enscript-type">struct</span> mbuf *nextrecord, *free_list;
	<span class="enscript-type">int</span> flags, error, offset;
	user_ssize_t len;
	<span class="enscript-type">struct</span> protosw *pr = so-&gt;so_proto;
	<span class="enscript-type">int</span> moff, type = 0;
	user_ssize_t orig_resid = uio_resid(uio);
	user_ssize_t delayed_copy_len;
	<span class="enscript-type">int</span> can_delay;
	<span class="enscript-type">int</span> need_event;
	<span class="enscript-type">struct</span> proc *p = current_proc();
	boolean_t en_tracing = FALSE;

	<span class="enscript-comment">/*
	 * Sanity check on the length passed by caller as we are making 'int'
	 * comparisons
	 */</span>
	<span class="enscript-keyword">if</span> (orig_resid &lt; 0 || orig_resid &gt; INT_MAX)
		<span class="enscript-keyword">return</span> (EINVAL);

	KERNEL_DEBUG(DBG_FNC_SORECEIVE | DBG_FUNC_START, so,
	    uio_resid(uio), so-&gt;so_rcv.sb_cc, so-&gt;so_rcv.sb_lowat,
	    so-&gt;so_rcv.sb_hiwat);

	socket_lock(so, 1);
	so_update_last_owner_locked(so, p);
	so_update_policy(so);

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MORE_LOCKING_DEBUG</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_usecount == 1) {
		panic(<span class="enscript-string">&quot;%s: so=%x no other reference on socket\n&quot;</span>, __func__, so);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
#<span class="enscript-reference">endif</span>
	mp = mp0;
	<span class="enscript-keyword">if</span> (psa != NULL)
		*psa = NULL;
	<span class="enscript-keyword">if</span> (controlp != NULL)
		*controlp = NULL;
	<span class="enscript-keyword">if</span> (flagsp != NULL)
		flags = *flagsp &amp;~ MSG_EOR;
	<span class="enscript-keyword">else</span>
		flags = 0;

	<span class="enscript-comment">/*
	 * If a recv attempt is made on a previously-accepted socket
	 * that has been marked as inactive (disconnected), reject
	 * the request.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DEFUNCT) {
		<span class="enscript-type">struct</span> sockbuf *sb = &amp;so-&gt;so_rcv;

		error = ENOTCONN;
		SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: defunct so 0x%llx [%d,%d] (%d)\n&quot;</span>,
		    __func__, proc_pid(p), (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
		    SOCK_DOM(so), SOCK_TYPE(so), error));
		<span class="enscript-comment">/*
		 * This socket should have been disconnected and flushed
		 * prior to being returned from sodefunct(); there should
		 * be no data on its receive list, so panic otherwise.
		 */</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_DEFUNCT)
			sb_empty_assert(sb, __func__);
		socket_unlock(so, 1);
		<span class="enscript-keyword">return</span> (error);
	}

	<span class="enscript-keyword">if</span> ((so-&gt;so_flags1 &amp; SOF1_PRECONNECT_DATA) &amp;&amp;
	    pr-&gt;pr_usrreqs-&gt;pru_preconnect) {
		<span class="enscript-comment">/*
		 * A user may set the CONNECT_RESUME_ON_READ_WRITE-flag but not
		 * calling write() right after this. *If* the app calls a read
		 * we do not want to block this read indefinetely. Thus,
		 * we trigger a connect so that the session gets initiated.
		 */</span>
		error = (*pr-&gt;pr_usrreqs-&gt;pru_preconnect)(so);

		<span class="enscript-keyword">if</span> (error) {
			socket_unlock(so, 1);
			<span class="enscript-keyword">return</span> (error);
		}
	}

	<span class="enscript-keyword">if</span> (ENTR_SHOULDTRACE &amp;&amp;
	    (SOCK_CHECK_DOM(so, AF_INET) || SOCK_CHECK_DOM(so, AF_INET6))) {
		<span class="enscript-comment">/*
		 * enable energy tracing for inet sockets that go over
		 * non-loopback interfaces only.
		 */</span>
		<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
		<span class="enscript-keyword">if</span> (inp-&gt;inp_last_outifp != NULL &amp;&amp;
		    !(inp-&gt;inp_last_outifp-&gt;if_flags &amp; IFF_LOOPBACK)) {
			en_tracing = TRUE;
			KERNEL_ENERGYTRACE(kEnTrActKernSockRead, DBG_FUNC_START,
			    VM_KERNEL_ADDRPERM(so),
			    ((so-&gt;so_state &amp; SS_NBIO) ?
			    kEnTrFlagNonBlocking : 0),
			    (int64_t)orig_resid);
		}
	}

	<span class="enscript-comment">/*
	 * When SO_WANTOOBFLAG is set we try to get out-of-band data
	 * regardless of the flags argument. Here is the case were
	 * out-of-band data is not inline.
	 */</span>
	<span class="enscript-keyword">if</span> ((flags &amp; MSG_OOB) ||
	    ((so-&gt;so_options &amp; SO_WANTOOBFLAG) != 0 &amp;&amp;
	    (so-&gt;so_options &amp; SO_OOBINLINE) == 0 &amp;&amp;
	    (so-&gt;so_oobmark || (so-&gt;so_state &amp; SS_RCVATMARK)))) {
		m = m_get(M_WAIT, MT_DATA);
		<span class="enscript-keyword">if</span> (m == NULL) {
			socket_unlock(so, 1);
			KERNEL_DEBUG(DBG_FNC_SORECEIVE | DBG_FUNC_END,
			    ENOBUFS, 0, 0, 0, 0);
			<span class="enscript-keyword">return</span> (ENOBUFS);
		}
		error = (*pr-&gt;pr_usrreqs-&gt;pru_rcvoob)(so, m, flags &amp; MSG_PEEK);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		socket_unlock(so, 0);
		<span class="enscript-keyword">do</span> {
			error = uiomove(mtod(m, caddr_t),
			    imin(uio_resid(uio), m-&gt;m_len), uio);
			m = m_free(m);
		} <span class="enscript-keyword">while</span> (uio_resid(uio) &amp;&amp; error == 0 &amp;&amp; m != NULL);
		socket_lock(so, 0);
<span class="enscript-reference">bad</span>:
		<span class="enscript-keyword">if</span> (m != NULL)
			m_freem(m);

		<span class="enscript-keyword">if</span> ((so-&gt;so_options &amp; SO_WANTOOBFLAG) != 0) {
			<span class="enscript-keyword">if</span> (error == EWOULDBLOCK || error == EINVAL) {
				<span class="enscript-comment">/*
				 * Let's try to get normal data:
				 * EWOULDBLOCK: out-of-band data not
				 * receive yet. EINVAL: out-of-band data
				 * already read.
				 */</span>
				error = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nooob</span>;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error == 0 &amp;&amp; flagsp != NULL) {
				*flagsp |= MSG_OOB;
			}
		}
		socket_unlock(so, 1);
		<span class="enscript-keyword">if</span> (en_tracing) {
			KERNEL_ENERGYTRACE(kEnTrActKernSockRead, DBG_FUNC_END,
			    VM_KERNEL_ADDRPERM(so), 0,
			    (int64_t)(orig_resid - uio_resid(uio)));
		}
		KERNEL_DEBUG(DBG_FNC_SORECEIVE | DBG_FUNC_END, error,
		    0, 0, 0, 0);

		<span class="enscript-keyword">return</span> (error);
	}
<span class="enscript-reference">nooob</span>:
	<span class="enscript-keyword">if</span> (mp != NULL)
		*mp = NULL;

	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_ISCONFIRMING &amp;&amp; uio_resid(uio)) {
		(*pr-&gt;pr_usrreqs-&gt;pru_rcvd)(so, 0);
	}

	free_list = NULL;
	delayed_copy_len = 0;
<span class="enscript-reference">restart</span>:
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MORE_LOCKING_DEBUG</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt;= 1)
		printf(<span class="enscript-string">&quot;soreceive: sblock so=0x%llx ref=%d on socket\n&quot;</span>,
		    (uint64_t)DEBUG_KERNEL_ADDRPERM(so), so-&gt;so_usecount);
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * See if the socket has been closed (SS_NOFDREF|SS_CANTRCVMORE)
	 * and if so just return to the caller.  This could happen when
	 * soreceive() is called by a socket upcall function during the
	 * time the socket is freed.  The socket buffer would have been
	 * locked across the upcall, therefore we cannot put this thread
	 * to sleep (else we will deadlock) or return EWOULDBLOCK (else
	 * we may livelock), because the lock on the socket buffer will
	 * only be released when the upcall routine returns to its caller.
	 * Because the socket has been officially closed, there can be
	 * no further read on it.
	 *
	 * A multipath subflow socket would have its SS_NOFDREF set by
	 * default, so check for SOF_MP_SUBFLOW socket flag; when the
	 * socket is closed for real, SOF_MP_SUBFLOW would be cleared.
	 */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; (SS_NOFDREF | SS_CANTRCVMORE)) ==
	    (SS_NOFDREF | SS_CANTRCVMORE) &amp;&amp; !(so-&gt;so_flags &amp; SOF_MP_SUBFLOW)) {
		socket_unlock(so, 1);
		<span class="enscript-keyword">return</span> (0);
	}

	error = sblock(&amp;so-&gt;so_rcv, SBLOCKWAIT(flags));
	<span class="enscript-keyword">if</span> (error) {
		socket_unlock(so, 1);
		KERNEL_DEBUG(DBG_FNC_SORECEIVE | DBG_FUNC_END, error,
		    0, 0, 0, 0);
		<span class="enscript-keyword">if</span> (en_tracing) {
			KERNEL_ENERGYTRACE(kEnTrActKernSockRead, DBG_FUNC_END,
			    VM_KERNEL_ADDRPERM(so), 0,
			    (int64_t)(orig_resid - uio_resid(uio)));
		}
		<span class="enscript-keyword">return</span> (error);
	}

	m = so-&gt;so_rcv.sb_mb;
	<span class="enscript-comment">/*
	 * If we have less data than requested, block awaiting more
	 * (subject to any timeout) if:
	 *   1. the current count is less than the low water mark, or
	 *   2. MSG_WAITALL is set, and it is possible to do the entire
	 *	receive operation at once if we block (resid &lt;= hiwat).
	 *   3. MSG_DONTWAIT is not set
	 * If MSG_WAITALL is set but resid is larger than the receive buffer,
	 * we have to do the receive in sections, and thus risk returning
	 * a short count if a timeout or signal occurs after we start.
	 */</span>
	<span class="enscript-keyword">if</span> (m == NULL || (((flags &amp; MSG_DONTWAIT) == 0 &amp;&amp;
	    so-&gt;so_rcv.sb_cc &lt; uio_resid(uio)) &amp;&amp;
	    (so-&gt;so_rcv.sb_cc &lt; so-&gt;so_rcv.sb_lowat ||
	    ((flags &amp; MSG_WAITALL) &amp;&amp; uio_resid(uio) &lt;= so-&gt;so_rcv.sb_hiwat)) &amp;&amp;
	    m-&gt;m_nextpkt == NULL &amp;&amp; (pr-&gt;pr_flags &amp; PR_ATOMIC) == 0)) {
		<span class="enscript-comment">/*
		 * Panic if we notice inconsistencies in the socket's
		 * receive list; both sb_mb and sb_cc should correctly
		 * reflect the contents of the list, otherwise we may
		 * end up with false positives during select() or poll()
		 * which could put the application in a bad state.
		 */</span>
		SB_MB_CHECK(&amp;so-&gt;so_rcv);

		<span class="enscript-keyword">if</span> (so-&gt;so_error) {
			<span class="enscript-keyword">if</span> (m != NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">dontblock</span>;
			error = so-&gt;so_error;
			<span class="enscript-keyword">if</span> ((flags &amp; MSG_PEEK) == 0)
				so-&gt;so_error = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}
		<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_CANTRCVMORE) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
			<span class="enscript-comment">/*
			 * Deal with half closed connections
			 */</span>
			<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_ISDISCONNECTED) == 0 &amp;&amp;
				cfil_sock_data_pending(&amp;so-&gt;so_rcv) != 0)
				CFIL_LOG(LOG_INFO,
					<span class="enscript-string">&quot;so %llx ignore SS_CANTRCVMORE&quot;</span>,
					(uint64_t)DEBUG_KERNEL_ADDRPERM(so));
			<span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>
			<span class="enscript-keyword">if</span> (m != NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">dontblock</span>;
			<span class="enscript-keyword">else</span>
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}
		<span class="enscript-keyword">for</span> (; m != NULL; m = m-&gt;m_next)
			<span class="enscript-keyword">if</span> (m-&gt;m_type == MT_OOBDATA || (m-&gt;m_flags &amp; M_EOR)) {
				m = so-&gt;so_rcv.sb_mb;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">dontblock</span>;
			}
		<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; (SS_ISCONNECTED|SS_ISCONNECTING)) == 0 &amp;&amp;
		    (so-&gt;so_proto-&gt;pr_flags &amp; PR_CONNREQUIRED)) {
			error = ENOTCONN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}
		<span class="enscript-keyword">if</span> (uio_resid(uio) == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;

		<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_NBIO) ||
		    (flags &amp; (MSG_DONTWAIT|MSG_NBIO))) {
			error = EWOULDBLOCK;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}
		SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive sbwait 1&quot;</span>);
		SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive sbwait 1&quot;</span>);
		sbunlock(&amp;so-&gt;so_rcv, TRUE);	<span class="enscript-comment">/* keep socket locked */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">EVEN_MORE_LOCKING_DEBUG</span>
		<span class="enscript-keyword">if</span> (socket_debug)
			printf(<span class="enscript-string">&quot;Waiting for socket data\n&quot;</span>);
#<span class="enscript-reference">endif</span>

		error = sbwait(&amp;so-&gt;so_rcv);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">EVEN_MORE_LOCKING_DEBUG</span>
		<span class="enscript-keyword">if</span> (socket_debug)
			printf(<span class="enscript-string">&quot;SORECEIVE - sbwait returned %d\n&quot;</span>, error);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt; 1) {
			panic(<span class="enscript-string">&quot;%s: after 2nd sblock so=%p ref=%d on socket\n&quot;</span>,
			    __func__, so, so-&gt;so_usecount);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		<span class="enscript-keyword">if</span> (error) {
			socket_unlock(so, 1);
			KERNEL_DEBUG(DBG_FNC_SORECEIVE | DBG_FUNC_END, error,
			    0, 0, 0, 0);
			<span class="enscript-keyword">if</span> (en_tracing) {
				KERNEL_ENERGYTRACE(kEnTrActKernSockRead, DBG_FUNC_END,
				    VM_KERNEL_ADDRPERM(so), 0,
				    (int64_t)(orig_resid - uio_resid(uio)));
			}
			<span class="enscript-keyword">return</span> (error);
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}
<span class="enscript-reference">dontblock</span>:
	OSIncrementAtomicLong(&amp;p-&gt;p_stats-&gt;p_ru.ru_msgrcv);
	SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 1&quot;</span>);
	SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 1&quot;</span>);
	nextrecord = m-&gt;m_nextpkt;

	<span class="enscript-keyword">if</span> ((pr-&gt;pr_flags &amp; PR_ADDR) &amp;&amp; m-&gt;m_type == MT_SONAME) {
		error = soreceive_addr(p, so, psa, flags, &amp;m, &amp;nextrecord,
		    mp0 == NULL);
		<span class="enscript-keyword">if</span> (error == ERESTART)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		orig_resid = 0;
	}

	<span class="enscript-comment">/*
	 * Process one or more MT_CONTROL mbufs present before any data mbufs
	 * in the first mbuf chain on the socket buffer.  If MSG_PEEK, we
	 * just copy the data; if !MSG_PEEK, we call into the protocol to
	 * perform externalization.
	 */</span>
	<span class="enscript-keyword">if</span> (m != NULL &amp;&amp; m-&gt;m_type == MT_CONTROL) {
		error = soreceive_ctl(so, controlp, flags, &amp;m, &amp;nextrecord);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		orig_resid = 0;
	}

	<span class="enscript-comment">/*
	 * If the socket is a TCP socket with message delivery
	 * enabled, then create a control msg to deliver the
	 * relative TCP sequence number for this data. Waiting
	 * until this point will protect against failures to
	 * allocate an mbuf for control msgs.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_type == SOCK_STREAM &amp;&amp; SOCK_PROTO(so) == IPPROTO_TCP &amp;&amp;
	    (so-&gt;so_flags &amp; SOF_ENABLE_MSGS) &amp;&amp; controlp != NULL) {
		<span class="enscript-type">struct</span> mbuf *seq_cm;

		seq_cm = sbcreatecontrol((caddr_t)&amp;m-&gt;m_pkthdr.msg_seq,
		    <span class="enscript-keyword">sizeof</span> (uint32_t), SCM_SEQNUM, SOL_SOCKET);
		<span class="enscript-keyword">if</span> (seq_cm == NULL) {
			<span class="enscript-comment">/* unable to allocate a control mbuf */</span>
			error = ENOBUFS;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}
		*controlp = seq_cm;
		controlp = &amp;seq_cm-&gt;m_next;
	}

	<span class="enscript-keyword">if</span> (m != NULL) {
		<span class="enscript-keyword">if</span> (!(flags &amp; MSG_PEEK)) {
			<span class="enscript-comment">/*
			 * We get here because m points to an mbuf following
			 * any MT_SONAME or MT_CONTROL mbufs which have been
			 * processed above.  In any case, m should be pointing
			 * to the head of the mbuf chain, and the nextrecord
			 * should be either NULL or equal to m-&gt;m_nextpkt.
			 * See comments above about SB_LOCK.
			 */</span>
			<span class="enscript-keyword">if</span> (m != so-&gt;so_rcv.sb_mb ||
			    m-&gt;m_nextpkt != nextrecord) {
				panic(<span class="enscript-string">&quot;%s: post-control !sync so=%p m=%p &quot;</span>
				    <span class="enscript-string">&quot;nextrecord=%p\n&quot;</span>, __func__, so, m,
				    nextrecord);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}
			<span class="enscript-keyword">if</span> (nextrecord == NULL)
				so-&gt;so_rcv.sb_lastrecord = m;
		}
		type = m-&gt;m_type;
		<span class="enscript-keyword">if</span> (type == MT_OOBDATA)
			flags |= MSG_OOB;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (!(flags &amp; MSG_PEEK)) {
			SB_EMPTY_FIXUP(&amp;so-&gt;so_rcv);
		}
	}
	SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 2&quot;</span>);
	SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 2&quot;</span>);

	moff = 0;
	offset = 0;

	<span class="enscript-keyword">if</span> (!(flags &amp; MSG_PEEK) &amp;&amp; uio_resid(uio) &gt; sorecvmincopy)
		can_delay = 1;
	<span class="enscript-keyword">else</span>
		can_delay = 0;

	need_event = 0;

	<span class="enscript-keyword">while</span> (m != NULL &amp;&amp;
	    (uio_resid(uio) - delayed_copy_len) &gt; 0 &amp;&amp; error == 0) {
		<span class="enscript-keyword">if</span> (m-&gt;m_type == MT_OOBDATA) {
			<span class="enscript-keyword">if</span> (type != MT_OOBDATA)
				<span class="enscript-keyword">break</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (type == MT_OOBDATA) {
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/*
		 * Make sure to allways set MSG_OOB event when getting
		 * out of band data inline.
		 */</span>
		<span class="enscript-keyword">if</span> ((so-&gt;so_options &amp; SO_WANTOOBFLAG) != 0 &amp;&amp;
		    (so-&gt;so_options &amp; SO_OOBINLINE) != 0 &amp;&amp;
		    (so-&gt;so_state &amp; SS_RCVATMARK) != 0) {
			flags |= MSG_OOB;
		}
		so-&gt;so_state &amp;= ~SS_RCVATMARK;
		len = uio_resid(uio) - delayed_copy_len;
		<span class="enscript-keyword">if</span> (so-&gt;so_oobmark &amp;&amp; len &gt; so-&gt;so_oobmark - offset)
			len = so-&gt;so_oobmark - offset;
		<span class="enscript-keyword">if</span> (len &gt; m-&gt;m_len - moff)
			len = m-&gt;m_len - moff;
		<span class="enscript-comment">/*
		 * If mp is set, just pass back the mbufs.
		 * Otherwise copy them out via the uio, then free.
		 * Sockbuf must be consistent here (points to current mbuf,
		 * it points to next record) when we drop priority;
		 * we must note any additions to the sockbuf when we
		 * block interrupts again.
		 */</span>
		<span class="enscript-keyword">if</span> (mp == NULL) {
			SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive uiomove&quot;</span>);
			SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive uiomove&quot;</span>);
			<span class="enscript-keyword">if</span> (can_delay &amp;&amp; len == m-&gt;m_len) {
				<span class="enscript-comment">/*
				 * only delay the copy if we're consuming the
				 * mbuf and we're NOT in MSG_PEEK mode
				 * and we have enough data to make it worthwile
				 * to drop and retake the lock... can_delay
				 * reflects the state of the 2 latter
				 * constraints moff should always be zero
				 * in these cases
				 */</span>
				delayed_copy_len += len;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (delayed_copy_len) {
					error = sodelayed_copy(so, uio,
					    &amp;free_list, &amp;delayed_copy_len);

					<span class="enscript-keyword">if</span> (error) {
						<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
					}
					<span class="enscript-comment">/*
					 * can only get here if MSG_PEEK is not
					 * set therefore, m should point at the
					 * head of the rcv queue; if it doesn't,
					 * it means something drastically
					 * changed while we were out from behind
					 * the lock in sodelayed_copy. perhaps
					 * a RST on the stream. in any event,
					 * the stream has been interrupted. it's
					 * probably best just to return whatever
					 * data we've moved and let the caller
					 * sort it out...
					 */</span>
					<span class="enscript-keyword">if</span> (m != so-&gt;so_rcv.sb_mb) {
						<span class="enscript-keyword">break</span>;
					}
				}
				socket_unlock(so, 0);
				error = uiomove(mtod(m, caddr_t) + moff,
				    (<span class="enscript-type">int</span>)len, uio);
				socket_lock(so, 0);

				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
			}
		} <span class="enscript-keyword">else</span> {
			uio_setresid(uio, (uio_resid(uio) - len));
		}
		<span class="enscript-keyword">if</span> (len == m-&gt;m_len - moff) {
			<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_EOR)
				flags |= MSG_EOR;
			<span class="enscript-keyword">if</span> (flags &amp; MSG_PEEK) {
				m = m-&gt;m_next;
				moff = 0;
			} <span class="enscript-keyword">else</span> {
				nextrecord = m-&gt;m_nextpkt;
				sbfree(&amp;so-&gt;so_rcv, m);
				m-&gt;m_nextpkt = NULL;

				<span class="enscript-comment">/*
				 * If this packet is an unordered packet
				 * (indicated by M_UNORDERED_DATA flag), remove
				 * the additional bytes added to the
				 * receive socket buffer size.
				 */</span>
				<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; SOF_ENABLE_MSGS) &amp;&amp;
				    m-&gt;m_len &amp;&amp;
				    (m-&gt;m_flags &amp; M_UNORDERED_DATA) &amp;&amp;
				    sbreserve(&amp;so-&gt;so_rcv,
				    so-&gt;so_rcv.sb_hiwat - m-&gt;m_len)) {
					<span class="enscript-keyword">if</span> (so-&gt;so_msg_state-&gt;msg_uno_bytes &gt;
					    m-&gt;m_len) {
						so-&gt;so_msg_state-&gt;
						    msg_uno_bytes -= m-&gt;m_len;
					} <span class="enscript-keyword">else</span> {
						so-&gt;so_msg_state-&gt;
						    msg_uno_bytes = 0;
					}
					m-&gt;m_flags &amp;= ~M_UNORDERED_DATA;
				}

				<span class="enscript-keyword">if</span> (mp != NULL) {
					*mp = m;
					mp = &amp;m-&gt;m_next;
					so-&gt;so_rcv.sb_mb = m = m-&gt;m_next;
					*mp = NULL;
				} <span class="enscript-keyword">else</span> {
					<span class="enscript-keyword">if</span> (free_list == NULL)
						free_list = m;
					<span class="enscript-keyword">else</span>
						ml-&gt;m_next = m;
					ml = m;
					so-&gt;so_rcv.sb_mb = m = m-&gt;m_next;
					ml-&gt;m_next = NULL;
				}
				<span class="enscript-keyword">if</span> (m != NULL) {
					m-&gt;m_nextpkt = nextrecord;
					<span class="enscript-keyword">if</span> (nextrecord == NULL)
						so-&gt;so_rcv.sb_lastrecord = m;
				} <span class="enscript-keyword">else</span> {
					so-&gt;so_rcv.sb_mb = nextrecord;
					SB_EMPTY_FIXUP(&amp;so-&gt;so_rcv);
				}
				SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 3&quot;</span>);
				SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 3&quot;</span>);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (flags &amp; MSG_PEEK) {
				moff += len;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (mp != NULL) {
					<span class="enscript-type">int</span> copy_flag;

					<span class="enscript-keyword">if</span> (flags &amp; MSG_DONTWAIT)
						copy_flag = M_DONTWAIT;
					<span class="enscript-keyword">else</span>
						copy_flag = M_WAIT;
					*mp = m_copym(m, 0, len, copy_flag);
					<span class="enscript-comment">/*
					 * Failed to allocate an mbuf?
					 * Adjust uio_resid back, it was
					 * adjusted down by len bytes which
					 * we didn't copy over.
					 */</span>
					<span class="enscript-keyword">if</span> (*mp == NULL) {
						uio_setresid(uio,
						    (uio_resid(uio) + len));
						<span class="enscript-keyword">break</span>;
					}
				}
				m-&gt;m_data += len;
				m-&gt;m_len -= len;
				so-&gt;so_rcv.sb_cc -= len;
			}
		}
		<span class="enscript-keyword">if</span> (so-&gt;so_oobmark) {
			<span class="enscript-keyword">if</span> ((flags &amp; MSG_PEEK) == 0) {
				so-&gt;so_oobmark -= len;
				<span class="enscript-keyword">if</span> (so-&gt;so_oobmark == 0) {
					so-&gt;so_state |= SS_RCVATMARK;
					<span class="enscript-comment">/*
					 * delay posting the actual event until
					 * after any delayed copy processing
					 * has finished
					 */</span>
					need_event = 1;
					<span class="enscript-keyword">break</span>;
				}
			} <span class="enscript-keyword">else</span> {
				offset += len;
				<span class="enscript-keyword">if</span> (offset == so-&gt;so_oobmark)
					<span class="enscript-keyword">break</span>;
			}
		}
		<span class="enscript-keyword">if</span> (flags &amp; MSG_EOR)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-comment">/*
		 * If the MSG_WAITALL or MSG_WAITSTREAM flag is set
		 * (for non-atomic socket), we must not quit until
		 * &quot;uio-&gt;uio_resid == 0&quot; or an error termination.
		 * If a signal/timeout occurs, return with a short
		 * count but without error.  Keep sockbuf locked
		 * against other readers.
		 */</span>
		<span class="enscript-keyword">while</span> (flags &amp; (MSG_WAITALL|MSG_WAITSTREAM) &amp;&amp; m == NULL &amp;&amp;
		    (uio_resid(uio) - delayed_copy_len) &gt; 0 &amp;&amp;
		    !sosendallatonce(so) &amp;&amp; !nextrecord) {
			<span class="enscript-keyword">if</span> (so-&gt;so_error || ((so-&gt;so_state &amp; SS_CANTRCVMORE)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
			    &amp;&amp; cfil_sock_data_pending(&amp;so-&gt;so_rcv) == 0
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>
			    ))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;

			<span class="enscript-comment">/*
			 * Depending on the protocol (e.g. TCP), the following
			 * might cause the socket lock to be dropped and later
			 * be reacquired, and more data could have arrived and
			 * have been appended to the receive socket buffer by
			 * the time it returns.  Therefore, we only sleep in
			 * sbwait() below if and only if the socket buffer is
			 * empty, in order to avoid a false sleep.
			 */</span>
			<span class="enscript-keyword">if</span> (pr-&gt;pr_flags &amp; PR_WANTRCVD &amp;&amp; so-&gt;so_pcb &amp;&amp;
			    (((<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb)-&gt;inp_state !=
			    INPCB_STATE_DEAD))
				(*pr-&gt;pr_usrreqs-&gt;pru_rcvd)(so, flags);

			SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive sbwait 2&quot;</span>);
			SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive sbwait 2&quot;</span>);

			<span class="enscript-keyword">if</span> (so-&gt;so_rcv.sb_mb == NULL &amp;&amp; sbwait(&amp;so-&gt;so_rcv)) {
				error = 0;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
			}
			<span class="enscript-comment">/*
			 * have to wait until after we get back from the sbwait
			 * to do the copy because we will drop the lock if we
			 * have enough data that has been delayed... by dropping
			 * the lock we open up a window allowing the netisr
			 * thread to process the incoming packets and to change
			 * the state of this socket... we're issuing the sbwait
			 * because the socket is empty and we're expecting the
			 * netisr thread to wake us up when more packets arrive;
			 * if we allow that processing to happen and then sbwait
			 * we could stall forever with packets sitting in the
			 * socket if no further packets arrive from the remote
			 * side.
			 *
			 * we want to copy before we've collected all the data
			 * to satisfy this request to allow the copy to overlap
			 * the incoming packet processing on an MP system
			 */</span>
			<span class="enscript-keyword">if</span> (delayed_copy_len &gt; sorecvmincopy &amp;&amp;
			    (delayed_copy_len &gt; (so-&gt;so_rcv.sb_hiwat / 2))) {
				error = sodelayed_copy(so, uio,
				    &amp;free_list, &amp;delayed_copy_len);

				<span class="enscript-keyword">if</span> (error)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
			}
			m = so-&gt;so_rcv.sb_mb;
			<span class="enscript-keyword">if</span> (m != NULL) {
				nextrecord = m-&gt;m_nextpkt;
			}
			SB_MB_CHECK(&amp;so-&gt;so_rcv);
		}
	}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MORE_LOCKING_DEBUG</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt;= 1) {
		panic(<span class="enscript-string">&quot;%s: after big while so=%p ref=%d on socket\n&quot;</span>,
		    __func__, so, so-&gt;so_usecount);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
#<span class="enscript-reference">endif</span>

	<span class="enscript-keyword">if</span> (m != NULL &amp;&amp; pr-&gt;pr_flags &amp; PR_ATOMIC) {
		<span class="enscript-keyword">if</span> (so-&gt;so_options &amp; SO_DONTTRUNC) {
			flags |= MSG_RCVMORE;
		} <span class="enscript-keyword">else</span> {
			flags |= MSG_TRUNC;
			<span class="enscript-keyword">if</span> ((flags &amp; MSG_PEEK) == 0)
				(<span class="enscript-type">void</span>) sbdroprecord(&amp;so-&gt;so_rcv);
		}
	}

	<span class="enscript-comment">/*
	 * pru_rcvd below (for TCP) may cause more data to be received
	 * if the socket lock is dropped prior to sending the ACK; some
	 * legacy OpenTransport applications don't handle this well
	 * (if it receives less data than requested while MSG_HAVEMORE
	 * is set), and so we set the flag now based on what we know
	 * prior to calling pru_rcvd.
	 */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_options &amp; SO_WANTMORE) &amp;&amp; so-&gt;so_rcv.sb_cc &gt; 0)
		flags |= MSG_HAVEMORE;

	<span class="enscript-keyword">if</span> ((flags &amp; MSG_PEEK) == 0) {
		<span class="enscript-keyword">if</span> (m == NULL) {
			so-&gt;so_rcv.sb_mb = nextrecord;
			<span class="enscript-comment">/*
			 * First part is an inline SB_EMPTY_FIXUP().  Second
			 * part makes sure sb_lastrecord is up-to-date if
			 * there is still data in the socket buffer.
			 */</span>
			<span class="enscript-keyword">if</span> (so-&gt;so_rcv.sb_mb == NULL) {
				so-&gt;so_rcv.sb_mbtail = NULL;
				so-&gt;so_rcv.sb_lastrecord = NULL;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nextrecord-&gt;m_nextpkt == NULL) {
				so-&gt;so_rcv.sb_lastrecord = nextrecord;
			}
			SB_MB_CHECK(&amp;so-&gt;so_rcv);
		}
		SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 4&quot;</span>);
		SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 4&quot;</span>);
		<span class="enscript-keyword">if</span> (pr-&gt;pr_flags &amp; PR_WANTRCVD &amp;&amp; so-&gt;so_pcb)
			(*pr-&gt;pr_usrreqs-&gt;pru_rcvd)(so, flags);
	}

	<span class="enscript-keyword">if</span> (delayed_copy_len) {
		error = sodelayed_copy(so, uio, &amp;free_list, &amp;delayed_copy_len);
		<span class="enscript-keyword">if</span> (error)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
	}
	<span class="enscript-keyword">if</span> (free_list != NULL) {
		m_freem_list(free_list);
		free_list = NULL;
	}
	<span class="enscript-keyword">if</span> (need_event)
		postevent(so, 0, EV_OOB);

	<span class="enscript-keyword">if</span> (orig_resid == uio_resid(uio) &amp;&amp; orig_resid &amp;&amp;
	    (flags &amp; MSG_EOR) == 0 &amp;&amp; (so-&gt;so_state &amp; SS_CANTRCVMORE) == 0) {
		sbunlock(&amp;so-&gt;so_rcv, TRUE);	<span class="enscript-comment">/* keep socket locked */</span>
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}

	<span class="enscript-keyword">if</span> (flagsp != NULL)
		*flagsp |= flags;
<span class="enscript-reference">release</span>:
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MORE_LOCKING_DEBUG</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt;= 1) {
		panic(<span class="enscript-string">&quot;%s: release so=%p ref=%d on socket\n&quot;</span>, __func__,
		    so, so-&gt;so_usecount);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-keyword">if</span> (delayed_copy_len)
		error = sodelayed_copy(so, uio, &amp;free_list, &amp;delayed_copy_len);

	<span class="enscript-keyword">if</span> (free_list != NULL)
		m_freem_list(free_list);

	sbunlock(&amp;so-&gt;so_rcv, FALSE);	<span class="enscript-comment">/* will unlock socket */</span>

	<span class="enscript-keyword">if</span> (en_tracing) {
		KERNEL_ENERGYTRACE(kEnTrActKernSockRead, DBG_FUNC_END,
		    VM_KERNEL_ADDRPERM(so),
		    ((error == EWOULDBLOCK) ? kEnTrFlagNoWork : 0),
		    (int64_t)(orig_resid - uio_resid(uio)));
	}
	KERNEL_DEBUG(DBG_FNC_SORECEIVE | DBG_FUNC_END, so, uio_resid(uio),
	    so-&gt;so_rcv.sb_cc, 0, error);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *	uiomove:EFAULT
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sodelayed_copy</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> uio *uio, <span class="enscript-type">struct</span> mbuf **free_list,
    user_ssize_t *resid)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> mbuf *m;

	m = *free_list;

	socket_unlock(so, 0);

	<span class="enscript-keyword">while</span> (m != NULL &amp;&amp; error == 0) {
		error = uiomove(mtod(m, caddr_t), (<span class="enscript-type">int</span>)m-&gt;m_len, uio);
		m = m-&gt;m_next;
	}
	m_freem_list(*free_list);

	*free_list = NULL;
	*resid = 0;

	socket_lock(so, 0);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sodelayed_copy_list</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> recv_msg_elem *msgarray,
    u_int uiocnt, <span class="enscript-type">struct</span> mbuf **free_list, user_ssize_t *resid)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">so</span>)
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">struct</span> mbuf *ml, *m;
	<span class="enscript-type">int</span> i = 0;
	<span class="enscript-type">struct</span> uio *auio;

	<span class="enscript-keyword">for</span> (ml = *free_list, i = 0; ml != NULL &amp;&amp; i &lt; uiocnt;
	    ml = ml-&gt;m_nextpkt, i++) {
		auio = msgarray[i].uio;
		<span class="enscript-keyword">for</span> (m = ml; m != NULL; m = m-&gt;m_next) {
			error = uiomove(mtod(m, caddr_t), m-&gt;m_len, auio);
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}
<span class="enscript-reference">out</span>:
	m_freem_list(*free_list);

	*free_list = NULL;
	*resid = 0;

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">soreceive_list</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> recv_msg_elem *msgarray, u_int uiocnt,
    <span class="enscript-type">int</span> *flagsp)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> mbuf *nextrecord;
	<span class="enscript-type">struct</span> mbuf *ml = NULL, *free_list = NULL, *free_tail = NULL;
	<span class="enscript-type">int</span> error;
	user_ssize_t len, pktlen, delayed_copy_len = 0;
	<span class="enscript-type">struct</span> protosw *pr = so-&gt;so_proto;
	user_ssize_t resid;
	<span class="enscript-type">struct</span> proc *p = current_proc();
	<span class="enscript-type">struct</span> uio *auio = NULL;
	<span class="enscript-type">int</span> npkts = 0;
	<span class="enscript-type">int</span> sblocked = 0;
	<span class="enscript-type">struct</span> sockaddr **psa = NULL;
	<span class="enscript-type">struct</span> mbuf **controlp = NULL;
	<span class="enscript-type">int</span> can_delay;
	<span class="enscript-type">int</span> flags;
	<span class="enscript-type">struct</span> mbuf *free_others = NULL;

	KERNEL_DEBUG(DBG_FNC_SORECEIVE_LIST | DBG_FUNC_START,
	    so, uiocnt,
	    so-&gt;so_rcv.sb_cc, so-&gt;so_rcv.sb_lowat, so-&gt;so_rcv.sb_hiwat);

	<span class="enscript-comment">/*
	 * Sanity checks:
	 * - Only supports don't wait flags
	 * - Only support datagram sockets (could be extended to raw)
	 * - Must be atomic
	 * - Protocol must support packet chains
	 * - The uio array is NULL (should we panic?)
	 */</span>
	<span class="enscript-keyword">if</span> (flagsp != NULL)
		flags = *flagsp;
	<span class="enscript-keyword">else</span>
		flags = 0;
	<span class="enscript-keyword">if</span> (flags &amp; ~(MSG_PEEK | MSG_WAITALL | MSG_DONTWAIT | MSG_NEEDSA |
	    MSG_NBIO)) {
		printf(<span class="enscript-string">&quot;%s invalid flags 0x%x\n&quot;</span>, __func__, flags);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (so-&gt;so_type != SOCK_DGRAM) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (sosendallatonce(so) == 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_send_list == NULL) {
		error = EPROTONOSUPPORT;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (msgarray == NULL) {
		printf(<span class="enscript-string">&quot;%s uioarray is NULL\n&quot;</span>, __func__);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (uiocnt == 0) {
		printf(<span class="enscript-string">&quot;%s uiocnt is 0\n&quot;</span>, __func__);
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-comment">/*
	 * Sanity check on the length passed by caller as we are making 'int'
	 * comparisons
	 */</span>
	resid = recv_msg_array_resid(msgarray, uiocnt);
	<span class="enscript-keyword">if</span> (resid &lt; 0 || resid &gt; INT_MAX) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (!(flags &amp; MSG_PEEK) &amp;&amp; sorecvmincopy &gt; 0)
		can_delay = 1;
	<span class="enscript-keyword">else</span>
		can_delay = 0;

	socket_lock(so, 1);
	so_update_last_owner_locked(so, p);
	so_update_policy(so);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
	so_update_necp_policy(so, NULL, NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

	<span class="enscript-comment">/*
	 * If a recv attempt is made on a previously-accepted socket
	 * that has been marked as inactive (disconnected), reject
	 * the request.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DEFUNCT) {
		<span class="enscript-type">struct</span> sockbuf *sb = &amp;so-&gt;so_rcv;

		error = ENOTCONN;
		SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: defunct so 0x%llx [%d,%d] (%d)\n&quot;</span>,
		    __func__, proc_pid(p), (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
		    SOCK_DOM(so), SOCK_TYPE(so), error));
		<span class="enscript-comment">/*
		 * This socket should have been disconnected and flushed
		 * prior to being returned from sodefunct(); there should
		 * be no data on its receive list, so panic otherwise.
		 */</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_DEFUNCT)
			sb_empty_assert(sb, __func__);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
	}

<span class="enscript-reference">next</span>:
	<span class="enscript-comment">/*
	 * The uio may be empty
	 */</span>
	<span class="enscript-keyword">if</span> (npkts &gt;= uiocnt) {
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
	}
<span class="enscript-reference">restart</span>:
	<span class="enscript-comment">/*
	 * See if the socket has been closed (SS_NOFDREF|SS_CANTRCVMORE)
	 * and if so just return to the caller.  This could happen when
	 * soreceive() is called by a socket upcall function during the
	 * time the socket is freed.  The socket buffer would have been
	 * locked across the upcall, therefore we cannot put this thread
	 * to sleep (else we will deadlock) or return EWOULDBLOCK (else
	 * we may livelock), because the lock on the socket buffer will
	 * only be released when the upcall routine returns to its caller.
	 * Because the socket has been officially closed, there can be
	 * no further read on it.
	 */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; (SS_NOFDREF | SS_CANTRCVMORE)) ==
	    (SS_NOFDREF | SS_CANTRCVMORE)) {
		error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
	}

	error = sblock(&amp;so-&gt;so_rcv, SBLOCKWAIT(flags));
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
	}
	sblocked = 1;

	m = so-&gt;so_rcv.sb_mb;
	<span class="enscript-comment">/*
	 * Block awaiting more datagram if needed
	 */</span>
	<span class="enscript-keyword">if</span> (m == NULL || (((flags &amp; MSG_DONTWAIT) == 0 &amp;&amp;
	    (so-&gt;so_rcv.sb_cc &lt; so-&gt;so_rcv.sb_lowat ||
	    ((flags &amp; MSG_WAITALL) &amp;&amp; npkts &lt; uiocnt))))) {
		<span class="enscript-comment">/*
		 * Panic if we notice inconsistencies in the socket's
		 * receive list; both sb_mb and sb_cc should correctly
		 * reflect the contents of the list, otherwise we may
		 * end up with false positives during select() or poll()
		 * which could put the application in a bad state.
		 */</span>
		SB_MB_CHECK(&amp;so-&gt;so_rcv);

		<span class="enscript-keyword">if</span> (so-&gt;so_error) {
			error = so-&gt;so_error;
			<span class="enscript-keyword">if</span> ((flags &amp; MSG_PEEK) == 0)
				so-&gt;so_error = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}
		<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_CANTRCVMORE) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}
		<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; (SS_ISCONNECTED|SS_ISCONNECTING)) == 0 &amp;&amp;
		    (so-&gt;so_proto-&gt;pr_flags &amp; PR_CONNREQUIRED)) {
			error = ENOTCONN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}
		<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_NBIO) ||
		    (flags &amp; (MSG_DONTWAIT|MSG_NBIO))) {
			error = EWOULDBLOCK;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}
		<span class="enscript-comment">/*
		 * Do not block if we got some data
		 */</span>
		<span class="enscript-keyword">if</span> (free_list != NULL) {
			error = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}

		SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive sbwait 1&quot;</span>);
		SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive sbwait 1&quot;</span>);

		sbunlock(&amp;so-&gt;so_rcv, TRUE);	<span class="enscript-comment">/* keep socket locked */</span>
		sblocked = 0;

		error = sbwait(&amp;so-&gt;so_rcv);
		<span class="enscript-keyword">if</span> (error) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
	}

	OSIncrementAtomicLong(&amp;p-&gt;p_stats-&gt;p_ru.ru_msgrcv);
	SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 1&quot;</span>);
	SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 1&quot;</span>);

	<span class="enscript-comment">/*
	 * Consume the current uio index as we have a datagram
	 */</span>
	auio = msgarray[npkts].uio;
	resid = uio_resid(auio);
	msgarray[npkts].which |= SOCK_MSG_DATA;
	psa = (msgarray[npkts].which &amp; SOCK_MSG_SA) ?
	    &amp;msgarray[npkts].psa : NULL;
	controlp = (msgarray[npkts].which &amp; SOCK_MSG_CONTROL) ?
	    &amp;msgarray[npkts].controlp : NULL;
	npkts += 1;
	nextrecord = m-&gt;m_nextpkt;

	<span class="enscript-keyword">if</span> ((pr-&gt;pr_flags &amp; PR_ADDR) &amp;&amp; m-&gt;m_type == MT_SONAME) {
		error = soreceive_addr(p, so, psa, flags, &amp;m, &amp;nextrecord, 1);
		<span class="enscript-keyword">if</span> (error == ERESTART)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">restart</span>;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
	}

	<span class="enscript-keyword">if</span> (m != NULL &amp;&amp; m-&gt;m_type == MT_CONTROL) {
		error = soreceive_ctl(so, controlp, flags, &amp;m, &amp;nextrecord);
		<span class="enscript-keyword">if</span> (error != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len == 0) {
		printf(<span class="enscript-string">&quot;%s:%d so %llx pkt %llx type %u pktlen null\n&quot;</span>,
		    __func__, __LINE__,
		    (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
		    (uint64_t)DEBUG_KERNEL_ADDRPERM(m),
		    m-&gt;m_type);
	}

	<span class="enscript-comment">/*
	 * Loop to copy the mbufs of the current record
	 * Support zero length packets
	 */</span>
	ml = NULL;
	pktlen = 0;
	<span class="enscript-keyword">while</span> (m != NULL &amp;&amp; (len = resid - pktlen) &gt;= 0 &amp;&amp; error == 0) {
		<span class="enscript-keyword">if</span> (m-&gt;m_len == 0)
			panic(<span class="enscript-string">&quot;%p m_len zero&quot;</span>, m);
		<span class="enscript-keyword">if</span> (m-&gt;m_type == 0)
			panic(<span class="enscript-string">&quot;%p m_type zero&quot;</span>, m);
		<span class="enscript-comment">/*
		 * Clip to the residual length
		 */</span>
		<span class="enscript-keyword">if</span> (len &gt; m-&gt;m_len)
			len = m-&gt;m_len;
		pktlen += len;
		<span class="enscript-comment">/*
		 * Copy the mbufs via the uio or delay the copy
		 * Sockbuf must be consistent here (points to current mbuf,
		 * it points to next record) when we drop priority;
		 * we must note any additions to the sockbuf when we
		 * block interrupts again.
		 */</span>
		<span class="enscript-keyword">if</span> (len &gt; 0 &amp;&amp; can_delay == 0) {
			socket_unlock(so, 0);
			error = uiomove(mtod(m, caddr_t), (<span class="enscript-type">int</span>)len, auio);
			socket_lock(so, 0);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;
		} <span class="enscript-keyword">else</span> {
			delayed_copy_len += len;
		}

		<span class="enscript-keyword">if</span> (len == m-&gt;m_len) {
			<span class="enscript-comment">/*
			 * m was entirely copied
			 */</span>
			sbfree(&amp;so-&gt;so_rcv, m);
			nextrecord = m-&gt;m_nextpkt;
			m-&gt;m_nextpkt = NULL;

			<span class="enscript-comment">/*
			 * Set the first packet to the head of the free list
			 */</span>
			<span class="enscript-keyword">if</span> (free_list == NULL)
				free_list = m;
			<span class="enscript-comment">/*
			 * Link current packet to tail of free list
			 */</span>
			<span class="enscript-keyword">if</span> (ml == NULL) {
				<span class="enscript-keyword">if</span> (free_tail != NULL)
					free_tail-&gt;m_nextpkt = m;
				free_tail = m;
			}
			<span class="enscript-comment">/*
			 * Link current mbuf to last mbuf of current packet
			 */</span>
			<span class="enscript-keyword">if</span> (ml != NULL)
				ml-&gt;m_next = m;
			ml = m;

			<span class="enscript-comment">/*
			 * Move next buf to head of socket buffer
			 */</span>
			so-&gt;so_rcv.sb_mb = m = ml-&gt;m_next;
			ml-&gt;m_next = NULL;

			<span class="enscript-keyword">if</span> (m != NULL) {
				m-&gt;m_nextpkt = nextrecord;
				<span class="enscript-keyword">if</span> (nextrecord == NULL)
					so-&gt;so_rcv.sb_lastrecord = m;
			} <span class="enscript-keyword">else</span> {
				so-&gt;so_rcv.sb_mb = nextrecord;
				SB_EMPTY_FIXUP(&amp;so-&gt;so_rcv);
			}
			SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 3&quot;</span>);
			SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 3&quot;</span>);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Stop the loop on partial copy
			 */</span>
			<span class="enscript-keyword">break</span>;
		}
	}
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MORE_LOCKING_DEBUG</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt;= 1) {
		panic(<span class="enscript-string">&quot;%s: after big while so=%llx ref=%d on socket\n&quot;</span>,
		    __func__,
		    (uint64_t)DEBUG_KERNEL_ADDRPERM(so), so-&gt;so_usecount);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
#<span class="enscript-reference">endif</span>
	<span class="enscript-comment">/*
	 * Tell the caller we made a partial copy
	 */</span>
	<span class="enscript-keyword">if</span> (m != NULL) {
		<span class="enscript-keyword">if</span> (so-&gt;so_options &amp; SO_DONTTRUNC) {
			<span class="enscript-comment">/*
			 * Copyout first the freelist then the partial mbuf
			 */</span>
			socket_unlock(so, 0);
			<span class="enscript-keyword">if</span> (delayed_copy_len)
				error = sodelayed_copy_list(so, msgarray,
				    uiocnt, &amp;free_list, &amp;delayed_copy_len);

			<span class="enscript-keyword">if</span> (error == 0) {
				error = uiomove(mtod(m, caddr_t), (<span class="enscript-type">int</span>)len,
				    auio);
			}
			socket_lock(so, 0);
			<span class="enscript-keyword">if</span> (error)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">release</span>;

			m-&gt;m_data += len;
			m-&gt;m_len -= len;
			so-&gt;so_rcv.sb_cc -= len;
			flags |= MSG_RCVMORE;
		} <span class="enscript-keyword">else</span> {
			(<span class="enscript-type">void</span>) sbdroprecord(&amp;so-&gt;so_rcv);
			nextrecord = so-&gt;so_rcv.sb_mb;
			m = NULL;
			flags |= MSG_TRUNC;
		}
	}

	<span class="enscript-keyword">if</span> (m == NULL) {
		so-&gt;so_rcv.sb_mb = nextrecord;
		<span class="enscript-comment">/*
		 * First part is an inline SB_EMPTY_FIXUP().  Second
		 * part makes sure sb_lastrecord is up-to-date if
		 * there is still data in the socket buffer.
		 */</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_rcv.sb_mb == NULL) {
			so-&gt;so_rcv.sb_mbtail = NULL;
			so-&gt;so_rcv.sb_lastrecord = NULL;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (nextrecord-&gt;m_nextpkt == NULL) {
			so-&gt;so_rcv.sb_lastrecord = nextrecord;
		}
		SB_MB_CHECK(&amp;so-&gt;so_rcv);
	}
	SBLASTRECORDCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 4&quot;</span>);
	SBLASTMBUFCHK(&amp;so-&gt;so_rcv, <span class="enscript-string">&quot;soreceive 4&quot;</span>);

	<span class="enscript-comment">/*
	 * We can continue to the next packet as long as:
	 * - We haven't exhausted the uio array
	 * - There was no error
	 * - A packet was not truncated
	 * - We can still receive more data
	 */</span>
	<span class="enscript-keyword">if</span> (npkts &lt; uiocnt &amp;&amp; error == 0 &amp;&amp;
	    (flags &amp; (MSG_RCVMORE | MSG_TRUNC)) == 0 &amp;&amp;
	    (so-&gt;so_state &amp; SS_CANTRCVMORE) == 0) {
		sbunlock(&amp;so-&gt;so_rcv, TRUE);	<span class="enscript-comment">/* keep socket locked */</span>
		sblocked = 0;

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">next</span>;
	}
	<span class="enscript-keyword">if</span> (flagsp != NULL)
		*flagsp |= flags;

<span class="enscript-reference">release</span>:
	<span class="enscript-comment">/*
	 * pru_rcvd may cause more data to be received if the socket lock
	 * is dropped so we set MSG_HAVEMORE now based on what we know.
	 * That way the caller won't be surprised if it receives less data
	 * than requested.
	 */</span>
	<span class="enscript-keyword">if</span> ((so-&gt;so_options &amp; SO_WANTMORE) &amp;&amp; so-&gt;so_rcv.sb_cc &gt; 0)
		flags |= MSG_HAVEMORE;

	<span class="enscript-keyword">if</span> (pr-&gt;pr_flags &amp; PR_WANTRCVD &amp;&amp; so-&gt;so_pcb)
		(*pr-&gt;pr_usrreqs-&gt;pru_rcvd)(so, flags);

	<span class="enscript-keyword">if</span> (sblocked)
		sbunlock(&amp;so-&gt;so_rcv, FALSE);	<span class="enscript-comment">/* will unlock socket */</span>
	<span class="enscript-keyword">else</span>
		socket_unlock(so, 1);

	<span class="enscript-keyword">if</span> (delayed_copy_len)
		error = sodelayed_copy_list(so, msgarray, uiocnt,
		    &amp;free_list, &amp;delayed_copy_len);
<span class="enscript-reference">out</span>:
	<span class="enscript-comment">/*
	 * Amortize the cost of freeing the mbufs
	 */</span>
	<span class="enscript-keyword">if</span> (free_list != NULL)
		m_freem_list(free_list);
	<span class="enscript-keyword">if</span> (free_others != NULL)
		m_freem_list(free_others);

	KERNEL_DEBUG(DBG_FNC_SORECEIVE_LIST | DBG_FUNC_END, error,
	    0, 0, 0, 0);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *		EINVAL
 *		ENOTCONN
 *	&lt;pru_shutdown&gt;:EINVAL
 *	&lt;pru_shutdown&gt;:EADDRNOTAVAIL[TCP]
 *	&lt;pru_shutdown&gt;:ENOBUFS[TCP]
 *	&lt;pru_shutdown&gt;:EMSGSIZE[TCP]
 *	&lt;pru_shutdown&gt;:EHOSTUNREACH[TCP]
 *	&lt;pru_shutdown&gt;:ENETUNREACH[TCP]
 *	&lt;pru_shutdown&gt;:ENETDOWN[TCP]
 *	&lt;pru_shutdown&gt;:ENOMEM[TCP]
 *	&lt;pru_shutdown&gt;:EACCES[TCP]
 *	&lt;pru_shutdown&gt;:EMSGSIZE[TCP]
 *	&lt;pru_shutdown&gt;:ENOBUFS[TCP]
 *	&lt;pru_shutdown&gt;:???[TCP]		[ignorable: mostly IPSEC/firewall/DLIL]
 *	&lt;pru_shutdown&gt;:???		[other protocol families]
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">soshutdown</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> how)
{
	<span class="enscript-type">int</span> error;

	KERNEL_DEBUG(DBG_FNC_SOSHUTDOWN | DBG_FUNC_START, how, 0, 0, 0, 0);

	<span class="enscript-keyword">switch</span> (how) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SHUT_RD</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SHUT_WR</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">SHUT_RDWR</span>:
		socket_lock(so, 1);
		<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp;
		    (SS_ISCONNECTED|SS_ISCONNECTING|SS_ISDISCONNECTING)) == 0) {
			error = ENOTCONN;
		} <span class="enscript-keyword">else</span> {
			error = soshutdownlock(so, how);
		}
		socket_unlock(so, 1);
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		error = EINVAL;
		<span class="enscript-keyword">break</span>;
	}

	KERNEL_DEBUG(DBG_FNC_SOSHUTDOWN | DBG_FUNC_END, how, error, 0, 0, 0);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">soshutdownlock_final</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> protosw *pr = so-&gt;so_proto;
	<span class="enscript-type">int</span> error = 0;

	sflt_notify(so, sock_evt_shutdown, &amp;how);

	<span class="enscript-keyword">if</span> (how != SHUT_WR) {
		<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_CANTRCVMORE) != 0) {
			<span class="enscript-comment">/* read already shut down */</span>
			error = ENOTCONN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		sorflush(so);
		postevent(so, 0, EV_RCLOSED);
	}
	<span class="enscript-keyword">if</span> (how != SHUT_RD) {
		<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_CANTSENDMORE) != 0) {
			<span class="enscript-comment">/* write already shut down */</span>
			error = ENOTCONN;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
		error = (*pr-&gt;pr_usrreqs-&gt;pru_shutdown)(so);
		postevent(so, 0, EV_WCLOSED);
	}
<span class="enscript-reference">done</span>:
	KERNEL_DEBUG(DBG_FNC_SOSHUTDOWN, how, 1, 0, 0, 0);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">soshutdownlock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> how)
{
	<span class="enscript-type">int</span> error = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
	<span class="enscript-comment">/*
	 * A content filter may delay the actual shutdown until it
	 * has processed the pending data
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_CONTENT_FILTER) {
		error = cfil_sock_shutdown(so, &amp;how);
		<span class="enscript-keyword">if</span> (error == EJUSTRETURN) {
			error = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error != 0) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>

	error = soshutdownlock_final(so, how);

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">sowflush</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> sockbuf *sb = &amp;so-&gt;so_snd;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">notyet</span>
	lck_mtx_t *mutex_held;
	<span class="enscript-comment">/*
	 * XXX: This code is currently commented out, because we may get here
	 * as part of sofreelastref(), and at that time, pr_getlock() may no
	 * longer be able to return us the lock; this will be fixed in future.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_getlock != NULL)
		mutex_held = (*so-&gt;so_proto-&gt;pr_getlock)(so, 0);
	<span class="enscript-keyword">else</span>
		mutex_held = so-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx;

	lck_mtx_assert(mutex_held, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* notyet */</span>

	<span class="enscript-comment">/*
	 * Obtain lock on the socket buffer (SB_LOCK).  This is required
	 * to prevent the socket buffer from being unexpectedly altered
	 * while it is used by another thread in socket send/receive.
	 *
	 * sblock() must not fail here, hence the assertion.
	 */</span>
	(<span class="enscript-type">void</span>) sblock(sb, SBL_WAIT | SBL_NOINTR | SBL_IGNDEFUNCT);
	VERIFY(sb-&gt;sb_flags &amp; SB_LOCK);

	sb-&gt;sb_flags		&amp;= ~(SB_SEL|SB_UPCALL);
	sb-&gt;sb_flags		|= SB_DROP;
	sb-&gt;sb_upcall		= NULL;
	sb-&gt;sb_upcallarg	= NULL;

	sbunlock(sb, TRUE);	<span class="enscript-comment">/* keep socket locked */</span>

	selthreadclear(&amp;sb-&gt;sb_sel);
	sbrelease(sb);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">sorflush</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> sockbuf *sb = &amp;so-&gt;so_rcv;
	<span class="enscript-type">struct</span> protosw *pr = so-&gt;so_proto;
	<span class="enscript-type">struct</span> sockbuf asb;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">notyet</span>
	lck_mtx_t *mutex_held;
	<span class="enscript-comment">/*
	 * XXX: This code is currently commented out, because we may get here
	 * as part of sofreelastref(), and at that time, pr_getlock() may no
	 * longer be able to return us the lock; this will be fixed in future.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_getlock != NULL)
		mutex_held = (*so-&gt;so_proto-&gt;pr_getlock)(so, 0);
	<span class="enscript-keyword">else</span>
		mutex_held = so-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx;

	lck_mtx_assert(mutex_held, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* notyet */</span>

	sflt_notify(so, sock_evt_flush_read, NULL);

	socantrcvmore(so);

	<span class="enscript-comment">/*
	 * Obtain lock on the socket buffer (SB_LOCK).  This is required
	 * to prevent the socket buffer from being unexpectedly altered
	 * while it is used by another thread in socket send/receive.
	 *
	 * sblock() must not fail here, hence the assertion.
	 */</span>
	(<span class="enscript-type">void</span>) sblock(sb, SBL_WAIT | SBL_NOINTR | SBL_IGNDEFUNCT);
	VERIFY(sb-&gt;sb_flags &amp; SB_LOCK);

	<span class="enscript-comment">/*
	 * Copy only the relevant fields from &quot;sb&quot; to &quot;asb&quot; which we
	 * need for sbrelease() to function.  In particular, skip
	 * sb_sel as it contains the wait queue linkage, which would
	 * wreak havoc if we were to issue selthreadclear() on &quot;asb&quot;.
	 * Make sure to not carry over SB_LOCK in &quot;asb&quot;, as we need
	 * to acquire it later as part of sbrelease().
	 */</span>
	bzero(&amp;asb, <span class="enscript-keyword">sizeof</span> (asb));
	asb.sb_cc		= sb-&gt;sb_cc;
	asb.sb_hiwat		= sb-&gt;sb_hiwat;
	asb.sb_mbcnt		= sb-&gt;sb_mbcnt;
	asb.sb_mbmax		= sb-&gt;sb_mbmax;
	asb.sb_ctl		= sb-&gt;sb_ctl;
	asb.sb_lowat		= sb-&gt;sb_lowat;
	asb.sb_mb		= sb-&gt;sb_mb;
	asb.sb_mbtail		= sb-&gt;sb_mbtail;
	asb.sb_lastrecord	= sb-&gt;sb_lastrecord;
	asb.sb_so		= sb-&gt;sb_so;
	asb.sb_flags		= sb-&gt;sb_flags;
	asb.sb_flags		&amp;= ~(SB_LOCK|SB_SEL|SB_KNOTE|SB_UPCALL);
	asb.sb_flags		|= SB_DROP;

	<span class="enscript-comment">/*
	 * Ideally we'd bzero() these and preserve the ones we need;
	 * but to do that we'd need to shuffle things around in the
	 * sockbuf, and we can't do it now because there are KEXTS
	 * that are directly referring to the socket structure.
	 *
	 * Setting SB_DROP acts as a barrier to prevent further appends.
	 * Clearing SB_SEL is done for selthreadclear() below.
	 */</span>
	sb-&gt;sb_cc		= 0;
	sb-&gt;sb_hiwat		= 0;
	sb-&gt;sb_mbcnt		= 0;
	sb-&gt;sb_mbmax		= 0;
	sb-&gt;sb_ctl		= 0;
	sb-&gt;sb_lowat		= 0;
	sb-&gt;sb_mb		= NULL;
	sb-&gt;sb_mbtail		= NULL;
	sb-&gt;sb_lastrecord	= NULL;
	sb-&gt;sb_timeo.tv_sec	= 0;
	sb-&gt;sb_timeo.tv_usec	= 0;
	sb-&gt;sb_upcall		= NULL;
	sb-&gt;sb_upcallarg	= NULL;
	sb-&gt;sb_flags		&amp;= ~(SB_SEL|SB_UPCALL);
	sb-&gt;sb_flags		|= SB_DROP;

	sbunlock(sb, TRUE);	<span class="enscript-comment">/* keep socket locked */</span>

	<span class="enscript-comment">/*
	 * Note that selthreadclear() is called on the original &quot;sb&quot; and
	 * not the local &quot;asb&quot; because of the way wait queue linkage is
	 * implemented.  Given that selwakeup() may be triggered, SB_SEL
	 * should no longer be set (cleared above.)
	 */</span>
	selthreadclear(&amp;sb-&gt;sb_sel);

	<span class="enscript-keyword">if</span> ((pr-&gt;pr_flags &amp; PR_RIGHTS) &amp;&amp; pr-&gt;pr_domain-&gt;dom_dispose)
		(*pr-&gt;pr_domain-&gt;dom_dispose)(asb.sb_mb);

	sbrelease(&amp;asb);
}

<span class="enscript-comment">/*
 * Perhaps this routine, and sooptcopyout(), below, ought to come in
 * an additional variant to handle the case where the option value needs
 * to be some kind of integer, but not a specific size.
 * In addition to their use here, these functions are also called by the
 * protocol-level pr_ctloutput() routines.
 *
 * Returns:	0			Success
 *		EINVAL
 *	copyin:EFAULT
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">sooptcopyin</span>(<span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">void</span> *buf, size_t len, size_t minlen)
{
	size_t	valsize;

	<span class="enscript-comment">/*
	 * If the user gives us more than we wanted, we ignore it,
	 * but if we don't get the minimum length the caller
	 * wants, we return EINVAL.  On success, sopt-&gt;sopt_valsize
	 * is set to however much we actually retrieved.
	 */</span>
	<span class="enscript-keyword">if</span> ((valsize = sopt-&gt;sopt_valsize) &lt; minlen)
		<span class="enscript-keyword">return</span> (EINVAL);
	<span class="enscript-keyword">if</span> (valsize &gt; len)
		sopt-&gt;sopt_valsize = valsize = len;

	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_p != kernproc)
		<span class="enscript-keyword">return</span> (copyin(sopt-&gt;sopt_val, buf, valsize));

	bcopy(CAST_DOWN(caddr_t, sopt-&gt;sopt_val), buf, valsize);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * sooptcopyin_timeval
 *   Copy in a timeval value into tv_p, and take into account whether the
 *   the calling process is 64-bit or 32-bit.  Moved the sanity checking
 *   code here so that we can verify the 64-bit tv_sec value before we lose
 *   the top 32-bits assigning tv64.tv_sec to tv_p-&gt;tv_sec.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sooptcopyin_timeval</span>(<span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">struct</span> timeval *tv_p)
{
	<span class="enscript-type">int</span>			error;

	<span class="enscript-keyword">if</span> (proc_is64bit(sopt-&gt;sopt_p)) {
		<span class="enscript-type">struct</span> user64_timeval	tv64;

		<span class="enscript-keyword">if</span> (sopt-&gt;sopt_valsize &lt; <span class="enscript-keyword">sizeof</span> (tv64))
			<span class="enscript-keyword">return</span> (EINVAL);

		sopt-&gt;sopt_valsize = <span class="enscript-keyword">sizeof</span> (tv64);
		<span class="enscript-keyword">if</span> (sopt-&gt;sopt_p != kernproc) {
			error = copyin(sopt-&gt;sopt_val, &amp;tv64, <span class="enscript-keyword">sizeof</span> (tv64));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">return</span> (error);
		} <span class="enscript-keyword">else</span> {
			bcopy(CAST_DOWN(caddr_t, sopt-&gt;sopt_val), &amp;tv64,
			    <span class="enscript-keyword">sizeof</span> (tv64));
		}
		<span class="enscript-keyword">if</span> (tv64.tv_sec &lt; 0 || tv64.tv_sec &gt; LONG_MAX ||
		    tv64.tv_usec &lt; 0 || tv64.tv_usec &gt;= 1000000)
			<span class="enscript-keyword">return</span> (EDOM);

		tv_p-&gt;tv_sec = tv64.tv_sec;
		tv_p-&gt;tv_usec = tv64.tv_usec;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> user32_timeval	tv32;

		<span class="enscript-keyword">if</span> (sopt-&gt;sopt_valsize &lt; <span class="enscript-keyword">sizeof</span> (tv32))
			<span class="enscript-keyword">return</span> (EINVAL);

		sopt-&gt;sopt_valsize = <span class="enscript-keyword">sizeof</span> (tv32);
		<span class="enscript-keyword">if</span> (sopt-&gt;sopt_p != kernproc) {
			error = copyin(sopt-&gt;sopt_val, &amp;tv32, <span class="enscript-keyword">sizeof</span> (tv32));
			<span class="enscript-keyword">if</span> (error != 0) {
				<span class="enscript-keyword">return</span> (error);
			}
		} <span class="enscript-keyword">else</span> {
			bcopy(CAST_DOWN(caddr_t, sopt-&gt;sopt_val), &amp;tv32,
			    <span class="enscript-keyword">sizeof</span> (tv32));
		}
#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__LP64__</span>
		<span class="enscript-comment">/*
		 * K64todo &quot;comparison is always false due to
		 * limited range of data type&quot;
		 */</span>
		<span class="enscript-keyword">if</span> (tv32.tv_sec &lt; 0 || tv32.tv_sec &gt; LONG_MAX ||
		    tv32.tv_usec &lt; 0 || tv32.tv_usec &gt;= 1000000)
			<span class="enscript-keyword">return</span> (EDOM);
#<span class="enscript-reference">endif</span>
		tv_p-&gt;tv_sec = tv32.tv_sec;
		tv_p-&gt;tv_usec = tv32.tv_usec;
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Returns:	0			Success
 *		EINVAL
 *		ENOPROTOOPT
 *		ENOBUFS
 *		EDOM
 *	sooptcopyin:EINVAL
 *	sooptcopyin:EFAULT
 *	sooptcopyin_timeval:EINVAL
 *	sooptcopyin_timeval:EFAULT
 *	sooptcopyin_timeval:EDOM
 *	&lt;pr_ctloutput&gt;:EOPNOTSUPP[AF_UNIX]
 *	&lt;pr_ctloutput&gt;:???w
 *	sflt_attach_private:???		[whatever a filter author chooses]
 *	&lt;sf_setoption&gt;:???		[whatever a filter author chooses]
 *
 * Notes:	Other &lt;pru_listen&gt; returns depend on the protocol family; all
 *		&lt;sf_listen&gt; returns depend on what the filter author causes
 *		their filter to return.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">sosetoptlock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">int</span> dolock)
{
	<span class="enscript-type">int</span>	error, optval;
	<span class="enscript-type">struct</span>	linger l;
	<span class="enscript-type">struct</span>	timeval tv;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
	<span class="enscript-type">struct</span> mac extmac;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_SOCKET */</span>

	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_dir != SOPT_SET)
		sopt-&gt;sopt_dir = SOPT_SET;

	<span class="enscript-keyword">if</span> (dolock)
		socket_lock(so, 1);

	<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; (SS_CANTRCVMORE | SS_CANTSENDMORE)) ==
	    (SS_CANTRCVMORE | SS_CANTSENDMORE) &amp;&amp;
	    (so-&gt;so_flags &amp; SOF_NPX_SETOPTSHUT) == 0) {
		<span class="enscript-comment">/* the socket has been shutdown, no more sockopt's */</span>
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	error = sflt_setsockopt(so, sopt);
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">if</span> (error == EJUSTRETURN)
			error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_level != SOL_SOCKET) {
		<span class="enscript-keyword">if</span> (so-&gt;so_proto != NULL &amp;&amp;
		    so-&gt;so_proto-&gt;pr_ctloutput != NULL) {
			error = (*so-&gt;so_proto-&gt;pr_ctloutput)(so, sopt);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		error = ENOPROTOOPT;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Allow socket-level (SOL_SOCKET) options to be filtered by
		 * the protocol layer, if needed.  A zero value returned from
		 * the handler means use default socket-level processing as
		 * done by the rest of this routine.  Otherwise, any other
		 * return value indicates that the option is unsupported.
		 */</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_proto != NULL &amp;&amp; (error = so-&gt;so_proto-&gt;pr_usrreqs-&gt;
		    pru_socheckopt(so, sopt)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		error = 0;
		<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_LINGER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_LINGER_SEC</span>:
			error = sooptcopyin(sopt, &amp;l, <span class="enscript-keyword">sizeof</span> (l), <span class="enscript-keyword">sizeof</span> (l));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

			so-&gt;so_linger = (sopt-&gt;sopt_name == SO_LINGER) ?
			    l.l_linger : l.l_linger * hz;
			<span class="enscript-keyword">if</span> (l.l_onoff != 0)
				so-&gt;so_options |= SO_LINGER;
			<span class="enscript-keyword">else</span>
				so-&gt;so_options &amp;= ~SO_LINGER;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_DEBUG</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_KEEPALIVE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_DONTROUTE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_USELOOPBACK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_BROADCAST</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_REUSEADDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_REUSEPORT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_OOBINLINE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TIMESTAMP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TIMESTAMP_MONOTONIC</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_DONTTRUNC</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_WANTMORE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_WANTOOBFLAG</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NOWAKEFROMSLEEP</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">if</span> (optval)
				so-&gt;so_options |= sopt-&gt;sopt_name;
			<span class="enscript-keyword">else</span>
				so-&gt;so_options &amp;= ~sopt-&gt;sopt_name;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_SNDBUF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RCVBUF</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_SNDLOWAT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RCVLOWAT</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

			<span class="enscript-comment">/*
			 * Values &lt; 1 make no sense for any of these
			 * options, so disallow them.
			 */</span>
			<span class="enscript-keyword">if</span> (optval &lt; 1) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}

			<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_SNDBUF</span>:
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RCVBUF</span>: {
				<span class="enscript-type">struct</span> sockbuf *sb =
				    (sopt-&gt;sopt_name == SO_SNDBUF) ?
				    &amp;so-&gt;so_snd : &amp;so-&gt;so_rcv;
				<span class="enscript-keyword">if</span> (sbreserve(sb, (u_int32_t)optval) == 0) {
					error = ENOBUFS;
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
				}
				sb-&gt;sb_flags |= SB_USRSIZE;
				sb-&gt;sb_flags &amp;= ~SB_AUTOSIZE;
				sb-&gt;sb_idealsize = (u_int32_t)optval;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-comment">/*
			 * Make sure the low-water is never greater than
			 * the high-water.
			 */</span>
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_SNDLOWAT</span>: {
				<span class="enscript-type">int</span> space = sbspace(&amp;so-&gt;so_snd);
				u_int32_t hiwat = so-&gt;so_snd.sb_hiwat;

				<span class="enscript-keyword">if</span> (so-&gt;so_snd.sb_flags &amp; SB_UNIX) {
					<span class="enscript-type">struct</span> unpcb *unp =
					    (<span class="enscript-type">struct</span> unpcb *)(so-&gt;so_pcb);
					<span class="enscript-keyword">if</span> (unp != NULL &amp;&amp;
					    unp-&gt;unp_conn != NULL) {
						hiwat += unp-&gt;unp_conn-&gt;unp_cc;
					}
				}

				so-&gt;so_snd.sb_lowat =
				    (optval &gt; hiwat) ?
				    hiwat : optval;

				<span class="enscript-keyword">if</span> (space &gt;= so-&gt;so_snd.sb_lowat) {
					sowwakeup(so);
				}
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RCVLOWAT</span>: {
				int64_t data_len;
				so-&gt;so_rcv.sb_lowat =
				    (optval &gt; so-&gt;so_rcv.sb_hiwat) ?
				    so-&gt;so_rcv.sb_hiwat : optval;
				data_len = so-&gt;so_rcv.sb_cc
				    - so-&gt;so_rcv.sb_ctl;
				<span class="enscript-keyword">if</span> (data_len &gt;= so-&gt;so_rcv.sb_lowat)
				    sorwakeup(so);
				<span class="enscript-keyword">break</span>;
			}
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_SNDTIMEO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RCVTIMEO</span>:
			error = sooptcopyin_timeval(sopt, &amp;tv);
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

			<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_SNDTIMEO</span>:
				so-&gt;so_snd.sb_timeo = tv;
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RCVTIMEO</span>:
				so-&gt;so_rcv.sb_timeo = tv;
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NKE</span>: {
			<span class="enscript-type">struct</span> so_nke nke;

			error = sooptcopyin(sopt, &amp;nke, <span class="enscript-keyword">sizeof</span> (nke),
			    <span class="enscript-keyword">sizeof</span> (nke));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

			error = sflt_attach_internal(so, nke.nke_handle);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NOSIGPIPE</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">if</span> (optval != 0)
				so-&gt;so_flags |= SOF_NOSIGPIPE;
			<span class="enscript-keyword">else</span>
				so-&gt;so_flags &amp;= ~SOF_NOSIGPIPE;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NOADDRERR</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">if</span> (optval != 0)
				so-&gt;so_flags |= SOF_NOADDRAVAIL;
			<span class="enscript-keyword">else</span>
				so-&gt;so_flags &amp;= ~SOF_NOADDRAVAIL;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_REUSESHAREUID</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">if</span> (optval != 0)
				so-&gt;so_flags |= SOF_REUSESHAREUID;
			<span class="enscript-keyword">else</span>
				so-&gt;so_flags &amp;= ~SOF_REUSESHAREUID;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NOTIFYCONFLICT</span>:
			<span class="enscript-keyword">if</span> (kauth_cred_issuser(kauth_cred_get()) == 0) {
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">if</span> (optval != 0)
				so-&gt;so_flags |= SOF_NOTIFYCONFLICT;
			<span class="enscript-keyword">else</span>
				so-&gt;so_flags &amp;= ~SOF_NOTIFYCONFLICT;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RESTRICTIONS</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

			error = so_set_restrictions(so, optval);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_AWDL_UNRESTRICTED</span>:
			<span class="enscript-keyword">if</span> (SOCK_DOM(so) != PF_INET &amp;&amp;
			    SOCK_DOM(so) != PF_INET6) {
				error = EOPNOTSUPP;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span>(optval),
			    <span class="enscript-keyword">sizeof</span>(optval));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">if</span> (optval != 0) {
				kauth_cred_t cred =  NULL;
				proc_t ep = PROC_NULL;

				<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DELEGATED) {
					ep = proc_find(so-&gt;e_pid);
					<span class="enscript-keyword">if</span> (ep)
						cred = kauth_cred_proc_ref(ep);
				}
				error = priv_check_cred(
				    cred ? cred : so-&gt;so_cred,
				    PRIV_NET_RESTRICTED_AWDL, 0);
				<span class="enscript-keyword">if</span> (error == 0)
					inp_set_awdl_unrestricted(
					    sotoinpcb(so));
				<span class="enscript-keyword">if</span> (cred)
					kauth_cred_unref(&amp;cred);
				<span class="enscript-keyword">if</span> (ep != PROC_NULL)
					proc_rele(ep);
			} <span class="enscript-keyword">else</span>
				inp_clear_awdl_unrestricted(sotoinpcb(so));
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_LABEL</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
			<span class="enscript-keyword">if</span> ((error = sooptcopyin(sopt, &amp;extmac, <span class="enscript-keyword">sizeof</span> (extmac),
			    <span class="enscript-keyword">sizeof</span> (extmac))) != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

			error = mac_setsockopt_label(proc_ucred(sopt-&gt;sopt_p),
			    so, &amp;extmac);
#<span class="enscript-reference">else</span>
			error = EOPNOTSUPP;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_SOCKET */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_UPCALLCLOSEWAIT</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">if</span> (optval != 0)
				so-&gt;so_flags |= SOF_UPCALLCLOSEWAIT;
			<span class="enscript-keyword">else</span>
				so-&gt;so_flags &amp;= ~SOF_UPCALLCLOSEWAIT;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RANDOMPORT</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">if</span> (optval != 0)
				so-&gt;so_flags |= SOF_BINDRANDOMPORT;
			<span class="enscript-keyword">else</span>
				so-&gt;so_flags &amp;= ~SOF_BINDRANDOMPORT;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NP_EXTENSIONS</span>: {
			<span class="enscript-type">struct</span> so_np_extensions sonpx;

			error = sooptcopyin(sopt, &amp;sonpx, <span class="enscript-keyword">sizeof</span> (sonpx),
			    <span class="enscript-keyword">sizeof</span> (sonpx));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">if</span> (sonpx.npx_mask &amp; ~SONPX_MASK_VALID) {
				error = EINVAL;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-comment">/*
			 * Only one bit defined for now
			 */</span>
			<span class="enscript-keyword">if</span> ((sonpx.npx_mask &amp; SONPX_SETOPTSHUT)) {
				<span class="enscript-keyword">if</span> ((sonpx.npx_flags &amp; SONPX_SETOPTSHUT))
					so-&gt;so_flags |= SOF_NPX_SETOPTSHUT;
				<span class="enscript-keyword">else</span>
					so-&gt;so_flags &amp;= ~SOF_NPX_SETOPTSHUT;
			}
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TRAFFIC_CLASS</span>: {
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			error = so_set_traffic_class(so, optval);
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RECV_TRAFFIC_CLASS</span>: {
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">if</span> (optval == 0)
				so-&gt;so_flags &amp;= ~SOF_RECV_TRAFFIC_CLASS;
			<span class="enscript-keyword">else</span>
				so-&gt;so_flags |= SOF_RECV_TRAFFIC_CLASS;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TRAFFIC_CLASS_DBG</span>: {
			<span class="enscript-type">struct</span> so_tcdbg so_tcdbg;

			error = sooptcopyin(sopt, &amp;so_tcdbg,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> so_tcdbg), <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> so_tcdbg));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			error = so_set_tcdbg(so, &amp;so_tcdbg);
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_PRIVILEGED_TRAFFIC_CLASS</span>:
			error = priv_check_cred(kauth_cred_get(),
			    PRIV_NET_PRIVILEGED_TRAFFIC_CLASS, 0);
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">if</span> (optval == 0)
				so-&gt;so_flags &amp;= ~SOF_PRIVILEGED_TRAFFIC_CLASS;
			<span class="enscript-keyword">else</span>
				so-&gt;so_flags |= SOF_PRIVILEGED_TRAFFIC_CLASS;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_DEFUNCTOK</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error != 0 || (so-&gt;so_flags &amp; SOF_DEFUNCT)) {
				<span class="enscript-keyword">if</span> (error == 0)
					error = EBADF;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-comment">/*
			 * Any process can set SO_DEFUNCTOK (clear
			 * SOF_NODEFUNCT), but only root can clear
			 * SO_DEFUNCTOK (set SOF_NODEFUNCT).
			 */</span>
			<span class="enscript-keyword">if</span> (optval == 0 &amp;&amp;
			    kauth_cred_issuser(kauth_cred_get()) == 0) {
				error = EPERM;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			<span class="enscript-keyword">if</span> (optval)
				so-&gt;so_flags &amp;= ~SOF_NODEFUNCT;
			<span class="enscript-keyword">else</span>
				so-&gt;so_flags |= SOF_NODEFUNCT;

			<span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET ||
			    SOCK_DOM(so) == PF_INET6) {
				<span class="enscript-type">char</span> s[MAX_IPv6_STR_LEN];
				<span class="enscript-type">char</span> d[MAX_IPv6_STR_LEN];
				<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);

				SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: so 0x%llx [%s %s:%d -&gt; &quot;</span>
				    <span class="enscript-string">&quot;%s:%d] is now marked as %seligible for &quot;</span>
				    <span class="enscript-string">&quot;defunct\n&quot;</span>, __func__, proc_selfpid(),
				    (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
				    (SOCK_TYPE(so) == SOCK_STREAM) ?
				    <span class="enscript-string">&quot;TCP&quot;</span> : <span class="enscript-string">&quot;UDP&quot;</span>, inet_ntop(SOCK_DOM(so),
				    ((SOCK_DOM(so) == PF_INET) ?
				    (<span class="enscript-type">void</span> *)&amp;inp-&gt;inp_laddr.s_addr :
				    (<span class="enscript-type">void</span> *)&amp;inp-&gt;in6p_laddr), s, <span class="enscript-keyword">sizeof</span> (s)),
				    ntohs(inp-&gt;in6p_lport),
				    inet_ntop(SOCK_DOM(so),
				    (SOCK_DOM(so) == PF_INET) ?
				    (<span class="enscript-type">void</span> *)&amp;inp-&gt;inp_faddr.s_addr :
				    (<span class="enscript-type">void</span> *)&amp;inp-&gt;in6p_faddr, d, <span class="enscript-keyword">sizeof</span> (d)),
				    ntohs(inp-&gt;in6p_fport),
				    (so-&gt;so_flags &amp; SOF_NODEFUNCT) ?
				    <span class="enscript-string">&quot;not &quot;</span> : <span class="enscript-string">&quot;&quot;</span>));
			} <span class="enscript-keyword">else</span> {
				SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: so 0x%llx [%d,%d] is &quot;</span>
				    <span class="enscript-string">&quot;now marked as %seligible for defunct\n&quot;</span>,
				    __func__, proc_selfpid(),
				    (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
				    SOCK_DOM(so), SOCK_TYPE(so),
				    (so-&gt;so_flags &amp; SOF_NODEFUNCT) ?
				    <span class="enscript-string">&quot;not &quot;</span> : <span class="enscript-string">&quot;&quot;</span>));
			}
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_ISDEFUNCT</span>:
			<span class="enscript-comment">/* This option is not settable */</span>
			error = EINVAL;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_OPPORTUNISTIC</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error == 0)
				error = so_set_opportunistic(so, optval);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_FLUSH</span>:
			<span class="enscript-comment">/* This option is handled by lower layer(s) */</span>
			error = 0;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RECV_ANYIF</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error == 0)
				error = so_set_recv_anyif(so, optval);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TRAFFIC_MGT_BACKGROUND</span>: {
			<span class="enscript-comment">/* This option is handled by lower layer(s) */</span>
			error = 0;
			<span class="enscript-keyword">break</span>;
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FLOW_DIVERT</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_FLOW_DIVERT_TOKEN</span>:
			error = flow_divert_token_set(so, sopt);
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* FLOW_DIVERT */</span>


		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_DELEGATED</span>:
			<span class="enscript-keyword">if</span> ((error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval))) != 0)
				<span class="enscript-keyword">break</span>;

			error = so_set_effective_pid(so, optval, sopt-&gt;sopt_p);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_DELEGATED_UUID</span>: {
			uuid_t euuid;

			<span class="enscript-keyword">if</span> ((error = sooptcopyin(sopt, &amp;euuid, <span class="enscript-keyword">sizeof</span> (euuid),
			    <span class="enscript-keyword">sizeof</span> (euuid))) != 0)
				<span class="enscript-keyword">break</span>;

			error = so_set_effective_uuid(so, euuid, sopt-&gt;sopt_p);
			<span class="enscript-keyword">break</span>;
		}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NECP_ATTRIBUTES</span>:
			error = necp_set_socket_attributes(so, sopt);
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_MPTCP_FASTJOIN</span>:
			<span class="enscript-keyword">if</span> (!((so-&gt;so_flags &amp; SOF_MP_SUBFLOW) ||
			    ((SOCK_CHECK_DOM(so, PF_MULTIPATH)) &amp;&amp;
			    (SOCK_CHECK_PROTO(so, IPPROTO_TCP))))) {
				error = ENOPROTOOPT;
				<span class="enscript-keyword">break</span>;
			}

			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error != 0)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			<span class="enscript-keyword">if</span> (optval == 0)
				so-&gt;so_flags &amp;= ~SOF_MPTCP_FASTJOIN;
			<span class="enscript-keyword">else</span>
				so-&gt;so_flags |= SOF_MPTCP_FASTJOIN;
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_EXTENDED_BK_IDLE</span>:
			error = sooptcopyin(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval),
			    <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">if</span> (error == 0)
				error = so_set_extended_bk_idle(so, optval);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			error = ENOPROTOOPT;
			<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; so-&gt;so_proto != NULL &amp;&amp;
		    so-&gt;so_proto-&gt;pr_ctloutput != NULL) {
			(<span class="enscript-type">void</span>) so-&gt;so_proto-&gt;pr_ctloutput(so, sopt);
		}
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (dolock)
		socket_unlock(so, 1);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* Helper routines for getsockopt */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">sooptcopyout</span>(<span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">void</span> *buf, size_t len)
{
	<span class="enscript-type">int</span>	error;
	size_t	valsize;

	error = 0;

	<span class="enscript-comment">/*
	 * Documented get behavior is that we always return a value,
	 * possibly truncated to fit in the user's buffer.
	 * Traditional behavior is that we always tell the user
	 * precisely how much we copied, rather than something useful
	 * like the total amount we had available for her.
	 * Note that this interface is not idempotent; the entire answer must
	 * generated ahead of time.
	 */</span>
	valsize = min(len, sopt-&gt;sopt_valsize);
	sopt-&gt;sopt_valsize = valsize;
	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_val != USER_ADDR_NULL) {
		<span class="enscript-keyword">if</span> (sopt-&gt;sopt_p != kernproc)
			error = copyout(buf, sopt-&gt;sopt_val, valsize);
		<span class="enscript-keyword">else</span>
			bcopy(buf, CAST_DOWN(caddr_t, sopt-&gt;sopt_val), valsize);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sooptcopyout_timeval</span>(<span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">const</span> <span class="enscript-type">struct</span> timeval *tv_p)
{
	<span class="enscript-type">int</span>			error;
	size_t			len;
	<span class="enscript-type">struct</span> user64_timeval	tv64;
	<span class="enscript-type">struct</span> user32_timeval	tv32;
	<span class="enscript-type">const</span> <span class="enscript-type">void</span> *		val;
	size_t			valsize;

	error = 0;
	<span class="enscript-keyword">if</span> (proc_is64bit(sopt-&gt;sopt_p)) {
		len = <span class="enscript-keyword">sizeof</span> (tv64);
		tv64.tv_sec = tv_p-&gt;tv_sec;
		tv64.tv_usec = tv_p-&gt;tv_usec;
		val = &amp;tv64;
	} <span class="enscript-keyword">else</span> {
		len = <span class="enscript-keyword">sizeof</span> (tv32);
		tv32.tv_sec = tv_p-&gt;tv_sec;
		tv32.tv_usec = tv_p-&gt;tv_usec;
		val = &amp;tv32;
	}
	valsize = min(len, sopt-&gt;sopt_valsize);
	sopt-&gt;sopt_valsize = valsize;
	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_val != USER_ADDR_NULL) {
		<span class="enscript-keyword">if</span> (sopt-&gt;sopt_p != kernproc)
			error = copyout(val, sopt-&gt;sopt_val, valsize);
		<span class="enscript-keyword">else</span>
			bcopy(val, CAST_DOWN(caddr_t, sopt-&gt;sopt_val), valsize);
	}
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * Return:	0			Success
 *		ENOPROTOOPT
 *	&lt;pr_ctloutput&gt;:EOPNOTSUPP[AF_UNIX]
 *	&lt;pr_ctloutput&gt;:???
 *	&lt;sf_getoption&gt;:???
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">sogetoptlock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">int</span> dolock)
{
	<span class="enscript-type">int</span>	error, optval;
	<span class="enscript-type">struct</span>	linger l;
	<span class="enscript-type">struct</span>	timeval tv;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
	<span class="enscript-type">struct</span> mac extmac;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_SOCKET */</span>

	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_dir != SOPT_GET)
		sopt-&gt;sopt_dir = SOPT_GET;

	<span class="enscript-keyword">if</span> (dolock)
		socket_lock(so, 1);

	error = sflt_getsockopt(so, sopt);
	<span class="enscript-keyword">if</span> (error != 0) {
		<span class="enscript-keyword">if</span> (error == EJUSTRETURN)
			error = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}

	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_level != SOL_SOCKET) {
		<span class="enscript-keyword">if</span> (so-&gt;so_proto != NULL &amp;&amp;
		    so-&gt;so_proto-&gt;pr_ctloutput != NULL) {
			error = (*so-&gt;so_proto-&gt;pr_ctloutput)(so, sopt);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
		error = ENOPROTOOPT;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Allow socket-level (SOL_SOCKET) options to be filtered by
		 * the protocol layer, if needed.  A zero value returned from
		 * the handler means use default socket-level processing as
		 * done by the rest of this routine.  Otherwise, any other
		 * return value indicates that the option is unsupported.
		 */</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_proto != NULL &amp;&amp; (error = so-&gt;so_proto-&gt;pr_usrreqs-&gt;
		    pru_socheckopt(so, sopt)) != 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

		error = 0;
		<span class="enscript-keyword">switch</span> (sopt-&gt;sopt_name) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_LINGER</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_LINGER_SEC</span>:
			l.l_onoff = ((so-&gt;so_options &amp; SO_LINGER) ? 1 : 0);
			l.l_linger = (sopt-&gt;sopt_name == SO_LINGER) ?
			    so-&gt;so_linger : so-&gt;so_linger / hz;
			error = sooptcopyout(sopt, &amp;l, <span class="enscript-keyword">sizeof</span> (l));
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_USELOOPBACK</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_DONTROUTE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_DEBUG</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_KEEPALIVE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_REUSEADDR</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_REUSEPORT</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_BROADCAST</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_OOBINLINE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TIMESTAMP</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TIMESTAMP_MONOTONIC</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_DONTTRUNC</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_WANTMORE</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_WANTOOBFLAG</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NOWAKEFROMSLEEP</span>:
			optval = so-&gt;so_options &amp; sopt-&gt;sopt_name;
<span class="enscript-reference">integer</span>:
			error = sooptcopyout(sopt, &amp;optval, <span class="enscript-keyword">sizeof</span> (optval));
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TYPE</span>:
			optval = so-&gt;so_type;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NREAD</span>:
			<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_flags &amp; PR_ATOMIC) {
				<span class="enscript-type">int</span> pkt_total;
				<span class="enscript-type">struct</span> mbuf *m1;

				pkt_total = 0;
				m1 = so-&gt;so_rcv.sb_mb;
				<span class="enscript-keyword">while</span> (m1 != NULL) {
					<span class="enscript-keyword">if</span> (m1-&gt;m_type == MT_DATA ||
					    m1-&gt;m_type == MT_HEADER ||
					    m1-&gt;m_type == MT_OOBDATA)
						pkt_total += m1-&gt;m_len;
					m1 = m1-&gt;m_next;
				}
				optval = pkt_total;
			} <span class="enscript-keyword">else</span> {
				optval = so-&gt;so_rcv.sb_cc - so-&gt;so_rcv.sb_ctl;
			}
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NUMRCVPKT</span>:
			<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_flags &amp; PR_ATOMIC) {
				<span class="enscript-type">int</span> cnt = 0;
				<span class="enscript-type">struct</span> mbuf *m1;

				m1 = so-&gt;so_rcv.sb_mb;
				<span class="enscript-keyword">while</span> (m1 != NULL) {
					<span class="enscript-keyword">if</span> (m1-&gt;m_type == MT_DATA ||
					    m1-&gt;m_type == MT_HEADER ||
					    m1-&gt;m_type == MT_OOBDATA)
						cnt += 1;
					m1 = m1-&gt;m_nextpkt;
				}
				optval = cnt;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;
			} <span class="enscript-keyword">else</span> {
				error = EINVAL;
				<span class="enscript-keyword">break</span>;
			}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NWRITE</span>:
			optval = so-&gt;so_snd.sb_cc;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_ERROR</span>:
			optval = so-&gt;so_error;
			so-&gt;so_error = 0;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_SNDBUF</span>: {
			u_int32_t hiwat = so-&gt;so_snd.sb_hiwat;

			<span class="enscript-keyword">if</span> (so-&gt;so_snd.sb_flags &amp; SB_UNIX) {
				<span class="enscript-type">struct</span> unpcb *unp =
				    (<span class="enscript-type">struct</span> unpcb *)(so-&gt;so_pcb);
				<span class="enscript-keyword">if</span> (unp != NULL &amp;&amp; unp-&gt;unp_conn != NULL) {
					hiwat += unp-&gt;unp_conn-&gt;unp_cc;
				}
			}

			optval = hiwat;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;
		}
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RCVBUF</span>:
			optval = so-&gt;so_rcv.sb_hiwat;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_SNDLOWAT</span>:
			optval = so-&gt;so_snd.sb_lowat;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RCVLOWAT</span>:
			optval = so-&gt;so_rcv.sb_lowat;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_SNDTIMEO</span>:
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RCVTIMEO</span>:
			tv = (sopt-&gt;sopt_name == SO_SNDTIMEO ?
			    so-&gt;so_snd.sb_timeo : so-&gt;so_rcv.sb_timeo);

			error = sooptcopyout_timeval(sopt, &amp;tv);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NOSIGPIPE</span>:
			optval = (so-&gt;so_flags &amp; SOF_NOSIGPIPE);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NOADDRERR</span>:
			optval = (so-&gt;so_flags &amp; SOF_NOADDRAVAIL);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_REUSESHAREUID</span>:
			optval = (so-&gt;so_flags &amp; SOF_REUSESHAREUID);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;


		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NOTIFYCONFLICT</span>:
			optval = (so-&gt;so_flags &amp; SOF_NOTIFYCONFLICT);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RESTRICTIONS</span>:
			optval = so_get_restrictions(so);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_AWDL_UNRESTRICTED</span>:
			<span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET ||
			    SOCK_DOM(so) == PF_INET6) {
				optval = inp_get_awdl_unrestricted(
				    sotoinpcb(so));
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;
			} <span class="enscript-keyword">else</span>
				error = EOPNOTSUPP;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_LABEL</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
			<span class="enscript-keyword">if</span> ((error = sooptcopyin(sopt, &amp;extmac, <span class="enscript-keyword">sizeof</span> (extmac),
			    <span class="enscript-keyword">sizeof</span> (extmac))) != 0 ||
			    (error = mac_socket_label_get(proc_ucred(
			    sopt-&gt;sopt_p), so, &amp;extmac)) != 0)
				<span class="enscript-keyword">break</span>;

			error = sooptcopyout(sopt, &amp;extmac, <span class="enscript-keyword">sizeof</span> (extmac));
#<span class="enscript-reference">else</span>
			error = EOPNOTSUPP;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_SOCKET */</span>
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_PEERLABEL</span>:
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
			<span class="enscript-keyword">if</span> ((error = sooptcopyin(sopt, &amp;extmac, <span class="enscript-keyword">sizeof</span> (extmac),
			    <span class="enscript-keyword">sizeof</span> (extmac))) != 0 ||
			    (error = mac_socketpeer_label_get(proc_ucred(
			    sopt-&gt;sopt_p), so, &amp;extmac)) != 0)
				<span class="enscript-keyword">break</span>;

			error = sooptcopyout(sopt, &amp;extmac, <span class="enscript-keyword">sizeof</span> (extmac));
#<span class="enscript-reference">else</span>
			error = EOPNOTSUPP;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_SOCKET */</span>
			<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__APPLE_API_PRIVATE</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_UPCALLCLOSEWAIT</span>:
			optval = (so-&gt;so_flags &amp; SOF_UPCALLCLOSEWAIT);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RANDOMPORT</span>:
			optval = (so-&gt;so_flags &amp; SOF_BINDRANDOMPORT);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NP_EXTENSIONS</span>: {
			<span class="enscript-type">struct</span> so_np_extensions sonpx;

			sonpx.npx_flags = (so-&gt;so_flags &amp; SOF_NPX_SETOPTSHUT) ?
			    SONPX_SETOPTSHUT : 0;
			sonpx.npx_mask = SONPX_MASK_VALID;

			error = sooptcopyout(sopt, &amp;sonpx,
			    <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> so_np_extensions));
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TRAFFIC_CLASS</span>:
			optval = so-&gt;so_traffic_class;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RECV_TRAFFIC_CLASS</span>:
			optval = (so-&gt;so_flags &amp; SOF_RECV_TRAFFIC_CLASS);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TRAFFIC_CLASS_STATS</span>:
			error = sooptcopyout(sopt, &amp;so-&gt;so_tc_stats,
			    <span class="enscript-keyword">sizeof</span> (so-&gt;so_tc_stats));
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TRAFFIC_CLASS_DBG</span>:
			error = sogetopt_tcdbg(so, sopt);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_PRIVILEGED_TRAFFIC_CLASS</span>:
			optval = (so-&gt;so_flags &amp; SOF_PRIVILEGED_TRAFFIC_CLASS);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_DEFUNCTOK</span>:
			optval = !(so-&gt;so_flags &amp; SOF_NODEFUNCT);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_ISDEFUNCT</span>:
			optval = (so-&gt;so_flags &amp; SOF_DEFUNCT);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_OPPORTUNISTIC</span>:
			optval = so_get_opportunistic(so);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_FLUSH</span>:
			<span class="enscript-comment">/* This option is not gettable */</span>
			error = EINVAL;
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_RECV_ANYIF</span>:
			optval = so_get_recv_anyif(so);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_TRAFFIC_MGT_BACKGROUND</span>:
			<span class="enscript-comment">/* This option is handled by lower layer(s) */</span>
			<span class="enscript-keyword">if</span> (so-&gt;so_proto != NULL &amp;&amp;
			    so-&gt;so_proto-&gt;pr_ctloutput != NULL) {
				(<span class="enscript-type">void</span>) so-&gt;so_proto-&gt;pr_ctloutput(so, sopt);
			}
			<span class="enscript-keyword">break</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">FLOW_DIVERT</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_FLOW_DIVERT_TOKEN</span>:
			error = flow_divert_token_get(so, sopt);
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* FLOW_DIVERT */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_NECP_ATTRIBUTES</span>:
			error = necp_get_socket_attributes(so, sopt);
			<span class="enscript-keyword">break</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_CFIL_SOCK_ID</span>: {
			cfil_sock_id_t sock_id;

			sock_id = cfil_sock_id_from_socket(so);

			error = sooptcopyout(sopt, &amp;sock_id,
				<span class="enscript-keyword">sizeof</span>(cfil_sock_id_t));
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span>	<span class="enscript-comment">/* CONTENT_FILTER */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_MPTCP_FASTJOIN</span>:
			<span class="enscript-keyword">if</span> (!((so-&gt;so_flags &amp; SOF_MP_SUBFLOW) ||
			    ((SOCK_CHECK_DOM(so, PF_MULTIPATH)) &amp;&amp;
			    (SOCK_CHECK_PROTO(so, IPPROTO_TCP))))) {
				error = ENOPROTOOPT;
				<span class="enscript-keyword">break</span>;
			}
			optval = (so-&gt;so_flags &amp; SOF_MPTCP_FASTJOIN);
			<span class="enscript-comment">/* Fixed along with rdar://19391339 */</span>
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MPTCP */</span>

		<span class="enscript-keyword">case</span> <span class="enscript-reference">SO_EXTENDED_BK_IDLE</span>:
			optval = (so-&gt;so_flags1 &amp; SOF1_EXTEND_BK_IDLE_WANTED);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">integer</span>;

		<span class="enscript-reference">default</span>:
			error = ENOPROTOOPT;
			<span class="enscript-keyword">break</span>;
		}
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (dolock)
		socket_unlock(so, 1);
	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/*
 * The size limits on our soopt_getm is different from that on FreeBSD.
 * We limit the size of options to MCLBYTES. This will have to change
 * if we need to define options that need more space than MCLBYTES.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">soopt_getm</span>(<span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">struct</span> mbuf **mp)
{
	<span class="enscript-type">struct</span> mbuf *m, *m_prev;
	<span class="enscript-type">int</span> sopt_size = sopt-&gt;sopt_valsize;
	<span class="enscript-type">int</span> how;

	<span class="enscript-keyword">if</span> (sopt_size &lt;= 0 || sopt_size &gt; MCLBYTES)
		<span class="enscript-keyword">return</span> (EMSGSIZE);

	how = sopt-&gt;sopt_p != kernproc ? M_WAIT : M_DONTWAIT;
	MGET(m, how, MT_DATA);
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span> (ENOBUFS);
	<span class="enscript-keyword">if</span> (sopt_size &gt; MLEN) {
		MCLGET(m, how);
		<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_EXT) == 0) {
			m_free(m);
			<span class="enscript-keyword">return</span> (ENOBUFS);
		}
		m-&gt;m_len = min(MCLBYTES, sopt_size);
	} <span class="enscript-keyword">else</span> {
		m-&gt;m_len = min(MLEN, sopt_size);
	}
	sopt_size -= m-&gt;m_len;
	*mp = m;
	m_prev = m;

	<span class="enscript-keyword">while</span> (sopt_size &gt; 0) {
		MGET(m, how, MT_DATA);
		<span class="enscript-keyword">if</span> (m == NULL) {
			m_freem(*mp);
			<span class="enscript-keyword">return</span> (ENOBUFS);
		}
		<span class="enscript-keyword">if</span> (sopt_size &gt; MLEN) {
			MCLGET(m, how);
			<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_EXT) == 0) {
				m_freem(*mp);
				m_freem(m);
				<span class="enscript-keyword">return</span> (ENOBUFS);
			}
			m-&gt;m_len = min(MCLBYTES, sopt_size);
		} <span class="enscript-keyword">else</span> {
			m-&gt;m_len = min(MLEN, sopt_size);
		}
		sopt_size -= m-&gt;m_len;
		m_prev-&gt;m_next = m;
		m_prev = m;
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/* copyin sopt data into mbuf chain */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">soopt_mcopyin</span>(<span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> mbuf *m0 = m;

	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_val == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">while</span> (m != NULL &amp;&amp; sopt-&gt;sopt_valsize &gt;= m-&gt;m_len) {
		<span class="enscript-keyword">if</span> (sopt-&gt;sopt_p != kernproc) {
			<span class="enscript-type">int</span> error;

			error = copyin(sopt-&gt;sopt_val, mtod(m, <span class="enscript-type">char</span> *),
			    m-&gt;m_len);
			<span class="enscript-keyword">if</span> (error != 0) {
				m_freem(m0);
				<span class="enscript-keyword">return</span> (error);
			}
		} <span class="enscript-keyword">else</span> {
			bcopy(CAST_DOWN(caddr_t, sopt-&gt;sopt_val),
			    mtod(m, <span class="enscript-type">char</span> *), m-&gt;m_len);
		}
		sopt-&gt;sopt_valsize -= m-&gt;m_len;
		sopt-&gt;sopt_val += m-&gt;m_len;
		m = m-&gt;m_next;
	}
	<span class="enscript-comment">/* should be allocated enoughly at ip6_sooptmcopyin() */</span>
	<span class="enscript-keyword">if</span> (m != NULL) {
		panic(<span class="enscript-string">&quot;soopt_mcopyin&quot;</span>);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/* copyout mbuf chain data into soopt */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">soopt_mcopyout</span>(<span class="enscript-type">struct</span> sockopt *sopt, <span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> mbuf *m0 = m;
	size_t valsize = 0;

	<span class="enscript-keyword">if</span> (sopt-&gt;sopt_val == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">while</span> (m != NULL &amp;&amp; sopt-&gt;sopt_valsize &gt;= m-&gt;m_len) {
		<span class="enscript-keyword">if</span> (sopt-&gt;sopt_p != kernproc) {
			<span class="enscript-type">int</span> error;

			error = copyout(mtod(m, <span class="enscript-type">char</span> *), sopt-&gt;sopt_val,
			    m-&gt;m_len);
			<span class="enscript-keyword">if</span> (error != 0) {
				m_freem(m0);
				<span class="enscript-keyword">return</span> (error);
			}
		} <span class="enscript-keyword">else</span> {
			bcopy(mtod(m, <span class="enscript-type">char</span> *),
			    CAST_DOWN(caddr_t, sopt-&gt;sopt_val), m-&gt;m_len);
		}
		sopt-&gt;sopt_valsize -= m-&gt;m_len;
		sopt-&gt;sopt_val += m-&gt;m_len;
		valsize += m-&gt;m_len;
		m = m-&gt;m_next;
	}
	<span class="enscript-keyword">if</span> (m != NULL) {
		<span class="enscript-comment">/* enough soopt buffer should be given from user-land */</span>
		m_freem(m0);
		<span class="enscript-keyword">return</span> (EINVAL);
	}
	sopt-&gt;sopt_valsize = valsize;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">sohasoutofband</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-keyword">if</span> (so-&gt;so_pgid &lt; 0)
		gsignal(-so-&gt;so_pgid, SIGURG);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (so-&gt;so_pgid &gt; 0)
		proc_signal(so-&gt;so_pgid, SIGURG);
	selwakeup(&amp;so-&gt;so_rcv.sb_sel);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sopoll</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> events, kauth_cred_t cred, <span class="enscript-type">void</span> * wql)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">cred</span>)
	<span class="enscript-type">struct</span> proc *p = current_proc();
	<span class="enscript-type">int</span> revents = 0;

	socket_lock(so, 1);
	so_update_last_owner_locked(so, PROC_NULL);
	so_update_policy(so);

	<span class="enscript-keyword">if</span> (events &amp; (POLLIN | POLLRDNORM))
		<span class="enscript-keyword">if</span> (soreadable(so))
			revents |= events &amp; (POLLIN | POLLRDNORM);

	<span class="enscript-keyword">if</span> (events &amp; (POLLOUT | POLLWRNORM))
		<span class="enscript-keyword">if</span> (sowriteable(so))
			revents |= events &amp; (POLLOUT | POLLWRNORM);

	<span class="enscript-keyword">if</span> (events &amp; (POLLPRI | POLLRDBAND))
		<span class="enscript-keyword">if</span> (so-&gt;so_oobmark || (so-&gt;so_state &amp; SS_RCVATMARK))
			revents |= events &amp; (POLLPRI | POLLRDBAND);

	<span class="enscript-keyword">if</span> (revents == 0) {
		<span class="enscript-keyword">if</span> (events &amp; (POLLIN | POLLPRI | POLLRDNORM | POLLRDBAND)) {
			<span class="enscript-comment">/*
			 * Darwin sets the flag first,
			 * BSD calls selrecord first
			 */</span>
			so-&gt;so_rcv.sb_flags |= SB_SEL;
			selrecord(p, &amp;so-&gt;so_rcv.sb_sel, wql);
		}

		<span class="enscript-keyword">if</span> (events &amp; (POLLOUT | POLLWRNORM)) {
			<span class="enscript-comment">/*
			 * Darwin sets the flag first,
			 * BSD calls selrecord first
			 */</span>
			so-&gt;so_snd.sb_flags |= SB_SEL;
			selrecord(p, &amp;so-&gt;so_snd.sb_sel, wql);
		}
	}

	socket_unlock(so, 1);
	<span class="enscript-keyword">return</span> (revents);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">soo_kqfilter</span>(<span class="enscript-type">struct</span> fileproc *fp, <span class="enscript-type">struct</span> knote *kn, vfs_context_t ctx)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">fp</span>)
#<span class="enscript-reference">if</span> !<span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">ctx</span>)
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_SOCKET */</span>
	<span class="enscript-type">struct</span> socket *so = (<span class="enscript-type">struct</span> socket *)kn-&gt;kn_fp-&gt;f_fglob-&gt;fg_data;
	<span class="enscript-type">struct</span> klist *skl;

	socket_lock(so, 1);
	so_update_last_owner_locked(so, PROC_NULL);
	so_update_policy(so);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_SOCKET</span>
	<span class="enscript-keyword">if</span> (mac_socket_check_kqfilter(proc_ucred(vfs_context_proc(ctx)),
	    kn, so) != 0) {
		socket_unlock(so, 1);
		<span class="enscript-keyword">return</span> (1);
	}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_SOCKET */</span>

	<span class="enscript-keyword">switch</span> (kn-&gt;kn_filter) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_READ</span>:
		kn-&gt;kn_fop = &amp;soread_filtops;
		<span class="enscript-comment">/*
		 * If the caller explicitly asked for OOB results (e.g. poll()),
		 * save that off in the hookid field and reserve the kn_flags
		 * EV_OOBAND bit for output only.
		 */</span>
		<span class="enscript-keyword">if</span> (kn-&gt;kn_flags &amp; EV_OOBAND) {
			kn-&gt;kn_flags &amp;= ~EV_OOBAND;
			kn-&gt;kn_hookid = EV_OOBAND;
		} <span class="enscript-keyword">else</span> {
			kn-&gt;kn_hookid = 0;
		}
		skl = &amp;so-&gt;so_rcv.sb_sel.si_note;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_WRITE</span>:
		kn-&gt;kn_fop = &amp;sowrite_filtops;
		skl = &amp;so-&gt;so_snd.sb_sel.si_note;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_SOCK</span>:
		kn-&gt;kn_fop = &amp;sock_filtops;
		skl = &amp;so-&gt;so_klist;
		kn-&gt;kn_hookid = 0;
		kn-&gt;kn_status |= KN_TOUCH;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		socket_unlock(so, 1);
		<span class="enscript-keyword">return</span> (1);
	}

	<span class="enscript-keyword">if</span> (KNOTE_ATTACH(skl, kn)) {
		<span class="enscript-keyword">switch</span> (kn-&gt;kn_filter) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_READ</span>:
			so-&gt;so_rcv.sb_flags |= SB_KNOTE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_WRITE</span>:
			so-&gt;so_snd.sb_flags |= SB_KNOTE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_SOCK</span>:
			so-&gt;so_flags |= SOF_KNOTE;
			<span class="enscript-keyword">break</span>;
		<span class="enscript-reference">default</span>:
			socket_unlock(so, 1);
			<span class="enscript-keyword">return</span> (1);
		}
	}
	socket_unlock(so, 1);
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_sordetach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-type">struct</span> socket *so = (<span class="enscript-type">struct</span> socket *)kn-&gt;kn_fp-&gt;f_fglob-&gt;fg_data;

	socket_lock(so, 1);
	<span class="enscript-keyword">if</span> (so-&gt;so_rcv.sb_flags &amp; SB_KNOTE)
		<span class="enscript-keyword">if</span> (KNOTE_DETACH(&amp;so-&gt;so_rcv.sb_sel.si_note, kn))
			so-&gt;so_rcv.sb_flags &amp;= ~SB_KNOTE;
	socket_unlock(so, 1);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_soread</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint)
{
	<span class="enscript-type">struct</span> socket *so = (<span class="enscript-type">struct</span> socket *)kn-&gt;kn_fp-&gt;f_fglob-&gt;fg_data;

	<span class="enscript-keyword">if</span> ((hint &amp; SO_FILT_HINT_LOCKED) == 0)
		socket_lock(so, 1);

	<span class="enscript-keyword">if</span> (so-&gt;so_options &amp; SO_ACCEPTCONN) {
		<span class="enscript-type">int</span> isempty;

		<span class="enscript-comment">/*
		 * Radar 6615193 handle the listen case dynamically
		 * for kqueue read filter. This allows to call listen()
		 * after registering the kqueue EVFILT_READ.
		 */</span>

		kn-&gt;kn_data = so-&gt;so_qlen;
		isempty = ! TAILQ_EMPTY(&amp;so-&gt;so_comp);

		<span class="enscript-keyword">if</span> ((hint &amp; SO_FILT_HINT_LOCKED) == 0)
			socket_unlock(so, 1);

		<span class="enscript-keyword">return</span> (isempty);
	}

	<span class="enscript-comment">/* socket isn't a listener */</span>
	<span class="enscript-comment">/*
	 * NOTE_LOWAT specifies new low water mark in data, i.e.
	 * the bytes of protocol data. We therefore exclude any
	 * control bytes.
	 */</span>
	kn-&gt;kn_data = so-&gt;so_rcv.sb_cc - so-&gt;so_rcv.sb_ctl;

	<span class="enscript-comment">/*
	 * Clear out EV_OOBAND that filt_soread may have set in the
	 * past.
	 */</span>
	kn-&gt;kn_flags &amp;= ~EV_OOBAND;
	<span class="enscript-keyword">if</span> ((so-&gt;so_oobmark) || (so-&gt;so_state &amp; SS_RCVATMARK)) {
		kn-&gt;kn_flags |= EV_OOBAND;
		<span class="enscript-comment">/*
		 * If caller registered explicit interest in OOB data,
		 * return immediately (data == amount beyond mark, for
		 * legacy reasons - that should be changed later).
		 */</span>
		<span class="enscript-keyword">if</span> (kn-&gt;kn_hookid == EV_OOBAND) {
			<span class="enscript-comment">/*
			 * When so_state is SS_RCVATMARK, so_oobmark
			 * is 0.
			 */</span>
			kn-&gt;kn_data -= so-&gt;so_oobmark;
			<span class="enscript-keyword">if</span> ((hint &amp; SO_FILT_HINT_LOCKED) == 0)
				socket_unlock(so, 1);
			<span class="enscript-keyword">return</span> (1);
		}
	}

	<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_CANTRCVMORE)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
	    &amp;&amp; cfil_sock_data_pending(&amp;so-&gt;so_rcv) == 0
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>
	   ) {
		kn-&gt;kn_flags |= EV_EOF;
		kn-&gt;kn_fflags = so-&gt;so_error;
		<span class="enscript-keyword">if</span> ((hint &amp; SO_FILT_HINT_LOCKED) == 0)
			socket_unlock(so, 1);
		<span class="enscript-keyword">return</span> (1);
	}

	<span class="enscript-keyword">if</span> (so-&gt;so_error) {	<span class="enscript-comment">/* temporary udp error */</span>
		<span class="enscript-keyword">if</span> ((hint &amp; SO_FILT_HINT_LOCKED) == 0)
			socket_unlock(so, 1);
		<span class="enscript-keyword">return</span> (1);
	}

	int64_t	lowwat = so-&gt;so_rcv.sb_lowat;
	<span class="enscript-comment">/*
	 * Ensure that when NOTE_LOWAT is used, the derived
	 * low water mark is bounded by socket's rcv buf's
	 * high and low water mark values.
	 */</span>
	<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_LOWAT) {
		<span class="enscript-keyword">if</span> (kn-&gt;kn_sdata &gt; so-&gt;so_rcv.sb_hiwat)
			lowwat = so-&gt;so_rcv.sb_hiwat;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kn-&gt;kn_sdata &gt; lowwat)
			lowwat = kn-&gt;kn_sdata;
	}

	<span class="enscript-keyword">if</span> ((hint &amp; SO_FILT_HINT_LOCKED) == 0)
		socket_unlock(so, 1);

	<span class="enscript-comment">/*
	 * The order below is important. Since NOTE_LOWAT
	 * overrides sb_lowat, check for NOTE_LOWAT case
	 * first.
	 */</span>
	<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_LOWAT)
		<span class="enscript-keyword">return</span> (kn-&gt;kn_data &gt;= lowwat);

	<span class="enscript-keyword">return</span> (so-&gt;so_rcv.sb_cc &gt;= lowwat);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_sowdetach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-type">struct</span> socket *so = (<span class="enscript-type">struct</span> socket *)kn-&gt;kn_fp-&gt;f_fglob-&gt;fg_data;
	socket_lock(so, 1);

	<span class="enscript-keyword">if</span> (so-&gt;so_snd.sb_flags &amp; SB_KNOTE)
		<span class="enscript-keyword">if</span> (KNOTE_DETACH(&amp;so-&gt;so_snd.sb_sel.si_note, kn))
			so-&gt;so_snd.sb_flags &amp;= ~SB_KNOTE;
	socket_unlock(so, 1);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">so_wait_for_if_feedback</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-keyword">if</span> ((SOCK_DOM(so) == PF_INET || SOCK_DOM(so) == PF_INET6) &amp;&amp;
	    (so-&gt;so_state &amp; SS_ISCONNECTED)) {
		<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);
		<span class="enscript-keyword">if</span> (INP_WAIT_FOR_IF_FEEDBACK(inp))
			<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*ARGSUSED*/</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_sowrite</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint)
{
	<span class="enscript-type">struct</span> socket *so = (<span class="enscript-type">struct</span> socket *)kn-&gt;kn_fp-&gt;f_fglob-&gt;fg_data;
	<span class="enscript-type">int</span> ret = 0;

	<span class="enscript-keyword">if</span> ((hint &amp; SO_FILT_HINT_LOCKED) == 0)
		socket_lock(so, 1);

	kn-&gt;kn_data = sbspace(&amp;so-&gt;so_snd);
	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_CANTSENDMORE) {
		kn-&gt;kn_flags |= EV_EOF;
		kn-&gt;kn_fflags = so-&gt;so_error;
		ret = 1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (so-&gt;so_error) {	<span class="enscript-comment">/* temporary udp error */</span>
		ret = 1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (!socanwrite(so)) {
		ret = 0;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	<span class="enscript-keyword">if</span> (so-&gt;so_flags1 &amp; SOF1_PRECONNECT_DATA) {
		ret = 1;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
	}
	int64_t	lowwat = so-&gt;so_snd.sb_lowat;
	<span class="enscript-keyword">if</span> (kn-&gt;kn_sfflags &amp; NOTE_LOWAT) {
		<span class="enscript-keyword">if</span> (kn-&gt;kn_sdata &gt; so-&gt;so_snd.sb_hiwat)
			lowwat = so-&gt;so_snd.sb_hiwat;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (kn-&gt;kn_sdata &gt; lowwat)
			lowwat = kn-&gt;kn_sdata;
	}
	<span class="enscript-keyword">if</span> (kn-&gt;kn_data &gt;= lowwat) {
		<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_NOTSENT_LOWAT) {
			<span class="enscript-keyword">if</span> ((SOCK_DOM(so) == PF_INET
			    || SOCK_DOM(so) == PF_INET6)
			    &amp;&amp; so-&gt;so_type == SOCK_STREAM) {
				ret = tcp_notsent_lowat_check(so);
			}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MPTCP</span>
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((SOCK_DOM(so) == PF_MULTIPATH) &amp;&amp;
			    (SOCK_PROTO(so) == IPPROTO_TCP)) {
				ret = mptcp_notsent_lowat_check(so);
			}
#<span class="enscript-reference">endif</span>
			<span class="enscript-keyword">else</span> {
				ret = 1;
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
		} <span class="enscript-keyword">else</span> {
			ret = 1;
		}
	}
	<span class="enscript-keyword">if</span> (so_wait_for_if_feedback(so))
		ret = 0;
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> ((hint &amp; SO_FILT_HINT_LOCKED) == 0)
		socket_unlock(so, 1);
	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_sockdetach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-type">struct</span> socket *so = (<span class="enscript-type">struct</span> socket *)kn-&gt;kn_fp-&gt;f_fglob-&gt;fg_data;
	socket_lock(so, 1);

	<span class="enscript-keyword">if</span> ((so-&gt;so_flags &amp; SOF_KNOTE) != 0)
		<span class="enscript-keyword">if</span> (KNOTE_DETACH(&amp;so-&gt;so_klist, kn))
			so-&gt;so_flags &amp;= ~SOF_KNOTE;
	socket_unlock(so, 1);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">filt_sockev</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint)
{
	<span class="enscript-type">int</span> ret = 0, locked = 0;
	<span class="enscript-type">struct</span> socket *so = (<span class="enscript-type">struct</span> socket *)kn-&gt;kn_fp-&gt;f_fglob-&gt;fg_data;
	<span class="enscript-type">long</span> ev_hint = (hint &amp; SO_FILT_HINT_EV);
	uint32_t level_trigger = 0;

	<span class="enscript-keyword">if</span> ((hint &amp; SO_FILT_HINT_LOCKED) == 0) {
		socket_lock(so, 1);
		locked = 1;
	}

	<span class="enscript-keyword">if</span> (ev_hint &amp; SO_FILT_HINT_CONNRESET) {
		kn-&gt;kn_fflags |= NOTE_CONNRESET;
	}
	<span class="enscript-keyword">if</span> (ev_hint &amp; SO_FILT_HINT_TIMEOUT) {
		kn-&gt;kn_fflags |= NOTE_TIMEOUT;
	}
	<span class="enscript-keyword">if</span> (ev_hint &amp; SO_FILT_HINT_NOSRCADDR) {
		kn-&gt;kn_fflags |= NOTE_NOSRCADDR;
	}
	<span class="enscript-keyword">if</span> (ev_hint &amp; SO_FILT_HINT_IFDENIED) {
		kn-&gt;kn_fflags |= NOTE_IFDENIED;
	}
	<span class="enscript-keyword">if</span> (ev_hint &amp; SO_FILT_HINT_KEEPALIVE) {
		kn-&gt;kn_fflags |= NOTE_KEEPALIVE;
	}
	<span class="enscript-keyword">if</span> (ev_hint &amp; SO_FILT_HINT_ADAPTIVE_WTIMO) {
		kn-&gt;kn_fflags |= NOTE_ADAPTIVE_WTIMO;
	}
	<span class="enscript-keyword">if</span> (ev_hint &amp; SO_FILT_HINT_ADAPTIVE_RTIMO) {
		kn-&gt;kn_fflags |= NOTE_ADAPTIVE_RTIMO;
	}
	<span class="enscript-keyword">if</span> ((ev_hint &amp; SO_FILT_HINT_CONNECTED) ||
	    (so-&gt;so_state &amp; SS_ISCONNECTED)) {
		kn-&gt;kn_fflags |= NOTE_CONNECTED;
		level_trigger |= NOTE_CONNECTED;
	}
	<span class="enscript-keyword">if</span> ((ev_hint &amp; SO_FILT_HINT_DISCONNECTED) ||
	    (so-&gt;so_state &amp; SS_ISDISCONNECTED)) {
		kn-&gt;kn_fflags |= NOTE_DISCONNECTED;
		level_trigger |= NOTE_DISCONNECTED;
	}
	<span class="enscript-keyword">if</span> (ev_hint &amp; SO_FILT_HINT_CONNINFO_UPDATED) {
		<span class="enscript-keyword">if</span> (so-&gt;so_proto != NULL &amp;&amp;
		    (so-&gt;so_proto-&gt;pr_flags &amp; PR_EVCONNINFO))
			kn-&gt;kn_fflags |= NOTE_CONNINFO_UPDATED;
	}

	<span class="enscript-keyword">if</span> ((so-&gt;so_state &amp; SS_CANTRCVMORE)
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONTENT_FILTER</span>
	    &amp;&amp; cfil_sock_data_pending(&amp;so-&gt;so_rcv) == 0
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONTENT_FILTER */</span>
	    ) {
		kn-&gt;kn_fflags |= NOTE_READCLOSED;
		level_trigger |= NOTE_READCLOSED;
	}

	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_CANTSENDMORE) {
		kn-&gt;kn_fflags |= NOTE_WRITECLOSED;
		level_trigger |= NOTE_WRITECLOSED;
	}

	<span class="enscript-keyword">if</span> ((ev_hint &amp; SO_FILT_HINT_SUSPEND) ||
	    (so-&gt;so_flags &amp; SOF_SUSPENDED)) {
		kn-&gt;kn_fflags &amp;= ~(NOTE_SUSPEND | NOTE_RESUME);

		<span class="enscript-comment">/* If resume event was delivered before, reset it */</span>
		kn-&gt;kn_hookid &amp;= ~NOTE_RESUME;

		kn-&gt;kn_fflags |= NOTE_SUSPEND;
		level_trigger |= NOTE_SUSPEND;
	}

	<span class="enscript-keyword">if</span> ((ev_hint &amp; SO_FILT_HINT_RESUME) ||
	    (so-&gt;so_flags &amp; SOF_SUSPENDED) == 0) {
		kn-&gt;kn_fflags &amp;= ~(NOTE_SUSPEND | NOTE_RESUME);

		<span class="enscript-comment">/* If suspend event was delivered before, reset it */</span>
		kn-&gt;kn_hookid &amp;= ~NOTE_SUSPEND;

		kn-&gt;kn_fflags |= NOTE_RESUME;
		level_trigger |= NOTE_RESUME;
	}

	<span class="enscript-keyword">if</span> (so-&gt;so_error != 0) {
		ret = 1;
		kn-&gt;kn_data = so-&gt;so_error;
		kn-&gt;kn_flags |= EV_EOF;
	} <span class="enscript-keyword">else</span> {
		get_sockev_state(so, (u_int32_t *)&amp;(kn-&gt;kn_data));
	}

	<span class="enscript-comment">/* Reset any events that are not requested on this knote */</span>
	kn-&gt;kn_fflags &amp;= (kn-&gt;kn_sfflags &amp; EVFILT_SOCK_ALL_MASK);
	level_trigger &amp;= (kn-&gt;kn_sfflags &amp; EVFILT_SOCK_ALL_MASK);

	<span class="enscript-comment">/* Find the level triggerred events that are already delivered */</span>
	level_trigger &amp;= kn-&gt;kn_hookid;
	level_trigger &amp;= EVFILT_SOCK_LEVEL_TRIGGER_MASK;

	<span class="enscript-comment">/* Do not deliver level triggerred events more than once */</span>
	<span class="enscript-keyword">if</span> ((kn-&gt;kn_fflags &amp; ~level_trigger) != 0)
		ret = 1;

	<span class="enscript-keyword">if</span> (locked)
		socket_unlock(so, 1);

	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">filt_socktouch</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">struct</span> kevent_internal_s *kev, <span class="enscript-type">long</span> type)
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">kev</span>)
	<span class="enscript-keyword">switch</span> (type) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EVENT_REGISTER</span>:
	{
		uint32_t changed_flags;
		changed_flags = (kn-&gt;kn_sfflags ^ kn-&gt;kn_hookid);

		<span class="enscript-comment">/*
		 * Since we keep track of events that are already
		 * delivered, if any of those events are not requested
		 * anymore the state related to them can be reset
		 */</span>
		kn-&gt;kn_hookid &amp;=
		    ~(changed_flags &amp; EVFILT_SOCK_LEVEL_TRIGGER_MASK);
		<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">case</span> <span class="enscript-reference">EVENT_PROCESS</span>:
		<span class="enscript-comment">/*
		 * Store the state of the events being delivered. This
		 * state can be used to deliver level triggered events
		 * ateast once and still avoid waking up the application
		 * multiple times as long as the event is active.
		 */</span>
		<span class="enscript-keyword">if</span> (kn-&gt;kn_fflags != 0)
			kn-&gt;kn_hookid |= (kn-&gt;kn_fflags &amp;
				EVFILT_SOCK_LEVEL_TRIGGER_MASK);

		<span class="enscript-comment">/*
		 * NOTE_RESUME and NOTE_SUSPEND are an exception, deliver
		 * only one of them and remember the last one that was
		 * delivered last
		 */</span>
		<span class="enscript-keyword">if</span> (kn-&gt;kn_fflags &amp; NOTE_SUSPEND)
			kn-&gt;kn_hookid &amp;= ~NOTE_RESUME;
		<span class="enscript-keyword">if</span> (kn-&gt;kn_fflags &amp; NOTE_RESUME)
			kn-&gt;kn_hookid &amp;= ~NOTE_SUSPEND;
		<span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
		<span class="enscript-keyword">break</span>;
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">get_sockev_state</span>(<span class="enscript-type">struct</span> socket *so, u_int32_t *statep)
{
	u_int32_t state = *(statep);

	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_ISCONNECTED)
		state |= SOCKEV_CONNECTED;
	<span class="enscript-keyword">else</span>
		state &amp;= ~(SOCKEV_CONNECTED);
	state |= ((so-&gt;so_state &amp; SS_ISDISCONNECTED) ? SOCKEV_DISCONNECTED : 0);
	*(statep) = state;
}

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SO_LOCK_HISTORY_STR_LEN</span> \
	(2 * SO_LCKDBG_MAX * (2 + (2 * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">void</span> *)) + 1) + 1)

__private_extern__ <span class="enscript-type">const</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">solockhistory_nr</span>(<span class="enscript-type">struct</span> socket *so)
{
	size_t n = 0;
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">static</span> <span class="enscript-type">char</span> lock_history_str[SO_LOCK_HISTORY_STR_LEN];

	bzero(lock_history_str, <span class="enscript-keyword">sizeof</span> (lock_history_str));
	<span class="enscript-keyword">for</span> (i = SO_LCKDBG_MAX - 1; i &gt;= 0; i--) {
		n += snprintf(lock_history_str + n,
		    SO_LOCK_HISTORY_STR_LEN - n, <span class="enscript-string">&quot;%p:%p &quot;</span>,
		    so-&gt;lock_lr[(so-&gt;next_lock_lr + i) % SO_LCKDBG_MAX],
		    so-&gt;unlock_lr[(so-&gt;next_unlock_lr + i) % SO_LCKDBG_MAX]);
	}
	<span class="enscript-keyword">return</span> (lock_history_str);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">socket_lock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> refcount)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">void</span> *lr_saved;

	lr_saved = __builtin_return_address(0);

	<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_lock) {
		error = (*so-&gt;so_proto-&gt;pr_lock)(so, refcount, lr_saved);
	} <span class="enscript-keyword">else</span> {
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MORE_LOCKING_DEBUG</span>
		lck_mtx_assert(so-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx,
		    LCK_MTX_ASSERT_NOTOWNED);
#<span class="enscript-reference">endif</span>
		lck_mtx_lock(so-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx);
		<span class="enscript-keyword">if</span> (refcount)
			so-&gt;so_usecount++;
		so-&gt;lock_lr[so-&gt;next_lock_lr] = lr_saved;
		so-&gt;next_lock_lr = (so-&gt;next_lock_lr+1) % SO_LCKDBG_MAX;
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">socket_unlock</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> refcount)
{
	<span class="enscript-type">int</span> error = 0;
	<span class="enscript-type">void</span> *lr_saved;
	lck_mtx_t *mutex_held;

	lr_saved = __builtin_return_address(0);

	<span class="enscript-keyword">if</span> (so-&gt;so_proto == NULL) {
		panic(<span class="enscript-string">&quot;%s: null so_proto so=%p\n&quot;</span>, __func__, so);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (so &amp;&amp; so-&gt;so_proto-&gt;pr_unlock) {
		error = (*so-&gt;so_proto-&gt;pr_unlock)(so, refcount, lr_saved);
	} <span class="enscript-keyword">else</span> {
		mutex_held = so-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">MORE_LOCKING_DEBUG</span>
		lck_mtx_assert(mutex_held, LCK_MTX_ASSERT_OWNED);
#<span class="enscript-reference">endif</span>
		so-&gt;unlock_lr[so-&gt;next_unlock_lr] = lr_saved;
		so-&gt;next_unlock_lr = (so-&gt;next_unlock_lr+1) % SO_LCKDBG_MAX;

		<span class="enscript-keyword">if</span> (refcount) {
			<span class="enscript-keyword">if</span> (so-&gt;so_usecount &lt;= 0) {
				panic(<span class="enscript-string">&quot;%s: bad refcount=%d so=%p (%d, %d, %d) &quot;</span>
				    <span class="enscript-string">&quot;lrh=%s&quot;</span>, __func__, so-&gt;so_usecount, so,
				    SOCK_DOM(so), so-&gt;so_type,
				    SOCK_PROTO(so), solockhistory_nr(so));
				<span class="enscript-comment">/* NOTREACHED */</span>
			}

			so-&gt;so_usecount--;
			<span class="enscript-keyword">if</span> (so-&gt;so_usecount == 0)
				sofreelastref(so, 1);
		}
		lck_mtx_unlock(mutex_held);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-comment">/* Called with socket locked, will unlock socket */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">sofree</span>(<span class="enscript-type">struct</span> socket *so)
{
	lck_mtx_t *mutex_held;

	<span class="enscript-keyword">if</span> (so-&gt;so_proto-&gt;pr_getlock != NULL)
		mutex_held = (*so-&gt;so_proto-&gt;pr_getlock)(so, 0);
	<span class="enscript-keyword">else</span>
		mutex_held = so-&gt;so_proto-&gt;pr_domain-&gt;dom_mtx;
	lck_mtx_assert(mutex_held, LCK_MTX_ASSERT_OWNED);

	sofreelastref(so, 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">soreference</span>(<span class="enscript-type">struct</span> socket *so)
{
	socket_lock(so, 1);	<span class="enscript-comment">/* locks &amp; take one reference on socket */</span>
	socket_unlock(so, 0);	<span class="enscript-comment">/* unlock only */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">sodereference</span>(<span class="enscript-type">struct</span> socket *so)
{
	socket_lock(so, 0);
	socket_unlock(so, 1);
}

<span class="enscript-comment">/*
 * Set or clear SOF_MULTIPAGES on the socket to enable or disable the
 * possibility of using jumbo clusters.  Caller must ensure to hold
 * the socket lock.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">somultipages</span>(<span class="enscript-type">struct</span> socket *so, boolean_t set)
{
	<span class="enscript-keyword">if</span> (set)
		so-&gt;so_flags |= SOF_MULTIPAGES;
	<span class="enscript-keyword">else</span>
		so-&gt;so_flags &amp;= ~SOF_MULTIPAGES;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">soif2kcl</span>(<span class="enscript-type">struct</span> socket *so, boolean_t set)
{
	<span class="enscript-keyword">if</span> (set)
		so-&gt;so_flags1 |= SOF1_IF_2KCL;
	<span class="enscript-keyword">else</span>
		so-&gt;so_flags1 &amp;= ~SOF1_IF_2KCL;
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">so_isdstlocal</span>(<span class="enscript-type">struct</span> socket *so) {

	<span class="enscript-type">struct</span> inpcb *inp = (<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb;

	<span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET)
		<span class="enscript-keyword">return</span> (inaddr_local(inp-&gt;inp_faddr));
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET6)
		<span class="enscript-keyword">return</span> (in6addr_local(&amp;inp-&gt;in6p_faddr));

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sosetdefunct</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> level, boolean_t noforce)
{
	<span class="enscript-type">struct</span> sockbuf *rcv, *snd;
	<span class="enscript-type">int</span> err = 0, defunct;

	rcv = &amp;so-&gt;so_rcv;
	snd = &amp;so-&gt;so_snd;

	defunct = (so-&gt;so_flags &amp; SOF_DEFUNCT);
	<span class="enscript-keyword">if</span> (defunct) {
		<span class="enscript-keyword">if</span> (!(snd-&gt;sb_flags &amp; rcv-&gt;sb_flags &amp; SB_DROP)) {
			panic(<span class="enscript-string">&quot;%s: SB_DROP not set&quot;</span>, __func__);
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_NODEFUNCT) {
		<span class="enscript-keyword">if</span> (noforce) {
			err = EOPNOTSUPP;
			SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: (target pid %d level %d) &quot;</span>
			    <span class="enscript-string">&quot;so 0x%llx [%d,%d] is not eligible for defunct &quot;</span>
			    <span class="enscript-string">&quot;(%d)\n&quot;</span>, __func__, proc_selfpid(), proc_pid(p),
			    level, (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
			    SOCK_DOM(so), SOCK_TYPE(so), err));
			<span class="enscript-keyword">return</span> (err);
		}
		so-&gt;so_flags &amp;= ~SOF_NODEFUNCT;
		SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: (target pid %d level %d) so 0x%llx &quot;</span>
		    <span class="enscript-string">&quot;[%d,%d] defunct by force\n&quot;</span>, __func__, proc_selfpid(),
		    proc_pid(p), level, (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
		    SOCK_DOM(so), SOCK_TYPE(so)));
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (so-&gt;so_flags1 &amp; SOF1_EXTEND_BK_IDLE_WANTED) {
		<span class="enscript-type">struct</span> inpcb *inp = (<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb;
		<span class="enscript-type">struct</span> ifnet *ifp = inp-&gt;inp_last_outifp;

		<span class="enscript-keyword">if</span> (ifp &amp;&amp; IFNET_IS_CELLULAR(ifp)) {
			OSIncrementAtomic(&amp;soextbkidlestat.so_xbkidle_nocell);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DELEGATED) {
			OSIncrementAtomic(&amp;soextbkidlestat.so_xbkidle_nodlgtd);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (soextbkidlestat.so_xbkidle_time == 0) {
			OSIncrementAtomic(&amp;soextbkidlestat.so_xbkidle_notime);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (noforce) {
			OSIncrementAtomic(&amp;soextbkidlestat.so_xbkidle_active);
		
			so-&gt;so_flags1 |= SOF1_EXTEND_BK_IDLE_INPROG;
			so-&gt;so_extended_bk_start = net_uptime();
			OSBitOrAtomic(P_LXBKIDLEINPROG, &amp;p-&gt;p_ladvflag);
			
			inpcb_timer_sched(inp-&gt;inp_pcbinfo, INPCB_TIMER_LAZY);
			
			err = EOPNOTSUPP;
			SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: (target pid %d level %d) &quot;</span>
			    <span class="enscript-string">&quot;extend bk idle &quot;</span>
			    <span class="enscript-string">&quot;so 0x%llx rcv hw %d cc %d\n&quot;</span>,
			    __func__, proc_selfpid(), proc_pid(p),
			    level, (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
			    so-&gt;so_rcv.sb_hiwat, so-&gt;so_rcv.sb_cc));
			<span class="enscript-keyword">return</span> (err);
		} <span class="enscript-keyword">else</span> {
			OSIncrementAtomic(&amp;soextbkidlestat.so_xbkidle_forced);
		}
	}

	so-&gt;so_flags |= SOF_DEFUNCT;

	<span class="enscript-comment">/* Prevent further data from being appended to the socket buffers */</span>
	snd-&gt;sb_flags |= SB_DROP;
	rcv-&gt;sb_flags |= SB_DROP;

	<span class="enscript-comment">/* Flush any existing data in the socket buffers */</span>
	<span class="enscript-keyword">if</span> (rcv-&gt;sb_cc != 0) {
		rcv-&gt;sb_flags &amp;= ~SB_SEL;
		selthreadclear(&amp;rcv-&gt;sb_sel);
		sbrelease(rcv);
	}
	<span class="enscript-keyword">if</span> (snd-&gt;sb_cc != 0) {
		snd-&gt;sb_flags &amp;= ~SB_SEL;
		selthreadclear(&amp;snd-&gt;sb_sel);
		sbrelease(snd);
	}

<span class="enscript-reference">done</span>:
	SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: (target pid %d level %d) so 0x%llx [%d,%d] %s &quot;</span>
	    <span class="enscript-string">&quot;defunct%s\n&quot;</span>, __func__, proc_selfpid(), proc_pid(p), level,
	    (uint64_t)DEBUG_KERNEL_ADDRPERM(so), SOCK_DOM(so), SOCK_TYPE(so),
	    defunct ? <span class="enscript-string">&quot;is already&quot;</span> : <span class="enscript-string">&quot;marked as&quot;</span>,
	    (so-&gt;so_flags1 &amp; SOF1_EXTEND_BK_IDLE_WANTED) ? <span class="enscript-string">&quot; extbkidle&quot;</span> : <span class="enscript-string">&quot;&quot;</span>));

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">sodefunct</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> level)
{
	<span class="enscript-type">struct</span> sockbuf *rcv, *snd;

	<span class="enscript-keyword">if</span> (!(so-&gt;so_flags &amp; SOF_DEFUNCT)) {
		panic(<span class="enscript-string">&quot;%s improperly called&quot;</span>, __func__);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
	<span class="enscript-keyword">if</span> (so-&gt;so_state &amp; SS_DEFUNCT)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;

	rcv = &amp;so-&gt;so_rcv;
	snd = &amp;so-&gt;so_snd;

	<span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET || SOCK_DOM(so) == PF_INET6) {
		<span class="enscript-type">char</span> s[MAX_IPv6_STR_LEN];
		<span class="enscript-type">char</span> d[MAX_IPv6_STR_LEN];
		<span class="enscript-type">struct</span> inpcb *inp = sotoinpcb(so);

		SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: (target pid %d level %d) so 0x%llx [%s &quot;</span>
		    <span class="enscript-string">&quot;%s:%d -&gt; %s:%d] is now defunct [rcv_si 0x%x, snd_si 0x%x, &quot;</span>
		    <span class="enscript-string">&quot;rcv_fl 0x%x, snd_fl 0x%x]\n&quot;</span>, __func__, proc_selfpid(),
		    proc_pid(p), level, (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
		    (SOCK_TYPE(so) == SOCK_STREAM) ? <span class="enscript-string">&quot;TCP&quot;</span> : <span class="enscript-string">&quot;UDP&quot;</span>,
		    inet_ntop(SOCK_DOM(so), ((SOCK_DOM(so) == PF_INET) ?
		    (<span class="enscript-type">void</span> *)&amp;inp-&gt;inp_laddr.s_addr : (<span class="enscript-type">void</span> *)&amp;inp-&gt;in6p_laddr),
		    s, <span class="enscript-keyword">sizeof</span> (s)), ntohs(inp-&gt;in6p_lport),
		    inet_ntop(SOCK_DOM(so), (SOCK_DOM(so) == PF_INET) ?
		    (<span class="enscript-type">void</span> *)&amp;inp-&gt;inp_faddr.s_addr : (<span class="enscript-type">void</span> *)&amp;inp-&gt;in6p_faddr,
		    d, <span class="enscript-keyword">sizeof</span> (d)), ntohs(inp-&gt;in6p_fport),
		    (uint32_t)rcv-&gt;sb_sel.si_flags,
		    (uint32_t)snd-&gt;sb_sel.si_flags,
		    rcv-&gt;sb_flags, snd-&gt;sb_flags));
	} <span class="enscript-keyword">else</span> {
		SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: (target pid %d level %d) so 0x%llx &quot;</span>
		    <span class="enscript-string">&quot;[%d,%d] is now defunct [rcv_si 0x%x, snd_si 0x%x, &quot;</span>
		    <span class="enscript-string">&quot;rcv_fl 0x%x, snd_fl 0x%x]\n&quot;</span>, __func__, proc_selfpid(),
		    proc_pid(p), level, (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
		    SOCK_DOM(so), SOCK_TYPE(so), (uint32_t)rcv-&gt;sb_sel.si_flags,
		    (uint32_t)snd-&gt;sb_sel.si_flags, rcv-&gt;sb_flags,
		    snd-&gt;sb_flags));
	}

	<span class="enscript-comment">/*
	 * Unwedge threads blocked on sbwait() and sb_lock().
	 */</span>
	sbwakeup(rcv);
	sbwakeup(snd);

	so-&gt;so_flags1 |= SOF1_DEFUNCTINPROG;
	<span class="enscript-keyword">if</span> (rcv-&gt;sb_flags &amp; SB_LOCK)
		sbunlock(rcv, TRUE);	<span class="enscript-comment">/* keep socket locked */</span>
	<span class="enscript-keyword">if</span> (snd-&gt;sb_flags &amp; SB_LOCK)
		sbunlock(snd, TRUE);	<span class="enscript-comment">/* keep socket locked */</span>

	<span class="enscript-comment">/*
	 * Flush the buffers and disconnect.  We explicitly call shutdown
	 * on both data directions to ensure that SS_CANT{RCV,SEND}MORE
	 * states are set for the socket.  This would also flush out data
	 * hanging off the receive list of this socket.
	 */</span>
	(<span class="enscript-type">void</span>) soshutdownlock_final(so, SHUT_RD);
	(<span class="enscript-type">void</span>) soshutdownlock_final(so, SHUT_WR);
	(<span class="enscript-type">void</span>) sodisconnectlocked(so);

	<span class="enscript-comment">/*
	 * Explicitly handle connectionless-protocol disconnection
	 * and release any remaining data in the socket buffers.
	 */</span>
	<span class="enscript-keyword">if</span> (!(so-&gt;so_flags &amp; SS_ISDISCONNECTED))
		(<span class="enscript-type">void</span>) soisdisconnected(so);

	<span class="enscript-keyword">if</span> (so-&gt;so_error == 0)
		so-&gt;so_error = EBADF;

	<span class="enscript-keyword">if</span> (rcv-&gt;sb_cc != 0) {
		rcv-&gt;sb_flags &amp;= ~SB_SEL;
		selthreadclear(&amp;rcv-&gt;sb_sel);
		sbrelease(rcv);
	}
	<span class="enscript-keyword">if</span> (snd-&gt;sb_cc != 0) {
		snd-&gt;sb_flags &amp;= ~SB_SEL;
		selthreadclear(&amp;snd-&gt;sb_sel);
		sbrelease(snd);
	}
	so-&gt;so_state |= SS_DEFUNCT;

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">soresume</span>(<span class="enscript-type">struct</span> proc *p, <span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> locked)
{
	<span class="enscript-keyword">if</span> (locked == 0)
		socket_lock(so, 1);

	<span class="enscript-keyword">if</span> (so-&gt;so_flags1 &amp; SOF1_EXTEND_BK_IDLE_INPROG) {
		SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: )target pid %d) so 0x%llx [%d,%d] &quot;</span>
		    <span class="enscript-string">&quot;resumed from bk idle\n&quot;</span>,
		    __func__, proc_selfpid(), proc_pid(p),
		    (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
		    SOCK_DOM(so), SOCK_TYPE(so)));

		so-&gt;so_flags1 &amp;= ~SOF1_EXTEND_BK_IDLE_INPROG;
		so-&gt;so_extended_bk_start = 0;
		OSBitAndAtomic(~P_LXBKIDLEINPROG, &amp;p-&gt;p_ladvflag);

		OSIncrementAtomic(&amp;soextbkidlestat.so_xbkidle_resumed);
		OSDecrementAtomic(&amp;soextbkidlestat.so_xbkidle_active);
		VERIFY(soextbkidlestat.so_xbkidle_active &gt;= 0);
	}
	<span class="enscript-keyword">if</span> (locked == 0)
		socket_unlock(so, 1);

	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Does not attempt to account for sockets that are delegated from
 * the current process
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">so_set_extended_bk_idle</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> optval)
{
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-keyword">if</span> ((SOCK_DOM(so) != PF_INET &amp;&amp; SOCK_DOM(so) != PF_INET6) ||
	    SOCK_PROTO(so) != IPPROTO_TCP) {
		OSDecrementAtomic(&amp;soextbkidlestat.so_xbkidle_notsupp);
		error = EOPNOTSUPP;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (optval == 0) {
		so-&gt;so_flags1 &amp;= ~SOF1_EXTEND_BK_IDLE_WANTED;

		soresume(current_proc(), so, 1);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-type">struct</span> proc *p = current_proc();
		<span class="enscript-type">int</span> i;
		<span class="enscript-type">struct</span> filedesc *fdp;
		<span class="enscript-type">int</span> count = 0;

		proc_fdlock(p);

		fdp = p-&gt;p_fd;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; fdp-&gt;fd_nfiles; i++) {
			<span class="enscript-type">struct</span> fileproc *fp = fdp-&gt;fd_ofiles[i];
			<span class="enscript-type">struct</span> socket *so2;

			<span class="enscript-keyword">if</span> (fp == NULL ||
			    (fdp-&gt;fd_ofileflags[i] &amp; UF_RESERVED) != 0 ||
			    FILEGLOB_DTYPE(fp-&gt;f_fglob) != DTYPE_SOCKET)
				<span class="enscript-keyword">continue</span>;

			so2 = (<span class="enscript-type">struct</span> socket *)fp-&gt;f_fglob-&gt;fg_data;
			<span class="enscript-keyword">if</span> (so != so2 &amp;&amp;
			    so2-&gt;so_flags1 &amp; SOF1_EXTEND_BK_IDLE_WANTED)
				count++;
			<span class="enscript-keyword">if</span> (count &gt;= soextbkidlestat.so_xbkidle_maxperproc)
				<span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (count &gt;= soextbkidlestat.so_xbkidle_maxperproc) {
			OSIncrementAtomic(&amp;soextbkidlestat.so_xbkidle_toomany);
			error = EBUSY;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DELEGATED) {
			OSIncrementAtomic(&amp;soextbkidlestat.so_xbkidle_nodlgtd);
			error = EBUSY;
		} <span class="enscript-keyword">else</span> {
			so-&gt;so_flags1 |= SOF1_EXTEND_BK_IDLE_WANTED;
			OSIncrementAtomic(&amp;soextbkidlestat.so_xbkidle_wantok);
		}
		SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: so 0x%llx [%d,%d] &quot;</span>
		    <span class="enscript-string">&quot;%s marked for extended bk idle\n&quot;</span>,
		    __func__, proc_selfpid(),
		    (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
		    SOCK_DOM(so), SOCK_TYPE(so),
		    (so-&gt;so_flags1 &amp; SOF1_EXTEND_BK_IDLE_WANTED) ?
		    <span class="enscript-string">&quot;is&quot;</span> : <span class="enscript-string">&quot;not&quot;</span>));

		proc_fdunlock(p);
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">so_stop_extended_bk_idle</span>(<span class="enscript-type">struct</span> socket *so)
{
	so-&gt;so_flags1 &amp;= ~SOF1_EXTEND_BK_IDLE_INPROG;
	so-&gt;so_extended_bk_start = 0;

	OSDecrementAtomic(&amp;soextbkidlestat.so_xbkidle_active);
	VERIFY(soextbkidlestat.so_xbkidle_active &gt;= 0);
	<span class="enscript-comment">/*
	 * Force defunct
	 */</span>
	sosetdefunct(current_proc(), so,
	    SHUTDOWN_SOCKET_LEVEL_DISCONNECT_INTERNAL, FALSE);
	<span class="enscript-keyword">if</span> (so-&gt;so_flags &amp; SOF_DEFUNCT) {
		sodefunct(current_proc(), so,
		    SHUTDOWN_SOCKET_LEVEL_DISCONNECT_INTERNAL);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">so_drain_extended_bk_idle</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-keyword">if</span> (so &amp;&amp; (so-&gt;so_flags1 &amp; SOF1_EXTEND_BK_IDLE_INPROG)) {
		<span class="enscript-comment">/*
		 * Only penalize sockets that have outstanding data
		 */</span>
		<span class="enscript-keyword">if</span> (so-&gt;so_rcv.sb_cc || so-&gt;so_snd.sb_cc) {
			so_stop_extended_bk_idle(so);

			OSIncrementAtomic(&amp;soextbkidlestat.so_xbkidle_drained);
		}
	}
}

<span class="enscript-comment">/*
 * Return values tells if socket is still in extended background idle
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">so_check_extended_bk_idle_time</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">int</span> ret = 1;

	<span class="enscript-keyword">if</span> ((so-&gt;so_flags1 &amp; SOF1_EXTEND_BK_IDLE_INPROG)) {
		SODEFUNCTLOG((<span class="enscript-string">&quot;%s[%d]: so 0x%llx [%d,%d]\n&quot;</span>,
		    __func__, proc_selfpid(),
		    (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
		    SOCK_DOM(so), SOCK_TYPE(so)));
		<span class="enscript-keyword">if</span> (net_uptime() - so-&gt;so_extended_bk_start &gt;
		    soextbkidlestat.so_xbkidle_time) {
			so_stop_extended_bk_idle(so);

			OSIncrementAtomic(&amp;soextbkidlestat.so_xbkidle_expired);

			ret = 0;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-type">struct</span> inpcb *inp = (<span class="enscript-type">struct</span> inpcb *)so-&gt;so_pcb;

			inpcb_timer_sched(inp-&gt;inp_pcbinfo, INPCB_TIMER_LAZY);
			OSIncrementAtomic(&amp;soextbkidlestat.so_xbkidle_resched);
		}
	}
	
	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">resume_proc_sockets</span>(proc_t p)
{
	<span class="enscript-keyword">if</span> (p-&gt;p_ladvflag &amp; P_LXBKIDLEINPROG) {
		<span class="enscript-type">struct</span> filedesc	*fdp;
		<span class="enscript-type">int</span> i;

		proc_fdlock(p);
		fdp = p-&gt;p_fd;
		<span class="enscript-keyword">for</span> (i = 0; i &lt; fdp-&gt;fd_nfiles; i++) {
			<span class="enscript-type">struct</span> fileproc	*fp;
			<span class="enscript-type">struct</span> socket *so;

			fp = fdp-&gt;fd_ofiles[i];
			<span class="enscript-keyword">if</span> (fp == NULL || 
			    (fdp-&gt;fd_ofileflags[i] &amp; UF_RESERVED) != 0 ||
			    FILEGLOB_DTYPE(fp-&gt;f_fglob) != DTYPE_SOCKET)
				<span class="enscript-keyword">continue</span>;

			so = (<span class="enscript-type">struct</span> socket *)fp-&gt;f_fglob-&gt;fg_data;
			(<span class="enscript-type">void</span>) soresume(p, so, 0);
		}
		proc_fdunlock(p);

		OSBitAndAtomic(~P_LXBKIDLEINPROG, &amp;p-&gt;p_ladvflag);
	}
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">so_set_recv_anyif</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> optval)
{
	<span class="enscript-type">int</span> ret = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET || SOCK_DOM(so) == PF_INET6) {
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET) {
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
		<span class="enscript-keyword">if</span> (optval)
			sotoinpcb(so)-&gt;inp_flags |= INP_RECV_ANYIF;
		<span class="enscript-keyword">else</span>
			sotoinpcb(so)-&gt;inp_flags &amp;= ~INP_RECV_ANYIF;
	}

	<span class="enscript-keyword">return</span> (ret);
}

__private_extern__ <span class="enscript-type">int</span>
<span class="enscript-function-name">so_get_recv_anyif</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">int</span> ret = 0;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET || SOCK_DOM(so) == PF_INET6) {
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET) {
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
		ret = (sotoinpcb(so)-&gt;inp_flags &amp; INP_RECV_ANYIF) ? 1 : 0;
	}

	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">so_set_restrictions</span>(<span class="enscript-type">struct</span> socket *so, uint32_t vals)
{
	<span class="enscript-type">int</span> nocell_old, nocell_new;
	<span class="enscript-type">int</span> noexpensive_old, noexpensive_new;

	<span class="enscript-comment">/*
	 * Deny-type restrictions are trapdoors; once set they cannot be
	 * unset for the lifetime of the socket.  This allows them to be
	 * issued by a framework on behalf of the application without
	 * having to worry that they can be undone.
	 *
	 * Note here that socket-level restrictions overrides any protocol
	 * level restrictions.  For instance, SO_RESTRICT_DENY_CELLULAR
	 * socket restriction issued on the socket has a higher precendence
	 * than INP_NO_IFT_CELLULAR.  The latter is affected by the UUID
	 * policy PROC_UUID_NO_CELLULAR for unrestricted sockets only,
	 * i.e. when SO_RESTRICT_DENY_CELLULAR has not been issued.
	 */</span>
	nocell_old = (so-&gt;so_restrictions &amp; SO_RESTRICT_DENY_CELLULAR);
	noexpensive_old = (so-&gt;so_restrictions &amp; SO_RESTRICT_DENY_EXPENSIVE);
	so-&gt;so_restrictions |= (vals &amp; (SO_RESTRICT_DENY_IN |
	    SO_RESTRICT_DENY_OUT | SO_RESTRICT_DENY_CELLULAR |
	    SO_RESTRICT_DENY_EXPENSIVE));
	nocell_new = (so-&gt;so_restrictions &amp; SO_RESTRICT_DENY_CELLULAR);
	noexpensive_new = (so-&gt;so_restrictions &amp; SO_RESTRICT_DENY_EXPENSIVE);

	<span class="enscript-comment">/* we can only set, not clear restrictions */</span>
	<span class="enscript-keyword">if</span> ((nocell_new - nocell_old) == 0 &amp;&amp;
	    (noexpensive_new - noexpensive_old) == 0)
		<span class="enscript-keyword">return</span> (0);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">INET6</span>
	<span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET || SOCK_DOM(so) == PF_INET6) {
#<span class="enscript-reference">else</span>
	<span class="enscript-keyword">if</span> (SOCK_DOM(so) == PF_INET) {
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !INET6 */</span>
		<span class="enscript-keyword">if</span> (nocell_new - nocell_old != 0) {
			<span class="enscript-comment">/*
			 * if deny cellular is now set, do what's needed
			 * for INPCB
			 */</span>
			inp_set_nocellular(sotoinpcb(so));
		}
		<span class="enscript-keyword">if</span> (noexpensive_new - noexpensive_old != 0) {
			inp_set_noexpensive(sotoinpcb(so));
		}
	}

	<span class="enscript-keyword">return</span> (0);
}

uint32_t
<span class="enscript-function-name">so_get_restrictions</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-keyword">return</span> (so-&gt;so_restrictions &amp; (SO_RESTRICT_DENY_IN |
	    SO_RESTRICT_DENY_OUT |
	    SO_RESTRICT_DENY_CELLULAR | SO_RESTRICT_DENY_EXPENSIVE));
}

<span class="enscript-type">struct</span> sockaddr_entry *
<span class="enscript-function-name">sockaddrentry_alloc</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> sockaddr_entry *se;

	se = (how == M_WAITOK) ? zalloc(se_zone) : zalloc_noblock(se_zone);
	<span class="enscript-keyword">if</span> (se != NULL)
		bzero(se, se_zone_size);

	<span class="enscript-keyword">return</span> (se);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">sockaddrentry_free</span>(<span class="enscript-type">struct</span> sockaddr_entry *se)
{
	<span class="enscript-keyword">if</span> (se-&gt;se_addr != NULL) {
		FREE(se-&gt;se_addr, M_SONAME);
		se-&gt;se_addr = NULL;
	}
	zfree(se_zone, se);
}

<span class="enscript-type">struct</span> sockaddr_entry *
<span class="enscript-function-name">sockaddrentry_dup</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_entry *src_se, <span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> sockaddr_entry *dst_se;

	dst_se = sockaddrentry_alloc(how);
	<span class="enscript-keyword">if</span> (dst_se != NULL) {
		<span class="enscript-type">int</span> len = src_se-&gt;se_addr-&gt;sa_len;

		MALLOC(dst_se-&gt;se_addr, <span class="enscript-type">struct</span> sockaddr *,
		    len, M_SONAME, how | M_ZERO);
		<span class="enscript-keyword">if</span> (dst_se-&gt;se_addr != NULL) {
			bcopy(src_se-&gt;se_addr, dst_se-&gt;se_addr, len);
		} <span class="enscript-keyword">else</span> {
			sockaddrentry_free(dst_se);
			dst_se = NULL;
		}
	}

	<span class="enscript-keyword">return</span> (dst_se);
}

<span class="enscript-type">struct</span> sockaddr_list *
<span class="enscript-function-name">sockaddrlist_alloc</span>(<span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> sockaddr_list *sl;

	sl = (how == M_WAITOK) ? zalloc(sl_zone) : zalloc_noblock(sl_zone);
	<span class="enscript-keyword">if</span> (sl != NULL) {
		bzero(sl, sl_zone_size);
		TAILQ_INIT(&amp;sl-&gt;sl_head);
	}
	<span class="enscript-keyword">return</span> (sl);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">sockaddrlist_free</span>(<span class="enscript-type">struct</span> sockaddr_list *sl)
{
	<span class="enscript-type">struct</span> sockaddr_entry *se, *tse;

	TAILQ_FOREACH_SAFE(se, &amp;sl-&gt;sl_head, se_link, tse) {
		sockaddrlist_remove(sl, se);
		sockaddrentry_free(se);
	}
	VERIFY(sl-&gt;sl_cnt == 0 &amp;&amp; TAILQ_EMPTY(&amp;sl-&gt;sl_head));
	zfree(sl_zone, sl);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">sockaddrlist_insert</span>(<span class="enscript-type">struct</span> sockaddr_list *sl, <span class="enscript-type">struct</span> sockaddr_entry *se)
{
	VERIFY(!(se-&gt;se_flags &amp; SEF_ATTACHED));
	se-&gt;se_flags |= SEF_ATTACHED;
	TAILQ_INSERT_TAIL(&amp;sl-&gt;sl_head, se, se_link);
	sl-&gt;sl_cnt++;
	VERIFY(sl-&gt;sl_cnt != 0);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">sockaddrlist_remove</span>(<span class="enscript-type">struct</span> sockaddr_list *sl, <span class="enscript-type">struct</span> sockaddr_entry *se)
{
	VERIFY(se-&gt;se_flags &amp; SEF_ATTACHED);
	se-&gt;se_flags &amp;= ~SEF_ATTACHED;
	VERIFY(sl-&gt;sl_cnt != 0);
	sl-&gt;sl_cnt--;
	TAILQ_REMOVE(&amp;sl-&gt;sl_head, se, se_link);
}

<span class="enscript-type">struct</span> sockaddr_list *
<span class="enscript-function-name">sockaddrlist_dup</span>(<span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_list *src_sl, <span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> sockaddr_entry *src_se, *tse;
	<span class="enscript-type">struct</span> sockaddr_list *dst_sl;

	dst_sl = sockaddrlist_alloc(how);
	<span class="enscript-keyword">if</span> (dst_sl == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	TAILQ_FOREACH_SAFE(src_se, &amp;src_sl-&gt;sl_head, se_link, tse) {
		<span class="enscript-type">struct</span> sockaddr_entry *dst_se;

		<span class="enscript-keyword">if</span> (src_se-&gt;se_addr == NULL)
			<span class="enscript-keyword">continue</span>;

		dst_se = sockaddrentry_dup(src_se, how);
		<span class="enscript-keyword">if</span> (dst_se == NULL) {
			sockaddrlist_free(dst_sl);
			<span class="enscript-keyword">return</span> (NULL);
		}

		sockaddrlist_insert(dst_sl, dst_se);
	}
	VERIFY(src_sl-&gt;sl_cnt == dst_sl-&gt;sl_cnt);

	<span class="enscript-keyword">return</span> (dst_sl);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">so_set_effective_pid</span>(<span class="enscript-type">struct</span> socket *so, <span class="enscript-type">int</span> epid, <span class="enscript-type">struct</span> proc *p)
{
	<span class="enscript-type">struct</span> proc *ep = PROC_NULL;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/* pid 0 is reserved for kernel */</span>
	<span class="enscript-keyword">if</span> (epid == 0) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * If this is an in-kernel socket, prevent its delegate
	 * association from changing unless the socket option is
	 * coming from within the kernel itself.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;last_pid == 0 &amp;&amp; p != kernproc) {
		error = EACCES;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * If this is issued by a process that's recorded as the
	 * real owner of the socket, or if the pid is the same as
	 * the process's own pid, then proceed.  Otherwise ensure
	 * that the issuing process has the necessary privileges.
	 */</span>
	<span class="enscript-keyword">if</span> (epid != so-&gt;last_pid || epid != proc_pid(p)) {
		<span class="enscript-keyword">if</span> ((error = priv_check_cred(kauth_cred_get(),
		    PRIV_NET_PRIVILEGED_SOCKET_DELEGATE, 0))) {
			error = EACCES;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	<span class="enscript-comment">/* Find the process that corresponds to the effective pid */</span>
	<span class="enscript-keyword">if</span> ((ep = proc_find(epid)) == PROC_NULL) {
		error = ESRCH;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * If a process tries to delegate the socket to itself, then
	 * there's really nothing to do; treat it as a way for the
	 * delegate association to be cleared.  Note that we check
	 * the passed-in proc rather than calling proc_selfpid(),
	 * as we need to check the process issuing the socket option
	 * which could be kernproc.  Given that we don't allow 0 for
	 * effective pid, it means that a delegated in-kernel socket
	 * stays delegated during its lifetime (which is probably OK.)
	 */</span>
	<span class="enscript-keyword">if</span> (epid == proc_pid(p)) {
		so-&gt;so_flags &amp;= ~SOF_DELEGATED;
		so-&gt;e_upid = 0;
		so-&gt;e_pid = 0;
		uuid_clear(so-&gt;e_uuid);
	} <span class="enscript-keyword">else</span> {
		so-&gt;so_flags |= SOF_DELEGATED;
		so-&gt;e_upid = proc_uniqueid(ep);
		so-&gt;e_pid = proc_pid(ep);
		proc_getexecutableuuid(ep, so-&gt;e_uuid, <span class="enscript-keyword">sizeof</span> (so-&gt;e_uuid));
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; net_io_policy_log) {
		uuid_string_t buf;

		uuid_unparse(so-&gt;e_uuid, buf);
		log(LOG_DEBUG, <span class="enscript-string">&quot;%s[%s,%d]: so 0x%llx [%d,%d] epid %d (%s) &quot;</span>
		    <span class="enscript-string">&quot;euuid %s%s\n&quot;</span>, __func__, proc_name_address(p),
		    proc_pid(p), (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
		    SOCK_DOM(so), SOCK_TYPE(so),
		    so-&gt;e_pid, proc_name_address(ep), buf,
		    ((so-&gt;so_flags &amp; SOF_DELEGATED) ? <span class="enscript-string">&quot; [delegated]&quot;</span> : <span class="enscript-string">&quot;&quot;</span>));
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error != 0 &amp;&amp; net_io_policy_log) {
		log(LOG_ERR, <span class="enscript-string">&quot;%s[%s,%d]: so 0x%llx [%d,%d] epid %d (%s) &quot;</span>
		    <span class="enscript-string">&quot;ERROR (%d)\n&quot;</span>, __func__, proc_name_address(p),
		    proc_pid(p), (uint64_t)DEBUG_KERNEL_ADDRPERM(so),
		    SOCK_DOM(so), SOCK_TYPE(so),
		    epid, (ep == PROC_NULL) ? <span class="enscript-string">&quot;PROC_NULL&quot;</span> :
		    proc_name_address(ep), error);
	}

	<span class="enscript-comment">/* Update this socket's policy upon success */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		so-&gt;so_policy_gencnt *= -1;
		so_update_policy(so);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		so_update_necp_policy(so, NULL, NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
	}

	<span class="enscript-keyword">if</span> (ep != PROC_NULL)
		proc_rele(ep);

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">so_set_effective_uuid</span>(<span class="enscript-type">struct</span> socket *so, uuid_t euuid, <span class="enscript-type">struct</span> proc *p)
{
	uuid_string_t buf;
	uuid_t uuid;
	<span class="enscript-type">int</span> error = 0;

	<span class="enscript-comment">/* UUID must not be all-zeroes (reserved for kernel) */</span>
	<span class="enscript-keyword">if</span> (uuid_is_null(euuid)) {
		error = EINVAL;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * If this is an in-kernel socket, prevent its delegate
	 * association from changing unless the socket option is
	 * coming from within the kernel itself.
	 */</span>
	<span class="enscript-keyword">if</span> (so-&gt;last_pid == 0 &amp;&amp; p != kernproc) {
		error = EACCES;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* Get the UUID of the issuing process */</span>
	proc_getexecutableuuid(p, uuid, <span class="enscript-keyword">sizeof</span> (uuid));

	<span class="enscript-comment">/*
	 * If this is issued by a process that's recorded as the
	 * real owner of the socket, or if the uuid is the same as
	 * the process's own uuid, then proceed.  Otherwise ensure
	 * that the issuing process has the necessary privileges.
	 */</span>
	<span class="enscript-keyword">if</span> (uuid_compare(euuid, so-&gt;last_uuid) != 0 ||
	    uuid_compare(euuid, uuid) != 0) {
		<span class="enscript-keyword">if</span> ((error = priv_check_cred(kauth_cred_get(),
		    PRIV_NET_PRIVILEGED_SOCKET_DELEGATE, 0))) {
			error = EACCES;
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
		}
	}

	<span class="enscript-comment">/*
	 * If a process tries to delegate the socket to itself, then
	 * there's really nothing to do; treat it as a way for the
	 * delegate association to be cleared.  Note that we check
	 * the uuid of the passed-in proc rather than that of the
	 * current process, as we need to check the process issuing
	 * the socket option which could be kernproc itself.  Given
	 * that we don't allow 0 for effective uuid, it means that
	 * a delegated in-kernel socket stays delegated during its
	 * lifetime (which is okay.)
	 */</span>
	<span class="enscript-keyword">if</span> (uuid_compare(euuid, uuid) == 0) {
		so-&gt;so_flags &amp;= ~SOF_DELEGATED;
		so-&gt;e_upid = 0;
		so-&gt;e_pid = 0;
		uuid_clear(so-&gt;e_uuid);
	} <span class="enscript-keyword">else</span> {
		so-&gt;so_flags |= SOF_DELEGATED;
		<span class="enscript-comment">/*
		 * Unlike so_set_effective_pid(), we only have the UUID
		 * here and the process ID is not known.  Inherit the
		 * real {pid,upid} of the socket.
		 */</span>
		so-&gt;e_upid = so-&gt;last_upid;
		so-&gt;e_pid = so-&gt;last_pid;
		uuid_copy(so-&gt;e_uuid, euuid);
	}

<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">if</span> (error == 0 &amp;&amp; net_io_policy_log) {
		uuid_unparse(so-&gt;e_uuid, buf);
		log(LOG_DEBUG, <span class="enscript-string">&quot;%s[%s,%d]: so 0x%llx [%d,%d] epid %d &quot;</span>
		    <span class="enscript-string">&quot;euuid %s%s\n&quot;</span>, __func__, proc_name_address(p), proc_pid(p),
		    (uint64_t)DEBUG_KERNEL_ADDRPERM(so), SOCK_DOM(so),
		    SOCK_TYPE(so), so-&gt;e_pid, buf,
		    ((so-&gt;so_flags &amp; SOF_DELEGATED) ? <span class="enscript-string">&quot; [delegated]&quot;</span> : <span class="enscript-string">&quot;&quot;</span>));
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (error != 0 &amp;&amp; net_io_policy_log) {
		uuid_unparse(euuid, buf);
		log(LOG_DEBUG, <span class="enscript-string">&quot;%s[%s,%d]: so 0x%llx [%d,%d] euuid %s &quot;</span>
		    <span class="enscript-string">&quot;ERROR (%d)\n&quot;</span>, __func__, proc_name_address(p), proc_pid(p),
		    (uint64_t)DEBUG_KERNEL_ADDRPERM(so), SOCK_DOM(so),
		    SOCK_TYPE(so), buf, error);
	}

	<span class="enscript-comment">/* Update this socket's policy upon success */</span>
	<span class="enscript-keyword">if</span> (error == 0) {
		so-&gt;so_policy_gencnt *= -1;
		so_update_policy(so);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">NECP</span>
		so_update_necp_policy(so, NULL, NULL);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* NECP */</span>
	}

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">netpolicy_post_msg</span>(uint32_t ev_code, <span class="enscript-type">struct</span> netpolicy_event_data *ev_data,
    uint32_t ev_datalen)
{
	<span class="enscript-type">struct</span> kev_msg ev_msg;

	<span class="enscript-comment">/*
	 * A netpolicy event always starts with a netpolicy_event_data
	 * structure, but the caller can provide for a longer event
	 * structure to post, depending on the event code.
	 */</span>
	VERIFY(ev_data != NULL &amp;&amp; ev_datalen &gt;= <span class="enscript-keyword">sizeof</span> (*ev_data));

	bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span> (ev_msg));
	ev_msg.vendor_code	= KEV_VENDOR_APPLE;
	ev_msg.kev_class	= KEV_NETWORK_CLASS;
	ev_msg.kev_subclass	= KEV_NETPOLICY_SUBCLASS;
	ev_msg.event_code	= ev_code;

	ev_msg.dv[0].data_ptr	= ev_data;
	ev_msg.dv[0].data_length = ev_datalen;

	kev_post_msg(&amp;ev_msg);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">socket_post_kev_msg</span>(uint32_t ev_code,
    <span class="enscript-type">struct</span> kev_socket_event_data *ev_data,
    uint32_t ev_datalen)
{
	<span class="enscript-type">struct</span> kev_msg ev_msg;

	bzero(&amp;ev_msg, <span class="enscript-keyword">sizeof</span>(ev_msg));
	ev_msg.vendor_code = KEV_VENDOR_APPLE;
	ev_msg.kev_class = KEV_NETWORK_CLASS;
	ev_msg.kev_subclass = KEV_SOCKET_SUBCLASS;
	ev_msg.event_code = ev_code;

	ev_msg.dv[0].data_ptr = ev_data;
	ev_msg.dv[0]. data_length = ev_datalen;

	kev_post_msg(&amp;ev_msg);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">socket_post_kev_msg_closed</span>(<span class="enscript-type">struct</span> socket *so)
{
	<span class="enscript-type">struct</span> kev_socket_closed ev;
	<span class="enscript-type">struct</span> sockaddr *socksa = NULL, *peersa = NULL;
	<span class="enscript-type">int</span> err;
	bzero(&amp;ev, <span class="enscript-keyword">sizeof</span>(ev));
	err = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_sockaddr)(so, &amp;socksa);
	<span class="enscript-keyword">if</span> (err == 0) {
		err = (*so-&gt;so_proto-&gt;pr_usrreqs-&gt;pru_peeraddr)(so,
		    &amp;peersa);
		<span class="enscript-keyword">if</span> (err == 0) {
			memcpy(&amp;ev.ev_data.kev_sockname, socksa,
			    min(socksa-&gt;sa_len,
			    <span class="enscript-keyword">sizeof</span> (ev.ev_data.kev_sockname)));
			memcpy(&amp;ev.ev_data.kev_peername, peersa,
			    min(peersa-&gt;sa_len,
			    <span class="enscript-keyword">sizeof</span> (ev.ev_data.kev_peername)));
			socket_post_kev_msg(KEV_SOCKET_CLOSED,
			    &amp;ev.ev_data, <span class="enscript-keyword">sizeof</span> (ev));
		}
	}
	<span class="enscript-keyword">if</span> (socksa != NULL)
		FREE(socksa, M_SONAME);
	<span class="enscript-keyword">if</span> (peersa != NULL)
		FREE(peersa, M_SONAME);
}
</pre>
<hr />
</body></html>