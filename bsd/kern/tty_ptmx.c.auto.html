<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>tty_ptmx.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">tty_ptmx.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1997-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)tty_pty.c	8.4 (Berkeley) 2/20/95
 */</span>

<span class="enscript-comment">/*
 * Pseudo-teletype Driver
 * (Actually two drivers, requiring two entries in 'cdevsw')
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;pty.h&quot;</span>		<span class="enscript-comment">/* XXX */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/tty.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/file_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/uio_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/user.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/signalvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/devfs.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;miscfs/devfs/devfsdefs.h&gt;</span>	<span class="enscript-comment">/* DEVFS_LOCK()/DEVFS_UNLOCK() */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;tty_dev.h&quot;</span>

<span class="enscript-comment">/*
 * Forward declarations
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">ptmx_init</span>(<span class="enscript-type">int</span> n_ptys);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ptmx_ioctl *<span class="enscript-function-name">ptmx_get_ioctl</span>(<span class="enscript-type">int</span> minor, <span class="enscript-type">int</span> open_flag);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ptmx_free_ioctl</span>(<span class="enscript-type">int</span> minor, <span class="enscript-type">int</span> open_flag);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ptmx_get_name</span>(<span class="enscript-type">int</span> minor, <span class="enscript-type">char</span> *buffer, size_t size);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ptsd_revoke_knotes</span>(<span class="enscript-type">int</span> minor, <span class="enscript-type">struct</span> tty *tp);

<span class="enscript-type">extern</span>	d_open_t	ptsopen;
<span class="enscript-type">extern</span>	d_close_t	ptsclose;
<span class="enscript-type">extern</span>	d_read_t	ptsread;
<span class="enscript-type">extern</span>	d_write_t	ptswrite;
<span class="enscript-type">extern</span>	d_ioctl_t	ptyioctl;
<span class="enscript-type">extern</span>	d_stop_t	ptsstop;
<span class="enscript-type">extern</span>	d_reset_t	ptsreset;
<span class="enscript-type">extern</span>	d_select_t	ptsselect;

<span class="enscript-type">extern</span>	d_open_t	ptcopen;
<span class="enscript-type">extern</span>	d_close_t	ptcclose;
<span class="enscript-type">extern</span>	d_read_t	ptcread;
<span class="enscript-type">extern</span>	d_write_t	ptcwrite;
<span class="enscript-type">extern</span>	d_stop_t	ptcstop;
<span class="enscript-type">extern</span>	d_reset_t	ptcreset;
<span class="enscript-type">extern</span>	d_select_t	ptcselect;

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ptmx_major;		<span class="enscript-comment">/* dynamically assigned major number */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cdevsw ptmx_cdev = {
	ptcopen,	ptcclose,	ptcread,	ptcwrite,
	ptyioctl,	ptcstop,	ptcreset,	0,
	ptcselect,	eno_mmap,	eno_strat,	eno_getc,
	eno_putc,	D_TTY
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ptsd_major;		<span class="enscript-comment">/* dynamically assigned major number */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> cdevsw ptsd_cdev = {
	ptsopen,	ptsclose,	ptsread,	ptswrite,
	ptyioctl,	ptsstop,	ptsreset,	0,
	ptsselect,	eno_mmap,	eno_strat,	eno_getc,
	eno_putc,	D_TTY
};

<span class="enscript-comment">/*
 * ptmx == /dev/ptmx
 * ptsd == /dev/pts[0123456789]{3}
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PTMX_TEMPLATE</span>	<span class="enscript-string">&quot;ptmx&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">PTSD_TEMPLATE</span>	<span class="enscript-string">&quot;ttys%03d&quot;</span>

<span class="enscript-comment">/*
 * System-wide limit on the max number of cloned ptys
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PTMX_MAX_DEFAULT</span>	127	<span class="enscript-comment">/* 128 entries */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PTMX_MAX_HARD</span>		999	<span class="enscript-comment">/* 1000 entries, due to PTSD_TEMPLATE */</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> ptmx_max = PTMX_MAX_DEFAULT;	<span class="enscript-comment">/* default # of clones we allow */</span>

<span class="enscript-comment">/* Range enforcement for the sysctl */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">sysctl_ptmx_max</span>(__unused <span class="enscript-type">struct</span> sysctl_oid *oidp, __unused <span class="enscript-type">void</span> *arg1,
		__unused <span class="enscript-type">int</span> arg2, <span class="enscript-type">struct</span> sysctl_req *req)
{
	<span class="enscript-type">int</span> new_value, changed;
	<span class="enscript-type">int</span> error = sysctl_io_number(req, ptmx_max, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">int</span>), &amp;new_value, &amp;changed);
	<span class="enscript-keyword">if</span> (changed) {
		<span class="enscript-keyword">if</span> (new_value &gt; 0 &amp;&amp; new_value &lt;= PTMX_MAX_HARD)
			ptmx_max = new_value;
		<span class="enscript-keyword">else</span>
			error = EINVAL;
	}
	<span class="enscript-keyword">return</span>(error);
}

<span class="enscript-function-name">SYSCTL_NODE</span>(_kern, KERN_TTY, tty, CTLFLAG_RW|CTLFLAG_LOCKED, 0, <span class="enscript-string">&quot;TTY&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_tty, OID_AUTO, ptmx_max,
		CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED,
		&amp;ptmx_max, 0, &amp;sysctl_ptmx_max, <span class="enscript-string">&quot;I&quot;</span>, <span class="enscript-string">&quot;ptmx_max&quot;</span>);

<span class="enscript-type">static</span> <span class="enscript-type">int</span>	ptmx_clone(dev_t dev, <span class="enscript-type">int</span> minor);

<span class="enscript-comment">/*
 * Set of locks to keep the interaction between kevents and revoke
 * from causing havoc.
 */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">LOG2_PTSD_KE_NLCK</span>	2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PTSD_KE_NLCK</span>		(1l &lt;&lt; LOG2_PTSD_KE_NLCK)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">PTSD_KE_LOCK_INDEX</span>(x)	((x) &amp; (PTSD_KE_NLCK - 1))

<span class="enscript-type">static</span> lck_mtx_t ptsd_kevent_lock[PTSD_KE_NLCK];

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ptsd_kevent_lock_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i;
	lck_grp_t *lgrp = lck_grp_alloc_init(<span class="enscript-string">&quot;ptsd kevent&quot;</span>, LCK_GRP_ATTR_NULL);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; PTSD_KE_NLCK; i++)
		lck_mtx_init(&amp;ptsd_kevent_lock[i], lgrp, LCK_ATTR_NULL);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ptsd_kevent_mtx_lock</span>(<span class="enscript-type">int</span> minor)
{
	lck_mtx_lock(&amp;ptsd_kevent_lock[PTSD_KE_LOCK_INDEX(minor)]);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ptsd_kevent_mtx_unlock</span>(<span class="enscript-type">int</span> minor)
{
	lck_mtx_unlock(&amp;ptsd_kevent_lock[PTSD_KE_LOCK_INDEX(minor)]);
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> tty_dev_t _ptmx_driver;

<span class="enscript-type">int</span>
<span class="enscript-function-name">ptmx_init</span>( __unused <span class="enscript-type">int</span> config_count)
{
	<span class="enscript-comment">/*
	 * We start looking at slot 10, since there are inits that will
	 * stomp explicit slots (e.g. vndevice stomps 1) below that.
	 */</span>

	<span class="enscript-comment">/* Get a major number for /dev/ptmx */</span>
	<span class="enscript-keyword">if</span>((ptmx_major = cdevsw_add(-15, &amp;ptmx_cdev)) == -1) {
		printf(<span class="enscript-string">&quot;ptmx_init: failed to obtain /dev/ptmx major number\n&quot;</span>);
		<span class="enscript-keyword">return</span> (ENOENT);
	}

	<span class="enscript-keyword">if</span> (cdevsw_setkqueueok(ptmx_major, &amp;ptmx_cdev, 0) == -1) {
		panic(<span class="enscript-string">&quot;Failed to set flags on ptmx cdevsw entry.&quot;</span>);
	}

	<span class="enscript-comment">/* Get a major number for /dev/pts/nnn */</span>
	<span class="enscript-keyword">if</span> ((ptsd_major = cdevsw_add(-15, &amp;ptsd_cdev)) == -1) {
		(<span class="enscript-type">void</span>)cdevsw_remove(ptmx_major, &amp;ptmx_cdev);
		printf(<span class="enscript-string">&quot;ptmx_init: failed to obtain /dev/ptmx major number\n&quot;</span>);
		<span class="enscript-keyword">return</span> (ENOENT);
	}
	
	<span class="enscript-keyword">if</span> (cdevsw_setkqueueok(ptsd_major, &amp;ptsd_cdev, 0) == -1) {
		panic(<span class="enscript-string">&quot;Failed to set flags on ptmx cdevsw entry.&quot;</span>);
	}

	<span class="enscript-comment">/*
	 * Locks to guard against races between revoke and kevents
	 */</span>
	ptsd_kevent_lock_init();

	<span class="enscript-comment">/* Create the /dev/ptmx device {&lt;major&gt;,0} */</span>
	(<span class="enscript-type">void</span>)devfs_make_node_clone(makedev(ptmx_major, 0),
				DEVFS_CHAR, UID_ROOT, GID_TTY, 0666,
				ptmx_clone, PTMX_TEMPLATE);

	_ptmx_driver.master = ptmx_major;
	_ptmx_driver.slave = ptsd_major;
	_ptmx_driver.fix_7828447 = 1;
	_ptmx_driver.fix_7070978 = 1;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF</span>
	_ptmx_driver.mac_notify = 1;
#<span class="enscript-reference">endif</span>
	_ptmx_driver.open = &amp;ptmx_get_ioctl;
	_ptmx_driver.free = &amp;ptmx_free_ioctl;
	_ptmx_driver.name = &amp;ptmx_get_name;
	_ptmx_driver.revoke = &amp;ptsd_revoke_knotes;
	tty_dev_register(&amp;_ptmx_driver);

	<span class="enscript-keyword">return</span> (0);
}


<span class="enscript-type">static</span> <span class="enscript-type">struct</span> _ptmx_ioctl_state {
	<span class="enscript-type">struct</span> ptmx_ioctl	**pis_ioctl_list;	<span class="enscript-comment">/* pointer vector */</span>
	<span class="enscript-type">int</span>			pis_total;		<span class="enscript-comment">/* total slots */</span>
	<span class="enscript-type">int</span>			pis_free;		<span class="enscript-comment">/* free slots */</span>
} _state;
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PTMX_GROW_VECTOR</span>	16	<span class="enscript-comment">/* Grow by this many slots at a time */</span>

<span class="enscript-comment">/*
 * Given a minor number, return the corresponding structure for that minor
 * number.  If there isn't one, and the create flag is specified, we create
 * one if possible.
 *
 * Parameters:	minor			Minor number of ptmx device
 *		open_flag		PF_OPEN_M	First open of master
 *					PF_OPEN_S	First open of slave
 *					0		Just want ioctl struct
 *
 * Returns:	NULL			Did not exist/could not create
 *		!NULL			structure corresponding minor number
 *
 * Locks:	tty_lock() on ptmx_ioctl-&gt;pt_tty NOT held on entry or exit.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ptmx_ioctl *
<span class="enscript-function-name">ptmx_get_ioctl</span>(<span class="enscript-type">int</span> minor, <span class="enscript-type">int</span> open_flag)
{
	<span class="enscript-type">struct</span> ptmx_ioctl *new_ptmx_ioctl;

	<span class="enscript-keyword">if</span> (open_flag &amp; PF_OPEN_M) {

		<span class="enscript-comment">/*
		 * If we are about to allocate more memory, but we have
		 * already hit the administrative limit, then fail the
		 * operation.
		 *
		 * Note:	Subtract free from total when making this
		 *		check to allow unit increments, rather than
		 *		snapping to the nearest PTMX_GROW_VECTOR...
		 */</span>
		<span class="enscript-keyword">if</span> ((_state.pis_total - _state.pis_free) &gt;= ptmx_max) {
			<span class="enscript-keyword">return</span> (NULL);
		}

		MALLOC(new_ptmx_ioctl, <span class="enscript-type">struct</span> ptmx_ioctl *, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ptmx_ioctl), M_TTYS, M_WAITOK|M_ZERO);
		<span class="enscript-keyword">if</span> (new_ptmx_ioctl == NULL) {
			<span class="enscript-keyword">return</span> (NULL);
		}

		<span class="enscript-keyword">if</span> ((new_ptmx_ioctl-&gt;pt_tty = ttymalloc()) == NULL) {
			FREE(new_ptmx_ioctl, M_TTYS);
			<span class="enscript-keyword">return</span> (NULL);
		}
	
		<span class="enscript-comment">/*
		 * Hold the DEVFS_LOCK() over this whole operation; devfs
		 * itself does this over malloc/free as well, so this should
		 * be safe to do.  We hold it longer than we want to, but
		 * doing so avoids a reallocation race on the minor number.
		 */</span>
		DEVFS_LOCK();
		<span class="enscript-comment">/* Need to allocate a larger vector? */</span>
		<span class="enscript-keyword">if</span> (_state.pis_free == 0) {
			<span class="enscript-type">struct</span> ptmx_ioctl **new_pis_ioctl_list;
			<span class="enscript-type">struct</span> ptmx_ioctl **old_pis_ioctl_list = NULL;

			<span class="enscript-comment">/* Yes. */</span>
			MALLOC(new_pis_ioctl_list, <span class="enscript-type">struct</span> ptmx_ioctl **, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ptmx_ioctl *) * (_state.pis_total + PTMX_GROW_VECTOR), M_TTYS, M_WAITOK|M_ZERO);
			<span class="enscript-keyword">if</span> (new_pis_ioctl_list == NULL) {
				ttyfree(new_ptmx_ioctl-&gt;pt_tty);
				DEVFS_UNLOCK();
				FREE(new_ptmx_ioctl, M_TTYS);
				<span class="enscript-keyword">return</span> (NULL);
			}

			<span class="enscript-comment">/* If this is not the first time, copy the old over */</span>
			bcopy(_state.pis_ioctl_list, new_pis_ioctl_list, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ptmx_ioctl *) * _state.pis_total);
			old_pis_ioctl_list = _state.pis_ioctl_list;
			_state.pis_ioctl_list = new_pis_ioctl_list;
			_state.pis_free += PTMX_GROW_VECTOR;
			_state.pis_total += PTMX_GROW_VECTOR;
			<span class="enscript-keyword">if</span> (old_pis_ioctl_list)
				FREE(old_pis_ioctl_list, M_TTYS);
		} 
		
		<span class="enscript-comment">/* is minor in range now? */</span>
		<span class="enscript-keyword">if</span> (minor &lt; 0 || minor &gt;= _state.pis_total) {
			ttyfree(new_ptmx_ioctl-&gt;pt_tty);
			DEVFS_UNLOCK();
			FREE(new_ptmx_ioctl, M_TTYS);
			<span class="enscript-keyword">return</span> (NULL);
		}
		
		<span class="enscript-keyword">if</span> (_state.pis_ioctl_list[minor] != NULL) {
			ttyfree(new_ptmx_ioctl-&gt;pt_tty);
			DEVFS_UNLOCK();
			FREE(new_ptmx_ioctl, M_TTYS);

			<span class="enscript-comment">/* Special error value so we know to redrive the open, we've been raced */</span>
			<span class="enscript-keyword">return</span> (<span class="enscript-type">struct</span> ptmx_ioctl*)-1; 

		}

		<span class="enscript-comment">/* Vector is large enough; grab a new ptmx_ioctl */</span>

		<span class="enscript-comment">/* Now grab a free slot... */</span>
		_state.pis_ioctl_list[minor] = new_ptmx_ioctl;

		<span class="enscript-comment">/* reduce free count */</span>
		_state.pis_free--;

		_state.pis_ioctl_list[minor]-&gt;pt_flags |= PF_OPEN_M;
		DEVFS_UNLOCK();

		<span class="enscript-comment">/* Create the /dev/ttysXXX device {&lt;major&gt;,XXX} */</span>
		_state.pis_ioctl_list[minor]-&gt;pt_devhandle = devfs_make_node(
				makedev(ptsd_major, minor),
				DEVFS_CHAR, UID_ROOT, GID_TTY, 0620,
				PTSD_TEMPLATE, minor);
		<span class="enscript-keyword">if</span> (_state.pis_ioctl_list[minor]-&gt;pt_devhandle == NULL) {
			printf(<span class="enscript-string">&quot;devfs_make_node() call failed for ptmx_get_ioctl()!!!!\n&quot;</span>);
		}
	}
	
	<span class="enscript-keyword">if</span> (minor &lt; 0 || minor &gt;= _state.pis_total) {
		<span class="enscript-keyword">return</span> (NULL);
	}
	
	<span class="enscript-keyword">return</span> (_state.pis_ioctl_list[minor]);
}

<span class="enscript-comment">/*
 * Locks:	tty_lock() of old_ptmx_ioctl-&gt;pt_tty NOT held for this call.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ptmx_free_ioctl</span>(<span class="enscript-type">int</span> minor, <span class="enscript-type">int</span> open_flag)
{
	<span class="enscript-type">struct</span> ptmx_ioctl *old_ptmx_ioctl = NULL;

	DEVFS_LOCK();
	
	<span class="enscript-keyword">if</span> (minor &lt; 0 || minor &gt;= _state.pis_total) {
		DEVFS_UNLOCK();
		<span class="enscript-keyword">return</span> (-1);
	}

	_state.pis_ioctl_list[minor]-&gt;pt_flags &amp;= ~(open_flag);

	<span class="enscript-comment">/*
	 * Was this the last close?  We will recognize it because we only get
	 * a notification on the last close of a device, and we will have
	 * cleared both the master and the slave open bits in the flags.
	 */</span>
	<span class="enscript-keyword">if</span> (!(_state.pis_ioctl_list[minor]-&gt;pt_flags &amp; (PF_OPEN_M|PF_OPEN_S))) {
		<span class="enscript-comment">/* Mark as free so it can be reallocated later */</span>
		old_ptmx_ioctl = _state.pis_ioctl_list[ minor];
	}
	DEVFS_UNLOCK();

	<span class="enscript-comment">/* Free old after dropping lock */</span>
	<span class="enscript-keyword">if</span> (old_ptmx_ioctl != NULL) {
		<span class="enscript-comment">/*
		 * XXX See &lt;rdar://5348651&gt; and &lt;rdar://4854638&gt;
		 *
		 * XXX Conditional to be removed when/if tty/pty reference
		 * XXX counting and mutex implemented.
		 */</span>
		<span class="enscript-keyword">if</span> (old_ptmx_ioctl-&gt;pt_devhandle != NULL)
			devfs_remove(old_ptmx_ioctl-&gt;pt_devhandle);
		ttyfree(old_ptmx_ioctl-&gt;pt_tty);
		FREE(old_ptmx_ioctl, M_TTYS);

		<span class="enscript-comment">/* Don't remove the entry until the devfs slot is free */</span>
		DEVFS_LOCK();
		_state.pis_ioctl_list[minor] = NULL;
		_state.pis_free++;
		DEVFS_UNLOCK();
	}

	<span class="enscript-keyword">return</span> (0);	<span class="enscript-comment">/* Success */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ptmx_get_name</span>(<span class="enscript-type">int</span> minor, <span class="enscript-type">char</span> *buffer, size_t size)
{
	<span class="enscript-keyword">return</span> snprintf(buffer, size, <span class="enscript-string">&quot;/dev/&quot;</span> PTSD_TEMPLATE, minor);
}



<span class="enscript-comment">/*
 * Given the dev entry that's being opened, we clone the device.  This driver
 * doesn't actually use the dev entry, since we alreaqdy know who we are by
 * being called from this code.  This routine is a callback registered from
 * devfs_make_node_clone() in ptmx_init(); it's purpose is to provide a new
 * minor number, or to return -1, if one can't be provided.
 *
 * Parameters:	dev			The device we are cloning from
 *
 * Returns:	&gt;= 0			A new minor device number
 *		-1			Error: ENOMEM (&quot;Can't alloc device&quot;)
 *
 * NOTE:	Called with DEVFS_LOCK() held
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ptmx_clone</span>(__unused dev_t dev, <span class="enscript-type">int</span> action)
{
	<span class="enscript-type">int</span> i;

	<span class="enscript-keyword">if</span> (action == DEVFS_CLONE_ALLOC) {
		<span class="enscript-comment">/* First one */</span>
		<span class="enscript-keyword">if</span> (_state.pis_total == 0)
			<span class="enscript-keyword">return</span> (0);

		<span class="enscript-comment">/*
		 * Note: We can add hinting on free slots, if this linear search
		 * ends up being a performance bottleneck...
		 */</span>
		<span class="enscript-keyword">for</span>(i = 0; i &lt; _state.pis_total; i++) {
			<span class="enscript-keyword">if</span> (_state.pis_ioctl_list[ i] == NULL)
				<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-comment">/*
		 * XXX We fall off the end here; if we did this twice at the
		 * XXX same time, we could return the same minor to two
		 * XXX callers; we should probably exand the pointer vector
		 * XXX here, but I need more information on the MALLOC/FREE
		 * XXX locking to ensure against a deadlock.  Maybe we can
		 * XXX just high watermark it at 1/2 of PTMX_GROW_VECTOR?
		 * XXX That would require returning &amp;minor as implict return
		 * XXX and an error code (&quot;EAGAIN/ERESTART&quot;) or 0 as our
		 * XXX explicit return.
		 */</span>

		<span class="enscript-keyword">return</span> (i);	<span class="enscript-comment">/* empty slot or next slot */</span>
	}
	<span class="enscript-keyword">return</span>(-1);
}


<span class="enscript-comment">/*
 * kqueue support.
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">ptsd_kqfilter</span>(dev_t, <span class="enscript-type">struct</span> knote *); 
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">ptsd_kqops_detach</span>(<span class="enscript-type">struct</span> knote *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">ptsd_kqops_event</span>(<span class="enscript-type">struct</span> knote *, <span class="enscript-type">long</span>);

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> filterops ptsd_kqops = {
	.f_isfd = 1,
	.f_detach = ptsd_kqops_detach,
	.f_event = ptsd_kqops_event,
};                                    

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PTSD_KNOTE_VALID</span>	NULL
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">PTSD_KNOTE_REVOKED</span>	((void *)-911l)

<span class="enscript-comment">/*
 * In the normal case, by the time the driver_close() routine is called
 * on the slave, all knotes have been detached.  However in the revoke(2)
 * case, the driver's close routine is called while there are knotes active
 * that reference the handlers below.  And we have no obvious means to
 * reach from the driver out to the kqueue's that reference them to get
 * them to stop.
 */</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ptsd_kqops_detach</span>(<span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-type">struct</span> ptmx_ioctl *pti;
	<span class="enscript-type">struct</span> tty *tp;
	dev_t dev, lockdev = (dev_t)kn-&gt;kn_hookid;

	ptsd_kevent_mtx_lock(minor(lockdev));

	<span class="enscript-keyword">if</span> ((dev = (dev_t)kn-&gt;kn_hookid) != 0) {
		pti = ptmx_get_ioctl(minor(dev), 0);
		<span class="enscript-keyword">if</span> (pti != NULL &amp;&amp; (tp = pti-&gt;pt_tty) != NULL) {
			tty_lock(tp);
			<span class="enscript-keyword">if</span> (kn-&gt;kn_filter == EVFILT_READ)
				KNOTE_DETACH(&amp;tp-&gt;t_rsel.si_note, kn);
			<span class="enscript-keyword">else</span>
				KNOTE_DETACH(&amp;tp-&gt;t_wsel.si_note, kn);
			tty_unlock(tp);
			kn-&gt;kn_hookid = 0;
		}
	}

	ptsd_kevent_mtx_unlock(minor(lockdev));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">ptsd_kqops_event</span>(<span class="enscript-type">struct</span> knote *kn, <span class="enscript-type">long</span> hint)
{
	<span class="enscript-type">struct</span> ptmx_ioctl *pti;
	<span class="enscript-type">struct</span> tty *tp;
	dev_t dev = (dev_t)kn-&gt;kn_hookid;
	<span class="enscript-type">int</span> retval = 0;

	ptsd_kevent_mtx_lock(minor(dev));

	<span class="enscript-keyword">do</span> {
		<span class="enscript-keyword">if</span> (kn-&gt;kn_hook != PTSD_KNOTE_VALID ) {
			<span class="enscript-comment">/* We were revoked */</span>
			kn-&gt;kn_data = 0;
			kn-&gt;kn_flags |= EV_EOF;
			retval = 1;
			<span class="enscript-keyword">break</span>;
		}

		pti = ptmx_get_ioctl(minor(dev), 0);
		<span class="enscript-keyword">if</span> (pti == NULL || (tp = pti-&gt;pt_tty) == NULL) {
			kn-&gt;kn_data = ENXIO;
			kn-&gt;kn_flags |= EV_ERROR;
			retval = 1;
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (hint == 0)
			tty_lock(tp);

		<span class="enscript-keyword">if</span> (kn-&gt;kn_filter == EVFILT_READ) {
			kn-&gt;kn_data = ttnread(tp);
			<span class="enscript-keyword">if</span> (kn-&gt;kn_data &gt; 0)
				retval = 1;
			<span class="enscript-keyword">if</span> (ISSET(tp-&gt;t_state, TS_ZOMBIE)) {
				kn-&gt;kn_flags |= EV_EOF;
				retval = 1;
			}
		} <span class="enscript-keyword">else</span> {	<span class="enscript-comment">/* EVFILT_WRITE */</span>
			<span class="enscript-keyword">if</span> ((tp-&gt;t_outq.c_cc &lt;= tp-&gt;t_lowat) &amp;&amp;
			    ISSET(tp-&gt;t_state, TS_CONNECTED)) {
				kn-&gt;kn_data = tp-&gt;t_outq.c_cn - tp-&gt;t_outq.c_cc;
				retval = 1;
			}
			<span class="enscript-keyword">if</span> (ISSET(tp-&gt;t_state, TS_ZOMBIE)) {
				kn-&gt;kn_flags |= EV_EOF;
				retval = 1;
			}
		}

		<span class="enscript-keyword">if</span> (hint == 0)
			tty_unlock(tp);
	} <span class="enscript-keyword">while</span> (0);

	ptsd_kevent_mtx_unlock(minor(dev));

	<span class="enscript-keyword">return</span> (retval);
}                                                                                                
<span class="enscript-type">int</span>
<span class="enscript-function-name">ptsd_kqfilter</span>(dev_t dev, <span class="enscript-type">struct</span> knote *kn)
{
	<span class="enscript-type">struct</span> tty *tp = NULL; 
	<span class="enscript-type">struct</span> ptmx_ioctl *pti = NULL;
	<span class="enscript-type">int</span> retval = 0;

	<span class="enscript-comment">/* make sure we're talking about the right device type */</span>
	<span class="enscript-keyword">if</span> (cdevsw[major(dev)].d_open != ptsopen) {
		<span class="enscript-keyword">return</span> (EINVAL);
	}

	<span class="enscript-keyword">if</span> ((pti = ptmx_get_ioctl(minor(dev), 0)) == NULL) {
	        <span class="enscript-keyword">return</span> (ENXIO);
	}

	tp = pti-&gt;pt_tty;
	tty_lock(tp);

	kn-&gt;kn_hookid = dev;
	kn-&gt;kn_hook = PTSD_KNOTE_VALID;
	kn-&gt;kn_fop = &amp;ptsd_kqops;

        <span class="enscript-keyword">switch</span> (kn-&gt;kn_filter) {
        <span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_READ</span>:
                KNOTE_ATTACH(&amp;tp-&gt;t_rsel.si_note, kn);
                <span class="enscript-keyword">break</span>;
        <span class="enscript-keyword">case</span> <span class="enscript-reference">EVFILT_WRITE</span>:
                KNOTE_ATTACH(&amp;tp-&gt;t_wsel.si_note, kn);
                <span class="enscript-keyword">break</span>;
        <span class="enscript-reference">default</span>:
                retval = EINVAL;
                <span class="enscript-keyword">break</span>;
        }

        tty_unlock(tp);
        <span class="enscript-keyword">return</span> (retval);
}

<span class="enscript-comment">/*
 * Support for revoke(2).
 *
 * Mark all the kn_hook fields so that future invocations of the
 * f_event op will just say &quot;EOF&quot; *without* looking at the
 * ptmx_ioctl structure (which may disappear or be recycled at
 * the end of ptsd_close).  Issue wakeups to post that EOF to
 * anyone listening.  And finally remove the knotes from the
 * tty's klists to keep ttyclose() happy, and set the hookid to
 * zero to make the final detach passively successful.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">ptsd_revoke_knotes</span>(<span class="enscript-type">int</span> minor, <span class="enscript-type">struct</span> tty *tp)
{
	<span class="enscript-type">struct</span> klist *list;
	<span class="enscript-type">struct</span> knote *kn, *tkn;

	<span class="enscript-comment">/* (Hold and drop the right locks in the right order.) */</span>

	ptsd_kevent_mtx_lock(minor);
	tty_lock(tp);

	list = &amp;tp-&gt;t_rsel.si_note;
	SLIST_FOREACH(kn, list, kn_selnext)
		kn-&gt;kn_hook = PTSD_KNOTE_REVOKED;

	list = &amp;tp-&gt;t_wsel.si_note;
	SLIST_FOREACH(kn, list, kn_selnext)
		kn-&gt;kn_hook = PTSD_KNOTE_REVOKED;

	tty_unlock(tp);
	ptsd_kevent_mtx_unlock(minor);

	tty_lock(tp);
	ttwakeup(tp);
	ttwwakeup(tp);
	tty_unlock(tp);

	ptsd_kevent_mtx_lock(minor);
	tty_lock(tp);

	list = &amp;tp-&gt;t_rsel.si_note;
	SLIST_FOREACH_SAFE(kn, list, kn_selnext, tkn) {
		(<span class="enscript-type">void</span>) KNOTE_DETACH(list, kn);
		kn-&gt;kn_hookid = 0;
	}

	list = &amp;tp-&gt;t_wsel.si_note;
	SLIST_FOREACH_SAFE(kn, list, kn_selnext, tkn) {
		(<span class="enscript-type">void</span>) KNOTE_DETACH(list, kn);
		kn-&gt;kn_hookid = 0;
	}

	tty_unlock(tp);
	ptsd_kevent_mtx_unlock(minor);
}
</pre>
<hr />
</body></html>