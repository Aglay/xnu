<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>netboot.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">netboot.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 2001-2013 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*
 * History:
 * 14 December, 2001	Dieter Siegmund (<a href="mailto:dieter@apple.com">dieter@apple.com</a>)
 * - created
 */</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/conf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/ioctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mount_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/filedesc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/vnode_internal.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socket.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/socketvar.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/reboot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kauth.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_dl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/if_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/route.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/in.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/if_ether.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;netinet/dhcp_options.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kalloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/netboot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/imageboot.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pexpert/pexpert.h&gt;</span>

<span class="enscript-comment">//#include &lt;libkern/libkern.h&gt;
</span><span class="enscript-type">extern</span> <span class="enscript-type">struct</span> filedesc 	filedesc0;

<span class="enscript-type">extern</span> <span class="enscript-type">int</span> 	nfs_mountroot(<span class="enscript-type">void</span>); 	<span class="enscript-comment">/* nfs_vfsops.c */</span>
<span class="enscript-type">extern</span> <span class="enscript-function-name">int</span> (*mountroot)(<span class="enscript-type">void</span>);

<span class="enscript-type">extern</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> 	rootdevice[];

<span class="enscript-type">static</span> <span class="enscript-type">int</span> 			S_netboot = 0;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> netboot_info *	S_netboot_info_p;

<span class="enscript-type">void</span> *
<span class="enscript-function-name">IOBSDRegistryEntryForDeviceTree</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> * path);

<span class="enscript-type">void</span>
<span class="enscript-function-name">IOBSDRegistryEntryRelease</span>(<span class="enscript-type">void</span> * entry);

<span class="enscript-type">const</span> <span class="enscript-type">void</span> *
<span class="enscript-function-name">IOBSDRegistryEntryGetData</span>(<span class="enscript-type">void</span> * entry, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * property_name, 
			  <span class="enscript-type">int</span> * packet_length);

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BOOTP_RESPONSE</span>	<span class="enscript-string">&quot;bootp-response&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">BSDP_RESPONSE</span>	<span class="enscript-string">&quot;bsdp-response&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">DHCP_RESPONSE</span>	<span class="enscript-string">&quot;dhcp-response&quot;</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">IP_FORMAT</span>	<span class="enscript-string">&quot;%d.%d.%d.%d&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IP_CH</span>(ip)	((u_char *)ip)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">IP_LIST</span>(ip)	IP_CH(ip)[0],IP_CH(ip)[1],IP_CH(ip)[2],IP_CH(ip)[3]

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kNetBootRootPathPrefixNFS</span>	<span class="enscript-string">&quot;nfs:&quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">kNetBootRootPathPrefixHTTP</span>	<span class="enscript-string">&quot;http:&quot;</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
    kNetBootImageTypeUnknown = 0,
    kNetBootImageTypeNFS = 1,
    kNetBootImageTypeHTTP = 2,
} NetBootImageType;

<span class="enscript-type">struct</span> netboot_info {
    <span class="enscript-type">struct</span> in_addr	client_ip;
    <span class="enscript-type">struct</span> in_addr	server_ip;
    <span class="enscript-type">char</span> *		server_name;
    <span class="enscript-type">int</span>			server_name_length;
    <span class="enscript-type">char</span> *		mount_point;
    <span class="enscript-type">int</span>			mount_point_length;
    <span class="enscript-type">char</span> *		image_path;
    <span class="enscript-type">int</span>			image_path_length;
    NetBootImageType	image_type;
    <span class="enscript-type">char</span> *		second_image_path;
    <span class="enscript-type">int</span>			second_image_path_length;
};

<span class="enscript-comment">/*
 * Function: parse_booter_path
 * Purpose:
 *   Parse a string of the form:
 *        &quot;&lt;IP&gt;:&lt;host&gt;:&lt;mount&gt;[:&lt;image_path&gt;]&quot;
 *   into the given ip address, host, mount point, and optionally, image_path.
 *
 * Note:
 *   The passed in string is modified i.e. ':' is replaced by '\0'.
 * Example: 
 *   &quot;17.202.16.17:seaport:/release/.images/Image9/CurrentHera&quot;
 */</span>
<span class="enscript-type">static</span> __inline__ boolean_t
<span class="enscript-function-name">parse_booter_path</span>(<span class="enscript-type">char</span> * path, <span class="enscript-type">struct</span> in_addr * iaddr_p, <span class="enscript-type">char</span> <span class="enscript-type">const</span> * * host,
		  <span class="enscript-type">char</span> * * mount_dir, <span class="enscript-type">char</span> * * image_path)
{
    <span class="enscript-type">char</span> *	start;
    <span class="enscript-type">char</span> *	colon;

    <span class="enscript-comment">/* IP address */</span>
    start = path;
    colon = strchr(start, <span class="enscript-string">':'</span>);
    <span class="enscript-keyword">if</span> (colon == NULL) {
	<span class="enscript-keyword">return</span> (FALSE);
    }
    *colon = <span class="enscript-string">'\0'</span>;
    <span class="enscript-keyword">if</span> (inet_aton(start, iaddr_p) != 1) {
	<span class="enscript-keyword">return</span> (FALSE);
    }

    <span class="enscript-comment">/* host */</span>
    start = colon + 1;
    colon = strchr(start, <span class="enscript-string">':'</span>);
    <span class="enscript-keyword">if</span> (colon == NULL) {
	<span class="enscript-keyword">return</span> (FALSE);
    }
    *colon = <span class="enscript-string">'\0'</span>;
    *host = start;

    <span class="enscript-comment">/* mount */</span>
    start = colon + 1;
    colon = strchr(start, <span class="enscript-string">':'</span>);
    *mount_dir = start;
    <span class="enscript-keyword">if</span> (colon == NULL) {
	*image_path = NULL;
    }
    <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">/* image path */</span>
	*colon = <span class="enscript-string">'\0'</span>;
	start = colon + 1;
	*image_path = start;
    }
    <span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-comment">/*
 * Function: find_colon
 * Purpose:
 *   Find the next unescaped instance of the colon character.
 *   If a colon is escaped (preceded by a backslash '\' character),
 *   shift the string over by one character to overwrite the backslash.
 */</span>
<span class="enscript-type">static</span> __inline__ <span class="enscript-type">char</span> *
<span class="enscript-function-name">find_colon</span>(<span class="enscript-type">char</span> * str)
{
    <span class="enscript-type">char</span> * start = str;
    <span class="enscript-type">char</span> * colon;
    
    <span class="enscript-keyword">while</span> ((colon = strchr(start, <span class="enscript-string">':'</span>)) != NULL) {
	<span class="enscript-type">char</span> * dst;
	<span class="enscript-type">char</span> * src;

	<span class="enscript-keyword">if</span> (colon == start) {
	    <span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (colon[-1] != <span class="enscript-string">'\\'</span>)
	    <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">for</span> (dst = colon - 1, src = colon; *dst != <span class="enscript-string">'\0'</span>; dst++, src++) {
	    *dst = *src;
	}
	start = colon;
    }
    <span class="enscript-keyword">return</span> (colon);
}

<span class="enscript-comment">/*
 * Function: parse_netboot_path
 * Purpose:
 *   Parse a string of the form:
 *        &quot;nfs:&lt;IP&gt;:&lt;mount&gt;[:&lt;image_path&gt;]&quot;
 *   into the given ip address, host, mount point, and optionally, image_path.
 * Notes:
 * - the passed in string is modified i.e. ':' is replaced by '\0'
 * - literal colons must be escaped with a backslash
 *
 * Examples:
 * nfs:17.202.42.112:/Library/NetBoot/NetBootSP0:Jaguar/Jaguar.dmg
 * nfs:17.202.42.112:/Volumes/Foo\:/Library/NetBoot/NetBootSP0:Jaguar/Jaguar.dmg
 */</span>
<span class="enscript-type">static</span> __inline__ boolean_t
<span class="enscript-function-name">parse_netboot_path</span>(<span class="enscript-type">char</span> * path, <span class="enscript-type">struct</span> in_addr * iaddr_p, <span class="enscript-type">char</span> <span class="enscript-type">const</span> * * host,
		   <span class="enscript-type">char</span> * * mount_dir, <span class="enscript-type">char</span> * * image_path)
{
    <span class="enscript-type">static</span> <span class="enscript-type">char</span>	tmp[MAX_IPv4_STR_LEN];	<span class="enscript-comment">/* Danger - not thread safe */</span>
    <span class="enscript-type">char</span> *	start;
    <span class="enscript-type">char</span> *	colon;

    <span class="enscript-keyword">if</span> (strncmp(path, kNetBootRootPathPrefixNFS, 
		strlen(kNetBootRootPathPrefixNFS)) != 0) {
	<span class="enscript-keyword">return</span> (FALSE);
    }

    <span class="enscript-comment">/* IP address */</span>
    start = path + strlen(kNetBootRootPathPrefixNFS);
    colon = strchr(start, <span class="enscript-string">':'</span>);
    <span class="enscript-keyword">if</span> (colon == NULL) {
	<span class="enscript-keyword">return</span> (FALSE);
    }
    *colon = <span class="enscript-string">'\0'</span>;
    <span class="enscript-keyword">if</span> (inet_aton(start, iaddr_p) != 1) {
	<span class="enscript-keyword">return</span> (FALSE);
    }

    <span class="enscript-comment">/* mount point */</span>
    start = colon + 1;
    colon = find_colon(start);
    *mount_dir = start;
    <span class="enscript-keyword">if</span> (colon == NULL) {
	*image_path = NULL;
    }
    <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">/* image path */</span>
	*colon = <span class="enscript-string">'\0'</span>;
	start = colon + 1;
	(<span class="enscript-type">void</span>)find_colon(start);
	*image_path = start;
    }
    *host = inet_ntop(AF_INET, iaddr_p, tmp, <span class="enscript-keyword">sizeof</span>(tmp));
    <span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">parse_image_path</span>(<span class="enscript-type">char</span> * path, <span class="enscript-type">struct</span> in_addr * iaddr_p, <span class="enscript-type">char</span> <span class="enscript-type">const</span> * * host,
		 <span class="enscript-type">char</span> * * mount_dir, <span class="enscript-type">char</span> * * image_path)
{
    <span class="enscript-keyword">if</span> (path[0] &gt;= <span class="enscript-string">'0'</span> &amp;&amp; path[0] &lt;= <span class="enscript-string">'9'</span>) {
	<span class="enscript-keyword">return</span> (parse_booter_path(path, iaddr_p, host, mount_dir,
				  image_path));
    }
    <span class="enscript-keyword">return</span> (parse_netboot_path(path, iaddr_p, host, mount_dir,
			       image_path));
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">get_root_path</span>(<span class="enscript-type">char</span> * root_path)
{
    <span class="enscript-type">void</span> *		entry;
    boolean_t		found = FALSE;
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> *	pkt;
    <span class="enscript-type">int</span>			pkt_len;
    
    entry = IOBSDRegistryEntryForDeviceTree(<span class="enscript-string">&quot;/chosen&quot;</span>);
    <span class="enscript-keyword">if</span> (entry == NULL) {
	<span class="enscript-keyword">return</span> (FALSE);
    }
    pkt = IOBSDRegistryEntryGetData(entry, BSDP_RESPONSE, &amp;pkt_len);
    <span class="enscript-keyword">if</span> (pkt != NULL &amp;&amp; pkt_len &gt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> dhcp)) {
	printf(<span class="enscript-string">&quot;netboot: retrieving root path from BSDP response\n&quot;</span>);
    }
    <span class="enscript-keyword">else</span> {
	pkt = IOBSDRegistryEntryGetData(entry, BOOTP_RESPONSE, 
					&amp;pkt_len);
	<span class="enscript-keyword">if</span> (pkt != NULL &amp;&amp; pkt_len &gt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> dhcp)) {
	    printf(<span class="enscript-string">&quot;netboot: retrieving root path from BOOTP response\n&quot;</span>);
	}
    }
    <span class="enscript-keyword">if</span> (pkt != NULL) {
	<span class="enscript-type">int</span>			len;
	dhcpol_t 		options;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *		path;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> dhcp *	reply;

	reply = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> dhcp *)pkt;
	(<span class="enscript-type">void</span>)dhcpol_parse_packet(&amp;options, reply, pkt_len);

	path = (<span class="enscript-type">const</span> <span class="enscript-type">char</span> *)dhcpol_find(&amp;options, 
					 dhcptag_root_path_e, &amp;len, NULL);
	<span class="enscript-keyword">if</span> (path) {
	    memcpy(root_path, path, len);
	    root_path[len] = <span class="enscript-string">'\0'</span>;
	    found = TRUE;
	}
    }
    IOBSDRegistryEntryRelease(entry);
    <span class="enscript-keyword">return</span> (found);

}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">save_path</span>(<span class="enscript-type">char</span> * * str_p, <span class="enscript-type">int</span> * length_p, <span class="enscript-type">char</span> * path)
{
    *length_p = strlen(path) + 1;
    *str_p = (<span class="enscript-type">char</span> *)kalloc(*length_p);
    strlcpy(*str_p, path, *length_p);
    <span class="enscript-keyword">return</span>;
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> netboot_info *
<span class="enscript-function-name">netboot_info_init</span>(<span class="enscript-type">struct</span> in_addr iaddr)
{
    boolean_t			have_root_path = FALSE;
    <span class="enscript-type">struct</span> netboot_info *	info = NULL;
    <span class="enscript-type">char</span> * 			root_path = NULL;

    info = (<span class="enscript-type">struct</span> netboot_info *)kalloc(<span class="enscript-keyword">sizeof</span>(*info));
    bzero(info, <span class="enscript-keyword">sizeof</span>(*info));
    info-&gt;client_ip = iaddr;
    info-&gt;image_type = kNetBootImageTypeUnknown;

    <span class="enscript-comment">/* check for a booter-specified path then a NetBoot path */</span>
    MALLOC_ZONE(root_path, caddr_t, MAXPATHLEN, M_NAMEI, M_WAITOK);
    <span class="enscript-keyword">if</span> (root_path  == NULL)
    	panic(<span class="enscript-string">&quot;netboot_info_init: M_NAMEI zone exhausted&quot;</span>);
    <span class="enscript-keyword">if</span> (PE_parse_boot_argn(<span class="enscript-string">&quot;rp0&quot;</span>, root_path, MAXPATHLEN) == TRUE
	|| PE_parse_boot_argn(<span class="enscript-string">&quot;rp&quot;</span>, root_path, MAXPATHLEN) == TRUE
	|| PE_parse_boot_argn(<span class="enscript-string">&quot;rootpath&quot;</span>, root_path, MAXPATHLEN) == TRUE) {
	<span class="enscript-keyword">if</span> (imageboot_format_is_valid(root_path)) {
	    printf(<span class="enscript-string">&quot;netboot_info_init: rp0='%s' isn't a network path,&quot;</span>
		   <span class="enscript-string">&quot; ignoring\n&quot;</span>, root_path);
	}
	<span class="enscript-keyword">else</span> {
	    have_root_path = TRUE;
	}
    }
    <span class="enscript-keyword">if</span> (have_root_path == FALSE) {
	have_root_path = get_root_path(root_path);
    }
    <span class="enscript-keyword">if</span> (have_root_path) {
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> * server_name = NULL;
	<span class="enscript-type">char</span> * mount_point = NULL;
	<span class="enscript-type">char</span> * image_path = NULL;
	<span class="enscript-type">struct</span> in_addr 	server_ip;

	<span class="enscript-keyword">if</span> (parse_image_path(root_path, &amp;server_ip, &amp;server_name, 
			     &amp;mount_point, &amp;image_path)) {
	    info-&gt;image_type = kNetBootImageTypeNFS;
	    info-&gt;server_ip = server_ip;
	    info-&gt;server_name_length = strlen(server_name) + 1;
	    info-&gt;server_name = (<span class="enscript-type">char</span> *)kalloc(info-&gt;server_name_length);
	    info-&gt;mount_point_length = strlen(mount_point) + 1;
	    info-&gt;mount_point = (<span class="enscript-type">char</span> *)kalloc(info-&gt;mount_point_length);
	    strlcpy(info-&gt;server_name, server_name, info-&gt;server_name_length);
	    strlcpy(info-&gt;mount_point, mount_point, info-&gt;mount_point_length);
	    
	    printf(<span class="enscript-string">&quot;netboot: NFS Server %s Mount %s&quot;</span>, 
		   server_name, info-&gt;mount_point);
	    <span class="enscript-keyword">if</span> (image_path != NULL) {
		boolean_t 	needs_slash = FALSE;
		
		info-&gt;image_path_length = strlen(image_path) + 1;
		<span class="enscript-keyword">if</span> (image_path[0] != <span class="enscript-string">'/'</span>) {
		    needs_slash = TRUE;
		    info-&gt;image_path_length++;
		}
		info-&gt;image_path = (<span class="enscript-type">char</span> *)kalloc(info-&gt;image_path_length);
		<span class="enscript-keyword">if</span> (needs_slash) {
			info-&gt;image_path[0] = <span class="enscript-string">'/'</span>;
			strlcpy(info-&gt;image_path + 1, image_path,
					info-&gt;image_path_length - 1);
		} <span class="enscript-keyword">else</span> {
			strlcpy(info-&gt;image_path, image_path,
					info-&gt;image_path_length);
		}
		printf(<span class="enscript-string">&quot; Image %s&quot;</span>, info-&gt;image_path);
	    }
	    printf(<span class="enscript-string">&quot;\n&quot;</span>);
	}
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (strncmp(root_path, kNetBootRootPathPrefixHTTP, 
			 strlen(kNetBootRootPathPrefixHTTP)) == 0) {
	    info-&gt;image_type = kNetBootImageTypeHTTP;
	    save_path(&amp;info-&gt;image_path, &amp;info-&gt;image_path_length,
		      root_path);
	    printf(<span class="enscript-string">&quot;netboot: HTTP URL %s\n&quot;</span>,  info-&gt;image_path);
	}	    
	<span class="enscript-keyword">else</span> {
	    printf(<span class="enscript-string">&quot;netboot: root path uses unrecognized format\n&quot;</span>);
	}

	<span class="enscript-comment">/* check for image-within-image */</span>
	<span class="enscript-keyword">if</span> (info-&gt;image_path != NULL) {
		<span class="enscript-keyword">if</span> (PE_parse_boot_argn(IMAGEBOOT_ROOT_ARG, root_path, MAXPATHLEN)
			|| PE_parse_boot_argn(<span class="enscript-string">&quot;rp1&quot;</span>, root_path, MAXPATHLEN)) {
			<span class="enscript-comment">/* rp1/root-dmg is the second-level image */</span>
			save_path(&amp;info-&gt;second_image_path, &amp;info-&gt;second_image_path_length, 
					root_path);
		}
	}
	<span class="enscript-keyword">if</span> (info-&gt;second_image_path != NULL) {
		printf(<span class="enscript-string">&quot;netboot: nested image %s\n&quot;</span>, info-&gt;second_image_path);
	}
    }
    FREE_ZONE(root_path, MAXPATHLEN, M_NAMEI);
    <span class="enscript-keyword">return</span> (info);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> 
<span class="enscript-function-name">netboot_info_free</span>(<span class="enscript-type">struct</span> netboot_info * * info_p)
{
    <span class="enscript-type">struct</span> netboot_info * info = *info_p;

    <span class="enscript-keyword">if</span> (info) {
	<span class="enscript-keyword">if</span> (info-&gt;mount_point) {
	    kfree(info-&gt;mount_point, info-&gt;mount_point_length);
	}
	<span class="enscript-keyword">if</span> (info-&gt;server_name) {
	    kfree(info-&gt;server_name, info-&gt;server_name_length);
	}
	<span class="enscript-keyword">if</span> (info-&gt;image_path) {
	    kfree(info-&gt;image_path, info-&gt;image_path_length);
	}
	<span class="enscript-keyword">if</span> (info-&gt;second_image_path) {
	    kfree(info-&gt;second_image_path, info-&gt;second_image_path_length);
	}
	kfree(info, <span class="enscript-keyword">sizeof</span>(*info));
    }
    *info_p = NULL;
    <span class="enscript-keyword">return</span>;
}

boolean_t
<span class="enscript-function-name">netboot_iaddr</span>(<span class="enscript-type">struct</span> in_addr * iaddr_p)
{
    <span class="enscript-keyword">if</span> (S_netboot_info_p == NULL)
	<span class="enscript-keyword">return</span> (FALSE);

    *iaddr_p = S_netboot_info_p-&gt;client_ip;
    <span class="enscript-keyword">return</span> (TRUE);
}

boolean_t
<span class="enscript-function-name">netboot_rootpath</span>(<span class="enscript-type">struct</span> in_addr * server_ip,
		 <span class="enscript-type">char</span> * name, <span class="enscript-type">int</span> name_len, 
		 <span class="enscript-type">char</span> * path, <span class="enscript-type">int</span> path_len)
{
    <span class="enscript-keyword">if</span> (S_netboot_info_p == NULL)
	<span class="enscript-keyword">return</span> (FALSE);

    name[0] = <span class="enscript-string">'\0'</span>;
    path[0] = <span class="enscript-string">'\0'</span>;

    <span class="enscript-keyword">if</span> (S_netboot_info_p-&gt;mount_point_length == 0) {
	<span class="enscript-keyword">return</span> (FALSE);
    }
    <span class="enscript-keyword">if</span> (path_len &lt; S_netboot_info_p-&gt;mount_point_length) {
	printf(<span class="enscript-string">&quot;netboot: path too small %d &lt; %d\n&quot;</span>,
	       path_len, S_netboot_info_p-&gt;mount_point_length);
	<span class="enscript-keyword">return</span> (FALSE);
    }
    strlcpy(path, S_netboot_info_p-&gt;mount_point, path_len);
    strlcpy(name, S_netboot_info_p-&gt;server_name, name_len);
    *server_ip = S_netboot_info_p-&gt;server_ip;
    <span class="enscript-keyword">return</span> (TRUE);
}


<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">get_ip_parameters</span>(<span class="enscript-type">struct</span> in_addr * iaddr_p, <span class="enscript-type">struct</span> in_addr * netmask_p, 
		   <span class="enscript-type">struct</span> in_addr * router_p)
{
    <span class="enscript-type">void</span> *		entry;
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> *	pkt;
    <span class="enscript-type">int</span>			pkt_len;


    entry = IOBSDRegistryEntryForDeviceTree(<span class="enscript-string">&quot;/chosen&quot;</span>);
    <span class="enscript-keyword">if</span> (entry == NULL) {
	<span class="enscript-keyword">return</span> (FALSE);
    }
    pkt = IOBSDRegistryEntryGetData(entry, DHCP_RESPONSE, &amp;pkt_len);
    <span class="enscript-keyword">if</span> (pkt != NULL &amp;&amp; pkt_len &gt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> dhcp)) {
	printf(<span class="enscript-string">&quot;netboot: retrieving IP information from DHCP response\n&quot;</span>);
    }
    <span class="enscript-keyword">else</span> {
	pkt = IOBSDRegistryEntryGetData(entry, BOOTP_RESPONSE, &amp;pkt_len);
	<span class="enscript-keyword">if</span> (pkt != NULL &amp;&amp; pkt_len &gt;= (<span class="enscript-type">int</span>)<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> dhcp)) {
	    printf(<span class="enscript-string">&quot;netboot: retrieving IP information from BOOTP response\n&quot;</span>);
	}
    }
    <span class="enscript-keyword">if</span> (pkt != NULL) {
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_addr *	ip;
	<span class="enscript-type">int</span>			len;
	dhcpol_t 		options;
	<span class="enscript-type">const</span> <span class="enscript-type">struct</span> dhcp *	reply;

	reply = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> dhcp *)pkt;
	(<span class="enscript-type">void</span>)dhcpol_parse_packet(&amp;options, reply, pkt_len);
	*iaddr_p = reply-&gt;dp_yiaddr;
	ip = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_addr *)
	    dhcpol_find(&amp;options, 
			dhcptag_subnet_mask_e, &amp;len, NULL);
	<span class="enscript-keyword">if</span> (ip) {
	    *netmask_p = *ip;
	}
	ip = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_addr *)
	    dhcpol_find(&amp;options, dhcptag_router_e, &amp;len, NULL);
	<span class="enscript-keyword">if</span> (ip) {
	    *router_p = *ip;
	}
    }
    IOBSDRegistryEntryRelease(entry);
    <span class="enscript-keyword">return</span> (pkt != NULL);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">route_cmd</span>(<span class="enscript-type">int</span> cmd, <span class="enscript-type">struct</span> in_addr d, <span class="enscript-type">struct</span> in_addr g, 
	  <span class="enscript-type">struct</span> in_addr m, uint32_t more_flags, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
    <span class="enscript-type">struct</span> sockaddr_in 		dst;
    <span class="enscript-type">int</span>				error;
    uint32_t			flags = RTF_UP | RTF_STATIC;
    <span class="enscript-type">struct</span> sockaddr_in		gw;
    <span class="enscript-type">struct</span> sockaddr_in		mask;
    
    flags |= more_flags;

    <span class="enscript-comment">/* destination */</span>
    bzero((caddr_t)&amp;dst, <span class="enscript-keyword">sizeof</span>(dst));
    dst.sin_len = <span class="enscript-keyword">sizeof</span>(dst);
    dst.sin_family = AF_INET;
    dst.sin_addr = d;

    <span class="enscript-comment">/* gateway */</span>
    bzero((caddr_t)&amp;gw, <span class="enscript-keyword">sizeof</span>(gw));
    gw.sin_len = <span class="enscript-keyword">sizeof</span>(gw);
    gw.sin_family = AF_INET;
    gw.sin_addr = g;

    <span class="enscript-comment">/* mask */</span>
    bzero(&amp;mask, <span class="enscript-keyword">sizeof</span>(mask));
    mask.sin_len = <span class="enscript-keyword">sizeof</span>(mask);
    mask.sin_family = AF_INET;
    mask.sin_addr = m;

    error = rtrequest_scoped(cmd, (<span class="enscript-type">struct</span> sockaddr *)&amp;dst,
        (<span class="enscript-type">struct</span> sockaddr *)&amp;gw, (<span class="enscript-type">struct</span> sockaddr *)&amp;mask, flags, NULL, ifscope);

    <span class="enscript-keyword">return</span> (error);

}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">default_route_add</span>(<span class="enscript-type">struct</span> in_addr router, boolean_t proxy_arp)
{
    uint32_t			flags = 0;
    <span class="enscript-type">struct</span> in_addr		zeroes = { 0 };
    
    <span class="enscript-keyword">if</span> (proxy_arp == FALSE) {
	flags |= RTF_GATEWAY;
    }
    <span class="enscript-keyword">return</span> (route_cmd(RTM_ADD, zeroes, router, zeroes, flags, IFSCOPE_NONE));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">host_route_delete</span>(<span class="enscript-type">struct</span> in_addr host, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ifscope)
{
    <span class="enscript-type">struct</span> in_addr		zeroes = { 0 };
    
    <span class="enscript-keyword">return</span> (route_cmd(RTM_DELETE, host, zeroes, zeroes, RTF_HOST, ifscope));
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ifnet *
<span class="enscript-function-name">find_interface</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">struct</span> ifnet *		ifp = NULL;

    dlil_if_lock();
    <span class="enscript-keyword">if</span> (rootdevice[0]) {
		ifp = ifunit((<span class="enscript-type">char</span> *)rootdevice);
    }
    <span class="enscript-keyword">if</span> (ifp == NULL) {
		ifnet_head_lock_shared();
		TAILQ_FOREACH(ifp, &amp;ifnet_head, if_link)
			<span class="enscript-keyword">if</span> ((ifp-&gt;if_flags &amp; (IFF_LOOPBACK|IFF_POINTOPOINT)) == 0)
				<span class="enscript-keyword">break</span>;
		ifnet_head_done();
    }
    dlil_if_unlock();
    <span class="enscript-keyword">return</span> (ifp);
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> <span class="enscript-type">struct</span> sockaddr_in blank_sin = {
    <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> sockaddr_in),
    AF_INET,
    0,
    { 0 },
    { 0, 0, 0, 0, 0, 0, 0, 0 }
};

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">inet_aifaddr</span>(<span class="enscript-type">struct</span> socket * so, <span class="enscript-type">const</span> <span class="enscript-type">char</span> * name,
	     <span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_addr * addr,
	     <span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_addr * mask,
	     <span class="enscript-type">const</span> <span class="enscript-type">struct</span> in_addr * broadcast)
{
    <span class="enscript-type">struct</span> ifaliasreq	ifra;

    bzero(&amp;ifra, <span class="enscript-keyword">sizeof</span>(ifra));
    strlcpy(ifra.ifra_name, name, <span class="enscript-keyword">sizeof</span>(ifra.ifra_name));
    <span class="enscript-keyword">if</span> (addr) {
	*((<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)&amp;ifra.ifra_addr) = blank_sin;
	((<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)&amp;ifra.ifra_addr)-&gt;sin_addr = *addr;
    }
    <span class="enscript-keyword">if</span> (mask) {
	*((<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)&amp;ifra.ifra_mask) = blank_sin;
	((<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)&amp;ifra.ifra_mask)-&gt;sin_addr = *mask;
    }
    <span class="enscript-keyword">if</span> (broadcast) {
	*((<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)&amp;ifra.ifra_broadaddr) = blank_sin;
	((<span class="enscript-type">struct</span> sockaddr_in *)(<span class="enscript-type">void</span> *)&amp;ifra.ifra_broadaddr)-&gt;sin_addr = *broadcast;
    }
    <span class="enscript-keyword">return</span> (ifioctl(so, SIOCAIFADDR, (caddr_t)&amp;ifra, current_proc()));
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">netboot_mountroot</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span> 			error = 0;
    <span class="enscript-type">struct</span> in_addr 		iaddr = { 0 };
    <span class="enscript-type">struct</span> ifreq 		ifr;
    <span class="enscript-type">struct</span> ifnet *		ifp;
    <span class="enscript-type">struct</span> in_addr		netmask = { 0 };
    proc_t			procp = current_proc();
    <span class="enscript-type">struct</span> in_addr		router = { 0 };
    <span class="enscript-type">struct</span> socket *		so = NULL;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>		try;

    bzero(&amp;ifr, <span class="enscript-keyword">sizeof</span>(ifr));

    <span class="enscript-comment">/* find the interface */</span>
    ifp = find_interface();
    <span class="enscript-keyword">if</span> (ifp == NULL) {
	printf(<span class="enscript-string">&quot;netboot: no suitable interface\n&quot;</span>);
	error = ENXIO;
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    snprintf(ifr.ifr_name, <span class="enscript-keyword">sizeof</span>(ifr.ifr_name), <span class="enscript-string">&quot;%s&quot;</span>, if_name(ifp));
    printf(<span class="enscript-string">&quot;netboot: using network interface '%s'\n&quot;</span>, ifr.ifr_name);

    <span class="enscript-comment">/* bring it up */</span>
    <span class="enscript-keyword">if</span> ((error = socreate(AF_INET, &amp;so, SOCK_DGRAM, 0)) != 0) {
	printf(<span class="enscript-string">&quot;netboot: socreate, error=%d\n&quot;</span>, error);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    ifr.ifr_flags = ifp-&gt;if_flags | IFF_UP;
    error = ifioctl(so, SIOCSIFFLAGS, (caddr_t)&amp;ifr, procp);
    <span class="enscript-keyword">if</span> (error) {
	printf(<span class="enscript-string">&quot;netboot: SIFFLAGS, error=%d\n&quot;</span>, error);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }

    <span class="enscript-comment">/* grab information from the registry */</span>
    <span class="enscript-keyword">if</span> (get_ip_parameters(&amp;iaddr, &amp;netmask, &amp;router) == FALSE) {
	printf(<span class="enscript-string">&quot;netboot: can't retrieve IP parameters\n&quot;</span>);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    printf(<span class="enscript-string">&quot;netboot: IP address &quot;</span> IP_FORMAT, IP_LIST(&amp;iaddr));
    <span class="enscript-keyword">if</span> (netmask.s_addr) {
	printf(<span class="enscript-string">&quot; netmask &quot;</span> IP_FORMAT, IP_LIST(&amp;netmask));
    }
    <span class="enscript-keyword">if</span> (router.s_addr) {
	printf(<span class="enscript-string">&quot; router &quot;</span> IP_FORMAT, IP_LIST(&amp;router));
    }
    printf(<span class="enscript-string">&quot;\n&quot;</span>);
    error = inet_aifaddr(so, ifr.ifr_name, &amp;iaddr, &amp;netmask, NULL);
    <span class="enscript-keyword">if</span> (error) {
	printf(<span class="enscript-string">&quot;netboot: inet_aifaddr failed, %d\n&quot;</span>, error);
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">failed</span>;
    }
    <span class="enscript-keyword">if</span> (router.s_addr == 0) {
	<span class="enscript-comment">/* enable proxy arp if we don't have a router */</span>
	router.s_addr = iaddr.s_addr;
    }
    printf(<span class="enscript-string">&quot;netboot: adding default route &quot;</span> IP_FORMAT <span class="enscript-string">&quot;\n&quot;</span>, 
	   IP_LIST(&amp;router));
    error = default_route_add(router, router.s_addr == iaddr.s_addr);
    <span class="enscript-keyword">if</span> (error) {
	printf(<span class="enscript-string">&quot;netboot: default_route_add failed %d\n&quot;</span>, error);
    }

    soclose(so);

    S_netboot_info_p = netboot_info_init(iaddr);
    <span class="enscript-keyword">switch</span> (S_netboot_info_p-&gt;image_type) {
    <span class="enscript-reference">default</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kNetBootImageTypeNFS</span>:
	<span class="enscript-keyword">for</span> (try = 1; TRUE; try++) {
	    error = nfs_mountroot();
	    <span class="enscript-keyword">if</span> (error == 0) {
		<span class="enscript-keyword">break</span>;
	    }
	    printf(<span class="enscript-string">&quot;netboot: nfs_mountroot() attempt %u failed; &quot;</span>
		   <span class="enscript-string">&quot;clearing ARP entry and trying again\n&quot;</span>, try);
	    <span class="enscript-comment">/* 
	     * error is either EHOSTDOWN or EHOSTUNREACH, which likely means
	     * that the port we're plugged into has spanning tree enabled,
	     * and either the router or the server can't answer our ARP
	     * requests.  Clear the incomplete ARP entry by removing the
	     * appropriate route, depending on the error code:
	     *     EHOSTDOWN		NFS server's route
	     *     EHOSTUNREACH		router's route
	     */</span>
	    <span class="enscript-keyword">switch</span> (error) {
	    <span class="enscript-reference">default</span>:
		<span class="enscript-comment">/* NOT REACHED */</span>
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTDOWN</span>:
		<span class="enscript-comment">/* remove the server's arp entry */</span>
		error = host_route_delete(S_netboot_info_p-&gt;server_ip,
					  ifp-&gt;if_index);
		<span class="enscript-keyword">if</span> (error) {
		    printf(<span class="enscript-string">&quot;netboot: host_route_delete(&quot;</span> IP_FORMAT
			   <span class="enscript-string">&quot;) failed %d\n&quot;</span>, 
			   IP_LIST(&amp;S_netboot_info_p-&gt;server_ip), error);
		}
		<span class="enscript-keyword">break</span>;
	    <span class="enscript-keyword">case</span> <span class="enscript-reference">EHOSTUNREACH</span>:
		error = host_route_delete(router, ifp-&gt;if_index);
		<span class="enscript-keyword">if</span> (error) {
		    printf(<span class="enscript-string">&quot;netboot: host_route_delete(&quot;</span> IP_FORMAT
			   <span class="enscript-string">&quot;) failed %d\n&quot;</span>, IP_LIST(&amp;router), error);
		}
		<span class="enscript-keyword">break</span>;
	    }
	}
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kNetBootImageTypeHTTP</span>:
	error = netboot_setup();
	<span class="enscript-keyword">break</span>;
    }
    <span class="enscript-keyword">if</span> (error == 0) {
	S_netboot = 1;
    }
    <span class="enscript-keyword">else</span> {
	S_netboot = 0;
    }
    <span class="enscript-keyword">return</span> (error);
<span class="enscript-reference">failed</span>:
    <span class="enscript-keyword">if</span> (so != NULL) {
	soclose(so);
    }
    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">netboot_setup</span>()
{
    <span class="enscript-type">int</span> 	error = 0;

    <span class="enscript-keyword">if</span> (S_netboot_info_p == NULL
	|| S_netboot_info_p-&gt;image_path == NULL) {
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
    }
    printf(<span class="enscript-string">&quot;netboot_setup: calling imageboot_mount_image\n&quot;</span>);
    error = imageboot_mount_image(S_netboot_info_p-&gt;image_path, -1);
    <span class="enscript-keyword">if</span> (error != 0) {
	printf(<span class="enscript-string">&quot;netboot: failed to mount root image, %d\n&quot;</span>, error);
    }
    <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (S_netboot_info_p-&gt;second_image_path != NULL) {
	error = imageboot_mount_image(S_netboot_info_p-&gt;second_image_path, 0);
	<span class="enscript-keyword">if</span> (error != 0) {
	    printf(<span class="enscript-string">&quot;netboot: failed to mount second root image, %d\n&quot;</span>, error);
	}
    }

 <span class="enscript-reference">done</span>:
    netboot_info_free(&amp;S_netboot_info_p);
    <span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">netboot_root</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> (S_netboot);
}
</pre>
<hr />
</body></html>