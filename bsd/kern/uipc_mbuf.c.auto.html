<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>uipc_mbuf.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">uipc_mbuf.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="?txt">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * Copyright (c) 1998-2014 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 *
 * Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */</span>
<span class="enscript-comment">/* Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved */</span>
<span class="enscript-comment">/*
 * Copyright (c) 1982, 1986, 1988, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@(#)uipc_mbuf.c	8.2 (Berkeley) 1/4/94
 */</span>
<span class="enscript-comment">/*
 * NOTICE: This file was modified by SPARTA, Inc. in 2005 to introduce
 * support for mandatory and extensible security protections.  This notice
 * is included in support of clause 2.2 (b) of the Apple Public License,
 * Version 2.0.
 */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/param.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/systm.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/malloc.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mbuf.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/kernel.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/sysctl.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/syslog.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/protosw.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/domain.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/proc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dev/random/randomdev.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/kern_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/simple_lock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/queue.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/sched_prim.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/cpu_number.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;kern/zalloc.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSAtomic.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/OSDebug.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;libkern/libkern.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;IOKit/IOMapper.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/limits.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;machine/machine_routines.h&gt;</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;security/mac_framework.h&gt;</span>
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_NET */</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;sys/mcache.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;net/ntstat.h&gt;</span>

<span class="enscript-comment">/*
 * MBUF IMPLEMENTATION NOTES.
 *
 * There is a total of 5 per-CPU caches:
 *
 * MC_MBUF:
 *	This is a cache of rudimentary objects of MSIZE in size; each
 *	object represents an mbuf structure.  This cache preserves only
 *	the m_type field of the mbuf during its transactions.
 *
 * MC_CL:
 *	This is a cache of rudimentary objects of MCLBYTES in size; each
 *	object represents a mcluster structure.  This cache does not
 *	preserve the contents of the objects during its transactions.
 *
 * MC_BIGCL:
 *	This is a cache of rudimentary objects of MBIGCLBYTES in size; each
 *	object represents a mbigcluster structure.  This cache does not
 *	preserve the contents of the objects during its transaction.
 *
 * MC_MBUF_CL:
 *	This is a cache of mbufs each having a cluster attached to it.
 *	It is backed by MC_MBUF and MC_CL rudimentary caches.  Several
 *	fields of the mbuf related to the external cluster are preserved
 *	during transactions.
 *
 * MC_MBUF_BIGCL:
 *	This is a cache of mbufs each having a big cluster attached to it.
 *	It is backed by MC_MBUF and MC_BIGCL rudimentary caches.  Several
 *	fields of the mbuf related to the external cluster are preserved
 *	during transactions.
 *
 * OBJECT ALLOCATION:
 *
 * Allocation requests are handled first at the per-CPU (mcache) layer
 * before falling back to the slab layer.  Performance is optimal when
 * the request is satisfied at the CPU layer because global data/lock
 * never gets accessed.  When the slab layer is entered for allocation,
 * the slab freelist will be checked first for available objects before
 * the VM backing store is invoked.  Slab layer operations are serialized
 * for all of the caches as the mbuf global lock is held most of the time.
 * Allocation paths are different depending on the class of objects:
 *
 * a. Rudimentary object:
 *
 *	{ m_get_common(), m_clattach(), m_mclget(),
 *	  m_mclalloc(), m_bigalloc(), m_copym_with_hdrs(),
 *	  composite object allocation }
 *			|	^
 *			|	|
 *			|	+-----------------------+
 *			v				|
 *	   mcache_alloc/mcache_alloc_ext()	mbuf_slab_audit()
 *			|				^
 *			v				|
 *		   [CPU cache] -------&gt;	(found?) -------+
 *			|				|
 *			v				|
 *		 mbuf_slab_alloc()			|
 *			|				|
 *			v				|
 *	+---------&gt; [freelist] -------&gt;	(found?) -------+
 *	|		|
 *	|		v
 *	|	    m_clalloc()
 *	|		|
 *	|		v
 *	+---&lt;&lt;---- kmem_mb_alloc()
 *
 * b. Composite object:
 *
 *	{ m_getpackets_internal(), m_allocpacket_internal() }
 *			|	^
 *			|	|
 *			|	+------	(done) ---------+
 *			v				|
 *	   mcache_alloc/mcache_alloc_ext()	mbuf_cslab_audit()
 *			|				^
 *			v				|
 *		   [CPU cache] -------&gt;	(found?) -------+
 *			|				|
 *			v				|
 *		 mbuf_cslab_alloc()			|
 *			|				|
 *			v				|
 *		    [freelist] -------&gt;	(found?) -------+
 *			|				|
 *			v				|
 *		(rudimentary object)			|
 *	   mcache_alloc/mcache_alloc_ext() ------&gt;&gt;-----+
 *
 * Auditing notes: If auditing is enabled, buffers will be subjected to
 * integrity checks by the audit routine.  This is done by verifying their
 * contents against DEADBEEF (free) pattern before returning them to caller.
 * As part of this step, the routine will also record the transaction and
 * pattern-fill the buffers with BADDCAFE (uninitialized) pattern.  It will
 * also restore any constructed data structure fields if necessary.
 *
 * OBJECT DEALLOCATION:
 *
 * Freeing an object simply involves placing it into the CPU cache; this
 * pollutes the cache to benefit subsequent allocations.  The slab layer
 * will only be entered if the object is to be purged out of the cache.
 * During normal operations, this happens only when the CPU layer resizes
 * its bucket while it's adjusting to the allocation load.  Deallocation
 * paths are different depending on the class of objects:
 *
 * a. Rudimentary object:
 *
 *	{ m_free(), m_freem_list(), composite object deallocation }
 *			|	^
 *			|	|
 *			|	+------	(done) ---------+
 *			v				|
 *	   mcache_free/mcache_free_ext()		|
 *			|				|
 *			v				|
 *		mbuf_slab_audit()			|
 *			|				|
 *			v				|
 *		   [CPU cache] ---&gt; (not purging?) -----+
 *			|				|
 *			v				|
 *		 mbuf_slab_free()			|
 *			|				|
 *			v				|
 *		    [freelist] -----------&gt;&gt;------------+
 *	 (objects get purged to VM only on demand)
 *
 * b. Composite object:
 *
 *	{ m_free(), m_freem_list() }
 *			|	^
 *			|	|
 *			|	+------	(done) ---------+
 *			v				|
 *	   mcache_free/mcache_free_ext()		|
 *			|				|
 *			v				|
 *		mbuf_cslab_audit()			|
 *			|				|
 *			v				|
 *		   [CPU cache] ---&gt; (not purging?) -----+
 *			|				|
 *			v				|
 *		 mbuf_cslab_free()			|
 *			|				|
 *			v				|
 *		    [freelist] ---&gt; (not purging?) -----+
 *			|				|
 *			v				|
 *		(rudimentary object)			|
 *	   mcache_free/mcache_free_ext() -------&gt;&gt;------+
 *
 * Auditing notes: If auditing is enabled, the audit routine will save
 * any constructed data structure fields (if necessary) before filling the
 * contents of the buffers with DEADBEEF (free) pattern and recording the
 * transaction.  Buffers that are freed (whether at CPU or slab layer) are
 * expected to contain the free pattern.
 *
 * DEBUGGING:
 *
 * Debugging can be enabled by adding &quot;mbuf_debug=0x3&quot; to boot-args; this
 * translates to the mcache flags (MCF_VERIFY | MCF_AUDIT).  Additionally,
 * the CPU layer cache can be disabled by setting the MCF_NOCPUCACHE flag,
 * i.e. modify the boot argument parameter to &quot;mbuf_debug=0x13&quot;.  Leak
 * detection may also be disabled by setting the MCF_NOLEAKLOG flag, e.g.
 * &quot;mbuf_debug=0x113&quot;.  Note that debugging consumes more CPU and memory.
 *
 * Each object is associated with exactly one mcache_audit_t structure that
 * contains the information related to its last buffer transaction.  Given
 * an address of an object, the audit structure can be retrieved by finding
 * the position of the object relevant to the base address of the cluster:
 *
 *	+------------+			+=============+
 *	| mbuf addr  |			| mclaudit[i] |
 *	+------------+			+=============+
 *	      |				| cl_audit[0] |
 *	i = MTOBG(addr)			+-------------+
 *	      |			+-----&gt;	| cl_audit[1] | -----&gt; mcache_audit_t
 *	b = BGTOM(i)		|	+-------------+
 *	      |			|	|     ...     |
 *	x = MCLIDX(b, addr)	|	+-------------+
 *	      |			|	| cl_audit[7] |
 *	      +-----------------+	+-------------+
 *		 (e.g. x == 1)
 *
 * The mclaudit[] array is allocated at initialization time, but its contents
 * get populated when the corresponding cluster is created.  Because a page
 * can be turned into NMBPG number of mbufs, we preserve enough space for the
 * mbufs so that there is a 1-to-1 mapping between them.  A page that never
 * gets (or has not yet) turned into mbufs will use only cl_audit[0] with the
 * remaining entries unused.  For 16KB cluster, only one entry from the first
 * page is allocated and used for the entire object.
 */</span>

<span class="enscript-comment">/* TODO: should be in header file */</span>
<span class="enscript-comment">/* kernel translater */</span>
<span class="enscript-type">extern</span> vm_offset_t <span class="enscript-function-name">kmem_mb_alloc</span>(vm_map_t, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">extern</span> ppnum_t <span class="enscript-function-name">pmap_find_phys</span>(pmap_t pmap, addr64_t va);
<span class="enscript-type">extern</span> vm_map_t mb_map;		<span class="enscript-comment">/* special map */</span>

<span class="enscript-comment">/* Global lock */</span>
<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, mbuf_mlock_data);
<span class="enscript-type">static</span> lck_mtx_t *mbuf_mlock = &amp;mbuf_mlock_data;
<span class="enscript-type">static</span> lck_attr_t *mbuf_mlock_attr;
<span class="enscript-type">static</span> lck_grp_t *mbuf_mlock_grp;
<span class="enscript-type">static</span> lck_grp_attr_t *mbuf_mlock_grp_attr;

<span class="enscript-comment">/* Back-end (common) layer */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *mbuf_worker_run;	<span class="enscript-comment">/* wait channel for worker thread */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> mbuf_worker_ready;	<span class="enscript-comment">/* worker thread is runnable */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> mbuf_expand_mcl;	<span class="enscript-comment">/* number of cluster creation requets */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> mbuf_expand_big;	<span class="enscript-comment">/* number of big cluster creation requests */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> mbuf_expand_16k;	<span class="enscript-comment">/* number of 16KB cluster creation requests */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> ncpu;		<span class="enscript-comment">/* number of CPUs */</span>
<span class="enscript-type">static</span> ppnum_t *mcl_paddr;	<span class="enscript-comment">/* Array of cluster physical addresses */</span>
<span class="enscript-type">static</span> ppnum_t mcl_pages;	<span class="enscript-comment">/* Size of array (# physical pages) */</span>
<span class="enscript-type">static</span> ppnum_t mcl_paddr_base;	<span class="enscript-comment">/* Handle returned by IOMapper::iovmAlloc() */</span>
<span class="enscript-type">static</span> mcache_t *ref_cache;	<span class="enscript-comment">/* Cache of cluster reference &amp; flags */</span>
<span class="enscript-type">static</span> mcache_t *mcl_audit_con_cache; <span class="enscript-comment">/* Audit contents cache */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mbuf_debug;	<span class="enscript-comment">/* patchable mbuf mcache flags */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mb_normalized; <span class="enscript-comment">/* number of packets &quot;normalized&quot; */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MB_GROWTH_AGGRESSIVE</span>	1	<span class="enscript-comment">/* Threshold: 1/2 of total */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MB_GROWTH_NORMAL</span>	2	<span class="enscript-comment">/* Threshold: 3/4 of total */</span>

<span class="enscript-type">typedef</span> <span class="enscript-type">enum</span> {
	MC_MBUF = 0,	<span class="enscript-comment">/* Regular mbuf */</span>
	MC_CL,		<span class="enscript-comment">/* Cluster */</span>
	MC_BIGCL,	<span class="enscript-comment">/* Large (4KB) cluster */</span>
	MC_16KCL,	<span class="enscript-comment">/* Jumbo (16KB) cluster */</span>
	MC_MBUF_CL,	<span class="enscript-comment">/* mbuf + cluster */</span>
	MC_MBUF_BIGCL,	<span class="enscript-comment">/* mbuf + large (4KB) cluster */</span>
	MC_MBUF_16KCL	<span class="enscript-comment">/* mbuf + jumbo (16KB) cluster */</span>
} mbuf_class_t;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MBUF_CLASS_MIN</span>		MC_MBUF
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MBUF_CLASS_MAX</span>		MC_MBUF_16KCL
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MBUF_CLASS_LAST</span>		MC_16KCL
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_CLASS_VALID</span>(c) \
	((<span class="enscript-type">int</span>)(c) &gt;= MBUF_CLASS_MIN &amp;&amp; (<span class="enscript-type">int</span>)(c) &lt;= MBUF_CLASS_MAX)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_CLASS_COMPOSITE</span>(c) \
	((<span class="enscript-type">int</span>)(c) &gt; MBUF_CLASS_LAST)


<span class="enscript-comment">/*
 * mbuf specific mcache allocation request flags.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCR_COMP</span>	MCR_USR1 <span class="enscript-comment">/* for MC_MBUF_{CL,BIGCL,16KCL} caches */</span>

<span class="enscript-comment">/*
 * Per-cluster slab structure.
 *
 * A slab is a cluster control structure that contains one or more object
 * chunks; the available chunks are chained in the slab's freelist (sl_head).
 * Each time a chunk is taken out of the slab, the slab's reference count
 * gets incremented.  When all chunks have been taken out, the empty slab
 * gets removed (SLF_DETACHED) from the class's slab list.  A chunk that is
 * returned to a slab causes the slab's reference count to be decremented;
 * it also causes the slab to be reinserted back to class's slab list, if
 * it's not already done.
 *
 * Compartmentalizing of the object chunks into slabs allows us to easily
 * merge one or more slabs together when the adjacent slabs are idle, as
 * well as to convert or move a slab from one class to another; e.g. the
 * mbuf cluster slab can be converted to a regular cluster slab when all
 * mbufs in the slab have been freed.
 *
 * A slab may also span across multiple clusters for chunks larger than
 * a cluster's size.  In this case, only the slab of the first cluster is
 * used.  The rest of the slabs are marked with SLF_PARTIAL to indicate
 * that they are part of the larger slab.
 *
 * Each slab controls a page of memory.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mcl_slab {
	<span class="enscript-type">struct</span> mcl_slab	*sl_next;	<span class="enscript-comment">/* neighboring slab */</span>
	u_int8_t	sl_class;	<span class="enscript-comment">/* controlling mbuf class */</span>
	int8_t		sl_refcnt;	<span class="enscript-comment">/* outstanding allocations */</span>
	int8_t		sl_chunks;	<span class="enscript-comment">/* chunks (bufs) in this slab */</span>
	u_int16_t	sl_flags;	<span class="enscript-comment">/* slab flags (see below) */</span>
	u_int16_t	sl_len;		<span class="enscript-comment">/* slab length */</span>
	<span class="enscript-type">void</span>		*sl_base;	<span class="enscript-comment">/* base of allocated memory */</span>
	<span class="enscript-type">void</span>		*sl_head;	<span class="enscript-comment">/* first free buffer */</span>
	TAILQ_ENTRY(mcl_slab) sl_link;	<span class="enscript-comment">/* next/prev slab on freelist */</span>
} mcl_slab_t;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SLF_MAPPED</span>	0x0001		<span class="enscript-comment">/* backed by a mapped page */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SLF_PARTIAL</span>	0x0002		<span class="enscript-comment">/* part of another slab */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">SLF_DETACHED</span>	0x0004		<span class="enscript-comment">/* not in slab freelist */</span>

<span class="enscript-comment">/*
 * The array of slabs are broken into groups of arrays per 1MB of kernel
 * memory to reduce the footprint.  Each group is allocated on demand
 * whenever a new piece of memory mapped in from the VM crosses the 1MB
 * boundary.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NSLABSPMB</span>	((1 &lt;&lt; MBSHIFT) &gt;&gt; PAGE_SHIFT)

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> mcl_slabg {
	mcl_slab_t	*slg_slab;	<span class="enscript-comment">/* group of slabs */</span>
} mcl_slabg_t;

<span class="enscript-comment">/*
 * Number of slabs needed to control a 16KB cluster object.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">NSLABSP16KB</span>	(M16KCLBYTES &gt;&gt; PAGE_SHIFT)

<span class="enscript-comment">/*
 * Per-cluster audit structure.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	mcache_audit_t	**cl_audit;	<span class="enscript-comment">/* array of audits */</span>
} mcl_audit_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	<span class="enscript-type">struct</span> thread	*msa_thread;	<span class="enscript-comment">/* thread doing transaction */</span>
	<span class="enscript-type">struct</span> thread	*msa_pthread;	<span class="enscript-comment">/* previous transaction thread */</span>
	uint32_t	msa_tstamp;	<span class="enscript-comment">/* transaction timestamp (ms) */</span>
	uint32_t	msa_ptstamp;	<span class="enscript-comment">/* prev transaction timestamp (ms) */</span>
	uint16_t	msa_depth;	<span class="enscript-comment">/* pc stack depth */</span>
	uint16_t	msa_pdepth;	<span class="enscript-comment">/* previous transaction pc stack */</span>
	<span class="enscript-type">void</span>		*msa_stack[MCACHE_STACK_DEPTH];
	<span class="enscript-type">void</span>		*msa_pstack[MCACHE_STACK_DEPTH];
} mcl_scratch_audit_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	<span class="enscript-comment">/*
	 * Size of data from the beginning of an mbuf that covers m_hdr,
	 * pkthdr and m_ext structures.  If auditing is enabled, we allocate
	 * a shadow mbuf structure of this size inside each audit structure,
	 * and the contents of the real mbuf gets copied into it when the mbuf
	 * is freed.  This allows us to pattern-fill the mbuf for integrity
	 * check, and to preserve any constructed mbuf fields (e.g. mbuf +
	 * cluster cache case).  Note that we don't save the contents of
	 * clusters when they are freed; we simply pattern-fill them.
	 */</span>
	u_int8_t		sc_mbuf[(MSIZE - _MHLEN) + <span class="enscript-keyword">sizeof</span> (_m_ext_t)];
	mcl_scratch_audit_t	sc_scratch __attribute__((aligned(8)));
} mcl_saved_contents_t;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">AUDIT_CONTENTS_SIZE</span>	(sizeof (mcl_saved_contents_t))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCA_SAVED_MBUF_PTR</span>(_mca)					\
	((<span class="enscript-type">struct</span> mbuf *)(<span class="enscript-type">void</span> *)((mcl_saved_contents_t *)		\
	(_mca)-&gt;mca_contents)-&gt;sc_mbuf)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MCA_SAVED_MBUF_SIZE</span>						\
	(<span class="enscript-keyword">sizeof</span> (((mcl_saved_contents_t *)0)-&gt;sc_mbuf))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MCA_SAVED_SCRATCH_PTR</span>(_mca)					\
	(&amp;((mcl_saved_contents_t *)(_mca)-&gt;mca_contents)-&gt;sc_scratch)

<span class="enscript-comment">/*
 * mbuf specific mcache audit flags
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MB_INUSE</span>	0x01	<span class="enscript-comment">/* object has not been returned to slab */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MB_COMP_INUSE</span>	0x02	<span class="enscript-comment">/* object has not been returned to cslab */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MB_SCVALID</span>	0x04	<span class="enscript-comment">/* object has valid saved contents */</span>

<span class="enscript-comment">/*
 * Each of the following two arrays hold up to nmbclusters elements.
 */</span>
<span class="enscript-type">static</span> mcl_audit_t *mclaudit;	<span class="enscript-comment">/* array of cluster audit information */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> maxclaudit;	<span class="enscript-comment">/* max # of entries in audit table */</span>
<span class="enscript-type">static</span> mcl_slabg_t **slabstbl;	<span class="enscript-comment">/* cluster slabs table */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> maxslabgrp;	<span class="enscript-comment">/* max # of entries in slabs table */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> slabgrp;	<span class="enscript-comment">/* # of entries in slabs table */</span>

<span class="enscript-comment">/* Globals */</span>
<span class="enscript-type">int</span> nclusters;			<span class="enscript-comment">/* # of clusters for non-jumbo (legacy) sizes */</span>
<span class="enscript-type">int</span> njcl;			<span class="enscript-comment">/* # of clusters for jumbo sizes */</span>
<span class="enscript-type">int</span> njclbytes;			<span class="enscript-comment">/* size of a jumbo cluster */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *mbutl;		<span class="enscript-comment">/* first mapped cluster address */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *embutl;		<span class="enscript-comment">/* ending virtual address of mclusters */</span>
<span class="enscript-type">int</span> _max_linkhdr;		<span class="enscript-comment">/* largest link-level header */</span>
<span class="enscript-type">int</span> _max_protohdr;		<span class="enscript-comment">/* largest protocol header */</span>
<span class="enscript-type">int</span> max_hdr;			<span class="enscript-comment">/* largest link+protocol header */</span>
<span class="enscript-type">int</span> max_datalen;		<span class="enscript-comment">/* MHLEN - max_hdr */</span>

<span class="enscript-type">static</span> boolean_t mclverify;	<span class="enscript-comment">/* debug: pattern-checking */</span>
<span class="enscript-type">static</span> boolean_t mcltrace;	<span class="enscript-comment">/* debug: stack tracing */</span>
<span class="enscript-type">static</span> boolean_t mclfindleak;	<span class="enscript-comment">/* debug: leak detection */</span>
<span class="enscript-type">static</span> boolean_t mclexpleak;	<span class="enscript-comment">/* debug: expose leak info to user space */</span>

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> timeval mb_start;	<span class="enscript-comment">/* beginning of time */</span>

<span class="enscript-comment">/* mbuf leak detection variables */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mleak_table mleak_table;
<span class="enscript-type">static</span> mleak_stat_t *mleak_stat;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MLEAK_STAT_SIZE</span>(n) \
	((size_t)(&amp;((mleak_stat_t *)0)-&gt;ml_trace[n]))

<span class="enscript-type">struct</span> mallocation {
	mcache_obj_t *element;	<span class="enscript-comment">/* the alloc'ed element, NULL if unused */</span>
	u_int32_t trace_index;	<span class="enscript-comment">/* mtrace index for corresponding backtrace */</span>
	u_int32_t count;	<span class="enscript-comment">/* How many objects were requested */</span>
	u_int64_t hitcount;	<span class="enscript-comment">/* for determining hash effectiveness */</span>
};

<span class="enscript-type">struct</span> mtrace {
	u_int64_t	collisions;
	u_int64_t	hitcount;
	u_int64_t	allocs;
	u_int64_t	depth;
	uintptr_t	addr[MLEAK_STACK_DEPTH];
};

<span class="enscript-comment">/* Size must be a power of two for the zhash to be able to just mask off bits */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MLEAK_ALLOCATION_MAP_NUM</span>	512
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MLEAK_TRACE_MAP_NUM</span>		256

<span class="enscript-comment">/*
 * Sample factor for how often to record a trace.  This is overwritable
 * by the boot-arg mleak_sample_factor.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MLEAK_SAMPLE_FACTOR</span>		500

<span class="enscript-comment">/*
 * Number of top leakers recorded.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MLEAK_NUM_TRACES</span>		5

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MB_LEAK_SPACING_64</span> <span class="enscript-string">&quot;                    &quot;</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MB_LEAK_SPACING_32</span> <span class="enscript-string">&quot;            &quot;</span>


#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MB_LEAK_HDR_32</span>	<span class="enscript-string">&quot;\n\
    trace [1]   trace [2]   trace [3]   trace [4]   trace [5]  \n\
    ----------  ----------  ----------  ----------  ---------- \n\
&quot;</span>

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MB_LEAK_HDR_64</span>	<span class="enscript-string">&quot;\n\
    trace [1]           trace [2]           trace [3]       \
        trace [4]           trace [5]      \n\
    ------------------  ------------------  ------------------  \
    ------------------  ------------------ \n\
&quot;</span>

<span class="enscript-type">static</span> uint32_t mleak_alloc_buckets = MLEAK_ALLOCATION_MAP_NUM;
<span class="enscript-type">static</span> uint32_t mleak_trace_buckets = MLEAK_TRACE_MAP_NUM;

<span class="enscript-comment">/* Hashmaps of allocations and their corresponding traces */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mallocation *mleak_allocations;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mtrace *mleak_traces;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mtrace *mleak_top_trace[MLEAK_NUM_TRACES];

<span class="enscript-comment">/* Lock to protect mleak tables from concurrent modification */</span>
<span class="enscript-function-name">decl_lck_mtx_data</span>(<span class="enscript-type">static</span>, mleak_lock_data);
<span class="enscript-type">static</span> lck_mtx_t *mleak_lock = &amp;mleak_lock_data;
<span class="enscript-type">static</span> lck_attr_t *mleak_lock_attr;
<span class="enscript-type">static</span> lck_grp_t *mleak_lock_grp;
<span class="enscript-type">static</span> lck_grp_attr_t *mleak_lock_grp_attr;

<span class="enscript-type">extern</span> u_int32_t high_sb_max;

<span class="enscript-comment">/* The minimum number of objects that are allocated, to start. */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MINCL</span>		32
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MINBIGCL</span>	(MINCL &gt;&gt; 1)
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MIN16KCL</span>	(MINCL &gt;&gt; 2)

<span class="enscript-comment">/* Low watermarks (only map in pages once free counts go below) */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MBIGCL_LOWAT</span>	MINBIGCL
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M16KCL_LOWAT</span>	MIN16KCL

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	mbuf_class_t	mtbl_class;	<span class="enscript-comment">/* class type */</span>
	mcache_t	*mtbl_cache;	<span class="enscript-comment">/* mcache for this buffer class */</span>
	TAILQ_HEAD(mcl_slhead, mcl_slab) mtbl_slablist; <span class="enscript-comment">/* slab list */</span>
	mcache_obj_t	*mtbl_cobjlist;	<span class="enscript-comment">/* composite objects freelist */</span>
	mb_class_stat_t	*mtbl_stats;	<span class="enscript-comment">/* statistics fetchable via sysctl */</span>
	u_int32_t	mtbl_maxsize;	<span class="enscript-comment">/* maximum buffer size */</span>
	<span class="enscript-type">int</span>		mtbl_minlimit;	<span class="enscript-comment">/* minimum allowed */</span>
	<span class="enscript-type">int</span>		mtbl_maxlimit;	<span class="enscript-comment">/* maximum allowed */</span>
	u_int32_t	mtbl_wantpurge;	<span class="enscript-comment">/* purge during next reclaim */</span>
	uint32_t	mtbl_avgtotal;  <span class="enscript-comment">/* average total on iOS */</span>
} mbuf_table_t;

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_class</span>(c)	mbuf_table[c].mtbl_class
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_cache</span>(c)	mbuf_table[c].mtbl_cache
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_slablist</span>(c)	mbuf_table[c].mtbl_slablist
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_cobjlist</span>(c)	mbuf_table[c].mtbl_cobjlist
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_maxsize</span>(c)	mbuf_table[c].mtbl_maxsize
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_minlimit</span>(c)	mbuf_table[c].mtbl_minlimit
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_maxlimit</span>(c)	mbuf_table[c].mtbl_maxlimit
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_wantpurge</span>(c)	mbuf_table[c].mtbl_wantpurge
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_avgtotal</span>(c)	mbuf_table[c].mtbl_avgtotal
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_cname</span>(c)	mbuf_table[c].mtbl_stats-&gt;mbcl_cname
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_size</span>(c)	mbuf_table[c].mtbl_stats-&gt;mbcl_size
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_total</span>(c)	mbuf_table[c].mtbl_stats-&gt;mbcl_total
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_active</span>(c)	mbuf_table[c].mtbl_stats-&gt;mbcl_active
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_infree</span>(c)	mbuf_table[c].mtbl_stats-&gt;mbcl_infree
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_slab_cnt</span>(c)	mbuf_table[c].mtbl_stats-&gt;mbcl_slab_cnt
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_alloc_cnt</span>(c)	mbuf_table[c].mtbl_stats-&gt;mbcl_alloc_cnt
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_free_cnt</span>(c)	mbuf_table[c].mtbl_stats-&gt;mbcl_free_cnt
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_notified</span>(c)	mbuf_table[c].mtbl_stats-&gt;mbcl_notified
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_purge_cnt</span>(c)	mbuf_table[c].mtbl_stats-&gt;mbcl_purge_cnt
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_fail_cnt</span>(c)	mbuf_table[c].mtbl_stats-&gt;mbcl_fail_cnt
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_ctotal</span>(c)	mbuf_table[c].mtbl_stats-&gt;mbcl_ctotal
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_peak</span>(c)	mbuf_table[c].mtbl_stats-&gt;mbcl_peak_reported
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">m_release_cnt</span>(c) mbuf_table[c].mtbl_stats-&gt;mbcl_release_cnt

<span class="enscript-type">static</span> mbuf_table_t mbuf_table[] = {
	<span class="enscript-comment">/*
	 * The caches for mbufs, regular clusters and big clusters.
	 * The average total values were based on data gathered by actual
	 * usage patterns on iOS.
	 */</span>
	{ MC_MBUF, NULL, TAILQ_HEAD_INITIALIZER(m_slablist(MC_MBUF)),
	    NULL, NULL, 0, 0, 0, 0, 3000 },
	{ MC_CL, NULL, TAILQ_HEAD_INITIALIZER(m_slablist(MC_CL)),
	    NULL, NULL, 0, 0, 0, 0, 2000 },
	{ MC_BIGCL, NULL, TAILQ_HEAD_INITIALIZER(m_slablist(MC_BIGCL)),
	    NULL, NULL, 0, 0, 0, 0, 1000 },
	{ MC_16KCL, NULL, TAILQ_HEAD_INITIALIZER(m_slablist(MC_16KCL)),
	    NULL, NULL, 0, 0, 0, 0, 1000 },
	<span class="enscript-comment">/*
	 * The following are special caches; they serve as intermediate
	 * caches backed by the above rudimentary caches.  Each object
	 * in the cache is an mbuf with a cluster attached to it.  Unlike
	 * the above caches, these intermediate caches do not directly
	 * deal with the slab structures; instead, the constructed
	 * cached elements are simply stored in the freelists.
	 */</span>
	{ MC_MBUF_CL, NULL, { NULL, NULL }, NULL, NULL, 0, 0, 0, 0, 2000 },
	{ MC_MBUF_BIGCL, NULL, { NULL, NULL }, NULL, NULL, 0, 0, 0, 0, 1000 },
	{ MC_MBUF_16KCL, NULL, { NULL, NULL }, NULL, NULL, 0, 0, 0, 0, 1000 },
};

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">NELEM</span>(a)	(sizeof (a) / sizeof ((a)[0]))

<span class="enscript-type">static</span> <span class="enscript-type">void</span> *mb_waitchan = &amp;mbuf_table;	<span class="enscript-comment">/* wait channel for all caches */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span> mb_waiters;			<span class="enscript-comment">/* number of waiters */</span>

boolean_t mb_peak_newreport = FALSE;
boolean_t mb_peak_firstreport = FALSE;

<span class="enscript-comment">/* generate a report by default after 1 week of uptime */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MBUF_PEAK_FIRST_REPORT_THRESHOLD</span>	604800

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MB_WDT_MAXTIME</span>	10		<span class="enscript-comment">/* # of secs before watchdog panic */</span>
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> timeval mb_wdtstart;	<span class="enscript-comment">/* watchdog start timestamp */</span>
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *mbuf_dump_buf;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MBUF_DUMP_BUF_SIZE</span>	2048

<span class="enscript-comment">/*
 * mbuf watchdog is enabled by default on embedded platforms.  It is
 * also toggeable via the kern.ipc.mb_watchdog sysctl.
 * Garbage collection is also enabled by default on embedded platforms.
 * mb_drain_maxint controls the amount of time to wait (in seconds) before
 * consecutive calls to m_drain().
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mb_watchdog = 0;
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> mb_drain_maxint = 0;

<span class="enscript-comment">/* Red zone */</span>
<span class="enscript-type">static</span> u_int32_t mb_redzone_cookie;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">m_redzone_init</span>(<span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">m_redzone_verify</span>(<span class="enscript-type">struct</span> mbuf *m);

<span class="enscript-comment">/* The following are used to serialize m_clalloc() */</span>
<span class="enscript-type">static</span> boolean_t mb_clalloc_busy;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> *mb_clalloc_waitchan = &amp;mb_clalloc_busy;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> mb_clalloc_waiters;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_mtypes_sync</span>(boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> mbstat_sysctl SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_stat_sync</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> mb_stat_sysctl SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> mleak_top_trace_sysctl SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">int</span> mleak_table_sysctl SYSCTL_HANDLER_ARGS;
<span class="enscript-type">static</span> <span class="enscript-type">char</span> *<span class="enscript-function-name">mbuf_dump</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_table_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> inline <span class="enscript-type">void</span> <span class="enscript-function-name">m_incref</span>(<span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> inline u_int32_t <span class="enscript-function-name">m_decref</span>(<span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">m_clalloc</span>(<span class="enscript-type">const</span> u_int32_t, <span class="enscript-type">const</span> <span class="enscript-type">int</span>, <span class="enscript-type">const</span> u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_worker_thread_init</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> mcache_obj_t *<span class="enscript-function-name">slab_alloc</span>(mbuf_class_t, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">slab_free</span>(mbuf_class_t, mcache_obj_t *);
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mbuf_slab_alloc</span>(<span class="enscript-type">void</span> *, mcache_obj_t ***,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_slab_free</span>(<span class="enscript-type">void</span> *, mcache_obj_t *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_slab_audit</span>(<span class="enscript-type">void</span> *, mcache_obj_t *, boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_slab_notify</span>(<span class="enscript-type">void</span> *, u_int32_t);
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cslab_alloc</span>(mbuf_class_t, mcache_obj_t ***,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">cslab_free</span>(mbuf_class_t, mcache_obj_t *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> <span class="enscript-function-name">mbuf_cslab_alloc</span>(<span class="enscript-type">void</span> *, mcache_obj_t ***,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_cslab_free</span>(<span class="enscript-type">void</span> *, mcache_obj_t *, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_cslab_audit</span>(<span class="enscript-type">void</span> *, mcache_obj_t *, boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">freelist_populate</span>(mbuf_class_t, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">freelist_init</span>(mbuf_class_t);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">mbuf_cached_above</span>(mbuf_class_t, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">mbuf_steal</span>(mbuf_class_t, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">m_reclaim</span>(mbuf_class_t, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">m_howmany</span>(<span class="enscript-type">int</span>, size_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_worker_thread</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mbuf_watchdog</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">mbuf_sleep</span>(mbuf_class_t, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcl_audit_init</span>(<span class="enscript-type">void</span> *, mcache_audit_t **, mcache_obj_t **,
    size_t, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcl_audit_free</span>(<span class="enscript-type">void</span> *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> mcache_audit_t *<span class="enscript-function-name">mcl_audit_buf2mca</span>(mbuf_class_t, mcache_obj_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcl_audit_mbuf</span>(mcache_audit_t *, <span class="enscript-type">void</span> *, boolean_t, boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcl_audit_cluster</span>(mcache_audit_t *, <span class="enscript-type">void</span> *, size_t, boolean_t,
    boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcl_audit_restore_mbuf</span>(<span class="enscript-type">struct</span> mbuf *, mcache_audit_t *, boolean_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcl_audit_save_mbuf</span>(<span class="enscript-type">struct</span> mbuf *, mcache_audit_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcl_audit_scratch</span>(mcache_audit_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcl_audit_mcheck_panic</span>(<span class="enscript-type">struct</span> mbuf *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mcl_audit_verify_nextptr</span>(<span class="enscript-type">void</span> *, mcache_audit_t *);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mleak_activate</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mleak_logger</span>(u_int32_t, mcache_obj_t *, boolean_t);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">mleak_log</span>(uintptr_t *, mcache_obj_t *, uint32_t, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mleak_free</span>(mcache_obj_t *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mleak_sort_traces</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">mleak_update_stats</span>(<span class="enscript-type">void</span>);

<span class="enscript-type">static</span> mcl_slab_t *<span class="enscript-function-name">slab_get</span>(<span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">slab_init</span>(mcl_slab_t *, mbuf_class_t, u_int32_t,
    <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">slab_insert</span>(mcl_slab_t *, mbuf_class_t);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">slab_remove</span>(mcl_slab_t *, mbuf_class_t);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">slab_inrange</span>(mcl_slab_t *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">slab_nextptr_panic</span>(mcl_slab_t *, <span class="enscript-type">void</span> *);
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">slab_detach</span>(mcl_slab_t *);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">slab_is_detached</span>(mcl_slab_t *);

<span class="enscript-type">static</span> <span class="enscript-type">int</span> <span class="enscript-function-name">m_copyback0</span>(<span class="enscript-type">struct</span> mbuf **, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *<span class="enscript-function-name">m_split0</span>(<span class="enscript-type">struct</span> mbuf *, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>, <span class="enscript-type">int</span>);
__private_extern__ <span class="enscript-type">void</span> mbuf_report_peak_usage(<span class="enscript-type">void</span>);
<span class="enscript-type">static</span> boolean_t <span class="enscript-function-name">mbuf_report_usage</span>(mbuf_class_t);

<span class="enscript-comment">/* flags for m_copyback0 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_COPYBACK0_COPYBACK</span>	0x0001	<span class="enscript-comment">/* copyback from cp */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_COPYBACK0_PRESERVE</span>	0x0002	<span class="enscript-comment">/* preserve original data */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_COPYBACK0_COW</span>		0x0004	<span class="enscript-comment">/* do copy-on-write */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">M_COPYBACK0_EXTEND</span>	0x0008	<span class="enscript-comment">/* extend chain */</span>

<span class="enscript-comment">/*
 * This flag is set for all mbufs that come out of and into the composite
 * mbuf + cluster caches, i.e. MC_MBUF_CL and MC_MBUF_BIGCL.  mbufs that
 * are marked with such a flag have clusters attached to them, and will be
 * treated differently when they are freed; instead of being placed back
 * into the mbuf and cluster freelists, the composite mbuf + cluster objects
 * are placed back into the appropriate composite cache's freelist, and the
 * actual freeing is deferred until the composite objects are purged.  At
 * such a time, this flag will be cleared from the mbufs and the objects
 * will be freed into their own separate freelists.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">EXTF_COMPOSITE</span>	0x1

<span class="enscript-comment">/*
 * This flag indicates that the external cluster is read-only, i.e. it is
 * or was referred to by more than one mbufs.  Once set, this flag is never
 * cleared.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">EXTF_READONLY</span>	0x2
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">EXTF_MASK</span>	(EXTF_COMPOSITE | EXTF_READONLY)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MEXT_RFA</span>(m)		((m)-&gt;m_ext.ext_refflags)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MEXT_REF</span>(m)		(MEXT_RFA(m)-&gt;refcnt)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MEXT_FLAGS</span>(m)		(MEXT_RFA(m)-&gt;flags)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_IS_COMPOSITE</span>(m)	\
	(MEXT_REF(m) == 0 &amp;&amp; (MEXT_FLAGS(m) &amp; EXTF_MASK) == EXTF_COMPOSITE)

<span class="enscript-comment">/*
 * Macros used to verify the integrity of the mbuf.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">_MCHECK</span>(m) {							\
	<span class="enscript-keyword">if</span> ((m)-&gt;m_type != MT_FREE) {					\
		<span class="enscript-keyword">if</span> (mclaudit == NULL)					\
			panic(<span class="enscript-string">&quot;MCHECK: m_type=%d m=%p&quot;</span>,			\
			    (u_int16_t)(m)-&gt;m_type, m);			\
		<span class="enscript-keyword">else</span>							\
			mcl_audit_mcheck_panic(m);			\
	}								\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_IN_MAP</span>(addr)						\
	((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)(addr) &gt;= mbutl &amp;&amp; 				\
	(<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)(addr) &lt; embutl)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MRANGE</span>(addr) {							\
	<span class="enscript-keyword">if</span> (!MBUF_IN_MAP(addr))						\
		panic(<span class="enscript-string">&quot;MRANGE: address out of range 0x%p&quot;</span>, addr);	\
}

<span class="enscript-comment">/*
 * Macro version of mtod.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MTOD</span>(m, t)	((t)((m)-&gt;m_data))

<span class="enscript-comment">/*
 * Macros to obtain page index given a base cluster address
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MTOPG</span>(x)	(((unsigned char *)x - mbutl) &gt;&gt; PAGE_SHIFT)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">PGTOM</span>(x)	(mbutl + (x &lt;&lt; PAGE_SHIFT))

<span class="enscript-comment">/*
 * Macro to find the mbuf index relative to a base.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBPAGEIDX</span>(c, m)	\
	(((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)(m) - (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)(c)) &gt;&gt; MSIZESHIFT)

<span class="enscript-comment">/*
 * Same thing for 2KB cluster index.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">CLPAGEIDX</span>(c, m)	\
	(((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)(m) - (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)(c)) &gt;&gt; MCLSHIFT)

<span class="enscript-comment">/*
 * Macro to find 4KB cluster index relative to a base
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">BCLPAGEIDX</span>(c, m) \
	(((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)(m) - (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)(c)) &gt;&gt; MBIGCLSHIFT)

<span class="enscript-comment">/*
 * Macros used during mbuf and cluster initialization.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_INIT_PKTHDR</span>(m) {						\
	(m)-&gt;m_pkthdr.rcvif = NULL;					\
	(m)-&gt;m_pkthdr.pkt_hdr = NULL;					\
	(m)-&gt;m_pkthdr.len = 0;						\
	(m)-&gt;m_pkthdr.csum_flags = 0;					\
	(m)-&gt;m_pkthdr.csum_data = 0;					\
	(m)-&gt;m_pkthdr.vlan_tag = 0;					\
	m_classifier_init(m, 0);					\
	m_tag_init(m, 1);						\
	m_scratch_init(m);						\
	m_redzone_init(m);						\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_INIT</span>(m, pkthdr, type) {					\
	_MCHECK(m);							\
	(m)-&gt;m_next = (m)-&gt;m_nextpkt = NULL;				\
	(m)-&gt;m_len = 0;							\
	(m)-&gt;m_type = type;						\
	<span class="enscript-keyword">if</span> ((pkthdr) == 0) {						\
		(m)-&gt;m_data = (m)-&gt;m_dat;				\
		(m)-&gt;m_flags = 0;					\
	} <span class="enscript-keyword">else</span> {							\
		(m)-&gt;m_data = (m)-&gt;m_pktdat;				\
		(m)-&gt;m_flags = M_PKTHDR;				\
		MBUF_INIT_PKTHDR(m);					\
	}								\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MEXT_INIT</span>(m, buf, size, free, arg, rfa, ref, flag) {		\
	(m)-&gt;m_data = (m)-&gt;m_ext.ext_buf = (buf);			\
	(m)-&gt;m_flags |= M_EXT;						\
	(m)-&gt;m_ext.ext_size = (size);					\
	(m)-&gt;m_ext.ext_free = (free);					\
	(m)-&gt;m_ext.ext_arg = (arg);					\
	(m)-&gt;m_ext.ext_refs.forward = (m)-&gt;m_ext.ext_refs.backward =	\
	    &amp;(m)-&gt;m_ext.ext_refs;					\
	MEXT_RFA(m) = (rfa);						\
	MEXT_REF(m) = (ref);						\
	MEXT_FLAGS(m) = (flag);						\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_CL_INIT</span>(m, buf, rfa, ref, flag)	\
	MEXT_INIT(m, buf, m_maxsize(MC_CL), NULL, NULL, rfa, ref, flag)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_BIGCL_INIT</span>(m, buf, rfa, ref, flag)	\
	MEXT_INIT(m, buf, m_maxsize(MC_BIGCL), m_bigfree, NULL, rfa, ref, flag)

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_16KCL_INIT</span>(m, buf, rfa, ref, flag)	\
	MEXT_INIT(m, buf, m_maxsize(MC_16KCL), m_16kfree, NULL, rfa, ref, flag)

<span class="enscript-comment">/*
 * Macro to convert BSD malloc sleep flag to mcache's
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MSLEEPF</span>(f)	((!((f) &amp; M_DONTWAIT)) ? MCR_SLEEP : MCR_NOSLEEP)

<span class="enscript-comment">/*
 * The structure that holds all mbuf class statistics exportable via sysctl.
 * Similar to mbstat structure, the mb_stat structure is protected by the
 * global mbuf lock.  It contains additional information about the classes
 * that allows for a more accurate view of the state of the allocator.
 */</span>
<span class="enscript-type">struct</span> mb_stat *mb_stat;
<span class="enscript-type">struct</span> omb_stat *omb_stat;	<span class="enscript-comment">/* For backwards compatibility */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MB_STAT_SIZE</span>(n) \
	((size_t)(&amp;((mb_stat_t *)0)-&gt;mbs_class[n]))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">OMB_STAT_SIZE</span>(n) \
	((size_t)(&amp;((<span class="enscript-type">struct</span> omb_stat *)0)-&gt;mbs_class[n]))

<span class="enscript-comment">/*
 * The legacy structure holding all of the mbuf allocation statistics.
 * The actual statistics used by the kernel are stored in the mbuf_table
 * instead, and are updated atomically while the global mbuf lock is held.
 * They are mirrored in mbstat to support legacy applications (e.g. netstat).
 * Unlike before, the kernel no longer relies on the contents of mbstat for
 * its operations (e.g. cluster expansion) because the structure is exposed
 * to outside and could possibly be modified, therefore making it unsafe.
 * With the exception of the mbstat.m_mtypes array (see below), all of the
 * statistics are updated as they change.
 */</span>
<span class="enscript-type">struct</span> mbstat mbstat;

#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MBSTAT_MTYPES_MAX</span> \
	(<span class="enscript-keyword">sizeof</span> (mbstat.m_mtypes) / <span class="enscript-keyword">sizeof</span> (mbstat.m_mtypes[0]))

<span class="enscript-comment">/*
 * Allocation statistics related to mbuf types (up to MT_MAX-1) are updated
 * atomically and stored in a per-CPU structure which is lock-free; this is
 * done in order to avoid writing to the global mbstat data structure which
 * would cause false sharing.  During sysctl request for kern.ipc.mbstat,
 * the statistics across all CPUs will be converged into the mbstat.m_mtypes
 * array and returned to the application.  Any updates for types greater or
 * equal than MT_MAX would be done atomically to the mbstat; this slows down
 * performance but is okay since the kernel uses only up to MT_MAX-1 while
 * anything beyond that (up to type 255) is considered a corner case.
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>	cpu_mtypes[MT_MAX];
} __attribute__((aligned(MAX_CPU_CACHE_LINE_SIZE), packed)) mtypes_cpu_t;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> {
	mtypes_cpu_t	mbs_cpu[1];
} mbuf_mtypes_t;

<span class="enscript-type">static</span> mbuf_mtypes_t *mbuf_mtypes;	<span class="enscript-comment">/* per-CPU statistics */</span>

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_MTYPES_SIZE</span>(n) \
	((size_t)(&amp;((mbuf_mtypes_t *)0)-&gt;mbs_cpu[n]))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MTYPES_CPU</span>(p) \
	((mtypes_cpu_t *)(<span class="enscript-type">void</span> *)((<span class="enscript-type">char</span> *)(p) + MBUF_MTYPES_SIZE(cpu_number())))

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">mtype_stat_add</span>(type, n) {					\
	<span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span>)(type) &lt; MT_MAX) {				\
		mtypes_cpu_t *mbs = MTYPES_CPU(mbuf_mtypes);		\
		atomic_add_32(&amp;mbs-&gt;cpu_mtypes[type], n);		\
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((<span class="enscript-type">unsigned</span>)(type) &lt; (<span class="enscript-type">unsigned</span>)MBSTAT_MTYPES_MAX) {	\
		atomic_add_16((int16_t *)&amp;mbstat.m_mtypes[type], n);	\
	}								\
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">mtype_stat_sub</span>(t, n)	mtype_stat_add(t, -(n))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">mtype_stat_inc</span>(t)	mtype_stat_add(t, 1)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">mtype_stat_dec</span>(t)	mtype_stat_sub(t, 1)

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_mtypes_sync</span>(boolean_t locked)
{
	<span class="enscript-type">int</span> m, n;
	mtypes_cpu_t mtc;

	<span class="enscript-keyword">if</span> (locked)
		lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);

	bzero(&amp;mtc, <span class="enscript-keyword">sizeof</span> (mtc));
	<span class="enscript-keyword">for</span> (m = 0; m &lt; ncpu; m++) {
		mtypes_cpu_t *scp = &amp;mbuf_mtypes-&gt;mbs_cpu[m];
		mtypes_cpu_t temp;

		bcopy(&amp;scp-&gt;cpu_mtypes, &amp;temp.cpu_mtypes,
		    <span class="enscript-keyword">sizeof</span> (temp.cpu_mtypes));

		<span class="enscript-keyword">for</span> (n = 0; n &lt; MT_MAX; n++)
			mtc.cpu_mtypes[n] += temp.cpu_mtypes[n];
	}
	<span class="enscript-keyword">if</span> (!locked)
		lck_mtx_lock(mbuf_mlock);
	<span class="enscript-keyword">for</span> (n = 0; n &lt; MT_MAX; n++)
		mbstat.m_mtypes[n] = mtc.cpu_mtypes[n];
	<span class="enscript-keyword">if</span> (!locked)
		lck_mtx_unlock(mbuf_mlock);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
mbstat_sysctl SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	mbuf_mtypes_sync(FALSE);

	<span class="enscript-keyword">return</span> (SYSCTL_OUT(req, &amp;mbstat, <span class="enscript-keyword">sizeof</span> (mbstat)));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_stat_sync</span>(<span class="enscript-type">void</span>)
{
	mb_class_stat_t *sp;
	mcache_cpu_t *ccp;
	mcache_t *cp;
	<span class="enscript-type">int</span> k, m, bktsize;

	lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">for</span> (k = 0; k &lt; NELEM(mbuf_table); k++) {
		cp = m_cache(k);
		ccp = &amp;cp-&gt;mc_cpu[0];
		bktsize = ccp-&gt;cc_bktsize;
		sp = mbuf_table[k].mtbl_stats;

		<span class="enscript-keyword">if</span> (cp-&gt;mc_flags &amp; MCF_NOCPUCACHE)
			sp-&gt;mbcl_mc_state = MCS_DISABLED;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (cp-&gt;mc_purge_cnt &gt; 0)
			sp-&gt;mbcl_mc_state = MCS_PURGING;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bktsize == 0)
			sp-&gt;mbcl_mc_state = MCS_OFFLINE;
		<span class="enscript-keyword">else</span>
			sp-&gt;mbcl_mc_state = MCS_ONLINE;

		sp-&gt;mbcl_mc_cached = 0;
		<span class="enscript-keyword">for</span> (m = 0; m &lt; ncpu; m++) {
			ccp = &amp;cp-&gt;mc_cpu[m];
			<span class="enscript-keyword">if</span> (ccp-&gt;cc_objs &gt; 0)
				sp-&gt;mbcl_mc_cached += ccp-&gt;cc_objs;
			<span class="enscript-keyword">if</span> (ccp-&gt;cc_pobjs &gt; 0)
				sp-&gt;mbcl_mc_cached += ccp-&gt;cc_pobjs;
		}
		sp-&gt;mbcl_mc_cached += (cp-&gt;mc_full.bl_total * bktsize);
		sp-&gt;mbcl_active = sp-&gt;mbcl_total - sp-&gt;mbcl_mc_cached -
		    sp-&gt;mbcl_infree;

		sp-&gt;mbcl_mc_waiter_cnt = cp-&gt;mc_waiter_cnt;
		sp-&gt;mbcl_mc_wretry_cnt = cp-&gt;mc_wretry_cnt;
		sp-&gt;mbcl_mc_nwretry_cnt = cp-&gt;mc_nwretry_cnt;

		<span class="enscript-comment">/* Calculate total count specific to each class */</span>
		sp-&gt;mbcl_ctotal = sp-&gt;mbcl_total;
		<span class="enscript-keyword">switch</span> (m_class(k)) {
		<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_MBUF</span>:
			<span class="enscript-comment">/* Deduct mbufs used in composite caches */</span>
			sp-&gt;mbcl_ctotal -= (m_total(MC_MBUF_CL) +
			    m_total(MC_MBUF_BIGCL));
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_CL</span>:
			<span class="enscript-comment">/* Deduct clusters used in composite cache */</span>
			sp-&gt;mbcl_ctotal -= m_total(MC_MBUF_CL);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_BIGCL</span>:
			<span class="enscript-comment">/* Deduct clusters used in composite cache */</span>
			sp-&gt;mbcl_ctotal -= m_total(MC_MBUF_BIGCL);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_16KCL</span>:
			<span class="enscript-comment">/* Deduct clusters used in composite cache */</span>
			sp-&gt;mbcl_ctotal -= m_total(MC_MBUF_16KCL);
			<span class="enscript-keyword">break</span>;

		<span class="enscript-reference">default</span>:
			<span class="enscript-keyword">break</span>;
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
mb_stat_sysctl SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">void</span> *statp;
	<span class="enscript-type">int</span> k, statsz, proc64 = proc_is64bit(req-&gt;p);

	lck_mtx_lock(mbuf_mlock);
	mbuf_stat_sync();

	<span class="enscript-keyword">if</span> (!proc64) {
		<span class="enscript-type">struct</span> omb_class_stat *oc;
		<span class="enscript-type">struct</span> mb_class_stat *c;

		omb_stat-&gt;mbs_cnt = mb_stat-&gt;mbs_cnt;
		oc = &amp;omb_stat-&gt;mbs_class[0];
		c = &amp;mb_stat-&gt;mbs_class[0];
		<span class="enscript-keyword">for</span> (k = 0; k &lt; omb_stat-&gt;mbs_cnt; k++, oc++, c++) {
			(<span class="enscript-type">void</span>) snprintf(oc-&gt;mbcl_cname, <span class="enscript-keyword">sizeof</span> (oc-&gt;mbcl_cname),
			    <span class="enscript-string">&quot;%s&quot;</span>, c-&gt;mbcl_cname);
			oc-&gt;mbcl_size = c-&gt;mbcl_size;
			oc-&gt;mbcl_total = c-&gt;mbcl_total;
			oc-&gt;mbcl_active = c-&gt;mbcl_active;
			oc-&gt;mbcl_infree = c-&gt;mbcl_infree;
			oc-&gt;mbcl_slab_cnt = c-&gt;mbcl_slab_cnt;
			oc-&gt;mbcl_alloc_cnt = c-&gt;mbcl_alloc_cnt;
			oc-&gt;mbcl_free_cnt = c-&gt;mbcl_free_cnt;
			oc-&gt;mbcl_notified = c-&gt;mbcl_notified;
			oc-&gt;mbcl_purge_cnt = c-&gt;mbcl_purge_cnt;
			oc-&gt;mbcl_fail_cnt = c-&gt;mbcl_fail_cnt;
			oc-&gt;mbcl_ctotal = c-&gt;mbcl_ctotal;
			oc-&gt;mbcl_release_cnt = c-&gt;mbcl_release_cnt;
			oc-&gt;mbcl_mc_state = c-&gt;mbcl_mc_state;
			oc-&gt;mbcl_mc_cached = c-&gt;mbcl_mc_cached;
			oc-&gt;mbcl_mc_waiter_cnt = c-&gt;mbcl_mc_waiter_cnt;
			oc-&gt;mbcl_mc_wretry_cnt = c-&gt;mbcl_mc_wretry_cnt;
			oc-&gt;mbcl_mc_nwretry_cnt = c-&gt;mbcl_mc_nwretry_cnt;
		}
		statp = omb_stat;
		statsz = OMB_STAT_SIZE(NELEM(mbuf_table));
	} <span class="enscript-keyword">else</span> {
		statp = mb_stat;
		statsz = MB_STAT_SIZE(NELEM(mbuf_table));
	}

	lck_mtx_unlock(mbuf_mlock);

	<span class="enscript-keyword">return</span> (SYSCTL_OUT(req, statp, statsz));
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
mleak_top_trace_sysctl SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> i;

	<span class="enscript-comment">/* Ensure leak tracing turned on */</span>
	<span class="enscript-keyword">if</span> (!mclfindleak || !mclexpleak)
		<span class="enscript-keyword">return</span> (ENXIO);

	lck_mtx_lock(mleak_lock);
	mleak_update_stats();
	i = SYSCTL_OUT(req, mleak_stat, MLEAK_STAT_SIZE(MLEAK_NUM_TRACES));
	lck_mtx_unlock(mleak_lock);

	<span class="enscript-keyword">return</span> (i);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
mleak_table_sysctl SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">oidp</span>, <span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> i = 0;

	<span class="enscript-comment">/* Ensure leak tracing turned on */</span>
	<span class="enscript-keyword">if</span> (!mclfindleak || !mclexpleak)
		<span class="enscript-keyword">return</span> (ENXIO);

	lck_mtx_lock(mleak_lock);
	i = SYSCTL_OUT(req, &amp;mleak_table, <span class="enscript-keyword">sizeof</span> (mleak_table));
	lck_mtx_unlock(mleak_lock);

	<span class="enscript-keyword">return</span> (i);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">void</span>
<span class="enscript-function-name">m_incref</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	UInt32 old, new;
	<span class="enscript-type">volatile</span> UInt32 *addr = (<span class="enscript-type">volatile</span> UInt32 *)&amp;MEXT_REF(m);

	<span class="enscript-keyword">do</span> {
		old = *addr;
		new = old + 1;
		ASSERT(new != 0);
	} <span class="enscript-keyword">while</span> (!OSCompareAndSwap(old, new, addr));

	<span class="enscript-comment">/*
	 * If cluster is shared, mark it with (sticky) EXTF_READONLY;
	 * we don't clear the flag when the refcount goes back to 1
	 * to simplify code calling m_mclhasreference().
	 */</span>
	<span class="enscript-keyword">if</span> (new &gt; 1 &amp;&amp; !(MEXT_FLAGS(m) &amp; EXTF_READONLY))
		(<span class="enscript-type">void</span>) OSBitOrAtomic(EXTF_READONLY, &amp;MEXT_FLAGS(m));
}

<span class="enscript-type">static</span> inline u_int32_t
<span class="enscript-function-name">m_decref</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	UInt32 old, new;
	<span class="enscript-type">volatile</span> UInt32 *addr = (<span class="enscript-type">volatile</span> UInt32 *)&amp;MEXT_REF(m);

	<span class="enscript-keyword">do</span> {
		old = *addr;
		new = old - 1;
		ASSERT(old != 0);
	} <span class="enscript-keyword">while</span> (!OSCompareAndSwap(old, new, addr));

	<span class="enscript-keyword">return</span> (new);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_table_init</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> b, c, s;
	<span class="enscript-type">int</span> m, config_mbuf_jumbo = 0;

	MALLOC(omb_stat, <span class="enscript-type">struct</span> omb_stat *, OMB_STAT_SIZE(NELEM(mbuf_table)),
	    M_TEMP, M_WAITOK | M_ZERO);
	VERIFY(omb_stat != NULL);

	MALLOC(mb_stat, mb_stat_t *, MB_STAT_SIZE(NELEM(mbuf_table)),
	    M_TEMP, M_WAITOK | M_ZERO);
	VERIFY(mb_stat != NULL);

	mb_stat-&gt;mbs_cnt = NELEM(mbuf_table);
	<span class="enscript-keyword">for</span> (m = 0; m &lt; NELEM(mbuf_table); m++)
		mbuf_table[m].mtbl_stats = &amp;mb_stat-&gt;mbs_class[m];

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MBUF_JUMBO</span>
	config_mbuf_jumbo = 1;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* CONFIG_MBUF_JUMBO */</span>

	<span class="enscript-keyword">if</span> (config_mbuf_jumbo == 1 || PAGE_SIZE == M16KCLBYTES) {
		<span class="enscript-comment">/*
		 * Set aside 1/3 of the mbuf cluster map for jumbo
		 * clusters; we do this only on platforms where jumbo
		 * cluster pool is enabled.
		 */</span>
		njcl = nmbclusters / 3;
		njclbytes = M16KCLBYTES;
	}

	<span class="enscript-comment">/*
	 * nclusters holds both the 2KB and 4KB pools, so ensure it's
	 * a multiple of 4KB clusters.
	 */</span>
	nclusters = P2ROUNDDOWN(nmbclusters - njcl, NCLPG);
	<span class="enscript-keyword">if</span> (njcl &gt; 0) {
		<span class="enscript-comment">/*
		 * Each jumbo cluster takes 8 2KB clusters, so make
		 * sure that the pool size is evenly divisible by 8;
		 * njcl is in 2KB unit, hence treated as such.
		 */</span>
		njcl = P2ROUNDDOWN(nmbclusters - nclusters, NCLPJCL);

		<span class="enscript-comment">/* Update nclusters with rounded down value of njcl */</span>
		nclusters = P2ROUNDDOWN(nmbclusters - njcl, NCLPG);
	}

	<span class="enscript-comment">/*
	 * njcl is valid only on platforms with 16KB jumbo clusters or
	 * with 16KB pages, where it is configured to 1/3 of the pool
	 * size.  On these platforms, the remaining is used for 2KB
	 * and 4KB clusters.  On platforms without 16KB jumbo clusters,
	 * the entire pool is used for both 2KB and 4KB clusters.  A 4KB
	 * cluster can either be splitted into 16 mbufs, or into 2 2KB
	 * clusters.
	 *
	 *  +---+---+------------ ... -----------+------- ... -------+
	 *  | c | b |              s             |        njcl       |
	 *  +---+---+------------ ... -----------+------- ... -------+
	 *
	 * 1/32th of the shared region is reserved for pure 2KB and 4KB
	 * clusters (1/64th each.)
	 */</span>
	c = P2ROUNDDOWN((nclusters &gt;&gt; 6), NCLPG);	<span class="enscript-comment">/* in 2KB unit */</span>
	b = P2ROUNDDOWN((nclusters &gt;&gt; (6 + NCLPBGSHIFT)), NBCLPG); <span class="enscript-comment">/* in 4KB unit */</span>
	s = nclusters - (c + (b &lt;&lt; NCLPBGSHIFT));	<span class="enscript-comment">/* in 2KB unit */</span>

	<span class="enscript-comment">/*
	 * 1/64th (c) is reserved for 2KB clusters.
	 */</span>
	m_minlimit(MC_CL) = c;
	m_maxlimit(MC_CL) = s + c;			<span class="enscript-comment">/* in 2KB unit */</span>
	m_maxsize(MC_CL) = m_size(MC_CL) = MCLBYTES;
	(<span class="enscript-type">void</span>) snprintf(m_cname(MC_CL), MAX_MBUF_CNAME, <span class="enscript-string">&quot;cl&quot;</span>);

	<span class="enscript-comment">/*
	 * Another 1/64th (b) of the map is reserved for 4KB clusters.
	 * It cannot be turned into 2KB clusters or mbufs.
	 */</span>
	m_minlimit(MC_BIGCL) = b;
	m_maxlimit(MC_BIGCL) = (s &gt;&gt; NCLPBGSHIFT) + b;	<span class="enscript-comment">/* in 4KB unit */</span>
	m_maxsize(MC_BIGCL) = m_size(MC_BIGCL) = MBIGCLBYTES;
	(<span class="enscript-type">void</span>) snprintf(m_cname(MC_BIGCL), MAX_MBUF_CNAME, <span class="enscript-string">&quot;bigcl&quot;</span>);

	<span class="enscript-comment">/*
	 * The remaining 31/32ths (s) are all-purpose (mbufs, 2KB, or 4KB)
	 */</span>
	m_minlimit(MC_MBUF) = 0;
	m_maxlimit(MC_MBUF) = (s &lt;&lt; NMBPCLSHIFT);	<span class="enscript-comment">/* in mbuf unit */</span>
	m_maxsize(MC_MBUF) = m_size(MC_MBUF) = MSIZE;
	(<span class="enscript-type">void</span>) snprintf(m_cname(MC_MBUF), MAX_MBUF_CNAME, <span class="enscript-string">&quot;mbuf&quot;</span>);

	<span class="enscript-comment">/*
	 * Set limits for the composite classes.
	 */</span>
	m_minlimit(MC_MBUF_CL) = 0;
	m_maxlimit(MC_MBUF_CL) = m_maxlimit(MC_CL);
	m_maxsize(MC_MBUF_CL) = MCLBYTES;
	m_size(MC_MBUF_CL) = m_size(MC_MBUF) + m_size(MC_CL);
	(<span class="enscript-type">void</span>) snprintf(m_cname(MC_MBUF_CL), MAX_MBUF_CNAME, <span class="enscript-string">&quot;mbuf_cl&quot;</span>);

	m_minlimit(MC_MBUF_BIGCL) = 0;
	m_maxlimit(MC_MBUF_BIGCL) = m_maxlimit(MC_BIGCL);
	m_maxsize(MC_MBUF_BIGCL) = MBIGCLBYTES;
	m_size(MC_MBUF_BIGCL) = m_size(MC_MBUF) + m_size(MC_BIGCL);
	(<span class="enscript-type">void</span>) snprintf(m_cname(MC_MBUF_BIGCL), MAX_MBUF_CNAME, <span class="enscript-string">&quot;mbuf_bigcl&quot;</span>);

	<span class="enscript-comment">/*
	 * And for jumbo classes.
	 */</span>
	m_minlimit(MC_16KCL) = 0;
	m_maxlimit(MC_16KCL) = (njcl &gt;&gt; NCLPJCLSHIFT);	<span class="enscript-comment">/* in 16KB unit */</span>
	m_maxsize(MC_16KCL) = m_size(MC_16KCL) = M16KCLBYTES;
	(<span class="enscript-type">void</span>) snprintf(m_cname(MC_16KCL), MAX_MBUF_CNAME, <span class="enscript-string">&quot;16kcl&quot;</span>);

	m_minlimit(MC_MBUF_16KCL) = 0;
	m_maxlimit(MC_MBUF_16KCL) = m_maxlimit(MC_16KCL);
	m_maxsize(MC_MBUF_16KCL) = M16KCLBYTES;
	m_size(MC_MBUF_16KCL) = m_size(MC_MBUF) + m_size(MC_16KCL);
	(<span class="enscript-type">void</span>) snprintf(m_cname(MC_MBUF_16KCL), MAX_MBUF_CNAME, <span class="enscript-string">&quot;mbuf_16kcl&quot;</span>);

	<span class="enscript-comment">/*
	 * Initialize the legacy mbstat structure.
	 */</span>
	bzero(&amp;mbstat, <span class="enscript-keyword">sizeof</span> (mbstat));
	mbstat.m_msize = m_maxsize(MC_MBUF);
	mbstat.m_mclbytes = m_maxsize(MC_CL);
	mbstat.m_minclsize = MINCLSIZE;
	mbstat.m_mlen = MLEN;
	mbstat.m_mhlen = MHLEN;
	mbstat.m_bigmclbytes = m_maxsize(MC_BIGCL);
}

#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ncl_tbl {
	uint64_t nt_maxmem;	<span class="enscript-comment">/* memory (sane) size */</span>
	uint32_t nt_mbpool;	<span class="enscript-comment">/* mbuf pool size */</span>
} ncl_tbl_t;

<span class="enscript-comment">/* Non-server */</span>
<span class="enscript-type">static</span> ncl_tbl_t ncl_table[] = {
	{ (1ULL &lt;&lt; GBSHIFT)	  <span class="enscript-comment">/*  1 GB */</span>,	(64 &lt;&lt; MBSHIFT)	 <span class="enscript-comment">/*  64 MB */</span> },
	{ (1ULL &lt;&lt; (GBSHIFT + 3)) <span class="enscript-comment">/*  8 GB */</span>,	(96 &lt;&lt; MBSHIFT)	 <span class="enscript-comment">/*  96 MB */</span> },
	{ (1ULL &lt;&lt; (GBSHIFT + 4)) <span class="enscript-comment">/* 16 GB */</span>,	(128 &lt;&lt; MBSHIFT) <span class="enscript-comment">/* 128 MB */</span> },
	{ 0, 0 }
};

<span class="enscript-comment">/* Server */</span>
<span class="enscript-type">static</span> ncl_tbl_t ncl_table_srv[] = {
	{ (1ULL &lt;&lt; GBSHIFT)	  <span class="enscript-comment">/*  1 GB */</span>,	(96 &lt;&lt; MBSHIFT)  <span class="enscript-comment">/*  96 MB */</span> },
	{ (1ULL &lt;&lt; (GBSHIFT + 2)) <span class="enscript-comment">/*  4 GB */</span>,	(128 &lt;&lt; MBSHIFT) <span class="enscript-comment">/* 128 MB */</span> },
	{ (1ULL &lt;&lt; (GBSHIFT + 3)) <span class="enscript-comment">/*  8 GB */</span>,	(160 &lt;&lt; MBSHIFT) <span class="enscript-comment">/* 160 MB */</span> },
	{ (1ULL &lt;&lt; (GBSHIFT + 4)) <span class="enscript-comment">/* 16 GB */</span>,	(192 &lt;&lt; MBSHIFT) <span class="enscript-comment">/* 192 MB */</span> },
	{ (1ULL &lt;&lt; (GBSHIFT + 5)) <span class="enscript-comment">/* 32 GB */</span>,	(256 &lt;&lt; MBSHIFT) <span class="enscript-comment">/* 256 MB */</span> },
	{ (1ULL &lt;&lt; (GBSHIFT + 6)) <span class="enscript-comment">/* 64 GB */</span>,	(384 &lt;&lt; MBSHIFT) <span class="enscript-comment">/* 384 MB */</span> },
	{ 0, 0 }
};
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __LP64__ */</span>

__private_extern__ <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mbuf_default_ncl</span>(<span class="enscript-type">int</span> server, uint64_t mem)
{
#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LP64__</span>)
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">server</span>)
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> n;
	<span class="enscript-comment">/*
	 * 32-bit kernel (default to 64MB of mbuf pool for &gt;= 1GB RAM).
	 */</span>
	<span class="enscript-keyword">if</span> ((n = ((mem / 16) / MCLBYTES)) &gt; 32768)
		n = 32768;
#<span class="enscript-reference">else</span>
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> n, i;
	ncl_tbl_t *tbl = (server ? ncl_table_srv : ncl_table);
	<span class="enscript-comment">/*
	 * 64-bit kernel (mbuf pool size based on table).
	 */</span>
	n = tbl[0].nt_mbpool;
	<span class="enscript-keyword">for</span> (i = 0; tbl[i].nt_mbpool != 0; i++) {
		<span class="enscript-keyword">if</span> (mem &lt; tbl[i].nt_maxmem)
			<span class="enscript-keyword">break</span>;
		n = tbl[i].nt_mbpool;
	}
	n &gt;&gt;= MCLSHIFT;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
	<span class="enscript-keyword">return</span> (n);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">mbinit</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> m;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> initmcl = 0;
	<span class="enscript-type">void</span> *buf;
	thread_t thread = THREAD_NULL;

	microuptime(&amp;mb_start);

	<span class="enscript-comment">/*
	 * These MBUF_ values must be equal to their private counterparts.
	 */</span>
	_CASSERT(MBUF_EXT == M_EXT);
	_CASSERT(MBUF_PKTHDR == M_PKTHDR);
	_CASSERT(MBUF_EOR == M_EOR);
	_CASSERT(MBUF_LOOP == M_LOOP);
	_CASSERT(MBUF_BCAST == M_BCAST);
	_CASSERT(MBUF_MCAST == M_MCAST);
	_CASSERT(MBUF_FRAG == M_FRAG);
	_CASSERT(MBUF_FIRSTFRAG == M_FIRSTFRAG);
	_CASSERT(MBUF_LASTFRAG == M_LASTFRAG);
	_CASSERT(MBUF_PROMISC == M_PROMISC);
	_CASSERT(MBUF_HASFCS == M_HASFCS);

	_CASSERT(MBUF_TYPE_FREE == MT_FREE);
	_CASSERT(MBUF_TYPE_DATA == MT_DATA);
	_CASSERT(MBUF_TYPE_HEADER == MT_HEADER);
	_CASSERT(MBUF_TYPE_SOCKET == MT_SOCKET);
	_CASSERT(MBUF_TYPE_PCB == MT_PCB);
	_CASSERT(MBUF_TYPE_RTABLE == MT_RTABLE);
	_CASSERT(MBUF_TYPE_HTABLE == MT_HTABLE);
	_CASSERT(MBUF_TYPE_ATABLE == MT_ATABLE);
	_CASSERT(MBUF_TYPE_SONAME == MT_SONAME);
	_CASSERT(MBUF_TYPE_SOOPTS == MT_SOOPTS);
	_CASSERT(MBUF_TYPE_FTABLE == MT_FTABLE);
	_CASSERT(MBUF_TYPE_RIGHTS == MT_RIGHTS);
	_CASSERT(MBUF_TYPE_IFADDR == MT_IFADDR);
	_CASSERT(MBUF_TYPE_CONTROL == MT_CONTROL);
	_CASSERT(MBUF_TYPE_OOBDATA == MT_OOBDATA);

	_CASSERT(MBUF_TSO_IPV4 == CSUM_TSO_IPV4);
	_CASSERT(MBUF_TSO_IPV6 == CSUM_TSO_IPV6);
	_CASSERT(MBUF_CSUM_REQ_SUM16 == CSUM_PARTIAL);
	_CASSERT(MBUF_CSUM_TCP_SUM16 == MBUF_CSUM_REQ_SUM16);
	_CASSERT(MBUF_CSUM_REQ_IP == CSUM_IP);
	_CASSERT(MBUF_CSUM_REQ_TCP == CSUM_TCP);
	_CASSERT(MBUF_CSUM_REQ_UDP == CSUM_UDP);
	_CASSERT(MBUF_CSUM_REQ_TCPIPV6 == CSUM_TCPIPV6);
	_CASSERT(MBUF_CSUM_REQ_UDPIPV6 == CSUM_UDPIPV6);
	_CASSERT(MBUF_CSUM_DID_IP == CSUM_IP_CHECKED);
	_CASSERT(MBUF_CSUM_IP_GOOD == CSUM_IP_VALID);
	_CASSERT(MBUF_CSUM_DID_DATA == CSUM_DATA_VALID);
	_CASSERT(MBUF_CSUM_PSEUDO_HDR == CSUM_PSEUDO_HDR);

	_CASSERT(MBUF_WAITOK == M_WAIT);
	_CASSERT(MBUF_DONTWAIT == M_DONTWAIT);
	_CASSERT(MBUF_COPYALL == M_COPYALL);

	_CASSERT(MBUF_SC2TC(MBUF_SC_BK_SYS) == MBUF_TC_BK);
	_CASSERT(MBUF_SC2TC(MBUF_SC_BK) == MBUF_TC_BK);
	_CASSERT(MBUF_SC2TC(MBUF_SC_BE) == MBUF_TC_BE);
	_CASSERT(MBUF_SC2TC(MBUF_SC_RD) == MBUF_TC_BE);
	_CASSERT(MBUF_SC2TC(MBUF_SC_OAM) == MBUF_TC_BE);
	_CASSERT(MBUF_SC2TC(MBUF_SC_AV) == MBUF_TC_VI);
	_CASSERT(MBUF_SC2TC(MBUF_SC_RV) == MBUF_TC_VI);
	_CASSERT(MBUF_SC2TC(MBUF_SC_VI) == MBUF_TC_VI);
	_CASSERT(MBUF_SC2TC(MBUF_SC_VO) == MBUF_TC_VO);
	_CASSERT(MBUF_SC2TC(MBUF_SC_CTL) == MBUF_TC_VO);

	_CASSERT(MBUF_TC2SCVAL(MBUF_TC_BK) == SCVAL_BK);
	_CASSERT(MBUF_TC2SCVAL(MBUF_TC_BE) == SCVAL_BE);
	_CASSERT(MBUF_TC2SCVAL(MBUF_TC_VI) == SCVAL_VI);
	_CASSERT(MBUF_TC2SCVAL(MBUF_TC_VO) == SCVAL_VO);

	<span class="enscript-comment">/* Module specific scratch space (32-bit alignment requirement) */</span>
	_CASSERT(!(offsetof(<span class="enscript-type">struct</span> mbuf, m_pkthdr.pkt_mpriv) %
	    <span class="enscript-keyword">sizeof</span> (uint32_t)));

	<span class="enscript-comment">/* Initialize random red zone cookie value */</span>
	_CASSERT(<span class="enscript-keyword">sizeof</span> (mb_redzone_cookie) ==
	    <span class="enscript-keyword">sizeof</span> (((<span class="enscript-type">struct</span> pkthdr *)0)-&gt;redzone));
	read_random(&amp;mb_redzone_cookie, <span class="enscript-keyword">sizeof</span> (mb_redzone_cookie));

	<span class="enscript-comment">/* Make sure we don't save more than we should */</span>
	_CASSERT(MCA_SAVED_MBUF_SIZE &lt;= <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mbuf));

	<span class="enscript-keyword">if</span> (nmbclusters == 0)
		nmbclusters = NMBCLUSTERS;

	<span class="enscript-comment">/* This should be a sane (at least even) value by now */</span>
	VERIFY(nmbclusters != 0 &amp;&amp; !(nmbclusters &amp; 0x1));

	<span class="enscript-comment">/* Setup the mbuf table */</span>
	mbuf_table_init();

	<span class="enscript-comment">/* Global lock for common layer */</span>
	mbuf_mlock_grp_attr = lck_grp_attr_alloc_init();
	mbuf_mlock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;mbuf&quot;</span>, mbuf_mlock_grp_attr);
	mbuf_mlock_attr = lck_attr_alloc_init();
	lck_mtx_init(mbuf_mlock, mbuf_mlock_grp, mbuf_mlock_attr);

	<span class="enscript-comment">/*
	 * Allocate cluster slabs table:
	 *
	 *	maxslabgrp = (N * 2048) / (1024 * 1024)
	 *
	 * Where N is nmbclusters rounded up to the nearest 512.  This yields
	 * mcl_slab_g_t units, each one representing a MB of memory.
	 */</span>
	maxslabgrp =
	    (P2ROUNDUP(nmbclusters, (MBSIZE &gt;&gt; MCLSHIFT)) &lt;&lt; MCLSHIFT) &gt;&gt; MBSHIFT;
	MALLOC(slabstbl, mcl_slabg_t **, maxslabgrp * <span class="enscript-keyword">sizeof</span> (mcl_slabg_t *),
	    M_TEMP, M_WAITOK | M_ZERO);
	VERIFY(slabstbl != NULL);

	<span class="enscript-comment">/*
	 * Allocate audit structures, if needed:
	 *
	 *	maxclaudit = (maxslabgrp * 1024 * 1024) / PAGE_SIZE
	 *
	 * This yields mcl_audit_t units, each one representing a page.
	 */</span>
	PE_parse_boot_argn(<span class="enscript-string">&quot;mbuf_debug&quot;</span>, &amp;mbuf_debug, <span class="enscript-keyword">sizeof</span> (mbuf_debug));
	mbuf_debug |= mcache_getflags();
	<span class="enscript-keyword">if</span> (mbuf_debug &amp; MCF_DEBUG) {
		<span class="enscript-type">int</span> l;
		mcl_audit_t *mclad;
		maxclaudit = ((maxslabgrp &lt;&lt; MBSHIFT) &gt;&gt; PAGE_SHIFT);
		MALLOC(mclaudit, mcl_audit_t *, maxclaudit * <span class="enscript-keyword">sizeof</span> (*mclaudit),
		    M_TEMP, M_WAITOK | M_ZERO);
		VERIFY(mclaudit != NULL);
		<span class="enscript-keyword">for</span> (l = 0, mclad = mclaudit; l &lt; maxclaudit; l++) {
			MALLOC(mclad[l].cl_audit, mcache_audit_t **,
			    NMBPG * <span class="enscript-keyword">sizeof</span>(mcache_audit_t *),
			    M_TEMP, M_WAITOK | M_ZERO);
			VERIFY(mclad[l].cl_audit != NULL);
		}

		mcl_audit_con_cache = mcache_create(<span class="enscript-string">&quot;mcl_audit_contents&quot;</span>,
		    AUDIT_CONTENTS_SIZE, <span class="enscript-keyword">sizeof</span> (u_int64_t), 0, MCR_SLEEP);
		VERIFY(mcl_audit_con_cache != NULL);
	}
	mclverify = (mbuf_debug &amp; MCF_VERIFY);
	mcltrace = (mbuf_debug &amp; MCF_TRACE);
	mclfindleak = !(mbuf_debug &amp; MCF_NOLEAKLOG);
	mclexpleak = mclfindleak &amp;&amp; (mbuf_debug &amp; MCF_EXPLEAKLOG);

	<span class="enscript-comment">/* Enable mbuf leak logging, with a lock to protect the tables */</span>

	mleak_lock_grp_attr = lck_grp_attr_alloc_init();
	mleak_lock_grp = lck_grp_alloc_init(<span class="enscript-string">&quot;mleak_lock&quot;</span>, mleak_lock_grp_attr);
	mleak_lock_attr = lck_attr_alloc_init();
	lck_mtx_init(mleak_lock, mleak_lock_grp, mleak_lock_attr);

	mleak_activate();

	<span class="enscript-comment">/* Calculate the number of pages assigned to the cluster pool */</span>
	mcl_pages = (nmbclusters &lt;&lt; MCLSHIFT) / PAGE_SIZE;
	MALLOC(mcl_paddr, ppnum_t *, mcl_pages * <span class="enscript-keyword">sizeof</span> (ppnum_t),
	    M_TEMP, M_WAITOK);
	VERIFY(mcl_paddr != NULL);

	<span class="enscript-comment">/* Register with the I/O Bus mapper */</span>
	mcl_paddr_base = IOMapperIOVMAlloc(mcl_pages);
	bzero((<span class="enscript-type">char</span> *)mcl_paddr, mcl_pages * <span class="enscript-keyword">sizeof</span> (ppnum_t));

	embutl = (mbutl + (nmbclusters * MCLBYTES));
	VERIFY(((embutl - mbutl) % MBIGCLBYTES) == 0);

	<span class="enscript-comment">/* Prime up the freelist */</span>
	PE_parse_boot_argn(<span class="enscript-string">&quot;initmcl&quot;</span>, &amp;initmcl, <span class="enscript-keyword">sizeof</span> (initmcl));
	<span class="enscript-keyword">if</span> (initmcl != 0) {
		initmcl &gt;&gt;= NCLPBGSHIFT;	<span class="enscript-comment">/* become a 4K unit */</span>
		<span class="enscript-keyword">if</span> (initmcl &gt; m_maxlimit(MC_BIGCL))
			initmcl = m_maxlimit(MC_BIGCL);
	}
	<span class="enscript-keyword">if</span> (initmcl &lt; m_minlimit(MC_BIGCL))
		initmcl = m_minlimit(MC_BIGCL);

	lck_mtx_lock(mbuf_mlock);

	<span class="enscript-comment">/*
	 * For classes with non-zero minimum limits, populate their freelists
	 * so that m_total(class) is at least m_minlimit(class).
	 */</span>
	VERIFY(m_total(MC_BIGCL) == 0 &amp;&amp; m_minlimit(MC_BIGCL) != 0);
	freelist_populate(m_class(MC_BIGCL), initmcl, M_WAIT);
	VERIFY(m_total(MC_BIGCL) &gt;= m_minlimit(MC_BIGCL));
	freelist_init(m_class(MC_CL));

	<span class="enscript-keyword">for</span> (m = 0; m &lt; NELEM(mbuf_table); m++) {
		<span class="enscript-comment">/* Make sure we didn't miss any */</span>
		VERIFY(m_minlimit(m_class(m)) == 0 ||
		    m_total(m_class(m)) &gt;= m_minlimit(m_class(m)));

		<span class="enscript-comment">/* populate the initial sizes and report from there on */</span>
		m_peak(m_class(m)) = m_total(m_class(m));
	}
	mb_peak_newreport = FALSE;

	lck_mtx_unlock(mbuf_mlock);

	(<span class="enscript-type">void</span>) kernel_thread_start((thread_continue_t)mbuf_worker_thread_init,
	    NULL, &amp;thread);
	thread_deallocate(thread);

	ref_cache = mcache_create(<span class="enscript-string">&quot;mext_ref&quot;</span>, <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> ext_ref),
	    0, 0, MCR_SLEEP);

	<span class="enscript-comment">/* Create the cache for each class */</span>
	<span class="enscript-keyword">for</span> (m = 0; m &lt; NELEM(mbuf_table); m++) {
		<span class="enscript-type">void</span> *allocfunc, *freefunc, *auditfunc, *logfunc;
		u_int32_t flags;

		flags = mbuf_debug;
		<span class="enscript-keyword">if</span> (m_class(m) == MC_MBUF_CL || m_class(m) == MC_MBUF_BIGCL ||
		    m_class(m) == MC_MBUF_16KCL) {
			allocfunc = mbuf_cslab_alloc;
			freefunc = mbuf_cslab_free;
			auditfunc = mbuf_cslab_audit;
			logfunc = mleak_logger;
		} <span class="enscript-keyword">else</span> {
			allocfunc = mbuf_slab_alloc;
			freefunc = mbuf_slab_free;
			auditfunc = mbuf_slab_audit;
			logfunc = mleak_logger;
		}

		<span class="enscript-comment">/*
		 * Disable per-CPU caches for jumbo classes if there
		 * is no jumbo cluster pool available in the system.
		 * The cache itself is still created (but will never
		 * be populated) since it simplifies the code.
		 */</span>
		<span class="enscript-keyword">if</span> ((m_class(m) == MC_MBUF_16KCL || m_class(m) == MC_16KCL) &amp;&amp;
		    njcl == 0)
			flags |= MCF_NOCPUCACHE;

		<span class="enscript-keyword">if</span> (!mclfindleak)
			flags |= MCF_NOLEAKLOG;

		m_cache(m) = mcache_create_ext(m_cname(m), m_maxsize(m),
		    allocfunc, freefunc, auditfunc, logfunc, mbuf_slab_notify,
		    (<span class="enscript-type">void</span> *)(uintptr_t)m, flags, MCR_SLEEP);
	}

	<span class="enscript-comment">/*
	 * Allocate structure for per-CPU statistics that's aligned
	 * on the CPU cache boundary; this code assumes that we never
	 * uninitialize this framework, since the original address
	 * before alignment is not saved.
	 */</span>
	ncpu = ml_get_max_cpus();
	MALLOC(buf, <span class="enscript-type">void</span> *, MBUF_MTYPES_SIZE(ncpu) + CPU_CACHE_LINE_SIZE,
	    M_TEMP, M_WAITOK);
	VERIFY(buf != NULL);

	mbuf_mtypes = (mbuf_mtypes_t *)P2ROUNDUP((intptr_t)buf,
	    CPU_CACHE_LINE_SIZE);
	bzero(mbuf_mtypes, MBUF_MTYPES_SIZE(ncpu));

	<span class="enscript-comment">/*
	 * Set the max limit on sb_max to be 1/16 th of the size of
	 * memory allocated for mbuf clusters.
	 */</span>
	high_sb_max = (nmbclusters &lt;&lt; (MCLSHIFT - 4));
	<span class="enscript-keyword">if</span> (high_sb_max &lt; sb_max) {
		<span class="enscript-comment">/* sb_max is too large for this configuration, scale it down */</span>
		<span class="enscript-keyword">if</span> (high_sb_max &gt; (1 &lt;&lt; MBSHIFT)) {
			<span class="enscript-comment">/* We have atleast 16 M of mbuf pool */</span>
			sb_max = high_sb_max;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((nmbclusters &lt;&lt; MCLSHIFT) &gt; (1 &lt;&lt; MBSHIFT)) {
			<span class="enscript-comment">/*
			 * If we have more than 1M of mbufpool, cap the size of
			 * max sock buf at 1M
			 */</span>
			sb_max = high_sb_max = (1 &lt;&lt; MBSHIFT);
		} <span class="enscript-keyword">else</span> {
			sb_max = high_sb_max;
		}
	}

	<span class="enscript-comment">/* allocate space for mbuf_dump_buf */</span>
	MALLOC(mbuf_dump_buf, <span class="enscript-type">char</span> *, MBUF_DUMP_BUF_SIZE, M_TEMP, M_WAITOK);
	VERIFY(mbuf_dump_buf != NULL);

	<span class="enscript-keyword">if</span> (mbuf_debug &amp; MCF_DEBUG) {
		printf(<span class="enscript-string">&quot;%s: MLEN %d, MHLEN %d\n&quot;</span>, __func__,
		    (<span class="enscript-type">int</span>)_MLEN, (<span class="enscript-type">int</span>)_MHLEN);
	}

	printf(<span class="enscript-string">&quot;%s: done [%d MB total pool size, (%d/%d) split]\n&quot;</span>, __func__,
	    (nmbclusters &lt;&lt; MCLSHIFT) &gt;&gt; MBSHIFT,
	    (nclusters &lt;&lt; MCLSHIFT) &gt;&gt; MBSHIFT,
	    (njcl &lt;&lt; MCLSHIFT) &gt;&gt; MBSHIFT);
}

<span class="enscript-comment">/*
 * Obtain a slab of object(s) from the class's freelist.
 */</span>
<span class="enscript-type">static</span> mcache_obj_t *
<span class="enscript-function-name">slab_alloc</span>(mbuf_class_t class, <span class="enscript-type">int</span> wait)
{
	mcl_slab_t *sp;
	mcache_obj_t *buf;

	lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* This should always be NULL for us */</span>
	VERIFY(m_cobjlist(class) == NULL);

	<span class="enscript-comment">/*
	 * Treat composite objects as having longer lifespan by using
	 * a slab from the reverse direction, in hoping that this could
	 * reduce the probability of fragmentation for slabs that hold
	 * more than one buffer chunks (e.g. mbuf slabs).  For other
	 * slabs, this probably doesn't make much of a difference.
	 */</span>
	<span class="enscript-keyword">if</span> ((class == MC_MBUF || class == MC_CL || class == MC_BIGCL)
	    &amp;&amp; (wait &amp; MCR_COMP))
		sp = (mcl_slab_t *)TAILQ_LAST(&amp;m_slablist(class), mcl_slhead);
	<span class="enscript-keyword">else</span>
		sp = (mcl_slab_t *)TAILQ_FIRST(&amp;m_slablist(class));

	<span class="enscript-keyword">if</span> (sp == NULL) {
		VERIFY(m_infree(class) == 0 &amp;&amp; m_slab_cnt(class) == 0);
		<span class="enscript-comment">/* The slab list for this class is empty */</span>
		<span class="enscript-keyword">return</span> (NULL);
	}

	VERIFY(m_infree(class) &gt; 0);
	VERIFY(!slab_is_detached(sp));
	VERIFY(sp-&gt;sl_class == class &amp;&amp;
	    (sp-&gt;sl_flags &amp; (SLF_MAPPED | SLF_PARTIAL)) == SLF_MAPPED);
	buf = sp-&gt;sl_head;
	VERIFY(slab_inrange(sp, buf) &amp;&amp; sp == slab_get(buf));
	sp-&gt;sl_head = buf-&gt;obj_next;
	<span class="enscript-comment">/* Increment slab reference */</span>
	sp-&gt;sl_refcnt++;

	VERIFY(sp-&gt;sl_head != NULL || sp-&gt;sl_refcnt == sp-&gt;sl_chunks);

	<span class="enscript-keyword">if</span> (sp-&gt;sl_head != NULL &amp;&amp; !slab_inrange(sp, sp-&gt;sl_head)) {
		slab_nextptr_panic(sp, sp-&gt;sl_head);
		<span class="enscript-comment">/* In case sl_head is in the map but not in the slab */</span>
		VERIFY(slab_inrange(sp, sp-&gt;sl_head));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (mclaudit != NULL) {
		mcache_audit_t *mca = mcl_audit_buf2mca(class, buf);
		mca-&gt;mca_uflags = 0;
		<span class="enscript-comment">/* Save contents on mbuf objects only */</span>
		<span class="enscript-keyword">if</span> (class == MC_MBUF)
			mca-&gt;mca_uflags |= MB_SCVALID;
	}

	<span class="enscript-keyword">if</span> (class == MC_CL) {
		mbstat.m_clfree = (--m_infree(MC_CL)) + m_infree(MC_MBUF_CL);
		<span class="enscript-comment">/*
		 * A 2K cluster slab can have at most NCLPG references.
		 */</span>
		VERIFY(sp-&gt;sl_refcnt &gt;= 1 &amp;&amp; sp-&gt;sl_refcnt &lt;= NCLPG &amp;&amp;
		    sp-&gt;sl_chunks == NCLPG &amp;&amp; sp-&gt;sl_len == PAGE_SIZE);
		VERIFY(sp-&gt;sl_refcnt &lt; NCLPG || sp-&gt;sl_head == NULL);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_BIGCL) {
		mbstat.m_bigclfree = (--m_infree(MC_BIGCL)) +
		    m_infree(MC_MBUF_BIGCL);
		<span class="enscript-comment">/*
		 * A 4K cluster slab can have NBCLPG references.
		 */</span>
		VERIFY(sp-&gt;sl_refcnt &gt;= 1 &amp;&amp; sp-&gt;sl_chunks == NBCLPG &amp;&amp;
		    sp-&gt;sl_len == PAGE_SIZE &amp;&amp; 
		    (sp-&gt;sl_refcnt &lt; NBCLPG || sp-&gt;sl_head == NULL));
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_16KCL) {
		mcl_slab_t *nsp;
		<span class="enscript-type">int</span> k;

		--m_infree(MC_16KCL);
		VERIFY(sp-&gt;sl_refcnt == 1 &amp;&amp; sp-&gt;sl_chunks == 1 &amp;&amp;
		    sp-&gt;sl_len == m_maxsize(class) &amp;&amp; sp-&gt;sl_head == NULL);
		<span class="enscript-comment">/*
		 * Increment 2nd-Nth slab reference, where N is NSLABSP16KB.
		 * A 16KB big cluster takes NSLABSP16KB slabs, each having at
		 * most 1 reference.
		 */</span>
		<span class="enscript-keyword">for</span> (nsp = sp, k = 1; k &lt; NSLABSP16KB; k++) {
			nsp = nsp-&gt;sl_next;
			<span class="enscript-comment">/* Next slab must already be present */</span>
			VERIFY(nsp != NULL);
			nsp-&gt;sl_refcnt++;
			VERIFY(!slab_is_detached(nsp));
			VERIFY(nsp-&gt;sl_class == MC_16KCL &amp;&amp;
			    nsp-&gt;sl_flags == (SLF_MAPPED | SLF_PARTIAL) &amp;&amp;
			    nsp-&gt;sl_refcnt == 1 &amp;&amp; nsp-&gt;sl_chunks == 0 &amp;&amp;
			    nsp-&gt;sl_len == 0 &amp;&amp; nsp-&gt;sl_base == sp-&gt;sl_base &amp;&amp;
			    nsp-&gt;sl_head == NULL);
		}
	} <span class="enscript-keyword">else</span> {
		VERIFY(class == MC_MBUF);
		--m_infree(MC_MBUF);
		<span class="enscript-comment">/*
		 * If auditing is turned on, this check is
		 * deferred until later in mbuf_slab_audit().
		 */</span>
		<span class="enscript-keyword">if</span> (mclaudit == NULL)
			_MCHECK((<span class="enscript-type">struct</span> mbuf *)buf);
		<span class="enscript-comment">/*
		 * Since we have incremented the reference count above,
		 * an mbuf slab (formerly a 4KB cluster slab that was cut
		 * up into mbufs) must have a reference count between 1
		 * and NMBPG at this point.
		 */</span>
		VERIFY(sp-&gt;sl_refcnt &gt;= 1 &amp;&amp; sp-&gt;sl_refcnt &lt;= NMBPG &amp;&amp;
		    sp-&gt;sl_chunks == NMBPG &amp;&amp;
		    sp-&gt;sl_len == PAGE_SIZE);
		VERIFY(sp-&gt;sl_refcnt &lt; NMBPG || sp-&gt;sl_head == NULL);
	}

	<span class="enscript-comment">/* If empty, remove this slab from the class's freelist */</span>
	<span class="enscript-keyword">if</span> (sp-&gt;sl_head == NULL) {
		VERIFY(class != MC_MBUF || sp-&gt;sl_refcnt == NMBPG);
		VERIFY(class != MC_CL || sp-&gt;sl_refcnt == NCLPG);
		VERIFY(class != MC_BIGCL || sp-&gt;sl_refcnt == NBCLPG);
		slab_remove(sp, class);
	}

	<span class="enscript-keyword">return</span> (buf);
}

<span class="enscript-comment">/*
 * Place a slab of object(s) back into a class's slab list.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">slab_free</span>(mbuf_class_t class, mcache_obj_t *buf)
{
	mcl_slab_t *sp;
	boolean_t reinit_supercl = false;
	mbuf_class_t super_class;

	lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);

	VERIFY(class != MC_16KCL || njcl &gt; 0);
	VERIFY(buf-&gt;obj_next == NULL);

	sp = slab_get(buf);
	VERIFY(sp-&gt;sl_class == class &amp;&amp; slab_inrange(sp, buf) &amp;&amp;
	    (sp-&gt;sl_flags &amp; (SLF_MAPPED | SLF_PARTIAL)) == SLF_MAPPED);

	<span class="enscript-comment">/* Decrement slab reference */</span>
	sp-&gt;sl_refcnt--;

	<span class="enscript-keyword">if</span> (class == MC_CL) {
		VERIFY(IS_P2ALIGNED(buf, MCLBYTES));
		<span class="enscript-comment">/*
		 * A slab that has been splitted for 2KB clusters can have
		 * at most 1 outstanding reference at this point.
		 */</span>
		VERIFY(sp-&gt;sl_refcnt &gt;= 0 &amp;&amp; sp-&gt;sl_refcnt &lt;= (NCLPG - 1) &amp;&amp;
		    sp-&gt;sl_chunks == NCLPG &amp;&amp; sp-&gt;sl_len == PAGE_SIZE);
		VERIFY(sp-&gt;sl_refcnt &lt; (NCLPG - 1) ||
		    (slab_is_detached(sp) &amp;&amp; sp-&gt;sl_head == NULL));
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_BIGCL) {
		VERIFY(IS_P2ALIGNED(buf, MBIGCLBYTES));

		<span class="enscript-comment">/* A 4KB cluster slab can have NBCLPG references at most */</span>
		VERIFY(sp-&gt;sl_refcnt &gt;= 0 &amp;&amp; sp-&gt;sl_chunks == NBCLPG);
		VERIFY(sp-&gt;sl_refcnt &lt; (NBCLPG - 1) ||
		    (slab_is_detached(sp) &amp;&amp; sp-&gt;sl_head == NULL));
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_16KCL) {
		mcl_slab_t *nsp;
		<span class="enscript-type">int</span> k;
		<span class="enscript-comment">/*
		 * A 16KB cluster takes NSLABSP16KB slabs, all must
		 * now have 0 reference.
		 */</span>
		VERIFY(IS_P2ALIGNED(buf, PAGE_SIZE));
		VERIFY(sp-&gt;sl_refcnt == 0 &amp;&amp; sp-&gt;sl_chunks == 1 &amp;&amp;
		    sp-&gt;sl_len == m_maxsize(class) &amp;&amp; sp-&gt;sl_head == NULL);
		VERIFY(slab_is_detached(sp));
		<span class="enscript-keyword">for</span> (nsp = sp, k = 1; k &lt; NSLABSP16KB; k++) {
			nsp = nsp-&gt;sl_next;
			<span class="enscript-comment">/* Next slab must already be present */</span>
			VERIFY(nsp != NULL);
			nsp-&gt;sl_refcnt--;
			VERIFY(slab_is_detached(nsp));
			VERIFY(nsp-&gt;sl_class == MC_16KCL &amp;&amp;
			    (nsp-&gt;sl_flags &amp; (SLF_MAPPED | SLF_PARTIAL)) &amp;&amp;
			    nsp-&gt;sl_refcnt == 0 &amp;&amp; nsp-&gt;sl_chunks == 0 &amp;&amp;
			    nsp-&gt;sl_len == 0 &amp;&amp; nsp-&gt;sl_base == sp-&gt;sl_base &amp;&amp;
			    nsp-&gt;sl_head == NULL);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * A slab that has been splitted for mbufs has at most
		 * NMBPG reference counts.  Since we have decremented
		 * one reference above, it must now be between 0 and
		 * NMBPG-1.
		 */</span>
		VERIFY(class == MC_MBUF);
		VERIFY(sp-&gt;sl_refcnt &gt;= 0 &amp;&amp;
		    sp-&gt;sl_refcnt &lt;= (NMBPG - 1) &amp;&amp;
		    sp-&gt;sl_chunks == NMBPG &amp;&amp;
		    sp-&gt;sl_len == PAGE_SIZE);
		VERIFY(sp-&gt;sl_refcnt &lt; (NMBPG - 1) ||
		    (slab_is_detached(sp) &amp;&amp; sp-&gt;sl_head == NULL));
	}

	<span class="enscript-comment">/*
	 * When auditing is enabled, ensure that the buffer still
	 * contains the free pattern.  Otherwise it got corrupted
	 * while at the CPU cache layer.
	 */</span>
	<span class="enscript-keyword">if</span> (mclaudit != NULL) {
		mcache_audit_t *mca = mcl_audit_buf2mca(class, buf);
		<span class="enscript-keyword">if</span> (mclverify) {
			mcache_audit_free_verify(mca, buf, 0,
			    m_maxsize(class));
		}
		mca-&gt;mca_uflags &amp;= ~MB_SCVALID;
	}

	<span class="enscript-keyword">if</span> (class == MC_CL) {
		mbstat.m_clfree = (++m_infree(MC_CL)) + m_infree(MC_MBUF_CL);
		buf-&gt;obj_next = sp-&gt;sl_head;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_BIGCL) {
		mbstat.m_bigclfree = (++m_infree(MC_BIGCL)) +
		    m_infree(MC_MBUF_BIGCL);
		buf-&gt;obj_next = sp-&gt;sl_head;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_16KCL) {
		++m_infree(MC_16KCL);
	} <span class="enscript-keyword">else</span> {
		++m_infree(MC_MBUF);
		buf-&gt;obj_next = sp-&gt;sl_head;
	}
	sp-&gt;sl_head = buf;

	<span class="enscript-comment">/*
	 * If a slab has been split to either one which holds 2KB clusters,
	 * or one which holds mbufs, turn it back to one which holds a
	 * 4 or 16 KB cluster depending on the page size.
	 */</span>
	<span class="enscript-keyword">if</span> (m_maxsize(MC_BIGCL) == PAGE_SIZE) {
		super_class = MC_BIGCL;
	} <span class="enscript-keyword">else</span> {
		VERIFY(PAGE_SIZE == m_maxsize(MC_16KCL));
		super_class = MC_16KCL;
	}
	<span class="enscript-keyword">if</span> (class == MC_MBUF &amp;&amp; sp-&gt;sl_refcnt == 0 &amp;&amp;
	    m_total(class) &gt;= (m_minlimit(class) + NMBPG) &amp;&amp;
	    m_total(super_class) &lt; m_maxlimit(super_class)) {
		<span class="enscript-type">int</span> i = NMBPG;

		m_total(MC_MBUF) -= NMBPG;
		mbstat.m_mbufs = m_total(MC_MBUF);
		m_infree(MC_MBUF) -= NMBPG;
		mtype_stat_add(MT_FREE, -((<span class="enscript-type">unsigned</span>)NMBPG));

		<span class="enscript-keyword">while</span> (i--) {
			<span class="enscript-type">struct</span> mbuf *m = sp-&gt;sl_head;
			VERIFY(m != NULL);
			sp-&gt;sl_head = m-&gt;m_next;
			m-&gt;m_next = NULL;
		}
		reinit_supercl = true;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_CL &amp;&amp; sp-&gt;sl_refcnt == 0 &amp;&amp;
	    m_total(class) &gt;=  (m_minlimit(class) + NCLPG) &amp;&amp;
	    m_total(super_class) &lt; m_maxlimit(super_class)) {
		<span class="enscript-type">int</span> i = NCLPG;

		m_total(MC_CL) -= NCLPG;
		mbstat.m_clusters = m_total(MC_CL);
		m_infree(MC_CL) -= NCLPG;

		<span class="enscript-keyword">while</span> (i--) {
			<span class="enscript-type">union</span> mcluster *c = sp-&gt;sl_head;
			VERIFY(c != NULL);
			sp-&gt;sl_head = c-&gt;mcl_next;
			c-&gt;mcl_next = NULL;
		}
		reinit_supercl = true;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_BIGCL &amp;&amp; super_class != MC_BIGCL &amp;&amp;
	    sp-&gt;sl_refcnt == 0 &amp;&amp;
	    m_total(class) &gt;= (m_minlimit(class) + NBCLPG) &amp;&amp;
	    m_total(super_class) &lt; m_maxlimit(super_class)) {
		<span class="enscript-type">int</span> i = NBCLPG;

		VERIFY(super_class == MC_16KCL);
		m_total(MC_BIGCL) -= NBCLPG;
		mbstat.m_bigclusters = m_total(MC_BIGCL);
		m_infree(MC_BIGCL) -= NBCLPG;

		<span class="enscript-keyword">while</span> (i--) {
			<span class="enscript-type">union</span> mbigcluster *bc = sp-&gt;sl_head;
			VERIFY(bc != NULL);
			sp-&gt;sl_head = bc-&gt;mbc_next;
			bc-&gt;mbc_next = NULL;
		}
		reinit_supercl = true;
	}

	<span class="enscript-keyword">if</span> (reinit_supercl) {
		VERIFY(sp-&gt;sl_head == NULL);
		VERIFY(m_total(class) &gt;= m_minlimit(class));
		slab_remove(sp, class);

		<span class="enscript-comment">/* Reinitialize it as a cluster for the super class */</span>
		m_total(super_class)++;
		m_infree(super_class)++;
		VERIFY(sp-&gt;sl_flags == (SLF_MAPPED | SLF_DETACHED) &amp;&amp;
		    sp-&gt;sl_len == PAGE_SIZE &amp;&amp; sp-&gt;sl_refcnt == 0);

		slab_init(sp, super_class, SLF_MAPPED, sp-&gt;sl_base,
		    sp-&gt;sl_base, PAGE_SIZE, 0, 1);
		<span class="enscript-keyword">if</span> (mclverify)
			mcache_set_pattern(MCACHE_FREE_PATTERN,
			    (caddr_t)sp-&gt;sl_base, sp-&gt;sl_len);
		((mcache_obj_t *)(sp-&gt;sl_base))-&gt;obj_next = NULL;

		<span class="enscript-keyword">if</span> (super_class == MC_BIGCL) {
			mbstat.m_bigclusters = m_total(MC_BIGCL);
			mbstat.m_bigclfree = m_infree(MC_BIGCL) +
			    m_infree(MC_MBUF_BIGCL);
		}

		VERIFY(slab_is_detached(sp));
		VERIFY(m_total(super_class) &lt;= m_maxlimit(super_class));

		<span class="enscript-comment">/* And finally switch class */</span>
		class = super_class;
	}

	<span class="enscript-comment">/* Reinsert the slab to the class's slab list */</span>
	<span class="enscript-keyword">if</span> (slab_is_detached(sp))
		slab_insert(sp, class);
}

<span class="enscript-comment">/*
 * Common allocator for rudimentary objects called by the CPU cache layer
 * during an allocation request whenever there is no available element in the
 * bucket layer.  It returns one or more elements from the appropriate global
 * freelist.  If the freelist is empty, it will attempt to populate it and
 * retry the allocation.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mbuf_slab_alloc</span>(<span class="enscript-type">void</span> *arg, mcache_obj_t ***plist, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num, <span class="enscript-type">int</span> wait)
{
	mbuf_class_t class = (mbuf_class_t)arg;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> need = num;
	mcache_obj_t **list = *plist;

	ASSERT(MBUF_CLASS_VALID(class) &amp;&amp; !MBUF_CLASS_COMPOSITE(class));
	ASSERT(need &gt; 0);

	lck_mtx_lock(mbuf_mlock);

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-keyword">if</span> ((*list = slab_alloc(class, wait)) != NULL) {
			(*list)-&gt;obj_next = NULL;
			list = *plist = &amp;(*list)-&gt;obj_next;

			<span class="enscript-keyword">if</span> (--need == 0) {
				<span class="enscript-comment">/*
				 * If the number of elements in freelist has
				 * dropped below low watermark, asynchronously
				 * populate the freelist now rather than doing
				 * it later when we run out of elements.
				 */</span>
				<span class="enscript-keyword">if</span> (!mbuf_cached_above(class, wait) &amp;&amp;
				    m_infree(class) &lt; (m_total(class) &gt;&gt; 5)) {
					(<span class="enscript-type">void</span>) freelist_populate(class, 1,
					    M_DONTWAIT);
				}
				<span class="enscript-keyword">break</span>;
			}
		} <span class="enscript-keyword">else</span> {
			VERIFY(m_infree(class) == 0 || class == MC_CL);

			(<span class="enscript-type">void</span>) freelist_populate(class, 1,
			    (wait &amp; MCR_NOSLEEP) ? M_DONTWAIT : M_WAIT);

			<span class="enscript-keyword">if</span> (m_infree(class) &gt; 0)
				<span class="enscript-keyword">continue</span>;

			<span class="enscript-comment">/* Check if there's anything at the cache layer */</span>
			<span class="enscript-keyword">if</span> (mbuf_cached_above(class, wait))
				<span class="enscript-keyword">break</span>;

			<span class="enscript-comment">/* watchdog checkpoint */</span>
			mbuf_watchdog();

			<span class="enscript-comment">/* We have nothing and cannot block; give up */</span>
			<span class="enscript-keyword">if</span> (wait &amp; MCR_NOSLEEP) {
				<span class="enscript-keyword">if</span> (!(wait &amp; MCR_TRYHARD)) {
					m_fail_cnt(class)++;
					mbstat.m_drops++;
					<span class="enscript-keyword">break</span>;
				}
			}

			<span class="enscript-comment">/*
			 * If the freelist is still empty and the caller is
			 * willing to be blocked, sleep on the wait channel
			 * until an element is available.  Otherwise, if
			 * MCR_TRYHARD is set, do our best to satisfy the
			 * request without having to go to sleep.
			 */</span>
			<span class="enscript-keyword">if</span> (mbuf_worker_ready &amp;&amp;
			    mbuf_sleep(class, need, wait))
				<span class="enscript-keyword">break</span>;

			lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);
		}
	}

	m_alloc_cnt(class) += num - need;
	lck_mtx_unlock(mbuf_mlock);

	<span class="enscript-keyword">return</span> (num - need);
}

<span class="enscript-comment">/*
 * Common de-allocator for rudimentary objects called by the CPU cache
 * layer when one or more elements need to be returned to the appropriate
 * global freelist.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_slab_free</span>(<span class="enscript-type">void</span> *arg, mcache_obj_t *list, __unused <span class="enscript-type">int</span> purged)
{
	mbuf_class_t class = (mbuf_class_t)arg;
	mcache_obj_t *nlist;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num = 0;
	<span class="enscript-type">int</span> w;

	ASSERT(MBUF_CLASS_VALID(class) &amp;&amp; !MBUF_CLASS_COMPOSITE(class));

	lck_mtx_lock(mbuf_mlock);

	<span class="enscript-keyword">for</span> (;;) {
		nlist = list-&gt;obj_next;
		list-&gt;obj_next = NULL;
		slab_free(class, list);
		++num;
		<span class="enscript-keyword">if</span> ((list = nlist) == NULL)
			<span class="enscript-keyword">break</span>;
	}
	m_free_cnt(class) += num;

	<span class="enscript-keyword">if</span> ((w = mb_waiters) &gt; 0)
		mb_waiters = 0;

	lck_mtx_unlock(mbuf_mlock);

	<span class="enscript-keyword">if</span> (w != 0)
		wakeup(mb_waitchan);
}

<span class="enscript-comment">/*
 * Common auditor for rudimentary objects called by the CPU cache layer
 * during an allocation or free request.  For the former, this is called
 * after the objects are obtained from either the bucket or slab layer
 * and before they are returned to the caller.  For the latter, this is
 * called immediately during free and before placing the objects into
 * the bucket or slab layer.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_slab_audit</span>(<span class="enscript-type">void</span> *arg, mcache_obj_t *list, boolean_t alloc)
{
	mbuf_class_t class = (mbuf_class_t)arg;
	mcache_audit_t *mca;

	ASSERT(MBUF_CLASS_VALID(class) &amp;&amp; !MBUF_CLASS_COMPOSITE(class));

	<span class="enscript-keyword">while</span> (list != NULL) {
		lck_mtx_lock(mbuf_mlock);
		mca = mcl_audit_buf2mca(class, list);

		<span class="enscript-comment">/* Do the sanity checks */</span>
		<span class="enscript-keyword">if</span> (class == MC_MBUF) {
			mcl_audit_mbuf(mca, list, FALSE, alloc);
			ASSERT(mca-&gt;mca_uflags &amp; MB_SCVALID);
		} <span class="enscript-keyword">else</span> {
			mcl_audit_cluster(mca, list, m_maxsize(class),
			    alloc, TRUE);
			ASSERT(!(mca-&gt;mca_uflags &amp; MB_SCVALID));
		}
		<span class="enscript-comment">/* Record this transaction */</span>
		<span class="enscript-keyword">if</span> (mcltrace)
			mcache_buffer_log(mca, list, m_cache(class), &amp;mb_start);

		<span class="enscript-keyword">if</span> (alloc)
			mca-&gt;mca_uflags |= MB_INUSE;
		<span class="enscript-keyword">else</span>
			mca-&gt;mca_uflags &amp;= ~MB_INUSE;
		<span class="enscript-comment">/* Unpair the object (unconditionally) */</span>
		mca-&gt;mca_uptr = NULL;
		lck_mtx_unlock(mbuf_mlock);

		list = list-&gt;obj_next;
	}
}

<span class="enscript-comment">/*
 * Common notify routine for all caches.  It is called by mcache when
 * one or more objects get freed.  We use this indication to trigger
 * the wakeup of any sleeping threads so that they can retry their
 * allocation requests.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_slab_notify</span>(<span class="enscript-type">void</span> *arg, u_int32_t reason)
{
	mbuf_class_t class = (mbuf_class_t)arg;
	<span class="enscript-type">int</span> w;

	ASSERT(MBUF_CLASS_VALID(class));

	<span class="enscript-keyword">if</span> (reason != MCN_RETRYALLOC)
		<span class="enscript-keyword">return</span>;

	lck_mtx_lock(mbuf_mlock);
	<span class="enscript-keyword">if</span> ((w = mb_waiters) &gt; 0) {
		m_notified(class)++;
		mb_waiters = 0;
	}
	lck_mtx_unlock(mbuf_mlock);

	<span class="enscript-keyword">if</span> (w != 0)
		wakeup(mb_waitchan);
}

<span class="enscript-comment">/*
 * Obtain object(s) from the composite class's freelist.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cslab_alloc</span>(mbuf_class_t class, mcache_obj_t ***plist, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> need = num;
	mcl_slab_t *sp, *clsp, *nsp;
	<span class="enscript-type">struct</span> mbuf *m;
	mcache_obj_t **list = *plist;
	<span class="enscript-type">void</span> *cl;

	VERIFY(need &gt; 0);
	VERIFY(class != MC_MBUF_16KCL || njcl &gt; 0);
	lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* Get what we can from the freelist */</span>
	<span class="enscript-keyword">while</span> ((*list = m_cobjlist(class)) != NULL) {
		MRANGE(*list);

		m = (<span class="enscript-type">struct</span> mbuf *)*list;
		sp = slab_get(m);
		cl = m-&gt;m_ext.ext_buf;
		clsp = slab_get(cl);
		VERIFY(m-&gt;m_flags == M_EXT &amp;&amp; cl != NULL);
		VERIFY(MEXT_RFA(m) != NULL &amp;&amp; MBUF_IS_COMPOSITE(m));

		<span class="enscript-keyword">if</span> (class == MC_MBUF_CL) {
			VERIFY(clsp-&gt;sl_refcnt &gt;= 1 &amp;&amp;
			    clsp-&gt;sl_refcnt &lt;= NCLPG);
		} <span class="enscript-keyword">else</span> {
			VERIFY(clsp-&gt;sl_refcnt &gt;= 1 &amp;&amp;
			    clsp-&gt;sl_refcnt &lt;= NBCLPG);
		}

		<span class="enscript-keyword">if</span> (class == MC_MBUF_16KCL) {
			<span class="enscript-type">int</span> k;
			<span class="enscript-keyword">for</span> (nsp = clsp, k = 1; k &lt; NSLABSP16KB; k++) {
				nsp = nsp-&gt;sl_next;
				<span class="enscript-comment">/* Next slab must already be present */</span>
				VERIFY(nsp != NULL);
				VERIFY(nsp-&gt;sl_refcnt == 1);
			}
		}

		<span class="enscript-keyword">if</span> ((m_cobjlist(class) = (*list)-&gt;obj_next) != NULL &amp;&amp;
		    !MBUF_IN_MAP(m_cobjlist(class))) {
			slab_nextptr_panic(sp, m_cobjlist(class));
			<span class="enscript-comment">/* NOTREACHED */</span>
		}
		(*list)-&gt;obj_next = NULL;
		list = *plist = &amp;(*list)-&gt;obj_next;

		<span class="enscript-keyword">if</span> (--need == 0)
			<span class="enscript-keyword">break</span>;
	}
	m_infree(class) -= (num - need);

	<span class="enscript-keyword">return</span> (num - need);
}

<span class="enscript-comment">/*
 * Place object(s) back into a composite class's freelist.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">cslab_free</span>(mbuf_class_t class, mcache_obj_t *list, <span class="enscript-type">int</span> purged)
{
	mcache_obj_t *o, *tail;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num = 0;
	<span class="enscript-type">struct</span> mbuf *m, *ms;
	mcache_audit_t *mca = NULL;
	mcache_obj_t *ref_list = NULL;
	mcl_slab_t *clsp, *nsp;
	<span class="enscript-type">void</span> *cl;
	mbuf_class_t cl_class;

	ASSERT(MBUF_CLASS_VALID(class) &amp;&amp; MBUF_CLASS_COMPOSITE(class));
	VERIFY(class != MC_MBUF_16KCL || njcl &gt; 0);
	lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">if</span> (class == MC_MBUF_CL) {
		cl_class = MC_CL;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_MBUF_BIGCL) {
		cl_class = MC_BIGCL;
	} <span class="enscript-keyword">else</span> {
		VERIFY(class == MC_MBUF_16KCL);
		cl_class = MC_16KCL;
	}

	o = tail = list;

	<span class="enscript-keyword">while</span> ((m = ms = (<span class="enscript-type">struct</span> mbuf *)o) != NULL) {
		mcache_obj_t *rfa, *nexto = o-&gt;obj_next;

		<span class="enscript-comment">/* Do the mbuf sanity checks */</span>
		<span class="enscript-keyword">if</span> (mclaudit != NULL) {
			mca = mcl_audit_buf2mca(MC_MBUF, (mcache_obj_t *)m);
			<span class="enscript-keyword">if</span> (mclverify) {
				mcache_audit_free_verify(mca, m, 0,
				    m_maxsize(MC_MBUF));
			}
			ms = MCA_SAVED_MBUF_PTR(mca);
		}

		<span class="enscript-comment">/* Do the cluster sanity checks */</span>
		cl = ms-&gt;m_ext.ext_buf;
		clsp = slab_get(cl);
		<span class="enscript-keyword">if</span> (mclverify) {
			size_t size = m_maxsize(cl_class);
			mcache_audit_free_verify(mcl_audit_buf2mca(cl_class,
			    (mcache_obj_t *)cl), cl, 0, size);
		}
		VERIFY(ms-&gt;m_type == MT_FREE);
		VERIFY(ms-&gt;m_flags == M_EXT);
		VERIFY(MEXT_RFA(ms) != NULL &amp;&amp; MBUF_IS_COMPOSITE(ms));
		<span class="enscript-keyword">if</span> (cl_class == MC_CL) {
			VERIFY(clsp-&gt;sl_refcnt &gt;= 1 &amp;&amp;
			    clsp-&gt;sl_refcnt &lt;= NCLPG);
		} <span class="enscript-keyword">else</span> {
			VERIFY(clsp-&gt;sl_refcnt &gt;= 1 &amp;&amp; 
			    clsp-&gt;sl_refcnt &lt;= NBCLPG);
		}
		<span class="enscript-keyword">if</span> (cl_class == MC_16KCL) {
			<span class="enscript-type">int</span> k;
			<span class="enscript-keyword">for</span> (nsp = clsp, k = 1; k &lt; NSLABSP16KB; k++) {
				nsp = nsp-&gt;sl_next;
				<span class="enscript-comment">/* Next slab must already be present */</span>
				VERIFY(nsp != NULL);
				VERIFY(nsp-&gt;sl_refcnt == 1);
			}
		}

		<span class="enscript-comment">/*
		 * If we're asked to purge, restore the actual mbuf using
		 * contents of the shadow structure (if auditing is enabled)
		 * and clear EXTF_COMPOSITE flag from the mbuf, as we are
		 * about to free it and the attached cluster into their caches.
		 */</span>
		<span class="enscript-keyword">if</span> (purged) {
			<span class="enscript-comment">/* Restore constructed mbuf fields */</span>
			<span class="enscript-keyword">if</span> (mclaudit != NULL)
				mcl_audit_restore_mbuf(m, mca, TRUE);

			MEXT_REF(m) = 0;
			MEXT_FLAGS(m) = 0;

			rfa = (mcache_obj_t *)(<span class="enscript-type">void</span> *)MEXT_RFA(m);
			rfa-&gt;obj_next = ref_list;
			ref_list = rfa;
			MEXT_RFA(m) = NULL;

			m-&gt;m_type = MT_FREE;
			m-&gt;m_flags = m-&gt;m_len = 0;
			m-&gt;m_next = m-&gt;m_nextpkt = NULL;

			<span class="enscript-comment">/* Save mbuf fields and make auditing happy */</span>
			<span class="enscript-keyword">if</span> (mclaudit != NULL)
				mcl_audit_mbuf(mca, o, FALSE, FALSE);

			VERIFY(m_total(class) &gt; 0);
			m_total(class)--;

			<span class="enscript-comment">/* Free the mbuf */</span>
			o-&gt;obj_next = NULL;
			slab_free(MC_MBUF, o);

			<span class="enscript-comment">/* And free the cluster */</span>
			((mcache_obj_t *)cl)-&gt;obj_next = NULL;
			<span class="enscript-keyword">if</span> (class == MC_MBUF_CL)
				slab_free(MC_CL, cl);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_MBUF_BIGCL)
				slab_free(MC_BIGCL, cl);
			<span class="enscript-keyword">else</span>
				slab_free(MC_16KCL, cl);
		}

		++num;
		tail = o;
		o = nexto;
	}

	<span class="enscript-keyword">if</span> (!purged) {
		tail-&gt;obj_next = m_cobjlist(class);
		m_cobjlist(class) = list;
		m_infree(class) += num;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ref_list != NULL) {
		mcache_free_ext(ref_cache, ref_list);
	}

	<span class="enscript-keyword">return</span> (num);
}

<span class="enscript-comment">/*
 * Common allocator for composite objects called by the CPU cache layer
 * during an allocation request whenever there is no available element in
 * the bucket layer.  It returns one or more composite elements from the
 * appropriate global freelist.  If the freelist is empty, it will attempt
 * to obtain the rudimentary objects from their caches and construct them
 * into composite mbuf + cluster objects.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">mbuf_cslab_alloc</span>(<span class="enscript-type">void</span> *arg, mcache_obj_t ***plist, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> needed,
    <span class="enscript-type">int</span> wait)
{
	mbuf_class_t class = (mbuf_class_t)arg;
	mbuf_class_t cl_class = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num = 0, cnum = 0, want = needed;
	mcache_obj_t *ref_list = NULL;
	mcache_obj_t *mp_list = NULL;
	mcache_obj_t *clp_list = NULL;
	mcache_obj_t **list;
	<span class="enscript-type">struct</span> ext_ref *rfa;
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">void</span> *cl;

	ASSERT(MBUF_CLASS_VALID(class) &amp;&amp; MBUF_CLASS_COMPOSITE(class));
	ASSERT(needed &gt; 0);

	VERIFY(class != MC_MBUF_16KCL || njcl &gt; 0);

	<span class="enscript-comment">/* There should not be any slab for this class */</span>
	VERIFY(m_slab_cnt(class) == 0 &amp;&amp;
	    m_slablist(class).tqh_first == NULL &amp;&amp;
	    m_slablist(class).tqh_last == NULL);

	lck_mtx_lock(mbuf_mlock);

	<span class="enscript-comment">/* Try using the freelist first */</span>
	num = cslab_alloc(class, plist, needed);
	list = *plist;
	<span class="enscript-keyword">if</span> (num == needed) {
		m_alloc_cnt(class) += num;
		lck_mtx_unlock(mbuf_mlock);
		<span class="enscript-keyword">return</span> (needed);
	}

	lck_mtx_unlock(mbuf_mlock);

	<span class="enscript-comment">/*
	 * We could not satisfy the request using the freelist alone;
	 * allocate from the appropriate rudimentary caches and use
	 * whatever we can get to construct the composite objects.
	 */</span>
	needed -= num;

	<span class="enscript-comment">/*
	 * Mark these allocation requests as coming from a composite cache.
	 * Also, if the caller is willing to be blocked, mark the request
	 * with MCR_FAILOK such that we don't end up sleeping at the mbuf
	 * slab layer waiting for the individual object when one or more
	 * of the already-constructed composite objects are available.
	 */</span>
	wait |= MCR_COMP;
	<span class="enscript-keyword">if</span> (!(wait &amp; MCR_NOSLEEP))
		wait |= MCR_FAILOK;

	<span class="enscript-comment">/* allocate mbufs */</span>
	needed = mcache_alloc_ext(m_cache(MC_MBUF), &amp;mp_list, needed, wait);
	<span class="enscript-keyword">if</span> (needed == 0) {
		ASSERT(mp_list == NULL);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-comment">/* allocate clusters */</span>
	<span class="enscript-keyword">if</span> (class == MC_MBUF_CL) {
		cl_class = MC_CL;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_MBUF_BIGCL) {
		cl_class = MC_BIGCL;
	} <span class="enscript-keyword">else</span> {
		VERIFY(class == MC_MBUF_16KCL);
		cl_class = MC_16KCL;
	}
	needed = mcache_alloc_ext(m_cache(cl_class), &amp;clp_list, needed, wait);
	<span class="enscript-keyword">if</span> (needed == 0) {
		ASSERT(clp_list == NULL);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	needed = mcache_alloc_ext(ref_cache, &amp;ref_list, needed, wait);
	<span class="enscript-keyword">if</span> (needed == 0) {
		ASSERT(ref_list == NULL);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-comment">/*
	 * By this time &quot;needed&quot; is MIN(mbuf, cluster, ref).  Any left
	 * overs will get freed accordingly before we return to caller.
	 */</span>
	<span class="enscript-keyword">for</span> (cnum = 0; cnum &lt; needed; cnum++) {
		<span class="enscript-type">struct</span> mbuf *ms;

		m = ms = (<span class="enscript-type">struct</span> mbuf *)mp_list;
		mp_list = mp_list-&gt;obj_next;

		cl = clp_list;
		clp_list = clp_list-&gt;obj_next;
		((mcache_obj_t *)cl)-&gt;obj_next = NULL;

		rfa = (<span class="enscript-type">struct</span> ext_ref *)ref_list;
		ref_list = ref_list-&gt;obj_next;
		((mcache_obj_t *)(<span class="enscript-type">void</span> *)rfa)-&gt;obj_next = NULL;

		<span class="enscript-comment">/*
		 * If auditing is enabled, construct the shadow mbuf
		 * in the audit structure instead of in the actual one.
		 * mbuf_cslab_audit() will take care of restoring the
		 * contents after the integrity check.
		 */</span>
		<span class="enscript-keyword">if</span> (mclaudit != NULL) {
			mcache_audit_t *mca, *cl_mca;

			lck_mtx_lock(mbuf_mlock);
			mca = mcl_audit_buf2mca(MC_MBUF, (mcache_obj_t *)m);
			ms = MCA_SAVED_MBUF_PTR(mca);
			cl_mca = mcl_audit_buf2mca(cl_class,
			    (mcache_obj_t *)cl);

			<span class="enscript-comment">/*
			 * Pair them up.  Note that this is done at the time
			 * the mbuf+cluster objects are constructed.  This
			 * information should be treated as &quot;best effort&quot;
			 * debugging hint since more than one mbufs can refer
			 * to a cluster.  In that case, the cluster might not
			 * be freed along with the mbuf it was paired with.
			 */</span>
			mca-&gt;mca_uptr = cl_mca;
			cl_mca-&gt;mca_uptr = mca;

			ASSERT(mca-&gt;mca_uflags &amp; MB_SCVALID);
			ASSERT(!(cl_mca-&gt;mca_uflags &amp; MB_SCVALID));
			lck_mtx_unlock(mbuf_mlock);

			<span class="enscript-comment">/* Technically, they are in the freelist */</span>
			<span class="enscript-keyword">if</span> (mclverify) {
				size_t size;

				mcache_set_pattern(MCACHE_FREE_PATTERN, m,
				    m_maxsize(MC_MBUF));

				<span class="enscript-keyword">if</span> (class == MC_MBUF_CL)
					size = m_maxsize(MC_CL);
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_MBUF_BIGCL)
					size = m_maxsize(MC_BIGCL);
				<span class="enscript-keyword">else</span>
					size = m_maxsize(MC_16KCL);

				mcache_set_pattern(MCACHE_FREE_PATTERN, cl,
				    size);
			}
		}

		MBUF_INIT(ms, 0, MT_FREE);
		<span class="enscript-keyword">if</span> (class == MC_MBUF_16KCL) {
			MBUF_16KCL_INIT(ms, cl, rfa, 0, EXTF_COMPOSITE);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_MBUF_BIGCL) {
			MBUF_BIGCL_INIT(ms, cl, rfa, 0, EXTF_COMPOSITE);
		} <span class="enscript-keyword">else</span> {
			MBUF_CL_INIT(ms, cl, rfa, 0, EXTF_COMPOSITE);
		}
		VERIFY(ms-&gt;m_flags == M_EXT);
		VERIFY(MEXT_RFA(ms) != NULL &amp;&amp; MBUF_IS_COMPOSITE(ms));

		*list = (mcache_obj_t *)m;
		(*list)-&gt;obj_next = NULL;
		list = *plist = &amp;(*list)-&gt;obj_next;
	}

<span class="enscript-reference">fail</span>:
	<span class="enscript-comment">/*
	 * Free up what's left of the above.
	 */</span>
	<span class="enscript-keyword">if</span> (mp_list != NULL)
		mcache_free_ext(m_cache(MC_MBUF), mp_list);
	<span class="enscript-keyword">if</span> (clp_list != NULL)
		mcache_free_ext(m_cache(cl_class), clp_list);
	<span class="enscript-keyword">if</span> (ref_list != NULL)
		mcache_free_ext(ref_cache, ref_list);

	lck_mtx_lock(mbuf_mlock);
	<span class="enscript-keyword">if</span> (num &gt; 0 || cnum &gt; 0) {
		m_total(class) += cnum;
		VERIFY(m_total(class) &lt;= m_maxlimit(class));
		m_alloc_cnt(class) += num + cnum;
	}
	<span class="enscript-keyword">if</span> ((num + cnum) &lt; want)
		m_fail_cnt(class) += (want - (num + cnum));
	lck_mtx_unlock(mbuf_mlock);

	<span class="enscript-keyword">return</span> (num + cnum);
}

<span class="enscript-comment">/*
 * Common de-allocator for composite objects called by the CPU cache
 * layer when one or more elements need to be returned to the appropriate
 * global freelist.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_cslab_free</span>(<span class="enscript-type">void</span> *arg, mcache_obj_t *list, <span class="enscript-type">int</span> purged)
{
	mbuf_class_t class = (mbuf_class_t)arg;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num;
	<span class="enscript-type">int</span> w;

	ASSERT(MBUF_CLASS_VALID(class) &amp;&amp; MBUF_CLASS_COMPOSITE(class));

	lck_mtx_lock(mbuf_mlock);

	num = cslab_free(class, list, purged);
	m_free_cnt(class) += num;

	<span class="enscript-keyword">if</span> ((w = mb_waiters) &gt; 0)
		mb_waiters = 0;

	lck_mtx_unlock(mbuf_mlock);

	<span class="enscript-keyword">if</span> (w != 0)
		wakeup(mb_waitchan);
}

<span class="enscript-comment">/*
 * Common auditor for composite objects called by the CPU cache layer
 * during an allocation or free request.  For the former, this is called
 * after the objects are obtained from either the bucket or slab layer
 * and before they are returned to the caller.  For the latter, this is
 * called immediately during free and before placing the objects into
 * the bucket or slab layer.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_cslab_audit</span>(<span class="enscript-type">void</span> *arg, mcache_obj_t *list, boolean_t alloc)
{
	mbuf_class_t class = (mbuf_class_t)arg, cl_class;
	mcache_audit_t *mca;
	<span class="enscript-type">struct</span> mbuf *m, *ms;
	mcl_slab_t *clsp, *nsp;
	size_t cl_size;
	<span class="enscript-type">void</span> *cl;

	ASSERT(MBUF_CLASS_VALID(class) &amp;&amp; MBUF_CLASS_COMPOSITE(class));
	<span class="enscript-keyword">if</span> (class == MC_MBUF_CL)
		cl_class = MC_CL;
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_MBUF_BIGCL)
		cl_class = MC_BIGCL;
	<span class="enscript-keyword">else</span>
		cl_class = MC_16KCL;
	cl_size = m_maxsize(cl_class);

	<span class="enscript-keyword">while</span> ((m = ms = (<span class="enscript-type">struct</span> mbuf *)list) != NULL) {
		lck_mtx_lock(mbuf_mlock);
		<span class="enscript-comment">/* Do the mbuf sanity checks and record its transaction */</span>
		mca = mcl_audit_buf2mca(MC_MBUF, (mcache_obj_t *)m);
		mcl_audit_mbuf(mca, m, TRUE, alloc);
		<span class="enscript-keyword">if</span> (mcltrace)
			mcache_buffer_log(mca, m, m_cache(class), &amp;mb_start);

		<span class="enscript-keyword">if</span> (alloc)
			mca-&gt;mca_uflags |= MB_COMP_INUSE;
		<span class="enscript-keyword">else</span>
			mca-&gt;mca_uflags &amp;= ~MB_COMP_INUSE;

		<span class="enscript-comment">/*
		 * Use the shadow mbuf in the audit structure if we are
		 * freeing, since the contents of the actual mbuf has been
		 * pattern-filled by the above call to mcl_audit_mbuf().
		 */</span>
		<span class="enscript-keyword">if</span> (!alloc &amp;&amp; mclverify)
			ms = MCA_SAVED_MBUF_PTR(mca);

		<span class="enscript-comment">/* Do the cluster sanity checks and record its transaction */</span>
		cl = ms-&gt;m_ext.ext_buf;
		clsp = slab_get(cl);
		VERIFY(ms-&gt;m_flags == M_EXT &amp;&amp; cl != NULL);
		VERIFY(MEXT_RFA(ms) != NULL &amp;&amp; MBUF_IS_COMPOSITE(ms));
		<span class="enscript-keyword">if</span> (class == MC_MBUF_CL)
			VERIFY(clsp-&gt;sl_refcnt &gt;= 1 &amp;&amp;
			    clsp-&gt;sl_refcnt &lt;= NCLPG);
		<span class="enscript-keyword">else</span>
			VERIFY(clsp-&gt;sl_refcnt &gt;= 1 &amp;&amp;
			    clsp-&gt;sl_refcnt &lt;= NBCLPG);

		<span class="enscript-keyword">if</span> (class == MC_MBUF_16KCL) {
			<span class="enscript-type">int</span> k;
			<span class="enscript-keyword">for</span> (nsp = clsp, k = 1; k &lt; NSLABSP16KB; k++) {
				nsp = nsp-&gt;sl_next;
				<span class="enscript-comment">/* Next slab must already be present */</span>
				VERIFY(nsp != NULL);
				VERIFY(nsp-&gt;sl_refcnt == 1);
			}
		}


		mca = mcl_audit_buf2mca(cl_class, cl);
		mcl_audit_cluster(mca, cl, cl_size, alloc, FALSE);
		<span class="enscript-keyword">if</span> (mcltrace)
			mcache_buffer_log(mca, cl, m_cache(class), &amp;mb_start);

		<span class="enscript-keyword">if</span> (alloc)
			mca-&gt;mca_uflags |= MB_COMP_INUSE;
		<span class="enscript-keyword">else</span>
			mca-&gt;mca_uflags &amp;= ~MB_COMP_INUSE;
		lck_mtx_unlock(mbuf_mlock);

		list = list-&gt;obj_next;
	}
}

<span class="enscript-comment">/*
 * Allocate some number of mbuf clusters and place on cluster freelist.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">m_clalloc</span>(<span class="enscript-type">const</span> u_int32_t num, <span class="enscript-type">const</span> <span class="enscript-type">int</span> wait, <span class="enscript-type">const</span> u_int32_t bufsize)
{
	<span class="enscript-type">int</span> i, count = 0;
	vm_size_t size = 0;
	<span class="enscript-type">int</span> numpages = 0, large_buffer;
	vm_offset_t page = 0;
	mcache_audit_t *mca_list = NULL;
	mcache_obj_t *con_list = NULL;
	mcl_slab_t *sp;
	mbuf_class_t class;

	<span class="enscript-comment">/* Set if a buffer allocation needs allocation of multiple pages */</span>
	large_buffer = ((bufsize == m_maxsize(MC_16KCL)) &amp;&amp;
		PAGE_SIZE &lt; M16KCLBYTES);
	VERIFY(bufsize == m_maxsize(MC_BIGCL) ||
	    bufsize == m_maxsize(MC_16KCL));

	VERIFY((bufsize == PAGE_SIZE) ||
	    (bufsize &gt; PAGE_SIZE &amp;&amp; bufsize == m_maxsize(MC_16KCL)));

	<span class="enscript-keyword">if</span> (bufsize == m_size(MC_BIGCL))
		class = MC_BIGCL;
	<span class="enscript-keyword">else</span>
		class = MC_16KCL;

	lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/*
	 * Multiple threads may attempt to populate the cluster map one
	 * after another.  Since we drop the lock below prior to acquiring
	 * the physical page(s), our view of the cluster map may no longer
	 * be accurate, and we could end up over-committing the pages beyond
	 * the maximum allowed for each class.  To prevent it, this entire
	 * operation (including the page mapping) is serialized.
	 */</span>
	<span class="enscript-keyword">while</span> (mb_clalloc_busy) {
		mb_clalloc_waiters++;
		(<span class="enscript-type">void</span>) msleep(mb_clalloc_waitchan, mbuf_mlock,
		    (PZERO-1), <span class="enscript-string">&quot;m_clalloc&quot;</span>, NULL);
		lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);
	}

	<span class="enscript-comment">/* We are busy now; tell everyone else to go away */</span>
	mb_clalloc_busy = TRUE;

	<span class="enscript-comment">/*
	 * Honor the caller's wish to block or not block.  We have a way
	 * to grow the pool asynchronously using the mbuf worker thread.
	 */</span>
	i = m_howmany(num, bufsize);
	<span class="enscript-keyword">if</span> (i == 0 || (wait &amp; M_DONTWAIT))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

	lck_mtx_unlock(mbuf_mlock);

	size = round_page(i * bufsize);
	page = kmem_mb_alloc(mb_map, size, large_buffer);

	<span class="enscript-comment">/*
	 * If we did ask for &quot;n&quot; 16KB physically contiguous chunks
	 * and didn't get them, then please try again without this
	 * restriction.
	 */</span>
	<span class="enscript-keyword">if</span> (large_buffer &amp;&amp; page == 0)
		page = kmem_mb_alloc(mb_map, size, 0);

	<span class="enscript-keyword">if</span> (page == 0) {
		<span class="enscript-keyword">if</span> (bufsize == m_maxsize(MC_BIGCL)) {
			<span class="enscript-comment">/* Try for 1 page if failed */</span>
			size = PAGE_SIZE;
			page = kmem_mb_alloc(mb_map, size, 0);
		}

		<span class="enscript-keyword">if</span> (page == 0) {
			lck_mtx_lock(mbuf_mlock);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
		}
	}

	VERIFY(IS_P2ALIGNED(page, PAGE_SIZE));
	numpages = size / PAGE_SIZE;

	<span class="enscript-comment">/* If auditing is enabled, allocate the audit structures now */</span>
	<span class="enscript-keyword">if</span> (mclaudit != NULL) {
		<span class="enscript-type">int</span> needed;

		<span class="enscript-comment">/*
		 * Yes, I realize this is a waste of memory for clusters
		 * that never get transformed into mbufs, as we may end
		 * up with NMBPG-1 unused audit structures per cluster.
		 * But doing so tremendously simplifies the allocation
		 * strategy, since at this point we are not holding the
		 * mbuf lock and the caller is okay to be blocked.
		 */</span>
		<span class="enscript-keyword">if</span> (bufsize == PAGE_SIZE) {
			needed = numpages * NMBPG;

			i = mcache_alloc_ext(mcl_audit_con_cache,
			    &amp;con_list, needed, MCR_SLEEP);

			VERIFY(con_list != NULL &amp;&amp; i == needed);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * if multiple 4K pages are being used for a
			 * 16K cluster 
			 */</span> 
			needed = numpages / NSLABSP16KB;
		}

		i = mcache_alloc_ext(mcache_audit_cache,
		    (mcache_obj_t **)&amp;mca_list, needed, MCR_SLEEP);

		VERIFY(mca_list != NULL &amp;&amp; i == needed);
	}

	lck_mtx_lock(mbuf_mlock);

	<span class="enscript-keyword">for</span> (i = 0; i &lt; numpages; i++, page += PAGE_SIZE) {
		ppnum_t offset =
		    ((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)page - mbutl) &gt;&gt; PAGE_SHIFT;
		ppnum_t new_page = pmap_find_phys(kernel_pmap, page);

		<span class="enscript-comment">/*
		 * If there is a mapper the appropriate I/O page is
		 * returned; zero out the page to discard its past
		 * contents to prevent exposing leftover kernel memory.
		 */</span>
		VERIFY(offset &lt; mcl_pages);
		<span class="enscript-keyword">if</span> (mcl_paddr_base != 0) {
			bzero((<span class="enscript-type">void</span> *)(uintptr_t) page, PAGE_SIZE);
			new_page = IOMapperInsertPage(mcl_paddr_base,
			    offset, new_page);
		}
		mcl_paddr[offset] = new_page;

		<span class="enscript-comment">/* Pattern-fill this fresh page */</span>
		<span class="enscript-keyword">if</span> (mclverify) {
			mcache_set_pattern(MCACHE_FREE_PATTERN,
			    (caddr_t)page, PAGE_SIZE);
		}
		<span class="enscript-keyword">if</span> (bufsize == PAGE_SIZE) {
			mcache_obj_t *buf;
			<span class="enscript-comment">/* One for the entire page */</span>
			sp = slab_get((<span class="enscript-type">void</span> *)page);
			<span class="enscript-keyword">if</span> (mclaudit != NULL) {
				mcl_audit_init((<span class="enscript-type">void</span> *)page,
				    &amp;mca_list, &amp;con_list,
				    AUDIT_CONTENTS_SIZE, NMBPG);
			}
			VERIFY(sp-&gt;sl_refcnt == 0 &amp;&amp; sp-&gt;sl_flags == 0);
			slab_init(sp, class, SLF_MAPPED, (<span class="enscript-type">void</span> *)page,
			    (<span class="enscript-type">void</span> *)page, PAGE_SIZE, 0, 1);
			buf = (mcache_obj_t *)page;
			buf-&gt;obj_next = NULL;

			<span class="enscript-comment">/* Insert this slab */</span>
			slab_insert(sp, class);

			<span class="enscript-comment">/* Update stats now since slab_get drops the lock */</span>
			++m_infree(class);
			++m_total(class);
			VERIFY(m_total(class) &lt;= m_maxlimit(class));
			<span class="enscript-keyword">if</span> (class == MC_BIGCL) {
				mbstat.m_bigclfree = m_infree(MC_BIGCL) +
				    m_infree(MC_MBUF_BIGCL);
				mbstat.m_bigclusters = m_total(MC_BIGCL);
			}
			++count;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((bufsize &gt; PAGE_SIZE) &amp;&amp;
		    (i % NSLABSP16KB) == 0) {
			<span class="enscript-type">union</span> m16kcluster *m16kcl = (<span class="enscript-type">union</span> m16kcluster *)page;
			mcl_slab_t *nsp;
			<span class="enscript-type">int</span> k;
				
			<span class="enscript-comment">/* One for the entire 16KB */</span>
			sp = slab_get(m16kcl);
			<span class="enscript-keyword">if</span> (mclaudit != NULL)
				mcl_audit_init(m16kcl, &amp;mca_list, NULL, 0, 1);

			VERIFY(sp-&gt;sl_refcnt == 0 &amp;&amp; sp-&gt;sl_flags == 0);
			slab_init(sp, MC_16KCL, SLF_MAPPED,
			    m16kcl, m16kcl, bufsize, 0, 1);
			m16kcl-&gt;m16kcl_next = NULL;

			<span class="enscript-comment">/*
			 * 2nd-Nth page's slab is part of the first one,
			 * where N is NSLABSP16KB.
			 */</span>
			<span class="enscript-keyword">for</span> (k = 1; k &lt; NSLABSP16KB; k++) {
				nsp = slab_get(((<span class="enscript-type">union</span> mbigcluster *)page) + k);
				VERIFY(nsp-&gt;sl_refcnt == 0 &amp;&amp;
				    nsp-&gt;sl_flags == 0);
				slab_init(nsp, MC_16KCL,
				    SLF_MAPPED | SLF_PARTIAL,
				    m16kcl, NULL, 0, 0, 0);
			}
			<span class="enscript-comment">/* Insert this slab */</span>
			slab_insert(sp, MC_16KCL);

			<span class="enscript-comment">/* Update stats now since slab_get drops the lock */</span>
			++m_infree(MC_16KCL);
			++m_total(MC_16KCL);
			VERIFY(m_total(MC_16KCL) &lt;= m_maxlimit(MC_16KCL));
			++count;
		}
	}
	VERIFY(mca_list == NULL &amp;&amp; con_list == NULL);

	<span class="enscript-keyword">if</span> (!mb_peak_newreport &amp;&amp; mbuf_report_usage(class))
		mb_peak_newreport = TRUE;

	<span class="enscript-comment">/* We're done; let others enter */</span>
	mb_clalloc_busy = FALSE;
	<span class="enscript-keyword">if</span> (mb_clalloc_waiters &gt; 0) {
		mb_clalloc_waiters = 0;
		wakeup(mb_clalloc_waitchan);
	}

	<span class="enscript-keyword">return</span> (count);
<span class="enscript-reference">out</span>:
	lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* We're done; let others enter */</span>
	mb_clalloc_busy = FALSE;
	<span class="enscript-keyword">if</span> (mb_clalloc_waiters &gt; 0) {
		mb_clalloc_waiters = 0;
		wakeup(mb_clalloc_waitchan);
	}

	<span class="enscript-comment">/*
	 * When non-blocking we kick a thread if we have to grow the
	 * pool or if the number of free clusters is less than requested.
	 */</span>
	<span class="enscript-keyword">if</span> (class == MC_BIGCL) {
		<span class="enscript-keyword">if</span> (i &gt; 0) {
			<span class="enscript-comment">/*
			 * Remember total number of 4KB clusters needed
			 * at this time.
			 */</span>
			i += m_total(MC_BIGCL);
			<span class="enscript-keyword">if</span> (i &gt; mbuf_expand_big) {
				mbuf_expand_big = i;
				<span class="enscript-keyword">if</span> (mbuf_worker_ready)
					wakeup((caddr_t)&amp;mbuf_worker_run);
			}
		}

		<span class="enscript-keyword">if</span> (m_infree(MC_BIGCL) &gt;= num)
			<span class="enscript-keyword">return</span> (1);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (i &gt; 0) {
			<span class="enscript-comment">/*
			 * Remember total number of 16KB clusters needed
			 * at this time.
			 */</span>
			i += m_total(MC_16KCL);
			<span class="enscript-keyword">if</span> (i &gt; mbuf_expand_16k) {
				mbuf_expand_16k = i;
				<span class="enscript-keyword">if</span> (mbuf_worker_ready)
					wakeup((caddr_t)&amp;mbuf_worker_run);
			}
		}

		<span class="enscript-keyword">if</span> (m_infree(MC_16KCL) &gt;= num)
			<span class="enscript-keyword">return</span> (1);
	}
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Populate the global freelist of the corresponding buffer class.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">freelist_populate</span>(mbuf_class_t class, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num, <span class="enscript-type">int</span> wait)
{
	mcache_obj_t *o = NULL;
	<span class="enscript-type">int</span> i, numpages = 0, count;
	mbuf_class_t super_class;

	VERIFY(class == MC_MBUF || class == MC_CL || class == MC_BIGCL ||
	    class == MC_16KCL);

	lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);

	VERIFY(PAGE_SIZE == m_maxsize(MC_BIGCL) ||
	    PAGE_SIZE == m_maxsize(MC_16KCL));

	<span class="enscript-keyword">if</span> (m_maxsize(class) &gt;= PAGE_SIZE)
		<span class="enscript-keyword">return</span>(m_clalloc(num, wait, m_maxsize(class)) != 0);

	<span class="enscript-comment">/*
	 * The rest of the function will allocate pages and will slice
	 * them up into the right size
	 */</span>

	numpages = (num * m_size(class) + PAGE_SIZE - 1) / PAGE_SIZE;

	<span class="enscript-comment">/* Currently assume that pages are 4K or 16K */</span>
	<span class="enscript-keyword">if</span> (PAGE_SIZE == m_maxsize(MC_BIGCL))
		super_class = MC_BIGCL;
	<span class="enscript-keyword">else</span>
		super_class = MC_16KCL;

	i = m_clalloc(numpages, wait, m_maxsize(super_class));

	<span class="enscript-comment">/* Respect the minimum limit  of super class */</span>
	<span class="enscript-keyword">if</span> (m_total(super_class) == m_maxlimit(super_class) &amp;&amp;
	    m_infree(super_class) &lt;= m_minlimit(super_class))
		<span class="enscript-keyword">if</span> (wait &amp; MCR_COMP)
				<span class="enscript-keyword">return</span> (0);

	<span class="enscript-comment">/* how many objects will we cut the page into? */</span>
	<span class="enscript-type">int</span> numobj = PAGE_SIZE / m_maxsize(class);

	<span class="enscript-keyword">for</span> (count = 0; count &lt; numpages; count++) {
		<span class="enscript-comment">/* respect totals, minlimit, maxlimit */</span>
		<span class="enscript-keyword">if</span> (m_total(super_class) &lt;= m_minlimit(super_class) ||
		    m_total(class) &gt;= m_maxlimit(class))
			<span class="enscript-keyword">break</span>;

		<span class="enscript-keyword">if</span> ((o = slab_alloc(super_class, wait)) == NULL)
			<span class="enscript-keyword">break</span>;

		<span class="enscript-type">struct</span> mbuf *m = (<span class="enscript-type">struct</span> mbuf *)o;
		<span class="enscript-type">union</span> mcluster *c = (<span class="enscript-type">union</span> mcluster *)o;
		<span class="enscript-type">union</span> mbigcluster *mbc = (<span class="enscript-type">union</span> mbigcluster *)o;
		mcl_slab_t *sp = slab_get(o);
		mcache_audit_t *mca = NULL;

		<span class="enscript-comment">/*
		 * since one full page will be converted to MC_MBUF or
		 * MC_CL, verify that the reference count will match that
		 * assumption
		 */</span>
		VERIFY(sp-&gt;sl_refcnt == 1 &amp;&amp; slab_is_detached(sp)); 
		VERIFY((sp-&gt;sl_flags &amp; (SLF_MAPPED | SLF_PARTIAL)) == SLF_MAPPED);
		<span class="enscript-comment">/*
		 * Make sure that the cluster is unmolested
		 * while in freelist
		 */</span>
		<span class="enscript-keyword">if</span> (mclverify) {
			mca = mcl_audit_buf2mca(super_class,
			    (mcache_obj_t *)o);
			mcache_audit_free_verify(mca,
			    (mcache_obj_t *)o, 0, m_maxsize(super_class));
		}

		<span class="enscript-comment">/* Reinitialize it as an mbuf or 2K or 4K slab */</span>
		slab_init(sp, class, sp-&gt;sl_flags,
		    sp-&gt;sl_base, NULL, PAGE_SIZE, 0, numobj);

		VERIFY(sp-&gt;sl_head == NULL);

		VERIFY(m_total(super_class) &gt;= 1);
		m_total(super_class)--;

		<span class="enscript-keyword">if</span> (super_class == MC_BIGCL)
			mbstat.m_bigclusters = m_total(MC_BIGCL);

		m_total(class) += numobj;
		m_infree(class) += numobj;

		<span class="enscript-keyword">if</span> (!mb_peak_newreport &amp;&amp; mbuf_report_usage(class))
			mb_peak_newreport = TRUE;

		i = numobj;
		<span class="enscript-keyword">if</span> (class == MC_MBUF) {
			mbstat.m_mbufs = m_total(MC_MBUF);
			mtype_stat_add(MT_FREE, NMBPG);
			<span class="enscript-keyword">while</span> (i--) {
				<span class="enscript-comment">/*
				 * If auditing is enabled, construct the
				 * shadow mbuf in the audit structure
				 * instead of the actual one.
				 * mbuf_slab_audit() will take care of
				 * restoring the contents after the
				 * integrity check.
				 */</span>
				<span class="enscript-keyword">if</span> (mclaudit != NULL) {
					<span class="enscript-type">struct</span> mbuf *ms;
					mca = mcl_audit_buf2mca(MC_MBUF,
					    (mcache_obj_t *)m);
					ms = MCA_SAVED_MBUF_PTR(mca);
					ms-&gt;m_type = MT_FREE;
				} <span class="enscript-keyword">else</span> {
					m-&gt;m_type = MT_FREE;
				}
				m-&gt;m_next = sp-&gt;sl_head;
				sp-&gt;sl_head = (<span class="enscript-type">void</span> *)m++;
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_CL) { <span class="enscript-comment">/* MC_CL */</span>
			mbstat.m_clfree =
			    m_infree(MC_CL) + m_infree(MC_MBUF_CL);
			mbstat.m_clusters = m_total(MC_CL);
			<span class="enscript-keyword">while</span> (i--) {
				c-&gt;mcl_next = sp-&gt;sl_head;
				sp-&gt;sl_head = (<span class="enscript-type">void</span> *)c++;
			}
		} <span class="enscript-keyword">else</span> {
			VERIFY(class == MC_BIGCL);
			mbstat.m_bigclusters = m_total(MC_BIGCL);
			mbstat.m_bigclfree = m_infree(MC_BIGCL) +
			    m_infree(MC_MBUF_BIGCL);
			<span class="enscript-keyword">while</span> (i--) {
				mbc-&gt;mbc_next = sp-&gt;sl_head;
				sp-&gt;sl_head = (<span class="enscript-type">void</span> *)mbc++;
			}
		}

		<span class="enscript-comment">/* Insert into the mbuf or 2k or 4k slab list */</span>
		slab_insert(sp, class);

		<span class="enscript-keyword">if</span> ((i = mb_waiters) &gt; 0)
			mb_waiters = 0;
		<span class="enscript-keyword">if</span> (i != 0)
			wakeup(mb_waitchan);
	}
	<span class="enscript-keyword">return</span> (count != 0);
}

<span class="enscript-comment">/*
 * For each class, initialize the freelist to hold m_minlimit() objects.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">freelist_init</span>(mbuf_class_t class)
{
	lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);

	VERIFY(class == MC_CL || class == MC_BIGCL);
	VERIFY(m_total(class) == 0);
	VERIFY(m_minlimit(class) &gt; 0);

	<span class="enscript-keyword">while</span> (m_total(class) &lt; m_minlimit(class))
		(<span class="enscript-type">void</span>) freelist_populate(class, m_minlimit(class), M_WAIT);

	VERIFY(m_total(class) &gt;= m_minlimit(class));
}

<span class="enscript-comment">/*
 * (Inaccurately) check if it might be worth a trip back to the
 * mcache layer due the availability of objects there.  We'll
 * end up back here if there's nothing up there.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">mbuf_cached_above</span>(mbuf_class_t class, <span class="enscript-type">int</span> wait)
{
	<span class="enscript-keyword">switch</span> (class) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_MBUF</span>:
		<span class="enscript-keyword">if</span> (wait &amp; MCR_COMP)
			<span class="enscript-keyword">return</span> (!mcache_bkt_isempty(m_cache(MC_MBUF_CL)) ||
			    !mcache_bkt_isempty(m_cache(MC_MBUF_BIGCL)));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_CL</span>:
		<span class="enscript-keyword">if</span> (wait &amp; MCR_COMP)
			<span class="enscript-keyword">return</span> (!mcache_bkt_isempty(m_cache(MC_MBUF_CL)));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_BIGCL</span>:
		<span class="enscript-keyword">if</span> (wait &amp; MCR_COMP)
			<span class="enscript-keyword">return</span> (!mcache_bkt_isempty(m_cache(MC_MBUF_BIGCL)));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_16KCL</span>:
		<span class="enscript-keyword">if</span> (wait &amp; MCR_COMP)
			<span class="enscript-keyword">return</span> (!mcache_bkt_isempty(m_cache(MC_MBUF_16KCL)));
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_MBUF_CL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_MBUF_BIGCL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_MBUF_16KCL</span>:
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (!mcache_bkt_isempty(m_cache(class)));
}

<span class="enscript-comment">/*
 * If possible, convert constructed objects to raw ones.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">mbuf_steal</span>(mbuf_class_t class, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num)
{
	mcache_obj_t *top = NULL;
	mcache_obj_t **list = &amp;top;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> tot = 0;

	lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-keyword">switch</span> (class) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_MBUF</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_CL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_BIGCL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_16KCL</span>:
		<span class="enscript-keyword">return</span> (FALSE);

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_MBUF_CL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_MBUF_BIGCL</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_MBUF_16KCL</span>:
		<span class="enscript-comment">/* Get the required number of constructed objects if possible */</span>
		<span class="enscript-keyword">if</span> (m_infree(class) &gt; m_minlimit(class)) {
			tot = cslab_alloc(class, &amp;list,
			    MIN(num, m_infree(class)));
		}

		<span class="enscript-comment">/* And destroy them to get back the raw objects */</span>
		<span class="enscript-keyword">if</span> (top != NULL)
			(<span class="enscript-type">void</span>) cslab_free(class, top, 1);
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (tot == num);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">m_reclaim</span>(mbuf_class_t class, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num, boolean_t comp)
{
	<span class="enscript-type">int</span> m, bmap = 0;

	lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);

	VERIFY(m_total(MC_CL) &lt;= m_maxlimit(MC_CL));
	VERIFY(m_total(MC_BIGCL) &lt;= m_maxlimit(MC_BIGCL));
	VERIFY(m_total(MC_16KCL) &lt;= m_maxlimit(MC_16KCL));

	<span class="enscript-comment">/*
	 * This logic can be made smarter; for now, simply mark
	 * all other related classes as potential victims.
	 */</span>
	<span class="enscript-keyword">switch</span> (class) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_MBUF</span>:
		m_wantpurge(MC_CL)++;
		m_wantpurge(MC_BIGCL)++;
		m_wantpurge(MC_MBUF_CL)++;
		m_wantpurge(MC_MBUF_BIGCL)++;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_CL</span>:
		m_wantpurge(MC_MBUF)++;
		m_wantpurge(MC_BIGCL)++;
		m_wantpurge(MC_MBUF_BIGCL)++;
		<span class="enscript-keyword">if</span> (!comp)
			m_wantpurge(MC_MBUF_CL)++;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_BIGCL</span>:
		m_wantpurge(MC_MBUF)++;
		m_wantpurge(MC_CL)++;
		m_wantpurge(MC_MBUF_CL)++;
		<span class="enscript-keyword">if</span> (!comp)
			m_wantpurge(MC_MBUF_BIGCL)++;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_16KCL</span>:
		<span class="enscript-keyword">if</span> (!comp)
			m_wantpurge(MC_MBUF_16KCL)++;
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-comment">/*
	 * Run through each marked class and check if we really need to
	 * purge (and therefore temporarily disable) the per-CPU caches
	 * layer used by the class.  If so, remember the classes since
	 * we are going to drop the lock below prior to purging.
	 */</span>
	<span class="enscript-keyword">for</span> (m = 0; m &lt; NELEM(mbuf_table); m++) {
		<span class="enscript-keyword">if</span> (m_wantpurge(m) &gt; 0) {
			m_wantpurge(m) = 0;
			<span class="enscript-comment">/*
			 * Try hard to steal the required number of objects
			 * from the freelist of other mbuf classes.  Only
			 * purge and disable the per-CPU caches layer when
			 * we don't have enough; it's the last resort.
			 */</span>
			<span class="enscript-keyword">if</span> (!mbuf_steal(m, num))
				bmap |= (1 &lt;&lt; m);
		}
	}

	lck_mtx_unlock(mbuf_mlock);

	<span class="enscript-keyword">if</span> (bmap != 0) {
		<span class="enscript-comment">/* signal the domains to drain */</span>
		net_drain_domains();

		<span class="enscript-comment">/* Sigh; we have no other choices but to ask mcache to purge */</span>
		<span class="enscript-keyword">for</span> (m = 0; m &lt; NELEM(mbuf_table); m++) {
			<span class="enscript-keyword">if</span> ((bmap &amp; (1 &lt;&lt; m)) &amp;&amp;
			    mcache_purge_cache(m_cache(m), TRUE)) {
				lck_mtx_lock(mbuf_mlock);
				m_purge_cnt(m)++;
				mbstat.m_drain++;
				lck_mtx_unlock(mbuf_mlock);
			}
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Request mcache to reap extra elements from all of its caches;
		 * note that all reaps are serialized and happen only at a fixed
		 * interval.
		 */</span>
		mcache_reap();
	}
	lck_mtx_lock(mbuf_mlock);
}

<span class="enscript-type">static</span> inline <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_get_common</span>(<span class="enscript-type">int</span> wait, <span class="enscript-type">short</span> type, <span class="enscript-type">int</span> hdr)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> mcflags = MSLEEPF(wait);

	<span class="enscript-comment">/* Is this due to a non-blocking retry?  If so, then try harder */</span>
	<span class="enscript-keyword">if</span> (mcflags &amp; MCR_NOSLEEP)
		mcflags |= MCR_TRYHARD;

	m = mcache_alloc(m_cache(MC_MBUF), mcflags);
	<span class="enscript-keyword">if</span> (m != NULL) {
		MBUF_INIT(m, hdr, type);
		mtype_stat_inc(type);
		mtype_stat_dec(MT_FREE);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
		<span class="enscript-keyword">if</span> (hdr &amp;&amp; mac_init_mbuf(m, wait) != 0) {
			m_free(m);
			<span class="enscript-keyword">return</span> (NULL);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_NET */</span>
	}
	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-comment">/*
 * Space allocation routines; these are also available as macros
 * for critical paths.
 */</span>
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">_M_GET</span>(wait, type)	m_get_common(wait, type, 0)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">_M_GETHDR</span>(wait, type)	m_get_common(wait, type, 1)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">_M_RETRY</span>(wait, type)	_M_GET(wait, type)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">_M_RETRYHDR</span>(wait, type)	_M_GETHDR(wait, type)
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">_MGET</span>(m, how, type)	((m) = _M_GET(how, type))
#<span class="enscript-reference">define</span>	<span class="enscript-function-name">_MGETHDR</span>(m, how, type)	((m) = _M_GETHDR(how, type))

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_get</span>(<span class="enscript-type">int</span> wait, <span class="enscript-type">int</span> type)
{
	<span class="enscript-keyword">return</span> (_M_GET(wait, type));
}

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_gethdr</span>(<span class="enscript-type">int</span> wait, <span class="enscript-type">int</span> type)
{
	<span class="enscript-keyword">return</span> (_M_GETHDR(wait, type));
}

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_retry</span>(<span class="enscript-type">int</span> wait, <span class="enscript-type">int</span> type)
{
	<span class="enscript-keyword">return</span> (_M_RETRY(wait, type));
}

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_retryhdr</span>(<span class="enscript-type">int</span> wait, <span class="enscript-type">int</span> type)
{
	<span class="enscript-keyword">return</span> (_M_RETRYHDR(wait, type));
}

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_getclr</span>(<span class="enscript-type">int</span> wait, <span class="enscript-type">int</span> type)
{
	<span class="enscript-type">struct</span> mbuf *m;

	_MGET(m, wait, type);
	<span class="enscript-keyword">if</span> (m != NULL)
		bzero(MTOD(m, caddr_t), MLEN);
	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_free</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> mbuf *n = m-&gt;m_next;

	<span class="enscript-keyword">if</span> (m-&gt;m_type == MT_FREE)
		panic(<span class="enscript-string">&quot;m_free: freeing an already freed mbuf&quot;</span>);

	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR) {
		<span class="enscript-comment">/* Check for scratch area overflow */</span>
		m_redzone_verify(m);
		<span class="enscript-comment">/* Free the aux data and tags if there is any */</span>
		m_tag_delete_chain(m, NULL);
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_EXT) {
		u_int32_t refcnt;
		u_int32_t composite;

		refcnt = m_decref(m);
		composite = (MEXT_FLAGS(m) &amp; EXTF_COMPOSITE);
		<span class="enscript-keyword">if</span> (refcnt == 0 &amp;&amp; !composite) {
			<span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == NULL) {
				mcache_free(m_cache(MC_CL), m-&gt;m_ext.ext_buf);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == m_bigfree) {
				mcache_free(m_cache(MC_BIGCL),
				    m-&gt;m_ext.ext_buf);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == m_16kfree) {
				mcache_free(m_cache(MC_16KCL),
				    m-&gt;m_ext.ext_buf);
			} <span class="enscript-keyword">else</span> {
				(*(m-&gt;m_ext.ext_free))(m-&gt;m_ext.ext_buf,
				    m-&gt;m_ext.ext_size, m-&gt;m_ext.ext_arg);
			}
			mcache_free(ref_cache, MEXT_RFA(m));
			MEXT_RFA(m) = NULL;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (refcnt == 0 &amp;&amp; composite) {
			VERIFY(m-&gt;m_type != MT_FREE);

			mtype_stat_dec(m-&gt;m_type);
			mtype_stat_inc(MT_FREE);

			m-&gt;m_type = MT_FREE;
			m-&gt;m_flags = M_EXT;
			m-&gt;m_len = 0;
			m-&gt;m_next = m-&gt;m_nextpkt = NULL;

			MEXT_FLAGS(m) &amp;= ~EXTF_READONLY;

			<span class="enscript-comment">/* &quot;Free&quot; into the intermediate cache */</span>
			<span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == NULL) {
				mcache_free(m_cache(MC_MBUF_CL), m);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == m_bigfree) {
				mcache_free(m_cache(MC_MBUF_BIGCL), m);
			} <span class="enscript-keyword">else</span> {
				VERIFY(m-&gt;m_ext.ext_free == m_16kfree);
				mcache_free(m_cache(MC_MBUF_16KCL), m);
			}
			<span class="enscript-keyword">return</span> (n);
		}
	}

	<span class="enscript-keyword">if</span> (m-&gt;m_type != MT_FREE) {
		mtype_stat_dec(m-&gt;m_type);
		mtype_stat_inc(MT_FREE);
	}

	m-&gt;m_type = MT_FREE;
	m-&gt;m_flags = m-&gt;m_len = 0;
	m-&gt;m_next = m-&gt;m_nextpkt = NULL;

	mcache_free(m_cache(MC_MBUF), m);

	<span class="enscript-keyword">return</span> (n);
}

__private_extern__ <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_clattach</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> type, caddr_t extbuf,
    <span class="enscript-type">void</span> (*extfree)(caddr_t, u_int, caddr_t), u_int extsize, caddr_t extarg,
    <span class="enscript-type">int</span> wait)
{
	<span class="enscript-type">struct</span> ext_ref *rfa = NULL;

	<span class="enscript-keyword">if</span> (m == NULL &amp;&amp; (m = _M_GETHDR(wait, type)) == NULL)
		<span class="enscript-keyword">return</span> (NULL);

	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_EXT) {
		u_int32_t refcnt;
		u_int32_t composite;

		refcnt = m_decref(m);
		composite = (MEXT_FLAGS(m) &amp; EXTF_COMPOSITE);
		<span class="enscript-keyword">if</span> (refcnt == 0 &amp;&amp; !composite) {
			<span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == NULL) {
				mcache_free(m_cache(MC_CL), m-&gt;m_ext.ext_buf);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == m_bigfree) {
				mcache_free(m_cache(MC_BIGCL),
				    m-&gt;m_ext.ext_buf);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == m_16kfree) {
				mcache_free(m_cache(MC_16KCL),
				    m-&gt;m_ext.ext_buf);
			} <span class="enscript-keyword">else</span> {
				(*(m-&gt;m_ext.ext_free))(m-&gt;m_ext.ext_buf,
				    m-&gt;m_ext.ext_size, m-&gt;m_ext.ext_arg);
			}
			<span class="enscript-comment">/* Re-use the reference structure */</span>
			rfa = MEXT_RFA(m);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (refcnt == 0 &amp;&amp; composite) {
			VERIFY(m-&gt;m_type != MT_FREE);

			mtype_stat_dec(m-&gt;m_type);
			mtype_stat_inc(MT_FREE);

			m-&gt;m_type = MT_FREE;
			m-&gt;m_flags = M_EXT;
			m-&gt;m_len = 0;
			m-&gt;m_next = m-&gt;m_nextpkt = NULL;

			MEXT_FLAGS(m) &amp;= ~EXTF_READONLY;

			<span class="enscript-comment">/* &quot;Free&quot; into the intermediate cache */</span>
			<span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == NULL) {
				mcache_free(m_cache(MC_MBUF_CL), m);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == m_bigfree) {
				mcache_free(m_cache(MC_MBUF_BIGCL), m);
			} <span class="enscript-keyword">else</span> {
				VERIFY(m-&gt;m_ext.ext_free == m_16kfree);
				mcache_free(m_cache(MC_MBUF_16KCL), m);
			}
			<span class="enscript-comment">/*
			 * Allocate a new mbuf, since we didn't divorce
			 * the composite mbuf + cluster pair above.
			 */</span>
			<span class="enscript-keyword">if</span> ((m = _M_GETHDR(wait, type)) == NULL)
				<span class="enscript-keyword">return</span> (NULL);
		}
	}

	<span class="enscript-keyword">if</span> (rfa == NULL &amp;&amp;
	    (rfa = mcache_alloc(ref_cache, MSLEEPF(wait))) == NULL) {
		m_free(m);
		<span class="enscript-keyword">return</span> (NULL);
	}

	MEXT_INIT(m, extbuf, extsize, extfree, extarg, rfa, 1, 0);

	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-comment">/*
 * Perform `fast' allocation mbuf clusters from a cache of recently-freed
 * clusters. (If the cache is empty, new clusters are allocated en-masse.)
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_getcl</span>(<span class="enscript-type">int</span> wait, <span class="enscript-type">int</span> type, <span class="enscript-type">int</span> flags)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> mcflags = MSLEEPF(wait);
	<span class="enscript-type">int</span> hdr = (flags &amp; M_PKTHDR);

	<span class="enscript-comment">/* Is this due to a non-blocking retry?  If so, then try harder */</span>
	<span class="enscript-keyword">if</span> (mcflags &amp; MCR_NOSLEEP)
		mcflags |= MCR_TRYHARD;

	m = mcache_alloc(m_cache(MC_MBUF_CL), mcflags);
	<span class="enscript-keyword">if</span> (m != NULL) {
		u_int32_t flag;
		<span class="enscript-type">struct</span> ext_ref *rfa;
		<span class="enscript-type">void</span> *cl;

		VERIFY(m-&gt;m_type == MT_FREE &amp;&amp; m-&gt;m_flags == M_EXT);
		cl = m-&gt;m_ext.ext_buf;
		rfa = MEXT_RFA(m);

		ASSERT(cl != NULL &amp;&amp; rfa != NULL);
		VERIFY(MBUF_IS_COMPOSITE(m) &amp;&amp; m-&gt;m_ext.ext_free == NULL);

		flag = MEXT_FLAGS(m);

		MBUF_INIT(m, hdr, type);
		MBUF_CL_INIT(m, cl, rfa, 1, flag);

		mtype_stat_inc(type);
		mtype_stat_dec(MT_FREE);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
		<span class="enscript-keyword">if</span> (hdr &amp;&amp; mac_init_mbuf(m, wait) != 0) {
			m_freem(m);
			<span class="enscript-keyword">return</span> (NULL);
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_NET */</span>
	}
	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-comment">/* m_mclget() add an mbuf cluster to a normal mbuf */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_mclget</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> wait)
{
	<span class="enscript-type">struct</span> ext_ref *rfa;

	<span class="enscript-keyword">if</span> ((rfa = mcache_alloc(ref_cache, MSLEEPF(wait))) == NULL)
		<span class="enscript-keyword">return</span> (m);

	m-&gt;m_ext.ext_buf = m_mclalloc(wait);
	<span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_buf != NULL) {
		MBUF_CL_INIT(m, m-&gt;m_ext.ext_buf, rfa, 1, 0);
	} <span class="enscript-keyword">else</span> {
		mcache_free(ref_cache, rfa);
	}
	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-comment">/* Allocate an mbuf cluster */</span>
caddr_t
<span class="enscript-function-name">m_mclalloc</span>(<span class="enscript-type">int</span> wait)
{
	<span class="enscript-type">int</span> mcflags = MSLEEPF(wait);

	<span class="enscript-comment">/* Is this due to a non-blocking retry?  If so, then try harder */</span>
	<span class="enscript-keyword">if</span> (mcflags &amp; MCR_NOSLEEP)
		mcflags |= MCR_TRYHARD;

	<span class="enscript-keyword">return</span> (mcache_alloc(m_cache(MC_CL), mcflags));
}

<span class="enscript-comment">/* Free an mbuf cluster */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">m_mclfree</span>(caddr_t p)
{
	mcache_free(m_cache(MC_CL), p);
}

<span class="enscript-comment">/*
 * mcl_hasreference() checks if a cluster of an mbuf is referenced by
 * another mbuf; see comments in m_incref() regarding EXTF_READONLY.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">m_mclhasreference</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-keyword">if</span> (!(m-&gt;m_flags &amp; M_EXT))
		<span class="enscript-keyword">return</span> (0);

	ASSERT(MEXT_RFA(m) != NULL);

	<span class="enscript-keyword">return</span> ((MEXT_FLAGS(m) &amp; EXTF_READONLY) ? 1 : 0);
}

__private_extern__ caddr_t
<span class="enscript-function-name">m_bigalloc</span>(<span class="enscript-type">int</span> wait)
{
	<span class="enscript-type">int</span> mcflags = MSLEEPF(wait);

	<span class="enscript-comment">/* Is this due to a non-blocking retry?  If so, then try harder */</span>
	<span class="enscript-keyword">if</span> (mcflags &amp; MCR_NOSLEEP)
		mcflags |= MCR_TRYHARD;

	<span class="enscript-keyword">return</span> (mcache_alloc(m_cache(MC_BIGCL), mcflags));
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">m_bigfree</span>(caddr_t p, __unused u_int size, __unused caddr_t arg)
{
	mcache_free(m_cache(MC_BIGCL), p);
}

<span class="enscript-comment">/* m_mbigget() add an 4KB mbuf cluster to a normal mbuf */</span>
__private_extern__ <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_mbigget</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> wait)
{
	<span class="enscript-type">struct</span> ext_ref *rfa;

	<span class="enscript-keyword">if</span> ((rfa = mcache_alloc(ref_cache, MSLEEPF(wait))) == NULL)
		<span class="enscript-keyword">return</span> (m);

	m-&gt;m_ext.ext_buf =  m_bigalloc(wait);
	<span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_buf != NULL) {
		MBUF_BIGCL_INIT(m, m-&gt;m_ext.ext_buf, rfa, 1, 0);
	} <span class="enscript-keyword">else</span> {
		mcache_free(ref_cache, rfa);
	}
	<span class="enscript-keyword">return</span> (m);
}

__private_extern__ caddr_t
<span class="enscript-function-name">m_16kalloc</span>(<span class="enscript-type">int</span> wait)
{
	<span class="enscript-type">int</span> mcflags = MSLEEPF(wait);

	<span class="enscript-comment">/* Is this due to a non-blocking retry?  If so, then try harder */</span>
	<span class="enscript-keyword">if</span> (mcflags &amp; MCR_NOSLEEP)
		mcflags |= MCR_TRYHARD;

	<span class="enscript-keyword">return</span> (mcache_alloc(m_cache(MC_16KCL), mcflags));
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">m_16kfree</span>(caddr_t p, __unused u_int size, __unused caddr_t arg)
{
	mcache_free(m_cache(MC_16KCL), p);
}

<span class="enscript-comment">/* m_m16kget() add a 16KB mbuf cluster to a normal mbuf */</span>
__private_extern__ <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_m16kget</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> wait)
{
	<span class="enscript-type">struct</span> ext_ref *rfa;

	<span class="enscript-keyword">if</span> ((rfa = mcache_alloc(ref_cache, MSLEEPF(wait))) == NULL)
		<span class="enscript-keyword">return</span> (m);

	m-&gt;m_ext.ext_buf =  m_16kalloc(wait);
	<span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_buf != NULL) {
		MBUF_16KCL_INIT(m, m-&gt;m_ext.ext_buf, rfa, 1, 0);
	} <span class="enscript-keyword">else</span> {
		mcache_free(ref_cache, rfa);
	}
	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-comment">/*
 * &quot;Move&quot; mbuf pkthdr from &quot;from&quot; to &quot;to&quot;.
 * &quot;from&quot; must have M_PKTHDR set, and &quot;to&quot; must be empty.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">m_copy_pkthdr</span>(<span class="enscript-type">struct</span> mbuf *to, <span class="enscript-type">struct</span> mbuf *from)
{
	VERIFY(from-&gt;m_flags &amp; M_PKTHDR);

	<span class="enscript-comment">/* Check for scratch area overflow */</span>
	m_redzone_verify(from);

	<span class="enscript-keyword">if</span> (to-&gt;m_flags &amp; M_PKTHDR) {
		<span class="enscript-comment">/* Check for scratch area overflow */</span>
		m_redzone_verify(to);
		<span class="enscript-comment">/* We will be taking over the tags of 'to' */</span>
		m_tag_delete_chain(to, NULL);
	}
	to-&gt;m_pkthdr = from-&gt;m_pkthdr;		<span class="enscript-comment">/* especially tags */</span>
	m_classifier_init(from, 0);		<span class="enscript-comment">/* purge classifier info */</span>
	m_tag_init(from, 1);			<span class="enscript-comment">/* purge all tags from src */</span>
	m_scratch_init(from);			<span class="enscript-comment">/* clear src scratch area */</span>
	to-&gt;m_flags = (from-&gt;m_flags &amp; M_COPYFLAGS) | (to-&gt;m_flags &amp; M_EXT);
	<span class="enscript-keyword">if</span> ((to-&gt;m_flags &amp; M_EXT) == 0)
		to-&gt;m_data = to-&gt;m_pktdat;
	m_redzone_init(to);			<span class="enscript-comment">/* setup red zone on dst */</span>
}

<span class="enscript-comment">/*
 * Duplicate &quot;from&quot;'s mbuf pkthdr in &quot;to&quot;.
 * &quot;from&quot; must have M_PKTHDR set, and &quot;to&quot; must be empty.
 * In particular, this does a deep copy of the packet tags.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">m_dup_pkthdr</span>(<span class="enscript-type">struct</span> mbuf *to, <span class="enscript-type">struct</span> mbuf *from, <span class="enscript-type">int</span> how)
{
	VERIFY(from-&gt;m_flags &amp; M_PKTHDR);

	<span class="enscript-comment">/* Check for scratch area overflow */</span>
	m_redzone_verify(from);

	<span class="enscript-keyword">if</span> (to-&gt;m_flags &amp; M_PKTHDR) {
		<span class="enscript-comment">/* Check for scratch area overflow */</span>
		m_redzone_verify(to);
		<span class="enscript-comment">/* We will be taking over the tags of 'to' */</span>
		m_tag_delete_chain(to, NULL);
	}
	to-&gt;m_flags = (from-&gt;m_flags &amp; M_COPYFLAGS) | (to-&gt;m_flags &amp; M_EXT);
	<span class="enscript-keyword">if</span> ((to-&gt;m_flags &amp; M_EXT) == 0)
		to-&gt;m_data = to-&gt;m_pktdat;
	to-&gt;m_pkthdr = from-&gt;m_pkthdr;
	m_redzone_init(to);			<span class="enscript-comment">/* setup red zone on dst */</span>
	m_tag_init(to, 0);			<span class="enscript-comment">/* preserve dst static tags */</span>
	<span class="enscript-keyword">return</span> (m_tag_copy_chain(to, from, how));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">m_copy_pftag</span>(<span class="enscript-type">struct</span> mbuf *to, <span class="enscript-type">struct</span> mbuf *from)
{
	to-&gt;m_pkthdr.pf_mtag = from-&gt;m_pkthdr.pf_mtag;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">PF_ECN</span>
	to-&gt;m_pkthdr.pf_mtag.pftag_hdr = NULL;
	to-&gt;m_pkthdr.pf_mtag.pftag_flags &amp;= ~(PF_TAG_HDR_INET|PF_TAG_HDR_INET6);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* PF_ECN */</span>
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">m_classifier_init</span>(<span class="enscript-type">struct</span> mbuf *m, uint32_t pktf_mask)
{
	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	m-&gt;m_pkthdr.pkt_proto = 0;
	m-&gt;m_pkthdr.pkt_flowsrc = 0;
	m-&gt;m_pkthdr.pkt_flowid = 0;
	m-&gt;m_pkthdr.pkt_flags &amp;= pktf_mask;	<span class="enscript-comment">/* caller-defined mask */</span>
	<span class="enscript-comment">/* preserve service class and interface info for loopback packets */</span>
	<span class="enscript-keyword">if</span> (!(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_LOOP))
		(<span class="enscript-type">void</span>) m_set_service_class(m, MBUF_SC_BE);
	<span class="enscript-keyword">if</span> (!(m-&gt;m_pkthdr.pkt_flags &amp; PKTF_IFAINFO))
		m-&gt;m_pkthdr.pkt_ifainfo = 0;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MEASURE_BW</span>
	m-&gt;m_pkthdr.pkt_bwseq  = 0;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MEASURE_BW */</span>
	m-&gt;m_pkthdr.pkt_enqueue_ts = 0;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">m_copy_classifier</span>(<span class="enscript-type">struct</span> mbuf *to, <span class="enscript-type">struct</span> mbuf *from)
{
	VERIFY(to-&gt;m_flags &amp; M_PKTHDR);
	VERIFY(from-&gt;m_flags &amp; M_PKTHDR);

	to-&gt;m_pkthdr.pkt_proto = from-&gt;m_pkthdr.pkt_proto;
	to-&gt;m_pkthdr.pkt_flowsrc = from-&gt;m_pkthdr.pkt_flowsrc;
	to-&gt;m_pkthdr.pkt_flowid = from-&gt;m_pkthdr.pkt_flowid;
	to-&gt;m_pkthdr.pkt_flags = from-&gt;m_pkthdr.pkt_flags;
	(<span class="enscript-type">void</span>) m_set_service_class(to, from-&gt;m_pkthdr.pkt_svc);
	to-&gt;m_pkthdr.pkt_ifainfo  = from-&gt;m_pkthdr.pkt_ifainfo;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">MEASURE_BW</span>
	to-&gt;m_pkthdr.pkt_bwseq  = from-&gt;m_pkthdr.pkt_bwseq;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MEASURE_BW */</span>
}

<span class="enscript-comment">/*
 * Return a list of mbuf hdrs that point to clusters.  Try for num_needed;
 * if wantall is not set, return whatever number were available.  Set up the
 * first num_with_pkthdrs with mbuf hdrs configured as packet headers; these
 * are chained on the m_nextpkt field.  Any packets requested beyond this
 * are chained onto the last packet header's m_next field.  The size of
 * the cluster is controlled by the parameter bufsize.
 */</span>
__private_extern__ <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_getpackets_internal</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *num_needed, <span class="enscript-type">int</span> num_with_pkthdrs,
    <span class="enscript-type">int</span> wait, <span class="enscript-type">int</span> wantall, size_t bufsize)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> mbuf **np, *top;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pnum, needed = *num_needed;
	mcache_obj_t *mp_list = NULL;
	<span class="enscript-type">int</span> mcflags = MSLEEPF(wait);
	u_int32_t flag;
	<span class="enscript-type">struct</span> ext_ref *rfa;
	mcache_t *cp;
	<span class="enscript-type">void</span> *cl;

	ASSERT(bufsize == m_maxsize(MC_CL) ||
	    bufsize == m_maxsize(MC_BIGCL) ||
	    bufsize == m_maxsize(MC_16KCL));

	<span class="enscript-comment">/*
	 * Caller must first check for njcl because this
	 * routine is internal and not exposed/used via KPI.
	 */</span>
	VERIFY(bufsize != m_maxsize(MC_16KCL) || njcl &gt; 0);

	top = NULL;
	np = &amp;top;
	pnum = 0;

	<span class="enscript-comment">/*
	 * The caller doesn't want all the requested buffers; only some.
	 * Try hard to get what we can, but don't block.  This effectively
	 * overrides MCR_SLEEP, since this thread will not go to sleep
	 * if we can't get all the buffers.
	 */</span>
	<span class="enscript-keyword">if</span> (!wantall || (mcflags &amp; MCR_NOSLEEP))
		mcflags |= MCR_TRYHARD;

	<span class="enscript-comment">/* Allocate the composite mbuf + cluster elements from the cache */</span>
	<span class="enscript-keyword">if</span> (bufsize == m_maxsize(MC_CL))
		cp = m_cache(MC_MBUF_CL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bufsize == m_maxsize(MC_BIGCL))
		cp = m_cache(MC_MBUF_BIGCL);
	<span class="enscript-keyword">else</span>
		cp = m_cache(MC_MBUF_16KCL);
	needed = mcache_alloc_ext(cp, &amp;mp_list, needed, mcflags);

	<span class="enscript-keyword">for</span> (pnum = 0; pnum &lt; needed; pnum++) {
		m = (<span class="enscript-type">struct</span> mbuf *)mp_list;
		mp_list = mp_list-&gt;obj_next;

		VERIFY(m-&gt;m_type == MT_FREE &amp;&amp; m-&gt;m_flags == M_EXT);
		cl = m-&gt;m_ext.ext_buf;
		rfa = MEXT_RFA(m);

		ASSERT(cl != NULL &amp;&amp; rfa != NULL);
		VERIFY(MBUF_IS_COMPOSITE(m));

		flag = MEXT_FLAGS(m);

		MBUF_INIT(m, num_with_pkthdrs, MT_DATA);
		<span class="enscript-keyword">if</span> (bufsize == m_maxsize(MC_16KCL)) {
			MBUF_16KCL_INIT(m, cl, rfa, 1, flag);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bufsize == m_maxsize(MC_BIGCL)) {
			MBUF_BIGCL_INIT(m, cl, rfa, 1, flag);
		} <span class="enscript-keyword">else</span> {
			MBUF_CL_INIT(m, cl, rfa, 1, flag);
		}

		<span class="enscript-keyword">if</span> (num_with_pkthdrs &gt; 0) {
			--num_with_pkthdrs;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
			<span class="enscript-keyword">if</span> (mac_mbuf_label_init(m, wait) != 0) {
				m_freem(m);
				<span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_NET */</span>
		}

		*np = m;
		<span class="enscript-keyword">if</span> (num_with_pkthdrs &gt; 0)
			np = &amp;m-&gt;m_nextpkt;
		<span class="enscript-keyword">else</span>
			np = &amp;m-&gt;m_next;
	}
	ASSERT(pnum != *num_needed || mp_list == NULL);
	<span class="enscript-keyword">if</span> (mp_list != NULL)
		mcache_free_ext(cp, mp_list);

	<span class="enscript-keyword">if</span> (pnum &gt; 0) {
		mtype_stat_add(MT_DATA, pnum);
		mtype_stat_sub(MT_FREE, pnum);
	}

	<span class="enscript-keyword">if</span> (wantall &amp;&amp; (pnum != *num_needed)) {
		<span class="enscript-keyword">if</span> (top != NULL)
			m_freem_list(top);
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (pnum &gt; *num_needed) {
		printf(<span class="enscript-string">&quot;%s: File a radar related to &lt;rdar://10146739&gt;. \
			needed = %u, pnum = %u, num_needed = %u \n&quot;</span>,
			__func__, needed, pnum, *num_needed);
	}		

	*num_needed = pnum;
	<span class="enscript-keyword">return</span> (top);
}

<span class="enscript-comment">/*
 * Return list of mbuf linked by m_nextpkt.  Try for numlist, and if
 * wantall is not set, return whatever number were available.  The size of
 * each mbuf in the list is controlled by the parameter packetlen.  Each
 * mbuf of the list may have a chain of mbufs linked by m_next.  Each mbuf
 * in the chain is called a segment.  If maxsegments is not null and the
 * value pointed to is not null, this specify the maximum number of segments
 * for a chain of mbufs.  If maxsegments is zero or the value pointed to
 * is zero the caller does not have any restriction on the number of segments.
 * The actual  number of segments of a mbuf chain is return in the value
 * pointed to by maxsegments.
 */</span>
__private_extern__ <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_allocpacket_internal</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *numlist, size_t packetlen,
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> *maxsegments, <span class="enscript-type">int</span> wait, <span class="enscript-type">int</span> wantall, size_t wantsize)
{
	<span class="enscript-type">struct</span> mbuf **np, *top, *first = NULL;
	size_t bufsize, r_bufsize;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> nsegs = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> needed, resid;
	<span class="enscript-type">int</span> mcflags = MSLEEPF(wait);
	mcache_obj_t *mp_list = NULL, *rmp_list = NULL;
	mcache_t *cp = NULL, *rcp = NULL;

	<span class="enscript-keyword">if</span> (*numlist == 0)
		<span class="enscript-keyword">return</span> (NULL);

	top = NULL;
	np = &amp;top;

	<span class="enscript-keyword">if</span> (wantsize == 0) {
		<span class="enscript-keyword">if</span> (packetlen &lt;= MINCLSIZE) {
			bufsize = packetlen;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (packetlen &gt; m_maxsize(MC_CL)) {
			<span class="enscript-comment">/* Use 4KB if jumbo cluster pool isn't available */</span>
			<span class="enscript-keyword">if</span> (packetlen &lt;= m_maxsize(MC_BIGCL) || njcl == 0)
				bufsize = m_maxsize(MC_BIGCL);
			<span class="enscript-keyword">else</span>
				bufsize = m_maxsize(MC_16KCL);
		} <span class="enscript-keyword">else</span> {
			bufsize = m_maxsize(MC_CL);
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wantsize == m_maxsize(MC_CL) ||
	    wantsize == m_maxsize(MC_BIGCL) ||
	    (wantsize == m_maxsize(MC_16KCL) &amp;&amp; njcl &gt; 0)) {
		bufsize = wantsize;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> (NULL);
	}

	<span class="enscript-keyword">if</span> (bufsize &lt;= MHLEN) {
		nsegs = 1;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bufsize &lt;= MINCLSIZE) {
		<span class="enscript-keyword">if</span> (maxsegments != NULL &amp;&amp; *maxsegments == 1) {
			bufsize = m_maxsize(MC_CL);
			nsegs = 1;
		} <span class="enscript-keyword">else</span> {
			nsegs = 2;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bufsize == m_maxsize(MC_16KCL)) {
		VERIFY(njcl &gt; 0);
		nsegs = ((packetlen - 1) &gt;&gt; M16KCLSHIFT) + 1;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bufsize == m_maxsize(MC_BIGCL)) {
		nsegs = ((packetlen - 1) &gt;&gt; MBIGCLSHIFT) + 1;
	} <span class="enscript-keyword">else</span> {
		nsegs = ((packetlen - 1) &gt;&gt; MCLSHIFT) + 1;
	}
	<span class="enscript-keyword">if</span> (maxsegments != NULL) {
		<span class="enscript-keyword">if</span> (*maxsegments &amp;&amp; nsegs &gt; *maxsegments) {
			*maxsegments = nsegs;
			<span class="enscript-keyword">return</span> (NULL);
		}
		*maxsegments = nsegs;
	}

	<span class="enscript-comment">/*
	 * The caller doesn't want all the requested buffers; only some.
	 * Try hard to get what we can, but don't block.  This effectively
	 * overrides MCR_SLEEP, since this thread will not go to sleep
	 * if we can't get all the buffers.
	 */</span>
	<span class="enscript-keyword">if</span> (!wantall || (mcflags &amp; MCR_NOSLEEP))
		mcflags |= MCR_TRYHARD;

	<span class="enscript-comment">/*
	 * Simple case where all elements in the lists/chains are mbufs.
	 * Unless bufsize is greater than MHLEN, each segment chain is made
	 * up of exactly 1 mbuf.  Otherwise, each segment chain is made up
	 * of 2 mbufs; the second one is used for the residual data, i.e.
	 * the remaining data that cannot fit into the first mbuf.
	 */</span>
	<span class="enscript-keyword">if</span> (bufsize &lt;= MINCLSIZE) {
		<span class="enscript-comment">/* Allocate the elements in one shot from the mbuf cache */</span>
		ASSERT(bufsize &lt;= MHLEN || nsegs == 2);
		cp = m_cache(MC_MBUF);
		needed = mcache_alloc_ext(cp, &amp;mp_list,
		    (*numlist) * nsegs, mcflags);

		<span class="enscript-comment">/*
		 * The number of elements must be even if we are to use an
		 * mbuf (instead of a cluster) to store the residual data.
		 * If we couldn't allocate the requested number of mbufs,
		 * trim the number down (if it's odd) in order to avoid
		 * creating a partial segment chain.
		 */</span>
		<span class="enscript-keyword">if</span> (bufsize &gt; MHLEN &amp;&amp; (needed &amp; 0x1))
			needed--;

		<span class="enscript-keyword">while</span> (num &lt; needed) {
			<span class="enscript-type">struct</span> mbuf *m;

			m = (<span class="enscript-type">struct</span> mbuf *)mp_list;
			mp_list = mp_list-&gt;obj_next;
			ASSERT(m != NULL);

			MBUF_INIT(m, 1, MT_DATA);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
			<span class="enscript-keyword">if</span> (mac_init_mbuf(m, wait) != 0) {
				m_free(m);
				<span class="enscript-keyword">break</span>;
			}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_NET */</span>
			num++;
			<span class="enscript-keyword">if</span> (bufsize &gt; MHLEN) {
				<span class="enscript-comment">/* A second mbuf for this segment chain */</span>
				m-&gt;m_next = (<span class="enscript-type">struct</span> mbuf *)mp_list;
				mp_list = mp_list-&gt;obj_next;
				ASSERT(m-&gt;m_next != NULL);

				MBUF_INIT(m-&gt;m_next, 0, MT_DATA);
				num++;
			}
			*np = m;
			np = &amp;m-&gt;m_nextpkt;
		}
		ASSERT(num != *numlist || mp_list == NULL);

		<span class="enscript-keyword">if</span> (num &gt; 0) {
			mtype_stat_add(MT_DATA, num);
			mtype_stat_sub(MT_FREE, num);
		}
		num /= nsegs;

		<span class="enscript-comment">/* We've got them all; return to caller */</span>
		<span class="enscript-keyword">if</span> (num == *numlist)
			<span class="enscript-keyword">return</span> (top);

		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;
	}

	<span class="enscript-comment">/*
	 * Complex cases where elements are made up of one or more composite
	 * mbufs + cluster, depending on packetlen.  Each N-segment chain can
	 * be illustrated as follows:
	 *
	 * [mbuf + cluster 1] [mbuf + cluster 2] ... [mbuf + cluster N]
	 *
	 * Every composite mbuf + cluster element comes from the intermediate
	 * cache (either MC_MBUF_CL or MC_MBUF_BIGCL).  For space efficiency,
	 * the last composite element will come from the MC_MBUF_CL cache,
	 * unless the residual data is larger than 2KB where we use the
	 * big cluster composite cache (MC_MBUF_BIGCL) instead.  Residual
	 * data is defined as extra data beyond the first element that cannot
	 * fit into the previous element, i.e. there is no residual data if
	 * the chain only has 1 segment.
	 */</span>
	r_bufsize = bufsize;
	resid = packetlen &gt; bufsize ? packetlen % bufsize : 0;
	<span class="enscript-keyword">if</span> (resid &gt; 0) {
		<span class="enscript-comment">/* There is residual data; figure out the cluster size */</span>
		<span class="enscript-keyword">if</span> (wantsize == 0 &amp;&amp; packetlen &gt; MINCLSIZE) {
			<span class="enscript-comment">/*
			 * Caller didn't request that all of the segments
			 * in the chain use the same cluster size; use the
			 * smaller of the cluster sizes.
			 */</span>
			<span class="enscript-keyword">if</span> (njcl &gt; 0 &amp;&amp; resid &gt; m_maxsize(MC_BIGCL))
				r_bufsize = m_maxsize(MC_16KCL);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (resid &gt; m_maxsize(MC_CL))
				r_bufsize = m_maxsize(MC_BIGCL);
			<span class="enscript-keyword">else</span>
				r_bufsize = m_maxsize(MC_CL);
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Use the same cluster size as the other segments */</span>
			resid = 0;
		}
	}

	needed = *numlist;
	<span class="enscript-keyword">if</span> (resid &gt; 0) {
		<span class="enscript-comment">/*
		 * Attempt to allocate composite mbuf + cluster elements for
		 * the residual data in each chain; record the number of such
		 * elements that can be allocated so that we know how many
		 * segment chains we can afford to create.
		 */</span>
		<span class="enscript-keyword">if</span> (r_bufsize &lt;= m_maxsize(MC_CL))
			rcp = m_cache(MC_MBUF_CL);
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (r_bufsize &lt;= m_maxsize(MC_BIGCL))
			rcp = m_cache(MC_MBUF_BIGCL);
		<span class="enscript-keyword">else</span>
			rcp = m_cache(MC_MBUF_16KCL);
		needed = mcache_alloc_ext(rcp, &amp;rmp_list, *numlist, mcflags);

		<span class="enscript-keyword">if</span> (needed == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;

		<span class="enscript-comment">/* This is temporarily reduced for calculation */</span>
		ASSERT(nsegs &gt; 1);
		nsegs--;
	}

	<span class="enscript-comment">/*
	 * Attempt to allocate the rest of the composite mbuf + cluster
	 * elements for the number of segment chains that we need.
	 */</span>
	<span class="enscript-keyword">if</span> (bufsize &lt;= m_maxsize(MC_CL))
		cp = m_cache(MC_MBUF_CL);
	<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (bufsize &lt;= m_maxsize(MC_BIGCL))
		cp = m_cache(MC_MBUF_BIGCL);
	<span class="enscript-keyword">else</span>
		cp = m_cache(MC_MBUF_16KCL);
	needed = mcache_alloc_ext(cp, &amp;mp_list, needed * nsegs, mcflags);

	<span class="enscript-comment">/* Round it down to avoid creating a partial segment chain */</span>
	needed = (needed / nsegs) * nsegs;
	<span class="enscript-keyword">if</span> (needed == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">fail</span>;

	<span class="enscript-keyword">if</span> (resid &gt; 0) {
		<span class="enscript-comment">/*
		 * We're about to construct the chain(s); take into account
		 * the number of segments we have created above to hold the
		 * residual data for each chain, as well as restore the
		 * original count of segments per chain.
		 */</span>
		ASSERT(nsegs &gt; 0);
		needed += needed / nsegs;
		nsegs++;
	}

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-type">struct</span> mbuf *m;
		u_int32_t flag;
		<span class="enscript-type">struct</span> ext_ref *rfa;
		<span class="enscript-type">void</span> *cl;
		<span class="enscript-type">int</span> pkthdr;

		++num;
		<span class="enscript-keyword">if</span> (nsegs == 1 || (num % nsegs) != 0 || resid == 0) {
			m = (<span class="enscript-type">struct</span> mbuf *)mp_list;
			mp_list = mp_list-&gt;obj_next;
		} <span class="enscript-keyword">else</span> {
			m = (<span class="enscript-type">struct</span> mbuf *)rmp_list;
			rmp_list = rmp_list-&gt;obj_next;
		}
		ASSERT(m != NULL);
		VERIFY(m-&gt;m_type == MT_FREE &amp;&amp; m-&gt;m_flags == M_EXT);
		VERIFY(m-&gt;m_ext.ext_free == NULL ||
		    m-&gt;m_ext.ext_free == m_bigfree ||
		    m-&gt;m_ext.ext_free == m_16kfree);

		cl = m-&gt;m_ext.ext_buf;
		rfa = MEXT_RFA(m);

		ASSERT(cl != NULL &amp;&amp; rfa != NULL);
		VERIFY(MBUF_IS_COMPOSITE(m));

		flag = MEXT_FLAGS(m);

		pkthdr = (nsegs == 1 || (num % nsegs) == 1);
		<span class="enscript-keyword">if</span> (pkthdr)
			first = m;
		MBUF_INIT(m, pkthdr, MT_DATA);
		<span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == m_16kfree) {
			MBUF_16KCL_INIT(m, cl, rfa, 1, flag);
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == m_bigfree) {
			MBUF_BIGCL_INIT(m, cl, rfa, 1, flag);
		} <span class="enscript-keyword">else</span> {
			MBUF_CL_INIT(m, cl, rfa, 1, flag);
		}
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
		<span class="enscript-keyword">if</span> (pkthdr &amp;&amp; mac_init_mbuf(m, wait) != 0) {
			--num;
			m_freem(m);
			<span class="enscript-keyword">break</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_NET */</span>

		*np = m;
		<span class="enscript-keyword">if</span> ((num % nsegs) == 0)
			np = &amp;first-&gt;m_nextpkt;
		<span class="enscript-keyword">else</span>
			np = &amp;m-&gt;m_next;

		<span class="enscript-keyword">if</span> (num == needed)
			<span class="enscript-keyword">break</span>;
	}

	<span class="enscript-keyword">if</span> (num &gt; 0) {
		mtype_stat_add(MT_DATA, num);
		mtype_stat_sub(MT_FREE, num);
	}

	num /= nsegs;

	<span class="enscript-comment">/* We've got them all; return to caller */</span>
	<span class="enscript-keyword">if</span> (num == *numlist) {
		ASSERT(mp_list == NULL &amp;&amp; rmp_list == NULL);
		<span class="enscript-keyword">return</span> (top);
	}

<span class="enscript-reference">fail</span>:
	<span class="enscript-comment">/* Free up what's left of the above */</span>
	<span class="enscript-keyword">if</span> (mp_list != NULL)
		mcache_free_ext(cp, mp_list);
	<span class="enscript-keyword">if</span> (rmp_list != NULL)
		mcache_free_ext(rcp, rmp_list);
	<span class="enscript-keyword">if</span> (wantall &amp;&amp; top != NULL) {
		m_freem(top);
		<span class="enscript-keyword">return</span> (NULL);
	}
	*numlist = num;
	<span class="enscript-keyword">return</span> (top);
}

<span class="enscript-comment">/*
 * Best effort to get a mbuf cluster + pkthdr.  Used by drivers to allocated
 * packets on receive ring.
 */</span>
__private_extern__ <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_getpacket_how</span>(<span class="enscript-type">int</span> wait)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_needed = 1;

	<span class="enscript-keyword">return</span> (m_getpackets_internal(&amp;num_needed, 1, wait, 1,
	    m_maxsize(MC_CL)));
}

<span class="enscript-comment">/*
 * Best effort to get a mbuf cluster + pkthdr.  Used by drivers to allocated
 * packets on receive ring.
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_getpacket</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num_needed = 1;

	<span class="enscript-keyword">return</span> (m_getpackets_internal(&amp;num_needed, 1, M_WAIT, 1,
	    m_maxsize(MC_CL)));
}

<span class="enscript-comment">/*
 * Return a list of mbuf hdrs that point to clusters.  Try for num_needed;
 * if this can't be met, return whatever number were available.  Set up the
 * first num_with_pkthdrs with mbuf hdrs configured as packet headers.  These
 * are chained on the m_nextpkt field.  Any packets requested beyond this are
 * chained onto the last packet header's m_next field.
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_getpackets</span>(<span class="enscript-type">int</span> num_needed, <span class="enscript-type">int</span> num_with_pkthdrs, <span class="enscript-type">int</span> how)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> n = num_needed;

	<span class="enscript-keyword">return</span> (m_getpackets_internal(&amp;n, num_with_pkthdrs, how, 0,
	    m_maxsize(MC_CL)));
}

<span class="enscript-comment">/*
 * Return a list of mbuf hdrs set up as packet hdrs chained together
 * on the m_nextpkt field
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_getpackethdrs</span>(<span class="enscript-type">int</span> num_needed, <span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> mbuf **np, *top;

	top = NULL;
	np = &amp;top;

	<span class="enscript-keyword">while</span> (num_needed--) {
		m = _M_RETRYHDR(how, MT_DATA);
		<span class="enscript-keyword">if</span> (m == NULL)
			<span class="enscript-keyword">break</span>;

		*np = m;
		np = &amp;m-&gt;m_nextpkt;
	}

	<span class="enscript-keyword">return</span> (top);
}

<span class="enscript-comment">/*
 * Free an mbuf list (m_nextpkt) while following m_next.  Returns the count
 * for mbufs packets freed.  Used by the drivers.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">m_freem_list</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> mbuf *nextpkt;
	mcache_obj_t *mp_list = NULL;
	mcache_obj_t *mcl_list = NULL;
	mcache_obj_t *mbc_list = NULL;
	mcache_obj_t *m16k_list = NULL;
	mcache_obj_t *m_mcl_list = NULL;
	mcache_obj_t *m_mbc_list = NULL;
	mcache_obj_t *m_m16k_list = NULL;
	mcache_obj_t *ref_list = NULL;
	<span class="enscript-type">int</span> pktcount = 0;
	<span class="enscript-type">int</span> mt_free = 0, mt_data = 0, mt_header = 0, mt_soname = 0, mt_tag = 0;

	<span class="enscript-keyword">while</span> (m != NULL) {
		pktcount++;

		nextpkt = m-&gt;m_nextpkt;
		m-&gt;m_nextpkt = NULL;

		<span class="enscript-keyword">while</span> (m != NULL) {
			<span class="enscript-type">struct</span> mbuf *next = m-&gt;m_next;
			mcache_obj_t *o, *rfa;
			u_int32_t refcnt, composite;

			<span class="enscript-keyword">if</span> (m-&gt;m_type == MT_FREE)
				panic(<span class="enscript-string">&quot;m_free: freeing an already freed mbuf&quot;</span>);

			<span class="enscript-keyword">if</span> (m-&gt;m_type != MT_FREE)
				mt_free++;

			<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR) {
				<span class="enscript-comment">/* Check for scratch area overflow */</span>
				m_redzone_verify(m);
				<span class="enscript-comment">/* Free the aux data and tags if there is any */</span>
				m_tag_delete_chain(m, NULL);
			}

			<span class="enscript-keyword">if</span> (!(m-&gt;m_flags &amp; M_EXT))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">simple_free</span>;

			o = (mcache_obj_t *)(<span class="enscript-type">void</span> *)m-&gt;m_ext.ext_buf;
			refcnt = m_decref(m);
			composite = (MEXT_FLAGS(m) &amp; EXTF_COMPOSITE);
			<span class="enscript-keyword">if</span> (refcnt == 0 &amp;&amp; !composite) {
				<span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == NULL) {
					o-&gt;obj_next = mcl_list;
					mcl_list = o;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == m_bigfree) {
					o-&gt;obj_next = mbc_list;
					mbc_list = o;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == m_16kfree) {
					o-&gt;obj_next = m16k_list;
					m16k_list = o;
				} <span class="enscript-keyword">else</span> {
					(*(m-&gt;m_ext.ext_free))((caddr_t)o,
					    m-&gt;m_ext.ext_size,
					    m-&gt;m_ext.ext_arg);
				}
				rfa = (mcache_obj_t *)(<span class="enscript-type">void</span> *)MEXT_RFA(m);
				rfa-&gt;obj_next = ref_list;
				ref_list = rfa;
				MEXT_RFA(m) = NULL;
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (refcnt == 0 &amp;&amp; composite) {
				VERIFY(m-&gt;m_type != MT_FREE);
				<span class="enscript-comment">/*
				 * Amortize the costs of atomic operations
				 * by doing them at the end, if possible.
				 */</span>
				<span class="enscript-keyword">if</span> (m-&gt;m_type == MT_DATA)
					mt_data++;
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_type == MT_HEADER)
					mt_header++;
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_type == MT_SONAME)
					mt_soname++;
				<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_type == MT_TAG)
					mt_tag++;
				<span class="enscript-keyword">else</span>
					mtype_stat_dec(m-&gt;m_type);

				m-&gt;m_type = MT_FREE;
				m-&gt;m_flags = M_EXT;
				m-&gt;m_len = 0;
				m-&gt;m_next = m-&gt;m_nextpkt = NULL;

				MEXT_FLAGS(m) &amp;= ~EXTF_READONLY;

				<span class="enscript-comment">/* &quot;Free&quot; into the intermediate cache */</span>
				o = (mcache_obj_t *)m;
				<span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == NULL) {
					o-&gt;obj_next = m_mcl_list;
					m_mcl_list = o;
				} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_ext.ext_free == m_bigfree) {
					o-&gt;obj_next = m_mbc_list;
					m_mbc_list = o;
				} <span class="enscript-keyword">else</span> {
					VERIFY(m-&gt;m_ext.ext_free == m_16kfree);
					o-&gt;obj_next = m_m16k_list;
					m_m16k_list = o;
				}
				m = next;
				<span class="enscript-keyword">continue</span>;
			}
<span class="enscript-reference">simple_free</span>:
			<span class="enscript-comment">/*
			 * Amortize the costs of atomic operations
			 * by doing them at the end, if possible.
			 */</span>
			<span class="enscript-keyword">if</span> (m-&gt;m_type == MT_DATA)
				mt_data++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_type == MT_HEADER)
				mt_header++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_type == MT_SONAME)
				mt_soname++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_type == MT_TAG)
				mt_tag++;
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_type != MT_FREE)
				mtype_stat_dec(m-&gt;m_type);

			m-&gt;m_type = MT_FREE;
			m-&gt;m_flags = m-&gt;m_len = 0;
			m-&gt;m_next = m-&gt;m_nextpkt = NULL;

			((mcache_obj_t *)m)-&gt;obj_next = mp_list;
			mp_list = (mcache_obj_t *)m;

			m = next;
		}

		m = nextpkt;
	}

	<span class="enscript-keyword">if</span> (mt_free &gt; 0)
		mtype_stat_add(MT_FREE, mt_free);
	<span class="enscript-keyword">if</span> (mt_data &gt; 0)
		mtype_stat_sub(MT_DATA, mt_data);
	<span class="enscript-keyword">if</span> (mt_header &gt; 0)
		mtype_stat_sub(MT_HEADER, mt_header);
	<span class="enscript-keyword">if</span> (mt_soname &gt; 0)
		mtype_stat_sub(MT_SONAME, mt_soname);
	<span class="enscript-keyword">if</span> (mt_tag &gt; 0)
		mtype_stat_sub(MT_TAG, mt_tag);

	<span class="enscript-keyword">if</span> (mp_list != NULL)
		mcache_free_ext(m_cache(MC_MBUF), mp_list);
	<span class="enscript-keyword">if</span> (mcl_list != NULL)
		mcache_free_ext(m_cache(MC_CL), mcl_list);
	<span class="enscript-keyword">if</span> (mbc_list != NULL)
		mcache_free_ext(m_cache(MC_BIGCL), mbc_list);
	<span class="enscript-keyword">if</span> (m16k_list != NULL)
		mcache_free_ext(m_cache(MC_16KCL), m16k_list);
	<span class="enscript-keyword">if</span> (m_mcl_list != NULL)
		mcache_free_ext(m_cache(MC_MBUF_CL), m_mcl_list);
	<span class="enscript-keyword">if</span> (m_mbc_list != NULL)
		mcache_free_ext(m_cache(MC_MBUF_BIGCL), m_mbc_list);
	<span class="enscript-keyword">if</span> (m_m16k_list != NULL)
		mcache_free_ext(m_cache(MC_MBUF_16KCL), m_m16k_list);
	<span class="enscript-keyword">if</span> (ref_list != NULL)
		mcache_free_ext(ref_cache, ref_list);

	<span class="enscript-keyword">return</span> (pktcount);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">m_freem</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-keyword">while</span> (m != NULL)
		m = m_free(m);
}

<span class="enscript-comment">/*
 * Mbuffer utility routines.
 */</span>

<span class="enscript-comment">/*
 * Compute the amount of space available before the current start
 * of data in an mbuf.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">m_leadingspace</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_EXT) {
		<span class="enscript-keyword">if</span> (MCLHASREFERENCE(m))
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-keyword">return</span> (m-&gt;m_data - m-&gt;m_ext.ext_buf);
	}
	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR)
		<span class="enscript-keyword">return</span> (m-&gt;m_data - m-&gt;m_pktdat);
	<span class="enscript-keyword">return</span> (m-&gt;m_data - m-&gt;m_dat);
}

<span class="enscript-comment">/*
 * Compute the amount of space available after the end of data in an mbuf.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">m_trailingspace</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_EXT) {
		<span class="enscript-keyword">if</span> (MCLHASREFERENCE(m))
			<span class="enscript-keyword">return</span> (0);
		<span class="enscript-keyword">return</span> (m-&gt;m_ext.ext_buf + m-&gt;m_ext.ext_size -
		    (m-&gt;m_data + m-&gt;m_len));
	}
	<span class="enscript-keyword">return</span> (&amp;m-&gt;m_dat[MLEN] - (m-&gt;m_data + m-&gt;m_len));
}

<span class="enscript-comment">/*
 * Lesser-used path for M_PREPEND: allocate new mbuf to prepend to chain,
 * copy junk along.  Does not adjust packet header length.
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_prepend</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> len, <span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> mbuf *mn;

	_MGET(mn, how, m-&gt;m_type);
	<span class="enscript-keyword">if</span> (mn == NULL) {
		m_freem(m);
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR) {
		M_COPY_PKTHDR(mn, m);
		m-&gt;m_flags &amp;= ~M_PKTHDR;
	}
	mn-&gt;m_next = m;
	m = mn;
	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR) {
		VERIFY(len &lt;= MHLEN);
		MH_ALIGN(m, len);
	} <span class="enscript-keyword">else</span> {
		VERIFY(len &lt;= MLEN);
		M_ALIGN(m, len);
	}
	m-&gt;m_len = len;
	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-comment">/*
 * Replacement for old M_PREPEND macro: allocate new mbuf to prepend to
 * chain, copy junk along, and adjust length.
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_prepend_2</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> len, <span class="enscript-type">int</span> how, <span class="enscript-type">int</span> align)
{
	<span class="enscript-keyword">if</span> (M_LEADINGSPACE(m) &gt;= len &amp;&amp;
	    (!align || IS_P2ALIGNED((m-&gt;m_data - len), <span class="enscript-keyword">sizeof</span>(u_int32_t)))) {
		m-&gt;m_data -= len;
		m-&gt;m_len += len;
	} <span class="enscript-keyword">else</span> {
		m = m_prepend(m, len, how);
	}
	<span class="enscript-keyword">if</span> ((m) &amp;&amp; (m-&gt;m_flags &amp; M_PKTHDR))
		m-&gt;m_pkthdr.len += len;
	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-comment">/*
 * Make a copy of an mbuf chain starting &quot;off0&quot; bytes from the beginning,
 * continuing for &quot;len&quot; bytes.  If len is M_COPYALL, copy to end of mbuf.
 * The wait parameter is a choice of M_WAIT/M_DONTWAIT from caller.
 */</span>
<span class="enscript-type">int</span> MCFail;

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_copym_mode</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off0, <span class="enscript-type">int</span> len, <span class="enscript-type">int</span> wait, uint32_t mode)
{
	<span class="enscript-type">struct</span> mbuf *n, *mhdr = NULL, **np;
	<span class="enscript-type">int</span> off = off0;
	<span class="enscript-type">struct</span> mbuf *top;
	<span class="enscript-type">int</span> copyhdr = 0;

	<span class="enscript-keyword">if</span> (off &lt; 0 || len &lt; 0)
		panic(<span class="enscript-string">&quot;m_copym: invalid offset %d or len %d&quot;</span>, off, len);

	VERIFY((mode != M_COPYM_MUST_COPY_HDR &amp;&amp;
	    mode != M_COPYM_MUST_MOVE_HDR) || (m-&gt;m_flags &amp; M_PKTHDR));

	<span class="enscript-keyword">if</span> ((off == 0 &amp;&amp; (m-&gt;m_flags &amp; M_PKTHDR)) ||
	    mode == M_COPYM_MUST_COPY_HDR || mode == M_COPYM_MUST_MOVE_HDR) {
		mhdr = m;
		copyhdr = 1;
	}

	<span class="enscript-keyword">while</span> (off &gt;= m-&gt;m_len) {
		<span class="enscript-keyword">if</span> (m-&gt;m_next == NULL)
			panic(<span class="enscript-string">&quot;m_copym: invalid mbuf chain&quot;</span>);
		off -= m-&gt;m_len;
		m = m-&gt;m_next;
	}
	np = &amp;top;
	top = NULL;

	<span class="enscript-keyword">while</span> (len &gt; 0) {
		<span class="enscript-keyword">if</span> (m == NULL) {
			<span class="enscript-keyword">if</span> (len != M_COPYALL)
				panic(<span class="enscript-string">&quot;m_copym: len != M_COPYALL&quot;</span>);
			<span class="enscript-keyword">break</span>;
		}

		<span class="enscript-keyword">if</span> (copyhdr)
			n = _M_RETRYHDR(wait, m-&gt;m_type);
		<span class="enscript-keyword">else</span>
			n = _M_RETRY(wait, m-&gt;m_type);
		*np = n;

		<span class="enscript-keyword">if</span> (n == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nospace</span>;

		<span class="enscript-keyword">if</span> (copyhdr != 0) {
			<span class="enscript-keyword">if</span> ((mode == M_COPYM_MOVE_HDR) ||
			    (mode == M_COPYM_MUST_MOVE_HDR)) {
				M_COPY_PKTHDR(n, mhdr);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((mode == M_COPYM_COPY_HDR) ||
			    (mode == M_COPYM_MUST_COPY_HDR)) {
				<span class="enscript-keyword">if</span> (m_dup_pkthdr(n, mhdr, wait) == 0)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">nospace</span>;
			}
			<span class="enscript-keyword">if</span> (len == M_COPYALL)
				n-&gt;m_pkthdr.len -= off0;
			<span class="enscript-keyword">else</span>
				n-&gt;m_pkthdr.len = len;
			copyhdr = 0;
			<span class="enscript-comment">/*
			 * There is data to copy from the packet header mbuf
			 * if it is empty or it is before the starting offset
			 */</span>
			<span class="enscript-keyword">if</span> (mhdr != m) {
				np = &amp;n-&gt;m_next;
				<span class="enscript-keyword">continue</span>;
			}
		}
		n-&gt;m_len = MIN(len, (m-&gt;m_len - off));
		<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_EXT) {
			n-&gt;m_ext = m-&gt;m_ext;
			m_incref(m);
			n-&gt;m_data = m-&gt;m_data + off;
			n-&gt;m_flags |= M_EXT;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Limit to the capacity of the destination
			 */</span>
			<span class="enscript-keyword">if</span> (n-&gt;m_flags &amp; M_PKTHDR)
				n-&gt;m_len = MIN(n-&gt;m_len, MHLEN);
			<span class="enscript-keyword">else</span>
				n-&gt;m_len = MIN(n-&gt;m_len, MLEN);

			<span class="enscript-keyword">if</span> (MTOD(n, <span class="enscript-type">char</span> *) + n-&gt;m_len &gt; ((<span class="enscript-type">char</span> *)n) + MSIZE)
				panic(<span class="enscript-string">&quot;%s n %p copy overflow&quot;</span>, 
					__func__, n);

			bcopy(MTOD(m, caddr_t)+off, MTOD(n, caddr_t),
			    (<span class="enscript-type">unsigned</span>)n-&gt;m_len);
		}
		<span class="enscript-keyword">if</span> (len != M_COPYALL)
			len -= n-&gt;m_len;
		off = 0;
		m = m-&gt;m_next;
		np = &amp;n-&gt;m_next;
	}

	<span class="enscript-keyword">if</span> (top == NULL)
		MCFail++;

	<span class="enscript-keyword">return</span> (top);
<span class="enscript-reference">nospace</span>:

	m_freem(top);
	MCFail++;
	<span class="enscript-keyword">return</span> (NULL);
}


<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_copym</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off0, <span class="enscript-type">int</span> len, <span class="enscript-type">int</span> wait)
{
	<span class="enscript-keyword">return</span> (m_copym_mode(m, off0, len, wait, M_COPYM_MOVE_HDR));
}

<span class="enscript-comment">/*
 * Equivalent to m_copym except that all necessary mbuf hdrs are allocated
 * within this routine also, the last mbuf and offset accessed are passed
 * out and can be passed back in to avoid having to rescan the entire mbuf
 * list (normally hung off of the socket)
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_copym_with_hdrs</span>(<span class="enscript-type">struct</span> mbuf *m0, <span class="enscript-type">int</span> off0, <span class="enscript-type">int</span> len0, <span class="enscript-type">int</span> wait,
    <span class="enscript-type">struct</span> mbuf **m_lastm, <span class="enscript-type">int</span> *m_off, uint32_t mode)
{
	<span class="enscript-type">struct</span> mbuf *m = m0, *n, **np = NULL;
	<span class="enscript-type">int</span> off = off0, len = len0;
	<span class="enscript-type">struct</span> mbuf *top = NULL;
	<span class="enscript-type">int</span> mcflags = MSLEEPF(wait);
	<span class="enscript-type">int</span> copyhdr = 0;
	<span class="enscript-type">int</span> type = 0;
	mcache_obj_t *list = NULL;
	<span class="enscript-type">int</span> needed = 0;

	<span class="enscript-keyword">if</span> (off == 0 &amp;&amp; (m-&gt;m_flags &amp; M_PKTHDR))
		copyhdr = 1;
	
	<span class="enscript-keyword">if</span> (m_lastm != NULL &amp;&amp; *m_lastm != NULL) {
		m = *m_lastm;
		off = *m_off;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">while</span> (off &gt;= m-&gt;m_len) {
			off -= m-&gt;m_len;
			m = m-&gt;m_next;
		}
	}

	n = m;
	<span class="enscript-keyword">while</span> (len &gt; 0) {
		needed++;
		ASSERT(n != NULL);
		len -= MIN(len, (n-&gt;m_len - ((needed == 1) ? off : 0)));
		n = n-&gt;m_next;
	}
	needed++;
	len = len0;

	<span class="enscript-comment">/*
	 * If the caller doesn't want to be put to sleep, mark it with
	 * MCR_TRYHARD so that we may reclaim buffers from other places
	 * before giving up.
	 */</span>
	<span class="enscript-keyword">if</span> (mcflags &amp; MCR_NOSLEEP)
		mcflags |= MCR_TRYHARD;

	<span class="enscript-keyword">if</span> (mcache_alloc_ext(m_cache(MC_MBUF), &amp;list, needed,
	    mcflags) != needed)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nospace</span>;

	needed = 0;
	<span class="enscript-keyword">while</span> (len &gt; 0) {
		n = (<span class="enscript-type">struct</span> mbuf *)list;
		list = list-&gt;obj_next;
		ASSERT(n != NULL &amp;&amp; m != NULL);

		type = (top == NULL) ? MT_HEADER : m-&gt;m_type;
		MBUF_INIT(n, (top == NULL), type);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">CONFIG_MACF_NET</span>
		<span class="enscript-keyword">if</span> (top == NULL &amp;&amp; mac_mbuf_label_init(n, wait) != 0) {
			mtype_stat_inc(MT_HEADER);
			mtype_stat_dec(MT_FREE);
			m_free(n);
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nospace</span>;
		}
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* MAC_NET */</span>

		<span class="enscript-keyword">if</span> (top == NULL) {
			top = n;
			np = &amp;top-&gt;m_next;
			<span class="enscript-keyword">continue</span>;
		} <span class="enscript-keyword">else</span> {
			needed++;
			*np = n;
		}

		<span class="enscript-keyword">if</span> (copyhdr) {
			<span class="enscript-keyword">if</span> ((mode == M_COPYM_MOVE_HDR) ||
			    (mode == M_COPYM_MUST_MOVE_HDR)) {
				M_COPY_PKTHDR(n, m);
			} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((mode == M_COPYM_COPY_HDR) ||
			    (mode == M_COPYM_MUST_COPY_HDR)) {
				<span class="enscript-keyword">if</span> (m_dup_pkthdr(n, m, wait) == 0)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">nospace</span>;
			}
			n-&gt;m_pkthdr.len = len;
			copyhdr = 0;
		}
		n-&gt;m_len = MIN(len, (m-&gt;m_len - off));

		<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_EXT) {
			n-&gt;m_ext = m-&gt;m_ext;
			m_incref(m);
			n-&gt;m_data = m-&gt;m_data + off;
			n-&gt;m_flags |= M_EXT;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-keyword">if</span> (MTOD(n, <span class="enscript-type">char</span> *) + n-&gt;m_len &gt; ((<span class="enscript-type">char</span> *)n) + MSIZE)
				panic(<span class="enscript-string">&quot;%s n %p copy overflow&quot;</span>, 
					__func__, n);

			bcopy(MTOD(m, caddr_t)+off, MTOD(n, caddr_t),
			    (<span class="enscript-type">unsigned</span>)n-&gt;m_len);
		}
		len -= n-&gt;m_len;

		<span class="enscript-keyword">if</span> (len == 0) {
			<span class="enscript-keyword">if</span> (m_lastm != NULL &amp;&amp; m_off != NULL) {
				<span class="enscript-keyword">if</span> ((off + n-&gt;m_len) == m-&gt;m_len) {
					*m_lastm = m-&gt;m_next;
					*m_off  = 0;
				} <span class="enscript-keyword">else</span> {
					*m_lastm = m;
					*m_off  = off + n-&gt;m_len;
				}
			}
			<span class="enscript-keyword">break</span>;
		}
		off = 0;
		m = m-&gt;m_next;
		np = &amp;n-&gt;m_next;
	}

	mtype_stat_inc(MT_HEADER);
	mtype_stat_add(type, needed);
	mtype_stat_sub(MT_FREE, needed + 1);

	ASSERT(list == NULL);
	<span class="enscript-keyword">return</span> (top);

<span class="enscript-reference">nospace</span>:
	<span class="enscript-keyword">if</span> (list != NULL)
		mcache_free_ext(m_cache(MC_MBUF), list);
	<span class="enscript-keyword">if</span> (top != NULL)
		m_freem(top);
	MCFail++;
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * Copy data from an mbuf chain starting &quot;off&quot; bytes from the beginning,
 * continuing for &quot;len&quot; bytes, into the indicated buffer.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">m_copydata</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> off, <span class="enscript-type">int</span> len, <span class="enscript-type">void</span> *vp)
{
	<span class="enscript-type">unsigned</span> count;
	<span class="enscript-type">char</span> *cp = vp;

	<span class="enscript-keyword">if</span> (off &lt; 0 || len &lt; 0)
		panic(<span class="enscript-string">&quot;m_copydata: invalid offset %d or len %d&quot;</span>, off, len);

	<span class="enscript-keyword">while</span> (off &gt; 0) {
		<span class="enscript-keyword">if</span> (m == NULL)
			panic(<span class="enscript-string">&quot;m_copydata: invalid mbuf chain&quot;</span>);
		<span class="enscript-keyword">if</span> (off &lt; m-&gt;m_len)
			<span class="enscript-keyword">break</span>;
		off -= m-&gt;m_len;
		m = m-&gt;m_next;
	}
	<span class="enscript-keyword">while</span> (len &gt; 0) {
		<span class="enscript-keyword">if</span> (m == NULL)
			panic(<span class="enscript-string">&quot;m_copydata: invalid mbuf chain&quot;</span>);
		count = MIN(m-&gt;m_len - off, len);
		bcopy(MTOD(m, caddr_t) + off, cp, count);
		len -= count;
		cp += count;
		off = 0;
		m = m-&gt;m_next;
	}
}

<span class="enscript-comment">/*
 * Concatenate mbuf chain n to m.  Both chains must be of the same type
 * (e.g. MT_DATA).  Any m_pkthdr is not updated.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">m_cat</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> mbuf *n)
{
	<span class="enscript-keyword">while</span> (m-&gt;m_next)
		m = m-&gt;m_next;
	<span class="enscript-keyword">while</span> (n) {
		<span class="enscript-keyword">if</span> ((m-&gt;m_flags &amp; M_EXT) ||
		    m-&gt;m_data + m-&gt;m_len + n-&gt;m_len &gt;= &amp;m-&gt;m_dat[MLEN]) {
			<span class="enscript-comment">/* just join the two chains */</span>
			m-&gt;m_next = n;
			<span class="enscript-keyword">return</span>;
		}
		<span class="enscript-comment">/* splat the data from one into the other */</span>
		bcopy(MTOD(n, caddr_t), MTOD(m, caddr_t) + m-&gt;m_len,
		    (u_int)n-&gt;m_len);
		m-&gt;m_len += n-&gt;m_len;
		n = m_free(n);
	}
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">m_adj</span>(<span class="enscript-type">struct</span> mbuf *mp, <span class="enscript-type">int</span> req_len)
{
	<span class="enscript-type">int</span> len = req_len;
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> count;

	<span class="enscript-keyword">if</span> ((m = mp) == NULL)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> (len &gt;= 0) {
		<span class="enscript-comment">/*
		 * Trim from head.
		 */</span>
		<span class="enscript-keyword">while</span> (m != NULL &amp;&amp; len &gt; 0) {
			<span class="enscript-keyword">if</span> (m-&gt;m_len &lt;= len) {
				len -= m-&gt;m_len;
				m-&gt;m_len = 0;
				m = m-&gt;m_next;
			} <span class="enscript-keyword">else</span> {
				m-&gt;m_len -= len;
				m-&gt;m_data += len;
				len = 0;
			}
		}
		m = mp;
		<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR)
			m-&gt;m_pkthdr.len -= (req_len - len);
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * Trim from tail.  Scan the mbuf chain,
		 * calculating its length and finding the last mbuf.
		 * If the adjustment only affects this mbuf, then just
		 * adjust and return.  Otherwise, rescan and truncate
		 * after the remaining size.
		 */</span>
		len = -len;
		count = 0;
		<span class="enscript-keyword">for</span> (;;) {
			count += m-&gt;m_len;
			<span class="enscript-keyword">if</span> (m-&gt;m_next == (<span class="enscript-type">struct</span> mbuf *)0)
				<span class="enscript-keyword">break</span>;
			m = m-&gt;m_next;
		}
		<span class="enscript-keyword">if</span> (m-&gt;m_len &gt;= len) {
			m-&gt;m_len -= len;
			m = mp;
			<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR)
				m-&gt;m_pkthdr.len -= len;
			<span class="enscript-keyword">return</span>;
		}
		count -= len;
		<span class="enscript-keyword">if</span> (count &lt; 0)
			count = 0;
		<span class="enscript-comment">/*
		 * Correct length for chain is &quot;count&quot;.
		 * Find the mbuf with last data, adjust its length,
		 * and toss data from remaining mbufs on chain.
		 */</span>
		m = mp;
		<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR)
			m-&gt;m_pkthdr.len = count;
		<span class="enscript-keyword">for</span> (; m; m = m-&gt;m_next) {
			<span class="enscript-keyword">if</span> (m-&gt;m_len &gt;= count) {
				m-&gt;m_len = count;
				<span class="enscript-keyword">break</span>;
			}
			count -= m-&gt;m_len;
		}
		<span class="enscript-keyword">while</span> ((m = m-&gt;m_next))
			m-&gt;m_len = 0;
	}
}

<span class="enscript-comment">/*
 * Rearange an mbuf chain so that len bytes are contiguous
 * and in the data area of an mbuf (so that mtod and dtom
 * will work for a structure of size len).  Returns the resulting
 * mbuf chain on success, frees it and returns null on failure.
 * If there is room, it will add up to max_protohdr-len extra bytes to the
 * contiguous region in an attempt to avoid being called next time.
 */</span>
<span class="enscript-type">int</span> MPFail;

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_pullup</span>(<span class="enscript-type">struct</span> mbuf *n, <span class="enscript-type">int</span> len)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> count;
	<span class="enscript-type">int</span> space;

	<span class="enscript-comment">/*
	 * If first mbuf has no cluster, and has room for len bytes
	 * without shifting current data, pullup into it,
	 * otherwise allocate a new mbuf to prepend to the chain.
	 */</span>
	<span class="enscript-keyword">if</span> ((n-&gt;m_flags &amp; M_EXT) == 0 &amp;&amp;
	    n-&gt;m_data + len &lt; &amp;n-&gt;m_dat[MLEN] &amp;&amp; n-&gt;m_next) {
		<span class="enscript-keyword">if</span> (n-&gt;m_len &gt;= len)
			<span class="enscript-keyword">return</span> (n);
		m = n;
		n = n-&gt;m_next;
		len -= m-&gt;m_len;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (len &gt; MHLEN)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		_MGET(m, M_DONTWAIT, n-&gt;m_type);
		<span class="enscript-keyword">if</span> (m == 0)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
		m-&gt;m_len = 0;
		<span class="enscript-keyword">if</span> (n-&gt;m_flags &amp; M_PKTHDR) {
			M_COPY_PKTHDR(m, n);
			n-&gt;m_flags &amp;= ~M_PKTHDR;
		}
	}
	space = &amp;m-&gt;m_dat[MLEN] - (m-&gt;m_data + m-&gt;m_len);
	<span class="enscript-keyword">do</span> {
		count = MIN(MIN(MAX(len, max_protohdr), space), n-&gt;m_len);
		bcopy(MTOD(n, caddr_t), MTOD(m, caddr_t) + m-&gt;m_len,
		    (<span class="enscript-type">unsigned</span>)count);
		len -= count;
		m-&gt;m_len += count;
		n-&gt;m_len -= count;
		space -= count;
		<span class="enscript-keyword">if</span> (n-&gt;m_len)
			n-&gt;m_data += count;
		<span class="enscript-keyword">else</span>
			n = m_free(n);
	} <span class="enscript-keyword">while</span> (len &gt; 0 &amp;&amp; n);
	<span class="enscript-keyword">if</span> (len &gt; 0) {
		(<span class="enscript-type">void</span>) m_free(m);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	m-&gt;m_next = n;
	<span class="enscript-keyword">return</span> (m);
<span class="enscript-reference">bad</span>:
	m_freem(n);
	MPFail++;
	<span class="enscript-keyword">return</span> (0);
}

<span class="enscript-comment">/*
 * Like m_pullup(), except a new mbuf is always allocated, and we allow
 * the amount of empty space before the data in the new mbuf to be specified
 * (in the event that the caller expects to prepend later).
 */</span>
__private_extern__ <span class="enscript-type">int</span> MSFail = 0;

__private_extern__ <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_copyup</span>(<span class="enscript-type">struct</span> mbuf *n, <span class="enscript-type">int</span> len, <span class="enscript-type">int</span> dstoff)
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">int</span> count, space;

	<span class="enscript-keyword">if</span> (len &gt; (MHLEN - dstoff))
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	MGET(m, M_DONTWAIT, n-&gt;m_type);
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	m-&gt;m_len = 0;
	<span class="enscript-keyword">if</span> (n-&gt;m_flags &amp; M_PKTHDR) {
		m_copy_pkthdr(m, n);
		n-&gt;m_flags &amp;= ~M_PKTHDR;
	}
	m-&gt;m_data += dstoff;
	space = &amp;m-&gt;m_dat[MLEN] - (m-&gt;m_data + m-&gt;m_len);
	<span class="enscript-keyword">do</span> {
		count = min(min(max(len, max_protohdr), space), n-&gt;m_len);
		memcpy(mtod(m, caddr_t) + m-&gt;m_len, mtod(n, caddr_t),
		    (<span class="enscript-type">unsigned</span>)count);
		len -= count;
		m-&gt;m_len += count;
		n-&gt;m_len -= count;
		space -= count;
		<span class="enscript-keyword">if</span> (n-&gt;m_len)
			n-&gt;m_data += count;
		<span class="enscript-keyword">else</span>
			n = m_free(n);
	} <span class="enscript-keyword">while</span> (len &gt; 0 &amp;&amp; n);
	<span class="enscript-keyword">if</span> (len &gt; 0) {
		(<span class="enscript-type">void</span>) m_free(m);
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">bad</span>;
	}
	m-&gt;m_next = n;
	<span class="enscript-keyword">return</span> (m);
<span class="enscript-reference">bad</span>:
	m_freem(n);
	MSFail++;
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * Partition an mbuf chain in two pieces, returning the tail --
 * all but the first len0 bytes.  In case of failure, it returns NULL and
 * attempts to restore the chain to its original state.
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_split</span>(<span class="enscript-type">struct</span> mbuf *m0, <span class="enscript-type">int</span> len0, <span class="enscript-type">int</span> wait)
{
	<span class="enscript-keyword">return</span> (m_split0(m0, len0, wait, 1));
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_split0</span>(<span class="enscript-type">struct</span> mbuf *m0, <span class="enscript-type">int</span> len0, <span class="enscript-type">int</span> wait, <span class="enscript-type">int</span> copyhdr)
{
	<span class="enscript-type">struct</span> mbuf *m, *n;
	<span class="enscript-type">unsigned</span> len = len0, remain;

	<span class="enscript-keyword">for</span> (m = m0; m &amp;&amp; len &gt; m-&gt;m_len; m = m-&gt;m_next)
		len -= m-&gt;m_len;
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span> (NULL);
	remain = m-&gt;m_len - len;
	<span class="enscript-keyword">if</span> (copyhdr &amp;&amp; (m0-&gt;m_flags &amp; M_PKTHDR)) {
		_MGETHDR(n, wait, m0-&gt;m_type);
		<span class="enscript-keyword">if</span> (n == NULL)
			<span class="enscript-keyword">return</span> (NULL);
		n-&gt;m_pkthdr.rcvif = m0-&gt;m_pkthdr.rcvif;
		n-&gt;m_pkthdr.len = m0-&gt;m_pkthdr.len - len0;
		m0-&gt;m_pkthdr.len = len0;
		<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_EXT)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">extpacket</span>;
		<span class="enscript-keyword">if</span> (remain &gt; MHLEN) {
			<span class="enscript-comment">/* m can't be the lead packet */</span>
			MH_ALIGN(n, 0);
			n-&gt;m_next = m_split(m, len, wait);
			<span class="enscript-keyword">if</span> (n-&gt;m_next == NULL) {
				(<span class="enscript-type">void</span>) m_free(n);
				<span class="enscript-keyword">return</span> (NULL);
			} <span class="enscript-keyword">else</span>
				<span class="enscript-keyword">return</span> (n);
		} <span class="enscript-keyword">else</span>
			MH_ALIGN(n, remain);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (remain == 0) {
		n = m-&gt;m_next;
		m-&gt;m_next = NULL;
		<span class="enscript-keyword">return</span> (n);
	} <span class="enscript-keyword">else</span> {
		_MGET(n, wait, m-&gt;m_type);
		<span class="enscript-keyword">if</span> (n == NULL)
			<span class="enscript-keyword">return</span> (NULL);
		M_ALIGN(n, remain);
	}
<span class="enscript-reference">extpacket</span>:
	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_EXT) {
		n-&gt;m_flags |= M_EXT;
		n-&gt;m_ext = m-&gt;m_ext;
		m_incref(m);
		n-&gt;m_data = m-&gt;m_data + len;
	} <span class="enscript-keyword">else</span> {
		bcopy(MTOD(m, caddr_t) + len, MTOD(n, caddr_t), remain);
	}
	n-&gt;m_len = remain;
	m-&gt;m_len = len;
	n-&gt;m_next = m-&gt;m_next;
	m-&gt;m_next = NULL;
	<span class="enscript-keyword">return</span> (n);
}

<span class="enscript-comment">/*
 * Routine to copy from device local memory into mbufs.
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_devget</span>(<span class="enscript-type">char</span> *buf, <span class="enscript-type">int</span> totlen, <span class="enscript-type">int</span> off0, <span class="enscript-type">struct</span> ifnet *ifp,
    <span class="enscript-type">void</span> (*copy)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *, <span class="enscript-type">void</span> *, size_t))
{
	<span class="enscript-type">struct</span> mbuf *m;
	<span class="enscript-type">struct</span> mbuf *top = NULL, **mp = &amp;top;
	<span class="enscript-type">int</span> off = off0, len;
	<span class="enscript-type">char</span> *cp;
	<span class="enscript-type">char</span> *epkt;

	cp = buf;
	epkt = cp + totlen;
	<span class="enscript-keyword">if</span> (off) {
		<span class="enscript-comment">/*
		 * If 'off' is non-zero, packet is trailer-encapsulated,
		 * so we have to skip the type and length fields.
		 */</span>
		cp += off + 2 * <span class="enscript-keyword">sizeof</span> (u_int16_t);
		totlen -= 2 * <span class="enscript-keyword">sizeof</span> (u_int16_t);
	}
	_MGETHDR(m, M_DONTWAIT, MT_DATA);
	<span class="enscript-keyword">if</span> (m == NULL)
		<span class="enscript-keyword">return</span> (NULL);
	m-&gt;m_pkthdr.rcvif = ifp;
	m-&gt;m_pkthdr.len = totlen;
	m-&gt;m_len = MHLEN;

	<span class="enscript-keyword">while</span> (totlen &gt; 0) {
		<span class="enscript-keyword">if</span> (top != NULL) {
			_MGET(m, M_DONTWAIT, MT_DATA);
			<span class="enscript-keyword">if</span> (m == NULL) {
				m_freem(top);
				<span class="enscript-keyword">return</span> (NULL);
			}
			m-&gt;m_len = MLEN;
		}
		len = MIN(totlen, epkt - cp);
		<span class="enscript-keyword">if</span> (len &gt;= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_EXT) {
				m-&gt;m_len = len = MIN(len, m_maxsize(MC_CL));
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-comment">/* give up when it's out of cluster mbufs */</span>
				<span class="enscript-keyword">if</span> (top != NULL)
					m_freem(top);
				m_freem(m);
				<span class="enscript-keyword">return</span> (NULL);
			}
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/*
			 * Place initial small packet/header at end of mbuf.
			 */</span>
			<span class="enscript-keyword">if</span> (len &lt; m-&gt;m_len) {
				<span class="enscript-keyword">if</span> (top == NULL &amp;&amp;
				    len + max_linkhdr &lt;= m-&gt;m_len)
					m-&gt;m_data += max_linkhdr;
				m-&gt;m_len = len;
			} <span class="enscript-keyword">else</span> {
				len = m-&gt;m_len;
			}
		}
		<span class="enscript-keyword">if</span> (copy)
			copy(cp, MTOD(m, caddr_t), (<span class="enscript-type">unsigned</span>)len);
		<span class="enscript-keyword">else</span>
			bcopy(cp, MTOD(m, caddr_t), (<span class="enscript-type">unsigned</span>)len);
		cp += len;
		*mp = m;
		mp = &amp;m-&gt;m_next;
		totlen -= len;
		<span class="enscript-keyword">if</span> (cp == epkt)
			cp = buf;
	}
	<span class="enscript-keyword">return</span> (top);
}

#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">MBUF_GROWTH_NORMAL_THRESH</span>
#<span class="enscript-reference">define</span>	<span class="enscript-variable-name">MBUF_GROWTH_NORMAL_THRESH</span> 25
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/*
 * Cluster freelist allocation check.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">m_howmany</span>(<span class="enscript-type">int</span> num, size_t bufsize)
{
	<span class="enscript-type">int</span> i = 0, j = 0;
	u_int32_t m_mbclusters, m_clusters, m_bigclusters, m_16kclusters;
	u_int32_t m_mbfree, m_clfree, m_bigclfree, m_16kclfree;
	u_int32_t sumclusters, freeclusters;
	u_int32_t percent_pool, percent_kmem;
	u_int32_t mb_growth, mb_growth_thresh;

	VERIFY(bufsize == m_maxsize(MC_BIGCL) ||
	    bufsize == m_maxsize(MC_16KCL));

	lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* Numbers in 2K cluster units */</span>
	m_mbclusters = m_total(MC_MBUF) &gt;&gt; NMBPCLSHIFT;
	m_clusters = m_total(MC_CL);
	m_bigclusters = m_total(MC_BIGCL) &lt;&lt; NCLPBGSHIFT;
	m_16kclusters = m_total(MC_16KCL);
	sumclusters = m_mbclusters + m_clusters + m_bigclusters;

	m_mbfree = m_infree(MC_MBUF) &gt;&gt; NMBPCLSHIFT;
	m_clfree = m_infree(MC_CL);
	m_bigclfree = m_infree(MC_BIGCL) &lt;&lt; NCLPBGSHIFT;
	m_16kclfree = m_infree(MC_16KCL);
	freeclusters = m_mbfree + m_clfree + m_bigclfree;

	<span class="enscript-comment">/* Bail if we've maxed out the mbuf memory map */</span>
	<span class="enscript-keyword">if</span> ((bufsize == m_maxsize(MC_BIGCL) &amp;&amp; sumclusters &gt;= nclusters) ||
	    (njcl &gt; 0 &amp;&amp; bufsize == m_maxsize(MC_16KCL) &amp;&amp;
	    (m_16kclusters &lt;&lt; NCLPJCLSHIFT) &gt;= njcl)) {
		<span class="enscript-keyword">return</span> (0);
	}

	<span class="enscript-keyword">if</span> (bufsize == m_maxsize(MC_BIGCL)) {
		<span class="enscript-comment">/* Under minimum */</span>
		<span class="enscript-keyword">if</span> (m_bigclusters &lt; m_minlimit(MC_BIGCL))
			<span class="enscript-keyword">return</span> (m_minlimit(MC_BIGCL) - m_bigclusters);

		percent_pool =
		    ((sumclusters - freeclusters) * 100) / sumclusters;
		percent_kmem = (sumclusters * 100) / nclusters;

		<span class="enscript-comment">/*
		 * If a light/normal user, grow conservatively (75%)
		 * If a heavy user, grow aggressively (50%)
		 */</span>
		<span class="enscript-keyword">if</span> (percent_kmem &lt; MBUF_GROWTH_NORMAL_THRESH)
			mb_growth = MB_GROWTH_NORMAL;
		<span class="enscript-keyword">else</span>
			mb_growth = MB_GROWTH_AGGRESSIVE;

		<span class="enscript-keyword">if</span> (percent_kmem &lt; 5) {
			<span class="enscript-comment">/* For initial allocations */</span>
			i = num;
		} <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">/* Return if &gt;= MBIGCL_LOWAT clusters available */</span>
			<span class="enscript-keyword">if</span> (m_infree(MC_BIGCL) &gt;= MBIGCL_LOWAT &amp;&amp;
			    m_total(MC_BIGCL) &gt;=
			    MBIGCL_LOWAT + m_minlimit(MC_BIGCL))
				<span class="enscript-keyword">return</span> (0);

			<span class="enscript-comment">/* Ensure at least num clusters are accessible */</span>
			<span class="enscript-keyword">if</span> (num &gt;= m_infree(MC_BIGCL))
				i = num - m_infree(MC_BIGCL);
			<span class="enscript-keyword">if</span> (num &gt; m_total(MC_BIGCL) - m_minlimit(MC_BIGCL))
				j = num - (m_total(MC_BIGCL) -
				    m_minlimit(MC_BIGCL));

			i = MAX(i, j);

			<span class="enscript-comment">/*
			 * Grow pool if percent_pool &gt; 75 (normal growth)
			 * or percent_pool &gt; 50 (aggressive growth).
			 */</span>
			mb_growth_thresh = 100 - (100 / (1 &lt;&lt; mb_growth));
			<span class="enscript-keyword">if</span> (percent_pool &gt; mb_growth_thresh)
				j = ((sumclusters + num) &gt;&gt; mb_growth) -
				    freeclusters;
			i = MAX(i, j);
		}

		<span class="enscript-comment">/* Check to ensure we didn't go over limits */</span>
		<span class="enscript-keyword">if</span> (i + m_bigclusters &gt;= m_maxlimit(MC_BIGCL))
			i = m_maxlimit(MC_BIGCL) - m_bigclusters;
		<span class="enscript-keyword">if</span> ((i &lt;&lt; 1) + sumclusters &gt;= nclusters)
			i = (nclusters - sumclusters) &gt;&gt; 1;
		VERIFY((m_total(MC_BIGCL) + i) &lt;= m_maxlimit(MC_BIGCL));
		VERIFY(sumclusters + (i &lt;&lt; 1) &lt;= nclusters);

	} <span class="enscript-keyword">else</span> { <span class="enscript-comment">/* 16K CL */</span>
		VERIFY(njcl &gt; 0);
		<span class="enscript-comment">/* Ensure at least num clusters are available */</span>
		<span class="enscript-keyword">if</span> (num &gt;= m_16kclfree)
			i = num - m_16kclfree;

		<span class="enscript-comment">/* Always grow 16KCL pool aggressively */</span>
		<span class="enscript-keyword">if</span> (((m_16kclusters + num) &gt;&gt; 1) &gt; m_16kclfree)
			j = ((m_16kclusters + num) &gt;&gt; 1) - m_16kclfree;
		i = MAX(i, j);

		<span class="enscript-comment">/* Check to ensure we don't go over limit */</span>
		<span class="enscript-keyword">if</span> (i + m_16kclusters &gt;= m_maxlimit(MC_16KCL))
			i = m_maxlimit(MC_16KCL) - m_16kclusters;
		VERIFY((m_total(MC_16KCL) + i) &lt;= m_maxlimit(MC_16KCL));
	}
	<span class="enscript-keyword">return</span> (i);
}
<span class="enscript-comment">/*
 * Return the number of bytes in the mbuf chain, m.
 */</span>
<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">m_length</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> mbuf *m0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> pktlen;

	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR)
		<span class="enscript-keyword">return</span> (m-&gt;m_pkthdr.len);

	pktlen = 0;
	<span class="enscript-keyword">for</span> (m0 = m; m0 != NULL; m0 = m0-&gt;m_next)
		pktlen += m0-&gt;m_len;
	<span class="enscript-keyword">return</span> (pktlen);
}

<span class="enscript-comment">/*
 * Copy data from a buffer back into the indicated mbuf chain,
 * starting &quot;off&quot; bytes from the beginning, extending the mbuf
 * chain if necessary.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">m_copyback</span>(<span class="enscript-type">struct</span> mbuf *m0, <span class="enscript-type">int</span> off, <span class="enscript-type">int</span> len, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *cp)
{
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-type">struct</span> mbuf *origm = m0;
	<span class="enscript-type">int</span> error;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

	<span class="enscript-keyword">if</span> (m0 == NULL)
		<span class="enscript-keyword">return</span>;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	error =
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>
	m_copyback0(&amp;m0, off, len, cp,
	    M_COPYBACK0_COPYBACK | M_COPYBACK0_EXTEND, M_DONTWAIT);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-keyword">if</span> (error != 0 || (m0 != NULL &amp;&amp; origm != m0))
		panic(<span class="enscript-string">&quot;m_copyback&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>
}

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_copyback_cow</span>(<span class="enscript-type">struct</span> mbuf *m0, <span class="enscript-type">int</span> off, <span class="enscript-type">int</span> len, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *cp, <span class="enscript-type">int</span> how)
{
	<span class="enscript-type">int</span> error;

	<span class="enscript-comment">/* don't support chain expansion */</span>
	VERIFY(off + len &lt;= m_length(m0));

	error = m_copyback0(&amp;m0, off, len, cp,
	    M_COPYBACK0_COPYBACK | M_COPYBACK0_COW, how);
	<span class="enscript-keyword">if</span> (error) {
		<span class="enscript-comment">/*
		 * no way to recover from partial success.
		 * just free the chain.
		 */</span>
		m_freem(m0);
		<span class="enscript-keyword">return</span> (NULL);
	}
	<span class="enscript-keyword">return</span> (m0);
}

<span class="enscript-comment">/*
 * m_makewritable: ensure the specified range writable.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">m_makewritable</span>(<span class="enscript-type">struct</span> mbuf **mp, <span class="enscript-type">int</span> off, <span class="enscript-type">int</span> len, <span class="enscript-type">int</span> how)
{
	<span class="enscript-type">int</span> error;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	<span class="enscript-type">struct</span> mbuf *n;
	<span class="enscript-type">int</span> origlen, reslen;

	origlen = m_length(*mp);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

#<span class="enscript-reference">if</span> 0 <span class="enscript-comment">/* M_COPYALL is large enough */</span>
	<span class="enscript-keyword">if</span> (len == M_COPYALL)
		len = m_length(*mp) - off; <span class="enscript-comment">/* XXX */</span>
#<span class="enscript-reference">endif</span>

	error = m_copyback0(mp, off, len, NULL,
	    M_COPYBACK0_PRESERVE | M_COPYBACK0_COW, how);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEBUG</span>
	reslen = 0;
	<span class="enscript-keyword">for</span> (n = *mp; n; n = n-&gt;m_next)
		reslen += n-&gt;m_len;
	<span class="enscript-keyword">if</span> (origlen != reslen)
		panic(<span class="enscript-string">&quot;m_makewritable: length changed&quot;</span>);
	<span class="enscript-keyword">if</span> (((*mp)-&gt;m_flags &amp; M_PKTHDR) &amp;&amp; reslen != (*mp)-&gt;m_pkthdr.len)
		panic(<span class="enscript-string">&quot;m_makewritable: inconsist&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DEBUG */</span>

	<span class="enscript-keyword">return</span> (error);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">m_copyback0</span>(<span class="enscript-type">struct</span> mbuf **mp0, <span class="enscript-type">int</span> off, <span class="enscript-type">int</span> len, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *vp, <span class="enscript-type">int</span> flags,
    <span class="enscript-type">int</span> how)
{
	<span class="enscript-type">int</span> mlen;
	<span class="enscript-type">struct</span> mbuf *m, *n;
	<span class="enscript-type">struct</span> mbuf **mp;
	<span class="enscript-type">int</span> totlen = 0;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *cp = vp;

	VERIFY(mp0 != NULL);
	VERIFY(*mp0 != NULL);
	VERIFY((flags &amp; M_COPYBACK0_PRESERVE) == 0 || cp == NULL);
	VERIFY((flags &amp; M_COPYBACK0_COPYBACK) == 0 || cp != NULL);

	<span class="enscript-comment">/*
	 * we don't bother to update &quot;totlen&quot; in the case of M_COPYBACK0_COW,
	 * assuming that M_COPYBACK0_EXTEND and M_COPYBACK0_COW are exclusive.
	 */</span>

	VERIFY((~flags &amp; (M_COPYBACK0_EXTEND|M_COPYBACK0_COW)) != 0);

	mp = mp0;
	m = *mp;
	<span class="enscript-keyword">while</span> (off &gt; (mlen = m-&gt;m_len)) {
		off -= mlen;
		totlen += mlen;
		<span class="enscript-keyword">if</span> (m-&gt;m_next == NULL) {
			<span class="enscript-type">int</span> tspace;
<span class="enscript-reference">extend</span>:
			<span class="enscript-keyword">if</span> (!(flags &amp; M_COPYBACK0_EXTEND))
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;

			<span class="enscript-comment">/*
			 * try to make some space at the end of &quot;m&quot;.
			 */</span>

			mlen = m-&gt;m_len;
			<span class="enscript-keyword">if</span> (off + len &gt;= MINCLSIZE &amp;&amp;
			    !(m-&gt;m_flags &amp; M_EXT) &amp;&amp; m-&gt;m_len == 0) {
				MCLGET(m, how);
			}
			tspace = M_TRAILINGSPACE(m);
			<span class="enscript-keyword">if</span> (tspace &gt; 0) {
				tspace = MIN(tspace, off + len);
				VERIFY(tspace &gt; 0);
				bzero(mtod(m, <span class="enscript-type">char</span> *) + m-&gt;m_len,
				    MIN(off, tspace));
				m-&gt;m_len += tspace;
				off += mlen;
				totlen -= mlen;
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/*
			 * need to allocate an mbuf.
			 */</span>

			<span class="enscript-keyword">if</span> (off + len &gt;= MINCLSIZE) {
				n = m_getcl(how, m-&gt;m_type, 0);
			} <span class="enscript-keyword">else</span> {
				n = _M_GET(how, m-&gt;m_type);
			}
			<span class="enscript-keyword">if</span> (n == NULL) {
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">out</span>;
			}
			n-&gt;m_len = 0;
			n-&gt;m_len = MIN(M_TRAILINGSPACE(n), off + len);
			bzero(mtod(n, <span class="enscript-type">char</span> *), MIN(n-&gt;m_len, off));
			m-&gt;m_next = n;
		}
		mp = &amp;m-&gt;m_next;
		m = m-&gt;m_next;
	}
	<span class="enscript-keyword">while</span> (len &gt; 0) {
		mlen = m-&gt;m_len - off;
		<span class="enscript-keyword">if</span> (mlen != 0 &amp;&amp; m_mclhasreference(m)) {
			<span class="enscript-type">char</span> *datap;
			<span class="enscript-type">int</span> eatlen;

			<span class="enscript-comment">/*
			 * this mbuf is read-only.
			 * allocate a new writable mbuf and try again.
			 */</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DIAGNOSTIC</span>
			<span class="enscript-keyword">if</span> (!(flags &amp; M_COPYBACK0_COW))
				panic(<span class="enscript-string">&quot;m_copyback0: read-only&quot;</span>);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* DIAGNOSTIC */</span>

			<span class="enscript-comment">/*
			 * if we're going to write into the middle of
			 * a mbuf, split it first.
			 */</span>
			<span class="enscript-keyword">if</span> (off &gt; 0 &amp;&amp; len &lt; mlen) {
				n = m_split0(m, off, how, 0);
				<span class="enscript-keyword">if</span> (n == NULL)
					<span class="enscript-keyword">goto</span> <span class="enscript-reference">enobufs</span>;
				m-&gt;m_next = n;
				mp = &amp;m-&gt;m_next;
				m = n;
				off = 0;
				<span class="enscript-keyword">continue</span>;
			}

			<span class="enscript-comment">/*
			 * XXX TODO coalesce into the trailingspace of
			 * the previous mbuf when possible.
			 */</span>

			<span class="enscript-comment">/*
			 * allocate a new mbuf.  copy packet header if needed.
			 */</span>
			n = _M_GET(how, m-&gt;m_type);
			<span class="enscript-keyword">if</span> (n == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">enobufs</span>;
			<span class="enscript-keyword">if</span> (off == 0 &amp;&amp; (m-&gt;m_flags &amp; M_PKTHDR)) {
				M_COPY_PKTHDR(n, m);
				n-&gt;m_len = MHLEN;
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (len &gt;= MINCLSIZE)
					MCLGET(n, M_DONTWAIT);
				n-&gt;m_len =
				    (n-&gt;m_flags &amp; M_EXT) ? MCLBYTES : MLEN;
			}
			<span class="enscript-keyword">if</span> (n-&gt;m_len &gt; len)
				n-&gt;m_len = len;

			<span class="enscript-comment">/*
			 * free the region which has been overwritten.
			 * copying data from old mbufs if requested.
			 */</span>
			<span class="enscript-keyword">if</span> (flags &amp; M_COPYBACK0_PRESERVE)
				datap = mtod(n, <span class="enscript-type">char</span> *);
			<span class="enscript-keyword">else</span>
				datap = NULL;
			eatlen = n-&gt;m_len;
			VERIFY(off == 0 || eatlen &gt;= mlen);
			<span class="enscript-keyword">if</span> (off &gt; 0) {
				VERIFY(len &gt;= mlen);
				m-&gt;m_len = off;
				m-&gt;m_next = n;
				<span class="enscript-keyword">if</span> (datap) {
					m_copydata(m, off, mlen, datap);
					datap += mlen;
				}
				eatlen -= mlen;
				mp = &amp;m-&gt;m_next;
				m = m-&gt;m_next;
			}
			<span class="enscript-keyword">while</span> (m != NULL &amp;&amp; m_mclhasreference(m) &amp;&amp;
			    n-&gt;m_type == m-&gt;m_type &amp;&amp; eatlen &gt; 0) {
				mlen = MIN(eatlen, m-&gt;m_len);
				<span class="enscript-keyword">if</span> (datap) {
					m_copydata(m, 0, mlen, datap);
					datap += mlen;
				}
				m-&gt;m_data += mlen;
				m-&gt;m_len -= mlen;
				eatlen -= mlen;
				<span class="enscript-keyword">if</span> (m-&gt;m_len == 0)
					*mp = m = m_free(m);
			}
			<span class="enscript-keyword">if</span> (eatlen &gt; 0)
				n-&gt;m_len -= eatlen;
			n-&gt;m_next = m;
			*mp = m = n;
			<span class="enscript-keyword">continue</span>;
		}
		mlen = MIN(mlen, len);
		<span class="enscript-keyword">if</span> (flags &amp; M_COPYBACK0_COPYBACK) {
			bcopy(cp, mtod(m, caddr_t) + off, (<span class="enscript-type">unsigned</span>)mlen);
			cp += mlen;
		}
		len -= mlen;
		mlen += off;
		off = 0;
		totlen += mlen;
		<span class="enscript-keyword">if</span> (len == 0)
			<span class="enscript-keyword">break</span>;
		<span class="enscript-keyword">if</span> (m-&gt;m_next == NULL) {
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">extend</span>;
		}
		mp = &amp;m-&gt;m_next;
		m = m-&gt;m_next;
	}
<span class="enscript-reference">out</span>:
	<span class="enscript-keyword">if</span> (((m = *mp0)-&gt;m_flags &amp; M_PKTHDR) &amp;&amp; (m-&gt;m_pkthdr.len &lt; totlen)) {
		VERIFY(flags &amp; M_COPYBACK0_EXTEND);
		m-&gt;m_pkthdr.len = totlen;
	}

	<span class="enscript-keyword">return</span> (0);

<span class="enscript-reference">enobufs</span>:
	<span class="enscript-keyword">return</span> (ENOBUFS);
}

uint64_t
<span class="enscript-function-name">mcl_to_paddr</span>(<span class="enscript-type">char</span> *addr)
{
	vm_offset_t base_phys;

	<span class="enscript-keyword">if</span> (!MBUF_IN_MAP(addr))
		<span class="enscript-keyword">return</span> (0);
	base_phys = mcl_paddr[atop_64(addr - (<span class="enscript-type">char</span> *)mbutl)];

	<span class="enscript-keyword">if</span> (base_phys == 0)
		<span class="enscript-keyword">return</span> (0);
	<span class="enscript-keyword">return</span> ((uint64_t)(ptoa_64(base_phys) | ((uint64_t)addr &amp; PAGE_MASK)));
}

<span class="enscript-comment">/*
 * Dup the mbuf chain passed in.  The whole thing.  No cute additional cruft.
 * And really copy the thing.  That way, we don't &quot;precompute&quot; checksums
 * for unsuspecting consumers.  Assumption: m-&gt;m_nextpkt == 0.  Trick: for
 * small packets, don't dup into a cluster.  That way received  packets
 * don't take up too much room in the sockbuf (cf. sbspace()).
 */</span>
<span class="enscript-type">int</span> MDFail;

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_dup</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> mbuf *n, **np;
	<span class="enscript-type">struct</span> mbuf *top;
	<span class="enscript-type">int</span> copyhdr = 0;

	np = &amp;top;
	top = NULL;
	<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_PKTHDR)
		copyhdr = 1;

	<span class="enscript-comment">/*
	 * Quick check: if we have one mbuf and its data fits in an
	 *  mbuf with packet header, just copy and go.
	 */</span>
	<span class="enscript-keyword">if</span> (m-&gt;m_next == NULL) {
		<span class="enscript-comment">/* Then just move the data into an mbuf and be done... */</span>
		<span class="enscript-keyword">if</span> (copyhdr) {
			<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.len &lt;= MHLEN &amp;&amp; m-&gt;m_len &lt;= MHLEN) {
				<span class="enscript-keyword">if</span> ((n = _M_GETHDR(how, m-&gt;m_type)) == NULL)
					<span class="enscript-keyword">return</span> (NULL);
				n-&gt;m_len = m-&gt;m_len;
				m_dup_pkthdr(n, m, how);
				bcopy(m-&gt;m_data, n-&gt;m_data, m-&gt;m_len);
				<span class="enscript-keyword">return</span> (n);
			}
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_len &lt;= MLEN) {
			<span class="enscript-keyword">if</span> ((n = _M_GET(how, m-&gt;m_type)) == NULL)
				<span class="enscript-keyword">return</span> (NULL);
			bcopy(m-&gt;m_data, n-&gt;m_data, m-&gt;m_len);
			n-&gt;m_len = m-&gt;m_len;
			<span class="enscript-keyword">return</span> (n);
		}
	}
	<span class="enscript-keyword">while</span> (m != NULL) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BLUE_DEBUG</span>
		kprintf(<span class="enscript-string">&quot;&lt;%x: %x, %x, %x\n&quot;</span>, m, m-&gt;m_flags, m-&gt;m_len,
		    m-&gt;m_data);
#<span class="enscript-reference">endif</span>
		<span class="enscript-keyword">if</span> (copyhdr)
			n = _M_GETHDR(how, m-&gt;m_type);
		<span class="enscript-keyword">else</span>
			n = _M_GET(how, m-&gt;m_type);
		<span class="enscript-keyword">if</span> (n == NULL)
			<span class="enscript-keyword">goto</span> <span class="enscript-reference">nospace</span>;
		<span class="enscript-keyword">if</span> (m-&gt;m_flags &amp; M_EXT) {
			<span class="enscript-keyword">if</span> (m-&gt;m_len &lt;= m_maxsize(MC_CL))
				MCLGET(n, how);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_len &lt;= m_maxsize(MC_BIGCL))
				n = m_mbigget(n, how);
			<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m-&gt;m_len &lt;= m_maxsize(MC_16KCL) &amp;&amp; njcl &gt; 0)
				n = m_m16kget(n, how);
			<span class="enscript-keyword">if</span> (!(n-&gt;m_flags &amp; M_EXT)) {
				(<span class="enscript-type">void</span>) m_free(n);
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nospace</span>;
			}
		}
		*np = n;
		<span class="enscript-keyword">if</span> (copyhdr) {
			<span class="enscript-comment">/* Don't use M_COPY_PKTHDR: preserve m_data */</span>
			m_dup_pkthdr(n, m, how);
			copyhdr = 0;
			<span class="enscript-keyword">if</span> (!(n-&gt;m_flags &amp; M_EXT))
				n-&gt;m_data = n-&gt;m_pktdat;
		}
		n-&gt;m_len = m-&gt;m_len;
		<span class="enscript-comment">/*
		 * Get the dup on the same bdry as the original
		 * Assume that the two mbufs have the same offset to data area
		 * (up to word boundaries)
		 */</span>
		bcopy(MTOD(m, caddr_t), MTOD(n, caddr_t), (<span class="enscript-type">unsigned</span>)n-&gt;m_len);
		m = m-&gt;m_next;
		np = &amp;n-&gt;m_next;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">BLUE_DEBUG</span>
		kprintf(<span class="enscript-string">&quot;&gt;%x: %x, %x, %x\n&quot;</span>, n, n-&gt;m_flags, n-&gt;m_len,
		    n-&gt;m_data);
#<span class="enscript-reference">endif</span>
	}

	<span class="enscript-keyword">if</span> (top == NULL)
		MDFail++;
	<span class="enscript-keyword">return</span> (top);

<span class="enscript-reference">nospace</span>:
	m_freem(top);
	MDFail++;
	<span class="enscript-keyword">return</span> (NULL);
}

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_MULTIPAGES</span>(m)						\
	(((m)-&gt;m_flags &amp; M_EXT) &amp;&amp;					\
	((IS_P2ALIGNED((m)-&gt;m_data, PAGE_SIZE)				\
	&amp;&amp; (m)-&gt;m_len &gt; PAGE_SIZE) ||					\
	(!IS_P2ALIGNED((m)-&gt;m_data, PAGE_SIZE) &amp;&amp;			\
	P2ROUNDUP((m)-&gt;m_data, PAGE_SIZE) &lt; ((uintptr_t)(m)-&gt;m_data + (m)-&gt;m_len))))

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_expand</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">struct</span> mbuf **last)
{
	<span class="enscript-type">struct</span> mbuf *top = NULL;
	<span class="enscript-type">struct</span> mbuf **nm = &amp;top;
	uintptr_t data0, data;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len0, len;

	VERIFY(MBUF_MULTIPAGES(m));
	VERIFY(m-&gt;m_next == NULL);
	data0 = (uintptr_t)m-&gt;m_data;
	len0 = m-&gt;m_len;
	*last = top;

	<span class="enscript-keyword">for</span> (;;) {
		<span class="enscript-type">struct</span> mbuf *n;

		data = data0;
		<span class="enscript-keyword">if</span> (IS_P2ALIGNED(data, PAGE_SIZE) &amp;&amp; len0 &gt; PAGE_SIZE)
			len = PAGE_SIZE;
		<span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (!IS_P2ALIGNED(data, PAGE_SIZE) &amp;&amp;
		    P2ROUNDUP(data, PAGE_SIZE) &lt; (data + len0))
			len = P2ROUNDUP(data, PAGE_SIZE) - data;
		<span class="enscript-keyword">else</span>
			len = len0;

		VERIFY(len &gt; 0);
		VERIFY(m-&gt;m_flags &amp; M_EXT);
		m-&gt;m_data = (<span class="enscript-type">void</span> *)data;
		m-&gt;m_len = len;

		*nm = *last = m;
		nm = &amp;m-&gt;m_next;
		m-&gt;m_next = NULL;

		data0 += len;
		len0 -= len;
		<span class="enscript-keyword">if</span> (len0 == 0)
			<span class="enscript-keyword">break</span>;

		n = _M_RETRY(M_DONTWAIT, MT_DATA);
		<span class="enscript-keyword">if</span> (n == NULL) {
			m_freem(top);
			top = *last = NULL;
			<span class="enscript-keyword">break</span>;
		}

		n-&gt;m_ext = m-&gt;m_ext;
		m_incref(m);
		n-&gt;m_flags |= M_EXT;
		m = n;
	}
	<span class="enscript-keyword">return</span> (top);
}

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_normalize</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> mbuf *top = NULL;
	<span class="enscript-type">struct</span> mbuf **nm = &amp;top;
	boolean_t expanded = FALSE;

	<span class="enscript-keyword">while</span> (m != NULL) {
		<span class="enscript-type">struct</span> mbuf *n;

		n = m-&gt;m_next;
		m-&gt;m_next = NULL;

		<span class="enscript-comment">/* Does the data cross one or more page boundaries? */</span>
		<span class="enscript-keyword">if</span> (MBUF_MULTIPAGES(m)) {
			<span class="enscript-type">struct</span> mbuf *last;
			<span class="enscript-keyword">if</span> ((m = m_expand(m, &amp;last)) == NULL) {
				m_freem(n);
				m_freem(top);
				top = NULL;
				<span class="enscript-keyword">break</span>;
			}
			*nm = m;
			nm = &amp;last-&gt;m_next;
			expanded = TRUE;
		} <span class="enscript-keyword">else</span> {
			*nm = m;
			nm = &amp;m-&gt;m_next;
		}
		m = n;
	}
	<span class="enscript-keyword">if</span> (expanded)
		atomic_add_32(&amp;mb_normalized, 1);
	<span class="enscript-keyword">return</span> (top);
}

<span class="enscript-comment">/*
 * Append the specified data to the indicated mbuf chain,
 * Extend the mbuf chain if the new data does not fit in
 * existing space.
 *
 * Return 1 if able to complete the job; otherwise 0.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">m_append</span>(<span class="enscript-type">struct</span> mbuf *m0, <span class="enscript-type">int</span> len, caddr_t cp)
{
	<span class="enscript-type">struct</span> mbuf *m, *n;
	<span class="enscript-type">int</span> remainder, space;

	<span class="enscript-keyword">for</span> (m = m0; m-&gt;m_next != NULL; m = m-&gt;m_next)
		;
	remainder = len;
	space = M_TRAILINGSPACE(m);
	<span class="enscript-keyword">if</span> (space &gt; 0) {
		<span class="enscript-comment">/*
		 * Copy into available space.
		 */</span>
		<span class="enscript-keyword">if</span> (space &gt; remainder)
			space = remainder;
		bcopy(cp, mtod(m, caddr_t) + m-&gt;m_len, space);
		m-&gt;m_len += space;
		cp += space, remainder -= space;
	}
	<span class="enscript-keyword">while</span> (remainder &gt; 0) {
		<span class="enscript-comment">/*
		 * Allocate a new mbuf; could check space
		 * and allocate a cluster instead.
		 */</span>
		n = m_get(M_WAITOK, m-&gt;m_type);
		<span class="enscript-keyword">if</span> (n == NULL)
			<span class="enscript-keyword">break</span>;
		n-&gt;m_len = min(MLEN, remainder);
		bcopy(cp, mtod(n, caddr_t), n-&gt;m_len);
		cp += n-&gt;m_len;
		remainder -= n-&gt;m_len;
		m-&gt;m_next = n;
		m = n;
	}
	<span class="enscript-keyword">if</span> (m0-&gt;m_flags &amp; M_PKTHDR)
		m0-&gt;m_pkthdr.len += len - remainder;
	<span class="enscript-keyword">return</span> (remainder == 0);
}

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_last</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-keyword">while</span> (m-&gt;m_next != NULL)
		m = m-&gt;m_next;
	<span class="enscript-keyword">return</span> (m);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">m_fixhdr</span>(<span class="enscript-type">struct</span> mbuf *m0)
{
	u_int len;

	VERIFY(m0-&gt;m_flags &amp; M_PKTHDR);

	len = m_length2(m0, NULL);
	m0-&gt;m_pkthdr.len = len;
	<span class="enscript-keyword">return</span> (len);
}

<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>
<span class="enscript-function-name">m_length2</span>(<span class="enscript-type">struct</span> mbuf *m0, <span class="enscript-type">struct</span> mbuf **last)
{
	<span class="enscript-type">struct</span> mbuf *m;
	u_int len;

	len = 0;
	<span class="enscript-keyword">for</span> (m = m0; m != NULL; m = m-&gt;m_next) {
		len += m-&gt;m_len;
		<span class="enscript-keyword">if</span> (m-&gt;m_next == NULL)
			<span class="enscript-keyword">break</span>;
	}
	<span class="enscript-keyword">if</span> (last != NULL)
		*last = m;
	<span class="enscript-keyword">return</span> (len);
}

<span class="enscript-comment">/*
 * Defragment a mbuf chain, returning the shortest possible chain of mbufs
 * and clusters.  If allocation fails and this cannot be completed, NULL will
 * be returned, but the passed in chain will be unchanged.  Upon success,
 * the original chain will be freed, and the new chain will be returned.
 *
 * If a non-packet header is passed in, the original mbuf (chain?) will
 * be returned unharmed.
 *
 * If offset is specfied, the first mbuf in the chain will have a leading
 * space of the amount stated by the &quot;off&quot; parameter.
 *
 * This routine requires that the m_pkthdr.header field of the original
 * mbuf chain is cleared by the caller.
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_defrag_offset</span>(<span class="enscript-type">struct</span> mbuf *m0, u_int32_t off, <span class="enscript-type">int</span> how)
{
	<span class="enscript-type">struct</span> mbuf *m_new = NULL, *m_final = NULL;
	<span class="enscript-type">int</span> progress = 0, length, pktlen;

	<span class="enscript-keyword">if</span> (!(m0-&gt;m_flags &amp; M_PKTHDR))
		<span class="enscript-keyword">return</span> (m0);

	VERIFY(off &lt; MHLEN);
	m_fixhdr(m0); <span class="enscript-comment">/* Needed sanity check */</span>

	pktlen = m0-&gt;m_pkthdr.len + off;
	<span class="enscript-keyword">if</span> (pktlen &gt; MHLEN)
		m_final = m_getcl(how, MT_DATA, M_PKTHDR);
	<span class="enscript-keyword">else</span>
		m_final = m_gethdr(how, MT_DATA);

	<span class="enscript-keyword">if</span> (m_final == NULL)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nospace</span>;

	<span class="enscript-keyword">if</span> (off &gt; 0) {
		pktlen -= off;
		m_final-&gt;m_data += off;
	}

	<span class="enscript-comment">/*
	 * Caller must have handled the contents pointed to by this
	 * pointer before coming here, as otherwise it will point to
	 * the original mbuf which will get freed upon success.
	 */</span>
	VERIFY(m0-&gt;m_pkthdr.pkt_hdr == NULL);

	<span class="enscript-keyword">if</span> (m_dup_pkthdr(m_final, m0, how) == 0)
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">nospace</span>;

	m_new = m_final;

	<span class="enscript-keyword">while</span> (progress &lt; pktlen) {
		length = pktlen - progress;
		<span class="enscript-keyword">if</span> (length &gt; MCLBYTES)
			length = MCLBYTES;
		length -= ((m_new == m_final) ? off : 0);

		<span class="enscript-keyword">if</span> (m_new == NULL) {
			<span class="enscript-keyword">if</span> (length &gt; MLEN)
				m_new = m_getcl(how, MT_DATA, 0);
			<span class="enscript-keyword">else</span>
				m_new = m_get(how, MT_DATA);
			<span class="enscript-keyword">if</span> (m_new == NULL)
				<span class="enscript-keyword">goto</span> <span class="enscript-reference">nospace</span>;
		}

		m_copydata(m0, progress, length, mtod(m_new, caddr_t));
		progress += length;
		m_new-&gt;m_len = length;
		<span class="enscript-keyword">if</span> (m_new != m_final)
			m_cat(m_final, m_new);
		m_new = NULL;
	}
	m_freem(m0);
	m0 = m_final;
	<span class="enscript-keyword">return</span> (m0);
<span class="enscript-reference">nospace</span>:
	<span class="enscript-keyword">if</span> (m_final)
		m_freem(m_final);
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_defrag</span>(<span class="enscript-type">struct</span> mbuf *m0, <span class="enscript-type">int</span> how)
{
	<span class="enscript-keyword">return</span> (m_defrag_offset(m0, 0, how));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">m_mchtype</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> t)
{
	mtype_stat_inc(t);
	mtype_stat_dec(m-&gt;m_type);
	(m)-&gt;m_type = t;
}

<span class="enscript-type">void</span> *
<span class="enscript-function-name">m_mtod</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-keyword">return</span> (MTOD(m, <span class="enscript-type">void</span> *));
}

<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_dtom</span>(<span class="enscript-type">void</span> *x)
{
	<span class="enscript-keyword">return</span> ((<span class="enscript-type">struct</span> mbuf *)((uintptr_t)(x) &amp; ~(MSIZE-1)));
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">m_mcheck</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	_MCHECK(m);
}

<span class="enscript-comment">/*
 * Return a pointer to mbuf/offset of location in mbuf chain.
 */</span>
<span class="enscript-type">struct</span> mbuf *
<span class="enscript-function-name">m_getptr</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> loc, <span class="enscript-type">int</span> *off)
{

	<span class="enscript-keyword">while</span> (loc &gt;= 0) {
		<span class="enscript-comment">/* Normal end of search. */</span>
		<span class="enscript-keyword">if</span> (m-&gt;m_len &gt; loc) {
			*off = loc;
			<span class="enscript-keyword">return</span> (m);
		} <span class="enscript-keyword">else</span> {
			loc -= m-&gt;m_len;
			<span class="enscript-keyword">if</span> (m-&gt;m_next == NULL) {
				<span class="enscript-keyword">if</span> (loc == 0) {
					<span class="enscript-comment">/* Point at the end of valid data. */</span>
					*off = m-&gt;m_len;
					<span class="enscript-keyword">return</span> (m);
				}
				<span class="enscript-keyword">return</span> (NULL);
			}
			m = m-&gt;m_next;
		}
	}
	<span class="enscript-keyword">return</span> (NULL);
}

<span class="enscript-comment">/*
 * Inform the corresponding mcache(s) that there's a waiter below.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_waiter_inc</span>(mbuf_class_t class, boolean_t comp)
{
	mcache_waiter_inc(m_cache(class));
	<span class="enscript-keyword">if</span> (comp) {
		<span class="enscript-keyword">if</span> (class == MC_CL) {
			mcache_waiter_inc(m_cache(MC_MBUF_CL));
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_BIGCL) {
			mcache_waiter_inc(m_cache(MC_MBUF_BIGCL));
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_16KCL) {
			mcache_waiter_inc(m_cache(MC_MBUF_16KCL));
		} <span class="enscript-keyword">else</span> {
			mcache_waiter_inc(m_cache(MC_MBUF_CL));
			mcache_waiter_inc(m_cache(MC_MBUF_BIGCL));
		}
	}
}

<span class="enscript-comment">/*
 * Inform the corresponding mcache(s) that there's no more waiter below.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_waiter_dec</span>(mbuf_class_t class, boolean_t comp)
{
	mcache_waiter_dec(m_cache(class));
	<span class="enscript-keyword">if</span> (comp) {
		<span class="enscript-keyword">if</span> (class == MC_CL) {
			mcache_waiter_dec(m_cache(MC_MBUF_CL));
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_BIGCL) {
			mcache_waiter_dec(m_cache(MC_MBUF_BIGCL));
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (class == MC_16KCL) {
			mcache_waiter_dec(m_cache(MC_MBUF_16KCL));
		} <span class="enscript-keyword">else</span> {
			mcache_waiter_dec(m_cache(MC_MBUF_CL));
			mcache_waiter_dec(m_cache(MC_MBUF_BIGCL));
		}
	}
}

<span class="enscript-comment">/*
 * Called during slab (blocking and non-blocking) allocation.  If there
 * is at least one waiter, and the time since the first waiter is blocked
 * is greater than the watchdog timeout, panic the system.
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_watchdog</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">struct</span> timeval now;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> since;

	<span class="enscript-keyword">if</span> (mb_waiters == 0 || !mb_watchdog)
		<span class="enscript-keyword">return</span>;

	microuptime(&amp;now);
	since = now.tv_sec - mb_wdtstart.tv_sec;
	<span class="enscript-keyword">if</span> (since &gt;= MB_WDT_MAXTIME) {
		panic_plain(<span class="enscript-string">&quot;%s: %d waiters stuck for %u secs\n%s&quot;</span>, __func__,
		    mb_waiters, since, mbuf_dump());
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
}

<span class="enscript-comment">/*
 * Called during blocking allocation.  Returns TRUE if one or more objects
 * are available at the per-CPU caches layer and that allocation should be
 * retried at that level.
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">mbuf_sleep</span>(mbuf_class_t class, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num, <span class="enscript-type">int</span> wait)
{
	boolean_t mcache_retry = FALSE;

	lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);

	<span class="enscript-comment">/* Check if there's anything at the cache layer */</span>
	<span class="enscript-keyword">if</span> (mbuf_cached_above(class, wait)) {
		mcache_retry = TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/* Nothing?  Then try hard to get it from somewhere */</span>
	m_reclaim(class, num, (wait &amp; MCR_COMP));

	<span class="enscript-comment">/* We tried hard and got something? */</span>
	<span class="enscript-keyword">if</span> (m_infree(class) &gt; 0) {
		mbstat.m_wait++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mbuf_cached_above(class, wait)) {
		mbstat.m_wait++;
		mcache_retry = TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (wait &amp; MCR_TRYHARD) {
		mcache_retry = TRUE;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	}

	<span class="enscript-comment">/*
	 * There's really nothing for us right now; inform the
	 * cache(s) that there is a waiter below and go to sleep.
	 */</span>
	mbuf_waiter_inc(class, (wait &amp; MCR_COMP));

	VERIFY(!(wait &amp; MCR_NOSLEEP));

	<span class="enscript-comment">/*
	 * If this is the first waiter, arm the watchdog timer.  Otherwise
	 * check if we need to panic the system due to watchdog timeout.
	 */</span>
	<span class="enscript-keyword">if</span> (mb_waiters == 0)
		microuptime(&amp;mb_wdtstart);
	<span class="enscript-keyword">else</span>
		mbuf_watchdog();

	mb_waiters++;
	(<span class="enscript-type">void</span>) msleep(mb_waitchan, mbuf_mlock, (PZERO-1), m_cname(class), NULL);

	<span class="enscript-comment">/* We are now up; stop getting notified until next round */</span>
	mbuf_waiter_dec(class, (wait &amp; MCR_COMP));

	<span class="enscript-comment">/* We waited and got something */</span>
	<span class="enscript-keyword">if</span> (m_infree(class) &gt; 0) {
		mbstat.m_wait++;
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mbuf_cached_above(class, wait)) {
		mbstat.m_wait++;
		mcache_retry = TRUE;
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (mcache_retry);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_worker_thread</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> mbuf_expand;

	<span class="enscript-keyword">while</span> (1) {
		lck_mtx_lock(mbuf_mlock);

		mbuf_expand = 0;
		<span class="enscript-keyword">if</span> (mbuf_expand_mcl) {
			<span class="enscript-type">int</span> n;

			<span class="enscript-comment">/* Adjust to current number of cluster in use */</span>
			n = mbuf_expand_mcl -
			    (m_total(MC_CL) - m_infree(MC_CL));
			<span class="enscript-keyword">if</span> ((n + m_total(MC_CL)) &gt; m_maxlimit(MC_CL))
				n = m_maxlimit(MC_CL) - m_total(MC_CL);
			mbuf_expand_mcl = 0;

			<span class="enscript-keyword">if</span> (n &gt; 0 &amp;&amp; freelist_populate(MC_CL, n, M_WAIT) &gt; 0)
				mbuf_expand++;
		}
		<span class="enscript-keyword">if</span> (mbuf_expand_big) {
			<span class="enscript-type">int</span> n;

			<span class="enscript-comment">/* Adjust to current number of 4 KB cluster in use */</span>
			n = mbuf_expand_big -
			    (m_total(MC_BIGCL) - m_infree(MC_BIGCL));
			<span class="enscript-keyword">if</span> ((n + m_total(MC_BIGCL)) &gt; m_maxlimit(MC_BIGCL))
				n = m_maxlimit(MC_BIGCL) - m_total(MC_BIGCL);
			mbuf_expand_big = 0;

			<span class="enscript-keyword">if</span> (n &gt; 0 &amp;&amp; freelist_populate(MC_BIGCL, n, M_WAIT) &gt; 0)
				mbuf_expand++;
		}
		<span class="enscript-keyword">if</span> (mbuf_expand_16k) {
			<span class="enscript-type">int</span> n;

			<span class="enscript-comment">/* Adjust to current number of 16 KB cluster in use */</span>
			n = mbuf_expand_16k -
			    (m_total(MC_16KCL) - m_infree(MC_16KCL));
			<span class="enscript-keyword">if</span> ((n + m_total(MC_16KCL)) &gt; m_maxlimit(MC_16KCL))
				n = m_maxlimit(MC_16KCL) - m_total(MC_16KCL);
			mbuf_expand_16k = 0;

			<span class="enscript-keyword">if</span> (n &gt; 0)
				(<span class="enscript-type">void</span>) freelist_populate(MC_16KCL, n, M_WAIT);
		}

		<span class="enscript-comment">/*
		 * Because we can run out of memory before filling the mbuf
		 * map, we should not allocate more clusters than they are
		 * mbufs -- otherwise we could have a large number of useless
		 * clusters allocated.
		 */</span>
		<span class="enscript-keyword">if</span> (mbuf_expand) {
			<span class="enscript-keyword">while</span> (m_total(MC_MBUF) &lt;
			    (m_total(MC_BIGCL) + m_total(MC_CL))) {
				<span class="enscript-keyword">if</span> (freelist_populate(MC_MBUF, 1, M_WAIT) == 0)
					<span class="enscript-keyword">break</span>;
			}
		}

		lck_mtx_unlock(mbuf_mlock);

		assert_wait(&amp;mbuf_worker_run, THREAD_UNINT);
		(<span class="enscript-type">void</span>) thread_block((thread_continue_t)mbuf_worker_thread);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_worker_thread_init</span>(<span class="enscript-type">void</span>)
{
	mbuf_worker_ready++;
	mbuf_worker_thread();
}

<span class="enscript-type">static</span> mcl_slab_t *
<span class="enscript-function-name">slab_get</span>(<span class="enscript-type">void</span> *buf)
{
	mcl_slabg_t *slg;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ix, k;

	lck_mtx_assert(mbuf_mlock, LCK_MTX_ASSERT_OWNED);

	VERIFY(MBUF_IN_MAP(buf));
	ix = ((<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)buf - mbutl) &gt;&gt; MBSHIFT;
	VERIFY(ix &lt; maxslabgrp);

	<span class="enscript-keyword">if</span> ((slg = slabstbl[ix]) == NULL) {
		<span class="enscript-comment">/*
		 * In the current implementation, we never shrink the slabs 
		 * table; if we attempt to reallocate a cluster group when
		 * it's already allocated, panic since this is a sign of a
		 * memory corruption (slabstbl[ix] got nullified).
		 */</span>
		++slabgrp;
		VERIFY(ix &lt; slabgrp);
		<span class="enscript-comment">/*
		 * Slabs expansion can only be done single threaded; when
		 * we get here, it must be as a result of m_clalloc() which
		 * is serialized and therefore mb_clalloc_busy must be set.
		 */</span>
		VERIFY(mb_clalloc_busy);
		lck_mtx_unlock(mbuf_mlock);

		<span class="enscript-comment">/* This is a new buffer; create the slabs group for it */</span>
		MALLOC(slg, mcl_slabg_t *, <span class="enscript-keyword">sizeof</span> (*slg), M_TEMP,
		    M_WAITOK | M_ZERO);
		MALLOC(slg-&gt;slg_slab, mcl_slab_t *, <span class="enscript-keyword">sizeof</span>(mcl_slab_t) * NSLABSPMB,
		    M_TEMP, M_WAITOK | M_ZERO);
		VERIFY(slg != NULL &amp;&amp; slg-&gt;slg_slab != NULL);

		lck_mtx_lock(mbuf_mlock);
		<span class="enscript-comment">/*
		 * No other thread could have gone into m_clalloc() after
		 * we dropped the lock above, so verify that it's true.
		 */</span>
		VERIFY(mb_clalloc_busy);

		slabstbl[ix] = slg;

		<span class="enscript-comment">/* Chain each slab in the group to its forward neighbor */</span>
		<span class="enscript-keyword">for</span> (k = 1; k &lt; NSLABSPMB; k++)
			slg-&gt;slg_slab[k - 1].sl_next = &amp;slg-&gt;slg_slab[k];
		VERIFY(slg-&gt;slg_slab[NSLABSPMB - 1].sl_next == NULL);

		<span class="enscript-comment">/* And chain the last slab in the previous group to this */</span>
		<span class="enscript-keyword">if</span> (ix &gt; 0) {
			VERIFY(slabstbl[ix - 1]-&gt;
			    slg_slab[NSLABSPMB - 1].sl_next == NULL);
			slabstbl[ix - 1]-&gt;slg_slab[NSLABSPMB - 1].sl_next =
			    &amp;slg-&gt;slg_slab[0];
		}
	}

	ix = MTOPG(buf) % NSLABSPMB;
	VERIFY(ix &lt; NSLABSPMB);

	<span class="enscript-keyword">return</span> (&amp;slg-&gt;slg_slab[ix]);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">slab_init</span>(mcl_slab_t *sp, mbuf_class_t class, u_int32_t flags,
    <span class="enscript-type">void</span> *base, <span class="enscript-type">void</span> *head, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> len, <span class="enscript-type">int</span> refcnt, <span class="enscript-type">int</span> chunks)
{
	sp-&gt;sl_class = class;
	sp-&gt;sl_flags = flags;
	sp-&gt;sl_base = base;
	sp-&gt;sl_head = head;
	sp-&gt;sl_len = len;
	sp-&gt;sl_refcnt = refcnt;
	sp-&gt;sl_chunks = chunks;
	slab_detach(sp);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">slab_insert</span>(mcl_slab_t *sp, mbuf_class_t class)
{
	VERIFY(slab_is_detached(sp));
	m_slab_cnt(class)++;
	TAILQ_INSERT_TAIL(&amp;m_slablist(class), sp, sl_link);
	sp-&gt;sl_flags &amp;= ~SLF_DETACHED;

	<span class="enscript-comment">/*
	 * If a buffer spans multiple contiguous pages then mark them as
	 * detached too
	 */</span>
	<span class="enscript-keyword">if</span> (class == MC_16KCL) {
		<span class="enscript-type">int</span> k;
		<span class="enscript-keyword">for</span> (k = 1; k &lt; NSLABSP16KB; k++) {
			sp = sp-&gt;sl_next;
			<span class="enscript-comment">/* Next slab must already be present */</span>
			VERIFY(sp != NULL &amp;&amp; slab_is_detached(sp));
			sp-&gt;sl_flags &amp;= ~SLF_DETACHED;
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">slab_remove</span>(mcl_slab_t *sp, mbuf_class_t class)
{
	<span class="enscript-type">int</span> k;
	VERIFY(!slab_is_detached(sp));
	VERIFY(m_slab_cnt(class) &gt; 0);
	m_slab_cnt(class)--;
	TAILQ_REMOVE(&amp;m_slablist(class), sp, sl_link);
	slab_detach(sp);
	<span class="enscript-keyword">if</span> (class == MC_16KCL) {
		<span class="enscript-keyword">for</span> (k = 1; k &lt; NSLABSP16KB; k++) {
			sp = sp-&gt;sl_next;
			<span class="enscript-comment">/* Next slab must already be present */</span>
			VERIFY(sp != NULL);
			VERIFY(!slab_is_detached(sp));
			slab_detach(sp);
		}
	}
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">slab_inrange</span>(mcl_slab_t *sp, <span class="enscript-type">void</span> *buf)
{
	<span class="enscript-keyword">return</span> ((uintptr_t)buf &gt;= (uintptr_t)sp-&gt;sl_base &amp;&amp;
	    (uintptr_t)buf &lt; ((uintptr_t)sp-&gt;sl_base + sp-&gt;sl_len));
}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">panic</span>

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">slab_nextptr_panic</span>(mcl_slab_t *sp, <span class="enscript-type">void</span> *addr)
{
	<span class="enscript-type">int</span> i;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> chunk_len = sp-&gt;sl_len / sp-&gt;sl_chunks;
	uintptr_t buf = (uintptr_t)sp-&gt;sl_base;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; sp-&gt;sl_chunks; i++, buf += chunk_len) {
		<span class="enscript-type">void</span> *next = ((mcache_obj_t *)buf)-&gt;obj_next;
		<span class="enscript-keyword">if</span> (next != addr)
			<span class="enscript-keyword">continue</span>;
		<span class="enscript-keyword">if</span> (!mclverify) {
			<span class="enscript-keyword">if</span> (next != NULL &amp;&amp; !MBUF_IN_MAP(next)) {
				mcache_t *cp = m_cache(sp-&gt;sl_class);
				panic(<span class="enscript-string">&quot;%s: %s buffer %p in slab %p modified &quot;</span>
				    <span class="enscript-string">&quot;after free at offset 0: %p out of range &quot;</span>
				    <span class="enscript-string">&quot;[%p-%p)\n&quot;</span>, __func__, cp-&gt;mc_name,
				    (<span class="enscript-type">void</span> *)buf, sp, next, mbutl, embutl);
				<span class="enscript-comment">/* NOTREACHED */</span>
			}
		} <span class="enscript-keyword">else</span> {
			mcache_audit_t *mca = mcl_audit_buf2mca(sp-&gt;sl_class,
			    (mcache_obj_t *)buf);
			mcl_audit_verify_nextptr(next, mca);
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">slab_detach</span>(mcl_slab_t *sp)
{
	sp-&gt;sl_link.tqe_next = (mcl_slab_t *)-1;
	sp-&gt;sl_link.tqe_prev = (mcl_slab_t **)-1;
	sp-&gt;sl_flags |= SLF_DETACHED;
}

<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">slab_is_detached</span>(mcl_slab_t *sp)
{
	<span class="enscript-keyword">return</span> ((intptr_t)sp-&gt;sl_link.tqe_next == -1 &amp;&amp;
	    (intptr_t)sp-&gt;sl_link.tqe_prev == -1 &amp;&amp;
	    (sp-&gt;sl_flags &amp; SLF_DETACHED));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcl_audit_init</span>(<span class="enscript-type">void</span> *buf, mcache_audit_t **mca_list,
    mcache_obj_t **con_list, size_t con_size, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num)
{
	mcache_audit_t *mca, *mca_tail;
	mcache_obj_t *con = NULL;
	boolean_t save_contents = (con_list != NULL);
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i, ix;

	ASSERT(num &lt;= NMBPG);
	ASSERT(con_list == NULL || con_size != 0);

	ix = MTOPG(buf);
	VERIFY(ix &lt; maxclaudit);

	<span class="enscript-comment">/* Make sure we haven't been here before */</span>
	<span class="enscript-keyword">for</span> (i = 0; i &lt; NMBPG; i++)
		VERIFY(mclaudit[ix].cl_audit[i] == NULL);

	mca = mca_tail = *mca_list;
	<span class="enscript-keyword">if</span> (save_contents)
		con = *con_list;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; num; i++) {
		mcache_audit_t *next;

		next = mca-&gt;mca_next;
		bzero(mca, <span class="enscript-keyword">sizeof</span> (*mca));
		mca-&gt;mca_next = next;
		mclaudit[ix].cl_audit[i] = mca;

		<span class="enscript-comment">/* Attach the contents buffer if requested */</span>
		<span class="enscript-keyword">if</span> (save_contents) {
			mcl_saved_contents_t *msc =
			    (mcl_saved_contents_t *)(<span class="enscript-type">void</span> *)con;

			VERIFY(msc != NULL);
			VERIFY(IS_P2ALIGNED(msc, <span class="enscript-keyword">sizeof</span> (u_int64_t)));
			VERIFY(con_size == <span class="enscript-keyword">sizeof</span> (*msc));
			mca-&gt;mca_contents_size = con_size;
			mca-&gt;mca_contents = msc;
			con = con-&gt;obj_next;
			bzero(mca-&gt;mca_contents, mca-&gt;mca_contents_size);
		}

		mca_tail = mca;
		mca = mca-&gt;mca_next;
	}

	<span class="enscript-keyword">if</span> (save_contents)
		*con_list = con;

	*mca_list = mca_tail-&gt;mca_next;
	mca_tail-&gt;mca_next = NULL;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcl_audit_free</span>(<span class="enscript-type">void</span> *buf, <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> i, ix;
	mcache_audit_t *mca, *mca_list;

	ix = MTOPG(buf);
	VERIFY(ix &lt; maxclaudit);
	
	<span class="enscript-keyword">if</span> (mclaudit[ix].cl_audit[0] != NULL) {
		mca_list = mclaudit[ix].cl_audit[0];
		<span class="enscript-keyword">for</span> (i = 0; i &lt; num; i++) {
			mca = mclaudit[ix].cl_audit[i];
			mclaudit[ix].cl_audit[i] = NULL;
			<span class="enscript-keyword">if</span> (mca-&gt;mca_contents)
				mcache_free(mcl_audit_con_cache,
				    mca-&gt;mca_contents);
		}
		mcache_free_ext(mcache_audit_cache,
		    (mcache_obj_t *)mca_list);
	}
}

<span class="enscript-comment">/*
 * Given an address of a buffer (mbuf/2KB/4KB/16KB), return
 * the corresponding audit structure for that buffer.
 */</span>
<span class="enscript-type">static</span> mcache_audit_t *
<span class="enscript-function-name">mcl_audit_buf2mca</span>(mbuf_class_t class, mcache_obj_t *mobj)
{
	mcache_audit_t *mca = NULL;
	<span class="enscript-type">int</span> ix = MTOPG(mobj), m_idx = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *page_addr;

	VERIFY(ix &lt; maxclaudit);
	VERIFY(IS_P2ALIGNED(mobj, MIN(m_maxsize(class), PAGE_SIZE)));

	page_addr = PGTOM(ix);

	<span class="enscript-keyword">switch</span> (class) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_MBUF</span>:
		<span class="enscript-comment">/*
		 * For the mbuf case, find the index of the page
		 * used by the mbuf and use that index to locate the
		 * base address of the page.  Then find out the
		 * mbuf index relative to the page base and use
		 * it to locate the audit structure.
		 */</span>
		m_idx = MBPAGEIDX(page_addr, mobj);
		VERIFY(m_idx &lt; (<span class="enscript-type">int</span>)NMBPG);
		mca = mclaudit[ix].cl_audit[m_idx];
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_CL</span>:
		<span class="enscript-comment">/*
		 * Same thing as above, but for 2KB clusters in a page.
		 */</span>
		m_idx = CLPAGEIDX(page_addr, mobj);
		VERIFY(m_idx &lt; (<span class="enscript-type">int</span>)NCLPG);
		mca = mclaudit[ix].cl_audit[m_idx];
		<span class="enscript-keyword">break</span>;

	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_BIGCL</span>:
		m_idx = BCLPAGEIDX(page_addr, mobj);
		VERIFY(m_idx &lt; (<span class="enscript-type">int</span>)NBCLPG);
		mca = mclaudit[ix].cl_audit[m_idx];
		<span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_16KCL</span>:
		<span class="enscript-comment">/*
		 * Same as above, but only return the first element.
		 */</span>
		mca = mclaudit[ix].cl_audit[0];
		<span class="enscript-keyword">break</span>;

	<span class="enscript-reference">default</span>:
		VERIFY(0);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">return</span> (mca);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcl_audit_mbuf</span>(mcache_audit_t *mca, <span class="enscript-type">void</span> *addr, boolean_t composite,
    boolean_t alloc)
{
	<span class="enscript-type">struct</span> mbuf *m = addr;
	mcache_obj_t *next = ((mcache_obj_t *)m)-&gt;obj_next;

	VERIFY(mca-&gt;mca_contents != NULL &amp;&amp;
	    mca-&gt;mca_contents_size == AUDIT_CONTENTS_SIZE);

	<span class="enscript-keyword">if</span> (mclverify)
		mcl_audit_verify_nextptr(next, mca);

	<span class="enscript-keyword">if</span> (!alloc) {
		<span class="enscript-comment">/* Save constructed mbuf fields */</span>
		mcl_audit_save_mbuf(m, mca);
		<span class="enscript-keyword">if</span> (mclverify) {
			mcache_set_pattern(MCACHE_FREE_PATTERN, m,
			    m_maxsize(MC_MBUF));
		}
		((mcache_obj_t *)m)-&gt;obj_next = next;
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/* Check if the buffer has been corrupted while in freelist */</span>
	<span class="enscript-keyword">if</span> (mclverify) {
		mcache_audit_free_verify_set(mca, addr, 0, m_maxsize(MC_MBUF));
	}
	<span class="enscript-comment">/* Restore constructed mbuf fields */</span>
	mcl_audit_restore_mbuf(m, mca, composite);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcl_audit_restore_mbuf</span>(<span class="enscript-type">struct</span> mbuf *m, mcache_audit_t *mca, boolean_t composite)
{
	<span class="enscript-type">struct</span> mbuf *ms = MCA_SAVED_MBUF_PTR(mca);

	<span class="enscript-keyword">if</span> (composite) {
		<span class="enscript-type">struct</span> mbuf *next = m-&gt;m_next;
		VERIFY(ms-&gt;m_flags == M_EXT &amp;&amp; MEXT_RFA(ms) != NULL &amp;&amp;
		    MBUF_IS_COMPOSITE(ms));
		VERIFY(mca-&gt;mca_contents_size == AUDIT_CONTENTS_SIZE);
		<span class="enscript-comment">/*
		 * We could have hand-picked the mbuf fields and restore
		 * them individually, but that will be a maintenance
		 * headache.  Instead, restore everything that was saved;
		 * the mbuf layer will recheck and reinitialize anyway.
		 */</span>
		bcopy(ms, m, MCA_SAVED_MBUF_SIZE);
		m-&gt;m_next = next;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/*
		 * For a regular mbuf (no cluster attached) there's nothing
		 * to restore other than the type field, which is expected
		 * to be MT_FREE.
		 */</span>
		m-&gt;m_type = ms-&gt;m_type;
	}
	_MCHECK(m);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcl_audit_save_mbuf</span>(<span class="enscript-type">struct</span> mbuf *m, mcache_audit_t *mca)
{
	VERIFY(mca-&gt;mca_contents_size == AUDIT_CONTENTS_SIZE);
	_MCHECK(m);
	bcopy(m, MCA_SAVED_MBUF_PTR(mca), MCA_SAVED_MBUF_SIZE);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcl_audit_cluster</span>(mcache_audit_t *mca, <span class="enscript-type">void</span> *addr, size_t size, boolean_t alloc,
    boolean_t save_next)
{
	mcache_obj_t *next = ((mcache_obj_t *)addr)-&gt;obj_next;

	<span class="enscript-keyword">if</span> (!alloc) {
		<span class="enscript-keyword">if</span> (mclverify) {
			mcache_set_pattern(MCACHE_FREE_PATTERN, addr, size);
		}
		<span class="enscript-keyword">if</span> (save_next) {
			mcl_audit_verify_nextptr(next, mca);
			((mcache_obj_t *)addr)-&gt;obj_next = next;
		}
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mclverify) {
		<span class="enscript-comment">/* Check if the buffer has been corrupted while in freelist */</span>
		mcl_audit_verify_nextptr(next, mca);
		mcache_audit_free_verify_set(mca, addr, 0, size);
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcl_audit_scratch</span>(mcache_audit_t *mca)
{
	<span class="enscript-type">void</span> *stack[MCACHE_STACK_DEPTH + 1];
	mcl_scratch_audit_t *msa;
	<span class="enscript-type">struct</span> timeval now;

	VERIFY(mca-&gt;mca_contents != NULL);
	msa = MCA_SAVED_SCRATCH_PTR(mca);

	msa-&gt;msa_pthread = msa-&gt;msa_thread;
	msa-&gt;msa_thread = current_thread();
	bcopy(msa-&gt;msa_stack, msa-&gt;msa_pstack, <span class="enscript-keyword">sizeof</span> (msa-&gt;msa_pstack));
	msa-&gt;msa_pdepth = msa-&gt;msa_depth;
	bzero(stack, <span class="enscript-keyword">sizeof</span> (stack));
	msa-&gt;msa_depth = OSBacktrace(stack, MCACHE_STACK_DEPTH + 1) - 1;
	bcopy(&amp;stack[1], msa-&gt;msa_stack, <span class="enscript-keyword">sizeof</span> (msa-&gt;msa_stack));

	msa-&gt;msa_ptstamp = msa-&gt;msa_tstamp;
	microuptime(&amp;now);
	<span class="enscript-comment">/* tstamp is in ms relative to base_ts */</span>
	msa-&gt;msa_tstamp = ((now.tv_usec - mb_start.tv_usec) / 1000);
	<span class="enscript-keyword">if</span> ((now.tv_sec - mb_start.tv_sec) &gt; 0)
		msa-&gt;msa_tstamp += ((now.tv_sec - mb_start.tv_sec) * 1000);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcl_audit_mcheck_panic</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	mcache_audit_t *mca;

	MRANGE(m);
	mca = mcl_audit_buf2mca(MC_MBUF, (mcache_obj_t *)m);

	panic(<span class="enscript-string">&quot;mcl_audit: freed mbuf %p with type 0x%x (instead of 0x%x)\n%s\n&quot;</span>,
	    m, (u_int16_t)m-&gt;m_type, MT_FREE, mcache_dump_mca(mca));
	<span class="enscript-comment">/* NOTREACHED */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mcl_audit_verify_nextptr</span>(<span class="enscript-type">void</span> *next, mcache_audit_t *mca)
{
	<span class="enscript-keyword">if</span> (next != NULL &amp;&amp; !MBUF_IN_MAP(next) &amp;&amp;
	    (next != (<span class="enscript-type">void</span> *)MCACHE_FREE_PATTERN || !mclverify)) {
		panic(<span class="enscript-string">&quot;mcl_audit: buffer %p modified after free at offset 0: &quot;</span>
		    <span class="enscript-string">&quot;%p out of range [%p-%p)\n%s\n&quot;</span>,
		    mca-&gt;mca_addr, next, mbutl, embutl, mcache_dump_mca(mca));
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
}

<span class="enscript-comment">/* This function turns on mbuf leak detection */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mleak_activate</span>(<span class="enscript-type">void</span>)
{
	mleak_table.mleak_sample_factor = MLEAK_SAMPLE_FACTOR;
	PE_parse_boot_argn(<span class="enscript-string">&quot;mleak_sample_factor&quot;</span>,
	    &amp;mleak_table.mleak_sample_factor,
	    <span class="enscript-keyword">sizeof</span> (mleak_table.mleak_sample_factor));

	<span class="enscript-keyword">if</span> (mleak_table.mleak_sample_factor == 0)
		mclfindleak = 0;

	<span class="enscript-keyword">if</span> (mclfindleak == 0)
		<span class="enscript-keyword">return</span>;

	vm_size_t alloc_size =
	    mleak_alloc_buckets * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mallocation);
	vm_size_t trace_size = mleak_trace_buckets * <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">struct</span> mtrace);

	MALLOC(mleak_allocations, <span class="enscript-type">struct</span> mallocation *, alloc_size,
	    M_TEMP, M_WAITOK | M_ZERO);
	VERIFY(mleak_allocations != NULL);

	MALLOC(mleak_traces, <span class="enscript-type">struct</span> mtrace *, trace_size,
	    M_TEMP, M_WAITOK | M_ZERO);
	VERIFY(mleak_traces != NULL);

	MALLOC(mleak_stat, mleak_stat_t *, MLEAK_STAT_SIZE(MLEAK_NUM_TRACES),
	    M_TEMP, M_WAITOK | M_ZERO);
	VERIFY(mleak_stat != NULL);
	mleak_stat-&gt;ml_cnt = MLEAK_NUM_TRACES;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
	mleak_stat-&gt;ml_isaddr64 = 1;
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* __LP64__ */</span>
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mleak_logger</span>(u_int32_t num, mcache_obj_t *addr, boolean_t alloc)
{
	<span class="enscript-type">int</span> temp;

	<span class="enscript-keyword">if</span> (mclfindleak == 0)
		<span class="enscript-keyword">return</span>;

	<span class="enscript-keyword">if</span> (!alloc)
		<span class="enscript-keyword">return</span> (mleak_free(addr));

	temp = atomic_add_32_ov(&amp;mleak_table.mleak_capture, 1);

	<span class="enscript-keyword">if</span> ((temp % mleak_table.mleak_sample_factor) == 0 &amp;&amp; addr != NULL) {
		uintptr_t bt[MLEAK_STACK_DEPTH];
		<span class="enscript-type">int</span> logged = fastbacktrace(bt, MLEAK_STACK_DEPTH);
		mleak_log(bt, addr, logged, num);
	}
}

<span class="enscript-comment">/*
 * This function records the allocation in the mleak_allocations table
 * and the backtrace in the mleak_traces table; if allocation slot is in use,
 * replace old allocation with new one if the trace slot is in use, return
 * (or increment refcount if same trace).
 */</span>
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">mleak_log</span>(uintptr_t *bt, mcache_obj_t *addr, uint32_t depth, <span class="enscript-type">int</span> num)
{
	<span class="enscript-type">struct</span> mallocation *allocation;
	<span class="enscript-type">struct</span> mtrace *trace;
	uint32_t trace_index;

	<span class="enscript-comment">/* Quit if someone else modifying the tables */</span>
	<span class="enscript-keyword">if</span> (!lck_mtx_try_lock_spin(mleak_lock)) {
		mleak_table.total_conflicts++;
		<span class="enscript-keyword">return</span> (FALSE);
	}

	allocation = &amp;mleak_allocations[hashaddr((uintptr_t)addr,
	    mleak_alloc_buckets)];
	trace_index = hashbacktrace(bt, depth, mleak_trace_buckets);
	trace = &amp;mleak_traces[trace_index];

	VERIFY(allocation &lt;= &amp;mleak_allocations[mleak_alloc_buckets - 1]);
	VERIFY(trace &lt;= &amp;mleak_traces[mleak_trace_buckets - 1]);

	allocation-&gt;hitcount++;
	trace-&gt;hitcount++;

	<span class="enscript-comment">/*
	 * If the allocation bucket we want is occupied
	 * and the occupier has the same trace, just bail.
	 */</span>
	<span class="enscript-keyword">if</span> (allocation-&gt;element != NULL &amp;&amp;
	    trace_index == allocation-&gt;trace_index) {
		mleak_table.alloc_collisions++;
		lck_mtx_unlock(mleak_lock);
		<span class="enscript-keyword">return</span> (TRUE);
	}

	<span class="enscript-comment">/*
	 * Store the backtrace in the traces array;
	 * Size of zero = trace bucket is free.
	 */</span>
	<span class="enscript-keyword">if</span> (trace-&gt;allocs &gt; 0 &amp;&amp;
	    bcmp(trace-&gt;addr, bt, (depth * <span class="enscript-keyword">sizeof</span> (uintptr_t))) != 0) {
		<span class="enscript-comment">/* Different, unique trace, but the same hash! Bail out. */</span>
		trace-&gt;collisions++;
		mleak_table.trace_collisions++;
		lck_mtx_unlock(mleak_lock);
		<span class="enscript-keyword">return</span> (TRUE);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (trace-&gt;allocs &gt; 0) {
		<span class="enscript-comment">/* Same trace, already added, so increment refcount */</span>
		trace-&gt;allocs++;
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Found an unused trace bucket, so record the trace here */</span>
		<span class="enscript-keyword">if</span> (trace-&gt;depth != 0) {
			<span class="enscript-comment">/* this slot previously used but not currently in use */</span>
			mleak_table.trace_overwrites++;
		}
		mleak_table.trace_recorded++;
		trace-&gt;allocs = 1;
		memcpy(trace-&gt;addr, bt, (depth * <span class="enscript-keyword">sizeof</span> (uintptr_t)));
		trace-&gt;depth = depth;
		trace-&gt;collisions = 0;
	}

	<span class="enscript-comment">/* Step 2: Store the allocation record in the allocations array */</span>
	<span class="enscript-keyword">if</span> (allocation-&gt;element != NULL) {
		<span class="enscript-comment">/*
		 * Replace an existing allocation.  No need to preserve
		 * because only a subset of the allocations are being
		 * recorded anyway.
		 */</span>
		mleak_table.alloc_collisions++;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (allocation-&gt;trace_index != 0) {
		mleak_table.alloc_overwrites++;
	}
	allocation-&gt;element = addr;
	allocation-&gt;trace_index = trace_index;
	allocation-&gt;count = num;
	mleak_table.alloc_recorded++;
	mleak_table.outstanding_allocs++;

	lck_mtx_unlock(mleak_lock);
	<span class="enscript-keyword">return</span> (TRUE);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mleak_free</span>(mcache_obj_t *addr)
{
	<span class="enscript-keyword">while</span> (addr != NULL) {
		<span class="enscript-type">struct</span> mallocation *allocation = &amp;mleak_allocations
		    [hashaddr((uintptr_t)addr, mleak_alloc_buckets)];

		<span class="enscript-keyword">if</span> (allocation-&gt;element == addr &amp;&amp;
		    allocation-&gt;trace_index &lt; mleak_trace_buckets) {
			lck_mtx_lock_spin(mleak_lock);
			<span class="enscript-keyword">if</span> (allocation-&gt;element == addr &amp;&amp;
			    allocation-&gt;trace_index &lt; mleak_trace_buckets) {
				<span class="enscript-type">struct</span> mtrace *trace;
				trace = &amp;mleak_traces[allocation-&gt;trace_index];
				<span class="enscript-comment">/* allocs = 0 means trace bucket is unused */</span>
				<span class="enscript-keyword">if</span> (trace-&gt;allocs &gt; 0)
					trace-&gt;allocs--;
				<span class="enscript-keyword">if</span> (trace-&gt;allocs == 0)
					trace-&gt;depth = 0;
				<span class="enscript-comment">/* NULL element means alloc bucket is unused */</span>
				allocation-&gt;element = NULL;
				mleak_table.outstanding_allocs--;
			}
			lck_mtx_unlock(mleak_lock);
		}
		addr = addr-&gt;obj_next;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mleak_sort_traces</span>()
{
	<span class="enscript-type">int</span> i, j, k;
	<span class="enscript-type">struct</span> mtrace *swap;

	<span class="enscript-keyword">for</span>(i = 0; i &lt; MLEAK_NUM_TRACES; i++)
		mleak_top_trace[i] = NULL;

	<span class="enscript-keyword">for</span>(i = 0, j = 0; j &lt; MLEAK_NUM_TRACES &amp;&amp; i &lt; mleak_trace_buckets; i++)
	{
		<span class="enscript-keyword">if</span> (mleak_traces[i].allocs &lt;= 0)
			<span class="enscript-keyword">continue</span>;

		mleak_top_trace[j] = &amp;mleak_traces[i];
		<span class="enscript-keyword">for</span> (k = j; k &gt; 0; k--) {
			<span class="enscript-keyword">if</span> (mleak_top_trace[k]-&gt;allocs &lt;=
			    mleak_top_trace[k-1]-&gt;allocs)
				<span class="enscript-keyword">break</span>;

			swap = mleak_top_trace[k-1];
			mleak_top_trace[k-1] = mleak_top_trace[k];
			mleak_top_trace[k] = swap;
		}
		j++;
	}

	j--;
	<span class="enscript-keyword">for</span>(; i &lt; mleak_trace_buckets; i++) {
		<span class="enscript-keyword">if</span> (mleak_traces[i].allocs &lt;= mleak_top_trace[j]-&gt;allocs)
			<span class="enscript-keyword">continue</span>;

		mleak_top_trace[j] = &amp;mleak_traces[i];

		<span class="enscript-keyword">for</span> (k = j; k &gt; 0; k--) {
			<span class="enscript-keyword">if</span> (mleak_top_trace[k]-&gt;allocs &lt;=
			    mleak_top_trace[k-1]-&gt;allocs)
				<span class="enscript-keyword">break</span>;

			swap = mleak_top_trace[k-1];
			mleak_top_trace[k-1] = mleak_top_trace[k];
			mleak_top_trace[k] = swap;
		}
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">mleak_update_stats</span>()
{
	mleak_trace_stat_t *mltr;
	<span class="enscript-type">int</span> i;

	VERIFY(mleak_stat != NULL);
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__LP64__</span>
	VERIFY(mleak_stat-&gt;ml_isaddr64);
#<span class="enscript-reference">else</span>
	VERIFY(!mleak_stat-&gt;ml_isaddr64);
#<span class="enscript-reference">endif</span> <span class="enscript-comment">/* !__LP64__ */</span>
	VERIFY(mleak_stat-&gt;ml_cnt == MLEAK_NUM_TRACES);

	mleak_sort_traces();

	mltr = &amp;mleak_stat-&gt;ml_trace[0];
	bzero(mltr, <span class="enscript-keyword">sizeof</span> (*mltr) * MLEAK_NUM_TRACES);
	<span class="enscript-keyword">for</span> (i = 0; i &lt; MLEAK_NUM_TRACES; i++) {
	<span class="enscript-type">int</span> j;

		<span class="enscript-keyword">if</span> (mleak_top_trace[i] == NULL ||
		    mleak_top_trace[i]-&gt;allocs == 0)
			<span class="enscript-keyword">continue</span>;

		mltr-&gt;mltr_collisions	= mleak_top_trace[i]-&gt;collisions;
		mltr-&gt;mltr_hitcount	= mleak_top_trace[i]-&gt;hitcount;
		mltr-&gt;mltr_allocs	= mleak_top_trace[i]-&gt;allocs;
		mltr-&gt;mltr_depth	= mleak_top_trace[i]-&gt;depth;

		VERIFY(mltr-&gt;mltr_depth &lt;= MLEAK_STACK_DEPTH);
		<span class="enscript-keyword">for</span> (j = 0; j &lt; mltr-&gt;mltr_depth; j++)
			mltr-&gt;mltr_addr[j] = mleak_top_trace[i]-&gt;addr[j];

		mltr++;
	}
}

<span class="enscript-type">static</span> <span class="enscript-type">struct</span> mbtypes {
	<span class="enscript-type">int</span>		mt_type;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span>	*mt_name;
} mbtypes[] = {
	{ MT_DATA,	<span class="enscript-string">&quot;data&quot;</span> },
	{ MT_OOBDATA,	<span class="enscript-string">&quot;oob data&quot;</span> },
	{ MT_CONTROL,	<span class="enscript-string">&quot;ancillary data&quot;</span> },
	{ MT_HEADER,	<span class="enscript-string">&quot;packet headers&quot;</span> },
	{ MT_SOCKET,	<span class="enscript-string">&quot;socket structures&quot;</span> },
	{ MT_PCB,	<span class="enscript-string">&quot;protocol control blocks&quot;</span> },
	{ MT_RTABLE,	<span class="enscript-string">&quot;routing table entries&quot;</span> },
	{ MT_HTABLE,	<span class="enscript-string">&quot;IMP host table entries&quot;</span> },
	{ MT_ATABLE,	<span class="enscript-string">&quot;address resolution tables&quot;</span> },
	{ MT_FTABLE,	<span class="enscript-string">&quot;fragment reassembly queue headers&quot;</span> },
	{ MT_SONAME,	<span class="enscript-string">&quot;socket names and addresses&quot;</span> },
	{ MT_SOOPTS,	<span class="enscript-string">&quot;socket options&quot;</span> },
	{ MT_RIGHTS,	<span class="enscript-string">&quot;access rights&quot;</span> },
	{ MT_IFADDR,	<span class="enscript-string">&quot;interface addresses&quot;</span> },
	{ MT_TAG,	<span class="enscript-string">&quot;packet tags&quot;</span> },
	{ 0,		NULL }
};

#<span class="enscript-reference">define</span>	<span class="enscript-function-name">MBUF_DUMP_BUF_CHK</span>() {	\
	clen -= k;		\
	<span class="enscript-keyword">if</span> (clen &lt; 1)		\
		<span class="enscript-keyword">goto</span> <span class="enscript-reference">done</span>;	\
	c += k;			\
}

<span class="enscript-type">static</span> <span class="enscript-type">char</span> *
<span class="enscript-function-name">mbuf_dump</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> totmem = 0, totfree = 0, totmbufs, totused, totpct;
	u_int32_t m_mbufs = 0, m_clfree = 0, m_bigclfree = 0;
	u_int32_t m_mbufclfree = 0, m_mbufbigclfree = 0;
	u_int32_t m_16kclusters = 0, m_16kclfree = 0, m_mbuf16kclfree = 0;
	<span class="enscript-type">int</span> nmbtypes = <span class="enscript-keyword">sizeof</span> (mbstat.m_mtypes) / <span class="enscript-keyword">sizeof</span> (<span class="enscript-type">short</span>);
	uint8_t seen[256];
	<span class="enscript-type">struct</span> mbtypes *mp;
	mb_class_stat_t *sp;
	mleak_trace_stat_t *mltr;
	<span class="enscript-type">char</span> *c = mbuf_dump_buf;
	<span class="enscript-type">int</span> i, k, clen = MBUF_DUMP_BUF_SIZE;

	mbuf_dump_buf[0] = <span class="enscript-string">'\0'</span>;

	<span class="enscript-comment">/* synchronize all statistics in the mbuf table */</span>
	mbuf_stat_sync();
	mbuf_mtypes_sync(TRUE);

	sp = &amp;mb_stat-&gt;mbs_class[0];
	<span class="enscript-keyword">for</span> (i = 0; i &lt; mb_stat-&gt;mbs_cnt; i++, sp++) {
		u_int32_t mem;

		<span class="enscript-keyword">if</span> (m_class(i) == MC_MBUF) {
			m_mbufs = sp-&gt;mbcl_active;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m_class(i) == MC_CL) {
			m_clfree = sp-&gt;mbcl_total - sp-&gt;mbcl_active;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m_class(i) == MC_BIGCL) {
			m_bigclfree = sp-&gt;mbcl_total - sp-&gt;mbcl_active;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (njcl &gt; 0 &amp;&amp; m_class(i) == MC_16KCL) {
			m_16kclfree = sp-&gt;mbcl_total - sp-&gt;mbcl_active;
			m_16kclusters = sp-&gt;mbcl_total;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m_class(i) == MC_MBUF_CL) {
			m_mbufclfree = sp-&gt;mbcl_total - sp-&gt;mbcl_active;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (m_class(i) == MC_MBUF_BIGCL) {
			m_mbufbigclfree = sp-&gt;mbcl_total - sp-&gt;mbcl_active;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (njcl &gt; 0 &amp;&amp; m_class(i) == MC_MBUF_16KCL) {
			m_mbuf16kclfree = sp-&gt;mbcl_total - sp-&gt;mbcl_active;
		}

		mem = sp-&gt;mbcl_ctotal * sp-&gt;mbcl_size;
		totmem += mem;
		totfree += (sp-&gt;mbcl_mc_cached + sp-&gt;mbcl_infree) *
		    sp-&gt;mbcl_size;

	}

	<span class="enscript-comment">/* adjust free counts to include composite caches */</span>
	m_clfree += m_mbufclfree;
	m_bigclfree += m_mbufbigclfree;
	m_16kclfree += m_mbuf16kclfree;

	totmbufs = 0;
	<span class="enscript-keyword">for</span> (mp = mbtypes; mp-&gt;mt_name != NULL; mp++)
		totmbufs += mbstat.m_mtypes[mp-&gt;mt_type];
	<span class="enscript-keyword">if</span> (totmbufs &gt; m_mbufs)
		totmbufs = m_mbufs;
	k = snprintf(c, clen, <span class="enscript-string">&quot;%lu/%u mbufs in use:\n&quot;</span>, totmbufs, m_mbufs);
	MBUF_DUMP_BUF_CHK();

	bzero(&amp;seen, <span class="enscript-keyword">sizeof</span> (seen));
	<span class="enscript-keyword">for</span> (mp = mbtypes; mp-&gt;mt_name != NULL; mp++) {
		<span class="enscript-keyword">if</span> (mbstat.m_mtypes[mp-&gt;mt_type] != 0) {
			seen[mp-&gt;mt_type] = 1;
			k = snprintf(c, clen, <span class="enscript-string">&quot;\t%u mbufs allocated to %s\n&quot;</span>,
			    mbstat.m_mtypes[mp-&gt;mt_type], mp-&gt;mt_name);
			MBUF_DUMP_BUF_CHK();
		}
	}
	seen[MT_FREE] = 1;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; nmbtypes; i++)
		<span class="enscript-keyword">if</span> (!seen[i] &amp;&amp; mbstat.m_mtypes[i] != 0) {
			k = snprintf(c, clen, <span class="enscript-string">&quot;\t%u mbufs allocated to &quot;</span>
			    <span class="enscript-string">&quot;&lt;mbuf type %d&gt;\n&quot;</span>, mbstat.m_mtypes[i], i);
			MBUF_DUMP_BUF_CHK();
		}
	<span class="enscript-keyword">if</span> ((m_mbufs - totmbufs) &gt; 0) {
		k = snprintf(c, clen, <span class="enscript-string">&quot;\t%lu mbufs allocated to caches\n&quot;</span>,
		    m_mbufs - totmbufs);
		MBUF_DUMP_BUF_CHK();
	}
	k = snprintf(c, clen, <span class="enscript-string">&quot;%u/%u mbuf 2KB clusters in use\n&quot;</span>
	    <span class="enscript-string">&quot;%u/%u mbuf 4KB clusters in use\n&quot;</span>,
	    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(mbstat.m_clusters - m_clfree),
	    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)mbstat.m_clusters,
	    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)(mbstat.m_bigclusters - m_bigclfree),
	    (<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span>)mbstat.m_bigclusters);
	MBUF_DUMP_BUF_CHK();

	<span class="enscript-keyword">if</span> (njcl &gt; 0) {
		k = snprintf(c, clen, <span class="enscript-string">&quot;%u/%u mbuf %uKB clusters in use\n&quot;</span>,
		    m_16kclusters - m_16kclfree, m_16kclusters,
		    njclbytes / 1024);
		MBUF_DUMP_BUF_CHK();
	}
	totused = totmem - totfree;
	<span class="enscript-keyword">if</span> (totmem == 0) {
		totpct = 0;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (totused &lt; (ULONG_MAX / 100)) {
		totpct = (totused * 100) / totmem;
	} <span class="enscript-keyword">else</span> {
		u_long totmem1 = totmem / 100;
		u_long totused1 = totused / 100;
		totpct = (totused1 * 100) / totmem1;
	}
	k = snprintf(c, clen, <span class="enscript-string">&quot;%lu KB allocated to network (approx. %lu%% &quot;</span>
	    <span class="enscript-string">&quot;in use)\n&quot;</span>, totmem / 1024, totpct);
	MBUF_DUMP_BUF_CHK();

	<span class="enscript-comment">/* mbuf leak detection statistics */</span>
	mleak_update_stats();

	k = snprintf(c, clen, <span class="enscript-string">&quot;\nmbuf leak detection table:\n&quot;</span>);
	MBUF_DUMP_BUF_CHK();
	k = snprintf(c, clen, <span class="enscript-string">&quot;\ttotal captured: %u (one per %u)\n&quot;</span>,
	    mleak_table.mleak_capture / mleak_table.mleak_sample_factor,
	    mleak_table.mleak_sample_factor);
	MBUF_DUMP_BUF_CHK();
	k = snprintf(c, clen, <span class="enscript-string">&quot;\ttotal allocs outstanding: %llu\n&quot;</span>,
	    mleak_table.outstanding_allocs);
	MBUF_DUMP_BUF_CHK();
	k = snprintf(c, clen, <span class="enscript-string">&quot;\tnew hash recorded: %llu allocs, %llu traces\n&quot;</span>,
	    mleak_table.alloc_recorded, mleak_table.trace_recorded);
	MBUF_DUMP_BUF_CHK();
	k = snprintf(c, clen, <span class="enscript-string">&quot;\thash collisions: %llu allocs, %llu traces\n&quot;</span>,
	    mleak_table.alloc_collisions, mleak_table.trace_collisions);
	MBUF_DUMP_BUF_CHK();
	k = snprintf(c, clen, <span class="enscript-string">&quot;\toverwrites: %llu allocs, %llu traces\n&quot;</span>,
	    mleak_table.alloc_overwrites, mleak_table.trace_overwrites);
	MBUF_DUMP_BUF_CHK();
	k = snprintf(c, clen, <span class="enscript-string">&quot;\tlock conflicts: %llu\n\n&quot;</span>,
	    mleak_table.total_conflicts);
	MBUF_DUMP_BUF_CHK();

	k = snprintf(c, clen, <span class="enscript-string">&quot;top %d outstanding traces:\n&quot;</span>,
	    mleak_stat-&gt;ml_cnt);
	MBUF_DUMP_BUF_CHK();
	<span class="enscript-keyword">for</span> (i = 0; i &lt; mleak_stat-&gt;ml_cnt; i++) {
		mltr = &amp;mleak_stat-&gt;ml_trace[i];
		k = snprintf(c, clen, <span class="enscript-string">&quot;[%d] %llu outstanding alloc(s), &quot;</span>
		    <span class="enscript-string">&quot;%llu hit(s), %llu collision(s)\n&quot;</span>, (i + 1),
		    mltr-&gt;mltr_allocs, mltr-&gt;mltr_hitcount,
		    mltr-&gt;mltr_collisions);
		MBUF_DUMP_BUF_CHK();
	}

	<span class="enscript-keyword">if</span> (mleak_stat-&gt;ml_isaddr64)
		k = snprintf(c, clen, MB_LEAK_HDR_64);
	<span class="enscript-keyword">else</span>
		k = snprintf(c, clen, MB_LEAK_HDR_32);
	MBUF_DUMP_BUF_CHK();

	<span class="enscript-keyword">for</span> (i = 0; i &lt; MLEAK_STACK_DEPTH; i++) {
		<span class="enscript-type">int</span> j;
		k = snprintf(c, clen, <span class="enscript-string">&quot;%2d: &quot;</span>, (i + 1));
		MBUF_DUMP_BUF_CHK();
		<span class="enscript-keyword">for</span> (j = 0; j &lt; mleak_stat-&gt;ml_cnt; j++) {
			mltr = &amp;mleak_stat-&gt;ml_trace[j];
			<span class="enscript-keyword">if</span> (i &lt; mltr-&gt;mltr_depth) {
				<span class="enscript-keyword">if</span> (mleak_stat-&gt;ml_isaddr64) {
					k = snprintf(c, clen, <span class="enscript-string">&quot;0x%0llx  &quot;</span>,
					    (uint64_t)VM_KERNEL_UNSLIDE(
						mltr-&gt;mltr_addr[i]));
				} <span class="enscript-keyword">else</span> {
					k = snprintf(c, clen,
					    <span class="enscript-string">&quot;0x%08x  &quot;</span>,
					    (uint32_t)VM_KERNEL_UNSLIDE(
						mltr-&gt;mltr_addr[i]));
				}
			} <span class="enscript-keyword">else</span> {
				<span class="enscript-keyword">if</span> (mleak_stat-&gt;ml_isaddr64)
					k = snprintf(c, clen,
					    MB_LEAK_SPACING_64);
				<span class="enscript-keyword">else</span>
					k = snprintf(c, clen,
					    MB_LEAK_SPACING_32);
			}
			MBUF_DUMP_BUF_CHK();
		}
		k = snprintf(c, clen, <span class="enscript-string">&quot;\n&quot;</span>);
		MBUF_DUMP_BUF_CHK();
	}
<span class="enscript-reference">done</span>:
	<span class="enscript-keyword">return</span> (mbuf_dump_buf);
}

#<span class="enscript-reference">undef</span> <span class="enscript-variable-name">MBUF_DUMP_BUF_CHK</span>

<span class="enscript-comment">/*
 * Convert between a regular and a packet header mbuf.  Caller is responsible
 * for setting or clearing M_PKTHDR; this routine does the rest of the work.
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">m_reinit</span>(<span class="enscript-type">struct</span> mbuf *m, <span class="enscript-type">int</span> hdr)
{
	<span class="enscript-type">int</span> ret = 0;

	<span class="enscript-keyword">if</span> (hdr) {
		VERIFY(!(m-&gt;m_flags &amp; M_PKTHDR));
		<span class="enscript-keyword">if</span> (!(m-&gt;m_flags &amp; M_EXT) &amp;&amp;
		    (m-&gt;m_data != m-&gt;m_dat || m-&gt;m_len &gt; 0)) {
			<span class="enscript-comment">/*
			 * If there's no external cluster attached and the
			 * mbuf appears to contain user data, we cannot
			 * safely convert this to a packet header mbuf,
			 * as the packet header structure might overlap
			 * with the data.
			 */</span>
			printf(<span class="enscript-string">&quot;%s: cannot set M_PKTHDR on altered mbuf %llx, &quot;</span>
			    <span class="enscript-string">&quot;m_data %llx (expected %llx), &quot;</span>
			    <span class="enscript-string">&quot;m_len %d (expected 0)\n&quot;</span>,
			    __func__,
			    (uint64_t)VM_KERNEL_ADDRPERM(m),
			    (uint64_t)VM_KERNEL_ADDRPERM(m-&gt;m_data),
			    (uint64_t)VM_KERNEL_ADDRPERM(m-&gt;m_dat), m-&gt;m_len);
			ret = EBUSY;
		} <span class="enscript-keyword">else</span> {
			VERIFY((m-&gt;m_flags &amp; M_EXT) || m-&gt;m_data == m-&gt;m_dat);
			m-&gt;m_flags |= M_PKTHDR;
			MBUF_INIT_PKTHDR(m);
		}
	} <span class="enscript-keyword">else</span> {
		<span class="enscript-comment">/* Check for scratch area overflow */</span>
		m_redzone_verify(m);
		<span class="enscript-comment">/* Free the aux data and tags if there is any */</span>
		m_tag_delete_chain(m, NULL);
		m-&gt;m_flags &amp;= ~M_PKTHDR;
	}

	<span class="enscript-keyword">return</span> (ret);
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">m_scratch_init</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	<span class="enscript-type">struct</span> pkthdr *pkt = &amp;m-&gt;m_pkthdr;

	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	<span class="enscript-comment">/* See comments in &lt;rdar://problem/14040693&gt; */</span>
	<span class="enscript-keyword">if</span> (pkt-&gt;pkt_flags &amp; PKTF_PRIV_GUARDED) {
		panic_plain(<span class="enscript-string">&quot;Invalid attempt to modify guarded module-private &quot;</span>
		    <span class="enscript-string">&quot;area: mbuf %p, pkt_flags 0x%x\n&quot;</span>, m, pkt-&gt;pkt_flags);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	bzero(&amp;pkt-&gt;pkt_mpriv, <span class="enscript-keyword">sizeof</span> (pkt-&gt;pkt_mpriv));
}

<span class="enscript-comment">/*
 * This routine is reserved for mbuf_get_driver_scratch(); clients inside
 * xnu that intend on utilizing the module-private area should directly
 * refer to the pkt_mpriv structure in the pkthdr.  They are also expected
 * to set and clear PKTF_PRIV_GUARDED, while owning the packet and prior
 * to handing it off to another module, respectively.
 */</span>
u_int32_t
<span class="enscript-function-name">m_scratch_get</span>(<span class="enscript-type">struct</span> mbuf *m, u_int8_t **p)
{
	<span class="enscript-type">struct</span> pkthdr *pkt = &amp;m-&gt;m_pkthdr;

	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	<span class="enscript-comment">/* See comments in &lt;rdar://problem/14040693&gt; */</span>
	<span class="enscript-keyword">if</span> (pkt-&gt;pkt_flags &amp; PKTF_PRIV_GUARDED) {
		panic_plain(<span class="enscript-string">&quot;Invalid attempt to access guarded module-private &quot;</span>
		    <span class="enscript-string">&quot;area: mbuf %p, pkt_flags 0x%x\n&quot;</span>, m, pkt-&gt;pkt_flags);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}

	<span class="enscript-keyword">if</span> (mcltrace) {
		mcache_audit_t *mca;

		lck_mtx_lock(mbuf_mlock);
		mca = mcl_audit_buf2mca(MC_MBUF, (mcache_obj_t *)m);
		<span class="enscript-keyword">if</span> (mca-&gt;mca_uflags &amp; MB_SCVALID)
			mcl_audit_scratch(mca);
		lck_mtx_unlock(mbuf_mlock);
	}

	*p = (u_int8_t *)&amp;pkt-&gt;pkt_mpriv;
	<span class="enscript-keyword">return</span> (<span class="enscript-keyword">sizeof</span> (pkt-&gt;pkt_mpriv));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">m_redzone_init</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);
	<span class="enscript-comment">/*
	 * Each mbuf has a unique red zone pattern, which is a XOR
	 * of the red zone cookie and the address of the mbuf.
	 */</span>
	m-&gt;m_pkthdr.redzone = ((u_int32_t)(uintptr_t)m) ^ mb_redzone_cookie;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span>
<span class="enscript-function-name">m_redzone_verify</span>(<span class="enscript-type">struct</span> mbuf *m)
{
	u_int32_t mb_redzone;

	VERIFY(m-&gt;m_flags &amp; M_PKTHDR);

	mb_redzone = ((u_int32_t)(uintptr_t)m) ^ mb_redzone_cookie;
	<span class="enscript-keyword">if</span> (m-&gt;m_pkthdr.redzone != mb_redzone) {
		panic(<span class="enscript-string">&quot;mbuf %p redzone violation with value 0x%x &quot;</span>
		    <span class="enscript-string">&quot;(instead of 0x%x, using cookie 0x%x)\n&quot;</span>,
		    m, m-&gt;m_pkthdr.redzone, mb_redzone, mb_redzone_cookie);
		<span class="enscript-comment">/* NOTREACHED */</span>
	}
}

<span class="enscript-comment">/*
 * Send a report of mbuf usage if the usage is at least 6% of max limit
 * or if there has been at least 3% increase since the last report.
 *
 * The values 6% and 3% are chosen so that we can do simple arithmetic
 * with shift operations.
 */</span> 
<span class="enscript-type">static</span> boolean_t
<span class="enscript-function-name">mbuf_report_usage</span>(mbuf_class_t cl)
{
	<span class="enscript-comment">/* if a report is already in progress, nothing to do */</span>
	<span class="enscript-keyword">if</span> (mb_peak_newreport)
		<span class="enscript-keyword">return</span> (TRUE);

	<span class="enscript-keyword">if</span> (m_total(cl) &gt; m_peak(cl) &amp;&amp;
	    m_total(cl) &gt;= (m_maxlimit(cl) &gt;&gt; 4) &amp;&amp;
	    (m_total(cl) - m_peak(cl)) &gt;= (m_peak(cl) &gt;&gt; 5))
		<span class="enscript-keyword">return</span> (TRUE);
	<span class="enscript-keyword">return</span> (FALSE);
}

__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">mbuf_report_peak_usage</span>(<span class="enscript-type">void</span>)
{
	<span class="enscript-type">int</span> i = 0; 
	u_int64_t uptime;
	<span class="enscript-type">struct</span> nstat_sysinfo_data ns_data;
	uint32_t memreleased = 0;

	uptime = net_uptime();
	lck_mtx_lock(mbuf_mlock);

	<span class="enscript-comment">/* Generate an initial report after 1 week of uptime */</span>
	<span class="enscript-keyword">if</span> (!mb_peak_firstreport &amp;&amp; 
	    uptime &gt; MBUF_PEAK_FIRST_REPORT_THRESHOLD) {
		mb_peak_newreport = TRUE;
		mb_peak_firstreport = TRUE;
	}

	<span class="enscript-keyword">if</span> (!mb_peak_newreport) {
		lck_mtx_unlock(mbuf_mlock);
		<span class="enscript-keyword">return</span>;
	}

	<span class="enscript-comment">/*
	 * Since a report is being generated before 1 week, 
	 * we do not need to force another one later
	 */</span>
	<span class="enscript-keyword">if</span> (uptime &lt; MBUF_PEAK_FIRST_REPORT_THRESHOLD)
		mb_peak_firstreport = TRUE;

	<span class="enscript-keyword">for</span> (i = 0; i &lt; NELEM(mbuf_table); i++) {
		m_peak(m_class(i)) = m_total(m_class(i));
		memreleased += m_release_cnt(i);
		m_release_cnt(i) = 0;
	}
	mb_peak_newreport = FALSE;
	lck_mtx_unlock(mbuf_mlock);

	bzero(&amp;ns_data, <span class="enscript-keyword">sizeof</span>(ns_data));
	ns_data.flags = NSTAT_SYSINFO_MBUF_STATS;
	ns_data.u.mb_stats.total_256b = m_peak(MC_MBUF);
	ns_data.u.mb_stats.total_2kb = m_peak(MC_CL);
	ns_data.u.mb_stats.total_4kb = m_peak(MC_BIGCL);
	ns_data.u.mb_stats.total_16kb = m_peak(MC_16KCL);
	ns_data.u.mb_stats.sbmb_total = total_sbmb_cnt_peak;
	ns_data.u.mb_stats.sb_atmbuflimit = sbmb_limreached;
	ns_data.u.mb_stats.draincnt = mbstat.m_drain;
	ns_data.u.mb_stats.memreleased = memreleased;

	nstat_sysinfo_send_data(&amp;ns_data);
}

<span class="enscript-comment">/*
 * Called by the VM when there's memory pressure.
 */</span>
__private_extern__ <span class="enscript-type">void</span>
<span class="enscript-function-name">m_drain</span>(<span class="enscript-type">void</span>)
{
	mbuf_class_t mc;
	mcl_slab_t *sp, *sp_tmp, *nsp;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> num, k, interval, released = 0;
	<span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> total_mem = 0, use_mem = 0;
	boolean_t ret, purge_caches = FALSE;
	ppnum_t offset;
	mcache_obj_t *obj;
	<span class="enscript-type">float</span> per;
	<span class="enscript-type">static</span> uint64_t last_drain = 0;
	<span class="enscript-type">static</span> <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> scratch[32];
	<span class="enscript-type">static</span> ppnum_t scratch_pa = 0;

	<span class="enscript-keyword">if</span> (mb_drain_maxint == 0 || mb_waiters)
		<span class="enscript-keyword">return</span>;
	<span class="enscript-keyword">if</span> (scratch_pa == 0) {
		bzero(scratch, <span class="enscript-keyword">sizeof</span>(scratch));
		scratch_pa = pmap_find_phys(kernel_pmap, (addr64_t)scratch);
		VERIFY(scratch_pa);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (mclverify) {
		<span class="enscript-comment">/*
		 * Panic if a driver wrote to our scratch memory.
		 */</span>
		<span class="enscript-keyword">for</span> (k = 0; k &lt; <span class="enscript-keyword">sizeof</span>(scratch); k++)
			<span class="enscript-keyword">if</span> (scratch[k])
				panic(<span class="enscript-string">&quot;suspect DMA to freed address&quot;</span>);
	}
	<span class="enscript-comment">/*
	 * Don't free memory too often as that could cause excessive
	 * waiting times for mbufs.  Purge caches if we were asked to drain
	 * in the last 5 minutes.
	 */</span>
	lck_mtx_lock(mbuf_mlock);
	<span class="enscript-keyword">if</span> (last_drain == 0) {
		last_drain = net_uptime();
		lck_mtx_unlock(mbuf_mlock);
		<span class="enscript-keyword">return</span>;
	}
	interval = net_uptime() - last_drain; 
	<span class="enscript-keyword">if</span> (interval &lt;= mb_drain_maxint) {
		lck_mtx_unlock(mbuf_mlock);
		<span class="enscript-keyword">return</span>;
	} 
	<span class="enscript-keyword">if</span> (interval &lt;= mb_drain_maxint * 5)
		purge_caches = TRUE;
	last_drain = net_uptime();
	<span class="enscript-comment">/*
	 * Don't free any memory if we're using 60% or more.
	 */</span>
	<span class="enscript-keyword">for</span> (mc = 0; mc &lt; NELEM(mbuf_table); mc++) {
		total_mem += m_total(mc) * m_maxsize(mc);
		use_mem += m_active(mc) * m_maxsize(mc);
	}
	per = (<span class="enscript-type">float</span>)use_mem / (<span class="enscript-type">float</span>)total_mem;
	<span class="enscript-keyword">if</span> (per &gt;= 0.6) {
		lck_mtx_unlock(mbuf_mlock);
		<span class="enscript-keyword">return</span>;
	}
	<span class="enscript-comment">/*
	 * Purge all the caches.  This effectively disables
	 * caching for a few seconds, but the mbuf worker thread will
	 * re-enable them again.
	 */</span>
	<span class="enscript-keyword">if</span> (purge_caches == TRUE)
		<span class="enscript-keyword">for</span> (mc = 0; mc &lt; NELEM(mbuf_table); mc++) {
			<span class="enscript-keyword">if</span> (m_total(mc) &lt; m_avgtotal(mc))
				<span class="enscript-keyword">continue</span>;
			lck_mtx_unlock(mbuf_mlock);
			ret = mcache_purge_cache(m_cache(mc), FALSE);
			lck_mtx_lock(mbuf_mlock);
			<span class="enscript-keyword">if</span> (ret == TRUE)
				m_purge_cnt(mc)++;
		}
	<span class="enscript-comment">/*
	 * Move the objects from the composite class freelist to
	 * the rudimentary slabs list, but keep at least 10% of the average
	 * total in the freelist.
	 */</span>
	<span class="enscript-keyword">for</span> (mc = 0; mc &lt; NELEM(mbuf_table); mc++) {
		<span class="enscript-keyword">while</span> (m_cobjlist(mc) &amp;&amp; 
		    m_total(mc) &lt; m_avgtotal(mc) &amp;&amp;
		    m_infree(mc) &gt; 0.1 * m_avgtotal(mc) + m_minlimit(mc)) {
			obj = m_cobjlist(mc);
			m_cobjlist(mc) = obj-&gt;obj_next;
			obj-&gt;obj_next = NULL;
			num = cslab_free(mc, obj, 1);
			VERIFY(num == 1);
			m_free_cnt(mc)++;
			m_infree(mc)--;
			<span class="enscript-comment">/* cslab_free() handles m_total */</span>
		}
	}
	<span class="enscript-comment">/*
	 * Free the buffers present in the slab list up to 10% of the total
	 * average per class.
	 *
	 * We walk the list backwards in an attempt to reduce fragmentation.
	 */</span>
	<span class="enscript-keyword">for</span> (mc = NELEM(mbuf_table) - 1; (<span class="enscript-type">int</span>)mc &gt;= 0; mc--) {
		TAILQ_FOREACH_SAFE(sp, &amp;m_slablist(mc), sl_link, sp_tmp) {
			<span class="enscript-comment">/*
			 * Process only unused slabs occupying memory.
			 */</span>
			<span class="enscript-keyword">if</span> (sp-&gt;sl_refcnt != 0 || sp-&gt;sl_len == 0 ||
			    sp-&gt;sl_base == NULL)
				<span class="enscript-keyword">continue</span>;
			<span class="enscript-keyword">if</span> (m_total(mc) &lt; m_avgtotal(mc) ||
			    m_infree(mc) &lt; 0.1 * m_avgtotal(mc) + m_minlimit(mc))
				<span class="enscript-keyword">break</span>;
			slab_remove(sp, mc);
			<span class="enscript-keyword">switch</span> (mc) {
			<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_MBUF</span>:
				m_infree(mc) -= NMBPG;
				m_total(mc) -= NMBPG;
				<span class="enscript-keyword">if</span> (mclaudit != NULL)
					mcl_audit_free(sp-&gt;sl_base, NMBPG);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_CL</span>:
				m_infree(mc) -= NCLPG;
				m_total(mc) -= NCLPG;
				<span class="enscript-keyword">if</span> (mclaudit != NULL)
					mcl_audit_free(sp-&gt;sl_base, NMBPG);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_BIGCL</span>:
			{
				m_infree(mc) -= NBCLPG;
				m_total(mc) -= NBCLPG;
				<span class="enscript-keyword">if</span> (mclaudit != NULL)
					mcl_audit_free(sp-&gt;sl_base, NMBPG);
				<span class="enscript-keyword">break</span>;
			}
			<span class="enscript-keyword">case</span> <span class="enscript-reference">MC_16KCL</span>:
				m_infree(mc)--;
				m_total(mc)--;
				<span class="enscript-keyword">for</span> (nsp = sp, k = 1; k &lt; NSLABSP16KB; k++) {
					nsp = nsp-&gt;sl_next;
					VERIFY(nsp-&gt;sl_refcnt == 0 &amp;&amp; 
					    nsp-&gt;sl_base != NULL &amp;&amp;
					    nsp-&gt;sl_len == 0);
					slab_init(nsp, 0, 0, NULL, NULL, 0, 0,
					    0);
					nsp-&gt;sl_flags = 0;
				}
				<span class="enscript-keyword">if</span> (mclaudit != NULL)
					mcl_audit_free(sp-&gt;sl_base, 1);
				<span class="enscript-keyword">break</span>;
			<span class="enscript-reference">default</span>:
				<span class="enscript-comment">/*
				 * The composite classes have their own
				 * freelist (m_cobjlist), so we only
				 * process rudimentary classes here.
				 */</span>
				VERIFY(0);
			}
			m_release_cnt(mc) += m_size(mc);
			released += m_size(mc);
			VERIFY(sp-&gt;sl_base != NULL &amp;&amp;
			    sp-&gt;sl_len &gt;= PAGE_SIZE);
			offset = MTOPG(sp-&gt;sl_base);
			<span class="enscript-comment">/*
			 * Make sure the IOMapper points to a valid, but
			 * bogus, address.  This should prevent further DMA
			 * accesses to freed memory.
			 */</span>
			IOMapperInsertPage(mcl_paddr_base, offset, scratch_pa);
			mcl_paddr[offset] = 0;
			kmem_free(mb_map, (vm_offset_t)sp-&gt;sl_base, 
			    sp-&gt;sl_len);
			slab_init(sp, 0, 0, NULL, NULL, 0, 0, 0);
			sp-&gt;sl_flags = 0;
		}
	}
	mbstat.m_drain++;
	mbstat.m_bigclusters = m_total(MC_BIGCL);
	mbstat.m_clusters = m_total(MC_CL);
	mbstat.m_mbufs = m_total(MC_MBUF);
	mbuf_stat_sync();
	mbuf_mtypes_sync(TRUE);
	lck_mtx_unlock(mbuf_mlock);
}

<span class="enscript-type">static</span> <span class="enscript-type">int</span>
m_drain_force_sysctl SYSCTL_HANDLER_ARGS
{
#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">unused</span>(<span class="enscript-variable-name">arg1</span>, <span class="enscript-variable-name">arg2</span>)
	<span class="enscript-type">int</span> val = 0, err;
	
	err = sysctl_handle_int(oidp, &amp;val, 0, req);
	<span class="enscript-keyword">if</span> (err != 0 || req-&gt;newptr == USER_ADDR_NULL)
		<span class="enscript-keyword">return</span> (err);
	<span class="enscript-keyword">if</span> (val)
		m_drain();

	<span class="enscript-keyword">return</span> (err);
}

<span class="enscript-function-name">SYSCTL_DECL</span>(_kern_ipc);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_ipc, KIPC_MBSTAT, mbstat,
    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED,
    0, 0, mbstat_sysctl, <span class="enscript-string">&quot;S,mbstat&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_ipc, OID_AUTO, mb_stat,
    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED,
    0, 0, mb_stat_sysctl, <span class="enscript-string">&quot;S,mb_stat&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_ipc, OID_AUTO, mleak_top_trace,
    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED,
    0, 0, mleak_top_trace_sysctl, <span class="enscript-string">&quot;S,mb_top_trace&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_ipc, OID_AUTO, mleak_table,
    CTLTYPE_STRUCT | CTLFLAG_RD | CTLFLAG_LOCKED,
    0, 0, mleak_table_sysctl, <span class="enscript-string">&quot;S,mleak_table&quot;</span>, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, mleak_sample_factor,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;mleak_table.mleak_sample_factor, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, mb_normalized,
    CTLFLAG_RD | CTLFLAG_LOCKED, &amp;mb_normalized, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, mb_watchdog,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;mb_watchdog, 0, <span class="enscript-string">&quot;&quot;</span>);
<span class="enscript-function-name">SYSCTL_PROC</span>(_kern_ipc, OID_AUTO, mb_drain_force,
    CTLTYPE_INT | CTLFLAG_RW | CTLFLAG_LOCKED, NULL, 0, 
    m_drain_force_sysctl, <span class="enscript-string">&quot;I&quot;</span>,
    <span class="enscript-string">&quot;Forces the mbuf garbage collection to run&quot;</span>);
<span class="enscript-function-name">SYSCTL_INT</span>(_kern_ipc, OID_AUTO, mb_drain_maxint,
    CTLFLAG_RW | CTLFLAG_LOCKED, &amp;mb_drain_maxint, 0,
    <span class="enscript-string">&quot;Minimum time interval between garbage collection&quot;</span>);
</pre>
<hr />
</body></html>